void sub_19E3E7A0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,void *a62,uint64_t a63)
{
  void *a65;
  char a70;
  char a72;
  void *a73;
  uint64_t v73;
  void *v75;
  void *v76;

  sub_19E3EB09C(&a31);
  v75 = *(void **)(v73 - 184);
  if (v75)
  {
    *(void *)(v73 - 176) = v75;
    operator delete(v75);
  }
  sub_19E401594((const void **)&STACK[0x228]);
  if (a50 < 0) {
    operator delete(__p);
  }
  sub_19E3EB09C((void **)(v73 - 240));
  v76 = *(void **)(v73 - 208);
  if (v76)
  {
    *(void *)(v73 - 200) = v76;
    operator delete(v76);
  }
  if (a61 < 0) {
    operator delete(a56);
  }
  sub_19E3C3B0C(&a62);
  if (a72)
  {
    if (a70 < 0) {
      operator delete(a65);
    }
  }
  sub_19E3C3B0C(&a73);
  _Unwind_Resume(a1);
}

void *sub_19E3E7F78()
{
  return &unk_1EF0B4C68;
}

uint64_t sub_19E3E7F84(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v126ToucanLanguageModelSession21_multiWordCompletionsERKNS0_17LinguisticCont"
                     "extERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmmPK14__CFDictionarybbRNS5_12basic"
                     "_stringIcNS5_11char_traitsIcEENS8_IcEEEERKNS5_8functionIFbvEEEE3$_0"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v126ToucanLanguageModelSession21_multiWordCompletionsERKNS0_17Lin"
                                "guisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmmPK14__CFDi"
                                "ctionarybbRNS5_12basic_stringIcNS5_11char_traitsIcEENS8_IcEEEERKNS5_8functionIFbvEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v126ToucanLanguageModelSession21_multiWordCompletionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmmPK14__CFDictionarybbRNS5_12basic_stringIcNS5_11char_traitsIcEENS8_IcEEEERKNS5_8functionIFbvEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v126ToucanLanguageModelSession21_multiWordCompletionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmmPK14__CFDictionarybbRNS5_12basic_stringIcNS5_11char_traitsIcEENS8_IcEEEERKNS5_8functionIFbvEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E3E7FDC(uint64_t a1, language_modeling::v1::InlineCompletion *a2)
{
  unint64_t v3 = *(void **)(a1 + 8);
  v4 = (language_modeling::v1::InlineCompletion *)v3[1];
  unint64_t v5 = v3[2];
  if ((unint64_t)v4 < v5) {
    language_modeling::v1::InlineCompletion::InlineCompletion(v4, a2);
  }
  uint64_t v6 = (uint64_t)v4 - *v3;
  unint64_t v7 = (v6 >> 3) + 1;
  if (!(v7 >> 61))
  {
    uint64_t v8 = v5 - *v3;
    uint64_t v9 = v8 >> 2;
    if (v8 >> 2 <= v7) {
      uint64_t v9 = (v6 >> 3) + 1;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10)
    {
      if (v10 >> 61) {
        sub_19E37C2B8();
      }
      v11 = (char *)operator new(8 * v10);
    }
    else
    {
      v11 = 0;
    }
    language_modeling::v1::InlineCompletion::InlineCompletion((language_modeling::v1::InlineCompletion *)&v11[8 * (v6 >> 3)], a2);
  }
  sub_19E37C7C4();
}

uint64_t sub_19E3E81D4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5710;
  a2[1] = v2;
  return result;
}

void *sub_19E3E81F8(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5710;
  result[1] = v3;
  return result;
}

void sub_19E3E8240()
{
}

uint64_t sub_19E3E8258(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a4;
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = a5 - a4;
  uint64_t v7 = (a5 - a4) >> 5;
  unint64_t v8 = (a3 - a2) >> 5;
  if (v8 + v7 >= 8)
  {
    v13 = 0;
    v14 = 0;
    unint64_t v15 = 0;
    sub_19E3C39E4(&v13, a2, a3, v8);
    if (v6 >= 0x40)
    {
      unint64_t v9 = (unint64_t)v14;
      uint64_t v10 = 32 * v7 - 32 * (v7 != 0);
      do
      {
        if (v9 < v15)
        {
          if (*(char *)(v5 + 23) < 0)
          {
            sub_19E39369C((unsigned char *)v9, *(void **)v5, *(void *)(v5 + 8));
          }
          else
          {
            long long v11 = *(_OWORD *)v5;
            *(void *)(v9 + 16) = *(void *)(v5 + 16);
            *(_OWORD *)unint64_t v9 = v11;
          }
          *(_DWORD *)(v9 + 24) = *(_DWORD *)(v5 + 24);
          v9 += 32;
        }
        else
        {
          unint64_t v9 = sub_19E3EAEDC((char **)&v13, v5);
        }
        v14 = (void *)v9;
        v5 += 32;
        v10 -= 32;
      }
      while (v10);
    }
    size_t __n = 1;
    __src = (void *)32;
    std::__sort<std::__less<char,char> &,char *>();
    size_t v20 = __n;
    v19[0] = 0;
    if (__n < 0x11)
    {
      memcpy(v19, &__src, __n);
      size_t v43 = v20;
      v42.__locale_ = 0;
      if (v20 < 0x11)
      {
        memcpy(&v42, v19, v20);
        size_t v22 = v43;
        __dst[0] = 0;
        if (v43 <= 0x10)
        {
          memcpy(__dst, &v42, v43);
          int v23 = 1;
          size_t v34 = v22;
          v33[0] = 0;
          if (v22 < 0x11)
          {
            memcpy(v33, __dst, v22);
            int v35 = 1;
            size_t v37 = v34;
            __p[0] = 0;
            if (v34 < 0x11)
            {
              memcpy(__p, v33, v34);
              int v38 = 1;
              size_t v25 = v37;
              v24[0] = 0;
              if (v37 < 0x11)
              {
                memcpy(v24, __p, v37);
                LODWORD(v26) = 1;
                uint64_t v16 = 0;
                size_t v28 = v25;
                v27[0] = 0;
                if (v25 < 0x11)
                {
                  memcpy(v27, v24, v25);
                  LODWORD(v29) = 1;
                  size_t v31 = v28;
                  v30[0] = 0;
                  if (v28 < 0x11)
                  {
                    memcpy(v30, v27, v28);
                    LODWORD(v32) = 1;
                    size_t v40 = v31;
                    v39[0].__locale_ = 0;
                    if (v31 < 0x11)
                    {
                      memcpy(v39, v30, v31);
                      LODWORD(v41) = 1;
                      size_t v43 = v40;
                      v42.__locale_ = 0;
                      if (v40 < 0x11)
                      {
                        memcpy(&v42, v39, v40);
                        LODWORD(v44) = 1;
                        operator new();
                      }
                      operator new[]();
                    }
                    operator new[]();
                  }
                  operator new[]();
                }
                operator new[]();
              }
              operator new[]();
            }
            operator new[]();
          }
          operator new[]();
        }
        operator new[]();
      }
      operator new[]();
    }
    operator new[]();
  }
  return 0;
}

void sub_19E3E97E0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_19E37B770(a1);
  }
  _Unwind_Resume(a1);
}

void sub_19E3E99DC()
{
}

void sub_19E3E99EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  unint64_t v15 = va_arg(va1, void *);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  if (*(char *)(v13 - 161) < 0) {
    operator delete(*(void **)(v13 - 184));
  }
  if (SLOBYTE(STACK[0x2E7]) < 0) {
    operator delete((void *)STACK[0x2D0]);
  }
  sub_19E3EB09C((void **)va);
  sub_19E3C3B0C((void **)va1);
  _Unwind_Resume(a1);
}

void sub_19E3E9A28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void **a49)
{
  if (SLOBYTE(STACK[0x2C7]) < 0) {
    operator delete((void *)STACK[0x2B0]);
  }
  sub_19E3EB310(&a49);
  sub_19E3EB164((uint64_t *)&STACK[0x2D0]);
  JUMPOUT(0x19E3E9A64);
}

void sub_19E3E9B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  v14 = va_arg(va1, void *);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  sub_19E3EB09C((void **)va);
  sub_19E3C3B0C((void **)va1);
  _Unwind_Resume(a1);
}

void sub_19E3E9B1C()
{
  std::locale::~locale((std::locale *)(v0 - 184));
  std::locale::~locale((std::locale *)&STACK[0x2D0]);
  JUMPOUT(0x19E3E9B30);
}

void sub_19E3E9B48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E39369C(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    *(void *)&long long v24 = *(void *)(a2 + 16);
  }
  DWORD2(v24) = 0;
  v19 = 0;
  size_t v20 = 0;
  uint64_t v18 = 0;
  unint64_t v15 = &v18;
  LOBYTE(v16) = 0;
  unint64_t v6 = operator new(0x20uLL);
  uint64_t v7 = v6;
  uint64_t v18 = v6;
  v19 = v6;
  unint64_t v8 = v6 + 4;
  size_t v20 = v6 + 4;
  if (SBYTE7(v24) < 0)
  {
    sub_19E39369C(v6, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)unint64_t v6 = *(_OWORD *)__p;
    v6[2] = v24;
  }
  *((_DWORD *)v7 + 6) = DWORD2(v24);
  v19 = v8;
  if (SBYTE7(v24) < 0)
  {
    operator delete(__p[0]);
    if ((*(char *)(a3 + 23) & 0x80000000) == 0) {
      goto LABEL_9;
    }
  }
  else if ((*(char *)(a3 + 23) & 0x80000000) == 0)
  {
LABEL_9:
    *(_OWORD *)__p = *(_OWORD *)a3;
    *(void *)&long long v24 = *(void *)(a3 + 16);
    goto LABEL_12;
  }
  sub_19E39369C(__p, *(void **)a3, *(void *)(a3 + 8));
LABEL_12:
  DWORD2(v24) = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unint64_t v15 = 0;
  v21 = &v15;
  char v22 = 0;
  unint64_t v9 = operator new(0x20uLL);
  uint64_t v10 = v9;
  unint64_t v15 = v9;
  uint64_t v16 = v9;
  long long v11 = v9 + 4;
  uint64_t v17 = v9 + 4;
  if (SBYTE7(v24) < 0)
  {
    sub_19E39369C(v9, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)unint64_t v9 = *(_OWORD *)__p;
    v9[2] = v24;
  }
  *((_DWORD *)v10 + 6) = DWORD2(v24);
  uint64_t v16 = v11;
  if (SBYTE7(v24) < 0) {
    operator delete(__p[0]);
  }
  long long v12 = *(_OWORD *)(a4 + 80);
  long long v27 = *(_OWORD *)(a4 + 64);
  long long v28 = v12;
  uint64_t v29 = *(void *)(a4 + 96);
  long long v13 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)__p = *(_OWORD *)a4;
  long long v24 = v13;
  long long v14 = *(_OWORD *)(a4 + 48);
  long long v25 = *(_OWORD *)(a4 + 32);
  long long v26 = v14;
  int v30 = *(_DWORD *)(a4 + 24) & 1 | (2 * ((*(_DWORD *)(a4 + 24) >> 8) & 1));
  operator new();
}

void sub_19E3E9E24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_19E3C3B0C(&a14);
  _Unwind_Resume(a1);
}

_OWORD *sub_19E3E9EC8(uint64_t *a1, void *a2)
{
  result = operator new(0x48uLL);
  uint64_t v5 = 0;
  *a1 = (uint64_t)result;
  *(_OWORD *)(a1 + 1) = xmmword_19E572FF0;
  *(void *)&long long v6 = 0x3030303030303030;
  *((void *)&v6 + 1) = 0x3030303030303030;
  _OWORD *result = v6;
  result[1] = v6;
  result[2] = v6;
  result[3] = v6;
  *((unsigned char *)result + 64) = 0;
  uint64_t v7 = 63;
  do
  {
    if ((*a2 >> v5))
    {
      if (*((char *)a1 + 23) >= 0) {
        unint64_t v8 = a1;
      }
      else {
        unint64_t v8 = (uint64_t *)*a1;
      }
      *((unsigned char *)v8 + v7) = 49;
    }
    ++v5;
    --v7;
  }
  while (v5 != 64);
  return result;
}

void *sub_19E3E9F58(void *__dst, void *__src, size_t a3)
{
  uint64_t v3 = __src;
  v4 = __dst;
  if (*((char *)__src + 23) < 0)
  {
    uint64_t v3 = (void *)*__src;
    size_t v5 = __src[1];
  }
  else
  {
    size_t v5 = *((unsigned __int8 *)__src + 23);
  }
  if (v5 >= a3) {
    size_t v6 = a3;
  }
  else {
    size_t v6 = v5;
  }
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  if (v6 >= 0x17)
  {
    uint64_t v7 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v7 = v6 | 7;
    }
    uint64_t v8 = v7 + 1;
    unint64_t v9 = operator new(v7 + 1);
    v4[1] = v6;
    v4[2] = v8 | 0x8000000000000000;
    void *v4 = v9;
    v4 = v9;
  }
  else
  {
    *((unsigned char *)__dst + 23) = v6;
    if (!v6) {
      goto LABEL_15;
    }
  }
  __dst = memmove(v4, v3, v6);
LABEL_15:
  *((unsigned char *)v4 + v6) = 0;
  return __dst;
}

uint64_t sub_19E3EA00C(unsigned char *a1, long long **a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  sub_19E393108((uint64_t)v32);
  uint64_t v3 = *a2;
  uint64_t v4 = (char *)a2[1] - (char *)*a2;
  if (v4)
  {
    uint64_t v5 = 32 * (v4 >> 5);
    while (1)
    {
      if ((v41 & 0x10) != 0)
      {
        unint64_t v8 = v40;
        unint64_t v9 = (const void **)&v36;
        if (v40 < v37)
        {
          unint64_t v40 = v37;
          unint64_t v8 = v37;
          unint64_t v9 = (const void **)&v36;
        }
      }
      else
      {
        if ((v41 & 8) == 0)
        {
          size_t v6 = 0;
          HIBYTE(v31) = 0;
          p_dst = &__dst;
          goto LABEL_18;
        }
        unint64_t v8 = v35;
        unint64_t v9 = (const void **)v34;
      }
      uint64_t v10 = *v9;
      size_t v6 = v8 - (void)*v9;
      if (v6 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      if (v6 >= 0x17) {
        break;
      }
      HIBYTE(v31) = v8 - *(unsigned char *)v9;
      p_dst = &__dst;
      if (v6) {
        goto LABEL_17;
      }
LABEL_18:
      *((unsigned char *)p_dst + v6) = 0;
      if ((SHIBYTE(v31) & 0x80000000) == 0)
      {
        if (!HIBYTE(v31)) {
          goto LABEL_23;
        }
LABEL_22:
        sub_19E37CA70(v33, (uint64_t)" ", 1);
        goto LABEL_23;
      }
      uint64_t v13 = *((void *)&__dst + 1);
      operator delete((void *)__dst);
      if (v13) {
        goto LABEL_22;
      }
LABEL_23:
      switch(*((_DWORD *)v3 + 6))
      {
        case 0:
        case 3:
          if (*((char *)v3 + 23) < 0)
          {
            sub_19E39369C(&__dst, *(void **)v3, *((void *)v3 + 1));
          }
          else
          {
            long long v14 = *v3;
            int64_t v31 = *((void *)v3 + 2);
            long long __dst = v14;
          }
          break;
        case 1:
          HIBYTE(v31) = 3;
          LODWORD(__dst) = 4092732;
          break;
        case 2:
          HIBYTE(v31) = 4;
          strcpy((char *)&__dst, "</s>");
          break;
        default:
          if (qword_1EC0095B8 != -1) {
            dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
          }
          long long v27 = qword_1EC0095B0;
          if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
          {
            int v28 = *((_DWORD *)v3 + 6);
            *(_DWORD *)buf = 67109120;
            int v44 = v28;
            _os_log_error_impl(&dword_19E36B000, v27, OS_LOG_TYPE_ERROR, "Unsupported token type: %d", buf, 8u);
          }
          __assert_rtn("toString", "TokenIDAdapterUtils.hpp", 89, "false");
      }
      if (v31 >= 0) {
        unint64_t v15 = &__dst;
      }
      else {
        unint64_t v15 = (long long *)__dst;
      }
      if (v31 >= 0) {
        uint64_t v16 = HIBYTE(v31);
      }
      else {
        uint64_t v16 = *((void *)&__dst + 1);
      }
      sub_19E37CA70(v33, (uint64_t)v15, v16);
      if (SHIBYTE(v31) < 0) {
        operator delete((void *)__dst);
      }
      v3 += 2;
      v5 -= 32;
      if (!v5) {
        goto LABEL_37;
      }
    }
    uint64_t v11 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v11 = v6 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (long long *)operator new(v11 + 1);
    *((void *)&__dst + 1) = v6;
    int64_t v31 = v12 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
LABEL_17:
    memmove(p_dst, v10, v6);
    goto LABEL_18;
  }
LABEL_37:
  if ((v41 & 0x10) != 0)
  {
    unint64_t v19 = v40;
    uint64_t v17 = a1;
    if (v40 < v37)
    {
      unint64_t v40 = v37;
      unint64_t v19 = v37;
    }
    size_t v20 = (const void **)&v36;
  }
  else
  {
    uint64_t v17 = a1;
    if ((v41 & 8) == 0)
    {
      size_t v18 = 0;
      a1[23] = 0;
      goto LABEL_52;
    }
    size_t v20 = (const void **)v34;
    unint64_t v19 = v35;
  }
  v21 = *v20;
  size_t v18 = v19 - (void)*v20;
  if (v18 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  if (v18 >= 0x17)
  {
    uint64_t v22 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18 | 7) != 0x17) {
      uint64_t v22 = v18 | 7;
    }
    uint64_t v23 = v22 + 1;
    long long v24 = operator new(v22 + 1);
    v17[1] = v18;
    v17[2] = v23 | 0x8000000000000000;
    *uint64_t v17 = v24;
    uint64_t v17 = v24;
    goto LABEL_51;
  }
  *((unsigned char *)v17 + 23) = v18;
  if (v18) {
LABEL_51:
  }
    memmove(v17, v21, v18);
LABEL_52:
  *((unsigned char *)v17 + v18) = 0;
  v32[0] = *MEMORY[0x1E4FBA408];
  uint64_t v25 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v32 + *(void *)(v32[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v33[0] = v25;
  v33[1] = MEMORY[0x1E4FBA470] + 16;
  if (v39 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x19F3BDC30](&v42);
}

void sub_19E3EA4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_19E3933E0((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E3EA524(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x19E3EA514);
}

uint64_t sub_19E3EA54C(void *a1, const void *****a2)
{
  sub_19E393108((uint64_t)v29);
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (*a2 != v4)
  {
    while (1)
    {
      if ((v38 & 0x10) != 0)
      {
        unint64_t v7 = v37;
        unint64_t v8 = (const void **)&v33;
        if (v37 < v34)
        {
          unint64_t v37 = v34;
          unint64_t v7 = v34;
          unint64_t v8 = (const void **)&v33;
        }
      }
      else
      {
        if ((v38 & 8) == 0)
        {
          std::string::size_type v5 = 0;
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
          p_dst = &__dst;
          goto LABEL_18;
        }
        unint64_t v7 = v32;
        unint64_t v8 = (const void **)v31;
      }
      unint64_t v9 = *v8;
      std::string::size_type v5 = v7 - (void)*v8;
      if (v5 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      if (v5 >= 0x17) {
        break;
      }
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v7 - *(unsigned char *)v8;
      p_dst = &__dst;
      if (v5) {
        goto LABEL_17;
      }
LABEL_18:
      p_dst->__r_.__value_.__s.__data_[v5] = 0;
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        if (!*((unsigned char *)&__dst.__r_.__value_.__s + 23)) {
          goto LABEL_23;
        }
LABEL_22:
        sub_19E37CA70(v30, (uint64_t)" ", 1);
        goto LABEL_23;
      }
      std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      operator delete(__dst.__r_.__value_.__l.__data_);
      if (size) {
        goto LABEL_22;
      }
LABEL_23:
      sub_19E4D2048(&__dst, **v3, (*v3)[1]);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v13 = &__dst;
      }
      else {
        uint64_t v13 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v14 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v14 = __dst.__r_.__value_.__l.__size_;
      }
      unint64_t v15 = sub_19E37CA70(v30, (uint64_t)v13, v14);
      sub_19E37CA70(v15, (uint64_t)"(", 1);
      uint64_t v16 = (void *)std::ostream::operator<<();
      sub_19E37CA70(v16, (uint64_t)")", 1);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (++v3 == v4) {
        goto LABEL_31;
      }
    }
    uint64_t v10 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v10 = v5 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v5;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
LABEL_17:
    memmove(p_dst, v9, v5);
    goto LABEL_18;
  }
LABEL_31:
  if ((v38 & 0x10) != 0)
  {
    unint64_t v19 = v37;
    if (v37 < v34)
    {
      unint64_t v37 = v34;
      unint64_t v19 = v34;
    }
    size_t v20 = (const void **)&v33;
  }
  else
  {
    if ((v38 & 8) == 0)
    {
      size_t v17 = 0;
      size_t v18 = a1;
      *((unsigned char *)a1 + 23) = 0;
      goto LABEL_46;
    }
    size_t v20 = (const void **)v31;
    unint64_t v19 = v32;
  }
  v21 = *v20;
  size_t v17 = v19 - (void)*v20;
  if (v17 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  if (v17 >= 0x17)
  {
    uint64_t v22 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17) {
      uint64_t v22 = v17 | 7;
    }
    uint64_t v23 = v22 + 1;
    long long v24 = operator new(v22 + 1);
    a1[1] = v17;
    a1[2] = v23 | 0x8000000000000000;
    *a1 = v24;
    size_t v18 = v24;
    goto LABEL_45;
  }
  size_t v18 = a1;
  *((unsigned char *)a1 + 23) = v17;
  if (v17) {
LABEL_45:
  }
    memmove(v18, v21, v17);
LABEL_46:
  *((unsigned char *)v18 + v17) = 0;
  v29[0] = *MEMORY[0x1E4FBA408];
  uint64_t v25 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v29 + *(void *)(v29[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v30[0] = v25;
  v30[1] = MEMORY[0x1E4FBA470] + 16;
  if (v36 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x19F3BDC30](&v39);
}

void sub_19E3EA924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
}

void sub_19E3EA95C()
{
}

void sub_19E3EAA38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_19E37059C(v14);
  if (a14 < 0) {
    operator delete(__p);
  }
  MEMORY[0x19F3BDCF0](v14, 0x1032C40D90104AELL);
  _Unwind_Resume(a1);
}

void *sub_19E3EAA84(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  _OWORD *result = v2;
  return result;
}

uint64_t *sub_19E3EAA94(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(char *)(v2 + 287) < 0) {
      operator delete(*(void **)(v2 + 264));
    }
    uint64_t v3 = sub_19E37059C(v2);
    MEMORY[0x19F3BDCF0](v3, 0x1032C40D90104AELL);
  }
  return a1;
}

uint64_t *sub_19E3EAAF0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_19E37059C(v2);
    MEMORY[0x19F3BDCF0](v3, 0x1032C4057ACE4D0);
  }
  return a1;
}

void *sub_19E3EAB38(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      sub_19E37C2B8();
    }
    unint64_t v9 = (char *)operator new(8 * v8);
  }
  else
  {
    unint64_t v9 = 0;
  }
  uint64_t v10 = &v9[8 * v3];
  uint64_t v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)uint64_t v10 = v12;
  uint64_t v13 = v10 + 8;
  uint64_t v14 = (char *)*a1;
  unint64_t v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
  }
  else
  {
    unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
    if (v16 < 0x78 || &v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v15) {
      goto LABEL_33;
    }
    uint64_t v17 = (v16 >> 3) + 1;
    uint64_t v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    unint64_t v19 = &v15[-v18];
    v10 -= v18;
    size_t v20 = &v9[8 * v3 - 16];
    v21 = v15 - 16;
    uint64_t v22 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *((_OWORD *)v21 - 1);
      long long v23 = *(_OWORD *)v21;
      *((_OWORD *)v21 - 1) = 0uLL;
      *(_OWORD *)v21 = 0uLL;
      *((_OWORD *)v20 - 1) = v24;
      *(_OWORD *)size_t v20 = v23;
      v20 -= 32;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    unint64_t v15 = v19;
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_33:
      do
      {
        uint64_t v25 = *((void *)v15 - 1);
        v15 -= 8;
        *(void *)unint64_t v15 = 0;
        *((void *)v10 - 1) = v25;
        v10 -= 8;
      }
      while (v15 != v14);
    }
    unint64_t v15 = (char *)*a1;
    long long v26 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    while (v26 != v15)
    {
      uint64_t v29 = *((void *)v26 - 1);
      v26 -= 8;
      uint64_t v28 = v29;
      *(void *)long long v26 = 0;
      if (v29)
      {
        if (*(char *)(v28 + 287) < 0) {
          operator delete(*(void **)(v28 + 264));
        }
        uint64_t v27 = sub_19E37059C(v28);
        MEMORY[0x19F3BDCF0](v27, 0x1032C40D90104AELL);
      }
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

os_log_t sub_19E3EACF8()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "ToucanInlineCompletion");
  qword_1E9459DF8 = (uint64_t)result;
  return result;
}

char *sub_19E3EAD28(char *__dst, long long *a2, long long *a3, long long *a4, uint64_t *a5, uint64_t *a6, long long *a7, uint64_t a8, int a9, uint64_t a10)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_19E39369C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v17 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v17;
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_19E39369C(__dst + 24, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v18 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)(__dst + 24) = v18;
  }
  long long v19 = a4[4];
  long long v20 = a4[5];
  long long v21 = a4[6];
  long long v22 = *a4;
  long long v23 = a4[1];
  long long v25 = a4[2];
  long long v24 = a4[3];
  *((void *)__dst + 20) = 0;
  *((_OWORD *)__dst + 3) = v22;
  *((_OWORD *)__dst + 4) = v23;
  *((_OWORD *)__dst + 8) = v20;
  *((_OWORD *)__dst + 9) = v21;
  *((_OWORD *)__dst + 6) = v24;
  *((_OWORD *)__dst + 7) = v19;
  *((_OWORD *)__dst + 5) = v25;
  *((void *)__dst + 21) = 0;
  *((void *)__dst + 22) = 0;
  sub_19E3C38BC((void *)__dst + 20, *a5, a5[1], (a5[1] - *a5) >> 5);
  *((void *)__dst + 23) = 0;
  *((void *)__dst + 24) = 0;
  *((void *)__dst + 25) = 0;
  sub_19E3C38BC((void *)__dst + 23, *a6, a6[1], (a6[1] - *a6) >> 5);
  long long v26 = __dst + 208;
  if (*((char *)a7 + 23) < 0)
  {
    sub_19E39369C(v26, *(void **)a7, *((void *)a7 + 1));
  }
  else
  {
    long long v27 = *a7;
    *((void *)__dst + 28) = *((void *)a7 + 2);
    *(_OWORD *)long long v26 = v27;
  }
  *((void *)__dst + 29) = a8;
  *((_DWORD *)__dst + 60) = a9;
  *((void *)__dst + 31) = a10;
  return __dst;
}

void sub_19E3EAE70(_Unwind_Exception *a1)
{
  sub_19E3C3B0C(v4);
  sub_19E3C3B0C(v3);
  if (*(char *)(v1 + 47) < 0)
  {
    operator delete(*v2);
    if ((*(char *)(v1 + 23) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(a1);
  }
  else if ((*(char *)(v1 + 23) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E3EAEDC(char **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v4 = (v3 - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    sub_19E37C7C4();
  }
  uint64_t v8 = a1[2] - v2;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 59) {
      sub_19E37C2B8();
    }
    uint64_t v10 = operator new(32 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t v11 = (char *)&v10[8 * v4];
  long long v17 = (char *)&v10[8 * v9];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E39369C(v11, *(void **)a2, *(void *)(a2 + 8));
    uint64_t v2 = *a1;
    uint64_t v3 = a1[1];
    uint64_t v11 = (char *)&v10[8 * v4];
  }
  else
  {
    *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
    *((void *)v11 + 2) = *(void *)(a2 + 16);
  }
  v10[8 * v4 + 6] = *(_DWORD *)(a2 + 24);
  uint64_t v12 = (uint64_t)&v10[8 * v4 + 8];
  if (v3 == v2)
  {
    uint64_t v14 = v2;
  }
  else
  {
    do
    {
      long long v13 = *((_OWORD *)v3 - 2);
      *((void *)v11 - 2) = *((void *)v3 - 2);
      *((_OWORD *)v11 - 2) = v13;
      *((void *)v3 - 3) = 0;
      *((void *)v3 - 2) = 0;
      *((void *)v3 - 4) = 0;
      *((_DWORD *)v11 - 2) = *((_DWORD *)v3 - 2);
      v11 -= 32;
      v3 -= 32;
    }
    while (v3 != v2);
    uint64_t v14 = *a1;
    uint64_t v2 = a1[1];
  }
  *a1 = v11;
  a1[1] = (char *)v12;
  a1[2] = v17;
  if (v2 != v14)
  {
    unint64_t v15 = (void **)(v2 - 32);
    do
    {
      if (*((char *)v15 + 23) < 0) {
        operator delete(*v15);
      }
      v15 -= 4;
    }
    while (v15 + 4 != (void **)v14);
    uint64_t v2 = v14;
  }
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

void sub_19E3EB088(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3EB870((uint64_t)va);
  _Unwind_Resume(a1);
}

void **sub_19E3EB09C(void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 3;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t *sub_19E3EB110(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t *sub_19E3EB164(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

char *sub_19E3EB1B8(void **a1, uint64_t a2)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_19E37C7C4();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v4;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_19E37C2B8();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[24 * v3];
  unint64_t v9 = &v7[24 * v6];
  *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v10 = v8 + 24;
  uint64_t v11 = (void **)*a1;
  uint64_t v12 = (void **)a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v12 - 3);
      *((void *)v8 - 1) = *(v12 - 1);
      *(_OWORD *)(v8 - 24) = v13;
      v8 -= 24;
      *(v12 - 2) = 0;
      *(v12 - 1) = 0;
      *(v12 - 3) = 0;
      v12 -= 3;
    }
    while (v12 != v11);
    uint64_t v12 = (void **)*a1;
    uint64_t v14 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    while (v14 != v12)
    {
      if (*((char *)v14 - 1) < 0) {
        operator delete(*(v14 - 3));
      }
      v14 -= 3;
    }
  }
  if (v12) {
    operator delete(v12);
  }
  return v10;
}

void ***sub_19E3EB310(void ***a1)
{
  if (!*((unsigned char *)a1 + 8))
  {
    uint64_t v2 = *a1;
    unint64_t v3 = (void **)**a1;
    if (v3)
    {
      unint64_t v4 = (void **)v2[1];
      unint64_t v5 = **a1;
      if (v4 != v3)
      {
        do
        {
          if (*((char *)v4 - 1) < 0) {
            operator delete(*(v4 - 3));
          }
          v4 -= 3;
        }
        while (v4 != v3);
        unint64_t v5 = **a1;
      }
      v2[1] = v3;
      operator delete(v5);
    }
  }
  return a1;
}

uint64_t *sub_19E3EB394(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      unint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

char *sub_19E3EB3E8(uint64_t a1, char *a2, char *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *(void **)a1;
  size_t v6 = *(void *)(*(void *)a1 + 16);
  unint64_t v40 = v6;
  v39[0] = 0;
  if (v6 >= 0x11) {
    operator new[]();
  }
  memcpy(v39, v5, v6);
  if (a2 == a3)
  {
LABEL_28:
    a2 = a3;
    if (v40 < 0x11) {
      goto LABEL_31;
    }
    goto LABEL_29;
  }
  if (v40 > 0x10)
  {
    while (1)
    {
      int v14 = *a2;
      unint64_t v15 = (char *)v39[0];
      unint64_t v16 = v40;
      do
      {
        unint64_t v17 = v16 >> 1;
        long long v18 = &v15[v16 >> 1];
        int v20 = *v18;
        long long v19 = v18 + 1;
        v16 += ~(v16 >> 1);
        if (v20 < v14) {
          unint64_t v15 = v19;
        }
        else {
          unint64_t v16 = v17;
        }
      }
      while (v16);
      if (v15 != (char *)(v39[0] + v40) && *v15 <= v14) {
        break;
      }
      if (++a2 == a3) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    if (!v40) {
      return a3;
    }
    while (1)
    {
      int v7 = *a2;
      uint64_t v8 = v39;
      unint64_t v9 = v40;
      do
      {
        unint64_t v10 = v9 >> 1;
        uint64_t v11 = (char *)v8 + (v9 >> 1);
        int v13 = *v11;
        uint64_t v12 = v11 + 1;
        v9 += ~(v9 >> 1);
        if (v13 < v7) {
          uint64_t v8 = v12;
        }
        else {
          unint64_t v9 = v10;
        }
      }
      while (v9);
      if (v8 != (void *)((char *)v39 + v40) && *(char *)v8 <= v7) {
        break;
      }
      if (++a2 == a3) {
        goto LABEL_28;
      }
    }
  }
  if (v40 >= 0x11)
  {
LABEL_29:
    if (v39[0]) {
      MEMORY[0x19F3BDCC0](v39[0], 0x1000C8077774924);
    }
  }
LABEL_31:
  if (a2 == a3) {
    return a3;
  }
  if (*((_DWORD *)v5 + 6)) {
    return a2;
  }
  unint64_t v21 = v5[2];
  if (v21 > 0x10)
  {
    int v30 = a2;
    while (1)
    {
      int v31 = *v30;
      unint64_t v32 = (char *)*v5;
      unint64_t v33 = v5[2];
      do
      {
        unint64_t v34 = v33 >> 1;
        unint64_t v35 = &v32[v33 >> 1];
        int v37 = *v35;
        char v36 = v35 + 1;
        v33 += ~(v33 >> 1);
        if (v37 < v31) {
          unint64_t v32 = v36;
        }
        else {
          unint64_t v33 = v34;
        }
      }
      while (v33);
      if (v32 == (char *)(*v5 + v21) || *v32 > v31) {
        break;
      }
      if (++v30 == a3) {
        return a2;
      }
    }
  }
  else
  {
    if (!v21) {
      return a2;
    }
    long long v22 = a2;
    while (1)
    {
      int v23 = *v22;
      long long v24 = (char *)v5;
      unint64_t v25 = v5[2];
      do
      {
        unint64_t v26 = v25 >> 1;
        long long v27 = &v24[v25 >> 1];
        int v29 = *v27;
        uint64_t v28 = v27 + 1;
        v25 += ~(v25 >> 1);
        if (v29 < v23) {
          long long v24 = v28;
        }
        else {
          unint64_t v25 = v26;
        }
      }
      while (v25);
      if (v24 == (char *)v5 + v21 || *v24 > v23) {
        break;
      }
      if (++v22 == a3) {
        return a2;
      }
    }
  }
  return a2;
}

uint64_t sub_19E3EB6C0(uint64_t result, _WORD *a2, int a3)
{
  unint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)os_log_t result = 0;
      return result;
    case 2:
      unint64_t v5 = *(void **)a2;
      if (*(void *)a2)
      {
        if (v5[2] >= 0x11uLL)
        {
          if (*v5) {
            MEMORY[0x19F3BDCC0](*v5, 0x1000C8077774924);
          }
        }
        os_log_t result = MEMORY[0x19F3BDCF0](v5, 0x1012C405C87E9CELL);
      }
      goto LABEL_12;
    case 3:
      os_log_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost9algorithm6detail13token_finderFINS1_10is_any_ofFIcEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (os_log_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost9algorithm6detail13token_finderFINS1_10is_any_ofFIcEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_12:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(void *)a2 = &unk_1EF0B75A0;
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_19E3EB838(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x1012C405C87E9CELL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E3EB870(uint64_t a1)
{
  unint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      unint64_t v5 = v2 - 4;
      *(void *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v5);
        unint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL sub_19E3EB8D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(a1 + 64) - v3;
  uint64_t v5 = v4 >> 5;
  unint64_t v6 = (a3 - a2) >> 5;
  if (v6 + (v4 >> 5) < 8) {
    return 0;
  }
  v129 = 0;
  v130 = 0;
  v131 = 0;
  sub_19E3C39E4(&v129, a2, a3, v6);
  if ((unint64_t)v4 >= 0x40)
  {
    unint64_t v9 = (unint64_t)v130;
    uint64_t v10 = 32 * v5 - 32 * (v5 != 0);
    do
    {
      if (v9 < (unint64_t)v131)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          sub_19E39369C((unsigned char *)v9, *(void **)v3, *(void *)(v3 + 8));
        }
        else
        {
          long long v11 = *(_OWORD *)v3;
          *(void *)(v9 + 16) = *(void *)(v3 + 16);
          *(_OWORD *)unint64_t v9 = v11;
        }
        *(_DWORD *)(v9 + 24) = *(_DWORD *)(v3 + 24);
        v9 += 32;
      }
      else
      {
        unint64_t v9 = sub_19E3EAEDC(&v129, v3);
      }
      v130 = (char *)v9;
      v3 += 32;
      v10 -= 32;
    }
    while (v10);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    sub_19E39369C(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a1;
    uint64_t v124 = *(void *)(a1 + 16);
  }
  int v125 = 0;
  sub_19E371C70(v126, (const UInt8 *)__p);
  int v12 = v125;
  int v128 = v125;
  int v13 = v130;
  if (v130 >= v131)
  {
    unint64_t v15 = v129;
    uint64_t v16 = (v130 - v129) >> 5;
    unint64_t v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 59) {
      sub_19E37C7C4();
    }
    uint64_t v18 = v131 - v129;
    if ((v131 - v129) >> 4 > v17) {
      unint64_t v17 = v18 >> 4;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19 >> 59) {
      sub_19E37C2B8();
    }
    int v20 = (char *)operator new(32 * v19);
    unint64_t v21 = &v20[32 * v16];
    *(_OWORD *)unint64_t v21 = *(_OWORD *)&v126[0].__locale_;
    *((void *)v21 + 2) = v127;
    v126[1].__locale_ = 0;
    uint64_t v127 = 0;
    v126[0].__locale_ = 0;
    *((_DWORD *)v21 + 6) = v12;
    long long v22 = v21 + 32;
    if (v13 == v15)
    {
      v129 = &v20[32 * v16];
      v130 = v21 + 32;
      v131 = &v20[32 * v19];
    }
    else
    {
      do
      {
        long long v23 = *((_OWORD *)v13 - 2);
        *((void *)v21 - 2) = *((void *)v13 - 2);
        *((_OWORD *)v21 - 2) = v23;
        *((void *)v13 - 3) = 0;
        *((void *)v13 - 2) = 0;
        *((void *)v13 - 4) = 0;
        *((_DWORD *)v21 - 2) = *((_DWORD *)v13 - 2);
        v21 -= 32;
        v13 -= 32;
      }
      while (v13 != v15);
      int v13 = v129;
      long long v24 = v130;
      v129 = v21;
      v130 = v22;
      v131 = &v20[32 * v19];
      while (v24 != v13)
      {
        if (*(v24 - 9) < 0) {
          operator delete(*((void **)v24 - 4));
        }
        v24 -= 32;
      }
    }
    if (v13) {
      operator delete(v13);
    }
    v130 = v22;
    if (SHIBYTE(v127) < 0)
    {
      operator delete(v126[0].__locale_);
      if ((SHIBYTE(v124) & 0x80000000) == 0) {
        goto LABEL_37;
      }
    }
    else if ((SHIBYTE(v124) & 0x80000000) == 0)
    {
      goto LABEL_37;
    }
    goto LABEL_17;
  }
  long long v14 = *(_OWORD *)&v126[0].__locale_;
  *((void *)v130 + 2) = v127;
  *(_OWORD *)int v13 = v14;
  v126[1].__locale_ = 0;
  uint64_t v127 = 0;
  v126[0].__locale_ = 0;
  *((_DWORD *)v13 + 6) = v128;
  v130 = v13 + 32;
  if (SHIBYTE(v124) < 0) {
LABEL_17:
  }
    operator delete(__p[0]);
LABEL_37:
  unint64_t v25 = v129;
  uint64_t v26 = (v130 - v129) >> 5;
  uint64_t v118 = v26 - 4;
  if (v26 == 4) {
    __assert_rtn("isPredictionResultingInLoop", "ToucanLanguageModelSession.cpp", 409, "index > 0");
  }
  unint64_t v117 = v26 - 8;
  if (v26 == 8)
  {
    BOOL v7 = 0;
    if (v129) {
      goto LABEL_151;
    }
    return v7;
  }
  uint64_t v113 = v26 - 2;
  uint64_t v114 = v26 - 3;
  uint64_t v112 = v26 - 1;
  uint64_t v27 = 1;
  uint64_t v28 = (std::locale::id *)MEMORY[0x1E4FBA258];
  do
  {
    uint64_t v121 = v27;
    int v29 = &v129[32 * v27];
    int v30 = &v129[32 * v118];
    MEMORY[0x19F3BDBC0](__p);
    std::locale::locale(v126, (const std::locale *)__p);
    int v31 = v29[23];
    if (v31 >= 0) {
      unint64_t v32 = v29;
    }
    else {
      unint64_t v32 = *(char **)v29;
    }
    if (v31 >= 0) {
      uint64_t v33 = v29[23];
    }
    else {
      uint64_t v33 = *((void *)v29 + 1);
    }
    int v34 = v30[23];
    if (v34 >= 0) {
      unint64_t v35 = v30;
    }
    else {
      unint64_t v35 = *(char **)v30;
    }
    if (v34 >= 0) {
      uint64_t v36 = v30[23];
    }
    else {
      uint64_t v36 = *((void *)v30 + 1);
    }
    if (v33) {
      BOOL v37 = v36 == 0;
    }
    else {
      BOOL v37 = 1;
    }
    v119 = v32;
    if (v37)
    {
      uint64_t v41 = v35;
LABEL_58:
      BOOL v7 = v32 == &v119[v33] && v41 == &v35[v36];
    }
    else
    {
      uint64_t v39 = v36 - 1;
      uint64_t v40 = v33 - 1;
      uint64_t v41 = v35;
      while (1)
      {
        char v42 = *v32;
        size_t v43 = std::locale::use_facet(v126, v28);
        int v44 = ((uint64_t (*)(const std::locale::facet *, void))v43->__vftable[1].~facet)(v43, v42);
        char v45 = *v41;
        v46 = std::locale::use_facet(v126, v28);
        if (v44 != ((unsigned int (*)(const std::locale::facet *, void))v46->__vftable[1].~facet)(v46, v45))break; {
        ++v32;
        }
        ++v41;
        if (v40)
        {
          uint64_t v47 = v39--;
          --v40;
          if (v47) {
            continue;
          }
        }
        goto LABEL_58;
      }
      BOOL v7 = 0;
    }
    std::locale::~locale(v126);
    std::locale::~locale((std::locale *)__p);
    unint64_t v48 = v121 + 1;
    if (v7)
    {
      unint64_t v120 = v121 + 1;
      v49 = &v129[32 * v48];
      v50 = &v129[32 * v114];
      MEMORY[0x19F3BDBC0](__p);
      std::locale::locale(v126, (const std::locale *)__p);
      int v51 = v49[23];
      if (v51 >= 0) {
        v52 = v49;
      }
      else {
        v52 = *(char **)v49;
      }
      if (v51 >= 0) {
        uint64_t v53 = v49[23];
      }
      else {
        uint64_t v53 = *((void *)v49 + 1);
      }
      int v54 = v50[23];
      if (v54 >= 0) {
        v55 = v50;
      }
      else {
        v55 = *(char **)v50;
      }
      if (v54 >= 0) {
        uint64_t v56 = v50[23];
      }
      else {
        uint64_t v56 = *((void *)v50 + 1);
      }
      if (v53) {
        BOOL v57 = v56 == 0;
      }
      else {
        BOOL v57 = 1;
      }
      v115 = v55;
      if (!v57)
      {
        uint64_t v78 = v56 - 1;
        uint64_t v79 = v53 - 1;
        v80 = v52;
        while (1)
        {
          char v81 = *v80;
          v82 = std::locale::use_facet(v126, v28);
          int v83 = ((uint64_t (*)(const std::locale::facet *, void))v82->__vftable[1].~facet)(v82, v81);
          char v84 = *v55;
          v85 = std::locale::use_facet(v126, v28);
          if (v83 != ((unsigned int (*)(const std::locale::facet *, void))v85->__vftable[1].~facet)(v85, v84))goto LABEL_113; {
          ++v80;
          }
          ++v55;
          if (v79)
          {
            uint64_t v86 = v78--;
            --v79;
            if (v86) {
              continue;
            }
          }
          goto LABEL_88;
        }
      }
      v80 = v52;
LABEL_88:
      std::locale::~locale(v126);
      std::locale::~locale((std::locale *)__p);
      BOOL v7 = 0;
      if (v80 != &v52[v53]) {
        goto LABEL_145;
      }
      unint64_t v48 = v121 + 1;
      if (v55 == &v115[v56])
      {
        v58 = &v129[32 * v121];
        v59 = &v129[32 * v113];
        MEMORY[0x19F3BDBC0](__p);
        std::locale::locale(v126, (const std::locale *)__p);
        v62 = (char *)*((void *)v58 + 8);
        v61 = v58 + 64;
        v60 = v62;
        int v63 = v61[23];
        if (v63 >= 0) {
          v64 = v61;
        }
        else {
          v64 = v60;
        }
        if (v63 >= 0) {
          uint64_t v65 = v61[23];
        }
        else {
          uint64_t v65 = *((void *)v61 + 1);
        }
        int v66 = v59[23];
        if (v66 >= 0) {
          v67 = v59;
        }
        else {
          v67 = *(char **)v59;
        }
        if (v66 >= 0) {
          uint64_t v68 = v59[23];
        }
        else {
          uint64_t v68 = *((void *)v59 + 1);
        }
        v116 = v67;
        if (v65 && v68)
        {
          uint64_t v69 = v68 - 1;
          uint64_t v70 = v65 - 1;
          v71 = v64;
          while (1)
          {
            char v72 = *v71;
            v73 = std::locale::use_facet(v126, v28);
            int v74 = ((uint64_t (*)(const std::locale::facet *, void))v73->__vftable[1].~facet)(v73, v72);
            char v75 = *v67;
            v76 = std::locale::use_facet(v126, v28);
            if (v74 != ((unsigned int (*)(const std::locale::facet *, void))v76->__vftable[1].~facet)(v76, v75))break; {
            ++v71;
            }
            ++v67;
            if (v70)
            {
              uint64_t v77 = v69--;
              --v70;
              if (v77) {
                continue;
              }
            }
            goto LABEL_115;
          }
LABEL_113:
          std::locale::~locale(v126);
          std::locale::~locale((std::locale *)__p);
          BOOL v7 = 0;
LABEL_145:
          unint64_t v48 = v120;
          goto LABEL_146;
        }
        v71 = v64;
LABEL_115:
        std::locale::~locale(v126);
        std::locale::~locale((std::locale *)__p);
        BOOL v7 = 0;
        if (v71 != &v64[v65]) {
          goto LABEL_145;
        }
        unint64_t v48 = v121 + 1;
        if (v67 == &v116[v68])
        {
          v87 = &v129[32 * v121];
          v88 = &v129[32 * v112];
          MEMORY[0x19F3BDBC0](__p);
          std::locale::locale(v126, (const std::locale *)__p);
          v91 = (char *)*((void *)v87 + 12);
          v90 = v87 + 96;
          v89 = v91;
          int v92 = v90[23];
          if (v92 >= 0) {
            v93 = v90;
          }
          else {
            v93 = v89;
          }
          if (v92 >= 0) {
            uint64_t v94 = v90[23];
          }
          else {
            uint64_t v94 = *((void *)v90 + 1);
          }
          int v95 = v88[23];
          if (v95 >= 0) {
            v96 = v88;
          }
          else {
            v96 = *(char **)v88;
          }
          if (v95 >= 0) {
            uint64_t v97 = v88[23];
          }
          else {
            uint64_t v97 = *((void *)v88 + 1);
          }
          v122 = v93;
          if (v94 && v97)
          {
            uint64_t v98 = v97 - 1;
            uint64_t v99 = v94 - 1;
            v100 = v96;
            v101 = v93;
            while (1)
            {
              char v102 = *v101;
              v103 = std::locale::use_facet(v126, v28);
              int v104 = ((uint64_t (*)(const std::locale::facet *, void))v103->__vftable[1].~facet)(v103, v102);
              char v105 = *v100;
              v106 = std::locale::use_facet(v126, v28);
              if (v104 != ((unsigned int (*)(const std::locale::facet *, void))v106->__vftable[1].~facet)(v106, v105))break; {
              ++v101;
              }
              ++v100;
              if (v99)
              {
                uint64_t v107 = v98--;
                --v99;
                if (v107) {
                  continue;
                }
              }
              goto LABEL_137;
            }
            BOOL v7 = 0;
          }
          else
          {
            v101 = v93;
            v100 = v96;
LABEL_137:
            BOOL v7 = v101 == &v122[v94] && v100 == &v96[v97];
          }
          std::locale::~locale(v126);
          std::locale::~locale((std::locale *)__p);
          goto LABEL_145;
        }
      }
    }
LABEL_146:
    if (v7) {
      break;
    }
    uint64_t v27 = v48;
  }
  while (v48 <= v117);
  unint64_t v25 = v129;
  if (!v129) {
    return v7;
  }
LABEL_151:
  v109 = v130;
  v110 = v25;
  if (v130 != v25)
  {
    do
    {
      if (*(v109 - 9) < 0) {
        operator delete(*((void **)v109 - 4));
      }
      v109 -= 32;
    }
    while (v109 != v25);
    v110 = v129;
  }
  v130 = v25;
  operator delete(v110);
  return v7;
}

void sub_19E3EC1A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,std::locale a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  sub_19E3C3B0C((void **)(v29 - 112));
  _Unwind_Resume(a1);
}

void **sub_19E3EC22C(void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        sub_19E3C3D24(v3 - 23);
        if (*((char *)v3 - 193) < 0) {
          operator delete(*(v3 - 27));
        }
        v3 -= 27;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void sub_19E3EC2A8(char **a1, unsigned char *a2, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = a5 - 1;
  if (a5 < 1) {
    return;
  }
  BOOL v7 = __src;
  unint64_t v9 = a1;
  unint64_t v11 = (unint64_t)*a1;
  unint64_t v10 = (unint64_t)a1[1];
  uint64_t v12 = a2 - *a1;
  uint64_t v13 = v12 >> 2;
  long long v14 = &(*a1)[v12 & 0xFFFFFFFFFFFFFFFCLL];
  unint64_t v15 = a1[2];
  if (a5 > (uint64_t)&v15[-v10] >> 2)
  {
    unint64_t v16 = a5 + ((uint64_t)(v10 - v11) >> 2);
    if (v16 >> 62) {
      sub_19E37C7C4();
    }
    uint64_t v17 = (uint64_t)&v15[-v11];
    if (v17 >> 1 > v16) {
      unint64_t v16 = v17 >> 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 62) {
        sub_19E37C2B8();
      }
      unint64_t v19 = (unint64_t)&(*a1)[v12 & 0xFFFFFFFFFFFFFFFCLL];
      unint64_t v20 = v18;
      unint64_t v21 = operator new(4 * v18);
      unint64_t v18 = v20;
      long long v14 = (char *)v19;
      uint64_t v13 = v12 >> 2;
      unint64_t v9 = a1;
    }
    else
    {
      unint64_t v21 = 0;
    }
    v46 = &v21[4 * v13];
    uint64_t v47 = &v46[4 * a5];
    unint64_t v48 = v46;
    if ((v5 & 0x3FFFFFFFFFFFFFFFuLL) >= 7)
    {
      unint64_t v48 = &v21[4 * v13];
      if ((unint64_t)(&v21[v12 & 0xFFFFFFFFFFFFFFFCLL] - v7) >= 0x20)
      {
        uint64_t v49 = (v5 & 0x3FFFFFFFFFFFFFFFLL) + 1;
        uint64_t v50 = 4 * (v49 & 0x7FFFFFFFFFFFFFF8);
        unint64_t v48 = &v46[v50];
        int v51 = (long long *)(v7 + 16);
        v52 = &v21[4 * v13 + 16];
        uint64_t v53 = v49 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v54 = *v51;
          *(v52 - 1) = *(v51 - 1);
          _OWORD *v52 = v54;
          v51 += 2;
          v52 += 2;
          v53 -= 8;
        }
        while (v53);
        if (v49 == (v49 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_44:
          if ((unsigned char *)v11 != a2)
          {
            if ((unint64_t)(v12 - 4) >= 0x3C)
            {
              uint64_t v56 = v14;
              if ((v12 & 0xFFFFFFFFFFFFFFFCLL) + v11 - (unint64_t)&v21[v12 & 0xFFFFFFFFFFFFFFFCLL] >= 0x20)
              {
                unint64_t v57 = ((unint64_t)(v12 - 4) >> 2) + 1;
                uint64_t v56 = &v14[-4 * (v57 & 0x7FFFFFFFFFFFFFF8)];
                uint64_t v58 = 4 * v13 - 16;
                v59 = (long long *)(v11 + v58);
                v60 = &v21[v58];
                uint64_t v61 = v57 & 0x7FFFFFFFFFFFFFF8;
                do
                {
                  long long v62 = *v59;
                  *(v60 - 1) = *(v59 - 1);
                  _OWORD *v60 = v62;
                  v59 -= 2;
                  v60 -= 2;
                  v61 -= 8;
                }
                while (v61);
                v46 -= 4 * (v57 & 0x7FFFFFFFFFFFFFF8);
                if (v57 == (v57 & 0x7FFFFFFFFFFFFFF8)) {
                  goto LABEL_52;
                }
              }
            }
            else
            {
              uint64_t v56 = v14;
            }
            do
            {
              int v63 = *((_DWORD *)v56 - 1);
              v56 -= 4;
              *((_DWORD *)v46 - 1) = v63;
              v46 -= 4;
            }
            while (v56 != (char *)v11);
          }
LABEL_52:
          v64 = &v21[4 * v18];
          size_t v65 = v10 - (void)v14;
          if (v65) {
            memmove(v47, v14, v65);
          }
          *unint64_t v9 = v46;
          v9[1] = &v47[v65];
          v9[2] = v64;
          if (v11)
          {
            operator delete((void *)v11);
          }
          return;
        }
        v7 += v50;
      }
    }
    do
    {
      int v55 = *(_DWORD *)v7;
      v7 += 4;
      *(_DWORD *)unint64_t v48 = v55;
      v48 += 4;
    }
    while (v48 != v47);
    goto LABEL_44;
  }
  uint64_t v22 = v10 - (void)v14;
  uint64_t v23 = (uint64_t)(v10 - (void)v14) >> 2;
  if (v23 >= a5)
  {
    long long v24 = &__src[4 * a5];
    unint64_t v26 = (unint64_t)a1[1];
LABEL_18:
    uint64_t v27 = &v14[4 * a5];
    size_t v28 = v26 - (void)v27;
    uint64_t v29 = (uint64_t)(v26 - (void)v27) >> 2;
    int v30 = (int *)(v26 - 4 * a5);
    int v31 = (char *)v26;
    if ((unint64_t)v30 < v10)
    {
      unint64_t v32 = (v12 & 0xFFFFFFFFFFFFFFFCLL) + v28;
      uint64_t v33 = (char *)(v32 + v11);
      unint64_t v34 = v32 + v11 + 4;
      if (v10 > v34) {
        unint64_t v34 = v10;
      }
      unint64_t v35 = v34 + ~v11 - v32;
      unint64_t v36 = v26 - (void)v33;
      BOOL v37 = v35 >= 0x2C && v36 > 0x1F;
      int v31 = (char *)v26;
      if (!v37) {
        goto LABEL_63;
      }
      uint64_t v38 = (v35 >> 2) + 1;
      uint64_t v39 = 4 * (v38 & 0x7FFFFFFFFFFFFFF8);
      int v30 = (int *)((char *)v30 + v39);
      uint64_t v40 = (_OWORD *)(v26 + 16);
      uint64_t v41 = (long long *)(4 * v29 + 4 * v13 + v11 + 16);
      uint64_t v42 = v38 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v43 = *v41;
        *(v40 - 1) = *(v41 - 1);
        *uint64_t v40 = v43;
        v40 += 2;
        v41 += 2;
        v42 -= 8;
      }
      while (v42);
      int v31 = (char *)(v26 + v39);
      if (v38 != (v38 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_63:
        do
        {
          int v44 = *v30++;
          *(_DWORD *)int v31 = v44;
          v31 += 4;
        }
        while ((unint64_t)v30 < v10);
      }
    }
    v9[1] = v31;
    if ((char *)v26 != v27)
    {
      char v45 = v14;
      memmove((void *)(v26 - 4 * v29), v14, v28);
      long long v14 = v45;
    }
    if (v24 != v7)
    {
      memmove(v14, v7, v24 - v7);
    }
    return;
  }
  long long v24 = &__src[4 * v23];
  int64_t v25 = a4 - v24;
  if (a4 != v24)
  {
    unint64_t v67 = (unint64_t)&(*a1)[v12 & 0xFFFFFFFFFFFFFFFCLL];
    memmove(a1[1], &__src[4 * v23], a4 - v24);
    uint64_t v13 = v12 >> 2;
    long long v14 = (char *)v67;
  }
  unint64_t v26 = v10 + v25;
  v9[1] = (char *)(v10 + v25);
  if (v22 >= 1) {
    goto LABEL_18;
  }
}

void *sub_19E3EC684()
{
  return &unk_1EF0B4C78;
}

uint64_t sub_19E3EC690(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v126ToucanLanguageModelSession26enumerateInlineCompletionsERKNS0_17Linguisti"
                     "cContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEERKNS5_8functionIFbRKNS0_16Inli"
                     "neCompletionEEEEPK14__CFDictionaryRKNSD_IFbvEEEE3$_0"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v126ToucanLanguageModelSession26enumerateInlineCompletionsERKNS0_"
                                "17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEERKNS5_8f"
                                "unctionIFbRKNS0_16InlineCompletionEEEEPK14__CFDictionaryRKNSD_IFbvEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v126ToucanLanguageModelSession26enumerateInlineCompletionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEERKNS5_8functionIFbRKNS0_16InlineCompletionEEEEPK14__CFDictionaryRKNSD_IFbvEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v126ToucanLanguageModelSession26enumerateInlineCompletionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEERKNS5_8functionIFbRKNS0_16InlineCompletionEEEEPK14__CFDictionaryRKNSD_IFbvEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E3EC6E8()
{
}

void sub_19E3EC840(_Unwind_Exception *a1)
{
  sub_19E37059C(v1);
  MEMORY[0x19F3BDCF0](v1, 0x1032C40D90104AELL);
  _Unwind_Resume(a1);
}

void sub_19E3EC894(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)va);
  _Unwind_Resume(a1);
}

__n128 sub_19E3EC8B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0B5768;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E3EC8E0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF0B5768;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E3EC934()
{
}

void sub_19E3EC94C(void *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  sub_19E3ECA60(&__p, a1, a2, a3, a4, a1[11] + 2);
  unint64_t v6 = __p;
  BOOL v7 = v17;
  if (__p != v17)
  {
    do
    {
      uint64_t v8 = *(void *)(a5 + 24);
      if (!v8) {
        sub_19E3ACB9C();
      }
      char v9 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 48))(v8, v6++);
      if (v6 == v7) {
        char v10 = 0;
      }
      else {
        char v10 = v9;
      }
    }
    while ((v10 & 1) != 0);
    unint64_t v6 = __p;
  }
  if (v6)
  {
    unint64_t v11 = v17;
    uint64_t v12 = v6;
    if (v17 != v6)
    {
      do
      {
        uint64_t v14 = *--v11;
        uint64_t v13 = v14;
        void *v11 = 0;
        if (v14)
        {
          uint64_t v15 = sub_19E37059C(v13);
          MEMORY[0x19F3BDCF0](v15, 0x1032C4057ACE4D0);
        }
      }
      while (v11 != v6);
      uint64_t v12 = __p;
    }
    uint64_t v17 = v6;
    operator delete(v12);
  }
}

void sub_19E3ECA48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3D3F84((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E3ECA60(void *a1, void *a2, uint64_t *a3, uint64_t *a4, uint64_t a5, unint64_t a6)
{
  char v9 = (void **)a1;
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v276 = *MEMORY[0x1E4F143B8];
  v249 = 0;
  v250 = 0;
  v251 = 0;
  v247 = 0;
  uint64_t v248 = 0;
  v246 = 0;
  v241 = a3;
  uint64_t v13 = *a3;
  uint64_t v14 = *(void *)(*a3 + 24);
  if (*(void *)(*a3 + 32) - v14 == 32)
  {
    if (*(_DWORD *)(v14 + 24) == 1 && a4[1] - *a4 == 8)
    {
      uint64_t v15 = *(void *)*a4;
      uint64_t v17 = *(void *)(v15 + 24);
      uint64_t v16 = *(void *)(v15 + 32);
      if (v17 == v16)
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
        __dst.__r_.__value_.__s.__data_[0] = 0;
      }
      else if (*(char *)(v16 - 9) < 0)
      {
        sub_19E39369C(&__dst, *(void **)(v16 - 32), *(void *)(v16 - 24));
      }
      else
      {
        long long v18 = *(_OWORD *)(v16 - 32);
        __dst.__r_.__value_.__r.__words[2] = *(void *)(v16 - 16);
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v18;
      }
      memset(&v258, 0, sizeof(v258));
      if (*(char *)(v13 + 231) < 0) {
        sub_19E39369C(&v257, *(void **)(v13 + 208), *(void *)(v13 + 216));
      }
      else {
        std::string v257 = *(std::string *)(v13 + 208);
      }
      uint64_t v19 = a2[22];
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        sub_19E39369C(&cf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else {
        std::string cf = __dst;
      }
      if (SHIBYTE(v257.__r_.__value_.__r.__words[2]) < 0) {
        sub_19E39369C(&v252, v257.__r_.__value_.__l.__data_, v257.__r_.__value_.__l.__size_);
      }
      else {
        std::string v252 = v257;
      }
      uint64_t v20 = *(void *)(v19 + 72);
      if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
        sub_19E39369C(&v263, cf.__r_.__value_.__l.__data_, cf.__r_.__value_.__l.__size_);
      }
      else {
        std::string v263 = cf;
      }
      if (SHIBYTE(v252.__r_.__value_.__r.__words[2]) < 0) {
        sub_19E39369C(&v262, v252.__r_.__value_.__l.__data_, v252.__r_.__value_.__l.__size_);
      }
      else {
        std::string v262 = v252;
      }
      unint64_t v21 = *(void **)(v20 + 480);
      if (SHIBYTE(v263.__r_.__value_.__r.__words[2]) < 0) {
        sub_19E39369C(&v265, v263.__r_.__value_.__l.__data_, v263.__r_.__value_.__l.__size_);
      }
      else {
        std::string v265 = v263;
      }
      if (SHIBYTE(v262.__r_.__value_.__r.__words[2]) < 0) {
        sub_19E39369C(&__p, v262.__r_.__value_.__l.__data_, v262.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = v262;
      }
      uint64_t v22 = a4;
      unint64_t v23 = a6;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      unint64_t v26 = sub_19E37BDA4((uint64_t)&v266, (uint64_t *)p_p, size);
      int8x8_t v27 = (int8x8_t)v21[1];
      if (v27)
      {
        unint64_t v28 = v26;
        uint8x8_t v29 = (uint8x8_t)vcnt_s8(v27);
        v29.i16[0] = vaddlv_u8(v29);
        if (v29.u32[0] > 1uLL)
        {
          unint64_t v30 = v26;
          if (v26 >= *(void *)&v27) {
            unint64_t v30 = v26 % *(void *)&v27;
          }
        }
        else
        {
          unint64_t v30 = (*(void *)&v27 - 1) & v26;
        }
        int v31 = *(uint64_t ***)(*v21 + 8 * v30);
        if (v31)
        {
          unint64_t v32 = *v31;
          if (*v31)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v33 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v33 = __p.__r_.__value_.__l.__size_;
            }
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v34 = &__p;
            }
            else {
              unint64_t v34 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            if (v29.u32[0] < 2uLL)
            {
              uint64_t v35 = *(void *)&v27 - 1;
              while (1)
              {
                uint64_t v40 = v32[1];
                if (v40 == v28)
                {
                  uint64_t v41 = *((unsigned __int8 *)v32 + 39);
                  if ((v41 & 0x80u) == 0) {
                    uint64_t v42 = *((unsigned __int8 *)v32 + 39);
                  }
                  else {
                    uint64_t v42 = v32[3];
                  }
                  if (v42 == v33)
                  {
                    if ((v41 & 0x80) != 0)
                    {
                      if (!memcmp((const void *)v32[2], v34, v32[3])) {
                        goto LABEL_85;
                      }
                    }
                    else
                    {
                      if (!*((unsigned char *)v32 + 39)) {
                        goto LABEL_85;
                      }
                      uint64_t v43 = 0;
                      while (*((unsigned __int8 *)v32 + v43 + 16) == v34->__r_.__value_.__s.__data_[v43])
                      {
                        if (v41 == ++v43) {
                          goto LABEL_84;
                        }
                      }
                    }
                  }
                }
                else if ((v40 & v35) != v30)
                {
                  goto LABEL_87;
                }
                unint64_t v32 = (uint64_t *)*v32;
                if (!v32) {
                  goto LABEL_87;
                }
              }
            }
            do
            {
              unint64_t v36 = v32[1];
              if (v36 == v28)
              {
                uint64_t v37 = *((unsigned __int8 *)v32 + 39);
                if ((v37 & 0x80u) == 0) {
                  uint64_t v38 = *((unsigned __int8 *)v32 + 39);
                }
                else {
                  uint64_t v38 = v32[3];
                }
                if (v38 == v33)
                {
                  if ((v37 & 0x80) != 0)
                  {
                    if (!memcmp((const void *)v32[2], v34, v32[3]))
                    {
LABEL_85:
                      CFStringRef theString = 0;
                      v255 = 0;
                      uint64_t v256 = 0;
                      if (SHIBYTE(v265.__r_.__value_.__r.__words[2]) < 0)
                      {
                        sub_19E39369C(&v266, v265.__r_.__value_.__l.__data_, v265.__r_.__value_.__l.__size_);
                      }
                      else
                      {
                        long long v266 = *(_OWORD *)&v265.__r_.__value_.__l.__data_;
                        *(void *)&long long v267 = *((void *)&v265.__r_.__value_.__l + 2);
                      }
                      a4 = v22;
                      sub_19E4BB5FC(v32 + 5, (uint64_t)&v266, (void **)&v258.__r_.__value_.__l.__data_, (char **)&theString);
                      if (SBYTE7(v267) < 0)
                      {
                        p_s1 = (std::string *)&v266;
LABEL_93:
                        operator delete(p_s1->__r_.__value_.__l.__data_);
                      }
                      goto LABEL_94;
                    }
                  }
                  else
                  {
                    if (!*((unsigned char *)v32 + 39)) {
                      goto LABEL_85;
                    }
                    uint64_t v39 = 0;
                    while (*((unsigned __int8 *)v32 + v39 + 16) == v34->__r_.__value_.__s.__data_[v39])
                    {
                      if (v37 == ++v39)
                      {
LABEL_84:
                        if (!v32) {
                          goto LABEL_87;
                        }
                        goto LABEL_85;
                      }
                    }
                  }
                }
              }
              else
              {
                if (v36 >= *(void *)&v27) {
                  v36 %= *(void *)&v27;
                }
                if (v36 != v30) {
                  break;
                }
              }
              unint64_t v32 = (uint64_t *)*v32;
            }
            while (v32);
          }
        }
      }
LABEL_87:
      if (SHIBYTE(v265.__r_.__value_.__r.__words[2]) < 0) {
        sub_19E39369C(&__s1, v265.__r_.__value_.__l.__data_, v265.__r_.__value_.__l.__size_);
      }
      else {
        std::string __s1 = v265;
      }
      a4 = v22;
      v255 = 0;
      uint64_t v256 = 0;
      CFStringRef theString = 0;
      for (i = (void *)v21[2]; i; i = (void *)*i)
      {
        if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_19E39369C(&v266, __s1.__r_.__value_.__l.__data_, __s1.__r_.__value_.__l.__size_);
        }
        else
        {
          long long v266 = *(_OWORD *)&__s1.__r_.__value_.__l.__data_;
          *(void *)&long long v267 = *((void *)&__s1.__r_.__value_.__l + 2);
        }
        sub_19E4BB5FC(i + 5, (uint64_t)&v266, (void **)&v258.__r_.__value_.__l.__data_, (char **)&theString);
        if (SBYTE7(v267) < 0) {
          operator delete((void *)v266);
        }
      }
      if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0)
      {
        p_s1 = &__s1;
        goto LABEL_93;
      }
LABEL_94:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v265.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_96:
          if ((SHIBYTE(v262.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_97;
          }
          goto LABEL_111;
        }
      }
      else if ((SHIBYTE(v265.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_96;
      }
      operator delete(v265.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v262.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_97:
        if ((SHIBYTE(v263.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_98;
        }
        goto LABEL_112;
      }
LABEL_111:
      operator delete(v262.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v263.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_98:
        if ((SHIBYTE(v252.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_99;
        }
        goto LABEL_113;
      }
LABEL_112:
      operator delete(v263.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v252.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_99:
        if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_100:
          if (v255 != theString)
          {
            if (0xEEEEEEEEEEEEEEEFLL
               * ((uint64_t)(v258.__r_.__value_.__l.__size_ - v258.__r_.__value_.__r.__words[0]) >> 3))
            {
              sub_19E3E9B48((uint64_t)&v266, (uint64_t)theString, (uint64_t)theString, (uint64_t)v258.__r_.__value_.__l.__data_);
            }
            sub_19E3F1CB4();
          }
          char v9 = (void **)a1;
          if (v255) {
            operator delete(v255);
          }
          if (SHIBYTE(v257.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v257.__r_.__value_.__l.__data_);
          }
          a6 = v23;
          if (v258.__r_.__value_.__r.__words[0]) {
            operator delete(v258.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          uint64_t v12 = (uint64_t)v250;
          unint64_t v11 = v246;
          uint64_t v10 = (uint64_t)v247;
          goto LABEL_124;
        }
LABEL_114:
        operator delete(cf.__r_.__value_.__l.__data_);
        goto LABEL_100;
      }
LABEL_113:
      operator delete(v252.__r_.__value_.__l.__data_);
      if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_100;
      }
      goto LABEL_114;
    }
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    uint64_t v12 = 0;
  }
LABEL_124:
  sub_19E3EEC08((uint64_t *)&v249, v12, (uint64_t)v11, v10, (v10 - (uint64_t)v11) >> 3);
  uint64_t v46 = a2[22];
  *(void *)&long long v266 = &unk_1EF0BDB38;
  *((void *)&v266 + 1) = &v249;
  *((void *)&v267 + 1) = &v266;
  sub_19E53F7A4(v46, v241, *a4, a4[1]);
  if (*((long long **)&v267 + 1) == &v266)
  {
    (*(void (**)(long long *))(v266 + 32))(&v266);
    uint64_t v47 = a2;
  }
  else
  {
    uint64_t v47 = a2;
    if (*((void *)&v267 + 1)) {
      (*(void (**)(void))(**((void **)&v267 + 1) + 40))();
    }
  }
  unint64_t v48 = v250;
  unint64_t v239 = ((char *)v250 - (unsigned char *)v249) >> 3;
  if (v239 >= a6)
  {
    *char v9 = v249;
    v9[1] = v48;
    v9[2] = v251;
    v250 = 0;
    v251 = 0;
    v249 = 0;
    goto LABEL_484;
  }
  v240 = a4;
  uint64_t v50 = v47[16];
  uint64_t v49 = (std::__shared_weak_count *)v47[17];
  uint64_t v245 = 0;
  if (v49) {
    atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v51 = (void *)*v241;
  uint64_t v52 = *(void *)*v241;
  if (*(void *)(*v241 + 8) - v52 == 32 && *(_DWORD *)(v52 + 24) == 1)
  {
    uint64_t v53 = (uint64_t **)*v240;
    if (v240[1] - *v240 == 8)
    {
      long long v54 = *v53;
      uint64_t v55 = **v53;
      if (v54[1] - v55 == 32 && !(*(char *)(v55 + 23) < 0 ? *(void *)(v55 + 8) : *(unsigned __int8 *)(v55 + 23)))
      {
        v233 = (void *)v47[24];
        if (v233)
        {
          if (*v233 != v233[1])
          {
            sub_19E371884(&v257, v233);
            goto LABEL_304;
          }
        }
      }
    }
  }
  uint64_t v57 = (uint64_t)(v51[4] - v51[3]) >> 5;
  *(void *)&long long v266 = v51[3];
  *((void *)&v266 + 1) = v57;
  sub_19E4DE5C8(&v265, (long long **)&v266);
  sub_19E3DDC6C((uint64_t *)&__p, (uint64_t)v47, (uint64_t)&v265, v240);
  (*(void (**)(std::string *__return_ptr, uint64_t, std::string *, void, uint64_t *))(*(void *)v50 + 16))(&v263, v50, &__p, v47[11], &v245);
  memset(&v257, 0, sizeof(v257));
  std::string::size_type v59 = v263.__r_.__value_.__l.__size_;
  std::string::size_type v58 = v263.__r_.__value_.__r.__words[0];
  if (v263.__r_.__value_.__r.__words[0] == v263.__r_.__value_.__l.__size_) {
    goto LABEL_283;
  }
  unint64_t v238 = a6;
  do
  {
    if (*(char *)(v58 + 23) < 0)
    {
      uint64_t v61 = *(const UInt8 **)v58;
      if (!*(void *)v58)
      {
        CFStringRef v62 = 0;
        __s1.__r_.__value_.__r.__words[0] = 0;
        goto LABEL_150;
      }
      CFIndex v60 = *(void *)(v58 + 8);
    }
    else
    {
      CFIndex v60 = *(unsigned __int8 *)(v58 + 23);
      uint64_t v61 = (const UInt8 *)v58;
    }
    CFStringRef v62 = CFStringCreateWithBytes(0, v61, v60, 0x8000100u, 0);
    __s1.__r_.__value_.__r.__words[0] = (std::string::size_type)v62;
    if (!v62)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
LABEL_150:
    sub_19E4D1F64(&v266, (void *)(v58 + 32));
    if ((SBYTE7(v267) & 0x80u) == 0) {
      int v63 = (const UInt8 *)&v266;
    }
    else {
      int v63 = (const UInt8 *)v266;
    }
    if (v63)
    {
      if ((SBYTE7(v267) & 0x80u) == 0) {
        CFIndex v64 = BYTE7(v267);
      }
      else {
        CFIndex v64 = *((void *)&v266 + 1);
      }
      CFStringRef v65 = CFStringCreateWithBytes(0, v63, v64, 0x8000100u, 0);
      v262.__r_.__value_.__r.__words[0] = (std::string::size_type)v65;
      if (!v65)
      {
        v235 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](v235, "Could not construct");
        __cxa_throw(v235, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    else
    {
      CFStringRef v65 = 0;
      v262.__r_.__value_.__r.__words[0] = 0;
    }
    CFComparisonResult v66 = CFStringCompare(v62, v65, 0x81uLL);
    if (v65) {
      CFRelease(v65);
    }
    if ((SBYTE7(v267) & 0x80000000) == 0)
    {
      if (!v62) {
        goto LABEL_167;
      }
LABEL_166:
      CFRelease(v62);
      goto LABEL_167;
    }
    operator delete((void *)v266);
    if (v62) {
      goto LABEL_166;
    }
LABEL_167:
    if (v66 && !sub_19E3EB8D8(v58, (uint64_t)v265.__r_.__value_.__l.__data_, v265.__r_.__value_.__l.__size_))
    {
      *(void *)&long long v267 = 0;
      WORD4(v267) = 0;
      LOBYTE(v268) = 1;
      long long v272 = xmmword_19E572FD0;
      unint64_t v273 = 0xFFEFFFFFFFFFFFFFLL;
      uint64_t v274 = 0;
      uint64_t v275 = 0;
      double v67 = *(float *)(v58 + 24);
      uint64_t v270 = 0x3FF0000000000000;
      double v269 = v67;
      int v271 = 2;
      *(double *)&long long v266 = v67;
      *((double *)&v266 + 1) = v67;
      if (*(char *)(v58 + 23) < 0)
      {
        sub_19E39369C(&v262, *(void **)v58, *(void *)(v58 + 8));
      }
      else
      {
        long long v68 = *(_OWORD *)v58;
        v262.__r_.__value_.__r.__words[2] = *(void *)(v58 + 16);
        *(_OWORD *)&v262.__r_.__value_.__l.__data_ = v68;
      }
      if (*(char *)(v58 + 23) < 0)
      {
        sub_19E39369C(&__dst, *(void **)v58, *(void *)(v58 + 8));
      }
      else
      {
        long long v69 = *(_OWORD *)v58;
        __dst.__r_.__value_.__r.__words[2] = *(void *)(v58 + 16);
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v69;
      }
      uint64_t v70 = v47[22];
      std::string::size_type v71 = *(void *)(v70 + 72);
      char v72 = *(std::__shared_weak_count **)(v70 + 80);
      __s1.__r_.__value_.__r.__words[0] = v71;
      __s1.__r_.__value_.__l.__size_ = (std::string::size_type)v72;
      if (v72) {
        atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v73 = (*(uint64_t (**)(std::string::size_type))(*(void *)v71 + 64))(v71);
      CFStringRef v74 = (const __CFString *)MEMORY[0x19F3BCDE0](v73);
      CFComparisonResult v75 = CFStringCompare(v74, @"zh-Hans", 0);
      CFComparisonResult v76 = v75;
      if (v72 && !atomic_fetch_add(&v72->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
        std::__shared_weak_count::__release_weak(v72);
        if (v76 == kCFCompareEqualTo) {
          goto LABEL_273;
        }
      }
      else if (v75 == kCFCompareEqualTo)
      {
        goto LABEL_273;
      }
      sub_19E5483D0(&__s1, v47[22], v58, 0);
      if (v260)
      {
        if (v51[1] != *v51)
        {
          uint64_t v77 = (std::string *)v58;
          if ((std::string *)v58 != &__dst)
          {
LABEL_184:
            char v78 = HIBYTE(v77->__r_.__value_.__r.__words[2]);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
            {
              if (v78 >= 0) {
                uint64_t v86 = v77;
              }
              else {
                uint64_t v86 = (std::string *)v77->__r_.__value_.__r.__words[0];
              }
              if (v78 >= 0) {
                size_t v87 = HIBYTE(v77->__r_.__value_.__r.__words[2]);
              }
              else {
                size_t v87 = v77->__r_.__value_.__l.__size_;
              }
              sub_19E3C6D44((void **)&__dst.__r_.__value_.__l.__data_, v86, v87);
            }
            else if ((*((unsigned char *)&v77->__r_.__value_.__s + 23) & 0x80) != 0)
            {
              sub_19E3C6C7C(&__dst, v77->__r_.__value_.__l.__data_, v77->__r_.__value_.__l.__size_);
            }
            else
            {
              long long v79 = *(_OWORD *)&v77->__r_.__value_.__l.__data_;
              __dst.__r_.__value_.__r.__words[2] = v77->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v79;
            }
          }
          if (!v260) {
            sub_19E3F1AD4();
          }
          if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            v91 = &__s1;
          }
          else {
            v91 = (std::string *)__s1.__r_.__value_.__r.__words[0];
          }
          if (v91)
          {
            if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v92 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v92 = __s1.__r_.__value_.__l.__size_;
            }
            CFStringRef v93 = CFStringCreateWithBytes(0, (const UInt8 *)v91, v92, 0x8000100u, 0);
            CFStringRef theString = v93;
            uint64_t v94 = a2;
            if (!v93)
            {
              v237 = __cxa_allocate_exception(0x10uLL);
              MEMORY[0x19F3BD790](v237, "Could not construct");
              __cxa_throw(v237, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
            }
            int v95 = *(char *)(v58 + 23);
            if ((v95 & 0x80000000) == 0)
            {
LABEL_232:
              CFIndex v96 = v95;
              uint64_t v97 = (const UInt8 *)v58;
              goto LABEL_236;
            }
          }
          else
          {
            CFStringRef v93 = 0;
            CFStringRef theString = 0;
            uint64_t v94 = a2;
            int v95 = *(char *)(v58 + 23);
            if ((v95 & 0x80000000) == 0) {
              goto LABEL_232;
            }
          }
          uint64_t v97 = *(const UInt8 **)v58;
          if (*(void *)v58)
          {
            CFIndex v96 = *(void *)(v58 + 8);
LABEL_236:
            CFStringRef v98 = CFStringCreateWithBytes(0, v97, v96, 0x8000100u, 0);
            cf.__r_.__value_.__r.__words[0] = (std::string::size_type)v98;
            if (!v98)
            {
              v236 = __cxa_allocate_exception(0x10uLL);
              MEMORY[0x19F3BD790](v236, "Could not construct");
              __cxa_throw(v236, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
            }
            CFStringRef v93 = theString;
          }
          else
          {
            CFStringRef v98 = 0;
            cf.__r_.__value_.__r.__words[0] = 0;
          }
          CFIndex Length = CFStringGetLength(v93);
          uint64_t v100 = v94[22];
          std::string::size_type v101 = *(void *)(v100 + 72);
          std::string::size_type v102 = *(void *)(v100 + 80);
          v258.__r_.__value_.__r.__words[0] = v101;
          v258.__r_.__value_.__l.__size_ = v102;
          if (v102) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v102 + 8), 1uLL, memory_order_relaxed);
          }
          CFLocaleRef v103 = (const __CFLocale *)(*(uint64_t (**)(std::string::size_type))(*(void *)v101 + 64))(v101);
          v277.location = 0;
          v277.length = Length;
          CFComparisonResult v104 = CFStringCompareWithOptionsAndLocale(v93, v98, v277, 0x80uLL, v103);
          CFComparisonResult v105 = v104;
          v106 = (std::__shared_weak_count *)v258.__r_.__value_.__l.__size_;
          if (v258.__r_.__value_.__l.__size_
            && !atomic_fetch_add((atomic_ullong *volatile)(v258.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
            std::__shared_weak_count::__release_weak(v106);
            int v107 = v260;
            if (v105 == kCFCompareEqualTo)
            {
LABEL_243:
              if (v107)
              {
                if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
                  sub_19E39369C(&v258, __s1.__r_.__value_.__l.__data_, __s1.__r_.__value_.__l.__size_);
                }
                else {
                  std::string v258 = __s1;
                }
              }
              else
              {
                *((unsigned char *)&v258.__r_.__value_.__s + 23) = 0;
                v258.__r_.__value_.__s.__data_[0] = 0;
              }
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__dst.__r_.__value_.__l.__data_);
              }
              std::string __dst = v258;
              int v107 = v260;
            }
          }
          else
          {
            int v107 = v260;
            if (v104 == kCFCompareEqualTo) {
              goto LABEL_243;
            }
          }
          if (!v107) {
            sub_19E3F1AD4();
          }
          if (SHIBYTE(v262.__r_.__value_.__r.__words[2]) < 0)
          {
            if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              v108 = &__s1;
            }
            else {
              v108 = (std::string *)__s1.__r_.__value_.__r.__words[0];
            }
            if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v109 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v109 = __s1.__r_.__value_.__l.__size_;
            }
            sub_19E3C6D44((void **)&v262.__r_.__value_.__l.__data_, v108, v109);
          }
          else if ((*((unsigned char *)&__s1.__r_.__value_.__s + 23) & 0x80) != 0)
          {
            sub_19E3C6C7C(&v262, __s1.__r_.__value_.__l.__data_, __s1.__r_.__value_.__l.__size_);
          }
          else
          {
            std::string v262 = __s1;
          }
          if (cf.__r_.__value_.__r.__words[0]) {
            CFRelease(cf.__r_.__value_.__l.__data_);
          }
          if (theString) {
            CFRelease(theString);
          }
          if (v260 && SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__s1.__r_.__value_.__l.__data_);
          }
LABEL_273:
          uint64_t v110 = *(void *)(v58 + 64);
          if (*(void *)(v58 + 56) == v110)
          {
            *((unsigned char *)&__s1.__r_.__value_.__s + 23) = 0;
            __s1.__r_.__value_.__s.__data_[0] = 0;
          }
          else if (*(char *)(v110 - 9) < 0)
          {
            sub_19E39369C(&__s1, *(void **)(v110 - 32), *(void *)(v110 - 24));
          }
          else
          {
            long long v111 = *(_OWORD *)(v110 - 32);
            __s1.__r_.__value_.__r.__words[2] = *(void *)(v110 - 16);
            *(_OWORD *)&__s1.__r_.__value_.__l.__data_ = v111;
          }
          sub_19E3E9B48((uint64_t)&v258, (uint64_t)&v262, (uint64_t)&__dst, (uint64_t)&v266);
        }
        int v80 = SHIBYTE(__s1.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0)
        {
          long long v88 = *(_OWORD *)&__s1.__r_.__value_.__l.__data_;
          size_t v89 = __s1.__r_.__value_.__l.__size_ != 0;
          if (memcmp(__s1.__r_.__value_.__l.__data_, "I", v89) || *((void *)&v88 + 1) != 1)
          {
            size_t v90 = *((void *)&v88 + 1) >= 3uLL ? 3 : *((void *)&v88 + 1);
            if ((memcmp((const void *)v88, "I'm", v90) || *((void *)&v88 + 1) != 3)
              && (memcmp((const void *)v88, "i", v89) || *((void *)&v88 + 1) != 1))
            {
              uint64_t v77 = &__s1;
              if (memcmp((const void *)v88, "i'm", v90) || *((void *)&v88 + 1) != 3) {
                goto LABEL_184;
              }
            }
          }
          operator delete((void *)v88);
        }
        else
        {
          int v81 = memcmp(&__s1, "I", SHIBYTE(__s1.__r_.__value_.__r.__words[2]) != 0);
          if (v80 != 1 || v81)
          {
            size_t v82 = v80 >= 3u ? 3 : v80;
            int v83 = memcmp(&__s1, "I'm", v82);
            if (v80 != 3 || v83)
            {
              int v84 = memcmp(&__s1, "i", v80 != 0);
              if (v80 != 1 || v84)
              {
                uint64_t v77 = &__s1;
                int v85 = memcmp(&__s1, "i'm", v82);
                if (v80 != 3 || v85) {
                  goto LABEL_184;
                }
              }
            }
          }
        }
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__dst.__r_.__value_.__l.__data_);
        if (SHIBYTE(v262.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_281;
        }
      }
      else if (SHIBYTE(v262.__r_.__value_.__r.__words[2]) < 0)
      {
LABEL_281:
        operator delete(v262.__r_.__value_.__l.__data_);
      }
      uint64_t v47 = a2;
    }
    v58 += 216;
  }
  while (v58 != v59);
  std::string::size_type v58 = v263.__r_.__value_.__r.__words[0];
  char v9 = (void **)a1;
  a6 = v238;
LABEL_283:
  if (v58)
  {
    std::string::size_type v112 = v263.__r_.__value_.__l.__size_;
    uint64_t v113 = (void *)v58;
    if (v263.__r_.__value_.__l.__size_ != v58)
    {
      do
      {
        sub_19E3C3D24((void **)(v112 - 184));
        if (*(char *)(v112 - 193) < 0) {
          operator delete(*(void **)(v112 - 216));
        }
        v112 -= 216;
      }
      while (v112 != v58);
      uint64_t v113 = (void *)v263.__r_.__value_.__r.__words[0];
    }
    v263.__r_.__value_.__l.__size_ = v58;
    operator delete(v113);
  }
  std::string::size_type v114 = __p.__r_.__value_.__r.__words[0];
  if (__p.__r_.__value_.__r.__words[0])
  {
    std::string::size_type v115 = __p.__r_.__value_.__l.__size_;
    v116 = (void *)__p.__r_.__value_.__r.__words[0];
    if (__p.__r_.__value_.__l.__size_ != __p.__r_.__value_.__r.__words[0])
    {
      do
        std::string::size_type v115 = (std::string::size_type)sub_19E3C3D24((void **)(v115 - 184));
      while (v115 != v114);
      v116 = (void *)__p.__r_.__value_.__r.__words[0];
    }
    __p.__r_.__value_.__l.__size_ = v114;
    operator delete(v116);
  }
  std::string::size_type v117 = v265.__r_.__value_.__r.__words[0];
  if (v265.__r_.__value_.__r.__words[0])
  {
    std::string::size_type v118 = v265.__r_.__value_.__l.__size_;
    v119 = (void *)v265.__r_.__value_.__r.__words[0];
    if (v265.__r_.__value_.__l.__size_ != v265.__r_.__value_.__r.__words[0])
    {
      do
      {
        if (*(char *)(v118 - 9) < 0) {
          operator delete(*(void **)(v118 - 32));
        }
        v118 -= 32;
      }
      while (v118 != v117);
      v119 = (void *)v265.__r_.__value_.__r.__words[0];
    }
    v265.__r_.__value_.__l.__size_ = v117;
    operator delete(v119);
  }
LABEL_304:
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
    std::__shared_weak_count::__release_weak(v49);
  }
  sub_19E3EEC08((uint64_t *)&v249, (uint64_t)v250, (uint64_t)v257.__r_.__value_.__l.__data_, v257.__r_.__value_.__l.__size_, (uint64_t)(v257.__r_.__value_.__l.__size_ - v257.__r_.__value_.__r.__words[0]) >> 3);
  __p.__r_.__value_.__r.__words[0] = 0;
  v263.__r_.__value_.__r.__words[0] = 0;
  uint64_t v120 = a2[22];
  uint64_t v121 = operator new(0x38uLL);
  *uint64_t v121 = &unk_1EF0BDB90;
  v121[1] = &v263;
  v121[2] = &v249;
  v121[3] = &__p;
  v121[4] = v240;
  v121[5] = v241;
  v121[6] = a2;
  *((void *)&v267 + 1) = v121;
  sub_19E53F7A4(v120, v241, *v240, v240[1]);
  if (*((long long **)&v267 + 1) == &v266)
  {
    (*(void (**)(long long *))(v266 + 32))(&v266);
  }
  else if (*((void *)&v267 + 1))
  {
    (*(void (**)(void))(**((void **)&v267 + 1) + 40))();
  }
  unint64_t v122 = v239 + a6;
  uint64_t v124 = (char *)v249;
  v123 = v250;
  if (v239 + a6 >= ((char *)v250 - (unsigned char *)v249) >> 3)
  {
    v126 = v250;
  }
  else
  {
    int v125 = v250 - 1;
    v126 = v250;
    do
    {
      uint64_t v127 = *v125;
      *int v125 = 0;
      if (v127)
      {
        uint64_t v128 = sub_19E37059C(v127);
        MEMORY[0x19F3BDCF0](v128, 0x1032C4057ACE4D0);
      }
      v250 = v125;
      uint64_t v124 = (char *)v249;
      --v126;
      --v125;
    }
    while (v122 < ((char *)v126 - (unsigned char *)v249) >> 3);
    v123 = v125 + 1;
  }
  v129 = (uint64_t *)&v124[8 * v239];
  unint64_t v130 = 126 - 2 * __clz(v126 - v129);
  if (v123 == v129) {
    uint64_t v131 = 0;
  }
  else {
    uint64_t v131 = v130;
  }
  sub_19E3EF1E4(v129, v123, v131, 1);
  *char v9 = 0;
  v9[1] = 0;
  v9[2] = 0;
  long long v266 = 0u;
  long long v267 = 0u;
  int v268 = 1065353216;
  v132 = (char *)v249;
  v243 = v250;
  if (v249 != v250)
  {
    v133 = 0;
    v134 = 0;
    while (1)
    {
      unint64_t v137 = *(void *)(*(void *)v132 + 248);
      v262.__r_.__value_.__r.__words[0] = v137;
      if (*((void *)&v266 + 1))
      {
        uint8x8_t v138 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v266 + 8));
        v138.i16[0] = vaddlv_u8(v138);
        if (v138.u32[0] > 1uLL)
        {
          unint64_t v139 = v137;
          if (v137 >= *((void *)&v266 + 1)) {
            unint64_t v139 = v137 % *((void *)&v266 + 1);
          }
        }
        else
        {
          unint64_t v139 = (*((void *)&v266 + 1) - 1) & v137;
        }
        v140 = *(void **)(v266 + 8 * v139);
        if (v140)
        {
          v141 = (void *)*v140;
          if (v141)
          {
            if (v138.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v143 = v141[1];
                if (v143 == v137)
                {
                  if (v141[2] == v137) {
                    goto LABEL_350;
                  }
                }
                else if ((v143 & (*((void *)&v266 + 1) - 1)) != v139)
                {
                  goto LABEL_346;
                }
                v141 = (void *)*v141;
                if (!v141) {
                  goto LABEL_346;
                }
              }
            }
            do
            {
              unint64_t v142 = v141[1];
              if (v142 == v137)
              {
                if (v141[2] == v137) {
                  goto LABEL_350;
                }
              }
              else
              {
                if (v142 >= *((void *)&v266 + 1)) {
                  v142 %= *((void *)&v266 + 1);
                }
                if (v142 != v139) {
                  break;
                }
              }
              v141 = (void *)*v141;
            }
            while (v141);
          }
        }
      }
LABEL_346:
      v144 = sub_19E3EFCE0((uint64_t *)&v266, v137, &v262);
      uint64_t v145 = *((void *)v144 + 4);
      if (v145)
      {
        for (uint64_t j = 0; j != v145; ++j)
          *(void *)(*((void *)v144 + 3) + 8 * j) = 0;
        v147 = (void **)*((void *)v144 + 5);
        *((void *)v144 + 5) = 0;
        *((void *)v144 + 6) = 0;
        if (v147)
        {
          do
          {
            v150 = (void **)*v147;
            if (*((char *)v147 + 39) < 0) {
              operator delete(v147[2]);
            }
            operator delete(v147);
            v147 = v150;
          }
          while (v150);
        }
      }
LABEL_350:
      v148 = sub_19E3EFCE0((uint64_t *)&v266, v137, &v262);
      uint64_t v149 = *(void *)v132;
      if (*(char *)(*(void *)v132 + 47) < 0) {
        sub_19E39369C(&v265, *(void **)(v149 + 24), *(void *)(v149 + 32));
      }
      else {
        std::string v265 = *(std::string *)(v149 + 24);
      }
      MEMORY[0x19F3BDBC0](&__dst);
      if ((v265.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v151 = &v265;
      }
      else {
        v151 = (std::string *)v265.__r_.__value_.__r.__words[0];
      }
      std::string::size_type v152 = HIBYTE(v265.__r_.__value_.__r.__words[2]);
      if ((v265.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v152 = v265.__r_.__value_.__l.__size_;
      }
      sub_19E3DCA10(&__s1, (char *)v151, (std::locale *)&__dst, (char *)v151 + v152);
      if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v153 = &__s1;
      }
      else {
        v153 = (std::string *)__s1.__r_.__value_.__r.__words[0];
      }
      if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v154 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v154 = __s1.__r_.__value_.__l.__size_;
      }
      unint64_t v155 = sub_19E37BDA4((uint64_t)&v258, (uint64_t *)v153, v154);
      int8x8_t v156 = *(int8x8_t *)(v148 + 32);
      if (v156)
      {
        unint64_t v157 = v155;
        uint8x8_t v158 = (uint8x8_t)vcnt_s8(v156);
        v158.i16[0] = vaddlv_u8(v158);
        if (v158.u32[0] > 1uLL)
        {
          unint64_t v159 = v155;
          if (v155 >= *(void *)&v156) {
            unint64_t v159 = v155 % *(void *)&v156;
          }
        }
        else
        {
          unint64_t v159 = (*(void *)&v156 - 1) & v155;
        }
        v160 = *(uint64_t ***)(*((void *)v148 + 3) + 8 * v159);
        if (v160)
        {
          v161 = *v160;
          if (*v160)
          {
            if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v162 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v162 = __s1.__r_.__value_.__l.__size_;
            }
            if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              v163 = &__s1;
            }
            else {
              v163 = (std::string *)__s1.__r_.__value_.__r.__words[0];
            }
            if (v158.u32[0] < 2uLL)
            {
              uint64_t v164 = *(void *)&v156 - 1;
              while (1)
              {
                uint64_t v172 = v161[1];
                if (v172 == v157)
                {
                  uint64_t v173 = *((unsigned __int8 *)v161 + 39);
                  if ((v173 & 0x80u) == 0) {
                    uint64_t v174 = *((unsigned __int8 *)v161 + 39);
                  }
                  else {
                    uint64_t v174 = v161[3];
                  }
                  if (v174 == v162)
                  {
                    if ((v173 & 0x80) != 0)
                    {
                      std::string::size_type v176 = v162;
                      int v177 = memcmp((const void *)v161[2], v163, v161[3]);
                      std::string::size_type v162 = v176;
                      if (!v177) {
                        goto LABEL_413;
                      }
                    }
                    else
                    {
                      if (!*((unsigned char *)v161 + 39)) {
                        goto LABEL_413;
                      }
                      uint64_t v175 = 0;
                      while (*((unsigned __int8 *)v161 + v175 + 16) == v163->__r_.__value_.__s.__data_[v175])
                      {
                        if (v173 == ++v175) {
                          goto LABEL_413;
                        }
                      }
                    }
                  }
                }
                else if ((v172 & v164) != v159)
                {
                  goto LABEL_414;
                }
                v165 = 0;
                v161 = (uint64_t *)*v161;
                if (!v161) {
                  goto LABEL_415;
                }
              }
            }
            while (1)
            {
              unint64_t v166 = v161[1];
              if (v166 == v157)
              {
                uint64_t v167 = *((unsigned __int8 *)v161 + 39);
                if ((v167 & 0x80u) == 0) {
                  uint64_t v168 = *((unsigned __int8 *)v161 + 39);
                }
                else {
                  uint64_t v168 = v161[3];
                }
                if (v168 == v162)
                {
                  if ((v167 & 0x80) != 0)
                  {
                    std::string::size_type v170 = v162;
                    int v171 = memcmp((const void *)v161[2], v163, v161[3]);
                    std::string::size_type v162 = v170;
                    if (!v171)
                    {
LABEL_413:
                      v165 = v161;
                      goto LABEL_415;
                    }
                  }
                  else
                  {
                    if (!*((unsigned char *)v161 + 39)) {
                      goto LABEL_413;
                    }
                    uint64_t v169 = 0;
                    while (*((unsigned __int8 *)v161 + v169 + 16) == v163->__r_.__value_.__s.__data_[v169])
                    {
                      if (v167 == ++v169) {
                        goto LABEL_413;
                      }
                    }
                  }
                }
              }
              else
              {
                if (v166 >= *(void *)&v156) {
                  v166 %= *(void *)&v156;
                }
                if (v166 != v159) {
                  break;
                }
              }
              v165 = 0;
              v161 = (uint64_t *)*v161;
              if (!v161) {
                goto LABEL_415;
              }
            }
          }
        }
      }
LABEL_414:
      v165 = 0;
LABEL_415:
      sub_19E3EFCE0((uint64_t *)&v266, v137, &v262);
      if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__s1.__r_.__value_.__l.__data_);
      }
      std::locale::~locale((std::locale *)&__dst);
      if (SHIBYTE(v265.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v265.__r_.__value_.__l.__data_);
        if (v165) {
          goto LABEL_325;
        }
      }
      else if (v165)
      {
        goto LABEL_325;
      }
      v178 = sub_19E3EFCE0((uint64_t *)&v266, v137, &v262);
      uint64_t v179 = *(void *)v132;
      if (*(char *)(*(void *)v132 + 47) < 0) {
        sub_19E39369C(&v265, *(void **)(v179 + 24), *(void *)(v179 + 32));
      }
      else {
        std::string v265 = *(std::string *)(v179 + 24);
      }
      MEMORY[0x19F3BDBC0](&__dst);
      if ((v265.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v180 = &v265;
      }
      else {
        v180 = (std::string *)v265.__r_.__value_.__r.__words[0];
      }
      std::string::size_type v181 = HIBYTE(v265.__r_.__value_.__r.__words[2]);
      if ((v265.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v181 = v265.__r_.__value_.__l.__size_;
      }
      sub_19E3DCA10(&__s1, (char *)v180, (std::locale *)&__dst, (char *)v180 + v181);
      sub_19E3F0170((uint64_t)(v178 + 24), (uint64_t)&__s1, (uint64_t)&__s1);
      if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__s1.__r_.__value_.__l.__data_);
      }
      std::locale::~locale((std::locale *)&__dst);
      if (SHIBYTE(v265.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v265.__r_.__value_.__l.__data_);
      }
      unint64_t v182 = a1[2];
      if ((unint64_t)v134 >= v182) {
        break;
      }
      uint64_t v135 = *(void *)v132;
      *(void *)v132 = 0;
      *(void *)v134 = v135;
      v136 = v134 + 8;
LABEL_324:
      a1[1] = v136;
      v134 = v136;
LABEL_325:
      v132 += 8;
      if (v132 == (char *)v243)
      {
        v209 = (void *)v267;
        if ((void)v267)
        {
          do
          {
            v217 = (void *)*v209;
            v218 = (void **)v209[5];
            if (v218)
            {
              do
              {
                v220 = (void **)*v218;
                if (*((char *)v218 + 39) < 0) {
                  operator delete(v218[2]);
                }
                operator delete(v218);
                v218 = v220;
              }
              while (v220);
            }
            v219 = (void *)v209[3];
            v209[3] = 0;
            if (v219) {
              operator delete(v219);
            }
            operator delete(v209);
            v209 = v217;
          }
          while (v217);
        }
        v210 = (void *)v266;
        *(void *)&long long v266 = 0;
        if (v210) {
          operator delete(v210);
        }
        goto LABEL_469;
      }
    }
    int64_t v183 = v134 - v133;
    uint64_t v184 = (v134 - v133) >> 3;
    unint64_t v185 = v184 + 1;
    if ((unint64_t)(v184 + 1) >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v186 = v182 - (void)v133;
    if (v186 >> 2 > v185) {
      unint64_t v185 = v186 >> 2;
    }
    if ((unint64_t)v186 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v187 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v187 = v185;
    }
    if (v187)
    {
      if (v187 >> 61) {
        sub_19E37C2B8();
      }
      v188 = (char *)operator new(8 * v187);
    }
    else
    {
      v188 = 0;
    }
    v133 = &v188[8 * v184];
    v189 = &v188[8 * v187];
    uint64_t v190 = *(void *)v132;
    *(void *)v132 = 0;
    *(void *)v133 = v190;
    v136 = v133 + 8;
    v191 = (char *)*a1;
    v192 = &v134[-*a1];
    if (v134 == (char *)*a1)
    {
      *a1 = v133;
      a1[1] = v136;
      a1[2] = v189;
    }
    else
    {
      v193 = v192 - 8;
      if ((unint64_t)(v192 - 8) < 0x138)
      {
        v194 = v134;
        goto LABEL_447;
      }
      unint64_t v200 = (unint64_t)v193 & 0xFFFFFFFFFFFFFFF8;
      if (&v134[-((unint64_t)v193 & 0xFFFFFFFFFFFFFFF8) - 8] > v134 - 8)
      {
        v194 = v134;
        goto LABEL_447;
      }
      if (&v188[v183 - 8 - v200] > &v188[v183 - 8])
      {
        v194 = v134;
        goto LABEL_447;
      }
      unint64_t v201 = (unint64_t)v193 >> 3;
      if (&v134[-8 * v201 - 8] < v133 && &v188[v183 - v200 - 8] < v134)
      {
        v194 = v134;
        goto LABEL_447;
      }
      unint64_t v202 = v201 + 1;
      uint64_t v203 = 8 * (v202 & 0x3FFFFFFFFFFFFFFCLL);
      v194 = &v134[-v203];
      v133 -= v203;
      v204 = &v188[8 * v184 - 16];
      v205 = v134 - 16;
      uint64_t v206 = v202 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v208 = *((_OWORD *)v205 - 1);
        long long v207 = *(_OWORD *)v205;
        *((_OWORD *)v205 - 1) = 0uLL;
        *(_OWORD *)v205 = 0uLL;
        *((_OWORD *)v204 - 1) = v208;
        *(_OWORD *)v204 = v207;
        v204 -= 32;
        v205 -= 32;
        v206 -= 4;
      }
      while (v206);
      if (v202 != (v202 & 0x3FFFFFFFFFFFFFFCLL))
      {
        do
        {
LABEL_447:
          uint64_t v195 = *((void *)v194 - 1);
          v194 -= 8;
          *(void *)v194 = 0;
          *((void *)v133 - 1) = v195;
          v133 -= 8;
        }
        while (v194 != v191);
      }
      v134 = (char *)*a1;
      v196 = (char *)a1[1];
      *a1 = v133;
      a1[1] = v136;
      a1[2] = v189;
      while (v196 != v134)
      {
        uint64_t v198 = *((void *)v196 - 1);
        v196 -= 8;
        uint64_t v197 = v198;
        *(void *)v196 = 0;
        if (v198)
        {
          uint64_t v199 = sub_19E37059C(v197);
          MEMORY[0x19F3BDCF0](v199, 0x1032C4057ACE4D0);
        }
      }
    }
    if (v134) {
      operator delete(v134);
    }
    goto LABEL_324;
  }
LABEL_469:
  std::string::size_type v211 = v257.__r_.__value_.__r.__words[0];
  if (v257.__r_.__value_.__r.__words[0])
  {
    v212 = (void *)v257.__r_.__value_.__l.__size_;
    v213 = (void *)v257.__r_.__value_.__r.__words[0];
    if (v257.__r_.__value_.__l.__size_ != v257.__r_.__value_.__r.__words[0])
    {
      do
      {
        uint64_t v215 = *--v212;
        uint64_t v214 = v215;
        void *v212 = 0;
        if (v215)
        {
          uint64_t v216 = sub_19E37059C(v214);
          MEMORY[0x19F3BDCF0](v216, 0x1032C4057ACE4D0);
        }
      }
      while (v212 != (void *)v211);
      v213 = (void *)v257.__r_.__value_.__r.__words[0];
    }
    v257.__r_.__value_.__l.__size_ = v211;
    operator delete(v213);
  }
LABEL_484:
  v221 = v246;
  if (v246)
  {
    v222 = v247;
    v223 = v246;
    if (v247 != v246)
    {
      do
      {
        uint64_t v225 = *--v222;
        uint64_t v224 = v225;
        void *v222 = 0;
        if (v225)
        {
          uint64_t v226 = sub_19E37059C(v224);
          MEMORY[0x19F3BDCF0](v226, 0x1032C4057ACE4D0);
        }
      }
      while (v222 != v221);
      v223 = v246;
    }
    v247 = v221;
    operator delete(v223);
  }
  v227 = (uint64_t *)v249;
  if (v249)
  {
    v228 = v250;
    v229 = v249;
    if (v250 != v249)
    {
      do
      {
        uint64_t v231 = *--v228;
        uint64_t v230 = v231;
        uint64_t *v228 = 0;
        if (v231)
        {
          uint64_t v232 = sub_19E37059C(v230);
          MEMORY[0x19F3BDCF0](v232, 0x1032C4057ACE4D0);
        }
      }
      while (v228 != v227);
      v229 = v249;
    }
    v250 = v227;
    operator delete(v229);
  }
}

void sub_19E3EE774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,std::locale a60,uint64_t a61,int a62,__int16 a63)
{
  sub_19E3EB09C(&a42);
  if (a76 < 0)
  {
    operator delete(a75);
    if (*(char *)(v76 - 217) < 0)
    {
LABEL_3:
      operator delete(*(void **)(v76 - 240));
      if ((a72 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if (*(char *)(v76 - 217) < 0)
  {
    goto LABEL_3;
  }
  if ((a72 & 0x80000000) == 0)
  {
LABEL_4:
    if (a74 < 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(a67);
  if (a74 < 0)
  {
LABEL_5:
    operator delete(__p);
    if ((a34 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_12:
  if ((a34 & 0x80000000) == 0)
  {
LABEL_6:
    if (a41 < 0) {
      goto LABEL_7;
    }
    goto LABEL_14;
  }
LABEL_13:
  operator delete(a29);
  if (a41 < 0)
  {
LABEL_7:
    operator delete(a36);
    if (a50 < 0)
    {
LABEL_15:
      operator delete(a45);
      char v78 = a52;
      if (a52) {
        goto LABEL_16;
      }
      goto LABEL_19;
    }
LABEL_18:
    char v78 = a52;
    if (a52)
    {
LABEL_16:
      operator delete(v78);
      if ((a65 & 0x80000000) == 0) {
        goto LABEL_21;
      }
LABEL_20:
      operator delete(a60.__locale_);
LABEL_21:
      sub_19E3D3F84(&a23);
      sub_19E3D3F84(&a26);
      _Unwind_Resume(a1);
    }
LABEL_19:
    if ((a65 & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
LABEL_14:
  if (a50 < 0) {
    goto LABEL_15;
  }
  goto LABEL_18;
}

uint64_t *sub_19E3EEC08(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  uint64_t v6 = *result;
  unint64_t v7 = result[1];
  uint64_t v8 = a2 - *result;
  uint64_t v9 = v8 >> 3;
  unint64_t v10 = *result + (v8 & 0xFFFFFFFFFFFFFFF8);
  uint64_t v11 = result[2];
  uint64_t v41 = v8;
  if (a5 > (uint64_t)(v11 - v7) >> 3)
  {
    unint64_t v12 = a5 + ((uint64_t)(v7 - v6) >> 3);
    if (!(v12 >> 61))
    {
      uint64_t v13 = v11 - v6;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          sub_19E37C2B8();
        }
        operator new(8 * v14);
      }
      operator new();
    }
    sub_19E37C7C4();
  }
  uint64_t v15 = (uint64_t)(v7 - v10) >> 3;
  if (v15 >= a5)
  {
    uint64_t v16 = a3 + 8 * a5;
    unint64_t v17 = result[1];
    goto LABEL_18;
  }
  uint64_t v16 = a3 + 8 * v15;
  if (v16 != a4) {
    operator new();
  }
  unint64_t v17 = result[1];
  result[1] = v7;
  if ((uint64_t)(v7 - v10) >= 1)
  {
LABEL_18:
    unint64_t v18 = v10 + 8 * a5;
    uint64_t v19 = (uint64_t)(v17 - v18) >> 3;
    uint64_t v20 = (uint64_t *)(v17 - 8 * a5);
    unint64_t v21 = (void *)v17;
    if ((unint64_t)v20 < v7)
    {
      unint64_t v22 = (v41 & 0xFFFFFFFFFFFFFFF8) + v17 - v18;
      uint64_t v23 = v22 + v6;
      unint64_t v24 = v22 + v6 + 8;
      if (v7 > v24) {
        unint64_t v24 = v7;
      }
      unint64_t v25 = v24 + ~v6 - v22;
      if (v25 >= 0xE8)
      {
        unint64_t v26 = v23 + (v25 & 0xFFFFFFFFFFFFFFF8) + 8;
        BOOL v27 = (unint64_t)v20 >= (v25 & 0xFFFFFFFFFFFFFFF8) + v17 + 8 || v17 >= v26;
        unint64_t v21 = (void *)v17;
        if (v27)
        {
          uint64_t v28 = (v25 >> 3) + 1;
          uint64_t v29 = 8 * (v28 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v20 = (uint64_t *)((char *)v20 + v29);
          unint64_t v21 = (void *)(v17 + v29);
          unint64_t v30 = (_OWORD *)(v17 + 16);
          int v31 = (long long *)(8 * v19 + 8 * v9 + v6 + 16);
          uint64_t v32 = v28 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v33 = *(v31 - 1);
            long long v34 = *v31;
            *(v31 - 1) = 0uLL;
            *int v31 = 0uLL;
            *(v30 - 1) = v33;
            *unint64_t v30 = v34;
            v30 += 2;
            v31 += 2;
            v32 -= 4;
          }
          while (v32);
          if (v28 == (v28 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_32;
          }
        }
      }
      else
      {
        unint64_t v21 = (void *)v17;
      }
      do
      {
        uint64_t v35 = *v20;
        *v20++ = 0;
        *v21++ = v35;
      }
      while ((unint64_t)v20 < v7);
    }
LABEL_32:
    result[1] = (uint64_t)v21;
    if (v17 != v18)
    {
      unint64_t v36 = (uint64_t **)(v17 - 8);
      uint64_t v37 = v6 + 8 * v9 - 8;
      uint64_t v38 = 8 * v19;
      do
      {
        uint64_t v39 = *(uint64_t **)(v37 + v38);
        *(void *)(v37 + v38) = 0;
        __n128 result = *v36;
        *unint64_t v36 = v39;
        if (result)
        {
          uint64_t v40 = sub_19E37059C((uint64_t)result);
          __n128 result = (uint64_t *)MEMORY[0x19F3BDCF0](v40, 0x1032C4057ACE4D0);
        }
        --v36;
        v38 -= 8;
      }
      while (v38);
    }
    if (v16 != a3) {
      language_modeling::v1::Prediction::operator=();
    }
  }
  return result;
}

void sub_19E3EF130(void *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x1032C4057ACE4D0);
  sub_19E37B770(a1);
}

void *sub_19E3EF160(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_19E3EF1E4(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v142 = a2 - 1;
  unint64_t v139 = a2 - 3;
  v140 = a2 - 2;
  uint64_t v9 = a1;
  while (1)
  {
    a1 = v9;
    uint64_t v10 = (char *)a2 - (char *)v9;
    uint64_t v11 = a2 - v9;
    if (v5 || !v4)
    {
      switch(v11)
      {
        case 0:
        case 1:
          return;
        case 2:
          uint64_t v66 = *v9;
          if (*(double *)(*v142 + 48) > *(double *)(*v9 + 48))
          {
            *uint64_t v9 = 0;
            uint64_t v67 = *v142;
            *unint64_t v142 = 0;
            uint64_t v68 = *v9;
            *uint64_t v9 = v67;
            if (v68)
            {
              uint64_t v69 = sub_19E37059C(v68);
              MEMORY[0x19F3BDCF0](v69, 0x1032C4057ACE4D0);
            }
            uint64_t v70 = *v142;
            *unint64_t v142 = v66;
            if (v70)
            {
              sub_19E37059C(v70);
              JUMPOUT(0x19F3BDCF0);
            }
          }
          return;
        case 3:
          sub_19E3F0B08(v9, v9 + 1, v142);
          break;
        case 4:
          sub_19E3F0D14(v9, v9 + 1, v9 + 2, v142);
          break;
        case 5:
          sub_19E3F0EB8(v9, v9 + 1, v9 + 2, v9 + 3, v142);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v10 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v9 == a2) {
        return;
      }
      int64_t v86 = (unint64_t)(v11 - 2) >> 1;
      int64_t v87 = v86;
      do
      {
        int64_t v88 = v87;
        if (v86 >= v87)
        {
          uint64_t v89 = (2 * v87) | 1;
          size_t v90 = &a1[v89];
          if (2 * v88 + 2 < v11 && *(double *)(*v90 + 48) > *(double *)(v90[1] + 48))
          {
            ++v90;
            uint64_t v89 = 2 * v88 + 2;
          }
          v91 = &a1[v88];
          uint64_t v92 = *v91;
          if (*(double *)(*v90 + 48) <= *(double *)(*v91 + 48))
          {
            uint64_t *v91 = 0;
            uint64_t v93 = *v90;
            do
            {
              uint64_t v94 = v90;
              uint64_t *v90 = 0;
              uint64_t v95 = *v91;
              uint64_t *v91 = v93;
              if (v95)
              {
                uint64_t v96 = sub_19E37059C(v95);
                MEMORY[0x19F3BDCF0](v96, 0x1032C4057ACE4D0);
              }
              if (v86 < v89) {
                break;
              }
              uint64_t v97 = 2 * v89;
              uint64_t v89 = (2 * v89) | 1;
              size_t v90 = &a1[v89];
              uint64_t v98 = v97 + 2;
              if (v98 < v11 && *(double *)(*v90 + 48) > *(double *)(v90[1] + 48))
              {
                ++v90;
                uint64_t v89 = v98;
              }
              uint64_t v93 = *v90;
              v91 = v94;
            }
            while (*(double *)(*v90 + 48) <= *(double *)(v92 + 48));
            uint64_t v99 = *v94;
            *uint64_t v94 = v92;
            if (v99)
            {
              uint64_t v100 = sub_19E37059C(v99);
              MEMORY[0x19F3BDCF0](v100, 0x1032C4057ACE4D0);
            }
          }
        }
        int64_t v87 = v88 - 1;
      }
      while (v88);
      uint64_t v101 = (unint64_t)v10 >> 3;
      while (2)
      {
        CFComparisonResult v105 = a2;
        uint64_t v106 = 0;
        uint64_t v107 = *a1;
        *a1 = 0;
        v108 = a1;
        do
        {
          std::string::size_type v109 = &v108[v106 + 1];
          uint64_t v110 = 2 * v106;
          uint64_t v106 = (2 * v106) | 1;
          uint64_t v111 = v110 + 2;
          if (v111 < v101 && *(double *)(*v109 + 48) > *(double *)(v109[1] + 48))
          {
            ++v109;
            uint64_t v106 = v111;
          }
          uint64_t v112 = *v109;
          uint64_t *v109 = 0;
          uint64_t v113 = *v108;
          uint64_t *v108 = v112;
          if (v113)
          {
            uint64_t v114 = sub_19E37059C(v113);
            MEMORY[0x19F3BDCF0](v114, 0x1032C4057ACE4D0);
          }
          v108 = v109;
        }
        while (v106 <= (uint64_t)((unint64_t)(v101 - 2) >> 1));
        --a2;
        if (v109 == v105 - 1)
        {
          uint64_t v102 = *v109;
          uint64_t *v109 = v107;
          if (!v102) {
            goto LABEL_127;
          }
        }
        else
        {
          uint64_t v115 = *a2;
          *a2 = 0;
          uint64_t v116 = *v109;
          uint64_t *v109 = v115;
          if (v116)
          {
            uint64_t v117 = sub_19E37059C(v116);
            MEMORY[0x19F3BDCF0](v117, 0x1032C4057ACE4D0);
          }
          uint64_t v118 = *a2;
          *a2 = v107;
          if (v118)
          {
            uint64_t v119 = sub_19E37059C(v118);
            MEMORY[0x19F3BDCF0](v119, 0x1032C4057ACE4D0);
          }
          uint64_t v120 = (char *)(v109 + 1) - (char *)a1;
          if (v120 < 9) {
            goto LABEL_127;
          }
          unint64_t v121 = (((unint64_t)v120 >> 3) - 2) >> 1;
          unint64_t v122 = &a1[v121];
          uint64_t v123 = *v109;
          if (*(double *)(*v122 + 48) <= *(double *)(*v109 + 48)) {
            goto LABEL_127;
          }
          uint64_t v124 = v105 - 1;
          uint64_t *v109 = 0;
          uint64_t v125 = *v122;
          do
          {
            v126 = v122;
            uint64_t *v122 = 0;
            uint64_t v127 = *v109;
            uint64_t *v109 = v125;
            if (v127)
            {
              uint64_t v128 = sub_19E37059C(v127);
              MEMORY[0x19F3BDCF0](v128, 0x1032C4057ACE4D0);
            }
            if (!v121) {
              break;
            }
            unint64_t v121 = (v121 - 1) >> 1;
            unint64_t v122 = &a1[v121];
            uint64_t v125 = *v122;
            std::string::size_type v109 = v126;
          }
          while (*(double *)(*v122 + 48) > *(double *)(v123 + 48));
          uint64_t v102 = *v126;
          uint64_t *v126 = v123;
          a2 = v124;
          if (!v102)
          {
LABEL_127:
            if (v101-- <= 2) {
              return;
            }
            continue;
          }
        }
        break;
      }
      uint64_t v103 = sub_19E37059C(v102);
      MEMORY[0x19F3BDCF0](v103, 0x1032C4057ACE4D0);
      goto LABEL_127;
    }
    unint64_t v12 = (unint64_t)v11 >> 1;
    uint64_t v13 = &v9[(unint64_t)v11 >> 1];
    if ((unint64_t)v10 < 0x401)
    {
      sub_19E3F0B08(v13, v9, v142);
    }
    else
    {
      sub_19E3F0B08(v9, v13, v142);
      uint64_t v14 = v12;
      uint64_t v15 = &v9[v14];
      sub_19E3F0B08(v9 + 1, &v9[v14 - 1], v140);
      sub_19E3F0B08(v9 + 2, &v9[v14 + 1], v139);
      sub_19E3F0B08(&v9[v14 - 1], v13, &v9[v14 + 1]);
      uint64_t v16 = *v9;
      *uint64_t v9 = 0;
      uint64_t v17 = *v15;
      *uint64_t v15 = 0;
      uint64_t v18 = *v9;
      *uint64_t v9 = v17;
      if (v18)
      {
        uint64_t v19 = sub_19E37059C(v18);
        MEMORY[0x19F3BDCF0](v19, 0x1032C4057ACE4D0);
      }
      uint64_t v20 = *v13;
      uint64_t *v13 = v16;
      if (v20)
      {
        uint64_t v21 = sub_19E37059C(v20);
        MEMORY[0x19F3BDCF0](v21, 0x1032C4057ACE4D0);
      }
    }
    --a3;
    uint64_t v22 = *v9;
    if (a4)
    {
      double v23 = *(double *)(v22 + 48);
LABEL_15:
      *uint64_t v9 = 0;
      unint64_t v24 = v9;
      do
      {
        unint64_t v25 = v24;
        uint64_t v27 = v24[1];
        ++v24;
        uint64_t v26 = v27;
      }
      while (*(double *)(v27 + 48) > v23);
      uint64_t v28 = a2;
      if (v25 == a1)
      {
        do
        {
          if (v24 >= a2) {
            break;
          }
          uint64_t v30 = *--a2;
        }
        while (*(double *)(v30 + 48) <= v23);
      }
      else
      {
        do
          uint64_t v29 = *--a2;
        while (*(double *)(v29 + 48) <= v23);
      }
      if (v24 < a2)
      {
        int v31 = v24;
        uint64_t v32 = a2;
        do
        {
          *int v31 = 0;
          uint64_t v33 = *v32;
          *uint64_t v32 = 0;
          uint64_t v34 = *v31;
          *int v31 = v33;
          if (v34)
          {
            uint64_t v35 = sub_19E37059C(v34);
            MEMORY[0x19F3BDCF0](v35, 0x1032C4057ACE4D0);
          }
          uint64_t v36 = *v32;
          *uint64_t v32 = v26;
          if (v36)
          {
            uint64_t v37 = sub_19E37059C(v36);
            MEMORY[0x19F3BDCF0](v37, 0x1032C4057ACE4D0);
          }
          double v38 = *(double *)(v22 + 48);
          do
          {
            unint64_t v25 = v31;
            uint64_t v39 = v31[1];
            ++v31;
            uint64_t v26 = v39;
          }
          while (*(double *)(v39 + 48) > v38);
          do
            uint64_t v40 = *--v32;
          while (*(double *)(v40 + 48) <= v38);
        }
        while (v31 < v32);
      }
      if (v25 != a1)
      {
        uint64_t v41 = *v25;
        *unint64_t v25 = 0;
        uint64_t v42 = *a1;
        *a1 = v41;
        if (v42)
        {
          uint64_t v43 = sub_19E37059C(v42);
          MEMORY[0x19F3BDCF0](v43, 0x1032C4057ACE4D0);
        }
      }
      uint64_t v44 = *v25;
      *unint64_t v25 = v22;
      if (v44)
      {
        uint64_t v45 = sub_19E37059C(v44);
        MEMORY[0x19F3BDCF0](v45, 0x1032C4057ACE4D0);
      }
      BOOL v4 = v24 >= a2;
      a2 = v28;
      if (!v4) {
        goto LABEL_41;
      }
      BOOL v46 = sub_19E3F10CC(a1, v25);
      uint64_t v9 = v25 + 1;
      if (sub_19E3F10CC(v25 + 1, v28))
      {
        a2 = v25;
        if (v46) {
          return;
        }
        goto LABEL_1;
      }
      if (!v46)
      {
LABEL_41:
        sub_19E3EF1E4(a1, v25, a3, a4 & 1);
        a4 = 0;
        uint64_t v9 = v25 + 1;
      }
    }
    else
    {
      double v23 = *(double *)(v22 + 48);
      if (*(double *)(*(v9 - 1) + 48) > v23) {
        goto LABEL_15;
      }
      *uint64_t v9 = 0;
      if (v23 <= *(double *)(*v142 + 48))
      {
        unint64_t v48 = v9 + 1;
        do
        {
          uint64_t v9 = v48;
          if (v48 >= a2) {
            break;
          }
          ++v48;
        }
        while (v23 <= *(double *)(*v9 + 48));
      }
      else
      {
        do
        {
          uint64_t v47 = v9[1];
          ++v9;
        }
        while (v23 <= *(double *)(v47 + 48));
      }
      uint64_t v49 = a2;
      if (v9 < a2)
      {
        uint64_t v49 = a2;
        do
          uint64_t v50 = *--v49;
        while (v23 > *(double *)(v50 + 48));
      }
      if (v9 < v49)
      {
        uint64_t v51 = *v9;
        do
        {
          *uint64_t v9 = 0;
          uint64_t v52 = *v49;
          uint64_t *v49 = 0;
          uint64_t v53 = *v9;
          *uint64_t v9 = v52;
          if (v53)
          {
            uint64_t v54 = sub_19E37059C(v53);
            MEMORY[0x19F3BDCF0](v54, 0x1032C4057ACE4D0);
          }
          uint64_t v55 = *v49;
          uint64_t *v49 = v51;
          if (v55)
          {
            uint64_t v56 = sub_19E37059C(v55);
            MEMORY[0x19F3BDCF0](v56, 0x1032C4057ACE4D0);
          }
          double v57 = *(double *)(v22 + 48);
          do
          {
            uint64_t v58 = v9[1];
            ++v9;
            uint64_t v51 = v58;
          }
          while (v57 <= *(double *)(v58 + 48));
          do
            uint64_t v59 = *--v49;
          while (v57 > *(double *)(v59 + 48));
        }
        while (v9 < v49);
      }
      CFIndex v60 = v9 - 1;
      BOOL v4 = v9 - 1 >= a1;
      BOOL v5 = v9 - 1 == a1;
      if (v9 - 1 != a1)
      {
        uint64_t v61 = *v60;
        uint64_t *v60 = 0;
        uint64_t v62 = *a1;
        *a1 = v61;
        if (v62)
        {
          uint64_t v63 = sub_19E37059C(v62);
          MEMORY[0x19F3BDCF0](v63, 0x1032C4057ACE4D0);
        }
      }
      a4 = 0;
      uint64_t v64 = *v60;
      uint64_t *v60 = v22;
      if (v64)
      {
        uint64_t v65 = sub_19E37059C(v64);
        MEMORY[0x19F3BDCF0](v65, 0x1032C4057ACE4D0);
        a4 = 0;
      }
    }
  }
  std::string::size_type v71 = v9 + 1;
  BOOL v73 = v9 == a2 || v71 == a2;
  if (a4)
  {
    if (!v73)
    {
      uint64_t v74 = 0;
      CFComparisonResult v75 = v9;
      do
      {
        uint64_t v76 = *v75;
        uint64_t v77 = v75[1];
        CFComparisonResult v75 = v71;
        if (*(double *)(v77 + 48) > *(double *)(v76 + 48))
        {
          char v78 = a2;
          uint64_t v79 = 0;
          uint64_t *v71 = 0;
          for (uint64_t i = v74; ; i -= 8)
          {
            int v81 = (uint64_t *)((char *)a1 + i);
            *int v81 = 0;
            v81[1] = v76;
            if (v79)
            {
              uint64_t v82 = sub_19E37059C(v79);
              MEMORY[0x19F3BDCF0](v82, 0x1032C4057ACE4D0);
            }
            if (!i) {
              break;
            }
            int v83 = (uint64_t *)((char *)a1 + i);
            uint64_t v76 = *(uint64_t *)((char *)a1 + i - 8);
            if (*(double *)(v77 + 48) <= *(double *)(v76 + 48)) {
              goto LABEL_104;
            }
            uint64_t v79 = *v81;
          }
          int v83 = a1;
LABEL_104:
          uint64_t v84 = *v83;
          *int v83 = v77;
          a2 = v78;
          if (v84)
          {
            uint64_t v85 = sub_19E37059C(v84);
            MEMORY[0x19F3BDCF0](v85, 0x1032C4057ACE4D0);
          }
        }
        std::string::size_type v71 = v75 + 1;
        v74 += 8;
      }
      while (v75 + 1 != a2);
    }
  }
  else if (!v73)
  {
    do
    {
      v129 = a1;
      a1 = v71;
      uint64_t v130 = *v129;
      uint64_t v131 = v129[1];
      double v132 = *(double *)(v131 + 48);
      if (v132 > *(double *)(*v129 + 48))
      {
        *a1 = 0;
        uint64_t *v129 = 0;
        v129[1] = v130;
        while (1)
        {
          uint64_t v135 = v129 - 1;
          uint64_t v134 = *(v129 - 1);
          if (v132 <= *(double *)(v134 + 48)) {
            break;
          }
          uint64_t v136 = *v129--;
          *uint64_t v135 = 0;
          v135[1] = v134;
          if (v136)
          {
            uint64_t v133 = sub_19E37059C(v136);
            MEMORY[0x19F3BDCF0](v133, 0x1032C4057ACE4D0);
            double v132 = *(double *)(v131 + 48);
          }
        }
        uint64_t v137 = *v129;
        uint64_t *v129 = v131;
        if (v137)
        {
          uint64_t v138 = sub_19E37059C(v137);
          MEMORY[0x19F3BDCF0](v138, 0x1032C4057ACE4D0);
        }
      }
      std::string::size_type v71 = a1 + 1;
    }
    while (a1 + 1 != a2);
  }
}

  if (!(*(unsigned int (**)(void))(**(void **)a2 + 72))()
    || ((*(uint64_t (**)(void))(*(void *)*a3 + 72))() & 1) == 0)
  {
    if ((*(unsigned int (**)(void))(*(void *)*a3 + 72))())
    {
      (*(void (**)(void))(**(void **)a2 + 88))();
      if (((*(uint64_t (**)(void))(**(void **)a2 + 72))() & 1) == 0)
      {
        do
        {
          uint64_t v6 = *(_DWORD *)(a1 + 28);
          unint64_t v7 = (*(uint64_t (**)(void))(**(void **)a2 + 80))();
          uint64_t v8 = (unsigned int *)(v7 + 4);
          if (v6) {
            uint64_t v8 = (unsigned int *)v7;
          }
          if ((*(uint64_t (**)(void, void))(*(void *)*a3 + 64))(*a3, *v8)) {
            break;
          }
          (*(void (**)(void))(**(void **)a2 + 88))();
        }
        while (!(*(unsigned int (**)(void))(**(void **)a2 + 72))());
      }
    }
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            if ((*(uint64_t (**)(void))(*(void *)*a3 + 72))()) {
              goto LABEL_1;
            }
            uint64_t v10 = (*(uint64_t (**)(void))(**(void **)a2 + 80))();
            uint64_t v11 = (*(uint64_t (**)(void))(*(void *)*a3 + 80))();
            (*(void (**)(void))(*(void *)*a3 + 88))();
            unint64_t v12 = *(_DWORD *)(a1 + 28);
            uint64_t v13 = v12 == 0;
            uint64_t v14 = v12 ? v11 : v10;
            uint64_t v15 = *(void *)v14;
            uint64_t v16 = *(float *)(v14 + 8);
            uint64_t v17 = *(_DWORD *)(v14 + 12);
            uint64_t v18 = v13 ? v11 : v10;
            uint64_t v19 = *(void *)v18;
            uint64_t v20 = *(float *)(v18 + 8);
            uint64_t v21 = *(_DWORD *)(v18 + 12);
            uint64_t v22 = *(unsigned __int8 **)(*(void *)(a1 + 16) + 136);
            if (v19 != -1) {
              break;
            }
            uint64_t v9 = v22[40];
            if (v22[40])
            {
              if (v9 == 1) {
                goto LABEL_34;
              }
            }
            else
            {
              if (v22[44]) {
                goto LABEL_33;
              }
              if (!v22[42])
              {
                LOBYTE(v9) = 1;
                goto LABEL_34;
              }
            }
          }
          if (HIDWORD(v15)) {
            break;
          }
          LOBYTE(v9) = v22[40];
          if (!(_BYTE)v9) {
            goto LABEL_34;
          }
        }
        if (HIDWORD(v15) != -1) {
          goto LABEL_33;
        }
        uint64_t v9 = v22[40];
        if (!v22[40]) {
          break;
        }
        if (v9 == 2) {
          goto LABEL_34;
        }
      }
      if (v22[43]) {
        break;
      }
      if (!v22[41])
      {
        LOBYTE(v9) = 2;
        goto LABEL_34;
      }
    }
LABEL_33:
    LOBYTE(v9) = 0;
LABEL_34:
    uint64_t v32 = __PAIR64__(v21, v17);
    uint64_t v33 = v9;
    *(_DWORD *)(a1 + 68) = v15;
    *(_DWORD *)(a1 + 72) = HIDWORD(v19);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009378, memory_order_acquire) & 1) == 0)
    {
      uint64_t v28 = v20;
      uint64_t v30 = v16;
      uint64_t v26 = __cxa_guard_acquire(&qword_1EC009378);
      uint64_t v20 = v28;
      uint64_t v16 = v30;
      if (v26)
      {
        dword_1EC009380 = -8388609;
        __cxa_guard_release(&qword_1EC009378);
        uint64_t v20 = v28;
        uint64_t v16 = v30;
      }
    }
    if (v16 == *(float *)&dword_1EC009380) {
      goto LABEL_44;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009378, memory_order_acquire) & 1) == 0)
    {
      uint64_t v29 = v20;
      int v31 = v16;
      uint64_t v27 = __cxa_guard_acquire(&qword_1EC009378);
      uint64_t v20 = v29;
      uint64_t v16 = v31;
      if (v27)
      {
        dword_1EC009380 = -8388609;
        __cxa_guard_release(&qword_1EC009378);
        uint64_t v20 = v29;
        uint64_t v16 = v31;
      }
    }
    if (v20 == *(float *)&dword_1EC009380)
    {
LABEL_44:
      unint64_t v24 = NAN;
    }
    else
    {
      double v23 = v20 == 3.4028e38 || v16 == 3.4028e38;
      unint64_t v24 = v20 + v16;
      if (v23) {
        unint64_t v24 = 3.4028e38;
      }
    }
    *(float *)(a1 + 76) = v24;
    *(_DWORD *)(a1 + 80) = sub_19E470994(*(void **)(*(void *)(a1 + 16) + 176), (uint64_t *)&v32);
    return 1;
  }
  return 0;
}

  if (!(*(unsigned int (**)(void))(**(void **)a2 + 72))()
    || ((*(uint64_t (**)(void))(*(void *)*a3 + 72))() & 1) == 0)
  {
    if ((*(unsigned int (**)(void))(*(void *)*a3 + 72))())
    {
      (*(void (**)(void))(**(void **)a2 + 88))();
      if (((*(uint64_t (**)(void))(**(void **)a2 + 72))() & 1) == 0)
      {
        do
        {
          uint64_t v6 = *(_DWORD *)(a1 + 28);
          unint64_t v7 = (*(uint64_t (**)(void))(**(void **)a2 + 80))();
          uint64_t v8 = (unsigned int *)(v7 + 4);
          if (v6) {
            uint64_t v8 = (unsigned int *)v7;
          }
          if ((*(uint64_t (**)(void, void))(*(void *)*a3 + 64))(*a3, *v8)) {
            break;
          }
          (*(void (**)(void))(**(void **)a2 + 88))();
        }
        while (!(*(unsigned int (**)(void))(**(void **)a2 + 72))());
      }
    }
    while (1)
    {
      while (1)
      {
        if ((*(uint64_t (**)(void))(*(void *)*a3 + 72))()) {
          goto LABEL_1;
        }
        uint64_t v9 = (*(uint64_t (**)(void))(**(void **)a2 + 80))();
        uint64_t v10 = (*(uint64_t (**)(void))(*(void *)*a3 + 80))();
        (*(void (**)(void))(*(void *)*a3 + 88))();
        uint64_t v11 = *(_DWORD *)(a1 + 28);
        unint64_t v12 = v11 == 0;
        uint64_t v13 = v11 ? v10 : v9;
        uint64_t v14 = *(void *)v13;
        uint64_t v15 = *(float *)(v13 + 8);
        uint64_t v16 = *(_DWORD *)(v13 + 12);
        uint64_t v17 = v12 ? v10 : v9;
        uint64_t v18 = *(void *)v17;
        uint64_t v19 = *(float *)(v17 + 8);
        uint64_t v20 = *(_DWORD *)(v17 + 12);
        uint64_t v21 = *(unsigned char **)(*(void *)(a1 + 16) + 136);
        if (v18 == -1) {
          break;
        }
        if (HIDWORD(v14) && (HIDWORD(v14) != -1 || v21[32] != 1))
        {
          uint64_t v22 = 0;
          goto LABEL_24;
        }
      }
      if (!v21[33])
      {
        uint64_t v22 = v21[34] ^ 1;
LABEL_24:
        uint64_t v32 = __PAIR64__(v20, v16);
        uint64_t v33 = v22;
        *(_DWORD *)(a1 + 68) = v14;
        *(_DWORD *)(a1 + 72) = HIDWORD(v18);
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009378, memory_order_acquire) & 1) == 0)
        {
          uint64_t v28 = v19;
          uint64_t v30 = v15;
          uint64_t v26 = __cxa_guard_acquire(&qword_1EC009378);
          uint64_t v19 = v28;
          uint64_t v15 = v30;
          if (v26)
          {
            dword_1EC009380 = -8388609;
            __cxa_guard_release(&qword_1EC009378);
            uint64_t v19 = v28;
            uint64_t v15 = v30;
          }
        }
        if (v15 == *(float *)&dword_1EC009380) {
          goto LABEL_34;
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009378, memory_order_acquire) & 1) == 0)
        {
          uint64_t v29 = v19;
          int v31 = v15;
          uint64_t v27 = __cxa_guard_acquire(&qword_1EC009378);
          uint64_t v19 = v29;
          uint64_t v15 = v31;
          if (v27)
          {
            dword_1EC009380 = -8388609;
            __cxa_guard_release(&qword_1EC009378);
            uint64_t v19 = v29;
            uint64_t v15 = v31;
          }
        }
        if (v19 == *(float *)&dword_1EC009380)
        {
LABEL_34:
          unint64_t v24 = NAN;
        }
        else
        {
          double v23 = v19 == 3.4028e38 || v15 == 3.4028e38;
          unint64_t v24 = v19 + v15;
          if (v23) {
            unint64_t v24 = 3.4028e38;
          }
        }
        *(float *)(a1 + 76) = v24;
        *(_DWORD *)(a1 + 80) = sub_19E470994(*(void **)(*(void *)(a1 + 16) + 176), (uint64_t *)&v32);
        return 1;
      }
    }
  }
  return 0;
}

  if (!(*(unsigned int (**)(void))(**(void **)a2 + 72))()
    || ((*(uint64_t (**)(void))(*(void *)*a3 + 72))() & 1) == 0)
  {
    if ((*(unsigned int (**)(void))(*(void *)*a3 + 72))())
    {
      (*(void (**)(void))(**(void **)a2 + 88))();
      if (((*(uint64_t (**)(void))(**(void **)a2 + 72))() & 1) == 0)
      {
        do
        {
          uint64_t v6 = *(_DWORD *)(a1 + 28);
          unint64_t v7 = (*(uint64_t (**)(void))(**(void **)a2 + 80))();
          uint64_t v8 = (unsigned int *)(v7 + 4);
          if (v6) {
            uint64_t v8 = (unsigned int *)v7;
          }
          if ((*(uint64_t (**)(void, void))(*(void *)*a3 + 64))(*a3, *v8)) {
            break;
          }
          (*(void (**)(void))(**(void **)a2 + 88))();
        }
        while (!(*(unsigned int (**)(void))(**(void **)a2 + 72))());
      }
    }
    while (1)
    {
      while (1)
      {
        if ((*(uint64_t (**)(void))(*(void *)*a3 + 72))()) {
          goto LABEL_1;
        }
        uint64_t v9 = (*(uint64_t (**)(void))(**(void **)a2 + 80))();
        uint64_t v10 = (*(uint64_t (**)(void))(*(void *)*a3 + 80))();
        (*(void (**)(void))(*(void *)*a3 + 88))();
        uint64_t v11 = *(_DWORD *)(a1 + 28);
        unint64_t v12 = v11 == 0;
        uint64_t v13 = v11 ? v10 : v9;
        uint64_t v14 = *(void *)v13;
        uint64_t v15 = HIDWORD(*(void *)v13);
        uint64_t v16 = *(float *)(v13 + 8);
        uint64_t v17 = *(_DWORD *)(v13 + 12);
        uint64_t v18 = v12 ? v10 : v9;
        uint64_t v19 = *(void *)v18;
        uint64_t v20 = *(float *)(v18 + 8);
        uint64_t v21 = *(_DWORD *)(v18 + 12);
        uint64_t v22 = *(unsigned char **)(*(void *)(a1 + 16) + 136);
        if (v15 == -1) {
          break;
        }
        if (v19 == -1)
        {
          double v23 = v22[32];
          if (!v23) {
            goto LABEL_25;
          }
        }
        else if (v15)
        {
          double v23 = 0;
          goto LABEL_25;
        }
      }
      if (!v22[33])
      {
        double v23 = v22[34] ^ 1;
LABEL_25:
        uint64_t v33 = __PAIR64__(v21, v17);
        uint64_t v34 = v23;
        *(_DWORD *)(a1 + 68) = v14;
        *(_DWORD *)(a1 + 72) = HIDWORD(v19);
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009378, memory_order_acquire) & 1) == 0)
        {
          uint64_t v29 = v20;
          int v31 = v16;
          uint64_t v27 = __cxa_guard_acquire(&qword_1EC009378);
          uint64_t v20 = v29;
          uint64_t v16 = v31;
          if (v27)
          {
            dword_1EC009380 = -8388609;
            __cxa_guard_release(&qword_1EC009378);
            uint64_t v20 = v29;
            uint64_t v16 = v31;
          }
        }
        if (v16 == *(float *)&dword_1EC009380) {
          goto LABEL_35;
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009378, memory_order_acquire) & 1) == 0)
        {
          uint64_t v30 = v20;
          uint64_t v32 = v16;
          uint64_t v28 = __cxa_guard_acquire(&qword_1EC009378);
          uint64_t v20 = v30;
          uint64_t v16 = v32;
          if (v28)
          {
            dword_1EC009380 = -8388609;
            __cxa_guard_release(&qword_1EC009378);
            uint64_t v20 = v30;
            uint64_t v16 = v32;
          }
        }
        if (v20 == *(float *)&dword_1EC009380)
        {
LABEL_35:
          unint64_t v25 = NAN;
        }
        else
        {
          unint64_t v24 = v20 == 3.4028e38 || v16 == 3.4028e38;
          unint64_t v25 = v20 + v16;
          if (v24) {
            unint64_t v25 = 3.4028e38;
          }
        }
        *(float *)(a1 + 76) = v25;
        *(_DWORD *)(a1 + 80) = sub_19E470994(*(void **)(*(void *)(a1 + 16) + 176), (uint64_t *)&v33);
        return 1;
      }
    }
  }
  return 0;
}

  unint64_t v142 = a2 - 1;
  unint64_t v139 = a2 - 3;
  v140 = a2 - 2;
  uint64_t v9 = a1;
  while (1)
  {
    a1 = v9;
    uint64_t v10 = (char *)a2 - (char *)v9;
    uint64_t v11 = a2 - v9;
    if (v5 || !v4)
    {
      switch(v11)
      {
        case 0:
        case 1:
          return;
        case 2:
          uint64_t v66 = *v9;
          if (*(double *)(*v142 + 48) > *(double *)(*v9 + 48))
          {
            *uint64_t v9 = 0;
            uint64_t v67 = *v142;
            *unint64_t v142 = 0;
            uint64_t v68 = *v9;
            *uint64_t v9 = v67;
            if (v68)
            {
              uint64_t v69 = sub_19E37059C(v68);
              MEMORY[0x19F3BDCF0](v69, 0x1032C4057ACE4D0);
            }
            uint64_t v70 = *v142;
            *unint64_t v142 = v66;
            if (v70)
            {
              sub_19E37059C(v70);
              JUMPOUT(0x19F3BDCF0);
            }
          }
          return;
        case 3:
          sub_19E3F0B08(v9, v9 + 1, v142);
          break;
        case 4:
          sub_19E3F0D14(v9, v9 + 1, v9 + 2, v142);
          break;
        case 5:
          sub_19E3F0EB8(v9, v9 + 1, v9 + 2, v9 + 3, v142);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v10 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v9 == a2) {
        return;
      }
      int64_t v86 = (unint64_t)(v11 - 2) >> 1;
      int64_t v87 = v86;
      do
      {
        int64_t v88 = v87;
        if (v86 >= v87)
        {
          uint64_t v89 = (2 * v87) | 1;
          size_t v90 = &a1[v89];
          if (2 * v88 + 2 < v11 && *(double *)(*v90 + 48) > *(double *)(v90[1] + 48))
          {
            ++v90;
            uint64_t v89 = 2 * v88 + 2;
          }
          v91 = &a1[v88];
          uint64_t v92 = *v91;
          if (*(double *)(*v90 + 48) <= *(double *)(*v91 + 48))
          {
            uint64_t *v91 = 0;
            uint64_t v93 = *v90;
            do
            {
              uint64_t v94 = v90;
              uint64_t *v90 = 0;
              uint64_t v95 = *v91;
              uint64_t *v91 = v93;
              if (v95)
              {
                uint64_t v96 = sub_19E37059C(v95);
                MEMORY[0x19F3BDCF0](v96, 0x1032C4057ACE4D0);
              }
              if (v86 < v89) {
                break;
              }
              uint64_t v97 = 2 * v89;
              uint64_t v89 = (2 * v89) | 1;
              size_t v90 = &a1[v89];
              uint64_t v98 = v97 + 2;
              if (v98 < v11 && *(double *)(*v90 + 48) > *(double *)(v90[1] + 48))
              {
                ++v90;
                uint64_t v89 = v98;
              }
              uint64_t v93 = *v90;
              v91 = v94;
            }
            while (*(double *)(*v90 + 48) <= *(double *)(v92 + 48));
            uint64_t v99 = *v94;
            *uint64_t v94 = v92;
            if (v99)
            {
              uint64_t v100 = sub_19E37059C(v99);
              MEMORY[0x19F3BDCF0](v100, 0x1032C4057ACE4D0);
            }
          }
        }
        int64_t v87 = v88 - 1;
      }
      while (v88);
      uint64_t v101 = (unint64_t)v10 >> 3;
      while (2)
      {
        CFComparisonResult v105 = a2;
        uint64_t v106 = 0;
        uint64_t v107 = *a1;
        *a1 = 0;
        v108 = a1;
        do
        {
          std::string::size_type v109 = &v108[v106 + 1];
          uint64_t v110 = 2 * v106;
          uint64_t v106 = (2 * v106) | 1;
          uint64_t v111 = v110 + 2;
          if (v111 < v101 && *(double *)(*v109 + 48) > *(double *)(v109[1] + 48))
          {
            ++v109;
            uint64_t v106 = v111;
          }
          uint64_t v112 = *v109;
          uint64_t *v109 = 0;
          uint64_t v113 = *v108;
          uint64_t *v108 = v112;
          if (v113)
          {
            uint64_t v114 = sub_19E37059C(v113);
            MEMORY[0x19F3BDCF0](v114, 0x1032C4057ACE4D0);
          }
          v108 = v109;
        }
        while (v106 <= (uint64_t)((unint64_t)(v101 - 2) >> 1));
        --a2;
        if (v109 == v105 - 1)
        {
          uint64_t v102 = *v109;
          uint64_t *v109 = v107;
          if (!v102) {
            goto LABEL_127;
          }
        }
        else
        {
          uint64_t v115 = *a2;
          *a2 = 0;
          uint64_t v116 = *v109;
          uint64_t *v109 = v115;
          if (v116)
          {
            uint64_t v117 = sub_19E37059C(v116);
            MEMORY[0x19F3BDCF0](v117, 0x1032C4057ACE4D0);
          }
          uint64_t v118 = *a2;
          *a2 = v107;
          if (v118)
          {
            uint64_t v119 = sub_19E37059C(v118);
            MEMORY[0x19F3BDCF0](v119, 0x1032C4057ACE4D0);
          }
          uint64_t v120 = (char *)(v109 + 1) - (char *)a1;
          if (v120 < 9) {
            goto LABEL_127;
          }
          unint64_t v121 = (((unint64_t)v120 >> 3) - 2) >> 1;
          unint64_t v122 = &a1[v121];
          uint64_t v123 = *v109;
          if (*(double *)(*v122 + 48) <= *(double *)(*v109 + 48)) {
            goto LABEL_127;
          }
          uint64_t v124 = v105 - 1;
          uint64_t *v109 = 0;
          uint64_t v125 = *v122;
          do
          {
            v126 = v122;
            uint64_t *v122 = 0;
            uint64_t v127 = *v109;
            uint64_t *v109 = v125;
            if (v127)
            {
              uint64_t v128 = sub_19E37059C(v127);
              MEMORY[0x19F3BDCF0](v128, 0x1032C4057ACE4D0);
            }
            if (!v121) {
              break;
            }
            unint64_t v121 = (v121 - 1) >> 1;
            unint64_t v122 = &a1[v121];
            uint64_t v125 = *v122;
            std::string::size_type v109 = v126;
          }
          while (*(double *)(*v122 + 48) > *(double *)(v123 + 48));
          uint64_t v102 = *v126;
          uint64_t *v126 = v123;
          a2 = v124;
          if (!v102)
          {
LABEL_127:
            if (v101-- <= 2) {
              return;
            }
            continue;
          }
        }
        break;
      }
      uint64_t v103 = sub_19E37059C(v102);
      MEMORY[0x19F3BDCF0](v103, 0x1032C4057ACE4D0);
      goto LABEL_127;
    }
    unint64_t v12 = (unint64_t)v11 >> 1;
    uint64_t v13 = &v9[(unint64_t)v11 >> 1];
    if ((unint64_t)v10 < 0x401)
    {
      sub_19E3F0B08(v13, v9, v142);
    }
    else
    {
      sub_19E3F0B08(v9, v13, v142);
      uint64_t v14 = v12;
      uint64_t v15 = &v9[v14];
      sub_19E3F0B08(v9 + 1, &v9[v14 - 1], v140);
      sub_19E3F0B08(v9 + 2, &v9[v14 + 1], v139);
      sub_19E3F0B08(&v9[v14 - 1], v13, &v9[v14 + 1]);
      uint64_t v16 = *v9;
      *uint64_t v9 = 0;
      uint64_t v17 = *v15;
      *uint64_t v15 = 0;
      uint64_t v18 = *v9;
      *uint64_t v9 = v17;
      if (v18)
      {
        uint64_t v19 = sub_19E37059C(v18);
        MEMORY[0x19F3BDCF0](v19, 0x1032C4057ACE4D0);
      }
      uint64_t v20 = *v13;
      uint64_t *v13 = v16;
      if (v20)
      {
        uint64_t v21 = sub_19E37059C(v20);
        MEMORY[0x19F3BDCF0](v21, 0x1032C4057ACE4D0);
      }
    }
    --a3;
    uint64_t v22 = *v9;
    if (a4)
    {
      double v23 = *(double *)(v22 + 48);
LABEL_15:
      *uint64_t v9 = 0;
      unint64_t v24 = v9;
      do
      {
        unint64_t v25 = v24;
        uint64_t v27 = v24[1];
        ++v24;
        uint64_t v26 = v27;
      }
      while (*(double *)(v27 + 48) > v23);
      uint64_t v28 = a2;
      if (v25 == a1)
      {
        do
        {
          if (v24 >= a2) {
            break;
          }
          uint64_t v30 = *--a2;
        }
        while (*(double *)(v30 + 48) <= v23);
      }
      else
      {
        do
          uint64_t v29 = *--a2;
        while (*(double *)(v29 + 48) <= v23);
      }
      if (v24 < a2)
      {
        int v31 = v24;
        uint64_t v32 = a2;
        do
        {
          *int v31 = 0;
          uint64_t v33 = *v32;
          *uint64_t v32 = 0;
          uint64_t v34 = *v31;
          *int v31 = v33;
          if (v34)
          {
            uint64_t v35 = sub_19E37059C(v34);
            MEMORY[0x19F3BDCF0](v35, 0x1032C4057ACE4D0);
          }
          uint64_t v36 = *v32;
          *uint64_t v32 = v26;
          if (v36)
          {
            uint64_t v37 = sub_19E37059C(v36);
            MEMORY[0x19F3BDCF0](v37, 0x1032C4057ACE4D0);
          }
          double v38 = *(double *)(v22 + 48);
          do
          {
            unint64_t v25 = v31;
            uint64_t v39 = v31[1];
            ++v31;
            uint64_t v26 = v39;
          }
          while (*(double *)(v39 + 48) > v38);
          do
            uint64_t v40 = *--v32;
          while (*(double *)(v40 + 48) <= v38);
        }
        while (v31 < v32);
      }
      if (v25 != a1)
      {
        uint64_t v41 = *v25;
        *unint64_t v25 = 0;
        uint64_t v42 = *a1;
        *a1 = v41;
        if (v42)
        {
          uint64_t v43 = sub_19E37059C(v42);
          MEMORY[0x19F3BDCF0](v43, 0x1032C4057ACE4D0);
        }
      }
      uint64_t v44 = *v25;
      *unint64_t v25 = v22;
      if (v44)
      {
        uint64_t v45 = sub_19E37059C(v44);
        MEMORY[0x19F3BDCF0](v45, 0x1032C4057ACE4D0);
      }
      BOOL v4 = v24 >= a2;
      a2 = v28;
      if (!v4) {
        goto LABEL_41;
      }
      BOOL v46 = sub_19E545ABC(a1, v25);
      uint64_t v9 = v25 + 1;
      if (sub_19E545ABC(v25 + 1, v28))
      {
        a2 = v25;
        if (v46) {
          return;
        }
        goto LABEL_1;
      }
      if (!v46)
      {
LABEL_41:
        sub_19E544FC0(a1, v25, a3, a4 & 1);
        a4 = 0;
        uint64_t v9 = v25 + 1;
      }
    }
    else
    {
      double v23 = *(double *)(v22 + 48);
      if (*(double *)(*(v9 - 1) + 48) > v23) {
        goto LABEL_15;
      }
      *uint64_t v9 = 0;
      if (v23 <= *(double *)(*v142 + 48))
      {
        unint64_t v48 = v9 + 1;
        do
        {
          uint64_t v9 = v48;
          if (v48 >= a2) {
            break;
          }
          ++v48;
        }
        while (v23 <= *(double *)(*v9 + 48));
      }
      else
      {
        do
        {
          uint64_t v47 = v9[1];
          ++v9;
        }
        while (v23 <= *(double *)(v47 + 48));
      }
      uint64_t v49 = a2;
      if (v9 < a2)
      {
        uint64_t v49 = a2;
        do
          uint64_t v50 = *--v49;
        while (v23 > *(double *)(v50 + 48));
      }
      if (v9 < v49)
      {
        uint64_t v51 = *v9;
        do
        {
          *uint64_t v9 = 0;
          uint64_t v52 = *v49;
          uint64_t *v49 = 0;
          uint64_t v53 = *v9;
          *uint64_t v9 = v52;
          if (v53)
          {
            uint64_t v54 = sub_19E37059C(v53);
            MEMORY[0x19F3BDCF0](v54, 0x1032C4057ACE4D0);
          }
          uint64_t v55 = *v49;
          uint64_t *v49 = v51;
          if (v55)
          {
            uint64_t v56 = sub_19E37059C(v55);
            MEMORY[0x19F3BDCF0](v56, 0x1032C4057ACE4D0);
          }
          double v57 = *(double *)(v22 + 48);
          do
          {
            uint64_t v58 = v9[1];
            ++v9;
            uint64_t v51 = v58;
          }
          while (v57 <= *(double *)(v58 + 48));
          do
            uint64_t v59 = *--v49;
          while (v57 > *(double *)(v59 + 48));
        }
        while (v9 < v49);
      }
      CFIndex v60 = v9 - 1;
      BOOL v4 = v9 - 1 >= a1;
      BOOL v5 = v9 - 1 == a1;
      if (v9 - 1 != a1)
      {
        uint64_t v61 = *v60;
        uint64_t *v60 = 0;
        uint64_t v62 = *a1;
        *a1 = v61;
        if (v62)
        {
          uint64_t v63 = sub_19E37059C(v62);
          MEMORY[0x19F3BDCF0](v63, 0x1032C4057ACE4D0);
        }
      }
      a4 = 0;
      uint64_t v64 = *v60;
      uint64_t *v60 = v22;
      if (v64)
      {
        uint64_t v65 = sub_19E37059C(v64);
        MEMORY[0x19F3BDCF0](v65, 0x1032C4057ACE4D0);
        a4 = 0;
      }
    }
  }
  std::string::size_type v71 = v9 + 1;
  BOOL v73 = v9 == a2 || v71 == a2;
  if (a4)
  {
    if (!v73)
    {
      uint64_t v74 = 0;
      CFComparisonResult v75 = v9;
      do
      {
        uint64_t v76 = *v75;
        uint64_t v77 = v75[1];
        CFComparisonResult v75 = v71;
        if (*(double *)(v77 + 48) > *(double *)(v76 + 48))
        {
          char v78 = a2;
          uint64_t v79 = 0;
          uint64_t *v71 = 0;
          for (uint64_t i = v74; ; i -= 8)
          {
            int v81 = (uint64_t *)((char *)a1 + i);
            *int v81 = 0;
            v81[1] = v76;
            if (v79)
            {
              uint64_t v82 = sub_19E37059C(v79);
              MEMORY[0x19F3BDCF0](v82, 0x1032C4057ACE4D0);
            }
            if (!i) {
              break;
            }
            int v83 = (uint64_t *)((char *)a1 + i);
            uint64_t v76 = *(uint64_t *)((char *)a1 + i - 8);
            if (*(double *)(v77 + 48) <= *(double *)(v76 + 48)) {
              goto LABEL_104;
            }
            uint64_t v79 = *v81;
          }
          int v83 = a1;
LABEL_104:
          uint64_t v84 = *v83;
          *int v83 = v77;
          a2 = v78;
          if (v84)
          {
            uint64_t v85 = sub_19E37059C(v84);
            MEMORY[0x19F3BDCF0](v85, 0x1032C4057ACE4D0);
          }
        }
        std::string::size_type v71 = v75 + 1;
        v74 += 8;
      }
      while (v75 + 1 != a2);
    }
  }
  else if (!v73)
  {
    do
    {
      v129 = a1;
      a1 = v71;
      uint64_t v130 = *v129;
      uint64_t v131 = v129[1];
      double v132 = *(double *)(v131 + 48);
      if (v132 > *(double *)(*v129 + 48))
      {
        *a1 = 0;
        uint64_t *v129 = 0;
        v129[1] = v130;
        while (1)
        {
          uint64_t v135 = v129 - 1;
          uint64_t v134 = *(v129 - 1);
          if (v132 <= *(double *)(v134 + 48)) {
            break;
          }
          uint64_t v136 = *v129--;
          *uint64_t v135 = 0;
          v135[1] = v134;
          if (v136)
          {
            uint64_t v133 = sub_19E37059C(v136);
            MEMORY[0x19F3BDCF0](v133, 0x1032C4057ACE4D0);
            double v132 = *(double *)(v131 + 48);
          }
        }
        uint64_t v137 = *v129;
        uint64_t *v129 = v131;
        if (v137)
        {
          uint64_t v138 = sub_19E37059C(v137);
          MEMORY[0x19F3BDCF0](v138, 0x1032C4057ACE4D0);
        }
      }
      std::string::size_type v71 = a1 + 1;
    }
    while (a1 + 1 != a2);
  }
}

char *sub_19E3EFCE0(uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (char *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = *((void *)v10 + 1);
            if (v12 == a2)
            {
              if (*((void *)v10 + 2) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = *(char **)v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((void *)v10 + 2) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = a1 + 2;
  uint64_t v10 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = v5;
  *((void *)v10 + 2) = *a3;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *((_DWORD *)v10 + 14) = 1065353216;
  float v14 = (float)(unint64_t)(a1[3] + 1);
  float v15 = *((float *)a1 + 8);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
    goto LABEL_72;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = a1[1];
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v20 = operator new(8 * prime);
    uint64_t v21 = (void *)*a1;
    *a1 = (uint64_t)v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v22++) = 0;
    while (prime != v22);
    double v23 = (void *)*v13;
    if (!*v13) {
      goto LABEL_59;
    }
    size_t v24 = v23[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*a1 + 8 * v26) = v13;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          double v23 = i;
        }
        else if (*(void *)(*a1 + 8 * v28))
        {
          *double v23 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*a1 + v29);
          **(void **)(*a1 + v29) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v28) = v23;
          double v23 = i;
          size_t v26 = v28;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*a1 + 8 * v24) = v13;
    uint64_t v33 = (void *)*v23;
    if (!*v23) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*a1 + 8 * v35))
        {
          *(void *)(*a1 + 8 * v35) = v23;
          goto LABEL_64;
        }
        *double v23 = *v33;
        uint64_t v34 = 8 * v35;
        *uint64_t v33 = **(void **)(*a1 + v34);
        **(void **)(*a1 + v34) = v33;
        uint64_t v33 = v23;
      }
      size_t v35 = v24;
LABEL_64:
      double v23 = v33;
      uint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      uint64_t v40 = (void *)*a1;
      *a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = a1[1];
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_72:
  uint64_t v36 = *a1;
  uint64_t v37 = *(void **)(*a1 + 8 * v5);
  if (v37)
  {
    *(void *)uint64_t v10 = *v37;
LABEL_80:
    *uint64_t v37 = v10;
    goto LABEL_81;
  }
  *(void *)uint64_t v10 = *v13;
  void *v13 = v10;
  *(void *)(v36 + 8 * v5) = v13;
  if (*(void *)v10)
  {
    unint64_t v38 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    uint64_t v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++a1[3];
  return v10;
}

void sub_19E3F015C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3F0A80((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E3F0170(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (unsigned char *)a2;
  unint64_t v7 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v8 = v7;
  }
  unint64_t v9 = sub_19E37BDA4((uint64_t)v42, (uint64_t *)a2, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    uint64_t v13 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      float v14 = *v13;
      if (*v13)
      {
        char v15 = v5[23];
        if (v15 >= 0) {
          uint64_t v16 = v5[23];
        }
        else {
          uint64_t v16 = *((void *)v5 + 1);
        }
        if (v15 < 0) {
          unint64_t v5 = *(unsigned char **)v5;
        }
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v22 = v14[1];
            if (v22 == v10)
            {
              uint64_t v23 = *((unsigned __int8 *)v14 + 39);
              if ((v23 & 0x80u) == 0) {
                uint64_t v24 = *((unsigned __int8 *)v14 + 39);
              }
              else {
                uint64_t v24 = v14[3];
              }
              if (v24 == v16)
              {
                size_t v25 = (const void **)(v14 + 2);
                if ((v23 & 0x80) != 0)
                {
                  if (!memcmp(*v25, v5, v14[3])) {
                    return;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v14 + 39)) {
                    return;
                  }
                  for (uint64_t i = v5; *(unsigned __int8 *)v25 == *i; ++i)
                  {
                    size_t v25 = (const void **)((char *)v25 + 1);
                    if (!--v23) {
                      return;
                    }
                  }
                }
              }
            }
            else if ((v22 & (v11 - 1)) != v3)
            {
              goto LABEL_51;
            }
            float v14 = (uint64_t *)*v14;
            if (!v14) {
              goto LABEL_51;
            }
          }
        }
        do
        {
          unint64_t v17 = v14[1];
          if (v17 == v10)
          {
            uint64_t v18 = *((unsigned __int8 *)v14 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v14 + 39);
            }
            else {
              uint64_t v19 = v14[3];
            }
            if (v19 == v16)
            {
              uint64_t v20 = (const void **)(v14 + 2);
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp(*v20, v5, v14[3])) {
                  return;
                }
              }
              else
              {
                if (!*((unsigned char *)v14 + 39)) {
                  return;
                }
                for (uint64_t j = v5; *(unsigned __int8 *)v20 == *j; ++j)
                {
                  uint64_t v20 = (const void **)((char *)v20 + 1);
                  if (!--v18) {
                    return;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= v11) {
              v17 %= v11;
            }
            if (v17 != v3) {
              break;
            }
          }
          float v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_51:
  uint64_t v27 = (void *)(a1 + 16);
  size_t v28 = operator new(0x28uLL);
  v42[0] = v28;
  v42[1] = a1 + 16;
  *size_t v28 = 0;
  v28[1] = v10;
  *((_OWORD *)v28 + 1) = *(_OWORD *)a3;
  v28[4] = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  char v43 = 1;
  float v29 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v30 = *(float *)(a1 + 32);
  if (!v11 || (float)(v30 * (float)v11) < v29)
  {
    BOOL v31 = 1;
    if (v11 >= 3) {
      BOOL v31 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v32 = v31 | (2 * v11);
    unint64_t v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33) {
      size_t prime = v33;
    }
    else {
      size_t prime = v32;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v35 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v35) {
      goto LABEL_63;
    }
    if (prime < *(void *)&v35)
    {
      unint64_t v36 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v35 < 3uLL || (uint8x8_t v37 = (uint8x8_t)vcnt_s8(v35), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }
      if (prime <= v36) {
        size_t prime = v36;
      }
      if (prime < *(void *)&v35) {
LABEL_63:
      }
        sub_19E3CEFD8(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v3 = v10 % v11;
      }
      else {
        unint64_t v3 = v10;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v10;
    }
  }
  uint64_t v39 = *(void *)a1;
  uint64_t v40 = *(void **)(*(void *)a1 + 8 * v3);
  if (v40)
  {
    *size_t v28 = *v40;
LABEL_87:
    *uint64_t v40 = v28;
    goto LABEL_88;
  }
  *size_t v28 = *v27;
  *uint64_t v27 = v28;
  *(void *)(v39 + 8 * v3) = v27;
  if (*v28)
  {
    unint64_t v41 = *(void *)(*v28 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v41 >= v11) {
        v41 %= v11;
      }
    }
    else
    {
      v41 &= v11 - 1;
    }
    uint64_t v40 = (void *)(*(void *)a1 + 8 * v41);
    goto LABEL_87;
  }
LABEL_88:
  ++*(void *)(a1 + 24);
}

void sub_19E3F0554(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3F0610((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E3F056C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v5 = (void *)*v2;
      uint64_t v6 = (void **)v2[5];
      if (v6)
      {
        do
        {
          unint64_t v8 = (void **)*v6;
          if (*((char *)v6 + 39) < 0) {
            operator delete(v6[2]);
          }
          operator delete(v6);
          uint64_t v6 = v8;
        }
        while (v8);
      }
      unint64_t v7 = (void *)v2[3];
      v2[3] = 0;
      if (v7) {
        operator delete(v7);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  unint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

uint64_t *sub_19E3F0610(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16) && *(char *)(v2 + 39) < 0) {
      operator delete(*(void **)(v2 + 16));
    }
    operator delete((void *)v2);
  }
  return a1;
}

void sub_19E3F0660(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (unsigned char *)a2;
  unint64_t v7 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v8 = v7;
  }
  unint64_t v9 = sub_19E37BDA4((uint64_t)v41, (uint64_t *)a2, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    uint64_t v13 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      float v14 = *v13;
      if (*v13)
      {
        char v15 = v5[23];
        if (v15 >= 0) {
          uint64_t v16 = v5[23];
        }
        else {
          uint64_t v16 = *((void *)v5 + 1);
        }
        if (v15 < 0) {
          unint64_t v5 = *(unsigned char **)v5;
        }
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v22 = v14[1];
            if (v22 == v10)
            {
              uint64_t v23 = *((unsigned __int8 *)v14 + 39);
              if ((v23 & 0x80u) == 0) {
                uint64_t v24 = *((unsigned __int8 *)v14 + 39);
              }
              else {
                uint64_t v24 = v14[3];
              }
              if (v24 == v16)
              {
                size_t v25 = (const void **)(v14 + 2);
                if ((v23 & 0x80) != 0)
                {
                  if (!memcmp(*v25, v5, v14[3])) {
                    return;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v14 + 39)) {
                    return;
                  }
                  for (uint64_t i = v5; *(unsigned __int8 *)v25 == *i; ++i)
                  {
                    size_t v25 = (const void **)((char *)v25 + 1);
                    if (!--v23) {
                      return;
                    }
                  }
                }
              }
            }
            else if ((v22 & (v11 - 1)) != v3)
            {
              goto LABEL_51;
            }
            float v14 = (uint64_t *)*v14;
            if (!v14) {
              goto LABEL_51;
            }
          }
        }
        do
        {
          unint64_t v17 = v14[1];
          if (v17 == v10)
          {
            uint64_t v18 = *((unsigned __int8 *)v14 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v14 + 39);
            }
            else {
              uint64_t v19 = v14[3];
            }
            if (v19 == v16)
            {
              uint64_t v20 = (const void **)(v14 + 2);
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp(*v20, v5, v14[3])) {
                  return;
                }
              }
              else
              {
                if (!*((unsigned char *)v14 + 39)) {
                  return;
                }
                for (uint64_t j = v5; *(unsigned __int8 *)v20 == *j; ++j)
                {
                  uint64_t v20 = (const void **)((char *)v20 + 1);
                  if (!--v18) {
                    return;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= v11) {
              v17 %= v11;
            }
            if (v17 != v3) {
              break;
            }
          }
          float v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_51:
  uint64_t v27 = operator new(0x28uLL);
  v41[0] = v27;
  v41[1] = a1 + 16;
  char v42 = 0;
  *uint64_t v27 = 0;
  v27[1] = v10;
  size_t v28 = v27 + 2;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_19E39369C(v28, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)size_t v28 = *(_OWORD *)a3;
    v28[2] = *(void *)(a3 + 16);
  }
  char v42 = 1;
  float v29 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v30 = *(float *)(a1 + 32);
  if (!v11 || (float)(v30 * (float)v11) < v29)
  {
    BOOL v31 = 1;
    if (v11 >= 3) {
      BOOL v31 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v32 = v31 | (2 * v11);
    unint64_t v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33) {
      size_t prime = v33;
    }
    else {
      size_t prime = v32;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v35 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v35) {
      goto LABEL_66;
    }
    if (prime < *(void *)&v35)
    {
      unint64_t v36 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v35 < 3uLL || (uint8x8_t v37 = (uint8x8_t)vcnt_s8(v35), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }
      if (prime <= v36) {
        size_t prime = v36;
      }
      if (prime < *(void *)&v35) {
LABEL_66:
      }
        sub_19E3CEFD8(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v3 = v10 % v11;
      }
      else {
        unint64_t v3 = v10;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v10;
    }
  }
  uint64_t v39 = *(void **)(*(void *)a1 + 8 * v3);
  if (v39)
  {
    *(void *)v41[0] = *v39;
    *uint64_t v39 = v41[0];
  }
  else
  {
    *(void *)v41[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v41[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v41[0])
    {
      unint64_t v40 = *(void *)(*(void *)v41[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v40 >= v11) {
          v40 %= v11;
        }
      }
      else
      {
        v40 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v40) = v41[0];
    }
  }
  ++*(void *)(a1 + 24);
}

void sub_19E3F0A64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3F0610((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E3F0A80(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      unint64_t v3 = (void **)v2[5];
      if (v3)
      {
        do
        {
          uint64_t v6 = (void **)*v3;
          if (*((char *)v3 + 39) < 0) {
            operator delete(v3[2]);
          }
          operator delete(v3);
          unint64_t v3 = v6;
        }
        while (v6);
      }
      BOOL v4 = (void *)v2[3];
      v2[3] = 0;
      if (v4) {
        operator delete(v4);
      }
    }
    operator delete(v2);
  }
  return a1;
}

double sub_19E3F0B08(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = *a2;
  double result = *(double *)(*a2 + 48);
  uint64_t v8 = *a1;
  double v9 = *(double *)(*a3 + 48);
  if (result <= *(double *)(*a1 + 48))
  {
    if (v9 > result)
    {
      *a2 = 0;
      uint64_t v14 = *a3;
      *a3 = 0;
      uint64_t v15 = *a2;
      *a2 = v14;
      if (v15)
      {
        uint64_t v16 = sub_19E37059C(v15);
        MEMORY[0x19F3BDCF0](v16, 0x1032C4057ACE4D0);
      }
      uint64_t v17 = *a3;
      *a3 = v6;
      if (v17)
      {
        uint64_t v18 = sub_19E37059C(v17);
        MEMORY[0x19F3BDCF0](v18, 0x1032C4057ACE4D0);
      }
      double result = *(double *)(*a2 + 48);
      uint64_t v19 = *a1;
      if (result > *(double *)(*a1 + 48))
      {
        *a1 = 0;
        uint64_t v20 = *a2;
        *a2 = 0;
        uint64_t v21 = *a1;
        *a1 = v20;
        if (v21)
        {
          uint64_t v22 = sub_19E37059C(v21);
          MEMORY[0x19F3BDCF0](v22, 0x1032C4057ACE4D0);
        }
        uint64_t v13 = *a2;
        *a2 = v19;
        if (v13) {
          goto LABEL_16;
        }
      }
    }
  }
  else
  {
    *a1 = 0;
    if (v9 > result)
    {
      uint64_t v10 = *a3;
      *a3 = 0;
      uint64_t v11 = *a1;
      *a1 = v10;
      if (!v11) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    uint64_t v23 = *a2;
    *a2 = 0;
    uint64_t v24 = *a1;
    *a1 = v23;
    if (v24)
    {
      uint64_t v25 = sub_19E37059C(v24);
      MEMORY[0x19F3BDCF0](v25, 0x1032C4057ACE4D0);
    }
    uint64_t v26 = *a2;
    *a2 = v8;
    if (v26)
    {
      uint64_t v27 = sub_19E37059C(v26);
      MEMORY[0x19F3BDCF0](v27, 0x1032C4057ACE4D0);
      uint64_t v8 = *a2;
    }
    double result = *(double *)(*a3 + 48);
    if (result > *(double *)(v8 + 48))
    {
      *a2 = 0;
      uint64_t v28 = *a3;
      *a3 = 0;
      uint64_t v11 = *a2;
      *a2 = v28;
      if (!v11)
      {
LABEL_5:
        uint64_t v13 = *a3;
        *a3 = v8;
        if (!v13) {
          return result;
        }
LABEL_16:
        sub_19E37059C(v13);
        JUMPOUT(0x19F3BDCF0);
      }
LABEL_4:
      uint64_t v12 = sub_19E37059C(v11);
      MEMORY[0x19F3BDCF0](v12, 0x1032C4057ACE4D0);
      goto LABEL_5;
    }
  }
  return result;
}

void sub_19E3F0D14(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  sub_19E3F0B08(a1, a2, a3);
  uint64_t v8 = *a3;
  if (*(double *)(*a4 + 48) > *(double *)(*a3 + 48))
  {
    *a3 = 0;
    uint64_t v9 = *a4;
    *a4 = 0;
    uint64_t v10 = *a3;
    *a3 = v9;
    if (v10)
    {
      uint64_t v11 = sub_19E37059C(v10);
      MEMORY[0x19F3BDCF0](v11, 0x1032C4057ACE4D0);
    }
    uint64_t v12 = *a4;
    *a4 = v8;
    if (v12)
    {
      uint64_t v13 = sub_19E37059C(v12);
      MEMORY[0x19F3BDCF0](v13, 0x1032C4057ACE4D0);
    }
    uint64_t v14 = *a2;
    if (*(double *)(*a3 + 48) > *(double *)(*a2 + 48))
    {
      *a2 = 0;
      uint64_t v15 = *a3;
      *a3 = 0;
      uint64_t v16 = *a2;
      *a2 = v15;
      if (v16)
      {
        uint64_t v17 = sub_19E37059C(v16);
        MEMORY[0x19F3BDCF0](v17, 0x1032C4057ACE4D0);
      }
      uint64_t v18 = *a3;
      *a3 = v14;
      if (v18)
      {
        uint64_t v19 = sub_19E37059C(v18);
        MEMORY[0x19F3BDCF0](v19, 0x1032C4057ACE4D0);
      }
      uint64_t v20 = *a1;
      if (*(double *)(*a2 + 48) > *(double *)(*a1 + 48))
      {
        *a1 = 0;
        uint64_t v21 = *a2;
        *a2 = 0;
        uint64_t v22 = *a1;
        *a1 = v21;
        if (v22)
        {
          uint64_t v23 = sub_19E37059C(v22);
          MEMORY[0x19F3BDCF0](v23, 0x1032C4057ACE4D0);
        }
        uint64_t v24 = *a2;
        *a2 = v20;
        if (v24)
        {
          sub_19E37059C(v24);
          JUMPOUT(0x19F3BDCF0);
        }
      }
    }
  }
}

void sub_19E3F0EB8(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  sub_19E3F0D14(a1, a2, a3, a4);
  uint64_t v10 = *a4;
  if (*(double *)(*a5 + 48) > *(double *)(*a4 + 48))
  {
    *a4 = 0;
    uint64_t v11 = *a5;
    *a5 = 0;
    uint64_t v12 = *a4;
    *a4 = v11;
    if (v12)
    {
      uint64_t v13 = sub_19E37059C(v12);
      MEMORY[0x19F3BDCF0](v13, 0x1032C4057ACE4D0);
    }
    uint64_t v14 = *a5;
    *a5 = v10;
    if (v14)
    {
      uint64_t v15 = sub_19E37059C(v14);
      MEMORY[0x19F3BDCF0](v15, 0x1032C4057ACE4D0);
    }
    uint64_t v16 = *a3;
    if (*(double *)(*a4 + 48) > *(double *)(*a3 + 48))
    {
      *a3 = 0;
      uint64_t v17 = *a4;
      *a4 = 0;
      uint64_t v18 = *a3;
      *a3 = v17;
      if (v18)
      {
        uint64_t v19 = sub_19E37059C(v18);
        MEMORY[0x19F3BDCF0](v19, 0x1032C4057ACE4D0);
      }
      uint64_t v20 = *a4;
      *a4 = v16;
      if (v20)
      {
        uint64_t v21 = sub_19E37059C(v20);
        MEMORY[0x19F3BDCF0](v21, 0x1032C4057ACE4D0);
      }
      uint64_t v22 = *a2;
      if (*(double *)(*a3 + 48) > *(double *)(*a2 + 48))
      {
        *a2 = 0;
        uint64_t v23 = *a3;
        *a3 = 0;
        uint64_t v24 = *a2;
        *a2 = v23;
        if (v24)
        {
          uint64_t v25 = sub_19E37059C(v24);
          MEMORY[0x19F3BDCF0](v25, 0x1032C4057ACE4D0);
        }
        uint64_t v26 = *a3;
        *a3 = v22;
        if (v26)
        {
          uint64_t v27 = sub_19E37059C(v26);
          MEMORY[0x19F3BDCF0](v27, 0x1032C4057ACE4D0);
        }
        uint64_t v28 = *a1;
        if (*(double *)(*a2 + 48) > *(double *)(*a1 + 48))
        {
          *a1 = 0;
          uint64_t v29 = *a2;
          *a2 = 0;
          uint64_t v30 = *a1;
          *a1 = v29;
          if (v30)
          {
            uint64_t v31 = sub_19E37059C(v30);
            MEMORY[0x19F3BDCF0](v31, 0x1032C4057ACE4D0);
          }
          uint64_t v32 = *a2;
          *a2 = v28;
          if (v32)
          {
            sub_19E37059C(v32);
            JUMPOUT(0x19F3BDCF0);
          }
        }
      }
    }
  }
}

BOOL sub_19E3F10CC(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *a1;
      if (*(double *)(*(a2 - 1) + 48) > *(double *)(*a1 + 48))
      {
        *a1 = 0;
        uint64_t v7 = *(a2 - 1);
        *(a2 - 1) = 0;
        uint64_t v8 = *a1;
        *a1 = v7;
        if (v8)
        {
          uint64_t v9 = sub_19E37059C(v8);
          MEMORY[0x19F3BDCF0](v9, 0x1032C4057ACE4D0);
        }
        uint64_t v10 = *(a2 - 1);
        *(a2 - 1) = v6;
        if (v10)
        {
          uint64_t v11 = sub_19E37059C(v10);
          MEMORY[0x19F3BDCF0](v11, 0x1032C4057ACE4D0);
        }
        return 1;
      }
      return result;
    case 3:
      sub_19E3F0B08(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_19E3F0D14(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_19E3F0EB8(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v12 = a1 + 2;
      sub_19E3F0B08(a1, a1 + 1, a1 + 2);
      uint64_t v13 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v14 = 0;
      uint64_t v15 = 16;
      break;
  }
  while (1)
  {
    uint64_t v16 = *v13;
    uint64_t v17 = *v12;
    if (*(double *)(*v13 + 48) > *(double *)(*v12 + 48))
    {
      uint64_t v18 = 0;
      uint64_t *v13 = 0;
      for (uint64_t i = v15; ; i -= 8)
      {
        uint64_t v20 = (uint64_t *)((char *)a1 + i);
        *uint64_t v20 = 0;
        v20[1] = v17;
        if (v18)
        {
          uint64_t v21 = sub_19E37059C(v18);
          MEMORY[0x19F3BDCF0](v21, 0x1032C4057ACE4D0);
        }
        if (!i) {
          break;
        }
        uint64_t v22 = (uint64_t *)((char *)a1 + i);
        uint64_t v17 = *(uint64_t *)((char *)a1 + i - 8);
        if (*(double *)(v16 + 48) <= *(double *)(v17 + 48)) {
          goto LABEL_19;
        }
        uint64_t v18 = *v20;
      }
      uint64_t v22 = a1;
LABEL_19:
      uint64_t v23 = *v22;
      *uint64_t v22 = v16;
      if (v23)
      {
        uint64_t v24 = sub_19E37059C(v23);
        MEMORY[0x19F3BDCF0](v24, 0x1032C4057ACE4D0);
      }
      if (++v14 == 8) {
        return v13 + 1 == a2;
      }
    }
    uint64_t v12 = v13;
    v15 += 8;
    if (++v13 == a2) {
      return 1;
    }
  }
}

void *sub_19E3F1308()
{
  return &unk_1EF0B81D8;
}

uint64_t sub_19E3F1314(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v126ToucanLanguageModelSession12_completionsERKNS0_17LinguisticContextERKNSt"
                     "3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmE3$_2"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v126ToucanLanguageModelSession12_completionsERKNS0_17LinguisticCo"
                                "ntextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmE3$_2" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v126ToucanLanguageModelSession12_completionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmE3$_2")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v126ToucanLanguageModelSession12_completionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E3F136C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  int v5 = *(_DWORD *)(*(void *)a2 + 240);
  BOOL v6 = v5 == 8 || v5 == 1;
  if (!v6 || **(void **)(a1 + 8) < 0xAuLL) {
    goto LABEL_9;
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(v4 + 96) + 112))(*(void *)(v4 + 96));
  if (result != 1)
  {
    int v5 = *(_DWORD *)(*(void *)a2 + 240);
LABEL_9:
    BOOL v8 = v5 == 8 || v5 == 1;
    if (!v8
      || **(void **)(a1 + 8) >= 0xAuLL
      && (*(unsigned int (**)(void))(**(void **)(v4 + 96) + 112))(*(void *)(v4 + 96)))
    {
      if (*(void *)(*(void *)(a1 + 16) + 8) < *(void *)(*(void *)(a1 + 16) + 16)) {
        operator new();
      }
      sub_19E3F1828(*(void **)(a1 + 16));
    }
    operator new();
  }
  return result;
}

void sub_19E3F1750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  language_modeling::v1::Prediction::~Prediction((language_modeling::v1::Prediction *)&a23);
  if (*(char *)(v28 - 89) < 0) {
    operator delete(*(void **)(v28 - 112));
  }
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)(v28 - 72));
  _Unwind_Resume(a1);
}

void sub_19E3F1800()
{
}

void sub_19E3F1828(void *a1)
{
  unint64_t v1 = ((uint64_t)(a1[1] - *a1) >> 3) + 1;
  if (!(v1 >> 61))
  {
    uint64_t v2 = a1[2] - *a1;
    if (v2 >> 2 > v1) {
      unint64_t v1 = v2 >> 2;
    }
    if ((unint64_t)v2 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v3 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v3 = v1;
    }
    if (v3)
    {
      if (v3 >> 61) {
        sub_19E37C2B8();
      }
      operator new(8 * v3);
    }
    operator new();
  }
  sub_19E37C7C4();
}

void sub_19E3F19F8(void *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x1032C4057ACE4D0);
  sub_19E37B770(a1);
}

__n128 sub_19E3F1A28(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0BDB90;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E3F1A60(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1EF0BDB90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void sub_19E3F1ABC()
{
}

void sub_19E3F1AD4()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA4F8] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA348], MEMORY[0x1E4FBA1F0]);
}

void *sub_19E3F1B20()
{
  return &unk_1EF0B81C8;
}

uint64_t sub_19E3F1B2C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v126ToucanLanguageModelSession12_completionsERKNS0_17LinguisticContextERKNSt"
                     "3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmE3$_0"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v126ToucanLanguageModelSession12_completionsERKNS0_17LinguisticCo"
                                "ntextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v126ToucanLanguageModelSession12_completionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v126ToucanLanguageModelSession12_completionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmmE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E3F1B84(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 8) + 8) < *(void *)(*(void *)(a1 + 8) + 16)) {
    operator new();
  }
  sub_19E3F1828(*(void **)(a1 + 8));
}

void sub_19E3F1C00(void *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x1032C4057ACE4D0);
  sub_19E37B770(a1);
}

uint64_t sub_19E3F1C30(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0BDB38;
  a2[1] = v2;
  return result;
}

void *sub_19E3F1C54(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0BDB38;
  result[1] = v3;
  return result;
}

void sub_19E3F1C9C()
{
}

void sub_19E3F1CB4()
{
}

void sub_19E3F1CCC()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_19E3F1ED8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  BOOL v8 = va_arg(va2, void **);
  sub_19E3D34D0((uint64_t *)va);
  language_modeling::v1::CompletionStem::~CompletionStem((void ***)va2);
  language_modeling::v1::CompletionStem::~CompletionStem((void ***)va1);
  _Unwind_Resume(a1);
}

void sub_19E3F1F18(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x19E3F1F24);
  }
  JUMPOUT(0x19E3F1F48);
}

void sub_19E3F1F3C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_19E37B770(a1);
}

void sub_19E3F1F58(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, void **a4@<X3>, void *a5@<X8>)
{
}

void sub_19E3F20CC(void *a1, uint64_t a2, uint64_t *a3, void *a4, void **a5)
{
  uint64_t v317 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a2 + 8);
  int v7 = *(char *)(v6 + 23);
  if (v7 >= 0) {
    size_t v8 = *(unsigned __int8 *)(v6 + 23);
  }
  else {
    size_t v8 = *(void *)(v6 + 8);
  }
  if (v8 == strlen((const char *)language_modeling::v1::kLanguageModelTypeTokenID))
  {
    uint64_t v9 = v7 >= 0 ? (const void *)v6 : *(const void **)v6;
    if (!memcmp(v9, (const void *)language_modeling::v1::kLanguageModelTypeTokenID, v8))
    {
      uint64_t v210 = *(void *)(a2 + 176);
      sub_19E546328(v210, a3, a4, (uint64_t)a5, a1);
      return;
    }
  }
  sub_19E3DBE64(&v312, a2, *a5);
  v309 = 0;
  v310 = 0;
  unint64_t v311 = 0;
  v306 = 0;
  v307 = 0;
  unint64_t v308 = 0;
  uint64_t v10 = (void *)*a3;
  v286 = (void *)a3[1];
  if ((void *)*a3 != v286)
  {
    while (1)
    {
      std::string __p = 0;
      long long v305 = 0uLL;
      long long v303 = 0uLL;
      v302 = 0;
      uint64_t v11 = *v10;
      if (v10[1] != *v10)
      {
        uint64_t v12 = 0;
        uint64_t v13 = 0;
        unsigned int v14 = 0;
        v290 = v10;
        do
        {
          uint64_t v16 = (long long *)(v11 + 32 * v13);
          if (*((char *)v16 + 23) < 0)
          {
            sub_19E39369C(&__dst, *(void **)v16, *((void *)v16 + 1));
          }
          else
          {
            long long v17 = *v16;
            *(void *)&long long v315 = *((void *)v16 + 2);
            long long __dst = v17;
          }
          DWORD2(v315) = *(_DWORD *)(v11 + 32 * v13 + 24);
          if (!v14)
          {
            sub_19E3DB9A0((uint64_t)v299, a2, (unsigned __int8 *)(*v10 + 32 * v13), (unsigned int *)v312, v313);
            if (SBYTE7(v315) < 0) {
              operator delete((void *)__dst);
            }
            long long __dst = *(_OWORD *)v299;
            *(void *)&long long v315 = v300;
            DWORD2(v315) = v301;
          }
          (*(void (**)(void **__return_ptr))(**(void **)(a2 + 112) + 16))(v299);
          if ((unint64_t)v12 >= *((void *)&v305 + 1))
          {
            uint64_t v18 = (char *)__p;
            unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v12 - (unsigned char *)__p) >> 3);
            unint64_t v20 = v19 + 1;
            if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_19E37C7C4();
            }
            if (0x5555555555555556 * ((uint64_t)(*((void *)&v305 + 1) - (void)__p) >> 3) > v20) {
              unint64_t v20 = 0x5555555555555556 * ((uint64_t)(*((void *)&v305 + 1) - (void)__p) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v305 + 1) - (void)__p) >> 3) >= 0x555555555555555) {
              unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v21 = v20;
            }
            if (v21 > 0xAAAAAAAAAAAAAAALL) {
              sub_19E37C2B8();
            }
            uint64_t v22 = (char *)operator new(24 * v21);
            uint64_t v23 = &v22[24 * v19];
            *(_OWORD *)uint64_t v23 = *(_OWORD *)v299;
            *((void *)v23 + 2) = v300;
            v299[0] = 0;
            v299[1] = 0;
            uint64_t v300 = 0;
            uint64_t v24 = v23 + 24;
            if (v12 == v18)
            {
              std::string __p = v23;
              *(void *)&long long v305 = v23 + 24;
              *((void *)&v305 + 1) = &v22[24 * v21];
            }
            else
            {
              do
              {
                long long v25 = *(_OWORD *)(v12 - 24);
                v12 -= 24;
                *(_OWORD *)(v23 - 24) = v25;
                v23 -= 24;
                *((void *)v23 + 2) = *((void *)v12 + 2);
                *(void *)uint64_t v12 = 0;
                *((void *)v12 + 1) = 0;
                *((void *)v12 + 2) = 0;
              }
              while (v12 != v18);
              uint64_t v12 = (char *)__p;
              uint64_t v26 = (char *)v305;
              std::string __p = v23;
              *(void *)&long long v305 = v24;
              *((void *)&v305 + 1) = &v22[24 * v21];
              if (v26 != v12)
              {
                uint64_t v27 = v26;
                do
                {
                  uint64_t v29 = (void *)*((void *)v27 - 3);
                  v27 -= 24;
                  uint64_t v28 = v29;
                  if (v29)
                  {
                    *((void *)v26 - 2) = v28;
                    operator delete(v28);
                  }
                  uint64_t v26 = v27;
                }
                while (v27 != v12);
              }
            }
            if (v12) {
              operator delete(v12);
            }
            *(void *)&long long v305 = v24;
            if (v299[0])
            {
              v299[1] = v299[0];
              operator delete(v299[0]);
            }
            uint64_t v12 = v24;
          }
          else
          {
            *(void *)uint64_t v12 = 0;
            *((void *)v12 + 1) = 0;
            *((void *)v12 + 2) = 0;
            *(_OWORD *)uint64_t v12 = *(_OWORD *)v299;
            *((void *)v12 + 2) = v300;
            v12 += 24;
            *(void *)&long long v305 = v12;
          }
          uint64_t v30 = (unsigned int *)*((void *)v12 - 3);
          uint64_t v31 = *((void *)v12 - 2) - (void)v30;
          if (v31)
          {
            uint64_t v32 = 4 * (v31 >> 2);
            while (!(*(unsigned int (**)(void, void))(**(void **)(a2 + 112) + 96))(*(void *)(a2 + 112), *v30))
            {
              ++v30;
              v32 -= 4;
              if (!v32) {
                goto LABEL_17;
              }
            }
            unint64_t v33 = (char *)v303;
            if ((unint64_t)v303 < *((void *)&v303 + 1))
            {
              *(void *)long long v303 = v13;
              uint64_t v15 = v33 + 8;
            }
            else
            {
              uint64_t v34 = (char *)v302;
              uint64_t v35 = v303 - (void)v302;
              uint64_t v36 = (uint64_t)(v303 - (void)v302) >> 3;
              unint64_t v37 = v36 + 1;
              if ((unint64_t)(v36 + 1) >> 61) {
                sub_19E37C7C4();
              }
              uint64_t v38 = *((void *)&v303 + 1) - (void)v302;
              if ((uint64_t)(*((void *)&v303 + 1) - (void)v302) >> 2 > v37) {
                unint64_t v37 = v38 >> 2;
              }
              if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v39 = v37;
              }
              if (v39)
              {
                if (v39 >> 61) {
                  sub_19E37C2B8();
                }
                unint64_t v40 = (char *)operator new(8 * v39);
              }
              else
              {
                unint64_t v40 = 0;
              }
              unint64_t v41 = &v40[8 * v36];
              *(void *)unint64_t v41 = v13;
              uint64_t v15 = v41 + 8;
              if (v33 != v34)
              {
                unint64_t v42 = v33 - 8 - v34;
                if (v42 < 0x58) {
                  goto LABEL_418;
                }
                if ((unint64_t)(v33 - &v40[v35]) < 0x20) {
                  goto LABEL_418;
                }
                uint64_t v43 = (v42 >> 3) + 1;
                uint64_t v44 = &v40[8 * v36 - 16];
                uint64_t v45 = v33 - 16;
                uint64_t v46 = v43 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v47 = *(_OWORD *)v45;
                  *((_OWORD *)v44 - 1) = *((_OWORD *)v45 - 1);
                  *(_OWORD *)uint64_t v44 = v47;
                  v44 -= 32;
                  v45 -= 32;
                  v46 -= 4;
                }
                while (v46);
                v41 -= 8 * (v43 & 0x3FFFFFFFFFFFFFFCLL);
                v33 -= 8 * (v43 & 0x3FFFFFFFFFFFFFFCLL);
                if (v43 != (v43 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_418:
                  do
                  {
                    uint64_t v48 = *((void *)v33 - 1);
                    v33 -= 8;
                    *((void *)v41 - 1) = v48;
                    v41 -= 8;
                  }
                  while (v33 != v34);
                }
              }
              v302 = v41;
              *((void *)&v303 + 1) = &v40[8 * v39];
              if (v34) {
                operator delete(v34);
              }
            }
            uint64_t v10 = v290;
            *(void *)&long long v303 = v15;
          }
LABEL_17:
          if (SBYTE7(v315) < 0) {
            operator delete((void *)__dst);
          }
          uint64_t v11 = *v10;
          uint64_t v13 = ++v14;
        }
        while (v14 < (unint64_t)((uint64_t)(v10[1] - *v10) >> 5));
      }
      uint64_t v49 = v307;
      if ((unint64_t)v307 >= v308)
      {
        uint64_t v50 = v302;
        uint64_t v54 = sub_19E3F40DC(&v306, v302, v303);
      }
      else
      {
        *(void *)v307 = 0;
        *((void *)v49 + 1) = 0;
        *((void *)v49 + 2) = 0;
        uint64_t v50 = v302;
        int64_t v51 = v303 - (void)v302;
        if ((void *)v303 != v302)
        {
          if (v51 < 0) {
            sub_19E37C7C4();
          }
          uint64_t v52 = (char *)operator new(v303 - (void)v302);
          *(void *)uint64_t v49 = v52;
          *((void *)v49 + 1) = v52;
          uint64_t v53 = &v52[8 * (v51 >> 3)];
          *((void *)v49 + 2) = v53;
          memcpy(v52, v50, v51);
          *((void *)v49 + 1) = v53;
        }
        uint64_t v54 = v49 + 24;
      }
      v307 = v54;
      uint64_t v55 = v310;
      if ((unint64_t)v310 >= v311) {
        break;
      }
      sub_19E3F42D0(v310, (uint64_t *)&__p);
      v310 = v55 + 3;
      if (v50) {
        goto LABEL_85;
      }
LABEL_86:
      uint64_t v56 = (char *)__p;
      if (__p)
      {
        double v57 = (char *)v305;
        if ((void *)v305 != __p)
        {
          uint64_t v58 = (char *)v305;
          do
          {
            CFIndex v60 = (void *)*((void *)v58 - 3);
            v58 -= 24;
            uint64_t v59 = v60;
            if (v60)
            {
              *((void *)v57 - 2) = v59;
              operator delete(v59);
            }
            double v57 = v58;
          }
          while (v58 != v56);
        }
        operator delete(v56);
      }
      v10 += 3;
      if (v10 == v286) {
        goto LABEL_120;
      }
    }
    unint64_t v61 = 0xAAAAAAAAAAAAAAABLL * (v310 - v309);
    unint64_t v62 = v61 + 1;
    if (v61 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_19E37C7C4();
    }
    if (0x5555555555555556 * ((uint64_t)(v311 - (void)v309) >> 3) > v62) {
      unint64_t v62 = 0x5555555555555556 * ((uint64_t)(v311 - (void)v309) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v311 - (void)v309) >> 3) >= 0x555555555555555) {
      unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v63 = v62;
    }
    v316 = &v311;
    if (v63)
    {
      if (v63 > 0xAAAAAAAAAAAAAAALL) {
        sub_19E37C2B8();
      }
      uint64_t v64 = (char *)operator new(24 * v63);
    }
    else
    {
      uint64_t v64 = 0;
    }
    *(void *)&long long __dst = v64;
    *((void *)&__dst + 1) = &v64[24 * v61];
    *(void *)&long long v315 = *((void *)&__dst + 1);
    *((void *)&v315 + 1) = &v64[24 * v63];
    sub_19E3F42D0(*((void **)&__dst + 1), (uint64_t *)&__p);
    uint64_t v65 = (void **)*((void *)&__dst + 1);
    uint64_t v66 = (void **)(v315 + 24);
    uint64_t v67 = v309;
    uint64_t v68 = v310;
    if (v310 == v309)
    {
      v309 = (void **)*((void *)&__dst + 1);
      v310 = (void **)(v315 + 24);
      unint64_t v311 = *((void *)&v315 + 1);
    }
    else
    {
      do
      {
        *(v65 - 3) = 0;
        *(v65 - 2) = 0;
        v65 -= 3;
        v65[2] = 0;
        long long v69 = *(_OWORD *)(v68 - 3);
        v68 -= 3;
        *(_OWORD *)uint64_t v65 = v69;
        v65[2] = v68[2];
        *uint64_t v68 = 0;
        v68[1] = 0;
        v68[2] = 0;
      }
      while (v68 != v67);
      uint64_t v68 = v309;
      uint64_t v70 = v310;
      v309 = v65;
      v310 = v66;
      unint64_t v311 = *((void *)&v315 + 1);
      if (v70 != v68)
      {
        std::string::size_type v71 = v70;
        do
        {
          uint64_t v74 = (char *)*(v71 - 3);
          v71 -= 3;
          BOOL v73 = v74;
          if (v74)
          {
            CFComparisonResult v75 = (char *)*(v70 - 2);
            char v72 = v73;
            if (v75 != v73)
            {
              uint64_t v76 = (char *)*(v70 - 2);
              do
              {
                char v78 = (void *)*((void *)v76 - 3);
                v76 -= 24;
                uint64_t v77 = v78;
                if (v78)
                {
                  *((void *)v75 - 2) = v77;
                  operator delete(v77);
                }
                CFComparisonResult v75 = v76;
              }
              while (v76 != v73);
              char v72 = *v71;
            }
            *(v70 - 2) = v73;
            operator delete(v72);
          }
          uint64_t v70 = v71;
        }
        while (v71 != v68);
      }
    }
    if (v68) {
      operator delete(v68);
    }
    uint64_t v50 = v302;
    v310 = v66;
    if (!v302) {
      goto LABEL_86;
    }
LABEL_85:
    *(void *)&long long v303 = v50;
    operator delete(v50);
    goto LABEL_86;
  }
LABEL_120:
  v299[0] = 0;
  v299[1] = 0;
  uint64_t v300 = 0;
  uint64_t v298 = 0;
  if (((*(uint64_t (**)(void, void ***, void *, char **, void **, uint64_t *))(**(void **)(a2 + 96)
                                                                                           + 32))(*(void *)(a2 + 96), &v309, a4, &v312, v299, &v298) & 1) == 0)
  {
    int v80 = (char *)v299[0];
    uint64_t v79 = v299[1];
    if (v299[1] != v299[0])
    {
      int v81 = (char *)v299[1];
      do
      {
        int v83 = (void *)*((void *)v81 - 3);
        v81 -= 24;
        uint64_t v82 = v83;
        if (v83)
        {
          *(v79 - 2) = v82;
          operator delete(v82);
        }
        uint64_t v79 = v81;
      }
      while (v81 != v80);
    }
    v299[1] = v80;
  }
  if (!*(unsigned char *)(a2 + 81))
  {
    uint64_t v173 = v306;
    if (v307 != v306)
    {
      uint64_t v174 = 0;
      unint64_t v175 = (v307 - v306) / 24;
      std::string::size_type v176 = v299[0];
      if (v175 <= 1) {
        unint64_t v175 = 1;
      }
      do
      {
        int v177 = &v173[24 * v174];
        uint64_t v178 = *(void *)v177;
        uint64_t v179 = *((void *)v177 + 1) - *(void *)v177;
        if (v179)
        {
          unint64_t v180 = v179 >> 3;
          uint64_t v181 = v176[3 * v174];
          if (v180 <= 1) {
            unint64_t v180 = 1;
          }
          if (v180 > 1)
          {
            unint64_t v182 = v180 & 0xFFFFFFFFFFFFFFFELL;
            int64_t v183 = (uint64_t *)(v178 + 8);
            unint64_t v184 = v180 & 0xFFFFFFFFFFFFFFFELL;
            do
            {
              uint64_t v185 = *v183;
              *(_DWORD *)(v181 + 4 * *(v183 - 1)) = 0;
              *(_DWORD *)(v181 + 4 * v185) = 0;
              v183 += 2;
              v184 -= 2;
            }
            while (v184);
            if (v180 == v182) {
              goto LABEL_254;
            }
          }
          else
          {
            unint64_t v182 = 0;
          }
          unint64_t v186 = v180 - v182;
          unint64_t v187 = (uint64_t *)(v178 + 8 * v182);
          do
          {
            uint64_t v188 = *v187++;
            *(_DWORD *)(v181 + 4 * v188) = 0;
            --v186;
          }
          while (v186);
        }
LABEL_254:
        ++v174;
      }
      while (v174 != v175);
    }
  }
  std::string __p = 0;
  long long v305 = 0uLL;
  uint64_t v84 = (float **)v299[0];
  v287 = (float **)v299[1];
  if (v299[0] == v299[1])
  {
    v302 = 0;
    long long v303 = 0uLL;
    goto LABEL_267;
  }
  do
  {
    v302 = 0;
    long long v303 = 0uLL;
    uint64_t v85 = *v84;
    int64_t v86 = v84[1];
    v291 = v84;
    if (*v84 != v86)
    {
      int64_t v87 = 0;
      int64_t v88 = 0;
      uint64_t v89 = 0;
      while (1)
      {
        float v91 = *v85;
        float v92 = log10f(*v85);
        if (v91 <= 0.0) {
          float v92 = -10.0;
        }
        double v93 = v92;
        if (v89 >= v88) {
          break;
        }
        double *v89 = v93;
        size_t v90 = v89 + 1;
LABEL_134:
        *(void *)&long long v303 = v90;
        ++v85;
        uint64_t v89 = v90;
        if (v85 == v86) {
          goto LABEL_161;
        }
      }
      uint64_t v94 = v89 - v87;
      unint64_t v95 = v94 + 1;
      if ((unint64_t)(v94 + 1) >> 61) {
        sub_19E37C7C4();
      }
      if (((char *)v88 - (char *)v87) >> 2 > v95) {
        unint64_t v95 = ((char *)v88 - (char *)v87) >> 2;
      }
      if ((unint64_t)((char *)v88 - (char *)v87) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v96 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v96 = v95;
      }
      if (v96)
      {
        if (v96 >> 61) {
          sub_19E37C2B8();
        }
        uint64_t v97 = operator new(8 * v96);
      }
      else
      {
        uint64_t v97 = 0;
      }
      uint64_t v98 = (double *)&v97[8 * v94];
      *uint64_t v98 = v93;
      size_t v90 = v98 + 1;
      if (v89 != v87)
      {
        unint64_t v99 = (char *)(v89 - 1) - (char *)v87;
        if (v99 >= 0x58)
        {
          if ((unint64_t)((char *)v87 - v97) >= 0x20)
          {
            uint64_t v101 = (v99 >> 3) + 1;
            uint64_t v100 = &v89[-(v101 & 0x3FFFFFFFFFFFFFFCLL)];
            uint64_t v102 = &v97[8 * v94 - 16];
            uint64_t v103 = v89 - 2;
            uint64_t v104 = v101 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v105 = *(_OWORD *)v103;
              *(v102 - 1) = *((_OWORD *)v103 - 1);
              *uint64_t v102 = v105;
              v102 -= 2;
              v103 -= 4;
              v104 -= 4;
            }
            while (v104);
            v98 -= v101 & 0x3FFFFFFFFFFFFFFCLL;
            if (v101 == (v101 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_157;
            }
          }
          else
          {
            uint64_t v100 = v89;
          }
        }
        else
        {
          uint64_t v100 = v89;
        }
        do
        {
          uint64_t v106 = *((void *)v100-- - 1);
          *((void *)v98-- - 1) = v106;
        }
        while (v100 != v87);
      }
LABEL_157:
      int64_t v88 = (double *)&v97[8 * v96];
      v302 = v98;
      *(void *)&long long v303 = v90;
      *((void *)&v303 + 1) = v88;
      if (v87) {
        operator delete(v87);
      }
      int64_t v87 = v98;
      goto LABEL_134;
    }
    size_t v90 = 0;
LABEL_161:
    uint64_t v107 = (void *)v305;
    if ((unint64_t)v305 >= *((void *)&v305 + 1))
    {
      uint64_t v113 = __p;
      unint64_t v114 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v305 - (void)__p) >> 3);
      unint64_t v115 = v114 + 1;
      if (v114 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_19E37C7C4();
      }
      if (0x5555555555555556 * ((uint64_t)(*((void *)&v305 + 1) - (void)__p) >> 3) > v115) {
        unint64_t v115 = 0x5555555555555556 * ((uint64_t)(*((void *)&v305 + 1) - (void)__p) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v305 + 1) - (void)__p) >> 3) >= 0x555555555555555) {
        unint64_t v116 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v116 = v115;
      }
      v316 = (unint64_t *)&v305 + 1;
      if (v116)
      {
        if (v116 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C2B8();
        }
        uint64_t v117 = (char *)operator new(24 * v116);
      }
      else
      {
        uint64_t v117 = 0;
      }
      *(void *)&long long __dst = v117;
      *((void *)&__dst + 1) = &v117[24 * v114];
      uint64_t v119 = &v117[24 * v116];
      *(void *)&long long v315 = *((void *)&__dst + 1);
      *((void *)&v315 + 1) = v119;
      uint64_t v120 = *((void *)&__dst + 1);
      *(void *)(*((void *)&__dst + 1) + 8) = 0;
      unint64_t v121 = (char **)(v120 + 8);
      uint64_t v118 = &v117[24 * v114];
      *((void *)v118 + 2) = 0;
      *(void *)uint64_t v118 = 0;
      unint64_t v122 = v302;
      int64_t v123 = (char *)v90 - (unsigned char *)v302;
      if (v90 != v302)
      {
        if (v123 < 0) {
          sub_19E37C7C4();
        }
        uint64_t v124 = (char *)operator new((char *)v90 - (unsigned char *)v302);
        *(void *)uint64_t v118 = v124;
        *unint64_t v121 = v124;
        uint64_t v125 = &v124[8 * (v123 >> 3)];
        *((void *)v118 + 2) = v125;
        memcpy(v124, v122, v123);
        *unint64_t v121 = v125;
      }
      v126 = v118 + 24;
      *(void *)&long long v315 = v118 + 24;
      if (v107 == v113)
      {
        std::string __p = v118;
        *(void *)&long long v305 = v118 + 24;
        *((void *)&v305 + 1) = v119;
        uint64_t v112 = v291;
      }
      else
      {
        uint64_t v112 = v291;
        do
        {
          uint64_t v127 = v118;
          *((void *)v118 - 2) = 0;
          *((void *)v118 - 1) = 0;
          long long v128 = *(_OWORD *)(v107 - 3);
          v107 -= 3;
          *(_OWORD *)(v118 - 24) = v128;
          v118 -= 24;
          *((void *)v127 - 1) = v107[2];
          *uint64_t v107 = 0;
          v107[1] = 0;
          v107[2] = 0;
        }
        while (v107 != v113);
        uint64_t v107 = __p;
        v129 = (void *)v305;
        std::string __p = v118;
        long long v305 = v315;
        v126 = (void *)v315;
        if (v129 != v107)
        {
          uint64_t v130 = v129;
          do
          {
            double v132 = (void *)*(v130 - 3);
            v130 -= 3;
            uint64_t v131 = v132;
            if (v132)
            {
              *(v129 - 2) = v131;
              operator delete(v131);
            }
            v129 = v130;
          }
          while (v130 != v107);
        }
      }
      if (v107) {
        operator delete(v107);
      }
      v108 = v302;
      *(void *)&long long v305 = v126;
      if (v302) {
LABEL_192:
      }
        operator delete(v108);
    }
    else
    {
      *(void *)long long v305 = 0;
      v107[1] = 0;
      v107[2] = 0;
      v108 = v302;
      int64_t v109 = (char *)v90 - (unsigned char *)v302;
      if (v90 != v302)
      {
        if (v109 < 0) {
          sub_19E37C7C4();
        }
        uint64_t v110 = (char *)operator new((char *)v90 - (unsigned char *)v302);
        *uint64_t v107 = v110;
        v107[1] = v110;
        uint64_t v111 = &v110[8 * (v109 >> 3)];
        v107[2] = v111;
        memcpy(v110, v108, v109);
        v107[1] = v111;
      }
      uint64_t v112 = v291;
      *(void *)&long long v305 = v107 + 3;
      if (v108) {
        goto LABEL_192;
      }
    }
    uint64_t v84 = v112 + 3;
  }
  while (v84 != v287);
  uint64_t v133 = (uint64_t **)__p;
  v302 = 0;
  long long v303 = 0uLL;
  v284 = (uint64_t **)v305;
  if (__p != (void *)v305)
  {
    do
    {
      uint64_t v135 = *v133;
      uint64_t v134 = v133[1];
      v288 = v133;
      if (*v133 == v134)
      {
        uint64_t v138 = 0;
        uint64_t v137 = 0;
      }
      else
      {
        uint64_t v136 = 0;
        uint64_t v137 = 0;
        uint64_t v138 = 0;
        do
        {
          long long __dst = 0uLL;
          uint64_t v139 = *v135;
          if (v138 < v136)
          {
            *(void *)uint64_t v138 = v139;
            *((void *)v138 + 1) = v139;
            *((void *)v138 + 2) = 0;
            *((_WORD *)v138 + 12) = 0;
            v138[32] = 1;
            *((void *)v138 + 5) = v139;
            *((void *)v138 + 6) = 0x3FF0000000000000;
            *((_DWORD *)v138 + 14) = 2;
            *((_OWORD *)v138 + 4) = xmmword_19E572FD0;
            *((void *)v138 + 10) = 0xFFEFFFFFFFFFFFFFLL;
            *(_OWORD *)(v138 + 88) = __dst;
            v138 += 104;
          }
          else
          {
            unint64_t v140 = 0x4EC4EC4EC4EC4EC5 * ((v138 - v137) >> 3) + 1;
            if (v140 > 0x276276276276276) {
              sub_19E37C7C4();
            }
            if (0x9D89D89D89D89D8ALL * ((v136 - v137) >> 3) > v140) {
              unint64_t v140 = 0x9D89D89D89D89D8ALL * ((v136 - v137) >> 3);
            }
            if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((v136 - v137) >> 3)) >= 0x13B13B13B13B13BLL) {
              unint64_t v141 = 0x276276276276276;
            }
            else {
              unint64_t v141 = v140;
            }
            if (v141)
            {
              if (v141 > 0x276276276276276) {
                sub_19E37C2B8();
              }
              unint64_t v142 = (char *)operator new(104 * v141);
            }
            else
            {
              unint64_t v142 = 0;
            }
            uint64_t v143 = &v142[8 * ((v138 - v137) >> 3)];
            *(void *)uint64_t v143 = v139;
            *((void *)v143 + 1) = v139;
            *((void *)v143 + 2) = 0;
            *((_WORD *)v143 + 12) = 0;
            v143[32] = 1;
            *((void *)v143 + 5) = v139;
            *((void *)v143 + 6) = 0x3FF0000000000000;
            *((_DWORD *)v143 + 14) = 2;
            *((_OWORD *)v143 + 4) = xmmword_19E572FD0;
            *((void *)v143 + 11) = 0;
            *((void *)v143 + 12) = 0;
            *((void *)v143 + 10) = 0xFFEFFFFFFFFFFFFFLL;
            if (v138 == v137)
            {
              v150 = &v142[8 * ((v138 - v137) >> 3)];
            }
            else
            {
              v144 = &v142[8 * ((v138 - v137) >> 3)];
              do
              {
                long long v145 = *(_OWORD *)(v138 - 104);
                long long v146 = *(_OWORD *)(v138 - 88);
                *(_OWORD *)(v144 - 72) = *(_OWORD *)(v138 - 72);
                *(_OWORD *)(v144 - 88) = v146;
                *(_OWORD *)(v144 - 104) = v145;
                long long v147 = *(_OWORD *)(v138 - 56);
                long long v148 = *(_OWORD *)(v138 - 40);
                long long v149 = *(_OWORD *)(v138 - 24);
                v150 = v144 - 104;
                *((void *)v144 - 1) = *((void *)v138 - 1);
                *(_OWORD *)(v144 - 24) = v149;
                *(_OWORD *)(v144 - 40) = v148;
                *(_OWORD *)(v144 - 56) = v147;
                v138 -= 104;
                v144 -= 104;
              }
              while (v138 != v137);
            }
            uint64_t v136 = &v142[104 * v141];
            uint64_t v138 = v143 + 104;
            if (v137) {
              operator delete(v137);
            }
            uint64_t v137 = v150;
          }
          ++v135;
        }
        while (v135 != v134);
      }
      v151 = (void *)v303;
      if ((unint64_t)v303 >= *((void *)&v303 + 1))
      {
        unint64_t v157 = v302;
        unint64_t v158 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v303 - (void)v302) >> 3);
        unint64_t v159 = v158 + 1;
        if (v158 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C7C4();
        }
        if (0x5555555555555556 * ((uint64_t)(*((void *)&v303 + 1) - (void)v302) >> 3) > v159) {
          unint64_t v159 = 0x5555555555555556 * ((uint64_t)(*((void *)&v303 + 1) - (void)v302) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v303 + 1) - (void)v302) >> 3) >= 0x555555555555555) {
          unint64_t v160 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v160 = v159;
        }
        v316 = (unint64_t *)&v303 + 1;
        if (v160)
        {
          if (v160 > 0xAAAAAAAAAAAAAAALL) {
            sub_19E37C2B8();
          }
          v161 = (char *)operator new(24 * v160);
        }
        else
        {
          v161 = 0;
        }
        std::string::size_type v162 = &v161[24 * v158];
        *(void *)&long long __dst = v161;
        *((void *)&__dst + 1) = v162;
        v163 = &v161[24 * v160];
        *((void *)v162 + 1) = 0;
        *(void *)&long long v315 = v162;
        *((void *)&v315 + 1) = v163;
        *((void *)v162 + 2) = 0;
        *(void *)std::string::size_type v162 = 0;
        int64_t v164 = v138 - v137;
        if (v164)
        {
          v282 = &v161[24 * v160];
          v283 = (char **)(v162 + 8);
          if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (v164 >> 3)) > 0x276276276276276) {
            sub_19E37C7C4();
          }
          v165 = (char *)operator new(v164);
          *(void *)std::string::size_type v162 = v165;
          *v283 = v165;
          unint64_t v166 = &v165[8 * (v164 >> 3)];
          *((void *)v162 + 2) = v166;
          memcpy(v165, v137, v164);
          v163 = v282;
          *v283 = v166;
        }
        unint64_t v155 = v162 + 24;
        *(void *)&long long v315 = v162 + 24;
        if (v151 == v157)
        {
          v302 = v162;
          *(void *)&long long v303 = v162 + 24;
          *((void *)&v303 + 1) = v163;
        }
        else
        {
          do
          {
            uint64_t v167 = v162;
            *((void *)v162 - 2) = 0;
            *((void *)v162 - 1) = 0;
            long long v168 = *(_OWORD *)(v151 - 3);
            v151 -= 3;
            *(_OWORD *)(v162 - 24) = v168;
            v162 -= 24;
            *((void *)v167 - 1) = v151[2];
            void *v151 = 0;
            v151[1] = 0;
            v151[2] = 0;
          }
          while (v151 != v157);
          v151 = v302;
          uint64_t v169 = (void *)v303;
          v302 = v162;
          long long v303 = v315;
          unint64_t v155 = (void *)v315;
          if (v169 != v151)
          {
            std::string::size_type v170 = v169;
            do
            {
              uint64_t v172 = (void *)*(v170 - 3);
              v170 -= 3;
              int v171 = v172;
              if (v172)
              {
                *(v169 - 2) = v171;
                operator delete(v171);
              }
              uint64_t v169 = v170;
            }
            while (v170 != v151);
          }
        }
        int8x8_t v156 = v288;
        if (v151) {
          operator delete(v151);
        }
      }
      else
      {
        *(_OWORD *)long long v303 = 0uLL;
        v151[2] = 0;
        int64_t v152 = v138 - v137;
        if (v152)
        {
          if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (v152 >> 3)) > 0x276276276276276) {
            sub_19E37C7C4();
          }
          v153 = (char *)operator new(v152);
          void *v151 = v153;
          v151[1] = v153;
          std::string::size_type v154 = &v153[8 * (v152 >> 3)];
          v151[2] = v154;
          memcpy(v153, v137, v152);
          v151[1] = v154;
        }
        unint64_t v155 = v151 + 3;
        int8x8_t v156 = v288;
      }
      *(void *)&long long v303 = v155;
      if (v137) {
        operator delete(v137);
      }
      uint64_t v133 = v156 + 3;
    }
    while (v133 != v284);
  }
LABEL_267:
  v296[0] = 0;
  v296[1] = 0;
  v297 = 0;
  if (*(_DWORD *)(a2 + 48) == 3)
  {
    v189 = v302;
    v292 = (void *)v303;
    if (v302 == (void *)v303)
    {
      v209 = 0;
      long long v208 = 0uLL;
    }
    else
    {
      do
      {
        long long __dst = 0uLL;
        *(void *)&long long v315 = 0;
        if (*v189 != v189[1]) {
          operator new();
        }
        uint64_t v190 = 0;
        v191 = (char *)v296[1];
        if (v296[1] >= v297)
        {
          v192 = sub_19E3F4634((void ***)v296, &__dst);
        }
        else
        {
          sub_19E3F4510((void *)v296[1], &__dst);
          v192 = v191 + 24;
        }
        v296[1] = v192;
        v193 = (void *)__dst;
        if ((void)__dst)
        {
          do
          {
            uint64_t v195 = *--v190;
            uint64_t v194 = v195;
            *uint64_t v190 = 0;
            if (v195) {
              MEMORY[0x19F3BDCF0](v194, 0x1000C4065B674BELL);
            }
          }
          while (v190 != v193);
          *((void *)&__dst + 1) = v193;
          operator delete((void *)__dst);
        }
        v189 += 3;
      }
      while (v189 != v292);
      long long v208 = *(_OWORD *)v296;
      v209 = v297;
    }
    *(_OWORD *)a1 = v208;
    a1[2] = v209;
  }
  else
  {
    uint64_t v196 = *(void *)(a2 + 176);
    *(void *)&long long __dst = &unk_1EF0BD610;
    *((void *)&v315 + 1) = &__dst;
    sub_19E546818(&v294, v196, (uint64_t)a3, a4, (uint64_t)a5, &v302);
    uint64_t v197 = a1;
    uint64_t v198 = (void **)v294;
    if (v294)
    {
      uint64_t v199 = v295;
      unint64_t v200 = v294;
      if (v295 != v294)
      {
        unint64_t v201 = v295;
        do
        {
          v204 = *(v201 - 3);
          v201 -= 3;
          uint64_t v203 = v204;
          if (v204)
          {
            v205 = *(v199 - 2);
            unint64_t v202 = v203;
            if (v205 != v203)
            {
              do
              {
                uint64_t v207 = *--v205;
                uint64_t v206 = v207;
                void *v205 = 0;
                if (v207) {
                  MEMORY[0x19F3BDCF0](v206, 0x1000C4065B674BELL);
                }
              }
              while (v205 != v203);
              unint64_t v202 = *v201;
            }
            *(v199 - 2) = v203;
            operator delete(v202);
          }
          uint64_t v199 = v201;
        }
        while (v201 != v198);
        unint64_t v200 = v294;
        uint64_t v197 = a1;
      }
      v295 = v198;
      operator delete(v200);
    }
    if (*((long long **)&v315 + 1) == &__dst)
    {
      (*(void (**)(long long *))(__dst + 32))(&__dst);
    }
    else if (*((void *)&v315 + 1))
    {
      (*(void (**)(void))(**((void **)&v315 + 1) + 40))();
    }
    *uint64_t v197 = 0;
    v197[1] = 0;
    v197[2] = 0;
    std::string::size_type v211 = v302;
    v212 = (void *)v303;
    v289 = (void *)v303;
    while (v211 != v212)
    {
      long long __dst = 0uLL;
      *(void *)&long long v315 = 0;
      uint64_t v213 = *v211;
      v293 = v211;
      if (*v211 != v211[1])
      {
        double v218 = *(double *)(v213 + 72);
        if (v218 <= 0.0) {
          goto LABEL_327;
        }
        if (*(double *)(v213 + 48) <= 0.0)
        {
          *(void *)(v213 + 48) = 0;
          if (v218 > 0.0) {
            goto LABEL_322;
          }
        }
        else
        {
          uint64_t v219 = *(void *)(a2 + 176);
          uint64_t v220 = *(void *)(v219 + 72);
          v221 = *(std::__shared_weak_count **)(v219 + 80);
          if (v221)
          {
            atomic_fetch_add_explicit(&v221->__shared_owners_, 1uLL, memory_order_relaxed);
            *(double *)(v213 + 48) = *(float *)(*(void *)(v220 + 232) + 420);
            if (!atomic_fetch_add(&v221->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v221->__on_zero_shared)(v221);
              std::__shared_weak_count::__release_weak(v221);
            }
          }
          else
          {
            *(double *)(v213 + 48) = *(float *)(*(void *)(v220 + 232) + 420);
          }
          if (*(double *)(v213 + 72) > 0.0)
          {
LABEL_322:
            uint64_t v222 = *(void *)(a2 + 176);
            uint64_t v223 = *(void *)(v222 + 72);
            uint64_t v224 = *(std::__shared_weak_count **)(v222 + 80);
            if (v224)
            {
              atomic_fetch_add_explicit(&v224->__shared_owners_, 1uLL, memory_order_relaxed);
              *(double *)(v213 + 72) = *(float *)(*(void *)(v223 + 232) + 424);
              if (!atomic_fetch_add(&v224->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v224->__on_zero_shared)(v224);
                std::__shared_weak_count::__release_weak(v224);
              }
            }
            else
            {
              *(double *)(v213 + 72) = *(float *)(*(void *)(v223 + 232) + 424);
            }
LABEL_326:
            double v225 = *(double *)(v213 + 48);
            double v226 = __exp10(*(double *)(v213 + 40)) * v225;
            double v227 = *(double *)(v213 + 72);
            double v228 = v226 + __exp10(*(double *)(v213 + 64)) * v227;
            double v229 = *(double *)(v213 + 88);
            double v230 = __exp10(*(double *)(v213 + 80));
            *(long double *)uint64_t v213 = log10(v228 + v230 * v229) - *(double *)(v213 + 96);
LABEL_327:
            operator new();
          }
        }
        *(void *)(v213 + 72) = 0;
        goto LABEL_326;
      }
      uint64_t v214 = 0;
      unint64_t v215 = a1[1];
      if (v215 >= a1[2])
      {
        uint64_t v216 = sub_19E3F4634((void ***)a1, &__dst);
        v217 = a1;
      }
      else
      {
        sub_19E3F4510((void *)a1[1], &__dst);
        uint64_t v216 = (char *)(v215 + 24);
        v217 = a1;
        a1[1] = v215 + 24;
      }
      v217[1] = v216;
      uint64_t v231 = (void *)__dst;
      if ((void)__dst)
      {
        do
        {
          uint64_t v233 = *--v214;
          uint64_t v232 = v233;
          *uint64_t v214 = 0;
          if (v233) {
            MEMORY[0x19F3BDCF0](v232, 0x1000C4065B674BELL);
          }
        }
        while (v214 != v231);
        *((void *)&__dst + 1) = v231;
        operator delete((void *)__dst);
      }
      v212 = v289;
      std::string::size_type v211 = v293 + 3;
    }
    v234 = (void **)v296[0];
    if (v296[0])
    {
      v235 = (void **)v296[1];
      v236 = v296[0];
      if (v296[1] != v296[0])
      {
        v237 = (void **)v296[1];
        do
        {
          v240 = *(v237 - 3);
          v237 -= 3;
          unint64_t v239 = v240;
          if (v240)
          {
            v241 = *(v235 - 2);
            unint64_t v238 = v239;
            if (v241 != v239)
            {
              do
              {
                uint64_t v243 = *--v241;
                uint64_t v242 = v243;
                void *v241 = 0;
                if (v243) {
                  MEMORY[0x19F3BDCF0](v242, 0x1000C4065B674BELL);
                }
              }
              while (v241 != v239);
              unint64_t v238 = *v237;
            }
            *(v235 - 2) = v239;
            operator delete(v238);
          }
          v235 = v237;
        }
        while (v237 != v234);
        v236 = v296[0];
      }
      v296[1] = v234;
      operator delete(v236);
    }
  }
  v244 = (char *)v302;
  if (v302)
  {
    uint64_t v245 = (char *)v303;
    v246 = v302;
    if ((void *)v303 != v302)
    {
      v247 = (char *)v303;
      do
      {
        v249 = (void *)*((void *)v247 - 3);
        v247 -= 24;
        uint64_t v248 = v249;
        if (v249)
        {
          *((void *)v245 - 2) = v248;
          operator delete(v248);
        }
        uint64_t v245 = v247;
      }
      while (v247 != v244);
      v246 = v302;
    }
    *(void *)&long long v303 = v244;
    operator delete(v246);
  }
  v250 = (char *)__p;
  if (__p)
  {
    v251 = (char *)v305;
    std::string v252 = __p;
    if ((void *)v305 != __p)
    {
      v253 = (char *)v305;
      do
      {
        v255 = (void *)*((void *)v253 - 3);
        v253 -= 24;
        v254 = v255;
        if (v255)
        {
          *((void *)v251 - 2) = v254;
          operator delete(v254);
        }
        v251 = v253;
      }
      while (v253 != v250);
      std::string v252 = __p;
    }
    *(void *)&long long v305 = v250;
    operator delete(v252);
  }
  uint64_t v256 = (char *)v299[0];
  if (v299[0])
  {
    std::string v257 = v299[1];
    std::string v258 = v299[0];
    if (v299[1] != v299[0])
    {
      v259 = (char *)v299[1];
      do
      {
        v261 = (void *)*((void *)v259 - 3);
        v259 -= 24;
        unsigned __int8 v260 = v261;
        if (v261)
        {
          *(v257 - 2) = v260;
          operator delete(v260);
        }
        std::string v257 = v259;
      }
      while (v259 != v256);
      std::string v258 = v299[0];
    }
    v299[1] = v256;
    operator delete(v258);
  }
  std::string v262 = v306;
  if (v306)
  {
    std::string v263 = v307;
    v264 = v306;
    if (v307 != v306)
    {
      std::string v265 = v307;
      do
      {
        long long v267 = (void *)*((void *)v265 - 3);
        v265 -= 24;
        long long v266 = v267;
        if (v267)
        {
          *((void *)v263 - 2) = v266;
          operator delete(v266);
        }
        std::string v263 = v265;
      }
      while (v265 != v262);
      v264 = v306;
    }
    v307 = v262;
    operator delete(v264);
  }
  int v268 = v309;
  if (v309)
  {
    double v269 = v310;
    uint64_t v270 = v309;
    if (v310 != v309)
    {
      int v271 = v310;
      do
      {
        uint64_t v274 = (char *)*(v271 - 3);
        v271 -= 3;
        unint64_t v273 = v274;
        if (v274)
        {
          uint64_t v275 = (char *)*(v269 - 2);
          long long v272 = v273;
          if (v275 != v273)
          {
            uint64_t v276 = (char *)*(v269 - 2);
            do
            {
              v278 = (void *)*((void *)v276 - 3);
              v276 -= 24;
              CFRange v277 = v278;
              if (v278)
              {
                *((void *)v275 - 2) = v277;
                operator delete(v277);
              }
              uint64_t v275 = v276;
            }
            while (v276 != v273);
            long long v272 = *v271;
          }
          *(v269 - 2) = v273;
          operator delete(v272);
        }
        double v269 = v271;
      }
      while (v271 != v268);
      uint64_t v270 = v309;
    }
    v310 = v268;
    operator delete(v270);
  }
  if (v312)
  {
    v313 = (unsigned int *)v312;
    operator delete(v312);
  }
}

void sub_19E3F3D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void **a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,uint64_t a36,void *a37,uint64_t a38)
{
  sub_19E3C76B8((void *)(v38 - 160));
  sub_19E3F401C(&a25);
  sub_19E3F4498(&__p);
  sub_19E3F4498(&a37);
  sub_19E3F4498(&a29);
  sub_19E3F4498((void **)(v38 - 232));
  sub_19E3F4884((void ***)(v38 - 208));
  unint64_t v40 = *(void **)(v38 - 184);
  if (!v40) {
    _Unwind_Resume(a1);
  }
  *(void *)(v38 - 176) = v40;
  operator delete(v40);
  _Unwind_Resume(a1);
}

void sub_19E3F3FF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  if (*(char *)(v34 - 137) < 0)
  {
    operator delete(*(void **)(v34 - 160));
    if (!a34) {
      JUMPOUT(0x19E3F3FACLL);
    }
    JUMPOUT(0x19E3F3FA4);
  }
  JUMPOUT(0x19E3F3F9CLL);
}

void ***sub_19E3F401C(void ***a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      uint64_t v5 = a1[1];
      do
      {
        size_t v8 = *(v5 - 3);
        v5 -= 3;
        int v7 = v8;
        if (v8)
        {
          uint64_t v9 = *(v3 - 2);
          uint64_t v6 = v7;
          if (v9 != v7)
          {
            do
            {
              uint64_t v11 = *--v9;
              uint64_t v10 = v11;
              *uint64_t v9 = 0;
              if (v11) {
                MEMORY[0x19F3BDCF0](v10, 0x1000C4065B674BELL);
              }
            }
            while (v9 != v7);
            uint64_t v6 = *v5;
          }
          *(v3 - 2) = v7;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

char *sub_19E3F40DC(char **a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_19E37C7C4();
  }
  if (0x5555555555555556 * ((a1[2] - v4) >> 3) > v6) {
    unint64_t v6 = 0x5555555555555556 * ((a1[2] - v4) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v4) >> 3) >= 0x555555555555555) {
    unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
      sub_19E37C2B8();
    }
    uint64_t v11 = (char *)operator new(24 * v10);
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v12 = &v11[24 * v5];
  uint64_t v13 = &v11[24 * v10];
  *((void *)&v25 + 1) = v13;
  *((void *)v12 + 1) = 0;
  *(void *)uint64_t v12 = 0;
  *((void *)v12 + 2) = 0;
  int64_t v14 = a3 - (void)a2;
  if (v14)
  {
    if (v14 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v15 = operator new(v14);
    *(void *)uint64_t v12 = v15;
    unint64_t v16 = (unint64_t)v15 + 8 * (v14 >> 3);
    memcpy(v15, a2, v14);
    *(int64x2_t *)(v12 + 8) = vdupq_n_s64(v16);
  }
  long long v17 = v12 + 24;
  *(void *)&long long v25 = v12 + 24;
  if (v3 == v4)
  {
    *a1 = v12;
    a1[1] = v17;
    a1[2] = v13;
  }
  else
  {
    do
    {
      uint64_t v18 = v12;
      *((void *)v12 - 2) = 0;
      *((void *)v12 - 1) = 0;
      long long v19 = *(_OWORD *)(v3 - 24);
      v3 -= 24;
      *(_OWORD *)(v12 - 24) = v19;
      v12 -= 24;
      *((void *)v18 - 1) = *((void *)v3 + 2);
      *(void *)uint64_t v3 = 0;
      *((void *)v3 + 1) = 0;
      *((void *)v3 + 2) = 0;
    }
    while (v3 != v4);
    uint64_t v3 = *a1;
    unint64_t v20 = a1[1];
    *a1 = v12;
    *(_OWORD *)(a1 + 1) = v25;
    long long v17 = (char *)v25;
    if (v20 != v3)
    {
      unint64_t v21 = v20;
      do
      {
        uint64_t v23 = (void *)*((void *)v21 - 3);
        v21 -= 24;
        uint64_t v22 = v23;
        if (v23)
        {
          *((void *)v20 - 2) = v22;
          operator delete(v22);
        }
        unint64_t v20 = v21;
      }
      while (v21 != v3);
    }
  }
  if (v3) {
    operator delete(v3);
  }
  return v17;
}

void sub_19E3F42AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  unint64_t v5 = *v2;
  if (*v2)
  {
    *uint64_t v3 = v5;
    operator delete(v5);
  }
  sub_19E3D2F94((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_19E3F42D0(void *a1, uint64_t *a2)
{
  a1[2] = 0;
  *a1 = 0;
  a1[1] = 0;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  int64_t v5 = v4 - *a2;
  if (v4 != *a2)
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * (v5 >> 3);
    if (v6 >= 0xAAAAAAAAAAAAAABLL) {
      sub_19E37C7C4();
    }
    int v7 = (char *)operator new(v5);
    uint64_t v8 = 0;
    *a1 = v7;
    a1[1] = v7;
    a1[2] = &v7[24 * v6];
    do
    {
      unint64_t v10 = &v7[v8];
      uint64_t v11 = v3 + v8;
      *(void *)unint64_t v10 = 0;
      *((void *)v10 + 1) = 0;
      *((void *)v10 + 2) = 0;
      uint64_t v13 = *(unsigned char **)(v3 + v8);
      uint64_t v12 = *(unsigned char **)(v3 + v8 + 8);
      int64_t v14 = v12 - v13;
      if (v12 != v13)
      {
        if (v14 < 0) {
          sub_19E37C7C4();
        }
        uint64_t v15 = (char *)operator new(v12 - v13);
        *(void *)unint64_t v10 = v15;
        *((void *)v10 + 1) = v15;
        uint64_t v9 = &v15[4 * (v14 >> 2)];
        *((void *)v10 + 2) = v9;
        memcpy(v15, v13, v14);
        *((void *)v10 + 1) = v9;
      }
      v8 += 24;
    }
    while (v11 + 24 != v4);
    a1[1] = &v7[v8];
  }
  return a1;
}

void sub_19E3F4414(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (char *)*v1;
  if (*v1)
  {
    uint64_t v4 = (char *)v1[1];
    int64_t v5 = *v1;
    if (v4 != v3)
    {
      unint64_t v6 = (char *)v1[1];
      do
      {
        uint64_t v8 = (void *)*((void *)v6 - 3);
        v6 -= 24;
        int v7 = v8;
        if (v8)
        {
          *((void *)v4 - 2) = v7;
          operator delete(v7);
        }
        uint64_t v4 = v6;
      }
      while (v6 != v3);
      int64_t v5 = *v1;
    }
    v1[1] = v3;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void **sub_19E3F4498(void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      int64_t v5 = (char *)a1[1];
      do
      {
        int v7 = (void *)*((void *)v5 - 3);
        v5 -= 24;
        unint64_t v6 = v7;
        if (v7)
        {
          *((void *)v3 - 2) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void *sub_19E3F4510(void *result, void *a2)
{
  uint64_t v2 = result;
  void *result = 0;
  result[1] = 0;
  result[2] = 0;
  uint64_t v3 = a2[1];
  uint64_t v4 = v3 - *a2;
  if (v3 != *a2)
  {
    if ((v4 & 0x8000000000000000) == 0)
    {
      int64_t v5 = (char *)operator new(v3 - *a2);
      *uint64_t v2 = v5;
      v2[1] = v5;
      v2[2] = &v5[8 * (v4 >> 3)];
      operator new();
    }
    sub_19E37C7C4();
  }
  return result;
}

void sub_19E3F45D0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (void *)*v1;
  if (*v1)
  {
    uint64_t v4 = (void *)v1[1];
    int64_t v5 = (void *)*v1;
    if (v4 != v3)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          MEMORY[0x19F3BDCF0](v6, 0x1000C4065B674BELL);
        }
      }
      while (v4 != v3);
      int64_t v5 = (void *)*v1;
    }
    v1[1] = v3;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

char *sub_19E3F4634(void ***a1, void *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_19E37C7C4();
  }
  if (0x5555555555555556 * (a1[2] - *a1) > v3) {
    unint64_t v3 = 0x5555555555555556 * (a1[2] - *a1);
  }
  if (0xAAAAAAAAAAAAAAABLL * (a1[2] - *a1) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_19E37C2B8();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v22 = &v7[24 * v2];
  uint64_t v23 = (void **)&v7[24 * v6];
  sub_19E3F4510(v22, a2);
  uint64_t v8 = (void **)v22;
  uint64_t v9 = (void **)(v22 + 24);
  unint64_t v10 = *a1;
  uint64_t v11 = a1[1];
  if (v11 == *a1)
  {
    *a1 = (void **)v22;
    a1[1] = v9;
    a1[2] = v23;
  }
  else
  {
    do
    {
      *(v8 - 3) = 0;
      *(v8 - 2) = 0;
      v8 -= 3;
      v8[2] = 0;
      long long v12 = *(_OWORD *)(v11 - 3);
      v11 -= 3;
      *(_OWORD *)uint64_t v8 = v12;
      v8[2] = v11[2];
      char *v11 = 0;
      v11[1] = 0;
      v11[2] = 0;
    }
    while (v11 != v10);
    uint64_t v11 = *a1;
    uint64_t v13 = a1[1];
    *a1 = v8;
    a1[1] = v9;
    a1[2] = v23;
    if (v13 != v11)
    {
      int64_t v14 = v13;
      do
      {
        long long v17 = *(v14 - 3);
        v14 -= 3;
        unint64_t v16 = v17;
        if (v17)
        {
          uint64_t v18 = *(v13 - 2);
          uint64_t v15 = v16;
          if (v18 != v16)
          {
            do
            {
              uint64_t v20 = *--v18;
              uint64_t v19 = v20;
              *uint64_t v18 = 0;
              if (v20) {
                MEMORY[0x19F3BDCF0](v19, 0x1000C4065B674BELL);
              }
            }
            while (v18 != v16);
            uint64_t v15 = *v14;
          }
          *(v13 - 2) = v16;
          operator delete(v15);
        }
        uint64_t v13 = v14;
      }
      while (v14 != v11);
    }
  }
  if (v11) {
    operator delete(v11);
  }
  return v22 + 24;
}

void sub_19E3F47F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3F4A20((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_19E3F4804(void *a1)
{
  unint64_t v2 = (void *)*a1;
  if (*a1)
  {
    unint64_t v3 = (void *)a1[1];
    uint64_t v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *unint64_t v3 = 0;
        if (v6) {
          MEMORY[0x19F3BDCF0](v5, 0x1000C4065B674BELL);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void ***sub_19E3F4884(void ***a1)
{
  unint64_t v2 = *a1;
  if (*a1)
  {
    unint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      uint64_t v5 = a1[1];
      do
      {
        uint64_t v8 = (char *)*(v5 - 3);
        v5 -= 3;
        uint64_t v7 = v8;
        if (v8)
        {
          uint64_t v9 = (char *)*(v3 - 2);
          uint64_t v6 = v7;
          if (v9 != v7)
          {
            unint64_t v10 = (char *)*(v3 - 2);
            do
            {
              long long v12 = (void *)*((void *)v10 - 3);
              v10 -= 24;
              uint64_t v11 = v12;
              if (v12)
              {
                *((void *)v9 - 2) = v11;
                operator delete(v11);
              }
              uint64_t v9 = v10;
            }
            while (v10 != v7);
            uint64_t v6 = *v5;
          }
          *(v3 - 2) = v7;
          operator delete(v6);
        }
        unint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void *sub_19E3F493C()
{
  return &unk_1EF0B8068;
}

uint64_t sub_19E3F4948(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v126ToucanLanguageModelSession31_combinedConditionalProbabilityERKNSt3__16vec"
                     "torINS3_INS0_14SanitizedTokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_INS0_13TokenMetadataENS5"
                     "_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_0"
    || ((v3 & (unint64_t)"ZN17language_modeling2v126ToucanLanguageModelSession31_combinedConditionalProbabilityERK"
                                "NSt3__16vectorINS3_INS0_14SanitizedTokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_IN"
                                "S0_13TokenMetadataENS5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v126ToucanLanguageModelSession31_combinedConditionalProbabilityERKNSt3__16vectorINS3_INS0_14SanitizedTokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_INS0_13TokenMetadataENS5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v126ToucanLanguageModelSession31_combinedConditionalProbabilityERKNSt3__16vectorINS3_INS0_14SanitizedTokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_INS0_13TokenMetadataENS5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

double sub_19E3F49A0()
{
  return 1.0;
}

void sub_19E3F49B0(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF0BD610;
}

void *sub_19E3F49D0()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF0BD610;
  return result;
}

void sub_19E3F4A08()
{
}

uint64_t sub_19E3F4A20(uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  unint64_t v3 = *(void ***)(a1 + 16);
  if (v3 != v2)
  {
    uint64_t v4 = *(void ***)(a1 + 16);
    do
    {
      uint64_t v7 = *(v4 - 3);
      v4 -= 3;
      uint64_t v6 = v7;
      *(void *)(a1 + 16) = v4;
      if (v7)
      {
        uint64_t v8 = *(v3 - 2);
        uint64_t v5 = v6;
        if (v8 != v6)
        {
          do
          {
            uint64_t v10 = *--v8;
            uint64_t v9 = v10;
            *uint64_t v8 = 0;
            if (v10) {
              MEMORY[0x19F3BDCF0](v9, 0x1000C4065B674BELL);
            }
          }
          while (v8 != v6);
          uint64_t v5 = *v4;
        }
        *(v3 - 2) = v6;
        operator delete(v5);
        uint64_t v4 = *(void ***)(a1 + 16);
      }
      unint64_t v3 = v4;
    }
    while (v4 != v2);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E3F4ADC(uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  unint64_t v3 = *(void ***)(a1 + 16);
  if (v3 != v2)
  {
    uint64_t v4 = *(void ***)(a1 + 16);
    do
    {
      uint64_t v7 = (char *)*(v4 - 3);
      v4 -= 3;
      uint64_t v6 = v7;
      *(void *)(a1 + 16) = v4;
      if (v7)
      {
        uint64_t v8 = (char *)*(v3 - 2);
        uint64_t v5 = v6;
        if (v8 != v6)
        {
          uint64_t v9 = (char *)*(v3 - 2);
          do
          {
            uint64_t v11 = (void *)*((void *)v9 - 3);
            v9 -= 24;
            uint64_t v10 = v11;
            if (v11)
            {
              *((void *)v8 - 2) = v10;
              operator delete(v10);
            }
            uint64_t v8 = v9;
          }
          while (v9 != v6);
          uint64_t v5 = *v4;
        }
        *(v3 - 2) = v6;
        operator delete(v5);
        uint64_t v4 = *(void ***)(a1 + 16);
      }
      unint64_t v3 = v4;
    }
    while (v4 != v2);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E3F4B90(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 16);
    uint64_t v4 = **(void **)(a1 + 8);
    if (v3 != v4)
    {
      uint64_t v5 = **(void **)(a1 + 16);
      do
      {
        uint64_t v7 = *(void **)(v5 - 24);
        v5 -= 24;
        uint64_t v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 16) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v4);
    }
  }
  return a1;
}

void sub_19E3F4C00(uint64_t a1@<X0>, uint64_t *a2@<X1>, void **a3@<X2>, void *a4@<X8>)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  std::string __p = 0;
  uint64_t v38 = 0;
  unint64_t v39 = 0;
  uint64_t v5 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      uint64_t v10 = (void *)(v5 + 24 * v7);
      uint64_t v9 = v10[1];
      uint64_t v11 = v9 - *v10;
      if (v9 == *v10)
      {
        int64_t v14 = 0;
        long long v15 = 0uLL;
      }
      else
      {
        if (v11 < 0) {
          sub_19E37C7C4();
        }
        long long v12 = (char *)operator new((unint64_t)v11 >> 4);
        size_t v13 = 2 * (v11 >> 5);
        int64_t v14 = &v12[v13];
        memset_pattern16(v12, &unk_19E573260, v13);
        *(void *)&long long v15 = v12;
        *((void *)&v15 + 1) = v14;
      }
      long long v36 = v15;
      if (v6 < v39)
      {
        *(_OWORD *)uint64_t v6 = v15;
        *((void *)v6 + 2) = v14;
        uint64_t v8 = v6 + 24;
      }
      else
      {
        unint64_t v16 = (char *)__p;
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v6 - (unsigned char *)__p) >> 3);
        unint64_t v18 = v17 + 1;
        if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C7C4();
        }
        if (0x5555555555555556 * ((v39 - (unsigned char *)__p) >> 3) > v18) {
          unint64_t v18 = 0x5555555555555556 * ((v39 - (unsigned char *)__p) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v39 - (unsigned char *)__p) >> 3) >= 0x555555555555555) {
          unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v19 = v18;
        }
        if (v19 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C2B8();
        }
        uint64_t v20 = (char *)operator new(24 * v19);
        unint64_t v21 = &v20[8 * ((v6 - (unsigned char *)__p) >> 3)];
        *(_OWORD *)unint64_t v21 = v36;
        *((void *)v21 + 2) = v14;
        uint64_t v8 = v21 + 24;
        if (v6 != v16)
        {
          uint64_t v22 = v6;
          do
          {
            long long v23 = *(_OWORD *)(v22 - 24);
            v22 -= 24;
            *(_OWORD *)(v21 - 24) = v23;
            v21 -= 24;
            *((void *)v21 + 2) = *((void *)v22 + 2);
            *(void *)uint64_t v22 = 0;
            *((void *)v22 + 1) = 0;
            *((void *)v22 + 2) = 0;
          }
          while (v22 != v16);
          std::string __p = v21;
          uint64_t v38 = v8;
          uint64_t v24 = v6;
          unint64_t v39 = &v20[24 * v19];
          do
          {
            uint64_t v26 = (void *)*((void *)v24 - 3);
            v24 -= 24;
            long long v25 = v26;
            if (v26)
            {
              *((void *)v6 - 2) = v25;
              operator delete(v25);
            }
            uint64_t v6 = v24;
          }
          while (v24 != v16);
          uint64_t v6 = v16;
          if (!v16) {
            goto LABEL_4;
          }
LABEL_27:
          operator delete(v6);
          goto LABEL_4;
        }
        std::string __p = &v20[24 * v17];
        unint64_t v39 = &v20[24 * v19];
        if (v6) {
          goto LABEL_27;
        }
      }
LABEL_4:
      uint64_t v38 = v8;
      ++v7;
      uint64_t v5 = *a2;
      uint64_t v6 = v8;
    }
    while (v7 < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  }
  sub_19E3F20CC(a4, a1, a2, &__p, a3);
  uint64_t v27 = (char *)__p;
  if (__p)
  {
    uint64_t v28 = v38;
    uint64_t v29 = __p;
    if (v38 != __p)
    {
      uint64_t v30 = v38;
      do
      {
        uint64_t v32 = (void *)*((void *)v30 - 3);
        v30 -= 24;
        uint64_t v31 = v32;
        if (v32)
        {
          *((void *)v28 - 2) = v31;
          operator delete(v31);
        }
        uint64_t v28 = v30;
      }
      while (v30 != v27);
      uint64_t v29 = __p;
    }
    uint64_t v38 = v27;
    operator delete(v29);
  }
}

void sub_19E3F4FE8(void *a1@<X1>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*a1 != a1[1]) {
    operator new();
  }
}

void sub_19E3F5280(_Unwind_Exception *a1)
{
  if (v2) {
    JUMPOUT(0x19E3F5288);
  }
  sub_19E3F4804(v1);
  _Unwind_Resume(a1);
}

void sub_19E3F52A4(void *a1, int a2)
{
  if (a2) {
    sub_19E37B770(a1);
  }
  JUMPOUT(0x19E3F52C0);
}

void sub_19E3F52C8(void *a1)
{
  unint64_t v1 = ((uint64_t)(a1[1] - *a1) >> 3) + 1;
  if (!(v1 >> 61))
  {
    uint64_t v2 = a1[2] - *a1;
    if (v2 >> 2 > v1) {
      unint64_t v1 = v2 >> 2;
    }
    if ((unint64_t)v2 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v3 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v3 = v1;
    }
    if (v3)
    {
      if (v3 >> 61) {
        sub_19E37C2B8();
      }
      operator new(8 * v3);
    }
    operator new();
  }
  sub_19E37C7C4();
}

uint64_t sub_19E3F54A8(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(const void ***)(a1 + 8);
  int v5 = *((char *)v4 + 23);
  if (v5 >= 0) {
    size_t v6 = *((unsigned __int8 *)v4 + 23);
  }
  else {
    size_t v6 = (size_t)v4[1];
  }
  if (v6 == strlen((const char *)language_modeling::v1::kLanguageModelTypeTokenID)
    && (v5 >= 0 ? (unint64_t v7 = v4) : (unint64_t v7 = *v4), !memcmp(v7, (const void *)language_modeling::v1::kLanguageModelTypeTokenID, v6)))
  {
    uint64_t v16 = *(void *)(a1 + 176);
    if (*(unsigned char *)(v16 + 88)
      && sub_19E4B5D64(*(std::recursive_mutex **)(*(void *)(v16 + 72) + 464), (uint64_t)a2))
    {
      return 1;
    }
    uint64_t result = sub_19E3FE284(*(void **)(v16 + 72), (uint64_t)a2, 0);
    if (!result) {
      return result;
    }
    return result != 500 || sub_19E53BBDC(*(void *)(v16 + 72), (uint64_t)a2) != 0;
  }
  else
  {
    uint64_t v8 = a2[23];
    int v9 = (char)v8;
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *((void *)a2 + 1);
    }
    if (v8)
    {
      if (v9 < 0) {
        a2 = *(unsigned __int8 **)a2;
      }
      uint64_t v10 = v8 - 1;
      uint64_t v11 = MEMORY[0x1E4F14390];
      do
      {
        uint64_t v14 = *a2;
        if ((char)*a2 < 0) {
          int v12 = __maskrune(v14, 0x4000uLL);
        }
        else {
          int v12 = *(_DWORD *)(v11 + 4 * v14 + 60) & 0x4000;
        }
        ++a2;
        if (v12) {
          BOOL v13 = v10 == 0;
        }
        else {
          BOOL v13 = 1;
        }
        --v10;
      }
      while (!v13);
      return v12 == 0;
    }
    else
    {
      return 0;
    }
  }
}

void *sub_19E3F5604(void *a1, long long *a2)
{
  *a1 = &unk_1EF0BD3F0;
  unint64_t v3 = a1 + 1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_19E39369C(v3, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    v3[2] = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v3 = v4;
  }
  return a1;
}

void sub_19E3F566C(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

os_log_t sub_19E3F5680()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "ToucanAutoCorrection");
  qword_1EC009228 = (uint64_t)result;
  return result;
}

void sub_19E3F56B0(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF0BD3F0;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);
}

uint64_t sub_19E3F5710(uint64_t a1)
{
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void sub_19E3F572C(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF0BD3F0;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E3F57A0(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, long long *a8, uint64_t a9, uint64_t *a10, void *a11, uint64_t a12)
{
  *(void *)&__p[24] = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1EF0B9818;
  *(void *)(a1 + 8) = a2;
  int v15 = atomic_load((unsigned __int16 *)word_1EC009188);
  if (v15 == 0xFFFF) {
    atomic_store(0, (unsigned __int16 *)word_1EC009188);
  }
  *(_WORD *)(a1 + 16) = atomic_fetch_add(word_1EC009188, 1u);
  if (*((char *)a8 + 23) < 0)
  {
    sub_19E39369C((unsigned char *)(a1 + 24), *(void **)a8, *((void *)a8 + 1));
  }
  else
  {
    long long v16 = *a8;
    *(void *)(a1 + 40) = *((void *)a8 + 2);
    *(_OWORD *)(a1 + 24) = v16;
  }
  unint64_t v17 = (const void *)language_modeling::v1::kEnvironmentSessionTypeKey;
  size_t v18 = strlen((const char *)language_modeling::v1::kEnvironmentSessionTypeKey);
  if (v18 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  size_t v19 = v18;
  uint64_t v111 = a7;
  if (v18 >= 0x17)
  {
    uint64_t v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18 | 7) != 0x17) {
      uint64_t v21 = v18 | 7;
    }
    uint64_t v22 = v21 + 1;
    p_dst = (void **)operator new(v21 + 1);
    size_t v117 = v19;
    int64_t v118 = v22 | 0x8000000000000000;
    long long __dst = p_dst;
    goto LABEL_13;
  }
  HIBYTE(v118) = v18;
  p_dst = (void **)&__dst;
  if (v18) {
LABEL_13:
  }
    memmove(p_dst, v17, v19);
  *((unsigned char *)p_dst + v19) = 0;
  long long v23 = sub_19E374C3C(a9, (const void **)&__dst);
  uint64_t v24 = (uint64_t *)(a9 + 8);
  if ((uint64_t *)(a9 + 8) == v23)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    int v101 = SHIBYTE(v118);
    if (v118 >= 0) {
      size_t v102 = HIBYTE(v118);
    }
    else {
      size_t v102 = v117;
    }
    unint64_t v103 = v102 + 37;
    if (v102 + 37 > 0x7FFFFFFFFFFFFFF7) {
      sub_19E37C958();
    }
    if (v103 > 0x16)
    {
      uint64_t v105 = (v103 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v103 | 7) != 0x17) {
        uint64_t v105 = v103 | 7;
      }
      uint64_t v106 = v105 + 1;
      uint64_t v107 = (char *)operator new(v105 + 1);
      *(void *)&__p[8] = v102 + 37;
      *(void *)&__p[16] = v106 | 0x8000000000000000;
      *(void *)std::string __p = v107;
      qmemcpy(v107, "Environment is missing required key: ", 37);
      uint64_t v104 = v107 + 37;
      if (!v102)
      {
LABEL_185:
        v104[v102] = 0;
        void *exception = &unk_1EF0BD3F0;
        int64_t v109 = exception + 1;
        if ((__p[23] & 0x80000000) != 0)
        {
          sub_19E39369C(v109, *(void **)__p, *(unint64_t *)&__p[8]);
        }
        else
        {
          long long v110 = *(_OWORD *)__p;
          exception[3] = *(void *)&__p[16];
          *(_OWORD *)int64_t v109 = v110;
        }
        __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
      }
    }
    else
    {
      qmemcpy(__p, "Environment is missing required key: ", sizeof(__p));
      uint64_t v104 = v120;
    }
    if (v101 >= 0) {
      v108 = (void **)&__dst;
    }
    else {
      v108 = __dst;
    }
    memmove(v104, v108, v102);
    goto LABEL_185;
  }
  if (*((_DWORD *)v23 + 20)) {
    sub_19E3D72EC();
  }
  int v25 = *((_DWORD *)v23 + 14);
  if (SHIBYTE(v118) < 0) {
    operator delete(__dst);
  }
  *(_DWORD *)(a1 + 48) = v25;
  uint64_t v26 = (const void *)language_modeling::v1::kEnvironmentRecipientIdentifierKey;
  size_t v27 = strlen((const char *)language_modeling::v1::kEnvironmentRecipientIdentifierKey);
  if (v27 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  size_t v28 = v27;
  if (v27 >= 0x17)
  {
    uint64_t v30 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v27 | 7) != 0x17) {
      uint64_t v30 = v27 | 7;
    }
    uint64_t v31 = v30 + 1;
    uint64_t v29 = operator new(v30 + 1);
    *(void *)&__p[8] = v28;
    *(void *)&__p[16] = v31 | 0x8000000000000000;
    *(void *)std::string __p = v29;
    goto LABEL_25;
  }
  __p[23] = v27;
  uint64_t v29 = __p;
  if (v27) {
LABEL_25:
  }
    memmove(v29, v26, v28);
  v29[v28] = 0;
  uint64_t v32 = sub_19E374C3C(a9, (const void **)__p);
  if (v24 == v32)
  {
    strcpy((char *)(a1 + 56), "DefaultRecipientID");
    *(unsigned char *)(a1 + 79) = 18;
  }
  else
  {
    if (*((_DWORD *)v32 + 20) != 1) {
      sub_19E3D72EC();
    }
    if (*((char *)v32 + 79) < 0)
    {
      sub_19E39369C((unsigned char *)(a1 + 56), (void *)v32[7], v32[8]);
    }
    else
    {
      long long v33 = *(_OWORD *)(v32 + 7);
      *(void *)(a1 + 72) = v32[9];
      *(_OWORD *)(a1 + 56) = v33;
    }
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v34 = (const void *)language_modeling::v1::kQueryCaseNormalizationForCPKey;
  size_t v35 = strlen((const char *)language_modeling::v1::kQueryCaseNormalizationForCPKey);
  if (v35 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  size_t v36 = v35;
  if (v35 >= 0x17)
  {
    uint64_t v38 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v35 | 7) != 0x17) {
      uint64_t v38 = v35 | 7;
    }
    uint64_t v39 = v38 + 1;
    unint64_t v37 = (void **)operator new(v38 + 1);
    size_t v117 = v36;
    int64_t v118 = v39 | 0x8000000000000000;
    long long __dst = v37;
    goto LABEL_41;
  }
  HIBYTE(v118) = v35;
  unint64_t v37 = (void **)&__dst;
  if (v35) {
LABEL_41:
  }
    memmove(v37, v34, v36);
  *((unsigned char *)v37 + v36) = 0;
  uint64_t v40 = (const void *)language_modeling::v1::kCaseNormalizationCapitalizeWordWithEmptyContext;
  size_t v41 = strlen((const char *)language_modeling::v1::kCaseNormalizationCapitalizeWordWithEmptyContext);
  if (v41 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v42 = v41;
  if (v41 >= 0x17)
  {
    uint64_t v44 = (v41 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v41 | 7) != 0x17) {
      uint64_t v44 = v41 | 7;
    }
    uint64_t v45 = v44 + 1;
    uint64_t v43 = operator new(v44 + 1);
    v115.__r_.__value_.__l.__size_ = v42;
    v115.__r_.__value_.__r.__words[2] = v45 | 0x8000000000000000;
    v115.__r_.__value_.__r.__words[0] = (std::string::size_type)v43;
    goto LABEL_49;
  }
  *((unsigned char *)&v115.__r_.__value_.__s + 23) = v41;
  uint64_t v43 = &v115;
  if (v41) {
LABEL_49:
  }
    memmove(v43, v40, v42);
  *((unsigned char *)v43 + v42) = 0;
  uint64_t v46 = sub_19E374C3C(a9, (const void **)&__dst);
  if (v24 == v46)
  {
    long long v47 = &v115;
    if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0)
    {
      p_std::string::size_type size = &v115.__r_.__value_.__l.__size_;
      goto LABEL_57;
    }
LABEL_55:
    *(_OWORD *)std::string __p = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
    *(void *)&__p[16] = *((void *)&v47->__r_.__value_.__l + 2);
    goto LABEL_58;
  }
  if (*((_DWORD *)v46 + 20) != 1) {
    sub_19E3D72EC();
  }
  long long v47 = (std::string *)(v46 + 7);
  if ((*((char *)v46 + 79) & 0x80000000) == 0) {
    goto LABEL_55;
  }
  p_std::string::size_type size = (unint64_t *)(v46 + 8);
LABEL_57:
  sub_19E39369C(__p, v47->__r_.__value_.__l.__data_, *p_size);
LABEL_58:
  size_t v49 = strlen((const char *)language_modeling::v1::kCaseNormalizationCapitalizeWordWithEmptyContext);
  size_t v50 = v49;
  char v51 = __p[23];
  if ((__p[23] & 0x80000000) == 0)
  {
    if (v49 != -1)
    {
      uint64_t v52 = __p;
      size_t v53 = __p[23];
      goto LABEL_63;
    }
LABEL_167:
    sub_19E3C4C28();
  }
  if (v49 == -1) {
    goto LABEL_167;
  }
  uint64_t v52 = *(unsigned char **)__p;
  size_t v53 = *(void *)&__p[8];
LABEL_63:
  if (v53 >= v50) {
    size_t v54 = v50;
  }
  else {
    size_t v54 = v53;
  }
  BOOL v55 = memcmp(v52, (const void *)language_modeling::v1::kCaseNormalizationCapitalizeWordWithEmptyContext, v54) == 0;
  BOOL v56 = v53 == v50 && v55;
  if ((v51 & 0x80) == 0)
  {
    if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_71;
    }
LABEL_93:
    operator delete(v115.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v118) & 0x80000000) == 0) {
      goto LABEL_72;
    }
    goto LABEL_94;
  }
  operator delete(*(void **)__p);
  if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_93;
  }
LABEL_71:
  if ((SHIBYTE(v118) & 0x80000000) == 0) {
    goto LABEL_72;
  }
LABEL_94:
  operator delete(__dst);
LABEL_72:
  *(unsigned char *)(a1 + 80) = v56;
  double v57 = (const void *)language_modeling::v1::kNonZeroProbabilitiesForUNKKey;
  size_t v58 = strlen((const char *)language_modeling::v1::kNonZeroProbabilitiesForUNKKey);
  if (v58 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  size_t v59 = v58;
  if (v58 >= 0x17)
  {
    uint64_t v61 = (v58 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v58 | 7) != 0x17) {
      uint64_t v61 = v58 | 7;
    }
    uint64_t v62 = v61 + 1;
    CFIndex v60 = (void **)operator new(v61 + 1);
    size_t v117 = v59;
    int64_t v118 = v62 | 0x8000000000000000;
    long long __dst = v60;
    goto LABEL_79;
  }
  HIBYTE(v118) = v58;
  CFIndex v60 = (void **)&__dst;
  if (v58) {
LABEL_79:
  }
    memmove(v60, v57, v59);
  *((unsigned char *)v60 + v59) = 0;
  unint64_t v63 = (const void *)language_modeling::v1::kZeroProbabilitiesForUNK;
  size_t v64 = strlen((const char *)language_modeling::v1::kZeroProbabilitiesForUNK);
  if (v64 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v65 = v64;
  if (v64 >= 0x17)
  {
    uint64_t v67 = (v64 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v64 | 7) != 0x17) {
      uint64_t v67 = v64 | 7;
    }
    uint64_t v68 = v67 + 1;
    uint64_t v66 = operator new(v67 + 1);
    v115.__r_.__value_.__l.__size_ = v65;
    v115.__r_.__value_.__r.__words[2] = v68 | 0x8000000000000000;
    v115.__r_.__value_.__r.__words[0] = (std::string::size_type)v66;
    goto LABEL_87;
  }
  *((unsigned char *)&v115.__r_.__value_.__s + 23) = v64;
  uint64_t v66 = &v115;
  if (v64) {
LABEL_87:
  }
    memmove(v66, v63, v65);
  *((unsigned char *)v66 + v65) = 0;
  long long v69 = sub_19E374C3C(a9, (const void **)&__dst);
  if (v24 == v69)
  {
    uint64_t v70 = &v115;
    if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::size_type v71 = &v115.__r_.__value_.__l.__size_;
      goto LABEL_98;
    }
LABEL_96:
    *(_OWORD *)std::string __p = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
    *(void *)&__p[16] = *((void *)&v70->__r_.__value_.__l + 2);
    goto LABEL_99;
  }
  if (*((_DWORD *)v69 + 20) != 1) {
    sub_19E3D72EC();
  }
  uint64_t v70 = (std::string *)(v69 + 7);
  if ((*((char *)v69 + 79) & 0x80000000) == 0) {
    goto LABEL_96;
  }
  std::string::size_type v71 = (unint64_t *)(v69 + 8);
LABEL_98:
  sub_19E39369C(__p, v70->__r_.__value_.__l.__data_, *v71);
LABEL_99:
  size_t v72 = strlen((const char *)language_modeling::v1::kNonZeroProbabilitiesForUNK);
  size_t v73 = v72;
  char v74 = __p[23];
  if ((__p[23] & 0x80000000) == 0)
  {
    if (v72 != -1)
    {
      CFComparisonResult v75 = __p;
      size_t v76 = __p[23];
      goto LABEL_104;
    }
LABEL_170:
    sub_19E3C4C28();
  }
  if (v72 == -1) {
    goto LABEL_170;
  }
  CFComparisonResult v75 = *(unsigned char **)__p;
  size_t v76 = *(void *)&__p[8];
LABEL_104:
  if (v76 >= v73) {
    size_t v77 = v73;
  }
  else {
    size_t v77 = v76;
  }
  BOOL v78 = memcmp(v75, (const void *)language_modeling::v1::kNonZeroProbabilitiesForUNK, v77) == 0;
  BOOL v79 = v76 == v73 && v78;
  if ((v74 & 0x80) == 0)
  {
    if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_112;
    }
LABEL_126:
    operator delete(v115.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v118) & 0x80000000) == 0) {
      goto LABEL_113;
    }
    goto LABEL_127;
  }
  operator delete(*(void **)__p);
  if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_126;
  }
LABEL_112:
  if ((SHIBYTE(v118) & 0x80000000) == 0) {
    goto LABEL_113;
  }
LABEL_127:
  operator delete(__dst);
LABEL_113:
  *(unsigned char *)(a1 + 81) = v79;
  int v80 = (const void *)language_modeling::v1::kMaxStaticCandidatesCountKey;
  size_t v81 = strlen((const char *)language_modeling::v1::kMaxStaticCandidatesCountKey);
  if (v81 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  size_t v82 = v81;
  if (v81 >= 0x17)
  {
    uint64_t v84 = (v81 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v81 | 7) != 0x17) {
      uint64_t v84 = v81 | 7;
    }
    uint64_t v85 = v84 + 1;
    int v83 = (void **)operator new(v84 + 1);
    size_t v117 = v82;
    int64_t v118 = v85 | 0x8000000000000000;
    long long __dst = v83;
    goto LABEL_120;
  }
  HIBYTE(v118) = v81;
  int v83 = (void **)&__dst;
  if (v81) {
LABEL_120:
  }
    memmove(v83, v80, v82);
  *((unsigned char *)v83 + v82) = 0;
  std::to_string(&v115, 6uLL);
  int64_t v86 = sub_19E374C3C(a9, (const void **)&__dst);
  if (v24 == v86)
  {
    int64_t v87 = &v115;
    if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0)
    {
      int64_t v88 = &v115.__r_.__value_.__l.__size_;
      goto LABEL_131;
    }
LABEL_129:
    *(_OWORD *)std::string __p = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
    *(void *)&__p[16] = *((void *)&v87->__r_.__value_.__l + 2);
    goto LABEL_132;
  }
  if (*((_DWORD *)v86 + 20) != 1) {
    sub_19E3D72EC();
  }
  int64_t v87 = (std::string *)(v86 + 7);
  if ((*((char *)v86 + 79) & 0x80000000) == 0) {
    goto LABEL_129;
  }
  int64_t v88 = (unint64_t *)(v86 + 8);
LABEL_131:
  sub_19E39369C(__p, v87->__r_.__value_.__l.__data_, *v88);
LABEL_132:
  int v89 = std::stoi((const std::string *)__p, 0, 10);
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_134;
    }
  }
  else if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_134;
  }
  operator delete(v115.__r_.__value_.__l.__data_);
LABEL_134:
  if (SHIBYTE(v118) < 0) {
    operator delete(__dst);
  }
  *(void *)(a1 + 88) = v89;
  *(void *)(a1 + 96) = *a3;
  uint64_t v90 = a3[1];
  *(void *)(a1 + 104) = v90;
  if (v90) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v90 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 112) = *a4;
  uint64_t v91 = a4[1];
  *(void *)(a1 + 120) = v91;
  if (v91) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v91 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 128) = *a5;
  uint64_t v92 = a5[1];
  *(void *)(a1 + 136) = v92;
  if (v92) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v92 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 144) = *a6;
  uint64_t v93 = a6[1];
  *(void *)(a1 + 152) = v93;
  if (v93) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v93 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 160) = *v111;
  uint64_t v94 = v111[1];
  *(void *)(a1 + 168) = v94;
  if (v94) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v94 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v95 = *a10;
  *a10 = 0;
  *(void *)(a1 + 176) = v95;
  *(void *)(a1 + 184) = a12;
  *(void *)(a1 + 192) = *a11;
  uint64_t v96 = a11[1];
  *(void *)(a1 + 200) = v96;
  if (v96) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v96 + 8), 1uLL, memory_order_relaxed);
  }
  if (qword_1EC009230 != -1) {
    dispatch_once(&qword_1EC009230, &unk_1EF0BEAD0);
  }
  uint64_t v97 = qword_1EC009228;
  if (os_log_type_enabled((os_log_t)qword_1EC009228, OS_LOG_TYPE_INFO))
  {
    uint64_t v98 = *(uint64_t ***)(a1 + 8);
    if (*((char *)v98 + 23) < 0) {
      uint64_t v98 = (uint64_t **)*v98;
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v98;
    _os_log_impl(&dword_19E36B000, v97, OS_LOG_TYPE_INFO, "Model type selected for conditional probablity: %s", __p, 0xCu);
  }
  return a1;
}

void sub_19E3F62D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  std::exception::~exception(v34);
  operator delete(v33);
  __cxa_free_exception(v34);
  if (a26 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v32 + 47) < 0) {
    operator delete(*a10);
  }
  _Unwind_Resume(a1);
}

void sub_19E3F6410()
{
}

void sub_19E3F6418()
{
}

__CFArray *sub_19E3F6420(uint64_t a1, int a2, int a3)
{
  if (a2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = &v7;
    uint64_t v9 = 0x2000000000;
    CFMutableArrayRef Mutable = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    LDEnumerateAssetDataItems();
    unint64_t v3 = (const void *)v8[3];
    _Block_object_dispose(&v7, 8);
    if (!v3) {
      goto LABEL_9;
    }
  }
  else if (a3)
  {
    uint64_t v7 = 0;
    uint64_t v8 = &v7;
    uint64_t v9 = 0x2000000000;
    CFMutableArrayRef Mutable = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    LDEnumerateAssetDataItems();
    unint64_t v3 = (const void *)v8[3];
    _Block_object_dispose(&v7, 8);
    if (!v3) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = &v7;
    uint64_t v9 = 0x2000000000;
    CFMutableArrayRef Mutable = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    LDEnumerateAssetDataItems();
    unint64_t v3 = (const void *)v8[3];
    _Block_object_dispose(&v7, 8);
    if (!v3) {
      goto LABEL_9;
    }
  }
  CFRetain(v3);
  CFRelease(v3);
LABEL_9:
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  CFMutableArrayRef Mutable = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  LDEnumerateAssetDataItems();
  CFArrayRef v4 = (const __CFArray *)v8[3];
  _Block_object_dispose(&v7, 8);
  MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFArrayRef)v3);
  v11.length = CFArrayGetCount(v4);
  v11.location = 0;
  CFArrayAppendArray(MutableCopy, v4, v11);
  if (v4) {
    CFRelease(v4);
  }
  if (v3) {
    CFRelease(v3);
  }
  return MutableCopy;
}

void sub_19E3F679C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  unint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  _Block_object_dispose(va1, 8);
  sub_19E3F6850((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_19E3F6818(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

const void **sub_19E3F6850(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

const void **sub_19E3F6888(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

const void **sub_19E3F68C0(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

uint64_t sub_19E3F68F8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 >= 4) {
    __assert_rtn("convertAssetBundleType", "LMLinguisticData.cpp", 109, "false && \"unsupported LinguisticData asset type\"");
  }
  unint64_t v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  return v3();
}

void sub_19E3F6950(uint64_t a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  v9[0] = a3;
  v9[1] = a4;
  if (a4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = a5[1];
  v8[0] = *a5;
  v8[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  v7[0] = 0;
  v7[1] = 0;
  sub_19E4EA12C(a1, a2, (uint64_t)v9, (uint64_t)v8, a6, (uint64_t)v7, 0);
}

void sub_19E3F6A74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
}

uint64_t sub_19E3F6A9C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E3F6AC0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE488;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E3F6B14(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE488;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_19E3F6B38(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__114default_deleteIN2LM21MontrealTokenIDMapperEEE"
    || ((v3 & (unint64_t)"NSt3__114default_deleteIN2LM21MontrealTokenIDMapperEEE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__114default_deleteIN2LM21MontrealTokenIDMapperEEE")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__114default_deleteIN2LM21MontrealTokenIDMapperEEE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E3F6B90(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_19E3F6BC0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E3F6C00(void *a1)
{
  uint64_t v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }
  CFArrayRef v4 = (void *)a1[7];
  if (v4)
  {
    a1[8] = v4;
    operator delete(v4);
  }
  uint64_t result = (void *)a1[3];
  if (result) {
    uint64_t result = (void *)munmap(result, a1[4]);
  }
  a1[4] = 0;
  return result;
}

void sub_19E3F6C68(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE3A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E3F6CBC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE3A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_19E3F6CDC(char *a1)
{
  if (a1)
  {
    sub_19E3F6CDC(*(void *)a1);
    sub_19E3F6CDC(*((void *)a1 + 1));
    sub_19E3CD3E0(*((char **)a1 + 8));
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

uint64_t sub_19E3F6D40(uint64_t a1)
{
  if (*(void *)a1)
  {
    sub_19E4DD41C(a1 + 48);
    int v2 = sqlite3_close(*(sqlite3 **)a1);
    char v3 = v2;
    if (v2)
    {
      if (qword_1EC009490 != -1) {
        dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
      }
      CFArrayRef v4 = (int *)qword_1EC009488;
      sqlite3_errmsg(*(sqlite3 **)a1);
      sub_19E4E4498(v4, v5, "Failed to close database, error code: %d  error message: %s\n", v6, v7, v8, v9, v10, v3);
    }
  }
  sub_19E4DD41C(a1 + 48);
  sub_19E418864(*(void **)(a1 + 80));
  sub_19E418864(*(void **)(a1 + 56));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_19E3F6E10(uint64_t a1)
{
  int v2 = (void *)(a1 + 104);
  sub_19E3F6CDC(*(char **)(a1 + 104));
  *(void *)(a1 + 96) = v2;
  *(void *)(a1 + 112) = 0;
  *int v2 = 0;
  sub_19E3CD3E0(*(char **)(a1 + 128));
  uint64_t v4 = a1 + 152;
  char v3 = *(char **)(a1 + 152);
  *(void *)(a1 + 120) = a1 + 128;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  sub_19E3CD3E0(v3);
  *(void *)(a1 + 144) = a1 + 152;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  uint64_t v5 = (const std::__fs::filesystem::path *)(a1 + 168);
  uint64_t v6 = (const char *)(a1 + 168);
  if (*(char *)(a1 + 191) < 0) {
    uint64_t v6 = (const char *)v5->__pn_.__r_.__value_.__r.__words[0];
  }
  if (stat(v6, &__dst)) {
    return;
  }
  int v8 = *(char *)(a1 + 191);
  if (v8 >= 0) {
    size_t v9 = *(unsigned __int8 *)(a1 + 191);
  }
  else {
    size_t v9 = *(void *)(a1 + 176);
  }
  unint64_t v10 = v9 + 4;
  if (v9 + 4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  if (v10 > 0x16)
  {
    uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v13 = v10 | 7;
    }
    size_t v14 = v13 + 1;
    int v15 = (char *)operator new(v13 + 1);
    long long v16 = v15;
    unint64_t v17 = v14 | 0x8000000000000000;
    __dst.st_ino = v9 + 4;
    *(void *)&__dst.st_uid = v14 | 0x8000000000000000;
    *(void *)&__dst.st_dev = v15;
    if (v8 >= 0) {
      CFRange v11 = (const void *)(v4 + 16);
    }
    else {
      CFRange v11 = (const void *)v5->__pn_.__r_.__value_.__r.__words[0];
    }
    memmove(v15, v11, v9);
    strcpy(&v16[v9], "-wal");
    int v12 = (std::__fs::filesystem::path *)operator new(v14);
    size_t v33 = v9 + 4;
    int64_t v34 = v17;
    uint64_t v32 = v12;
  }
  else
  {
    memset(&__dst, 0, 24);
    HIBYTE(__dst.st_gid) = v9 + 4;
    if (!v9)
    {
      __dst.st_dev = 1818326829;
      size_t v33 = 0;
      int64_t v34 = 0;
      uint64_t v32 = 0;
      int v12 = (std::__fs::filesystem::path *)&v32;
      HIBYTE(v34) = v9 + 4;
      goto LABEL_21;
    }
    if (v8 >= 0) {
      CFRange v11 = (const void *)(v4 + 16);
    }
    else {
      CFRange v11 = (const void *)v5->__pn_.__r_.__value_.__r.__words[0];
    }
    memmove(&__dst, v11, v9);
    strcpy((char *)&__dst + v9, "-wal");
    size_t v33 = 0;
    int64_t v34 = 0;
    uint64_t v32 = 0;
    int v12 = (std::__fs::filesystem::path *)&v32;
    HIBYTE(v34) = v9 + 4;
  }
  memmove(v12, v11, v9);
LABEL_21:
  strcpy((char *)v12 + v9, "-shm");
  if (v8 < 0) {
    uint64_t v5 = (const std::__fs::filesystem::path *)v5->__pn_.__r_.__value_.__r.__words[0];
  }
  if (remove(v5, v7) < 0)
  {
    if (qword_1EC009490 != -1) {
      dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
    }
    sub_19E4E4498((int *)qword_1EC009488, (uint64_t)v18, "failed to remove dynamic languagelikelihood model", v19, v20, v21, v22, v23, v31);
  }
  int st_gid_high = SHIBYTE(__dst.st_gid);
  int v25 = *(void **)&__dst.st_dev;
  if ((__dst.st_gid & 0x80000000) == 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = *(stat **)&__dst.st_dev;
  }
  remove((const std::__fs::filesystem::path *)p_dst, v18);
  int v28 = SHIBYTE(v34);
  uint64_t v29 = (std::__fs::filesystem::path *)v32;
  if (v34 >= 0) {
    uint64_t v30 = (const std::__fs::filesystem::path *)&v32;
  }
  else {
    uint64_t v30 = v32;
  }
  remove(v30, v27);
  if ((v28 & 0x80000000) == 0)
  {
    if ((st_gid_high & 0x80000000) == 0) {
      return;
    }
LABEL_37:
    operator delete(v25);
    return;
  }
  operator delete(v29);
  if (st_gid_high < 0) {
    goto LABEL_37;
  }
}

void sub_19E3F709C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((a21 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a21 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a16);
  _Unwind_Resume(exception_object);
}

void sub_19E3F70E8(sqlite3 **a1)
{
}

void sub_19E3F72BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void sub_19E3F7364(_Unwind_Exception *a1)
{
}

uint64_t **sub_19E3F7388(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (!v5)
  {
    unint64_t v10 = a1 + 1;
    goto LABEL_29;
  }
  int v7 = *((char *)a2 + 23);
  if (v7 >= 0) {
    int v8 = a2;
  }
  else {
    int v8 = *a2;
  }
  if (v7 >= 0) {
    size_t v9 = (const void *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v9 = a2[1];
  }
  do
  {
    while (1)
    {
      unint64_t v10 = (uint64_t **)v5;
      uint64_t v13 = v5[4];
      CFRange v11 = v5 + 4;
      int v12 = (void *)v13;
      int v14 = *((char *)v11 + 23);
      int v15 = v14 >= 0 ? v11 : v12;
      long long v16 = v14 >= 0 ? (const void *)*((unsigned __int8 *)v11 + 23) : (const void *)v11[1];
      size_t v17 = (size_t)(v16 >= v9 ? v9 : v16);
      int v18 = memcmp(v8, v15, v17);
      if (v18) {
        break;
      }
      if (v9 >= v16) {
        goto LABEL_22;
      }
LABEL_8:
      uint64_t v5 = *v10;
      uint64_t v6 = v10;
      if (!*v10) {
        goto LABEL_29;
      }
    }
    if (v18 < 0) {
      goto LABEL_8;
    }
LABEL_22:
    int v19 = memcmp(v15, v8, v17);
    if (v19)
    {
      if ((v19 & 0x80000000) == 0) {
        return v10;
      }
    }
    else if (v16 >= v9)
    {
      return v10;
    }
    uint64_t v5 = v10[1];
  }
  while (v5);
  uint64_t v6 = v10 + 1;
LABEL_29:
  uint64_t v20 = (uint64_t *)v10;
  unint64_t v10 = (uint64_t **)operator new(0x40uLL);
  *((_OWORD *)v10 + 2) = *(_OWORD *)a3;
  uint64_t v21 = *(uint64_t **)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  v10[6] = v21;
  v10[7] = 0;
  *unint64_t v10 = 0;
  v10[1] = 0;
  v10[2] = v20;
  *uint64_t v6 = (uint64_t *)v10;
  uint64_t v22 = (uint64_t *)**a1;
  uint64_t v23 = (uint64_t *)v10;
  if (v22)
  {
    *a1 = v22;
    uint64_t v23 = *v6;
  }
  sub_19E37D324(a1[1], v23);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v10;
}

uint64_t **sub_19E3F74E0(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *((char *)a2 + 23);
    if (v7 >= 0) {
      int v8 = a2;
    }
    else {
      int v8 = *a2;
    }
    if (v7 >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    while (1)
    {
      unint64_t v10 = (uint64_t **)v5;
      uint64_t v13 = (const void *)v5[4];
      CFRange v11 = v5 + 4;
      int v12 = v13;
      int v14 = *((char *)v11 + 23);
      if (v14 >= 0) {
        int v15 = v11;
      }
      else {
        int v15 = v12;
      }
      if (v14 >= 0) {
        size_t v16 = *((unsigned __int8 *)v11 + 23);
      }
      else {
        size_t v16 = v11[1];
      }
      if (v16 >= v9) {
        size_t v17 = v9;
      }
      else {
        size_t v17 = v16;
      }
      int v18 = memcmp(v8, v15, v17);
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_8;
        }
LABEL_22:
        int v19 = memcmp(v15, v8, v17);
        if (v19)
        {
          if ((v19 & 0x80000000) == 0) {
            return v10;
          }
        }
        else if (v16 >= v9)
        {
          return v10;
        }
        uint64_t v5 = v10[1];
        if (!v5)
        {
          uint64_t v6 = v10 + 1;
          goto LABEL_29;
        }
      }
      else
      {
        if (v9 >= v16) {
          goto LABEL_22;
        }
LABEL_8:
        uint64_t v5 = *v10;
        uint64_t v6 = v10;
        if (!*v10) {
          goto LABEL_29;
        }
      }
    }
  }
  unint64_t v10 = a1 + 1;
LABEL_29:
  uint64_t v20 = operator new(0x50uLL);
  uint64_t v21 = v20 + 4;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_19E39369C(v21, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v21 = *(_OWORD *)a3;
    v20[6] = *(void *)(a3 + 16);
  }
  v20[9] = 0;
  v20[8] = 0;
  v20[7] = v20 + 8;
  *uint64_t v20 = 0;
  v20[1] = 0;
  v20[2] = v10;
  *uint64_t v6 = v20;
  uint64_t v22 = (uint64_t *)**a1;
  uint64_t v23 = v20;
  if (v22)
  {
    *a1 = v22;
    uint64_t v23 = *v6;
  }
  sub_19E37D324(a1[1], v23);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v20;
}

void sub_19E3F765C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t **sub_19E3F7670(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *((char *)a2 + 23);
    if (v7 >= 0) {
      int v8 = a2;
    }
    else {
      int v8 = *a2;
    }
    if (v7 >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    while (1)
    {
      unint64_t v10 = (uint64_t **)v5;
      uint64_t v13 = (const void *)v5[4];
      CFRange v11 = v5 + 4;
      int v12 = v13;
      int v14 = *((char *)v11 + 23);
      if (v14 >= 0) {
        int v15 = v11;
      }
      else {
        int v15 = v12;
      }
      if (v14 >= 0) {
        size_t v16 = *((unsigned __int8 *)v11 + 23);
      }
      else {
        size_t v16 = v11[1];
      }
      if (v16 >= v9) {
        size_t v17 = v9;
      }
      else {
        size_t v17 = v16;
      }
      int v18 = memcmp(v8, v15, v17);
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_8;
        }
LABEL_22:
        int v19 = memcmp(v15, v8, v17);
        if (v19)
        {
          if ((v19 & 0x80000000) == 0) {
            return v10;
          }
        }
        else if (v16 >= v9)
        {
          return v10;
        }
        uint64_t v5 = v10[1];
        if (!v5)
        {
          uint64_t v6 = v10 + 1;
          goto LABEL_29;
        }
      }
      else
      {
        if (v9 >= v16) {
          goto LABEL_22;
        }
LABEL_8:
        uint64_t v5 = *v10;
        uint64_t v6 = v10;
        if (!*v10) {
          goto LABEL_29;
        }
      }
    }
  }
  unint64_t v10 = a1 + 1;
LABEL_29:
  uint64_t v20 = (char *)operator new(0x40uLL);
  uint64_t v21 = v20 + 32;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_19E39369C(v21, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v21 = *(_OWORD *)a3;
    *((void *)v20 + 6) = *(void *)(a3 + 16);
  }
  *((_DWORD *)v20 + 14) = 0;
  *(void *)uint64_t v20 = 0;
  *((void *)v20 + 1) = 0;
  *((void *)v20 + 2) = v10;
  *uint64_t v6 = (uint64_t *)v20;
  uint64_t v22 = (uint64_t *)**a1;
  uint64_t v23 = (uint64_t *)v20;
  if (v22)
  {
    *a1 = v22;
    uint64_t v23 = *v6;
  }
  sub_19E37D324(a1[1], v23);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v20;
}

void sub_19E3F77E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t **sub_19E3F77F4(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *((char *)a2 + 23);
    if (v7 >= 0) {
      int v8 = a2;
    }
    else {
      int v8 = *a2;
    }
    if (v7 >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    while (1)
    {
      unint64_t v10 = (uint64_t **)v5;
      uint64_t v13 = (const void *)v5[4];
      CFRange v11 = v5 + 4;
      int v12 = v13;
      int v14 = *((char *)v11 + 23);
      if (v14 >= 0) {
        int v15 = v11;
      }
      else {
        int v15 = v12;
      }
      if (v14 >= 0) {
        size_t v16 = *((unsigned __int8 *)v11 + 23);
      }
      else {
        size_t v16 = v11[1];
      }
      if (v16 >= v9) {
        size_t v17 = v9;
      }
      else {
        size_t v17 = v16;
      }
      int v18 = memcmp(v8, v15, v17);
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_8;
        }
LABEL_22:
        int v19 = memcmp(v15, v8, v17);
        if (v19)
        {
          if ((v19 & 0x80000000) == 0) {
            return v10;
          }
        }
        else if (v16 >= v9)
        {
          return v10;
        }
        uint64_t v5 = v10[1];
        if (!v5)
        {
          uint64_t v6 = v10 + 1;
          goto LABEL_29;
        }
      }
      else
      {
        if (v9 >= v16) {
          goto LABEL_22;
        }
LABEL_8:
        uint64_t v5 = *v10;
        uint64_t v6 = v10;
        if (!*v10) {
          goto LABEL_29;
        }
      }
    }
  }
  unint64_t v10 = a1 + 1;
LABEL_29:
  uint64_t v20 = (char *)operator new(0x48uLL);
  uint64_t v21 = v20 + 32;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_19E39369C(v21, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v21 = *(_OWORD *)a3;
    *((void *)v20 + 6) = *(void *)(a3 + 16);
  }
  *((_DWORD *)v20 + 14) = 0;
  *((void *)v20 + 8) = 0;
  *(void *)uint64_t v20 = 0;
  *((void *)v20 + 1) = 0;
  *((void *)v20 + 2) = v10;
  *uint64_t v6 = (uint64_t *)v20;
  uint64_t v22 = (uint64_t *)**a1;
  uint64_t v23 = (uint64_t *)v20;
  if (v22)
  {
    *a1 = v22;
    uint64_t v23 = *v6;
  }
  sub_19E37D324(a1[1], v23);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v20;
}

void sub_19E3F7968(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t *sub_19E3F797C(unint64_t *a1)
{
  unint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    unint64_t v3 = sub_19E499F28(v2);
    MEMORY[0x19F3BDCF0](v3, 0x1020C4055CCDE27);
  }
  return a1;
}

uint64_t sub_19E3F79C4(sqlite3 **a1, const char *a2)
{
  char v2 = (char)a2;
  uint64_t v4 = sqlite3_exec(*a1, a2, 0, 0, 0);
  if (v4)
  {
    if (qword_1EC009490 != -1) {
      dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
    }
    uint64_t v5 = (int *)qword_1EC009488;
    sqlite3_errmsg(*a1);
    sub_19E4E4498(v5, v6, "Could not execute SQL \"%s\", error message: %s\n", v7, v8, v9, v10, v11, v2);
    if (v4 == 26 || v4 == 11)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      sub_19E3F7ABC((uint64_t)exception, 1);
      __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
    }
  }
  return v4;
}

void sub_19E3F7AA8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E3F7ABC(uint64_t a1, int a2)
{
  *(void *)a1 = &unk_1EF0BB7A8;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_19E377894((void **)(a1 + 8), off_1E599F368[a2 - 1], qword_19E574C00[a2 - 1]);
  return a1;
}

void sub_19E3F7B38(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  std::exception::~exception((std::exception *)v1);
  _Unwind_Resume(a1);
}

void sub_19E3F7B5C(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF0BB7A8;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);
}

uint64_t sub_19E3F7BBC(uint64_t a1)
{
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void sub_19E3F7BD8(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF0BB7A8;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);
  JUMPOUT(0x19F3BDCF0);
}

void **sub_19E3F7C4C(void **a1, char *__s)
{
  size_t v4 = strlen(__s);
  return sub_19E377894(a1, __s, v4);
}

sqlite3 *sub_19E3F7C94(uint64_t a1, int a2)
{
  ppDb = 0;
  size_t v4 = (const char *)(a1 + 16);
  if (*(char *)(a1 + 39) < 0) {
    size_t v4 = *(const char **)v4;
  }
  int v5 = sqlite3_open(v4, &ppDb);
  if (!v5)
  {
    if (a2) {
      p_ppDb = (sqlite3 **)a1;
    }
    else {
      p_ppDb = &ppDb;
    }
    uint64_t v7 = *p_ppDb;
    if (a2) {
      uint64_t v8 = &ppDb;
    }
    else {
      uint64_t v8 = (sqlite3 **)a1;
    }
    uint64_t v9 = *v8;
    if (a2 && *(unsigned char *)(a1 + 41)) {
      sqlite3_exec(ppDb, "PRAGMA journal_mode = WAL;", 0, 0, 0);
    }
    uint64_t v10 = sqlite3_backup_init(v9, "main", v7, "main");
    if (v10)
    {
      uint64_t v11 = v10;
      sqlite3_backup_step(v10, -1);
      sqlite3_backup_finish(v11);
    }
    int v5 = sqlite3_errcode(ppDb);
  }
  uint64_t result = ppDb;
  if (ppDb) {
    uint64_t result = (sqlite3 *)sqlite3_close(ppDb);
  }
  if (v5)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E3F7ABC((uint64_t)exception, 3);
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
  }
  return result;
}

void sub_19E3F7DAC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E3F7DC0(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v206 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 208))
  {
    unint64_t v3 = *(void **)(a1 + 96);
    uint64_t v194 = a1;
    size_t v4 = (void *)(a1 + 104);
    if (v3 != (void *)(a1 + 104))
    {
      unint64_t v187 = (void *)(a1 + 104);
      do
      {
        *(void *)((char *)&v202 + 7) = 0;
        *(void *)&long long v202 = 0;
        memset(__p, 0, sizeof(__p));
        int v201 = 0;
        int v5 = (void **)v3[7];
        uint64_t v6 = (void **)(v3 + 8);
        if (v5 == v3 + 8)
        {
          uint64_t v9 = 0;
          char v10 = 0;
LABEL_72:
          if (SHIBYTE(__p[2]) < 0) {
            goto LABEL_111;
          }
LABEL_73:
          if (v10 < 0) {
            goto LABEL_112;
          }
          goto LABEL_74;
        }
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        char v10 = 0;
        do
        {
          uint64_t v11 = v7;
          if (*((_DWORD *)v5 + 14) > (int)v7)
          {
            if (__p != v5 + 4)
            {
              char v12 = *((unsigned char *)v5 + 55);
              if (SHIBYTE(__p[2]) < 0)
              {
                if (v12 >= 0) {
                  uint64_t v13 = v5 + 4;
                }
                else {
                  uint64_t v13 = v5[4];
                }
                if (v12 >= 0) {
                  size_t v14 = *((unsigned __int8 *)v5 + 55);
                }
                else {
                  size_t v14 = (size_t)v5[5];
                }
                sub_19E3C6D44(__p, v13, v14);
              }
              else if ((*((unsigned char *)v5 + 55) & 0x80) != 0)
              {
                sub_19E3C6C7C(__p, v5[4], (size_t)v5[5]);
              }
              else
              {
                *(_OWORD *)std::string __p = *((_OWORD *)v5 + 2);
                __p[2] = v5[6];
              }
            }
            uint64_t v11 = *((unsigned int *)v5 + 14);
            int v201 = *((_DWORD *)v5 + 14);
          }
          if ((int)v11 <= (int)v8)
          {
            uint64_t v7 = v11;
            size_t v17 = (void **)v5[1];
            if (!v17)
            {
              do
              {
LABEL_28:
                int v18 = (void **)v5[2];
                BOOL v156 = *v18 == v5;
                int v5 = v18;
              }
              while (!v156);
              goto LABEL_7;
            }
          }
          else
          {
            *(void *)&long long v204 = v202;
            *(void *)((char *)&v204 + 7) = *(void *)((char *)&v202 + 7);
            int v15 = __p[0];
            *(void **)&long long v202 = __p[1];
            *(void **)((char *)&v202 + 7) = *(void **)((char *)&__p[1] + 7);
            char v16 = HIBYTE(__p[2]);
            __p[0] = v9;
            __p[1] = (void *)v204;
            *(void **)((char *)&__p[1] + 7) = *(void **)((char *)&v204 + 7);
            HIBYTE(__p[2]) = v10;
            int v201 = v8;
            uint64_t v7 = v8;
            char v10 = v16;
            uint64_t v9 = v15;
            uint64_t v8 = v11;
            size_t v17 = (void **)v5[1];
            if (!v17) {
              goto LABEL_28;
            }
          }
          do
          {
            int v18 = v17;
            size_t v17 = (void **)*v17;
          }
          while (v17);
LABEL_7:
          int v5 = v18;
        }
        while (v18 != v6);
        if ((int)v8 < 2001 || (int)v7 <= 0 || (double)(int)v7 / (double)(int)v8 >= 0.05) {
          goto LABEL_72;
        }
        int v195 = SHIBYTE(__p[2]);
        int v19 = (void **)__p[0];
        __src = __p[0];
        if (SHIBYTE(__p[2]) >= 0) {
          int v19 = __p;
        }
        uint64_t v197 = (char *)v3[8];
        std::string __s1 = v19;
        v192 = __p[1];
        if (SHIBYTE(__p[2]) >= 0) {
          uint64_t v20 = (void *)HIBYTE(__p[2]);
        }
        else {
          uint64_t v20 = __p[1];
        }
        uint64_t v21 = (char **)(v3 + 8);
        uint64_t v22 = (char **)(v3 + 8);
        if (!v3[8]) {
          goto LABEL_76;
        }
        while (2)
        {
          uint64_t v23 = v197;
LABEL_42:
          while (2)
          {
            uint64_t v22 = (char **)v23;
            uint64_t v24 = v23 + 32;
            int v25 = (const void *)*((void *)v23 + 4);
            int v26 = *((char *)v24 + 23);
            if (v26 >= 0) {
              size_t v27 = v24;
            }
            else {
              size_t v27 = v25;
            }
            if (v26 >= 0) {
              size_t v28 = *((unsigned __int8 *)v24 + 23);
            }
            else {
              size_t v28 = v24[1];
            }
            if (v28 >= (unint64_t)v20) {
              size_t v29 = (size_t)v20;
            }
            else {
              size_t v29 = v28;
            }
            int v30 = memcmp(__s1, v27, v29);
            if (v30)
            {
              if (v30 < 0) {
                goto LABEL_41;
              }
            }
            else if ((unint64_t)v20 < v28)
            {
LABEL_41:
              uint64_t v23 = *v22;
              uint64_t v21 = v22;
              if (!*v22) {
                goto LABEL_76;
              }
              continue;
            }
            break;
          }
          int v31 = memcmp(v27, __s1, v29);
          if (v31)
          {
            if (v31 < 0) {
              break;
            }
            goto LABEL_57;
          }
          if (v28 >= (unint64_t)v20)
          {
LABEL_57:
            if (*((int *)v22 + 14) < 2001) {
              goto LABEL_110;
            }
            uint64_t v32 = (void **)v3[7];
            uint64_t v23 = v197;
            if (v32 != v6)
            {
              do
              {
                *((_DWORD *)v32 + 14) = (int)((double)*((int *)v32 + 14) * 0.95);
                size_t v33 = (void **)v32[1];
                if (v33)
                {
                  do
                  {
                    int64_t v34 = v33;
                    size_t v33 = (void **)*v33;
                  }
                  while (v33);
                }
                else
                {
                  do
                  {
                    int64_t v34 = (void **)v32[2];
                    BOOL v156 = *v34 == v32;
                    uint64_t v32 = v34;
                  }
                  while (!v156);
                }
                uint64_t v32 = v34;
              }
              while (v34 != v6);
              continue;
            }
            goto LABEL_42;
          }
          break;
        }
        uint64_t v23 = v22[1];
        if (v23) {
          goto LABEL_42;
        }
        uint64_t v21 = v22 + 1;
LABEL_76:
        size_t v36 = (char *)operator new(0x40uLL);
        unint64_t v37 = v36 + 32;
        if (v195 < 0)
        {
          sub_19E39369C(v37, __src, (unint64_t)v192);
        }
        else
        {
          *(_OWORD *)unint64_t v37 = *(_OWORD *)__p;
          *((void **)v36 + 6) = __p[2];
        }
        *((_DWORD *)v36 + 14) = 0;
        *(void *)size_t v36 = 0;
        *((void *)v36 + 1) = 0;
        *((void *)v36 + 2) = v22;
        unsigned char *v21 = v36;
        uint64_t v38 = *(void *)v3[7];
        if (v38)
        {
          v3[7] = v38;
          size_t v36 = *v21;
        }
        uint64_t v39 = (char *)*v6;
        BOOL v156 = v36 == *v6;
        v36[24] = v156;
        if (!v156)
        {
          do
          {
            uint64_t v40 = *((void *)v36 + 2);
            if (*(unsigned char *)(v40 + 24)) {
              break;
            }
            size_t v41 = *(char **)(v40 + 16);
            uint64_t v42 = *(void *)v41;
            if (*(void *)v41 == v40)
            {
              uint64_t v45 = *((void *)v41 + 1);
              if (!v45 || (v46 = *(unsigned __int8 *)(v45 + 24), uint64_t v43 = (unsigned char *)(v45 + 24), v46))
              {
                if (*(char **)v40 == v36)
                {
                  long long v47 = (uint64_t *)*((void *)v36 + 2);
                }
                else
                {
                  long long v47 = *(uint64_t **)(v40 + 8);
                  uint64_t v48 = *v47;
                  *(void *)(v40 + 8) = *v47;
                  if (v48)
                  {
                    *(void *)(v48 + 16) = v40;
                    size_t v41 = *(char **)(v40 + 16);
                  }
                  v47[2] = (uint64_t)v41;
                  *(void *)(*(void *)(v40 + 16) + 8 * (**(void **)(v40 + 16) != v40)) = v47;
                  *long long v47 = v40;
                  *(void *)(v40 + 16) = v47;
                  size_t v41 = (char *)v47[2];
                  uint64_t v40 = *(void *)v41;
                }
                *((unsigned char *)v47 + 24) = 1;
                v41[24] = 0;
                uint64_t v51 = *(void *)(v40 + 8);
                *(void *)size_t v41 = v51;
                if (v51) {
                  *(void *)(v51 + 16) = v41;
                }
                *(void *)(v40 + 16) = *((void *)v41 + 2);
                *(void *)(*((void *)v41 + 2) + 8 * (**((void **)v41 + 2) != (void)v41)) = v40;
                *(void *)(v40 + 8) = v41;
                goto LABEL_108;
              }
            }
            else if (!v42 || (v44 = *(unsigned __int8 *)(v42 + 24), uint64_t v43 = (unsigned char *)(v42 + 24), v44))
            {
              if (*(char **)v40 == v36)
              {
                uint64_t v49 = *((void *)v36 + 1);
                *(void *)uint64_t v40 = v49;
                if (v49)
                {
                  *(void *)(v49 + 16) = v40;
                  size_t v41 = *(char **)(v40 + 16);
                }
                *((void *)v36 + 2) = v41;
                *(void *)(*(void *)(v40 + 16) + 8 * (**(void **)(v40 + 16) != v40)) = v36;
                *((void *)v36 + 1) = v40;
                *(void *)(v40 + 16) = v36;
                size_t v41 = (char *)*((void *)v36 + 2);
              }
              else
              {
                size_t v36 = (char *)*((void *)v36 + 2);
              }
              v36[24] = 1;
              v41[24] = 0;
              uint64_t v40 = *((void *)v41 + 1);
              size_t v50 = *(char **)v40;
              *((void *)v41 + 1) = *(void *)v40;
              if (v50) {
                *((void *)v50 + 2) = v41;
              }
              *(void *)(v40 + 16) = *((void *)v41 + 2);
              *(void *)(*((void *)v41 + 2) + 8 * (**((void **)v41 + 2) != (void)v41)) = v40;
              *(void *)uint64_t v40 = v41;
LABEL_108:
              *((void *)v41 + 2) = v40;
              break;
            }
            *(unsigned char *)(v40 + 24) = 1;
            size_t v36 = v41;
            v41[24] = v41 == v39;
            *uint64_t v43 = 1;
          }
          while (v41 != v39);
        }
        ++v3[9];
LABEL_110:
        *(unsigned char *)(v194 + 192) = 1;
        size_t v4 = v187;
        if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
          goto LABEL_73;
        }
LABEL_111:
        operator delete(__p[0]);
        if (v10 < 0)
        {
LABEL_112:
          operator delete(v9);
          size_t v35 = (void *)v3[1];
          if (v35) {
            goto LABEL_113;
          }
          do
          {
LABEL_115:
            uint64_t v52 = (void *)v3[2];
            BOOL v156 = *v52 == (void)v3;
            unint64_t v3 = v52;
          }
          while (!v156);
          goto LABEL_4;
        }
LABEL_74:
        size_t v35 = (void *)v3[1];
        if (!v35) {
          goto LABEL_115;
        }
        do
        {
LABEL_113:
          uint64_t v52 = v35;
          size_t v35 = (void *)*v35;
        }
        while (v35);
LABEL_4:
        unint64_t v3 = v52;
      }
      while (v52 != v4);
    }
    a1 = v194;
    *(unsigned char *)(v194 + 208) = 0;
  }
  uint64_t v53 = a1;
  __p[1] = 0;
  __p[2] = 0;
  __p[0] = &__p[1];
  size_t v54 = *(uint64_t **)a3;
  v193 = (uint64_t *)(a3 + 8);
  if (*(void *)a3 != a3 + 8)
  {
    while (1)
    {
      double v57 = (void **)__p[1];
      size_t v58 = &__p[1];
      if (__p[0] == &__p[1]) {
        break;
      }
      size_t v59 = (void **)__p[1];
      CFIndex v60 = &__p[1];
      if (__p[1])
      {
        do
        {
          size_t v58 = v59;
          size_t v59 = (void **)v59[1];
        }
        while (v59);
      }
      else
      {
        do
        {
          size_t v58 = (void **)v60[2];
          BOOL v156 = *v58 == v60;
          CFIndex v60 = v58;
        }
        while (v156);
      }
      int v61 = *((char *)v58 + 55);
      if (v61 >= 0) {
        uint64_t v62 = v58 + 4;
      }
      else {
        uint64_t v62 = v58[4];
      }
      if (v61 >= 0) {
        size_t v63 = *((unsigned __int8 *)v58 + 55);
      }
      else {
        size_t v63 = (size_t)v58[5];
      }
      int v64 = *((char *)v54 + 55);
      if (v64 >= 0) {
        std::string::size_type v65 = v54 + 4;
      }
      else {
        std::string::size_type v65 = (const void *)v54[4];
      }
      if (v64 >= 0) {
        size_t v66 = *((unsigned __int8 *)v54 + 55);
      }
      else {
        size_t v66 = v54[5];
      }
      if (v66 >= v63) {
        size_t v67 = v63;
      }
      else {
        size_t v67 = v66;
      }
      int v68 = memcmp(v62, v65, v67);
      if (v68)
      {
        if (v68 < 0) {
          break;
        }
      }
      else if (v63 < v66)
      {
        break;
      }
      long long v69 = &__p[1];
      uint64_t v70 = &__p[1];
      if (v57)
      {
        uint64_t v70 = &__p[1];
        while (1)
        {
          long long v69 = v57;
          size_t v71 = *((unsigned __int8 *)v57 + 55);
          size_t v72 = v57[5];
          if ((v71 & 0x80u) == 0) {
            size_t v73 = v57 + 4;
          }
          else {
            size_t v73 = v57[4];
          }
          if ((v71 & 0x80u) == 0) {
            size_t v74 = v71;
          }
          else {
            size_t v74 = (size_t)v72;
          }
          if (v74 >= v66) {
            size_t v75 = v66;
          }
          else {
            size_t v75 = v74;
          }
          int v76 = memcmp(v65, v73, v75);
          if (v76)
          {
            if (v76 < 0) {
              goto LABEL_147;
            }
LABEL_161:
            int v77 = memcmp(v73, v65, v75);
            if (v77)
            {
              if ((v77 & 0x80000000) == 0) {
                break;
              }
            }
            else if (v74 >= v66)
            {
              break;
            }
            uint64_t v70 = v69 + 1;
            double v57 = (void **)v69[1];
            if (!v57) {
              goto LABEL_177;
            }
          }
          else
          {
            if (v66 >= v74) {
              goto LABEL_161;
            }
LABEL_147:
            double v57 = (void **)*v69;
            uint64_t v70 = v69;
            if (!*v69) {
              goto LABEL_177;
            }
          }
        }
      }
LABEL_174:
      if (*v70)
      {
        BOOL v78 = (uint64_t *)v54[1];
        if (!v78) {
          goto LABEL_185;
        }
      }
      else
      {
LABEL_177:
        BOOL v79 = (uint64_t *)operator new(0x40uLL);
        int v80 = v79 + 4;
        if (*((char *)v54 + 55) < 0)
        {
          sub_19E39369C(v80, (void *)v54[4], v54[5]);
        }
        else
        {
          long long v81 = *((_OWORD *)v54 + 2);
          v79[6] = v54[6];
          *(_OWORD *)int v80 = v81;
        }
        v79[7] = v54[7];
        *BOOL v79 = 0;
        v79[1] = 0;
        v79[2] = (uint64_t)v69;
        *uint64_t v70 = v79;
        if (*(void *)__p[0])
        {
          __p[0] = *(void **)__p[0];
          BOOL v79 = (uint64_t *)*v70;
        }
        sub_19E37D324((uint64_t *)__p[1], v79);
        ++__p[2];
        BOOL v78 = (uint64_t *)v54[1];
        if (!v78)
        {
          do
          {
LABEL_185:
            size_t v82 = (uint64_t *)v54[2];
            BOOL v156 = *v82 == (void)v54;
            size_t v54 = v82;
          }
          while (!v156);
          goto LABEL_122;
        }
      }
      do
      {
        size_t v82 = v78;
        BOOL v78 = (uint64_t *)*v78;
      }
      while (v78);
LABEL_122:
      size_t v54 = v82;
      if (v82 == v193) {
        goto LABEL_120;
      }
    }
    if (v57) {
      long long v69 = v58;
    }
    else {
      long long v69 = &__p[1];
    }
    if (v57) {
      uint64_t v70 = v58 + 1;
    }
    else {
      uint64_t v70 = &__p[1];
    }
    goto LABEL_174;
  }
LABEL_120:
  *((void *)&v204 + 1) = 0;
  uint64_t v205 = 0;
  *(void *)&long long v204 = (char *)&v204 + 8;
  BOOL v55 = *(uint64_t ***)(v53 + 96);
  BOOL v56 = (uint64_t **)(v53 + 104);
  __srca = (uint64_t **)(v53 + 104);
  if (v55 != (uint64_t **)(v53 + 104))
  {
    while (1)
    {
      int v83 = (uint64_t **)v55[7];
      uint64_t v196 = (uint64_t *)v55;
      __s1a = v55 + 8;
      if (v83 != v55 + 8) {
        break;
      }
LABEL_190:
      uint64_t v84 = v196;
      uint64_t v85 = (uint64_t *)v196[1];
      if (v85)
      {
        do
        {
          int64_t v86 = (uint64_t **)v85;
          uint64_t v85 = (uint64_t *)*v85;
        }
        while (v85);
      }
      else
      {
        do
        {
          int64_t v86 = (uint64_t **)v84[2];
          BOOL v156 = *v86 == v84;
          uint64_t v84 = (uint64_t *)v86;
        }
        while (!v156);
      }
      BOOL v55 = v86;
      BOOL v56 = (uint64_t **)(v53 + 104);
      if (v86 == __srca) {
        goto LABEL_265;
      }
    }
    while (1)
    {
      int v87 = *((_DWORD *)v83 + 14);
      int64_t v88 = (char *)*((void *)&v204 + 1);
      int v89 = (char *)&v204 + 8;
      uint64_t v90 = (char **)&v204 + 1;
      if (*((void *)&v204 + 1)) {
        break;
      }
LABEL_221:
      unint64_t v103 = (char *)operator new(0x40uLL);
      uint64_t v104 = v103 + 32;
      if (*((char *)v83 + 55) < 0)
      {
        sub_19E39369C(v104, v83[4], (unint64_t)v83[5]);
      }
      else
      {
        long long v105 = *((_OWORD *)v83 + 2);
        *((void *)v103 + 6) = v83[6];
        *(_OWORD *)uint64_t v104 = v105;
      }
      *((_DWORD *)v103 + 14) = 0;
      *(void *)unint64_t v103 = 0;
      *((void *)v103 + 1) = 0;
      *((void *)v103 + 2) = v89;
      double *v90 = v103;
      uint64_t v106 = v103;
      if (*(void *)v204)
      {
        *(void *)&long long v204 = *(void *)v204;
        uint64_t v106 = *v90;
      }
      uint64_t v107 = (char *)*((void *)&v204 + 1);
      BOOL v156 = v106 == *((char **)&v204 + 1);
      v106[24] = v106 == *((char **)&v204 + 1);
      if (!v156)
      {
        do
        {
          uint64_t v108 = *((void *)v106 + 2);
          if (*(unsigned char *)(v108 + 24)) {
            break;
          }
          int64_t v109 = *(char **)(v108 + 16);
          uint64_t v110 = *(void *)v109;
          if (*(void *)v109 == v108)
          {
            uint64_t v113 = *((void *)v109 + 1);
            if (!v113 || (int v114 = *(unsigned __int8 *)(v113 + 24), v111 = (unsigned char *)(v113 + 24), v114))
            {
              if (*(char **)v108 == v106)
              {
                std::string v115 = (uint64_t *)*((void *)v106 + 2);
              }
              else
              {
                std::string v115 = *(uint64_t **)(v108 + 8);
                uint64_t v116 = *v115;
                *(void *)(v108 + 8) = *v115;
                if (v116)
                {
                  *(void *)(v116 + 16) = v108;
                  int64_t v109 = *(char **)(v108 + 16);
                }
                v115[2] = (uint64_t)v109;
                *(void *)(*(void *)(v108 + 16) + 8 * (**(void **)(v108 + 16) != v108)) = v115;
                uint64_t *v115 = v108;
                *(void *)(v108 + 16) = v115;
                int64_t v109 = (char *)v115[2];
                uint64_t v108 = *(void *)v109;
              }
              *((unsigned char *)v115 + 24) = 1;
              v109[24] = 0;
              uint64_t v120 = *(void *)(v108 + 8);
              *(void *)int64_t v109 = v120;
              if (v120) {
                *(void *)(v120 + 16) = v109;
              }
              *(void *)(v108 + 16) = *((void *)v109 + 2);
              *(void *)(*((void *)v109 + 2) + 8 * (**((void **)v109 + 2) != (void)v109)) = v108;
              *(void *)(v108 + 8) = v109;
              goto LABEL_254;
            }
          }
          else if (!v110 || (int v112 = *(unsigned __int8 *)(v110 + 24), v111 = (unsigned char *)(v110 + 24), v112))
          {
            if (*(char **)v108 == v106)
            {
              uint64_t v118 = *((void *)v106 + 1);
              *(void *)uint64_t v108 = v118;
              if (v118)
              {
                *(void *)(v118 + 16) = v108;
                int64_t v109 = *(char **)(v108 + 16);
              }
              *((void *)v106 + 2) = v109;
              *(void *)(*(void *)(v108 + 16) + 8 * (**(void **)(v108 + 16) != v108)) = v106;
              *((void *)v106 + 1) = v108;
              *(void *)(v108 + 16) = v106;
              int64_t v109 = (char *)*((void *)v106 + 2);
            }
            else
            {
              uint64_t v106 = (char *)*((void *)v106 + 2);
            }
            v106[24] = 1;
            v109[24] = 0;
            uint64_t v108 = *((void *)v109 + 1);
            uint64_t v119 = *(char **)v108;
            *((void *)v109 + 1) = *(void *)v108;
            if (v119) {
              *((void *)v119 + 2) = v109;
            }
            *(void *)(v108 + 16) = *((void *)v109 + 2);
            *(void *)(*((void *)v109 + 2) + 8 * (**((void **)v109 + 2) != (void)v109)) = v108;
            *(void *)uint64_t v108 = v109;
LABEL_254:
            *((void *)v109 + 2) = v108;
            break;
          }
          *(unsigned char *)(v108 + 24) = 1;
          uint64_t v106 = v109;
          v109[24] = v109 == v107;
          *uint64_t v111 = 1;
        }
        while (v109 != v107);
      }
      int v117 = 0;
      ++v205;
LABEL_256:
      *((_DWORD *)v103 + 14) = v117 + v87;
      unint64_t v121 = v83[1];
      if (v121)
      {
        do
        {
          unint64_t v122 = (uint64_t **)v121;
          unint64_t v121 = (uint64_t *)*v121;
        }
        while (v121);
      }
      else
      {
        do
        {
          unint64_t v122 = (uint64_t **)v83[2];
          BOOL v156 = *v122 == (uint64_t *)v83;
          int v83 = v122;
        }
        while (!v156);
      }
      int v83 = v122;
      if (v122 == __s1a) {
        goto LABEL_190;
      }
    }
    int v91 = *((char *)v83 + 55);
    if (v91 >= 0) {
      uint64_t v92 = (uint64_t *)(v83 + 4);
    }
    else {
      uint64_t v92 = v83[4];
    }
    if (v91 >= 0) {
      size_t v93 = *((unsigned __int8 *)v83 + 55);
    }
    else {
      size_t v93 = (size_t)v83[5];
    }
    while (1)
    {
      int v89 = v88;
      uint64_t v96 = (char *)*((void *)v88 + 4);
      uint64_t v94 = v88 + 32;
      uint64_t v95 = v96;
      int v97 = v94[23];
      if (v97 >= 0) {
        uint64_t v98 = v94;
      }
      else {
        uint64_t v98 = v95;
      }
      if (v97 >= 0) {
        size_t v99 = v94[23];
      }
      else {
        size_t v99 = *((void *)v94 + 1);
      }
      if (v99 >= v93) {
        size_t v100 = v93;
      }
      else {
        size_t v100 = v99;
      }
      int v101 = memcmp(v92, v98, v100);
      if (v101)
      {
        if (v101 < 0) {
          goto LABEL_201;
        }
LABEL_215:
        int v102 = memcmp(v98, v92, v100);
        if (v102)
        {
          if ((v102 & 0x80000000) == 0) {
            goto LABEL_241;
          }
        }
        else if (v99 >= v93)
        {
LABEL_241:
          int v117 = *((_DWORD *)v89 + 14);
          unint64_t v103 = v89;
          goto LABEL_256;
        }
        int64_t v88 = (char *)*((void *)v89 + 1);
        if (!v88)
        {
          uint64_t v90 = (char **)(v89 + 8);
          goto LABEL_221;
        }
      }
      else
      {
        if (v93 >= v99) {
          goto LABEL_215;
        }
LABEL_201:
        int64_t v88 = *(char **)v89;
        uint64_t v90 = (char **)v89;
        if (!*(void *)v89) {
          goto LABEL_221;
        }
      }
    }
  }
LABEL_265:
  sub_19E3F8F38((uint64_t **)&v204, a3);
  int64_t v123 = *v56;
  uint64_t v124 = a2;
  int v125 = *((char *)a2 + 23);
  if (!*v56)
  {
    int v140 = 0;
    goto LABEL_336;
  }
  if (v125 >= 0) {
    v126 = a2;
  }
  else {
    v126 = *a2;
  }
  if (v125 >= 0) {
    size_t v127 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v127 = (size_t)a2[1];
  }
  long long v128 = v56;
  v129 = *v56;
  do
  {
    while (1)
    {
      int v130 = *((char *)v129 + 55);
      uint64_t v131 = v130 >= 0 ? v129 + 4 : (uint64_t *)v129[4];
      size_t v132 = v130 >= 0 ? *((unsigned __int8 *)v129 + 55) : v129[5];
      size_t v133 = v127 >= v132 ? v132 : v127;
      int v134 = memcmp(v131, v126, v133);
      if (v134) {
        break;
      }
      if (v132 >= v127) {
        goto LABEL_287;
      }
LABEL_273:
      v129 = (uint64_t *)v129[1];
      if (!v129) {
        goto LABEL_288;
      }
    }
    if (v134 < 0) {
      goto LABEL_273;
    }
LABEL_287:
    long long v128 = (uint64_t **)v129;
    v129 = (uint64_t *)*v129;
  }
  while (v129);
LABEL_288:
  if (v128 == v56) {
    goto LABEL_312;
  }
  int v135 = *((char *)v128 + 55);
  if (v135 >= 0) {
    uint64_t v136 = (uint64_t *)(v128 + 4);
  }
  else {
    uint64_t v136 = v128[4];
  }
  if (v135 >= 0) {
    size_t v137 = *((unsigned __int8 *)v128 + 55);
  }
  else {
    size_t v137 = (size_t)v128[5];
  }
  if (v137 >= v127) {
    size_t v138 = v127;
  }
  else {
    size_t v138 = v137;
  }
  int v139 = memcmp(v126, v136, v138);
  if (v139)
  {
    if (v139 < 0)
    {
LABEL_312:
      int v140 = 0;
      uint64_t v124 = a2;
      goto LABEL_313;
    }
  }
  else if (v127 < v137)
  {
    goto LABEL_312;
  }
  unint64_t v141 = (uint64_t **)v128[7];
  if (v141 == v128 + 8) {
    goto LABEL_312;
  }
  int v140 = 0;
  uint64_t v124 = a2;
  do
  {
    unint64_t v142 = v141[1];
    uint64_t v143 = (uint64_t *)v141;
    if (v142)
    {
      do
      {
        v144 = (uint64_t **)v142;
        unint64_t v142 = (uint64_t *)*v142;
      }
      while (v142);
    }
    else
    {
      do
      {
        v144 = (uint64_t **)v143[2];
        BOOL v156 = *v144 == v143;
        uint64_t v143 = (uint64_t *)v144;
      }
      while (!v156);
    }
    v140 += *((_DWORD *)v141 + 14);
    unint64_t v141 = v144;
  }
  while (v144 != v128 + 8);
LABEL_313:
  unint64_t v145 = *((unsigned __int8 *)v124 + 23);
  int v125 = (char)v145;
  if (!v123)
  {
LABEL_336:
    long long v146 = v124[1];
    unint64_t v145 = v125;
    goto LABEL_337;
  }
  long long v146 = v124[1];
  if ((v145 & 0x80u) == 0) {
    long long v147 = v124;
  }
  else {
    long long v147 = *v124;
  }
  long long v148 = v56;
  if ((v145 & 0x80u) == 0) {
    size_t v149 = *((unsigned __int8 *)v124 + 23);
  }
  else {
    size_t v149 = (size_t)v124[1];
  }
  while (2)
  {
    int v150 = *((char *)v123 + 55);
    if (v150 >= 0) {
      v151 = v123 + 4;
    }
    else {
      v151 = (const void *)v123[4];
    }
    if (v150 >= 0) {
      size_t v152 = *((unsigned __int8 *)v123 + 55);
    }
    else {
      size_t v152 = v123[5];
    }
    if (v149 >= v152) {
      size_t v153 = v152;
    }
    else {
      size_t v153 = v149;
    }
    int v154 = memcmp(v151, v147, v153);
    if (!v154)
    {
      if (v152 < v149) {
        goto LABEL_335;
      }
      goto LABEL_320;
    }
    if ((v154 & 0x80000000) == 0)
    {
LABEL_320:
      long long v148 = (uint64_t **)v123;
      goto LABEL_321;
    }
LABEL_335:
    ++v123;
LABEL_321:
    int64_t v123 = (uint64_t *)*v123;
    if (v123) {
      continue;
    }
    break;
  }
  if (v148 == __srca)
  {
    BOOL v56 = (uint64_t **)(v53 + 104);
    goto LABEL_337;
  }
  int v164 = *((char *)v148 + 55);
  if (v164 >= 0) {
    v165 = (uint64_t *)(v148 + 4);
  }
  else {
    v165 = v148[4];
  }
  if (v164 >= 0) {
    size_t v166 = *((unsigned __int8 *)v148 + 55);
  }
  else {
    size_t v166 = (size_t)v148[5];
  }
  if (v166 >= v149) {
    size_t v167 = v149;
  }
  else {
    size_t v167 = v166;
  }
  int v168 = memcmp(v147, v165, v167);
  if (v168)
  {
    BOOL v56 = (uint64_t **)(v53 + 104);
    if (v168 < 0) {
      goto LABEL_337;
    }
  }
  else
  {
    BOOL v178 = v149 >= v166;
    BOOL v56 = (uint64_t **)(v53 + 104);
    if (!v178) {
LABEL_337:
    }
      long long v148 = v56;
  }
  if (v125 >= 0) {
    unint64_t v155 = v145;
  }
  else {
    unint64_t v155 = (unint64_t)v146;
  }
  if (v155) {
    BOOL v156 = v56 == v148;
  }
  else {
    BOOL v156 = 1;
  }
  if (!v156 && v140 >= 1)
  {
    sub_19E3F8F38(v148 + 7, (uint64_t)__p);
    *((void *)&v202 + 1) = 0;
    unint64_t v203 = 0;
    *(void *)&long long v202 = (char *)&v202 + 8;
    unint64_t v158 = (void **)__p[0];
    if (__p[0] != &__p[1])
    {
      do
      {
        unint64_t v159 = sub_19E374C3C(a3, (const void **)v158 + 4);
        if (v193 == v159)
        {
          v161 = sub_19E3CD25C((uint64_t **)&v202, (const void **)v158 + 4, (uint64_t)(v158 + 4));
          unint64_t v160 = 0;
        }
        else
        {
          unint64_t v160 = (uint64_t *)v159[7];
          v161 = sub_19E3CD25C((uint64_t **)&v202, (const void **)v158 + 4, (uint64_t)(v158 + 4));
        }
        v161[7] = v160;
        std::string::size_type v162 = (void **)v158[1];
        if (v162)
        {
          do
          {
            v163 = v162;
            std::string::size_type v162 = (void **)*v162;
          }
          while (v162);
        }
        else
        {
          do
          {
            v163 = (void **)v158[2];
            BOOL v156 = *v163 == v158;
            unint64_t v158 = v163;
          }
          while (!v156);
        }
        unint64_t v158 = v163;
      }
      while (v163 != &__p[1]);
      if (v203)
      {
        uint64_t v169 = (double *)v202;
        if ((long long *)v202 != (long long *)((char *)&v202 + 8))
        {
          double v170 = 0.0;
          int v171 = (_OWORD *)v202;
          do
          {
            uint64_t v172 = (void *)*((void *)v171 + 1);
            uint64_t v173 = v171;
            if (v172)
            {
              do
              {
                uint64_t v174 = v172;
                uint64_t v172 = (void *)*v172;
              }
              while (v172);
            }
            else
            {
              do
              {
                uint64_t v174 = (_OWORD *)*((void *)v173 + 2);
                BOOL v156 = *(void *)v174 == (void)v173;
                uint64_t v173 = v174;
              }
              while (!v156);
            }
            double v170 = *((double *)v171 + 7) + v170;
            int v171 = v174;
          }
          while (v174 != (long long *)((char *)&v202 + 8));
          if (v170 <= 0.0)
          {
            double v179 = 1.0 / (double)v203;
            do
            {
              v169[7] = v179;
              unint64_t v180 = (double *)*((void *)v169 + 1);
              if (v180)
              {
                do
                {
                  uint64_t v181 = v180;
                  unint64_t v180 = *(double **)v180;
                }
                while (v180);
              }
              else
              {
                do
                {
                  uint64_t v181 = (double *)*((void *)v169 + 2);
                  BOOL v156 = *(void *)v181 == (void)v169;
                  uint64_t v169 = v181;
                }
                while (!v156);
              }
              uint64_t v169 = v181;
            }
            while (v181 != (double *)((char *)&v202 + 8));
          }
          else
          {
            double v175 = 1.0 / v170;
            do
            {
              v169[7] = v169[7] * v175;
              std::string::size_type v176 = (double *)*((void *)v169 + 1);
              if (v176)
              {
                do
                {
                  int v177 = v176;
                  std::string::size_type v176 = *(double **)v176;
                }
                while (v176);
              }
              else
              {
                do
                {
                  int v177 = (double *)*((void *)v169 + 2);
                  BOOL v156 = *(void *)v177 == (void)v169;
                  uint64_t v169 = v177;
                }
                while (!v156);
              }
              uint64_t v169 = v177;
            }
            while (v177 != (double *)((char *)&v202 + 8));
          }
        }
      }
    }
    sub_19E3CD3E0(*(char **)(a3 + 8));
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = v193;
    unint64_t v182 = (void **)__p[0];
    if (__p[0] != &__p[1])
    {
      do
      {
        double v183 = *((double *)v182 + 7);
        double v184 = *((double *)sub_19E3CD25C((uint64_t **)&v202, (const void **)v182 + 4, (uint64_t)(v182 + 4)) + 7);
        *((double *)sub_19E3CD25C((uint64_t **)a3, (const void **)v182 + 4, (uint64_t)(v182 + 4)) + 7) = v183 * 0.8 + v184 * 0.2;
        uint64_t v185 = (void **)v182[1];
        if (v185)
        {
          do
          {
            unint64_t v186 = v185;
            uint64_t v185 = (void **)*v185;
          }
          while (v185);
        }
        else
        {
          do
          {
            unint64_t v186 = (void **)v182[2];
            BOOL v156 = *v186 == v182;
            unint64_t v182 = v186;
          }
          while (!v156);
        }
        unint64_t v182 = v186;
      }
      while (v186 != &__p[1]);
    }
    sub_19E3CD3E0(*((char **)&v202 + 1));
  }
  sub_19E3CD3E0(*((char **)&v204 + 1));
  sub_19E3CD3E0((char *)__p[1]);
}

void sub_19E3F8E90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, char *a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char *a30)
{
}

uint64_t **sub_19E3F8F38(uint64_t **result, uint64_t a2)
{
  char v2 = result + 1;
  unint64_t v3 = *result;
  if (*result == (uint64_t *)(result + 1)) {
    return result;
  }
  int v5 = 0;
  uint64_t v6 = *result;
  do
  {
    uint64_t v7 = (void *)v6[1];
    uint64_t v8 = v6;
    if (v7)
    {
      do
      {
        uint64_t v9 = v7;
        uint64_t v7 = (void *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        uint64_t v9 = (void *)v8[2];
        BOOL v10 = *v9 == (void)v8;
        uint64_t v8 = v9;
      }
      while (!v10);
    }
    v5 += *((_DWORD *)v6 + 14);
    uint64_t v6 = v9;
  }
  while (v9 != v2);
  if (v5 < 1) {
    return result;
  }
  unint64_t v11 = *(void *)(a2 + 16);
  if (!v11)
  {
    double v31 = 1.0 / (double)v5;
    do
    {
      int v32 = *((_DWORD *)v3 + 14);
      if (v32 >= 2001)
      {
        double v33 = (double)v32 * v31;
        if (v33 > 0.05)
        {
          uint64_t result = sub_19E3CD25C((uint64_t **)a2, (const void **)v3 + 4, (uint64_t)(v3 + 4));
          *((double *)result + 7) = v33;
        }
      }
      int64_t v34 = (void *)v3[1];
      if (v34)
      {
        do
        {
          size_t v35 = v34;
          int64_t v34 = (void *)*v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          size_t v35 = (void *)v3[2];
          BOOL v10 = *v35 == (void)v3;
          unint64_t v3 = v35;
        }
        while (!v10);
      }
      unint64_t v3 = v35;
    }
    while (v35 != v2);
    unint64_t v11 = *(void *)(a2 + 16);
    if (!v11) {
      return result;
    }
LABEL_73:
    uint64_t v38 = *(uint64_t **)a2;
    unint64_t v37 = (uint64_t *)(a2 + 8);
    size_t v36 = v38;
    if (v38 != v37)
    {
      double v39 = 0.0;
      uint64_t v40 = v36;
      do
      {
        size_t v41 = (uint64_t *)v40[1];
        uint64_t v42 = v40;
        if (v41)
        {
          do
          {
            uint64_t v43 = v41;
            size_t v41 = (uint64_t *)*v41;
          }
          while (v41);
        }
        else
        {
          do
          {
            uint64_t v43 = (uint64_t *)v42[2];
            BOOL v10 = *v43 == (void)v42;
            uint64_t v42 = v43;
          }
          while (!v10);
        }
        double v39 = *((double *)v40 + 7) + v39;
        uint64_t v40 = v43;
      }
      while (v43 != v37);
      if (v39 <= 0.0)
      {
        do
        {
          *((double *)v36 + 7) = 1.0 / (double)v11;
          long long v47 = (uint64_t *)v36[1];
          if (v47)
          {
            do
            {
              uint64_t v48 = v47;
              long long v47 = (uint64_t *)*v47;
            }
            while (v47);
          }
          else
          {
            do
            {
              uint64_t v48 = (uint64_t *)v36[2];
              BOOL v10 = *v48 == (void)v36;
              size_t v36 = v48;
            }
            while (!v10);
          }
          size_t v36 = v48;
        }
        while (v48 != v37);
      }
      else
      {
        double v44 = 1.0 / v39;
        do
        {
          *((double *)v36 + 7) = *((double *)v36 + 7) * v44;
          uint64_t v45 = (uint64_t *)v36[1];
          if (v45)
          {
            do
            {
              int v46 = v45;
              uint64_t v45 = (uint64_t *)*v45;
            }
            while (v45);
          }
          else
          {
            do
            {
              int v46 = (uint64_t *)v36[2];
              BOOL v10 = *v46 == (void)v36;
              size_t v36 = v46;
            }
            while (!v10);
          }
          size_t v36 = v46;
        }
        while (v46 != v37);
      }
    }
    return result;
  }
  char v12 = (uint64_t *)(a2 + 8);
  uint64_t v13 = *(uint64_t **)a2;
  if (*(void *)a2 == a2 + 8) {
    goto LABEL_73;
  }
  unint64_t v49 = *(void *)(a2 + 16);
  size_t v14 = (uint64_t *)*v2;
  double v15 = 1.0 / (double)v5;
  while (2)
  {
    if (!v14) {
      goto LABEL_51;
    }
    char v16 = *((unsigned char *)v13 + 55);
    if (v16 >= 0) {
      size_t v17 = v13 + 4;
    }
    else {
      size_t v17 = (const void *)v13[4];
    }
    if (v16 >= 0) {
      size_t v18 = *((unsigned __int8 *)v13 + 55);
    }
    else {
      size_t v18 = v13[5];
    }
    int v19 = v2;
    uint64_t v20 = v14;
    do
    {
      while (1)
      {
        int v21 = *((char *)v20 + 55);
        uint64_t v22 = v21 >= 0 ? v20 + 4 : (uint64_t *)v20[4];
        size_t v23 = v21 >= 0 ? *((unsigned __int8 *)v20 + 55) : v20[5];
        size_t v24 = v18 >= v23 ? v23 : v18;
        uint64_t result = (uint64_t **)memcmp(v22, v17, v24);
        if (result) {
          break;
        }
        if (v23 >= v18) {
          goto LABEL_37;
        }
LABEL_23:
        uint64_t v20 = (uint64_t *)v20[1];
        if (!v20) {
          goto LABEL_38;
        }
      }
      if ((result & 0x80000000) != 0) {
        goto LABEL_23;
      }
LABEL_37:
      int v19 = v20;
      uint64_t v20 = (uint64_t *)*v20;
    }
    while (v20);
LABEL_38:
    if (v19 != v2)
    {
      int v25 = *((char *)v19 + 55);
      if (v25 >= 0) {
        int v26 = v19 + 4;
      }
      else {
        int v26 = (const void *)v19[4];
      }
      if (v25 >= 0) {
        size_t v27 = *((unsigned __int8 *)v19 + 55);
      }
      else {
        size_t v27 = v19[5];
      }
      if (v27 >= v18) {
        size_t v28 = v18;
      }
      else {
        size_t v28 = v27;
      }
      uint64_t result = (uint64_t **)memcmp(v17, v26, v28);
      if (result)
      {
        if ((result & 0x80000000) == 0) {
          goto LABEL_50;
        }
      }
      else if (v18 >= v27)
      {
LABEL_50:
        *((double *)v13 + 7) = (double)*((int *)v19 + 14) * v15;
      }
    }
LABEL_51:
    size_t v29 = (uint64_t *)v13[1];
    if (v29)
    {
      do
      {
        int v30 = v29;
        size_t v29 = (uint64_t *)*v29;
      }
      while (v29);
    }
    else
    {
      do
      {
        int v30 = (uint64_t *)v13[2];
        BOOL v10 = *v30 == (void)v13;
        uint64_t v13 = v30;
      }
      while (!v10);
    }
    uint64_t v13 = v30;
    if (v30 != v12) {
      continue;
    }
    break;
  }
  unint64_t v11 = v49;
  if (v49) {
    goto LABEL_73;
  }
  return result;
}

uint64_t sub_19E3F92F4(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = *(void *)(a1 + 32);
  if (v5 >= v4)
  {
    uint64_t v7 = *(void *)(a1 + 24);
    uint64_t v8 = (uint64_t)(v5 - v7) >> 5;
    if ((unint64_t)(v8 + 1) >> 59) {
      sub_19E37C7C4();
    }
    uint64_t v9 = v4 - v7;
    uint64_t v10 = v9 >> 4;
    if (v9 >> 4 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11)
    {
      if (v11 >> 59) {
        sub_19E37C2B8();
      }
      char v12 = (char *)operator new(32 * v11);
    }
    else
    {
      char v12 = 0;
    }
    int v21 = &v12[32 * v8];
    uint64_t v22 = &v12[32 * v11];
    sub_19E371C70(v21, (const UInt8 *)a2);
    *((_DWORD *)v21 + 6) = *(_DWORD *)(a2 + 24);
    uint64_t v13 = v21;
    uint64_t v6 = v21 + 32;
    size_t v14 = *(void ***)(a1 + 24);
    double v15 = *(void ***)(a1 + 32);
    if (v15 == v14)
    {
      *(void *)(a1 + 24) = v21;
      *(void *)(a1 + 32) = v6;
      *(void *)(a1 + 40) = v22;
    }
    else
    {
      do
      {
        long long v16 = *((_OWORD *)v15 - 2);
        *((void *)v13 - 2) = *(v15 - 2);
        *((_OWORD *)v13 - 2) = v16;
        *(v15 - 3) = 0;
        *(v15 - 2) = 0;
        *(v15 - 4) = 0;
        *((_DWORD *)v13 - 2) = *((_DWORD *)v15 - 2);
        v13 -= 32;
        v15 -= 4;
      }
      while (v15 != v14);
      double v15 = *(void ***)(a1 + 24);
      size_t v17 = *(void ***)(a1 + 32);
      *(void *)(a1 + 24) = v13;
      *(void *)(a1 + 32) = v6;
      *(void *)(a1 + 40) = v22;
      while (v17 != v15)
      {
        if (*((char *)v17 - 9) < 0) {
          operator delete(*(v17 - 4));
        }
        v17 -= 4;
      }
    }
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    sub_19E371C70(*(void **)(a1 + 32), (const UInt8 *)a2);
    *(_DWORD *)(v5 + 24) = *(_DWORD *)(a2 + 24);
    uint64_t v6 = (char *)(v5 + 32);
    *(void *)(a1 + 32) = v5 + 32;
  }
  *(void *)(a1 + 32) = v6;
  unint64_t v18 = *(void *)(a1 + 8);
  if (v18 >= *(void *)(a1 + 16))
  {
    uint64_t result = sub_19E3F94FC((char **)a1, a2);
  }
  else
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_19E39369C(*(unsigned char **)(a1 + 8), *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v19 = *(_OWORD *)a2;
      *(void *)(v18 + 16) = *(void *)(a2 + 16);
      *(_OWORD *)unint64_t v18 = v19;
    }
    *(_DWORD *)(v18 + 24) = *(_DWORD *)(a2 + 24);
    uint64_t result = v18 + 32;
    *(void *)(a1 + 8) = v18 + 32;
  }
  *(void *)(a1 + 8) = result;
  return result;
}

void sub_19E3F94D8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_19E3F94E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3EB870((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E3F94F4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 32) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_19E3F94FC(char **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  uint64_t v4 = (v3 - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    sub_19E37C7C4();
  }
  uint64_t v8 = a1[2] - v2;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 59) {
      sub_19E37C2B8();
    }
    uint64_t v10 = operator new(32 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  unint64_t v11 = (char *)&v10[8 * v4];
  size_t v17 = (char *)&v10[8 * v9];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E39369C(v11, *(void **)a2, *(void *)(a2 + 8));
    uint64_t v2 = *a1;
    unint64_t v3 = a1[1];
    unint64_t v11 = (char *)&v10[8 * v4];
  }
  else
  {
    *(_OWORD *)unint64_t v11 = *(_OWORD *)a2;
    *((void *)v11 + 2) = *(void *)(a2 + 16);
  }
  v10[8 * v4 + 6] = *(_DWORD *)(a2 + 24);
  uint64_t v12 = (uint64_t)&v10[8 * v4 + 8];
  if (v3 == v2)
  {
    size_t v14 = v2;
  }
  else
  {
    do
    {
      long long v13 = *((_OWORD *)v3 - 2);
      *((void *)v11 - 2) = *((void *)v3 - 2);
      *((_OWORD *)v11 - 2) = v13;
      *((void *)v3 - 3) = 0;
      *((void *)v3 - 2) = 0;
      *((void *)v3 - 4) = 0;
      *((_DWORD *)v11 - 2) = *((_DWORD *)v3 - 2);
      v11 -= 32;
      v3 -= 32;
    }
    while (v3 != v2);
    size_t v14 = *a1;
    uint64_t v2 = a1[1];
  }
  *a1 = v11;
  a1[1] = (char *)v12;
  a1[2] = v17;
  if (v2 != v14)
  {
    double v15 = (void **)(v2 - 32);
    do
    {
      if (*((char *)v15 + 23) < 0) {
        operator delete(*v15);
      }
      v15 -= 4;
    }
    while (v15 + 4 != (void **)v14);
    uint64_t v2 = v14;
  }
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

void sub_19E3F96A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3EB870((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E3F96BC(void *a1)
{
  uint64_t v1 = a1[1];
  uint64_t v2 = a1[4];
  if (v1 - *a1 != v2 - a1[3]) {
    __assert_rtn("pop_back", "LinguisticContextImpl.cpp", 22, "m_tokens.size() == m_sanitizedTokens.size()");
  }
  uint64_t v4 = (void **)(v1 - 32);
  if (*(char *)(v1 - 9) < 0)
  {
    operator delete(*v4);
    uint64_t v2 = a1[4];
  }
  a1[1] = v4;
  unint64_t v5 = (void **)(v2 - 32);
  if (*(char *)(v2 - 9) < 0) {
    operator delete(*v5);
  }
  a1[4] = v5;
  uint64_t v6 = a1 + 8;
  while (1)
  {
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      break;
    }
    uint64_t v7 = v6[3];
    uint64_t v8 = v6[4];
    unint64_t v9 = (v8 - v7) >> 2;
    unint64_t v10 = (uint64_t)(a1[1] - *a1) >> 5;
    if (v9 > v10)
    {
      v6[4] = v8 - 4;
      unint64_t v9 = (v8 - 4 - v7) >> 2;
    }
    if (v9 > v10) {
      __assert_rtn("pop_back", "LinguisticContextImpl.cpp", 28, "cache.size() <= m_tokens.size()");
    }
  }
  unint64_t v11 = a1 + 13;
  while (1)
  {
    unint64_t v11 = (void *)*v11;
    if (!v11) {
      break;
    }
    uint64_t v13 = v11[3];
    uint64_t v14 = v11[4];
    unint64_t v12 = (v14 - v13) >> 3;
    unint64_t v15 = (uint64_t)(a1[1] - *a1) >> 5;
    if (v12 > v15)
    {
      unint64_t v18 = *(const void **)(v14 - 8);
      uint64_t v17 = v14 - 8;
      long long v16 = v18;
      if (v18)
      {
        CFRelease(v16);
        uint64_t v13 = v11[3];
        unint64_t v15 = (uint64_t)(a1[1] - *a1) >> 5;
      }
      v11[4] = v17;
      unint64_t v12 = (v17 - v13) >> 3;
    }
    if (v12 > v15) {
      __assert_rtn("pop_back", "LinguisticContextImpl.cpp", 33, "wordCache.size() <= m_tokens.size()");
    }
  }
  if (a1[19] != a1[24]) {
    __assert_rtn("pop_back", "LinguisticContextImpl.cpp", 36, "m_fragmentCaches.size() == m_cumulativeFragmentCounts.size()");
  }
  long long v19 = a1 + 18;
  while (1)
  {
    long long v19 = (void *)*v19;
    if (!v19) {
      break;
    }
    int v21 = sub_19E3F996C((uint64_t)(a1 + 21), *((_DWORD *)v19 + 4), (_DWORD *)v19 + 4);
    uint64_t v22 = v21[3];
    uint64_t v23 = v21[4];
    unint64_t v24 = (uint64_t)(a1[1] - *a1) >> 5;
    if (v24 >= (v23 - v22) >> 3)
    {
      uint64_t v20 = v21[4];
    }
    else
    {
      int v25 = v21;
      uint64_t v20 = v23 - 8;
      v21[4] = v23 - 8;
      if (v22 == v23 - 8)
      {
        unint64_t v26 = 0;
        size_t v27 = v19 + 4;
        uint64_t v28 = v19[3];
        unint64_t v29 = (v19[4] - v28) >> 2;
      }
      else
      {
        unint64_t v26 = *(void *)(v23 - 16);
        size_t v27 = v19 + 4;
        uint64_t v28 = v19[3];
        unint64_t v29 = (v19[4] - v28) >> 2;
        if (v26 > v29)
        {
          sub_19E3F9C70((uint64_t)(v19 + 3), v26 - v29);
          uint64_t v22 = v25[3];
          uint64_t v20 = v25[4];
          unint64_t v24 = (uint64_t)(a1[1] - *a1) >> 5;
          goto LABEL_21;
        }
      }
      if (v29 > v26) {
        *size_t v27 = v28 + 4 * v26;
      }
    }
LABEL_21:
    if (v24 < (v20 - v22) >> 3) {
      __assert_rtn("pop_back", "LinguisticContextImpl.cpp", 44, "counts.size() <= m_tokens.size()");
    }
  }
}

void *sub_19E3F996C(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = (void *)(a1 + 16);
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v6 = v3;
  }
  else
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_35:
      }
        sub_19E3CEFD8(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        v6 %= v7;
      }
    }
    else
    {
      unint64_t v6 = (v7 - 1) & v6;
    }
  }
  uint64_t v23 = *(void *)a1;
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v6);
  if (v24)
  {
    *unint64_t v10 = *v24;
LABEL_58:
    *unint64_t v24 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *v13;
  void *v13 = v10;
  *(void *)(v23 + 8 * v6) = v13;
  if (*v10)
  {
    unint64_t v25 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    unint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_19E3F9C5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3CF17C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E3F9C70(uint64_t a1, unint64_t a2)
{
  unint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  unint64_t v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 2)
  {
    if (a2)
    {
      bzero(v5, 4 * a2);
      unint64_t v6 = &v5[4 * a2];
    }
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    unint64_t v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v9 = v8 >> 2;
    unint64_t v10 = (v8 >> 2) + a2;
    if (v10 >> 62) {
      sub_19E37C7C4();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        sub_19E37C2B8();
      }
      uint64_t v13 = operator new(4 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    float v14 = &v13[4 * v9];
    size_t v15 = 4 * a2;
    BOOL v16 = &v13[4 * v12];
    bzero(v14, v15);
    unint64_t v17 = &v14[v15];
    if (v5 != v7)
    {
      unint64_t v18 = v5 - v7 - 4;
      if (v18 < 0x2C) {
        goto LABEL_31;
      }
      if ((unint64_t)(v5 - v13 - v8) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v19 = (v18 >> 2) + 1;
      unint64_t v6 = &v5[-4 * (v19 & 0x7FFFFFFFFFFFFFF8)];
      unint64_t v20 = &v13[4 * v9 - 16];
      uint8x8_t v21 = v5 - 16;
      uint64_t v22 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        *unint64_t v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 8;
      }
      while (v22);
      v14 -= 4 * (v19 & 0x7FFFFFFFFFFFFFF8);
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_31:
        do
        {
          int v24 = *((_DWORD *)v6 - 1);
          v6 -= 4;
          *((_DWORD *)v14 - 1) = v24;
          v14 -= 4;
        }
        while (v6 != v7);
      }
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v17;
    *(void *)(a1 + 16) = v16;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void sub_19E3F9E24(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v46 = a2;
  uint64_t v6 = *(void *)(a1 + 24);
  unint64_t v7 = (*(void *)(a1 + 32) - v6) >> 5;
  uint64_t v8 = sub_19E3FA0C4(a1 + 48, a2, &v46);
  uint64_t v9 = sub_19E3FA3C8(a1 + 88, a2, &v46);
  uint64_t v11 = v9 + 3;
  uint64_t v10 = v9[3];
  uint64_t v12 = v9[4];
  unint64_t v13 = (v12 - v10) >> 3;
  uint64_t v45 = v9 + 3;
  if (v7 <= v13)
  {
    if (v7 < v13)
    {
      float v14 = v9;
      uint64_t v15 = v10 + 8 * v7;
      while (v12 != v15)
      {
        unint64_t v17 = *(const void **)(v12 - 8);
        v12 -= 8;
        BOOL v16 = v17;
        if (v17) {
          CFRelease(v16);
        }
      }
      v14[4] = v15;
      uint64_t v11 = v45;
    }
  }
  else
  {
    sub_19E3FA6CC((uint64_t)(v9 + 3), v7 - v13);
  }
  unint64_t v18 = (uint64_t)(v8[4] - v8[3]) >> 2;
  if (v18 < v7)
  {
    uint64_t v19 = (void **)(v8 + 3);
    unint64_t v43 = v7;
    uint64_t v44 = v6;
    while (1)
    {
      uint64_t v21 = *(void *)(a3 + 24);
      if (!v21) {
        sub_19E3ACB9C();
      }
      int v22 = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, void **))(*(void *)v21 + 48))(v21, v6 + 32 * v18, *v11 + 8 * v18, v19);
      int v23 = v22;
      unint64_t v25 = (char *)v8[4];
      unint64_t v24 = v8[5];
      if ((unint64_t)v25 >= v24) {
        break;
      }
      *(_DWORD *)unint64_t v25 = v22;
      unint64_t v20 = v25 + 4;
LABEL_12:
      v8[4] = v20;
      ++v18;
      uint64_t v19 = (void **)(v8 + 3);
      if (v18 == v7) {
        return;
      }
    }
    uint64_t v26 = a3;
    size_t v27 = (char *)*v19;
    uint64_t v28 = v25 - (unsigned char *)*v19;
    uint64_t v29 = v28 >> 2;
    unint64_t v30 = (v28 >> 2) + 1;
    if (v30 >> 62) {
      sub_19E37C7C4();
    }
    uint64_t v31 = v24 - (void)v27;
    if (v31 >> 1 > v30) {
      unint64_t v30 = v31 >> 1;
    }
    if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32)
    {
      if (v32 >> 62) {
        sub_19E37C2B8();
      }
      double v33 = operator new(4 * v32);
    }
    else
    {
      double v33 = 0;
    }
    int64_t v34 = &v33[4 * v29];
    *int64_t v34 = v23;
    unint64_t v20 = v34 + 1;
    if (v25 == v27)
    {
      uint64_t v11 = v45;
      goto LABEL_34;
    }
    unint64_t v35 = v25 - 4 - v27;
    if (v35 >= 0x2C)
    {
      unint64_t v36 = v25 - &v33[v28];
      uint64_t v11 = v45;
      if (v36 >= 0x20)
      {
        uint64_t v37 = (v35 >> 2) + 1;
        uint64_t v38 = &v33[4 * v29 - 16];
        double v39 = v25 - 16;
        uint64_t v40 = v37 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v41 = *(_OWORD *)v39;
          *(v38 - 1) = *((_OWORD *)v39 - 1);
          *uint64_t v38 = v41;
          v38 -= 2;
          v39 -= 32;
          v40 -= 8;
        }
        while (v40);
        v34 -= v37 & 0x7FFFFFFFFFFFFFF8;
        v25 -= 4 * (v37 & 0x7FFFFFFFFFFFFFF8);
        if (v37 == (v37 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_34:
          v8[3] = v34;
          v8[4] = v20;
          v8[5] = &v33[4 * v32];
          if (v27) {
            operator delete(v27);
          }
          a3 = v26;
          unint64_t v7 = v43;
          uint64_t v6 = v44;
          goto LABEL_12;
        }
      }
    }
    else
    {
      uint64_t v11 = v45;
    }
    do
    {
      int v42 = *((_DWORD *)v25 - 1);
      v25 -= 4;
      *--int64_t v34 = v42;
    }
    while (v25 != v27);
    goto LABEL_34;
  }
}

void *sub_19E3FA0C4(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v13 = (void *)(a1 + 16);
  uint64_t v10 = operator new(0x30uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v6 = v3;
  }
  else
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_35:
      }
        sub_19E3CEFD8(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        v6 %= v7;
      }
    }
    else
    {
      unint64_t v6 = (v7 - 1) & v6;
    }
  }
  uint64_t v23 = *(void *)a1;
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v6);
  if (v24)
  {
    *uint64_t v10 = *v24;
LABEL_58:
    *unint64_t v24 = v10;
    goto LABEL_59;
  }
  *uint64_t v10 = *v13;
  void *v13 = v10;
  *(void *)(v23 + 8 * v6) = v13;
  if (*v10)
  {
    unint64_t v25 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    unint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_19E3FA3B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3CF17C((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_19E3FA3C8(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v13 = (void *)(a1 + 16);
  uint64_t v10 = operator new(0x30uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v6 = v3;
  }
  else
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_35:
      }
        sub_19E3CEFD8(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        v6 %= v7;
      }
    }
    else
    {
      unint64_t v6 = (v7 - 1) & v6;
    }
  }
  uint64_t v23 = *(void *)a1;
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v6);
  if (v24)
  {
    *uint64_t v10 = *v24;
LABEL_58:
    *unint64_t v24 = v10;
    goto LABEL_59;
  }
  *uint64_t v10 = *v13;
  void *v13 = v10;
  *(void *)(v23 + 8 * v6) = v13;
  if (*v10)
  {
    unint64_t v25 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    unint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_19E3FA6B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3CF288((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E3FA6CC(uint64_t a1, unint64_t a2)
{
  unint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (a2 > (v4 - (uint64_t)v5) >> 3)
  {
    unint64_t v6 = *(char **)a1;
    uint64_t v7 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v8 = v7 >> 3;
    unint64_t v9 = (v7 >> 3) + a2;
    if (v9 >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v10 = v4 - (void)v6;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        sub_19E37C2B8();
      }
      uint64_t v12 = (char *)operator new(8 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    unint64_t v13 = &v12[8 * v8];
    size_t v14 = 8 * a2;
    float v15 = &v12[8 * v11];
    bzero(v13, v14);
    BOOL v16 = &v13[v14];
    if (v5 == v6)
    {
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v15;
      goto LABEL_29;
    }
    unint64_t v17 = v5 - v6 - 8;
    if (v17 > 0x77
      && (&v12[v7 - (v17 & 0xFFFFFFFFFFFFFFF8) - 8] >= v5 || &v5[-(v17 & 0xFFFFFFFFFFFFFFF8) - 8] >= v13))
    {
      uint64_t v18 = (v17 >> 3) + 1;
      v13 -= 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v19 = v5 - 32;
      unint64_t v20 = &v12[8 * v8 - 16];
      uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *((_OWORD *)v19 + 1);
        *((_OWORD *)v20 - 1) = *(_OWORD *)v19;
        *(_OWORD *)unint64_t v20 = v22;
        *(_OWORD *)uint64_t v19 = 0uLL;
        *((_OWORD *)v19 + 1) = 0uLL;
        v19 -= 32;
        v20 -= 32;
        v21 -= 4;
      }
      while (v21);
      if (v18 == (v18 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_24;
      }
      v5 -= 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
    }
    do
    {
      uint64_t v23 = *((void *)v5 - 1);
      v5 -= 8;
      *((void *)v13 - 1) = v23;
      v13 -= 8;
      *(void *)unint64_t v5 = 0;
    }
    while (v5 != v6);
LABEL_24:
    unint64_t v5 = *(char **)a1;
    unint64_t v24 = *(char **)(a1 + 8);
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = v16;
    *(void *)(a1 + 16) = v15;
    while (v24 != v5)
    {
      uint64_t v26 = (const void *)*((void *)v24 - 1);
      v24 -= 8;
      unint64_t v25 = v26;
      if (v26) {
        CFRelease(v25);
      }
    }
LABEL_29:
    if (v5)
    {
      operator delete(v5);
    }
    return;
  }
  if (a2)
  {
    bzero(*(void **)(a1 + 8), 8 * a2);
    v5 += 8 * a2;
  }
  *(void *)(a1 + 8) = v5;
}

void sub_19E3FA8C0(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = a1;
  unsigned int v45 = a3;
  unsigned int v46 = a2;
  uint64_t v8 = *(void *)(a1 + 24);
  unint64_t v9 = (*(void *)(a1 + 32) - v8) >> 5;
  uint64_t v44 = sub_19E3FA3C8(a1 + 88, a2, &v46)[3];
  v7 += 48;
  uint64_t v10 = sub_19E3FA0C4(v7, a2, &v46);
  unint64_t v11 = sub_19E3FA0C4(v7, a3, &v45);
  int v42 = (void **)(v11 + 3);
  v11[4] = v11[3];
  uint64_t v12 = v10[3];
  unint64_t v13 = (v10[4] - v12) >> 2;
  if (v13 >= v9) {
    unint64_t v13 = v9;
  }
  if (v13)
  {
    size_t v14 = v11;
    unint64_t v15 = 0;
    unint64_t v40 = v9;
    uint64_t v41 = v8;
    while (1)
    {
      uint64_t v18 = *(void *)(a4 + 24);
      if (!v18) {
        sub_19E3ACB9C();
      }
      int v19 = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, unint64_t))(*(void *)v18 + 48))(v18, v8 + 32 * v15, v44 + 8 * v15, v12 + 4 * v15);
      int v20 = v19;
      long long v22 = (char *)v14[4];
      unint64_t v21 = v14[5];
      if ((unint64_t)v22 >= v21) {
        break;
      }
      *(_DWORD *)long long v22 = v19;
      BOOL v16 = v22 + 4;
LABEL_6:
      v14[4] = v16;
      ++v15;
      uint64_t v12 = v10[3];
      unint64_t v17 = (v10[4] - v12) >> 2;
      if (v17 >= v9) {
        unint64_t v17 = v9;
      }
      if (v17 <= v15) {
        return;
      }
    }
    uint64_t v23 = v10;
    uint64_t v24 = a4;
    unint64_t v25 = (char *)*v42;
    uint64_t v26 = v22 - (unsigned char *)*v42;
    uint64_t v27 = v26 >> 2;
    unint64_t v28 = (v26 >> 2) + 1;
    if (v28 >> 62) {
      sub_19E37C7C4();
    }
    uint64_t v29 = v21 - (void)v25;
    if (v29 >> 1 > v28) {
      unint64_t v28 = v29 >> 1;
    }
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v28 = 0x3FFFFFFFFFFFFFFFLL;
    }
    unint64_t v43 = v28;
    if (v28)
    {
      if (v28 >> 62) {
        sub_19E37C2B8();
      }
      unint64_t v30 = operator new(4 * v28);
    }
    else
    {
      unint64_t v30 = 0;
    }
    uint64_t v31 = &v30[4 * v27];
    *uint64_t v31 = v20;
    BOOL v16 = v31 + 1;
    if (v22 == v25)
    {
      a4 = v24;
      uint64_t v10 = v23;
    }
    else
    {
      unint64_t v32 = v22 - 4 - v25;
      if (v32 >= 0x2C)
      {
        unint64_t v33 = v22 - &v30[v26];
        a4 = v24;
        uint64_t v10 = v23;
        if (v33 >= 0x20)
        {
          uint64_t v34 = (v32 >> 2) + 1;
          unint64_t v35 = &v30[4 * v27 - 16];
          unint64_t v36 = v22 - 16;
          uint64_t v37 = v34 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v38 = *(_OWORD *)v36;
            *(v35 - 1) = *((_OWORD *)v36 - 1);
            *unint64_t v35 = v38;
            v35 -= 2;
            v36 -= 32;
            v37 -= 8;
          }
          while (v37);
          v31 -= v34 & 0x7FFFFFFFFFFFFFF8;
          v22 -= 4 * (v34 & 0x7FFFFFFFFFFFFFF8);
          if (v34 == (v34 & 0x7FFFFFFFFFFFFFF8)) {
            goto LABEL_29;
          }
        }
      }
      else
      {
        a4 = v24;
        uint64_t v10 = v23;
      }
      do
      {
        int v39 = *((_DWORD *)v22 - 1);
        v22 -= 4;
        *--uint64_t v31 = v39;
      }
      while (v22 != v25);
    }
LABEL_29:
    v14[3] = v31;
    v14[4] = v16;
    v14[5] = &v30[4 * v43];
    if (v25) {
      operator delete(v25);
    }
    unint64_t v9 = v40;
    uint64_t v8 = v41;
    goto LABEL_6;
  }
}

void sub_19E3FAB60(uint64_t a1, unint64_t a2)
{
  unint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  unint64_t v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 3)
  {
    if (a2)
    {
      bzero(v5, 8 * a2);
      unint64_t v6 = &v5[8 * a2];
    }
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    uint64_t v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v9 = v8 >> 3;
    unint64_t v10 = (v8 >> 3) + a2;
    if (v10 >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        sub_19E37C2B8();
      }
      unint64_t v13 = operator new(8 * v12);
    }
    else
    {
      unint64_t v13 = 0;
    }
    size_t v14 = &v13[8 * v9];
    size_t v15 = 8 * a2;
    BOOL v16 = &v13[8 * v12];
    bzero(v14, v15);
    unint64_t v17 = &v14[v15];
    if (v5 != v7)
    {
      unint64_t v18 = v5 - v7 - 8;
      if (v18 < 0x58) {
        goto LABEL_31;
      }
      if ((unint64_t)(v5 - v13 - v8) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v19 = (v18 >> 3) + 1;
      unint64_t v6 = &v5[-8 * (v19 & 0x3FFFFFFFFFFFFFFCLL)];
      int v20 = &v13[8 * v9 - 16];
      unint64_t v21 = v5 - 16;
      uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        *int v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 4;
      }
      while (v22);
      v14 -= 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_31:
        do
        {
          uint64_t v24 = *((void *)v6 - 1);
          v6 -= 8;
          *((void *)v14 - 1) = v24;
          v14 -= 8;
        }
        while (v6 != v7);
      }
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v17;
    *(void *)(a1 + 16) = v16;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

uint64_t *sub_19E3FAD14(void *a1, uint64_t a2)
{
  uint64_t v2 = (unsigned char *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v5 = v4;
  }
  unint64_t v6 = sub_19E37BDA4((uint64_t)&v25, (uint64_t *)a2, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (v7)
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *(void *)&v7) {
        unint64_t v10 = v6 % *(void *)&v7;
      }
    }
    else
    {
      unint64_t v10 = (*(void *)&v7 - 1) & v6;
    }
    uint64_t v11 = *(uint64_t ***)(*a1 + 8 * v10);
    if (v11)
    {
      unint64_t v12 = *v11;
      if (*v11)
      {
        char v13 = v2[23];
        if (v13 >= 0) {
          uint64_t v14 = v2[23];
        }
        else {
          uint64_t v14 = *((void *)v2 + 1);
        }
        if (v13 < 0) {
          uint64_t v2 = *(unsigned char **)v2;
        }
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v15 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v21 = v12[1];
            if (v21 == v8)
            {
              uint64_t v22 = *((unsigned __int8 *)v12 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v23 = v12[3];
              }
              if (v23 == v14)
              {
                if ((v22 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v2, v12[3])) {
                    return v12;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    return v12;
                  }
                  uint64_t v24 = 0;
                  while (*((unsigned __int8 *)v12 + v24 + 16) == v2[v24])
                  {
                    if (v22 == ++v24) {
                      return v12;
                    }
                  }
                }
              }
            }
            else if ((v21 & v15) != v10)
            {
              return 0;
            }
            uint64_t result = 0;
            unint64_t v12 = (uint64_t *)*v12;
            if (!v12) {
              return result;
            }
          }
        }
        while (1)
        {
          unint64_t v17 = v12[1];
          if (v17 == v8)
          {
            uint64_t v18 = *((unsigned __int8 *)v12 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v19 = v12[3];
            }
            if (v19 == v14)
            {
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v2, v12[3])) {
                  return v12;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  return v12;
                }
                uint64_t v20 = 0;
                while (*((unsigned __int8 *)v12 + v20 + 16) == v2[v20])
                {
                  if (v18 == ++v20) {
                    return v12;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= *(void *)&v7) {
              v17 %= *(void *)&v7;
            }
            if (v17 != v10) {
              return 0;
            }
          }
          uint64_t result = 0;
          unint64_t v12 = (uint64_t *)*v12;
          if (!v12) {
            return result;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t *sub_19E3FAF14(uint64_t a1, uint64_t a2, long long **a3)
{
  unint64_t v5 = (unsigned char *)a2;
  unint64_t v7 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v8 = v7;
  }
  unint64_t v9 = sub_19E37BDA4((uint64_t)v42, (uint64_t *)a2, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    char v13 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        char v15 = v5[23];
        if (v15 >= 0) {
          uint64_t v16 = v5[23];
        }
        else {
          uint64_t v16 = *((void *)v5 + 1);
        }
        if (v15 < 0) {
          unint64_t v5 = *(unsigned char **)v5;
        }
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v21 = v14[1];
            if (v21 == v10)
            {
              uint64_t v22 = *((unsigned __int8 *)v14 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = *((unsigned __int8 *)v14 + 39);
              }
              else {
                uint64_t v23 = v14[3];
              }
              if (v23 == v16)
              {
                if ((v22 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v14[2], v5, v14[3])) {
                    return v14;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v14 + 39)) {
                    return v14;
                  }
                  uint64_t v24 = 0;
                  while (*((unsigned __int8 *)v14 + v24 + 16) == v5[v24])
                  {
                    if (v22 == ++v24) {
                      return v14;
                    }
                  }
                }
              }
            }
            else if ((v21 & (v11 - 1)) != v3)
            {
              goto LABEL_51;
            }
            uint64_t v14 = (uint64_t *)*v14;
            if (!v14) {
              goto LABEL_51;
            }
          }
        }
        do
        {
          unint64_t v17 = v14[1];
          if (v17 == v10)
          {
            uint64_t v18 = *((unsigned __int8 *)v14 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v14 + 39);
            }
            else {
              uint64_t v19 = v14[3];
            }
            if (v19 == v16)
            {
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp((const void *)v14[2], v5, v14[3])) {
                  return v14;
                }
              }
              else
              {
                if (!*((unsigned char *)v14 + 39)) {
                  return v14;
                }
                uint64_t v20 = 0;
                while (*((unsigned __int8 *)v14 + v20 + 16) == v5[v20])
                {
                  if (v18 == ++v20) {
                    return v14;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= v11) {
              v17 %= v11;
            }
            if (v17 != v3) {
              break;
            }
          }
          uint64_t v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_51:
  char v25 = (char *)operator new(0x30uLL);
  v42[0] = v25;
  v42[1] = a1 + 16;
  char v43 = 0;
  *(void *)char v25 = 0;
  *((void *)v25 + 1) = v10;
  uint64_t v26 = v25 + 16;
  uint64_t v27 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    sub_19E39369C(v26, *(void **)v27, *((void *)v27 + 1));
  }
  else
  {
    long long v28 = *v27;
    *((void *)v25 + 4) = *((void *)v27 + 2);
    *(_OWORD *)uint64_t v26 = v28;
  }
  *((_DWORD *)v25 + 10) = 0;
  char v43 = 1;
  float v29 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v30 = *(float *)(a1 + 32);
  if (!v11 || (float)(v30 * (float)v11) < v29)
  {
    BOOL v31 = 1;
    if (v11 >= 3) {
      BOOL v31 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v32 = v31 | (2 * v11);
    unint64_t v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33) {
      size_t prime = v33;
    }
    else {
      size_t prime = v32;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v35 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v35) {
      goto LABEL_66;
    }
    if (prime < *(void *)&v35)
    {
      unint64_t v36 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v35 < 3uLL || (uint8x8_t v37 = (uint8x8_t)vcnt_s8(v35), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }
      if (prime <= v36) {
        size_t prime = v36;
      }
      if (prime < *(void *)&v35) {
LABEL_66:
      }
        sub_19E3CEFD8(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v3 = v10 % v11;
      }
      else {
        unint64_t v3 = v10;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v10;
    }
  }
  int v39 = *(void **)(*(void *)a1 + 8 * v3);
  if (v39)
  {
    *(void *)v42[0] = *v39;
    *int v39 = v42[0];
  }
  else
  {
    *(void *)v42[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v42[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v42[0])
    {
      unint64_t v40 = *(void *)(*(void *)v42[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v40 >= v11) {
          v40 %= v11;
        }
      }
      else
      {
        v40 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v40) = v42[0];
    }
  }
  uint64_t v14 = (uint64_t *)v42[0];
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_19E3FB324(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3F0610((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E3FB340(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  __p[0] = 0;
  uint64_t v116 = 0;
  *(_OWORD *)std::string v115 = 0u;
  *(_OWORD *)int v114 = 0u;
  uint64_t v5 = *(void *)(a3 + 24);
  if (v5 != *(void *)(a3 + 32))
  {
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    unint64_t v9 = (void *)(a2 + 144);
    unint64_t v10 = 0;
    int v112 = (void *)(a2 + 144);
    while (1)
    {
      unint64_t v11 = sub_19E3FC044(v9, v5);
      if (!v11) {
        goto LABEL_4;
      }
      int v12 = *((_DWORD *)v11 + 10);
      if (v12 < 0) {
        goto LABEL_4;
      }
      if (v6 >= v8) {
        break;
      }
      *(_DWORD *)unint64_t v6 = v12;
      v6 += 4;
      unint64_t v10 = v6;
LABEL_4:
      v5 += 24;
      if (v5 == *(void *)(v3 + 32))
      {
        v114[1] = v10;
        v114[0] = v7;
        goto LABEL_33;
      }
    }
    uint64_t v13 = (v6 - v7) >> 2;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 62) {
      sub_19E37C7C4();
    }
    if ((v8 - v7) >> 1 > v14) {
      unint64_t v14 = (v8 - v7) >> 1;
    }
    if ((unint64_t)(v8 - v7) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15)
    {
      if (v15 >> 62) {
        sub_19E37C2B8();
      }
      uint64_t v16 = operator new(4 * v15);
    }
    else
    {
      uint64_t v16 = 0;
    }
    unint64_t v17 = &v16[4 * v13];
    *(_DWORD *)unint64_t v17 = v12;
    if (v6 == v7)
    {
      uint64_t v3 = a3;
      unint64_t v10 = v17 + 4;
      unint64_t v8 = &v16[4 * v15];
      if (!v7) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
    unint64_t v18 = v6 - 4 - v7;
    if (v18 >= 0x2C && (unint64_t)(v7 - v16) >= 0x20)
    {
      uint64_t v21 = (v18 >> 2) + 1;
      uint64_t v19 = &v6[-4 * (v21 & 0x7FFFFFFFFFFFFFF8)];
      uint64_t v22 = &v16[4 * v13 - 16];
      uint64_t v23 = v6 - 16;
      uint64_t v24 = v21 & 0x7FFFFFFFFFFFFFF8;
      unint64_t v10 = v17 + 4;
      do
      {
        long long v25 = *(_OWORD *)v23;
        *(v22 - 1) = *((_OWORD *)v23 - 1);
        *uint64_t v22 = v25;
        v22 -= 2;
        v23 -= 32;
        v24 -= 8;
      }
      while (v24);
      v17 -= 4 * (v21 & 0x7FFFFFFFFFFFFFF8);
      uint64_t v3 = a3;
      if (v21 == (v21 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_23:
        unint64_t v8 = &v16[4 * v15];
        if (!v7)
        {
LABEL_25:
          unint64_t v6 = v10;
          unint64_t v7 = v17;
          unint64_t v9 = v112;
          goto LABEL_4;
        }
LABEL_24:
        operator delete(v7);
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v19 = v6;
      uint64_t v3 = a3;
      unint64_t v10 = v17 + 4;
    }
    do
    {
      int v20 = *((_DWORD *)v19 - 1);
      v19 -= 4;
      *((_DWORD *)v17 - 1) = v20;
      v17 -= 4;
    }
    while (v19 != v7);
    goto LABEL_23;
  }
LABEL_33:
  uint64_t v26 = *(void *)(v3 + 48);
  if (v26 != *(void *)(v3 + 56))
  {
    uint64_t v27 = 0;
    long long v28 = 0;
    float v29 = 0;
    do
    {
      float v30 = sub_19E3FC044((void *)(a2 + 144), v26);
      if (v30)
      {
        int v31 = *((_DWORD *)v30 + 10);
        if ((v31 & 0x80000000) == 0)
        {
          uint64_t v32 = *(void *)(v26 + 24);
          if (v29 < v28)
          {
            *(_DWORD *)float v29 = v31;
            *((void *)v29 + 1) = v32;
            v29 += 16;
          }
          else
          {
            uint64_t v33 = (v29 - v27) >> 4;
            unint64_t v34 = v33 + 1;
            if ((unint64_t)(v33 + 1) >> 60) {
              sub_19E37C7C4();
            }
            if ((v28 - v27) >> 3 > v34) {
              unint64_t v34 = (v28 - v27) >> 3;
            }
            if ((unint64_t)(v28 - v27) >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v35 = v34;
            }
            if (v35)
            {
              if (v35 >> 60) {
                sub_19E37C2B8();
              }
              unint64_t v36 = (char *)operator new(16 * v35);
            }
            else
            {
              unint64_t v36 = 0;
            }
            uint8x8_t v37 = &v36[16 * v33];
            *(_DWORD *)uint8x8_t v37 = v31;
            *((void *)v37 + 1) = v32;
            if (v29 == v27)
            {
              int v39 = &v36[16 * v33];
            }
            else
            {
              uint64_t v38 = &v36[16 * v33];
              do
              {
                int v39 = v38 - 16;
                *((_OWORD *)v38 - 1) = *((_OWORD *)v29 - 1);
                v29 -= 16;
                v38 -= 16;
              }
              while (v29 != v27);
            }
            long long v28 = &v36[16 * v35];
            float v29 = v37 + 16;
            if (v27) {
              operator delete(v27);
            }
            uint64_t v27 = v39;
            uint64_t v3 = a3;
          }
        }
      }
      v26 += 32;
    }
    while (v26 != *(void *)(v3 + 56));
    uint64_t v116 = (int *)v29;
    v115[1] = v27;
  }
  uint64_t v40 = *(void *)(a2 + 424);
  if (!v40) {
    goto LABEL_101;
  }
  sub_19E3FB340(&v124, v40, v3);
  *(_OWORD *)std::string __p = v124;
  long long v41 = v124;
  uint64_t v118 = (uint64_t)v125;
  long long v124 = 0uLL;
  int v125 = 0;
  int v42 = (const void *)v41;
  int64_t v43 = *((void *)&v41 + 1) - v41;
  if (*((void *)&v41 + 1) == (void)v41)
  {
    uint64_t v44 = 0;
  }
  else
  {
    if (v43 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v44 = (char *)operator new(*((void *)&v41 + 1) - v41);
    *(void *)&long long v124 = v44;
    int v125 = &v44[8 * (v43 >> 3)];
    memcpy(v44, v42, v43);
    *((void *)&v124 + 1) = &v44[8 * (v43 >> 3)];
  }
  unint64_t v45 = *(int *)(a2 + 272);
  unint64_t v122 = 0;
  int64_t v123 = 0;
  unint64_t v121 = 0;
  if (!v45)
  {
    if (v44) {
      goto LABEL_100;
    }
    goto LABEL_101;
  }
  if ((v45 & 0x80000000) != 0) {
    sub_19E37C7C4();
  }
  size_t v46 = 8 * v45;
  long long v47 = (char *)operator new(8 * v45);
  unint64_t v121 = v47;
  int64_t v123 = &v47[8 * v45];
  bzero(v47, 8 * v45);
  uint64_t v48 = 0;
  unint64_t v49 = 0;
  uint64_t v110 = v123;
  unint64_t v122 = v123;
  do
  {
    *(void *)&v47[8 * v49] = 0;
    uint64_t v50 = *(void *)(a2 + 112);
    if ((uint64_t)v49 >= (int)(-1431655765 * ((unint64_t)(*(void *)(a2 + 120) - v50) >> 3))) {
      __assert_rtn("Str", "maxent.h", 235, "id >= 0 && id < (int)id2str.size()");
    }
    uint64_t v51 = (long long *)(v50 + v48);
    if (*((char *)v51 + 23) < 0)
    {
      sub_19E39369C(__dst, *(void **)v51, *((void *)v51 + 1));
    }
    else
    {
      long long v52 = *v51;
      uint64_t v120 = *((void *)v51 + 2);
      *(_OWORD *)stat __dst = v52;
    }
    uint64_t v53 = sub_19E3FC044((void *)(*(void *)(a2 + 424) + 72), (uint64_t)__dst);
    if (!v53 || (uint64_t v54 = *((int *)v53 + 10), v54 == -1))
    {
      if (*(double *)&v47[8 * v49] != 0.0) {
        goto LABEL_78;
      }
LABEL_77:
      *(void *)&v47[8 * v49] = 0x3F50624DD2F1A9FCLL;
      goto LABEL_78;
    }
    double v55 = *(double *)&v44[8 * v54];
    *(double *)&v47[8 * v49] = v55;
    if (v55 == 0.0) {
      goto LABEL_77;
    }
LABEL_78:
    if (SHIBYTE(v120) < 0) {
      operator delete(__dst[0]);
    }
    ++v49;
    v48 += 24;
  }
  while (v49 < v45);
  uint64_t v56 = v118;
  double v57 = __p[0];
  if (v45 > (int64_t)(v118 - (unint64_t)__p[0]) >> 3)
  {
    if (__p[0])
    {
      operator delete(__p[0]);
      uint64_t v56 = 0;
    }
    uint64_t v58 = v56 >> 2;
    if (v56 >> 2 <= v45) {
      uint64_t v58 = v45;
    }
    if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v59 = v58;
    }
    if (v59 >> 61) {
      sub_19E37C7C4();
    }
    __p[0] = operator new(8 * v59);
    memcpy(__p[0], v47, 8 * v45);
    goto LABEL_99;
  }
  unint64_t v60 = ((char *)__p[1] - (char *)__p[0]) >> 3;
  if (v60 >= v45)
  {
    uint64_t v62 = __p[0];
    size_t v63 = v47;
    goto LABEL_98;
  }
  int v61 = &v47[8 * v60];
  if (__p[1] != __p[0])
  {
    memmove(__p[0], v47, (char *)__p[1] - (char *)__p[0]);
    double v57 = __p[1];
  }
  size_t v46 = v110 - v61;
  if (v61 != v110)
  {
    uint64_t v62 = v57;
    size_t v63 = v61;
LABEL_98:
    memmove(v62, v63, v46);
  }
LABEL_99:
  operator delete(v47);
  if (v44) {
LABEL_100:
  }
    operator delete(v44);
LABEL_101:
  uint64_t v64 = *(int *)(a2 + 272);
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  if (v64)
  {
    if ((v64 & 0x80000000) != 0) {
      sub_19E37C7C4();
    }
    std::string::size_type v65 = (char *)operator new(8 * v64);
    *a1 = v65;
    a1[2] = &v65[8 * v64];
    bzero(v65, 8 * v64);
    a1[1] = &v65[8 * v64];
    int v66 = v64;
    long long v124 = 0uLL;
    int v125 = 0;
    size_t v67 = (double *)operator new(8 * v64);
    int v68 = &v67[v64];
    bzero(v67, 8 * v64);
  }
  else
  {
    std::string::size_type v65 = 0;
    int v66 = 0;
    int v68 = 0;
    size_t v67 = 0;
    long long v124 = 0uLL;
    int v125 = 0;
  }
  long long v69 = (int *)v114[0];
  if (v114[0] != v114[1])
  {
    uint64_t v70 = *(void *)(a2 + 328);
    do
    {
      size_t v71 = (unsigned int **)(v70 + 24 * *v69);
      size_t v72 = *v71;
      size_t v73 = (int *)v71[1];
      if (v72 != (unsigned int *)v73)
      {
        uint64_t v74 = *(void *)(a2 + 184);
        do
        {
          uint64_t v75 = (int)*v72;
          if ((v75 & 0x80000000) != 0
            || (uint64_t v76 = *(void *)(a2 + 248), (int)v75 >= (int)((unint64_t)(*(void *)(a2 + 256) - v76) >> 2)))
          {
            __assert_rtn("Feature", "maxent.h", 178, "id >= 0 && id < (int)id2mef.size()");
          }
          double v77 = *(double *)(v74 + 8 * v75);
          uint64_t v78 = *(unsigned __int8 *)(v76 + 4 * *v72);
          v67[v78] = v67[v78] + v77;
          ++v72;
        }
        while (v72 != (unsigned int *)v73);
      }
      ++v69;
    }
    while (v69 != v114[1]);
  }
  BOOL v79 = (double *)v115[1];
  if (v115[1] != v116)
  {
    uint64_t v80 = *(void *)(a2 + 328);
    do
    {
      long long v81 = (unsigned int **)(v80 + 24 * *(int *)v79);
      size_t v82 = *v81;
      int v83 = (int *)v81[1];
      if (v82 != (unsigned int *)v83)
      {
        uint64_t v84 = *(void *)(a2 + 184);
        do
        {
          uint64_t v85 = (int)*v82;
          if ((v85 & 0x80000000) != 0
            || (uint64_t v86 = *(void *)(a2 + 248), (int)v85 >= (int)((unint64_t)(*(void *)(a2 + 256) - v86) >> 2)))
          {
            __assert_rtn("Feature", "maxent.h", 178, "id >= 0 && id < (int)id2mef.size()");
          }
          double v87 = *(double *)(v84 + 8 * v85);
          uint64_t v88 = *(unsigned __int8 *)(v86 + 4 * *v82);
          v67[v88] = v67[v88] + v79[1] * v87;
          ++v82;
        }
        while (v82 != (unsigned int *)v83);
      }
      v79 += 2;
    }
    while (v79 != (double *)v116);
  }
  int v89 = v67;
  if (v67 != v68)
  {
    uint64_t v90 = v67 + 1;
    int v89 = v67;
    if (v67 + 1 != v68)
    {
      double v91 = *v67;
      int v89 = v67;
      uint64_t v92 = v67 + 1;
      do
      {
        double v93 = *v92++;
        BOOL v94 = v91 < v93;
        double v91 = fmax(v91, v93);
        if (v94) {
          int v89 = v90;
        }
        uint64_t v90 = v92;
      }
      while (v92 != v68);
    }
  }
  if ((int)v64 >= 1)
  {
    uint64_t v95 = 0;
    double v96 = 0.0;
    double v97 = fmax(*v89 + -700.0, 0.0);
    uint64_t v98 = *(void *)(a2 + 424);
    do
    {
      double v99 = exp(v67[v95] - v97);
      if (v98) {
        double v99 = *(double *)((char *)__p[0] + v95 * 8) * v99;
      }
      if (v99 == 0.0) {
        __assert_rtn("conditional_probability", "maxent.cpp", 126, "prod != 0");
      }
      *(double *)&v65[v95 * 8] = v99;
      double v96 = v99 + v96;
      ++v95;
    }
    while (v64 != v95);
    uint64_t v100 = 0;
    int v101 = 0;
    do
    {
      double v102 = *(double *)&v65[8 * v100] * (1.0 / v96);
      *(double *)&v65[8 * v100] = v102;
      if (v102 > *(double *)&v65[8 * v101]) {
        int v101 = v100;
      }
      ++v100;
    }
    while (v64 != v100);
    uint64_t v3 = a3;
    if (v101 < 0) {
      __assert_rtn("conditional_probability", "maxent.cpp", 134, "max_label >= 0");
    }
  }
  if (v67) {
    operator delete(v67);
  }
  if (v64)
  {
    uint64_t v103 = 0;
    signed int v104 = 0;
    double v105 = 0.0;
    do
    {
      double v106 = *(double *)&v65[8 * v103];
      if (v106 > v105) {
        signed int v104 = v103;
      }
      double v105 = fmax(v106, v105);
      ++v103;
    }
    while (v66 != v103);
    if (v104 < 0) {
LABEL_167:
    }
      __assert_rtn("Str", "maxent.h", 235, "id >= 0 && id < (int)id2str.size()");
  }
  else
  {
    signed int v104 = 0;
  }
  uint64_t v107 = *(void *)(a2 + 112);
  if (v104 >= (int)(-1431655765 * ((unint64_t)(*(void *)(a2 + 120) - v107) >> 3))) {
    goto LABEL_167;
  }
  uint64_t v108 = (long long *)(v107 + 24 * v104);
  if (*((char *)v108 + 23) < 0)
  {
    sub_19E39369C(&v124, *(void **)v108, *((void *)v108 + 1));
  }
  else
  {
    long long v109 = *v108;
    int v125 = (char *)*((void *)v108 + 2);
    long long v124 = v109;
  }
  if (*(char *)(v3 + 23) < 0) {
    operator delete(*(void **)v3);
  }
  *(_OWORD *)uint64_t v3 = v124;
  *(void *)(v3 + 16) = v125;
  if (__p[0]) {
    operator delete(__p[0]);
  }
  if (v115[1]) {
    operator delete(v115[1]);
  }
  if (v114[0]) {
    operator delete(v114[0]);
  }
}

void sub_19E3FBE10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  operator delete(v28);
  if (v27) {
    operator delete(v27);
  }
  sub_19E3FBFF0(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_19E3FBF24(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 56);
    unint64_t v4 = *(void **)(a1 + 48);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 9) < 0) {
          operator delete(*(void **)(v3 - 32));
        }
        v3 -= 32;
      }
      while (v3 != v2);
      unint64_t v4 = *(void **)(a1 + 48);
    }
    *(void *)(a1 + 56) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *(void *)(a1 + 24);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    unint64_t v7 = *(void **)(a1 + 24);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0) {
          operator delete(*(void **)(v6 - 24));
        }
        v6 -= 24;
      }
      while (v6 != v5);
      unint64_t v7 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v5;
    operator delete(v7);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_19E3FBFF0(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t *sub_19E3FC044(void *a1, uint64_t a2)
{
  uint64_t v2 = (unsigned char *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v5 = v4;
  }
  unint64_t v6 = sub_19E37BDA4((uint64_t)&v25, (uint64_t *)a2, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (v7)
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *(void *)&v7) {
        unint64_t v10 = v6 % *(void *)&v7;
      }
    }
    else
    {
      unint64_t v10 = (*(void *)&v7 - 1) & v6;
    }
    unint64_t v11 = *(uint64_t ***)(*a1 + 8 * v10);
    if (v11)
    {
      int v12 = *v11;
      if (*v11)
      {
        char v13 = v2[23];
        if (v13 >= 0) {
          uint64_t v14 = v2[23];
        }
        else {
          uint64_t v14 = *((void *)v2 + 1);
        }
        if (v13 < 0) {
          uint64_t v2 = *(unsigned char **)v2;
        }
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v15 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v21 = v12[1];
            if (v8 == v21)
            {
              uint64_t v22 = *((unsigned __int8 *)v12 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v23 = v12[3];
              }
              if (v23 == v14)
              {
                if ((v22 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v2, v12[3])) {
                    return v12;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    return v12;
                  }
                  uint64_t v24 = 0;
                  while (*((unsigned __int8 *)v12 + v24 + 16) == v2[v24])
                  {
                    if (v22 == ++v24) {
                      return v12;
                    }
                  }
                }
              }
            }
            else if ((v21 & v15) != v10)
            {
              return 0;
            }
            uint64_t result = 0;
            int v12 = (uint64_t *)*v12;
            if (!v12) {
              return result;
            }
          }
        }
        while (1)
        {
          unint64_t v17 = v12[1];
          if (v8 == v17)
          {
            uint64_t v18 = *((unsigned __int8 *)v12 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v19 = v12[3];
            }
            if (v19 == v14)
            {
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v2, v12[3])) {
                  return v12;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  return v12;
                }
                uint64_t v20 = 0;
                while (*((unsigned __int8 *)v12 + v20 + 16) == v2[v20])
                {
                  if (v18 == ++v20) {
                    return v12;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= *(void *)&v7) {
              v17 %= *(void *)&v7;
            }
            if (v17 != v10) {
              return 0;
            }
          }
          uint64_t result = 0;
          int v12 = (uint64_t *)*v12;
          if (!v12) {
            return result;
          }
        }
      }
    }
  }
  return 0;
}

char *sub_19E3FC244(char **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_19E37C7C4();
  }
  if (0x5555555555555556 * ((a1[2] - v3) >> 3) > v6) {
    unint64_t v6 = 0x5555555555555556 * ((a1[2] - v3) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      sub_19E37C2B8();
    }
    uint8x8_t v9 = (char *)operator new(24 * v8);
  }
  else
  {
    uint8x8_t v9 = 0;
  }
  unint64_t v10 = &v9[24 * v5];
  unint64_t v17 = v10;
  uint64_t v18 = v10;
  uint64_t v19 = &v9[24 * v8];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E39369C(v10, *(void **)a2, *(void *)(a2 + 8));
    uint64_t v3 = *a1;
    unint64_t v4 = a1[1];
    unint64_t v10 = v17;
    unint64_t v11 = v18;
  }
  else
  {
    *(_OWORD *)unint64_t v10 = *(_OWORD *)a2;
    *((void *)v10 + 2) = *(void *)(a2 + 16);
    unint64_t v11 = &v9[24 * v5];
  }
  int v12 = v11 + 24;
  if (v4 == v3)
  {
    uint64_t v14 = v3;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v4 - 24);
      *((void *)v10 - 1) = *((void *)v4 - 1);
      *(_OWORD *)(v10 - 24) = v13;
      v10 -= 24;
      *((void *)v4 - 2) = 0;
      *((void *)v4 - 1) = 0;
      *((void *)v4 - 3) = 0;
      v4 -= 24;
    }
    while (v4 != v3);
    uint64_t v14 = *a1;
    uint64_t v3 = a1[1];
  }
  *a1 = v10;
  a1[1] = v12;
  a1[2] = v19;
  if (v3 != v14)
  {
    uint64_t v15 = (void **)(v3 - 24);
    do
    {
      if (*((char *)v15 + 23) < 0) {
        operator delete(*v15);
      }
      v15 -= 3;
    }
    while (v15 + 3 != (void **)v14);
    uint64_t v3 = v14;
  }
  if (v3) {
    operator delete(v3);
  }
  return v12;
}

void sub_19E3FC3FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3FC410((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E3FC410(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      unint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        unint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E3FC478(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
  {
    operator delete(*(void **)(a1 + 24));
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      return a1;
    }
LABEL_5:
    operator delete(*(void **)a1);
    return a1;
  }
  if (*(char *)(a1 + 23) < 0) {
    goto LABEL_5;
  }
  return a1;
}

uint64_t sub_19E3FC4D0(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 416) + 8);
}

void sub_19E3FC4DC(uint64_t a1)
{
  long long v32 = 0uLL;
  unint64_t v33 = 0;
  uint64_t v1 = *(void *)(a1 + 184);
  uint64_t v30 = *(void *)(a1 + 192);
  if (v1 == v30) {
LABEL_38:
  }
    operator new();
  uint64_t v2 = 0;
LABEL_4:
  uint64_t v3 = *(void *)(*(void *)v1 + 8);
  uint64_t v4 = *(void *)(*(void *)v1 + 16);
  while (1)
  {
    if (v3 == v4)
    {
      v1 += 16;
      if (v1 == v30) {
        goto LABEL_38;
      }
      goto LABEL_4;
    }
    (*(void (**)(uint64_t *__return_ptr))(**(void **)v3 + 56))(&v31);
    if ((unint64_t)v2 < v33)
    {
      uint64_t v5 = v31;
      uint64_t v31 = 0;
      *(void *)uint64_t v2 = v5;
      v2 += 8;
      goto LABEL_36;
    }
    unint64_t v6 = (char *)v32;
    int8x8_t v7 = &v2[-v32];
    uint64_t v8 = (uint64_t)&v2[-v32] >> 3;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v10 = v33 - v32;
    if ((uint64_t)(v33 - v32) >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    unint64_t v11 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v9;
    if (v11)
    {
      if (v11 >> 61) {
        sub_19E37C2B8();
      }
      int v12 = (char *)operator new(8 * v11);
    }
    else
    {
      int v12 = 0;
    }
    long long v13 = &v12[8 * v8];
    uint64_t v14 = &v12[8 * v11];
    uint64_t v15 = v31;
    uint64_t v31 = 0;
    *(void *)long long v13 = v15;
    uint64_t v16 = v13 + 8;
    unint64_t v17 = (char *)(v2 - v6);
    if (v2 != v6) {
      break;
    }
    *(void *)&long long v32 = &v12[8 * v8];
    *((void *)&v32 + 1) = v13 + 8;
    unint64_t v33 = (unint64_t)v14;
LABEL_33:
    if (v2) {
      operator delete(v2);
    }
    uint64_t v2 = v16;
LABEL_36:
    *((void *)&v32 + 1) = v2;
    uint64_t v29 = v31;
    uint64_t v31 = 0;
    if (v29) {
      (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
    }
    v3 += 8;
  }
  uint64_t v18 = v17 - 8;
  if ((unint64_t)(v17 - 8) > 0x77
    && (&v2[-8 * ((unint64_t)v18 >> 3) - 8] >= v13
     || &v7[(void)v12 - ((unint64_t)v18 & 0xFFFFFFFFFFFFFFF8) - 8] >= v2))
  {
    uint64_t v19 = ((unint64_t)v18 >> 3) + 1;
    v13 -= 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v20 = v2 - 32;
    uint64_t v21 = &v12[8 * v8 - 16];
    uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *(_OWORD *)v20;
      long long v23 = *((_OWORD *)v20 + 1);
      *(_OWORD *)uint64_t v20 = 0uLL;
      *((_OWORD *)v20 + 1) = 0uLL;
      v20 -= 32;
      *((_OWORD *)v21 - 1) = v24;
      *(_OWORD *)uint64_t v21 = v23;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    if (v19 == (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      uint64_t v26 = (char *)*((void *)&v32 + 1);
      uint64_t v2 = (char *)v32;
      *(void *)&long long v32 = v13;
      *((void *)&v32 + 1) = v16;
      unint64_t v33 = (unint64_t)v14;
      while (v26 != v2)
      {
        uint64_t v28 = *((void *)v26 - 1);
        v26 -= 8;
        uint64_t v27 = v28;
        *(void *)uint64_t v26 = 0;
        if (v28) {
          (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
        }
      }
      goto LABEL_33;
    }
    v2 -= 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
  }
  do
  {
    uint64_t v25 = *((void *)v2 - 1);
    v2 -= 8;
    *(void *)uint64_t v2 = 0;
    *((void *)v13 - 1) = v25;
    v13 -= 8;
  }
  while (v2 != v6);
  goto LABEL_28;
}

void sub_19E3FC96C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  sub_19E3FCA08((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_19E3FCA08(void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    uint64_t v3 = (void *)a1[1];
    uint64_t v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_19E3FCA98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v4[0] = &unk_1EF0B5BE0;
  v4[1] = a3;
  uint64_t v5 = v4;
  sub_19E3FCB90(a1, a2, 0, (uint64_t)v4);
  uint64_t result = (uint64_t)v5;
  if (v5 == v4) {
    return (*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

void sub_19E3FCB7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3FD0EC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E3FCB90(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  CFStringRef v9 = (const __CFString *)MEMORY[0x19F3BCDE0](v8);
  if (CFEqual(v9, @"zh-Hans")) {
    return;
  }
  if (a3 == 3)
  {
    uint64_t v10 = *(void *)(a1 + 208);
    uint64_t v11 = *(void *)(a1 + 216);
    if (v10 != v11)
    {
      uint64_t v12 = v10 + 8;
      do
      {
        if (sub_19E4B98FC(a2, *(void *)(v12 - 8), 0, a4)) {
          break;
        }
        BOOL v13 = v12 == v11;
        v12 += 8;
      }
      while (!v13);
    }
    return;
  }
  uint64_t v14 = *(void *)(a1 + 184);
  uint64_t v15 = *(void *)(a1 + 192);
  if (v14 == v15)
  {
LABEL_12:
    if (a3 == 2) {
      return;
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (!v16) {
      goto LABEL_28;
    }
    uint64_t v17 = *(void *)(v16 + 560);
    uint64_t v18 = *(std::__shared_weak_count **)(v16 + 568);
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    if (v17)
    {
      uint64_t v19 = *(void *)(a1 + 48);
      uint64_t v20 = *(void *)(v19 + 560);
      uint64_t v21 = *(std::__shared_weak_count **)(v19 + 568);
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v22 = sub_19E4B98FC(a2, v20, 1, a4);
      if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
      if (a3 == 1) {
        char v23 = 1;
      }
      else {
        char v23 = v22;
      }
      if (v23) {
        return;
      }
    }
    else
    {
LABEL_28:
      if (a3 == 1) {
        return;
      }
    }
    uint64_t v24 = *(void *)(a1 + 296);
    if (!v24 || (sub_19E4B98FC(a2, *(void *)(v24 + 16), 5, a4) & 1) == 0)
    {
      uint64_t v25 = *(void *)(a1 + 304);
      if (!v25 || (sub_19E4B98FC(a2, *(void *)(v25 + 16), 3, a4) & 1) == 0)
      {
        uint64_t v26 = *(void *)(a1 + 288);
        if (!v26 || (sub_19E4B98FC(a2, *(void *)(v26 + 16), 4, a4) & 1) == 0)
        {
          uint64_t v27 = *(void **)(a1 + 24);
          uint64_t v28 = *(void **)(a1 + 32);
          if (v27 != v28)
          {
            uint64_t v29 = (struct type_info *)MEMORY[0x1E4FBA338];
            do
            {
              uint64_t v44 = 0;
              int v30 = (*(uint64_t (**)(void, uint64_t, uint64_t *))(*(void *)*v27 + 72))(*v27, a2, &v44);
              if (v30)
              {
                int v31 = v30;
                unsigned __int8 v43 = 0;
                char v32 = *(unsigned char *)(a2 + 23);
                unint64_t v33 = v32 >= 0 ? (const UInt8 *)a2 : *(const UInt8 **)a2;
                if (v33)
                {
                  if (v32 >= 0) {
                    CFIndex v34 = *(unsigned __int8 *)(a2 + 23);
                  }
                  else {
                    CFIndex v34 = *(void *)(a2 + 8);
                  }
                  CFStringRef v35 = CFStringCreateWithBytes(0, v33, v34, 0x8000100u, 0);
                  CFStringRef cf = v35;
                  if (!v35)
                  {
                    exception = __cxa_allocate_exception(0x10uLL);
                    MEMORY[0x19F3BD790](exception, "Could not construct");
                    __cxa_throw(exception, v29, MEMORY[0x1E4FBA1D8]);
                  }
                }
                else
                {
                  CFStringRef v35 = 0;
                  CFStringRef cf = 0;
                }
                uint64_t v36 = v44;
                CFArrayRef v37 = *(const __CFArray **)(a1 + 176);
                if (v37 && CFArrayGetCount(v37)) {
                  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0);
                }
                else {
                  ValueAtIndex = *(const void **)(*(void *)(a1 + 416) + 8);
                }
                CFStringRef v49 = v35;
                int v48 = v31;
                uint64_t v47 = v36;
                int v46 = 2;
                unint64_t v45 = ValueAtIndex;
                uint64_t v39 = *(void *)(a4 + 24);
                if (!v39) {
                  sub_19E3ACB9C();
                }
                (*(void (**)(uint64_t, CFStringRef *, int *, uint64_t *, int *, const void **, unsigned __int8 *))(*(void *)v39 + 48))(v39, &v49, &v48, &v47, &v46, &v45, &v43);
                int v40 = v43;
                if (cf) {
                  CFRelease(cf);
                }
                if (v40) {
                  break;
                }
              }
              ++v27;
            }
            while (v27 != v28);
          }
        }
      }
    }
    return;
  }
  while (!sub_19E4B9C40(a2, *(void *)(*(void *)v14 + 8), *(void *)(*(void *)v14 + 16), a4))
  {
    v14 += 16;
    if (v14 == v15) {
      goto LABEL_12;
    }
  }
}

void sub_19E3FD0A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_19E3FD0D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_19E3D73EC((uint64_t)va);
  JUMPOUT(0x19E3FD0E0);
}

void *sub_19E3FD0EC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E3FD170()
{
  return &unk_1EF0B82F8;
}

uint64_t sub_19E3FD17C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK2LM22CompositeLanguageModel33enumerateSortkeyEquivalentEntriesERKNSt3__112basic_stringIcNS1_11ch"
                     "ar_traitsIcEENS1_9allocatorIcEEEERKNS1_8functionIFvPK10__CFStringjdRbEEEE3$_0"
    || ((v3 & (unint64_t)"ZNK2LM22CompositeLanguageModel33enumerateSortkeyEquivalentEntriesERKNSt3__112basic_strin"
                                "gIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_8functionIFvPK10__CFStringjdRbEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK2LM22CompositeLanguageModel33enumerateSortkeyEquivalentEntriesERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_8functionIFvPK10__CFStringjdRbEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK2LM22CompositeLanguageModel33enumerateSortkeyEquivalentEntriesERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_8functionIFvPK10__CFStringjdRbEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E3FD1D4(uint64_t a1, uint64_t *a2, int *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = *a3;
  uint64_t v8 = *a4;
  uint64_t v9 = *(void *)(*(void *)(a1 + 8) + 24);
  uint64_t v13 = *a2;
  int v12 = v7;
  uint64_t v11 = v8;
  if (!v9) {
    sub_19E3ACB9C();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, int *, uint64_t *, uint64_t))(*(void *)v9 + 48))(v9, &v13, &v12, &v11, a7);
}

uint64_t sub_19E3FD254(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5BE0;
  a2[1] = v2;
  return result;
}

void *sub_19E3FD278(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5BE0;
  result[1] = v3;
  return result;
}

void sub_19E3FD2C0()
{
}

void sub_19E3FD2D8(uint64_t a1@<X0>, int a2@<W8>)
{
}

void sub_19E3FD31C(int a1, int a2, std::__shared_weak_count *this)
{
  if (this)
  {
    if (std::__shared_weak_count::lock(this)) {
      operator new();
    }
  }
  sub_19E3FDEBC();
}

void sub_19E3FDC50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::recursive_mutex *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, long long a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24)
{
  uint64_t v28 = *(void *)(v26 - 112);
  *(void *)(v26 - 112) = 0;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  if (v25)
  {
    if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  uint64_t v29 = sub_19E4AAE74(v24);
  MEMORY[0x19F3BDCF0](v29, 0x10E1C40525E7390);
  sub_19E3D73EC((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_19E3FDEBC()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA438] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA2E0], MEMORY[0x1E4FBA208]);
}

void sub_19E3FDF08(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2 <= 0x1F3)
  {
    sub_19E4A98F8((void *)a3, a2);
    return;
  }
  uint64_t v6 = (void *)a1[3];
  int v7 = (void *)a1[4];
  while (v6 != v7)
  {
    (*(void (**)(void, uint64_t))(*(void *)*v6 + 56))(*v6, a2);
    uint64_t v8 = *(unsigned __int8 *)(a3 + 23);
    int v9 = (char)v8;
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *(void *)(a3 + 8);
    }
    if (v8) {
      return;
    }
    if (v9 < 0) {
      operator delete(*(void **)a3);
    }
    ++v6;
  }
  uint64_t v10 = a1[23];
  uint64_t v11 = a1[24];
  while (v10 != v11)
  {
    int v12 = *(void **)(*(void *)v10 + 8);
    uint64_t v13 = *(void **)(*(void *)v10 + 16);
    while (v12 != v13)
    {
      (*(void (**)(void, uint64_t))(*(void *)*v12 + 32))(*v12, a2);
      uint64_t v14 = *(unsigned __int8 *)(a3 + 23);
      int v15 = (char)v14;
      if ((v14 & 0x80u) != 0) {
        uint64_t v14 = *(void *)(a3 + 8);
      }
      if (v14) {
        return;
      }
      if (v15 < 0) {
        operator delete(*(void **)a3);
      }
      ++v12;
    }
    v10 += 16;
  }
  if (!*(unsigned char *)(a1[29] + 192))
  {
LABEL_60:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    return;
  }
  uint64_t v16 = a1[6];
  if (!v16)
  {
LABEL_39:
    uint64_t v21 = a1[37];
    if (v21 && (a2 & 0x80000000) != 0)
    {
      (*(void (**)(void, uint64_t))(**(void **)(v21 + 16) + 32))(*(void *)(v21 + 16), a2);
      if (*(char *)(a3 + 23) < 0)
      {
        if (*(void *)(a3 + 8)) {
          return;
        }
        operator delete(*(void **)a3);
      }
      else if (*(unsigned char *)(a3 + 23))
      {
        return;
      }
    }
    uint64_t v22 = a1[38];
    if (v22 && (a2 & 0x80000000) != 0)
    {
      (*(void (**)(void, uint64_t))(**(void **)(v22 + 16) + 32))(*(void *)(v22 + 16), a2);
      if (*(char *)(a3 + 23) < 0)
      {
        if (*(void *)(a3 + 8)) {
          return;
        }
        operator delete(*(void **)a3);
      }
      else if (*(unsigned char *)(a3 + 23))
      {
        return;
      }
    }
    uint64_t v23 = a1[36];
    if (v23 && (a2 & 0x80000000) != 0)
    {
      (*(void (**)(void, uint64_t))(**(void **)(v23 + 16) + 32))(*(void *)(v23 + 16), a2);
      if (*(char *)(a3 + 23) < 0)
      {
        if (*(void *)(a3 + 8)) {
          return;
        }
        operator delete(*(void **)a3);
      }
      else if (*(unsigned char *)(a3 + 23))
      {
        return;
      }
    }
    goto LABEL_60;
  }
  uint64_t v17 = *(void *)(v16 + 560);
  uint64_t v18 = *(std::__shared_weak_count **)(v16 + 568);
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v17) {
    goto LABEL_34;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 32))(v17, a2);
  int v19 = *(char *)(a3 + 23);
  if (v19 < 0)
  {
    if (*(void *)(a3 + 8))
    {
      BOOL v20 = 0;
      goto LABEL_35;
    }
    operator delete(*(void **)a3);
LABEL_34:
    BOOL v20 = 1;
    goto LABEL_35;
  }
  BOOL v20 = v19 == 0;
LABEL_35:
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  if (v20) {
    goto LABEL_39;
  }
}

void sub_19E3FE270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E3FE284(void *a1, uint64_t a2, void *a3)
{
  LOBYTE(v6[0]) = 0;
  char v7 = 0;
  if (a3)
  {
    *a3 = 0;
    uint64_t result = sub_19E3FE30C(a1, a2, (uint64_t)a3, v6);
  }
  else
  {
    uint64_t result = sub_19E3FE30C(a1, a2, 0, v6);
  }
  if (!result) {
    return sub_19E4BA040(a2, *(unsigned __int8 *)(a1[29] + 358));
  }
  return result;
}

void sub_19E3FE2F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3FE820((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E3FE30C(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1[29] + 365) || (uint64_t v8 = (void *)a1[3], v9 = (void *)a1[4], v8 == v9))
  {
LABEL_5:
    if (*((unsigned char *)a4 + 16))
    {
      uint64_t v11 = (std::__shared_weak_count *)a4[1];
      uint64_t v39 = *a4;
      int v40 = v11;
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v12 = operator new(0x10uLL);
      std::string __p = v12;
      CFArrayRef v37 = (std::__shared_weak_count *)v12;
      uint64_t v38 = v12 + 2;
      uint64_t v13 = v40;
      *int v12 = v39;
      v12[1] = v13;
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        CFArrayRef v37 = (std::__shared_weak_count *)(v12 + 2);
        if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
          std::__shared_weak_count::__release_weak(v40);
        }
      }
      else
      {
        CFArrayRef v37 = (std::__shared_weak_count *)(v12 + 2);
      }
    }
    else
    {
      sub_19E3FE894(&__p, (uint64_t)(a1 + 23));
    }
    uint64_t v16 = (std::__shared_weak_count *)__p;
    int v15 = v37;
    if (__p == v37)
    {
      uint64_t v19 = 0;
      int v20 = 1;
      if (!__p)
      {
LABEL_33:
        if (!v20) {
          return v19;
        }
LABEL_34:
        uint64_t v24 = a1[29];
        if (!*(unsigned char *)(v24 + 365))
        {
          int v31 = (void *)a1[3];
          char v32 = (void *)a1[4];
          if (v31 != v32)
          {
            while (1)
            {
              uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v31 + 72))(*v31, a2, a3);
              if (v14) {
                return v14;
              }
              if (++v31 == v32)
              {
                uint64_t v24 = a1[29];
                break;
              }
            }
          }
        }
        if (!*(unsigned char *)(v24 + 192)) {
          return 0;
        }
        uint64_t v25 = a1[6];
        uint64_t v26 = *(void **)(v25 + 560);
        uint64_t v27 = *(std::__shared_weak_count **)(v25 + 568);
        std::string __p = v26;
        CFArrayRef v37 = v27;
        if (v27) {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v26
          || (uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v26 + 24))(v26, a2, a3),
              !v14))
        {
          if (!*(unsigned char *)(a1[29] + 192)) {
            goto LABEL_55;
          }
          uint64_t v28 = a1[37];
          if (v28)
          {
            uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v28 + 16) + 24))(*(void *)(v28 + 16), a2, a3);
            if (v14) {
              goto LABEL_46;
            }
            if (!*(unsigned char *)(a1[29] + 192)) {
              goto LABEL_55;
            }
          }
          uint64_t v29 = a1[38];
          if (v29)
          {
            uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v29 + 16) + 24))(*(void *)(v29 + 16), a2, a3);
            if (v14) {
              goto LABEL_46;
            }
            if (!*(unsigned char *)(a1[29] + 192)) {
              goto LABEL_55;
            }
          }
          uint64_t v33 = a1[36];
          if (v33) {
            unsigned int v34 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v33 + 16) + 24))(*(void *)(v33 + 16), a2, a3);
          }
          else {
LABEL_55:
          }
            unsigned int v34 = 0;
          BOOL v30 = v34 != 0;
          if (v34) {
            uint64_t v14 = v34;
          }
          else {
            uint64_t v14 = v19;
          }
          if (!v27)
          {
LABEL_62:
            if (v30) {
              return v14;
            }
            return 0;
          }
LABEL_60:
          if (!atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
            std::__shared_weak_count::__release_weak(v27);
          }
          goto LABEL_62;
        }
LABEL_46:
        BOOL v30 = 1;
        if (!v27) {
          goto LABEL_62;
        }
        goto LABEL_60;
      }
    }
    else
    {
      while (1)
      {
        uint64_t v17 = v16->~__shared_weak_count_0;
        on_zero_shared = v16->__on_zero_shared;
        if ((char *)v17 != (char *)on_zero_shared) {
          break;
        }
LABEL_19:
        uint64_t v16 = (std::__shared_weak_count *)((char *)v16 + 16);
        if (v16 == v15)
        {
          uint64_t v19 = 0;
          int v20 = 1;
          uint64_t v16 = (std::__shared_weak_count *)__p;
          if (__p) {
            goto LABEL_23;
          }
          goto LABEL_33;
        }
      }
      while (1)
      {
        uint64_t v19 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)v17 + 24))(*(void *)v17, a2, a3);
        if (v19) {
          break;
        }
        uint64_t v17 = (void (__cdecl *)(std::__shared_weak_count *__hidden))((char *)v17 + 8);
        if ((char *)v17 == (char *)on_zero_shared) {
          goto LABEL_19;
        }
      }
      int v20 = 0;
      uint64_t v16 = (std::__shared_weak_count *)__p;
      if (!__p) {
        goto LABEL_33;
      }
    }
LABEL_23:
    uint64_t v21 = v37;
    uint64_t v22 = v16;
    if (v37 != v16)
    {
      do
      {
        shared_weak_owners = (std::__shared_weak_count *)v21[-1].__shared_weak_owners_;
        if (shared_weak_owners && !atomic_fetch_add(&shared_weak_owners->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))shared_weak_owners->__on_zero_shared)(shared_weak_owners);
          std::__shared_weak_count::__release_weak(shared_weak_owners);
        }
        uint64_t v21 = (std::__shared_weak_count *)((char *)v21 - 16);
      }
      while (v21 != v16);
      uint64_t v22 = __p;
    }
    CFArrayRef v37 = v16;
    operator delete(v22);
    if (!v20) {
      return v19;
    }
    goto LABEL_34;
  }
  while (1)
  {
    uint64_t v10 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v8 + 72))(*v8, a2, a3);
    if (v10) {
      return v10;
    }
    if (++v8 == v9) {
      goto LABEL_5;
    }
  }
}

void sub_19E3FE7D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_19E3FE7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E3D73EC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E3FE80C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

uint64_t sub_19E3FE820(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
    if (v2)
    {
      if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
  }
  return a1;
}

void *sub_19E3FE894(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v3 = *(void **)a2;
  uint64_t v4 = *(void **)(a2 + 8);
  uint64_t v5 = (uint64_t)v4 - *(void *)a2;
  if (v4 != *(void **)a2)
  {
    if (v5 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v6 = operator new((size_t)v4 - *(void *)a2);
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[2 * (v5 >> 4)];
    do
    {
      uint64_t v7 = v3[1];
      *uint64_t v6 = *v3;
      v6[1] = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      v6 += 2;
      v3 += 2;
    }
    while (v3 != v4);
    a1[1] = v6;
  }
  return a1;
}

void sub_19E3FE934(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (char *)*v1;
  if (*v1)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = *v1;
    if (v4 != v3)
    {
      do
      {
        uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
        if (v6)
        {
          if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
        }
        v4 -= 16;
      }
      while (v4 != v3);
      uint64_t v5 = *v1;
    }
    v1[1] = v3;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E3FE9C0(void *a1, const __CFString *a2, uint64_t a3)
{
  sub_19E37774C(a2, &v36);
  if (!*(unsigned char *)(a1[29] + 365) || (uint64_t v6 = (void *)a1[3], v7 = (void *)a1[4], v6 == v7))
  {
LABEL_5:
    sub_19E3FE894(&__p, (uint64_t)(a1 + 23));
    int v9 = (std::__shared_weak_count *)__p;
    uint64_t v10 = v39;
    if (__p == v39)
    {
      uint64_t v13 = 0;
      int v14 = 1;
      if (!v39)
      {
LABEL_23:
        if (!v14)
        {
LABEL_21:
          uint64_t v8 = v13;
          goto LABEL_54;
        }
LABEL_24:
        uint64_t v18 = a1[29];
        if (!*(unsigned char *)(v18 + 365))
        {
          uint64_t v25 = (void *)a1[3];
          uint64_t v26 = (void *)a1[4];
          if (v25 != v26)
          {
            while (1)
            {
              uint64_t v8 = (*(uint64_t (**)(void, const __CFString *, uint64_t))(*(void *)*v25 + 64))(*v25, a2, a3);
              if (v8) {
                goto LABEL_54;
              }
              if (++v25 == v26)
              {
                uint64_t v18 = a1[29];
                break;
              }
            }
          }
        }
        if (!*(unsigned char *)(v18 + 192))
        {
LABEL_53:
          uint64_t v8 = 0;
          goto LABEL_54;
        }
        uint64_t v19 = a1[6];
        int v20 = *(void **)(v19 + 560);
        uint64_t v21 = *(std::__shared_weak_count **)(v19 + 568);
        std::string __p = v20;
        uint64_t v39 = v21;
        if (v21) {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v20
          || (uint64_t v8 = (*(uint64_t (**)(void *, const __CFString *, uint64_t))(*(void *)v20 + 16))(v20, a2, a3),
              !v8))
        {
          if (!*(unsigned char *)(a1[29] + 192)) {
            goto LABEL_45;
          }
          uint64_t v22 = a1[37];
          if (v22)
          {
            uint64_t v8 = (*(uint64_t (**)(void, const __CFString *, uint64_t))(**(void **)(v22 + 16) + 16))(*(void *)(v22 + 16), a2, a3);
            if (v8) {
              goto LABEL_36;
            }
            if (!*(unsigned char *)(a1[29] + 192)) {
              goto LABEL_45;
            }
          }
          uint64_t v23 = a1[38];
          if (v23)
          {
            uint64_t v8 = (*(uint64_t (**)(void, const __CFString *, uint64_t))(**(void **)(v23 + 16) + 16))(*(void *)(v23 + 16), a2, a3);
            if (v8) {
              goto LABEL_36;
            }
            if (!*(unsigned char *)(a1[29] + 192)) {
              goto LABEL_45;
            }
          }
          uint64_t v27 = a1[36];
          if (v27) {
            unsigned int v28 = (*(uint64_t (**)(void, const __CFString *, uint64_t))(**(void **)(v27 + 16) + 16))(*(void *)(v27 + 16), a2, a3);
          }
          else {
LABEL_45:
          }
            unsigned int v28 = 0;
          BOOL v24 = v28 != 0;
          if (v28) {
            uint64_t v8 = v28;
          }
          else {
            uint64_t v8 = v13;
          }
          if (!v21) {
            goto LABEL_52;
          }
          goto LABEL_50;
        }
LABEL_36:
        BOOL v24 = 1;
        if (!v21) {
          goto LABEL_52;
        }
LABEL_50:
        if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
LABEL_52:
        if (v24) {
          goto LABEL_54;
        }
        goto LABEL_53;
      }
    }
    else
    {
      while (1)
      {
        uint64_t v11 = v9->~__shared_weak_count_0;
        on_zero_shared = v9->__on_zero_shared;
        if ((char *)v11 != (char *)on_zero_shared) {
          break;
        }
LABEL_9:
        int v9 = (std::__shared_weak_count *)((char *)v9 + 16);
        if (v9 == v10)
        {
          uint64_t v13 = 0;
          int v14 = 1;
          uint64_t v10 = (std::__shared_weak_count *)__p;
          if (__p) {
            goto LABEL_13;
          }
          goto LABEL_23;
        }
      }
      while (1)
      {
        uint64_t v13 = (*(uint64_t (**)(void, const __CFString *, uint64_t))(**(void **)v11 + 16))(*(void *)v11, a2, a3);
        if (v13) {
          break;
        }
        uint64_t v11 = (void (__cdecl *)(std::__shared_weak_count *__hidden))((char *)v11 + 8);
        if ((char *)v11 == (char *)on_zero_shared) {
          goto LABEL_9;
        }
      }
      int v14 = 0;
      uint64_t v10 = (std::__shared_weak_count *)__p;
      if (!__p) {
        goto LABEL_23;
      }
    }
LABEL_13:
    int v15 = v39;
    uint64_t v16 = v10;
    if (v39 != v10)
    {
      do
      {
        shared_weak_owners = (std::__shared_weak_count *)v15[-1].__shared_weak_owners_;
        if (shared_weak_owners && !atomic_fetch_add(&shared_weak_owners->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))shared_weak_owners->__on_zero_shared)(shared_weak_owners);
          std::__shared_weak_count::__release_weak(shared_weak_owners);
        }
        int v15 = (std::__shared_weak_count *)((char *)v15 - 16);
      }
      while (v15 != v10);
      uint64_t v16 = __p;
    }
    uint64_t v39 = v10;
    operator delete(v16);
    if (!v14) {
      goto LABEL_21;
    }
    goto LABEL_24;
  }
  while (1)
  {
    uint64_t v8 = (*(uint64_t (**)(void, const __CFString *, uint64_t))(*(void *)*v6 + 64))(*v6, a2, a3);
    if (v8) {
      break;
    }
    if (++v6 == v7) {
      goto LABEL_5;
    }
  }
LABEL_54:
  if (v37 < 0)
  {
    operator delete(v36);
    if (v8) {
      return v8;
    }
  }
  else if (v8)
  {
    return v8;
  }
  if (!*(unsigned char *)(a1[29] + 358)) {
    goto LABEL_67;
  }
  CFIndex Length = CFStringGetLength(a2);
  if (Length < 1) {
    return 3;
  }
  CFIndex v30 = Length;
  uint64_t v31 = 1;
  do
  {
    UChar32 CharacterAtIndex = CFStringGetCharacterAtIndex(a2, v31 - 1);
    int v33 = (1 << u_charType(CharacterAtIndex)) & 0xE00;
    if (v33) {
      BOOL v34 = v31 < v30;
    }
    else {
      BOOL v34 = 0;
    }
    ++v31;
  }
  while (v34);
  if (v33) {
    return 3;
  }
LABEL_67:
  sub_19E37774C(a2, &__p);
  uint64_t v8 = sub_19E4AA6F8((uint64_t)&__p);
  if (v40 < 0) {
    operator delete(__p);
  }
  return v8;
}

void sub_19E3FEEB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_19E3FEF20(uint64_t a1)
{
  sub_19E3FEF58(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E3FEF58(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BB550;
  uint64_t v2 = *(void *)(a1 + 232);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 264);
    if (v3)
    {
      std::mutex::lock(*(std::mutex **)(a1 + 232));
      uint64_t v5 = *(char **)(v2 + 64);
      uint64_t v4 = *(char **)(v2 + 72);
      if (v5 != v4)
      {
        while (*(void *)v5 != v3 + 120)
        {
          v5 += 8;
          if (v5 == v4)
          {
            uint64_t v5 = *(char **)(v2 + 72);
            break;
          }
        }
      }
      if (v5 != v4)
      {
        int64_t v6 = v4 - (v5 + 8);
        if (v4 != v5 + 8) {
          memmove(v5, v5 + 8, v4 - (v5 + 8));
        }
        *(void *)(v2 + 72) = &v5[v6];
      }
      std::mutex::unlock((std::mutex *)v2);
    }
  }
  uint64_t v7 = *(std::recursive_mutex **)(a1 + 464);
  if (v7) {
    sub_19E4B383C(v7, a1, 0);
  }
  uint64_t v8 = *(void *)(a1 + 480);
  *(void *)(a1 + 480) = 0;
  if (v8) {
    sub_19E3FF6EC(v8);
  }
  int v9 = *(std::__shared_weak_count **)(a1 + 472);
  if (!v9 || atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v10 = *(const void **)(a1 + 456);
    if (!v10) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v9);
  uint64_t v10 = *(const void **)(a1 + 456);
  if (v10) {
LABEL_19:
  }
    CFRelease(v10);
LABEL_20:
  *(void *)(a1 + 456) = 0;
  uint64_t v11 = *(const void **)(a1 + 432);
  if (v11) {
    CFRelease(v11);
  }
  *(void *)(a1 + 432) = 0;
  int v12 = *(std::__shared_weak_count **)(a1 + 424);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  *(void *)(a1 + 344) = &unk_1EF0B9A38;
  sub_19E3FF7C8(*(void **)(a1 + 400));
  sub_19E3FF824(*(void **)(a1 + 376));
  uint64_t v13 = *(void *)(a1 + 336);
  *(void *)(a1 + 336) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = *(void *)(a1 + 328);
  *(void *)(a1 + 328) = 0;
  if (v14)
  {
    CFRelease(*(CFTypeRef *)v14);
    int v15 = *(void **)(v14 + 16);
    if (v15) {

    }
    MEMORY[0x19F3BDCF0](v14, 0x10E0C40F5622EBCLL);
  }
  uint64_t v16 = *(void *)(a1 + 320);
  *(void *)(a1 + 320) = 0;
  if (v16)
  {
    CFRelease(*(CFTypeRef *)v16);
    uint64_t v17 = *(void **)(v16 + 16);
    if (v17) {

    }
    MEMORY[0x19F3BDCF0](v16, 0x10E0C40F5622EBCLL);
  }
  uint64_t v18 = *(void *)(a1 + 312);
  *(void *)(a1 + 312) = 0;
  if (v18)
  {
    CFRelease(*(CFTypeRef *)v18);
    uint64_t v19 = *(void **)(v18 + 16);
    if (v19) {

    }
    MEMORY[0x19F3BDCF0](v18, 0x10E0C40F5622EBCLL);
  }
  uint64_t v20 = *(void *)(a1 + 304);
  *(void *)(a1 + 304) = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  uint64_t v21 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  uint64_t v22 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  uint64_t v23 = *(void *)(a1 + 280);
  *(void *)(a1 + 280) = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  uint64_t v24 = *(void *)(a1 + 272);
  *(void *)(a1 + 272) = 0;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  uint64_t v25 = *(void *)(a1 + 264);
  *(void *)(a1 + 264) = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(a1 + 256);
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(a1 + 240);
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  unsigned int v28 = *(void **)(a1 + 208);
  if (v28)
  {
    uint64_t v29 = *(void **)(a1 + 216);
    CFIndex v30 = *(void **)(a1 + 208);
    if (v29 != v28)
    {
      do
      {
        uint64_t v32 = *--v29;
        uint64_t v31 = v32;
        *uint64_t v29 = 0;
        if (v32) {
          (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
        }
      }
      while (v29 != v28);
      CFIndex v30 = *(void **)(a1 + 208);
    }
    *(void *)(a1 + 216) = v28;
    operator delete(v30);
  }
  uint64_t v33 = *(void *)(a1 + 184);
  if (v33)
  {
    uint64_t v34 = *(void *)(a1 + 192);
    CFStringRef v35 = *(void **)(a1 + 184);
    if (v34 != v33)
    {
      do
      {
        uint64_t v36 = *(std::__shared_weak_count **)(v34 - 8);
        if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
        v34 -= 16;
      }
      while (v34 != v33);
      CFStringRef v35 = *(void **)(a1 + 184);
    }
    *(void *)(a1 + 192) = v33;
    operator delete(v35);
  }
  char v37 = *(const void **)(a1 + 176);
  if (v37) {
    CFRelease(v37);
  }
  *(void *)(a1 + 176) = 0;
  uint64_t v38 = *(void **)(a1 + 152);
  if (v38)
  {
    uint64_t v39 = *(void **)(a1 + 160);
    char v40 = *(void **)(a1 + 152);
    if (v39 != v38)
    {
      do
      {
        uint64_t v42 = *--v39;
        uint64_t v41 = v42;
        *uint64_t v39 = 0;
        if (v42) {
          (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
        }
      }
      while (v39 != v38);
      char v40 = *(void **)(a1 + 152);
    }
    *(void *)(a1 + 160) = v38;
    operator delete(v40);
  }
  uint64_t v43 = *(void *)(a1 + 128);
  if (v43)
  {
    uint64_t v44 = *(void *)(a1 + 136);
    unint64_t v45 = *(void **)(a1 + 128);
    if (v44 != v43)
    {
      do
      {
        int v46 = *(std::__shared_weak_count **)(v44 - 8);
        if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
          std::__shared_weak_count::__release_weak(v46);
        }
        v44 -= 16;
      }
      while (v44 != v43);
      unint64_t v45 = *(void **)(a1 + 128);
    }
    *(void *)(a1 + 136) = v43;
    operator delete(v45);
  }
  uint64_t v47 = *(const void **)(a1 + 120);
  if (v47) {
    CFRelease(v47);
  }
  *(void *)(a1 + 120) = 0;
  uint64_t v48 = *(void *)(a1 + 96);
  if (v48)
  {
    uint64_t v49 = *(void *)(a1 + 104);
    uint64_t v50 = *(void **)(a1 + 96);
    if (v49 != v48)
    {
      do
      {
        v49 -= 40;
        sub_19E3FF880(v49);
      }
      while (v49 != v48);
      uint64_t v50 = *(void **)(a1 + 96);
    }
    *(void *)(a1 + 104) = v48;
    operator delete(v50);
  }
  uint64_t v51 = *(const void **)(a1 + 88);
  if (v51) {
    CFRelease(v51);
  }
  *(void *)(a1 + 88) = 0;
  uint64_t v52 = *(void *)(a1 + 64);
  if (v52)
  {
    uint64_t v53 = *(void *)(a1 + 72);
    uint64_t v54 = *(void **)(a1 + 64);
    if (v53 != v52)
    {
      do
      {
        double v55 = *(std::__shared_weak_count **)(v53 - 8);
        if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
          std::__shared_weak_count::__release_weak(v55);
        }
        v53 -= 16;
      }
      while (v53 != v52);
      uint64_t v54 = *(void **)(a1 + 64);
    }
    *(void *)(a1 + 72) = v52;
    operator delete(v54);
  }
  uint64_t v56 = *(std::__shared_weak_count **)(a1 + 56);
  if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
  double v57 = *(void **)(a1 + 24);
  if (v57)
  {
    *(void *)(a1 + 32) = v57;
    operator delete(v57);
  }
  uint64_t v58 = *(std::__shared_weak_count **)(a1 + 16);
  if (v58) {
    std::__shared_weak_count::__release_weak(v58);
  }
  return a1;
}

void sub_19E3FF6EC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v4 = *(void **)(a1 + 40);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 40);
    }
    *(void *)(a1 + 48) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *(void ***)(a1 + 16);
  if (v5)
  {
    do
    {
      uint64_t v7 = (void **)*v5;
      sub_19E3FFB5C((uint64_t)(v5 + 5));
      if (*((char *)v5 + 39) < 0) {
        operator delete(v5[2]);
      }
      operator delete(v5);
      uint64_t v5 = v7;
    }
    while (v7);
  }
  int64_t v6 = *(void **)a1;
  *(void *)a1 = 0;
  if (v6) {
    operator delete(v6);
  }
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E3FF7C8(void *a1)
{
  if (a1)
  {
    sub_19E3FF7C8(*a1);
    sub_19E3FF7C8(a1[1]);
    sub_19E3C5DBC((char *)a1[9]);
    sub_19E3C5DBC((char *)a1[6]);
    operator delete(a1);
  }
}

void sub_19E3FF824(void *a1)
{
  if (a1)
  {
    sub_19E3FF824(*a1);
    sub_19E3FF824(a1[1]);
    sub_19E3C5DBC((char *)a1[8]);
    sub_19E3C5DBC((char *)a1[5]);
    operator delete(a1);
  }
}

void *sub_19E3FF880(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2)
  {
    uint64_t v3 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x19F3BDCF0](v2, 0x1080C409A65DFB4);
  }
  uint64_t v4 = *(uint64_t **)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v4)
  {
    uint64_t v5 = *v4;
    if (*v4)
    {
      uint64_t v6 = *(void *)(v5 + 24);
      if (v6)
      {
        sub_19E4AB828(v6 + 8);
        MEMORY[0x19F3BDCF0](v6, 0x1020C403F824CD1);
        if (*(void *)v5) {
          free(*(void **)v5);
        }
      }
      MEMORY[0x19F3BDCF0](v5, 0x1030C40FC63861FLL);
    }
    MEMORY[0x19F3BDCF0](v4, 0x20C4093837F09);
  }
  uint64_t result = *(void **)a1;
  if (*(void *)a1) {
    uint64_t result = (void *)munmap(result, *(void *)(a1 + 8));
  }
  *(void *)(a1 + 8) = 0;
  return result;
}

uint64_t *sub_19E3FF96C@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t result = (uint64_t *)(a1 + 56);
  uint64_t v5 = v6;
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = result;
  do
  {
    unsigned int v8 = *(_DWORD *)(v5 + 32);
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint64_t v10 = (uint64_t *)v5;
    }
    else {
      uint64_t v10 = (uint64_t *)(v5 + 8);
    }
    if (v9) {
      uint64_t v7 = (uint64_t *)v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 != result && *((_DWORD *)v7 + 8) <= a2)
  {
    a3[1] = 0;
    a3[2] = 0;
    *a3 = (uint64_t)(a3 + 1);
    sub_19E3C5B70(a3, (void *)v7[5], v7 + 6);
    a3[4] = 0;
    a3[3] = (uint64_t)(a3 + 4);
    uint64_t v11 = a3 + 3;
    v11[2] = 0;
    return sub_19E3C5B70(v11, (void *)v7[8], v7 + 9);
  }
  else
  {
LABEL_12:
    a3[1] = 0;
    *a3 = (uint64_t)(a3 + 1);
    a3[5] = 0;
    a3[4] = 0;
    a3[2] = 0;
    a3[3] = (uint64_t)(a3 + 4);
  }
  return result;
}

void sub_19E3FFA30(_Unwind_Exception *a1)
{
  sub_19E3C5DBC(*v2);
  sub_19E3C5DBC(*v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E3FFA54(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v2 = (void *)(a1 + 32);
  uint64_t v3 = v4;
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v2;
  do
  {
    if ((unint64_t)(v3 + 4) >= a2) {
      uint64_t v6 = v3;
    }
    else {
      uint64_t v6 = v3 + 1;
    }
    if ((unint64_t)(v3 + 4) >= a2) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v6;
  }
  while (*v6);
  unint64_t v7 = (unint64_t)(v5 + 4);
  if (v5 == v2)
  {
    BOOL v8 = 1;
    BOOL v9 = 0;
  }
  else
  {
    BOOL v8 = v7 >= a2;
    BOOL v9 = v7 == a2;
  }
  if (!v9 && v8) {
    return 0;
  }
  else {
    return *((unsigned int *)v5 + 20);
  }
}

void sub_19E3FFA9C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0B9A38;
  sub_19E3FF7C8(*(void **)(a1 + 56));
  sub_19E3FF824(*(void **)(a1 + 32));
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E3FFB0C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0B9A38;
  sub_19E3FF7C8(*(void **)(a1 + 56));
  sub_19E3FF824(*(void **)(a1 + 32));
  return a1;
}

uint64_t sub_19E3FFB5C(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = *(char **)v2;
      uint64_t v6 = *((void *)v2 + 5);
      if (v6)
      {
        uint64_t v7 = *((void *)v2 + 6);
        BOOL v8 = (void *)*((void *)v2 + 5);
        if (v7 != v6)
        {
          do
          {
            if (*(char *)(v7 - 1) < 0) {
              operator delete(*(void **)(v7 - 24));
            }
            v7 -= 24;
          }
          while (v7 != v6);
          BOOL v8 = (void *)*((void *)v2 + 5);
        }
        *((void *)v2 + 6) = v6;
        operator delete(v8);
      }
      if (v2[39] < 0) {
        operator delete(*((void **)v2 + 2));
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void sub_19E3FFC1C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_19E3FFD24(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E3FFD60(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__110shared_ptrIN2LM22CompositeLanguageModelEE27__shared_ptr_default_deleteIS2_S2_EE"
    || ((v3 & (unint64_t)"NSt3__110shared_ptrIN2LM22CompositeLanguageModelEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__110shared_ptrIN2LM22CompositeLanguageModelEE27__shared_ptr_default_deleteIS2_S2_EE")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__110shared_ptrIN2LM22CompositeLanguageModelEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E3FFDB8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_19E3FFDE8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E3FFE24(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    sub_19E3C5DBC(*(char **)(a1 + 32));
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_19E3FFE68(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EF0BB550;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  double v99 = (CFTypeRef *)(a1 + 176);
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_DWORD *)(a1 + 360) = -1;
  *(void *)(a1 + 344) = &unk_1EF0B9A38;
  *(void *)(a1 + 352) = 0xC0000000C0000000;
  *(void *)(a1 + 368) = a1 + 376;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = a1 + 400;
  *(_OWORD *)(a1 + 416) = *(_OWORD *)a3;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a1 + 432) = CFRetain(cf);
  *(void *)(a1 + 448) = 50;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  uint64_t v5 = *(void *)(a1 + 416);
  uint64_t v6 = *(void **)(v5 + 8);
  int v91 = *(unsigned __int8 *)(v5 + 16);
  int v96 = *(unsigned __int8 *)(v5 + 17);
  uint64_t v92 = MEMORY[0x19F3BCDE0](v6);
  CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 432);
  memset(buf, 0, sizeof(buf));
  if (!v7
    || !kLMLanguageLocalesKey
    || (Value = CFDictionaryGetValue(v7, (const void *)kLMLanguageLocalesKey)) == 0
    || (CFTypeID TypeID = CFArrayGetTypeID(), TypeID != CFGetTypeID(Value)))
  {
    LOBYTE(cfa[0]) = 0;
    goto LABEL_9;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)Value);
  int v11 = Count;
  if (Count << 32)
  {
    if (Count << 32 < 0) {
      sub_19E37C7C4();
    }
    int v12 = (char *)operator new(8 * (int)Count);
    uint64_t v13 = &v12[8 * v11];
    int64x2_t v14 = vdupq_n_s64((unint64_t)v12);
  }
  else
  {
    uint64_t v13 = 0;
    int64x2_t v14 = 0uLL;
  }
  int64x2_t v97 = v14;
  uint64_t v95 = v6;
  if (v11 < 1)
  {
LABEL_138:
    *(int64x2_t *)cfa = v97;
    uint64_t v84 = v97.i64[1];
    double v105 = 0;
    uint64_t v106 = 0;
    signed int v104 = 0;
    sub_19E3CF1CC(&v104, (CFTypeRef *)v97.i64[0], (CFTypeRef *)v97.i64[1], (v97.i64[1] - v97.i64[0]) >> 3);
    uint64_t v6 = v95;
    if (v97.i64[0])
    {
      while (v84 != v97.i64[0])
      {
        uint64_t v86 = *(const void **)(v84 - 8);
        v84 -= 8;
        uint64_t v85 = v86;
        if (v86) {
          CFRelease(v85);
        }
      }
      operator delete((void *)v97.i64[0]);
    }
    goto LABEL_10;
  }
  CFIndex v59 = 0;
  uint64_t v90 = v11;
  while (1)
  {
    unint64_t v3 = (unint64_t)Value;
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)Value, v59);
    int v61 = ValueAtIndex;
    if (!ValueAtIndex) {
      break;
    }
    CFRetain(ValueAtIndex);
    CFTypeID v62 = CFGetTypeID(v61);
    if (v62 != CFStringGetTypeID())
    {
      CFRelease(v61);
      break;
    }
    size_t v63 = (char *)v97.i64[1];
    v64.i64[0] = v97.i64[0];
    if (v97.i64[1] >= (unint64_t)v13)
    {
      std::string::size_type v65 = (char *)v97.i64[0];
      uint64_t v66 = (v97.i64[1] - v97.i64[0]) >> 3;
      unint64_t v67 = v66 + 1;
      if ((unint64_t)(v66 + 1) >> 61) {
        sub_19E37C7C4();
      }
      if ((uint64_t)&v13[-v97.i64[0]] >> 2 > v67) {
        unint64_t v67 = (uint64_t)&v13[-v97.i64[0]] >> 2;
      }
      if ((unint64_t)&v13[-v97.i64[0]] >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v68 = v67;
      }
      if (v68)
      {
        if (v68 >> 61) {
          sub_19E37C2B8();
        }
        long long v69 = (char *)operator new(8 * v68);
      }
      else
      {
        long long v69 = 0;
      }
      uint64_t v70 = &v69[8 * v66];
      *(void *)uint64_t v70 = v61;
      size_t v71 = v70 + 8;
      uint64_t v72 = v97.i64[1] - v97.i64[0];
      if (v97.i64[1] == v97.i64[0])
      {
        uint64_t v98 = &v69[8 * v66];
      }
      else
      {
        unint64_t v73 = v72 - 8;
        if ((unint64_t)(v72 - 8) < 0x78)
        {
          uint64_t v74 = (void *)v97.i64[1];
          goto LABEL_133;
        }
        if ((unint64_t)&v69[v97.i64[1] - v97.i64[0] - (v73 & 0xFFFFFFFFFFFFFFF8) - 8] < v97.i64[1]
          && (uint64_t v74 = (void *)v97.i64[1], v97.i64[1] - (v73 & 0xFFFFFFFFFFFFFFF8) - 8 < (unint64_t)v70))
        {
          do
          {
LABEL_133:
            uint64_t v81 = *--v74;
            *((void *)v70 - 1) = v81;
            v70 -= 8;
            *uint64_t v74 = 0;
          }
          while (v74 != (void *)v97.i64[0]);
        }
        else
        {
          uint64_t v76 = (v73 >> 3) + 1;
          v70 -= 8 * (v76 & 0x3FFFFFFFFFFFFFFCLL);
          double v77 = (_OWORD *)(v97.i64[1] - 32);
          uint64_t v78 = &v69[8 * v66 - 16];
          uint64_t v79 = v76 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v80 = v77[1];
            *((_OWORD *)v78 - 1) = *v77;
            *(_OWORD *)uint64_t v78 = v80;
            *double v77 = 0uLL;
            v77[1] = 0uLL;
            v77 -= 2;
            v78 -= 32;
            v79 -= 4;
          }
          while (v79);
          if (v76 != (v76 & 0x3FFFFFFFFFFFFFFCLL))
          {
            uint64_t v74 = (void *)(v97.i64[1] - 8 * (v76 & 0x3FFFFFFFFFFFFFFCLL));
            goto LABEL_133;
          }
        }
        uint64_t v98 = v70;
        while (v63 != v65)
        {
          int v83 = (const void *)*((void *)v63 - 1);
          v63 -= 8;
          size_t v82 = v83;
          if (v83) {
            CFRelease(v82);
          }
        }
      }
      if (v65) {
        operator delete(v65);
      }
      uint64_t v13 = &v69[8 * v68];
      v75.i64[0] = (uint64_t)v98;
      v75.i64[1] = (uint64_t)v71;
      int64x2_t v97 = v75;
      goto LABEL_106;
    }
    *(void *)v97.i64[1] = v61;
    v64.i64[1] = v97.i64[1] + 8;
    int64x2_t v97 = v64;
LABEL_106:
    if (++v59 == v90) {
      goto LABEL_138;
    }
  }
  LOBYTE(cfa[0]) = 0;
  uint64_t v6 = v95;
  if (v97.i64[0])
  {
    double v87 = (char *)v97.i64[1];
    if (v97.i64[1] != v97.i64[0])
    {
      do
      {
        int v89 = (const void *)*((void *)v87 - 1);
        v87 -= 8;
        uint64_t v88 = v89;
        if (v89) {
          CFRelease(v88);
        }
      }
      while (v87 != (char *)v97.i64[0]);
      double v87 = (char *)v97.i64[0];
    }
    operator delete(v87);
  }
LABEL_9:
  signed int v104 = 0;
  double v105 = 0;
  uint64_t v106 = 0;
LABEL_10:
  uint64_t v16 = v104;
  int v15 = v105;
  if (v104 == v105)
  {
    uint64_t v17 = 0;
    CFIndex v30 = v99;
    if (!v105) {
      goto LABEL_39;
    }
    goto LABEL_32;
  }
  BOOL v94 = v6;
  uint64_t v17 = 0;
  do
  {
    CFLocaleRef v18 = CFLocaleCreate(0, *v16);
    if (v18)
    {
      cfa[0] = v18;
      if ((unint64_t)v17 < *(void *)&buf[16])
      {
        *(void *)uint64_t v17 = v18;
        v17 += 8;
        *(void *)&buf[8] = v17;
      }
      else
      {
        uint64_t v17 = sub_19E42ECB8((char **)buf, cfa);
        *(void *)&buf[8] = v17;
        if (cfa[0]) {
          CFRelease(cfa[0]);
        }
      }
    }
    else
    {
      if (qword_1EC009490 == -1)
      {
        CFStringRef v19 = *v16;
        if (!*v16) {
          goto LABEL_28;
        }
      }
      else
      {
        dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
        CFStringRef v19 = *v16;
        if (!*v16)
        {
LABEL_28:
          exception = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x19F3BD790](exception, "Could not construct");
          __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
        }
      }
      uint64_t v20 = (int *)qword_1EC009488;
      CFTypeID v21 = CFStringGetTypeID();
      v3 &= 0xFFFFFFFFFFFFFF00;
      if (v21 == CFGetTypeID(v19))
      {
        sub_19E3C6934(cfa, v19);
        unsigned int v28 = cfa;
        if (v101 < 0) {
          LOBYTE(v28) = cfa[0];
        }
      }
      else
      {
        cfa[0] = (CFTypeRef)v3;
        char v101 = 0;
        unsigned int v28 = cfa;
      }
      sub_19E4E4498(v20, v22, "Unable to construct locale: %s", v23, v24, v25, v26, v27, (char)v28);
      if (v101 < 0) {
        operator delete((void *)cfa[0]);
      }
    }
    ++v16;
  }
  while (v16 != v15);
  int v15 = v104;
  uint64_t v6 = v94;
  CFIndex v30 = v99;
  if (v104)
  {
LABEL_32:
    uint64_t v31 = v105;
    uint64_t v32 = v15;
    if (v105 != v15)
    {
      do
      {
        uint64_t v34 = *--v31;
        uint64_t v33 = v34;
        if (v34) {
          CFRelease(v33);
        }
      }
      while (v31 != v15);
      uint64_t v32 = v104;
    }
    double v105 = v15;
    operator delete(v32);
    uint64_t v17 = *(char **)&buf[8];
  }
LABEL_39:
  if (*(char **)buf == v17)
  {
    CFArrayRef v35 = 0;
    if (v17) {
      goto LABEL_44;
    }
LABEL_41:
    CFTypeRef v36 = *v30;
    if (*v30) {
LABEL_49:
    }
      CFRelease(v36);
  }
  else
  {
    CFArrayRef v35 = sub_19E400E28(*(char **)buf, v17);
    uint64_t v17 = *(char **)buf;
    if (!*(void *)buf) {
      goto LABEL_41;
    }
LABEL_44:
    for (uint64_t i = *(char **)&buf[8]; i != v17; i -= 8)
    {
      uint64_t v39 = (const void *)*((void *)i - 1);
      uint64_t v38 = v39;
      if (v39) {
        CFRelease(v38);
      }
    }
    *(void *)&buf[8] = v17;
    operator delete(v17);
    CFTypeRef v36 = *v30;
    if (*v30) {
      goto LABEL_49;
    }
  }
  *CFIndex v30 = v35;
  if (v35 && CFArrayGetCount(v35))
  {
LABEL_65:
    CFTypeRef v46 = *v30;
    if (*v30) {
      CFRetain(*v30);
    }
    sub_19E40100C(cfa, v46);
    CFArrayRef v47 = (const __CFArray *)cfa[0];
    if (cfa[0])
    {
      CFIndex v48 = CFArrayGetCount((CFArrayRef)cfa[0]);
      CFIndex v49 = v48;
      CFArrayRef v50 = (const __CFArray *)cfa[0];
      if (cfa[0])
      {
        CFIndex v51 = CFArrayGetCount((CFArrayRef)cfa[0]);
        if (!v49) {
          goto LABEL_75;
        }
      }
      else
      {
        CFIndex v51 = 0;
        if (!v48) {
          goto LABEL_75;
        }
      }
      if (v47 != v50 || v51)
      {
        sub_19E4010C4(buf, v47, 0);
        operator new();
      }
    }
LABEL_75:
    sub_19E4B8A80((uint64_t)&v104, *v30);
    if (v96)
    {
      if (qword_1EC009588 != -1) {
        dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
      }
      uint64_t v52 = qword_1EC009580;
      if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v53 = (void **)&v104;
        if (v106 < 0) {
          uint64_t v53 = (void **)v104;
        }
        *(_DWORD *)buf = 138412802;
        *(void *)&uint8_t buf[4] = v92;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v53;
        *(_WORD *)&buf[22] = 2112;
        CFTypeRef v103 = cf;
        uint64_t v54 = "Creating Siri CompositeLanguageModel (%@) for locale(s) (%s):\n%@";
LABEL_95:
        _os_log_impl(&dword_19E36B000, v52, OS_LOG_TYPE_DEFAULT, v54, buf, 0x20u);
      }
    }
    else if (v91)
    {
      if (qword_1EC009588 != -1) {
        dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
      }
      uint64_t v52 = qword_1EC009580;
      if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_DEFAULT))
      {
        double v55 = (void **)&v104;
        if (v106 < 0) {
          double v55 = (void **)v104;
        }
        *(_DWORD *)buf = 138412802;
        *(void *)&uint8_t buf[4] = v92;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v55;
        *(_WORD *)&buf[22] = 2112;
        CFTypeRef v103 = cf;
        uint64_t v54 = "Creating multilingual CompositeLanguageModel (%@) for locale(s) (%s):\n%@";
        goto LABEL_95;
      }
    }
    else
    {
      if (qword_1EC009588 != -1) {
        dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
      }
      uint64_t v52 = qword_1EC009580;
      if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v56 = (void **)&v104;
        if (v106 < 0) {
          uint64_t v56 = (void **)v104;
        }
        *(_DWORD *)buf = 138412802;
        *(void *)&uint8_t buf[4] = v92;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v56;
        *(_WORD *)&buf[22] = 2112;
        CFTypeRef v103 = cf;
        uint64_t v54 = "Creating CompositeLanguageModel (%@) for locale(s) (%s):\n%@";
        goto LABEL_95;
      }
    }
    if (SHIBYTE(v106) < 0)
    {
      operator delete(v104);
      CFTypeRef v57 = cfa[0];
      if (!cfa[0]) {
        return a1;
      }
    }
    else
    {
      CFTypeRef v57 = cfa[0];
      if (!cfa[0]) {
        return a1;
      }
    }
    CFRelease(v57);
    return a1;
  }
  if (v6)
  {
    CFRetain(v6);
    signed int v104 = (CFLocaleIdentifier *)v6;
    sub_19E400D38(buf, (CFTypeRef *)&v104, 1uLL);
    CFArrayRef v40 = sub_19E400E28(*(char **)buf, *(char **)&buf[8]);
    if (*v30) {
      CFRelease(*v30);
    }
    *CFIndex v30 = v40;
    uint64_t v41 = *(void *)buf;
    if (*(void *)buf)
    {
      uint64_t v42 = *(void *)&buf[8];
      uint64_t v43 = *(void **)buf;
      if (*(void *)&buf[8] != *(void *)buf)
      {
        do
        {
          unint64_t v45 = *(const void **)(v42 - 8);
          v42 -= 8;
          uint64_t v44 = v45;
          if (v45) {
            CFRelease(v44);
          }
        }
        while (v42 != v41);
        uint64_t v43 = *(void **)buf;
      }
      *(void *)&buf[8] = v41;
      operator delete(v43);
    }
    if (v104) {
      CFRelease(v104);
    }
    goto LABEL_65;
  }
  return a1;
}

void sub_19E400990(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E400D38(void *a1, CFTypeRef *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v5 = a3;
    uint64_t v6 = operator new(8 * a3);
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[v5];
    do
    {
      CFTypeRef v7 = *a2;
      if (*a2) {
        CFRetain(*a2);
      }
      *v6++ = v7;
      ++a2;
      --v5;
    }
    while (v5 * 8);
    a1[1] = v6;
  }
  return a1;
}

void sub_19E400DD4(_Unwind_Exception *exception_object)
{
  unint64_t v3 = (char *)*v1;
  if (*v1)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = *v1;
    if (v4 != v3)
    {
      do
      {
        CFTypeRef v7 = (const void *)*((void *)v4 - 1);
        v4 -= 8;
        uint64_t v6 = v7;
        if (v7) {
          CFRelease(v6);
        }
      }
      while (v4 != v3);
      uint64_t v5 = *v1;
    }
    v1[1] = v3;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef sub_19E400E28(char *a1, char *a2)
{
  size_t v2 = a2 - a1;
  if (a2 == a1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    goto LABEL_13;
  }
  if ((v2 & 0x8000000000000000) != 0) {
    sub_19E37C7C4();
  }
  uint64_t v4 = a1;
  uint64_t v5 = (char *)operator new(a2 - a1);
  bzero(v5, v2);
  uint64_t v6 = &v5[v2];
  if (v2 - 8 < 0x18)
  {
    uint64_t v10 = v5;
    do
    {
LABEL_12:
      uint64_t v14 = *(void *)v4;
      v4 += 8;
      *(void *)uint64_t v10 = v14;
      v10 += 8;
    }
    while (v4 != a2);
    goto LABEL_13;
  }
  if ((unint64_t)(v5 - v4) < 0x20)
  {
    uint64_t v10 = v5;
    goto LABEL_12;
  }
  uint64_t v7 = 0;
  unint64_t v8 = ((v2 - 8) >> 3) + 1;
  uint64_t v9 = 8 * (v8 & 0x3FFFFFFFFFFFFFFCLL);
  uint64_t v10 = &v5[v9];
  uint64_t v11 = v8 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    int v12 = &v5[v7];
    long long v13 = *(_OWORD *)&v4[v7 + 16];
    *(_OWORD *)int v12 = *(_OWORD *)&v4[v7];
    *((_OWORD *)v12 + 1) = v13;
    v7 += 32;
    v11 -= 4;
  }
  while (v11);
  if (v8 != (v8 & 0x3FFFFFFFFFFFFFFCLL))
  {
    v4 += v9;
    goto LABEL_12;
  }
LABEL_13:
  CFArrayRef v15 = CFArrayCreate(0, (const void **)v5, (v6 - v5) >> 3, MEMORY[0x1E4F1D510]);
  if (!v15)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  if (v5) {
    operator delete(v5);
  }
  return v15;
}

void sub_19E400F74(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

void **sub_19E400F9C(void **a1)
{
  size_t v2 = (char *)*a1;
  if (*a1)
  {
    unint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = (const void *)*((void *)v3 - 1);
        v3 -= 8;
        uint64_t v5 = v6;
        if (v6) {
          CFRelease(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void *sub_19E40100C(void *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFArrayGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  return a1;
}

void sub_19E401094(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

CFTypeRef sub_19E4010C4(void *a1, CFArrayRef theArray, unint64_t a3)
{
  if (CFArrayGetCount(theArray) <= a3
    || (ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3), (uint64_t v7 = ValueAtIndex) == 0))
  {
    __cxa_allocate_exception(0x10uLL);
    sub_19E401A0C();
  }
  CFTypeRef result = CFRetain(ValueAtIndex);
  *a1 = v7;
  return result;
}

void sub_19E401134()
{
  __cxa_throw(v0, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_19E401154(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E401174(uint64_t a1)
{
  size_t v2 = *(const void **)(a1 + 136);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  if (v3)
  {
    uint64_t v4 = *(const void **)(v3 + 16);
    if (v4) {
      CFRelease(v4);
    }
    uint64_t v5 = *(const void **)(v3 + 8);
    if (v5) {
      CFRelease(v5);
    }
    MEMORY[0x19F3BDCF0](v3, 0x1060C40950A32C8);
  }
  uint64_t v6 = *(void **)(a1 + 104);
  if (v6)
  {
    uint64_t v7 = *(void **)(a1 + 112);
    unint64_t v8 = *(void **)(a1 + 104);
    if (v7 != v6)
    {
      do
      {
        uint64_t v10 = *--v7;
        uint64_t v9 = v10;
        *uint64_t v7 = 0;
        if (v10) {
          (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
        }
      }
      while (v7 != v6);
      unint64_t v8 = *(void **)(a1 + 104);
    }
    *(void *)(a1 + 112) = v6;
    operator delete(v8);
  }
  uint64_t v11 = *(void **)(a1 + 80);
  if (v11)
  {
    int v12 = *(void **)(a1 + 88);
    long long v13 = *(void **)(a1 + 80);
    if (v12 != v11)
    {
      do
      {
        uint64_t v15 = *--v12;
        uint64_t v14 = v15;
        *int v12 = 0;
        if (v15) {
          (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
        }
      }
      while (v12 != v11);
      long long v13 = *(void **)(a1 + 80);
    }
    *(void *)(a1 + 88) = v11;
    operator delete(v13);
  }
  uint64_t v16 = *(void **)(a1 + 56);
  if (v16)
  {
    uint64_t v17 = *(void **)(a1 + 64);
    CFLocaleRef v18 = *(void **)(a1 + 56);
    if (v17 != v16)
    {
      do
      {
        uint64_t v20 = *--v17;
        uint64_t v19 = v20;
        *uint64_t v17 = 0;
        if (v20) {
          (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
        }
      }
      while (v17 != v16);
      CFLocaleRef v18 = *(void **)(a1 + 56);
    }
    *(void *)(a1 + 64) = v16;
    operator delete(v18);
  }
  CFTypeID v21 = *(void **)(a1 + 32);
  if (v21)
  {
    *(void *)(a1 + 40) = v21;
    operator delete(v21);
  }
  uint64_t v22 = *(void **)(a1 + 8);
  if (v22)
  {
    uint64_t v23 = *(void **)(a1 + 16);
    uint64_t v24 = *(void **)(a1 + 8);
    if (v23 != v22)
    {
      do
      {
        uint64_t v26 = *--v23;
        uint64_t v25 = v26;
        *uint64_t v23 = 0;
        if (v26) {
          (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
        }
      }
      while (v23 != v22);
      uint64_t v24 = *(void **)(a1 + 8);
    }
    *(void *)(a1 + 16) = v22;
    operator delete(v24);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  *(void *)a1 = 0;
  return a1;
}

void sub_19E4013A4(void *a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t)(a1[1] - *a1) >> 4;
  unint64_t v3 = v2 + 1;
  if (!((unint64_t)(v2 + 1) >> 60))
  {
    uint64_t v5 = a1[2] - *a1;
    if (v5 >> 3 > v3) {
      unint64_t v3 = v5 >> 3;
    }
    if ((unint64_t)v5 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v6 = v3;
    }
    if (v6)
    {
      if (v6 >> 60) {
        sub_19E37C2B8();
      }
      uint64_t v7 = operator new(16 * v6);
    }
    else
    {
      uint64_t v7 = 0;
    }
    v7[2 * v2] = a2;
    operator new();
  }
  sub_19E37C7C4();
}

void sub_19E401560(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2)
  {
    uint64_t v4 = sub_19E401174(v2);
    MEMORY[0x19F3BDCF0](v4, 0x10E0C405C30B098);
  }
  sub_19E401884((uint64_t)va);
  _Unwind_Resume(a1);
}

const void **sub_19E401594(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_19E4015C8(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

uint64_t *sub_19E401600(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    CFRelease(*(CFTypeRef *)v2);
    unint64_t v3 = *(void **)(v2 + 16);
    if (v3) {

    }
    MEMORY[0x19F3BDCF0](v2, 0x10E0C40F5622EBCLL);
  }
  return a1;
}

void *sub_19E401660(void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    unint64_t v3 = (void *)a1[1];
    uint64_t v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *unint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void *sub_19E4016F0(void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    unint64_t v3 = (void *)a1[1];
    uint64_t v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *unint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

const void **sub_19E401780(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

void **sub_19E4017B8(void **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v2)
    {
      do
      {
        v3 -= 40;
        sub_19E3FF880(v3);
      }
      while ((void *)v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

const void **sub_19E40181C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

os_log_t sub_19E401854()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "CompositeLanguageModel");
  qword_1EC009580 = (uint64_t)result;
  return result;
}

uint64_t sub_19E401884(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E401930(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__110shared_ptrIN2LM23LocaleSpecificResourcesEE27__shared_ptr_default_deleteIS2_S2_EE"
    || ((v3 & (unint64_t)"NSt3__110shared_ptrIN2LM23LocaleSpecificResourcesEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__110shared_ptrIN2LM23LocaleSpecificResourcesEE27__shared_ptr_default_deleteIS2_S2_EE")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__110shared_ptrIN2LM23LocaleSpecificResourcesEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E401988(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_19E401174(result);
    JUMPOUT(0x19F3BDCF0);
  }
  return result;
}

void sub_19E4019D0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E401A0C()
{
}

void sub_19E401A18(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 416) + 72)) {
    operator new();
  }
  operator new();
}

void sub_19E406E20()
{
}

void sub_19E406E28()
{
  sub_19E3D7338((void **)(v0 - 192));
  JUMPOUT(0x19E406F30);
}

void sub_19E406F08(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_19E37B770(a1);
  }
  _Unwind_Resume(a1);
}

void sub_19E406F10(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x19E406F14);
  }
  _Unwind_Resume(a1);
}

void sub_19E406F18(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x19E406F1CLL);
  }
  sub_19E37B770(a1);
}

__n128 sub_19E40714C(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void sub_19E40715C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

__n128 sub_19E4071D8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void sub_19E4071E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

__n128 sub_19E407264(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void sub_19E407288(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v4 = *(void **)(a1 + 40);
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 40);
    }
    *(void *)(a1 + 48) = v1;
    operator delete(v4);
  }
}

void sub_19E407358(void *a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)a1[22];
  if (qword_1EC009588 != -1) {
    dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
  }
  if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(CFDictionaryRef **)a2;
    LODWORD(valuePtr) = 0;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*v5, @"Type");
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    CFDictionaryGetValue(**(CFDictionaryRef **)a2, @"URL");
    sub_19E3C2CE4();
  }
  uint64_t v7 = *(CFDictionaryRef **)a2;
  LODWORD(valuePtr) = 0;
  CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(*v7, @"Type");
  CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
  switch((int)valuePtr)
  {
    case 0:
      uint64_t v13 = *(void *)(a1[4] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 1:
    case 5:
      uint64_t v13 = *(void *)(a1[6] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 2:
      sub_19E40978C((uint64_t)v4);
      operator new();
    case 4:
      if (!*(void *)(*(void *)(a1[12] + 8) + 40))
      {
        CFDictionaryGetValue(**(CFDictionaryRef **)a2, @"URL");
        sub_19E411A3C();
      }
      return;
    case 7:
      uint64_t v13 = *(void *)(a1[5] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 10:
    case 41:
    case 42:
      uint64_t v9 = *(void *)(a1[18] + 8);
      uint64_t v10 = *(__n128 **)(v9 + 48);
      if ((unint64_t)v10 >= *(void *)(v9 + 56))
      {
        int v12 = sub_19E40CC80(v9 + 40, *(__n128 *)a2);
      }
      else
      {
        v10->n128_u64[0] = *(void *)a2;
        unint64_t v11 = *(void *)(a2 + 8);
        v10->n128_u64[1] = v11;
        if (v11) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
        }
        int v12 = v10 + 1;
      }
      *(void *)(v9 + 48) = v12;
      uint64_t v13 = *(void *)(a1[19] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 12:
      uint64_t v13 = *(void *)(a1[9] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 < *(void *)(v13 + 56)) {
        goto LABEL_60;
      }
      goto LABEL_50;
    case 13:
      uint64_t v18 = a1[10];
      goto LABEL_79;
    case 14:
      uint64_t v18 = a1[11];
LABEL_79:
      uint64_t v15 = *(void *)(v18 + 8);
      goto LABEL_80;
    case 16:
      CFDictionaryGetValue(**(CFDictionaryRef **)a2, @"URL");
      if (v4[13] < v4[14]) {
        sub_19E50B320();
      }
      sub_19E412B7C(v4 + 12);
    case 17:
      CFLocaleRef v24 = *(const __CFLocale **)(v4[52] + 8);
      *(void *)&long long valuePtr = CFDictionaryGetValue(**(CFDictionaryRef **)a2, @"URL");
      CFStringRef v25 = (const __CFString *)CFLocaleGetValue(v24, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
      if (CFStringCompare(v25, @"de", 0))
      {
        if (CFEqual(v25, @"it")
          || CFEqual(v25, @"fr")
          || CFEqual(v25, @"pt")
          || CFEqual(v25, @"es"))
        {
          operator new();
        }
        if (CFEqual(v25, @"ru")) {
          sub_19E4CFC38();
        }
        if (CFEqual(v25, @"tr")) {
          sub_19E4CFCD0();
        }
      }
      uint64_t v30 = v4[42];
      v4[42] = 0;
      if (v30) {
        (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
      }
      return;
    case 20:
      uint64_t v13 = *(void *)(a1[7] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 26:
      uint64_t v13 = *(void *)(a1[8] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 27:
      uint64_t v13 = *(void *)(a1[13] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 29:
      uint64_t v15 = *(void *)(a1[14] + 8);
      if (!*(void *)(v15 + 40)) {
        goto LABEL_80;
      }
      if (qword_1EC009588 != -1) {
        dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
      }
      if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_ERROR)) {
        sub_19E54A118((int)&valuePtr, **(CFDictionaryRef **)(*(void *)(a1[14] + 8) + 40));
      }
      int v16 = 278;
      goto LABEL_77;
    case 30:
      uint64_t v17 = a1[15];
      goto LABEL_34;
    case 31:
      uint64_t v15 = *(void *)(a1[16] + 8);
      if (!*(void *)(v15 + 40)) {
        goto LABEL_80;
      }
      if (qword_1EC009588 != -1) {
        dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
      }
      if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_ERROR)) {
        sub_19E54A118((int)&valuePtr, **(CFDictionaryRef **)(*(void *)(a1[16] + 8) + 40));
      }
      int v16 = 290;
      goto LABEL_77;
    case 34:
      uint64_t v17 = a1[17];
LABEL_34:
      uint64_t v19 = *(void *)(v17 + 8);
      uint64_t v21 = *(void *)(v19 + 40);
      uint64_t v20 = (void *)(v19 + 40);
      if (!v21) {
        sub_19E412D04(v20, *(void *)a2, *(void *)(a2 + 8));
      }
      return;
    case 35:
      if (qword_1EC009588 != -1) {
        dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
      }
      uint64_t v22 = qword_1EC009580;
      if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_ERROR))
      {
        LOWORD(valuePtr) = 0;
        _os_log_error_impl(&dword_19E36B000, v22, OS_LOG_TYPE_ERROR, "Skipping unsupported resource: LanguageModelFSTBlocklistResourceType", (uint8_t *)&valuePtr, 2u);
      }
      return;
    case 40:
      uint64_t v13 = *(void *)(a1[20] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 48:
      uint64_t v13 = *(void *)(a1[7] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 49:
      uint64_t v15 = *(void *)(a1[21] + 8);
      if (*(void *)(v15 + 40))
      {
        if (qword_1EC009588 != -1) {
          dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
        }
        if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_ERROR)) {
          sub_19E54A118((int)&valuePtr, **(CFDictionaryRef **)(*(void *)(a1[21] + 8) + 40));
        }
        int v16 = 320;
LABEL_77:
        __assert_rtn("initialize_block_invoke", "LMCompositeLanguageModel.cpp", v16, "false");
      }
LABEL_80:
      unsigned int v28 = *(CFDictionaryRef **)a2;
      uint64_t v27 = *(void *)(a2 + 8);
      if (v27) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v29 = *(std::__shared_weak_count **)(v15 + 48);
      *(void *)(v15 + 40) = v28;
      *(void *)(v15 + 48) = v27;
      if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
      break;
    case 50:
      uint64_t v13 = *(void *)(a1[18] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 >= *(void *)(v13 + 56)) {
        goto LABEL_50;
      }
      goto LABEL_60;
    case 52:
      uint64_t v13 = *(void *)(a1[19] + 8);
      uint64_t v14 = *(__n128 **)(v13 + 48);
      if ((unint64_t)v14 < *(void *)(v13 + 56))
      {
LABEL_60:
        v14->n128_u64[0] = *(void *)a2;
        unint64_t v26 = *(void *)(a2 + 8);
        v14->n128_u64[1] = v26;
        if (v26) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v23 = v14 + 1;
      }
      else
      {
LABEL_50:
        uint64_t v23 = sub_19E40CC80(v13 + 40, *(__n128 *)a2);
      }
      *(void *)(v13 + 48) = v23;
      break;
    default:
      return;
  }
}

void sub_19E4081F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,long long __p,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50)
{
  if (a29 < 0) {
    operator delete((void *)__p);
  }
  if (a23 < 0)
  {
    operator delete(a18);
    if ((v53 & 1) == 0) {
      goto LABEL_8;
    }
  }
  else if (!v53)
  {
LABEL_8:
    a31 = (void *)*MEMORY[0x1E4FBA408];
    uint64_t v58 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(void **)((char *)&a31 + *(a31 - 3)) = *(void **)(MEMORY[0x1E4FBA408] + 64);
    a33 = v58;
    a34 = MEMORY[0x1E4FBA470] + 16;
    if (a47 < 0) {
      operator delete(a42);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x19F3BDC30](&a50);
    if (*v51) {
      munmap(*v51, *(void *)(v50 + 32));
    }
    *(void *)(v50 + 32) = 0;
    if (a17 < 0) {
      operator delete(a12);
    }
    MEMORY[0x19F3BDCF0](v50, 0x10F1C40E875E8CALL);
    if (a2 == 1)
    {
      CFIndex v59 = __cxa_begin_catch(a1);
      if (*(void *)(v54 + 1416) != -1) {
        dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
      }
      unint64_t v60 = *(NSObject **)(v55 + 1408);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        uint64_t v61 = (*(uint64_t (**)(void *))(*(void *)v59 + 16))(v59);
        LODWORD(__p) = 136315138;
        *(void *)((char *)&__p + 4) = v61;
        _os_log_error_impl(&dword_19E36B000, v60, OS_LOG_TYPE_ERROR, "Resource initialization failed: %s", (uint8_t *)&__p, 0xCu);
      }
      __cxa_end_catch();
      JUMPOUT(0x19E407ADCLL);
    }
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v52);
  goto LABEL_8;
}

void sub_19E4086B8(void *a1, CFTypeRef cf)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  if ((CFTypeRef)a1[22] != cf)
  {
    CFRetain(cf);
    uint64_t v4 = (const void *)a1[22];
    if (v4) {
      CFRelease(v4);
    }
    a1[22] = cf;
  }
  uint64_t v65 = (uint64_t)a1;
  uint64_t v5 = a1[23];
  uint64_t v7 = a1[24];
  for (uint64_t i = (const void ****)(a1 + 23); v7 != v5; v7 -= 16)
  {
    CFNumberRef v8 = *(std::__shared_weak_count **)(v7 - 8);
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  *(void *)(v65 + 192) = v5;
  if (!cf)
  {
    CFArrayRef theArray = 0;
    goto LABEL_17;
  }
  CFRetain(cf);
  sub_19E40100C(&theArray, cf);
  CFArrayRef v9 = theArray;
  if (!theArray) {
    goto LABEL_17;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  CFIndex v11 = Count;
  CFArrayRef v12 = theArray;
  if (theArray)
  {
    CFIndex v13 = CFArrayGetCount(theArray);
    if (!v11) {
      goto LABEL_17;
    }
  }
  else
  {
    CFIndex v13 = 0;
    if (!Count) {
      goto LABEL_17;
    }
  }
  if (v9 != v12 || v13)
  {
    sub_19E4010C4(cfa, v9, 0);
    operator new();
  }
LABEL_17:
  uint64_t v14 = *(std::recursive_mutex **)(v65 + 464);
  if (v14) {
    sub_19E4B383C(v14, v65, *(const __CFArray **)(v65 + 176));
  }
  uint64_t v15 = *(void *)(v65 + 416);
  int v16 = *(unsigned __int8 *)(v15 + 16);
  int v17 = *(unsigned __int8 *)(v15 + 17);
  uint64_t v18 = MEMORY[0x19F3BCDE0](*(void *)(v15 + 8));
  sub_19E4B8A80((uint64_t)v66, cf);
  if (v17)
  {
    if (qword_1EC009588 != -1) {
      dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
    }
    uint64_t v19 = v65;
    uint64_t v20 = qword_1EC009580;
    if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = v66;
      if (v67 < 0) {
        uint64_t v21 = (void **)v66[0];
      }
      *(_DWORD *)cfa = 138412546;
      *(void *)&cfa[4] = v18;
      *(_WORD *)&cfa[12] = 2080;
      *(void *)&cfa[14] = v21;
      uint64_t v22 = "Reloading Siri CompositeLanguageModel (%@) for locale(s) (%s)";
LABEL_43:
      _os_log_impl(&dword_19E36B000, v20, OS_LOG_TYPE_DEFAULT, v22, cfa, 0x16u);
    }
  }
  else if (v16)
  {
    if (qword_1EC009588 != -1) {
      dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
    }
    uint64_t v19 = v65;
    uint64_t v20 = qword_1EC009580;
    if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = v66;
      if (v67 < 0) {
        uint64_t v23 = (void **)v66[0];
      }
      *(_DWORD *)cfa = 138412546;
      *(void *)&cfa[4] = v18;
      *(_WORD *)&cfa[12] = 2080;
      *(void *)&cfa[14] = v23;
      uint64_t v22 = "Reloading multilingual CompositeLanguageModel (%@) for locale(s) (%s)";
      goto LABEL_43;
    }
  }
  else
  {
    if (qword_1EC009588 != -1) {
      dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
    }
    uint64_t v19 = v65;
    uint64_t v20 = qword_1EC009580;
    if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_DEFAULT))
    {
      CFLocaleRef v24 = v66;
      if (v67 < 0) {
        CFLocaleRef v24 = (void **)v66[0];
      }
      *(_DWORD *)cfa = 138412546;
      *(void *)&cfa[4] = v18;
      *(_WORD *)&cfa[12] = 2080;
      *(void *)&cfa[14] = v24;
      uint64_t v22 = "Reloading CompositeLanguageModel (%@) for locale (%s)";
      goto LABEL_43;
    }
  }
  sub_19E4B9684(*(void *)(v19 + 416), *(CFDictionaryRef *)(v19 + 432), *(unsigned __int8 *)(*(void *)(v19 + 232) + 344), i);
  sub_19E40A6EC((void *)v19);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *(CFDictionaryRef *)(v19 + 432));
  CFMutableDictionaryRef theDict = MutableCopy;
  CFDictionaryRemoveValue(MutableCopy, (const void *)kLMLanguageLocalesKey);
  CFDictionarySetValue(MutableCopy, (const void *)kLMLanguageModelIgnoreSystemLanguageModelsKey, (const void *)*MEMORY[0x1E4F1CFD0]);
  CFDictionarySetValue(MutableCopy, (const void *)kLMLanguageModelIsMultilingualModelKey, (const void *)*MEMORY[0x1E4F1CFC8]);
  unint64_t v26 = *(uint64_t ***)(v19 + 184);
  int64x2_t v64 = *(uint64_t ***)(v19 + 192);
  if (v26 == v64) {
    goto LABEL_149;
  }
  do
  {
    sub_19E410C70(&v75, **v26);
    char v84 = 7;
    strcpy(cfa, "hi-Latn");
    char v86 = 7;
    strcpy((char *)v85, "gu-Latn");
    char v88 = 7;
    strcpy((char *)v87, "mr-Latn");
    char v90 = 7;
    strcpy((char *)v89, "te-Latn");
    char v92 = 7;
    strcpy((char *)v91, "ta-Latn");
    char v94 = 7;
    strcpy((char *)v93, "pa-Latn");
    char v96 = 7;
    strcpy((char *)v95, "bn-Latn");
    *(_OWORD *)std::string __p = 0u;
    *(_OWORD *)uint64_t v81 = 0u;
    int v82 = 1065353216;
    sub_19E3F0660((uint64_t)__p, (uint64_t)cfa, (uint64_t)cfa);
    sub_19E3F0660((uint64_t)__p, (uint64_t)v85, (uint64_t)v85);
    sub_19E3F0660((uint64_t)__p, (uint64_t)v87, (uint64_t)v87);
    sub_19E3F0660((uint64_t)__p, (uint64_t)v89, (uint64_t)v89);
    sub_19E3F0660((uint64_t)__p, (uint64_t)v91, (uint64_t)v91);
    sub_19E3F0660((uint64_t)__p, (uint64_t)v93, (uint64_t)v93);
    sub_19E3F0660((uint64_t)__p, (uint64_t)v95, (uint64_t)v95);
    if (v96 < 0)
    {
      operator delete(v95[0]);
      if ((v94 & 0x80000000) == 0)
      {
LABEL_49:
        if ((v92 & 0x80000000) == 0) {
          goto LABEL_50;
        }
        goto LABEL_68;
      }
    }
    else if ((v94 & 0x80000000) == 0)
    {
      goto LABEL_49;
    }
    operator delete(v93[0]);
    if ((v92 & 0x80000000) == 0)
    {
LABEL_50:
      if ((v90 & 0x80000000) == 0) {
        goto LABEL_51;
      }
      goto LABEL_69;
    }
LABEL_68:
    operator delete(v91[0]);
    if ((v90 & 0x80000000) == 0)
    {
LABEL_51:
      if ((v88 & 0x80000000) == 0) {
        goto LABEL_52;
      }
      goto LABEL_70;
    }
LABEL_69:
    operator delete(v89[0]);
    if ((v88 & 0x80000000) == 0)
    {
LABEL_52:
      if (v86 < 0) {
        goto LABEL_71;
      }
      goto LABEL_53;
    }
LABEL_70:
    operator delete(v87[0]);
    if (v86 < 0)
    {
LABEL_71:
      operator delete(v85[0]);
      if ((v84 & 0x80000000) == 0) {
        goto LABEL_54;
      }
      goto LABEL_72;
    }
LABEL_53:
    if ((v84 & 0x80000000) == 0) {
      goto LABEL_54;
    }
LABEL_72:
    operator delete(*(void **)cfa);
LABEL_54:
    if (sub_19E4B9E40(__p, (uint64_t)&v75))
    {
      unint64_t v27 = v77;
      if ((v77 & 0x80u) != 0) {
        unint64_t v27 = (unint64_t)v76;
      }
      if (v27 >= 2) {
        size_t v28 = 2;
      }
      else {
        size_t v28 = v27;
      }
      char v84 = v28;
      if (v28)
      {
        if ((v77 & 0x80u) == 0) {
          uint64_t v29 = &v75;
        }
        else {
          uint64_t v29 = v75;
        }
        uint64_t v30 = cfa;
        memmove(cfa, v29, v28);
        int v31 = v84;
        cfa[v28] = 0;
        if (v31 < 0)
        {
          uint64_t v30 = *(const UInt8 **)cfa;
          if (!*(void *)cfa)
          {
            CFArrayRef v35 = 0;
            CFTypeRef v73 = 0;
            goto LABEL_90;
          }
          CFIndex v32 = *(void *)&cfa[8];
        }
        else
        {
          CFIndex v32 = v31;
        }
      }
      else
      {
        CFIndex v32 = 0;
        cfa[0] = 0;
        uint64_t v30 = cfa;
      }
      uint64_t v30 = (const UInt8 *)CFStringCreateWithBytes(0, v30, v32, 0x8000100u, 0);
      CFTypeRef v73 = v30;
      if (!v30)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      if (v84 < 0)
      {
        CFArrayRef v35 = *(void **)cfa;
LABEL_90:
        operator delete(v35);
      }
    }
    else
    {
      if ((v77 & 0x80u) == 0) {
        uint64_t v33 = (const UInt8 *)&v75;
      }
      else {
        uint64_t v33 = (const UInt8 *)v75;
      }
      if (v33)
      {
        if ((v77 & 0x80u) == 0) {
          CFIndex v34 = v77;
        }
        else {
          CFIndex v34 = (CFIndex)v76;
        }
        uint64_t v30 = (const UInt8 *)CFStringCreateWithBytes(0, v33, v34, 0x8000100u, 0);
        CFTypeRef v73 = v30;
        if (!v30)
        {
          size_t v63 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x19F3BD790](v63, "Could not construct");
          __cxa_throw(v63, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
        }
      }
      else
      {
        uint64_t v30 = 0;
        CFTypeRef v73 = 0;
      }
    }
    CFLocaleRef v36 = CFLocaleCreate(0, (CFLocaleIdentifier)v30);
    CFTypeRef v78 = v36;
    if (v73) {
      CFRelease(v73);
    }
    char v37 = (void **)v81[0];
    if (v81[0])
    {
      do
      {
        uint64_t v43 = (void **)*v37;
        if (*((char *)v37 + 39) < 0) {
          operator delete(v37[2]);
        }
        operator delete(v37);
        char v37 = v43;
      }
      while (v43);
    }
    uint64_t v38 = __p[0];
    __p[0] = 0;
    if (v38) {
      operator delete(v38);
    }
    if ((char)v77 < 0) {
      operator delete(v75);
    }
    CFDictionaryRef v39 = theDict;
    CFDictionarySetValue(theDict, (const void *)kLMLanguageModelLocaleKey, v36);
    sub_19E4300A4((uint64_t)cfa, v39);
    sub_19E432C84((char **)__p, *(CFTypeRef *)cfa, 42);
    sub_19E432C84((char **)&v75, *(CFTypeRef *)cfa, 10);
    sub_19E4114EC(__p, (uint64_t)__p[1], v75, v76, (v76 - (unsigned char *)v75) >> 4);
    sub_19E432C84((char **)&v73, *(CFTypeRef *)cfa, 41);
    sub_19E4114EC(__p, (uint64_t)__p[1], v73, v74, (v74 - (unsigned char *)v73) >> 4);
    sub_19E432C84((char **)&v71, *(CFTypeRef *)cfa, 50);
    sub_19E432C84((char **)&v69, *(CFTypeRef *)cfa, 52);
    sub_19E4114EC(&v69, (uint64_t)v70, (void *)__p[0], (void *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 4);
    sub_19E4114EC(&v71, (uint64_t)v72, (void *)__p[0], (void *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 4);
    sub_19E409914((uint64_t)*v26, (__n128 **)&v71, (uint64_t)&v69);
    CFArrayRef v40 = (char *)v69;
    if (v69)
    {
      uint64_t v41 = v70;
      uint64_t v42 = v69;
      if (v70 != v69)
      {
        do
        {
          uint64_t v44 = (std::__shared_weak_count *)*((void *)v41 - 1);
          if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
          v41 -= 16;
        }
        while (v41 != v40);
        uint64_t v42 = v69;
      }
      uint64_t v70 = v40;
      operator delete(v42);
    }
    unint64_t v45 = (char *)v71;
    if (v71)
    {
      CFTypeRef v46 = v72;
      CFArrayRef v47 = v71;
      if (v72 != v71)
      {
        do
        {
          CFIndex v48 = (std::__shared_weak_count *)*((void *)v46 - 1);
          if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
            std::__shared_weak_count::__release_weak(v48);
          }
          v46 -= 16;
        }
        while (v46 != v45);
        CFArrayRef v47 = v71;
      }
      uint64_t v72 = v45;
      operator delete(v47);
    }
    CFIndex v49 = (char *)v73;
    if (v73)
    {
      uint64_t v50 = v74;
      CFIndex v51 = (void *)v73;
      if (v74 != v73)
      {
        do
        {
          uint64_t v52 = (std::__shared_weak_count *)*((void *)v50 - 1);
          if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
            std::__shared_weak_count::__release_weak(v52);
          }
          v50 -= 16;
        }
        while (v50 != v49);
        CFIndex v51 = (void *)v73;
      }
      uint64_t v74 = v49;
      operator delete(v51);
    }
    int v53 = (char *)v75;
    if (v75)
    {
      uint64_t v54 = v76;
      uint64_t v55 = v75;
      if (v76 != v75)
      {
        do
        {
          uint64_t v56 = (std::__shared_weak_count *)*((void *)v54 - 1);
          if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
            std::__shared_weak_count::__release_weak(v56);
          }
          v54 -= 16;
        }
        while (v54 != v53);
        uint64_t v55 = v75;
      }
      uint64_t v76 = v53;
      operator delete(v55);
    }
    CFTypeRef v57 = (char *)__p[0];
    if (__p[0])
    {
      uint64_t v58 = (char *)__p[1];
      CFIndex v59 = __p[0];
      if (__p[1] != __p[0])
      {
        do
        {
          unint64_t v60 = (std::__shared_weak_count *)*((void *)v58 - 1);
          if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
            std::__shared_weak_count::__release_weak(v60);
          }
          v58 -= 16;
        }
        while (v58 != v57);
        CFIndex v59 = __p[0];
      }
      __p[1] = v57;
      operator delete(v59);
    }
    sub_19E3D7458((uint64_t)cfa);
    if (v78) {
      CFRelease(v78);
    }
    v26 += 2;
  }
  while (v26 != v64);
  MutableCopy = theDict;
  uint64_t v19 = v65;
LABEL_149:
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (*(unsigned char *)(*(void *)(v19 + 232) + 192)
    && *(void *)(v65 + 48)
    && *(void *)(v65 + 272)
    && *(void *)(v65 + 184) != *(void *)(v65 + 192))
  {
    (*(void (**)(void, uint64_t))(**(void **)(*(void *)(v65 + 272) + 8) + 72))(*(void *)(*(void *)(v65 + 272) + 8), *(void *)(v65 + 232) + 88);
    operator new();
  }
  sub_19E40A984((void *)v65);
  if (v67 < 0)
  {
    operator delete(v66[0]);
    CFArrayRef v61 = theArray;
    if (theArray) {
      goto LABEL_160;
    }
  }
  else
  {
    CFArrayRef v61 = theArray;
    if (!theArray) {
      return;
    }
LABEL_160:
    CFRelease(v61);
  }
}

void sub_19E409480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,char a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_19E37B770(exception_object);
}

void sub_19E4095A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,const void *a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

void sub_19E40960C()
{
}

void sub_19E409614()
{
}

void sub_19E40961C()
{
}

void sub_19E409624()
{
}

void sub_19E40962C()
{
}

void sub_19E409634(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  sub_19E3C6F1C((const void **)va);
  JUMPOUT(0x19E409640);
}

void sub_19E409654()
{
}

void sub_19E40965C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, const void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,const void *a36,void *a37,uint64_t a38,void *__p,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,void *a61,uint64_t a62,int a63)
{
  unsigned __int8 v77 = (void **)__p;
  if (__p)
  {
    do
    {
      uint64_t v79 = (void **)*v77;
      if (*((char *)v77 + 39) < 0) {
        operator delete(v77[2]);
      }
      operator delete(v77);
      unsigned __int8 v77 = v79;
    }
    while (v79);
  }
  CFTypeRef v78 = a37;
  a37 = 0;
  if (v78)
  {
    operator delete(v78);
    if ((a76 & 0x80000000) == 0)
    {
LABEL_4:
      if ((a74 & 0x80000000) == 0) {
        goto LABEL_5;
      }
      goto LABEL_20;
    }
  }
  else if ((a76 & 0x80000000) == 0)
  {
    goto LABEL_4;
  }
  operator delete(a75);
  if ((a74 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a72 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_21;
  }
LABEL_20:
  operator delete(a73);
  if ((a72 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a66 & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_22;
  }
LABEL_21:
  operator delete(a67);
  if ((a66 & 0x80000000) == 0)
  {
LABEL_7:
    if ((a60 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_23;
  }
LABEL_22:
  operator delete(a61);
  if ((a60 & 0x80000000) == 0)
  {
LABEL_8:
    if ((a54 & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_24;
  }
LABEL_23:
  operator delete(a55);
  if ((a54 & 0x80000000) == 0)
  {
LABEL_9:
    if ((a48 & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_25;
  }
LABEL_24:
  operator delete(a49);
  if ((a48 & 0x80000000) == 0)
  {
LABEL_10:
    if ((a34 & 0x80000000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_25:
  operator delete(a43);
  if ((a34 & 0x80000000) == 0)
  {
LABEL_12:
    sub_19E410F30(&a36);
    if (a18 < 0) {
      operator delete(a13);
    }
    sub_19E401594(&a19);
    _Unwind_Resume(a1);
  }
LABEL_11:
  operator delete(a29);
  goto LABEL_12;
}

uint64_t sub_19E40978C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 184);
  if (v1 == *(void *)(a1 + 192)) {
    operator new();
  }
  return *(void *)v1;
}

void sub_19E4098C0(_Unwind_Exception *a1)
{
  uint64_t v5 = sub_19E401174(v2);
  MEMORY[0x19F3BDCF0](v5, 0x10E0C405C30B098);
  *(void *)(v1 + 192) = v3;
  _Unwind_Resume(a1);
}

void sub_19E4098F0(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10E0C405C30B098);
  _Unwind_Resume(a1);
}

void sub_19E409914(uint64_t a1, __n128 **a2, uint64_t a3)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  sub_19E410C70(v63, *(void *)a1);
  *(unsigned char *)(a1 + 145) = 0;
  sub_19E433AA0(v76, a2, 50);
  uint64_t v6 = (void **)(a1 + 56);
  uint64_t v7 = *(void **)(a1 + 56);
  if (v7)
  {
    CFNumberRef v8 = *(void **)(a1 + 64);
    CFArrayRef v9 = *(void **)(a1 + 56);
    if (v8 != v7)
    {
      do
      {
        uint64_t v11 = *--v8;
        uint64_t v10 = v11;
        *CFNumberRef v8 = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
        }
      }
      while (v8 != v7);
      CFArrayRef v9 = *v6;
    }
    *(void *)(a1 + 64) = v7;
    operator delete(v9);
    *uint64_t v6 = 0;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
  }
  CFTypeRef v12 = v76[0];
  *(CFTypeRef *)(a1 + 56) = v76[0];
  CFTypeRef v13 = v76[1];
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v76[1];
  if (v12 == v13 && *a2 != a2[1])
  {
    if (qword_1EC009588 != -1) {
      dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
    }
    uint64_t v14 = qword_1EC009580;
    if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_ERROR))
    {
      uint64_t v58 = v63;
      if (v64 < 0) {
        uint64_t v58 = (void **)v63[0];
      }
      LODWORD(v76[0]) = 136315138;
      *(CFTypeRef *)((char *)v76 + 4) = v58;
      _os_log_error_impl(&dword_19E36B000, v14, OS_LOG_TYPE_ERROR, "Failed to load default blocklist for locale: %s", (uint8_t *)v76, 0xCu);
    }
  }
  if (*(void *)a3 != *(void *)(a3 + 8))
  {
    sub_19E433AA0(v76, (__n128 **)a3, 52);
    uint64_t v15 = (void **)(a1 + 80);
    int v16 = *(void **)(a1 + 80);
    if (v16)
    {
      int v17 = *(void **)(a1 + 88);
      uint64_t v18 = *(void **)(a1 + 80);
      if (v17 != v16)
      {
        do
        {
          uint64_t v20 = *--v17;
          uint64_t v19 = v20;
          *int v17 = 0;
          if (v20) {
            (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
          }
        }
        while (v17 != v16);
        uint64_t v18 = *v15;
      }
      *(void *)(a1 + 88) = v16;
      operator delete(v18);
      *uint64_t v15 = 0;
      *(void *)(a1 + 88) = 0;
      *(void *)(a1 + 96) = 0;
    }
    CFTypeRef v21 = v76[0];
    *(CFTypeRef *)(a1 + 80) = v76[0];
    CFTypeRef v22 = v76[1];
    *(_OWORD *)(a1 + 88) = *(_OWORD *)&v76[1];
    if (v21 == v22)
    {
      if (qword_1EC009588 != -1) {
        dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
      }
      uint64_t v23 = qword_1EC009580;
      if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_ERROR))
      {
        CFIndex v59 = v63;
        if (v64 < 0) {
          CFIndex v59 = (void **)v63[0];
        }
        LODWORD(v76[0]) = 136315138;
        *(CFTypeRef *)((char *)v76 + 4) = v59;
        _os_log_error_impl(&dword_19E36B000, v23, OS_LOG_TYPE_ERROR, "Failed to load quickpath blocklist for locale: %s", (uint8_t *)v76, 0xCu);
      }
    }
  }
  *(unsigned char *)(a1 + 144) = 0;
  memset(v76, 0, sizeof(v76));
  CFLocaleRef v24 = *a2;
  CFStringRef v25 = a2[1];
  if (*a2 != v25)
  {
    do
    {
      unint64_t v27 = (CFDictionaryRef *)v24->n128_u64[0];
      LODWORD(valuePtr) = 0;
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*v27, @"Type");
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      if (valuePtr == 50)
      {
        uint64_t v29 = (__n128 *)v76[1];
        if (v76[1] >= v76[2])
        {
          unint64_t v26 = sub_19E40CC80((uint64_t)v76, *v24);
        }
        else
        {
          *(void *)v76[1] = v24->n128_u64[0];
          unint64_t v30 = v24->n128_u64[1];
          v29->n128_u64[1] = v30;
          if (v30) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v26 = v29 + 1;
        }
        v76[1] = v26;
      }
      ++v24;
    }
    while (v24 != v25);
    int v31 = (CFDictionaryRef **)v76[0];
    CFIndex v32 = (CFDictionaryRef **)v76[1];
    if (v76[0] != v76[1])
    {
      CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (1)
      {
        CFIndex v34 = CFDictionaryGetValue(**v31, @"URL");
        CFTypeRef v65 = CFRetain(v34);
        CFTypeRef v66 = CFBundleCreate(v33, (CFURLRef)v65);
        CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)v66);
        if (!InfoDictionary) {
          break;
        }
        CFArrayRef v36 = (const __CFArray *)CFDictionaryGetValue(InfoDictionary, @"Contents");
        if (!v36)
        {
          int v60 = 229;
          CFTypeID v62 = "_getContents";
          CFArrayRef v61 = "(contents != 0) && \"There should files contained within the blocklist bundle\"";
LABEL_125:
          __assert_rtn(v62, "BlocklistBundle.cpp", v60, v61);
        }
        CFIndex v37 = 0;
        while (v37 < CFArrayGetCount(v36))
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v36, v37);
          LODWORD(valuePtr) = 0;
          CFNumberRef v39 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"Type");
          CFNumberGetValue(v39, kCFNumberIntType, &valuePtr);
          ++v37;
          if (valuePtr == 53)
          {
            CFArrayRef v40 = sub_19E49822C((CFURLRef *)&v65, ValueAtIndex);
            long long valuePtr = v40;
            cf[1] = 0;
            cf[0] = CFRetain(v40);
            LOBYTE(v69[0]) = 1;
            if (!v40 || (CFRelease(v40), LOBYTE(v69[0]))) {
              operator new();
            }
            break;
          }
        }
        if (v66) {
          CFRelease(v66);
        }
        CFTypeRef v66 = 0;
        if (v65) {
          CFRelease(v65);
        }
        v31 += 2;
        if (v31 == v32)
        {
          int v31 = (CFDictionaryRef **)v76[0];
          goto LABEL_53;
        }
      }
      int v60 = 218;
      CFArrayRef v61 = "d && \"An Info.plist file was unable to be read from the bundle\"";
      CFTypeID v62 = "_getInfoDictionary";
      goto LABEL_125;
    }
LABEL_53:
    if (v31)
    {
      uint64_t v41 = (CFDictionaryRef **)v76[1];
      uint64_t v42 = v31;
      if (v76[1] != v31)
      {
        do
        {
          uint64_t v43 = (std::__shared_weak_count *)*(v41 - 1);
          if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
            std::__shared_weak_count::__release_weak(v43);
          }
          v41 -= 2;
        }
        while (v41 != v31);
        uint64_t v42 = (CFDictionaryRef **)v76[0];
      }
      v76[1] = v31;
      operator delete(v42);
    }
  }
  HIBYTE(v76[2]) = 7;
  strcpy((char *)v76, "hi-Latn");
  char v78 = 7;
  strcpy((char *)v77, "gu-Latn");
  char v80 = 7;
  strcpy((char *)v79, "mr-Latn");
  char v82 = 7;
  strcpy((char *)v81, "te-Latn");
  char v84 = 7;
  strcpy((char *)v83, "ta-Latn");
  char v86 = 7;
  strcpy((char *)v85, "pa-Latn");
  char v88 = 7;
  strcpy((char *)v87, "bn-Latn");
  *(_OWORD *)CFStringRef cf = 0u;
  *(_OWORD *)long long v69 = 0u;
  int v70 = 1065353216;
  sub_19E3F0660((uint64_t)cf, (uint64_t)v76, (uint64_t)v76);
  sub_19E3F0660((uint64_t)cf, (uint64_t)v77, (uint64_t)v77);
  sub_19E3F0660((uint64_t)cf, (uint64_t)v79, (uint64_t)v79);
  sub_19E3F0660((uint64_t)cf, (uint64_t)v81, (uint64_t)v81);
  sub_19E3F0660((uint64_t)cf, (uint64_t)v83, (uint64_t)v83);
  sub_19E3F0660((uint64_t)cf, (uint64_t)v85, (uint64_t)v85);
  sub_19E3F0660((uint64_t)cf, (uint64_t)v87, (uint64_t)v87);
  if (v88 < 0)
  {
    operator delete(v87[0]);
    if ((v86 & 0x80000000) == 0)
    {
LABEL_64:
      if ((v84 & 0x80000000) == 0) {
        goto LABEL_65;
      }
      goto LABEL_100;
    }
  }
  else if ((v86 & 0x80000000) == 0)
  {
    goto LABEL_64;
  }
  operator delete(v85[0]);
  if ((v84 & 0x80000000) == 0)
  {
LABEL_65:
    if ((v82 & 0x80000000) == 0) {
      goto LABEL_66;
    }
    goto LABEL_101;
  }
LABEL_100:
  operator delete(v83[0]);
  if ((v82 & 0x80000000) == 0)
  {
LABEL_66:
    if ((v80 & 0x80000000) == 0) {
      goto LABEL_67;
    }
    goto LABEL_102;
  }
LABEL_101:
  operator delete(v81[0]);
  if ((v80 & 0x80000000) == 0)
  {
LABEL_67:
    if ((v78 & 0x80000000) == 0) {
      goto LABEL_68;
    }
LABEL_103:
    operator delete(v77[0]);
    if ((SHIBYTE(v76[2]) & 0x80000000) == 0) {
      goto LABEL_69;
    }
    goto LABEL_104;
  }
LABEL_102:
  operator delete(v79[0]);
  if (v78 < 0) {
    goto LABEL_103;
  }
LABEL_68:
  if ((SHIBYTE(v76[2]) & 0x80000000) == 0) {
    goto LABEL_69;
  }
LABEL_104:
  operator delete((void *)v76[0]);
LABEL_69:
  uint64_t v44 = sub_19E4B9E40(cf, (uint64_t)v63);
  unint64_t v45 = (void **)v69[0];
  if (v69[0])
  {
    do
    {
      uint64_t v55 = (void **)*v45;
      if (*((char *)v45 + 39) < 0) {
        operator delete(v45[2]);
      }
      operator delete(v45);
      unint64_t v45 = v55;
    }
    while (v55);
  }
  CFTypeRef v46 = (void *)cf[0];
  cf[0] = 0;
  if (v46) {
    operator delete(v46);
  }
  if (v44)
  {
    *(unsigned char *)(a1 + 145) = 1;
    CFArrayRef v47 = (const void *)*MEMORY[0x1E4F72458];
    if (*MEMORY[0x1E4F72458]) {
      CFRetain((CFTypeRef)*MEMORY[0x1E4F72458]);
    }
    sub_19E372124(cf, v47);
    CFIndex v48 = *(const void **)a1;
    if (*(void *)a1) {
      CFRetain(*(CFTypeRef *)a1);
    }
    *(void *)std::string __p = v48;
    CFTypeRef v49 = cf[0];
    if (cf[0]) {
      CFRetain(cf[0]);
    }
    v76[0] = v49;
    v76[1] = v48;
    *(void *)std::string __p = 0;
    CFDictionaryRef v50 = sub_19E411038((uint64_t *)v76, 1uLL);
    CFTypeRef v65 = v50;
    if (v76[1]) {
      CFRelease(v76[1]);
    }
    if (v76[0]) {
      CFRelease(v76[0]);
    }
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    CFErrorRef err = 0;
    uint64_t v51 = LXTransliterationCreate();
    uint64_t v52 = *(const void **)(a1 + 136);
    if (v52) {
      CFRelease(v52);
    }
    *(void *)(a1 + 136) = v51;
    if (!err) {
      goto LABEL_113;
    }
    CFStringRef v53 = CFErrorCopyDescription(err);
    CFStringRef v71 = v53;
    CFRelease(err);
    sub_19E37774C(v53, v76);
    sub_19E410C70(cf, *(void *)a1);
    if (qword_1EC009588 != -1) {
      dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
    }
    uint64_t v54 = qword_1EC009580;
    if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_ERROR))
    {
      uint64_t v56 = cf;
      if (SHIBYTE(v69[0]) < 0) {
        uint64_t v56 = (CFTypeRef *)cf[0];
      }
      CFTypeRef v57 = v76;
      if (SHIBYTE(v76[2]) < 0) {
        CFTypeRef v57 = (CFTypeRef *)v76[0];
      }
      *(_DWORD *)std::string __p = 136315394;
      *(void *)&__p[4] = v56;
      __int16 v74 = 2080;
      int64x2_t v75 = v57;
      _os_log_error_impl(&dword_19E36B000, v54, OS_LOG_TYPE_ERROR, "Failed to load transliteration lexicon for locale: %s, Error: %s", __p, 0x16u);
      if ((SHIBYTE(v69[0]) & 0x80000000) == 0)
      {
LABEL_92:
        if ((SHIBYTE(v76[2]) & 0x80000000) == 0) {
          goto LABEL_93;
        }
        goto LABEL_111;
      }
    }
    else if ((SHIBYTE(v69[0]) & 0x80000000) == 0)
    {
      goto LABEL_92;
    }
    operator delete((void *)cf[0]);
    if ((SHIBYTE(v76[2]) & 0x80000000) == 0)
    {
LABEL_93:
      if (!v53) {
        goto LABEL_113;
      }
      goto LABEL_112;
    }
LABEL_111:
    operator delete((void *)v76[0]);
    if (!v53)
    {
LABEL_113:
      CFRelease(v50);
      goto LABEL_114;
    }
LABEL_112:
    CFRelease(v53);
    goto LABEL_113;
  }
LABEL_114:
  if (v64 < 0) {
    operator delete(v63[0]);
  }
}

void sub_19E40A3BC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_19E37B770(a1);
}

void sub_19E40A604(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  JUMPOUT(0x19E40A648);
}

void sub_19E40A620()
{
}

void sub_19E40A634()
{
}

void sub_19E40A6DC()
{
}

void sub_19E40A6EC(void *a1)
{
  uint64_t v1 = (uint64_t *)a1[23];
  for (uint64_t i = (uint64_t *)a1[24]; v1 != i; v1 += 2)
  {
    uint64_t v4 = (void *)*v1;
    uint64_t v6 = *(void *)(*v1 + 8);
    uint64_t v5 = *(void *)(*v1 + 16);
    uint64_t v7 = v5 - v6;
    if (v5 == v6)
    {
      CFArrayRef v9 = 0;
      CFNumberRef v8 = 0;
    }
    else
    {
      if (v7 < 0) {
        sub_19E37C7C4();
      }
      CFNumberRef v8 = (char *)operator new(v5 - v6);
      CFArrayRef v9 = &v8[8 * (v7 >> 3)];
      bzero(v8, v7 & 0xFFFFFFFFFFFFFFF8);
    }
    uint64_t v10 = (void *)v4[4];
    if (v10)
    {
      v4[5] = v10;
      operator delete(v10);
      v4[4] = 0;
      v4[5] = 0;
      v4[6] = 0;
    }
    v4[4] = v8;
    v4[5] = v9;
    v4[6] = v9;
    uint64_t v11 = a1[29];
    if (!*(unsigned char *)(v11 + 361) && !*(unsigned char *)(v11 + 360))
    {
      uint64_t v12 = *v1;
      uint64_t v13 = *(void *)(*v1 + 8);
      if (*(void *)(*v1 + 16) != v13)
      {
        unint64_t v14 = 0;
        do
        {
          uint64_t v15 = *(const void **)(v13 + 8 * v14);
          if (v15
            && __dynamic_cast(v15, (const struct __class_type_info *)&unk_1EF0B6DF0, (const struct __class_type_info *)&unk_1EF0B62A0, 0))
          {
            v22[0] = 0;
            v22[1] = v22;
            v22[2] = 0x2000000000;
            v22[3] = 0;
            uint64_t v18 = 0;
            uint64_t v19 = &v18;
            uint64_t v20 = 0x2000000000;
            uint64_t v21 = 0;
            RootCursor = (const void *)LXLexiconCreateRootCursor();
            LXCursorEnumerateEntriesRecursivelyWithPolicy();
            uint64_t v17 = v19[3];
            if (RootCursor) {
              CFRelease(RootCursor);
            }
            _Block_object_dispose(&v18, 8);
            _Block_object_dispose(v22, 8);
            uint64_t v12 = *v1;
            *(void *)(*(void *)(*v1 + 32) + 8 * v14) = v17;
          }
          ++v14;
          uint64_t v13 = *(void *)(v12 + 8);
        }
        while (v14 < (*(void *)(v12 + 16) - v13) >> 3);
      }
    }
  }
}

void sub_19E40A930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E40A950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_19E40A984(void *a1)
{
  if (!a1[60]) {
    operator new();
  }
  uint64_t v79 = 0;
  char v80 = 0;
  unint64_t v81 = 0;
  uint64_t v3 = (uint64_t **)a1[23];
  uint64_t v4 = (uint64_t **)a1[24];
  if (v3 == v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  else
  {
    do
    {
      sub_19E410C70(__p, **v3);
      CFNumberRef v8 = v80;
      if ((unint64_t)v80 < v81)
      {
        long long v7 = *(_OWORD *)__p;
        *((void *)v80 + 2) = v85;
        *CFNumberRef v8 = v7;
        char v80 = (char *)v8 + 24;
      }
      else
      {
        char v80 = sub_19E3EB1B8(&v79, (uint64_t)__p);
        if (SHIBYTE(v85) < 0) {
          operator delete(__p[0]);
        }
      }
      v3 += 2;
    }
    while (v3 != v4);
    uint64_t v6 = (long long *)v79;
    uint64_t v5 = (long long *)v80;
  }
  uint64_t v9 = a1[60];
  unsigned __int8 v77 = 0;
  uint64_t v78 = 0;
  uint64_t v76 = 0;
  sub_19E3938C0((char *)&v76, v6, v5, 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v6) >> 3));
  if ((void **)(v9 + 40) != &v76) {
    sub_19E42104C((void ***)(v9 + 40), (void **)v76, v77, 0xAAAAAAAAAAAAAAABLL * (((char *)v77 - (unsigned char *)v76) >> 3));
  }
  uint64_t v10 = *(void *)(v9 + 8);
  if (v10)
  {
    for (uint64_t i = 0; i != v10; ++i)
      *(void *)(*(void *)v9 + 8 * i) = 0;
    uint64_t v12 = *(void ***)(v9 + 16);
    *(void *)(v9 + 16) = 0;
    *(void *)(v9 + 24) = 0;
    if (v12)
    {
      do
      {
        unint64_t v68 = (void **)*v12;
        sub_19E3FFB5C((uint64_t)(v12 + 5));
        if (*((char *)v12 + 39) < 0) {
          operator delete(v12[2]);
        }
        operator delete(v12);
        uint64_t v12 = v68;
      }
      while (v68);
    }
  }
  uint64_t v13 = *(long long **)(v9 + 40);
  int64x2_t v75 = *(long long **)(v9 + 48);
  if (v13 != v75)
  {
    while (1)
    {
      if (*((char *)v13 + 23) < 0)
      {
        sub_19E39369C(__dst, *(void **)v13, *((void *)v13 + 1));
      }
      else
      {
        long long v14 = *v13;
        uint64_t v88 = *((void *)v13 + 2);
        *(_OWORD *)stat __dst = v14;
      }
      if (SHIBYTE(v88) < 0)
      {
        sub_19E39369C(v82, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)char v82 = *(_OWORD *)__dst;
        uint64_t v83 = v88;
      }
      sub_19E4BBDE4();
      if (v88 >= 0) {
        uint64_t v15 = (uint64_t *)__dst;
      }
      else {
        uint64_t v15 = (uint64_t *)__dst[0];
      }
      if (v88 >= 0) {
        unint64_t v16 = HIBYTE(v88);
      }
      else {
        unint64_t v16 = (unint64_t)__dst[1];
      }
      unint64_t v17 = sub_19E37BDA4((uint64_t)v89, v15, v16);
      unint64_t v18 = v17;
      unint64_t v19 = *(void *)(v9 + 8);
      if (v19)
      {
        uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v19);
        v20.i16[0] = vaddlv_u8(v20);
        if (v20.u32[0] > 1uLL)
        {
          unint64_t v1 = v17;
          if (v17 >= v19) {
            unint64_t v1 = v17 % v19;
          }
        }
        else
        {
          unint64_t v1 = (v19 - 1) & v17;
        }
        uint64_t v21 = *(void **)(*(void *)v9 + 8 * v1);
        if (v21)
        {
          CFTypeRef v22 = (void *)*v21;
          if (*v21)
          {
            if (v88 >= 0) {
              uint64_t v23 = (void *)HIBYTE(v88);
            }
            else {
              uint64_t v23 = __dst[1];
            }
            if (v88 >= 0) {
              CFLocaleRef v24 = __dst;
            }
            else {
              CFLocaleRef v24 = (void **)__dst[0];
            }
            if (v20.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v29 = v22[1];
                if (v29 == v18)
                {
                  uint64_t v30 = *((unsigned __int8 *)v22 + 39);
                  if ((v30 & 0x80u) == 0) {
                    int v31 = (void *)*((unsigned __int8 *)v22 + 39);
                  }
                  else {
                    int v31 = (void *)v22[3];
                  }
                  if (v31 == v23)
                  {
                    if ((v30 & 0x80) != 0)
                    {
                      if (!memcmp((const void *)v22[2], v24, v22[3])) {
                        goto LABEL_120;
                      }
                    }
                    else
                    {
                      if (!*((unsigned char *)v22 + 39)) {
                        goto LABEL_120;
                      }
                      uint64_t v32 = 0;
                      while (*((unsigned __int8 *)v22 + v32 + 16) == *((unsigned __int8 *)v24 + v32))
                      {
                        if (v30 == ++v32) {
                          goto LABEL_120;
                        }
                      }
                    }
                  }
                }
                else if ((v29 & (v19 - 1)) != v1)
                {
                  goto LABEL_79;
                }
                CFTypeRef v22 = (void *)*v22;
                if (!v22) {
                  goto LABEL_79;
                }
              }
            }
            do
            {
              unint64_t v25 = v22[1];
              if (v25 == v18)
              {
                uint64_t v26 = *((unsigned __int8 *)v22 + 39);
                if ((v26 & 0x80u) == 0) {
                  unint64_t v27 = (void *)*((unsigned __int8 *)v22 + 39);
                }
                else {
                  unint64_t v27 = (void *)v22[3];
                }
                if (v27 == v23)
                {
                  if ((v26 & 0x80) != 0)
                  {
                    if (!memcmp((const void *)v22[2], v24, v22[3])) {
                      goto LABEL_120;
                    }
                  }
                  else
                  {
                    if (!*((unsigned char *)v22 + 39)) {
                      goto LABEL_120;
                    }
                    uint64_t v28 = 0;
                    while (*((unsigned __int8 *)v22 + v28 + 16) == *((unsigned __int8 *)v24 + v28))
                    {
                      if (v26 == ++v28) {
                        goto LABEL_120;
                      }
                    }
                  }
                }
              }
              else
              {
                if (v25 >= v19) {
                  v25 %= v19;
                }
                if (v25 != v1) {
                  break;
                }
              }
              CFTypeRef v22 = (void *)*v22;
            }
            while (v22);
          }
        }
      }
LABEL_79:
      CFAllocatorRef v33 = operator new(0x50uLL);
      CFTypeRef v22 = v33;
      *CFAllocatorRef v33 = 0;
      v33[1] = v18;
      if (SHIBYTE(v88) < 0)
      {
        sub_19E39369C((unsigned char *)v33 + 16, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *((_OWORD *)v33 + 1) = *(_OWORD *)__dst;
        v33[4] = v88;
      }
      *(_OWORD *)(v22 + 5) = 0u;
      *(_OWORD *)(v22 + 7) = 0u;
      *((_DWORD *)v22 + 18) = 1065353216;
      float v34 = (float)(unint64_t)(*(void *)(v9 + 24) + 1);
      float v35 = *(float *)(v9 + 32);
      if (!v19 || (float)(v35 * (float)v19) < v34)
      {
        BOOL v36 = (v19 & (v19 - 1)) != 0;
        if (v19 < 3) {
          BOOL v36 = 1;
        }
        unint64_t v37 = v36 | (2 * v19);
        unint64_t v38 = vcvtps_u32_f32(v34 / v35);
        if (v37 <= v38) {
          size_t prime = v38;
        }
        else {
          size_t prime = v37;
        }
        if (prime == 1)
        {
          size_t prime = 2;
        }
        else if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
        }
        int8x8_t v40 = *(int8x8_t *)(v9 + 8);
        if (prime > *(void *)&v40) {
          goto LABEL_94;
        }
        if (prime < *(void *)&v40)
        {
          unint64_t v41 = vcvtps_u32_f32((float)*(unint64_t *)(v9 + 24) / *(float *)(v9 + 32));
          if (*(void *)&v40 < 3uLL || (uint8x8_t v42 = (uint8x8_t)vcnt_s8(v40), v42.i16[0] = vaddlv_u8(v42), v42.u32[0] > 1uLL))
          {
            unint64_t v41 = std::__next_prime(v41);
          }
          else
          {
            uint64_t v43 = 1 << -(char)__clz(v41 - 1);
            if (v41 >= 2) {
              unint64_t v41 = v43;
            }
          }
          if (prime <= v41) {
            size_t prime = v41;
          }
          if (prime < *(void *)&v40) {
LABEL_94:
          }
            sub_19E3CEFD8(v9, prime);
        }
        unint64_t v19 = *(void *)(v9 + 8);
        if ((v19 & (v19 - 1)) != 0)
        {
          if (v18 >= v19) {
            unint64_t v1 = v18 % v19;
          }
          else {
            unint64_t v1 = v18;
          }
        }
        else
        {
          unint64_t v1 = (v19 - 1) & v18;
        }
      }
      uint64_t v44 = *(void **)(*(void *)v9 + 8 * v1);
      if (v44) {
        break;
      }
      *CFTypeRef v22 = *(void *)(v9 + 16);
      *(void *)(v9 + 16) = v22;
      *(void *)(*(void *)v9 + 8 * v1) = v9 + 16;
      if (*v22)
      {
        unint64_t v45 = *(void *)(*v22 + 8);
        if ((v19 & (v19 - 1)) != 0)
        {
          if (v45 >= v19) {
            v45 %= v19;
          }
        }
        else
        {
          v45 &= v19 - 1;
        }
        uint64_t v44 = (void *)(*(void *)v9 + 8 * v45);
        goto LABEL_118;
      }
LABEL_119:
      ++*(void *)(v9 + 24);
LABEL_120:
      CFTypeRef v46 = v22 + 5;
      if (v22 + 5 != __p)
      {
        *((_DWORD *)v22 + 18) = v86;
        CFArrayRef v47 = v85;
        uint64_t v48 = v22[6];
        if (!v48) {
          goto LABEL_140;
        }
        for (uint64_t j = 0; j != v48; ++j)
          *(void *)(*v46 + 8 * j) = 0;
        CFDictionaryRef v50 = (char *)v22[7];
        v22[7] = 0;
        v22[8] = 0;
        if (v50)
        {
          while (v47)
          {
            if (v50 != v47)
            {
              uint64_t v51 = (void **)(v50 + 16);
              char v52 = v47[39];
              if (v50[39] < 0)
              {
                if (v52 >= 0) {
                  uint64_t v54 = v47 + 16;
                }
                else {
                  uint64_t v54 = (void *)*((void *)v47 + 2);
                }
                if (v52 >= 0) {
                  size_t v55 = v47[39];
                }
                else {
                  size_t v55 = *((void *)v47 + 3);
                }
                sub_19E3C6D44(v51, v54, v55);
              }
              else if (v47[39] < 0)
              {
                sub_19E3C6C7C(v51, *((void **)v47 + 2), *((void *)v47 + 3));
              }
              else
              {
                long long v53 = *((_OWORD *)v47 + 1);
                *((void *)v50 + 4) = *((void *)v47 + 4);
                *(_OWORD *)uint64_t v51 = v53;
              }
              sub_19E42104C((void ***)v50 + 5, *((void ***)v47 + 5), *((void ***)v47 + 6), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v47 + 6) - *((void *)v47 + 5)) >> 3));
            }
            uint64_t v56 = *(char **)v50;
            sub_19E4BF4D4((uint64_t)v46, (uint64_t)v50);
            CFArrayRef v47 = *(char **)v47;
            CFDictionaryRef v50 = v56;
            if (!v56) {
              goto LABEL_140;
            }
          }
          do
          {
            char v64 = *(char **)v50;
            uint64_t v65 = *((void *)v50 + 5);
            if (v65)
            {
              uint64_t v66 = *((void *)v50 + 6);
              char v67 = (void *)*((void *)v50 + 5);
              if (v66 != v65)
              {
                do
                {
                  if (*(char *)(v66 - 1) < 0) {
                    operator delete(*(void **)(v66 - 24));
                  }
                  v66 -= 24;
                }
                while (v66 != v65);
                char v67 = (void *)*((void *)v50 + 5);
              }
              *((void *)v50 + 6) = v65;
              operator delete(v67);
            }
            if (v50[39] < 0) {
              operator delete(*((void **)v50 + 2));
            }
            operator delete(v50);
            CFDictionaryRef v50 = v64;
          }
          while (v64);
        }
        else
        {
LABEL_140:
          while (v47)
          {
            CFTypeRef v57 = (char *)operator new(0x40uLL);
            uint64_t v58 = (uint64_t)v57;
            CFIndex v59 = (uint64_t *)(v57 + 16);
            *(void *)CFTypeRef v57 = 0;
            *((void *)v57 + 1) = 0;
            if (v47[39] < 0)
            {
              sub_19E39369C(v57 + 16, *((void **)v47 + 2), *((void *)v47 + 3));
            }
            else
            {
              long long v60 = *((_OWORD *)v47 + 1);
              *((void *)v57 + 4) = *((void *)v47 + 4);
              *(_OWORD *)CFIndex v59 = v60;
            }
            *(void *)(v58 + 40) = 0;
            *(void *)(v58 + 48) = 0;
            *(void *)(v58 + 56) = 0;
            sub_19E3938C0((char *)(v58 + 40), *((long long **)v47 + 5), *((long long **)v47 + 6), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v47 + 6) - *((void *)v47 + 5)) >> 3));
            int v61 = *(char *)(v58 + 39);
            if (v61 >= 0) {
              CFTypeID v62 = v59;
            }
            else {
              CFTypeID v62 = *(uint64_t **)(v58 + 16);
            }
            if (v61 >= 0) {
              unint64_t v63 = *(unsigned __int8 *)(v58 + 39);
            }
            else {
              unint64_t v63 = *(void *)(v58 + 24);
            }
            *(void *)(v58 + 8) = sub_19E37BDA4((uint64_t)v89, v62, v63);
            sub_19E4BF4D4((uint64_t)v46, v58);
            CFArrayRef v47 = *(char **)v47;
          }
        }
      }
      sub_19E3FFB5C((uint64_t)__p);
      if (SHIBYTE(v83) < 0)
      {
        operator delete(v82[0]);
        if (SHIBYTE(v88) < 0) {
LABEL_166:
        }
          operator delete(__dst[0]);
      }
      else if (SHIBYTE(v88) < 0)
      {
        goto LABEL_166;
      }
      uint64_t v13 = (long long *)((char *)v13 + 24);
      if (v13 == v75) {
        goto LABEL_170;
      }
    }
    *CFTypeRef v22 = *v44;
LABEL_118:
    *uint64_t v44 = v22;
    goto LABEL_119;
  }
LABEL_170:
  long long v69 = (void **)v76;
  if (v76)
  {
    int v70 = v77;
    CFStringRef v71 = v76;
    if (v77 != v76)
    {
      do
      {
        if (*((char *)v70 - 1) < 0) {
          operator delete(*(v70 - 3));
        }
        v70 -= 3;
      }
      while (v70 != v69);
      CFStringRef v71 = v76;
    }
    unsigned __int8 v77 = v69;
    operator delete(v71);
  }
  uint64_t v72 = (char *)v79;
  if (v79)
  {
    CFTypeRef v73 = v80;
    __int16 v74 = v79;
    if (v80 != v79)
    {
      do
      {
        if (*(v73 - 1) < 0) {
          operator delete(*((void **)v73 - 3));
        }
        v73 -= 24;
      }
      while (v73 != v72);
      __int16 v74 = v79;
    }
    char v80 = v72;
    operator delete(v74);
  }
}

void sub_19E40B240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
}

char *sub_19E40B3F8(char **a1, uint64_t a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 4;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 60) {
    sub_19E37C7C4();
  }
  uint64_t v5 = a1[2] - *a1;
  if (v5 >> 3 > v3) {
    unint64_t v3 = v5 >> 3;
  }
  BOOL v6 = (unint64_t)v5 >= 0x7FFFFFFFFFFFFFF0;
  unint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
  if (!v6) {
    unint64_t v7 = v3;
  }
  if (v7 >> 60) {
    sub_19E37C2B8();
  }
  uint64_t v9 = 16 * v7;
  uint64_t v10 = (char *)operator new(16 * v7);
  uint64_t v11 = &v10[16 * v2];
  *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
  uint64_t v12 = v11 + 16;
  uint64_t v13 = &v10[v9];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  long long v14 = *a1;
  uint64_t v15 = a1[1];
  if (v15 == *a1)
  {
    *a1 = v11;
    a1[1] = v12;
    a1[2] = v13;
  }
  else
  {
    do
    {
      long long v16 = *((_OWORD *)v15 - 1);
      v15 -= 16;
      *((_OWORD *)v11 - 1) = v16;
      v11 -= 16;
      *(void *)uint64_t v15 = 0;
      *((void *)v15 + 1) = 0;
    }
    while (v15 != v14);
    uint64_t v15 = *a1;
    unint64_t v17 = a1[1];
    *a1 = v11;
    a1[1] = v12;
    for (a1[2] = v13; v17 != v15; v17 -= 16)
    {
      unint64_t v18 = (std::__shared_weak_count *)*((void *)v17 - 1);
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v12;
}

char *sub_19E40B544(char **a1, uint64_t a2)
{
  unint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = v2 - *a1;
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = (v4 >> 3) + 1;
  if (v6 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v9 = a1[2] - v3;
  if (v9 >> 2 > v6) {
    unint64_t v6 = v9 >> 2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v11 = (char *)operator new(8 * v10);
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v12 = &v11[8 * v5];
  uint64_t v13 = &v11[8 * v10];
  *(void *)uint64_t v12 = a2;
  long long v14 = v12 + 8;
  if (v2 == v3)
  {
    *a1 = v12;
    a1[1] = v14;
    a1[2] = v13;
    goto LABEL_25;
  }
  unint64_t v15 = v2 - v3 - 8;
  if (v15 > 0x77
    && (&v2[-(v15 & 0xFFFFFFFFFFFFFFF8) - 8] >= v12 || &v11[v4 - (v15 & 0xFFFFFFFFFFFFFFF8) - 8] >= v2))
  {
    uint64_t v16 = (v15 >> 3) + 1;
    v12 -= 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
    unint64_t v17 = v2 - 32;
    unint64_t v18 = &v11[8 * v5 - 16];
    uint64_t v19 = v16 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v21 = *(_OWORD *)v17;
      long long v20 = *((_OWORD *)v17 + 1);
      *(_OWORD *)unint64_t v17 = 0uLL;
      *((_OWORD *)v17 + 1) = 0uLL;
      v17 -= 32;
      *((_OWORD *)v18 - 1) = v21;
      *(_OWORD *)unint64_t v18 = v20;
      v18 -= 32;
      v19 -= 4;
    }
    while (v19);
    if (v16 == (v16 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_20;
    }
    v2 -= 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
  }
  do
  {
    uint64_t v22 = *((void *)v2 - 1);
    v2 -= 8;
    *(void *)uint64_t v2 = 0;
    *((void *)v12 - 1) = v22;
    v12 -= 8;
  }
  while (v2 != v3);
LABEL_20:
  uint64_t v2 = *a1;
  uint64_t v23 = a1[1];
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  while (v23 != v2)
  {
    uint64_t v25 = *((void *)v23 - 1);
    v23 -= 8;
    uint64_t v24 = v25;
    *(void *)uint64_t v23 = 0;
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
    }
  }
LABEL_25:
  if (v2) {
    operator delete(v2);
  }
  return v14;
}

void sub_19E40B6F0()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_19E40C7B4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,long long buf)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_19E43C8CC();
  if (a46 < 0) {
    operator delete(__p);
  }
  sub_19E45D208((uint64_t)&a49);
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_19E45D208((uint64_t)&a27);
  sub_19E383288(&buf);
  uint64_t v63 = *a13;
  *a13 = 0;
  if (v63) {
    (*(void (**)(uint64_t))(*(void *)v63 + 8))(v63);
  }
  MEMORY[0x19F3BDCF0](a13, 0x1020C405F07FB98);
  MEMORY[0x19F3BDCF0](a11, 0x1020C40AF0ADC4FLL);
  char v64 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v65 = v64;
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    uint64_t v66 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_DEFAULT))
    {
      char v67 = *(uint64_t ***)(a10 + 32);
      if (*((char *)v67 + 23) < 0) {
        char v67 = (uint64_t **)*v67;
      }
      uint64_t v68 = (*(uint64_t (**)(void *))(*(void *)v65 + 16))(v65);
      LODWORD(buf) = 136315394;
      *(void *)((char *)&buf + 4) = v67;
      WORD6(buf) = 2080;
      *(void *)((char *)&buf + 14) = v68;
      long long v69 = "failed to create the FST Grammar from file=%s [%s]";
      int v70 = v66;
      uint32_t v71 = 22;
LABEL_21:
      _os_log_impl(&dword_19E36B000, v70, OS_LOG_TYPE_DEFAULT, v69, (uint8_t *)&buf, v71);
    }
  }
  else
  {
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    uint64_t v72 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v73 = *(uint64_t ***)(a10 + 32);
      if (*((char *)v73 + 23) < 0) {
        CFTypeRef v73 = (uint64_t **)*v73;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v73;
      long long v69 = "failed to create the FST grammar from file=%s [unknown exception]";
      int v70 = v72;
      uint32_t v71 = 12;
      goto LABEL_21;
    }
  }
  __cxa_end_catch();
  JUMPOUT(0x19E40C444);
}

__n128 *sub_19E40CC80(uint64_t a1, __n128 a2)
{
  uint64_t v2 = *(__n128 **)a1;
  unint64_t v3 = *(__n128 **)(a1 + 8);
  uint64_t v4 = ((uint64_t)v3 - *(void *)a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    sub_19E37C7C4();
  }
  uint64_t v7 = *(void *)(a1 + 16) - (void)v2;
  if (v7 >> 3 > v5) {
    unint64_t v5 = v7 >> 3;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
  }
  if (v5 >> 60) {
    sub_19E37C2B8();
  }
  uint64_t v8 = 16 * v5;
  uint64_t v9 = (char *)operator new(16 * v5);
  unint64_t v10 = (__n128 *)&v9[16 * v4];
  *unint64_t v10 = a2;
  if (a2.n128_u64[1])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a2.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
    uint64_t v2 = *(__n128 **)a1;
    unint64_t v3 = *(__n128 **)(a1 + 8);
  }
  uint64_t v11 = &v9[v8];
  uint64_t v12 = v10 + 1;
  if (v3 == v2)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
  }
  else
  {
    do
    {
      __n128 v13 = v3[-1];
      --v3;
      v10[-1] = v13;
      --v10;
      v3->n128_u64[0] = 0;
      v3->n128_u64[1] = 0;
    }
    while (v3 != v2);
    uint64_t v2 = *(__n128 **)a1;
    long long v14 = *(__n128 **)(a1 + 8);
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    for (*(void *)(a1 + 16) = v11; v14 != v2; --v14)
    {
      unint64_t v15 = (std::__shared_weak_count *)v14[-1].n128_u64[1];
      if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

unint64_t sub_19E40CDE4(const __CFNumber *a1)
{
  switch(CFNumberGetType(a1))
  {
    case kCFNumberSInt8Type:
      LOBYTE(valuePtr) = 0;
      CFNumberRef v2 = a1;
      CFNumberType v3 = kCFNumberSInt8Type;
      goto LABEL_10;
    case kCFNumberSInt16Type:
      LOWORD(valuePtr) = 0;
      CFNumberRef v6 = a1;
      CFNumberType v7 = kCFNumberSInt16Type;
      goto LABEL_18;
    case kCFNumberSInt32Type:
      LODWORD(valuePtr) = 0;
      CFNumberRef v8 = a1;
      CFNumberType v9 = kCFNumberSInt32Type;
      goto LABEL_20;
    case kCFNumberSInt64Type:
      double valuePtr = 0.0;
      CFNumberRef v10 = a1;
      CFNumberType v11 = kCFNumberSInt64Type;
      goto LABEL_31;
    case kCFNumberFloat32Type:
      LODWORD(valuePtr) = 0;
      CFNumberRef v12 = a1;
      CFNumberType v13 = kCFNumberFloat32Type;
      goto LABEL_27;
    case kCFNumberFloat64Type:
      double valuePtr = 0.0;
      CFNumberRef v14 = a1;
      CFNumberType v15 = kCFNumberFloat64Type;
      goto LABEL_33;
    case kCFNumberCharType:
      LOBYTE(valuePtr) = 0;
      CFNumberRef v2 = a1;
      CFNumberType v3 = kCFNumberCharType;
LABEL_10:
      int Value = CFNumberGetValue(v2, v3, &valuePtr);
      if (Value) {
        char v17 = LOBYTE(valuePtr);
      }
      else {
        char v17 = 0;
      }
      if (Value != 0 && SLOBYTE(valuePtr) < 0) {
        unint64_t v4 = -256;
      }
      else {
        unint64_t v4 = 0;
      }
      LOBYTE(v5) = v17;
      return v5 | v4;
    case kCFNumberShortType:
      LOWORD(valuePtr) = 0;
      CFNumberRef v6 = a1;
      CFNumberType v7 = kCFNumberShortType;
LABEL_18:
      BOOL v18 = CFNumberGetValue(v6, v7, &valuePtr) == 0;
      unsigned __int8 v19 = LOBYTE(valuePtr);
      uint64_t v20 = SLOWORD(valuePtr);
      goto LABEL_21;
    case kCFNumberIntType:
      LODWORD(valuePtr) = 0;
      CFNumberRef v8 = a1;
      CFNumberType v9 = kCFNumberIntType;
LABEL_20:
      BOOL v18 = CFNumberGetValue(v8, v9, &valuePtr) == 0;
      unsigned __int8 v19 = LOBYTE(valuePtr);
      uint64_t v20 = SLODWORD(valuePtr);
LABEL_21:
      unint64_t v21 = v20 & 0xFFFFFFFFFFFFFF00 | v19;
      if (v18) {
        unint64_t v5 = 0;
      }
      else {
        unint64_t v5 = v21;
      }
      goto LABEL_37;
    case kCFNumberLongType:
      double valuePtr = 0.0;
      CFNumberRef v10 = a1;
      CFNumberType v11 = kCFNumberLongType;
      goto LABEL_31;
    case kCFNumberLongLongType:
      double valuePtr = 0.0;
      CFNumberRef v10 = a1;
      CFNumberType v11 = kCFNumberLongLongType;
      goto LABEL_31;
    case kCFNumberFloatType:
      LODWORD(valuePtr) = 0;
      CFNumberRef v12 = a1;
      CFNumberType v13 = kCFNumberFloatType;
LABEL_27:
      BOOL v22 = CFNumberGetValue(v12, v13, &valuePtr) == 0;
      unint64_t v5 = (unint64_t)*(float *)&valuePtr;
      goto LABEL_34;
    case kCFNumberDoubleType:
      double valuePtr = 0.0;
      CFNumberRef v14 = a1;
      CFNumberType v15 = kCFNumberDoubleType;
      goto LABEL_33;
    case kCFNumberCFIndexType:
      double valuePtr = 0.0;
      CFNumberRef v10 = a1;
      CFNumberType v11 = kCFNumberCFIndexType;
      goto LABEL_31;
    case kCFNumberNSIntegerType:
      double valuePtr = 0.0;
      CFNumberRef v10 = a1;
      CFNumberType v11 = kCFNumberNSIntegerType;
LABEL_31:
      BOOL v22 = CFNumberGetValue(v10, v11, &valuePtr) == 0;
      unint64_t v5 = *(void *)&valuePtr;
      goto LABEL_34;
    case kCFNumberCGFloatType:
      double valuePtr = 0.0;
      CFNumberRef v14 = a1;
      CFNumberType v15 = kCFNumberCGFloatType;
LABEL_33:
      BOOL v22 = CFNumberGetValue(v14, v15, &valuePtr) == 0;
      unint64_t v5 = (unint64_t)valuePtr;
LABEL_34:
      if (v22) {
        unint64_t v5 = 0;
      }
LABEL_37:
      unint64_t v4 = v5 & 0xFFFFFFFFFFFFFF00;
      break;
    default:
      unint64_t v4 = 0;
      LOBYTE(v5) = 0;
      break;
  }
  return v5 | v4;
}

void sub_19E40D074(void *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1[6]) {
    __assert_rtn("loadDynamicData", "LMCompositeLanguageModel.cpp", 768, "!m_dynamicData");
  }
  uint64_t v2 = a1[29];
  if (!*(void *)(v2 + 184)) {
    sub_19E4333A0((int)&v7, a1[52]);
  }
  uint64_t v3 = a1[33];
  if (v3)
  {
    std::mutex::lock((std::mutex *)v2);
    unint64_t v5 = *(char **)(v2 + 64);
    unint64_t v4 = *(char **)(v2 + 72);
    if (v5 != v4)
    {
      do
      {
        if (*(void *)v5 == v3 + 120) {
          goto LABEL_9;
        }
        v5 += 8;
      }
      while (v5 != v4);
      unint64_t v5 = *(char **)(v2 + 72);
    }
LABEL_9:
    if (v5 != v4)
    {
      int64_t v6 = v4 - (v5 + 8);
      if (v4 != v5 + 8) {
        memmove(v5, v5 + 8, v4 - (v5 + 8));
      }
      *(void *)(v2 + 72) = &v5[v6];
    }
    std::mutex::unlock((std::mutex *)v2);
  }
  sub_19E433598((uint64_t)&valuePtr, a1[52]);
}

void sub_19E40F52C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_19E37B770(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E40FD94(uint64_t a1)
{
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  uint64_t v2 = *(const void **)(a1 + 56);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(a1 + 56) = 0;
  uint64_t v3 = *(const void **)(a1 + 48);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 48) = 0;
  if (*(char *)(a1 + 47) < 0)
  {
    operator delete(*(void **)(a1 + 24));
    unint64_t v4 = *(const void **)(a1 + 16);
    if (!v4) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  unint64_t v4 = *(const void **)(a1 + 16);
  if (v4) {
LABEL_9:
  }
    CFRelease(v4);
LABEL_10:
  *(void *)(a1 + 16) = 0;
  unint64_t v5 = *(const void **)(a1 + 8);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + 8) = 0;
  return a1;
}

uint64_t *sub_19E40FE2C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_19E40FD94(v2);
    MEMORY[0x19F3BDCF0](v3, 0x1072C40AE5FB29CLL);
  }
  return a1;
}

uint64_t sub_19E40FE74(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = sub_19E40FD94(v2);
    MEMORY[0x19F3BDCF0](v3, 0x1072C40AE5FB29CLL);
  }
  unint64_t v4 = *(const void **)(a1 + 8);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 8) = 0;
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  *(void *)a1 = 0;
  return a1;
}

__n128 sub_19E40FEE4(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void sub_19E40FEF4(uint64_t a1)
{
  unint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_19E40FF70(void *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009598, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC009598))
  {
    xmmword_1EC0095C0 = 0u;
    *(_OWORD *)&qword_1EC0095D0 = 0u;
    dword_1EC0095E0 = 1065353216;
    __cxa_guard_release(&qword_1EC009598);
  }
  uint64_t v2 = (uint64_t *)a1[6];
  int v3 = *((char *)v2 + 23);
  if (v3 >= 0) {
    unint64_t v4 = (uint64_t *)a1[6];
  }
  else {
    unint64_t v4 = (uint64_t *)*v2;
  }
  if (v3 >= 0) {
    unint64_t v5 = *((unsigned __int8 *)v2 + 23);
  }
  else {
    unint64_t v5 = v2[1];
  }
  unint64_t v6 = sub_19E37BDA4((uint64_t)&v28, v4, v5);
  unint64_t v7 = *((void *)&xmmword_1EC0095C0 + 1);
  if (*((void *)&xmmword_1EC0095C0 + 1))
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EC0095C0 + 8));
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *((void *)&xmmword_1EC0095C0 + 1)) {
        unint64_t v10 = v6 % *((void *)&xmmword_1EC0095C0 + 1);
      }
    }
    else
    {
      unint64_t v10 = (*((void *)&xmmword_1EC0095C0 + 1) - 1) & v6;
    }
    CFNumberType v11 = *(uint64_t ***)(xmmword_1EC0095C0 + 8 * v10);
    if (v11)
    {
      CFNumberRef v12 = *v11;
      if (*v11)
      {
        char v13 = *((unsigned char *)v2 + 23);
        if (v13 >= 0) {
          uint64_t v14 = *((unsigned __int8 *)v2 + 23);
        }
        else {
          uint64_t v14 = v2[1];
        }
        if (v13 < 0) {
          uint64_t v2 = (uint64_t *)*v2;
        }
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v15 = *((void *)&xmmword_1EC0095C0 + 1) - 1;
          while (1)
          {
            uint64_t v20 = v12[1];
            if (v20 == v8)
            {
              uint64_t v21 = *((unsigned __int8 *)v12 + 39);
              if ((v21 & 0x80u) == 0) {
                uint64_t v22 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v22 = v12[3];
              }
              if (v22 == v14)
              {
                if ((v21 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v2, v12[3])) {
                    goto LABEL_55;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    goto LABEL_55;
                  }
                  uint64_t v23 = 0;
                  while (*((unsigned __int8 *)v12 + v23 + 16) == *((unsigned __int8 *)v2 + v23))
                  {
                    if (v21 == ++v23) {
                      goto LABEL_54;
                    }
                  }
                }
              }
            }
            else if ((v20 & v15) != v10)
            {
              goto LABEL_62;
            }
            CFNumberRef v12 = (uint64_t *)*v12;
            if (!v12) {
              goto LABEL_62;
            }
          }
        }
        do
        {
          unint64_t v16 = v12[1];
          if (v16 == v8)
          {
            uint64_t v17 = *((unsigned __int8 *)v12 + 39);
            if ((v17 & 0x80u) == 0) {
              uint64_t v18 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v18 = v12[3];
            }
            if (v18 == v14)
            {
              if ((v17 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v2, v12[3]))
                {
LABEL_55:
                  uint64_t v24 = (std::__shared_weak_count *)v12[6];
                  if (v24 && (uint64_t v24 = std::__shared_weak_count::lock(v24)) != 0) {
                    uint64_t v25 = v12[5];
                  }
                  else {
                    uint64_t v25 = 0;
                  }
                  uint64_t v26 = *(void *)(a1[5] + 8);
                  unint64_t v27 = *(std::__shared_weak_count **)(v26 + 48);
                  *(void *)(v26 + 40) = v25;
                  *(void *)(v26 + 48) = v24;
                  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                    std::__shared_weak_count::__release_weak(v27);
                  }
                  break;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  goto LABEL_55;
                }
                uint64_t v19 = 0;
                while (*((unsigned __int8 *)v12 + v19 + 16) == *((unsigned __int8 *)v2 + v19))
                {
                  if (v17 == ++v19)
                  {
LABEL_54:
                    if (!v12) {
                      goto LABEL_62;
                    }
                    goto LABEL_55;
                  }
                }
              }
            }
          }
          else
          {
            if (v16 >= v7) {
              v16 %= v7;
            }
            if (v16 != v10) {
              break;
            }
          }
          CFNumberRef v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_62:
  if (!*(void *)(*(void *)(a1[5] + 8) + 40))
  {
    (*(void (**)(void))(a1[4] + 16))();
    operator new();
  }
}

void sub_19E410898(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E4108F8((uint64_t *)va);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_19E4108F8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      int v3 = *(std::__shared_weak_count **)(v2 + 48);
      if (v3) {
        std::__shared_weak_count::__release_weak(v3);
      }
      if (*(char *)(v2 + 39) < 0) {
        operator delete(*(void **)(v2 + 16));
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t sub_19E410958(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__110shared_ptrIN2LM10FSTGrammarEE27__shared_ptr_default_deleteIS2_S2_EE"
    || ((v3 & (unint64_t)"NSt3__110shared_ptrIN2LM10FSTGrammarEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__110shared_ptrIN2LM10FSTGrammarEE27__shared_ptr_default_deleteIS2_S2_EE")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__110shared_ptrIN2LM10FSTGrammarEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E4109B0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    std::mutex::~mutex((std::mutex *)(v1 + 8));
    uint64_t v2 = *(uint64_t **)v1;
    *(void *)uint64_t v1 = 0;
    if (v2)
    {
      uint64_t v3 = *v2;
      *uint64_t v2 = 0;
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
      }
      MEMORY[0x19F3BDCF0](v2, 0x1020C405F07FB98);
    }
    JUMPOUT(0x19F3BDCF0);
  }
  return result;
}

void sub_19E410A60(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E410AA0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E410AC4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE2C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E410B18(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE2C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_19E410B3C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E410B60(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE258;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E410BB4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE258;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_19E410BD8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E410BFC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE4F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E410C50(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE4F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_19E410C70(void *a1, uint64_t a2)
{
  uint64_t v3 = (const void *)MEMORY[0x19F3BCDE0](a2);
  if (!v3)
  {
    CFTypeRef cf = 0;
    goto LABEL_8;
  }
  unint64_t v4 = v3;
  CFRetain(v3);
  sub_19E372124(&cf, v4);
  CFStringRef v5 = (const __CFString *)cf;
  if (!cf)
  {
LABEL_8:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    goto LABEL_10;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(v5))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not convert");
LABEL_10:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  sub_19E3721DC(a1, v5);
  if (cf) {
    CFRelease(cf);
  }
}

void sub_19E410D54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  __cxa_free_exception(v10);
  sub_19E3C6F1C(&a10);
  _Unwind_Resume(a1);
}

char *sub_19E410D84(char **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = v2 - *a1;
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = (v4 >> 3) + 1;
  if (v6 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v9 = a1[2] - v3;
  if (v9 >> 2 > v6) {
    unint64_t v6 = v9 >> 2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 >> 61) {
      sub_19E37C2B8();
    }
    CFNumberType v11 = (char *)operator new(8 * v10);
  }
  else
  {
    CFNumberType v11 = 0;
  }
  CFNumberRef v12 = &v11[8 * v5];
  char v13 = &v11[8 * v10];
  *(void *)CFNumberRef v12 = a2;
  uint64_t v14 = v12 + 8;
  if (v2 == v3)
  {
    *a1 = v12;
    a1[1] = v14;
    a1[2] = v13;
    goto LABEL_25;
  }
  unint64_t v15 = v2 - v3 - 8;
  if (v15 > 0x77
    && (&v2[-(v15 & 0xFFFFFFFFFFFFFFF8) - 8] >= v12 || &v11[v4 - (v15 & 0xFFFFFFFFFFFFFFF8) - 8] >= v2))
  {
    uint64_t v16 = (v15 >> 3) + 1;
    v12 -= 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v17 = v2 - 32;
    uint64_t v18 = &v11[8 * v5 - 16];
    uint64_t v19 = v16 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v21 = *(_OWORD *)v17;
      long long v20 = *((_OWORD *)v17 + 1);
      *(_OWORD *)uint64_t v17 = 0uLL;
      *((_OWORD *)v17 + 1) = 0uLL;
      v17 -= 32;
      *((_OWORD *)v18 - 1) = v21;
      *(_OWORD *)uint64_t v18 = v20;
      v18 -= 32;
      v19 -= 4;
    }
    while (v19);
    if (v16 == (v16 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_20;
    }
    v2 -= 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
  }
  do
  {
    uint64_t v22 = *((void *)v2 - 1);
    v2 -= 8;
    *(void *)uint64_t v2 = 0;
    *((void *)v12 - 1) = v22;
    v12 -= 8;
  }
  while (v2 != v3);
LABEL_20:
  uint64_t v2 = *a1;
  uint64_t v23 = a1[1];
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  while (v23 != v2)
  {
    uint64_t v25 = *((void *)v23 - 1);
    v23 -= 8;
    uint64_t v24 = v25;
    *(void *)uint64_t v23 = 0;
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
    }
  }
LABEL_25:
  if (v2) {
    operator delete(v2);
  }
  return v14;
}

const void **sub_19E410F30(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

const void **sub_19E410F68(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_19E410FA0(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void sub_19E410FC4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE728;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E411018(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE728;
  std::__shared_weak_count::~__shared_weak_count(this);
}

CFDictionaryRef sub_19E411038(uint64_t *a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_19E37C7C4();
    }
    size_t v3 = 8 * a2;
    uint64_t v5 = (char *)operator new(8 * a2);
    unint64_t v6 = (const void **)operator new(v3);
    unint64_t v7 = &v5[v3];
    unint64_t v8 = v5;
    uint64_t v9 = v6;
    unint64_t v10 = &a1[2 * a2];
    CFNumberType v11 = &v6[v3 / 8];
    uint64_t v54 = v10;
    while (1)
    {
      uint64_t v13 = *a1;
      if (v8 < v7)
      {
        *(void *)unint64_t v8 = v13;
        v8 += 8;
        goto LABEL_30;
      }
      char v52 = v11;
      int64_t v14 = v8 - v5;
      uint64_t v15 = (v8 - v5) >> 3;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 61) {
        sub_19E37C7C4();
      }
      if ((v7 - v5) >> 2 > v16) {
        unint64_t v16 = (v7 - v5) >> 2;
      }
      if ((unint64_t)(v7 - v5) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v16;
      }
      if (v17)
      {
        if (v17 >> 61) {
          sub_19E37C2B8();
        }
        uint64_t v18 = v8;
        uint64_t v19 = operator new(8 * v17);
        unint64_t v8 = v18;
      }
      else
      {
        uint64_t v19 = 0;
      }
      long long v20 = &v19[8 * v15];
      *(void *)long long v20 = v13;
      long long v21 = v20 + 8;
      if (v8 != v5)
      {
        unint64_t v22 = v8 - 8 - v5;
        if (v22 >= 0x58)
        {
          if ((unint64_t)(v8 - &v19[v14]) >= 0x20)
          {
            uint64_t v24 = (v22 >> 3) + 1;
            uint64_t v23 = &v8[-8 * (v24 & 0x3FFFFFFFFFFFFFFCLL)];
            uint64_t v25 = &v19[8 * v15 - 16];
            uint64_t v26 = v8 - 16;
            uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v28 = *(_OWORD *)v26;
              *(v25 - 1) = *((_OWORD *)v26 - 1);
              *uint64_t v25 = v28;
              v25 -= 2;
              v26 -= 32;
              v27 -= 4;
            }
            while (v27);
            v20 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
            if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_27;
            }
          }
          else
          {
            uint64_t v23 = v8;
          }
        }
        else
        {
          uint64_t v23 = v8;
        }
        do
        {
          uint64_t v29 = *((void *)v23 - 1);
          v23 -= 8;
          *((void *)v20 - 1) = v29;
          v20 -= 8;
        }
        while (v23 != v5);
      }
LABEL_27:
      unint64_t v7 = &v19[8 * v17];
      if (v5)
      {
        uint64_t v30 = &v19[8 * v17];
        operator delete(v5);
        unint64_t v7 = v30;
      }
      uint64_t v5 = v20;
      unint64_t v8 = v21;
      CFNumberType v11 = v52;
LABEL_30:
      int v31 = (const void *)a1[1];
      if (v9 >= v11)
      {
        uint64_t v32 = v9 - v6;
        unint64_t v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 61) {
          sub_19E37C7C4();
        }
        if (((char *)v11 - (char *)v6) >> 2 > v33) {
          unint64_t v33 = ((char *)v11 - (char *)v6) >> 2;
        }
        if ((unint64_t)((char *)v11 - (char *)v6) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v34 = v33;
        }
        long long v53 = v7;
        if (v34)
        {
          if (v34 >> 61) {
            sub_19E37C2B8();
          }
          float v35 = v8;
          BOOL v36 = operator new(8 * v34);
          unint64_t v8 = v35;
        }
        else
        {
          BOOL v36 = 0;
        }
        unint64_t v37 = (const void **)&v36[8 * v32];
        *unint64_t v37 = v31;
        CFNumberRef v12 = v37 + 1;
        if (v9 != v6)
        {
          unint64_t v38 = (char *)(v9 - 1) - (char *)v6;
          if (v38 < 0x58)
          {
            CFNumberRef v39 = v9;
            goto LABEL_49;
          }
          if ((unint64_t)((char *)v6 - v36) < 0x20)
          {
            CFNumberRef v39 = v9;
            goto LABEL_49;
          }
          uint64_t v40 = (v38 >> 3) + 1;
          CFNumberRef v39 = &v9[-(v40 & 0x3FFFFFFFFFFFFFFCLL)];
          unint64_t v41 = &v36[8 * v32 - 16];
          uint8x8_t v42 = v9 - 2;
          uint64_t v43 = v40 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v44 = *(_OWORD *)v42;
            *(v41 - 1) = *((_OWORD *)v42 - 1);
            *unint64_t v41 = v44;
            v41 -= 2;
            v42 -= 4;
            v43 -= 4;
          }
          while (v43);
          v37 -= v40 & 0x3FFFFFFFFFFFFFFCLL;
          if (v40 != (v40 & 0x3FFFFFFFFFFFFFFCLL))
          {
            do
            {
LABEL_49:
              unint64_t v45 = *--v39;
              *--unint64_t v37 = v45;
            }
            while (v39 != v6);
          }
        }
        CFNumberType v11 = (const void **)&v36[8 * v34];
        if (v6)
        {
          CFTypeRef v46 = v6;
          CFArrayRef v47 = v8;
          operator delete(v46);
          unint64_t v8 = v47;
        }
        unint64_t v6 = v37;
        unint64_t v7 = v53;
        goto LABEL_5;
      }
      *uint64_t v9 = v31;
      CFNumberRef v12 = v9 + 1;
LABEL_5:
      a1 += 2;
      uint64_t v9 = v12;
      if (a1 == v54) {
        goto LABEL_54;
      }
    }
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
LABEL_54:
  CFDictionaryRef v48 = CFDictionaryCreate(0, (const void **)v5, v6, a2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v48)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  if (v6) {
    operator delete(v6);
  }
  if (v5) {
    operator delete(v5);
  }
  return v48;
}

void sub_19E411404(_Unwind_Exception *a1)
{
  __cxa_free_exception(v3);
  if (v2)
  {
    operator delete(v2);
    if (!v1) {
LABEL_3:
    }
      _Unwind_Resume(a1);
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E41145C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  return a1;
}

uint64_t sub_19E4114A0(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(a1 + 8) = 0;
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  *(void *)a1 = 0;
  return a1;
}

void sub_19E4114EC(void **a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  unint64_t v6 = a3;
  unint64_t v8 = *a1;
  unint64_t v9 = (unint64_t)a1[1];
  uint64_t v10 = a2 - (void)*a1;
  uint64_t v11 = v10 >> 4;
  unint64_t v12 = (unint64_t)*a1 + (v10 & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = a1[2];
  if (a5 > (uint64_t)&v13[-v9] >> 4)
  {
    unint64_t v14 = a5 + ((uint64_t)(v9 - (void)v8) >> 4);
    if (v14 >> 60) {
      sub_19E37C7C4();
    }
    uint64_t v15 = v13 - (unsigned char *)v8;
    if (v15 >> 3 > v14) {
      unint64_t v14 = v15 >> 3;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      if (v16 >> 60) {
        sub_19E37C2B8();
      }
      unint64_t v17 = (char *)operator new(16 * v16);
    }
    else
    {
      unint64_t v17 = 0;
    }
    uint64_t v23 = &v17[16 * v11];
    uint64_t v24 = &v23[16 * a5];
    uint64_t v25 = v23;
    do
    {
      uint64_t v26 = v6[1];
      *(void *)uint64_t v25 = *v6;
      *((void *)v25 + 1) = v26;
      if (v26) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
      }
      v25 += 16;
      v6 += 2;
    }
    while (v25 != v24);
    uint64_t v27 = *a1;
    if (*a1 != (void *)v12)
    {
      long long v28 = (void *)v12;
      do
      {
        long long v29 = *((_OWORD *)v28 - 1);
        v28 -= 2;
        *((_OWORD *)v23 - 1) = v29;
        v23 -= 16;
        *long long v28 = 0;
        v28[1] = 0;
      }
      while (v28 != v27);
    }
    uint64_t v30 = a1[1];
    if (v30 != (void *)v12)
    {
      do
      {
        *(_OWORD *)uint64_t v24 = *(_OWORD *)v12;
        v24 += 16;
        *(void *)unint64_t v12 = 0;
        *(void *)(v12 + 8) = 0;
        v12 += 16;
      }
      while ((void *)v12 != v30);
      unint64_t v12 = (unint64_t)a1[1];
    }
    int v31 = *a1;
    *a1 = v23;
    a1[1] = v24;
    for (a1[2] = &v17[16 * v16]; (void *)v12 != v31; v12 -= 16)
    {
      uint64_t v32 = *(std::__shared_weak_count **)(v12 - 8);
      if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    if (v31)
    {
      operator delete(v31);
    }
    return;
  }
  uint64_t v18 = (uint64_t)(v9 - v12) >> 4;
  if (v18 >= a5)
  {
    uint64_t v19 = &a3[2 * a5];
    long long v21 = (char *)a1[1];
LABEL_42:
    unint64_t v33 = (char *)(v12 + 16 * a5);
    unint64_t v34 = &v21[-16 * a5];
    float v35 = v21;
    if ((unint64_t)v34 < v9)
    {
      float v35 = v21;
      do
      {
        *(_OWORD *)float v35 = *(_OWORD *)v34;
        v35 += 16;
        *(void *)unint64_t v34 = 0;
        *((void *)v34 + 1) = 0;
        v34 += 16;
      }
      while ((unint64_t)v34 < v9);
    }
    a1[1] = v35;
    if (v21 != v33)
    {
      BOOL v36 = (std::__shared_weak_count **)(v21 - 8);
      uint64_t v37 = 16 * ((v21 - v33) >> 4);
      uint64_t v38 = (uint64_t)&v8[2 * v11 - 2];
      do
      {
        CFNumberRef v39 = (void *)(v38 + v37);
        long long v40 = *(_OWORD *)(v38 + v37);
        *CFNumberRef v39 = 0;
        v39[1] = 0;
        unint64_t v41 = *v36;
        *(_OWORD *)(v36 - 1) = v40;
        if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
        v36 -= 2;
        v37 -= 16;
      }
      while (v37);
    }
    for (; v6 != v19; v12 += 16)
    {
      uint64_t v43 = *v6;
      uint64_t v42 = v6[1];
      if (v42) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v42 + 8), 1uLL, memory_order_relaxed);
      }
      long long v44 = *(std::__shared_weak_count **)(v12 + 8);
      *(void *)unint64_t v12 = v43;
      *(void *)(v12 + 8) = v42;
      if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
      v6 += 2;
    }
    return;
  }
  uint64_t v19 = &a3[2 * v18];
  if (v19 == a4)
  {
    long long v21 = (char *)a1[1];
  }
  else
  {
    long long v20 = &a3[2 * v18];
    long long v21 = (char *)a1[1];
    do
    {
      uint64_t v22 = v20[1];
      *(void *)long long v21 = *v20;
      *((void *)v21 + 1) = v22;
      if (v22) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
      }
      v21 += 16;
      v20 += 2;
    }
    while (v20 != a4);
  }
  a1[1] = v21;
  if ((uint64_t)(v9 - v12) >= 1) {
    goto LABEL_42;
  }
}

char *sub_19E411884(char **a1, uint64_t a2)
{
  size_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = v2 - *a1;
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = (v4 >> 3) + 1;
  if (v6 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v9 = a1[2] - v3;
  if (v9 >> 2 > v6) {
    unint64_t v6 = v9 >> 2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v11 = (char *)operator new(8 * v10);
  }
  else
  {
    uint64_t v11 = 0;
  }
  unint64_t v12 = &v11[8 * v5];
  uint64_t v13 = &v11[8 * v10];
  uint64_t v14 = a2 + 8;
  if (!a2) {
    uint64_t v14 = 0;
  }
  *(void *)unint64_t v12 = v14;
  uint64_t v15 = v12 + 8;
  if (v2 == v3)
  {
    *a1 = v12;
    a1[1] = v15;
    a1[2] = v13;
    goto LABEL_27;
  }
  unint64_t v16 = v2 - v3 - 8;
  if (v16 > 0x77
    && (&v2[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v12 || &v11[v4 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v2))
  {
    uint64_t v17 = (v16 >> 3) + 1;
    v12 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v18 = v2 - 32;
    uint64_t v19 = &v11[8 * v5 - 16];
    uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v22 = *(_OWORD *)v18;
      long long v21 = *((_OWORD *)v18 + 1);
      *(_OWORD *)uint64_t v18 = 0uLL;
      *((_OWORD *)v18 + 1) = 0uLL;
      v18 -= 32;
      *((_OWORD *)v19 - 1) = v22;
      *(_OWORD *)uint64_t v19 = v21;
      v19 -= 32;
      v20 -= 4;
    }
    while (v20);
    if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_22;
    }
    v2 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
  }
  do
  {
    uint64_t v23 = *((void *)v2 - 1);
    v2 -= 8;
    *(void *)uint64_t v2 = 0;
    *((void *)v12 - 1) = v23;
    v12 -= 8;
  }
  while (v2 != v3);
LABEL_22:
  uint64_t v2 = *a1;
  uint64_t v24 = a1[1];
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v13;
  while (v24 != v2)
  {
    uint64_t v26 = *((void *)v24 - 1);
    v24 -= 8;
    uint64_t v25 = v26;
    *(void *)uint64_t v24 = 0;
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    }
  }
LABEL_27:
  if (v2) {
    operator delete(v2);
  }
  return v15;
}

void sub_19E411A3C()
{
  uint64_t v0 = operator new(0xE0uLL);
  v0[1] = 0;
  v0[2] = 0;
  *uint64_t v0 = &unk_1EF0BE530;
  sub_19E3C2CE4();
}

void sub_19E4127B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, void **a14, void **a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a33 < 0)
  {
    operator delete(a28);
    if ((v60 & 1) == 0)
    {
LABEL_8:
      a40 = (void *)*MEMORY[0x1E4FBA408];
      uint64_t v63 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      *(void **)((char *)&a40 + *(a40 - 3)) = *(void **)(MEMORY[0x1E4FBA408] + 64);
      a42 = v63;
      a43 = MEMORY[0x1E4FBA470] + 16;
      if (a56 < 0) {
        operator delete(a51);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x19F3BDC30](&a59);
      char v64 = *a15;
      if (*a15)
      {
        v59[7].__shared_weak_owners_ = (uint64_t)v64;
        operator delete(v64);
      }
      uint64_t v65 = *a17;
      if (*a17)
      {
        v59[6].__shared_weak_owners_ = (uint64_t)v65;
        operator delete(v65);
      }
      shared_owners = (void *)v59[5].__shared_owners_;
      if (shared_owners)
      {
        do
        {
          char v67 = (void *)*shared_owners;
          operator delete(shared_owners);
          shared_owners = v67;
        }
        while (v67);
      }
      shared_weak_owners = (void *)v59[4].__shared_weak_owners_;
      v59[4].__shared_weak_owners_ = 0;
      if (shared_weak_owners) {
        operator delete(shared_weak_owners);
      }
      uint64_t v69 = v59[4].__shared_owners_;
      v59[4].__shared_owners_ = 0;
      if (v69)
      {
        int v70 = *(void **)v69;
        if (*(void *)v69)
        {
          *(void *)(v69 + 8) = v70;
          operator delete(v70);
        }
        MEMORY[0x19F3BDCF0](v69, 0x1080C409A65DFB4);
      }
      uint32_t v71 = (std::__shared_weak_count_vtbl *)v59[2].__shared_weak_owners_;
      if (v71)
      {
        v59[3].__vftable = v71;
        operator delete(v71);
      }
      uint64_t v72 = (std::__shared_weak_count_vtbl *)*a14;
      if (*a14)
      {
        v59[2].__vftable = v72;
        operator delete(v72);
      }
      if (*a13) {
        munmap(*a13, v59[1].__shared_owners_);
      }
      v59[1].__shared_owners_ = 0;
      std::__shared_weak_count::~__shared_weak_count(v59);
      operator delete(v73);
      _Unwind_Resume(a1);
    }
  }
  else if (!v60)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v61);
  goto LABEL_8;
}

uint64_t sub_19E412B04(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_19E412B7C(void *a1)
{
  unint64_t v1 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[1] - *a1) >> 3) + 1;
  if (v1 <= 0x666666666666666)
  {
    if (0x999999999999999ALL * ((uint64_t)(a1[2] - *a1) >> 3) > v1) {
      unint64_t v1 = 0x999999999999999ALL * ((uint64_t)(a1[2] - *a1) >> 3);
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[2] - *a1) >> 3) >= 0x333333333333333) {
      unint64_t v2 = 0x666666666666666;
    }
    else {
      unint64_t v2 = v1;
    }
    if (v2)
    {
      if (v2 > 0x666666666666666) {
        sub_19E37C2B8();
      }
      operator new(40 * v2);
    }
    sub_19E50B320();
  }
  sub_19E37C7C4();
}

void sub_19E412CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E412D84((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_19E412D04(void *a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

uint64_t sub_19E412D84(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
    sub_19E3FF880(i - 40);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_19E412DDC(void *a1)
{
  unint64_t v2 = (void *)a1[22];
  if (v2)
  {
    a1[23] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[19];
  if (v3)
  {
    a1[20] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[16];
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)*v4;
      operator delete(v4);
      uint64_t v4 = v5;
    }
    while (v5);
  }
  unint64_t v6 = (void *)a1[14];
  a1[14] = 0;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = a1[13];
  a1[13] = 0;
  if (v7)
  {
    unint64_t v8 = *(void **)v7;
    if (*(void *)v7)
    {
      *(void *)(v7 + 8) = v8;
      operator delete(v8);
    }
    MEMORY[0x19F3BDCF0](v7, 0x1080C409A65DFB4);
  }
  uint64_t v9 = (void *)a1[8];
  if (v9)
  {
    a1[9] = v9;
    operator delete(v9);
  }
  unint64_t v10 = (void *)a1[5];
  if (v10)
  {
    a1[6] = v10;
    operator delete(v10);
  }
  __n128 result = (void *)a1[3];
  if (result) {
    __n128 result = (void *)munmap(result, a1[4]);
  }
  a1[4] = 0;
  return result;
}

void sub_19E412EB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE530;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E412F04(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE530;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_19E412F28(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__110shared_ptrIN2LM10ParametersEE27__shared_ptr_default_deleteIS2_S2_EE"
    || ((v3 & (unint64_t)"NSt3__110shared_ptrIN2LM10ParametersEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__110shared_ptrIN2LM10ParametersEE27__shared_ptr_default_deleteIS2_S2_EE")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__110shared_ptrIN2LM10ParametersEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E412F80(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_19E3D7670(result);
    JUMPOUT(0x19F3BDCF0);
  }
  return result;
}

void sub_19E412FC8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E413004()
{
}

void sub_19E41320C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  sub_19E3D73EC((uint64_t)&a9);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  MEMORY[0x19F3BDCF0](v10, 0x10A1C40417A30D1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E413274(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  long long v5 = *(_OWORD *)(a3 + 16);
  v9[0] = *(_OWORD *)a3;
  v9[1] = v5;
  long long v6 = *(_OWORD *)(a3 + 48);
  __n128 v10 = *(__n128 *)(a3 + 32);
  long long v11 = v6;
  uint64_t v13 = 0;
  uint64_t v7 = sub_19E413378(a1, a2 | ((unint64_t)a2 << 32), (uint64_t *)v9, a4, a5, 1, 1, v12, v10);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
  }
  else if (v13)
  {
    (*(void (**)(void *))(*v13 + 40))(v13);
  }
  return v7;
}

void sub_19E413364(_Unwind_Exception *a1)
{
  sub_19E3C76B8((void *)(v1 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_19E413378(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, int a6, int a7, void *a8, __n128 a9)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  uint64_t v99 = a5;
  unint64_t v14 = a3[1];
  if (v14)
  {
    uint64_t v15 = *a3;
    uint64_t v16 = 4 * v14;
    uint64_t v17 = *a3 + 4 * v14;
    while (v16)
    {
      int v18 = *(_DWORD *)(v15 + v16 - 4);
      v16 -= 4;
      if (v18 == 1)
      {
        uint64_t v19 = (v17 - (v15 + v16 + 4)) >> 2;
        unint64_t v14 = v19 + 1;
        uint64_t v15 = v17 + 4 * ~v19;
        break;
      }
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  *a3 = v15;
  a3[1] = v14;
  unint64_t v20 = a3[3];
  if (v20 >= v14) {
    unint64_t v21 = v14;
  }
  else {
    unint64_t v21 = a3[3];
  }
  a3[2] = a3[2] + 4 * v20 - 4 * v21;
  a3[3] = v21;
  unint64_t v22 = a3[5];
  if (v22 >= v14) {
    unint64_t v23 = v14;
  }
  else {
    unint64_t v23 = a3[5];
  }
  a3[4] = a3[4] + 4 * v22 - 4 * v23;
  a3[5] = v23;
  unint64_t v24 = a3[7];
  if (v24 < v14) {
    unint64_t v14 = a3[7];
  }
  a3[6] = a3[6] + 4 * v24 - 4 * v14;
  a3[7] = v14;
  if (a8[3]
    || !*(void *)(a1 + 248)
    && *(void *)(a1 + 136) == *(void *)(a1 + 128)
    && *(void *)(a1 + 160) == *(void *)(a1 + 152))
  {
    int v93 = 0;
  }
  else
  {
    *(void *)(a4 + 16) = 0;
    *(_WORD *)(a4 + 24) = 0;
    int v93 = 1;
    *(unsigned char *)(a4 + 32) = 1;
    *(_OWORD *)(a4 + 40) = xmmword_19E572FD0;
    *(_DWORD *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 64) = xmmword_19E572FD0;
    *(void *)(a4 + 88) = 0;
    *(void *)(a4 + 96) = 0;
    *(void *)(a4 + 80) = 0xFFEFFFFFFFFFFFFFLL;
    a9.n128_u64[1] = 0xFFEFFFFFFFFFFFFFLL;
    *(_OWORD *)a4 = xmmword_19E573020;
  }
  if (*(void *)(a1 + 288)) {
    int v25 = a6;
  }
  else {
    int v25 = 0;
  }
  if (*(void *)(a1 + 296)) {
    int v26 = a6;
  }
  else {
    int v26 = 0;
  }
  if (*(void *)(a1 + 304)) {
    int v27 = a6;
  }
  else {
    int v27 = 0;
  }
  uint64_t v28 = *(void *)(a1 + 232);
  if (!*(unsigned char *)(v28 + 192))
  {
    int v94 = 0;
    uint64_t v30 = *(void *)(a1 + 280);
    if (v30) {
      goto LABEL_35;
    }
LABEL_39:
    unsigned int v95 = 0;
    if (a2 == 1) {
      goto LABEL_36;
    }
LABEL_40:
    if ((a2 & 0x80000000) != 0) {
      int v32 = v26;
    }
    else {
      int v32 = 0;
    }
    if (v32 == 1)
    {
      std::string __p = 0;
      if (sub_19E4A18B0(*(void **)(a1 + 296), a2, (uint64_t)a3, a4, (double *)&__p)) {
        goto LABEL_66;
      }
    }
    unsigned int v31 = a2 >> 31;
    if ((a2 & 0x80000000) != 0) {
      int v33 = v27;
    }
    else {
      int v33 = 0;
    }
    if (v33 == 1)
    {
      double v98 = 0.0;
      if (sub_19E4A18B0(*(void **)(a1 + 304), a2, (uint64_t)a3, a4, &v98)) {
        goto LABEL_62;
      }
      float v35 = *(void **)(a1 + 24);
      unint64_t v34 = *(void **)(a1 + 32);
      if (v35 != v34)
      {
        BOOL v36 = 0;
        do
        {
          if ((*(unsigned int (**)(void, unint64_t))(*(void *)*v35 + 80))(*v35, a2))
          {
            (*(void (**)(void **__return_ptr))(*(void *)*v35 + 56))(&__p);
            double v97 = 0.0;
            if (*(unsigned char *)(*(void *)(a1 + 232) + 192))
            {
              uint64_t v37 = *(void *)(a1 + 304);
              if (v37)
              {
                int v38 = (*(uint64_t (**)(void, void **, double *))(**(void **)(v37 + 16) + 24))(*(void *)(v37 + 16), &__p, &v97);
                if (v38) {
                  BOOL v36 = sub_19E4A18B0(*(void **)(a1 + 304), v38, (uint64_t)a3, a4, &v98);
                }
              }
            }
            if (v102 < 0) {
              operator delete(__p);
            }
          }
          ++v35;
        }
        while (v35 != v34);
        if (v36)
        {
LABEL_62:
          double v40 = v98;
          if (v98 > *(double *)a4)
          {
            *(void *)(a4 + 8) = 0xFFEFFFFFFFFFFFFFLL;
            *(void *)(a4 + 16) = 0;
            *(_WORD *)(a4 + 24) = 0;
            BOOL v39 = 1;
            *(unsigned char *)(a4 + 32) = 1;
            *(_OWORD *)(a4 + 40) = xmmword_19E572FD0;
            *(_DWORD *)(a4 + 56) = 0;
            *(_OWORD *)(a4 + 64) = xmmword_19E572FD0;
LABEL_67:
            *(double *)a4 = v40;
            *(double *)(a4 + 80) = v40;
            *(void *)(a4 + 88) = 0x3FF0000000000000;
            *(void *)(a4 + 96) = 0;
            return v39;
          }
        }
      }
    }
    goto LABEL_64;
  }
  if (*(unsigned char *)(v28 + 419)) {
    int v29 = 0;
  }
  else {
    int v29 = a6;
  }
  int v94 = v29;
  uint64_t v30 = *(void *)(a1 + 280);
  if (!v30) {
    goto LABEL_39;
  }
LABEL_35:
  unsigned int v95 = a6 & ~(*(unsigned int (**)(void))(**(void **)(v30 + 8) + 24))(*(void *)(v30 + 8));
  if (a2 != 1) {
    goto LABEL_40;
  }
LABEL_36:
  if (!a3[1]) {
    return 1;
  }
  unsigned int v31 = a2 >> 31;
LABEL_64:
  if ((v25 & v31) == 1)
  {
    std::string __p = 0;
    if (sub_19E4A18B0(*(void **)(a1 + 288), a2, (uint64_t)a3, a4, (double *)&__p))
    {
LABEL_66:
      *(void *)(a4 + 8) = 0xFFEFFFFFFFFFFFFFLL;
      *(void *)(a4 + 16) = 0;
      *(_WORD *)(a4 + 24) = 0;
      BOOL v39 = 1;
      *(unsigned char *)(a4 + 32) = 1;
      *(_OWORD *)(a4 + 40) = xmmword_19E572FD0;
      *(_DWORD *)(a4 + 56) = 0;
      *(_OWORD *)(a4 + 64) = xmmword_19E572FD0;
      double v40 = *(double *)&__p;
      goto LABEL_67;
    }
  }
  double v98 = 0.0;
  unint64_t v41 = *(float **)(a1 + 232);
  float v42 = v41[84];
  float v43 = v41[51];
  float v44 = v41[62];
  float v45 = (float)(v43 + v42) + v44;
  float v46 = 1.0;
  if (v95) {
    float v46 = 1.0 - v41[81];
  }
  if (v45 > 0.0)
  {
    float v47 = 1.0 / v45;
    v41[84] = (float)(v46 * v42) * v47;
    float v43 = (float)(v46 * v43) * v47;
    v41[51] = v43;
    v41[62] = (float)(v46 * v44) * v47;
  }
  CFDictionaryRef v48 = a8;
  float v49 = v41[85];
  float v50 = v41[63];
  float v51 = v50 + v49;
  if ((float)(v50 + v49) > 0.0)
  {
    v41[85] = v49 / v51;
    v41[63] = v50 / v51;
  }
  double v52 = 0.0;
  if (!v94)
  {
    double v59 = 0.0;
    double v60 = 0.0;
    if (!v95) {
      goto LABEL_85;
    }
    goto LABEL_84;
  }
  long long v53 = *(void **)(a1 + 272);
  if (v53)
  {
    uint64_t v54 = 248;
    if ((unint64_t)a3[3] < 2) {
      uint64_t v54 = 252;
    }
    float v55 = *(float *)(v53[3] + v54);
    unint64_t v56 = v53[7];
    if (v56)
    {
      CFTypeRef v57 = (std::mutex *)(v56 + 96);
      std::mutex::lock((std::mutex *)(v56 + 96));
      unint64_t v56 = *(void *)(v56 + 40);
      std::mutex::unlock(v57);
    }
    unint64_t v58 = (*(uint64_t (**)(void *))(*v53 + 32))(v53);
    if (v56 < v58) {
      float v55 = (float)((float)((float)v56 / (float)v58) * (float)((float)v56 / (float)v58)) * v55;
    }
    double v59 = v55;
    unint64_t v41 = *(float **)(a1 + 232);
    float v43 = v41[51];
    CFDictionaryRef v48 = a8;
  }
  else
  {
    double v59 = 0.0;
  }
  double v60 = v43;
  if (v95) {
LABEL_84:
  }
    double v52 = v41[81];
LABEL_85:
  if (v93)
  {
    int v61 = v48;
    CFTypeID v62 = *(void **)(a1 + 128);
    uint64_t v63 = *(void **)(a1 + 136);
    if (v62 == v63)
    {
      char v64 = 0;
      int v66 = 1;
      double v65 = 0.0;
    }
    else
    {
      char v64 = 0;
      double v65 = 0.0;
      int v66 = 1;
      do
      {
        std::string __p = 0;
        __int16 v101 = 0;
        v66 &= (*(uint64_t (**)(void, unint64_t, uint64_t, uint64_t, double *, void **, uint64_t))(*(void *)*v62 + 16))(*v62, a2, *a3, a3[1], &v98, &__p, v99);
        if ((uint64_t)__p > (uint64_t)v64) {
          char v64 = __p;
        }
        if (v66 == 1) {
          *(double *)a4 = *(double *)a4 + v98 * *(double *)(*v62 + 8);
        }
        if (*(void *)(a1 + 160) != *(void *)(a1 + 152))
        {
          double v97 = 0.0;
          (*(void (**)(void, unint64_t, void, void, double *, void, uint64_t))(*(void *)*v62 + 16))(*v62, a2, 0, 0, &v97, 0, v99);
          double v65 = v97 + v65;
        }
        v62 += 2;
      }
      while (v62 != v63);
    }
    char v67 = *(void **)(a1 + 152);
    uint64_t v68 = *(void **)(a1 + 160);
    while (v67 != v68)
    {
      int v69 = (*(uint64_t (**)(void, unint64_t, uint64_t, uint64_t, double *, void, uint64_t))(*(void *)*v67 + 16))(*v67, a2, *a3, a3[1], &v98, 0, v99);
      if ((_BYTE)v66) {
        int v66 = v69;
      }
      else {
        int v66 = 0;
      }
      if (v66) {
        *(double *)a4 = *(double *)a4 + v98 * *(double *)(*v67 + 8);
      }
      ++v67;
    }
    uint64_t v70 = *(void *)(a1 + 248);
    if (v70)
    {
      int v71 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, double *, void, uint64_t))(*(void *)v70 + 16))(v70, a2, *a3, a3[1], &v98, 0, v99) ^ 1;
      if (!v66) {
        LOBYTE(v71) = 1;
      }
      if (v71)
      {
        int v66 = 0;
      }
      else
      {
        *(double *)a4 = *(double *)a4 + v98 * *(double *)(*(void *)(a1 + 248) + 8);
        int v66 = 1;
      }
    }
    CFDictionaryRef v48 = v61;
    if (*(void *)(a1 + 160) != *(void *)(a1 + 152) && *(void *)(a1 + 136) != *(void *)(a1 + 128)) {
      *(double *)a4 = *(double *)a4 - v65;
    }
    *(_DWORD *)(a4 + 56) = 1;
    BOOL v39 = v66 != 0;
  }
  else
  {
    char v64 = 0;
    BOOL v39 = 1;
  }
  a9.n128_u64[0] = *(void *)a4;
  if (*(double *)a4 < 0.0)
  {
    *(void *)(a4 + 40) = a9.n128_u64[0];
    *(void *)(a4 + 48) = 0x3FF0000000000000;
    *(void *)(a4 + 8) = a9.n128_u64[0];
  }
  uint64_t v72 = (void *)v48[3];
  if (v72)
  {
    if (v72 == v48)
    {
      p_p = &__p;
      (*(void (**)(void *, void **, __n128))(*v48 + 24))(v48, &__p, a9);
      if (!v94) {
        goto LABEL_140;
      }
      goto LABEL_128;
    }
    CFTypeRef v73 = (void **)(*(uint64_t (**)(void *, __n128))(*v72 + 16))(v72, a9);
LABEL_125:
    p_p = v73;
    if (!v94) {
      goto LABEL_140;
    }
LABEL_128:
    double v76 = *(double *)a4;
    double v97 = 0.0;
    double v77 = 0.0;
    if (v60 > 0.0)
    {
      uint64_t v78 = *(uint64_t **)(a1 + 264);
      if (v78)
      {
        if (sub_19E534244(v78, HIDWORD(a2), a3[2], a3[3], &v97, (uint64_t)&__p, a7)) {
          double v77 = v97 * v60;
        }
      }
    }
    long double __x = 0.0;
    if (v59 > 0.0)
    {
      uint64_t v79 = *(uint64_t **)(a1 + 272);
      if (v79)
      {
        if (sub_19E534244(v79, HIDWORD(a2), a3[2], a3[3], &__x, (uint64_t)&__p, a7))
        {
          double v77 = __x * v59 + v77;
          if (__x * v59 > 0.0) {
            *(long double *)(a4 + 64) = log10(__x);
          }
        }
      }
    }
    double v80 = 1.0 - (v59 + v60 + v52);
    *(double *)(a4 + 72) = v59;
    if (v77 > 0.0) {
      *(unsigned char *)(a4 + 24) = 1;
    }
    *(double *)(a4 + 40) = v76;
    *(double *)(a4 + 48) = v80;
    *(double *)(a4 + 8) = v76;
    double v81 = __exp10(v76);
    *(long double *)a4 = log10(v77 + v81 * v80);
    goto LABEL_140;
  }
  if (*(void *)(a1 + 248))
  {
    CFTypeRef v73 = (void **)operator new(0x60uLL);
    void *v73 = &unk_1EF0B5B88;
    v73[1] = (void *)a2;
    long long v74 = *((_OWORD *)a3 + 1);
    *((_OWORD *)v73 + 1) = *(_OWORD *)a3;
    *((_OWORD *)v73 + 2) = v74;
    long long v75 = *((_OWORD *)a3 + 3);
    *((_OWORD *)v73 + 3) = *((_OWORD *)a3 + 2);
    *((_OWORD *)v73 + 4) = v75;
    v73[10] = &v99;
    v73[11] = (void *)a1;
    goto LABEL_125;
  }
  p_p = 0;
  if (v94) {
    goto LABEL_128;
  }
LABEL_140:
  double v97 = 0.0;
  if (v95)
  {
    if (*(void *)(a1 + 280))
    {
      if (sub_19E413F50((void *)a1, HIDWORD(a2)))
      {
        if (sub_19E534244(*(uint64_t **)(a1 + 280), HIDWORD(a2), a3[2], a3[3], &v97, (uint64_t)&__p, a7))
        {
          double v82 = v97;
          double v83 = __exp10(*(double *)a4);
          double v84 = v82 * v52;
          *(long double *)a4 = log10(v83 + v84);
          if (v84 > 0.0) {
            *(unsigned char *)(a4 + 25) = 1;
          }
        }
      }
    }
  }
  uint64_t v85 = *(void *)(a1 + 336);
  if (v85
    && ((*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(*(void *)v85 + 16))(v85, a2, *a3, a3[1]) & 1) == 0)
  {
    double v86 = (*(double (**)(void))(**(void **)(a1 + 336) + 24))(*(void *)(a1 + 336));
    *(double *)a4 = *(double *)a4 - v86;
    *(double *)(a4 + 96) = *(double *)(a4 + 96) + v86;
  }
  uint64_t v88 = *(void **)(a1 + 24);
  double v87 = *(void **)(a1 + 32);
  if (v88 != v87)
  {
    while (1)
    {
      int v89 = (*(uint64_t (**)(void, unint64_t))(*(void *)*v88 + 80))(*v88, a2);
      if (v89 && v89 != a2) {
        break;
      }
      if (++v88 == v87) {
        goto LABEL_156;
      }
    }
    *(double *)a4 = *(double *)a4 + -3.0;
    *(double *)(a4 + 96) = *(double *)(a4 + 96) + 3.0;
  }
LABEL_156:
  *(void *)(a4 + 16) = v64;
  if (p_p == &__p)
  {
    (*((void (**)(void **))__p + 4))(&__p);
  }
  else if (p_p)
  {
    (*((void (**)(void))*p_p + 5))();
  }
  return v39;
}

void sub_19E413F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

BOOL sub_19E413F50(void *a1, uint64_t a2)
{
  if (!a1[11]) {
    return 0;
  }
  sub_19E3FDF08(a1, a2, (uint64_t)&__p);
  if (v10 >= 0) {
    p_p = (const UInt8 *)&__p;
  }
  else {
    p_p = (const UInt8 *)__p;
  }
  if (p_p)
  {
    if (v10 >= 0) {
      CFIndex v3 = HIBYTE(v10);
    }
    else {
      CFIndex v3 = (CFIndex)v9;
    }
    CFStringRef v4 = CFStringCreateWithBytes(0, p_p, v3, 0x8000100u, 0);
    CFStringRef v12 = v4;
    if (!v4)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    if ((v10 & 0x8000000000000000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  CFStringRef v4 = 0;
  CFStringRef v12 = 0;
  if (v10 < 0) {
LABEL_11:
  }
    operator delete(__p);
LABEL_12:
  std::string __p = 0;
  uint64_t v9 = &__p;
  uint64_t v10 = 0x2000000000;
  char v11 = 0;
  LXLemmatizerEnumerateLemmasforString();
  BOOL v5 = *((unsigned char *)v9 + 24) != 0;
  _Block_object_dispose(&__p, 8);
  if (v4) {
    CFRelease(v4);
  }
  return v5;
}

void sub_19E4140CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E414120(uint64_t result, uint64_t a2, int a3, unsigned char *a4)
{
  if ((a3 - 1) <= 2)
  {
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void *sub_19E414144()
{
  return &unk_1EF0B4CC8;
}

uint64_t sub_19E414150(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK2LM22CompositeLanguageModel22conditionalProbabilityENS_11SingleTokenENS_13ContextTokensERNS_18Co"
                     "mpositeScoreInfoEPNS_6LoggerEbbRKNSt3__18functionIFdmEEEE3$_0"
    || ((v3 & (unint64_t)"ZNK2LM22CompositeLanguageModel22conditionalProbabilityENS_11SingleTokenENS_13ContextToke"
                                "nsERNS_18CompositeScoreInfoEPNS_6LoggerEbbRKNSt3__18functionIFdmEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK2LM22CompositeLanguageModel22conditionalProbabilityENS_11SingleTokenENS_13ContextTokensERNS_18CompositeScoreInfoEPNS_6LoggerEbbRKNSt3__18functionIFdmEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK2LM22CompositeLanguageModel22conditionalProbabilityENS_11SingleTokenENS_13ContextTokensERNS_18CompositeScoreInfoEPNS_6LoggerEbbRKNSt3__18functionIFdmEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

double sub_19E4141A8(uint64_t a1, void *a2, __n128 a3)
{
  CFStringRef v4 = *(void **)(*(void *)(a1 + 88) + 248);
  uint64_t v5 = v4[3];
  a3.n128_u64[0] = 1.0;
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = v6 - *a2;
    if (v6 != *a2)
    {
      uint64_t v8 = *(unsigned int *)(a1 + 8);
      if ((v8 - 5) > 0x3B || ((1 << (v8 - 5)) & 0xC00000000040005) == 0)
      {
        uint64_t v10 = *(void *)(a1 + 16);
        uint64_t v11 = **(void **)(a1 + 80);
        double v16 = 0.0;
        int v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, double *, void, uint64_t, __n128))(*(void *)v5 + 16))(v5, v8, 0, 0, &v16, 0, v11, a3);
        a3.n128_u64[0] = 1.0;
        if (v12)
        {
          double v15 = 0.0;
          int v13 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, double *, void, uint64_t, double))(*v4 + 16))(v4, v8, v10, v7, &v15, 0, v11, 1.0);
          a3.n128_u64[0] = 1.0;
          if (v13) {
            a3.n128_f64[0] = __exp10(v15 - v16);
          }
        }
      }
    }
  }
  return a3.n128_f64[0];
}

__n128 sub_19E4142E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0B5B88;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  __n128 result = *(__n128 *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 56);
  long long v5 = *(_OWORD *)(a1 + 72);
  *(void *)(a2 + 88) = *(void *)(a1 + 88);
  *(_OWORD *)(a2 + 72) = v5;
  *(_OWORD *)(a2 + 56) = v4;
  *(__n128 *)(a2 + 40) = result;
  return result;
}

__n128 sub_19E414338(uint64_t a1)
{
  long long v2 = (char *)operator new(0x60uLL);
  *(void *)long long v2 = &unk_1EF0B5B88;
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  *((void *)v2 + 11) = *(void *)(a1 + 88);
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_19E4143AC()
{
}

unint64_t sub_19E4143C4(void *a1, const __CFString *a2)
{
  if (!a2 || (CFTypeID TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(a2)))
  {
    __cxa_allocate_exception(0x10uLL);
    sub_19E4144D4();
  }
  return sub_19E3721DC(a1, a2);
}

void sub_19E414434()
{
  __cxa_throw(v0, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_19E414454(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E414468(uint64_t a1)
{
  long long v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      long long v5 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      long long v2 = v5;
    }
    while (v5);
  }
  unint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void sub_19E4144D4()
{
}

uint64_t sub_19E4144E0(void *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1[29];
  if (!*(unsigned char *)(v3 + 361) && !*(unsigned char *)(v3 + 360))
  {
    uint64_t v7 = a1[23];
    uint64_t v8 = a1[24];
    if (v7 == v8)
    {
      BOOL v4 = 0;
      int v5 = 1;
      return v4 | (v5 << 8);
    }
    double v10 = *MEMORY[0x1E4F72480];
    while (1)
    {
      uint64_t v11 = *(void *)(*(void *)v7 + 8);
      if (*(void *)(*(void *)v7 + 16) != v11) {
        break;
      }
LABEL_7:
      BOOL v4 = 0;
      v7 += 16;
      int v5 = 1;
      if (v7 == v8) {
        return v4 | (v5 << 8);
      }
    }
    unint64_t v12 = 0;
    while (1)
    {
      double v22 = v10;
      int v21 = 0;
      int v21 = (*(uint64_t (**)(void, uint64_t, double *))(**(void **)(v11 + 8 * v12) + 24))(*(void *)(v11 + 8 * v12), a2, &v22);
      if (v21)
      {
        BOOL v4 = v22 > *(double *)(*(void *)(*(void *)v7 + 32) + 8 * v12);
        int v5 = 1;
        return v4 | (v5 << 8);
      }
      if (*(char *)(a2 + 23) < 0)
      {
        unint64_t v14 = *(const UInt8 **)a2;
        if (!*(void *)a2)
        {
          CFTypeRef cf = 0;
          goto LABEL_16;
        }
        CFIndex v13 = *(void *)(a2 + 8);
      }
      else
      {
        CFIndex v13 = *(unsigned __int8 *)(a2 + 23);
        unint64_t v14 = (const UInt8 *)a2;
      }
      CFTypeRef cf = CFStringCreateWithBytes(0, v14, v13, 0x8000100u, 0);
      if (!cf)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
LABEL_16:
      double v15 = operator new(0x28uLL);
      *double v15 = &unk_1EF0BDF00;
      v15[1] = &cf;
      v15[2] = v7;
      v15[3] = &v22;
      v15[4] = &v21;
      unint64_t v24 = v15;
      uint64_t v16 = *(void *)(*(void *)(*(void *)v7 + 8) + 8 * v12);
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 48))(v16, a2, v23);
      int v17 = v21;
      if (v21) {
        BOOL v2 = v22 > *(double *)(*(void *)(*(void *)v7 + 32) + 8 * v12);
      }
      if (v24 == v23)
      {
        (*(void (**)(void *))(v23[0] + 32))(v23);
        CFTypeRef v18 = cf;
        if (!cf) {
          goto LABEL_25;
        }
LABEL_24:
        CFRelease(v18);
        goto LABEL_25;
      }
      if (v24) {
        (*(void (**)(void))(*v24 + 40))();
      }
      CFTypeRef v18 = cf;
      if (cf) {
        goto LABEL_24;
      }
LABEL_25:
      if (v17)
      {
        int v5 = 1;
        BOOL v4 = v2;
        return v4 | (v5 << 8);
      }
      ++v12;
      uint64_t v11 = *(void *)(*(void *)v7 + 8);
      if (v12 >= (*(void *)(*(void *)v7 + 16) - v11) >> 3) {
        goto LABEL_7;
      }
    }
  }
  BOOL v4 = 0;
  int v5 = 0;
  return v4 | (v5 << 8);
}

void sub_19E4147E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf, uint64_t a10, uint64_t a11, char a12)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E414850(void *a1)
{
  BOOL v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E4148D4()
{
  return &unk_1EF0B82E8;
}

uint64_t sub_19E4148E0(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK2LM22CompositeLanguageModel29isCommonWordFromStaticLexiconENSt3__112basic_stringIcNS1_11char_tra"
                     "itsIcEENS1_9allocatorIcEEEEE3$_0"
    || ((v3 & (unint64_t)"ZNK2LM22CompositeLanguageModel29isCommonWordFromStaticLexiconENSt3__112basic_stringIcNS1"
                                "_11char_traitsIcEENS1_9allocatorIcEEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK2LM22CompositeLanguageModel29isCommonWordFromStaticLexiconENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK2LM22CompositeLanguageModel29isCommonWordFromStaticLexiconENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

CFComparisonResult sub_19E414938(uint64_t a1, const __CFString **a2, int *a3, double *a4)
{
  CFStringRef v5 = *a2;
  int v6 = *a3;
  double v7 = *a4;
  CFStringRef v8 = **(const __CFString ***)(a1 + 8);
  v12.length = CFStringGetLength(v8);
  v12.location = 0;
  CFComparisonResult result = CFStringCompareWithOptionsAndLocale(v8, v5, v12, 0x81uLL, ***(CFLocaleRef ***)(a1 + 16));
  if (v6) {
    BOOL v10 = result == kCFCompareEqualTo;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    uint64_t v11 = *(double **)(a1 + 24);
    if (*v11 < v7)
    {
      double *v11 = v7;
      **(_DWORD **)(a1 + 32) = v6;
    }
  }
  return result;
}

__n128 sub_19E4149D8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0BDF00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E414A08(uint64_t a1)
{
  BOOL v2 = (char *)operator new(0x28uLL);
  *(void *)BOOL v2 = &unk_1EF0BDF00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_19E414A5C()
{
}

uint64_t sub_19E414A74(uint64_t result, uint64_t a2, uint64_t a3, double *a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v6 = result;
    uint64_t v7 = 0;
    int64x2_t v14 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    double v8 = 0.0;
    do
    {
      int64x2_t v15 = v14;
      uint64_t v16 = 0;
      __int16 v17 = 0;
      char v18 = 1;
      __n128 v10 = (__n128)xmmword_19E572FD0;
      long long v19 = xmmword_19E572FD0;
      int v20 = 0;
      long long v21 = xmmword_19E572FD0;
      unint64_t v22 = 0xFFEFFFFFFFFFFFFFLL;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      uint64_t v11 = *(unsigned int *)(a2 + 4 * v7);
      if (qword_1EC009490 != -1) {
        dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
      }
      v25[0] = a2;
      v25[1] = v7;
      v25[2] = a2;
      v25[3] = v7;
      v25[4] = a2;
      v25[5] = v7;
      v25[6] = a2;
      v25[7] = v7;
      int v27 = 0;
      int v12 = sub_19E413378(v6, v11 | (v11 << 32), v25, (uint64_t)&v15, qword_1EC009488, 1, 1, v26, v10);
      __n128 result = (uint64_t)v27;
      if (v27 == v26)
      {
        __n128 result = (*(uint64_t (**)(void *))(v26[0] + 32))(v26);
      }
      else if (v27)
      {
        __n128 result = (*(uint64_t (**)(void *))(*v27 + 40))(v27);
      }
      double v9 = *(double *)v15.i64;
      if (!v12) {
        double v9 = -0.0;
      }
      double v8 = v9 + v8;
      ++v7;
    }
    while (a3 != v7);
  }
  else
  {
    double v8 = 0.0;
  }
  if (a4) {
    *a4 = v8;
  }
  return result;
}

void sub_19E414C64(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 120);
  if (v3 == v1 - 144)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 - 144) + 32))(v1 - 144);
    _Unwind_Resume(exception_object);
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E414CD8(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  if (v2)
  {
    uint64_t v3 = *a2;
    uint64_t v4 = 4 * v2;
    uint64_t v5 = *a2 + 4 * v2;
    do
    {
      if (!v4) {
        goto LABEL_7;
      }
      int v6 = *(_DWORD *)(v3 + v4 - 4);
      v4 -= 4;
    }
    while (v6 != 1);
    uint64_t v7 = (v5 - (v3 + v4 + 4)) >> 2;
    unint64_t v2 = v7 + 1;
    uint64_t v3 = v5 + 4 * ~v7;
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_7:
  *a2 = v3;
  a2[1] = v2;
  unint64_t v8 = a2[3];
  if (v8 >= v2) {
    unint64_t v9 = v2;
  }
  else {
    unint64_t v9 = a2[3];
  }
  a2[2] = a2[2] + 4 * v8 - 4 * v9;
  a2[3] = v9;
  unint64_t v10 = a2[5];
  if (v10 >= v2) {
    unint64_t v11 = v2;
  }
  else {
    unint64_t v11 = a2[5];
  }
  a2[4] = a2[4] + 4 * v10 - 4 * v11;
  a2[5] = v11;
  unint64_t v12 = a2[7];
  if (v12 < v2) {
    unint64_t v2 = a2[7];
  }
  a2[6] = a2[6] + 4 * v12 - 4 * v2;
  a2[7] = v2;
  operator new();
}

void sub_19E414E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19E3D73EC((uint64_t)&a9);
  MEMORY[0x19F3BDCF0](v9, 0x10B1C40598E04D2);
  _Unwind_Resume(a1);
}

uint64_t sub_19E414EA4(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[23];
  uint64_t v5 = a1[24];
  while (v4 != v5)
  {
    int v6 = *(void **)(*(void *)v4 + 8);
    for (uint64_t i = *(void **)(*(void *)v4 + 16); v6 != i; ++v6)
    {
      uint64_t v8 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)*v6 + 24))(*v6, a2, 0);
      if (v8) {
        return v8;
      }
    }
    v4 += 16;
  }
  uint64_t v11 = a1[29];
  if (!*(unsigned char *)(v11 + 192)) {
    goto LABEL_23;
  }
  uint64_t v12 = a1[6];
  uint64_t v13 = *(void *)(v12 + 560);
  int64x2_t v14 = *(std::__shared_weak_count **)(v12 + 568);
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13
    || (uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v13 + 24))(v13, a2, 0), !v9))
  {
    uint64_t v9 = 0;
    int v15 = 1;
    if (!v14) {
      goto LABEL_20;
    }
LABEL_18:
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
    goto LABEL_20;
  }
  int v15 = 0;
  if (v14) {
    goto LABEL_18;
  }
LABEL_20:
  if (!v15 || v9) {
    return v9;
  }
  uint64_t v11 = a1[29];
LABEL_23:
  int v16 = *(unsigned __int8 *)(v11 + 358);
  return sub_19E4BA040(a2, v16);
}

void sub_19E415054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_19E415068(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v9 = (char *)operator new(8 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  unint64_t v10 = &v9[8 * v3];
  uint64_t v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)unint64_t v10 = v12;
  uint64_t v13 = v10 + 8;
  int64x2_t v14 = (char *)*a1;
  int v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    goto LABEL_25;
  }
  unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
  if (v16 > 0x77
    && (&v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v10 || &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v15))
  {
    uint64_t v17 = (v16 >> 3) + 1;
    v10 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    char v18 = v15 - 32;
    long long v19 = &v9[8 * v3 - 16];
    uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v22 = *(_OWORD *)v18;
      long long v21 = *((_OWORD *)v18 + 1);
      *(_OWORD *)char v18 = 0uLL;
      *((_OWORD *)v18 + 1) = 0uLL;
      v18 -= 32;
      *((_OWORD *)v19 - 1) = v22;
      *(_OWORD *)long long v19 = v21;
      v19 -= 32;
      v20 -= 4;
    }
    while (v20);
    if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_20;
    }
    v15 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
  }
  do
  {
    uint64_t v23 = *((void *)v15 - 1);
    v15 -= 8;
    *(void *)int v15 = 0;
    *((void *)v10 - 1) = v23;
    v10 -= 8;
  }
  while (v15 != v14);
LABEL_20:
  int v15 = (char *)*a1;
  uint64_t v24 = (char *)a1[1];
  *a1 = v10;
  a1[1] = v13;
  a1[2] = v11;
  while (v24 != v15)
  {
    uint64_t v26 = *((void *)v24 - 1);
    v24 -= 8;
    uint64_t v25 = v26;
    *(void *)uint64_t v24 = 0;
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    }
  }
LABEL_25:
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

uint64_t sub_19E415218(uint64_t a1, const __CFString *a2, int *a3)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 232);
  if (!*(unsigned char *)(v4 + 192)) {
    return 0;
  }
  if (*(unsigned char *)(v4 + 356)) {
    sub_19E4BB22C(__p, *(void *)(a1 + 184), *(void *)(a1 + 192));
  }
  else {
    memset(__p, 0, sizeof(__p));
  }
  uint64_t v7 = sub_19E4BA2A4(a2, a3, *(void *)(a1 + 48), (uint64_t)__p, *(const void **)(a1 + 176), 0);
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_19E4152B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E4152D0(void *a1, const __CFString *a2)
{
  uint64_t v2 = a1[29];
  if (*(unsigned char *)(v2 + 192) && *(unsigned char *)(v2 + 359))
  {
    uint64_t v5 = (const __CFLocale ***)(a1 + 39);
    if (!a1[39]) {
      operator new();
    }
    if (!a1[40]) {
      operator new();
    }
    unsigned int v6 = sub_19E3FE9C0(a1, a2, 0);
    unsigned int v12 = v6;
    uint64_t v7 = a1[6];
    if (*(_DWORD *)(v7 + 328) <= v6 && *(_DWORD *)(v7 + 332) >= v6)
    {
      uint64_t v8 = a1[34];
      if (v8)
      {
        float v13 = 0.0;
        uint64_t v9 = *(void *)(v8 + 24);
        if (*(unsigned char *)(v9 + 401)) {
          uint64_t v10 = 2;
        }
        else {
          uint64_t v10 = 1;
        }
        (*(void (**)(void, unsigned int *, uint64_t, uint64_t, uint64_t, float *, void))(**(void **)(v8 + 8) + 104))(*(void *)(v8 + 8), &v12, 1, v9 + 88, v10, &v13, 0);
        if (v13 == 0.0) {
          uint64_t v11 = v5;
        }
        else {
          uint64_t v11 = (const __CFLocale ***)(a1 + 40);
        }
        sub_19E437390(*v11, a2);
      }
    }
  }
}

void sub_19E4154B0(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10E0C40F5622EBCLL);
  _Unwind_Resume(a1);
}

void sub_19E4154DC(void *a1, CFStringRef theString)
{
  uint64_t v2 = a1[23];
  uint64_t v3 = a1[24];
  if (v2 != v3)
  {
    int v6 = 0;
    do
    {
LABEL_4:
      uint64_t v7 = *(void **)(*(void *)v2 + 8);
      uint64_t v8 = *(void **)(*(void *)v2 + 16);
      if (v7 != v8)
      {
        while (1)
        {
          int v6 = (*(uint64_t (**)(void, CFStringRef, void))(*(void *)*v7 + 16))(*v7, theString, 0);
          if (v6) {
            break;
          }
          if (++v7 == v8)
          {
            int v6 = 0;
            v2 += 16;
            if (v2 != v3) {
              goto LABEL_4;
            }
            return;
          }
        }
      }
      v2 += 16;
    }
    while (v2 != v3);
    if (v6 && *(unsigned char *)(a1[29] + 359))
    {
      if (!a1[41]) {
        operator new();
      }
      uint64_t v9 = (const __CFLocale **)a1[41];
      sub_19E437390(v9, theString);
    }
  }
}

void sub_19E415648(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10E0C40F5622EBCLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E41566C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, void *a8)
{
  uint64_t v8 = a3;
  if (a3)
  {
    if (!a7)
    {
      long long v19 = (void *)a8[10];
      uint64_t v20 = (void *)a8[11];
      if (v19 != v20)
      {
        while (((*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)*v19 + 16))(*v19, a2, v8, a4, a5, a6) & 1) == 0)
        {
          if (++v19 == v20) {
            goto LABEL_6;
          }
        }
        return 1;
      }
    }
    int64x2_t v14 = (void *)a8[7];
    int v15 = (void *)a8[8];
    if (v14 != v15)
    {
      while (((*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)*v14 + 16))(*v14, a2, v8, a4, a5, a6) & 1) == 0)
      {
        if (++v14 == v15) {
          goto LABEL_6;
        }
      }
      return 1;
    }
LABEL_6:
    if (*(unsigned char *)(*(void *)(a1 + 232) + 192))
    {
      uint64_t v16 = *(void *)(a1 + 48);
      uint64_t v17 = *(void *)(v16 + 560);
      char v18 = *(std::__shared_weak_count **)(v16 + 568);
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v8 = (*(uint64_t (**)(uint64_t, void))(*(void *)v17 + 224))(v17, *(unsigned int *)(a2 + 4 * v8 - 4));
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    else
    {
      return 0;
    }
  }
  return v8;
}

void sub_19E415830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E415844(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(*(void *)(a1 + 232) + 192)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(v4 + 560);
  int v6 = *(std::__shared_weak_count **)(v4 + 568);
  if (!v6
    || (atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed),
        atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    if (v5) {
      goto LABEL_5;
    }
    return 0;
  }
  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  if (!v5) {
    return 0;
  }
LABEL_5:
  if (*(unsigned char *)(*(void *)(a1 + 232) + 192))
  {
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v8 = *(void *)(v7 + 560);
    uint64_t v9 = *(std::__shared_weak_count **)(v7 + 568);
    uint64_t v16 = v9;
    if (!v9
      || (atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed),
          *(unsigned char *)(*(void *)(a1 + 232) + 192)))
    {
      uint64_t v10 = *(void *)(a1 + 48);
      uint64_t v11 = *(void *)(v10 + 560);
      unsigned int v12 = *(std::__shared_weak_count **)(v10 + 568);
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v16 = 0;
  }
  unsigned int v12 = 0;
  uint64_t v11 = 0;
LABEL_14:
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v11 + 24))(v11, a2, 0);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 208))(v8, v14);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  return v13;
}

void sub_19E415A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_19E415A64(void *a1, int a2, double *a3, uint64_t a4, _DWORD *a5, unint64_t a6)
{
  unint64_t v6 = a6;
  if (!a6)
  {
    uint64_t v11 = 0;
    if (a2 == 2) {
      return;
    }
LABEL_9:
    if (!*(unsigned char *)(a1[29] + 192)) {
      return;
    }
    if (!a2
      && (uint64_t v15 = a1[33]) != 0
      && (char v23 = 10, strcpy((char *)__p, "selfSender"), sub_19E533DAC(v15, 0, 0, a4, v11, v6, __p), v23 < 0))
    {
      operator delete(__p[0]);
      uint64_t v16 = a1[34];
      if (v16)
      {
LABEL_14:
        char v23 = 10;
        strcpy((char *)__p, "selfSender");
        sub_19E533DAC(v16, a2, a3, a4, v11, v6, __p);
        if (v23 < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      uint64_t v16 = a1[34];
      if (v16) {
        goto LABEL_14;
      }
    }
    sub_19E3FDF08(a1, a4, (uint64_t)__p);
    unint64_t v17 = v23;
    char v18 = v23;
    if (v23 < 0) {
      unint64_t v17 = (unint64_t)__p[1];
    }
    if (v17)
    {
      uint64_t v19 = a1[6];
      uint64_t v20 = *(void *)(v19 + 560);
      long long v21 = *(std::__shared_weak_count **)(v19 + 568);
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, void **, uint64_t, float))(*(void *)v20 + 184))(v20, __p, a4, 1.0);
      if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
      char v18 = v23;
    }
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    return;
  }
  uint64_t v11 = a5;
  uint64_t v12 = a6;
  while (v12 * 4)
  {
    int v13 = a5[--v12];
    if (v13 == 1)
    {
      uint64_t v14 = (uint64_t)(4 * a6 - (v12 * 4 + 4)) >> 2;
      unint64_t v6 = v14 + 1;
      uint64_t v11 = &a5[a6 + ~v14];
      break;
    }
  }
  if (a2 != 2) {
    goto LABEL_9;
  }
}

void sub_19E415CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E415CD0(void *a1, int a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5 = a5;
  if (!a5)
  {
    uint64_t v8 = 0;
    if (a2 == 2) {
      return;
    }
    goto LABEL_9;
  }
  uint64_t v8 = a4;
  uint64_t v9 = 4 * a5;
  while (v9)
  {
    int v10 = *(_DWORD *)(a4 + v9 - 4);
    v9 -= 4;
    if (v10 == 1)
    {
      uint64_t v11 = (uint64_t)(4 * a5 - (v9 + 4)) >> 2;
      unint64_t v5 = v11 + 1;
      uint64_t v8 = a4 + 4 * a5 + 4 * ~v11;
      break;
    }
  }
  if (a2 != 2)
  {
LABEL_9:
    if (*(unsigned char *)(a1[29] + 192))
    {
      if (!a2)
      {
        uint64_t v12 = a1[33];
        if (v12) {
          sub_19E5340DC(v12, a3, v8, v5);
        }
      }
      uint64_t v13 = a1[34];
      if (v13) {
        sub_19E5340DC(v13, a3, v8, v5);
      }
      sub_19E3FDF08(a1, a3, (uint64_t)__p);
      unint64_t v14 = v20;
      unsigned __int8 v15 = v20;
      if ((v20 & 0x80u) != 0) {
        unint64_t v14 = (unint64_t)__p[1];
      }
      if (v14)
      {
        uint64_t v16 = a1[6];
        uint64_t v17 = *(void *)(v16 + 560);
        char v18 = *(std::__shared_weak_count **)(v16 + 568);
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, void **, uint64_t, float))(*(void *)v17 + 184))(v17, __p, a3, -1.0);
        if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
        unsigned __int8 v15 = v20;
      }
      if ((v15 & 0x80) != 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_19E415E70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_19E415E94(void *a1, uint64_t a2)
{
  sub_19E3FDF08(a1, a2, (uint64_t)__p);
  unint64_t v4 = v17;
  if ((v17 & 0x80u) != 0) {
    unint64_t v4 = (unint64_t)__p[1];
  }
  if (v4 && *(unsigned char *)(a1[29] + 192))
  {
    uint64_t v5 = a1[6];
    uint64_t v6 = *(void *)(v5 + 560);
    uint64_t v7 = *(std::__shared_weak_count **)(v5 + 568);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, void **, uint64_t, uint64_t))(*(void *)v6 + 192))(v6, __p, a2, 1);
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    uint64_t v8 = a1[29];
    uint64_t v9 = a1[6];
    uint64_t v10 = *(void *)(v9 + 560);
    uint64_t v11 = *(std::__shared_weak_count **)(v9 + 568);
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(unsigned char *)(v8 + 192)
      && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v10 + 200))(v10, a2) >= *(_DWORD *)(v8 + 392))
    {
      BOOL v12 = (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v10 + 208))(v10, a2) < *(_DWORD *)(v8 + 396);
      if (!v11) {
        goto LABEL_18;
      }
    }
    else
    {
      BOOL v12 = 0;
      if (!v11) {
        goto LABEL_18;
      }
    }
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
      if (!v12) {
        goto LABEL_25;
      }
      goto LABEL_19;
    }
LABEL_18:
    if (!v12) {
      goto LABEL_25;
    }
LABEL_19:
    uint64_t v13 = a1[6];
    uint64_t v14 = *(void *)(v13 + 560);
    unsigned __int8 v15 = *(std::__shared_weak_count **)(v13 + 568);
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 216))(v14, a2);
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
LABEL_25:
  if ((char)v17 < 0) {
    operator delete(__p[0]);
  }
}

void sub_19E416124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_19E416150(uint64_t *a1, const __CFString *a2, CFIndex a3, CFIndex a4)
{
  v19.location = a3;
  v19.length = a4;
  sub_19E4BB22C(&__p, a1[23], a1[24]);
  if (!a2)
  {
    BOOL v9 = 0;
    uint64_t v6 = (char *)__p;
    if (!__p) {
      return v9;
    }
    goto LABEL_26;
  }
  uint64_t v6 = (char *)__p;
  if (!a1[34] || (char v18 = v21, __p == v21))
  {
    BOOL v9 = 0;
    if (!__p) {
      return v9;
    }
LABEL_26:
    long long v21 = v6;
    operator delete(v6);
    return v9;
  }
  unsigned __int8 v17 = (char *)__p;
  uint64_t v7 = (char *)__p;
LABEL_13:
  uint64_t v10 = *(void *)v7;
  uint64_t v11 = *(__CFStringTokenizer **)(*(void *)v7 + 8);
  CFRange v12 = v19;
  if (v11) {
    CFStringTokenizerSetString(v11, a2, v12);
  }
  else {
    *(void *)(v10 + 8) = CFStringTokenizerCreate(0, a2, v12, 0, *(CFLocaleRef *)(v10 + 16));
  }
  unint64_t v13 = 0;
  while (CFStringTokenizerAdvanceToNextToken(*(CFStringTokenizerRef *)(v10 + 8)))
  {
    CFRange CurrentTokenRange = CFStringTokenizerGetCurrentTokenRange((CFStringTokenizerRef)*(void *)(v10 + 8));
    if (*(unsigned char *)(v10 + 36))
    {
      if (*(void *)v10)
      {
        uint64_t v23 = 0;
        uint64_t v24 = &v23;
        uint64_t v25 = 0x2000000000;
        char v26 = 1;
        v22[0] = MEMORY[0x1E4F143A8];
        v22[1] = 0x40000000;
        v22[2] = sub_19E429CC4;
        v22[3] = &unk_1E599F770;
        v22[4] = &v23;
        void v22[5] = v10;
        sub_19E3C2AB0(a2, CurrentTokenRange.location, CurrentTokenRange.length, (uint64_t)v22);
        int v15 = *((unsigned __int8 *)v24 + 24);
        _Block_object_dispose(&v23, 8);
        if (!v15)
        {
          BOOL v9 = 0;
LABEL_12:
          v7 += 8;
          if (v7 == v18) {
            goto LABEL_23;
          }
          goto LABEL_13;
        }
      }
    }
    ++v13;
  }
  BOOL v9 = *(_DWORD *)(v10 + 24) != 2 || v13 > 5;
  if (!v9) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v6 = v17;
  if (v17) {
    goto LABEL_26;
  }
  return v9;
}

void sub_19E416338(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_19E416368(uint64_t *a1, unsigned int *a2, unint64_t a3)
{
  sub_19E4BB22C(&__p, a1[23], a1[24]);
  if (!a1[34])
  {
    BOOL v14 = 0;
LABEL_23:
    if (!__p) {
      return v14;
    }
LABEL_24:
    operator delete(__p);
    return v14;
  }
  if (__p != v17)
  {
    float v6 = 1.0 / (float)a3;
    uint64_t v7 = (uint64_t *)__p;
    while (1)
    {
      if (a3)
      {
        unint64_t v8 = 0;
        unint64_t v9 = 0;
        uint64_t v10 = *v7;
        uint64_t v11 = 4 * a3;
        CFRange v12 = a2;
        do
        {
          unsigned int v13 = *v12;
          if (!*v12 || *(_DWORD *)(v10 + 28) <= v13 && v13 <= *(_DWORD *)(v10 + 32)) {
            ++v8;
          }
          if (v13 - 10 < 0x35) {
            ++v9;
          }
          ++v12;
          v11 -= 4;
        }
        while (v11);
        BOOL v14 = (float)(v6 * (float)v9) < 0.2 && (float)(v6 * (float)v8) < 0.15;
        if (v14) {
          goto LABEL_23;
        }
      }
      else
      {
        BOOL v14 = 0;
      }
      if (++v7 == v17) {
        goto LABEL_23;
      }
    }
  }
  BOOL v14 = 0;
  if (__p) {
    goto LABEL_24;
  }
  return v14;
}

void *sub_19E4164AC(void *result)
{
  if (*(unsigned char *)(result[29] + 192))
  {
    if (result[33])
    {
      uint64_t v1 = result[6];
      std::mutex::lock((std::mutex *)(v1 + 664));
      sub_19E4995D0(*(void *)(v1 + 24), 11, @"cache");
      sub_19E49981C(*(void *)(v1 + 24), @"cache");
      sub_19E3C2CE4();
    }
    if (result[35])
    {
      uint64_t v2 = result[6];
      std::mutex::lock((std::mutex *)(v2 + 664));
      sub_19E4995D0(*(void *)(v2 + 24), 39, @"recency");
      sub_19E49981C(*(void *)(v2 + 24), @"recency");
      sub_19E3C2CE4();
    }
  }
  return result;
}

void sub_19E4166A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long __p, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete((void *)__p);
  }
  if (a2 == 1)
  {
    char v18 = __cxa_begin_catch(a1);
    if (qword_1E9459FA8 != -1) {
      dispatch_once(&qword_1E9459FA8, &unk_1EF0B5D60);
    }
    CFRange v19 = qword_1E9459FA0;
    if (os_log_type_enabled((os_log_t)qword_1E9459FA0, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = (*(uint64_t (**)(void *))(*(void *)v18 + 16))(v18);
      LODWORD(__p) = 136315138;
      *(void *)((char *)&__p + 4) = v20;
      _os_log_error_impl(&dword_19E36B000, v19, OS_LOG_TYPE_ERROR, "recency flush failed: %s", (uint8_t *)&__p, 0xCu);
    }
    __cxa_end_catch();
    JUMPOUT(0x19E41666CLL);
  }
  std::mutex::unlock(v15);
  _Unwind_Resume(a1);
}

void sub_19E416894(void *a1)
{
  if (*(unsigned char *)(a1[29] + 192))
  {
    uint64_t v2 = a1[6];
    uint64_t v3 = *(void *)(v2 + 560);
    unint64_t v4 = *(std::__shared_weak_count **)(v2 + 568);
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t))(*(void *)v3 + 240))(v3);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      uint64_t v5 = a1[35];
      if (!v5) {
        return;
      }
    }
    else
    {
      uint64_t v5 = a1[35];
      if (!v5) {
        return;
      }
    }
    float v6 = *(void (**)(void))(**(void **)(v5 + 8) + 168);
    v6();
  }
}

void sub_19E4169A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_19E4169B8(uint64_t a1, char a2)
{
  if ((a2 & 0x10) != 0)
  {
LABEL_10:
    uint64_t v6 = *(void *)(a1 + 280);
    if (v6)
    {
      uint64_t v7 = *(void (**)(void))(**(void **)(v6 + 8) + 168);
      v7();
    }
    return;
  }
  if (!*(unsigned char *)(*(void *)(a1 + 232) + 192))
  {
    if ((a2 & 2) != 0) {
      return;
    }
    goto LABEL_10;
  }
  uint64_t v4 = *(void *)(a1 + 264);
  if (v4) {
    (*(void (**)(void))(**(void **)(v4 + 8) + 168))(*(void *)(v4 + 8));
  }
  if ((a2 & 2) == 0)
  {
    sub_19E42C57C(*(void *)(a1 + 48));
    uint64_t v5 = *(std::recursive_mutex **)(a1 + 464);
    if (v5)
    {
      std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 464));
      sub_19E42C57C(v5[2].__m_.__sig);
      std::recursive_mutex::unlock(v5);
    }
    goto LABEL_10;
  }
}

void sub_19E416AA8(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E416ABC(uint64_t a1)
{
  if (!*(unsigned char *)(*(void *)(a1 + 232) + 192)) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    sub_19E42CFDC(v2);
    uint64_t v3 = *(std::recursive_mutex **)(a1 + 464);
    if (v3)
    {
      std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 464));
      sub_19E42CFDC(v3[2].__m_.__sig);
      std::recursive_mutex::unlock(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = *(void *)(a1 + 264);
    if (v5) {
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 264);
    if (v5)
    {
LABEL_8:
      uint64_t v6 = *(void *)(a1 + 232);
      std::mutex::lock((std::mutex *)v6);
      unint64_t v8 = *(char **)(v6 + 64);
      uint64_t v7 = *(char **)(v6 + 72);
      if (v8 != v7)
      {
        while (*(void *)v8 != v5 + 120)
        {
          v8 += 8;
          if (v8 == v7)
          {
            unint64_t v8 = *(char **)(v6 + 72);
            break;
          }
        }
      }
      if (v8 != v7)
      {
        int64_t v9 = v7 - (v8 + 8);
        if (v7 != v8 + 8) {
          memmove(v8, v8 + 8, v7 - (v8 + 8));
        }
        *(void *)(v6 + 72) = &v8[v9];
      }
      std::mutex::unlock((std::mutex *)v6);
      uint64_t v10 = *(void *)(a1 + 264);
      *(void *)(a1 + 264) = 0;
      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      }
      goto LABEL_20;
    }
  }
  *(void *)(a1 + 264) = 0;
LABEL_20:
  uint64_t v11 = *(void *)(a1 + 272);
  *(void *)(a1 + 272) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *(void *)(a1 + 280);
  *(void *)(a1 + 280) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  unsigned int v13 = *(std::__shared_weak_count **)(a1 + 472);
  *(void *)(a1 + 464) = 0;
  *(void *)(a1 + 472) = 0;
  if (v13)
  {
    if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  *(unsigned char *)(*(void *)(a1 + 232) + 192) = 0;
}

void sub_19E416CCC(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E416CE0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_19E3FDF08(*(void **)(a1 + 32), a2, (uint64_t)__p);
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6) {
    goto LABEL_5;
  }
  uint64_t v7 = (void *)HIBYTE(v9);
  if (v9 < 0) {
    uint64_t v7 = __p[1];
  }
  if (!v7)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 24))(v6, a2);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
LABEL_5:
    *(_OWORD *)a3 = *(_OWORD *)__p;
    *(void *)(a3 + 16) = v9;
  }
}

void sub_19E416D94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E416DB0(void *a1, CFStringRef theString1, _DWORD *a3, uint64_t a4)
{
  uint64_t v5 = a1[29];
  if (*(unsigned char *)(v5 + 192))
  {
    if (!a1[35])
    {
      uint64_t v15 = a1[6];
      if (v15)
      {
        if (*(float *)(v5 + 324) > 0.0) {
          sub_19E42E0EC((uint64_t)__p, v15, (uint64_t)(a1 + 29));
        }
      }
    }
    if (theString1 && a4)
    {
      for (unint64_t i = 0; a4 != i; ++i)
      {
        uint64_t v10 = a1[35];
        if (v10)
        {
          int v11 = a3[i];
          sub_19E37774C(theString1, __p);
          sub_19E533DAC(v10, 2, 0, v11, a3, i, __p);
          if (v17 < 0) {
            operator delete(__p[0]);
          }
        }
        if (CFEqual(theString1, (CFStringRef)kLMAdaptationContextSelfSender)
          || !sub_19E413F50(a1, a3[i]))
        {
          continue;
        }
        uint64_t v12 = a1[6];
        uint64_t v13 = *(void *)(v12 + 560);
        BOOL v14 = *(std::__shared_weak_count **)(v12 + 568);
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_19E3FDF08(a1, a3[i], (uint64_t)__p);
        (*(void (**)(uint64_t, void **, void))(*(void *)v13 + 232))(v13, __p, a3[i]);
        if (v17 < 0)
        {
          operator delete(__p[0]);
          if (v14)
          {
LABEL_18:
            if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
          }
        }
        else if (v14)
        {
          goto LABEL_18;
        }
      }
    }
  }
}

void sub_19E416FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_19E3D73EC((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void sub_19E416FE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E417004(void *a1, uint64_t a2)
{
  uint64_t v4 = (char *)a1[3];
  uint64_t v5 = (char *)a1[4];
  uint64_t v6 = v5;
  uint64_t v7 = v4;
  if (v4 != v5)
  {
    while (*(void *)v7 != a2)
    {
      v7 += 8;
      if (v7 == v5)
      {
        uint64_t v7 = (char *)a1[4];
        break;
      }
    }
  }
  if (v7 == v5)
  {
    unint64_t v8 = a1[5];
    if ((unint64_t)v5 >= v8)
    {
      int64_t v10 = v5 - v4;
      uint64_t v11 = (v5 - v4) >> 3;
      unint64_t v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 61) {
        sub_19E37C7C4();
      }
      uint64_t v13 = v8 - (void)v4;
      if (v13 >> 2 > v12) {
        unint64_t v12 = v13 >> 2;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 61) {
          sub_19E37C2B8();
        }
        uint64_t v15 = operator new(8 * v14);
      }
      else
      {
        uint64_t v15 = 0;
      }
      uint64_t v16 = &v15[8 * v11];
      char v17 = &v15[8 * v14];
      *uint64_t v16 = a2;
      uint64_t v9 = v16 + 1;
      if (v4 != v5)
      {
        if ((unint64_t)(v10 - 8) < 0x58) {
          goto LABEL_37;
        }
        if ((unint64_t)(v4 - v15) < 0x20) {
          goto LABEL_37;
        }
        unint64_t v18 = ((unint64_t)(v10 - 8) >> 3) + 1;
        uint64_t v6 = &v5[-8 * (v18 & 0x3FFFFFFFFFFFFFFCLL)];
        CFRange v19 = &v15[8 * v11 - 16];
        uint64_t v20 = v5 - 16;
        uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v22 = *(_OWORD *)v20;
          *(v19 - 1) = *((_OWORD *)v20 - 1);
          _OWORD *v19 = v22;
          v19 -= 2;
          v20 -= 32;
          v21 -= 4;
        }
        while (v21);
        v16 -= v18 & 0x3FFFFFFFFFFFFFFCLL;
        if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_37:
          do
          {
            uint64_t v23 = *((void *)v6 - 1);
            v6 -= 8;
            *--uint64_t v16 = v23;
          }
          while (v6 != v4);
          uint64_t v4 = (char *)a1[3];
        }
      }
      a1[3] = v16;
      a1[4] = v9;
      a1[5] = v17;
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      *(void *)uint64_t v5 = a2;
      uint64_t v9 = v5 + 8;
    }
    a1[4] = v9;
    uint64_t v24 = a1[31];
    if (v24)
    {
      uint64_t v25 = *(void (**)(void))(**(void **)(*(void *)(v24 + 16) + 16) + 96);
      v25();
    }
  }
}

void sub_19E4171F0(void *a1, const void *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  switch(a3)
  {
    case 0uLL:
      operator new();
    case 1uLL:
    case 2uLL:
      uint64_t v5 = a1[36];
      if (v5) {
        goto LABEL_10;
      }
      uint64_t v6 = (std::__shared_weak_count *)a1[2];
      *(void *)buf = a1[1];
      if (v6)
      {
        if (std::__shared_weak_count::lock(v6)) {
          sub_19E413004();
        }
      }
      goto LABEL_20;
    case 3uLL:
    case 4uLL:
      uint64_t v5 = a1[37];
      if (!v5)
      {
        uint64_t v7 = (std::__shared_weak_count *)a1[2];
        *(void *)buf = a1[1];
        if (v7 && std::__shared_weak_count::lock(v7)) {
          sub_19E413004();
        }
        goto LABEL_20;
      }
LABEL_10:
      uint64_t v8 = *(void *)(v5 + 16);
      break;
    case 5uLL:
      uint64_t v9 = a1[38];
      if (!v9)
      {
        int64_t v10 = (std::__shared_weak_count *)a1[2];
        *(void *)buf = a1[1];
        if (v10 && std::__shared_weak_count::lock(v10)) {
          sub_19E413004();
        }
LABEL_20:
        sub_19E3FDEBC();
      }
      uint64_t v8 = *(void *)(v9 + 16);
      a3 = 5;
      break;
    default:
      if (qword_1EC009588 != -1) {
        dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
      }
      uint64_t v11 = qword_1EC009580;
      if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = v3;
        _os_log_error_impl(&dword_19E36B000, v11, OS_LOG_TYPE_ERROR, "Unknown external lexicon type: %ld", buf, 0xCu);
      }
      __assert_rtn("addLexicon", "LMCompositeLanguageModel.cpp", 2354, "false && \"Unknown external lexicon type\"");
  }
  sub_19E4A1CEC(v8, a2, a3);
}

void sub_19E41769C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_19E3D73EC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E4176B8(_Unwind_Exception *exception_object)
{
}

void sub_19E4176C4(_Unwind_Exception *a1)
{
  uint64_t v4 = (void *)v2[12];
  if (v4)
  {
    v2[13] = v4;
    operator delete(v4);
    uint64_t v5 = (void *)v2[9];
    if (!v5)
    {
LABEL_3:
      uint64_t v6 = (void *)v2[6];
      if (!v6) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v5 = (void *)v2[9];
    if (!v5) {
      goto LABEL_3;
    }
  }
  v2[10] = v5;
  operator delete(v5);
  uint64_t v6 = (void *)v2[6];
  if (!v6)
  {
LABEL_4:
    uint64_t v7 = (void **)*v1;
    if (!*v1) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }
LABEL_9:
  v2[7] = v6;
  operator delete(v6);
  uint64_t v7 = (void **)*v1;
  if (!*v1)
  {
LABEL_5:
    uint64_t v8 = (const void *)v2[2];
    if (!v8) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_10:
  uint64_t v9 = (void **)v2[4];
  int64_t v10 = v7;
  if (v9 != v7)
  {
    do
    {
      if (*((char *)v9 - 1) < 0) {
        operator delete(*(v9 - 3));
      }
      v9 -= 3;
    }
    while (v9 != v7);
    int64_t v10 = *v1;
  }
  v2[4] = v7;
  operator delete(v10);
  uint64_t v8 = (const void *)v2[2];
  if (!v8)
  {
LABEL_18:
    v2[2] = 0;
    uint64_t v11 = (const void *)v2[1];
    if (v11) {
      CFRelease(v11);
    }
    v2[1] = 0;
    MEMORY[0x19F3BDCF0](v2, 0x10F1C40EEDAF61BLL);
    _Unwind_Resume(a1);
  }
LABEL_17:
  CFRelease(v8);
  goto LABEL_18;
}

void sub_19E4177BC(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_19E37B770(exception_object);
}

void sub_19E4177F0(void *a1, unint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a2 - 1 < 2)
  {
    uint64_t v2 = a1[36];
    if (!v2) {
      return;
    }
    goto LABEL_10;
  }
  if (a2 - 3 < 2)
  {
    uint64_t v2 = a1[37];
    if (!v2) {
      return;
    }
    goto LABEL_10;
  }
  if (a2 != 5)
  {
    unint64_t v5 = a2;
    if (qword_1EC009588 != -1) {
      dispatch_once(&qword_1EC009588, &unk_1EF0BEB50);
    }
    uint64_t v4 = qword_1EC009580;
    if (os_log_type_enabled((os_log_t)qword_1EC009580, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      unint64_t v7 = v5;
      _os_log_error_impl(&dword_19E36B000, v4, OS_LOG_TYPE_ERROR, "Unknown external lexicon type: %ld", buf, 0xCu);
    }
    __assert_rtn("removeLexicon", "LMCompositeLanguageModel.cpp", 2377, "false && \"Unknown external lexicon type\"");
  }
  uint64_t v2 = a1[38];
  if (v2)
  {
    a2 = 5;
LABEL_10:
    unint64_t v3 = (uint64_t *)(*(void *)(v2 + 16) + 8);
    sub_19E4D07A0(v3, a2);
  }
}

void sub_19E417960(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[16];
  uint64_t v3 = a1[17];
  if (v2 != v3)
  {
    while (munlock(*(const void **)(*(void *)v2 + 112), *(void *)(*(void *)v2 + 120)))
    {
      uint64_t v4 = *__error();
      unint64_t v5 = std::generic_category();
      *(void *)&v17.__val_ = v4;
      v17.__cat_ = v5;
      if (!v4) {
        goto LABEL_8;
      }
LABEL_3:
      v2 += 16;
      if (v2 == v3) {
        goto LABEL_15;
      }
    }
    uint64_t v6 = std::system_category();
    *(void *)&v17.__val_ = 0;
    v17.__cat_ = v6;
LABEL_8:
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    unint64_t v7 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_DEFAULT))
    {
      std::error_code::message(&v16, &v17);
      uint64_t v8 = &v16;
      if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v8 = (std::string *)v16.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 136315394;
      CFRange v19 = "munlock";
      __int16 v20 = 2080;
      uint64_t v21 = v8;
      _os_log_impl(&dword_19E36B000, v7, OS_LOG_TYPE_DEFAULT, "%s: munlock() failed: %s", buf, 0x16u);
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v16.__r_.__value_.__l.__data_);
      }
    }
    goto LABEL_3;
  }
LABEL_15:
  uint64_t v9 = a1[23];
  uint64_t v10 = a1[24];
  while (v9 != v10)
  {
    uint64_t v11 = *(uint64_t **)(*(void *)v9 + 8);
    unint64_t v12 = *(uint64_t **)(*(void *)v9 + 16);
    while (v11 != v12)
    {
      uint64_t v13 = *v11++;
      (*(void (**)(uint64_t))(*(void *)v13 + 80))(v13);
    }
    v9 += 16;
  }
  uint64_t v14 = a1[31];
  if (v14)
  {
    uint64_t v15 = *(void (**)(void))(**(void **)(*(void *)(v14 + 16) + 16) + 88);
    v15();
  }
}

void sub_19E417BC0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_19E37B770(a1);
}

void sub_19E417BCC()
{
}

void sub_19E417BF8()
{
}

void sub_19E417C24()
{
}

void sub_19E417C50()
{
}

void sub_19E417C7C()
{
}

void sub_19E417CAC()
{
}

uint64_t sub_19E417CD8()
{
  return 0;
}

void sub_19E417CE0()
{
}

void sub_19E417D0C()
{
}

void sub_19E417D38()
{
}

void sub_19E417D64()
{
}

void sub_19E417D90()
{
}

void sub_19E417DBC()
{
}

void sub_19E417DE8()
{
}

void sub_19E417E14()
{
}

void sub_19E417E40()
{
}

uint64_t sub_19E417E6C(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  uint64_t v5 = *(void *)(v2 + 80);
  uint64_t v3 = v2 + 80;
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v6 = v3;
    do
    {
      unsigned int v7 = *(_DWORD *)(v4 + 28);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t *)v4;
      }
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != v3 && *(_DWORD *)(v6 + 28) <= a2)
    {
      uint64_t v10 = *(unsigned __int8 *)(v6 + 32);
      if (v10) {
        return v10;
      }
    }
  }
  uint64_t v12 = *(void *)(a1 + 144);
  uint64_t v15 = *(void *)(v12 + 104);
  uint64_t v13 = v12 + 104;
  uint64_t v14 = v15;
  if (!v15) {
    return 0;
  }
  uint64_t v16 = v13;
  do
  {
    unsigned int v17 = *(_DWORD *)(v14 + 28);
    BOOL v18 = v17 >= a2;
    if (v17 >= a2) {
      CFRange v19 = (uint64_t *)v14;
    }
    else {
      CFRange v19 = (uint64_t *)(v14 + 8);
    }
    if (v18) {
      uint64_t v16 = v14;
    }
    uint64_t v14 = *v19;
  }
  while (*v19);
  if (v16 != v13 && *(_DWORD *)(v16 + 28) <= a2) {
    return *(unsigned __int8 *)(v16 + 32);
  }
  else {
    return 0;
  }
}

void sub_19E417F10()
{
}

void sub_19E417F3C()
{
}

void sub_19E417F68()
{
}

void sub_19E417F94()
{
}

off_t sub_19E417FC0(uint64_t a1)
{
  uint64_t v2 = (const char *)(a1 + 16);
  if (*(char *)(a1 + 39) < 0) {
    uint64_t v2 = *(const char **)v2;
  }
  if (stat(v2, &v4) >= 0) {
    return 0;
  }
  else {
    return v4.st_size;
  }
}

uint64_t sub_19E418004(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 32))();
}

uint64_t sub_19E41802C(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 16))(*(void *)(a1 + 136));
  uint64_t v5 = *(void *)(a1 + 144);
  char v11 = 0;
  uint64_t v6 = *(void **)(v5 + 24);
  unsigned int v7 = (void *)(v5 + 32);
  if (v6 != (void *)(v5 + 32))
  {
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void, char *, double))(a2 + 16))(a2, *((unsigned int *)v6 + 8), &v11, 1.0);
      if (v11) {
        break;
      }
      BOOL v8 = (void *)v6[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          BOOL v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v6[2];
          BOOL v10 = *v9 == (void)v6;
          uint64_t v6 = v9;
        }
        while (!v10);
      }
      uint64_t v6 = v9;
    }
    while (v9 != v7);
  }
  return result;
}

uint64_t sub_19E418104()
{
  return 0;
}

void sub_19E41810C()
{
}

void sub_19E418138()
{
}

void sub_19E418164()
{
}

void sub_19E4182C8(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10E1C40AD94C641);
  _Unwind_Resume(a1);
}

void sub_19E4182EC(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if ((a2 & 0x80000000) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 120);
    if (v6)
    {
      uint64_t v7 = a1 + 120;
      do
      {
        unsigned int v8 = *(_DWORD *)(v6 + 32);
        BOOL v9 = v8 >= a2;
        if (v8 >= a2) {
          BOOL v10 = (uint64_t *)v6;
        }
        else {
          BOOL v10 = (uint64_t *)(v6 + 8);
        }
        if (v9) {
          uint64_t v7 = v6;
        }
        uint64_t v6 = *v10;
      }
      while (*v10);
      if (v7 != a1 + 120 && *(_DWORD *)(v7 + 32) <= a2)
      {
        if (*(char *)(v7 + 63) < 0)
        {
          int v32 = *(void **)(v7 + 40);
          unint64_t v33 = *(void *)(v7 + 48);
          sub_19E39369C((unsigned char *)a3, v32, v33);
        }
        else
        {
          long long v11 = *(_OWORD *)(v7 + 40);
          *(void *)(a3 + 16) = *(void *)(v7 + 56);
          *(_OWORD *)a3 = v11;
        }
        return;
      }
    }
  }
  if (*(_DWORD *)(a1 + 72) > a2 || *(_DWORD *)(a1 + 76) < a2)
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    return;
  }
  uint64_t v12 = *(void *)(a1 + 136);
  uint64_t v15 = *(void *)(v12 + 24);
  uint64_t v13 = v12 + 24;
  uint64_t v14 = v15;
  if (!v15) {
    goto LABEL_29;
  }
  uint64_t v16 = v13;
  do
  {
    unsigned int v17 = *(_DWORD *)(v14 + 28);
    BOOL v18 = v17 >= a2;
    if (v17 >= a2) {
      CFRange v19 = (uint64_t *)v14;
    }
    else {
      CFRange v19 = (uint64_t *)(v14 + 8);
    }
    if (v18) {
      uint64_t v16 = v14;
    }
    uint64_t v14 = *v19;
  }
  while (*v19);
  if (v16 == v13 || *(_DWORD *)(v16 + 28) > a2)
  {
LABEL_29:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
LABEL_30:
    uint64_t v20 = *(void *)(a1 + 144);
    uint64_t v23 = *(void *)(v20 + 32);
    uint64_t v21 = v20 + 32;
    uint64_t v22 = v23;
    if (!v23) {
      goto LABEL_41;
    }
    uint64_t v24 = v21;
    do
    {
      unsigned int v25 = *(_DWORD *)(v22 + 32);
      BOOL v26 = v25 >= a2;
      if (v25 >= a2) {
        int v27 = (uint64_t *)v22;
      }
      else {
        int v27 = (uint64_t *)(v22 + 8);
      }
      if (v26) {
        uint64_t v24 = v22;
      }
      uint64_t v22 = *v27;
    }
    while (*v27);
    if (v24 != v21 && *(_DWORD *)(v24 + 32) <= a2)
    {
      if (*(char *)(v24 + 63) < 0)
      {
        sub_19E39369C(&v37, *(void **)(v24 + 40), *(void *)(v24 + 48));
      }
      else
      {
        long long v37 = *(_OWORD *)(v24 + 40);
        uint64_t v38 = *(void *)(v24 + 56);
      }
    }
    else
    {
LABEL_41:
      long long v37 = 0uLL;
      uint64_t v38 = 0;
    }
    if (*(char *)(a3 + 23) < 0) {
      operator delete(*(void **)a3);
    }
    *(_OWORD *)a3 = v37;
    *(void *)(a3 + 16) = v38;
    return;
  }
  uint64_t v28 = (const char *)(*(void *)(*(void *)(a1 + 136) + 40) + *(unsigned int *)(v16 + 32));
  size_t v29 = strlen(v28);
  if (v29 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  size_t v30 = v29;
  if (v29 >= 0x17)
  {
    uint64_t v34 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v29 | 7) != 0x17) {
      uint64_t v34 = v29 | 7;
    }
    uint64_t v35 = v34 + 1;
    unsigned int v31 = operator new(v34 + 1);
    *(void *)(a3 + 8) = v30;
    *(void *)(a3 + 16) = v35 | 0x8000000000000000;
    *(void *)a3 = v31;
    goto LABEL_58;
  }
  *(unsigned char *)(a3 + 23) = v29;
  unsigned int v31 = (void *)a3;
  if (v29) {
LABEL_58:
  }
    memmove(v31, v28, v30);
  *((unsigned char *)v31 + v30) = 0;
  uint64_t v36 = *(unsigned __int8 *)(a3 + 23);
  if ((v36 & 0x80u) != 0) {
    uint64_t v36 = *(void *)(a3 + 8);
  }
  if (!v36) {
    goto LABEL_30;
  }
}

void sub_19E418570(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E41858C(uint64_t *a1, unsigned __int8 *a2, double *a3)
{
  stat v4 = (const void **)a2;
  signed __int8 v6 = a2[23];
  if (v6 >= 0) {
    unsigned int v7 = a2[23];
  }
  else {
    unsigned int v7 = *((_DWORD *)a2 + 2);
  }
  if (!v7) {
    goto LABEL_11;
  }
  uint64_t v8 = *(void *)(a1[17] + 8);
  if (v6 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  v12[0] = xmmword_19E57CC38;
  v12[1] = unk_19E57CC48;
  sub_19E5006BC(v8, a2, v7, 1, (uint64_t)v12);
  uint64_t result = DWORD1(v12[0]);
  if ((DWORD1(v12[0]) & 0x80000000) != 0) {
    goto LABEL_11;
  }
  if (a3) {
    *a3 = *((float *)v12 + 2);
  }
  if (!result)
  {
LABEL_11:
    BOOL v10 = sub_19E374C3C((uint64_t)(a1 + 11), v4);
    if (a1 + 12 == v10 && (v11 = a1[18], BOOL v10 = sub_19E374C3C(v11, v4), (uint64_t *)(v11 + 8) == v10)) {
      return 0;
    }
    else {
      return *((unsigned int *)v10 + 14);
    }
  }
  return result;
}

uint64_t sub_19E418668(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  sub_19E37774C(a2, __p);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void **, uint64_t))(*(void *)a1 + 24))(a1, __p, a3);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return v5;
}

void sub_19E4186E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E418704(uint64_t a1)
{
  sub_19E41873C(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E41873C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BAEF0;
  uint64_t v2 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v2)
  {
    sub_19E418864(*(void **)(v2 + 104));
    sub_19E4188B0(v2 + 48);
    sub_19E418A38(*(char **)(v2 + 32));
    sub_19E3CD3E0(*(char **)(v2 + 8));
    MEMORY[0x19F3BDCF0](v2, 0x10A0C404AAAD15CLL);
  }
  uint64_t v3 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_19E418A38(*(char **)(a1 + 120));
  sub_19E3CD3E0(*(char **)(a1 + 96));
  stat v4 = *(void **)(a1 + 80);
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)*v4;
      operator delete(v4);
      stat v4 = v5;
    }
    while (v5);
  }
  *(void *)(a1 + 80) = 0;
  if (*(char *)(a1 + 63) < 0)
  {
    operator delete(*(void **)(a1 + 40));
    if ((*(char *)(a1 + 39) & 0x80000000) == 0)
    {
LABEL_9:
      signed __int8 v6 = *(const void **)(a1 + 8);
      if (!v6) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
  }
  else if ((*(char *)(a1 + 39) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(*(void **)(a1 + 16));
  signed __int8 v6 = *(const void **)(a1 + 8);
  if (v6) {
LABEL_13:
  }
    CFRelease(v6);
LABEL_14:
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_19E418864(void *a1)
{
  if (a1)
  {
    sub_19E418864(*a1);
    sub_19E418864(a1[1]);
    operator delete(a1);
  }
}

uint64_t sub_19E4188B0(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    stat v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    stat v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    signed __int8 v6 = &v2[v5 / 0x66];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 40 * (v5 % 0x66);
    unint64_t v9 = (unint64_t)v2[(*(void *)(a1 + 40) + v5) / 0x66] + 40 * ((*(void *)(a1 + 40) + v5) % 0x66);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 23) < 0)
        {
          operator delete(*(void **)v8);
          unint64_t v7 = (unint64_t)*v6;
        }
        v8 += 40;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }
      while (v8 != v9);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 51;
    goto LABEL_17;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 102;
LABEL_17:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E418A38(char *a1)
{
  if (a1)
  {
    sub_19E418A38(*(void *)a1);
    sub_19E418A38(*((void *)a1 + 1));
    if (a1[63] < 0) {
      operator delete(*((void **)a1 + 5));
    }
    operator delete(a1);
  }
}

int32x2_t *sub_19E418A98(int32x2_t *a1, CFTypeRef cf, long long *a3, long long *a4, unsigned int *a5)
{
  *a1 = (int32x2_t)&unk_1EF0BAEF0;
  a1[1] = 0;
  size_t v132 = (CFTypeRef *)&a1[1];
  if (*((char *)a3 + 23) < 0)
  {
    sub_19E39369C(&a1[2], *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    a1[4] = (int32x2_t)a3[1];
    *(_OWORD *)a1[2].i8 = v9;
  }
  if (*((char *)a4 + 23) < 0)
  {
    sub_19E39369C(&a1[5], *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v10 = *a4;
    a1[7] = (int32x2_t)a4[1];
    *(_OWORD *)a1[5].i8 = v10;
  }
  a1[17] = 0;
  a1[12] = 0;
  a1[10] = 0;
  a1[11] = (int32x2_t)&a1[12];
  a1[16] = 0;
  a1[15] = 0;
  a1[13] = 0;
  a1[14] = (int32x2_t)&a1[15];
  a1[18] = 0;
  size_t v133 = a1 + 18;
  int v134 = a1 + 17;
  if ((CFTypeRef)a1[1] != cf)
  {
    CFRetain(cf);
    if (*v132) {
      CFRelease(*v132);
    }
    CFTypeRef *v132 = cf;
  }
  int32x2_t v11 = *(int32x2_t *)a5;
  a1[8] = *(int32x2_t *)a5;
  a1[9].i32[0] = v11.i32[1];
  a1[9].i32[1] = v11.i32[0];
  vcvtpd_u64_f64(log2((double)v11.u32[1]));
  CFDictionaryRef v12 = (const __CFDictionary *)sub_19E3C30D0((const __CFURL *)cf, 0);
  if (!v12) {
    CFDictionaryRef v12 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFDictionaryRef theDict = v12;
  if (CFDictionaryGetCount(v12))
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"Version");
    CFNumberRef v14 = Value;
    LODWORD(valuePtr) = 0;
    if (Value && (CFTypeID v15 = CFGetTypeID(Value), v15 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v14, kCFNumberIntType, &valuePtr);
      uint64_t v16 = valuePtr;
      if (valuePtr == 1)
      {
        CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"dynamicRangeMin");
        CFNumberRef v18 = v17;
        LODWORD(valuePtr) = 0;
        if (v17 && (CFTypeID v19 = CFGetTypeID(v17), v19 == CFNumberGetTypeID()))
        {
          CFNumberGetValue(v18, kCFNumberIntType, &valuePtr);
          __int32 v20 = valuePtr;
        }
        else
        {
          __int32 v20 = 0;
        }
        CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"dynamicRangeMax");
        CFNumberRef v22 = v21;
        LODWORD(valuePtr) = 0;
        if (v21 && (CFTypeID v23 = CFGetTypeID(v21), v23 == CFNumberGetTypeID()))
        {
          CFNumberGetValue(v22, kCFNumberIntType, &valuePtr);
          __int32 v24 = valuePtr;
        }
        else
        {
          __int32 v24 = 0;
        }
        a1[9].i32[0] = v20;
        a1[9].i32[1] = v24;
        CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"dynamicLimitsMin");
        CFNumberRef v26 = v25;
        LODWORD(valuePtr) = 0;
        if (v25 && (CFTypeID v27 = CFGetTypeID(v25), v27 == CFNumberGetTypeID()))
        {
          CFNumberGetValue(v26, kCFNumberIntType, &valuePtr);
          __int32 v28 = valuePtr;
        }
        else
        {
          __int32 v28 = 0;
        }
        CFNumberRef v29 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"dynamicLimitsMax");
        CFNumberRef v30 = v29;
        LODWORD(valuePtr) = 0;
        if (v29 && (CFTypeID v31 = CFGetTypeID(v29), v31 == CFNumberGetTypeID()))
        {
          CFNumberGetValue(v30, kCFNumberIntType, &valuePtr);
          unsigned int v32 = valuePtr;
        }
        else
        {
          unsigned int v32 = 0;
        }
        a1[8].i32[0] = v28;
        a1[8].i32[1] = v32;
        if (v28 != *a5 || v32 != a5[1])
        {
          exception = __cxa_allocate_exception(0x20uLL);
          sub_19E439798("dynamicids resource file is incompatible with the parameters the client has set (dynamicIDLimits [%d, %d], expected dynamicIDLimits [%d, %d])", (uint64_t)&v141, *a5, a5[1], a1[8].u32[0], a1[8].u32[1]);
          sub_19E3F5604(exception, (long long *)&v141.st_dev);
          __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
        }
        vcvtpd_u64_f64(log2((double)v32));
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    int v130 = __cxa_allocate_exception(0x20uLL);
    sub_19E439798("dynamicids resource file is incompatible (version %d, expected version %d)", (uint64_t)&v141, v16, 1);
    sub_19E3F5604(v130, (long long *)&v141.st_dev);
    __cxa_throw(v130, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
  }
LABEL_36:
  if (*((char *)a3 + 23) >= 0) {
    unint64_t v33 = (const char *)a3;
  }
  else {
    unint64_t v33 = *(const char **)a3;
  }
  int v34 = open_dprotected_np(v33, 0, 3, 0, 0);
  if ((v34 & 0x80000000) == 0)
  {
    fcntl(v34, 64, 3);
    operator new();
  }
  if (*((char *)a4 + 23) >= 0) {
    uint64_t v35 = (const char *)a4;
  }
  else {
    uint64_t v35 = *(const char **)a4;
  }
  int v36 = open_dprotected_np(v35, 0, 3, 0, 0);
  if ((v36 & 0x80000000) == 0)
  {
    fcntl(v36, 64, 3);
    operator new();
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (!*(void *)v134) {
    operator new();
  }
  if (!*(void *)v133) {
    operator new();
  }
  int32x2_t v37 = *v134;
  memset(&v141, 0, 24);
  uint64_t v38 = *(void **)(*(void *)&v37 + 16);
  BOOL v39 = (void *)(*(void *)&v37 + 24);
  if (v38 != (void *)(*(void *)&v37 + 24))
  {
    double v40 = 0;
    unint64_t v41 = 0;
    st_ino = 0;
    while (st_ino < v41)
    {
      *(_DWORD *)st_ino = *((_DWORD *)v38 + 7);
      st_ino += 4;
LABEL_74:
      v141.st_ino = (__darwin_ino64_t)st_ino;
      double v52 = (void *)v38[1];
      if (v52)
      {
        do
        {
          long long v53 = v52;
          double v52 = (void *)*v52;
        }
        while (v52);
      }
      else
      {
        do
        {
          long long v53 = (void *)v38[2];
          BOOL v54 = *v53 == (void)v38;
          uint64_t v38 = v53;
        }
        while (!v54);
      }
      uint64_t v38 = v53;
      if (v53 == v39) {
        goto LABEL_91;
      }
    }
    uint64_t v43 = (st_ino - v40) >> 2;
    unint64_t v44 = v43 + 1;
    if ((unint64_t)(v43 + 1) >> 62) {
      sub_19E37C7C4();
    }
    if ((v41 - v40) >> 1 > v44) {
      unint64_t v44 = (v41 - v40) >> 1;
    }
    if ((unint64_t)(v41 - v40) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v45 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v45 = v44;
    }
    if (v45)
    {
      if (v45 >> 62) {
        sub_19E37C2B8();
      }
      float v46 = operator new(4 * v45);
    }
    else
    {
      float v46 = 0;
    }
    float v47 = &v46[4 * v43];
    *float v47 = *((_DWORD *)v38 + 7);
    CFDictionaryRef v48 = (char *)(v47 + 1);
    if (st_ino != v40)
    {
      unint64_t v49 = st_ino - 4 - v40;
      if (v49 >= 0xBC)
      {
        if (&v46[st_ino - v40 - 4 - (v49 & 0xFFFFFFFFFFFFFFFCLL)] > &v46[st_ino - v40 - 4])
        {
          float v50 = st_ino;
        }
        else if (&st_ino[-(v49 & 0xFFFFFFFFFFFFFFFCLL) - 4] > st_ino - 4)
        {
          float v50 = st_ino;
        }
        else if ((unint64_t)(v40 - v46) >= 0x20)
        {
          uint64_t v55 = (v49 >> 2) + 1;
          float v50 = &st_ino[-4 * (v55 & 0x7FFFFFFFFFFFFFF8)];
          unint64_t v56 = &v46[4 * v43 - 16];
          CFTypeRef v57 = (long long *)(st_ino - 16);
          uint64_t v58 = v55 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v59 = *v57;
            *(v56 - 1) = *(v57 - 1);
            *unint64_t v56 = v59;
            v56 -= 2;
            v57 -= 2;
            v58 -= 8;
          }
          while (v58);
          v47 -= v55 & 0x7FFFFFFFFFFFFFF8;
          if (v55 == (v55 & 0x7FFFFFFFFFFFFFF8)) {
            goto LABEL_71;
          }
        }
        else
        {
          float v50 = st_ino;
        }
      }
      else
      {
        float v50 = st_ino;
      }
      do
      {
        int v51 = *((_DWORD *)v50 - 1);
        v50 -= 4;
        *--float v47 = v51;
      }
      while (v50 != v40);
    }
LABEL_71:
    unint64_t v41 = &v46[4 * v45];
    *(void *)&v141.st_dev = v47;
    *(void *)&v141.st_uid = v41;
    if (v40) {
      operator delete(v40);
    }
    double v40 = v47;
    st_ino = v48;
    goto LABEL_74;
  }
  st_ino = 0;
LABEL_91:
  int32x2_t v60 = *v133;
  int v139 = 0;
  size_t __sz = 0;
  size_t v138 = 0;
  int v61 = *(void **)(*(void *)&v60 + 24);
  CFTypeID v62 = (void *)(*(void *)&v60 + 32);
  if (v61 != (void *)(*(void *)&v60 + 32))
  {
    size_t v63 = 0;
    char v64 = 0;
    double v65 = 0;
    int v66 = 0;
    while (1)
    {
      if ((unint64_t)v64 < v63)
      {
        *(_DWORD *)char v64 = *((_DWORD *)v61 + 8);
        v64 += 4;
        char v67 = (void *)v61[1];
        if (v67) {
          goto LABEL_114;
        }
        goto LABEL_116;
      }
      uint64_t v68 = (v64 - v66) >> 2;
      unint64_t v69 = v68 + 1;
      if ((unint64_t)(v68 + 1) >> 62)
      {
        size_t v138 = v65;
        int v139 = v64;
        size_t __sz = v63;
        sub_19E37C7C4();
      }
      if ((uint64_t)(v63 - (void)v66) >> 1 > v69) {
        unint64_t v69 = (uint64_t)(v63 - (void)v66) >> 1;
      }
      if (v63 - (unint64_t)v66 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v70 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v70 = v69;
      }
      if (v70)
      {
        if (v70 >> 62)
        {
          size_t v138 = v65;
          size_t __sz = v63;
          sub_19E37C2B8();
        }
        int v71 = operator new(4 * v70);
      }
      else
      {
        int v71 = 0;
      }
      double v65 = &v71[4 * v68];
      *(_DWORD *)double v65 = *((_DWORD *)v61 + 8);
      uint64_t v72 = v65 + 4;
      if (v64 != v66)
      {
        unint64_t v73 = v64 - 4 - v66;
        if (v73 < 0xBC)
        {
          long long v74 = v64;
          goto LABEL_110;
        }
        if (&v71[v64 - v66 - 4 - (v73 & 0xFFFFFFFFFFFFFFFCLL)] > &v71[v64 - v66 - 4])
        {
          long long v74 = v64;
          do
          {
LABEL_110:
            int v75 = *((_DWORD *)v74 - 1);
            v74 -= 4;
            *((_DWORD *)v65 - 1) = v75;
            v65 -= 4;
          }
          while (v74 != v66);
          goto LABEL_111;
        }
        if (&v64[-(v73 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v64 - 4)
        {
          long long v74 = v64;
          goto LABEL_110;
        }
        if ((unint64_t)(v66 - v71) < 0x20)
        {
          long long v74 = v64;
          goto LABEL_110;
        }
        uint64_t v77 = (v73 >> 2) + 1;
        long long v74 = &v64[-4 * (v77 & 0x7FFFFFFFFFFFFFF8)];
        uint64_t v78 = &v71[4 * v68 - 16];
        uint64_t v79 = v64 - 16;
        uint64_t v80 = v77 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v81 = *(_OWORD *)v79;
          *(v78 - 1) = *((_OWORD *)v79 - 1);
          *uint64_t v78 = v81;
          v78 -= 2;
          v79 -= 32;
          v80 -= 8;
        }
        while (v80);
        v65 -= 4 * (v77 & 0x7FFFFFFFFFFFFFF8);
        if (v77 != (v77 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_110;
        }
      }
LABEL_111:
      size_t v63 = (size_t)&v71[4 * v70];
      if (v66) {
        operator delete(v66);
      }
      int v66 = v65;
      char v64 = v72;
      char v67 = (void *)v61[1];
      if (v67)
      {
        do
        {
LABEL_114:
          double v76 = v67;
          char v67 = (void *)*v67;
        }
        while (v67);
        goto LABEL_93;
      }
      do
      {
LABEL_116:
        double v76 = (void *)v61[2];
        BOOL v54 = *v76 == (void)v61;
        int v61 = v76;
      }
      while (!v54);
LABEL_93:
      int v61 = v76;
      if (v76 == v62)
      {
        size_t v138 = v65;
        int v139 = v64;
        size_t __sz = v63;
        st_ino = (char *)v141.st_ino;
        goto LABEL_131;
      }
    }
  }
  char v64 = 0;
  double v65 = 0;
LABEL_131:
  sub_19E3EC2A8((char **)&v141, st_ino, v65, v64, (v64 - v65) >> 2);
  std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
  int v89 = *(unsigned __int32 **)&v141.st_dev;
  __darwin_ino64_t v88 = v141.st_ino;
  unsigned __int32 v90 = a1[9].u32[0];
  if (v141.st_ino == *(void *)&v141.st_dev)
  {
    int v89 = (unsigned __int32 *)v141.st_ino;
  }
  else
  {
    unsigned __int32 v91 = a1[9].u32[1];
    if (v90 > v91)
    {
      unsigned __int32 v90 = **(_DWORD **)&v141.st_dev;
      a1[9].i32[0] = **(_DWORD **)&v141.st_dev;
      unsigned __int32 v91 = *(_DWORD *)(v88 - 4);
      a1[9].i32[1] = v91;
    }
    if (v91 < *(_DWORD *)(v88 - 4))
    {
      if (qword_1EC009490 != -1) {
        dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
      }
      sub_19E4E4498((int *)qword_1EC009488, v82, "Inconsistency in dynamic word id ranges: %d, expected max (%d)", v83, v84, v85, v86, v87, *(_DWORD *)(v141.st_ino - 4));
      int v89 = *(unsigned __int32 **)&v141.st_dev;
      __darwin_ino64_t v88 = v141.st_ino;
      a1[9].i32[1] = *(_DWORD *)(v141.st_ino - 4);
      unsigned __int32 v90 = a1[9].u32[0];
    }
    if ((unsigned __int32 *)v88 != v89 && v90 > *v89)
    {
      if (qword_1EC009490 != -1) {
        dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
      }
      sub_19E4E4498((int *)qword_1EC009488, v82, "Inconsistency in dynamic word id ranges: %d, expected min (%d)", v83, v84, v85, v86, v87, **(_DWORD **)&v141.st_dev);
      int v89 = *(unsigned __int32 **)&v141.st_dev;
      unsigned __int32 v90 = **(_DWORD **)&v141.st_dev;
      a1[9].i32[0] = **(_DWORD **)&v141.st_dev;
    }
  }
  if (v90 < a1[8].i32[0] || (unsigned __int32 v92 = a1[9].u32[1], v92 > a1[8].i32[1]))
  {
    if (qword_1EC009490 != -1) {
      dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
    }
    sub_19E4E4498((int *)qword_1EC009488, v82, "Unexpected dynamic word id ranges: (dynamicIDRanges [%d, %d], dynamicIDLimits [%d, %d])", v83, v84, v85, v86, v87, a1[9].i32[0]);
    int32x2_t v93 = *v134;
    int v94 = *(unsigned char **)(*(void *)v134 + 40);
    *(void *)(*(void *)&v93 + 48) = v94;
    unint64_t v95 = *(void *)(*(void *)&v93 + 56);
    if ((unint64_t)v94 >= v95)
    {
      unint64_t v97 = v95 - (void)v94;
      uint64_t v98 = 2 * v97;
      if (2 * v97 <= 1) {
        uint64_t v98 = 1;
      }
      if (v97 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v99 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v99 = v98;
      }
      uint64_t v100 = operator new(v99);
      unsigned char *v100 = 0;
      char v96 = v100 + 1;
      *(void *)(*(void *)&v93 + 40) = v100;
      *(void *)(*(void *)&v93 + 48) = v100 + 1;
      *(void *)(*(void *)&v93 + 56) = &v100[v99];
      if (v94) {
        operator delete(v94);
      }
    }
    else
    {
      *int v94 = 0;
      char v96 = v94 + 1;
    }
    __int16 v101 = *(void **)(*(void *)&v93 + 24);
    *(void *)(*(void *)&v93 + 48) = v96;
    sub_19E418864(v101);
    *(void *)(*(void *)&v93 + 16) = *(void *)&v93 + 24;
    *(void *)(*(void *)&v93 + 24) = 0;
    *(void *)(*(void *)&v93 + 32) = 0;
    *(_DWORD *)(*(void *)&v93 + 64) = 0;
    uint64_t v102 = *(void *)(*(void *)&v93 + 8);
    if (v102)
    {
      int v103 = *(_DWORD *)(v102 + 2080) - 1;
      *(_DWORD *)(v102 + 2080) = v103;
      if (!v103)
      {
        uint64_t v104 = *(void **)(v102 + 2084);
        if (v104)
        {
          if (*(_DWORD *)(v102 + 2096)) {
            munmap(v104, *(void *)(v102 + 2072));
          }
        }
        else
        {
          sub_19E4FEBFC(v102);
        }
        free((void *)v102);
      }
    }
    int v114 = (char *)malloc_type_calloc(1uLL, 0x83CuLL, 0x105004056F6A631uLL);
    if (v114)
    {
      *((_OWORD *)v114 + 129) = 0u;
      *((_DWORD *)v114 + 520) = 1;
      *(void *)(v114 + 2084) = 0;
      *(void *)(v114 + 2092) = 64;
    }
    *(void *)(*(void *)&v93 + 8) = v114;
    int32x2_t v115 = *v133;
    uint64_t v116 = (char **)(*(void *)v133 + 32);
    sub_19E418A38(*v116);
    *(void *)(*(void *)&v115 + 24) = v116;
    *(void *)(*(void *)&v115 + 40) = 0;
    int *v116 = 0;
    sub_19E3CD3E0(*(char **)(*(void *)&v115 + 8));
    **(void **)&int32x2_t v115 = *(void *)&v115 + 8;
    *(void *)(*(void *)&v115 + 16) = 0;
    *(void *)(*(void *)&v115 + 8) = 0;
    int v117 = *(void ***)(*(void *)&v115 + 56);
    uint64_t v118 = *(void ***)(*(void *)&v115 + 64);
    if (v118 == v117)
    {
      uint64_t v119 = (void *)(*(void *)&v115 + 88);
      uint64_t v118 = *(void ***)(*(void *)&v115 + 56);
    }
    else
    {
      uint64_t v119 = (void *)(*(void *)&v115 + 88);
      unint64_t v120 = *(void *)(*(void *)&v115 + 80);
      unint64_t v121 = &v117[v120 / 0x66];
      unint64_t v122 = (unint64_t)*v121;
      unint64_t v123 = (unint64_t)*v121 + 40 * (v120 % 0x66);
      unint64_t v124 = (unint64_t)v117[(*(void *)(*(void *)&v115 + 88) + v120) / 0x66]
           + 40 * ((*(void *)(*(void *)&v115 + 88) + v120) % 0x66);
      if (v123 != v124)
      {
        do
        {
          if (*(char *)(v123 + 23) < 0)
          {
            operator delete(*(void **)v123);
            unint64_t v122 = (unint64_t)*v121;
          }
          v123 += 40;
          if (v123 - v122 == 4080)
          {
            unint64_t v125 = (unint64_t)v121[1];
            ++v121;
            unint64_t v122 = v125;
            unint64_t v123 = v125;
          }
        }
        while (v123 != v124);
        int v117 = *(void ***)(*(void *)&v115 + 56);
        uint64_t v118 = *(void ***)(*(void *)&v115 + 64);
      }
    }
    void *v119 = 0;
    unint64_t v126 = (char *)v118 - (char *)v117;
    if ((unint64_t)((char *)v118 - (char *)v117) >= 0x11)
    {
      do
      {
        operator delete(*v117);
        uint64_t v127 = *(void *)(*(void *)&v115 + 64);
        int v117 = (void **)(*(void *)(*(void *)&v115 + 56) + 8);
        *(void *)(*(void *)&v115 + 56) = v117;
        unint64_t v126 = v127 - (void)v117;
      }
      while (v126 > 0x10);
    }
    if (v126 >> 3 == 1)
    {
      uint64_t v128 = 51;
    }
    else
    {
      if (v126 >> 3 != 2)
      {
LABEL_194:
        a1[9] = vrev64_s32(a1[8]);
        goto LABEL_195;
      }
      uint64_t v128 = 102;
    }
    *(void *)(*(void *)&v115 + 80) = v128;
    goto LABEL_194;
  }
  unsigned int v105 = v92 + 1;
  __darwin_ino64_t v106 = v141.st_ino;
  if ((unsigned __int32 *)v141.st_ino == v89)
  {
    unsigned int v107 = v92 + 1;
  }
  else
  {
    do
    {
      unsigned int v110 = *(_DWORD *)(v106 - 4);
      v106 -= 4;
      unsigned int v107 = v110;
      unsigned int v111 = v110 + 1;
      if (v110 + 1 < v105)
      {
        int v112 = (_DWORD *)a1[10];
        do
        {
          uint64_t v113 = operator new(0x10uLL);
          *(void *)uint64_t v113 = v112;
          v113[2] = v111;
          a1[10] = (int32x2_t)v113;
          ++v111;
          int v112 = v113;
        }
        while (v105 != v111);
      }
      unsigned int v105 = v107;
    }
    while ((unsigned __int32 *)v106 != v89);
  }
  if (v90 < v107)
  {
    uint64_t v108 = (_DWORD *)a1[10];
    do
    {
      long long v109 = operator new(0x10uLL);
      *(void *)long long v109 = v108;
      v109[2] = v90;
      a1[10] = (int32x2_t)v109;
      ++v90;
      uint64_t v108 = v109;
    }
    while (v107 != v90);
  }
LABEL_195:
  if (v65)
  {
    int v139 = v65;
    operator delete(v65);
  }
  if (*(void *)&v141.st_dev)
  {
    v141.st_ino = *(void *)&v141.st_dev;
    operator delete(*(void **)&v141.st_dev);
  }
  return a1;
}

#error "19E41B808: call analysis failed (funcsize=132)"

uint64_t *sub_19E41B930(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_19E418864(*(void **)(v2 + 104));
    sub_19E4188B0(v2 + 48);
    sub_19E418A38(*(char **)(v2 + 32));
    sub_19E3CD3E0(*(char **)(v2 + 8));
    MEMORY[0x19F3BDCF0](v2, 0x10A0C404AAAD15CLL);
  }
  return a1;
}

void language_modeling::v1::InlineCompletion::InlineCompletion(language_modeling::v1::InlineCompletion *this, const language_modeling::v1::InlineCompletion *a2)
{
}

void sub_19E41BA24(void *a1)
{
  sub_19E37059C(v1);
  MEMORY[0x19F3BDCF0](v1, 0x1032C40D90104AELL);
  sub_19E37B770(a1);
}

void language_modeling::v1::InlineCompletion::operator=()
{
}

void sub_19E41BB20(void *a1)
{
  sub_19E37059C(v1);
  MEMORY[0x19F3BDCF0](v1, 0x1032C40D90104AELL);
  sub_19E37B770(a1);
}

void *language_modeling::v1::InlineCompletion::InlineCompletion(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  void *result = v2;
  return result;
}

{
  uint64_t v2;

  uint64_t v2 = *a2;
  *a2 = 0;
  void *result = v2;
  return result;
}

{
  uint64_t v2;

  uint64_t v2 = *a2;
  *a2 = 0;
  void *result = v2;
  return result;
}

{
  uint64_t v2;

  uint64_t v2 = *a2;
  *a2 = 0;
  void *result = v2;
  return result;
}

uint64_t *language_modeling::v1::InlineCompletion::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t v4 = *a1;
  *a1 = v3;
  if (v4)
  {
    if (*(char *)(v4 + 287) < 0) {
      operator delete(*(void **)(v4 + 264));
    }
    uint64_t v5 = sub_19E37059C(v4);
    MEMORY[0x19F3BDCF0](v5, 0x1032C40D90104AELL);
  }
  return a1;
}

void language_modeling::v1::InlineCompletion::~InlineCompletion(language_modeling::v1::InlineCompletion *this)
{
  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1)
  {
    if (*(char *)(v1 + 287) < 0) {
      operator delete(*(void **)(v1 + 264));
    }
    uint64_t v2 = sub_19E37059C(v1);
    MEMORY[0x19F3BDCF0](v2, 0x1032C40D90104AELL);
  }
}

{
  uint64_t v1;
  uint64_t v2;

  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1)
  {
    if (*(char *)(v1 + 287) < 0) {
      operator delete(*(void **)(v1 + 264));
    }
    uint64_t v2 = sub_19E37059C(v1);
    MEMORY[0x19F3BDCF0](v2, 0x1032C40D90104AELL);
  }
}

long long **language_modeling::v1::InlineCompletion::string@<X0>(long long **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *this;
  if (*((char *)*this + 23) < 0) {
    return (long long **)sub_19E39369C((unsigned char *)a2, *(void **)v2, *((void *)v2 + 1));
  }
  long long v3 = *v2;
  *(void *)(a2 + 16) = *((void *)v2 + 2);
  *(_OWORD *)a2 = v3;
  return this;
}

uint64_t language_modeling::v1::InlineCompletion::probability(language_modeling::v1::InlineCompletion *this)
{
  return *(void *)(*(void *)this + 48);
}

uint64_t *language_modeling::v1::InlineCompletion::prefix@<X0>(uint64_t *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *this;
  if (*(char *)(*this + 231) < 0) {
    return (uint64_t *)sub_19E39369C((unsigned char *)a2, *(void **)(v2 + 208), *(void *)(v2 + 216));
  }
  long long v3 = *(_OWORD *)(v2 + 208);
  *(void *)(a2 + 16) = *(void *)(v2 + 224);
  *(_OWORD *)a2 = v3;
  return this;
}

uint64_t language_modeling::v1::InlineCompletion::contextSize(language_modeling::v1::InlineCompletion *this)
{
  return *(void *)(*(void *)this + 232);
}

BOOL language_modeling::v1::InlineCompletion::wordBoundaryAt(language_modeling::v1::InlineCompletion *this, char a2)
{
  return (*(void *)(*(void *)this + 256) & (1 << a2)) != 0;
}

uint64_t language_modeling::v1::InlineCompletion::source(language_modeling::v1::InlineCompletion *this)
{
  return *(unsigned int *)(*(void *)this + 240);
}

void language_modeling::v1::InlineCompletion::underlyingPrediction(language_modeling::v1::InlineCompletion *this)
{
}

void sub_19E41BE34(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x1032C4057ACE4D0);
  _Unwind_Resume(a1);
}

uint64_t *language_modeling::v1::InlineCompletion::log@<X0>(uint64_t *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *this;
  if (*(char *)(*this + 287) < 0) {
    return (uint64_t *)sub_19E39369C((unsigned char *)a2, *(void **)(v2 + 264), *(void *)(v2 + 272));
  }
  long long v3 = (long long *)(v2 + 264);
  long long v4 = *v3;
  *(void *)(a2 + 16) = *((void *)v3 + 2);
  *(_OWORD *)a2 = v4;
  return this;
}

uint64_t sub_19E41BEA4()
{
  return 46;
}

void sub_19E41BEAC(uint64_t a1@<X0>, CFDictionaryRef *a2@<X8>)
{
}

void sub_19E41BEB4(uint64_t a1@<X0>, int a2@<W1>, CFDictionaryRef *a3@<X8>)
{
}

uint64_t sub_19E41BEBC(uint64_t a1)
{
  return a1 + 392;
}

void sub_19E41BEC4(void *a1)
{
  uint64_t v2 = *(void *)(a1[21] + 248);
  if (v2) {
    (*(void (**)(void))(**(void **)(*(void *)(v2 + 16) + 16) + 72))(*(void *)(*(void *)(v2 + 16) + 16));
  }
  uint64_t v3 = a1[55];
  long long v4 = (std::__shared_weak_count *)a1[56];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t))(*(void *)v3 + 72))(v3);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_19E41BFC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_19E41BFD4(uint64_t a1)
{
  sub_19E417960(*(void **)(a1 + 168));
  uint64_t v2 = *(void *)(a1 + 440);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 448);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 88))(v2);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_19E41C0A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_19E41C0B4(uint64_t a1)
{
}

void sub_19E41C0C0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 168);
  if (*(unsigned char *)(v1[29] + 192))
  {
    uint64_t v2 = v1[6];
    if (v2)
    {
      sub_19E42CFDC(v2);
      uint64_t v3 = (std::recursive_mutex *)v1[58];
      if (v3)
      {
        std::recursive_mutex::lock(v3);
        sub_19E42CFDC(v3[2].__m_.__sig);
        std::recursive_mutex::unlock(v3);
      }
    }
  }
}

void sub_19E41C130(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E41C144(uint64_t a1, void *a2)
{
}

void sub_19E41C14C(uint64_t a1, uint64_t *cf)
{
  if (!cf) {
    __assert_rtn("addVocabulary", "TokenIDLanguageModel.cpp", 317, "vocabulary");
  }
  CFRetain(cf);
  long long v4 = *(void **)(a1 + 168);
  uint64_t v5 = cf[3];
  sub_19E417004(v4, v5);
}

void sub_19E41C1B4(uint64_t a1, const void **a2)
{
  uint64_t v2 = *(void **)(a1 + 168);
  unint64_t v3 = sub_19E492AA0(a2);
  sub_19E4177F0(v2, v3);
}

void sub_19E41C1F4(uint64_t a1, const void *a2, const void **a3)
{
  long long v4 = *(void **)(a1 + 168);
  unint64_t v5 = sub_19E492AA0(a3);
  sub_19E4171F0(v4, a2, v5);
}

uint64_t sub_19E41C23C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 168) + 176);
}

void sub_19E41C248(uint64_t a1, const void *a2)
{
  uint64_t v3 = a1 + 104;
  sub_19E4086B8(*(void **)(a1 + 168), a2);
  sub_19E492D84(v3);
  long long v4 = *(void **)(a1 + 520);
  if (v4)
  {
    if (*v4 != v4[1]) {
      sub_19E41C49C((uint64_t)&v5, (void *)a1);
    }
  }
}

void sub_19E41C458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)va);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  _Unwind_Resume(a1);
}

void sub_19E41C49C(uint64_t a1, void *a2)
{
  v37[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (const void *)language_modeling::v1::kEnvironmentSessionTypeKey;
  size_t v4 = strlen((const char *)language_modeling::v1::kEnvironmentSessionTypeKey);
  if (v4 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  uint64_t v5 = (const void *)v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    signed __int8 v6 = (const void **)operator new(v7 + 1);
    __dst[1] = v5;
    unint64_t v28 = v8 | 0x8000000000000000;
    __dst[0] = v6;
  }
  else
  {
    HIBYTE(v28) = v4;
    signed __int8 v6 = __dst;
    if (!v4)
    {
LABEL_9:
      *((unsigned char *)v5 + (void)v6) = 0;
      v29[0] = 3;
      int v30 = 0;
      long long v9 = (const void *)language_modeling::v1::kEnvironmentAppIdentifierKey;
      size_t v10 = strlen((const char *)language_modeling::v1::kEnvironmentAppIdentifierKey);
      if (v10 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      int32x2_t v11 = (const void *)v10;
      if (v10 >= 0x17)
      {
        uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v10 | 7) != 0x17) {
          uint64_t v13 = v10 | 7;
        }
        uint64_t v14 = v13 + 1;
        CFDictionaryRef v12 = (const void **)operator new(v13 + 1);
        v31[1] = v11;
        unint64_t v32 = v14 | 0x8000000000000000;
        v31[0] = v12;
      }
      else
      {
        HIBYTE(v32) = v10;
        CFDictionaryRef v12 = v31;
        if (!v10)
        {
LABEL_17:
          *((unsigned char *)v11 + (void)v12) = 0;
          uint64_t v33 = 0x746C7561666564;
          *(void *)int v34 = v37[0];
          *(void *)&v34[7] = *(void *)((char *)v37 + 7);
          char v35 = 7;
          memset(v37, 0, 15);
          int v36 = 1;
          v25[0] = 0;
          v25[1] = 0;
          __int32 v24 = v25;
          sub_19E3D7E04((uint64_t *)&v24, (uint64_t)v25, __dst, (uint64_t)__dst);
          sub_19E3D7E04((uint64_t *)&v24, (uint64_t)v25, v31, (uint64_t)v31);
          if (v36 != -1) {
            ((void (*)(unsigned char *, uint64_t *))off_1EF0BEB90[v36])(v26, &v33);
          }
          int v36 = -1;
          if (SHIBYTE(v32) < 0) {
            operator delete((void *)v31[0]);
          }
          if (v30 != -1) {
            ((void (*)(unsigned char *, int *))off_1EF0BEB90[v30])(v26, v29);
          }
          int v30 = -1;
          if (SHIBYTE(v28) < 0) {
            operator delete((void *)__dst[0]);
          }
          uint64_t v15 = a2[1];
          uint64_t v17 = *(void *)(v15 + 144);
          uint64_t v16 = *(void *)(v15 + 152);
          v23[11] = v17;
          v23[12] = v16;
          if (v16) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v18 = a2[56];
          v23[9] = a2[55];
          v23[10] = v18;
          if (v18) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v19 = a2[58];
          v23[7] = a2[57];
          v23[8] = v19;
          if (v19) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v20 = a2[60];
          v23[5] = a2[59];
          v23[6] = v20;
          if (v20) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v21 = a2[62];
          void v23[3] = a2[61];
          v23[4] = v21;
          if (v21) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v22 = a2[64];
          v23[1] = a2[63];
          v23[2] = v22;
          if (v22) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
          }
          sub_19E372F7C((uint64_t)v23, (uint64_t)(a2 + 13), (uint64_t)&v24);
        }
      }
      memmove(v12, v9, (size_t)v11);
      goto LABEL_17;
    }
  }
  memmove(v6, v3, (size_t)v5);
  goto LABEL_9;
}

void sub_19E41CC04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,unsigned int *a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,char a35,uint64_t a36,char a37)
{
  if (a32) {
    (*(void (**)(uint64_t))(*(void *)a32 + 8))(a32);
  }
  sub_19E3D73EC((uint64_t)&a33);
  sub_19E3D73EC((uint64_t)&a35);
  sub_19E3D73EC((uint64_t)&a37);
  sub_19E3D73EC(v38 - 112);
  sub_19E3D73EC(v38 - 224);
  MEMORY[0x19F3BDCF0](v37, 0x10F3C403524454CLL);
  sub_19E3D73EC((uint64_t)&a17);
  sub_19E3D73EC((uint64_t)&a19);
  sub_19E3D73EC((uint64_t)&a21);
  sub_19E3D73EC((uint64_t)&a23);
  sub_19E3D73EC((uint64_t)&a25);
  sub_19E3D73EC((uint64_t)&a27);
  sub_19E3D8278(a30);
  _Unwind_Resume(a1);
}

uint64_t sub_19E41CD30(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 48);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_1EF0BEB90[v2])(&v4, a1 + 24);
  }
  *(_DWORD *)(a1 + 48) = -1;
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E41CD9C(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  return sub_19E493848((uint64_t *)(a1 + 104), a2, a3, a4);
}

uint64_t sub_19E41CDA4(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4)
{
  return sub_19E494710((uint64_t *)(a1 + 104), a2, a3, a4);
}

char *sub_19E41CDAC@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[103] < 0) {
    return (char *)sub_19E39369C((unsigned char *)a2, *((void **)result + 10), *((void *)result + 11));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 5);
  *(void *)(a2 + 16) = *((void *)result + 12);
  return result;
}

void sub_19E41CDD8(uint64_t a1)
{
  sub_19E41CE10(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E41CE10(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0B9608;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 528);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_19E41CF44(a1 + 416);
  sub_19E3C5DBC(*(char **)(a1 + 400));
  sub_19E41D104(a1 + 104);
  if (*(char *)(a1 + 103) < 0)
  {
    operator delete(*(void **)(a1 + 80));
    if ((*(char *)(a1 + 79) & 0x80000000) == 0)
    {
LABEL_6:
      if ((*(char *)(a1 + 55) & 0x80000000) == 0) {
        goto LABEL_7;
      }
LABEL_11:
      operator delete(*(void **)(a1 + 32));
      uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v3) {
        return a1;
      }
      goto LABEL_12;
    }
  }
  else if ((*(char *)(a1 + 79) & 0x80000000) == 0)
  {
    goto LABEL_6;
  }
  operator delete(*(void **)(a1 + 56));
  if (*(char *)(a1 + 55) < 0) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3) {
    return a1;
  }
LABEL_12:
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t sub_19E41CF44(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  char v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 48);
    if (!v5) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 48);
    if (!v5) {
      goto LABEL_13;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_13:
  signed __int8 v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      return a1;
    }
    goto LABEL_16;
  }
  if (*(char *)(a1 + 23) < 0) {
LABEL_16:
  }
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_19E41D104(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0B96C0;
  uint64_t v2 = *(void **)(a1 + 264);
  if (v2)
  {
    *(void *)(a1 + 272) = v2;
    operator delete(v2);
  }
  sub_19E41D2BC((void **)(a1 + 192));
  sub_19E3C5DBC(*(char **)(a1 + 176));
  uint64_t v3 = *(void ***)(a1 + 144);
  if (v3)
  {
    do
    {
      int32x2_t v11 = (void **)*v3;
      if (*((char *)v3 + 39) < 0) {
        operator delete(v3[2]);
      }
      operator delete(v3);
      uint64_t v3 = v11;
    }
    while (v11);
  }
  char v4 = *(void **)(a1 + 128);
  *(void *)(a1 + 128) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(char **)(a1 + 104);
  if (v5)
  {
    do
    {
      CFDictionaryRef v12 = *(char **)v5;
      uint64_t v13 = *((void *)v5 + 5);
      *((void *)v5 + 5) = 0;
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      }
      if (v5[39] < 0) {
        operator delete(*((void **)v5 + 2));
      }
      operator delete(v5);
      uint64_t v5 = v12;
    }
    while (v12);
  }
  signed __int8 v6 = *(void **)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v7)
  {
    uint64_t v8 = sub_19E3709A0(v7);
    MEMORY[0x19F3BDCF0](v8, 0x10F0C4069D522A4);
  }
  long long v9 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v9 || atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((*(char *)(a1 + 63) & 0x80000000) == 0) {
      goto LABEL_14;
    }
LABEL_25:
    operator delete(*(void **)(a1 + 40));
    if ((*(char *)(a1 + 39) & 0x80000000) == 0) {
      return a1;
    }
LABEL_26:
    operator delete(*(void **)(a1 + 16));
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v9);
  if (*(char *)(a1 + 63) < 0) {
    goto LABEL_25;
  }
LABEL_14:
  if (*(char *)(a1 + 39) < 0) {
    goto LABEL_26;
  }
  return a1;
}

void **sub_19E41D2BC(void **a1)
{
  uint64_t v2 = (char *)a1[6];
  if (v2)
  {
    uint64_t v3 = (char *)a1[7];
    char v4 = a1[6];
    if (v3 != v2)
    {
      do
      {
        signed __int8 v6 = (const void *)*((void *)v3 - 1);
        v3 -= 8;
        uint64_t v5 = v6;
        if (v6) {
          CFRelease(v5);
        }
      }
      while (v3 != v2);
      char v4 = a1[6];
    }
    a1[7] = v2;
    operator delete(v4);
  }
  uint64_t v7 = a1[3];
  if (v7)
  {
    a1[4] = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void **)*a1;
  if (*a1)
  {
    long long v9 = (void **)a1[1];
    size_t v10 = *a1;
    if (v9 != v8)
    {
      do
      {
        if (*((char *)v9 - 1) < 0) {
          operator delete(*(v9 - 3));
        }
        v9 -= 3;
      }
      while (v9 != v8);
      size_t v10 = *a1;
    }
    a1[1] = v8;
    operator delete(v10);
  }
  return a1;
}

char *sub_19E41D388(char *__dst, long long *a2)
{
  *stat __dst = 0;
  __dst[48] = 0;
  if (*((unsigned char *)a2 + 48))
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_19E39369C(__dst, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v4 = *a2;
      *((void *)__dst + 2) = *((void *)a2 + 2);
      *(_OWORD *)stat __dst = v4;
    }
    *((void *)__dst + 4) = 0;
    *((void *)__dst + 3) = __dst + 32;
    *((void *)__dst + 5) = 0;
    sub_19E3C5B70((uint64_t *)__dst + 3, *((void **)a2 + 3), (void *)a2 + 4);
    __dst[48] = 1;
  }
  return __dst;
}

void sub_19E41D410(_Unwind_Exception *a1)
{
  sub_19E3FFE24(v1);
  _Unwind_Resume(a1);
}

void sub_19E41D444(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  long long v4 = a2;
  if (*(void *)(a1 + 16))
  {
    signed __int8 v6 = *(uint64_t **)a1;
    uint64_t v8 = (uint64_t **)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    long long v9 = v6[1] ? (uint64_t *)v6[1] : v6;
    uint64_t v63 = a1;
    double v65 = v9;
    if (v9)
    {
      size_t v10 = (char *)v9[2];
      if (v10)
      {
        int32x2_t v11 = *(char **)v10;
        if (*(uint64_t **)v10 == v9)
        {
          *(void *)size_t v10 = 0;
          while (1)
          {
            CFTypeID v62 = (char *)*((void *)v10 + 1);
            if (!v62) {
              break;
            }
            do
            {
              size_t v10 = v62;
              CFTypeID v62 = *(char **)v62;
            }
            while (v62);
          }
        }
        else
        {
          for (*((void *)v10 + 1) = 0; v11; int32x2_t v11 = (char *)*((void *)v10 + 1))
          {
            do
            {
              size_t v10 = v11;
              int32x2_t v11 = *(char **)v11;
            }
            while (v11);
          }
        }
      }
      char v64 = v10;
      if (a2 != a3)
      {
        CFDictionaryRef v12 = a2;
        while (1)
        {
          if (v9 != v12)
          {
            uint64_t v13 = (void **)(v9 + 4);
            char v14 = *((unsigned char *)v12 + 55);
            if (*((char *)v9 + 55) < 0)
            {
              if (v14 >= 0) {
                uint64_t v16 = v12 + 4;
              }
              else {
                uint64_t v16 = (void *)v12[4];
              }
              if (v14 >= 0) {
                size_t v17 = *((unsigned __int8 *)v12 + 55);
              }
              else {
                size_t v17 = v12[5];
              }
              sub_19E3C6D44(v13, v16, v17);
            }
            else if ((*((unsigned char *)v12 + 55) & 0x80) != 0)
            {
              sub_19E3C6C7C(v13, (void *)v12[4], v12[5]);
            }
            else
            {
              long long v15 = *((_OWORD *)v12 + 2);
              v9[6] = v12[6];
              *(_OWORD *)uint64_t v13 = v15;
            }
            uint64_t v18 = (void **)(v9 + 7);
            char v19 = *((unsigned char *)v12 + 79);
            if (*((char *)v9 + 79) < 0)
            {
              if (v19 >= 0) {
                uint64_t v21 = v12 + 7;
              }
              else {
                uint64_t v21 = (void *)v12[7];
              }
              if (v19 >= 0) {
                size_t v22 = *((unsigned __int8 *)v12 + 79);
              }
              else {
                size_t v22 = v12[8];
              }
              sub_19E3C6D44(v18, v21, v22);
            }
            else if ((*((unsigned char *)v12 + 79) & 0x80) != 0)
            {
              sub_19E3C6C7C(v18, (void *)v12[7], v12[8]);
            }
            else
            {
              long long v20 = *(_OWORD *)(v12 + 7);
              v9[9] = v12[9];
              *(_OWORD *)uint64_t v18 = v20;
            }
          }
          CFTypeID v23 = v65;
          __int32 v24 = *v8;
          CFNumberRef v25 = (uint64_t **)(a1 + 8);
          CFNumberRef v26 = (uint64_t **)(a1 + 8);
          if (*v8)
          {
            int v27 = *((char *)v65 + 55);
            if (v27 >= 0) {
              unint64_t v28 = v65 + 4;
            }
            else {
              unint64_t v28 = (const void *)v65[4];
            }
            if (v27 >= 0) {
              size_t v29 = *((unsigned __int8 *)v65 + 55);
            }
            else {
              size_t v29 = v65[5];
            }
            while (1)
            {
              CFNumberRef v25 = (uint64_t **)v24;
              unint64_t v32 = (const void *)v24[4];
              int v30 = v24 + 4;
              CFTypeID v31 = v32;
              int v33 = *((char *)v30 + 23);
              if (v33 >= 0) {
                int v34 = v30;
              }
              else {
                int v34 = v31;
              }
              if (v33 >= 0) {
                size_t v35 = *((unsigned __int8 *)v30 + 23);
              }
              else {
                size_t v35 = v30[1];
              }
              if (v35 >= v29) {
                size_t v36 = v29;
              }
              else {
                size_t v36 = v35;
              }
              int v37 = memcmp(v28, v34, v36);
              if (v37)
              {
                if (v37 < 0) {
                  goto LABEL_43;
                }
LABEL_57:
                __int32 v24 = v25[1];
                if (!v24)
                {
                  CFNumberRef v26 = v25 + 1;
                  break;
                }
              }
              else
              {
                if (v29 >= v35) {
                  goto LABEL_57;
                }
LABEL_43:
                __int32 v24 = *v25;
                CFNumberRef v26 = v25;
                if (!*v25) {
                  break;
                }
              }
            }
          }
          *double v65 = 0;
          v23[1] = 0;
          v23[2] = (uint64_t)v25;
          *CFNumberRef v26 = v23;
          uint64_t v38 = **(void **)a1;
          if (v38)
          {
            *(void *)a1 = v38;
            CFTypeID v23 = *v26;
          }
          sub_19E37D324(*(uint64_t **)(a1 + 8), v23);
          ++*(void *)(a1 + 16);
          long long v9 = (uint64_t *)v64;
          double v65 = (uint64_t *)v64;
          if (v64)
          {
            size_t v10 = (char *)*((void *)v64 + 2);
            if (v10)
            {
              BOOL v39 = *(char **)v10;
              if (*(char **)v10 == v64)
              {
                *(void *)size_t v10 = 0;
                while (1)
                {
                  float v42 = (char *)*((void *)v10 + 1);
                  if (!v42) {
                    break;
                  }
                  do
                  {
                    size_t v10 = v42;
                    float v42 = *(char **)v42;
                  }
                  while (v42);
                }
              }
              else
              {
                for (*((void *)v10 + 1) = 0; v39; BOOL v39 = (char *)*((void *)v10 + 1))
                {
                  do
                  {
                    size_t v10 = v39;
                    BOOL v39 = *(char **)v39;
                  }
                  while (v39);
                }
              }
            }
            char v64 = v10;
            double v40 = (uint64_t *)v12[1];
            if (v40)
            {
              do
              {
LABEL_70:
                long long v4 = v40;
                double v40 = (uint64_t *)*v40;
              }
              while (v40);
              goto LABEL_74;
            }
          }
          else
          {
            size_t v10 = 0;
            double v40 = (uint64_t *)v12[1];
            if (v40) {
              goto LABEL_70;
            }
          }
          do
          {
            long long v4 = (uint64_t *)v12[2];
            BOOL v41 = *v4 == (void)v12;
            CFDictionaryRef v12 = v4;
          }
          while (!v41);
LABEL_74:
          if (v9)
          {
            CFDictionaryRef v12 = v4;
            if (v4 != a3) {
              continue;
            }
          }
          break;
        }
      }
      sub_19E3C5DBC((char *)v9);
      if (v10)
      {
        for (unint64_t i = (char *)*((void *)v10 + 2); i; unint64_t i = (char *)*((void *)i + 2))
          size_t v10 = i;
        sub_19E3C5DBC(v10);
      }
    }
  }
  if (v4 == a3) {
    return;
  }
  while (2)
  {
    sub_19E3C60DC((uint64_t)&v63, a1, (uint64_t)(v4 + 4));
    unint64_t v44 = (uint64_t *)v63;
    unint64_t v45 = *(uint64_t **)(a1 + 8);
    float v46 = (uint64_t **)(a1 + 8);
    float v47 = (uint64_t **)(a1 + 8);
    if (!v45) {
      goto LABEL_111;
    }
    int v48 = *(char *)(v63 + 55);
    if (v48 >= 0) {
      unint64_t v49 = (const void *)(v63 + 32);
    }
    else {
      unint64_t v49 = *(const void **)(v63 + 32);
    }
    if (v48 >= 0) {
      unint64_t v50 = *(unsigned __int8 *)(v63 + 55);
    }
    else {
      unint64_t v50 = *(void *)(v63 + 40);
    }
    do
    {
      while (1)
      {
        float v46 = (uint64_t **)v45;
        uint64_t v53 = v45[4];
        int v51 = v45 + 4;
        double v52 = (void *)v53;
        int v54 = *((char *)v51 + 23);
        uint64_t v55 = v54 >= 0 ? v51 : v52;
        unint64_t v56 = v54 >= 0 ? *((unsigned __int8 *)v51 + 23) : v51[1];
        size_t v57 = v56 >= v50 ? v50 : v56;
        int v58 = memcmp(v49, v55, v57);
        if (v58) {
          break;
        }
        if (v50 >= v56) {
          goto LABEL_109;
        }
LABEL_95:
        unint64_t v45 = *v46;
        float v47 = v46;
        if (!*v46) {
          goto LABEL_111;
        }
      }
      if (v58 < 0) {
        goto LABEL_95;
      }
LABEL_109:
      unint64_t v45 = v46[1];
    }
    while (v45);
    float v47 = v46 + 1;
LABEL_111:
    *unint64_t v44 = 0;
    v44[1] = 0;
    v44[2] = (uint64_t)v46;
    *float v47 = v44;
    uint64_t v59 = **(void **)a1;
    if (v59)
    {
      *(void *)a1 = v59;
      unint64_t v44 = *v47;
    }
    sub_19E37D324(*(uint64_t **)(a1 + 8), v44);
    ++*(void *)(a1 + 16);
    int32x2_t v60 = (uint64_t *)v4[1];
    if (v60)
    {
      do
      {
        int v61 = v60;
        int32x2_t v60 = (uint64_t *)*v60;
      }
      while (v60);
    }
    else
    {
      do
      {
        int v61 = (uint64_t *)v4[2];
        BOOL v41 = *v61 == (void)v4;
        long long v4 = v61;
      }
      while (!v41);
    }
    long long v4 = v61;
    if (v61 != a3) {
      continue;
    }
    break;
  }
}

void sub_19E41D89C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E41D9F4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E41D8B4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    long long v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6)
        {
          uint64_t v7 = sub_19E37059C(v5);
          MEMORY[0x19F3BDCF0](v7, 0x1032C4057ACE4D0);
        }
      }
      while (v3 != v1);
      long long v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void sub_19E41D950(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0B5C70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E41D9A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0B5C70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

os_log_t sub_19E41D9C4()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "ToucanLanguageModel");
  qword_1EC0091C8 = (uint64_t)result;
  return result;
}

uint64_t sub_19E41D9F4(uint64_t a1)
{
  sub_19E3C5DBC(*(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_19E3C5DBC((char *)v2);
  }
  return a1;
}

void sub_19E41DA44(uint64_t a1, const __CFString *a2)
{
  if (a2 && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(a2)))
  {
    sub_19E3C6934(__p, a2);
    char v7 = 1;
    if (SHIBYTE(v6) < 0)
    {
      sub_19E39369C((unsigned char *)a1, __p[0], (unint64_t)__p[1]);
      if (v7)
      {
        if (SHIBYTE(v6) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      *(_OWORD *)a1 = *(_OWORD *)__p;
      *(void *)(a1 + 16) = v6;
    }
  }
  else
  {
    LOBYTE(__p[0]) = 0;
    char v7 = 0;
    *(unsigned char *)(a1 + 23) = 0;
    *(unsigned char *)a1 = 0;
  }
}

void sub_19E41DB04(uint64_t a1, const __CFDictionary *a2, CFTypeRef **a3)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1EF0B9608;
  *(void *)(a1 + 8) = *a3;
  uint64_t v6 = a3[1];
  *(void *)(a1 + 16) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v6 + 1, 1uLL, memory_order_relaxed);
  }
  char v7 = *a3;
  uint64_t v8 = (std::__shared_weak_count *)a3[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_19E432C84((char **)__p, *v7, 46);
  long long v9 = *(char **)__p;
  int32x2_t v11 = **(const void ****)__p;
  size_t v10 = *(std::__shared_weak_count **)(*(void *)__p + 8);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFDictionaryRef v12 = *(char **)&__p[8];
  uint64_t v13 = v9;
  if (*(char **)&__p[8] != v9)
  {
    do
    {
      char v14 = (std::__shared_weak_count *)*((void *)v12 - 1);
      if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
      v12 -= 16;
    }
    while (v12 != v9);
    uint64_t v13 = *(char **)__p;
  }
  *(void *)&__p[8] = v9;
  operator delete(v13);
  if (v11)
  {
    int v15 = sub_19E4DE320(*v11);
    if (!v10)
    {
LABEL_20:
      if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
      *(_DWORD *)(a1 + 24) = v15;
      uint64_t v16 = *a3;
      size_t v17 = (std::__shared_weak_count *)a3[1];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        int v15 = *(_DWORD *)(a1 + 24);
      }
      sub_19E432C84((char **)&v82, *v16, 46);
      uint64_t v18 = **(const void ***)v82;
      if (v18) {
        CFRetain(**(CFTypeRef **)v82);
      }
      sub_19E36E590(&cf, v18);
      if (!cf)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      stat __dst = (void **)(a1 + 32);
      CFNumberRef v19 = (const __CFNumber *)sub_19E3D6F18((const __CFDictionary *)cf, (const UInt8 *)language_modeling::v1::kUseForConditionalProbabilityKey);
      if (v19)
      {
        unsigned __int16 v20 = sub_19E3D7020(v19);
        if (v20 >= 0x100u)
        {
          if ((_BYTE)v20)
          {
            if (v15)
            {
              if (qword_1EC0091D0 != -1) {
                dispatch_once(&qword_1EC0091D0, &unk_1EF0BEB70);
              }
              uint64_t v21 = qword_1EC0091C8;
              if (os_log_type_enabled((os_log_t)qword_1EC0091C8, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)std::string __p = 136315650;
                *(void *)&__p[4] = "determineModelType";
                *(_WORD *)&unsigned char __p[12] = 2080;
                *(void *)&__p[14] = language_modeling::v1::kLanguageModelTypeToucan;
                __int16 v90 = 2080;
                uint64_t v91 = language_modeling::v1::kUseForConditionalProbabilityKey;
                _os_log_impl(&dword_19E36B000, v21, OS_LOG_TYPE_DEFAULT, "%s: Running model type %s since LD has set key %s to true and the architecture is not LSTM based", __p, 0x20u);
              }
              size_t v22 = (const void *)language_modeling::v1::kLanguageModelTypeToucan;
              size_t v23 = strlen((const char *)language_modeling::v1::kLanguageModelTypeToucan);
              if (v23 <= 0x7FFFFFFFFFFFFFF7)
              {
                size_t v24 = v23;
                if (v23 >= 0x17)
                {
                  uint64_t v25 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v23 | 7) != 0x17) {
                    uint64_t v25 = v23 | 7;
                  }
LABEL_120:
                  uint64_t v57 = v25 + 1;
                  unint64_t v56 = operator new(v25 + 1);
                  *(void *)(a1 + 40) = v24;
                  *(void *)(a1 + 48) = v57 | 0x8000000000000000;
                  *(void *)(a1 + 32) = v56;
                  goto LABEL_121;
                }
                goto LABEL_116;
              }
            }
            else
            {
              if (qword_1EC0091D0 != -1) {
                dispatch_once(&qword_1EC0091D0, &unk_1EF0BEB70);
              }
              int v54 = qword_1EC0091C8;
              if (os_log_type_enabled((os_log_t)qword_1EC0091C8, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)std::string __p = 136315650;
                *(void *)&__p[4] = "determineModelType";
                *(_WORD *)&unsigned char __p[12] = 2080;
                *(void *)&__p[14] = language_modeling::v1::kLanguageModelTypeToucanCPU;
                __int16 v90 = 2080;
                uint64_t v91 = language_modeling::v1::kUseForConditionalProbabilityKey;
                _os_log_impl(&dword_19E36B000, v54, OS_LOG_TYPE_DEFAULT, "%s: Running model type %s since LD has set key %s to true and the architecture is LSTM based", __p, 0x20u);
              }
              size_t v22 = (const void *)language_modeling::v1::kLanguageModelTypeToucanCPU;
              size_t v55 = strlen((const char *)language_modeling::v1::kLanguageModelTypeToucanCPU);
              if (v55 <= 0x7FFFFFFFFFFFFFF7)
              {
                size_t v24 = v55;
                if (v55 >= 0x17)
                {
                  uint64_t v25 = (v55 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v55 | 7) != 0x17) {
                    uint64_t v25 = v55 | 7;
                  }
                  goto LABEL_120;
                }
LABEL_116:
                *(unsigned char *)(a1 + 55) = v24;
                unint64_t v56 = (unsigned char *)(a1 + 32);
                if (!v24)
                {
LABEL_122:
                  v56[v24] = 0;
                  CFTypeRef v53 = cf;
                  if (!cf) {
                    goto LABEL_124;
                  }
                  goto LABEL_123;
                }
LABEL_121:
                memmove(v56, v22, v24);
                goto LABEL_122;
              }
            }
            sub_19E37C958();
          }
        }
      }
      CFStringRef v26 = (CFStringRef)language_modeling::v1::kLanguageModelForConditionalProbabilityKey;
      if (language_modeling::v1::kLanguageModelForConditionalProbabilityKey)
      {
        size_t v27 = strlen((const char *)language_modeling::v1::kLanguageModelForConditionalProbabilityKey);
        CFStringRef v26 = CFStringCreateWithBytes(0, (const UInt8 *)language_modeling::v1::kLanguageModelForConditionalProbabilityKey, v27, 0x8000100u, 0);
        if (!v26)
        {
          uint64_t v78 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x19F3BD790](v78, "Could not construct");
          __cxa_throw(v78, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
        }
      }
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, v26);
      if (v26) {
        CFRelease(v26);
      }
      sub_19E41DA44((uint64_t)v87, Value);
      CFStringRef v29 = (CFStringRef)language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey;
      if (language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey)
      {
        size_t v30 = strlen((const char *)language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey);
        CFStringRef v29 = CFStringCreateWithBytes(0, (const UInt8 *)language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey, v30, 0x8000100u, 0);
        if (!v29)
        {
          uint64_t v79 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x19F3BD790](v79, "Could not construct");
          __cxa_throw(v79, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
        }
      }
      CFStringRef v31 = (const __CFString *)CFDictionaryGetValue(a2, v29);
      if (v29) {
        CFRelease(v29);
      }
      sub_19E41DA44((uint64_t)v85, v31);
      unint64_t v32 = (const void *)language_modeling::v1::kLanguageModelTypeToucan;
      int v33 = (char)v88;
      if ((v88 & 0x80u) == 0) {
        size_t v34 = v88;
      }
      else {
        size_t v34 = (size_t)v87[1];
      }
      size_t v35 = strlen((const char *)language_modeling::v1::kLanguageModelTypeToucan);
      if (v34 != v35
        || ((v88 & 0x80u) == 0 ? (size_t v36 = v87) : (size_t v36 = (void **)v87[0]),
            memcmp(v36, (const void *)language_modeling::v1::kLanguageModelTypeToucan, v34)))
      {
        if (v34 != strlen((const char *)language_modeling::v1::kLanguageModelTypeToucanCPU)) {
          goto LABEL_91;
        }
        int v37 = v33 >= 0 ? v87 : (void **)v87[0];
        if (memcmp(v37, (const void *)language_modeling::v1::kLanguageModelTypeToucanCPU, v34)) {
          goto LABEL_91;
        }
      }
      int v38 = (char)v86;
      if ((v86 & 0x80u) == 0) {
        size_t v39 = v86;
      }
      else {
        size_t v39 = (size_t)v85[1];
      }
      if (v39 == v35)
      {
        double v40 = (v86 & 0x80u) == 0 ? v85 : (void **)v85[0];
        if (!memcmp(v40, v32, v35))
        {
          if (qword_1EC0091D0 != -1) {
            dispatch_once(&qword_1EC0091D0, &unk_1EF0BEB70);
          }
          uint64_t v72 = qword_1EC0091C8;
          if (os_log_type_enabled((os_log_t)qword_1EC0091C8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string __p = 136315394;
            *(void *)&__p[4] = "determineModelType";
            *(_WORD *)&unsigned char __p[12] = 2080;
            *(void *)&__p[14] = language_modeling::v1::kLanguageModelTypeToucanCPU;
            _os_log_impl(&dword_19E36B000, v72, OS_LOG_TYPE_DEFAULT, "%s: Running model type %s since user toggled internal preference", __p, 0x16u);
          }
          unint64_t v45 = (const void *)language_modeling::v1::kLanguageModelTypeToucanCPU;
          size_t v73 = strlen((const char *)language_modeling::v1::kLanguageModelTypeToucanCPU);
          if (v73 <= 0x7FFFFFFFFFFFFFF7)
          {
            size_t v47 = v73;
            if (v73 >= 0x17)
            {
              uint64_t v48 = (v73 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v73 | 7) != 0x17) {
                uint64_t v48 = v73 | 7;
              }
              goto LABEL_101;
            }
            goto LABEL_97;
          }
          goto LABEL_183;
        }
      }
      if (v39 == strlen((const char *)language_modeling::v1::kLanguageModelTypeToucanDisabled))
      {
        BOOL v41 = v38 >= 0 ? v85 : (void **)v85[0];
        if (!memcmp(v41, (const void *)language_modeling::v1::kLanguageModelTypeToucanDisabled, v39))
        {
          if (qword_1EC0091D0 != -1) {
            dispatch_once(&qword_1EC0091D0, &unk_1EF0BEB70);
          }
          long long v74 = qword_1EC0091C8;
          if (os_log_type_enabled((os_log_t)qword_1EC0091C8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string __p = 136315394;
            *(void *)&__p[4] = "determineModelType";
            *(_WORD *)&unsigned char __p[12] = 2080;
            *(void *)&__p[14] = language_modeling::v1::kLanguageModelTypeTokenID;
            _os_log_impl(&dword_19E36B000, v74, OS_LOG_TYPE_DEFAULT, "%s: Running model type %s since user toggled internal preference", __p, 0x16u);
          }
          unint64_t v45 = (const void *)language_modeling::v1::kLanguageModelTypeTokenID;
          size_t v75 = strlen((const char *)language_modeling::v1::kLanguageModelTypeTokenID);
          if (v75 <= 0x7FFFFFFFFFFFFFF7)
          {
            size_t v47 = v75;
            if (v75 >= 0x17)
            {
              uint64_t v48 = (v75 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v75 | 7) != 0x17) {
                uint64_t v48 = v75 | 7;
              }
              goto LABEL_101;
            }
            goto LABEL_97;
          }
          goto LABEL_183;
        }
      }
      if (qword_1EC0091A8 != -1) {
        dispatch_once(&qword_1EC0091A8, &unk_1EF0BEC80);
      }
      if (!byte_1E9459D98) {
        goto LABEL_91;
      }
      if (!cf)
      {
        uint64_t v80 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](v80, "Could not construct");
        __cxa_throw(v80, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      CFNumberRef v42 = (const __CFNumber *)sub_19E3D6F18((const __CFDictionary *)cf, (const UInt8 *)language_modeling::v1::kSupportsConditionalProbabilityKey);
      if (v42 && (unsigned __int16 v43 = sub_19E3D7020(v42), v43 >= 0x100u) && (_BYTE)v43)
      {
        if (qword_1EC0091D0 != -1) {
          dispatch_once(&qword_1EC0091D0, &unk_1EF0BEB70);
        }
        unint64_t v44 = qword_1EC0091C8;
        if (os_log_type_enabled((os_log_t)qword_1EC0091C8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string __p = 136315650;
          *(void *)&__p[4] = "determineModelType";
          *(_WORD *)&unsigned char __p[12] = 2080;
          *(void *)&__p[14] = language_modeling::v1::kLanguageModelTypeToucanCPU;
          __int16 v90 = 2080;
          uint64_t v91 = language_modeling::v1::kSupportsConditionalProbabilityKey;
          _os_log_impl(&dword_19E36B000, v44, OS_LOG_TYPE_DEFAULT, "%s: Running model type %s since device is H13ANE and LD has set key %s to true", __p, 0x20u);
        }
        unint64_t v45 = (const void *)language_modeling::v1::kLanguageModelTypeToucanCPU;
        size_t v46 = strlen((const char *)language_modeling::v1::kLanguageModelTypeToucanCPU);
        if (v46 <= 0x7FFFFFFFFFFFFFF7)
        {
          size_t v47 = v46;
          if (v46 >= 0x17)
          {
            uint64_t v48 = (v46 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v46 | 7) != 0x17) {
              uint64_t v48 = v46 | 7;
            }
LABEL_101:
            uint64_t v52 = v48 + 1;
            int v51 = operator new(v48 + 1);
            *(void *)(a1 + 40) = v47;
            *(void *)(a1 + 48) = v52 | 0x8000000000000000;
            *(void *)(a1 + 32) = v51;
            goto LABEL_102;
          }
          goto LABEL_97;
        }
      }
      else
      {
LABEL_91:
        if (qword_1EC0091D0 != -1) {
          dispatch_once(&qword_1EC0091D0, &unk_1EF0BEB70);
        }
        unint64_t v49 = qword_1EC0091C8;
        if (os_log_type_enabled((os_log_t)qword_1EC0091C8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string __p = 136315394;
          *(void *)&__p[4] = "determineModelType";
          *(_WORD *)&unsigned char __p[12] = 2080;
          *(void *)&__p[14] = language_modeling::v1::kLanguageModelTypeTokenID;
          _os_log_impl(&dword_19E36B000, v49, OS_LOG_TYPE_DEFAULT, "%s: Falling back to default model type %s", __p, 0x16u);
        }
        unint64_t v45 = (const void *)language_modeling::v1::kLanguageModelTypeTokenID;
        size_t v50 = strlen((const char *)language_modeling::v1::kLanguageModelTypeTokenID);
        if (v50 <= 0x7FFFFFFFFFFFFFF7)
        {
          size_t v47 = v50;
          if (v50 >= 0x17)
          {
            uint64_t v48 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v50 | 7) != 0x17) {
              uint64_t v48 = v50 | 7;
            }
            goto LABEL_101;
          }
LABEL_97:
          *(unsigned char *)(a1 + 55) = v47;
          int v51 = (unsigned char *)(a1 + 32);
          if (!v47)
          {
LABEL_103:
            v51[v47] = 0;
            if ((char)v86 < 0)
            {
              operator delete(v85[0]);
              if (((char)v88 & 0x80000000) == 0)
              {
LABEL_105:
                CFTypeRef v53 = cf;
                if (!cf) {
                  goto LABEL_124;
                }
                goto LABEL_123;
              }
            }
            else if (((char)v88 & 0x80000000) == 0)
            {
              goto LABEL_105;
            }
            operator delete(v87[0]);
            CFTypeRef v53 = cf;
            if (!cf)
            {
LABEL_124:
              int v58 = (char *)v82;
              if (v82)
              {
                uint64_t v59 = v83;
                int32x2_t v60 = v82;
                if (v83 != v82)
                {
                  do
                  {
                    int v61 = (std::__shared_weak_count *)*((void *)v59 - 1);
                    if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                      std::__shared_weak_count::__release_weak(v61);
                    }
                    v59 -= 16;
                  }
                  while (v59 != v58);
                  int32x2_t v60 = v82;
                }
                uint64_t v83 = v58;
                operator delete(v60);
              }
              if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
                std::__shared_weak_count::__release_weak(v17);
              }
              CFTypeID v62 = (const void *)MEMORY[0x19F3BCDE0](*(void *)(*(void *)(a1 + 8) + 8));
              uint64_t v63 = v62;
              if (v62) {
                CFRetain(v62);
              }
              sub_19E372124(__p, v63);
              CFStringRef v64 = *(const __CFString **)__p;
              if (*(void *)__p)
              {
                CFTypeID TypeID = CFStringGetTypeID();
                if (TypeID == CFGetTypeID(v64))
                {
                  sub_19E3721DC((void *)(a1 + 56), v64);
                  if (*(void *)__p) {
                    CFRelease(*(CFTypeRef *)__p);
                  }
                  sub_19E524878((unsigned char *)(a1 + 80), (uint64_t *)(a1 + 56));
                  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a2);
                  int v67 = *(char *)(a1 + 55);
                  if (v67 >= 0) {
                    size_t v68 = *(unsigned __int8 *)(a1 + 55);
                  }
                  else {
                    size_t v68 = *(void *)(a1 + 40);
                  }
                  if (v68 == strlen((const char *)language_modeling::v1::kLanguageModelTypeToucanCPU))
                  {
                    unint64_t v69 = v67 >= 0 ? (const void *)(a1 + 32) : *__dst;
                    if (!memcmp(v69, (const void *)language_modeling::v1::kLanguageModelTypeToucanCPU, v68)) {
                      goto LABEL_158;
                    }
                  }
                  if (v68 == strlen((const char *)language_modeling::v1::kLanguageModelTypeToucan))
                  {
                    unint64_t v70 = v67 >= 0 ? (const void *)(a1 + 32) : *__dst;
                    if (!memcmp(v70, (const void *)language_modeling::v1::kLanguageModelTypeToucan, v68))
                    {
                      if (qword_1EC0091A8 != -1) {
                        dispatch_once(&qword_1EC0091A8, &unk_1EF0BEC80);
                      }
                      if (byte_1E9459D98)
                      {
LABEL_158:
                        int v71 = (const void *)*MEMORY[0x1E4F1CFC8];
                        CFDictionarySetValue(MutableCopy, (const void *)kLMLanguageModelUseMontrealKey, (const void *)*MEMORY[0x1E4F1CFC8]);
                        CFDictionarySetValue(MutableCopy, (const void *)kLMLanguageModelUseLegacyStaticNgramModelsKey, v71);
                        goto LABEL_159;
                      }
                      sub_19E3F7C4C(__dst, (char *)language_modeling::v1::kLanguageModelTypeTokenID);
                    }
                  }
LABEL_159:
                  *(_OWORD *)uint64_t v85 = *(_OWORD *)a3;
                  *a3 = 0;
                  a3[1] = 0;
                  sub_19E494D14(a1 + 104, (uint64_t)MutableCopy, v85);
                }
                uint64_t v77 = __cxa_allocate_exception(0x10uLL);
                MEMORY[0x19F3BD790](v77, "Could not convert");
              }
              else
              {
                uint64_t v77 = __cxa_allocate_exception(0x10uLL);
                MEMORY[0x19F3BD790](v77, "Could not construct");
              }
              __cxa_throw(v77, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
            }
LABEL_123:
            CFRelease(v53);
            goto LABEL_124;
          }
LABEL_102:
          memmove(v51, v45, v47);
          goto LABEL_103;
        }
      }
LABEL_183:
      sub_19E37C958();
    }
  }
  else
  {
    int v15 = 0;
    if (!v10) {
      goto LABEL_20;
    }
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  goto LABEL_20;
}

void sub_19E41F46C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void **a11, uint64_t a12, void **a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,CFTypeRef cf,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,CFTypeRef a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  __cxa_free_exception(v58);
  if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
    std::__shared_weak_count::__release_weak(v59);
  }
  sub_19E3C5DBC(*v57);
  sub_19E41D104(a12);
  if (*(char *)(v56 + 103) < 0) {
    operator delete(*a10);
  }
  if (*(char *)(v56 + 79) < 0) {
    operator delete(*a11);
  }
  if (*(char *)(v56 + 55) < 0) {
    operator delete(*a13);
  }
  int v61 = *(std::__shared_weak_count **)(v56 + 16);
  if (v61)
  {
    if (!atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
      std::__shared_weak_count::__release_weak(v61);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E41FBD4(uint64_t a1)
{
  return MEMORY[0x1F412A7F0](*(void *)(a1 + 8));
}

uint64_t sub_19E41FBDC(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void sub_19E41FBE4()
{
}

void sub_19E41FC48()
{
}

void sub_19E41FC50()
{
  v0[4] = *MEMORY[0x1E4F143B8];
  v0[0] = &unk_1EF0BD6C0;
  v0[3] = v0;
  sub_19E51273C();
}

void sub_19E41FD40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(exception_object);
  }
  if (a13) {
    (*(void (**)(void))(*a13 + 40))();
  }
  _Unwind_Resume(exception_object);
}

void sub_19E41FDB8(uint64_t a1@<X8>)
{
}

uint64_t sub_19E41FDC8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = *(unsigned int *)(a1 + 256);
  if ((int)v6 < 1) {
    goto LABEL_23;
  }
  uint64_t v7 = 0;
  uint64_t v8 = *(void *)(a1 + 152);
  char v9 = *(unsigned char *)(a2 + 23);
  if (v9 >= 0) {
    uint64_t v10 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v10 = *(void *)(a2 + 8);
  }
  if (v9 >= 0) {
    int32x2_t v11 = (unsigned __int8 *)a2;
  }
  else {
    int32x2_t v11 = *(unsigned __int8 **)a2;
  }
  while (1)
  {
    CFDictionaryRef v12 = (unsigned __int8 *)(v8 + 24 * v7);
    uint64_t v13 = v12[23];
    if ((v13 & 0x80u) == 0) {
      uint64_t v14 = v12[23];
    }
    else {
      uint64_t v14 = *((void *)v12 + 1);
    }
    if (v14 != v10) {
      goto LABEL_9;
    }
    if ((v13 & 0x80) == 0) {
      break;
    }
    if (!memcmp(*(const void **)v12, v11, *((void *)v12 + 1))) {
      goto LABEL_19;
    }
LABEL_9:
    if (++v7 == v6) {
      goto LABEL_23;
    }
  }
  if (v12[23])
  {
    int v15 = v11;
    while (*v12 == *v15)
    {
      ++v12;
      ++v15;
      if (!--v13) {
        goto LABEL_19;
      }
    }
    goto LABEL_9;
  }
LABEL_19:
  if ((v7 & 0x80000000) == 0)
  {
    ++*(void *)(a1 + 264);
    uint64_t v16 = *(void *)(a1 + 200);
    uint64_t v17 = *(void *)(a1 + 248);
    if (*(void *)(v16 + 8 * v7) != v17)
    {
      uint64_t v18 = v17 + 1;
      *(void *)(a1 + 248) = v18;
      *(void *)(v16 + 8 * v7) = v18;
    }
    CFNumberRef v19 = (double *)(*(void *)(a1 + 176) + 16 * v7);
    goto LABEL_57;
  }
LABEL_23:
  ++*(void *)(a1 + 272);
  v39[0] = 0;
  CFStringRef v20 = sub_19E3C2A64(a2);
  uint64_t v40 = 0;
  BOOL v41 = &v40;
  int v43 = 0;
  uint64_t v42 = 0x2000000000;
  v39[1] = MEMORY[0x1E4F143A8];
  void v39[2] = 0x40000000;
  v39[3] = sub_19E512428;
  v39[4] = &unk_1E59A1D20;
  v39[5] = &v40;
  v39[6] = v20;
  v39[7] = v39;
  LXLexiconEnumerateEntriesForString();
  int v21 = *((_DWORD *)v41 + 6);
  _Block_object_dispose(&v40, 8);
  double v22 = *(double *)v39;
  if (v20) {
    CFRelease(v20);
  }
  CFNumberRef v19 = *(double **)(a1 + 224);
  size_t v23 = *(unsigned int **)(a1 + 232);
  if (v19 != (double *)v23)
  {
    while (*(_DWORD *)v19 != v21 || v19[1] != v22)
    {
      v19 += 2;
      if (v19 == (double *)v23)
      {
        CFNumberRef v19 = *(double **)(a1 + 232);
        break;
      }
    }
  }
  if (v19 == (double *)v23)
  {
    unint64_t v25 = *(int *)(a1 + 256);
    uint64_t v26 = *(void *)(a1 + 152);
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 160) - v26) >> 3) <= v25)
    {
      if ((int)v25 < 2)
      {
        LODWORD(v25) = 0;
      }
      else
      {
        size_t v27 = *(unint64_t **)(a1 + 200);
        unint64_t v28 = *v27;
        uint64_t v29 = 1;
        LODWORD(v25) = 0;
        do
        {
          unint64_t v30 = v27[v29];
          if (v28 > v30) {
            LODWORD(v25) = v29;
          }
          if (v28 >= v30) {
            unint64_t v28 = v27[v29];
          }
          ++v29;
        }
        while (*(_DWORD *)(a1 + 256) != v29);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 256) = v25 + 1;
    }
    uint64_t v31 = (int)v25;
    uint64_t v32 = v26 + 24 * (int)v25;
    if (v32 != a2)
    {
      char v33 = *(unsigned char *)(a2 + 23);
      if (*(char *)(v32 + 23) < 0)
      {
        if (v33 >= 0) {
          size_t v35 = (unsigned __int8 *)a2;
        }
        else {
          size_t v35 = *(unsigned __int8 **)a2;
        }
        if (v33 >= 0) {
          size_t v36 = *(unsigned __int8 *)(a2 + 23);
        }
        else {
          size_t v36 = *(void *)(a2 + 8);
        }
        sub_19E3C6D44((void **)v32, v35, v36);
      }
      else if ((*(unsigned char *)(a2 + 23) & 0x80) != 0)
      {
        sub_19E3C6C7C((void *)v32, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        long long v34 = *(_OWORD *)a2;
        *(void *)(v32 + 16) = *(void *)(a2 + 16);
        *(_OWORD *)uint64_t v32 = v34;
      }
    }
    CFNumberRef v19 = (double *)(*(void *)(a1 + 176) + 16 * v31);
    *(_DWORD *)CFNumberRef v19 = v21;
    v19[1] = v22;
    uint64_t v37 = *(void *)(a1 + 248) + 1;
    *(void *)(a1 + 248) = v37;
    *(void *)(*(void *)(a1 + 200) + 8 * v31) = v37;
  }
LABEL_57:
  uint64_t result = *(unsigned int *)v19;
  if (a3)
  {
    if (result) {
      *a3 = *((void *)v19 + 1);
    }
  }
  return result;
}

void sub_19E4200F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  if (v9) {
    CFRelease(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E42011C()
{
  uint64_t v2 = 0;
  uint64_t v3 = &v2;
  int v5 = 0;
  uint64_t v4 = 0x2000000000;
  LXLexiconEnumerateEntriesForString();
  uint64_t v0 = *((unsigned int *)v3 + 6);
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_19E4201C4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_19E4201DC(void *a1)
{
  sub_19E420214(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E420214(void *a1)
{
  *a1 = &unk_1EF0B9C50;
  uint64_t v2 = (void *)a1[28];
  if (v2)
  {
    a1[29] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[25];
  if (v3)
  {
    a1[26] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[22];
  if (v4)
  {
    a1[23] = v4;
    operator delete(v4);
  }
  uint64_t v5 = a1[19];
  if (v5)
  {
    uint64_t v6 = a1[20];
    uint64_t v7 = (void *)a1[19];
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0) {
          operator delete(*(void **)(v6 - 24));
        }
        v6 -= 24;
      }
      while (v6 != v5);
      uint64_t v7 = (void *)a1[19];
    }
    a1[20] = v5;
    operator delete(v7);
  }
  uint64_t v8 = (void *)a1[12];
  if (v8)
  {
    a1[13] = v8;
    operator delete(v8);
  }
  char v9 = (void *)a1[9];
  if (v9)
  {
    a1[10] = v9;
    operator delete(v9);
  }
  uint64_t v10 = (void *)a1[6];
  if (v10)
  {
    a1[7] = v10;
    operator delete(v10);
  }
  uint64_t v11 = a1[3];
  if (v11)
  {
    uint64_t v12 = a1[4];
    uint64_t v13 = (void *)a1[3];
    if (v12 != v11)
    {
      do
      {
        if (*(char *)(v12 - 1) < 0) {
          operator delete(*(void **)(v12 - 24));
        }
        v12 -= 24;
      }
      while (v12 != v11);
      uint64_t v13 = (void *)a1[3];
    }
    a1[4] = v11;
    operator delete(v13);
  }
  uint64_t v14 = (const void *)a1[2];
  if (v14) {
    CFRelease(v14);
  }
  a1[2] = 0;
  int v15 = (const void *)a1[1];
  if (v15) {
    CFRelease(v15);
  }
  a1[1] = 0;
  return a1;
}

__n128 sub_19E420378(std::string *a1, char *__s, std::string *a3)
{
  std::string::size_type v6 = strlen(__s);
  uint64_t v7 = (__n128 *)std::string::insert(a3, 0, __s, v6);
  __n128 result = *v7;
  *a1 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

uint64_t sub_19E4203DC()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009590, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC009590))
  {
    sub_19E382340(__p, "StaticTokenIDCacheSize");
    qword_1EC009460 = sub_19E4A00D8((uint64_t)__p);
    *(void *)&byte_1EC009468 = v2;
    if (v6 < 0) {
      operator delete(*(void **)__p);
    }
    __cxa_guard_release(&qword_1EC009590);
  }
  if (!byte_1EC009468) {
    return 100;
  }
  if (qword_1EC0095B8 != -1) {
    dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
  }
  uint64_t v0 = qword_1EC0095B0;
  if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = "StaticTokenIDCacheSize";
    __int16 v4 = 2048;
    uint64_t v5 = qword_1EC009460;
    _os_log_impl(&dword_19E36B000, v0, OS_LOG_TYPE_DEFAULT, "Setting configuration value %s=%zu (overridden by user preferences)", __p, 0x16u);
  }
  return qword_1EC009460;
}

void sub_19E420538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  __cxa_guard_abort(&qword_1EC009590);
  _Unwind_Resume(a1);
}

uint64_t sub_19E420568(uint64_t a1, unint64_t a2, uint64_t a3)
{
  char v6 = sub_19E373C28((void *)a1, a2);
  v6[3] = 0;
  v6[4] = 0;
  v6[5] = 0;
  if (a2)
  {
    if (a2 >> 62) {
      sub_19E37C7C4();
    }
    uint64_t v7 = (char *)operator new(4 * a2);
    *(void *)(a1 + 24) = v7;
    *(void *)(a1 + 40) = &v7[4 * a2];
    bzero(v7, 4 * a2);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 32) = &v7[4 * a2];
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 64) = 0;
    if (a2 >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v8 = (char *)operator new(8 * a2);
    *(void *)(a1 + 48) = v8;
    *(void *)(a1 + 64) = &v8[8 * a2];
    bzero(v8, 8 * a2);
    *(void *)(a1 + 56) = &v8[8 * a2];
  }
  else
  {
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v10 = *(unsigned char **)a3;
  char v9 = *(unsigned char **)(a3 + 8);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  int64_t v11 = v9 - v10;
  if (v9 != v10)
  {
    if (v11 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v12 = (char *)operator new(v9 - v10);
    *(void *)(a1 + 72) = v12;
    *(void *)(a1 + 80) = v12;
    uint64_t v13 = &v12[4 * (v11 >> 2)];
    *(void *)(a1 + 88) = v13;
    memmove(v12, v10, v11);
    *(void *)(a1 + 80) = v13;
  }
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  return a1;
}

void sub_19E4206C8(_Unwind_Exception *a1)
{
  char v6 = v4;
  uint64_t v8 = *v6;
  if (*v6)
  {
    *(void *)(v1 + 80) = v8;
    operator delete(v8);
    char v9 = *v3;
    if (!*v3)
    {
LABEL_3:
      uint64_t v10 = *v2;
      if (!*v2) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else
  {
    char v9 = *v3;
    if (!*v3) {
      goto LABEL_3;
    }
  }
  *uint64_t v5 = v9;
  operator delete(v9);
  uint64_t v10 = *v2;
  if (!*v2)
  {
LABEL_5:
    sub_19E3EB09C((void **)v1);
    _Unwind_Resume(a1);
  }
LABEL_4:
  *(void *)(v1 + 32) = v10;
  operator delete(v10);
  goto LABEL_5;
}

void sub_19E420734()
{
  if (!*v0) {
    JUMPOUT(0x19E4206F0);
  }
  JUMPOUT(0x19E4206E8);
}

uint64_t sub_19E420744(uint64_t a1, unint64_t a2, char **a3)
{
  char v6 = sub_19E373C28((void *)a1, a2);
  v6[3] = 0;
  v6[4] = 0;
  v6[5] = 0;
  if (a2)
  {
    if (a2 >> 60) {
      sub_19E37C7C4();
    }
    uint64_t v7 = (char *)operator new(16 * a2);
    *(void *)(a1 + 24) = v7;
    *(void *)(a1 + 32) = v7;
    uint64_t v8 = &v7[16 * a2];
    *(void *)(a1 + 40) = v8;
    if (((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) != 0)
    {
      uint64_t v9 = ((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      uint64_t v10 = v7 + 16;
      uint64_t v11 = v9 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *((_DWORD *)v10 - 4) = 0;
        *(_DWORD *)uint64_t v10 = 0;
        *((void *)v10 - 1) = 0;
        *((void *)v10 + 1) = 0;
        v10 += 32;
        v11 -= 2;
      }
      while (v11);
      if (v9 == (v9 & 0x1FFFFFFFFFFFFFFELL)) {
        goto LABEL_9;
      }
      v7 += 16 * (v9 & 0x1FFFFFFFFFFFFFFELL);
    }
    do
    {
      *(_DWORD *)uint64_t v7 = 0;
      *((void *)v7 + 1) = 0;
      v7 += 16;
    }
    while (v7 != v8);
LABEL_9:
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 32) = v8;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    uint64_t v12 = (char *)operator new(8 * a2);
    *(void *)(a1 + 48) = v12;
    *(void *)(a1 + 64) = &v12[8 * a2];
    bzero(v12, 8 * a2);
    *(void *)(a1 + 56) = &v12[8 * a2];
    goto LABEL_11;
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
LABEL_11:
  uint64_t v13 = *a3;
  uint64_t v14 = a3[1];
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  uint64_t v15 = v14 - v13;
  if (v14 != v13)
  {
    if (v15 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v16 = operator new(v14 - v13);
    *(void *)(a1 + 72) = v16;
    *(void *)(a1 + 80) = v16;
    *(void *)(a1 + 88) = &v16[v15 >> 4];
    do
    {
      long long v17 = *(_OWORD *)v13;
      v13 += 16;
      *v16++ = v17;
    }
    while (v13 != v14);
    *(void *)(a1 + 80) = v16;
  }
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  return a1;
}

void sub_19E4208D0(_Unwind_Exception *a1)
{
  __int16 v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  sub_19E3EB09C((void **)v1);
  _Unwind_Resume(a1);
}

const void **sub_19E42093C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

uint64_t sub_19E420974(uint64_t a1, const void *a2, CFDictionaryRef *a3, CFDictionaryRef ***a4)
{
  *(void *)a1 = &unk_1EF0B9C50;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFURLRef Value = (const __CFURL *)CFDictionaryGetValue(*a3, @"URL");
  CFStringRef v10 = CFURLCopyFileSystemPath(Value, kCFURLPOSIXPathStyle);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72430], v10);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  uint64_t v12 = *a4;
  uint64_t v13 = a4[1];
  if (*a4 != v13)
  {
    do
    {
      CFURLRef v14 = (const __CFURL *)CFDictionaryGetValue(**v12, @"URL");
      CFStringRef v15 = CFURLCopyFileSystemPath(v14, kCFURLPOSIXPathStyle);
      CFArrayAppendValue(v11, v15);
      if (v15) {
        CFRelease(v15);
      }
      v12 += 2;
    }
    while (v12 != v13);
  }
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72438], v11);
  if (v11) {
    CFRelease(v11);
  }
  CFDictionaryRef v16 = *a3;
  long long v17 = (const void *)*MEMORY[0x1E4F72470];
  if (CFDictionaryContainsKey(v16, (const void *)*MEMORY[0x1E4F72470]))
  {
    uint64_t v18 = CFDictionaryGetValue(v16, v17);
    CFDictionaryAddValue(Mutable, v17, v18);
  }
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72458], a2);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72440], (const void *)*MEMORY[0x1E4F1CFD0]);
  uint64_t v19 = LXLexiconCreate();
  if (!v19)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v26 = (char *)operator new(0x20uLL);
    strcpy(v26, "Failed to create the lexicon");
    *(void *)exception = &unk_1EF0BD3F0;
    sub_19E39369C(exception + 8, v26, 0x1CuLL);
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  *(void *)(a1 + 8) = v19;
  *(void *)(a1 + 16) = 0;
  unint64_t v20 = sub_19E4203DC();
  memset(&v27, 0, sizeof(v27));
  sub_19E420568(a1 + 24, v20, (uint64_t)&v27);
  unint64_t v21 = sub_19E4203DC();
  memset(&v27, 0, sizeof(v27));
  sub_19E420744(a1 + 152, v21, &v27.__r_.__value_.__l.__data_);
  double v22 = *(const void **)(a1 + 16);
  *(_DWORD *)(a1 + 280) = 1;
  if (v22 != a2)
  {
    CFRetain(a2);
    size_t v23 = *(const void **)(a1 + 16);
    if (v23) {
      CFRelease(v23);
    }
    *(void *)(a1 + 16) = a2;
  }
  return a1;
}

void sub_19E420D3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  std::exception::~exception(v19);
  operator delete(v20);
  if (a17 < 0) {
    operator delete(__p);
  }
  __cxa_free_exception(v19);
  if (v18) {
    CFRelease(v18);
  }
  if (v17) {
    CFRelease(v17);
  }
  _Unwind_Resume(a1);
}

const void **sub_19E420F7C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

uint64_t sub_19E420FB4(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 32) + 8);
  unint64_t v4 = *(void *)(v3 + 24) + 1;
  *(void *)(v3 + 24) = v4;
  if (v4 <= *(void *)(result + 48))
  {
    uint64_t v5 = result;
    __n128 result = LXEntryGetProbability();
    *(void *)(*(void *)(*(void *)(v5 + 40) + 8) + 24) = v6;
  }
  else
  {
    *a3 = 1;
  }
  return result;
}

const void **sub_19E421014(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

void sub_19E42104C(void ***a1, void **a2, void **a3, size_t __sz)
{
  uint64_t v6 = a2;
  uint64_t v8 = (uint64_t)a1[2];
  uint64_t v9 = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)*a1) >> 3) < __sz)
  {
    if (v9)
    {
      CFStringRef v10 = a1[1];
      uint64_t v11 = *a1;
      if (v10 != v9)
      {
        do
        {
          if (*((char *)v10 - 1) < 0) {
            operator delete(*(v10 - 3));
          }
          v10 -= 3;
        }
        while (v10 != v9);
        uint64_t v11 = *a1;
      }
      a1[1] = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (__sz > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_70;
    }
    unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v24 = 2 * v23;
    if (2 * v23 <= __sz) {
      uint64_t v24 = __sz;
    }
    unint64_t v25 = v23 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v24;
    if (v25 > 0xAAAAAAAAAAAAAAALL) {
LABEL_70:
    }
      sub_19E37C7C4();
    uint64_t v26 = 3 * v25;
    uint64_t v9 = (void **)operator new(24 * v25);
    *a1 = v9;
    a1[1] = v9;
    a1[2] = &v9[v26];
    if (v6 != a3)
    {
      uint64_t v27 = 0;
      do
      {
        unint64_t v28 = (char *)&v9[v27];
        uint64_t v29 = &v6[v27];
        if (SHIBYTE(v6[v27 + 2]) < 0)
        {
          sub_19E39369C(&v9[v27], *v29, (unint64_t)v29[1]);
        }
        else
        {
          *(_OWORD *)unint64_t v28 = *(_OWORD *)v29;
          *((void *)v28 + 2) = v29[2];
        }
        v27 += 3;
      }
      while (&v6[v27] != a3);
      uint64_t v9 = (void **)((char *)v9 + v27 * 8);
    }
LABEL_55:
    a1[1] = v9;
    return;
  }
  uint64_t v12 = a1[1];
  if (0xAAAAAAAAAAAAAAABLL * (v12 - v9) >= __sz)
  {
    if (a2 != a3)
    {
      do
      {
        if (v6 != v9)
        {
          char v21 = *((unsigned char *)v6 + 23);
          if (*((char *)v9 + 23) < 0)
          {
            if (v21 >= 0) {
              uint64_t v19 = v6;
            }
            else {
              uint64_t v19 = *v6;
            }
            if (v21 >= 0) {
              size_t v20 = *((unsigned __int8 *)v6 + 23);
            }
            else {
              size_t v20 = (size_t)v6[1];
            }
            sub_19E3C6D44(v9, v19, v20);
          }
          else if ((*((unsigned char *)v6 + 23) & 0x80) != 0)
          {
            sub_19E3C6C7C(v9, *v6, (size_t)v6[1]);
          }
          else
          {
            long long v22 = *(_OWORD *)v6;
            _OWORD v9[2] = v6[2];
            *(_OWORD *)uint64_t v9 = v22;
          }
        }
        v6 += 3;
        v9 += 3;
      }
      while (v6 != a3);
      uint64_t v12 = a1[1];
    }
    while (v12 != v9)
    {
      if (*((char *)v12 - 1) < 0) {
        operator delete(*(v12 - 3));
      }
      v12 -= 3;
    }
    goto LABEL_55;
  }
  uint64_t v13 = &a2[v12 - v9];
  if (v12 != v9)
  {
    uint64_t v14 = 8 * (v12 - v9);
    do
    {
      if (v6 != v9)
      {
        char v17 = *((unsigned char *)v6 + 23);
        if (*((char *)v9 + 23) < 0)
        {
          if (v17 >= 0) {
            CFStringRef v15 = v6;
          }
          else {
            CFStringRef v15 = *v6;
          }
          if (v17 >= 0) {
            size_t v16 = *((unsigned __int8 *)v6 + 23);
          }
          else {
            size_t v16 = (size_t)v6[1];
          }
          sub_19E3C6D44(v9, v15, v16);
        }
        else if ((*((unsigned char *)v6 + 23) & 0x80) != 0)
        {
          sub_19E3C6C7C(v9, *v6, (size_t)v6[1]);
        }
        else
        {
          long long v18 = *(_OWORD *)v6;
          _OWORD v9[2] = v6[2];
          *(_OWORD *)uint64_t v9 = v18;
        }
      }
      v6 += 3;
      v9 += 3;
      v14 -= 24;
    }
    while (v14);
    uint64_t v9 = a1[1];
  }
  unint64_t v30 = (char *)v9;
  if (v13 != a3)
  {
    uint64_t v31 = 0;
    do
    {
      char v33 = (char *)&v9[v31];
      long long v34 = &v13[v31];
      if (SHIBYTE(v13[v31 + 2]) < 0)
      {
        sub_19E39369C(&v9[v31], *v34, (unint64_t)v34[1]);
      }
      else
      {
        long long v32 = *(_OWORD *)v34;
        *((void *)v33 + 2) = v34[2];
        *(_OWORD *)char v33 = v32;
      }
      v31 += 3;
    }
    while (&v13[v31] != a3);
    unint64_t v30 = (char *)&v9[v31];
  }
  a1[1] = (void **)v30;
}

void sub_19E4213CC(uint64_t a1, uint64_t *a2, const void **a3, int a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v9 = *a2;
  uint64_t v8 = a2[1];
  if (*a2 != v8)
  {
    while (1)
    {
      uint64_t v10 = *(unsigned __int8 *)(v9 + 23);
      int v11 = (char)v10;
      if ((v10 & 0x80u) != 0) {
        uint64_t v10 = *(void *)(v9 + 8);
      }
      if (v10 == 2)
      {
        uint64_t v12 = v11 >= 0 ? (_WORD *)v9 : *(_WORD **)v9;
        if (*v12 == 28261) {
          break;
        }
      }
      v9 += 24;
      if (v9 == v8) {
        goto LABEL_60;
      }
    }
  }
  if (v9 != v8)
  {
    int v13 = *((char *)a3 + 23);
    size_t v14 = v13 >= 0 ? *((unsigned __int8 *)a3 + 23) : (size_t)a3[1];
    if (v14)
    {
      unint64_t v15 = v14 + 2;
      if (v14 + 2 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      if (v15 > 0x16)
      {
        uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v15 | 7) != 0x17) {
          uint64_t v17 = v15 | 7;
        }
        uint64_t v18 = v17 + 1;
        p_dst = (long long *)operator new(v17 + 1);
        *((void *)&__dst + 1) = v14 + 2;
        unint64_t v136 = v18 | 0x8000000000000000;
        *(void *)&long long __dst = p_dst;
      }
      else
      {
        unint64_t v136 = 0;
        long long __dst = 0uLL;
        p_dst = &__dst;
        HIBYTE(v136) = v14 + 2;
      }
      if (v13 >= 0) {
        uint64_t v19 = a3;
      }
      else {
        uint64_t v19 = *a3;
      }
      memmove(p_dst, v19, v14);
      strcpy((char *)p_dst + v14, "'s");
      size_t v20 = sub_19E3EB1B8((void **)a1, (uint64_t)&__dst);
      int v21 = SHIBYTE(v136);
      *(void *)(a1 + 8) = v20;
      if (v21 < 0)
      {
        operator delete((void *)__dst);
        if (a4 != 69) {
          goto LABEL_60;
        }
      }
      else if (a4 != 69)
      {
        goto LABEL_60;
      }
      unsigned int v22 = *((unsigned __int8 *)a3 + 23);
      if (*((char *)a3 + 23) < 0)
      {
        unint64_t v25 = (unint64_t)a3[1];
        if (!v25) {
          goto LABEL_60;
        }
        uint64_t v24 = (char *)*a3;
        unsigned int v26 = *((char *)*a3 + v25 - 1) - 115;
        if (v26 <= 7 && ((1 << v26) & 0xA1) != 0) {
          goto LABEL_60;
        }
        if (v25 < 2)
        {
LABEL_42:
          int v27 = (char)v22;
          if ((v22 & 0x80u) == 0) {
            size_t v28 = *((unsigned __int8 *)a3 + 23);
          }
          else {
            size_t v28 = (size_t)a3[1];
          }
          unint64_t v29 = v28 + 1;
          if (v28 + 1 > 0x7FFFFFFFFFFFFFF7) {
            sub_19E37C958();
          }
          if (v29 >= 0x17)
          {
            uint64_t v31 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v29 | 7) != 0x17) {
              uint64_t v31 = v29 | 7;
            }
            uint64_t v32 = v31 + 1;
            unint64_t v30 = (long long *)operator new(v31 + 1);
            *((void *)&__dst + 1) = v28 + 1;
            unint64_t v136 = v32 | 0x8000000000000000;
            *(void *)&long long __dst = v30;
          }
          else
          {
            unint64_t v136 = 0;
            long long __dst = 0uLL;
            unint64_t v30 = &__dst;
            HIBYTE(v136) = v28 + 1;
            if (!v28) {
              goto LABEL_56;
            }
          }
          if (v27 >= 0) {
            char v33 = a3;
          }
          else {
            char v33 = *a3;
          }
          memmove(v30, v33, v28);
LABEL_56:
          *(_WORD *)((char *)v30 + v28) = 115;
          unint64_t v34 = *(void *)(a1 + 8);
          if (v34 >= *(void *)(a1 + 16))
          {
            size_t v36 = sub_19E3EB1B8((void **)a1, (uint64_t)&__dst);
            int v37 = SHIBYTE(v136);
            *(void *)(a1 + 8) = v36;
            if (v37 < 0) {
              operator delete((void *)__dst);
            }
          }
          else
          {
            long long v35 = __dst;
            *(void *)(v34 + 16) = v136;
            *(_OWORD *)unint64_t v34 = v35;
            *(void *)(a1 + 8) = v34 + 24;
          }
          goto LABEL_60;
        }
      }
      else
      {
        if (!*((unsigned char *)a3 + 23)) {
          goto LABEL_60;
        }
        unsigned int v23 = *((unsigned __int8 *)a3 + *((unsigned __int8 *)a3 + 23) - 1) - 115;
        if (v23 <= 7 && ((1 << v23) & 0xA1) != 0) {
          goto LABEL_60;
        }
        uint64_t v24 = (char *)a3;
        unint64_t v25 = *((unsigned __int8 *)a3 + 23);
        if (v22 < 2) {
          goto LABEL_42;
        }
      }
      if (*(_WORD *)&v24[v25 - 2] == 26739) {
        goto LABEL_60;
      }
      goto LABEL_42;
    }
  }
LABEL_60:
  uint64_t v39 = *a2;
  uint64_t v38 = a2[1];
  if (*a2 != v38)
  {
    while (1)
    {
      uint64_t v40 = *(unsigned __int8 *)(v39 + 23);
      int v41 = (char)v40;
      if ((v40 & 0x80u) != 0) {
        uint64_t v40 = *(void *)(v39 + 8);
      }
      if (v40 == 2)
      {
        uint64_t v42 = v41 >= 0 ? (_WORD *)v39 : *(_WORD **)v39;
        if (*v42 == 29300) {
          break;
        }
      }
      v39 += 24;
      if (v39 == v38) {
        return;
      }
    }
  }
  if (v39 != v38)
  {
    if (*((char *)a3 + 23) < 0)
    {
      if ((unint64_t)a3[1] <= 1) {
        return;
      }
      int v43 = (const char *)*a3;
    }
    else
    {
      if (*((unsigned __int8 *)a3 + 23) < 2u) {
        return;
      }
      int v43 = (const char *)a3;
    }
    CFStringRef v145 = CFStringCreateWithCString(0, v43, 0x8000100u);
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v145);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9459F60, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1E9459F60))
    {
      qword_1E9459F58 = (uint64_t)CFLocaleCreate(0, @"tr");
      __cxa_guard_release(&qword_1E9459F60);
    }
    CFStringRef v44 = MutableCopy;
    CFStringLowercase(MutableCopy, (CFLocaleRef)qword_1E9459F58);
    CFIndex Length = CFStringGetLength(v44);
    CFStringRef theString = v44;
    uint64_t v140 = 0;
    CFIndex v141 = Length;
    CharactersPtr = CFStringGetCharactersPtr(v44);
    if (CharactersPtr) {
      CStringPtr = 0;
    }
    else {
      CStringPtr = CFStringGetCStringPtr(v44, 0x600u);
    }
    uint64_t v142 = 0;
    uint64_t v143 = 0;
    int v139 = CStringPtr;
    unint64_t v47 = Length - 1;
    if (Length >= 1 && (uint64_t v48 = v141, v141 >= Length))
    {
      if (CharactersPtr)
      {
        UniChar v49 = CharactersPtr[v140 + v47];
      }
      else if (CStringPtr)
      {
        UniChar v49 = CStringPtr[v140 + v47];
      }
      else
      {
        CFIndex v50 = Length - 5;
        if ((unint64_t)Length < 5) {
          CFIndex v50 = 0;
        }
        if (v50 + 64 < v141) {
          uint64_t v48 = v50 + 64;
        }
        uint64_t v142 = v50;
        uint64_t v143 = v48;
        v146.location = v140 + v50;
        v146.length = v48 - v50;
        CFStringGetCharacters(theString, v146, (UniChar *)&__dst);
        UniChar v49 = *((_WORD *)&__dst + v47 - v142);
      }
    }
    else
    {
      UniChar v49 = 0;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9459F70, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1E9459F70))
    {
      qword_1E9459F68 = (uint64_t)CFCharacterSetCreateWithCharactersInString(0, @"bcdfghjklmnprstvyz");
      __cxa_guard_release(&qword_1E9459F70);
    }
    int IsCharacterMember = CFCharacterSetIsCharacterMember((CFCharacterSetRef)qword_1E9459F68, v49);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9459F80, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1E9459F80))
    {
      qword_1E9459F78 = (uint64_t)CFCharacterSetCreateWithCharactersInString(0, @"aeiou");
      __cxa_guard_release(&qword_1E9459F80);
    }
    int v52 = CFCharacterSetIsCharacterMember((CFCharacterSetRef)qword_1E9459F78, v49);
    if (!(v52 | IsCharacterMember)) {
      goto LABEL_246;
    }
    int v124 = v52;
    size_t v132 = 0;
    uint64_t v133 = 0;
    uint64_t v134 = 0;
    std::string __p = 0;
    uint64_t v130 = 0;
    uint64_t v131 = 0;
    if (Length < 1) {
      goto LABEL_244;
    }
    CFIndex v53 = 1 - Length;
    CFIndex v54 = Length + 63;
    while (1)
    {
      uint64_t v55 = Length - 1;
      uint64_t v56 = v47 >= 4 ? 4 : v47;
      CFIndex v57 = v141;
      if (v141 <= v55)
      {
        UniChar v58 = 0;
      }
      else if (CharactersPtr)
      {
        UniChar v58 = CharactersPtr[Length - 1 + v140];
      }
      else if (v139)
      {
        UniChar v58 = v139[v140 - 1 + Length];
      }
      else
      {
        uint64_t v59 = v142;
        if (v143 <= v55 || v142 > v55)
        {
          uint64_t v61 = v56 + v53;
          CFIndex v62 = v54 - v56;
          CFIndex v63 = Length - v56;
          uint64_t v64 = v63 - 1;
          CFIndex v65 = v63 + 63;
          if (v65 >= v141) {
            CFIndex v65 = v141;
          }
          uint64_t v142 = v64;
          uint64_t v143 = v65;
          if (v141 >= v62) {
            CFIndex v57 = v62;
          }
          v147.length = v57 + v61;
          v147.location = v64 + v140;
          CFStringGetCharacters(theString, v147, (UniChar *)&__dst);
          uint64_t v59 = v142;
        }
        UniChar v58 = *((_WORD *)&v134 + Length - v59 + 3);
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9459F80, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1E9459F80))
      {
        qword_1E9459F78 = (uint64_t)CFCharacterSetCreateWithCharactersInString(0, @"aeiou");
        __cxa_guard_release(&qword_1E9459F80);
      }
      if (CFCharacterSetIsCharacterMember((CFCharacterSetRef)qword_1E9459F78, v58)) {
        break;
      }
      --v47;
      ++v53;
      --v54;
      CFIndex Length = v55;
      if (v55 <= 0) {
        goto LABEL_244;
      }
    }
    if (v58 > 0xF5u)
    {
      int v66 = (char *)&__p + 1;
      if (v58 == 246 || v58 == 252)
      {
        if (SHIBYTE(v134) < 0)
        {
          uint64_t v133 = 2;
          unint64_t v70 = v132;
        }
        else
        {
          HIBYTE(v134) = 2;
          unint64_t v70 = &v132;
        }
        *(_WORD *)unint64_t v70 = -17213;
        v70[2] = 0;
LABEL_149:
        if (SHIBYTE(v131) < 0)
        {
          uint64_t v130 = 1;
          p_p = __p;
          int v66 = (char *)__p + 1;
        }
        else
        {
          HIBYTE(v131) = 1;
          p_p = &__p;
        }
        char v72 = 101;
      }
      else
      {
        if (v58 != 305) {
          goto LABEL_154;
        }
LABEL_131:
        if (SHIBYTE(v134) < 0)
        {
          uint64_t v133 = 2;
          size_t v68 = v132;
        }
        else
        {
          HIBYTE(v134) = 2;
          size_t v68 = &v132;
        }
        *(_WORD *)size_t v68 = -20028;
        v68[2] = 0;
LABEL_143:
        if (SHIBYTE(v131) < 0)
        {
          uint64_t v130 = 1;
          p_p = __p;
          int v66 = (char *)__p + 1;
        }
        else
        {
          HIBYTE(v131) = 1;
          p_p = &__p;
        }
        char v72 = 97;
      }
      unsigned char *p_p = v72;
      *int v66 = 0;
    }
    else
    {
      int v66 = (char *)&__p + 1;
      switch(v58)
      {
        case 'a':
          goto LABEL_131;
        case 'e':
        case 'i':
          if (SHIBYTE(v134) < 0)
          {
            uint64_t v133 = 1;
            int v67 = v132;
          }
          else
          {
            HIBYTE(v134) = 1;
            int v67 = &v132;
          }
          _WORD *v67 = 105;
          goto LABEL_149;
        case 'o':
        case 'u':
          if (SHIBYTE(v134) < 0)
          {
            uint64_t v133 = 1;
            unint64_t v69 = v132;
          }
          else
          {
            HIBYTE(v134) = 1;
            unint64_t v69 = &v132;
          }
          *unint64_t v69 = 117;
          goto LABEL_143;
        default:
          break;
      }
    }
LABEL_154:
    int v73 = *((char *)a3 + 23);
    if (v73 >= 0) {
      size_t v74 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      size_t v74 = (size_t)a3[1];
    }
    unint64_t v75 = v74 + 1;
    if (v74 + 1 > 0x7FFFFFFFFFFFFFF7) {
      sub_19E37C958();
    }
    if (v75 >= 0x17)
    {
      uint64_t v77 = (v75 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v75 | 7) != 0x17) {
        uint64_t v77 = v75 | 7;
      }
      uint64_t v78 = v77 + 1;
      double v76 = (char *)operator new(v77 + 1);
      v126.__r_.__value_.__l.__size_ = v74 + 1;
      v126.__r_.__value_.__r.__words[2] = v78 | 0x8000000000000000;
      v126.__r_.__value_.__r.__words[0] = (std::string::size_type)v76;
    }
    else
    {
      memset(&v126, 0, sizeof(v126));
      double v76 = (char *)&v126;
      *((unsigned char *)&v126.__r_.__value_.__s + 23) = v74 + 1;
      if (!v74) {
        goto LABEL_168;
      }
    }
    if (v73 >= 0) {
      uint64_t v79 = a3;
    }
    else {
      uint64_t v79 = *a3;
    }
    memmove(v76, v79, v74);
LABEL_168:
    *(_WORD *)&v76[v74] = 39;
    std::string::size_type v80 = v124 != 0;
    if (v124) {
      long long v81 = "y";
    }
    else {
      long long v81 = "";
    }
    uint64_t v82 = std::string::append(&v126, v81, v80);
    long long v83 = *(_OWORD *)&v82->__r_.__value_.__l.__data_;
    v127.__r_.__value_.__r.__words[2] = v82->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v127.__r_.__value_.__l.__data_ = v83;
    v82->__r_.__value_.__l.__size_ = 0;
    v82->__r_.__value_.__r.__words[2] = 0;
    v82->__r_.__value_.__r.__words[0] = 0;
    if (v134 >= 0) {
      uint64_t v84 = (const std::string::value_type *)&v132;
    }
    else {
      uint64_t v84 = (const std::string::value_type *)v132;
    }
    if (v134 >= 0) {
      std::string::size_type v85 = HIBYTE(v134);
    }
    else {
      std::string::size_type v85 = v133;
    }
    unsigned __int8 v86 = std::string::append(&v127, v84, v85);
    std::string v128 = *v86;
    v86->__r_.__value_.__l.__size_ = 0;
    v86->__r_.__value_.__r.__words[2] = 0;
    v86->__r_.__value_.__r.__words[0] = 0;
    uint64_t v87 = *(std::string **)(a1 + 8);
    if ((unint64_t)v87 < *(void *)(a1 + 16))
    {
      std::string *v87 = v128;
      *(void *)(a1 + 8) = v87 + 1;
      if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_179;
      }
LABEL_183:
      if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_184:
        int v90 = *((char *)a3 + 23);
        if (v90 >= 0) {
          size_t v91 = *((unsigned __int8 *)a3 + 23);
        }
        else {
          size_t v91 = (size_t)a3[1];
        }
        unint64_t v92 = v91 + 1;
        if (v91 + 1 > 0x7FFFFFFFFFFFFFF7) {
          sub_19E37C958();
        }
        if (v92 >= 0x17)
        {
          uint64_t v94 = (v92 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v92 | 7) != 0x17) {
            uint64_t v94 = v92 | 7;
          }
          uint64_t v95 = v94 + 1;
          int32x2_t v93 = (char *)operator new(v94 + 1);
          v126.__r_.__value_.__l.__size_ = v91 + 1;
          v126.__r_.__value_.__r.__words[2] = v95 | 0x8000000000000000;
          v126.__r_.__value_.__r.__words[0] = (std::string::size_type)v93;
        }
        else
        {
          memset(&v126, 0, sizeof(v126));
          int32x2_t v93 = (char *)&v126;
          *((unsigned char *)&v126.__r_.__value_.__s + 23) = v91 + 1;
          if (!v91) {
            goto LABEL_198;
          }
        }
        if (v90 >= 0) {
          char v96 = a3;
        }
        else {
          char v96 = *a3;
        }
        memmove(v93, v96, v91);
LABEL_198:
        *(_WORD *)&v93[v91] = 39;
        unint64_t v97 = std::string::append(&v126, v81, v80);
        long long v98 = *(_OWORD *)&v97->__r_.__value_.__l.__data_;
        v127.__r_.__value_.__r.__words[2] = v97->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v127.__r_.__value_.__l.__data_ = v98;
        v97->__r_.__value_.__l.__size_ = 0;
        v97->__r_.__value_.__r.__words[2] = 0;
        v97->__r_.__value_.__r.__words[0] = 0;
        if (v131 >= 0) {
          size_t v99 = (const std::string::value_type *)&__p;
        }
        else {
          size_t v99 = (const std::string::value_type *)__p;
        }
        if (v131 >= 0) {
          std::string::size_type v100 = HIBYTE(v131);
        }
        else {
          std::string::size_type v100 = v130;
        }
        __int16 v101 = std::string::append(&v127, v99, v100);
        std::string v128 = *v101;
        v101->__r_.__value_.__l.__size_ = 0;
        v101->__r_.__value_.__r.__words[2] = 0;
        v101->__r_.__value_.__r.__words[0] = 0;
        uint64_t v102 = *(std::string **)(a1 + 8);
        if ((unint64_t)v102 < *(void *)(a1 + 16))
        {
          *uint64_t v102 = v128;
          *(void *)(a1 + 8) = v102 + 1;
          if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
            goto LABEL_206;
          }
LABEL_210:
          if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_211:
            int v105 = *((char *)a3 + 23);
            if (v105 >= 0) {
              size_t v106 = *((unsigned __int8 *)a3 + 23);
            }
            else {
              size_t v106 = (size_t)a3[1];
            }
            unint64_t v107 = v106 + 1;
            if (v106 + 1 > 0x7FFFFFFFFFFFFFF7) {
              sub_19E37C958();
            }
            if (v107 >= 0x17)
            {
              uint64_t v109 = (v107 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v107 | 7) != 0x17) {
                uint64_t v109 = v107 | 7;
              }
              uint64_t v110 = v109 + 1;
              uint64_t v108 = (char *)operator new(v109 + 1);
              v125.__r_.__value_.__l.__size_ = v106 + 1;
              v125.__r_.__value_.__r.__words[2] = v110 | 0x8000000000000000;
              v125.__r_.__value_.__r.__words[0] = (std::string::size_type)v108;
            }
            else
            {
              memset(&v125, 0, sizeof(v125));
              uint64_t v108 = (char *)&v125;
              *((unsigned char *)&v125.__r_.__value_.__s + 23) = v106 + 1;
              if (!v106) {
                goto LABEL_225;
              }
            }
            if (v105 >= 0) {
              unsigned int v111 = a3;
            }
            else {
              unsigned int v111 = *a3;
            }
            memmove(v108, v111, v106);
LABEL_225:
            *(_WORD *)&v108[v106] = 39;
            if (v124) {
              int v112 = "n";
            }
            else {
              int v112 = "";
            }
            uint64_t v113 = std::string::append(&v125, v112, v80);
            long long v114 = *(_OWORD *)&v113->__r_.__value_.__l.__data_;
            v126.__r_.__value_.__r.__words[2] = v113->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v126.__r_.__value_.__l.__data_ = v114;
            v113->__r_.__value_.__l.__size_ = 0;
            v113->__r_.__value_.__r.__words[2] = 0;
            v113->__r_.__value_.__r.__words[0] = 0;
            if (v134 >= 0) {
              int32x2_t v115 = (const std::string::value_type *)&v132;
            }
            else {
              int32x2_t v115 = (const std::string::value_type *)v132;
            }
            if (v134 >= 0) {
              std::string::size_type v116 = HIBYTE(v134);
            }
            else {
              std::string::size_type v116 = v133;
            }
            int v117 = std::string::append(&v126, v115, v116);
            long long v118 = *(_OWORD *)&v117->__r_.__value_.__l.__data_;
            v127.__r_.__value_.__r.__words[2] = v117->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v127.__r_.__value_.__l.__data_ = v118;
            v117->__r_.__value_.__l.__size_ = 0;
            v117->__r_.__value_.__r.__words[2] = 0;
            v117->__r_.__value_.__r.__words[0] = 0;
            uint64_t v119 = std::string::append(&v127, "n", 1uLL);
            std::string v128 = *v119;
            v119->__r_.__value_.__l.__size_ = 0;
            v119->__r_.__value_.__r.__words[2] = 0;
            v119->__r_.__value_.__r.__words[0] = 0;
            unint64_t v120 = *(std::string **)(a1 + 8);
            if ((unint64_t)v120 < *(void *)(a1 + 16))
            {
              *unint64_t v120 = v128;
              *(void *)(a1 + 8) = v120 + 1;
              if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
                goto LABEL_236;
              }
LABEL_242:
              if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
              {
LABEL_237:
                operator delete(v126.__r_.__value_.__l.__data_);
                if (SHIBYTE(v125.__r_.__value_.__r.__words[2]) < 0) {
                  goto LABEL_238;
                }
                goto LABEL_244;
              }
LABEL_243:
              if (SHIBYTE(v125.__r_.__value_.__r.__words[2]) < 0)
              {
LABEL_238:
                operator delete(v125.__r_.__value_.__l.__data_);
                if (SHIBYTE(v131) < 0)
                {
LABEL_251:
                  operator delete(__p);
                  if (SHIBYTE(v134) < 0)
                  {
LABEL_252:
                    operator delete(v132);
                    CFMutableStringRef v123 = MutableCopy;
                    if (!MutableCopy)
                    {
LABEL_248:
                      if (v145) {
                        CFRelease(v145);
                      }
                      return;
                    }
LABEL_247:
                    CFRelease(v123);
                    goto LABEL_248;
                  }
LABEL_246:
                  CFMutableStringRef v123 = MutableCopy;
                  if (!MutableCopy) {
                    goto LABEL_248;
                  }
                  goto LABEL_247;
                }
LABEL_245:
                if (SHIBYTE(v134) < 0) {
                  goto LABEL_252;
                }
                goto LABEL_246;
              }
LABEL_244:
              if (SHIBYTE(v131) < 0) {
                goto LABEL_251;
              }
              goto LABEL_245;
            }
            unint64_t v121 = sub_19E3EB1B8((void **)a1, (uint64_t)&v128);
            int v122 = SHIBYTE(v128.__r_.__value_.__r.__words[2]);
            *(void *)(a1 + 8) = v121;
            if (v122 < 0)
            {
              operator delete(v128.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_242;
              }
            }
            else if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_242;
            }
LABEL_236:
            operator delete(v127.__r_.__value_.__l.__data_);
            if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
              goto LABEL_237;
            }
            goto LABEL_243;
          }
LABEL_207:
          operator delete(v126.__r_.__value_.__l.__data_);
          goto LABEL_211;
        }
        int v103 = sub_19E3EB1B8((void **)a1, (uint64_t)&v128);
        int v104 = SHIBYTE(v128.__r_.__value_.__r.__words[2]);
        *(void *)(a1 + 8) = v103;
        if (v104 < 0)
        {
          operator delete(v128.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_210;
          }
        }
        else if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_210;
        }
LABEL_206:
        operator delete(v127.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_211;
        }
        goto LABEL_207;
      }
LABEL_180:
      operator delete(v126.__r_.__value_.__l.__data_);
      goto LABEL_184;
    }
    unsigned __int8 v88 = sub_19E3EB1B8((void **)a1, (uint64_t)&v128);
    int v89 = SHIBYTE(v128.__r_.__value_.__r.__words[2]);
    *(void *)(a1 + 8) = v88;
    if (v89 < 0)
    {
      operator delete(v128.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_183;
      }
    }
    else if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_183;
    }
LABEL_179:
    operator delete(v127.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_184;
    }
    goto LABEL_180;
  }
}

void sub_19E4221C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  __cxa_guard_abort(&qword_1E9459F80);
  sub_19E422428((const void **)(v57 - 104));
  sub_19E3DCC24((const void **)(v57 - 96));
  sub_19E3EB09C(v56);
  _Unwind_Resume(a1);
}

const void **sub_19E422428(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

void sub_19E422460()
{
}

uint64_t sub_19E42248C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v2 = (uint64_t (*)(uint64_t))off_1E9459F98;
  uint64_t v9 = off_1E9459F98;
  if (!off_1E9459F98)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = sub_19E422578;
    v5[3] = &unk_1E599F6D0;
    v5[4] = &v6;
    sub_19E422578((uint64_t)v5);
    uint64_t v2 = (uint64_t (*)(uint64_t))v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (!v2)
  {
    dlerror();
    unint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v6, 8);
    _Unwind_Resume(v4);
  }
  return v2(v1);
}

void *sub_19E422578(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  __n128 result = dlsym(v2, "MRLModelReset");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E9459F98 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E4226B8()
{
  uint64_t result = _sl_dlopen();
  qword_1EC0092F8 = result;
  return result;
}

uint64_t sub_19E42272C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v2 = (uint64_t (*)(uint64_t))off_1E9459F90;
  uint64_t v9 = off_1E9459F90;
  if (!off_1E9459F90)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = sub_19E422818;
    v5[3] = &unk_1E599F6A8;
    v5[4] = &v6;
    sub_19E422818((uint64_t)v5);
    uint64_t v2 = (uint64_t (*)(uint64_t))v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (!v2)
  {
    dlerror();
    unint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v6, 8);
    _Unwind_Resume(v4);
  }
  return v2(v1);
}

void *sub_19E422818(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelUnlock");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E9459F90 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E422958(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v2 = (uint64_t (*)(uint64_t))off_1E9459F88;
  uint64_t v9 = off_1E9459F88;
  if (!off_1E9459F88)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = sub_19E422A44;
    v5[3] = &unk_1E599F680;
    v5[4] = &v6;
    sub_19E422A44((uint64_t)v5);
    uint64_t v2 = (uint64_t (*)(uint64_t))v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (!v2)
  {
    dlerror();
    unint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v6, 8);
    _Unwind_Resume(v4);
  }
  return v2(v1);
}

void *sub_19E422A44(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelLock");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E9459F88 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_19E422B84(void *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v13 = 0;
  size_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v3 = (uint64_t (*)(uint64_t))off_1E9459E30;
  size_t v16 = off_1E9459E30;
  if (!off_1E9459E30)
  {
    uint64_t v8 = MEMORY[0x1E4F143A8];
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_19E422DF0;
    int v11 = &unk_1E599F608;
    uint64_t v12 = &v13;
    sub_19E422DF0((uint64_t)&v8);
    uint64_t v3 = (uint64_t (*)(uint64_t))v14[3];
  }
  _Block_object_dispose(&v13, 8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = v3(v2);
  uint64_t v5 = a1[3];
  uint64_t v13 = 0;
  size_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  long long v6 = (void (*)(uint64_t, uint64_t, uint64_t))off_1E9459E28;
  size_t v16 = off_1E9459E28;
  if (!off_1E9459E28)
  {
    uint64_t v8 = MEMORY[0x1E4F143A8];
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_19E422F30;
    int v11 = &unk_1E599F630;
    uint64_t v12 = &v13;
    sub_19E422F30((uint64_t)&v8);
    long long v6 = (void (*)(uint64_t, uint64_t, uint64_t))v14[3];
  }
  _Block_object_dispose(&v13, 8);
  if (v6)
  {
    v6(v5, v4, 1);
    uint64_t v7 = (std::__shared_weak_count *)a1[2];
    uint64_t v8 = a1[1];
    if (v7)
    {
      uint64_t v9 = (uint64_t)std::__shared_weak_count::lock(v7);
      if (v9) {
        operator new();
      }
    }
  }
  else
  {
LABEL_10:
    dlerror();
    abort_report_np();
  }
  sub_19E3FDEBC();
}

void sub_19E422DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19E422DDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3D73EC((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_19E422DF0(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelStateCreate");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E9459E30 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E422F30(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelStateSave");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E9459E28 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E423070(uint64_t a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = a2;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v22 = a3;
  if (a6)
  {
    LODWORD(v8) = a4;
    if (a4 >= 6)
    {
      if (qword_1EC0095B8 == -1) {
        goto LABEL_31;
      }
      goto LABEL_34;
    }
    int v9 = a6;
    int v21 = dword_19E575608[a4];
    uint64_t v8 = *(void *)(a1 + 24);
    if (a2) {
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    }
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v23 = 0;
    uint64_t v24 = &v23;
    uint64_t v25 = 0x2000000000;
    uint64_t v12 = (void (*)(uint64_t, uint64_t, int *, uint64_t, uint64_t, int *, uint64_t, uint64_t, int))off_1E9459E48;
    unsigned int v26 = off_1E9459E48;
    if (!off_1E9459E48)
    {
      *(void *)buf = MEMORY[0x1E4F143A8];
      uint64_t v28 = 0x40000000;
      unint64_t v29 = sub_19E423640;
      unint64_t v30 = &unk_1E599F5E0;
      uint64_t v31 = &v23;
      sub_19E423640((uint64_t)buf);
      uint64_t v12 = (void (*)(uint64_t, uint64_t, int *, uint64_t, uint64_t, int *, uint64_t, uint64_t, int))v24[3];
    }
    _Block_object_dispose(&v23, 8);
    if (v12)
    {
      v12(v8, v6, &v22, 1, v11, &v21, 1, a5, v9);
      return *(void *)(a1 + 32);
    }
LABEL_26:
    dlerror();
    abort_report_np();
    __break(1u);
LABEL_34:
    dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
LABEL_31:
    size_t v20 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v8;
      _os_log_error_impl(&dword_19E36B000, v20, OS_LOG_TYPE_ERROR, "unknown neural network output class: %d", buf, 8u);
    }
    __assert_rtn("convert", "LegacyMontreal.cpp", 80, "false");
  }
  if (qword_1EC009570 != -1) {
    dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
  }
  os_signpost_id_t v13 = os_signpost_id_generate((os_log_t)qword_1EC009568);
  if (qword_1EC009570 != -1) {
    dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
  }
  unint64_t v14 = v13 - 1;
  if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v15 = qword_1EC009568;
    if (os_signpost_enabled((os_log_t)qword_1EC009568))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_19E36B000, v15, OS_SIGNPOST_INTERVAL_BEGIN, v13, "MontrealRecognizeIncremental", (const char *)&unk_19E5812E5, buf, 2u);
    }
  }
  uint64_t v16 = *(void *)(a1 + 24);
  if (v6) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  }
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  uint64_t v17 = (void (*)(uint64_t, uint64_t, int *, uint64_t, uint64_t))off_1E9459E40;
  unsigned int v26 = off_1E9459E40;
  if (!off_1E9459E40)
  {
    *(void *)buf = MEMORY[0x1E4F143A8];
    uint64_t v28 = 0x40000000;
    unint64_t v29 = sub_19E423500;
    unint64_t v30 = &unk_1E599F5B8;
    uint64_t v31 = &v23;
    sub_19E423500((uint64_t)buf);
    uint64_t v17 = (void (*)(uint64_t, uint64_t, int *, uint64_t, uint64_t))v24[3];
  }
  _Block_object_dispose(&v23, 8);
  if (!v17) {
    goto LABEL_26;
  }
  v17(v16, v6, &v22, 1, v8);
  if (qword_1EC009570 == -1)
  {
    if (v14 > 0xFFFFFFFFFFFFFFFDLL) {
      return *(void *)(a1 + 32);
    }
  }
  else
  {
    dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
    if (v14 > 0xFFFFFFFFFFFFFFFDLL) {
      return *(void *)(a1 + 32);
    }
  }
  uint64_t v18 = qword_1EC009568;
  if (os_signpost_enabled((os_log_t)qword_1EC009568))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_19E36B000, v18, OS_SIGNPOST_INTERVAL_END, v13, "MontrealRecognizeIncremental", (const char *)&unk_19E5812E5, buf, 2u);
  }
  return *(void *)(a1 + 32);
}

void sub_19E4234E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *sub_19E423500(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelRecognizeIncremental");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E9459E40 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E423640(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelRecognizeIncrementalClassPlusSuffixIds");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E9459E48 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E423780(uint64_t a1)
{
  return sub_19E423788(*(void *)(a1 + 24));
}

uint64_t sub_19E423788(uint64_t a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v2 = (uint64_t (*)(uint64_t))off_1EC009308;
  int v9 = off_1EC009308;
  if (!off_1EC009308)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = sub_19E423874;
    v5[3] = &unk_1E599F568;
    v5[4] = &v6;
    sub_19E423874((uint64_t)v5);
    uint64_t v2 = (uint64_t (*)(uint64_t))v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (!v2)
  {
    dlerror();
    uint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v6, 8);
    _Unwind_Resume(v4);
  }
  return v2(a1);
}

void *sub_19E423874(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelGetOutputSize");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC009308 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_19E4239B4(void *a1)
{
  sub_19E4239EC(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E4239EC(void *a1)
{
  *a1 = &unk_1EF0B9DF0;
  uint64_t v2 = a1[3];
  uint64_t v8 = 0;
  int v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v3 = (void (*)(uint64_t))off_1EC0092E0;
  uint64_t v11 = off_1EC0092E0;
  if (!off_1EC0092E0)
  {
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    void v7[2] = sub_19E423B28;
    v7[3] = &unk_1E599F590;
    v7[4] = &v8;
    sub_19E423B28((uint64_t)v7);
    uint64_t v3 = (void (*)(uint64_t))v9[3];
  }
  _Block_object_dispose(&v8, 8);
  if (v3)
  {
    v3(v2);
    uint64_t v4 = (void *)a1[4];
    if (v4)
    {
      a1[5] = v4;
      operator delete(v4);
    }
    uint64_t v5 = (std::__shared_weak_count *)a1[2];
    if (v5) {
      std::__shared_weak_count::__release_weak(v5);
    }
    return (uint64_t)a1;
  }
  else
  {
    dlerror();
    uint64_t result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_19E423B0C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  sub_19E37B770(a1);
}

void *sub_19E423B28(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelRelease");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0092E0 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E423C6C(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "kMRLModelFileLocationKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_1EC009310 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E423DAC(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelCreate");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC009300 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_19E423EEC(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  long long v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 2)
  {
    if (a2)
    {
      bzero(v5, 4 * a2);
      long long v6 = &v5[4 * a2];
    }
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    uint64_t v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v9 = v8 >> 2;
    unint64_t v10 = (v8 >> 2) + a2;
    if (v10 >> 62) {
      sub_19E37C7C4();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        sub_19E37C2B8();
      }
      os_signpost_id_t v13 = operator new(4 * v12);
    }
    else
    {
      os_signpost_id_t v13 = 0;
    }
    unint64_t v14 = &v13[4 * v9];
    size_t v15 = 4 * a2;
    uint64_t v16 = &v13[4 * v12];
    bzero(v14, v15);
    uint64_t v17 = &v14[v15];
    if (v5 != v7)
    {
      unint64_t v18 = v5 - v7 - 4;
      if (v18 < 0x2C) {
        goto LABEL_31;
      }
      if ((unint64_t)(v5 - v13 - v8) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v19 = (v18 >> 2) + 1;
      long long v6 = &v5[-4 * (v19 & 0x7FFFFFFFFFFFFFF8)];
      size_t v20 = &v13[4 * v9 - 16];
      int v21 = v5 - 16;
      uint64_t v22 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        *size_t v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 8;
      }
      while (v22);
      v14 -= 4 * (v19 & 0x7FFFFFFFFFFFFFF8);
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_31:
        do
        {
          int v24 = *((_DWORD *)v6 - 1);
          v6 -= 4;
          *((_DWORD *)v14 - 1) = v24;
          v14 -= 4;
        }
        while (v6 != v7);
      }
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v17;
    *(void *)(a1 + 16) = v16;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void sub_19E4240A0(void *a1, uint64_t a2)
{
  uint64_t v14 = 0;
  size_t v15 = &v14;
  uint64_t v16 = 0x4002000000;
  uint64_t v17 = sub_19E424460;
  unint64_t v18 = sub_19E42447C;
  std::string __p = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  v13[2] = sub_19E424490;
  v13[3] = &unk_1E599F4B8;
  v13[4] = &v14;
  v13[5] = a2;
  *(void *)&long long v23 = 0;
  *((void *)&v23 + 1) = &v23;
  uint64_t v24 = 0x3802000000;
  uint64_t v25 = sub_19E424AA4;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  unsigned int v26 = sub_19E424AB4;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0092B0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v6 = a2;
    int v7 = __cxa_guard_acquire(&qword_1EC0092B0);
    a2 = v6;
    if (v7)
    {
      qword_1EC009318 = (uint64_t)dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
      __cxa_guard_release(&qword_1EC0092B0);
      a2 = v6;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0092F0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v8 = a2;
    int v9 = __cxa_guard_acquire(&qword_1EC0092F0);
    a2 = v8;
    if (v9)
    {
      qword_1EC009320 = (uint64_t)dispatch_queue_create("com.apple.NLPUtils.SingletonResourceManager", (dispatch_queue_attr_t)qword_1EC009318);
      __cxa_guard_release(&qword_1EC0092F0);
      a2 = v8;
    }
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = sub_19E424B30;
  block[3] = &unk_1E599F6F8;
  block[5] = &v23;
  block[6] = a2;
  block[4] = v13;
  dispatch_sync((dispatch_queue_t)qword_1EC009320, block);
  uint64_t v3 = *((void *)&v23 + 1);
  *a1 = *(void *)(*((void *)&v23 + 1) + 40);
  uint64_t v4 = *(void *)(v3 + 48);
  a1[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  _Block_object_dispose(&v23, 8);
  uint64_t v5 = v28;
  if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (!*a1)
  {
    unint64_t v10 = v15;
    if (*((char *)v15 + 63) < 0)
    {
      if (v15[6]) {
        goto LABEL_22;
      }
      v15[6] = 13;
      uint64_t v11 = (char *)v10[5];
    }
    else
    {
      if (*((unsigned char *)v15 + 63)) {
        goto LABEL_22;
      }
      uint64_t v11 = (char *)(v15 + 5);
      *((unsigned char *)v15 + 63) = 13;
    }
    strcpy(v11, "unknown error");
LABEL_22:
    exception = __cxa_allocate_exception(0x20uLL);
    std::operator+<char>();
    sub_19E3F5604(exception, &v23);
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
  }
  _Block_object_dispose(&v14, 8);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p);
  }
}

void sub_19E424404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (*(char *)(v30 - 81) < 0)
  {
    operator delete(*(void **)(v30 - 104));
    if ((v29 & 1) == 0)
    {
LABEL_6:
      sub_19E3D73EC(v27);
      _Block_object_dispose(&a17, 8);
      if (a27 < 0) {
        operator delete(__p);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

__n128 sub_19E424460(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_19E42447C(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void sub_19E424490()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_19E4248D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  int v37 = *v34;
  if (*v34)
  {
    *(void *)(v33 + 40) = v37;
    operator delete(v37);
  }
  uint64_t v38 = *(std::__shared_weak_count **)(v33 + 16);
  if (v38) {
    std::__shared_weak_count::__release_weak(v38);
  }
  MEMORY[0x19F3BDCF0](v33, 0xA1C40E92AFD59);
  if (a2 == 1)
  {
    uint64_t v39 = __cxa_begin_catch(a1);
    uint64_t v40 = (char *)(*(uint64_t (**)(void *))(*(void *)v39 + 16))(v39);
    sub_19E3F7C4C((void **)(*(void *)(*(void *)(v32 + 32) + 8) + 40), v40);
    __cxa_end_catch();
    JUMPOUT(0x19E424770);
  }
  _Unwind_Resume(a1);
}

void sub_19E424A88()
{
}

void sub_19E424A94(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x19E424A9CLL);
  }
  JUMPOUT(0x19E4249B8);
}

__n128 sub_19E424AA4(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void sub_19E424AB4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_19E424B30(void *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0092E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC0092E8))
  {
    xmmword_1EC0092B8 = 0u;
    *(_OWORD *)&qword_1EC0092C8 = 0u;
    dword_1EC0092D8 = 1065353216;
    __cxa_guard_release(&qword_1EC0092E8);
  }
  uint64_t v2 = (uint64_t *)a1[6];
  int v3 = *((char *)v2 + 23);
  if (v3 >= 0) {
    uint64_t v4 = (uint64_t *)a1[6];
  }
  else {
    uint64_t v4 = (uint64_t *)*v2;
  }
  if (v3 >= 0) {
    unint64_t v5 = *((unsigned __int8 *)v2 + 23);
  }
  else {
    unint64_t v5 = v2[1];
  }
  unint64_t v6 = sub_19E37BDA4((uint64_t)&v28, v4, v5);
  unint64_t v7 = *((void *)&xmmword_1EC0092B8 + 1);
  if (*((void *)&xmmword_1EC0092B8 + 1))
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EC0092B8 + 8));
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *((void *)&xmmword_1EC0092B8 + 1)) {
        unint64_t v10 = v6 % *((void *)&xmmword_1EC0092B8 + 1);
      }
    }
    else
    {
      unint64_t v10 = (*((void *)&xmmword_1EC0092B8 + 1) - 1) & v6;
    }
    uint64_t v11 = *(uint64_t ***)(xmmword_1EC0092B8 + 8 * v10);
    if (v11)
    {
      unint64_t v12 = *v11;
      if (*v11)
      {
        char v13 = *((unsigned char *)v2 + 23);
        if (v13 >= 0) {
          uint64_t v14 = *((unsigned __int8 *)v2 + 23);
        }
        else {
          uint64_t v14 = v2[1];
        }
        if (v13 < 0) {
          uint64_t v2 = (uint64_t *)*v2;
        }
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v15 = *((void *)&xmmword_1EC0092B8 + 1) - 1;
          while (1)
          {
            uint64_t v20 = v12[1];
            if (v20 == v8)
            {
              uint64_t v21 = *((unsigned __int8 *)v12 + 39);
              if ((v21 & 0x80u) == 0) {
                uint64_t v22 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v22 = v12[3];
              }
              if (v22 == v14)
              {
                if ((v21 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v2, v12[3])) {
                    goto LABEL_55;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    goto LABEL_55;
                  }
                  uint64_t v23 = 0;
                  while (*((unsigned __int8 *)v12 + v23 + 16) == *((unsigned __int8 *)v2 + v23))
                  {
                    if (v21 == ++v23) {
                      goto LABEL_54;
                    }
                  }
                }
              }
            }
            else if ((v20 & v15) != v10)
            {
              goto LABEL_62;
            }
            unint64_t v12 = (uint64_t *)*v12;
            if (!v12) {
              goto LABEL_62;
            }
          }
        }
        do
        {
          unint64_t v16 = v12[1];
          if (v16 == v8)
          {
            uint64_t v17 = *((unsigned __int8 *)v12 + 39);
            if ((v17 & 0x80u) == 0) {
              uint64_t v18 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v18 = v12[3];
            }
            if (v18 == v14)
            {
              if ((v17 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v2, v12[3]))
                {
LABEL_55:
                  uint64_t v24 = (std::__shared_weak_count *)v12[6];
                  if (v24 && (uint64_t v24 = std::__shared_weak_count::lock(v24)) != 0) {
                    uint64_t v25 = v12[5];
                  }
                  else {
                    uint64_t v25 = 0;
                  }
                  uint64_t v26 = *(void *)(a1[5] + 8);
                  uint64_t v27 = *(std::__shared_weak_count **)(v26 + 48);
                  *(void *)(v26 + 40) = v25;
                  *(void *)(v26 + 48) = v24;
                  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                    std::__shared_weak_count::__release_weak(v27);
                  }
                  break;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  goto LABEL_55;
                }
                uint64_t v19 = 0;
                while (*((unsigned __int8 *)v12 + v19 + 16) == *((unsigned __int8 *)v2 + v19))
                {
                  if (v17 == ++v19)
                  {
LABEL_54:
                    if (!v12) {
                      goto LABEL_62;
                    }
                    goto LABEL_55;
                  }
                }
              }
            }
          }
          else
          {
            if (v16 >= v7) {
              v16 %= v7;
            }
            if (v16 != v10) {
              break;
            }
          }
          unint64_t v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_62:
  if (!*(void *)(*(void *)(a1[5] + 8) + 40))
  {
    (*(void (**)(void))(a1[4] + 16))();
    operator new();
  }
}

void sub_19E425508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E4108F8((uint64_t *)va);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E425578(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__110shared_ptrIN2LM14LegacyMontrealEE27__shared_ptr_default_deleteIS2_S2_EE"
    || ((v3 & (unint64_t)"NSt3__110shared_ptrIN2LM14LegacyMontrealEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__110shared_ptrIN2LM14LegacyMontrealEE27__shared_ptr_default_deleteIS2_S2_EE")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__110shared_ptrIN2LM14LegacyMontrealEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E4255D0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_19E425600(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E42563C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v8 = 0;
  uint8x8_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))off_1E9459E38;
  uint64_t v11 = off_1E9459E38;
  if (!off_1E9459E38)
  {
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    void v7[2] = sub_19E425738;
    v7[3] = &unk_1E599F658;
    v7[4] = &v8;
    sub_19E425738((uint64_t)v7);
    uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))v9[3];
  }
  _Block_object_dispose(&v8, 8);
  if (!v4)
  {
    dlerror();
    unint64_t v6 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v8, 8);
    _Unwind_Resume(v6);
  }
  return v4(v3, a2);
}

void *sub_19E425738(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0092F8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4226B8;
    v5[4] = &unk_1E599F4F0;
    void v5[5] = v5;
    long long v6 = xmmword_1E599F4D8;
    uint64_t v7 = 0;
    qword_1EC0092F8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0092F8;
    if (qword_1EC0092F8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0092F8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLModelStateRelease");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E9459E38 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

CFStringRef sub_19E425878(uint64_t a1, int a2, const __CFString *a3, __n128 a4)
{
  uint64_t v7 = *(void *)(a1 + 96);
  if (!v7) {
    goto LABEL_13;
  }
  uint64_t v8 = a1 + 96;
  do
  {
    int v9 = *(_DWORD *)(v7 + 32);
    BOOL v10 = v9 < 5;
    if (v9 >= 5) {
      uint64_t v11 = (uint64_t *)v7;
    }
    else {
      uint64_t v11 = (uint64_t *)(v7 + 8);
    }
    if (!v10) {
      uint64_t v8 = v7;
    }
    uint64_t v7 = *v11;
  }
  while (*v11);
  if (v8 == a1 + 96 || *(int *)(v8 + 32) > 5 || (uint64_t v12 = *(void *)(v8 + 40)) == 0)
  {
LABEL_13:
    sub_19E518C44(&__p, *(uint64_t ***)(a1 + 136), 5, a4);
    sub_19E499BC8();
  }
  sub_19E49A008(*(void *)(v8 + 40));
  sub_19E49A168(v12, a2);
  int v13 = sqlite3_step(*(sqlite3_stmt **)(v12 + 8));
  if (v13 == 100)
  {
    sub_19E37774C(a3, &__p);
    unint64_t v16 = sub_19E3FC044((void *)(*(void *)(a1 + 8) + 24), (uint64_t)&__p);
    if (!v16
      || (int v17 = *((_DWORD *)v16 + 10), v17 == -1)
      || ((uint64_t v18 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(v12 + 8), v17),
           int v19 = sqlite3_column_bytes(*(sqlite3_stmt **)(v12 + 8), v17),
           v19 >= 1)
        ? (BOOL v20 = v18 == 0)
        : (BOOL v20 = 1),
          v20))
    {
      CFStringRef v15 = 0;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v15;
      }
    }
    else
    {
      CFStringRef v15 = CFStringCreateWithBytes(0, v18, v19, 0x8000100u, 0);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v15;
      }
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    return v15;
  }
  if (v13 == 26 || v13 == 11)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E3F7ABC((uint64_t)exception, 1);
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
  }
  return 0;
}

void sub_19E425A54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E425B28(uint64_t a1, int a2, const __CFString *a3, void *a4, __n128 a5)
{
  uint64_t v9 = *(void *)(a1 + 96);
  if (!v9) {
    goto LABEL_13;
  }
  uint64_t v10 = a1 + 96;
  do
  {
    int v11 = *(_DWORD *)(v9 + 32);
    BOOL v12 = v11 < 5;
    if (v11 >= 5) {
      int v13 = (uint64_t *)v9;
    }
    else {
      int v13 = (uint64_t *)(v9 + 8);
    }
    if (!v12) {
      uint64_t v10 = v9;
    }
    uint64_t v9 = *v13;
  }
  while (*v13);
  if (v10 == a1 + 96 || *(int *)(v10 + 32) > 5 || (uint64_t v14 = *(void *)(v10 + 40)) == 0)
  {
LABEL_13:
    sub_19E518C44(&__p, *(uint64_t ***)(a1 + 136), 5, a5);
    sub_19E499BC8();
  }
  sub_19E49A008(*(void *)(v10 + 40));
  sub_19E49A168(v14, a2);
  int v15 = sqlite3_step(*(sqlite3_stmt **)(v14 + 8));
  if (v15 != 100)
  {
    if (v15 == 26 || v15 == 11)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      sub_19E3F7ABC((uint64_t)exception, 1);
      __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
    }
    return 0;
  }
  sub_19E37774C(a3, &__p);
  uint64_t v18 = sub_19E3FC044((void *)(*(void *)(a1 + 8) + 24), (uint64_t)&__p);
  if (!v18 || (int v19 = *((_DWORD *)v18 + 10), v19 == -1))
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    return 0;
  }
  if (a4) {
    *a4 = sqlite3_column_int(*(sqlite3_stmt **)(v14 + 8), v19);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 1;
}

void sub_19E425CD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFDictionary *sub_19E425DA4(uint64_t a1, int a2, __n128 a3)
{
  uint64_t v5 = *(void *)(a1 + 96);
  if (!v5) {
    goto LABEL_13;
  }
  uint64_t v6 = a1 + 96;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < 5;
    if (v7 >= 5) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 == a1 + 96 || *(int *)(v6 + 32) > 5 || (uint64_t v10 = *(void *)(v6 + 40)) == 0)
  {
LABEL_13:
    sub_19E518C44(&__p, *(uint64_t ***)(a1 + 136), 5, a3);
    sub_19E499BC8();
  }
  sub_19E49A008(*(void *)(v6 + 40));
  sub_19E49A168(v10, a2);
  int v11 = sqlite3_step(*(sqlite3_stmt **)(v10 + 8));
  if (v11 == 100) {
    return sub_19E425FBC(*(uint64_t **)(a1 + 8), v10, 0);
  }
  if (v11 == 26 || v11 == 11)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E3F7ABC((uint64_t)exception, 1);
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
  }
  return 0;
}

void sub_19E425EEC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E425F00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFDictionary *sub_19E425FBC(uint64_t *a1, uint64_t a2, int *a3)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4), MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  if (*a1 != v8)
  {
    uint64_t v9 = 0;
    while (1)
    {
      int v11 = *(_DWORD *)(v7 + 32);
      if (v11 == 1) {
        break;
      }
      if (!v11)
      {
        BOOL v12 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a2 + 8), v9);
        uint64_t v10 = (v9 + 1);
        int v13 = sqlite3_column_bytes(*(sqlite3_stmt **)(a2 + 8), v9);
        if (v13 < 1 || v12 == 0) {
          goto LABEL_4;
        }
        CFStringRef v15 = CFStringCreateWithBytes(0, v12, v13, 0x8000100u, 0);
        if (!CFEqual(v15, *(CFTypeRef *)(v7 + 40))) {
          CFDictionaryAddValue(Mutable, *(const void **)(v7 + 24), v15);
        }
        unint64_t v16 = v15;
        goto LABEL_17;
      }
      uint64_t v10 = v9;
LABEL_4:
      v7 += 48;
      uint64_t v9 = v10;
      if (v7 == v8) {
        goto LABEL_19;
      }
    }
    int valuePtr = 0;
    int valuePtr = sqlite3_column_int(*(sqlite3_stmt **)(a2 + 8), v9);
    CFNumberRef v17 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    if (!CFEqual(v17, *(CFTypeRef *)(v7 + 40))) {
      CFDictionaryAddValue(Mutable, *(const void **)(v7 + 24), v17);
    }
    uint64_t v10 = (v9 + 1);
    unint64_t v16 = v17;
LABEL_17:
    CFRelease(v16);
    goto LABEL_4;
  }
  LODWORD(v10) = 0;
LABEL_19:
  if (a3) {
    *a3 = sqlite3_column_int(*(sqlite3_stmt **)(a2 + 8), v10);
  }
  return Mutable;
}

uint64_t sub_19E426150(uint64_t a1, CFDictionaryRef theDict, int a3)
{
  int v16 = a3;
  if (theDict)
  {
    uint64_t v5 = *(uint64_t **)(a1 + 8);
    int v13 = 0;
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    while (v6 != v7)
    {
      if (CFDictionaryContainsKey(theDict, *(const void **)(v6 + 24)))
      {
        uint64_t v9 = v14;
        if ((unint64_t)v14 >= v15)
        {
          uint64_t v8 = sub_19E3FC244((char **)&v13, v6);
        }
        else
        {
          if (*(char *)(v6 + 23) < 0)
          {
            sub_19E39369C(v14, *(void **)v6, *(void *)(v6 + 8));
          }
          else
          {
            long long v10 = *(_OWORD *)v6;
            *((void *)v14 + 2) = *(void *)(v6 + 16);
            *uint64_t v9 = v10;
          }
          uint64_t v8 = (char *)v9 + 24;
        }
        uint64_t v14 = v8;
      }
      v6 += 48;
    }
    sub_19E519F94(&__p, *(void *)(a1 + 136), (const void ***)&v13);
    operator new();
  }
  return 0;
}

void sub_19E426370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17)
{
  __cxa_free_exception(v17);
  sub_19E3F797C((unint64_t *)&a15);
  sub_19E3EB09C(&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_19E42641C(uint64_t *a1, CFDictionaryRef theDict, int *a3, uint64_t a4, uint64_t a5)
{
  if (!a4)
  {
    uint64_t v20 = *a1;
    uint64_t v21 = a1[1];
    if (*a1 == v21) {
      return 1;
    }
    while (1)
    {
      int v23 = CFDictionaryContainsKey(theDict, *(const void **)(v20 + 24));
      if (v23)
      {
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, *(const void **)(v20 + 24));
        int v25 = *(_DWORD *)(v20 + 32);
        if (!v25) {
          goto LABEL_37;
        }
      }
      else
      {
        CFStringRef Value = *(const __CFString **)(v20 + 40);
        int v25 = *(_DWORD *)(v20 + 32);
        if (!v25)
        {
LABEL_37:
          CFTypeID v27 = CFGetTypeID(Value);
          if (v27 != CFStringGetTypeID()) {
            return 0;
          }
          if (a5 && v23) {
            sub_19E49A438(a5, Value);
          }
          goto LABEL_28;
        }
      }
      if (v25 == 1)
      {
        CFTypeID v26 = CFGetTypeID(Value);
        if (v26 != CFNumberGetTypeID()) {
          return 0;
        }
        int valuePtr = 0;
        CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &valuePtr);
        if (a5 && v23) {
          sub_19E49A168(a5, valuePtr);
        }
      }
LABEL_28:
      v20 += 48;
      if (v20 == v21) {
        return 1;
      }
    }
  }
  if (!a3) {
    return 0;
  }
  sub_19E49A168(a4, *a3);
  uint64_t v9 = *a1;
  uint64_t v10 = a1[1];
  if (*a1 == v10) {
    return 1;
  }
  if (!a5)
  {
    while (1)
    {
      if (CFDictionaryContainsKey(theDict, *(const void **)(v9 + 24)))
      {
        CFStringRef v16 = (const __CFString *)CFDictionaryGetValue(theDict, *(const void **)(v9 + 24));
        int v17 = *(_DWORD *)(v9 + 32);
        if (!v17) {
          goto LABEL_24;
        }
      }
      else
      {
        CFStringRef v16 = *(const __CFString **)(v9 + 40);
        int v17 = *(_DWORD *)(v9 + 32);
        if (!v17)
        {
LABEL_24:
          CFTypeID v19 = CFGetTypeID(v16);
          if (v19 == CFStringGetTypeID()) {
            sub_19E49A438(a4, v16);
          }
          return 0;
        }
      }
      if (v17 == 1)
      {
        CFTypeID v18 = CFGetTypeID(v16);
        if (v18 != CFNumberGetTypeID()) {
          return 0;
        }
        int valuePtr = 0;
        CFNumberGetValue((CFNumberRef)v16, kCFNumberIntType, &valuePtr);
        sub_19E49A168(a4, valuePtr);
      }
      v9 += 48;
      if (v9 == v10) {
        return 1;
      }
    }
  }
  while (1)
  {
    int v11 = CFDictionaryContainsKey(theDict, *(const void **)(v9 + 24));
    if (v11) {
      CFStringRef v12 = (const __CFString *)CFDictionaryGetValue(theDict, *(const void **)(v9 + 24));
    }
    else {
      CFStringRef v12 = *(const __CFString **)(v9 + 40);
    }
    int v13 = *(_DWORD *)(v9 + 32);
    if (v13 == 1)
    {
      CFTypeID v15 = CFGetTypeID(v12);
      if (v15 != CFNumberGetTypeID()) {
        return 0;
      }
      int valuePtr = 0;
      CFNumberGetValue((CFNumberRef)v12, kCFNumberIntType, &valuePtr);
      sub_19E49A168(a4, valuePtr);
      if (v11) {
        sub_19E49A168(a5, valuePtr);
      }
      goto LABEL_6;
    }
    if (!v13) {
      break;
    }
LABEL_6:
    v9 += 48;
    if (v9 == v10) {
      return 1;
    }
  }
  CFTypeID v14 = CFGetTypeID(v12);
  if (v14 == CFStringGetTypeID()) {
    sub_19E49A438(a4, v12);
  }
  return 0;
}

void sub_19E42678C()
{
}

uint64_t sub_19E4267A0(uint64_t a1, const __CFDictionary *a2, __n128 a3)
{
  if (!a2) {
    return 3;
  }
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  unint64_t v33 = 0;
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (*v4 != v6)
  {
    do
    {
      if (CFDictionaryContainsKey(a2, *(const void **)(v5 + 24)))
      {
        uint64_t v8 = (__n128 *)v32;
        if ((unint64_t)v32 >= v33)
        {
          uint64_t v7 = sub_19E3FC244(&v31, v5);
        }
        else
        {
          if (*(char *)(v5 + 23) < 0)
          {
            sub_19E39369C(v32, *(void **)v5, *(void *)(v5 + 8));
          }
          else
          {
            a3 = *(__n128 *)v5;
            *((void *)v32 + 2) = *(void *)(v5 + 16);
            *uint64_t v8 = a3;
          }
          uint64_t v7 = &v8[1].n128_i8[8];
        }
        uint64_t v32 = v7;
      }
      v5 += 48;
    }
    while (v5 != v6);
  }
  uint64_t v9 = *(void *)(a1 + 96);
  if (!v9) {
    goto LABEL_25;
  }
  uint64_t v10 = a1 + 96;
  do
  {
    int v11 = *(_DWORD *)(v9 + 32);
    BOOL v12 = v11 < 6;
    if (v11 >= 6) {
      int v13 = (uint64_t *)v9;
    }
    else {
      int v13 = (uint64_t *)(v9 + 8);
    }
    if (!v12) {
      uint64_t v10 = v9;
    }
    uint64_t v9 = *v13;
  }
  while (*v13);
  if (v10 == a1 + 96 || *(int *)(v10 + 32) > 6 || (uint64_t v14 = *(void *)(v10 + 40)) == 0)
  {
LABEL_25:
    sub_19E518C44(&v34, *(uint64_t ***)(a1 + 136), 6, a3);
    sub_19E499BC8();
  }
  uint64_t v29 = *(void *)(v10 + 40);
  sub_19E49A008(v14);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, *(const void **)(*(void *)(*(void *)(a1 + 8) + 64) + 24));
  CFStringRef v16 = Value;
  if (!Value || (CFTypeID v17 = CFGetTypeID(Value), v17 == CFStringGetTypeID())) {
    sub_19E49A438(v29, v16);
  }
  if (qword_1EC009490 != -1) {
    dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
  }
  sub_19E4E4498((int *)qword_1EC009488, v18, "binding attributes failed: missing or incompatible token string", v19, v20, v21, v22, v23, v28);
  int v25 = v31;
  if (v31)
  {
    CFTypeID v26 = v32;
    CFTypeID v27 = v31;
    if (v32 != v31)
    {
      do
      {
        if (*(v26 - 1) < 0) {
          operator delete(*((void **)v26 - 3));
        }
        v26 -= 24;
      }
      while (v26 != v25);
      CFTypeID v27 = v31;
    }
    uint64_t v32 = v25;
    operator delete(v27);
  }
  return 3;
}

void sub_19E4272A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }
  sub_19E3EB09C((void **)(v29 - 136));
  _Unwind_Resume(a1);
}

void sub_19E427538()
{
}

uint64_t sub_19E427564()
{
  return 0;
}

void sub_19E42756C()
{
}

void sub_19E427598()
{
}

void sub_19E4275C4()
{
}

void sub_19E4275F0()
{
}

sqlite3 *sub_19E427624(sqlite3 *result)
{
  if (*((unsigned char *)result + 56)) {
    return sub_19E427714((uint64_t)result + 16, 1);
  }
  return result;
}

sqlite3 *sub_19E427714(uint64_t a1, int a2)
{
  ppDb = 0;
  uint64_t v4 = (const char *)(a1 + 16);
  if (*(char *)(a1 + 39) < 0) {
    uint64_t v4 = *(const char **)v4;
  }
  int v5 = sqlite3_open(v4, &ppDb);
  if (!v5)
  {
    if (a2) {
      p_ppDb = (sqlite3 **)a1;
    }
    else {
      p_ppDb = &ppDb;
    }
    uint64_t v7 = *p_ppDb;
    if (a2) {
      uint64_t v8 = &ppDb;
    }
    else {
      uint64_t v8 = (sqlite3 **)a1;
    }
    uint64_t v9 = *v8;
    if (a2 && *(unsigned char *)(a1 + 41)) {
      sqlite3_exec(ppDb, "PRAGMA journal_mode = WAL;", 0, 0, 0);
    }
    uint64_t v10 = sqlite3_backup_init(v9, "main", v7, "main");
    if (v10)
    {
      int v11 = v10;
      sqlite3_backup_step(v10, -1);
      sqlite3_backup_finish(v11);
    }
    int v5 = sqlite3_errcode(ppDb);
  }
  uint64_t result = ppDb;
  if (ppDb) {
    uint64_t result = (sqlite3 *)sqlite3_close(ppDb);
  }
  if (v5)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E3F7ABC((uint64_t)exception, 3);
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
  }
  return result;
}

void sub_19E42782C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E427840()
{
  v0[0] = 0;
  v0[1] = v0;
  v0[2] = 0x3002000000;
  v0[3] = sub_19E427BB8;
  v0[4] = sub_19E427BC8;
  operator new();
}

void sub_19E427B24(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10F3C401454C883);
  _Unwind_Resume(a1);
}

void sub_19E427B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  sub_19E418864(a33);
  _Block_object_dispose((const void *)(v33 - 128), 8);
  uint64_t v35 = *(void *)(v33 - 88);
  *(void *)(v33 - 88) = 0;
  if (!v35) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  _Unwind_Resume(a1);
}

uint64_t sub_19E427BB8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(void *)(result + 40) = v2;
  return result;
}

uint64_t sub_19E427BC8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_19E427C00(uint64_t a1, uint64_t a2, long long *a3)
{
  *(void *)a1 = &unk_1EF0B9F90;
  *(void *)(a1 + 8) = *(void *)(a2 + 184);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a1;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 64) = a1 + 72;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = a1 + 96;
  if (*((char *)a3 + 23) < 0)
  {
    sub_19E39369C((unsigned char *)(a1 + 112), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v3 = *a3;
    *(void *)(a1 + 128) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 112) = v3;
  }
  operator new();
}

void sub_19E427F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, long long a10)
{
  __cxa_free_exception(v13);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E382340(&a10, "Failed to create lexicon database");
    sub_19E3F5604(exception, &a10);
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
  }
  sub_19E428458((uint64_t *)(v11 + 136));
  if (*(char *)(v11 + 135) < 0) {
    operator delete(*v12);
  }
  sub_19E4284B0(v10);
  _Unwind_Resume(a1);
}

void sub_19E428078(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
      goto LABEL_6;
    }
  }
  else if (!v16)
  {
LABEL_6:
    __cxa_end_catch();
    JUMPOUT(0x19E4280ACLL);
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void *sub_19E4280D8(void *result, void *a2)
{
  result[5] = a2[5];
  uint64_t v2 = a2 + 6;
  uint64_t v3 = a2[6];
  result[6] = v3;
  uint64_t v4 = result + 6;
  uint64_t v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[5] = v2;
    *uint64_t v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void sub_19E428114(uint64_t a1)
{
}

void sub_19E42811C(void *a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)a1[8];
  uint64_t v3 = *v2;
  if (*v2)
  {
    uint64_t v4 = *(void *)(v3 + 24);
    if (v4 && *(_DWORD *)(v3 + 16) != 0)
    {
      uint64_t v8 = a1[7];
      unsigned int v9 = *(_DWORD *)(v3 + 20);
      unsigned int v10 = *(unsigned __int8 *)(v3 + 7);
      if (!*(void *)(v3 + 40))
      {
        uint64_t v11 = malloc_type_malloc(0x30uLL, 0x100004052888210uLL);
        *(void *)(v3 + 40) = v11;
        if (v11)
        {
          *(void *)&long long v12 = -1;
          *((void *)&v12 + 1) = -1;
          v11[1] = v12;
          v11[2] = v12;
          _OWORD *v11 = v12;
        }
      }
      if (sub_19E5293C0(v4, v9, v10, *(_DWORD **)(*v2 + 40), a2, 0, 0))
      {
        int v24 = 0;
        int v13 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 264))(v8, a2);
        uint64_t v14 = *(void *)(*(void *)(a1[4] + 8) + 40);
        if ((*(unsigned int (**)(uint64_t, const void *, int *))(*(void *)v14 + 248))(v14, v13, &v24))
        {
          *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 0;
        }
        else
        {
          int v15 = v24;
          uint64_t v16 = *(void *)(a1[5] + 8);
          uint64_t v18 = (uint64_t **)(v16 + 48);
          CFTypeID v17 = *(unsigned int **)(v16 + 48);
          if (v17)
          {
            while (1)
            {
              while (1)
              {
                uint64_t v19 = v17;
                unsigned int v20 = v17[7];
                if (v20 <= a2) {
                  break;
                }
                CFTypeID v17 = (unsigned int *)*v19;
                uint64_t v18 = (uint64_t **)v19;
                if (!*v19) {
                  goto LABEL_19;
                }
              }
              if (v20 >= a2) {
                break;
              }
              CFTypeID v17 = (unsigned int *)v19[1];
              if (!v17)
              {
                uint64_t v18 = (uint64_t **)(v19 + 1);
                goto LABEL_19;
              }
            }
          }
          else
          {
            uint64_t v19 = (void *)(v16 + 48);
LABEL_19:
            uint64_t v21 = v19;
            uint64_t v19 = operator new(0x28uLL);
            *((_DWORD *)v19 + 7) = a2;
            *((_DWORD *)v19 + 8) = 0;
            void *v19 = 0;
            v19[1] = 0;
            v19[2] = v21;
            *uint64_t v18 = v19;
            uint64_t v22 = **(void **)(v16 + 40);
            uint64_t v23 = v19;
            if (v22)
            {
              *(void *)(v16 + 40) = v22;
              uint64_t v23 = *v18;
            }
            sub_19E37D324(*(uint64_t **)(v16 + 48), v23);
            ++*(void *)(v16 + 56);
          }
          *((_DWORD *)v19 + 8) = v15;
        }
        CFRelease(v13);
      }
    }
  }
}

uint64_t sub_19E428314(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = *(void *)(v2 + 48);
  uint64_t v3 = v2 + 48;
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v6 = v3;
    do
    {
      unsigned int v7 = *(_DWORD *)(v4 + 28);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        unsigned int v9 = (uint64_t *)v4;
      }
      else {
        unsigned int v9 = (uint64_t *)(v4 + 8);
      }
      if (v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != v3 && *(_DWORD *)(v6 + 28) <= a2) {
      return *(unsigned int *)(v6 + 32);
    }
  }
  return a2;
}

uint64_t sub_19E428364(uint64_t a1, int a2, __n128 a3)
{
  uint64_t v3 = *(void *)(a1 + 96);
  if (!v3) {
    goto LABEL_13;
  }
  uint64_t v4 = a1 + 96;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      unsigned int v7 = (uint64_t *)v3;
    }
    else {
      unsigned int v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 96 || *(_DWORD *)(v4 + 32) > a2 || (uint64_t v8 = *(void *)(v4 + 40)) == 0)
  {
LABEL_13:
    sub_19E518C44(&__p, *(uint64_t ***)(a1 + 136), a2, a3);
    sub_19E499BC8();
  }
  sub_19E49A008(*(void *)(v4 + 40));
  return v8;
}

void sub_19E42843C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E428458(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(char *)(v2 + 31) < 0) {
      operator delete(*(void **)(v2 + 8));
    }
    MEMORY[0x19F3BDCF0](v2, 0x1072C408ACDB0FELL);
  }
  return a1;
}

uint64_t sub_19E4284B0(uint64_t a1)
{
  if (*(void *)a1)
  {
    sub_19E4DD41C(a1 + 48);
    int v2 = sqlite3_close(*(sqlite3 **)a1);
    char v3 = v2;
    if (v2)
    {
      if (qword_1EC009490 != -1) {
        dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
      }
      uint64_t v4 = (int *)qword_1EC009488;
      sqlite3_errmsg(*(sqlite3 **)a1);
      sub_19E4E4498(v4, v5, "Failed to close database, error code: %d  error message: %s\n", v6, v7, v8, v9, v10, v3);
    }
  }
  sub_19E4DD41C(a1 + 48);
  sub_19E418864(*(void **)(a1 + 80));
  sub_19E418864(*(void **)(a1 + 56));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_19E428580(sqlite3 **a1)
{
  uint64_t v1 = a1;
  int v2 = sub_19E428E28(a1, "BEGIN IMMEDIATE");
  char v9 = v2;
  if ((v2 == 0) != (v2 != 5))
  {
    if (qword_1EC009490 != -1) {
      dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
    }
    sub_19E4E4498((int *)qword_1EC009488, v3, "Could not begin transaction, error %d", v4, v5, v6, v7, v8, v9);
  }
  if (*((unsigned char *)v1 + 40))
  {
    uint64_t v10 = *((void *)v1[1] + 17);
    *((unsigned char *)&v60.__r_.__value_.__s + 23) = 13;
    strcpy((char *)&v60, "CREATE TABLE ");
    if (*(char *)(v10 + 31) < 0)
    {
      sub_19E39369C(__p, *(void **)(v10 + 8), *(void *)(v10 + 16));
    }
    else
    {
      long long v11 = *(_OWORD *)(v10 + 8);
      uint64_t v59 = *(void *)(v10 + 24);
      *(_OWORD *)std::string __p = v11;
    }
    if (v59 >= 0) {
      long long v12 = __p;
    }
    else {
      long long v12 = (void **)__p[0];
    }
    if (v59 >= 0) {
      std::string::size_type v13 = HIBYTE(v59);
    }
    else {
      std::string::size_type v13 = (std::string::size_type)__p[1];
    }
    uint64_t v14 = std::string::append(&v60, (const std::string::value_type *)v12, v13);
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    __dst.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    uint64_t v16 = std::string::append(&__dst, " (TokenID INTEGER PRIMARY KEY, ", 0x1FuLL);
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v57.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v59) & 0x80000000) == 0) {
        goto LABEL_17;
      }
    }
    else if ((SHIBYTE(v59) & 0x80000000) == 0)
    {
      goto LABEL_17;
    }
    operator delete(__p[0]);
LABEL_17:
    uint64_t v56 = v1;
    if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v60.__r_.__value_.__l.__data_);
    }
    uint64_t v18 = **(const void ****)v10;
    uint64_t v19 = *(const void ***)(*(void *)v10 + 8);
    if (v18 == v19)
    {
LABEL_79:
      std::string::append(&v57, ")", 1uLL);
      uint64_t v1 = v56;
      sub_19E428E28(v56, "PRAGMA journal_mode = WAL;");
      if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v45 = &v57;
      }
      else {
        unint64_t v45 = (std::string *)v57.__r_.__value_.__r.__words[0];
      }
      int v46 = sub_19E428E28(v56, (const char *)v45);
      if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v57.__r_.__value_.__l.__data_);
      }
      if (v46)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        sub_19E3F7ABC((uint64_t)exception, 4);
        __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
      }
      goto LABEL_85;
    }
    int v20 = *((char *)v18 + 23);
    if (v20 >= 0) {
      size_t v21 = *((unsigned __int8 *)v18 + 23);
    }
    else {
      size_t v21 = (size_t)v18[1];
    }
    unint64_t v22 = v21 + 1;
    if (v21 + 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_90:
    }
      sub_19E37C958();
    if (v22 >= 0x17)
    {
      uint64_t v24 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v22 | 7) != 0x17) {
        uint64_t v24 = v22 | 7;
      }
      uint64_t v25 = v24 + 1;
      p_dst = (char *)operator new(v24 + 1);
      __dst.__r_.__value_.__l.__size_ = v21 + 1;
      __dst.__r_.__value_.__r.__words[2] = v25 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = (char *)&__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v21 + 1;
      if (!v21) {
        goto LABEL_36;
      }
    }
    if (v20 >= 0) {
      CFTypeID v26 = v18;
    }
    else {
      CFTypeID v26 = *v18;
    }
    memmove(p_dst, v26, v21);
LABEL_36:
    *(_WORD *)&p_dst[v21] = 32;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFTypeID v27 = &__dst;
    }
    else {
      CFTypeID v27 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    }
    std::string::append(&v57, (const std::string::value_type *)v27, size);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
      int v29 = *((_DWORD *)v18 + 8);
      if (v29) {
        goto LABEL_44;
      }
    }
    else
    {
      int v29 = *((_DWORD *)v18 + 8);
      if (v29)
      {
LABEL_44:
        if (v29 != 1) {
          goto LABEL_49;
        }
        uint64_t v30 = "INTEGER";
        std::string::size_type v31 = 7;
LABEL_48:
        std::string::append(&v57, v30, v31);
LABEL_49:
        uint64_t v32 = v18 + 6;
        if (v18 + 6 != v19)
        {
          while (1)
          {
            std::string::append(&v57, ", ", 2uLL);
            int v35 = *((char *)v32 + 23);
            if (v35 >= 0) {
              size_t v36 = *((unsigned __int8 *)v32 + 23);
            }
            else {
              size_t v36 = (size_t)v32[1];
            }
            unint64_t v37 = v36 + 1;
            if (v36 + 1 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_90;
            }
            if (v37 >= 0x17)
            {
              uint64_t v39 = (v37 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v37 | 7) != 0x17) {
                uint64_t v39 = v37 | 7;
              }
              uint64_t v40 = v39 + 1;
              uint64_t v38 = (char *)operator new(v39 + 1);
              __dst.__r_.__value_.__l.__size_ = v36 + 1;
              __dst.__r_.__value_.__r.__words[2] = v40 | 0x8000000000000000;
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
            }
            else
            {
              memset(&__dst, 0, sizeof(__dst));
              uint64_t v38 = (char *)&__dst;
              *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v36 + 1;
              if (!v36) {
                goto LABEL_68;
              }
            }
            if (v35 >= 0) {
              int v41 = v32;
            }
            else {
              int v41 = *v32;
            }
            memmove(v38, v41, v36);
LABEL_68:
            *(_WORD *)&v38[v36] = 32;
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v42 = &__dst;
            }
            else {
              uint64_t v42 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            }
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v43 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v43 = __dst.__r_.__value_.__l.__size_;
            }
            std::string::append(&v57, (const std::string::value_type *)v42, v43);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            int v44 = *((_DWORD *)v32 + 8);
            if (v44 == 1)
            {
              uint64_t v33 = "INTEGER";
              std::string::size_type v34 = 7;
            }
            else
            {
              if (v44) {
                goto LABEL_53;
              }
              uint64_t v33 = "BLOB";
              std::string::size_type v34 = 4;
            }
            std::string::append(&v57, v33, v34);
LABEL_53:
            v32 += 6;
            if (v32 == v19) {
              goto LABEL_79;
            }
          }
        }
        goto LABEL_79;
      }
    }
    uint64_t v30 = "BLOB";
    std::string::size_type v31 = 4;
    goto LABEL_48;
  }
LABEL_85:
  int v47 = sub_19E428E28(v1, "COMMIT");
  char v54 = v47;
  if (v47)
  {
    if (qword_1EC009490 != -1) {
      dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
    }
    sub_19E4E4498((int *)qword_1EC009488, v48, "Could not commit transaction, error %d", v49, v50, v51, v52, v53, v54);
  }
}

void sub_19E428A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_19E428F20((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t sub_19E428B60(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 136);
  *((unsigned char *)&v24.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v24, "DROP TABLE ");
  uint64_t v5 = *(const std::string::value_type **)(v2 + 8);
  uint64_t v3 = v2 + 8;
  uint64_t v4 = v5;
  int v6 = *(char *)(v3 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (const std::string::value_type *)v3;
  }
  else {
    uint64_t v7 = v4;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(v3 + 23);
  }
  else {
    std::string::size_type v8 = *(void *)(v3 + 8);
  }
  char v9 = std::string::append(&v24, v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  int64_t v23 = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (v23 >= 0) {
    long long v11 = __p;
  }
  else {
    long long v11 = (void **)__p[0];
  }
  int v12 = sqlite3_exec(*(sqlite3 **)a1, (const char *)v11, 0, 0, 0);
  if (v12)
  {
    if (qword_1EC009490 != -1) {
      dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
    }
    std::string::size_type v13 = (int *)qword_1EC009488;
    sqlite3_errmsg(*(sqlite3 **)a1);
    sub_19E4E4498(v13, v14, "Could not execute SQL \"%s\", error message: %s\n", v15, v16, v17, v18, v19, (char)v11);
    if (v12 == 26 || v12 == 11)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      *(void *)exception = &unk_1EF0BB7A8;
      *((void *)exception + 1) = 0;
      *((void *)exception + 2) = 0;
      *((void *)exception + 3) = 0;
      sub_19E377894((void **)exception + 1, "SQLite database corrupted", 0x19uLL);
      __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
    }
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  sub_19E428580((sqlite3 **)a1);
  return 1;
}

#error "19E428DEC: call analysis failed (funcsize=48)"

uint64_t sub_19E428E28(sqlite3 **a1, const char *a2)
{
  char v2 = (char)a2;
  uint64_t v4 = sqlite3_exec(*a1, a2, 0, 0, 0);
  if (v4)
  {
    if (qword_1EC009490 != -1) {
      dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
    }
    uint64_t v5 = (int *)qword_1EC009488;
    sqlite3_errmsg(*a1);
    sub_19E4E4498(v5, v6, "Could not execute SQL \"%s\", error message: %s\n", v7, v8, v9, v10, v11, v2);
    if (v4 == 26 || v4 == 11)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      sub_19E3F7ABC((uint64_t)exception, 1);
      __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
    }
  }
  return v4;
}

void sub_19E428F0C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E428F20(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_19E428E28(*(sqlite3 ***)a1, "ROLLBACK");
  }
  return a1;
}

void sub_19E428F60()
{
}

uint64_t sub_19E428F8C()
{
  return 0;
}

uint64_t sub_19E428F94()
{
  return 0;
}

BOOL sub_19E428F9C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1[1] + 64);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v9 = (const char *)a2;
  }
  else {
    uint64_t v9 = *(const char **)a2;
  }
  CFStringRef v10 = CFStringCreateWithCString(0, v9, 0x8000100u);
  CFDictionarySetValue(Mutable, *(const void **)(v7 + 24), v10);
  CFRelease(v10);
  int v11 = (*(uint64_t (**)(void *, __CFDictionary *, uint64_t))(*a1 + 248))(a1, Mutable, a4);
  CFRelease(Mutable);
  return v11 == 0;
}

void sub_19E429080(uint64_t a1, std::error_code *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(unsigned char *)(a1 + 56))
  {
    sub_19E4DD41C(a1 + 64);
    sub_19E428B60(a1 + 16);
  }
  uint64_t v10 = *(void *)(a1 + 144);
  unsigned int v11 = *(_DWORD *)(v10 + 288);
  *(void *)(a1 + 152) = v11;
  if (v11 <= *(_DWORD *)(v10 + 292)) {
    unsigned int v12 = v11;
  }
  else {
    unsigned int v12 = 0;
  }
  *(_DWORD *)(a1 + 152) = v12;
  std::string::size_type v13 = (const std::__fs::filesystem::path **)(a1 + 112);
  if (*(char *)(a1 + 135) < 0)
  {
    if ((remove(*v13, a2) & 0x80000000) == 0) {
      return;
    }
  }
  else if ((remove((const std::__fs::filesystem::path *)v13, a2) & 0x80000000) == 0)
  {
    return;
  }
  if (qword_1EC009490 != -1) {
    dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
  }
  int v20 = (int *)qword_1EC009488;
  sub_19E4E4498(v20, v14, "failed to remove lexicon database", v15, v16, v17, v18, v19, a9);
}

off_t sub_19E42914C(uint64_t a1)
{
  char v2 = (const char *)(a1 + 112);
  if (*(char *)(a1 + 135) < 0) {
    char v2 = *(const char **)v2;
  }
  if (stat(v2, &v4) >= 0) {
    return 0;
  }
  else {
    return v4.st_size;
  }
}

uint64_t sub_19E429190(uint64_t a1)
{
  return *(unsigned int *)(a1 + 156);
}

uint64_t sub_19E429198(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v4 = sub_19E428364(a1, 12, a3);
  uint64_t result = sqlite3_step(*(sqlite3_stmt **)(v4 + 8));
  if (result == 26 || result == 11)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E3F7ABC((uint64_t)exception, 1);
    goto LABEL_18;
  }
  char v11 = 0;
  if (result == 100)
  {
    while (1)
    {
      uint64_t v7 = sqlite3_column_int(*(sqlite3_stmt **)(v4 + 8), 0);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t, char *, double))(a2 + 16))(a2, v7, &v11, 0.0);
      }
      uint64_t result = sqlite3_step(*(sqlite3_stmt **)(v4 + 8));
      if (result == 26 || result == 11) {
        break;
      }
      if (result != 100 || v11 != 0) {
        return result;
      }
    }
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E3F7ABC((uint64_t)exception, 1);
LABEL_18:
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
  }
  return result;
}

void sub_19E429290(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E4292A8()
{
}

void sub_19E4292D4()
{
}

void sub_19E429300(void *a1@<X8>)
{
  *a1 = 0;
}

size_t sub_19E429308@<X0>(uint64_t a1@<X0>, int a2@<W1>, unsigned char *a3@<X8>, __n128 a4@<Q0>)
{
  uint64_t v6 = sub_19E428364(a1, 7, a4);
  sub_19E49A168(v6, a2);
  size_t result = sqlite3_step(*(sqlite3_stmt **)(v6 + 8));
  if (result != 100)
  {
    if (result == 26 || result == 11)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      sub_19E3F7ABC((uint64_t)exception, 1);
      __cxa_throw(exception, (struct type_info *)&unk_1EF0B6A10, (void (*)(void *))sub_19E3F7B5C);
    }
    goto LABEL_13;
  }
  size_t result = *(void *)(v6 + 8);
  if (!result)
  {
LABEL_13:
    a3[23] = 0;
    *a3 = 0;
    return result;
  }
  uint64_t v10 = (const char *)sqlite3_column_blob((sqlite3_stmt *)result, 0);
  size_t result = strlen(v10);
  if (result >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  size_t v11 = result;
  if (result >= 0x17)
  {
    uint64_t v12 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v12 = result | 7;
    }
    uint64_t v13 = v12 + 1;
    uint64_t v14 = operator new(v12 + 1);
    *((void *)a3 + 1) = v11;
    *((void *)a3 + 2) = v13 | 0x8000000000000000;
    *(void *)a3 = v14;
    a3 = v14;
  }
  else
  {
    a3[23] = result;
    if (!result) {
      goto LABEL_18;
    }
  }
  size_t result = (size_t)memmove(a3, v10, v11);
LABEL_18:
  a3[v11] = 0;
  return result;
}

void sub_19E42942C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E429440(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v5 = sub_19E3C2A64(a2);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 16))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

void sub_19E4294CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3DCC24((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E4294E0(uint64_t a1, const __CFString *a2, __n128 a3)
{
  uint64_t v4 = sub_19E428364(a1, 8, a3);
  sub_19E49A438(v4, a2);
}

void sub_19E42958C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E4295A0(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0B9F90;
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v2)
  {
    if (*(char *)(v2 + 31) < 0) {
      operator delete(*(void **)(v2 + 8));
    }
    MEMORY[0x19F3BDCF0](v2, 0x1072C408ACDB0FELL);
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  sub_19E4284B0(a1 + 16);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E42964C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0B9F90;
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v2)
  {
    if (*(char *)(v2 + 31) < 0) {
      operator delete(*(void **)(v2 + 8));
    }
    MEMORY[0x19F3BDCF0](v2, 0x1072C408ACDB0FELL);
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  sub_19E4284B0(a1 + 16);
  return a1;
}

uint64_t sub_19E4296D8(uint64_t a1, int *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0094A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC0094A0))
  {
    qword_1EC009510 = 0;
    qword_1EC009508 = 0;
    qword_1EC009500 = (uint64_t)&qword_1EC009508;
    __cxa_guard_release(&qword_1EC0094A0);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009498, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC009498))
  {
    qword_1EC0094C0 = 850045863;
    unk_1EC0094C8 = 0u;
    unk_1EC0094D8 = 0u;
    unk_1EC0094E8 = 0u;
    qword_1EC0094F8 = 0;
    __cxa_guard_release(&qword_1EC009498);
  }
  if (!a1) {
    return a1;
  }
  CFStringRef v4 = (const __CFString *)MEMORY[0x19F3BCDE0](a1);
  sub_19E37774C(v4, __p);
  std::mutex::lock((std::mutex *)&qword_1EC0094C0);
  uint64_t v5 = qword_1EC009508;
  if (!qword_1EC009508) {
    goto LABEL_41;
  }
  if (v51 >= 0) {
    uint64_t v6 = __p;
  }
  else {
    uint64_t v6 = (void **)__p[0];
  }
  if (v51 >= 0) {
    uint64_t v7 = (void *)HIBYTE(v51);
  }
  else {
    uint64_t v7 = __p[1];
  }
  uint64_t v8 = &qword_1EC009508;
  do
  {
    while (1)
    {
      int v9 = *(char *)(v5 + 55);
      uint64_t v10 = v9 >= 0 ? (const void *)(v5 + 32) : *(const void **)(v5 + 32);
      size_t v11 = v9 >= 0 ? (void *)*(unsigned __int8 *)(v5 + 55) : *(void **)(v5 + 40);
      size_t v12 = (size_t)(v7 >= v11 ? v11 : v7);
      int v13 = memcmp(v10, v6, v12);
      if (v13) {
        break;
      }
      if (v11 < v7) {
        goto LABEL_14;
      }
LABEL_12:
      uint64_t v8 = (uint64_t *)v5;
      uint64_t v5 = *(void *)v5;
      if (!v5) {
        goto LABEL_29;
      }
    }
    if ((v13 & 0x80000000) == 0) {
      goto LABEL_12;
    }
LABEL_14:
    uint64_t v5 = *(void *)(v5 + 8);
  }
  while (v5);
LABEL_29:
  if (v8 == &qword_1EC009508)
  {
LABEL_41:
    uint64_t v19 = ulocdata_open();
    uint64_t ExemplarSet = ulocdata_getExemplarSet();
    uint64_t v21 = ulocdata_getExemplarSet();
    uint64_t v22 = ulocdata_getExemplarSet();
    if (*a2 <= 0 && (uint64_t v44 = v22, v45 = uset_openEmpty(), (a1 = v45) != 0))
    {
      MEMORY[0x19F3BE730](v45, 48, 57);
      uset_addString();
      if (ExemplarSet)
      {
        MEMORY[0x19F3BE720](a1, ExemplarSet);
        uset_close();
      }
      if (v21)
      {
        MEMORY[0x19F3BE720](a1, v21);
        uset_close();
      }
      if (v44)
      {
        MEMORY[0x19F3BE720](a1, v44);
        uset_close();
      }
      if (v19) {
        ulocdata_close();
      }
    }
    else
    {
      if (qword_1EC009490 != -1) {
        dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
      }
      int v29 = __p;
      if (v51 < 0) {
        LOBYTE(v29) = __p[0];
      }
      sub_19E4E4498((int *)qword_1EC009488, v23, "failed to initialize exemplar set for %s (error code %d)", v24, v25, v26, v27, v28, (char)v29);
      a1 = 0;
    }
    uint64_t v30 = qword_1EC009508;
    if (!qword_1EC009508)
    {
      uint64_t v33 = &qword_1EC009508;
      std::string::size_type v34 = &qword_1EC009508;
LABEL_84:
      int v46 = operator new(0x40uLL);
      int v47 = v46 + 4;
      if (SHIBYTE(v51) < 0)
      {
        sub_19E39369C(v47, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)int v47 = *(_OWORD *)__p;
        v46[6] = v51;
      }
      v46[7] = 0;
      void *v46 = 0;
      v46[1] = 0;
      v46[2] = v34;
      *uint64_t v33 = (uint64_t)v46;
      uint64_t v48 = v46;
      if (*(void *)qword_1EC009500)
      {
        qword_1EC009500 = *(void *)qword_1EC009500;
        uint64_t v48 = (uint64_t *)*v33;
      }
      sub_19E37D324((uint64_t *)qword_1EC009508, v48);
      ++qword_1EC009510;
LABEL_91:
      v46[7] = a1;
      goto LABEL_94;
    }
    if (v51 >= 0) {
      std::string::size_type v31 = __p;
    }
    else {
      std::string::size_type v31 = (void **)__p[0];
    }
    if (v51 >= 0) {
      uint64_t v32 = (void *)HIBYTE(v51);
    }
    else {
      uint64_t v32 = __p[1];
    }
    while (1)
    {
      std::string::size_type v34 = (uint64_t *)v30;
      unint64_t v37 = *(const void **)(v30 + 32);
      uint64_t v35 = v30 + 32;
      size_t v36 = v37;
      int v38 = *(char *)(v35 + 23);
      if (v38 >= 0) {
        uint64_t v39 = (const void *)v35;
      }
      else {
        uint64_t v39 = v36;
      }
      if (v38 >= 0) {
        size_t v40 = *(unsigned __int8 *)(v35 + 23);
      }
      else {
        size_t v40 = *(void *)(v35 + 8);
      }
      if (v40 >= (unint64_t)v32) {
        size_t v41 = (size_t)v32;
      }
      else {
        size_t v41 = v40;
      }
      int v42 = memcmp(v31, v39, v41);
      if (v42)
      {
        if (v42 < 0) {
          goto LABEL_54;
        }
LABEL_68:
        int v43 = memcmp(v39, v31, v41);
        if (v43)
        {
          if ((v43 & 0x80000000) == 0) {
            goto LABEL_90;
          }
        }
        else if (v40 >= (unint64_t)v32)
        {
LABEL_90:
          int v46 = v34;
          goto LABEL_91;
        }
        uint64_t v30 = v34[1];
        if (!v30)
        {
          uint64_t v33 = v34 + 1;
          goto LABEL_84;
        }
      }
      else
      {
        if ((unint64_t)v32 >= v40) {
          goto LABEL_68;
        }
LABEL_54:
        uint64_t v30 = *v34;
        uint64_t v33 = v34;
        if (!*v34) {
          goto LABEL_84;
        }
      }
    }
  }
  int v14 = *((char *)v8 + 55);
  if (v14 >= 0) {
    uint64_t v15 = v8 + 4;
  }
  else {
    uint64_t v15 = (const void *)v8[4];
  }
  if (v14 >= 0) {
    size_t v16 = *((unsigned __int8 *)v8 + 55);
  }
  else {
    size_t v16 = v8[5];
  }
  if (v16 >= (unint64_t)v7) {
    size_t v17 = (size_t)v7;
  }
  else {
    size_t v17 = v16;
  }
  int v18 = memcmp(v6, v15, v17);
  if (v18)
  {
    if (v18 < 0) {
      goto LABEL_41;
    }
  }
  else if ((unint64_t)v7 < v16)
  {
    goto LABEL_41;
  }
  a1 = v8[7];
LABEL_94:
  std::mutex::unlock((std::mutex *)&qword_1EC0094C0);
  if (SHIBYTE(v51) < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_19E429B94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  operator delete(v17);
  std::mutex::unlock((std::mutex *)&qword_1EC0094C0);
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E429BD4(uint64_t a1, CFTypeRef cf, int a3, uint64_t a4, char a5)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  if (cf)
  {
    CFLocaleRef v10 = (const __CFLocale *)CFRetain(cf);
    *(void *)(a1 + 16) = v10;
    *(_DWORD *)(a1 + 24) = a3;
    *(void *)(a1 + 28) = a4;
    *(unsigned char *)(a1 + 36) = a5;
    if (v10)
    {
      CFStringRef Value = (const __CFString *)CFLocaleGetValue(v10, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
      if (CFStringCompare(Value, @"zh", 0))
      {
        if (CFStringCompare(Value, @"ja", 0) && CFStringCompare(Value, @"ko", 0))
        {
          int v13 = 0;
          *(void *)a1 = sub_19E4296D8((uint64_t)cf, &v13);
        }
      }
    }
  }
  else
  {
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = a3;
    *(void *)(a1 + 28) = a4;
    *(unsigned char *)(a1 + 36) = a5;
  }
  return a1;
}

uint64_t sub_19E429CC4(uint64_t a1, UTF32Char a2, unsigned char *a3)
{
  uint64_t result = MEMORY[0x19F3BE760](**(void **)(a1 + 40));
  if (!result)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009388, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EC009388))
    {
      qword_1EC009398 = CEMCreateEmojiCharacterSet();
      __cxa_guard_release(&qword_1EC009388);
    }
    uint64_t result = qword_1EC009398;
    if (!qword_1EC009398
      || (uint64_t result = CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)qword_1EC009398, a2), !result))
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      *a3 = 1;
    }
  }
  return result;
}

void sub_19E429D68(_Unwind_Exception *a1)
{
}

uint64_t sub_19E429D80(uint64_t a1)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 40))
  {
    CFURLRef valuePtr = sub_19E49981C(**(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), @"dynamic");
    sub_19E3C2CE4();
  }
  return 0;
}

void sub_19E42B350(_Unwind_Exception *exception_object)
{
}

os_log_t sub_19E42B35C()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "DynamicData");
  qword_1E9459FA0 = (uint64_t)result;
  return result;
}

__n128 sub_19E42B38C(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void sub_19E42B39C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_19E42B418()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0094B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC0094B0))
  {
    qword_1EC009540 = (uint64_t)dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    __cxa_guard_release(&qword_1EC0094B0);
  }
  uint64_t v0 = &unk_1EC009000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0094B8, memory_order_acquire) & 1) == 0)
  {
    int v2 = __cxa_guard_acquire(&qword_1EC0094B8);
    uint64_t v0 = (void *)&unk_1EC009000;
    if (v2)
    {
      qword_1EC009548 = (uint64_t)dispatch_queue_create("com.apple.NLPUtils.SingletonResourceManager", (dispatch_queue_attr_t)qword_1EC009540);
      __cxa_guard_release(&qword_1EC0094B8);
      uint64_t v0 = (void *)&unk_1EC009000;
    }
  }
  return v0[169];
}

void sub_19E42B4D0(void *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0094A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC0094A8))
  {
    xmmword_1EC009518 = 0u;
    *(_OWORD *)&qword_1EC009528 = 0u;
    dword_1EC009538 = 1065353216;
    __cxa_guard_release(&qword_1EC0094A8);
  }
  int v2 = (uint64_t *)a1[6];
  int v3 = *((char *)v2 + 23);
  if (v3 >= 0) {
    CFStringRef v4 = (uint64_t *)a1[6];
  }
  else {
    CFStringRef v4 = (uint64_t *)*v2;
  }
  if (v3 >= 0) {
    unint64_t v5 = *((unsigned __int8 *)v2 + 23);
  }
  else {
    unint64_t v5 = v2[1];
  }
  unint64_t v6 = sub_19E37BDA4((uint64_t)&v28, v4, v5);
  unint64_t v7 = *((void *)&xmmword_1EC009518 + 1);
  if (*((void *)&xmmword_1EC009518 + 1))
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EC009518 + 8));
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *((void *)&xmmword_1EC009518 + 1)) {
        unint64_t v10 = v6 % *((void *)&xmmword_1EC009518 + 1);
      }
    }
    else
    {
      unint64_t v10 = (*((void *)&xmmword_1EC009518 + 1) - 1) & v6;
    }
    size_t v11 = *(uint64_t ***)(xmmword_1EC009518 + 8 * v10);
    if (v11)
    {
      size_t v12 = *v11;
      if (*v11)
      {
        char v13 = *((unsigned char *)v2 + 23);
        if (v13 >= 0) {
          uint64_t v14 = *((unsigned __int8 *)v2 + 23);
        }
        else {
          uint64_t v14 = v2[1];
        }
        if (v13 < 0) {
          int v2 = (uint64_t *)*v2;
        }
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v15 = *((void *)&xmmword_1EC009518 + 1) - 1;
          while (1)
          {
            uint64_t v20 = v12[1];
            if (v20 == v8)
            {
              uint64_t v21 = *((unsigned __int8 *)v12 + 39);
              if ((v21 & 0x80u) == 0) {
                uint64_t v22 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v22 = v12[3];
              }
              if (v22 == v14)
              {
                if ((v21 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v2, v12[3])) {
                    goto LABEL_55;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    goto LABEL_55;
                  }
                  uint64_t v23 = 0;
                  while (*((unsigned __int8 *)v12 + v23 + 16) == *((unsigned __int8 *)v2 + v23))
                  {
                    if (v21 == ++v23) {
                      goto LABEL_54;
                    }
                  }
                }
              }
            }
            else if ((v20 & v15) != v10)
            {
              goto LABEL_62;
            }
            size_t v12 = (uint64_t *)*v12;
            if (!v12) {
              goto LABEL_62;
            }
          }
        }
        do
        {
          unint64_t v16 = v12[1];
          if (v16 == v8)
          {
            uint64_t v17 = *((unsigned __int8 *)v12 + 39);
            if ((v17 & 0x80u) == 0) {
              uint64_t v18 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v18 = v12[3];
            }
            if (v18 == v14)
            {
              if ((v17 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v2, v12[3]))
                {
LABEL_55:
                  uint64_t v24 = (std::__shared_weak_count *)v12[6];
                  if (v24 && (uint64_t v24 = std::__shared_weak_count::lock(v24)) != 0) {
                    uint64_t v25 = v12[5];
                  }
                  else {
                    uint64_t v25 = 0;
                  }
                  uint64_t v26 = *(void *)(a1[5] + 8);
                  uint64_t v27 = *(std::__shared_weak_count **)(v26 + 48);
                  *(void *)(v26 + 40) = v25;
                  *(void *)(v26 + 48) = v24;
                  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                    std::__shared_weak_count::__release_weak(v27);
                  }
                  break;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  goto LABEL_55;
                }
                uint64_t v19 = 0;
                while (*((unsigned __int8 *)v12 + v19 + 16) == *((unsigned __int8 *)v2 + v19))
                {
                  if (v17 == ++v19)
                  {
LABEL_54:
                    if (!v12) {
                      goto LABEL_62;
                    }
                    goto LABEL_55;
                  }
                }
              }
            }
          }
          else
          {
            if (v16 >= v7) {
              v16 %= v7;
            }
            if (v16 != v10) {
              break;
            }
          }
          size_t v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_62:
  if (!*(void *)(*(void *)(a1[5] + 8) + 40))
  {
    (*(void (**)(void))(a1[4] + 16))();
    operator new();
  }
}

void sub_19E42BDF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E4108F8((uint64_t *)va);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E42BE58(uint64_t a1)
{
  std::mutex::~mutex((std::mutex *)(a1 + 664));
  int v2 = *(std::__shared_weak_count **)(a1 + 648);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(void *)(a1 + 616);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 624);
    unint64_t v5 = *(void **)(a1 + 616);
    if (v4 != v3)
    {
      do
      {
        unint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        v4 -= 16;
      }
      while (v4 != v3);
      unint64_t v5 = *(void **)(a1 + 616);
    }
    *(void *)(a1 + 624) = v3;
    operator delete(v5);
  }
  unint64_t v7 = *(char **)(a1 + 592);
  if (v7)
  {
    do
    {
      unint64_t v8 = *(char **)v7;
      uint8x8_t v9 = (std::__shared_weak_count *)*((void *)v7 + 6);
      if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      if (v7[39] < 0) {
        operator delete(*((void **)v7 + 2));
      }
      operator delete(v7);
      unint64_t v7 = v8;
    }
    while (v8);
  }
  unint64_t v10 = *(void **)(a1 + 576);
  *(void *)(a1 + 576) = 0;
  if (v10) {
    operator delete(v10);
  }
  size_t v11 = *(std::__shared_weak_count **)(a1 + 568);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  size_t v12 = *(std::__shared_weak_count **)(a1 + 552);
  if (!v12 || atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((*(char *)(a1 + 535) & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (*(char *)(a1 + 535) < 0) {
LABEL_29:
  }
    operator delete(*(void **)(a1 + 512));
LABEL_30:
  sub_19E3D7670(a1 + 40);
  char v13 = *(const void **)(a1 + 32);
  if (v13) {
    CFRelease(v13);
  }
  uint64_t v14 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  if (v14)
  {
    uint64_t v15 = sub_19E40FD94(v14);
    MEMORY[0x19F3BDCF0](v15, 0x1072C40AE5FB29CLL);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E42C0E8(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__110shared_ptrIN2LM11DynamicDataEE27__shared_ptr_default_deleteIS2_S2_EE"
    || ((v3 & (unint64_t)"NSt3__110shared_ptrIN2LM11DynamicDataEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__110shared_ptrIN2LM11DynamicDataEE27__shared_ptr_default_deleteIS2_S2_EE")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__110shared_ptrIN2LM11DynamicDataEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E42C140(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_19E42BE58(result);
    JUMPOUT(0x19F3BDCF0);
  }
  return result;
}

void sub_19E42C188(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t *sub_19E42C1C4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::mutex::~mutex((std::mutex *)(v2 + 96));
    unint64_t v3 = *(const void **)(v2 + 8);
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(v2 + 8) = 0;
    if (*(void *)v2) {
      CFRelease(*(CFTypeRef *)v2);
    }
    *(void *)uint64_t v2 = 0;
    MEMORY[0x19F3BDCF0](v2, 0x1060C40530E8172);
  }
  return a1;
}

void sub_19E42C23C(void *a1, uint64_t a2)
{
  *a1 = 0;
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v2 = (const char *)a2;
  }
  else {
    uint64_t v2 = *(const char **)a2;
  }
  int v3 = open_dprotected_np(v2, 0, 3, 0, 0);
  if ((v3 & 0x80000000) == 0)
  {
    fcntl(v3, 64, 3);
    operator new();
  }
  operator new();
}

void sub_19E42C3A0(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v2, 0x20C4093837F09);
  sub_19E42C508(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E42C4C0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_19E4C6030(v2);
    MEMORY[0x19F3BDCF0](v3, 0x1060C4064AC95D2);
  }
  return a1;
}

uint64_t **sub_19E42C508(uint64_t **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*v2)
    {
      sub_19E374B30(v2);
      if (*v2) {
        MEMORY[0x19F3BDCF0](*v2, 0x1010C4006136809);
      }
    }
    MEMORY[0x19F3BDCF0](v2, 0x20C4093837F09);
  }
  return a1;
}

void sub_19E42C57C(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 664);
  std::mutex::lock((std::mutex *)(a1 + 664));
  (*(void (**)(void))(**(void **)(a1 + 640) + 168))(*(void *)(a1 + 640));
  uint64_t v4 = (const std::__fs::filesystem::path **)(a1 + 512);
  if (*(char *)(a1 + 535) < 0)
  {
    if ((remove(*v4, v3) & 0x80000000) == 0) {
      goto LABEL_9;
    }
  }
  else if ((remove((const std::__fs::filesystem::path *)v4, v3) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  if (qword_1E9459FA8 != -1) {
    dispatch_once(&qword_1E9459FA8, &unk_1EF0B5D60);
  }
  unint64_t v5 = qword_1E9459FA0;
  if (os_log_type_enabled((os_log_t)qword_1E9459FA0, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_19E36B000, v5, OS_LOG_TYPE_DEFAULT, "failed to remove dynamic model", (uint8_t *)&__p, 2u);
  }
LABEL_9:
  uint64_t v6 = *(void *)(a1 + 560);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 112))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 616);
  for (uint64_t i = *(void *)(a1 + 624); v7 != i; v7 += 16)
    (*(void (**)(void))(**(void **)v7 + 112))();
  uint64_t v9 = *(void *)(a1 + 544);
  std::mutex::lock((std::mutex *)(v9 + 96));
  *(void *)(v9 + 32) = 0;
  *(void *)(v9 + 40) = 0;
  *(CFAbsoluteTime *)(v9 + 48) = CFAbsoluteTimeGetCurrent();
  *(_OWORD *)(v9 + 56) = 0u;
  *(_OWORD *)(v9 + 72) = 0u;
  *(void *)(v9 + 88) = 0;
  *(_WORD *)(v9 + 24) = 257;
  if (*(void *)(v9 + 8)) {
    sub_19E3C2CE4();
  }
  std::mutex::unlock((std::mutex *)(v9 + 96));
  std::mutex::unlock(v2);
}

void sub_19E42C798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(v15);
  std::mutex::unlock(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_19E42C7DC(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(char **)v2;
      uint64_t v4 = (std::__shared_weak_count *)*((void *)v2 + 6);
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v2[39] < 0) {
        operator delete(*((void **)v2 + 2));
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

uint64_t sub_19E42C8A4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E42C8C8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE370;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E42C91C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE370;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_19E42C940(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E42C964(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE4C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E42C9B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE4C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_19E42C9DC(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__114default_deleteIN2LM15NgramPoolFacadeEEE"
    || ((v3 & (unint64_t)"NSt3__114default_deleteIN2LM15NgramPoolFacadeEEE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__114default_deleteIN2LM15NgramPoolFacadeEEE")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__114default_deleteIN2LM15NgramPoolFacadeEEE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E42CA34(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_19E42CA64(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E42CAA4(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__114default_deleteIN2LM28DynamicLanguageModelMetadataEEE"
    || ((v3 & (unint64_t)"NSt3__114default_deleteIN2LM28DynamicLanguageModelMetadataEEE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__114default_deleteIN2LM28DynamicLanguageModelMetadataEEE")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__114default_deleteIN2LM28DynamicLanguageModelMetadataEEE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E42CAFC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    std::mutex::~mutex((std::mutex *)(v1 + 96));
    uint64_t v2 = *(const void **)(v1 + 8);
    if (v2) {
      CFRelease(v2);
    }
    *(void *)(v1 + 8) = 0;
    if (*(void *)v1) {
      CFRelease(*(CFTypeRef *)v1);
    }
    *(void *)uint64_t v1 = 0;
    JUMPOUT(0x19F3BDCF0);
  }
  return result;
}

void sub_19E42CB80(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E42CBBC(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 24);
  if (!v1) {
    sub_19E3ACB9C();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

void sub_19E42CC10(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0094A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC0094A8))
  {
    xmmword_1EC009518 = 0u;
    *(_OWORD *)&qword_1EC009528 = 0u;
    dword_1EC009538 = 1065353216;
    __cxa_guard_release(&qword_1EC0094A8);
  }
  uint64_t v2 = (void *)qword_1EC009528;
  if (qword_1EC009528)
  {
    do
    {
      unint64_t v3 = (std::__shared_weak_count *)v2[6];
      if (v3)
      {
        uint64_t v4 = std::__shared_weak_count::lock(v3);
        if (v4)
        {
          unint64_t v5 = v4;
          uint64_t v6 = v2[5];
          if (v6) {
            (*(void (**)(void, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), v6);
          }
          if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
      }
      uint64_t v2 = (void *)*v2;
    }
    while (v2);
  }
}

void sub_19E42CD18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_19E42CD2C(uint64_t *a1, int a2, double a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (std::mutex *)(a1 + 83);
  std::mutex::lock((std::mutex *)(a1 + 83));
  uint64_t v7 = a1[68];
  std::mutex::lock((std::mutex *)(v7 + 96));
  double v8 = *(double *)(v7 + 56);
  if (v8 == 0.0) {
    double v9 = *(double *)(v7 + 56);
  }
  else {
    double v9 = a3 - v8;
  }
  std::mutex::unlock((std::mutex *)(v7 + 96));
  float v10 = floor(v9 / *((float *)a1 + 63));
  if (a2 && (float v11 = 1.0, v10 < 1.0) || (float v11 = v10, v10 > 0.0))
  {
    float v12 = expf(*((float *)a1 + 62) * v11);
    if (qword_1E9459FA8 != -1) {
      dispatch_once(&qword_1E9459FA8, &unk_1EF0B5D60);
    }
    char v13 = qword_1E9459FA0;
    if (os_log_type_enabled((os_log_t)qword_1E9459FA0, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = a1;
      if (*((char *)a1 + 23) < 0) {
        uint64_t v14 = (uint64_t *)*a1;
      }
      int buf = 136315138;
      *(void *)buf_4 = v14;
      _os_log_impl(&dword_19E36B000, v13, OS_LOG_TYPE_INFO, "applying exponential decay for dynamic model bundle: %s", (uint8_t *)&buf, 0xCu);
    }
    (*(void (**)(uint64_t, float))(*(void *)a1[80] + 136))(a1[80], v12);
    uint64_t v15 = a1[68];
    std::mutex::lock((std::mutex *)(v15 + 96));
    *(CFAbsoluteTime *)(v15 + 56) = CFAbsoluteTimeGetCurrent();
    *(void *)(v15 + 32) = 0;
    *(unsigned char *)(v15 + 24) = 1;
    std::mutex::unlock((std::mutex *)(v15 + 96));
  }
  CFURLRef v16 = *(const __CFURL **)(a1[3] + 16);
  if (v16 && *((unsigned char *)a1 + 404))
  {
    CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, v16);
    sub_19E4D9B70(PathComponent);
  }
  std::mutex::unlock(v6);
}

void sub_19E42CF90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E42CFDC(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 664);
  std::mutex::lock((std::mutex *)(a1 + 664));
  uint64_t v3 = *(void *)(a1 + 544);
  uint64_t v4 = (std::mutex *)(v3 + 96);
  std::mutex::lock((std::mutex *)(v3 + 96));
  LODWORD(v3) = *(unsigned __int8 *)(v3 + 24);
  std::mutex::unlock(v4);
  if (!v3) {
    goto LABEL_50;
  }
  unint64_t v5 = (const char *)a1;
  if (*(char *)(a1 + 23) < 0) {
    unint64_t v5 = *(const char **)a1;
  }
  uint64_t v6 = (const std::__fs::filesystem::path *)(a1 + 512);
  if (*(char *)(a1 + 535) < 0) {
    uint64_t v6 = (const std::__fs::filesystem::path *)v6->__pn_.__r_.__value_.__r.__words[0];
  }
  v56[0] = MEMORY[0x1E4F143A8];
  v56[1] = 0x40000000;
  std::string v57 = sub_19E42D690;
  UniChar v58 = &unk_1E599F7D8;
  uint64_t v59 = a1;
  *__error() = 0;
  size_t v7 = strlen(v5);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  double v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    double v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    unint64_t v61 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_13;
  }
  HIBYTE(v61) = v7;
  double v9 = __dst;
  if (v7) {
LABEL_13:
  }
    memcpy(v9, v5, (size_t)v8);
  *((unsigned char *)v8 + (void)v9) = 0;
  sub_19E3C300C((uint64_t)__dst, (uint64_t)__p);
  if ((SHIBYTE(v61) & 0x80000000) == 0)
  {
    int v18 = v63;
    if ((v63 & 0x80000000) == 0) {
      goto LABEL_16;
    }
LABEL_19:
    if (!__p[1]) {
      goto LABEL_32;
    }
    uint64_t v19 = (void **)__p[0];
LABEL_21:
    uint64_t v20 = sub_19E439480((const char *)v19, 1538, v12, v13, v14, v15, v16, v17, 0x180u);
    if ((v20 & 0x80000000) == 0)
    {
      int v21 = ((uint64_t (*)(void *, uint64_t))v57)(v56, v20);
      close(v20);
      if (v21)
      {
        uint64_t v24 = v63 >= 0 ? (const std::__fs::filesystem::path *)__p : (const std::__fs::filesystem::path *)__p[0];
        rename(v24, v6, v23);
        if ((v25 & 0x80000000) == 0)
        {
LABEL_32:
          if (v63 < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_34;
        }
      }
      if (v63 >= 0) {
        uint64_t v26 = (const std::__fs::filesystem::path *)__p;
      }
      else {
        uint64_t v26 = (const std::__fs::filesystem::path *)__p[0];
      }
      remove(v26, v22);
    }
    __error();
    CFLog();
    goto LABEL_32;
  }
  operator delete(__dst[0]);
  int v18 = v63;
  if (v63 < 0) {
    goto LABEL_19;
  }
LABEL_16:
  if (v18)
  {
    uint64_t v19 = __p;
    goto LABEL_21;
  }
LABEL_34:
  (*(void (**)(void))(**(void **)(a1 + 560) + 168))(*(void *)(a1 + 560));
  uint64_t v28 = *(void **)(a1 + 616);
  for (uint64_t i = *(void **)(a1 + 624); v28 != i; v28 += 2)
    (*(void (**)(void, uint64_t))(*(void *)*v28 + 168))(*v28, v27);
  uint64_t v30 = *(void *)(a1 + 640);
  __p[0] = 0;
  char v31 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v30 + 208))(v30, __p);
  if (!__p[0]) {
    char v31 = 1;
  }
  if ((v31 & 1) == 0)
  {
    CFStringRef v54 = CFErrorCopyDescription((CFErrorRef)__p[0]);
    CFLog();
    CFRelease(v54);
    CFRelease(__p[0]);
  }
  uint64_t v32 = *(void *)(a1 + 544);
  __p[0] = 0;
  std::mutex::lock((std::mutex *)(v32 + 96));
  CFStringRef v33 = CFStringCreateWithFormat(0, 0, @"%d.%d", *(unsigned int *)(v32 + 16), *(unsigned int *)(v32 + 20));
  CFDictionarySetValue(*(CFMutableDictionaryRef *)v32, @"adaptationVersion", v33);
  CFRelease(v33);
  *(CFAbsoluteTime *)(v32 + 88) = CFAbsoluteTimeGetCurrent();
  std::string::size_type v34 = *(__CFDictionary **)v32;
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(v32 + 56));
  CFDictionarySetValue(v34, @"lastDecay", v35);
  CFRelease(v35);
  size_t v36 = *(__CFDictionary **)v32;
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(v32 + 64));
  CFDictionarySetValue(v36, @"lastPruning", v37);
  CFRelease(v37);
  int v38 = *(__CFDictionary **)v32;
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(v32 + 48));
  CFDictionarySetValue(v38, @"creationTime", v39);
  CFRelease(v39);
  size_t v40 = *(__CFDictionary **)v32;
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberCFIndexType, (const void *)(v32 + 32));
  CFDictionarySetValue(v40, @"wordsSinceLastDecay", v41);
  CFRelease(v41);
  int v42 = *(__CFDictionary **)v32;
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(v32 + 80));
  CFDictionarySetValue(v42, @"lastOfflineAdaptationTime1", v43);
  CFRelease(v43);
  uint64_t v44 = *(__CFDictionary **)v32;
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(v32 + 72));
  CFDictionarySetValue(v44, @"lastOfflineAdaptationTime2", v45);
  CFRelease(v45);
  int v46 = *(__CFDictionary **)v32;
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(v32 + 88));
  CFDictionarySetValue(v46, @"lastFlushTimeKey", v47);
  CFRelease(v47);
  uint64_t v48 = *(__CFDictionary **)v32;
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberLongType, (const void *)(v32 + 40));
  CFDictionarySetValue(v48, @"numberOfTokensTyped", v49);
  CFRelease(v49);
  uint64_t v50 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!*(unsigned char *)(v32 + 25)) {
    uint64_t v50 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)v32, @"didResetMessages", *v50);
  *(unsigned char *)(v32 + 24) = 0;
  BOOL v51 = sub_19E3C2D94(*(const void **)v32, *(CFURLRef *)(v32 + 8), kCFPropertyListBinaryFormat_v1_0, 1, (CFErrorRef *)__p);
  std::mutex::unlock((std::mutex *)(v32 + 96));
  if (__p[0]) {
    char v52 = v51;
  }
  else {
    char v52 = 1;
  }
  if ((v52 & 1) == 0)
  {
    CFStringRef v55 = CFErrorCopyDescription((CFErrorRef)__p[0]);
    CFLog();
    CFRelease(v55);
    CFRelease(__p[0]);
  }
  CFURLRef v53 = *(const __CFURL **)(*(void *)(a1 + 24) + 16);
  if (v53 && *(unsigned char *)(a1 + 404))
  {
    __dst[0] = CFURLCreateCopyDeletingLastPathComponent(0, v53);
    sub_19E4D9B70((CFURLRef)__dst[0]);
  }
LABEL_50:
  std::mutex::unlock(v2);
}

void sub_19E42D618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_19E3F6888((const void **)&a17);
  std::mutex::unlock(v28);
  _Unwind_Resume(a1);
}

uint64_t sub_19E42D690(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 640) + 176))();
}

BOOL sub_19E42D6BC(uint64_t a1, void **__s1)
{
  uint64_t v2 = (void *)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    size_t v3 = *(void *)(a1 + 40);
  }
  else {
    size_t v3 = *(unsigned __int8 *)(a1 + 55);
  }
  if ((*((char *)__s1 + 23) & 0x80000000) == 0)
  {
    if (v3 != -1)
    {
      size_t v4 = *((unsigned __int8 *)__s1 + 23);
      goto LABEL_9;
    }
LABEL_20:
    sub_19E3C4C28();
  }
  if (v3 == -1) {
    goto LABEL_20;
  }
  unint64_t v5 = __s1;
  std::string __s1 = (void **)*__s1;
  size_t v4 = (size_t)v5[1];
LABEL_9:
  if (v4 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v4;
  }
  if (*(char *)(a1 + 55) < 0) {
    uint64_t v2 = (void *)*v2;
  }
  return !memcmp(__s1, v2, v6) && v6 == v3;
}

void sub_19E42D750(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0094A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC0094A8))
  {
    xmmword_1EC009518 = 0u;
    *(_OWORD *)&qword_1EC009528 = 0u;
    dword_1EC009538 = 1065353216;
    __cxa_guard_release(&qword_1EC0094A8);
  }
  uint64_t v2 = (uint64_t *)qword_1EC009528;
  if (qword_1EC009528)
  {
    while (1)
    {
      uint64_t v16 = 0;
      size_t v3 = (std::__shared_weak_count *)v2[6];
      if (!v3) {
        break;
      }
      uint64_t v16 = std::__shared_weak_count::lock(v3);
      if (!v16
        || !v2[5]
        || (*(unsigned int (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32)))
      {
        break;
      }
      uint64_t v2 = (uint64_t *)*v2;
      uint64_t v15 = v16;
LABEL_40:
      if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
LABEL_4:
      if (!v2) {
        return;
      }
    }
    unint64_t v4 = *((void *)&xmmword_1EC009518 + 1);
    unint64_t v5 = v2[1];
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EC009518 + 8));
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      if (v5 >= *((void *)&xmmword_1EC009518 + 1)) {
        v5 %= *((void *)&xmmword_1EC009518 + 1);
      }
    }
    else
    {
      v5 &= *((void *)&xmmword_1EC009518 + 1) - 1;
    }
    size_t v7 = (uint64_t *)*v2;
    double v8 = *(uint64_t **)(xmmword_1EC009518 + 8 * v5);
    do
    {
      double v9 = v8;
      double v8 = (uint64_t *)*v8;
    }
    while (v8 != v2);
    if (v9 == &qword_1EC009528) {
      goto LABEL_48;
    }
    unint64_t v10 = v9[1];
    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= *((void *)&xmmword_1EC009518 + 1)) {
        v10 %= *((void *)&xmmword_1EC009518 + 1);
      }
    }
    else
    {
      v10 &= *((void *)&xmmword_1EC009518 + 1) - 1;
    }
    uint64_t v11 = *v2;
    if (v10 != v5)
    {
LABEL_48:
      if (v7)
      {
        unint64_t v12 = v7[1];
        if (v6.u32[0] > 1uLL)
        {
          if (v12 >= *((void *)&xmmword_1EC009518 + 1)) {
            v12 %= *((void *)&xmmword_1EC009518 + 1);
          }
        }
        else
        {
          v12 &= *((void *)&xmmword_1EC009518 + 1) - 1;
        }
        uint64_t v11 = *v2;
        if (v12 == v5)
        {
LABEL_29:
          unint64_t v13 = *(void *)(v11 + 8);
          if (v6.u32[0] > 1uLL)
          {
            if (v13 >= v4) {
              v13 %= v4;
            }
          }
          else
          {
            v13 &= v4 - 1;
          }
          if (v13 != v5)
          {
            *(void *)(xmmword_1EC009518 + 8 * v13) = v9;
            uint64_t v11 = *v2;
          }
LABEL_35:
          *double v9 = v11;
          *uint64_t v2 = 0;
          --qword_1EC009530;
          uint64_t v14 = (std::__shared_weak_count *)v2[6];
          if (v14) {
            std::__shared_weak_count::__release_weak(v14);
          }
          if (*((char *)v2 + 39) < 0) {
            operator delete((void *)v2[2]);
          }
          operator delete(v2);
          uint64_t v2 = v7;
          uint64_t v15 = v16;
          if (!v16) {
            goto LABEL_4;
          }
          goto LABEL_40;
        }
      }
      *(void *)(xmmword_1EC009518 + 8 * v5) = 0;
      uint64_t v11 = *v2;
    }
    if (!v11) {
      goto LABEL_35;
    }
    goto LABEL_29;
  }
}

void sub_19E42D9F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_19E42DA08(uint64_t a1)
{
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  char v19 = 1;
  uint64_t v2 = (const char **)(a1 + 40);
  int v3 = *(char *)(a1 + 63);
  unint64_t v4 = (const char *)(a1 + 40);
  if (v3 < 0) {
    unint64_t v4 = *v2;
  }
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 1174405120;
  uint64_t v11 = sub_19E42DC2C;
  unint64_t v12 = &unk_1EF0BEA70;
  unint64_t v13 = &v16;
  if (v3 < 0)
  {
    sub_19E39369C(&__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    long long __p = *(_OWORD *)v2;
    uint64_t v15 = *(void *)(a1 + 56);
  }
  if (!stat(v4, &v21) && (v21.st_mode & 0xF000) == 0x4000)
  {
    char v20 = 0;
    unint64_t v5 = opendir(v4);
    if (v5)
    {
      do
      {
        uint8x8_t v6 = readdir(v5);
        if (!v6) {
          break;
        }
        unint64_t d_namlen = v6->d_namlen;
        if (d_namlen >= 0xB)
        {
          d_name = v6->d_name;
          if (!strncmp((const char *)&v6->d_seekoff + d_namlen + 3, "dynamic.lm", 0xAuLL)) {
            v11((uint64_t)v10, d_name, &v20);
          }
        }
      }
      while (!v20);
      closedir(v5);
    }
  }
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9) {
    (*(void (**)(uint64_t, void))(v9 + 16))(v9, *((unsigned __int8 *)v17 + 24));
  }
  if (SHIBYTE(v15) < 0) {
    operator delete((void *)__p);
  }
  _Block_object_dispose(&v16, 8);
}

void sub_19E42DBB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
}

void sub_19E42DBE8(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void *sub_19E42DBFC(uint64_t a1, uint64_t a2)
{
  uint64_t result = (void *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0) {
    return sub_19E39369C(result, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  long long v3 = *(_OWORD *)(a2 + 40);
  result[2] = *(void *)(a2 + 56);
  *(_OWORD *)uint64_t result = v3;
  return result;
}

void sub_19E42DC2C(uint64_t a1, char *__s, unsigned char *a3)
{
  int v3 = *(char *)(a1 + 63);
  if (v3 >= 0) {
    size_t v4 = *(unsigned __int8 *)(a1 + 63);
  }
  else {
    size_t v4 = *(void *)(a1 + 48);
  }
  unint64_t v5 = v4 + 1;
  if (v4 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  if (v5 >= 0x17)
  {
    uint64_t v10 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v10 = v5 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v4 + 1;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v4 + 1;
    if (!v4) {
      goto LABEL_15;
    }
  }
  if (v3 >= 0) {
    unint64_t v12 = (const void *)(a1 + 40);
  }
  else {
    unint64_t v12 = *(const void **)(a1 + 40);
  }
  memmove(p_dst, v12, v4);
LABEL_15:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v4) = 47;
  std::string::size_type v13 = strlen(__s);
  uint64_t v14 = std::string::append(&__dst, __s, v13);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  int64_t v24 = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (v24 >= 0) {
    uint64_t v16 = __p;
  }
  else {
    uint64_t v16 = (void **)__p[0];
  }
  uint64_t v17 = opendir((const char *)v16);
  if (v17)
  {
    strlen((const char *)v16);
    while (1)
    {
      uint64_t v18 = readdir(v17);
      if (!v18) {
        break;
      }
      d_name = v18->d_name;
      if (strcmp(v18->d_name, "."))
      {
        if (strcmp(d_name, ".."))
        {
          strlen(d_name);
          operator new[]();
        }
      }
    }
    closedir(v17);
    BOOL v20 = rmdir((const char *)v16) == 0;
  }
  else
  {
    BOOL v20 = 0;
  }
  uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v21 + 24)) {
    BOOL v20 = 0;
  }
  *(unsigned char *)(v21 + 24) = v20;
  if (SHIBYTE(v24) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_30;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_30;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_30:
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    *a3 = 1;
  }
}

void sub_19E42DEF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if ((a17 & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_19E42DF40(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void *sub_19E42DF54(uint64_t a1, uint64_t a2)
{
  uint64_t result = (void *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0) {
    return sub_19E39369C(result, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  long long v3 = *(_OWORD *)(a2 + 32);
  result[2] = *(void *)(a2 + 48);
  *(_OWORD *)uint64_t result = v3;
  return result;
}

void *sub_19E42DF84(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  *a1 = &unk_1EF0BAD68;
  a1[1] = v4;
  a1[2] = 0;
  sub_19E4F9E3C((uint64_t)(a1 + 3), a3);
  return a1;
}

void sub_19E42DFE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10)
{
  uint64_t v12 = *(void *)(v10 + 16);
  *(void *)(v10 + 16) = 0;
  if (v12)
  {
    uint64_t v13 = sub_19E4C6030(v12);
    MEMORY[0x19F3BDCF0](v13, 0x1060C4064AC95D2);
  }
  uint64_t v14 = *(uint64_t **)(v10 + 8);
  *(void *)(v10 + 8) = 0;
  if (v14)
  {
    long long v15 = sub_19E528DAC(v14);
    MEMORY[0x19F3BDCF0](v15, 0x20C4093837F09);
  }
  sub_19E42C4C0(&a9);
  sub_19E42C508(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_19E42E054(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E42E078(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE3E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E42E0CC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE3E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_19E42E0EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(*(void *)a3 + 357))
  {
    if (sub_19E4998CC(*(void *)(a2 + 24), @"recency"))
    {
      CFTypeRef cf = sub_19E49981C(*(void *)(a2 + 24), @"recency");
      sub_19E3C2CE4();
    }
  }
  operator new();
}

void sub_19E42E548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,const void *a21)
{
  sub_19E3D73EC((uint64_t)&a10);
  MEMORY[0x19F3BDCF0](v21, 0x10B1C403F1E130DLL);
  sub_19E3D73EC((uint64_t)&a12);
  sub_19E42C508(&a14);
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_19E3F6888(&a21);
  _Unwind_Resume(a1);
}

void sub_19E42E5D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, uint64_t *);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  sub_19E3D73EC((uint64_t)va1);
  MEMORY[0x19F3BDCF0](v2, 0x10B1C403F1E130DLL);
  sub_19E3D73EC((uint64_t)va2);
  sub_19E42C508((uint64_t **)va);
  _Unwind_Resume(a1);
}

void sub_19E42E638(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

void sub_19E42E65C(uint64_t a1, uint64_t a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  if (v3 >= 0) {
    size_t v4 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v4 = (size_t)a3[1];
  }
  unint64_t v5 = v4 + 1;
  if (v4 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  if (v5 >= 0x17)
  {
    uint64_t v9 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v9 = v5 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v11 = (char *)operator new(v9 + 1);
    size_t v14 = v4 + 1;
    unint64_t v15 = v10 | 0x8000000000000000;
    long long __p = v11;
    char *v11 = 45;
    double v8 = v11 + 1;
  }
  else
  {
    size_t v14 = 0;
    unint64_t v15 = 0;
    HIBYTE(v15) = v4 + 1;
    double v8 = (char *)&__p + 1;
    long long __p = (void *)45;
    if (!v4) {
      goto LABEL_15;
    }
  }
  if (v3 >= 0) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = *a3;
  }
  memmove(v8, v12, v4);
LABEL_15:
  v8[v4] = 0;
  sub_19E42E7F4(&theString, @"dynamic-lexicon", (uint64_t)&__p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  long long __p = sub_19E49981C(*(void *)(a2 + 24), theString);
  sub_19E3C2CE4();
}

void sub_19E42E7B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, const void *a12)
{
}

void sub_19E42E7D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E42E7F4(CFStringRef *a1, CFTypeRef cf, uint64_t a3)
{
  if (cf)
  {
    CFRetain(cf);
    sub_19E372124(&v28, cf);
    CFStringRef v6 = v28;
    if (!v28)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(v6))
    {
      sub_19E3C6934(&v25, v6);
    }
    else
    {
      v25.__r_.__value_.__r.__words[0] = 0;
      *((unsigned char *)&v25.__r_.__value_.__s + 23) = 0;
    }
    int v13 = *(char *)(a3 + 23);
    if (v13 >= 0) {
      size_t v14 = (const std::string::value_type *)a3;
    }
    else {
      size_t v14 = *(const std::string::value_type **)a3;
    }
    if (v13 >= 0) {
      std::string::size_type v15 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      std::string::size_type v15 = *(void *)(a3 + 8);
    }
    uint64_t v16 = std::string::append(&v25, v14, v15);
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    int64_t v27 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    char v18 = HIBYTE(v27);
    if (v27 >= 0) {
      char v19 = __p;
    }
    else {
      char v19 = (void **)__p[0];
    }
    if (v19)
    {
      if (v27 >= 0) {
        CFIndex v20 = HIBYTE(v27);
      }
      else {
        CFIndex v20 = (CFIndex)__p[1];
      }
      CFStringRef v21 = CFStringCreateWithBytes(0, (const UInt8 *)v19, v20, 0x8000100u, 0);
      *a1 = v21;
      if (!v21)
      {
        int64_t v24 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](v24, "Could not construct");
        __cxa_throw(v24, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      if ((v27 & 0x8000000000000000) == 0)
      {
LABEL_32:
        CFStringRef v22 = v28;
        if (!v28) {
          return;
        }
LABEL_36:
        CFRelease(v22);
        return;
      }
    }
    else
    {
      *a1 = 0;
      if ((v18 & 0x80) == 0) {
        goto LABEL_32;
      }
    }
    operator delete(__p[0]);
    CFStringRef v22 = v28;
    if (v28) {
      goto LABEL_36;
    }
  }
  else
  {
    char v8 = *(unsigned char *)(a3 + 23);
    if (v8 >= 0) {
      uint64_t v9 = (const UInt8 *)a3;
    }
    else {
      uint64_t v9 = *(const UInt8 **)a3;
    }
    if (v9)
    {
      if (v8 >= 0) {
        CFIndex v10 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        CFIndex v10 = *(void *)(a3 + 8);
      }
      CFStringRef v11 = CFStringCreateWithBytes(0, v9, v10, 0x8000100u, 0);
      *a1 = v11;
      if (!v11)
      {
        uint64_t v12 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](v12, "Could not construct");
        __cxa_throw(v12, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    else
    {
      *a1 = 0;
    }
  }
}

void sub_19E42EA34(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E42EA48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_19E3C6F1C((const void **)(v21 - 40));
  _Unwind_Resume(a1);
}

uint64_t *sub_19E42EAB8(void *a1, uint64_t a2)
{
  uint64_t v2 = (unsigned char *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v5 = v4;
  }
  unint64_t v6 = sub_19E37BDA4((uint64_t)&v25, (uint64_t *)a2, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (v7)
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *(void *)&v7) {
        unint64_t v10 = v6 % *(void *)&v7;
      }
    }
    else
    {
      unint64_t v10 = (*(void *)&v7 - 1) & v6;
    }
    CFStringRef v11 = *(uint64_t ***)(*a1 + 8 * v10);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (*v11)
      {
        char v13 = v2[23];
        if (v13 >= 0) {
          uint64_t v14 = v2[23];
        }
        else {
          uint64_t v14 = *((void *)v2 + 1);
        }
        if (v13 < 0) {
          uint64_t v2 = *(unsigned char **)v2;
        }
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v15 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v21 = v12[1];
            if (v8 == v21)
            {
              uint64_t v22 = *((unsigned __int8 *)v12 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v23 = v12[3];
              }
              if (v23 == v14)
              {
                if ((v22 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v2, v12[3])) {
                    return v12;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    return v12;
                  }
                  uint64_t v24 = 0;
                  while (*((unsigned __int8 *)v12 + v24 + 16) == v2[v24])
                  {
                    if (v22 == ++v24) {
                      return v12;
                    }
                  }
                }
              }
            }
            else if ((v21 & v15) != v10)
            {
              return 0;
            }
            uint64_t result = 0;
            uint64_t v12 = (uint64_t *)*v12;
            if (!v12) {
              return result;
            }
          }
        }
        while (1)
        {
          unint64_t v17 = v12[1];
          if (v8 == v17)
          {
            uint64_t v18 = *((unsigned __int8 *)v12 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v19 = v12[3];
            }
            if (v19 == v14)
            {
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v2, v12[3])) {
                  return v12;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  return v12;
                }
                uint64_t v20 = 0;
                while (*((unsigned __int8 *)v12 + v20 + 16) == v2[v20])
                {
                  if (v18 == ++v20) {
                    return v12;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= *(void *)&v7) {
              v17 %= *(void *)&v7;
            }
            if (v17 != v10) {
              return 0;
            }
          }
          uint64_t result = 0;
          uint64_t v12 = (uint64_t *)*v12;
          if (!v12) {
            return result;
          }
        }
      }
    }
  }
  return 0;
}

char *sub_19E42ECB8(char **a1, void *a2)
{
  int v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = v2 - *a1;
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = (v4 >> 3) + 1;
  if (v6 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v9 = a1[2] - v3;
  if (v9 >> 2 > v6) {
    unint64_t v6 = v9 >> 2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 >> 61) {
      sub_19E37C2B8();
    }
    CFStringRef v11 = (char *)operator new(8 * v10);
  }
  else
  {
    CFStringRef v11 = 0;
  }
  uint64_t v12 = &v11[8 * v5];
  char v13 = &v11[8 * v10];
  *(void *)uint64_t v12 = *a2;
  uint64_t v14 = v12 + 8;
  *a2 = 0;
  if (v2 != v3)
  {
    unint64_t v15 = v2 - v3 - 8;
    if (v15 < 0x78) {
      goto LABEL_22;
    }
    if (&v11[v4 - (v15 & 0xFFFFFFFFFFFFFFF8) - 8] < v2 && &v2[-(v15 & 0xFFFFFFFFFFFFFFF8) - 8] < v12) {
      goto LABEL_22;
    }
    uint64_t v17 = (v15 >> 3) + 1;
    v12 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v18 = v2 - 32;
    uint64_t v19 = &v11[8 * v5 - 16];
    uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v21 = *((_OWORD *)v18 + 1);
      *((_OWORD *)v19 - 1) = *(_OWORD *)v18;
      *(_OWORD *)uint64_t v19 = v21;
      *(_OWORD *)uint64_t v18 = 0uLL;
      *((_OWORD *)v18 + 1) = 0uLL;
      v18 -= 32;
      v19 -= 32;
      v20 -= 4;
    }
    while (v20);
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v2 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
      do
      {
LABEL_22:
        uint64_t v22 = *((void *)v2 - 1);
        v2 -= 8;
        *((void *)v12 - 1) = v22;
        v12 -= 8;
        *(void *)uint64_t v2 = 0;
      }
      while (v2 != v3);
    }
  }
  uint64_t v23 = *a1;
  uint64_t v24 = a1[1];
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  while (v24 != v23)
  {
    uint64_t v26 = (const void *)*((void *)v24 - 1);
    v24 -= 8;
    char v25 = v26;
    if (v26) {
      CFRelease(v25);
    }
  }
  if (v23) {
    operator delete(v23);
  }
  return v14;
}

uint64_t *sub_19E42EE40(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      int v3 = *(std::__shared_weak_count **)(v2 + 48);
      if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
        if ((*(char *)(v2 + 39) & 0x80000000) == 0) {
          goto LABEL_7;
        }
        goto LABEL_6;
      }
      if (*(char *)(v2 + 39) < 0) {
LABEL_6:
      }
        operator delete(*(void **)(v2 + 16));
    }
LABEL_7:
    operator delete((void *)v2);
  }
  return a1;
}

void sub_19E42EEEC(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(char **)a1;
  if (a2 <= (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) {
    return;
  }
  if (a2 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v4 = *(char **)(a1 + 8);
  uint64_t v5 = 8 * a2;
  unint64_t v6 = (char *)operator new(8 * a2);
  int8x8_t v7 = &v6[v5];
  uint64_t v8 = v4 - v2;
  unint64_t v9 = (unint64_t)&v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
  if (v4 == v2)
  {
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = v9;
    *(void *)(a1 + 16) = v7;
    goto LABEL_7;
  }
  unint64_t v10 = v8 - 8;
  if ((unint64_t)(v8 - 8) > 0x77)
  {
    BOOL v12 = &v6[(v8 & 0xFFFFFFFFFFFFFFF8) - (v10 & 0xFFFFFFFFFFFFFFF8) - 8] >= v4
       || (unint64_t)&v4[-(v10 & 0xFFFFFFFFFFFFFFF8) - 8] >= v9;
    CFStringRef v11 = &v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
    if (v12)
    {
      uint64_t v13 = v8 >> 3;
      uint64_t v14 = (v10 >> 3) + 1;
      CFStringRef v11 = (char *)(v9 - 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL));
      unint64_t v15 = v4 - 32;
      uint64_t v16 = &v6[8 * v13 - 16];
      uint64_t v17 = v14 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v18 = *((_OWORD *)v15 + 1);
        *((_OWORD *)v16 - 1) = *(_OWORD *)v15;
        *(_OWORD *)uint64_t v16 = v18;
        *(_OWORD *)unint64_t v15 = 0uLL;
        *((_OWORD *)v15 + 1) = 0uLL;
        v15 -= 32;
        v16 -= 32;
        v17 -= 4;
      }
      while (v17);
      if (v14 == (v14 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_22;
      }
      v4 -= 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL);
    }
  }
  else
  {
    CFStringRef v11 = &v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
  }
  do
  {
    uint64_t v19 = *((void *)v4 - 1);
    v4 -= 8;
    *((void *)v11 - 1) = v19;
    v11 -= 8;
    *(void *)uint64_t v4 = 0;
  }
  while (v4 != v2);
LABEL_22:
  uint64_t v2 = *(char **)a1;
  uint64_t v20 = *(char **)(a1 + 8);
  *(void *)a1 = v11;
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = v7;
  while (v20 != v2)
  {
    uint64_t v22 = (const void *)*((void *)v20 - 1);
    v20 -= 8;
    long long v21 = v22;
    if (v22) {
      CFRelease(v21);
    }
  }
LABEL_7:
  if (v2)
  {
    operator delete(v2);
  }
}

char *sub_19E42F058(char **a1, void *a2)
{
  int v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = v2 - *a1;
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = (v4 >> 3) + 1;
  if (v6 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v9 = a1[2] - v3;
  if (v9 >> 2 > v6) {
    unint64_t v6 = v9 >> 2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 >> 61) {
      sub_19E37C2B8();
    }
    CFStringRef v11 = (char *)operator new(8 * v10);
  }
  else
  {
    CFStringRef v11 = 0;
  }
  BOOL v12 = &v11[8 * v5];
  uint64_t v13 = &v11[8 * v10];
  *(void *)BOOL v12 = *a2;
  uint64_t v14 = v12 + 8;
  *a2 = 0;
  if (v2 != v3)
  {
    unint64_t v15 = v2 - v3 - 8;
    if (v15 < 0x78) {
      goto LABEL_22;
    }
    if (&v11[v4 - (v15 & 0xFFFFFFFFFFFFFFF8) - 8] < v2 && &v2[-(v15 & 0xFFFFFFFFFFFFFFF8) - 8] < v12) {
      goto LABEL_22;
    }
    uint64_t v17 = (v15 >> 3) + 1;
    v12 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    long long v18 = v2 - 32;
    uint64_t v19 = &v11[8 * v5 - 16];
    uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v21 = *((_OWORD *)v18 + 1);
      *((_OWORD *)v19 - 1) = *(_OWORD *)v18;
      *(_OWORD *)uint64_t v19 = v21;
      *(_OWORD *)long long v18 = 0uLL;
      *((_OWORD *)v18 + 1) = 0uLL;
      v18 -= 32;
      v19 -= 32;
      v20 -= 4;
    }
    while (v20);
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v2 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
      do
      {
LABEL_22:
        uint64_t v22 = *((void *)v2 - 1);
        v2 -= 8;
        *((void *)v12 - 1) = v22;
        v12 -= 8;
        *(void *)uint64_t v2 = 0;
      }
      while (v2 != v3);
    }
  }
  uint64_t v23 = *a1;
  uint64_t v24 = a1[1];
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  while (v24 != v23)
  {
    uint64_t v26 = (const void *)*((void *)v24 - 1);
    v24 -= 8;
    char v25 = v26;
    if (v26) {
      CFRelease(v25);
    }
  }
  if (v23) {
    operator delete(v23);
  }
  return v14;
}

void sub_19E42F1E0(void *a1, uint64_t a2, uint64_t a3)
{
  v22[19] = *MEMORY[0x1E4F143B8];
  v12[0] = 0;
  v12[1] = v12;
  _OWORD v12[2] = 0x2000000000;
  void v12[3] = 0;
  v19[0] = 0;
  v19[1] = v19;
  v19[2] = 0x26002000000;
  v19[3] = sub_19E42F618;
  v19[4] = sub_19E42F7E0;
  uint64_t v5 = MEMORY[0x1E4FBA468] + 64;
  v22[0] = MEMORY[0x1E4FBA468] + 64;
  unint64_t v6 = (uint64_t *)MEMORY[0x1E4FBA400];
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA400] + 16);
  uint64_t v20 = *(void *)(MEMORY[0x1E4FBA400] + 8);
  *(void *)&v21[*(void *)(v20 - 24) - 8] = v7;
  uint64_t v8 = (std::ios_base *)&v21[*(void *)(v20 - 24) - 8];
  std::ios_base::init(v8, v21);
  uint64_t v9 = MEMORY[0x1E4FBA468] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v20 = v9;
  v22[0] = v5;
  MEMORY[0x19F3BD8B0](v21);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)&v21[*(void *)(v20 - 24) - 8], *(_DWORD *)&v21[*(void *)(v20 - 24) + 24] | 4);
  }
  v11[0] = MEMORY[0x1E4F143A8];
  v10.n128_u64[0] = 0x40000000;
  v11[1] = 0x40000000;
  v11[2] = sub_19E42F8C0;
  v11[3] = &unk_1E599F820;
  v11[4] = a3;
  v11[5] = v19;
  v11[6] = v12;
  long long __p = 0;
  uint64_t v14 = 0;
  v17[0] = 0;
  v17[1] = v17;
  int v18 = -1;
  v17[2] = 0x2000000000;
  uint64_t v15 = 0;
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 0x40000000;
  v16[2] = sub_19E42FD08;
  v16[3] = &unk_1E599F848;
  v16[4] = v11;
  v16[5] = v17;
  v16[6] = &__p;
  v16[7] = a1;
  sub_19E52A010(a1, 0, 0, (uint64_t)v16, v10);
  _Block_object_dispose(v17, 8);
  if (__p)
  {
    uint64_t v14 = __p;
    operator delete(__p);
  }
  _Block_object_dispose(v19, 8);
  uint64_t v20 = *v6;
  *(void *)&v21[*(void *)(v20 - 24) - 8] = v6[3];
  MEMORY[0x19F3BD8C0](v21);
  std::ostream::~ostream();
  MEMORY[0x19F3BDC30](v22);
  _Block_object_dispose(v12, 8);
}

void sub_19E42F59C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  _Block_object_dispose(&a31, 8);
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }
  _Block_object_dispose(&a35, 8);
  sub_19E42FFD8(v35);
  _Block_object_dispose(&a16, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E42F618(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)(a1 + 40);
  uint64_t v5 = MEMORY[0x1E4FBA400];
  *(void *)(a1 + 456) = MEMORY[0x1E4FBA4A8] + 16;
  uint64_t v6 = *(void *)(v5 + 16);
  uint64_t v7 = *(void *)(v5 + 8);
  *(void *)(a1 + 40) = v7;
  *(void *)((char *)v4 + *(void *)(v7 - 24)) = v6;
  uint64_t v8 = (std::ios_base *)(a1 + 40 + *(void *)(*(void *)(a1 + 40) - 24));
  uint64_t v9 = (std::ios_base *)(a2 + 40 + *(void *)(*(void *)(a2 + 40) - 24));
  std::ios_base::move(v8, v9);
  v8[1].__vftable = v9[1].__vftable;
  v9[1].__vftable = 0;
  v8[1].__fmtflags_ = v9[1].__fmtflags_;
  *(void *)(a1 + 40) = MEMORY[0x1E4FBA468] + 24;
  *(void *)(a1 + 456) = MEMORY[0x1E4FBA468] + 64;
  uint64_t result = MEMORY[0x19F3BD8A0](a1 + 48, a2 + 48);
  *(void *)((char *)v4 + *(void *)(*v4 - 24) + 40) = result;
  return result;
}

void sub_19E42F7B8(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x19F3BDC30](v1);
  _Unwind_Resume(a1);
}

void sub_19E42F7E0(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1E4FBA400];
  uint64_t v2 = *MEMORY[0x1E4FBA400];
  *(void *)(a1 + 40) = *MEMORY[0x1E4FBA400];
  *(void *)(a1 + 40 + *(void *)(v2 - 24)) = *(void *)(v1 + 24);
  MEMORY[0x19F3BD8C0](a1 + 48);
  std::ostream::~ostream();
  JUMPOUT(0x19F3BDC30);
}

uint64_t sub_19E42F8C0(void *a1, uint64_t a2, unint64_t a3)
{
  sub_19E37B784((uint64_t)v29);
  uint64_t v5 = (void *)std::ostream::operator<<();
  sub_19E37CA70(v5, (uint64_t)"|", 1);
  uint64_t v6 = (void *)std::ostream::operator<<();
  sub_19E37CA70(v6, (uint64_t)"|", 1);
  if (a3)
  {
    unsigned int v7 = 1;
    do
    {
      if (v7 != 1) {
        sub_19E37CA70(v29, (uint64_t)" ", 1);
      }
      (*(void (**)(void **__return_ptr))(a1[4] + 16))(&__p);
      if (v28 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      if (v28 >= 0) {
        uint64_t v10 = HIBYTE(v28);
      }
      else {
        uint64_t v10 = v27;
      }
      sub_19E37CA70(v29, (uint64_t)p_p, v10);
      size_t v11 = HIBYTE(v28);
      if (v28 < 0) {
        size_t v11 = v27;
      }
      if (v11)
      {
        if (v28 < 0) {
          goto LABEL_18;
        }
      }
      else
      {
        sub_19E37CA70(v29, (uint64_t)"[", 1);
        BOOL v12 = (void *)std::ostream::operator<<();
        sub_19E37CA70(v12, (uint64_t)"]", 1);
        if (v28 < 0) {
LABEL_18:
        }
          operator delete(__p);
      }
      unint64_t v8 = v7++;
    }
    while (a3 > v8);
  }
  uint64_t v13 = *(void *)(a1[5] + 8);
  if ((v36 & 0x10) != 0)
  {
    unint64_t v16 = v35;
    if (v35 < v32)
    {
      unint64_t v35 = v32;
      unint64_t v16 = v32;
    }
    uint64_t v17 = (const void **)&v31;
  }
  else
  {
    if ((v36 & 8) == 0)
    {
      size_t v14 = 0;
      HIBYTE(v28) = 0;
      uint64_t v15 = &__p;
      goto LABEL_34;
    }
    uint64_t v17 = (const void **)v30;
    unint64_t v16 = v30[2];
  }
  int v18 = *v17;
  size_t v14 = v16 - (void)*v17;
  if (v14 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  if (v14 >= 0x17)
  {
    uint64_t v19 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v19 = v14 | 7;
    }
    uint64_t v20 = v19 + 1;
    uint64_t v15 = operator new(v19 + 1);
    size_t v27 = v14;
    int64_t v28 = v20 | 0x8000000000000000;
    long long __p = v15;
    goto LABEL_33;
  }
  HIBYTE(v28) = v16 - *(unsigned char *)v17;
  uint64_t v15 = &__p;
  if (v14) {
LABEL_33:
  }
    memmove(v15, v18, v14);
LABEL_34:
  *((unsigned char *)v15 + v14) = 0;
  if (v28 >= 0) {
    long long v21 = &__p;
  }
  else {
    long long v21 = __p;
  }
  if (v28 >= 0) {
    uint64_t v22 = HIBYTE(v28);
  }
  else {
    uint64_t v22 = v27;
  }
  uint64_t v23 = sub_19E37CA70((void *)(v13 + 40), (uint64_t)v21, v22);
  std::ios_base::getloc((const std::ios_base *)((char *)v23 + *(void *)(*v23 - 24)));
  uint64_t v24 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v24->__vftable[2].~facet_0)(v24, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(v28) < 0) {
    operator delete(__p);
  }
  ++*(void *)(*(void *)(a1[6] + 8) + 24);
  v29[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v29 + *(void *)(v29[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v29[1] = MEMORY[0x1E4FBA470] + 16;
  if (v34 < 0) {
    operator delete(v33);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x19F3BDC30](&v37);
}

void sub_19E42FCB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

void sub_19E42FD08(void *a1, int a2, float a3)
{
  uint64_t v6 = a1[6];
  char v34 = 0;
  unint64_t v35 = 0;
  long long __p = 0;
  unint64_t v8 = *(unsigned char **)v6;
  unsigned int v7 = *(unsigned char **)(v6 + 8);
  int64_t v9 = v7 - v8;
  if (v7 == v8)
  {
    uint64_t v10 = 0;
    size_t v11 = 0;
  }
  else
  {
    if (v9 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v10 = (char *)operator new(v7 - v8);
    size_t v11 = &v10[4 * (v9 >> 2)];
    long long __p = v10;
    unint64_t v35 = v11;
    memcpy(v10, v8, v9);
    char v34 = v11;
  }
  uint64_t v12 = v11 - v10;
  uint64_t v13 = (v11 - v10) >> 2;
  unint64_t v14 = v13 + 1;
  if ((unint64_t)(v13 + 1) >> 62) {
    sub_19E37C7C4();
  }
  if (v12 >> 1 > v14) {
    unint64_t v14 = v12 >> 1;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v15 = v14;
  }
  if (v15)
  {
    if (v15 >> 62) {
      sub_19E37C2B8();
    }
    unint64_t v16 = (char *)operator new(4 * v15);
  }
  else
  {
    unint64_t v16 = 0;
  }
  uint64_t v17 = &v16[4 * v13];
  int v18 = &v16[4 * v15];
  *(_DWORD *)uint64_t v17 = a2;
  uint64_t v19 = v17 + 4;
  if (v11 != v10)
  {
    unint64_t v20 = v11 - v10 - 4;
    if (v20 < 0x1C)
    {
      long long v21 = v11;
      do
      {
LABEL_21:
        int v27 = *((_DWORD *)v21 - 1);
        v21 -= 4;
        *((_DWORD *)v17 - 1) = v27;
        v17 -= 4;
      }
      while (v21 != v10);
      goto LABEL_22;
    }
    uint64_t v22 = (v20 >> 2) + 1;
    long long v21 = &v11[-4 * (v22 & 0x7FFFFFFFFFFFFFF8)];
    uint64_t v23 = &v16[4 * v13 - 16];
    uint64_t v24 = v11 - 16;
    uint64_t v25 = v22 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      long long v26 = *(_OWORD *)v24;
      *((_OWORD *)v23 - 1) = *((_OWORD *)v24 - 1);
      *(_OWORD *)uint64_t v23 = v26;
      v23 -= 32;
      v24 -= 32;
      v25 -= 8;
    }
    while (v25);
    v17 -= 4 * (v22 & 0x7FFFFFFFFFFFFFF8);
    if (v22 != (v22 & 0x7FFFFFFFFFFFFFF8)) {
      goto LABEL_21;
    }
  }
LABEL_22:
  long long __p = v17;
  unint64_t v35 = v18;
  if (v10) {
    operator delete(v10);
  }
  char v34 = v19;
  (*(void (**)(float))(a1[4] + 16))(a3);
  uint64_t v29 = *(void *)(a1[5] + 8);
  if (*(_DWORD *)(v29 + 24) != a2)
  {
    uint64_t v30 = (void *)a1[7];
    uint64_t v31 = a1[4];
    if (v34 == __p) {
      unint64_t v32 = 0;
    }
    else {
      unint64_t v32 = (int *)__p;
    }
    v37[0] = 0;
    v37[1] = v37;
    int v38 = -1;
    v37[2] = 0x2000000000;
    v36[0] = MEMORY[0x1E4F143A8];
    v28.n128_u64[0] = 0x40000000;
    v36[1] = 0x40000000;
    v36[2] = sub_19E42FD08;
    v36[3] = &unk_1E599F848;
    v36[4] = v31;
    v36[5] = v37;
    v36[6] = &__p;
    v36[7] = v30;
    sub_19E52A010(v30, v32, (unint64_t)(v34 - (unsigned char *)__p) >> 2, (uint64_t)v36, v28);
    _Block_object_dispose(v37, 8);
    uint64_t v29 = *(void *)(a1[5] + 8);
  }
  *(_DWORD *)(v29 + 24) = a2;
  if (__p)
  {
    char v34 = (char *)__p;
    operator delete(__p);
  }
}

void sub_19E42FFA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_19E42FFD8(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA400];
  uint64_t v3 = *MEMORY[0x1E4FBA400];
  *a1 = *MEMORY[0x1E4FBA400];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x19F3BD8C0](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x19F3BDC30](a1 + 52);
  return a1;
}

uint64_t sub_19E4300A4(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  uint64_t v13 = (CFTypeRef *)(a1 + 8);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 64) = 1;
  *(unsigned char *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  if (a2)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, (const void *)kLMLanguageModelLocaleKey);
    CFStringRef v4 = Value;
    if (Value)
    {
      CFTypeID v5 = CFGetTypeID(Value);
      if (v5 == CFStringGetTypeID())
      {
        CFLocaleRef v6 = CFLocaleCreate(0, v4);
        if (*v13) {
          CFRelease(*v13);
        }
        CFTypeRef *v13 = v6;
      }
      else
      {
        CFTypeID v7 = CFGetTypeID(v4);
        CFTypeID TypeID = CFLocaleGetTypeID();
        CFLocaleRef v6 = (CFLocaleRef)*v13;
        if (v7 == TypeID)
        {
          if (v6 != (CFLocaleRef)v4)
          {
            CFRetain(v4);
            if (*v13) {
              CFRelease(*v13);
            }
            CFTypeRef *v13 = v4;
          }
LABEL_13:
          CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(a2, (const void *)kLMLanguageModelIsMultilingualModelKey);
          *(unsigned char *)(a1 + 16) = sub_19E377394(v9, 0);
          CFStringRef v10 = (const __CFString *)CFDictionaryGetValue(a2, (const void *)kLMLanguageModelIsSiriModelKey);
          *(unsigned char *)(a1 + 17) = sub_19E377394(v10, 0);
          operator new();
        }
      }
      if (!v6)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        sub_19E382340(v15, "Locale is missing from ResourceLoader options");
        sub_19E3F5604(exception, (long long *)v15);
        __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
      }
      goto LABEL_13;
    }
  }
  return a1;
}

void sub_19E431414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef cf, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,CFTypeRef a27,uint64_t a28,char a29)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E4318FC(uint64_t a1, CFArrayRef theArray)
{
  int Count = CFArrayGetCount(theArray);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v17 = 0;
  sub_19E42EEEC((uint64_t)__p, Count);
  if (Count < 1)
  {
LABEL_10:
    *(_OWORD *)a1 = *(_OWORD *)__p;
    *(void *)(a1 + 16) = v17;
    *(unsigned char *)(a1 + 24) = 1;
  }
  else
  {
    CFIndex v5 = 0;
    uint64_t v6 = Count;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
      unint64_t v8 = ValueAtIndex;
      if (!ValueAtIndex) {
        break;
      }
      CFRetain(ValueAtIndex);
      CFTypeRef cf = v8;
      char v15 = 1;
      CFStringRef v9 = (char *)__p[1];
      if (__p[1] < v17)
      {
        *(void *)__p[1] = v8;
        __p[1] = v9 + 8;
      }
      else
      {
        __p[1] = sub_19E42F058((char **)__p, &cf);
        if (v15)
        {
          if (cf) {
            CFRelease(cf);
          }
        }
      }
      if (v6 == ++v5) {
        goto LABEL_10;
      }
    }
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 24) = 0;
    CFStringRef v10 = (char *)__p[0];
    if (__p[0])
    {
      size_t v11 = (char *)__p[1];
      if (__p[1] != __p[0])
      {
        do
        {
          uint64_t v13 = (const void *)*((void *)v11 - 1);
          v11 -= 8;
          uint64_t v12 = v13;
          if (v13) {
            CFRelease(v12);
          }
        }
        while (v11 != v10);
        CFStringRef v10 = (char *)__p[0];
      }
      operator delete(v10);
    }
  }
}

char *sub_19E431A70(char **a1, void *a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = v2 - *a1;
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = (v4 >> 3) + 1;
  if (v6 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v9 = a1[2] - v3;
  if (v9 >> 2 > v6) {
    unint64_t v6 = v9 >> 2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 >> 61) {
      sub_19E37C2B8();
    }
    size_t v11 = (char *)operator new(8 * v10);
  }
  else
  {
    size_t v11 = 0;
  }
  uint64_t v12 = &v11[8 * v5];
  uint64_t v13 = &v11[8 * v10];
  *(void *)uint64_t v12 = *a2;
  unint64_t v14 = v12 + 8;
  *a2 = 0;
  if (v2 != v3)
  {
    unint64_t v15 = v2 - v3 - 8;
    if (v15 < 0x78) {
      goto LABEL_22;
    }
    if (&v11[v4 - (v15 & 0xFFFFFFFFFFFFFFF8) - 8] < v2 && &v2[-(v15 & 0xFFFFFFFFFFFFFFF8) - 8] < v12) {
      goto LABEL_22;
    }
    uint64_t v17 = (v15 >> 3) + 1;
    v12 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    int v18 = v2 - 32;
    uint64_t v19 = &v11[8 * v5 - 16];
    uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v21 = *((_OWORD *)v18 + 1);
      *((_OWORD *)v19 - 1) = *(_OWORD *)v18;
      *(_OWORD *)uint64_t v19 = v21;
      *(_OWORD *)int v18 = 0uLL;
      *((_OWORD *)v18 + 1) = 0uLL;
      v18 -= 32;
      v19 -= 32;
      v20 -= 4;
    }
    while (v20);
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v2 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
      do
      {
LABEL_22:
        uint64_t v22 = *((void *)v2 - 1);
        v2 -= 8;
        *((void *)v12 - 1) = v22;
        v12 -= 8;
        *(void *)uint64_t v2 = 0;
      }
      while (v2 != v3);
    }
  }
  uint64_t v23 = *a1;
  uint64_t v24 = a1[1];
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  while (v24 != v23)
  {
    long long v26 = (const void *)*((void *)v24 - 1);
    v24 -= 8;
    uint64_t v25 = v26;
    if (v26) {
      CFRelease(v25);
    }
  }
  if (v23) {
    operator delete(v23);
  }
  return v14;
}

uint64_t sub_19E431BF8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

char **sub_19E431C34(char **a1)
{
  if (*((unsigned char *)a1 + 24))
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      uint64_t v3 = a1[1];
      uint64_t v4 = *a1;
      if (v3 != v2)
      {
        do
        {
          unint64_t v6 = (const void *)*((void *)v3 - 1);
          v3 -= 8;
          uint64_t v5 = v6;
          if (v6) {
            CFRelease(v5);
          }
        }
        while (v3 != v2);
        uint64_t v4 = *a1;
      }
      a1[1] = v2;
      operator delete(v4);
    }
  }
  return a1;
}

CFPropertyListRef sub_19E431CAC(void *a1, const __CFURL *a2)
{
  CFPropertyListRef result = sub_19E3C30D0(a2, 0);
  if (result) {
    operator new();
  }
  *a1 = 0;
  a1[1] = 0;
  return result;
}

void sub_19E431D50(_Unwind_Exception *a1)
{
  if (*v1) {
    CFRelease(*v1);
  }
  *uint64_t v1 = 0;
  MEMORY[0x19F3BDCF0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

void **sub_19E431D88(void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        unint64_t v6 = (const void *)*((void *)v3 - 1);
        v3 -= 8;
        uint64_t v5 = v6;
        if (v6) {
          CFRelease(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

int **sub_19E431DF8(int **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*v2 != -1)
    {
      flock(*v2, 8);
      close(*v2);
    }
    MEMORY[0x19F3BDCF0](v2, 0x1000C4052888210);
  }
  return a1;
}

uint64_t *sub_19E431E60(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_19E3D7670(v2);
    MEMORY[0x19F3BDCF0]();
  }
  return a1;
}

const void **sub_19E431EA8(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

uint64_t sub_19E431EE4(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__110shared_ptrIN2LM26InlineCompletionParametersEE27__shared_ptr_default_deleteIS2_S2_EE"
    || ((v3 & (unint64_t)"NSt3__110shared_ptrIN2LM26InlineCompletionParametersEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__110shared_ptrIN2LM26InlineCompletionParametersEE27__shared_ptr_default_deleteIS2_S2_EE")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__110shared_ptrIN2LM26InlineCompletionParametersEE27__shared_ptr_default_deleteIS2_S2_EE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E431F3C(uint64_t result)
{
  uint64_t v1 = *(CFTypeRef **)(result + 24);
  if (v1)
  {
    if (*v1) {
      CFRelease(*v1);
    }
    *uint64_t v1 = 0;
    JUMPOUT(0x19F3BDCF0);
  }
  return result;
}

void sub_19E431FA4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E431FE0(uint64_t a1, CFArrayRef *a2)
{
  CFStringRef v3 = (const __CFString *)LDCreateSystemLexiconCompatibilityVersion();
  sub_19E37774C(v3, &__s1);
  if (v3) {
    CFRelease(v3);
  }
  if (CFArrayGetCount(*a2) > 0)
  {
    CFDictionaryRef ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(*a2, 0);
    CFURLRef v6 = CFBundleCopyBundleURL(ValueAtIndex);
    sub_19E4985FC((int)&v5, v6);
  }
  if (v8 < 0) {
    operator delete(__s1);
  }
}

void sub_19E4324C8()
{
  sub_19E3F6888(&v0);
  JUMPOUT(0x19E432514);
}

void sub_19E4324D0()
{
}

void sub_19E4324EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_19E3DCC24((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E432508()
{
}

void sub_19E432534(CFURLRef directoryURL, const __CFLocale *a2, const __CFString *a3, __CFArray *a4, char a5)
{
  if (directoryURL && a2)
  {
    CFArrayRef BundlesFromDirectory = CFBundleCreateBundlesFromDirectory(0, directoryURL, @"lm");
    if (a5)
    {
      for (CFIndex i = 0; i < CFArrayGetCount(BundlesFromDirectory); ++i)
      {
        CFDictionaryRef ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(BundlesFromDirectory, i);
        CFURLRef v12 = CFBundleCopyBundleURL(ValueAtIndex);
        CFStringRef PathComponent = CFURLCopyLastPathComponent(v12);
        if (sub_19E3723AC(ValueAtIndex, a2, a3)) {
          CFArrayAppendValue(a4, ValueAtIndex);
        }
        CFRelease(ValueAtIndex);
        if (PathComponent) {
          CFRelease(PathComponent);
        }
        if (v12) {
          CFRelease(v12);
        }
      }
    }
    else
    {
      for (CFIndex j = 0; j < CFArrayGetCount(BundlesFromDirectory); ++j)
      {
        unint64_t v15 = (__CFBundle *)CFArrayGetValueAtIndex(BundlesFromDirectory, j);
        CFURLRef v16 = CFBundleCopyBundleURL(v15);
        CFStringRef v17 = CFURLCopyLastPathComponent(v16);
        if (!CFStringHasPrefix(v17, @"Siri"))
        {
          if (sub_19E3723AC(v15, a2, a3)) {
            CFArrayAppendValue(a4, v15);
          }
          CFRelease(v15);
        }
        if (v17) {
          CFRelease(v17);
        }
        if (v16) {
          CFRelease(v16);
        }
      }
    }
    if (BundlesFromDirectory) {
      CFRelease(BundlesFromDirectory);
    }
  }
}

void sub_19E4326F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  sub_19E3F6888((const void **)va);
  sub_19E3F6850((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_19E432758(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CFStringRef v3 = *(__CFDictionary **)(a1 + 32);
  int v4 = *(_DWORD *)(a1 + 40);
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"Type");
  if (Value)
  {
    CFNumberRef v6 = Value;
    *(_DWORD *)CFURLRef valuePtr = 999;
    if (!CFNumberGetValue(Value, kCFNumberIntType, valuePtr)
      || *(_DWORD *)valuePtr > 0x24u
      || ((0x1300080348uLL >> valuePtr[0]) & 1) == 0)
    {
      if (v4 != 1
        || (*(_DWORD *)CFURLRef valuePtr = 0, CFNumberGetValue(v6, kCFNumberIntType, valuePtr), *(_DWORD *)valuePtr > 0x2Eu)
        || ((0x4000A00030A3uLL >> valuePtr[0]) & 1) == 0)
      {
        if (!CFDictionaryContainsKey(v3, v6))
        {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionarySetValue(v3, v6, Mutable);
          if (Mutable) {
            CFRelease(Mutable);
          }
        }
        CFDictionaryRef v8 = (const __CFDictionary *)CFDictionaryGetValue(v3, v6);
        if (CFDictionaryContainsKey(theDict, @"Priority"))
        {
          uint64_t v9 = CFDictionaryGetValue(theDict, @"Priority");
          CFNumberRef v10 = (const __CFNumber *)CFRetain(v9);
        }
        else
        {
          *(_DWORD *)CFURLRef valuePtr = 0;
          CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
        }
        CFNumberRef v12 = v10;
        if (CFDictionaryContainsKey(v8, @"Resources"))
        {
          CFArrayRef v13 = (const __CFArray *)CFDictionaryGetValue(v8, @"Resources");
          CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(v8, @"Priority");
          CFComparisonResult v15 = CFNumberCompare(v12, v14, 0);
          if (v15)
          {
            if (v15 == kCFCompareGreaterThan)
            {
              if (theDict) {
                CFRetain(theDict);
              }
              sub_19E36E590(valuePtr, theDict);
              CFStringRef v16 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)valuePtr, @"UseExistingModelFiles");
              if (sub_19E377394(v16, 0))
              {
                unint64_t v17 = (unint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)valuePtr, @"Name");
                if (!(v17 | (unint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)valuePtr, @"URL"))
                  && CFArrayGetCount(v13) == 1)
                {
                  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, 0);
                  uint64_t v19 = CFDictionaryGetValue(ValueAtIndex, @"Name");
                  uint64_t v20 = CFDictionaryGetValue(ValueAtIndex, @"URL");
                  if (v19)
                  {
                    long long v21 = v20;
                    if (v20)
                    {
                      CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                      CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *(CFDictionaryRef *)valuePtr);
                      CFDictionarySetValue(MutableCopy, @"Name", v19);
                      CFDictionarySetValue(MutableCopy, @"URL", v21);
                      CFDictionaryRef Copy = CFDictionaryCreateCopy(v22, MutableCopy);
                      sub_19E36E590(&v28, Copy);
                      uint64_t v26 = v28;
                      uint64_t v25 = *(const void **)valuePtr;
                      uint64_t v28 = *(void *)valuePtr;
                      *(void *)CFURLRef valuePtr = v26;
                      if (v28) {
                        CFRelease(v25);
                      }
                      if (MutableCopy) {
                        CFRelease(MutableCopy);
                      }
                    }
                  }
                }
              }
              CFArrayRemoveAllValues(v13);
              CFArrayAppendValue(v13, *(const void **)valuePtr);
              CFDictionarySetValue(v8, @"Priority", v12);
              if (*(void *)valuePtr) {
                CFRelease(*(CFTypeRef *)valuePtr);
              }
            }
          }
          else
          {
            CFArrayAppendValue(v13, theDict);
          }
        }
        else
        {
          int v27 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D510]);
          CFArrayAppendValue(v27, theDict);
          CFDictionarySetValue(v8, @"Resources", v27);
          CFDictionarySetValue(v8, @"Priority", v12);
          if (v27) {
            CFRelease(v27);
          }
        }
        if (v12) {
          CFRelease(v12);
        }
      }
    }
  }
  else
  {
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    size_t v11 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CFURLRef valuePtr = 138412290;
      *(void *)&valuePtr[4] = theDict;
      _os_log_error_impl(&dword_19E36B000, v11, OS_LOG_TYPE_ERROR, "Malformed resource properties (missing resource type):\n%@", valuePtr, 0xCu);
    }
  }
}

void sub_19E432BA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFTypeRef cf)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E432C84(char **a1, CFTypeRef cf, int a3)
{
  if (!cf)
  {
    CFTypeRef cfa = 0;
    goto LABEL_57;
  }
  CFRetain(cf);
  sub_19E36E590(&cfa, cf);
  CFDictionaryRef v6 = (const __CFDictionary *)cfa;
  if (!cfa)
  {
LABEL_57:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    goto LABEL_59;
  }
  LODWORD(valuePtr) = a3;
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v7)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
LABEL_59:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  int v8 = CFDictionaryContainsKey(v6, v7);
  CFRelease(v7);
  if (!v8)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    goto LABEL_50;
  }
  CFDictionaryRef v9 = (const __CFDictionary *)cfa;
  if (!cfa)
  {
    uint64_t v37 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v37, "Could not construct");
    goto LABEL_68;
  }
  LODWORD(theArray) = a3;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberIntType, &theArray);
  if (!v10)
  {
    int v38 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v38, "Could not construct");
    __cxa_throw(v38, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFNumberRef Value = CFDictionaryGetValue(v9, v10);
  CFRelease(v10);
  if (!Value)
  {
    uint64_t v37 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v37, "Could not find item");
LABEL_68:
    __cxa_throw(v37, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFRetain(Value);
  sub_19E36E590(&valuePtr, Value);
  if (!valuePtr)
  {
    CFNumberRef v39 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v39, "Could not construct");
    __cxa_throw(v39, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  if (!CFDictionaryContainsKey(valuePtr, @"Resources")) {
    __assert_rtn("resources", "LMResourceLoader.cpp", 150, "resourceContainer->has_key(kResourcesKey)");
  }
  if (!valuePtr)
  {
    size_t v40 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v40, "Could not construct");
    goto LABEL_65;
  }
  CFNumberRef v12 = CFDictionaryGetValue(valuePtr, @"Resources");
  CFArrayRef v13 = v12;
  if (!v12)
  {
    size_t v40 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v40, "Could not find item");
LABEL_65:
    __cxa_throw(v40, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFRetain(v12);
  sub_19E40100C(&theArray, v13);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CFArrayRef v14 = theArray;
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    CFIndex v16 = Count;
    CFArrayRef v17 = theArray;
    if (theArray)
    {
      CFIndex v41 = CFArrayGetCount(theArray);
      if (!v16)
      {
LABEL_46:
        if (theArray) {
          CFRelease(theArray);
        }
        goto LABEL_48;
      }
    }
    else
    {
      CFIndex v41 = 0;
      if (!Count) {
        goto LABEL_46;
      }
    }
    unint64_t v18 = 0;
    while (1)
    {
      if (v14 == v17 && v18 == v41) {
        goto LABEL_46;
      }
      if (CFArrayGetCount(v14) <= v18 || (CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v14, v18)) == 0)
      {
        unint64_t v35 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](v35, "Could not find item");
        __cxa_throw(v35, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      uint64_t v20 = operator new(0x28uLL);
      v20[1] = 0;
      v20[2] = 0;
      *uint64_t v20 = &unk_1EF0BE728;
      v20[4] = v18;
      v20[3] = CFRetain(ValueAtIndex);
      *(void *)&long long v42 = v20 + 3;
      *((void *)&v42 + 1) = v20;
      CFAllocatorRef v22 = a1[1];
      unint64_t v21 = (unint64_t)a1[2];
      if ((unint64_t)v22 >= v21) {
        break;
      }
      *(void *)CFAllocatorRef v22 = v20 + 3;
      *((void *)v22 + 1) = v20;
      a1[1] = v22 + 16;
LABEL_20:
      if (++v18 == v16) {
        goto LABEL_46;
      }
    }
    uint64_t v23 = *a1;
    uint64_t v24 = (v22 - *a1) >> 4;
    unint64_t v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 60) {
      sub_19E37C7C4();
    }
    uint64_t v26 = v21 - (void)v23;
    if (v26 >> 3 > v25) {
      unint64_t v25 = v26 >> 3;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    if (v27 >> 60) {
      sub_19E37C2B8();
    }
    uint64_t v28 = (char *)operator new(16 * v27);
    uint64_t v29 = &v28[16 * v24];
    *(_OWORD *)uint64_t v29 = v42;
    uint64_t v30 = v29 + 16;
    uint64_t v31 = &v28[16 * v27];
    if (v22 == v23)
    {
      *a1 = v29;
      a1[1] = v30;
      a1[2] = v31;
      if (!v22) {
        goto LABEL_43;
      }
    }
    else
    {
      unint64_t v32 = v22;
      do
      {
        long long v33 = *((_OWORD *)v32 - 1);
        v32 -= 16;
        *((_OWORD *)v29 - 1) = v33;
        v29 -= 16;
        *(void *)unint64_t v32 = 0;
        *((void *)v32 + 1) = 0;
      }
      while (v32 != v23);
      *a1 = v29;
      a1[1] = v30;
      a1[2] = v31;
      do
      {
        char v34 = (std::__shared_weak_count *)*((void *)v22 - 1);
        if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
        v22 -= 16;
      }
      while (v22 != v23);
      CFAllocatorRef v22 = v23;
      if (!v23) {
        goto LABEL_43;
      }
    }
    operator delete(v22);
LABEL_43:
    a1[1] = v30;
    goto LABEL_20;
  }
LABEL_48:
  if (valuePtr) {
    CFRelease(valuePtr);
  }
LABEL_50:
  if (cfa) {
    CFRelease(cfa);
  }
}

void sub_19E4332BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  int v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_19E43336C((const void **)va);
  sub_19E3C6EAC((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_19E4332CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16)
{
  __cxa_free_exception(v16);
  sub_19E3C6EAC(&a16);
  _Unwind_Resume(a1);
}

void sub_19E4332E0()
{
  sub_19E3C6EAC(&v0);
  JUMPOUT(0x19E43335CLL);
}

void sub_19E4332E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_19E3C6EAC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E4332F0(uint64_t a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_19E3D73EC((uint64_t)va);
  sub_19E3D7338(v2);
  sub_19E401594((const void **)va1);
  JUMPOUT(0x19E433354);
}

const void **sub_19E43336C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_19E4333A0(int a1, uint64_t a2)
{
  CFStringRef v4 = (const __CFString *)*MEMORY[0x1E4F1D218];
  CFStringRef Value = (const __CFString *)CFLocaleGetValue(*(CFLocaleRef *)(a2 + 8), (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  CFStringRef v6 = (const __CFString *)CFLocaleGetValue(*(CFLocaleRef *)(a2 + 8), (CFLocaleKey)*MEMORY[0x1E4F1D220]);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v8 = Mutable;
  if (*(unsigned char *)(a2 + 17)) {
    CFStringAppend(Mutable, @"siri-");
  }
  CFStringAppend(v8, Value);
  if (CFEqual(Value, @"mul"))
  {
    CFStringRef v9 = (const __CFString *)CFLocaleGetValue(*(CFLocaleRef *)(a2 + 8), (CFLocaleKey)*MEMORY[0x1E4F1D1F0]);
    if (v9)
    {
      CFStringAppend(v8, @"_");
      CFStringAppend(v8, v9);
    }
  }
  if (v6)
  {
    CFStringAppend(v8, @"_");
    CFStringAppend(v8, v6);
  }
  CFStringAppend(v8, @"-dynamic.lm");
  CFURLRef v11 = CFURLCreateCopyAppendingPathComponent(0, *(CFURLRef *)(a2 + 24), v8, 1u);
  CFStringRef v10 = (const __CFString *)CFLocaleGetValue(*(CFLocaleRef *)(a2 + 8), v4);
  CFLocaleCreate(0, v10);
  sub_19E4985FC(a1, v11);
}

void sub_19E43355C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_19E422428((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E433598(uint64_t a1, uint64_t a2)
{
  sub_19E4333A0((int)&v2, a2);
}

void sub_19E433964(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  sub_19E40FE2C(&a10);
  _Unwind_Resume(a1);
}

int *sub_19E4339A4(int *a1, const __CFString *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  a1[1] = 0;
  uint64_t v3 = a1 + 1;
  *a1 = 0;
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, a2, @".");
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  if (Count >= 1)
  {
    CFIndex v6 = 0;
    if (Count == 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = 2;
    }
    do
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v6);
      CFStringGetCString(ValueAtIndex, buffer, 16, 0x8000100u);
      CFStringRef v9 = a1;
      if (v6)
      {
        if (v6 != 1) {
          goto LABEL_6;
        }
        CFStringRef v9 = v3;
      }
      *CFStringRef v9 = atoi(buffer);
LABEL_6:
      ++v6;
    }
    while (v7 != v6);
  }
  CFRelease(ArrayBySeparatingStrings);
  return a1;
}

void sub_19E433AA0(void *a1, __n128 **a2, int a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CFStringRef v4 = *a2;
  uint64_t v5 = a2[1];
  long long __p = 0;
  char v63 = 0;
  unint64_t v64 = 0;
  if (v4 != v5)
  {
    do
    {
      uint64_t v8 = (CFDictionaryRef *)v4->n128_u64[0];
      LODWORD(valuePtr) = 0;
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*v8, @"Type");
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      if (valuePtr == a3)
      {
        CFStringRef v10 = v63;
        if ((unint64_t)v63 >= v64)
        {
          uint64_t v7 = sub_19E40CC80((uint64_t)&__p, *v4);
        }
        else
        {
          v63->n128_u64[0] = v4->n128_u64[0];
          unint64_t v11 = v4->n128_u64[1];
          v10->n128_u64[1] = v11;
          if (v11) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v7 = v10 + 1;
        }
        char v63 = v7;
      }
      ++v4;
    }
    while (v4 != v5);
    uint64_t v12 = (__n128 *)__p;
    if (__p != v63)
    {
      CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFArrayRef v13 = "d && \"An Info.plist file was unable to be read from the bundle\"";
      CFArrayRef v14 = "_getInfoDictionary";
      CFComparisonResult v15 = CFDictionaryGetValue(**(CFDictionaryRef **)__p, @"URL");
      *(void *)int v67 = CFRetain(v15);
      CFIndex v16 = CFBundleCreate(allocator, *(CFURLRef *)v67);
      *(void *)&v67[8] = v16;
      if (sub_19E497F44(v16))
      {
        if (sub_19E497F44(v16))
        {
          CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(v16);
          if (InfoDictionary)
          {
            CFArrayRef v18 = (const __CFArray *)CFDictionaryGetValue(InfoDictionary, @"Contents");
            if (v18)
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v18, 0);
              *(void *)&long long valuePtr = sub_19E49822C((CFURLRef *)v67, ValueAtIndex);
              operator new();
            }
            int v54 = 229;
            CFArrayRef v14 = "_getContents";
            CFArrayRef v13 = "(contents != 0) && \"There should files contained within the blocklist bundle\"";
          }
          else
          {
            int v54 = 218;
          }
          __assert_rtn(v14, "BlocklistBundle.cpp", v54, v13);
        }
        exception = __cxa_allocate_exception(0x20uLL);
        sub_19E382340(&valuePtr, "Malformed legacy blocklist bundle configuration: cannot load the legacy blocklist resource");
        sub_19E3F5604(exception, &valuePtr);
        __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
      }
      if (sub_19E49811C(v16))
      {
        sub_19E4983D4(&v61, (CFURLRef *)v67);
        CFDictionaryGetValue(*v61, @"URL");
        operator new();
      }
      sub_19E4983D4(&v61, (CFURLRef *)v67);
      if (sub_19E49800C(v16))
      {
        CFDictionaryRef v20 = CFBundleGetInfoDictionary(v16);
        if (v20)
        {
          CFArrayRef v21 = (const __CFArray *)CFDictionaryGetValue(v20, @"Contents");
          if (v21)
          {
            for (CFIndex i = 0; i < CFArrayGetCount(v21); ++i)
            {
              CFDictionaryRef v23 = (const __CFDictionary *)CFArrayGetValueAtIndex(v21, i);
              LODWORD(valuePtr) = 0;
              CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(v23, @"Type");
              CFNumberGetValue(v24, kCFNumberIntType, &valuePtr);
              if (valuePtr == 42)
              {
                *(void *)&long long valuePtr = sub_19E49822C((CFURLRef *)v67, v23);
                operator new();
              }
            }
            CFDictionaryGetValue(*v61, @"URL");
            operator new();
          }
          int v55 = 229;
          CFArrayRef v14 = "_getContents";
          CFArrayRef v13 = "(contents != 0) && \"There should files contained within the blocklist bundle\"";
        }
        else
        {
          int v55 = 218;
        }
        __assert_rtn(v14, "BlocklistBundle.cpp", v55, v13);
      }
      std::string v57 = __cxa_allocate_exception(0x20uLL);
      sub_19E382340(&valuePtr, "Malformed lemmatized blocklist bundle configuration: cannot load the blocklist id map resource");
      sub_19E3F5604(v57, &valuePtr);
      __cxa_throw(v57, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
    }
    if (__p)
    {
      unint64_t v25 = v63;
      uint64_t v26 = __p;
      if (v63 != __p)
      {
        do
        {
          unint64_t v27 = (std::__shared_weak_count *)v25[-1].n128_u64[1];
          if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
            std::__shared_weak_count::__release_weak(v27);
          }
          --v25;
        }
        while (v25 != v12);
        uint64_t v26 = __p;
      }
      char v63 = v12;
      operator delete(v26);
    }
  }
  uint64_t v28 = *a2;
  uint64_t v29 = a2[1];
  char v63 = 0;
  unint64_t v64 = 0;
  long long __p = 0;
  if (v28 == v29)
  {
    CFIndex v41 = 0;
    uint64_t v37 = 0;
    memset(buf, 0, sizeof(buf));
    unint64_t v69 = 0;
  }
  else
  {
    do
    {
      uint64_t v31 = (CFDictionaryRef *)v28->n128_u64[0];
      LODWORD(valuePtr) = 0;
      CFNumberRef v32 = (const __CFNumber *)CFDictionaryGetValue(*v31, @"Type");
      CFNumberGetValue(v32, kCFNumberIntType, &valuePtr);
      if (valuePtr == 41)
      {
        long long v33 = v63;
        if ((unint64_t)v63 >= v64)
        {
          uint64_t v30 = sub_19E40CC80((uint64_t)&__p, *v28);
        }
        else
        {
          v63->n128_u64[0] = v28->n128_u64[0];
          unint64_t v34 = v28->n128_u64[1];
          v33->n128_u64[1] = v34;
          if (v34) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v30 = v33 + 1;
        }
        char v63 = v30;
      }
      ++v28;
    }
    while (v28 != v29);
    unint64_t v35 = *a2;
    int v36 = a2[1];
    memset(buf, 0, sizeof(buf));
    unint64_t v69 = 0;
    if (v35 == v36)
    {
      CFIndex v41 = 0;
      uint64_t v37 = 0;
    }
    else
    {
      uint64_t v37 = 0;
      do
      {
        int v38 = (CFDictionaryRef *)v35->n128_u64[0];
        LODWORD(valuePtr) = 0;
        CFNumberRef v39 = (const __CFNumber *)CFDictionaryGetValue(*v38, @"Type");
        CFNumberGetValue(v39, kCFNumberIntType, &valuePtr);
        if (valuePtr == 42)
        {
          if ((unint64_t)v37 >= v69)
          {
            uint64_t v37 = sub_19E40CC80((uint64_t)buf, *v35);
          }
          else
          {
            v37->n128_u64[0] = v35->n128_u64[0];
            unint64_t v40 = v35->n128_u64[1];
            v37->n128_u64[1] = v40;
            if (v40) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v40 + 8), 1uLL, memory_order_relaxed);
            }
            ++v37;
          }
          *(void *)&uint8_t buf[8] = v37;
        }
        ++v35;
      }
      while (v35 != v36);
      CFIndex v41 = *(__n128 **)buf;
    }
  }
  if ((char *)v63 - (unsigned char *)__p != (char *)v37 - (char *)v41)
  {
    UniChar v58 = __cxa_allocate_exception(0x20uLL);
    sub_19E382340(&valuePtr, "Malformed language model configuration: mismatched lemmatized blocklist resources");
    sub_19E3F5604(v58, &valuePtr);
    __cxa_throw(v58, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
  }
  if ((unint64_t)((char *)v63 - (unsigned char *)__p) >= 0x11)
  {
    uint64_t v59 = __cxa_allocate_exception(0x20uLL);
    sub_19E382340(&valuePtr, "Malformed language model configuration: too many lemmatized blocklist resources");
    sub_19E3F5604(v59, &valuePtr);
    __cxa_throw(v59, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
  }
  if (__p != v63)
  {
    CFDictionaryGetValue(**(CFDictionaryRef **)__p, @"URL");
    operator new();
  }
  if (!v41)
  {
    long long v42 = (__n128 *)__p;
    if (!__p) {
      goto LABEL_82;
    }
    goto LABEL_66;
  }
  int v46 = v41;
  if (v37 != v41)
  {
    do
    {
      CFNumberRef v47 = (std::__shared_weak_count *)v37[-1].n128_u64[1];
      if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
      --v37;
    }
    while (v37 != v41);
    int v46 = *(__n128 **)buf;
  }
  *(void *)&uint8_t buf[8] = v41;
  operator delete(v46);
  long long v42 = (__n128 *)__p;
  if (__p)
  {
LABEL_66:
    CFNumberRef v43 = v63;
    uint64_t v44 = v42;
    if (v63 != v42)
    {
      do
      {
        CFNumberRef v45 = (std::__shared_weak_count *)v43[-1].n128_u64[1];
        if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
        --v43;
      }
      while (v43 != v42);
      uint64_t v44 = __p;
    }
    char v63 = v42;
    operator delete(v44);
  }
LABEL_82:
  uint64_t v48 = *a2;
  CFNumberRef v49 = a2[1];
  unint64_t v66 = 0;
  long long valuePtr = 0uLL;
  if (v48 != v49)
  {
    uint64_t v50 = 0;
    do
    {
      BOOL v51 = (CFDictionaryRef *)v48->n128_u64[0];
      LODWORD(__p) = 0;
      CFNumberRef v52 = (const __CFNumber *)CFDictionaryGetValue(*v51, @"Type");
      CFNumberGetValue(v52, kCFNumberIntType, &__p);
      if (__p == 10)
      {
        if ((unint64_t)v50 >= v66)
        {
          uint64_t v50 = sub_19E40CC80((uint64_t)&valuePtr, *v48);
        }
        else
        {
          v50->n128_u64[0] = v48->n128_u64[0];
          unint64_t v53 = v48->n128_u64[1];
          v50->n128_u64[1] = v53;
          if (v53) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v53 + 8), 1uLL, memory_order_relaxed);
          }
          ++v50;
        }
        *((void *)&valuePtr + 1) = v50;
      }
      ++v48;
    }
    while (v48 != v49);
    if ((__n128 *)valuePtr != v50)
    {
      CFDictionaryGetValue(**(CFDictionaryRef **)valuePtr, @"URL");
      operator new();
    }
    if (v50)
    {
      *((void *)&valuePtr + 1) = v50;
      operator delete(v50);
    }
  }
}

void sub_19E435260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, const void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  __cxa_free_exception(v32);
  sub_19E3C6F1C(&a20);
  sub_19E410F68((const void **)&a22);
  uint64_t v35 = a23;
  a23 = 0;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  }
  sub_19E3D7338((void **)(v33 - 128));
  sub_19E3D7338((void **)&a24);
  sub_19E435BB0(&a15);
  sub_19E435BB0(a10);
  _Unwind_Resume(a1);
}

void *sub_19E43584C(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      sub_19E37C2B8();
    }
    CFStringRef v9 = (char *)operator new(8 * v8);
  }
  else
  {
    CFStringRef v9 = 0;
  }
  CFStringRef v10 = &v9[8 * v3];
  unint64_t v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)CFStringRef v10 = v12;
  CFArrayRef v13 = v10 + 8;
  CFArrayRef v14 = (char *)*a1;
  CFComparisonResult v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    goto LABEL_25;
  }
  unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
  if (v16 > 0x77
    && (&v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v10 || &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v15))
  {
    uint64_t v17 = (v16 >> 3) + 1;
    v10 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    CFArrayRef v18 = v15 - 32;
    uint64_t v19 = &v9[8 * v3 - 16];
    uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v22 = *(_OWORD *)v18;
      long long v21 = *((_OWORD *)v18 + 1);
      *(_OWORD *)CFArrayRef v18 = 0uLL;
      *((_OWORD *)v18 + 1) = 0uLL;
      v18 -= 32;
      *((_OWORD *)v19 - 1) = v22;
      *(_OWORD *)uint64_t v19 = v21;
      v19 -= 32;
      v20 -= 4;
    }
    while (v20);
    if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_20;
    }
    v15 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
  }
  do
  {
    uint64_t v23 = *((void *)v15 - 1);
    v15 -= 8;
    *(void *)CFComparisonResult v15 = 0;
    *((void *)v10 - 1) = v23;
    v10 -= 8;
  }
  while (v15 != v14);
LABEL_20:
  CFComparisonResult v15 = (char *)*a1;
  CFNumberRef v24 = (char *)a1[1];
  *a1 = v10;
  a1[1] = v13;
  a1[2] = v11;
  while (v24 != v15)
  {
    uint64_t v26 = *((void *)v24 - 1);
    v24 -= 8;
    uint64_t v25 = v26;
    *(void *)CFNumberRef v24 = 0;
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    }
  }
LABEL_25:
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

CFTypeRef **sub_19E4359FC(CFTypeRef **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*v2) {
      CFRelease(*v2);
    }
    MEMORY[0x19F3BDCF0](v2, 0x1060C40C2E02434);
  }
  return a1;
}

void sub_19E435A54()
{
}

void sub_19E435B1C(_Unwind_Exception *a1)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    v1[4] = v4;
    operator delete(v4);
  }
  uint64_t v5 = v1[2];
  v1[2] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = v1[1];
  v1[1] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  MEMORY[0x19F3BDCF0](v1, 0xB1C404273B650);
  _Unwind_Resume(a1);
}

void *sub_19E435BB0(void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    uint64_t v3 = (void *)a1[1];
    unint64_t v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      unint64_t v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t **sub_19E435C40(uint64_t **a1, void *a2, uint64_t *a3, uint64_t a4)
{
  a1[1] = 0;
  uint64_t v5 = a1 + 1;
  a1[2] = 0;
  a1[4] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  a1[3] = (uint64_t *)(a1 + 4);
  uint64_t v31 = (uint64_t)(a1 + 3);
  a1[5] = 0;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2[1] - *a2) >> 3);
  if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3) < v6) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3);
  }
  unint64_t v33 = v6;
  if (v6)
  {
    for (uint64_t i = 0; i != v33; ++i)
    {
      uint64_t v8 = 24 * i;
      uint64_t v9 = *a2 + 24 * i;
      uint64_t v10 = *a3;
      if (*(char *)(v9 + 23) < 0)
      {
        sub_19E39369C(__dst, *(void **)v9, *(void *)(v9 + 8));
      }
      else
      {
        long long v11 = *(_OWORD *)v9;
        uint64_t v37 = *(void *)(v9 + 16);
        *(_OWORD *)std::string __dst = v11;
      }
      uint64_t v12 = (long long *)(v10 + v8);
      if (*(char *)(v10 + v8 + 23) < 0)
      {
        sub_19E39369C(&__p, *(void **)v12, *((void *)v12 + 1));
      }
      else
      {
        long long v13 = *v12;
        uint64_t v39 = *((void *)v12 + 2);
        long long __p = v13;
      }
      CFArrayRef v14 = (void *)*v5;
      CFComparisonResult v15 = v5;
      unint64_t v16 = v5;
      if (!*v5) {
        goto LABEL_39;
      }
      if (v37 >= 0) {
        uint64_t v17 = __dst;
      }
      else {
        uint64_t v17 = (void **)__dst[0];
      }
      if (v37 >= 0) {
        CFArrayRef v18 = (void *)HIBYTE(v37);
      }
      else {
        CFArrayRef v18 = __dst[1];
      }
      do
      {
        while (1)
        {
          unint64_t v16 = v14;
          long long v21 = (void *)v14[4];
          uint64_t v19 = v14 + 4;
          uint64_t v20 = v21;
          int v22 = *((char *)v19 + 23);
          uint64_t v23 = v22 >= 0 ? v19 : v20;
          CFNumberRef v24 = v22 >= 0 ? (void *)*((unsigned __int8 *)v19 + 23) : (void *)v19[1];
          size_t v25 = (size_t)(v24 >= v18 ? v18 : v24);
          int v26 = memcmp(v17, v23, v25);
          if (v26) {
            break;
          }
          if (v18 >= v24) {
            goto LABEL_33;
          }
LABEL_19:
          CFArrayRef v14 = (void *)*v16;
          CFComparisonResult v15 = v16;
          if (!*v16) {
            goto LABEL_39;
          }
        }
        if (v26 < 0) {
          goto LABEL_19;
        }
LABEL_33:
        int v27 = memcmp(v23, v17, v25);
        if (v27)
        {
          if ((v27 & 0x80000000) == 0) {
            goto LABEL_42;
          }
        }
        else if (v24 >= v18)
        {
          goto LABEL_42;
        }
        CFArrayRef v14 = (void *)v16[1];
      }
      while (v14);
      CFComparisonResult v15 = v16 + 1;
LABEL_39:
      uint64_t v28 = operator new(0x50uLL);
      v28[2] = *(_OWORD *)__dst;
      *((void *)v28 + 6) = v37;
      __dst[1] = 0;
      uint64_t v37 = 0;
      __dst[0] = 0;
      *(_OWORD *)((char *)v28 + 56) = __p;
      *((void *)v28 + 9) = v39;
      long long __p = 0uLL;
      uint64_t v39 = 0;
      *(void *)uint64_t v28 = 0;
      *((void *)v28 + 1) = 0;
      *((void *)v28 + 2) = v16;
      *CFComparisonResult v15 = v28;
      uint64_t v29 = (uint64_t *)**a1;
      if (v29)
      {
        *a1 = v29;
        uint64_t v28 = (_OWORD *)*v15;
      }
      sub_19E37D324(a1[1], (uint64_t *)v28);
      a1[2] = (uint64_t *)((char *)a1[2] + 1);
LABEL_42:
      if (SHIBYTE(v39) < 0)
      {
        operator delete((void *)__p);
        if (SHIBYTE(v37) < 0) {
          goto LABEL_46;
        }
      }
      else if (SHIBYTE(v37) < 0)
      {
LABEL_46:
        operator delete(__dst[0]);
      }
    }
  }
  if (v31 != a4) {
    sub_19E41D444(v31, *(uint64_t **)a4, (uint64_t *)(a4 + 8));
  }
  return a1;
}

void sub_19E435EF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  sub_19E3C5DBC(*a9);
  sub_19E3C5DBC(*v26);
  _Unwind_Resume(a1);
}

unint64_t sub_19E435F44(uint64_t a1, uint64_t a2, int *a3)
{
  return (*a3 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(a2 + 8);
}

uint64_t sub_19E435F58()
{
  return 0;
}

void sub_19E435F60(int a1@<W2>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = a1;
  *(void *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 16) = 0;
}

void sub_19E435F74(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
}

uint64_t sub_19E435F84(uint64_t a1, uint64_t a2, int *a3)
{
  return *(unsigned int *)(*(void *)(a2 + 8) + (*a3 & 0xFFFFFFFFFFFFFFFCLL));
}

void sub_19E435F98(uint64_t a1, uint64_t a2, int *a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  uint64_t v12 = *(void *)(a2 + 8);
  unint64_t v13 = *a3 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v30 = 0;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x2000000000;
  v33[0] = 0;
  uint64_t v14 = *(unsigned int *)(v12 + v13);
  if (v14)
  {
    (*(void (**)(uint64_t, uint64_t, unint64_t, unsigned char *))(a7 + 16))(a7, v14, a4, v33);
    BOOL v15 = *((unsigned char *)v31 + 24) != 0;
  }
  else
  {
    BOOL v15 = 0;
  }
  if (a5 - 1 >= a4 && !v15)
  {
    if (qword_1E9459FB0 != -1) {
      dispatch_once(&qword_1E9459FB0, &unk_1EF0BEBA0);
    }
    if (!*((unsigned char *)v31 + 24))
    {
      uint64_t v16 = qword_1E9459FB8;
      if (a6)
      {
        uint64_t v17 = v12;
        unint64_t v18 = 0;
        uint64_t v19 = v13 + v17 + 4;
        do
        {
          (*(void (**)(void *__return_ptr))(**(void **)(v16 + 8 * (*(_DWORD *)(v19 + 4 * v18) & 3))
                                                       + 32))(v29);
          *(unsigned char *)(a6 + a4) = v18;
          uint64_t v23 = MEMORY[0x1E4F143A8];
          uint64_t v24 = 0x40000000;
          size_t v25 = sub_19E4362C8;
          int v26 = &unk_1E599F928;
          uint64_t v27 = a7;
          uint64_t v28 = &v30;
          uint64_t v20 = *(void *)(v16 + 8 * (v29[0] & 3));
          (*(void (**)(uint64_t, uint64_t, void *, unint64_t, uint64_t, unint64_t, uint64_t *))(*(void *)v20 + 24))(v20, a2, v29, a4 + 1, a5, a6, &v23);
          if (*((unsigned char *)v31 + 24)) {
            break;
          }
          BOOL v21 = v18++ >= 0xFF;
        }
        while (!v21);
      }
      else
      {
        do
        {
          (*(void (**)(void *__return_ptr))(**(void **)(v16
                                                                     + 8 * (*(_DWORD *)(v13 + v12 + 4 + 4 * a6) & 3))
                                                       + 32))(v29);
          uint64_t v23 = MEMORY[0x1E4F143A8];
          uint64_t v24 = 0x40000000;
          size_t v25 = sub_19E4362C8;
          int v26 = &unk_1E599F928;
          uint64_t v27 = a7;
          uint64_t v28 = &v30;
          uint64_t v22 = *(void *)(v16 + 8 * (v29[0] & 3));
          (*(void (**)(uint64_t, uint64_t, void *, unint64_t, uint64_t, void, uint64_t *))(*(void *)v22 + 24))(v22, a2, v29, a4 + 1, a5, 0, &v23);
          if (*((unsigned char *)v31 + 24)) {
            break;
          }
          BOOL v21 = a6++ >= 0xFF;
        }
        while (!v21);
      }
    }
  }
  _Block_object_dispose(&v30, 8);
}

void sub_19E4362A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E4362C8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *a4 = *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

void sub_19E436318()
{
}

uint64_t sub_19E436444(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned __int8 *)(a3 + 16) + *(void *)(a3 + 8);
}

uint64_t sub_19E436454(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v3 = (unsigned int *)*((void *)a3 + 1);
  if (v3 == (unsigned int *)(*(void *)(a2 + 16) + (*a3 & 0xFFFFFFFFFFFFFFFCLL) + 4)) {
    return *v3;
  }
  uint64_t v4 = *(unsigned __int8 *)v3;
  if (v4 == *((unsigned __int8 *)a3 + 16)) {
    return *(unsigned int *)((char *)v3 + v4 + 1);
  }
  else {
    return 0;
  }
}

void sub_19E4364A0(uint64_t a1@<X1>, int a2@<W2>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16) + (int)(a2 & 0xFFFFFFFC);
  *(_DWORD *)a3 = a2;
  *(void *)(a3 + 8) = v3 + 4;
  *(unsigned char *)(a3 + 16) = 0;
}

void sub_19E4364C0(uint64_t a1, uint64_t a2, int *a3, unint64_t a4, size_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (unsigned int *)*((void *)a3 + 1);
  if (v7)
  {
    BOOL v13 = 0;
    unsigned __int8 v49 = 0;
    uint64_t v14 = (unsigned int *)(*(void *)(a2 + 16) + (*a3 & 0xFFFFFFFFFFFFFFFCLL));
    BOOL v15 = v14 + 1;
    if (v7 == v14 + 1)
    {
      uint64_t v16 = *v7;
      if (v16)
      {
        (*(void (**)(uint64_t, uint64_t, unint64_t, unsigned __int8 *))(a7 + 16))(a7, v16, a4, &v49);
        BOOL v13 = v49 != 0;
      }
      else
      {
        BOOL v13 = 0;
      }
    }
    if (a5 - 1 >= a4 && !v13)
    {
      memset(__dst, 0, sizeof(__dst));
      uint64_t v17 = (unsigned __int8 *)*((void *)a3 + 1);
      if (v17 <= (unsigned __int8 *)v15)
      {
        size_t v19 = 0;
        uint64_t v20 = (unsigned __int8 *)(v14 + 2);
      }
      else
      {
        uint64_t v18 = *v17;
        size_t v19 = *((unsigned __int8 *)a3 + 16);
        memcpy(__dst, v17 + 1, v19);
        if (v19 <= v18) {
          uint64_t v20 = v17;
        }
        else {
          uint64_t v20 = &v17[v18 + 5];
        }
      }
      unint64_t v21 = a4 - v19;
      if (a6)
      {
        uint64_t v22 = (void *)(a6 + a4);
        if (a5)
        {
          do
          {
            if (v20 >= (unsigned __int8 *)v15 + *v14) {
              break;
            }
            unsigned int v25 = *v20;
            uint64_t v23 = (char *)(v20 + 1);
            uint64_t v24 = v25;
            size_t v26 = v25 - v19;
            if (v25 < v19 || v26 > a5) {
              goto LABEL_20;
            }
            int v27 = memcmp(v23, __dst, v19);
            if (v27 > 0) {
              return;
            }
            if (v27)
            {
LABEL_20:
              int v28 = 0;
            }
            else
            {
              int v28 = *(_DWORD *)&v23[v24];
              if (v28)
              {
                memcpy(v22, &v23[v19], v26);
                (*(void (**)(uint64_t, void, unint64_t, unsigned __int8 *))(a7 + 16))(a7, *(unsigned int *)&v23[v24], v21 + v24, &v49);
                int v28 = v49;
              }
            }
            uint64_t v20 = (unsigned __int8 *)&v23[v24 + 4];
          }
          while (!v28);
        }
        else
        {
          while (v20 < (unsigned __int8 *)v15 + *v14)
          {
            unsigned int v32 = *v20;
            uint64_t v30 = (char *)(v20 + 1);
            uint64_t v31 = v32;
            size_t v33 = v32 - v19;
            if (v32 < v19) {
              goto LABEL_25;
            }
            int v34 = memcmp(v30, __dst, v19);
            if (v34 > 0) {
              return;
            }
            if (v34)
            {
LABEL_25:
              int v29 = 0;
            }
            else
            {
              int v29 = *(_DWORD *)&v30[v31];
              if (v29)
              {
                memcpy(v22, &v30[v19], v33);
                (*(void (**)(uint64_t, void, unint64_t, unsigned __int8 *))(a7 + 16))(a7, *(unsigned int *)&v30[v31], v21 + v31, &v49);
                int v29 = v49;
              }
            }
            uint64_t v20 = (unsigned __int8 *)&v30[v31 + 4];
            if (v29) {
              return;
            }
          }
        }
      }
      else if (a5)
      {
        do
        {
          if (v20 >= (unsigned __int8 *)v15 + *v14) {
            break;
          }
          unsigned int v37 = *v20;
          uint64_t v35 = (char *)(v20 + 1);
          uint64_t v36 = v37;
          size_t v38 = v37 - v19;
          if (v37 < v19 || v38 > a5) {
            goto LABEL_41;
          }
          int v40 = memcmp(v35, __dst, v19);
          if (v40 > 0) {
            return;
          }
          if (v40 || (uint64_t v42 = *(unsigned int *)&v35[v36], !v42))
          {
LABEL_41:
            int v41 = 0;
          }
          else
          {
            (*(void (**)(uint64_t, uint64_t, unint64_t, unsigned __int8 *))(a7 + 16))(a7, v42, v21 + v36, &v49);
            int v41 = v49;
          }
          uint64_t v20 = (unsigned __int8 *)&v35[v36 + 4];
        }
        while (!v41);
      }
      else
      {
        while (v20 < (unsigned __int8 *)v15 + *v14)
        {
          unsigned int v46 = *v20;
          uint64_t v44 = (char *)(v20 + 1);
          uint64_t v45 = v46;
          if (v19 > v46) {
            goto LABEL_46;
          }
          int v47 = memcmp(v44, __dst, v19);
          if (v47 > 0) {
            return;
          }
          if (v47 || (uint64_t v48 = *(unsigned int *)&v44[v45], !v48))
          {
LABEL_46:
            int v43 = 0;
          }
          else
          {
            (*(void (**)(uint64_t, uint64_t, unint64_t, unsigned __int8 *))(a7 + 16))(a7, v48, v21 + v45, &v49);
            int v43 = v49;
          }
          uint64_t v20 = (unsigned __int8 *)&v44[v45 + 4];
          if (v43) {
            return;
          }
        }
      }
    }
  }
}

void sub_19E436838(uint64_t a1@<X1>, int *a2@<X2>, char a3@<W3>, uint64_t a4@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (unsigned __int8 *)*((void *)a2 + 1);
  if (!v5)
  {
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(unsigned char *)(a4 + 16) = 0;
    return;
  }
  uint64_t v7 = *a2;
  uint64_t v8 = (unsigned __int8 *)(*(void *)(a1 + 16) + (v7 & 0xFFFFFFFFFFFFFFFCLL));
  uint64_t v9 = v8 + 4;
  memset(v17, 0, sizeof(v17));
  if (v5 > v8 + 4)
  {
    uint64_t v10 = *v5;
    size_t v11 = *((unsigned __int8 *)a2 + 16);
    memcpy(v17, v5 + 1, v11);
    size_t v12 = v11 + 1;
    *((unsigned char *)v17 + v11) = a3;
    if (v11 >= v10) {
      BOOL v13 = &v5[v10 + 5];
    }
    else {
      BOOL v13 = v5;
    }
LABEL_11:
    unint64_t v14 = (unint64_t)&v9[*(unsigned int *)v8];
    while ((unint64_t)v13 < v14)
    {
      size_t v15 = *v13;
      if (v12 <= v15)
      {
        int v16 = memcmp(v13 + 1, v17, v12);
        if (v16 > 0) {
          goto LABEL_8;
        }
        if (!v16) {
          goto LABEL_9;
        }
      }
      v13 += v15 + 5;
    }
    goto LABEL_8;
  }
  if (v5 == v9)
  {
    BOOL v13 = v8 + 8;
    LOBYTE(v17[0]) = a3;
    size_t v12 = 1;
    goto LABEL_11;
  }
LABEL_8:
  LODWORD(v7) = 0;
  BOOL v13 = 0;
  LOBYTE(v12) = 0;
LABEL_9:
  *(_DWORD *)a4 = v7;
  *(void *)(a4 + 8) = v13;
  *(unsigned char *)(a4 + 16) = v12;
}

void sub_19E4369BC()
{
}

uint64_t sub_19E4369D4(uint64_t a1, uint64_t a2, int *a3)
{
  return *(unsigned int *)(*(void *)(a2 + 8) + (*a3 & 0xFFFFFFFFFFFFFFFCLL));
}

void sub_19E4369E8(uint64_t a1, uint64_t a2, int *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  size_t v12 = (unsigned int *)(*(void *)(a2 + 8) + (*a3 & 0xFFFFFFFFFFFFFFFCLL));
  uint64_t v28 = 0;
  int v29 = &v28;
  v13.i32[1] = 32;
  uint64_t v30 = 0x2000000000;
  v31[0] = 0;
  uint64_t v14 = *v12;
  if (v14)
  {
    (*(void (**)(uint64_t, uint64_t, unint64_t, unsigned char *))(a7 + 16))(a7, v14, a4, v31);
    BOOL v15 = *((unsigned char *)v29 + 24) != 0;
  }
  else
  {
    BOOL v15 = 0;
  }
  if (a5 - 1 >= a4 && !v15)
  {
    if (qword_1E9459FB0 != -1) {
      dispatch_once(&qword_1E9459FB0, &unk_1EF0BEBA0);
    }
    int v16 = v29;
    if (!*((unsigned char *)v29 + 24))
    {
      unsigned int v17 = 0;
      uint64_t v18 = qword_1E9459FB8;
      do
      {
        unsigned int v19 = v17 >> 5;
        unsigned int v20 = v12[(v17 >> 5) + 1];
        if ((v20 >> v17))
        {
          if (v17 >= 0x20u)
          {
            if (v19 <= 1) {
              unsigned int v19 = 1;
            }
            int8x8_t v13 = vcnt_s8((int8x8_t)v12[1]);
            v13.i16[0] = vaddlv_u8((uint8x8_t)v13);
            __int32 v21 = v13.i32[0];
            if (v17 >= 0x40)
            {
              int8x8_t v13 = vcnt_s8((int8x8_t)v12[2]);
              v13.i16[0] = vaddlv_u8((uint8x8_t)v13);
              v21 += v13.i32[0];
              if (v19 != 2)
              {
                int8x8_t v13 = vcnt_s8((int8x8_t)v12[3]);
                v13.i16[0] = vaddlv_u8((uint8x8_t)v13);
                v21 += v13.i32[0];
                if (v19 != 3)
                {
                  int8x8_t v13 = vcnt_s8((int8x8_t)v12[4]);
                  v13.i16[0] = vaddlv_u8((uint8x8_t)v13);
                  v21 += v13.i32[0];
                  if (v19 != 4)
                  {
                    int8x8_t v13 = vcnt_s8((int8x8_t)v12[5]);
                    v13.i16[0] = vaddlv_u8((uint8x8_t)v13);
                    v21 += v13.i32[0];
                    if (v19 != 5)
                    {
                      int8x8_t v13 = vcnt_s8((int8x8_t)v12[6]);
                      v13.i16[0] = vaddlv_u8((uint8x8_t)v13);
                      v21 += v13.i32[0];
                      if (v19 != 6)
                      {
                        int8x8_t v13 = vcnt_s8((int8x8_t)v12[7]);
                        v13.i16[0] = vaddlv_u8((uint8x8_t)v13);
                        v21 += v13.i32[0];
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            __int32 v21 = 0;
          }
          if ((v17 & 0x1F) == 0x1F) {
            int v22 = 0x7FFFFFFF;
          }
          else {
            int v22 = ~(-1 << (v17 & 0x1F));
          }
          v13.i32[0] = v20 & v22;
          uint8x8_t v23 = (uint8x8_t)vcnt_s8(v13);
          v23.i16[0] = vaddlv_u8(v23);
          (*(void (**)(void *__return_ptr))(**(void **)(v18 + 8 * (v12[v23.i32[0] + v21 + 10] & 3))
                                                       + 32))(v27);
          if (a6) {
            *(unsigned char *)(a6 + a4) = v17;
          }
          v26[0] = MEMORY[0x1E4F143A8];
          v26[1] = 0x40000000;
          v26[2] = sub_19E436D50;
          void v26[3] = &unk_1E599F950;
          v26[4] = a7;
          v26[5] = &v28;
          uint64_t v24 = *(void *)(v18 + 8 * (v27[0] & 3));
          (*(void (**)(uint64_t, uint64_t, void *, unint64_t, uint64_t, uint64_t, void *))(*(void *)v24 + 24))(v24, a2, v27, a4 + 1, a5, a6, v26);
          int v16 = v29;
        }
        if (*((unsigned char *)v16 + 24)) {
          break;
        }
      }
      while (v17++ < 0xFF);
    }
  }
  _Block_object_dispose(&v28, 8);
}

void sub_19E436D34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E436D50(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *a4 = *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t sub_19E436DA0@<X0>(uint64_t a1@<X1>, int *a2@<X2>, unsigned int a3@<W3>, uint64_t a4@<X8>, uint8x8_t a5@<D0>)
{
  uint64_t v5 = (unsigned int *)(*(void *)(a1 + 8) + (*a2 & 0xFFFFFFFFFFFFFFFCLL));
  unsigned int v6 = a3 >> 5;
  uint64_t v7 = &v5[a3 >> 5];
  unsigned int v9 = v7[1];
  uint64_t v8 = v7 + 1;
  if ((v9 >> a3))
  {
    if (qword_1E9459FB0 != -1) {
      dispatch_once(&qword_1E9459FB0, &unk_1EF0BEBA0);
    }
    int v11 = a3 & 0x1F;
    if (a3 >= 0x20)
    {
      if (v6 <= 1) {
        int v13 = 1;
      }
      else {
        int v13 = v6;
      }
      a5 = (uint8x8_t)vcnt_s8((int8x8_t)v5[1]);
      a5.i16[0] = vaddlv_u8(a5);
      __int32 v12 = a5.i32[0];
      if (a3 >= 0x40)
      {
        a5 = (uint8x8_t)vcnt_s8((int8x8_t)v5[2]);
        a5.i16[0] = vaddlv_u8(a5);
        v12 += a5.i32[0];
        if (v13 != 2)
        {
          a5 = (uint8x8_t)vcnt_s8((int8x8_t)v5[3]);
          a5.i16[0] = vaddlv_u8(a5);
          v12 += a5.i32[0];
          if (v13 != 3)
          {
            a5 = (uint8x8_t)vcnt_s8((int8x8_t)v5[4]);
            a5.i16[0] = vaddlv_u8(a5);
            v12 += a5.i32[0];
            if (v13 != 4)
            {
              a5 = (uint8x8_t)vcnt_s8((int8x8_t)v5[5]);
              a5.i16[0] = vaddlv_u8(a5);
              v12 += a5.i32[0];
              if (v13 != 5)
              {
                a5 = (uint8x8_t)vcnt_s8((int8x8_t)v5[6]);
                a5.i16[0] = vaddlv_u8(a5);
                v12 += a5.i32[0];
                if (v13 != 6)
                {
                  a5 = (uint8x8_t)vcnt_s8((int8x8_t)v5[7]);
                  a5.i16[0] = vaddlv_u8(a5);
                  v12 += a5.i32[0];
                }
              }
            }
          }
        }
      }
    }
    else
    {
      __int32 v12 = 0;
    }
    if (v11 == 31) {
      int v14 = 0x7FFFFFFF;
    }
    else {
      int v14 = ~(-1 << v11);
    }
    a5.i32[0] = *v8 & v14;
    uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)a5);
    v15.i16[0] = vaddlv_u8(v15);
    int v16 = *(uint64_t (**)(void))(**(void **)(qword_1E9459FB8 + 8 * (v5[v15.i32[0] + v12 + 10] & 3)) + 32);
    return v16();
  }
  else
  {
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(unsigned char *)(a4 + 16) = 0;
  }
  return result;
}

void sub_19E436FB4()
{
}

uint64_t sub_19E436FCC()
{
  return 0;
}

void sub_19E436FD4()
{
}

uint64_t sub_19E436FEC(uint64_t a1, uint64_t a2, int *a3, unsigned int a4)
{
  if (qword_1E9459FB0 != -1) {
    dispatch_once(&qword_1E9459FB0, &unk_1EF0BEBA0);
  }
  uint64_t v7 = *(uint64_t (**)(void))(**(void **)(qword_1E9459FB8
                                         + 8
                                         * (*(_DWORD *)(*(void *)(a2 + 8) + (*a3 & 0xFFFFFFFFFFFFFFFCLL) + 4 * a4 + 4) & 3))
                           + 32);
  return v7();
}

void sub_19E4370A8()
{
}

void *sub_19E4370C0()
{
  qword_1E9459D60 = (uint64_t)objc_lookUpClass("_DPWordRecorder");
  qword_1E9459D50 = (uint64_t)objc_lookUpClass("_DPWordRecord");
  uint64_t result = objc_lookUpClass("_DPStringRecorder");
  qword_1E9459D68 = (uint64_t)result;
  if (!qword_1E9459D60)
  {
    CFURLRef v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"/System/Library/PrivateFrameworks/DifferentialPrivacy.framework", kCFURLPOSIXPathStyle, 1u);
    qword_1E9459FC0 = (uint64_t)CFBundleCreate(0, v1);
    CFRelease(v1);
    if (qword_1E9459FC0)
    {
      CFBundleLoadExecutableAndReturnError((CFBundleRef)qword_1E9459FC0, 0);
      qword_1E9459D60 = (uint64_t)objc_lookUpClass("_DPWordRecorder");
      qword_1E9459D50 = (uint64_t)objc_lookUpClass("_DPWordRecord");
      uint64_t result = objc_lookUpClass("_DPStringRecorder");
      qword_1E9459D68 = (uint64_t)result;
    }
    else
    {
      uint64_t result = (void *)qword_1E9459D68;
    }
  }
  if (qword_1E9459D60) {
    BOOL v2 = qword_1E9459D50 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2 && result != 0)
  {
    qword_1E9459D58 = (uint64_t)objc_lookUpClass("NSAutoreleasePool");
    uint64_t result = dispatch_queue_create("com.apple.LanguageModeling.recorder", 0);
    qword_1E9459D48 = (uint64_t)result;
  }
  return result;
}

uint64_t sub_19E4371FC(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  *(void *)a1 = MEMORY[0x19F3BCDC0](0);
  *(_DWORD *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = 0;
  if (qword_1E9459D70 == -1)
  {
    if (a4)
    {
LABEL_3:
      *(void *)(a1 + 16) = a4;
      return a1;
    }
  }
  else
  {
    dispatch_once(&qword_1E9459D70, &unk_1EF0BEBC0);
    if (a4) {
      goto LABEL_3;
    }
  }
  CFLocaleRef v7 = *(const __CFLocale **)a1;
  int v8 = *(_DWORD *)(a1 + 8);
  CFTypeRef Value = CFLocaleGetValue(*(CFLocaleRef *)a1, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  CFTypeRef v10 = CFLocaleGetValue(v7, (CFLocaleKey)*MEMORY[0x1E4F1D1F0]);
  if (v10)
  {
    int v11 = @"RevisedWords";
    if (v8 == 1) {
      int v11 = @"LocalWords";
    }
    if (!v8) {
      int v11 = @"NewWords";
    }
  }
  else
  {
    CFTypeRef v10 = (CFTypeRef)[&unk_1EF0C20E0 objectForKey:Value];
    int v11 = @"RevisedWords";
    if (v8 == 1) {
      int v11 = @"LocalWords";
    }
    if (!v8) {
      int v11 = @"NewWords";
    }
    if (!v10)
    {
      CFStringRef v12 = CFStringCreateWithFormat(0, 0, @"com.apple.keyboard.%@.%@", v11, Value);
      goto LABEL_17;
    }
  }
  CFStringRef v12 = CFStringCreateWithFormat(0, 0, @"com.apple.keyboard.%@.%@_%@", v11, Value, v10);
LABEL_17:
  CFStringRef v13 = v12;
  int v14 = &qword_1E9459D68;
  if (a3 != 2) {
    int v14 = &qword_1E9459D60;
  }
  *(void *)(a1 + 16) = objc_msgSend((id)objc_msgSend((id)*v14, "alloc"), "initWithKey:", v12);
  CFRelease(v13);
  return a1;
}

void sub_19E437390(const __CFLocale **a1, CFStringRef theString)
{
  CFStringRef v2 = theString;
  uint64_t v3 = a1;
  CFLocaleRef v4 = *a1;
  CFIndex Length = CFStringGetLength(theString);
  if (Length < 3) {
    return;
  }
  CFIndex v47 = Length;
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v2);
  CFMutableStringRef v63 = MutableCopy;
  CFStringUppercase(MutableCopy, v4);
  if (CFEqual(v2, MutableCopy))
  {
    BOOL v8 = 0;
    if (MutableCopy) {
      goto LABEL_73;
    }
    goto LABEL_74;
  }
  CFStringRef theStringa = v2;
  uint64_t v59 = 0;
  int64_t v60 = v47;
  CharactersPtr = CFStringGetCharactersPtr(v2);
  uint64_t v45 = v3;
  CFStringRef v46 = v2;
  uint64_t v44 = MutableCopy;
  if (CharactersPtr) {
    CStringPtr = 0;
  }
  else {
    CStringPtr = CFStringGetCStringPtr(v2, 0x600u);
  }
  uint64_t v9 = 0;
  int64_t v10 = 0;
  BOOL v8 = 0;
  int v11 = 0;
  uint64_t v61 = 0;
  int64_t v62 = 0;
  unint64_t v12 = v47;
  CFIndex v13 = v47 - 1;
  UniChar v58 = CStringPtr;
  uint64_t v14 = -1;
  uint64_t v15 = 65;
  uint64_t v16 = MEMORY[0x1E4F14390];
  unint64_t v17 = 1;
  int v18 = 1;
  do
  {
    int64_t v19 = v9 + 1;
    if (v17 >= 5) {
      uint64_t v20 = 5;
    }
    else {
      uint64_t v20 = v17;
    }
    if (v17 >= 4) {
      uint64_t v21 = 4;
    }
    else {
      uint64_t v21 = v17;
    }
    int64_t v22 = v60;
    if (v60 <= v19)
    {
      UniChar v24 = 0;
      if (v60 < v19) {
        goto LABEL_22;
      }
    }
    else
    {
      if (CharactersPtr)
      {
        uint8x8_t v23 = (UniChar *)&CharactersPtr[v9 + v59];
        goto LABEL_18;
      }
      if (!v58)
      {
        if (v62 <= v19 || v10 > v19)
        {
          CFIndex v30 = v13;
          uint64_t v31 = v21 + v14;
          uint64_t v32 = v15 - v21;
          uint64_t v33 = v9 - v21;
          uint64_t v34 = v33 + 1;
          int64_t v35 = v33 + 65;
          if (v35 >= v60) {
            int64_t v35 = v60;
          }
          uint64_t v61 = v34;
          int64_t v62 = v35;
          if (v60 >= v32) {
            int64_t v22 = v32;
          }
          v64.length = v22 + v31;
          v64.location = v34 + v59;
          CFStringGetCharacters(theStringa, v64, buffer);
          int64_t v22 = v60;
          int64_t v10 = v61;
          unint64_t v12 = v47;
          CFIndex v13 = v30;
          uint64_t v16 = MEMORY[0x1E4F14390];
        }
        uint8x8_t v23 = &buffer[v9 - v10];
LABEL_18:
        UniChar v24 = v23[1];
        if (v22 < v19) {
          goto LABEL_22;
        }
        goto LABEL_19;
      }
      UniChar v24 = v58[v59 + 1 + v9];
      if (v60 < v19)
      {
LABEL_22:
        UniChar v25 = 0;
        goto LABEL_23;
      }
    }
LABEL_19:
    if (CharactersPtr)
    {
      UniChar v25 = CharactersPtr[v9 + v59];
    }
    else if (v58)
    {
      UniChar v25 = v58[v59 + v9];
    }
    else
    {
      if (v62 < v19 || v10 >= v19)
      {
        CFIndex v43 = v13;
        uint64_t v36 = v9 - v20 + 65;
        if (v36 >= v22) {
          uint64_t v36 = v22;
        }
        uint64_t v61 = v9 - v20 + 1;
        int64_t v62 = v36;
        if (v22 >= v15 - v20) {
          int64_t v22 = v15 - v20;
        }
        v65.length = v22 + v20 + v14;
        v65.location = v9 - v20 + 1 + v59;
        CFStringGetCharacters(theStringa, v65, buffer);
        int64_t v10 = v61;
        unint64_t v12 = v47;
        CFIndex v13 = v43;
        uint64_t v16 = MEMORY[0x1E4F14390];
      }
      UniChar v25 = buffer[v9 - v10];
    }
LABEL_23:
    if (v24 <= 0xFFu && (*(_DWORD *)(v16 + 4 * v24 + 60) & 0x400) != 0) {
      break;
    }
    if ((unint64_t)v19 < 2 || (int64_t v26 = v9 - 1, v27 = v60, v60 <= v9 - 1))
    {
      unsigned __int16 v29 = 0;
    }
    else
    {
      if (CharactersPtr)
      {
        uint64_t v28 = (UniChar *)&CharactersPtr[v9 + v59];
LABEL_29:
        unsigned __int16 v29 = *(v28 - 1);
        goto LABEL_31;
      }
      if (!v58)
      {
        if (v62 <= v26 || v10 > v26)
        {
          CFIndex v37 = v13;
          uint64_t v38 = v9 - 5;
          if ((unint64_t)v26 < 4) {
            uint64_t v38 = 0;
          }
          if (v38 + 64 < v60) {
            uint64_t v27 = v38 + 64;
          }
          uint64_t v61 = v38;
          int64_t v62 = v27;
          v66.location = v59 + v38;
          v66.length = v27 - v38;
          CFStringGetCharacters(theStringa, v66, buffer);
          int64_t v10 = v61;
          unint64_t v12 = v47;
          CFIndex v13 = v37;
          uint64_t v16 = MEMORY[0x1E4F14390];
        }
        uint64_t v28 = &buffer[v9 - v10];
        goto LABEL_29;
      }
      unsigned __int16 v29 = v58[v59 - 1 + v9];
    }
LABEL_31:
    if (v24 == v29) {
      ++v11;
    }
    else {
      int v11 = 0;
    }
    if (v24 == v25) {
      ++v18;
    }
    else {
      int v18 = 1;
    }
    if (v18 == 3) {
      break;
    }
    if (v11 == 4) {
      break;
    }
    ++v17;
    BOOL v8 = v9 + 2 >= v12;
    ++v9;
    --v14;
    ++v15;
  }
  while (v13 != v9);
  uint64_t v3 = v45;
  CFStringRef v2 = v46;
  CFMutableStringRef MutableCopy = v44;
  if (v44) {
LABEL_73:
  }
    CFRelease(MutableCopy);
LABEL_74:
  if (v8)
  {
    if (v2)
    {
      CFLocaleRef v39 = v3[2];
      if (v39)
      {
        if (qword_1E9459D48)
        {
          if (*((_DWORD *)v3 + 2) == 2)
          {
            CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
            CFArrayAppendValue(Mutable, v2);
            *(void *)buffer = 0;
            uint64_t v51 = buffer;
            uint64_t v52 = 0x3052000000;
            unint64_t v53 = sub_19E437988;
            int v54 = sub_19E437998;
            CFLocaleRef v55 = 0;
            CFLocaleRef v55 = v3[2];
            int v41 = qword_1E9459D48;
            v49[0] = MEMORY[0x1E4F143A8];
            v49[1] = 3221225472;
            v49[2] = sub_19E4379A4;
            v49[3] = &unk_1E599F978;
            v49[4] = buffer;
            v49[5] = Mutable;
            uint64_t v42 = v49;
          }
          else
          {
            *(void *)buffer = 0;
            uint64_t v51 = buffer;
            uint64_t v52 = 0x3052000000;
            unint64_t v53 = sub_19E437988;
            int v54 = sub_19E437998;
            CFLocaleRef v55 = 0;
            CFLocaleRef v55 = v39;
            CFRetain(v2);
            int v41 = qword_1E9459D48;
            block[0] = MEMORY[0x1E4F143A8];
            block[1] = 3221225472;
            block[2] = sub_19E4379F8;
            block[3] = &unk_1E599F978;
            block[4] = buffer;
            block[5] = v2;
            uint64_t v42 = block;
          }
          dispatch_async(v41, v42);
          _Block_object_dispose(buffer, 8);
        }
      }
    }
  }
}

void sub_19E437948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_19E437960(_Unwind_Exception *a1)
{
  sub_19E422428((const void **)(v1 - 96));
  _Unwind_Resume(a1);
}

void sub_19E437988(uint64_t a1, uint64_t a2)
{
}

void sub_19E437998(uint64_t a1)
{
}

void sub_19E4379A4(uint64_t a1)
{
  [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) record:*(void *)(a1 + 40)];

  CFStringRef v2 = *(const void **)(a1 + 40);
  CFRelease(v2);
}

void sub_19E4379F8(uint64_t a1)
{
  id v18 = objc_alloc_init((Class)qword_1E9459D58);
  uint64_t v19 = a1;
  CFStringRef v2 = *(const __CFString **)(a1 + 40);
  uint64_t v3 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  uint64_t valuePtr = 0;
  uint64_t Length = CFStringGetLength(v2);
  unint64_t v17 = v3;
  uint64_t v5 = [v3 wordFragmentWidth];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  v21.CFIndex location = 0;
  v21.length = Length;
  CFStringRef v7 = CFStringCreateWithSubstring(0, v2, v21);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  CFArrayAppendValue(Mutable, (const void *)[(id)qword_1E9459D50 word:v7 atPosition:v8]);
  CFRelease(v8);
  CFRelease(v7);
  if (v5 <= 1) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = v5;
  }
  if (Length >= 1 && valuePtr < Length)
  {
    CFIndex location = 0;
    CFIndex v11 = 0;
    do
    {
      unint64_t v12 = CFStringCreateMutable(0, 0);
      ++valuePtr;
      uint64_t v13 = v9;
      do
      {
        if (v11 + location < Length)
        {
          CFRange RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex(v2, v11 + location);
          CFIndex location = RangeOfComposedCharactersAtIndex.location;
          CFIndex v11 = RangeOfComposedCharactersAtIndex.length;
          CFStringRef v15 = CFStringCreateWithSubstring(0, v2, RangeOfComposedCharactersAtIndex);
          CFStringAppend(v12, v15);
          CFRelease(v15);
        }
        --v13;
      }
      while (v13);
      CFNumberRef v16 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
      CFArrayAppendValue(Mutable, (const void *)[(id)qword_1E9459D50 word:v12 atPosition:v16]);
      CFRelease(v16);
      CFRelease(v12);
    }
    while (location + v11 < Length && valuePtr < Length);
  }
  [v17 record:Mutable];
  CFRelease(Mutable);

  CFRelease(*(CFTypeRef *)(v19 + 40));
}

uint64_t sub_19E437C1C()
{
  return 1;
}

uint64_t sub_19E437C24(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

uint64_t sub_19E437C4C(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v6 = a1;
  CFNumberRef v8 = (char ***)*a2;
  CFStringRef v7 = (char ***)a2[1];
  if (0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a2) >> 3) <= 1)
  {
    sub_19E4E9368(a1, a2, a3, a4, a5, a6);
    return 1;
  }
  v209 = 0;
  long long v210 = 0uLL;
  uint64_t v206 = 0;
  uint64_t v207 = 0;
  unint64_t v208 = 0;
  if (v8 != v7)
  {
    uint64_t v185 = v7;
    while (1)
    {
      unint64_t __p = 0;
      long long v204 = 0;
      uint64_t v205 = 0;
      uint64_t v199 = 0;
      unint64_t v200 = 0;
      int v201 = 0;
      uint64_t v9 = *v8;
      v189 = v8;
      uint64_t v197 = v8[1];
      if (*v8 != v197) {
        break;
      }
LABEL_82:
      uint64_t v84 = (void *)v210;
      if ((unint64_t)v210 >= *((void *)&v210 + 1))
      {
        int v89 = v209;
        unint64_t v90 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v210 - (void)v209) >> 3);
        unint64_t v91 = v90 + 1;
        if (v90 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C7C4();
        }
        if (0x5555555555555556 * ((uint64_t)(*((void *)&v210 + 1) - (void)v209) >> 3) > v91) {
          unint64_t v91 = 0x5555555555555556 * ((uint64_t)(*((void *)&v210 + 1) - (void)v209) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v210 + 1) - (void)v209) >> 3) >= 0x555555555555555) {
          unint64_t v92 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v92 = v91;
        }
        uint64_t v214 = (char *)&v210 + 8;
        if (v92)
        {
          if (v92 > 0xAAAAAAAAAAAAAAALL) {
            sub_19E37C2B8();
          }
          int32x2_t v93 = (char *)operator new(24 * v92);
        }
        else
        {
          int32x2_t v93 = 0;
        }
        std::string::size_type v211 = v93;
        v212 = &v93[24 * v90];
        uint64_t v95 = &v93[24 * v92];
        *(void *)&long long v213 = v212;
        *((void *)&v213 + 1) = v95;
        char v96 = v212;
        *((void *)v212 + 1) = 0;
        unint64_t v97 = (char **)(v96 + 8);
        uint64_t v94 = &v93[24 * v90];
        *((void *)v94 + 2) = 0;
        *(void *)uint64_t v94 = 0;
        int64_t v98 = (int64_t)&v204[-__p];
        if (v204 != (char *)__p)
        {
          if (v98 < 0) {
            sub_19E37C7C4();
          }
          size_t v99 = (char *)operator new((size_t)&v204[-__p]);
          *(void *)uint64_t v94 = v99;
          *unint64_t v97 = v99;
          std::string::size_type v100 = &v99[4 * (v98 >> 2)];
          *((void *)v94 + 2) = v100;
          memcpy(v99, (const void *)__p, v98);
          *unint64_t v97 = v100;
        }
        unsigned __int8 v88 = v94 + 24;
        *(void *)&long long v213 = v94 + 24;
        if (v84 == v89)
        {
          v209 = v94;
          *(void *)&long long v210 = v94 + 24;
          *((void *)&v210 + 1) = v95;
        }
        else
        {
          do
          {
            __int16 v101 = v94;
            *((void *)v94 - 2) = 0;
            *((void *)v94 - 1) = 0;
            long long v102 = *(_OWORD *)(v84 - 3);
            v84 -= 3;
            *(_OWORD *)(v94 - 24) = v102;
            v94 -= 24;
            *((void *)v101 - 1) = v84[2];
            *uint64_t v84 = 0;
            v84[1] = 0;
            v84[2] = 0;
          }
          while (v84 != v89);
          uint64_t v84 = v209;
          int v103 = (void *)v210;
          v209 = v94;
          long long v210 = v213;
          unsigned __int8 v88 = (void *)v213;
          if (v103 != v84)
          {
            int v104 = v103;
            do
            {
              size_t v106 = (void *)*(v104 - 3);
              v104 -= 3;
              int v105 = v106;
              if (v106)
              {
                *(v103 - 2) = v105;
                operator delete(v105);
              }
              int v103 = v104;
            }
            while (v104 != v84);
          }
        }
        if (v84) {
          operator delete(v84);
        }
      }
      else
      {
        *(_OWORD *)long long v210 = 0uLL;
        v84[2] = 0;
        int64_t v85 = (int64_t)&v204[-__p];
        if (v204 != (char *)__p)
        {
          if (v85 < 0) {
            sub_19E37C7C4();
          }
          unsigned __int8 v86 = (char *)operator new((size_t)&v204[-__p]);
          *uint64_t v84 = v86;
          v84[1] = v86;
          uint64_t v87 = &v86[4 * (v85 >> 2)];
          v84[2] = v87;
          memcpy(v86, (const void *)__p, v85);
          v84[1] = v87;
        }
        unsigned __int8 v88 = v84 + 3;
      }
      *(void *)&long long v210 = v88;
      unint64_t v107 = v207;
      if ((unint64_t)v207 >= v208)
      {
        uint64_t v108 = v199;
        int v112 = sub_19E3F40DC((char **)&v206, v199, (uint64_t)v200);
      }
      else
      {
        *(void *)uint64_t v207 = 0;
        *((void *)v107 + 1) = 0;
        *((void *)v107 + 2) = 0;
        uint64_t v108 = v199;
        int64_t v109 = v200 - v199;
        if (v200 != v199)
        {
          if (v109 < 0) {
            sub_19E37C7C4();
          }
          uint64_t v110 = (char *)operator new(v200 - v199);
          *(void *)unint64_t v107 = v110;
          *((void *)v107 + 1) = v110;
          unsigned int v111 = &v110[8 * (v109 >> 3)];
          *((void *)v107 + 2) = v111;
          memcpy(v110, v199, v109);
          *((void *)v107 + 1) = v111;
        }
        int v112 = v107 + 24;
      }
      uint64_t v207 = v112;
      uint64_t v6 = a1;
      if (v108) {
        operator delete(v108);
      }
      if (__p) {
        operator delete((void *)__p);
      }
      CFNumberRef v8 = v189 + 3;
      if (v189 + 3 == v185) {
        goto LABEL_120;
      }
    }
    int64_t v10 = 0;
    uint64_t v11 = 0;
    while (1)
    {
      CFNumberRef v16 = *v9;
      CFStringRef v15 = v9[1];
      uint64_t v17 = v15 - *v9;
      if (v17 >= 1)
      {
        uint64_t v18 = v17 >> 2;
        uint64_t v19 = (void *)__p;
        int64_t v20 = (int64_t)&v10[-__p];
        uint64_t v21 = (uint64_t)&v10[-__p] >> 2;
        int64_t v22 = (char *)(__p + ((unint64_t)&v10[-__p] & 0xFFFFFFFFFFFFFFFCLL));
        if (v17 >> 2 > (v205 - v10) >> 2)
        {
          unint64_t v23 = v21 + v18;
          if ((unint64_t)(v21 + v18) >> 62) {
            sub_19E37C7C4();
          }
          uint64_t v24 = (uint64_t)&v205[-__p];
          if ((uint64_t)&v205[-__p] >> 1 > v23) {
            unint64_t v23 = v24 >> 1;
          }
          _CF = (unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
          if (!_CF) {
            unint64_t v26 = v23;
          }
          unint64_t v194 = v26;
          if (v26)
          {
            if (v26 >> 62) {
              sub_19E37C2B8();
            }
            uint64_t v27 = operator new(4 * v26);
            int64_t v22 = (char *)(__p + ((unint64_t)&v10[-__p] & 0xFFFFFFFFFFFFFFFCLL));
            uint64_t v21 = (uint64_t)&v10[-__p] >> 2;
          }
          else
          {
            uint64_t v27 = 0;
          }
          int v41 = &v27[4 * v21];
          uint64_t v42 = &v41[4 * v18];
          if ((unint64_t)(v17 - 4) >= 0x1C)
          {
            CFIndex v43 = &v27[4 * v21];
            if ((unint64_t)(&v27[v20 & 0xFFFFFFFFFFFFFFFCLL] - v16) < 0x20) {
              goto LABEL_39;
            }
            unint64_t v44 = ((unint64_t)(v17 - 4) >> 2) + 1;
            uint64_t v45 = 4 * (v44 & 0x7FFFFFFFFFFFFFF8);
            CFIndex v43 = &v41[v45];
            CFStringRef v46 = (long long *)(v16 + 16);
            CFIndex v47 = &v27[4 * v21 + 16];
            uint64_t v48 = v44 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v49 = *v46;
              *(v47 - 1) = *(v46 - 1);
              *CFIndex v47 = v49;
              v46 += 2;
              v47 += 2;
              v48 -= 8;
            }
            while (v48);
            if (v44 != (v44 & 0x7FFFFFFFFFFFFFF8))
            {
              v16 += v45;
              goto LABEL_39;
            }
          }
          else
          {
            CFIndex v43 = &v27[4 * v21];
            do
            {
LABEL_39:
              int v50 = *(_DWORD *)v16;
              v16 += 4;
              *(_DWORD *)CFIndex v43 = v50;
              v43 += 4;
            }
            while (v43 != v42);
          }
          if ((char *)__p != v10)
          {
            if ((unint64_t)(v20 - 4) < 0x3C)
            {
              uint64_t v51 = v22;
              goto LABEL_47;
            }
            uint64_t v51 = v22;
            if (__p + (v20 & 0xFFFFFFFFFFFFFFFCLL) - (unint64_t)&v27[v20 & 0xFFFFFFFFFFFFFFFCLL] < 0x20) {
              goto LABEL_212;
            }
            unint64_t v52 = ((unint64_t)(v20 - 4) >> 2) + 1;
            uint64_t v51 = &v22[-4 * (v52 & 0x7FFFFFFFFFFFFFF8)];
            unint64_t v53 = (long long *)(__p + 4 * v21 - 16);
            int v54 = &v27[4 * v21 - 16];
            uint64_t v55 = v52 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v56 = *v53;
              *(v54 - 1) = *(v53 - 1);
              *int v54 = v56;
              v53 -= 2;
              v54 -= 2;
              v55 -= 8;
            }
            while (v55);
            v41 -= 4 * (v52 & 0x7FFFFFFFFFFFFFF8);
            if (v52 != (v52 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_212:
              do
              {
LABEL_47:
                int v57 = *((_DWORD *)v51 - 1);
                v51 -= 4;
                *((_DWORD *)v41 - 1) = v57;
                v41 -= 4;
              }
              while (v51 != (char *)__p);
            }
          }
          size_t v58 = v10 - v22;
          if (v58)
          {
            uint64_t v59 = v27;
            memmove(v42, v22, v58);
            uint64_t v27 = v59;
          }
          int64_t v10 = &v42[v58];
          unint64_t __p = (unint64_t)v41;
          long long v204 = v10;
          uint64_t v205 = &v27[4 * v194];
          if (v19) {
            operator delete(v19);
          }
          goto LABEL_62;
        }
        uint64_t v28 = v10 - v22;
        uint64_t v29 = (v10 - v22) >> 2;
        if (v29 >= v18)
        {
          CFIndex v30 = &v16[4 * v18];
          uint64_t v32 = v10;
LABEL_26:
          uint64_t v33 = &v22[4 * v18];
          size_t v34 = v32 - v33;
          uint64_t v35 = (v32 - v33) >> 2;
          uint64_t v36 = &v32[-4 * v18];
          CFIndex v37 = v32;
          if (v36 < v10)
          {
            unint64_t v38 = (v20 & 0xFFFFFFFFFFFFFFFCLL) + v34;
            unint64_t v39 = __p + v38 + 4;
            if ((unint64_t)v10 > v39) {
              unint64_t v39 = (unint64_t)v10;
            }
            unint64_t v40 = v39 + ~__p - v38;
            if (v40 <= 0x2B)
            {
              CFIndex v37 = v32;
              goto LABEL_56;
            }
            CFIndex v37 = v32;
            if ((unint64_t)&v33[-(v20 & 0xFFFFFFFFFFFFFFFCLL) - __p] < 0x20) {
              goto LABEL_213;
            }
            uint64_t v60 = (v40 >> 2) + 1;
            uint64_t v61 = 4 * (v60 & 0x7FFFFFFFFFFFFFF8);
            v36 += v61;
            int64_t v62 = v32 + 16;
            CFMutableStringRef v63 = (long long *)(__p + 4 * v35 + 4 * v21 + 16);
            uint64_t v64 = v60 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v65 = *v63;
              *(v62 - 1) = *(v63 - 1);
              _OWORD *v62 = v65;
              v62 += 2;
              v63 += 2;
              v64 -= 8;
            }
            while (v64);
            CFIndex v37 = &v32[v61];
            if (v60 != (v60 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_213:
              do
              {
LABEL_56:
                int v66 = *(_DWORD *)v36;
                v36 += 4;
                *(_DWORD *)CFIndex v37 = v66;
                v37 += 4;
              }
              while (v36 < v10);
            }
          }
          long long v204 = v37;
          if (v32 != v33)
          {
            int v67 = v22;
            memmove(&v32[-4 * v35], v22, v34);
            int64_t v22 = v67;
          }
          if (v30 != v16) {
            memmove(v22, v16, v30 - v16);
          }
          int64_t v10 = v37;
          goto LABEL_62;
        }
        CFIndex v30 = &v16[4 * v29];
        int64_t v31 = v15 - v30;
        if (v15 != v30)
        {
          v191 = &v16[4 * v29];
          memmove(v10, v191, v15 - v30);
          uint64_t v21 = (uint64_t)&v10[-__p] >> 2;
          CFIndex v30 = v191;
          int64_t v22 = (char *)(__p + ((unint64_t)&v10[-__p] & 0xFFFFFFFFFFFFFFFCLL));
        }
        uint64_t v32 = &v10[v31];
        long long v204 = &v10[v31];
        if (v28 >= 1) {
          goto LABEL_26;
        }
        v10 += v31;
      }
LABEL_62:
      uint64_t v68 = v11 + ((v9[1] - *v9) >> 2);
      unint64_t v69 = v200;
      if (v200 < v201)
      {
        *(void *)unint64_t v200 = v68;
        unint64_t v12 = v200 + 8;
      }
      else
      {
        uint64_t v70 = v199;
        uint64_t v71 = (v200 - v199) >> 3;
        unint64_t v72 = v71 + 1;
        if ((unint64_t)(v71 + 1) >> 61) {
          sub_19E37C7C4();
        }
        uint64_t v73 = v201 - v199;
        if ((v201 - v199) >> 2 > v72) {
          unint64_t v72 = v73 >> 2;
        }
        if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v74 = v72;
        }
        if (v74)
        {
          if (v74 >> 61) {
            sub_19E37C2B8();
          }
          unint64_t v75 = operator new(8 * v74);
        }
        else
        {
          unint64_t v75 = 0;
        }
        double v76 = &v75[8 * v71];
        *(void *)double v76 = v68;
        unint64_t v12 = v76 + 8;
        if (v200 != v199)
        {
          unint64_t v77 = v200 - 8 - v199;
          if (v77 < 0x58) {
            goto LABEL_214;
          }
          if ((unint64_t)(v199 - v75) < 0x20) {
            goto LABEL_214;
          }
          uint64_t v78 = (v77 >> 3) + 1;
          uint64_t v79 = &v75[8 * v71 - 16];
          std::string::size_type v80 = v200 - 16;
          uint64_t v81 = v78 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v82 = *(_OWORD *)v80;
            *(v79 - 1) = *((_OWORD *)v80 - 1);
            *uint64_t v79 = v82;
            v79 -= 2;
            v80 -= 32;
            v81 -= 4;
          }
          while (v81);
          v76 -= 8 * (v78 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v69 = &v200[-8 * (v78 & 0x3FFFFFFFFFFFFFFCLL)];
          if (v78 != (v78 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_214:
            do
            {
              uint64_t v83 = *((void *)v69 - 1);
              v69 -= 8;
              *((void *)v76 - 1) = v83;
              v76 -= 8;
            }
            while (v69 != v199);
          }
        }
        uint64_t v199 = v76;
        int v201 = &v75[8 * v74];
        if (v70) {
          operator delete(v70);
        }
      }
      unint64_t v200 = v12;
      uint64_t v14 = *v9;
      uint64_t v13 = v9[1];
      v9 += 3;
      v11 += (v13 - v14) >> 2;
      if (v9 == v197) {
        goto LABEL_82;
      }
    }
  }
LABEL_120:
  (*(void (**)(char **__return_ptr))(**(void **)(v6 + 40) + 64))(&v211);
  uint64_t v113 = v207;
  if (v207 != v206)
  {
    unint64_t v114 = 0;
    int v115 = 0;
    __asm { FMOV            V10.2S, #-10.0 }
    uint64_t v113 = (char *)v206;
    do
    {
      int v186 = v115;
      __pa = 0;
      uint64_t v120 = *(void *)&v113[24 * v114];
      if (*(void *)&v113[24 * v114 + 8] != v120)
      {
        unint64_t v121 = 0;
        int v122 = 0;
        CFMutableStringRef v123 = 0;
        uint64_t v124 = 0;
        unsigned int v125 = 0;
        uint64_t v126 = 0;
        unint64_t v190 = v114;
        while (1)
        {
          uint64_t v130 = *(void *)(v120 + 8 * v124);
          float v131 = 0.0;
          if (v126 != v130) {
            break;
          }
LABEL_138:
          float v147 = __exp10(v131);
LABEL_139:
          if (v123 >= v122)
          {
            uint64_t v148 = v123 - v121;
            unint64_t v149 = v148 + 1;
            if ((unint64_t)(v148 + 1) >> 62) {
              sub_19E37C7C4();
            }
            if (((char *)v122 - (char *)v121) >> 1 > v149) {
              unint64_t v149 = ((char *)v122 - (char *)v121) >> 1;
            }
            if ((unint64_t)((char *)v122 - (char *)v121) >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v150 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v150 = v149;
            }
            if (v150)
            {
              if (v150 >> 62) {
                sub_19E37C2B8();
              }
              v151 = operator new(4 * v150);
            }
            else
            {
              v151 = 0;
            }
            size_t v152 = (float *)&v151[4 * v148];
            *size_t v152 = v147;
            uint64_t v127 = (uint64_t)(v152 + 1);
            if (v123 == v121)
            {
              unint64_t v114 = v190;
            }
            else
            {
              unint64_t v153 = (char *)(v123 - 1) - (char *)v121;
              if (v153 < 0x2C || (unint64_t)((char *)v121 - v151) < 0x20)
              {
                int v154 = v123;
                unint64_t v114 = v190;
                goto LABEL_154;
              }
              uint64_t v156 = (v153 >> 2) + 1;
              int v154 = &v123[-(v156 & 0x7FFFFFFFFFFFFFF8)];
              unint64_t v157 = &v151[4 * v148 - 16];
              unint64_t v158 = v123 - 4;
              uint64_t v159 = v156 & 0x7FFFFFFFFFFFFFF8;
              unint64_t v114 = v190;
              do
              {
                long long v160 = *(_OWORD *)v158;
                *(v157 - 1) = *((_OWORD *)v158 - 1);
                *unint64_t v157 = v160;
                v157 -= 2;
                v158 -= 8;
                v159 -= 8;
              }
              while (v159);
              v152 -= v156 & 0x7FFFFFFFFFFFFFF8;
              if (v156 != (v156 & 0x7FFFFFFFFFFFFFF8))
              {
                do
                {
LABEL_154:
                  int v155 = *((_DWORD *)v154-- - 1);
                  *((_DWORD *)v152-- - 1) = v155;
                }
                while (v154 != v121);
              }
            }
            int v122 = (float *)&v151[4 * v150];
            __pa = v152;
            if (v121) {
              operator delete(v121);
            }
            unint64_t v121 = v152;
            goto LABEL_127;
          }
          float *v123 = v147;
          uint64_t v127 = (uint64_t)(v123 + 1);
LABEL_127:
          std::string v128 = (uint64_t *)((char *)v206 + 24 * v114);
          uint64_t v120 = *v128;
          uint64_t v129 = v128[1];
          uint64_t v126 = *(void *)(*v128 + 8 * v124);
          CFMutableStringRef v123 = (float *)v127;
          uint64_t v124 = ++v125;
          if (v125 >= (unint64_t)((v129 - v120) >> 3)) {
            goto LABEL_165;
          }
        }
        uint64_t v132 = *(void *)&v211[24 * v114];
        uint64_t v133 = 4 * v126;
        uint64_t v134 = (float32x2_t *)(v132 + v133);
        unint64_t v135 = 4 * v130 - v133 - 4;
        if (v135 >= 0xC)
        {
          uint64_t v188 = (v135 >> 2) + 1;
          unint64_t v136 = (float *)v134 + (v188 & 0x7FFFFFFFFFFFFFFCLL);
          size_t v137 = v134 + 1;
          float32x2_t v138 = 0;
          uint64_t v139 = v188 & 0x7FFFFFFFFFFFFFFCLL;
          float32x2_t v140 = 0;
          do
          {
            LODWORD(v192) = v137[-1];
            float32x2_t v198 = *v137;
            int8x8_t v141 = (int8x8_t)vcgtz_f32(v137[-1]);
            int8x8_t v142 = (int8x8_t)vcgtz_f32(*v137);
            float v195 = log10f(COERCE_FLOAT(HIDWORD(*(void *)&v137[-1])));
            *(float *)v143.i32 = log10f(v192);
            *(float *)&v143.i32[1] = v195;
            int8x8_t v196 = v143;
            float v193 = log10f(v198.f32[1]);
            *(float *)v144.i32 = log10f(v198.f32[0]);
            *(float *)&v144.i32[1] = v193;
            float32x2_t v138 = vadd_f32((float32x2_t)vbsl_s8(v141, v196, _D10), v138);
            float32x2_t v140 = vadd_f32((float32x2_t)vbsl_s8(v142, v144, _D10), v140);
            v137 += 2;
            v139 -= 4;
          }
          while (v139);
          float v131 = vaddv_f32(vadd_f32(v140, v138));
          unint64_t v114 = v190;
          if (v188 != (v188 & 0x7FFFFFFFFFFFFFFCLL)) {
            goto LABEL_134;
          }
        }
        else
        {
          unint64_t v136 = (float *)v134;
          do
          {
LABEL_134:
            float v145 = *v136++;
            float v146 = log10f(v145);
            if (v145 <= 0.0) {
              float v146 = -10.0;
            }
            float v131 = v146 + v131;
          }
          while (v136 != (float *)(v132 + 4 * v130));
        }
        float v147 = 0.0;
        if (v131 <= -10.0) {
          goto LABEL_139;
        }
        goto LABEL_138;
      }
      uint64_t v127 = 0;
LABEL_165:
      v161 = *(void **)(a5 + 8);
      if ((unint64_t)v161 >= *(void *)(a5 + 16))
      {
        std::string::size_type v162 = __pa;
        *(void *)(a5 + 8) = sub_19E438A94((char **)a5, __pa, v127);
        if (!__pa) {
          goto LABEL_123;
        }
      }
      else
      {
        void *v161 = 0;
        v161[1] = 0;
        v161[2] = 0;
        std::string::size_type v162 = __pa;
        int64_t v163 = v127 - (void)__pa;
        if ((float *)v127 != __pa)
        {
          if (v163 < 0) {
            sub_19E37C7C4();
          }
          int v164 = (char *)operator new(v127 - (void)__pa);
          void *v161 = v164;
          v161[1] = v164;
          v165 = &v164[4 * (v163 >> 2)];
          v161[2] = v165;
          memcpy(v164, __pa, v163);
          v161[1] = v165;
        }
        *(void *)(a5 + 8) = v161 + 3;
        *(void *)(a5 + 8) = v161 + 3;
        if (!__pa) {
          goto LABEL_123;
        }
      }
      operator delete(v162);
LABEL_123:
      unint64_t v114 = (v186 + 1);
      uint64_t v113 = (char *)v206;
      int v115 = v186 + 1;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((v207 - (unsigned char *)v206) >> 3) > v114);
  }
  size_t v166 = v211;
  if (v211)
  {
    size_t v167 = v212;
    int v168 = v211;
    if (v212 != v211)
    {
      uint64_t v169 = v212;
      do
      {
        int v171 = (void *)*((void *)v169 - 3);
        v169 -= 24;
        double v170 = v171;
        if (v171)
        {
          *((void *)v167 - 2) = v170;
          operator delete(v170);
        }
        size_t v167 = v169;
      }
      while (v169 != v166);
      int v168 = v211;
    }
    v212 = v166;
    operator delete(v168);
    uint64_t v113 = (char *)v206;
  }
  if (v113)
  {
    uint64_t v172 = v207;
    uint64_t v173 = v113;
    if (v207 != v113)
    {
      uint64_t v174 = v207;
      do
      {
        std::string::size_type v176 = (void *)*((void *)v174 - 3);
        v174 -= 24;
        double v175 = v176;
        if (v176)
        {
          *((void *)v172 - 2) = v175;
          operator delete(v175);
        }
        uint64_t v172 = v174;
      }
      while (v174 != v113);
      uint64_t v173 = v206;
    }
    uint64_t v207 = v113;
    operator delete(v173);
  }
  int v177 = (char *)v209;
  if (v209)
  {
    BOOL v178 = (char *)v210;
    double v179 = v209;
    if ((void *)v210 != v209)
    {
      unint64_t v180 = (char *)v210;
      do
      {
        unint64_t v182 = (void *)*((void *)v180 - 3);
        v180 -= 24;
        uint64_t v181 = v182;
        if (v182)
        {
          *((void *)v178 - 2) = v181;
          operator delete(v181);
        }
        BOOL v178 = v180;
      }
      while (v180 != v177);
      double v179 = v209;
    }
    *(void *)&long long v210 = v177;
    operator delete(v179);
  }
  return 1;
}

void sub_19E43898C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31)
{
}

char *sub_19E438A94(char **a1, const void *a2, uint64_t a3)
{
  CFLocaleRef v4 = *a1;
  uint64_t v3 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_19E37C7C4();
  }
  if (0x5555555555555556 * ((a1[2] - v4) >> 3) > v6) {
    unint64_t v6 = 0x5555555555555556 * ((a1[2] - v4) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v4) >> 3) >= 0x555555555555555) {
    unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
      sub_19E37C2B8();
    }
    uint64_t v11 = (char *)operator new(24 * v10);
  }
  else
  {
    uint64_t v11 = 0;
  }
  unint64_t v12 = &v11[24 * v5];
  uint64_t v13 = &v11[24 * v10];
  *((void *)&v25 + 1) = v13;
  *((void *)v12 + 1) = 0;
  *(void *)unint64_t v12 = 0;
  *((void *)v12 + 2) = 0;
  int64_t v14 = a3 - (void)a2;
  if (v14)
  {
    if (v14 < 0) {
      sub_19E37C7C4();
    }
    CFStringRef v15 = operator new(v14);
    *(void *)unint64_t v12 = v15;
    unint64_t v16 = (unint64_t)v15 + 4 * (v14 >> 2);
    memcpy(v15, a2, v14);
    *(int64x2_t *)(v12 + 8) = vdupq_n_s64(v16);
  }
  uint64_t v17 = v12 + 24;
  *(void *)&long long v25 = v12 + 24;
  if (v3 == v4)
  {
    *a1 = v12;
    a1[1] = v17;
    a1[2] = v13;
  }
  else
  {
    do
    {
      uint64_t v18 = v12;
      *((void *)v12 - 2) = 0;
      *((void *)v12 - 1) = 0;
      long long v19 = *(_OWORD *)(v3 - 24);
      v3 -= 24;
      *(_OWORD *)(v12 - 24) = v19;
      v12 -= 24;
      *((void *)v18 - 1) = *((void *)v3 + 2);
      *(void *)uint64_t v3 = 0;
      *((void *)v3 + 1) = 0;
      *((void *)v3 + 2) = 0;
    }
    while (v3 != v4);
    uint64_t v3 = *a1;
    int64_t v20 = a1[1];
    *a1 = v12;
    *(_OWORD *)(a1 + 1) = v25;
    uint64_t v17 = (char *)v25;
    if (v20 != v3)
    {
      uint64_t v21 = v20;
      do
      {
        unint64_t v23 = (void *)*((void *)v21 - 3);
        v21 -= 24;
        int64_t v22 = v23;
        if (v23)
        {
          *((void *)v20 - 2) = v22;
          operator delete(v22);
        }
        int64_t v20 = v21;
      }
      while (v21 != v3);
    }
  }
  if (v3) {
    operator delete(v3);
  }
  return v17;
}

void sub_19E438C64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  unint64_t v5 = *v2;
  if (*v2)
  {
    *uint64_t v3 = v5;
    operator delete(v5);
  }
  sub_19E3D2F94((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E438C88(void *a1)
{
  *a1 = &unk_1EF0BA5F8;
  CFStringRef v2 = (std::__shared_weak_count *)a1[27];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_19E438D34(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E438D34(void *a1)
{
  *a1 = &unk_1EF0BA388;
  CFStringRef v2 = (void *)a1[23];
  if (v2)
  {
    a1[24] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[19];
  if (v3)
  {
    a1[20] = v3;
    operator delete(v3);
  }
  CFLocaleRef v4 = (void *)a1[16];
  if (v4)
  {
    a1[17] = v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)a1[13];
  if (v5)
  {
    a1[14] = v5;
    operator delete(v5);
  }
  unint64_t v6 = (std::__shared_weak_count *)a1[10];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    CFStringRef v7 = (std::__shared_weak_count *)a1[8];
    if (!v7) {
      goto LABEL_15;
    }
  }
  else
  {
    CFStringRef v7 = (std::__shared_weak_count *)a1[8];
    if (!v7) {
      goto LABEL_15;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_15:
  CFNumberRef v8 = (std::__shared_weak_count *)a1[6];
  if (!v8 || atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v9 = (void *)a1[2];
    if (!v9) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  uint64_t v9 = (void *)a1[2];
  if (v9)
  {
LABEL_18:
    a1[3] = v9;
    operator delete(v9);
  }
LABEL_19:
  uint64_t v10 = a1[1];
  a1[1] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  return a1;
}

void *sub_19E438EE4(void *a1)
{
  *a1 = &unk_1EF0BA5F8;
  CFStringRef v2 = (std::__shared_weak_count *)a1[27];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return sub_19E438D34(a1);
}

uint64_t sub_19E438F7C(UTF32Char theChar)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009388, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC009388))
  {
    qword_1EC009398 = CEMCreateEmojiCharacterSet();
    __cxa_guard_release(&qword_1EC009388);
  }
  uint64_t result = qword_1EC009398;
  if (qword_1EC009398) {
    return CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)qword_1EC009398, theChar) != 0;
  }
  return result;
}

void sub_19E438FF0(_Unwind_Exception *a1)
{
}

uint64_t sub_19E439008(const __CFString *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, int a6)
{
  CFStringRef v31 = a1;
  uint64_t v34 = a2;
  uint64_t v35 = a3;
  if (CFStringGetCharactersPtr(a1)) {
    CStringPtr = 0;
  }
  else {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v33 = CStringPtr;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  int __s2 = 0;
  unsigned int v12 = sub_19E4392F0(buffer, 0);
  unsigned int v13 = v12;
  if (a6 != 134217984)
  {
    int64_t v15 = 0;
    if (a5 >= 1)
    {
      unint64_t v16 = 0;
      if (a3 >= 1)
      {
        unint64_t v16 = 0;
        int64_t v15 = 0;
        do
        {
          if (!v16) {
            unint64_t v16 = a4;
          }
          if (HIWORD(v13)) {
            uint64_t v17 = 2;
          }
          else {
            uint64_t v17 = 1;
          }
          v15 += v17;
          unsigned int v13 = sub_19E4392F0(buffer, v15);
        }
        while (v15 < a3);
      }
      goto LABEL_48;
    }
LABEL_47:
    unint64_t v16 = 0;
    goto LABEL_48;
  }
  if (v12 > 0x7F)
  {
    if (v12 > 0x7FF)
    {
      if (HIWORD(v12))
      {
        unsigned int v19 = (v12 >> 18) | 0xFFFFFFF0;
        BYTE1(__s2) = (v12 >> 12) & 0x3F | 0x80;
        uint64_t v20 = 2;
      }
      else
      {
        unsigned int v19 = (v12 >> 12) | 0xFFFFFFE0;
        uint64_t v20 = 1;
      }
      LOBYTE(__s2) = v19;
      uint64_t v18 = v20 + 1;
      *(unsigned char *)((unint64_t)&__s2 | v20) = (v12 >> 6) & 0x3F | 0x80;
    }
    else
    {
      LOBYTE(__s2) = (v12 >> 6) | 0xC0;
      uint64_t v18 = 1;
    }
    size_t v14 = v18 + 1;
    *((unsigned char *)&buffer[-2] + v18) = v12 & 0x3F | 0x80;
  }
  else
  {
    LOBYTE(__s2) = v12;
    size_t v14 = 1;
  }
  int64_t v15 = 0;
  if (a5 < 1) {
    goto LABEL_47;
  }
  unint64_t v16 = 0;
  if (a3 > 0)
  {
    unint64_t v16 = 0;
    int64_t v15 = 0;
    unint64_t v21 = (unint64_t)&a4[a5];
    int64_t v22 = a4;
    do
    {
      if (!memcmp(v22, &__s2, v14))
      {
        if (!v16) {
          unint64_t v16 = v22;
        }
        v22 += v14;
        if (HIWORD(v13)) {
          uint64_t v23 = 2;
        }
        else {
          uint64_t v23 = 1;
        }
        v15 += v23;
        unsigned int v24 = sub_19E4392F0(buffer, v15);
        unsigned int v13 = v24;
        if (v24 >= 0x80)
        {
          if (v24 >= 0x800)
          {
            if (v24 >= 0x10000)
            {
              unsigned int v26 = (v24 >> 18) | 0xFFFFFFF0;
              BYTE1(__s2) = (v24 >> 12) & 0x3F | 0x80;
              uint64_t v27 = 2;
            }
            else
            {
              unsigned int v26 = (v24 >> 12) | 0xFFFFFFE0;
              uint64_t v27 = 1;
            }
            LOBYTE(__s2) = v26;
            uint64_t v25 = v27 + 1;
            *(unsigned char *)((unint64_t)&__s2 | v27) = (v24 >> 6) & 0x3F | 0x80;
          }
          else
          {
            LOBYTE(__s2) = (v24 >> 6) | 0xC0;
            uint64_t v25 = 1;
          }
          size_t v14 = v25 + 1;
          *((unsigned char *)&buffer[-2] + v25) = v24 & 0x3F | 0x80;
          if ((unint64_t)v22 >= v21) {
            break;
          }
        }
        else
        {
          LOBYTE(__s2) = v24;
          size_t v14 = 1;
          if ((unint64_t)v22 >= v21) {
            break;
          }
        }
      }
      else
      {
        unint64_t v16 = 0;
        if ((unint64_t)++v22 >= v21) {
          break;
        }
      }
    }
    while (v15 < a3);
  }
LABEL_48:
  if (v15 == a3) {
    return v16 - a4;
  }
  else {
    return -1;
  }
}

uint64_t sub_19E4392F0(UniChar *buffer, int64_t a2)
{
  if (a2 < 0) {
    return 0;
  }
  int64_t v4 = *((void *)buffer + 20);
  if (v4 <= a2) {
    return 0;
  }
  uint64_t v5 = *((void *)buffer + 17);
  if (v5)
  {
    UniChar v6 = *(_WORD *)(v5 + 2 * (*((void *)buffer + 19) + a2));
  }
  else
  {
    uint64_t v8 = *((void *)buffer + 18);
    if (v8)
    {
      UniChar v6 = *(char *)(v8 + *((void *)buffer + 19) + a2);
    }
    else
    {
      if (*((void *)buffer + 22) <= a2 || (int64_t v9 = *((void *)buffer + 21), v9 > a2))
      {
        int64_t v10 = a2 - 4;
        if ((unint64_t)a2 < 4) {
          int64_t v10 = 0;
        }
        if (v10 + 64 < v4) {
          int64_t v4 = v10 + 64;
        }
        *((void *)buffer + 21) = v10;
        *((void *)buffer + 22) = v4;
        v18.CFIndex location = *((void *)buffer + 19) + v10;
        v18.length = v4 - v10;
        CFStringGetCharacters(*((CFStringRef *)buffer + 16), v18, buffer);
        int64_t v9 = *((void *)buffer + 21);
      }
      UniChar v6 = buffer[a2 - v9];
    }
  }
  if (v6 >> 10 != 54) {
    return v6;
  }
  int64_t v11 = a2 + 1;
  int64_t v12 = *((void *)buffer + 20);
  if (v12 <= a2 + 1) {
    return v6;
  }
  uint64_t v13 = *((void *)buffer + 17);
  if (v13)
  {
    UniChar v14 = *(_WORD *)(v13 + 2 * (*((void *)buffer + 19) + v11));
  }
  else
  {
    uint64_t v15 = *((void *)buffer + 18);
    if (v15)
    {
      UniChar v14 = *(char *)(v15 + *((void *)buffer + 19) + v11);
    }
    else
    {
      if (*((void *)buffer + 22) <= v11 || (int64_t v16 = *((void *)buffer + 21), v16 > v11))
      {
        int64_t v17 = a2 - 3;
        if ((unint64_t)a2 < 3) {
          int64_t v17 = 0;
        }
        if (v17 + 64 < v12) {
          int64_t v12 = v17 + 64;
        }
        *((void *)buffer + 21) = v17;
        *((void *)buffer + 22) = v12;
        v19.CFIndex location = *((void *)buffer + 19) + v17;
        v19.length = v12 - v17;
        CFStringGetCharacters(*((CFStringRef *)buffer + 16), v19, buffer);
        int64_t v16 = *((void *)buffer + 21);
      }
      UniChar v14 = buffer[v11 - v16];
    }
  }
  if (v14 >> 10 != 55) {
    return v6;
  }
  return (v6 << 10) + v14 - 56613888;
}

uint64_t sub_19E439480(const char *a1, __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  if ((a2 & 0x200) != 0) {
    uint64_t v9 = a9;
  }
  else {
    uint64_t v9 = 0;
  }
  return open_dprotected_np(a1, a2, 3, 0, v9);
}

void sub_19E4394BC(void *a1, const char *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  CFStringRef v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v3, 0, v4);
  CFStringTransform(MutableCopy, 0, (CFStringRef)*MEMORY[0x1E4F1D4F0], 0);
  sub_19E37774C(MutableCopy, a1);
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v4) {
    CFRelease(v4);
  }
}

void sub_19E43957C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3DCC24((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E4395A0(int a1, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  operator new[]();
}

void sub_19E43961C(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  MEMORY[0x19F3BDCC0](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E439644(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)*result;
  if (*((char *)result + 23) >= 0) {
    uint64_t v2 = result;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = *a2 + 1;
  *a2 = v4;
  int v5 = *((char *)v2 + v3);
  if ((v5 & 0x80000000) == 0) {
    return result;
  }
  uint64_t v6 = *((unsigned __int8 *)result + 23);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = result[1];
  }
  if (v4 == v6) {
    return result;
  }
  if (v5 < 0xE0u)
  {
    if (v5 < 0xC2u) {
      return result;
    }
    goto LABEL_19;
  }
  if (v5 > 0xEFu)
  {
    if (v5 > 0xF4u) {
      return result;
    }
    uint64_t v11 = v7 >= 0 ? (uint64_t)result : *result;
    if (((byte_19E57CD41[(unint64_t)*(unsigned __int8 *)(v11 + v4) >> 4] >> (v5 + 16)) & 1) == 0) {
      return result;
    }
    uint64_t v4 = v3 + 2;
    *a2 = v3 + 2;
    if (*((char *)result + 23) < 0)
    {
      if (v4 == result[1]) {
        return result;
      }
      int64_t v12 = (uint64_t *)*result;
    }
    else
    {
      int64_t v12 = result;
      if (v4 == *((unsigned __int8 *)result + 23)) {
        return result;
      }
    }
    if (*((char *)v12 + v4) > -65) {
      return result;
    }
  }
  else
  {
    if (v7 >= 0) {
      uint64_t v8 = result;
    }
    else {
      uint64_t v8 = (uint64_t *)*result;
    }
    if (((a00000000000000[v5 & 0xF] >> (*((unsigned char *)v8 + v4) >> 5)) & 1) == 0) {
      return result;
    }
  }
  *a2 = ++v4;
  uint64_t v9 = *((unsigned __int8 *)result + 23);
  int v7 = (char)v9;
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = result[1];
  }
  if (v4 != v9)
  {
LABEL_19:
    if (v7 >= 0) {
      int64_t v10 = result;
    }
    else {
      int64_t v10 = (uint64_t *)*result;
    }
    if (*((char *)v10 + v4) <= -65) {
      *a2 = v4 + 1;
    }
  }
  return result;
}

uint64_t sub_19E439798@<X0>(char *__format@<X0>, uint64_t a2@<X8>, ...)
{
  va_start(va, a2);
  int v4 = vsnprintf(0, 0, __format, va);
  if (v4 <= -2) {
    sub_19E37C958();
  }
  size_t v5 = v4 + 1;
  if (v5 >= 0x17)
  {
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v7 = v5 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    *(void *)(a2 + 8) = v5;
    *(void *)(a2 + 16) = v8 | 0x8000000000000000;
    *(void *)a2 = v6;
    goto LABEL_8;
  }
  *(unsigned char *)(a2 + 23) = v5;
  uint64_t v6 = (void *)a2;
  if (v4 != -1) {
LABEL_8:
  }
    bzero(v6, v5);
  *((unsigned char *)v6 + v5) = 0;
  int v9 = *(char *)(a2 + 23);
  if (v9 >= 0) {
    int64_t v10 = (char *)a2;
  }
  else {
    int64_t v10 = *(char **)a2;
  }
  if (v9 >= 0) {
    size_t v11 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v11 = *(void *)(a2 + 8);
  }
  return vsnprintf(v10, v11, __format, va);
}

void sub_19E439884(uint64_t *a1, os_log_t oslog)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a1 + 23) >= 0) {
      int v4 = a1;
    }
    else {
      int v4 = (uint64_t *)*a1;
    }
    int v5 = 136315394;
    uint64_t v6 = "logToErrorAndDebug";
    __int16 v7 = 2080;
    uint64_t v8 = v4;
    _os_log_error_impl(&dword_19E36B000, oslog, OS_LOG_TYPE_ERROR, "%s: %s", (uint8_t *)&v5, 0x16u);
  }
}

CFErrorRef sub_19E439948(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v3 = (const char *)a1;
  }
  else {
    uint64_t v3 = *(const char **)a1;
  }
  CFStringRef v4 = CFStringCreateWithCString(0, v3, 0x8000100u);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F1D170], v4);
  CFErrorRef v5 = CFErrorCreate(0, @"com.apple.LanguageModeling", 0, Mutable);
  if (v4) {
    CFRelease(v4);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v5;
}

void sub_19E439A1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E410F30((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E439A40()
{
  CFURLRef v0 = (const __CFURL *)CFCopyHomeDirectoryURLForUser();
  qword_1EC009550 = (uint64_t)CFURLCreateCopyAppendingPathComponent(0, v0, @"Library/LanguageModeling", 1u);
  CFRelease(v0);
}

uint64_t sub_19E439A9C()
{
  v4[19] = *MEMORY[0x1E4F143B8];
  sub_19E439BDC(v2);
  std::istream::tellg();
  v2[0] = *MEMORY[0x1E4FBA3F8];
  *(uint64_t *)((char *)v2 + *(void *)(v2[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
  MEMORY[0x19F3BD8C0](&v3);
  std::istream::~istream();
  MEMORY[0x19F3BDC30](v4);
  return v1;
}

void sub_19E439BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

uint64_t *sub_19E439BDC(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA460] + 64;
  a1[53] = MEMORY[0x1E4FBA460] + 64;
  uint64_t v3 = a1 + 2;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA3F8] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA3F8] + 8);
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = v4;
  a1[1] = 0;
  uint64_t v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 2);
  uint64_t v7 = MEMORY[0x1E4FBA460] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  a1[53] = v2;
  MEMORY[0x19F3BD8B0](v3);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_19E439D74(_Unwind_Exception *a1)
{
  std::istream::~istream();
  MEMORY[0x19F3BDC30](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E439DAC(uint64_t a1, void **a2, unsigned __int8 *a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  int64_t v62 = a2;
  uint64_t v5 = MEMORY[0x1E4FBA488] + 104;
  v74[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v6 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v69 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v7 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  v68[0] = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)((char *)v68 + *(void *)(v68[0] - 24)) = v8;
  v68[1] = 0;
  uint64_t v9 = (std::ios_base *)((char *)v68 + *(void *)(v68[0] - 24));
  std::ios_base::init(v9, v70);
  uint64_t v10 = MEMORY[0x1E4FBA488] + 24;
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  uint64_t v11 = v7[5];
  uint64_t v69 = v7[4];
  *(void *)((char *)&v70[-1] + *(void *)(v69 - 24)) = v11;
  v68[0] = v7[1];
  *(void *)((char *)v68 + *(void *)(v68[0] - 24)) = v7[6];
  v74[0] = v5;
  v68[0] = v10;
  uint64_t v69 = v6;
  std::streambuf::basic_streambuf();
  uint64_t v12 = MEMORY[0x1E4FBA470] + 16;
  v70[0] = MEMORY[0x1E4FBA470] + 16;
  long long v71 = 0u;
  long long v72 = 0u;
  int v73 = 24;
  if (&v71 != (long long *)v62)
  {
    if (*((char *)v62 + 23) < 0)
    {
      sub_19E3C6C7C(&v71, *v62, (size_t)v62[1]);
    }
    else
    {
      long long v71 = *(_OWORD *)v62;
      *(void *)&long long v72 = v62[2];
    }
  }
  sub_19E43A714((uint64_t)v70);
  int64_t v62 = (void **)v70;
  unint64_t __p = 0;
  unint64_t v66 = 0;
  uint64_t v67 = 0;
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v68 + *(void *)(v68[0] - 24)));
    UniChar v14 = std::locale::use_facet(__dst, MEMORY[0x1E4FBA258]);
    unsigned __int8 v15 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
    std::locale::~locale(__dst);
    int64_t v16 = sub_19E3AAC74(v68, (uint64_t)&__p, v15);
    if ((*((unsigned char *)v16 + *(void *)(*v16 - 24) + 32) & 5) != 0) {
      break;
    }
    unint64_t v17 = 0;
    unint64_t v18 = HIBYTE(v67);
    unsigned int v19 = SHIBYTE(v67) >> 31;
    unint64_t v21 = (char *)__p;
    unint64_t v20 = v66;
    if (v67 >= 0) {
      unint64_t v22 = HIBYTE(v67);
    }
    else {
      unint64_t v22 = v66;
    }
    int v23 = (char)a3[23];
    uint64_t v24 = a3[23];
    uint64_t v25 = *((void *)a3 + 1);
    if (v23 >= 0) {
      uint64_t v26 = a3[23];
    }
    else {
      uint64_t v26 = *((void *)a3 + 1);
    }
    if (v22 && v26)
    {
      unint64_t v17 = 0;
      uint64_t v27 = *(unsigned __int8 **)a3;
      if (v23 >= 0) {
        uint64_t v28 = a3;
      }
      else {
        uint64_t v28 = *(unsigned __int8 **)a3;
      }
      if (v67 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      while (1)
      {
        CFIndex v30 = &p_p[v17];
        CFStringRef v31 = &p_p[v22];
LABEL_23:
        uint64_t v32 = v26;
        uint64_t v33 = v28;
        while (*v30 != *v33)
        {
          ++v33;
          if (!--v32)
          {
            if (++v30 == v31) {
              goto LABEL_86;
            }
            goto LABEL_23;
          }
        }
        if (v30 == v31) {
          goto LABEL_86;
        }
        unint64_t v34 = v30 - p_p;
        if (v30 - p_p == -1) {
          goto LABEL_86;
        }
        if (v34 > v17) {
          break;
        }
LABEL_72:
        unint64_t v17 = v34 + 1;
        LOBYTE(v19) = (v18 & 0x80u) != 0;
        if ((v18 & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = v21;
        }
        if ((v18 & 0x80u) == 0) {
          unint64_t v22 = v18;
        }
        else {
          unint64_t v22 = v20;
        }
        if ((v24 & 0x80u) == 0) {
          uint64_t v28 = a3;
        }
        else {
          uint64_t v28 = v27;
        }
        if ((v24 & 0x80u) == 0) {
          uint64_t v26 = v24;
        }
        else {
          uint64_t v26 = v25;
        }
        if (v22 <= v17 || !v26) {
          goto LABEL_86;
        }
      }
      if (v19)
      {
        if (v20 < v17) {
          goto LABEL_106;
        }
      }
      else
      {
        if (v17 > v18) {
LABEL_106:
        }
          sub_19E3C4C28();
        unint64_t v21 = (char *)&__p;
        unint64_t v20 = v18;
      }
      if (v20 - v17 >= v34 - v17) {
        size_t v35 = v34 - v17;
      }
      else {
        size_t v35 = v20 - v17;
      }
      if (v35 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      if (v35 >= 0x17)
      {
        uint64_t v37 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v35 | 7) != 0x17) {
          uint64_t v37 = v35 | 7;
        }
        uint64_t v38 = v37 + 1;
        uint64_t v36 = (std::locale::__imp *)operator new(v37 + 1);
        __dst[1].__locale_ = (std::locale::__imp *)v35;
        unint64_t v64 = v38 | 0x8000000000000000;
        __dst[0].__locale_ = v36;
      }
      else
      {
        HIBYTE(v64) = v35;
        uint64_t v36 = (std::locale::__imp *)__dst;
        if (!v35) {
          goto LABEL_47;
        }
      }
      memmove(v36, &v21[v17], v35);
LABEL_47:
      *((unsigned char *)v36 + v35) = 0;
      unint64_t v40 = *(void **)(a1 + 8);
      unint64_t v39 = *(void *)(a1 + 16);
      if ((unint64_t)v40 >= v39)
      {
        CFIndex v43 = *(void **)a1;
        unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v40 - *(void *)a1) >> 3);
        unint64_t v45 = v44 + 1;
        if (v44 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C7C4();
        }
        unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39 - (void)v43) >> 3);
        if (2 * v46 > v45) {
          unint64_t v45 = 2 * v46;
        }
        if (v46 >= 0x555555555555555) {
          unint64_t v47 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v47 = v45;
        }
        if (v47)
        {
          if (v47 > 0xAAAAAAAAAAAAAAALL) {
            sub_19E37C2B8();
          }
          uint64_t v48 = (char *)operator new(24 * v47);
        }
        else
        {
          uint64_t v48 = 0;
        }
        long long v49 = &v48[24 * v44];
        *(_OWORD *)long long v49 = *(_OWORD *)&__dst[0].__locale_;
        *((void *)v49 + 2) = v64;
        int v50 = &v48[24 * v47];
        __dst[1].__locale_ = 0;
        unint64_t v64 = 0;
        __dst[0].__locale_ = 0;
        uint64_t v42 = v49 + 24;
        if (v40 == v43)
        {
          *(void *)a1 = v49;
          *(void *)(a1 + 8) = v42;
          *(void *)(a1 + 16) = v50;
        }
        else
        {
          do
          {
            long long v51 = *(_OWORD *)(v40 - 3);
            *((void *)v49 - 1) = *(v40 - 1);
            *(_OWORD *)(v49 - 24) = v51;
            v49 -= 24;
            *(v40 - 2) = 0;
            *(v40 - 1) = 0;
            *(v40 - 3) = 0;
            v40 -= 3;
          }
          while (v40 != v43);
          unint64_t v40 = *(void **)a1;
          unint64_t v52 = *(void **)(a1 + 8);
          *(void *)a1 = v49;
          *(void *)(a1 + 8) = v42;
          *(void *)(a1 + 16) = v50;
          while (v52 != v40)
          {
            if (*((char *)v52 - 1) < 0) {
              operator delete((void *)*(v52 - 3));
            }
            v52 -= 3;
          }
        }
        if (v40) {
          operator delete(v40);
        }
      }
      else
      {
        long long v41 = *(_OWORD *)&__dst[0].__locale_;
        v40[2] = v64;
        *(_OWORD *)unint64_t v40 = v41;
        __dst[1].__locale_ = 0;
        unint64_t v64 = 0;
        __dst[0].__locale_ = 0;
        uint64_t v42 = v40 + 3;
      }
      *(void *)(a1 + 8) = v42;
      if (SHIBYTE(v64) < 0) {
        operator delete(__dst[0].__locale_);
      }
      unint64_t v18 = HIBYTE(v67);
      unint64_t v21 = (char *)__p;
      unint64_t v20 = v66;
      uint64_t v24 = a3[23];
      uint64_t v27 = *(unsigned __int8 **)a3;
      uint64_t v25 = *((void *)a3 + 1);
      goto LABEL_72;
    }
LABEL_86:
    if (v19)
    {
      if (v17 < v20)
      {
        unint64_t v18 = v20;
        goto LABEL_91;
      }
    }
    else if (v17 < v18)
    {
      unint64_t v21 = (char *)&__p;
LABEL_91:
      size_t v53 = v18 - v17;
      if (v18 - v17 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      if (v53 >= 0x17)
      {
        uint64_t v55 = (v53 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v53 | 7) != 0x17) {
          uint64_t v55 = v53 | 7;
        }
        uint64_t v56 = v55 + 1;
        int v54 = (std::locale::__imp *)operator new(v55 + 1);
        __dst[1].__locale_ = (std::locale::__imp *)v53;
        unint64_t v64 = v56 | 0x8000000000000000;
        __dst[0].__locale_ = v54;
      }
      else
      {
        HIBYTE(v64) = v18 - v17;
        int v54 = (std::locale::__imp *)__dst;
      }
      memmove(v54, &v21[v17], v53);
      *((unsigned char *)v54 + v53) = 0;
      unint64_t v57 = *(void *)(a1 + 8);
      if (v57 < *(void *)(a1 + 16))
      {
        long long v13 = *(_OWORD *)&__dst[0].__locale_;
        *(void *)(v57 + 16) = v64;
        *(_OWORD *)unint64_t v57 = v13;
        *(void *)(a1 + 8) = v57 + 24;
      }
      else
      {
        size_t v58 = sub_19E3EB1B8((void **)a1, (uint64_t)__dst);
        int v59 = SHIBYTE(v64);
        *(void *)(a1 + 8) = v58;
        if (v59 < 0) {
          operator delete(__dst[0].__locale_);
        }
      }
    }
  }
  if (SHIBYTE(v67) < 0) {
    operator delete(__p);
  }
  v68[0] = *MEMORY[0x1E4FBA408];
  uint64_t v60 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v68 + *(void *)(v68[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v69 = v60;
  v70[0] = v12;
  if (SBYTE7(v72) < 0) {
    operator delete((void *)v71);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x19F3BDC30](v74);
}

void sub_19E43A650(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::locale a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  std::iostream::~basic_iostream();
  MEMORY[0x19F3BDC30](a11);
  sub_19E3EB09C(v41);
  _Unwind_Resume(a1);
}

std::string *sub_19E43A714(uint64_t a1)
{
  *(void *)(a1 + 88) = 0;
  uint64_t result = (std::string *)(a1 + 64);
  unint64_t v3 = *(unsigned __int8 *)(a1 + 87);
  if ((*(char *)(a1 + 87) & 0x80000000) == 0)
  {
    uint64_t v4 = result;
    unint64_t v5 = *(unsigned __int8 *)(a1 + 87);
    int v6 = *(_DWORD *)(a1 + 96);
    if ((v6 & 8) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  uint64_t v4 = *(std::string **)(a1 + 64);
  unint64_t v5 = *(void *)(a1 + 72);
  int v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
LABEL_3:
    *(void *)(a1 + 88) = (char *)v4 + v5;
    *(void *)(a1 + 16) = v4;
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = (char *)v4 + v5;
  }
LABEL_4:
  if ((v6 & 0x10) == 0) {
    return result;
  }
  *(void *)(a1 + 88) = (char *)v4 + v5;
  if ((v3 & 0x80) != 0)
  {
    unint64_t v3 = *(void *)(a1 + 72);
    unint64_t v7 = (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v3 >= v7)
    {
      uint64_t result = *(std::string **)(a1 + 64);
      *(void *)(a1 + 72) = v7;
LABEL_14:
      result->__r_.__value_.__s.__data_[v7] = 0;
      LODWORD(v8) = *(char *)(a1 + 87);
      if ((v8 & 0x80000000) != 0) {
        goto LABEL_15;
      }
LABEL_12:
      uint64_t v8 = v8;
      goto LABEL_16;
    }
  }
  else
  {
    unint64_t v7 = 22;
    if (v3 > 0x15)
    {
      *(unsigned char *)(a1 + 87) = 22;
      goto LABEL_14;
    }
  }
  uint64_t result = std::string::append(result, v7 - v3, 0);
  LODWORD(v8) = *(char *)(a1 + 87);
  if ((v8 & 0x80000000) == 0) {
    goto LABEL_12;
  }
LABEL_15:
  uint64_t v8 = *(void *)(a1 + 72);
LABEL_16:
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = v4;
  *(void *)(a1 + 56) = (char *)v4 + v8;
  if ((*(unsigned char *)(a1 + 96) & 3) != 0)
  {
    if (v5 >> 31)
    {
      uint64_t v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
      unint64_t v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
      uint64_t v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
      unint64_t v5 = v5 - v10 - 0x7FFFFFFF;
      *(void *)(a1 + 48) = v4;
    }
    if (v5) {
      *(void *)(a1 + 48) = (char *)v4 + v5;
    }
  }
  return result;
}

uint64_t sub_19E43A85C(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 != a3) {
    operator new();
  }
  return 0;
}

void sub_19E43B484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void **a28,__int16 a29,char a30,char a31)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  language_modeling::v1::CompletionStem::~CompletionStem(&a28);
  sub_19E43BDB0((uint64_t)&a29);
  sub_19E3D34D0(a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E43B550(void *a1, uint64_t a2)
{
  uint64_t v2 = (unsigned char *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v5 = v4;
  }
  unint64_t v6 = sub_19E37BDA4((uint64_t)&v25, (uint64_t *)a2, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (v7)
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *(void *)&v7) {
        unint64_t v10 = v6 % *(void *)&v7;
      }
    }
    else
    {
      unint64_t v10 = (*(void *)&v7 - 1) & v6;
    }
    uint64_t v11 = *(uint64_t ***)(*a1 + 8 * v10);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (*v11)
      {
        char v13 = v2[23];
        if (v13 >= 0) {
          uint64_t v14 = v2[23];
        }
        else {
          uint64_t v14 = *((void *)v2 + 1);
        }
        if (v13 < 0) {
          uint64_t v2 = *(unsigned char **)v2;
        }
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v15 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v21 = v12[1];
            if (v21 == v8)
            {
              uint64_t v22 = *((unsigned __int8 *)v12 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v23 = v12[3];
              }
              if (v23 == v14)
              {
                if ((v22 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v2, v12[3])) {
                    return v12;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    return v12;
                  }
                  uint64_t v24 = 0;
                  while (*((unsigned __int8 *)v12 + v24 + 16) == v2[v24])
                  {
                    if (v22 == ++v24) {
                      return v12;
                    }
                  }
                }
              }
            }
            else if ((v21 & v15) != v10)
            {
              return 0;
            }
            uint64_t result = 0;
            uint64_t v12 = (uint64_t *)*v12;
            if (!v12) {
              return result;
            }
          }
        }
        while (1)
        {
          unint64_t v17 = v12[1];
          if (v17 == v8)
          {
            uint64_t v18 = *((unsigned __int8 *)v12 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v19 = v12[3];
            }
            if (v19 == v14)
            {
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v2, v12[3])) {
                  return v12;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  return v12;
                }
                uint64_t v20 = 0;
                while (*((unsigned __int8 *)v12 + v20 + 16) == v2[v20])
                {
                  if (v18 == ++v20) {
                    return v12;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= *(void *)&v7) {
              v17 %= *(void *)&v7;
            }
            if (v17 != v10) {
              return 0;
            }
          }
          uint64_t result = 0;
          uint64_t v12 = (uint64_t *)*v12;
          if (!v12) {
            return result;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t *sub_19E43B750(void *a1, uint64_t a2, long long **a3)
{
  unint64_t v4 = (unsigned char *)a2;
  unint64_t v6 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v7 = v6;
  }
  unint64_t v8 = sub_19E37BDA4((uint64_t)v30, (uint64_t *)a2, v7);
  unint64_t v9 = v8;
  int8x8_t v10 = (int8x8_t)a1[1];
  if (!*(void *)&v10) {
    goto LABEL_51;
  }
  uint8x8_t v11 = (uint8x8_t)vcnt_s8(v10);
  v11.i16[0] = vaddlv_u8(v11);
  if (v11.u32[0] > 1uLL)
  {
    unint64_t v12 = v8;
    if (v8 >= *(void *)&v10) {
      unint64_t v12 = v8 % *(void *)&v10;
    }
  }
  else
  {
    unint64_t v12 = (*(void *)&v10 - 1) & v8;
  }
  char v13 = *(uint64_t ***)(*a1 + 8 * v12);
  if (!v13 || (uint64_t v14 = *v13) == 0)
  {
LABEL_51:
    char v25 = operator new(0x30uLL);
    v30[0] = v25;
    v30[1] = a1 + 2;
    char v31 = 0;
    *char v25 = 0;
    v25[1] = v9;
    uint64_t v26 = v25 + 2;
    uint64_t v27 = *a3;
    if (*((char *)*a3 + 23) < 0)
    {
      sub_19E39369C(v26, *(void **)v27, *((void *)v27 + 1));
    }
    else
    {
      long long v28 = *v27;
      v26[2] = *((void *)v27 + 2);
      *(_OWORD *)uint64_t v26 = v28;
    }
    operator new();
  }
  char v15 = v4[23];
  if (v15 >= 0) {
    uint64_t v16 = v4[23];
  }
  else {
    uint64_t v16 = *((void *)v4 + 1);
  }
  if (v15 < 0) {
    unint64_t v4 = *(unsigned char **)v4;
  }
  if (v11.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v21 = v14[1];
      if (v21 == v9)
      {
        uint64_t v22 = *((unsigned __int8 *)v14 + 39);
        if ((v22 & 0x80u) == 0) {
          uint64_t v23 = *((unsigned __int8 *)v14 + 39);
        }
        else {
          uint64_t v23 = v14[3];
        }
        if (v23 == v16)
        {
          if ((v22 & 0x80) != 0)
          {
            if (!memcmp((const void *)v14[2], v4, v14[3])) {
              return v14;
            }
          }
          else
          {
            if (!*((unsigned char *)v14 + 39)) {
              return v14;
            }
            uint64_t v24 = 0;
            while (*((unsigned __int8 *)v14 + v24 + 16) == v4[v24])
            {
              if (v22 == ++v24) {
                return v14;
              }
            }
          }
        }
      }
      else if ((v21 & (*(void *)&v10 - 1)) != v12)
      {
        goto LABEL_51;
      }
      uint64_t v14 = (uint64_t *)*v14;
      if (!v14) {
        goto LABEL_51;
      }
    }
  }
  while (1)
  {
    unint64_t v17 = v14[1];
    if (v17 == v9) {
      break;
    }
    if (v17 >= *(void *)&v10) {
      v17 %= *(void *)&v10;
    }
    if (v17 != v12) {
      goto LABEL_51;
    }
LABEL_20:
    uint64_t v14 = (uint64_t *)*v14;
    if (!v14) {
      goto LABEL_51;
    }
  }
  uint64_t v18 = *((unsigned __int8 *)v14 + 39);
  if ((v18 & 0x80u) == 0) {
    uint64_t v19 = *((unsigned __int8 *)v14 + 39);
  }
  else {
    uint64_t v19 = v14[3];
  }
  if (v19 != v16) {
    goto LABEL_20;
  }
  if ((v18 & 0x80) == 0)
  {
    if (!*((unsigned char *)v14 + 39)) {
      return v14;
    }
    uint64_t v20 = 0;
    while (*((unsigned __int8 *)v14 + v20 + 16) == v4[v20])
    {
      if (v18 == ++v20) {
        return v14;
      }
    }
    goto LABEL_20;
  }
  if (memcmp((const void *)v14[2], v4, v14[3])) {
    goto LABEL_20;
  }
  return v14;
}

void sub_19E43BB98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E43BE40((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E43BBB8(void *a1)
{
  unint64_t v1 = ((uint64_t)(a1[1] - *a1) >> 3) + 1;
  if (!(v1 >> 61))
  {
    uint64_t v2 = a1[2] - *a1;
    if (v2 >> 2 > v1) {
      unint64_t v1 = v2 >> 2;
    }
    if ((unint64_t)v2 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v3 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v3 = v1;
    }
    if (v3)
    {
      if (v3 >> 61) {
        sub_19E37C2B8();
      }
      operator new(8 * v3);
    }
    operator new();
  }
  sub_19E37C7C4();
}

void sub_19E43BD88(void *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x1030C403C62F202);
  sub_19E37B770(a1);
}

uint64_t sub_19E43BDB0(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v5 = *(char **)v2;
      unint64_t v6 = (void **)*((void *)v2 + 5);
      *((void *)v2 + 5) = 0;
      if (v6)
      {
        unint64_t v7 = sub_19E3C3D24(v6);
        MEMORY[0x19F3BDCF0](v7, 0x1030C403C62F202);
      }
      if (v2[39] < 0) {
        operator delete(*((void **)v2 + 2));
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  unint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

uint64_t *sub_19E43BE40(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      unint64_t v3 = *(void ***)(v2 + 40);
      *(void *)(v2 + 40) = 0;
      if (v3)
      {
        unint64_t v4 = sub_19E3C3D24(v3);
        MEMORY[0x19F3BDCF0](v4, 0x1030C403C62F202);
      }
      if (*(char *)(v2 + 39) < 0) {
        operator delete(*(void **)(v2 + 16));
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

const void **sub_19E43BEB4(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

double sub_19E43BEE8(uint64_t a1)
{
  CFDateRef v1 = CFDateCreate(0, -(*MEMORY[0x1E4F1CF78] + (double)a1 * -0.000001));
  if (!v1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFDateRef v2 = v1;
  double v3 = MEMORY[0x19F3BCC60]();
  CFRelease(v2);
  return v3;
}

void sub_19E43BF90(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E43BFA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E43BEB4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_19E43BFBC(void *__dst, uint64_t a2)
{
  CFDateRef v2 = __dst;
  int v3 = *(_DWORD *)(a2 + 120);
  if ((v3 & 0x10) != 0)
  {
    unint64_t v5 = *(void *)(a2 + 112);
    unint64_t v6 = *(void *)(a2 + 72);
    if (v5 < v6)
    {
      *(void *)(a2 + 112) = v6;
      unint64_t v5 = v6;
    }
    unint64_t v7 = (const void **)(a2 + 64);
  }
  else
  {
    if ((v3 & 8) == 0)
    {
      size_t v4 = 0;
      *((unsigned char *)__dst + 23) = 0;
      goto LABEL_16;
    }
    unint64_t v7 = (const void **)(a2 + 40);
    unint64_t v5 = *(void *)(a2 + 56);
  }
  unint64_t v8 = *v7;
  size_t v4 = v5 - (void)*v7;
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  if (v4 >= 0x17)
  {
    uint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v9 = v4 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint8x8_t v11 = operator new(v9 + 1);
    v2[1] = v4;
    uint64_t v2[2] = v10 | 0x8000000000000000;
    *CFDateRef v2 = v11;
    CFDateRef v2 = v11;
  }
  else
  {
    *((unsigned char *)__dst + 23) = v4;
    if (!v4) {
      goto LABEL_16;
    }
  }
  std::string __dst = memmove(v2, v8, v4);
LABEL_16:
  *((unsigned char *)v2 + v4) = 0;
  return __dst;
}

uint64_t sub_19E43C098(unsigned char *a1, uint64_t a2, long double *a3)
{
  sub_19E37B784((uint64_t)v21);
  uint64_t v6 = v21[0];
  *(void *)((char *)&v21[2] + *(void *)(v21[0] - 24)) = 3;
  *(_DWORD *)((char *)&v21[1] + *(void *)(v6 - 24)) = *(_DWORD *)((unsigned char *)&v21[1] + *(void *)(v6 - 24)) & 0xFFFFFEFB | 4;
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = *(void *)a2;
  }
  if (v7 >= 0) {
    uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v9 = *(void *)(a2 + 8);
  }
  uint64_t v10 = sub_19E37CA70(v21, v8, v9);
  sub_19E37CA70(v10, (uint64_t)": ", 2);
  log10(*a3);
  uint8x8_t v11 = (void *)std::ostream::operator<<();
  sub_19E37CA70(v11, (uint64_t)"+", 1);
  unint64_t v12 = (void *)std::ostream::operator<<();
  sub_19E37CA70(v12, (uint64_t)" ", 1);
  if ((v28 & 0x10) != 0)
  {
    unint64_t v14 = v27;
    if (v27 < v24)
    {
      unint64_t v27 = v24;
      unint64_t v14 = v24;
    }
    char v15 = (const void **)&v23;
  }
  else
  {
    if ((v28 & 8) == 0)
    {
      size_t v13 = 0;
      a1[23] = 0;
      goto LABEL_22;
    }
    char v15 = (const void **)v22;
    unint64_t v14 = v22[2];
  }
  uint64_t v16 = *v15;
  size_t v13 = v14 - (void)*v15;
  if (v13 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  if (v13 >= 0x17)
  {
    uint64_t v17 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v17 = v13 | 7;
    }
    uint64_t v18 = v17 + 1;
    uint64_t v19 = operator new(v17 + 1);
    *((void *)a1 + 1) = v13;
    *((void *)a1 + 2) = v18 | 0x8000000000000000;
    *(void *)a1 = v19;
    a1 = v19;
    goto LABEL_21;
  }
  a1[23] = v13;
  if (v13) {
LABEL_21:
  }
    memmove(a1, v16, v13);
LABEL_22:
  a1[v13] = 0;
  v21[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v21 + *(void *)(v21[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v21[1] = MEMORY[0x1E4FBA470] + 16;
  if (v26 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x19F3BDC30](&v29);
}

void sub_19E43C354(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3919D0((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E43C368(std::string *a1, const std::string::value_type *a2)
{
  std::string::size_type v3 = *((void *)a2 + 1);
  if (a2[23] >= 0)
  {
    std::string::size_type v4 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = *(const std::string::value_type **)a2;
    std::string::size_type v4 = v3;
  }
  std::string::append(a1, a2, v4);
  if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = a1->__r_.__value_.__l.__size_;
    if (size)
    {
      int v7 = (std::string *)a1->__r_.__value_.__r.__words[0];
      if (!*(unsigned char *)(a1->__r_.__value_.__r.__words[0] + size - 1))
      {
        std::string::size_type v6 = size - 1;
        a1->__r_.__value_.__l.__size_ = v6;
        goto LABEL_11;
      }
    }
  }
  else
  {
    uint64_t v5 = HIBYTE(a1->__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&a1->__r_.__value_.__s + 23) && !a1->__r_.__value_.__s.__data_[v5 - 1])
    {
      std::string::size_type v6 = v5 - 1;
      *((unsigned char *)&a1->__r_.__value_.__s + 23) = v5 - 1;
      int v7 = a1;
LABEL_11:
      v7->__r_.__value_.__s.__data_[v6] = 0;
    }
  }
  std::string::push_back(a1, 10);
}

unsigned char *sub_19E43C40C(unsigned char *__dst, uint64_t a2)
{
  CFDateRef v2 = __dst;
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  unint64_t v4 = *(void *)(a2 + 8);
  if ((v3 & 0x80u) == 0) {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (v5 == 4)
  {
    if ((v3 & 0x80u) == 0) {
      uint8x8_t v11 = (_DWORD *)a2;
    }
    else {
      uint8x8_t v11 = *(_DWORD **)a2;
    }
    if (*v11 == 1047736124)
    {
      __dst[23] = 0;
      *std::string __dst = 0;
      int v10 = 2;
      goto LABEL_36;
    }
LABEL_19:
    if ((v3 & 0x80) != 0)
    {
      size_t v13 = *(unsigned char **)a2;
      if (*v13 != 120 || (v13[v4 - 1] == 120 ? (BOOL v14 = v4 > 1) : (BOOL v14 = 0), !v14))
      {
        std::string __dst = sub_19E39369C(__dst, v13, v4);
        int v10 = 0;
        goto LABEL_36;
      }
      std::string __dst = sub_19E39369C(__dst, v13, v4);
    }
    else
    {
      if (*(unsigned char *)a2 != 120 || (*(unsigned char *)(a2 + v3 - 1) == 120 ? (BOOL v12 = v3 > 1) : (BOOL v12 = 0), !v12))
      {
        int v10 = 0;
        *(_OWORD *)std::string __dst = *(_OWORD *)a2;
        *((void *)__dst + 2) = *(void *)(a2 + 16);
        goto LABEL_36;
      }
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      *((void *)__dst + 2) = *(void *)(a2 + 16);
    }
    int v10 = 3;
    goto LABEL_36;
  }
  if (v5 != 3) {
    goto LABEL_19;
  }
  std::string::size_type v6 = (v3 & 0x80u) == 0 ? (unsigned __int16 *)a2 : *(unsigned __int16 **)a2;
  int v7 = *v6;
  int v8 = *((unsigned __int8 *)v6 + 2);
  if (v7 != 29500 || v8 != 62) {
    goto LABEL_19;
  }
  __dst[23] = 0;
  *std::string __dst = 0;
  int v10 = 1;
LABEL_36:
  v2[6] = v10;
  return __dst;
}

void *sub_19E43C554(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t *result = 0;
  result[1] = 0;
  result[2] = 0;
  if (a2 != a3) {
    operator new();
  }
  return result;
}

void sub_19E43C734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  language_modeling::v1::CompletionStem::~CompletionStem((void ***)va);
  sub_19E3D34D0(v6);
  _Unwind_Resume(a1);
}

void sub_19E43C780(uint64_t a1)
{
  sub_19E43C7B8(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E43C7B8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BC260;
  size_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 16);
    if (v3)
    {
      if (munmap(v3, v2))
      {
        char v13 = 5;
        strcpy(v12, "ERROR");
        unint64_t v4 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)v12, 5);
        sub_19E37CA70(v4, (uint64_t)": ", 2);
        uint64_t v5 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"failed to unmap region: ", 24);
        std::string::size_type v6 = __error();
        int v7 = strerror(*v6);
        size_t v8 = strlen(v7);
        sub_19E37CA70(v5, (uint64_t)v7, v8);
        sub_19E43C8CC();
        if (v13 < 0)
        {
          uint64_t v9 = *(void **)v12;
LABEL_8:
          operator delete(v9);
        }
      }
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 8);
      if (v10)
      {
        uint64_t v9 = (void *)(v10 - *(int *)(a1 + 32));
        goto LABEL_8;
      }
    }
  }
  return a1;
}

uint64_t sub_19E43C8CC()
{
  std::ios_base::getloc((const std::ios_base *)(MEMORY[0x1E4FBA240] + *(void *)(*MEMORY[0x1E4FBA240] - 24)));
  CFURLRef v0 = std::locale::use_facet(&v2, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v0->__vftable[2].~facet_0)(v0, 10);
  std::locale::~locale(&v2);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_19E43C978(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void sub_19E43C994(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  std::istream::tellg();
  if (!a2) {
    goto LABEL_10;
  }
  if ((v25 & 0x800000000000000FLL) == 0)
  {
    BOOL v14 = *(char *)(a3 + 23) >= 0 ? (const char *)a3 : *(const char **)a3;
    int v15 = open(v14, 0);
    if (v15 != -1)
    {
      int v16 = sysconf(29);
      uint64_t v17 = mmap(0, v25 % v16 + a4, 1, 1, v15, v25 / v16 * v16);
      if (!close(v15) && v17 != (void *)-1) {
        operator new();
      }
      char v24 = 4;
      strcpy((char *)__p, "INFO");
      uint64_t v18 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 4);
      sub_19E37CA70(v18, (uint64_t)": ", 2);
      uint64_t v19 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Mapping of file failed: ", 24);
      uint64_t v20 = __error();
      uint64_t v21 = strerror(*v20);
      size_t v22 = strlen(v21);
      sub_19E37CA70(v19, (uint64_t)v21, v22);
      sub_19E43C8CC();
      if (v24 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  char v24 = 7;
  strcpy((char *)__p, "WARNING");
  int v7 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 7);
  sub_19E37CA70(v7, (uint64_t)": ", 2);
  sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"File mapping at offset ", 23);
  size_t v8 = (void *)std::ostream::operator<<();
  uint64_t v9 = sub_19E37CA70(v8, (uint64_t)" of file ", 9);
  int v10 = *(char *)(a3 + 23);
  uint64_t v11 = v10 >= 0 ? a3 : *(void *)a3;
  uint64_t v12 = v10 >= 0 ? *(unsigned __int8 *)(a3 + 23) : *(void *)(a3 + 8);
  char v13 = sub_19E37CA70(v9, v11, v12);
  sub_19E37CA70(v13, (uint64_t)" could not be honored, reading instead.", 39);
  sub_19E43C8CC();
  if (v24 < 0)
  {
    operator delete(__p[0]);
    if (!a4) {
LABEL_20:
    }
      operator new();
  }
  else
  {
LABEL_10:
    if (!a4) {
      goto LABEL_20;
    }
  }
  operator new(a4 + 16);
  goto LABEL_20;
}

void sub_19E43CE3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E43CE9C(uint64_t *a1, const __CFString *a2, const __CFDictionary *a3)
{
  sub_19E37774C(a2, a1);
  a1[3] = (uint64_t)CFRetain(a2);
  *((_DWORD *)a1 + 8) = 0;
  *((_WORD *)a1 + 18) = 0;
  a1[5] = 0;
  unint64_t Count = CFDictionaryGetCount(a3);
  unint64_t v7 = Count;
  if (Count)
  {
    if (Count >> 61) {
      sub_19E37C7C4();
    }
    size_t v8 = (CFTypeRef *)operator new(8 * Count);
    bzero(v8, 8 * v7);
    uint64_t v9 = (CFTypeRef *)operator new(8 * v7);
    bzero(v9, 8 * v7);
  }
  else
  {
    size_t v8 = 0;
    uint64_t v9 = 0;
  }
  uint64_t v60 = v8;
  CFDictionaryGetKeysAndValues(a3, v8, v9);
  int v59 = v9;
  if (v7)
  {
    CFStringRef v10 = (const __CFString *)*MEMORY[0x1E4F1CFD0];
    while (1)
    {
      CFTypeID v11 = CFGetTypeID(*v8);
      if (v11 != CFStringGetTypeID())
      {
        exception = __cxa_allocate_exception(0x20uLL);
        sub_19E382340(__p, "unexpected key type in schema");
        sub_19E3F5604(exception, (long long *)__p);
        __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
      }
      sub_19E37774C((const __CFString *)*v8, __p);
      CFStringRef v12 = (const __CFString *)*v9;
      unint64_t v13 = v65;
      unsigned __int8 v14 = v65;
      int v15 = __p[1];
      if ((v65 & 0x80u) == 0) {
        unint64_t v16 = v65;
      }
      else {
        unint64_t v16 = (unint64_t)__p[1];
      }
      if (v16 == 4)
      {
        uint64_t v17 = (void **)__p[0];
        if ((v65 & 0x80u) == 0) {
          uint64_t v17 = __p;
        }
        if (*(_DWORD *)v17 == 1701869908)
        {
          CFTypeID v18 = CFGetTypeID(*v9);
          if (v18 != CFStringGetTypeID())
          {
            size_t v53 = __cxa_allocate_exception(0x20uLL);
            int v54 = __p;
            if ((v65 & 0x80u) != 0) {
              int v54 = (void **)__p[0];
            }
            uint64_t v55 = a1;
            if (*((char *)a1 + 23) < 0) {
              uint64_t v55 = (uint64_t *)*a1;
            }
            sub_19E439798("unexpected value type in schema for attribute %s and key %s", (uint64_t)v62, v54, v55);
            sub_19E3F5604(v53, (long long *)v62);
            __cxa_throw(v53, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
          }
          sub_19E37774C(v12, v62);
          unint64_t v19 = v63;
          int v20 = (char)v63;
          if ((v63 & 0x80u) != 0) {
            unint64_t v19 = (unint64_t)v62[1];
          }
          if (v19 == 6)
          {
            uint64_t v21 = v62[0];
            uint64_t v26 = v62;
            if ((v63 & 0x80u) != 0) {
              uint64_t v26 = (void **)v62[0];
            }
            int v27 = *(_DWORD *)v26;
            int v28 = *((unsigned __int16 *)v26 + 2);
            if (v27 != 1769108563 || v28 != 26478)
            {
LABEL_86:
              uint64_t v48 = __cxa_allocate_exception(0x20uLL);
              long long v49 = a1;
              if (*((char *)a1 + 23) < 0) {
                long long v49 = (uint64_t *)*a1;
              }
              sub_19E439798("unsupported type for key %s (supported types are String and Integer)", (uint64_t)&v61, v49);
              sub_19E3F5604(v48, &v61);
              __cxa_throw(v48, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
            }
          }
          else
          {
            if (v19 != 7) {
              goto LABEL_86;
            }
            uint64_t v21 = v62[0];
            size_t v22 = v62;
            if ((v63 & 0x80u) != 0) {
              size_t v22 = (void **)v62[0];
            }
            int v23 = *(_DWORD *)v22;
            int v24 = *(_DWORD *)((char *)v22 + 3);
            if (v23 != 1702129225 || v24 != 1919248229) {
              goto LABEL_86;
            }
            *((_DWORD *)a1 + 8) = 1;
          }
          if (v20 < 0) {
            operator delete(v21);
          }
          unint64_t v13 = v65;
          int v15 = __p[1];
          unsigned __int8 v14 = v65;
        }
      }
      if ((v14 & 0x80u) == 0) {
        CFIndex v30 = (void *)v13;
      }
      else {
        CFIndex v30 = v15;
      }
      if (v30 == (void *)6)
      {
        char v31 = (v14 & 0x80u) == 0 ? __p : (void **)__p[0];
        int v32 = *(_DWORD *)v31;
        int v33 = *((unsigned __int16 *)v31 + 2);
        if (v32 == 1902734933 && v33 == 25973)
        {
          CFTypeID v35 = CFGetTypeID(v12);
          if (v35 != CFBooleanGetTypeID())
          {
            uint64_t v56 = __cxa_allocate_exception(0x20uLL);
            unint64_t v57 = __p;
            if ((v65 & 0x80u) != 0) {
              unint64_t v57 = (void **)__p[0];
            }
            size_t v58 = a1;
            if (*((char *)a1 + 23) < 0) {
              size_t v58 = (uint64_t *)*a1;
            }
            sub_19E439798("unexpected value type in schema for attribute %s and key %s", (uint64_t)v62, v57, v58);
            sub_19E3F5604(v56, (long long *)v62);
            __cxa_throw(v56, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
          }
          *((unsigned char *)a1 + 36) = v12 == v10;
          unint64_t v13 = v65;
          int v15 = __p[1];
          unsigned __int8 v14 = v65;
        }
      }
      if ((v14 & 0x80u) == 0) {
        uint64_t v36 = (void *)v13;
      }
      else {
        uint64_t v36 = v15;
      }
      if (v36 == (void *)13)
      {
        uint64_t v37 = (v14 & 0x80u) == 0 ? __p : (void **)__p[0];
        uint64_t v38 = *v37;
        uint64_t v39 = *(uint64_t *)((char *)v37 + 5);
        if (v38 == (void *)0x536E656B6F547349 && v39 == 0x676E697274536E65)
        {
          CFTypeID v41 = CFGetTypeID(v12);
          if (v41 != CFBooleanGetTypeID())
          {
            int v50 = __cxa_allocate_exception(0x20uLL);
            long long v51 = __p;
            if ((v65 & 0x80u) != 0) {
              long long v51 = (void **)__p[0];
            }
            unint64_t v52 = a1;
            if (*((char *)a1 + 23) < 0) {
              unint64_t v52 = (uint64_t *)*a1;
            }
            sub_19E439798("unexpected value type in schema for attribute %s and key %s", (uint64_t)v62, v51, v52);
            sub_19E3F5604(v50, (long long *)v62);
            __cxa_throw(v50, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
          }
          *((unsigned char *)a1 + 37) = v12 == v10;
          unint64_t v13 = v65;
          int v15 = __p[1];
          unsigned __int8 v14 = v65;
        }
      }
      if ((v14 & 0x80u) != 0) {
        unint64_t v13 = (unint64_t)v15;
      }
      if (v13 == 12)
      {
        uint64_t v42 = (void **)__p[0];
        if ((v14 & 0x80u) == 0) {
          uint64_t v42 = __p;
        }
        CFIndex v43 = *v42;
        int v44 = *((_DWORD *)v42 + 2);
        if (v43 == (void *)0x56746C7561666544 && v44 == 1702194273)
        {
          a1[5] = (uint64_t)CFRetain(v12);
          unsigned __int8 v14 = v65;
        }
      }
      if ((v14 & 0x80) != 0) {
        operator delete(__p[0]);
      }
      ++v9;
      ++v8;
      if (!--v7) {
        goto LABEL_81;
      }
    }
  }
  if (v9) {
LABEL_81:
  }
    operator delete(v59);
  if (v60) {
    operator delete(v60);
  }
  return a1;
}

void sub_19E43D488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  operator delete(v32);
  if ((*(char *)(v31 + 23) & 0x80000000) == 0) {
    _Unwind_Resume(a1);
  }
  operator delete(*(void **)v31);
  _Unwind_Resume(a1);
}

uint64_t sub_19E43D5EC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 16);
    uint64_t v4 = **(void **)(a1 + 8);
    while (v3 != v4)
    {
      uint64_t v5 = *(const void **)(v3 - 24);
      if (v5) {
        CFRelease(v5);
      }
      std::string::size_type v6 = *(const void **)(v3 - 8);
      if (v6) {
        CFRelease(v6);
      }
      if (*(char *)(v3 - 25) < 0) {
        operator delete(*(void **)(v3 - 48));
      }
      v3 -= 48;
    }
  }
  return a1;
}

uint64_t *sub_19E43D66C(uint64_t *a1, long long **a2)
{
  a1[2] = 0;
  uint64_t v5 = (char *)(a1 + 2);
  *a1 = 0;
  a1[1] = 0;
  std::string::size_type v6 = *a2;
  unint64_t v7 = a2[1];
  int64_t v8 = (char *)v7 - (char *)*a2;
  if (v7 != *a2)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    if (v9 >= 0x555555555555556) {
      sub_19E37C7C4();
    }
    CFStringRef v10 = (char *)operator new(v8);
    *a1 = (uint64_t)v10;
    a1[1] = (uint64_t)v10;
    a1[2] = (uint64_t)&v10[48 * v9];
    uint64_t v67 = v10;
    uint64_t v68 = v10;
    unsigned __int8 v63 = v5;
    unint64_t v64 = &v67;
    unsigned __int8 v65 = &v68;
    char v66 = 0;
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v12 = v10;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_19E39369C(v12, *(void **)v6, *((void *)v6 + 1));
      }
      else
      {
        long long v13 = *v6;
        *((void *)v12 + 2) = *((void *)v6 + 2);
        *(_OWORD *)CFStringRef v12 = v13;
      }
      *((void *)v12 + 3) = CFStringCreateCopy(v11, *((CFStringRef *)v6 + 3));
      *((_DWORD *)v12 + 8) = *((_DWORD *)v6 + 8);
      *((_WORD *)v12 + 18) = *((_WORD *)v6 + 18);
      *((void *)v12 + 5) = CFRetain(*((CFTypeRef *)v6 + 5));
      v6 += 3;
      CFStringRef v12 = v68 + 48;
      v68 += 48;
    }
    while (v6 != v7);
    a1[1] = (uint64_t)v12;
  }
  *(_OWORD *)(a1 + 3) = 0u;
  unsigned __int8 v14 = a1 + 3;
  *(_OWORD *)(a1 + 5) = 0u;
  *((_DWORD *)a1 + 14) = *((_DWORD *)a2 + 14);
  size_t prime = (size_t)a2[4];
  if (prime != 1)
  {
    if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      int8x8_t v57 = (int8x8_t)a1[4];
      BOOL v58 = prime >= *(void *)&v57;
      if (prime > *(void *)&v57) {
        goto LABEL_11;
      }
    }
    else
    {
      int8x8_t v57 = 0;
      BOOL v58 = 1;
      if (prime) {
        goto LABEL_11;
      }
    }
    if (v58) {
      goto LABEL_12;
    }
    unint64_t v59 = vcvtps_u32_f32((float)(unint64_t)a1[6] / *((float *)a1 + 14));
    if (*(void *)&v57 < 3uLL || (uint8x8_t v60 = (uint8x8_t)vcnt_s8(v57), v60.i16[0] = vaddlv_u8(v60), v60.u32[0] > 1uLL))
    {
      unint64_t v59 = std::__next_prime(v59);
    }
    else
    {
      uint64_t v61 = 1 << -(char)__clz(v59 - 1);
      if (v59 >= 2) {
        unint64_t v59 = v61;
      }
    }
    if (prime <= v59) {
      size_t prime = v59;
    }
    if (prime >= *(void *)&v57) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  size_t prime = 2;
LABEL_11:
  sub_19E3CEFD8((uint64_t)(a1 + 3), prime);
LABEL_12:
  unint64_t v16 = a2[5];
  if (!v16) {
    goto LABEL_109;
  }
  int64_t v62 = a1 + 5;
  while (2)
  {
    int v17 = *((char *)v16 + 39);
    if (v17 >= 0) {
      CFTypeID v18 = (uint64_t *)(v16 + 1);
    }
    else {
      CFTypeID v18 = (uint64_t *)*((void *)v16 + 2);
    }
    if (v17 >= 0) {
      unint64_t v19 = *((unsigned __int8 *)v16 + 39);
    }
    else {
      unint64_t v19 = *((void *)v16 + 3);
    }
    unint64_t v20 = sub_19E37BDA4((uint64_t)&v63, v18, v19);
    unint64_t v21 = v20;
    unint64_t v22 = a1[4];
    if (!v22) {
      goto LABEL_71;
    }
    uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)v22);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      unint64_t v2 = v20;
      if (v20 >= v22) {
        unint64_t v2 = v20 % v22;
      }
    }
    else
    {
      unint64_t v2 = (v22 - 1) & v20;
    }
    int v24 = *(uint64_t ***)(*v14 + 8 * v2);
    if (!v24) {
      goto LABEL_71;
    }
    unint64_t v25 = *v24;
    if (!*v24) {
      goto LABEL_71;
    }
    char v26 = *((unsigned char *)v16 + 39);
    if (v26 >= 0) {
      uint64_t v27 = *((unsigned __int8 *)v16 + 39);
    }
    else {
      uint64_t v27 = *((void *)v16 + 3);
    }
    if (v26 >= 0) {
      int v28 = (unsigned __int8 *)(v16 + 1);
    }
    else {
      int v28 = (unsigned __int8 *)*((void *)v16 + 2);
    }
    if (v23.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v34 = v25[1];
        if (v34 == v21)
        {
          uint64_t v35 = *((unsigned __int8 *)v25 + 39);
          if ((v35 & 0x80u) == 0) {
            uint64_t v36 = *((unsigned __int8 *)v25 + 39);
          }
          else {
            uint64_t v36 = v25[3];
          }
          if (v36 == v27)
          {
            uint64_t v37 = (const void **)(v25 + 2);
            if ((v35 & 0x80) != 0)
            {
              if (!memcmp(*v37, v28, v25[3])) {
                goto LABEL_16;
              }
            }
            else
            {
              if (!*((unsigned char *)v25 + 39)) {
                goto LABEL_16;
              }
              uint64_t v38 = v28;
              while (*(unsigned __int8 *)v37 == *v38)
              {
                uint64_t v37 = (const void **)((char *)v37 + 1);
                ++v38;
                if (!--v35) {
                  goto LABEL_16;
                }
              }
            }
          }
        }
        else if ((v34 & (v22 - 1)) != v2)
        {
          goto LABEL_70;
        }
        unint64_t v25 = (uint64_t *)*v25;
        if (!v25) {
          goto LABEL_70;
        }
      }
    }
    do
    {
      unint64_t v29 = v25[1];
      if (v29 == v21)
      {
        uint64_t v30 = *((unsigned __int8 *)v25 + 39);
        if ((v30 & 0x80u) == 0) {
          uint64_t v31 = *((unsigned __int8 *)v25 + 39);
        }
        else {
          uint64_t v31 = v25[3];
        }
        if (v31 == v27)
        {
          int v32 = (const void **)(v25 + 2);
          if ((v30 & 0x80) != 0)
          {
            if (!memcmp(*v32, v28, v25[3])) {
              goto LABEL_16;
            }
          }
          else
          {
            if (!*((unsigned char *)v25 + 39)) {
              goto LABEL_16;
            }
            int v33 = v28;
            while (*(unsigned __int8 *)v32 == *v33)
            {
              int v32 = (const void **)((char *)v32 + 1);
              ++v33;
              if (!--v30) {
                goto LABEL_16;
              }
            }
          }
        }
        goto LABEL_39;
      }
      if (v29 >= v22) {
        v29 %= v22;
      }
      if (v29 != v2) {
        break;
      }
LABEL_39:
      unint64_t v25 = (uint64_t *)*v25;
    }
    while (v25);
LABEL_70:
    unsigned __int8 v14 = a1 + 3;
LABEL_71:
    uint64_t v39 = (char *)operator new(0x30uLL);
    unsigned __int8 v63 = v39;
    unint64_t v64 = (char **)(a1 + 5);
    LOBYTE(v65) = 0;
    *(void *)uint64_t v39 = 0;
    *((void *)v39 + 1) = v21;
    unint64_t v40 = v39 + 16;
    if (*((char *)v16 + 39) < 0)
    {
      sub_19E39369C(v40, *((void **)v16 + 2), *((void *)v16 + 3));
    }
    else
    {
      long long v41 = v16[1];
      *((void *)v39 + 4) = *((void *)v16 + 4);
      *(_OWORD *)unint64_t v40 = v41;
    }
    *((_DWORD *)v39 + 10) = *((_DWORD *)v16 + 10);
    LOBYTE(v65) = 1;
    float v42 = (float)(unint64_t)(a1[6] + 1);
    float v43 = *((float *)a1 + 14);
    if (!v22 || (float)(v43 * (float)v22) < v42)
    {
      BOOL v44 = (v22 & (v22 - 1)) != 0;
      if (v22 < 3) {
        BOOL v44 = 1;
      }
      unint64_t v45 = v44 | (2 * v22);
      unint64_t v46 = vcvtps_u32_f32(v42 / v43);
      if (v45 <= v46) {
        size_t v47 = v46;
      }
      else {
        size_t v47 = v45;
      }
      if (v47 == 1)
      {
        size_t v47 = 2;
      }
      else if ((v47 & (v47 - 1)) != 0)
      {
        size_t v47 = std::__next_prime(v47);
      }
      int8x8_t v48 = (int8x8_t)a1[4];
      if (v47 > *(void *)&v48) {
        goto LABEL_86;
      }
      if (v47 < *(void *)&v48)
      {
        unint64_t v49 = vcvtps_u32_f32((float)(unint64_t)a1[6] / *((float *)a1 + 14));
        if (*(void *)&v48 < 3uLL || (uint8x8_t v50 = (uint8x8_t)vcnt_s8(v48), v50.i16[0] = vaddlv_u8(v50), v50.u32[0] > 1uLL))
        {
          unint64_t v49 = std::__next_prime(v49);
        }
        else
        {
          uint64_t v51 = 1 << -(char)__clz(v49 - 1);
          if (v49 >= 2) {
            unint64_t v49 = v51;
          }
        }
        if (v47 <= v49) {
          size_t v47 = v49;
        }
        if (v47 < *(void *)&v48) {
LABEL_86:
        }
          sub_19E3CEFD8((uint64_t)v14, v47);
      }
      unint64_t v22 = a1[4];
      if ((v22 & (v22 - 1)) != 0)
      {
        if (v21 >= v22) {
          unint64_t v2 = v21 % v22;
        }
        else {
          unint64_t v2 = v21;
        }
      }
      else
      {
        unint64_t v2 = (v22 - 1) & v21;
      }
    }
    unint64_t v52 = *(void **)(*v14 + 8 * v2);
    if (v52)
    {
      *(void *)unsigned __int8 v63 = *v52;
      void *v52 = v63;
    }
    else
    {
      *(void *)unsigned __int8 v63 = *v62;
      void *v62 = v63;
      *(void *)(*v14 + 8 * v2) = v62;
      if (*(void *)v63)
      {
        unint64_t v53 = *(void *)(*(void *)v63 + 8);
        if ((v22 & (v22 - 1)) != 0)
        {
          if (v53 >= v22) {
            v53 %= v22;
          }
        }
        else
        {
          v53 &= v22 - 1;
        }
        *(void *)(*v14 + 8 * v53) = v63;
      }
    }
    ++a1[6];
LABEL_16:
    unint64_t v16 = *(long long **)v16;
    unsigned __int8 v14 = a1 + 3;
    if (v16) {
      continue;
    }
    break;
  }
LABEL_109:
  uint64_t v54 = *a1;
  uint64_t v55 = a1[1];
  while (v54 != v55)
  {
    if (*(unsigned char *)(v54 + 37)) {
      a1[8] = v54;
    }
    v54 += 48;
  }
  return a1;
}

void sub_19E43DC98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_19E414468(a9);
  CFAllocatorRef v11 = (char *)*v9;
  if (*v9)
  {
    CFStringRef v12 = (char *)v9[1];
    if (v12 == v11)
    {
      int v15 = *v9;
    }
    else
    {
      do
      {
        long long v13 = (const void *)*((void *)v12 - 3);
        if (v13) {
          CFRelease(v13);
        }
        unsigned __int8 v14 = (const void *)*((void *)v12 - 1);
        if (v14) {
          CFRelease(v14);
        }
        if (*(v12 - 25) < 0) {
          operator delete(*((void **)v12 - 6));
        }
        v12 -= 48;
      }
      while (v12 != v11);
      int v15 = *v9;
    }
    v9[1] = v11;
    operator delete(v15);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_19E43DDB0(uint64_t *a1, void *a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = (unsigned __int8 **)*a2;
  if (v2 - *a1 != a2[1] - *a2) {
    return 0;
  }
  for (; v3 != v2; v4 += 6)
  {
    uint64_t v7 = *(unsigned __int8 *)(v3 + 23);
    if ((v7 & 0x80u) == 0) {
      int64_t v8 = (unsigned __int8 *)*(unsigned __int8 *)(v3 + 23);
    }
    else {
      int64_t v8 = *(unsigned __int8 **)(v3 + 8);
    }
    unint64_t v9 = (unsigned __int8 *)*((unsigned __int8 *)v4 + 23);
    int v10 = (char)v9;
    if ((char)v9 < 0) {
      unint64_t v9 = v4[1];
    }
    if (v8 != v9) {
      return 0;
    }
    if (v10 >= 0) {
      CFAllocatorRef v11 = (unsigned __int8 *)v4;
    }
    else {
      CFAllocatorRef v11 = *v4;
    }
    if ((v7 & 0x80) != 0)
    {
      if (memcmp(*(const void **)v3, v11, *(void *)(v3 + 8))) {
        return 0;
      }
    }
    else if (*(unsigned char *)(v3 + 23))
    {
      uint64_t v12 = 0;
      while (*(unsigned __int8 *)(v3 + v12) == v11[v12])
      {
        if (v7 == ++v12) {
          goto LABEL_19;
        }
      }
      return 0;
    }
LABEL_19:
    if (*(_DWORD *)(v3 + 32) != *((_DWORD *)v4 + 8)
      || *(unsigned __int8 *)(v3 + 36) != *((unsigned __int8 *)v4 + 36)
      || *(unsigned __int8 *)(v3 + 37) != *((unsigned __int8 *)v4 + 37))
    {
      return 0;
    }
    uint64_t result = (uint64_t *)CFEqual(*(CFTypeRef *)(v3 + 40), v4[5]);
    if (!result) {
      return result;
    }
    v3 += 48;
  }
  if (a1[6] != a2[6]) {
    return 0;
  }
  unsigned __int8 v14 = a2 + 3;
  int v15 = a1 + 5;
  do
  {
    int v15 = (void *)*v15;
    uint64_t result = (uint64_t *)(v15 == 0);
    if (!v15) {
      break;
    }
    unint64_t v16 = (const void **)(v15 + 2);
    uint64_t result = sub_19E3FC044(v14, (uint64_t)(v15 + 2));
    if (!result) {
      break;
    }
    int v17 = result;
    uint64_t v18 = *((unsigned __int8 *)v15 + 39);
    if ((v18 & 0x80u) == 0) {
      uint64_t v19 = *((unsigned __int8 *)v15 + 39);
    }
    else {
      uint64_t v19 = v15[3];
    }
    uint64_t v20 = *((unsigned __int8 *)result + 39);
    int v21 = (char)v20;
    if ((v20 & 0x80u) != 0) {
      uint64_t v20 = result[3];
    }
    if (v19 != v20) {
      return 0;
    }
    if (v21 >= 0) {
      unint64_t v22 = (unsigned __int8 *)(result + 2);
    }
    else {
      unint64_t v22 = (unsigned __int8 *)result[2];
    }
    if ((v18 & 0x80) != 0)
    {
      BOOL v23 = memcmp(*v16, v22, v15[3]) == 0;
    }
    else
    {
      if (*((unsigned char *)v15 + 39))
      {
        while (*(unsigned __int8 *)v16 == *v22)
        {
          unint64_t v16 = (const void **)((char *)v16 + 1);
          ++v22;
          if (!--v18) {
            goto LABEL_41;
          }
        }
        return 0;
      }
LABEL_41:
      BOOL v23 = 1;
    }
    uint64_t result = 0;
  }
  while (v23 && *((_DWORD *)v15 + 10) == *((_DWORD *)v17 + 10));
  return result;
}

void sub_19E43DFA8()
{
}

void sub_19E43DFD4(uint64_t a1)
{
}

uint64_t sub_19E43DFDC(uint64_t a1)
{
  return sub_19E43DFE4((uint64_t *)(a1 + 16));
}

uint64_t sub_19E43DFE4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v2 = (uint64_t (*)(uint64_t))off_1EC0091E8;
  unint64_t v9 = off_1EC0091E8;
  if (!off_1EC0091E8)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = sub_19E43E0D0;
    v5[3] = &unk_1E599FA40;
    v5[4] = &v6;
    sub_19E43E0D0((uint64_t)v5);
    uint64_t v2 = (uint64_t (*)(uint64_t))v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (!v2)
  {
    dlerror();
    uint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v6, 8);
    _Unwind_Resume(v4);
  }
  return v2(v1);
}

void *sub_19E43E0D0(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0093C8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E43E210;
    v5[4] = &unk_1E599FA18;
    void v5[5] = v5;
    long long v6 = xmmword_1E599FA00;
    uint64_t v7 = 0;
    qword_1EC0093C8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0093C8;
    if (qword_1EC0093C8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0093C8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkModelUnLock");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0091E8 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E43E210()
{
  uint64_t result = _sl_dlopen();
  qword_1EC0093C8 = result;
  return result;
}

void *sub_19E43E284(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0093C8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E43E210;
    v5[4] = &unk_1E599FA18;
    void v5[5] = v5;
    long long v6 = xmmword_1E599FA00;
    uint64_t v7 = 0;
    qword_1EC0093C8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0093C8;
    if (qword_1EC0093C8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0093C8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkModelLock");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0091E0 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_19E43E3C4(uint64_t a1)
{
  uint64_t v7 = 0;
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v12 = 0;
  long long v13 = &v12;
  uint64_t v14 = 0x2000000000;
  uint64_t v2 = (uint64_t (*)(uint64_t, __CFError **))off_1EC0093E8;
  int v15 = off_1EC0093E8;
  if (!off_1EC0093E8)
  {
    unint64_t __p = (void *)MEMORY[0x1E4F143A8];
    *(void *)&long long v9 = 0x40000000;
    *((void *)&v9 + 1) = sub_19E50AE14;
    int v10 = &unk_1E59A1C10;
    CFAllocatorRef v11 = &v12;
    sub_19E50AE14((uint64_t)&__p);
    uint64_t v2 = (uint64_t (*)(uint64_t, __CFError **))v13[3];
  }
  _Block_object_dispose(&v12, 8);
  if (v2)
  {
    uint64_t v3 = (const void *)v2(v1, &v7);
    sub_19E40100C(&cf, v3);
    uint64_t v4 = v7;
    if (v7)
    {
      unint64_t __p = operator new(0x20uLL);
      long long v9 = xmmword_19E573030;
      strcpy((char *)__p, "MRLNeuralNetworkCopyStates");
      sub_19E50A648((uint64_t *)&__p, v4);
      if (SHIBYTE(v9) < 0) {
        operator delete(__p);
      }
    }
    operator new();
  }
  dlerror();
  uint64_t v5 = (_Unwind_Exception *)abort_report_np();
  _Block_object_dispose(&v12, 8);
  _Unwind_Resume(v5);
}

void sub_19E43E5A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  MEMORY[0x19F3BDCF0](v17, 0x10E1C406EE1D4F3);
  sub_19E401594(&a10);
  _Unwind_Resume(a1);
}

void *sub_19E43E5F8(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, const void *a5, uint64_t a6)
{
  __p[5] = *(void **)MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    CFAllocatorRef v11 = *(const void **)v10;
    unint64_t v12 = *(void *)(v10 + 8);
    if (*(void *)v10) {
      CFRetain(v11);
    }
  }
  else
  {
    CFAllocatorRef v11 = 0;
    unint64_t v12 = 0;
  }
  int v13 = *(_DWORD *)(a1 + 8);
  if (v13 != 1)
  {
    if (v13)
    {
      char v26 = 0;
      goto LABEL_131;
    }
    uint64_t v14 = (unsigned int *)operator new(4uLL);
    unsigned int *v14 = a3;
    CFStringRef v15 = (CFStringRef)(a1 + 120);
    uint64_t v16 = *(void *)(a1 + 24);
    uint64_t v17 = *(void *)(a1 + 32);
    long long v71 = v14;
    if (v16 != v17)
    {
      unint64_t v18 = v12;
      char v19 = *(unsigned char *)(a1 + 143);
      if (v19 >= 0) {
        uint64_t v20 = *(unsigned __int8 *)(a1 + 143);
      }
      else {
        uint64_t v20 = *(void *)(a1 + 128);
      }
      if (v19 >= 0) {
        int v21 = (unsigned __int8 *)(a1 + 120);
      }
      else {
        int v21 = *(unsigned __int8 **)(a1 + 120);
      }
      do
      {
        uint64_t v27 = *(unsigned __int8 *)(v16 + 23);
        if ((v27 & 0x80u) == 0) {
          uint64_t v28 = *(unsigned __int8 *)(v16 + 23);
        }
        else {
          uint64_t v28 = *(void *)(v16 + 8);
        }
        if (v28 == v20)
        {
          if ((v27 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)v16, v21, *(void *)(v16 + 8))) {
              goto LABEL_30;
            }
          }
          else
          {
            if (!*(unsigned char *)(v16 + 23)) {
              goto LABEL_30;
            }
            uint64_t v29 = 0;
            while (*(unsigned __int8 *)(v16 + v29) == v21[v29])
            {
              if (v27 == ++v29) {
                goto LABEL_30;
              }
            }
          }
        }
        v16 += 24;
      }
      while (v16 != v17);
      uint64_t v16 = v17;
LABEL_30:
      unint64_t v12 = v18;
    }
    if (v16 == v17)
    {
      if (qword_1EC0095B8 == -1) {
        goto LABEL_140;
      }
    }
    else
    {
      uint64_t v30 = (float *)operator new(4uLL);
      *uint64_t v30 = (float)*v71;
      uint64_t v31 = sub_19E43FF80((uint64_t **)(a1 + 72), (const void **)(a1 + 120), a1 + 120);
      int v32 = v31[7];
      if (v32)
      {
        unsigned char v31[8] = v32;
        operator delete(v32);
        v31[7] = 0;
        unsigned char v31[8] = 0;
        v31[9] = 0;
      }
      v31[7] = (uint64_t *)v30;
      unsigned char v31[8] = (uint64_t *)(v30 + 1);
      v31[9] = (uint64_t *)(v30 + 1);
      int v33 = sub_19E43FF80((uint64_t **)(a1 + 72), (const void **)(a1 + 120), a1 + 120)[7];
      double v76 = 0;
      uint64_t v34 = *(void *)(a1 + 16);
      char v35 = *(unsigned char *)(a1 + 143);
      if (v35 >= 0) {
        uint64_t v36 = (const UInt8 *)(a1 + 120);
      }
      else {
        uint64_t v36 = *(const UInt8 **)(a1 + 120);
      }
      if (v36)
      {
        if (v35 >= 0) {
          CFIndex v37 = *(unsigned __int8 *)(a1 + 143);
        }
        else {
          CFIndex v37 = *(void *)(a1 + 128);
        }
        CFStringRef v15 = CFStringCreateWithBytes(0, v36, v37, 0x8000100u, 0);
        if (!v15)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x19F3BD790](exception, "Could not construct");
          __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
        }
      }
      else
      {
        CFStringRef v15 = 0;
      }
      uint64_t v72 = 0;
      int v73 = &v72;
      uint64_t v74 = 0x2000000000;
      uint64_t v54 = (void (*)(uint64_t, CFStringRef, uint64_t, uint64_t, uint64_t *, __CFError **))off_1EC0093D8;
      unint64_t v75 = off_1EC0093D8;
      if (!off_1EC0093D8)
      {
        __p[0] = (void *)MEMORY[0x1E4F143A8];
        __p[1] = (void *)0x40000000;
        __p[2] = sub_19E440B38;
        __p[3] = &unk_1E599FA90;
        __p[4] = &v72;
        sub_19E440B38((uint64_t)__p);
        uint64_t v54 = (void (*)(uint64_t, CFStringRef, uint64_t, uint64_t, uint64_t *, __CFError **))v73[3];
      }
      _Block_object_dispose(&v72, 8);
      if (v54)
      {
        v54(v34, v15, 1, 1, v33, &v76);
        if (v15) {
          CFRelease(v15);
        }
        uint64_t v55 = v76;
        if (v76
          && (__p[0] = operator new(0x20uLL),
              *(_OWORD *)&__p[1] = xmmword_19E572FA0,
              strcpy((char *)__p[0], "MRLNeuralNetworkSetInput"),
              sub_19E43FBD8((uint64_t *)__p, v55),
              SHIBYTE(__p[2]) < 0))
        {
          operator delete(__p[0]);
          uint64_t v56 = (uint64_t *)(a1 + 16);
          if (a6) {
            goto LABEL_103;
          }
        }
        else
        {
          uint64_t v56 = (uint64_t *)(a1 + 16);
          if (a6)
          {
LABEL_103:
            size_t v57 = 4 * a6;
            uint64_t v72 = 0;
            int v73 = 0;
            uint64_t v74 = 0;
            if (4 * a6)
            {
              if ((v57 & 0x8000000000000000) != 0) {
                sub_19E37C7C4();
              }
              unint64_t v59 = (char *)operator new(4 * a6);
              BOOL v58 = &v59[4 * ((4 * a6) >> 2)];
              memmove(v59, a5, v57);
            }
            else
            {
              BOOL v58 = 0;
              unint64_t v59 = 0;
            }
            uint64_t v60 = (v58 - v59) >> 2;
            double v76 = 0;
            int v61 = *(char *)(a1 + 191);
            if (v61 >= 0) {
              CFIndex v62 = *(unsigned __int8 *)(a1 + 191);
            }
            else {
              CFIndex v62 = *(void *)(a1 + 176);
            }
            if (v62)
            {
              if (v61 >= 0) {
                unsigned __int8 v63 = (const UInt8 *)(a1 + 168);
              }
              else {
                unsigned __int8 v63 = *(const UInt8 **)(a1 + 168);
              }
              uint64_t v64 = *(void *)(a1 + 16);
              if (v63)
              {
                CFStringRef v65 = CFStringCreateWithBytes(0, v63, v62, 0x8000100u, 0);
                __p[0] = (void *)v65;
                if (!v65)
                {
                  char v66 = __cxa_allocate_exception(0x10uLL);
                  MEMORY[0x19F3BD790](v66, "Could not construct");
                  __cxa_throw(v66, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
                }
              }
              else
              {
                CFStringRef v65 = 0;
                __p[0] = 0;
              }
              sub_19E4408DC(v64, (uint64_t)v65, (uint64_t)v59, v60, (uint64_t)&v76);
              if (v65) {
                CFRelease(v65);
              }
            }
            else
            {
              sub_19E4408DC(*v56, 0, (uint64_t)v59, (v58 - v59) >> 2, (uint64_t)&v76);
            }
            uint64_t v67 = v76;
            if (v76)
            {
              __p[0] = operator new(0x28uLL);
              *(_OWORD *)&__p[1] = xmmword_19E573040;
              strcpy((char *)__p[0], "MRLNeuralNetworkSetPartialOutputIndices");
              sub_19E43FBD8((uint64_t *)__p, v67);
              if (SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
            }
            if (v59) {
              operator delete(v59);
            }
          }
        }
        sub_19E50A404(v56, (uint64_t)v11);
        uint64_t v72 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
        sub_19E43F904((uint64_t)__p, v56, (int *)&v72, a1 + 144);
        char v26 = __p[2];
        uint64_t v53 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
        unint64_t v22 = (float *)v71;
        goto LABEL_129;
      }
      dlerror();
      abort_report_np();
      __break(1u);
    }
    dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
LABEL_140:
    uint64_t v69 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 143) >= 0) {
        CFStringRef v70 = v15;
      }
      else {
        CFStringRef v70 = *(CFStringRef *)(a1 + 120);
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v70;
      _os_log_error_impl(&dword_19E36B000, v69, OS_LOG_TYPE_ERROR, "%s() not found as neural network input", (uint8_t *)__p, 0xCu);
    }
    __assert_rtn("setInput", "NeuralNetwork.hpp", 161, "false");
  }
  unint64_t v22 = (float *)operator new(4uLL);
  *unint64_t v22 = (float)a3;
  HIBYTE(__p[2]) = 5;
  strcpy((char *)__p, "input");
  sub_19E43F230(a1 + 16, v22, (uint64_t)__p);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  HIBYTE(__p[2]) = 8;
  strcpy((char *)__p, "position");
  uint64_t v24 = *(void *)(a1 + 24);
  uint64_t v23 = *(void *)(a1 + 32);
  uint64_t v25 = v24;
  if (v24 != v23)
  {
    uint64_t v25 = *(void *)(a1 + 24);
    while (1)
    {
      uint64_t v39 = *(unsigned __int8 *)(v25 + 23);
      if ((v39 & 0x80u) == 0) {
        uint64_t v40 = *(unsigned __int8 *)(v25 + 23);
      }
      else {
        uint64_t v40 = *(void *)(v25 + 8);
      }
      if (v40 == 8)
      {
        if ((v39 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v25, __p, *(void *)(v25 + 8))) {
            break;
          }
        }
        else
        {
          if (!*(unsigned char *)(v25 + 23)) {
            break;
          }
          uint64_t v41 = 0;
          while (*(unsigned __int8 *)(v25 + v41) == *((unsigned __int8 *)__p + v41))
          {
            if (v39 == ++v41) {
              goto LABEL_54;
            }
          }
        }
      }
      v25 += 24;
      if (v25 == v23) {
        goto LABEL_58;
      }
    }
  }
LABEL_54:
  if (v25 != v23)
  {
    float v42 = (float *)operator new(4uLL);
    *float v42 = (float)v12;
    HIBYTE(__p[2]) = 8;
    strcpy((char *)__p, "position");
    sub_19E43F230(a1 + 16, v42, (uint64_t)__p);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    operator delete(v42);
    uint64_t v24 = *(void *)(a1 + 24);
    uint64_t v23 = *(void *)(a1 + 32);
  }
LABEL_58:
  HIBYTE(__p[2]) = 11;
  strcpy((char *)__p, "temperature");
  uint64_t v43 = v23;
  if (v24 != v23)
  {
    uint64_t v43 = v24;
    while (1)
    {
      uint64_t v44 = *(unsigned __int8 *)(v43 + 23);
      if ((v44 & 0x80u) == 0) {
        uint64_t v45 = *(unsigned __int8 *)(v43 + 23);
      }
      else {
        uint64_t v45 = *(void *)(v43 + 8);
      }
      if (v45 == 11)
      {
        if ((v44 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v43, __p, *(void *)(v43 + 8))) {
            break;
          }
        }
        else
        {
          if (!*(unsigned char *)(v43 + 23)) {
            break;
          }
          uint64_t v46 = 0;
          while (*(unsigned __int8 *)(v43 + v46) == *((unsigned __int8 *)__p + v46))
          {
            if (v44 == ++v46) {
              goto LABEL_71;
            }
          }
        }
      }
      v43 += 24;
      if (v43 == v23) {
        goto LABEL_75;
      }
    }
  }
LABEL_71:
  if (v43 != v23)
  {
    size_t v47 = operator new(4uLL);
    *size_t v47 = 1065353216;
    HIBYTE(__p[2]) = 11;
    strcpy((char *)__p, "temperature");
    sub_19E43F230(a1 + 16, v47, (uint64_t)__p);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    operator delete(v47);
    uint64_t v24 = *(void *)(a1 + 24);
    uint64_t v23 = *(void *)(a1 + 32);
  }
LABEL_75:
  HIBYTE(__p[2]) = 7;
  strcpy((char *)__p, "segment");
  uint64_t v48 = v23;
  if (v24 == v23) {
    goto LABEL_89;
  }
  while (1)
  {
    uint64_t v49 = *(unsigned __int8 *)(v24 + 23);
    if ((v49 & 0x80u) == 0) {
      uint64_t v50 = *(unsigned __int8 *)(v24 + 23);
    }
    else {
      uint64_t v50 = *(void *)(v24 + 8);
    }
    if (v50 != 7) {
      goto LABEL_78;
    }
    if ((v49 & 0x80) == 0) {
      break;
    }
    if (!memcmp(*(const void **)v24, __p, *(void *)(v24 + 8))) {
      goto LABEL_88;
    }
LABEL_78:
    v24 += 24;
    if (v24 == v23) {
      goto LABEL_93;
    }
  }
  if (*(unsigned char *)(v24 + 23))
  {
    uint64_t v51 = 0;
    while (*(unsigned __int8 *)(v24 + v51) == *((unsigned __int8 *)__p + v51))
    {
      if (v49 == ++v51) {
        goto LABEL_88;
      }
    }
    goto LABEL_78;
  }
LABEL_88:
  uint64_t v48 = v24;
LABEL_89:
  if (v48 != v23)
  {
    unint64_t v52 = operator new(4uLL);
    _DWORD *v52 = 0;
    HIBYTE(__p[2]) = 7;
    strcpy((char *)__p, "segment");
    sub_19E43F230(a1 + 16, v52, (uint64_t)__p);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    operator delete(v52);
  }
LABEL_93:
  sub_19E50A404((uint64_t *)(a1 + 16), (uint64_t)v11);
  uint64_t v72 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  sub_19E43F904((uint64_t)__p, (uint64_t *)(a1 + 16), (int *)&v72, a1 + 144);
  char v26 = __p[2];
  uint64_t v53 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
LABEL_129:
  operator delete(v22);
  if (v53) {
    *(void *)(a1 + 192) = v12 + 1;
  }
LABEL_131:
  if (v11) {
    CFRelease(v11);
  }
  return v26;
}

void sub_19E43F0C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, const void *a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  __cxa_free_exception(v26);
  if (v27) {
    operator delete(v27);
  }
  operator delete(__p);
  sub_19E401594(&a12);
  _Unwind_Resume(a1);
}

void sub_19E43F230(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  if (v6 != v7)
  {
    char v8 = *(unsigned char *)(a3 + 23);
    if (v8 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v9 = *(void *)(a3 + 8);
    }
    if (v8 >= 0) {
      uint64_t v10 = (unsigned __int8 *)a3;
    }
    else {
      uint64_t v10 = *(unsigned __int8 **)a3;
    }
    while (1)
    {
      uint64_t v11 = *(unsigned __int8 *)(v6 + 23);
      if ((v11 & 0x80u) == 0) {
        uint64_t v12 = *(unsigned __int8 *)(v6 + 23);
      }
      else {
        uint64_t v12 = *(void *)(v6 + 8);
      }
      if (v12 == v9)
      {
        if ((v11 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v6, v10, *(void *)(v6 + 8))) {
            break;
          }
        }
        else
        {
          if (!*(unsigned char *)(v6 + 23)) {
            break;
          }
          uint64_t v13 = 0;
          while (*(unsigned __int8 *)(v6 + v13) == v10[v13])
          {
            if (v11 == ++v13) {
              goto LABEL_19;
            }
          }
        }
      }
      v6 += 24;
      if (v6 == v7) {
        goto LABEL_55;
      }
    }
  }
LABEL_19:
  if (v6 == v7)
  {
LABEL_55:
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    int v32 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) >= 0) {
        int v33 = (unsigned __int8 *)a3;
      }
      else {
        int v33 = *(unsigned __int8 **)a3;
      }
      *(_DWORD *)uint64_t v40 = 136315138;
      *(void *)&v40[4] = v33;
      _os_log_error_impl(&dword_19E36B000, v32, OS_LOG_TYPE_ERROR, "%s() not found as neural network input", v40, 0xCu);
    }
    __assert_rtn("setInputTensor", "NeuralNetwork.hpp", 184, "false");
  }
  sub_19E43FE94(a1, a2, (uint64_t *)1, (const void **)a3);
  uint64_t v14 = sub_19E43FF80((uint64_t **)(a1 + 56), (const void **)a3, a3)[7];
  uint64_t v34 = 1;
  uint64_t v35 = 1;
  sub_19E440544((uint64_t)v40, "InputDimension", &v34);
  sub_19E440544((uint64_t)&v40[16], "SequenceLength", &v35);
  CFDictionaryRef v15 = sub_19E411038((uint64_t *)v40, 2uLL);
  if (cf) {
    CFRelease(cf);
  }
  if (*(void *)&v40[16]) {
    CFRelease(*(CFTypeRef *)&v40[16]);
  }
  if (*(void *)&v40[8]) {
    CFRelease(*(CFTypeRef *)&v40[8]);
  }
  if (*(void *)v40) {
    CFRelease(*(CFTypeRef *)v40);
  }
  uint64_t v36 = 0;
  CFIndex v37 = &v36;
  uint64_t v38 = 0x2000000000;
  uint64_t v16 = (uint64_t (*)(CFDictionaryRef))off_1EC0091F0;
  uint64_t v39 = off_1EC0091F0;
  if (!off_1EC0091F0)
  {
    *(void *)uint64_t v40 = MEMORY[0x1E4F143A8];
    *(void *)&v40[8] = 0x40000000;
    *(void *)&v40[16] = sub_19E440618;
    CFTypeRef cf = &unk_1E599FAE0;
    float v42 = &v36;
    sub_19E440618((uint64_t)v40);
    uint64_t v16 = (uint64_t (*)(CFDictionaryRef))v37[3];
  }
  _Block_object_dispose(&v36, 8);
  if (!v16) {
    goto LABEL_63;
  }
  uint64_t v17 = v16(v15);
  CFRelease(v15);
  unint64_t v18 = (uint64_t **)(a1 + 80);
  char v19 = sub_19E440108((uint64_t **)(a1 + 80), (const void **)a3, a3);
  uint64_t v20 = v19[7];
  if (v20) {
    CFRelease(v20);
  }
  v19[7] = (uint64_t *)v17;
  int v21 = sub_19E440108((uint64_t **)(a1 + 80), (const void **)a3, a3)[7];
  uint64_t v36 = 0;
  CFIndex v37 = &v36;
  uint64_t v38 = 0x2000000000;
  unint64_t v22 = (void (*)(uint64_t *, uint64_t *, uint64_t))off_1EC009200;
  uint64_t v39 = off_1EC009200;
  if (!off_1EC009200)
  {
    *(void *)uint64_t v40 = MEMORY[0x1E4F143A8];
    *(void *)&v40[8] = 0x40000000;
    *(void *)&v40[16] = sub_19E44028C;
    CFTypeRef cf = &unk_1E599FB08;
    float v42 = &v36;
    sub_19E44028C((uint64_t)v40);
    unint64_t v22 = (void (*)(uint64_t *, uint64_t *, uint64_t))v37[3];
  }
  _Block_object_dispose(&v36, 8);
  if (!v22) {
    goto LABEL_63;
  }
  v22(v21, v14, 4);
  uint64_t v35 = 0;
  uint64_t v23 = *(void *)a1;
  char v24 = *(unsigned char *)(a3 + 23);
  uint64_t v25 = v24 >= 0 ? (const UInt8 *)a3 : *(const UInt8 **)a3;
  if (v25)
  {
    if (v24 >= 0) {
      CFIndex v26 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      CFIndex v26 = *(void *)(a3 + 8);
    }
    CFStringRef v27 = CFStringCreateWithBytes(0, v25, v26, 0x8000100u, 0);
    uint64_t v34 = (uint64_t)v27;
    if (!v27)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFStringRef v27 = 0;
    uint64_t v34 = 0;
  }
  uint64_t v29 = sub_19E440108(v18, (const void **)a3, a3)[7];
  uint64_t v36 = 0;
  CFIndex v37 = &v36;
  uint64_t v38 = 0x2000000000;
  uint64_t v30 = (void (*)(uint64_t, CFStringRef, uint64_t *, uint64_t *))off_1EC0091F8;
  uint64_t v39 = off_1EC0091F8;
  if (!off_1EC0091F8)
  {
    *(void *)uint64_t v40 = MEMORY[0x1E4F143A8];
    *(void *)&v40[8] = 0x40000000;
    *(void *)&v40[16] = sub_19E4403CC;
    CFTypeRef cf = &unk_1E599FB30;
    float v42 = &v36;
    sub_19E4403CC((uint64_t)v40);
    uint64_t v30 = (void (*)(uint64_t, CFStringRef, uint64_t *, uint64_t *))v37[3];
  }
  _Block_object_dispose(&v36, 8);
  if (!v30)
  {
LABEL_63:
    dlerror();
    abort_report_np();
    __break(1u);
  }
  v30(v23, v27, v29, &v35);
  if (v27) {
    CFRelease(v27);
  }
  uint64_t v31 = (__CFError *)v35;
  if (v35)
  {
    *(void *)uint64_t v40 = operator new(0x20uLL);
    *(_OWORD *)&v40[8] = xmmword_19E573050;
    strcpy(*(char **)v40, "MRLNeuralNetworkSetInputTensor");
    sub_19E43FBD8((uint64_t *)v40, v31);
    if ((v40[23] & 0x80000000) != 0) {
      operator delete(*(void **)v40);
    }
  }
}

void sub_19E43F804(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E43F818(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, int a16, const void *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

void sub_19E43F904(uint64_t a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v17 = 0;
  int v6 = *(char *)(a4 + 23);
  if (v6 >= 0) {
    CFIndex v7 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    CFIndex v7 = *(void *)(a4 + 8);
  }
  if (v7)
  {
    if (v6 >= 0) {
      char v8 = (const UInt8 *)a4;
    }
    else {
      char v8 = *(const UInt8 **)a4;
    }
    uint64_t v9 = *a2;
    if (v8)
    {
      uint64_t v10 = (__CFString *)CFStringCreateWithBytes(0, v8, v7, 0x8000100u, 0);
      unint64_t __p = v10;
      if (!v10)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    else
    {
      uint64_t v10 = 0;
      unint64_t __p = 0;
    }
    uint64_t v12 = sub_19E43FAD4(v9, (uint64_t)v10, (uint64_t)&v17);
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    uint64_t v12 = sub_19E43FAD4(*a2, 0, (uint64_t)&v17);
  }
  if (!v12) {
    __assert_rtn("getOutput", "NeuralNetwork.hpp", 262, "output != nullptr");
  }
  uint64_t v13 = v17;
  if (v17)
  {
    unint64_t __p = operator new(0x20uLL);
    long long v16 = xmmword_19E573060;
    strcpy((char *)__p, "MRLNeuralNetworkGetOutput");
    sub_19E43FBD8((uint64_t *)&__p, v13);
    if (SHIBYTE(v16) < 0) {
      operator delete(__p);
    }
  }
  uint64_t v14 = *a3;
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = v14;
  *(void *)(a1 + 16) = v12;
}

void sub_19E43FA8C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E43FAA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E43FAC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_19E43FAD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  int v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))off_1EC0093E0;
  uint64_t v13 = off_1EC0093E0;
  if (!off_1EC0093E0)
  {
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    _OWORD v9[2] = sub_19E43FD54;
    v9[3] = &unk_1E599FA68;
    v9[4] = &v10;
    sub_19E43FD54((uint64_t)v9);
    int v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v11[3];
  }
  _Block_object_dispose(&v10, 8);
  if (!v6)
  {
    dlerror();
    char v8 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v10, 8);
    _Unwind_Resume(v8);
  }
  return v6(a1, a2, a3);
}

void sub_19E43FBD8(uint64_t *a1, CFErrorRef err)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = CFErrorCopyDescription(err);
  if (qword_1EC0095B8 != -1) {
    dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
  }
  uint64_t v5 = qword_1EC0095B0;
  if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a1 + 23) >= 0) {
      int v6 = a1;
    }
    else {
      int v6 = (uint64_t *)*a1;
    }
    *(_DWORD *)int buf = 136315394;
    char v8 = v6;
    __int16 v9 = 2112;
    CFStringRef v10 = v4;
    _os_log_error_impl(&dword_19E36B000, v5, OS_LOG_TYPE_ERROR, "%s() failed: %@", buf, 0x16u);
    if (v4) {
      goto LABEL_5;
    }
  }
  else if (v4)
  {
LABEL_5:
    CFRelease(v4);
  }
  CFRelease(err);
}

void sub_19E43FCF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_19E43FD1C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

void *sub_19E43FD54(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0093C8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E43E210;
    v5[4] = &unk_1E599FA18;
    void v5[5] = v5;
    long long v6 = xmmword_1E599FA00;
    uint64_t v7 = 0;
    qword_1EC0093C8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0093C8;
    if (qword_1EC0093C8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0093C8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkGetOutput");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0093E0 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_19E43FE94(uint64_t a1, const void *a2, uint64_t *a3, const void **a4)
{
  uint64_t v5 = a3;
  if (a3)
  {
    if (((unint64_t)a3 & 0x8000000000000000) != 0) {
      sub_19E37C7C4();
    }
    size_t v8 = 4 * (void)a3;
    __int16 v9 = (char *)operator new(4 * (void)a3);
    uint64_t v5 = (uint64_t *)&v9[4 * (void)v5];
    memcpy(v9, a2, v8);
  }
  else
  {
    __int16 v9 = 0;
  }
  CFStringRef v10 = sub_19E43FF80((uint64_t **)(a1 + 56), a4, (uint64_t)a4);
  uint64_t v11 = v10[7];
  if (v11)
  {
    v10[8] = v11;
    operator delete(v11);
    v10[7] = 0;
    v10[8] = 0;
    v10[9] = 0;
  }
  v10[7] = (uint64_t *)v9;
  v10[8] = v5;
  v10[9] = v5;
}

void sub_19E43FF54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (v11) {
    operator delete(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_19E43FF80(uint64_t **a1, const void **a2, uint64_t a3)
{
  long long v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *((char *)a2 + 23);
    if (v7 >= 0) {
      size_t v8 = a2;
    }
    else {
      size_t v8 = *a2;
    }
    if (v7 >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    while (1)
    {
      CFStringRef v10 = (uint64_t **)v5;
      uint64_t v13 = (const void *)v5[4];
      uint64_t v11 = v5 + 4;
      uint64_t v12 = v13;
      int v14 = *((char *)v11 + 23);
      if (v14 >= 0) {
        CFDictionaryRef v15 = v11;
      }
      else {
        CFDictionaryRef v15 = v12;
      }
      if (v14 >= 0) {
        size_t v16 = *((unsigned __int8 *)v11 + 23);
      }
      else {
        size_t v16 = v11[1];
      }
      if (v16 >= v9) {
        size_t v17 = v9;
      }
      else {
        size_t v17 = v16;
      }
      int v18 = memcmp(v8, v15, v17);
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_8;
        }
LABEL_22:
        int v19 = memcmp(v15, v8, v17);
        if (v19)
        {
          if ((v19 & 0x80000000) == 0) {
            return v10;
          }
        }
        else if (v16 >= v9)
        {
          return v10;
        }
        uint64_t v5 = v10[1];
        if (!v5)
        {
          long long v6 = v10 + 1;
          goto LABEL_29;
        }
      }
      else
      {
        if (v9 >= v16) {
          goto LABEL_22;
        }
LABEL_8:
        uint64_t v5 = *v10;
        long long v6 = v10;
        if (!*v10) {
          goto LABEL_29;
        }
      }
    }
  }
  CFStringRef v10 = a1 + 1;
LABEL_29:
  uint64_t v20 = operator new(0x50uLL);
  int v21 = v20 + 4;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_19E39369C(v21, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)int v21 = *(_OWORD *)a3;
    v20[6] = *(void *)(a3 + 16);
  }
  v20[7] = 0;
  v20[8] = 0;
  v20[9] = 0;
  *uint64_t v20 = 0;
  v20[1] = 0;
  v20[2] = v10;
  *long long v6 = v20;
  unint64_t v22 = (uint64_t *)**a1;
  uint64_t v23 = v20;
  if (v22)
  {
    *a1 = v22;
    uint64_t v23 = *v6;
  }
  sub_19E37D324(a1[1], v23);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v20;
}

void sub_19E4400F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t **sub_19E440108(uint64_t **a1, const void **a2, uint64_t a3)
{
  long long v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *((char *)a2 + 23);
    if (v7 >= 0) {
      size_t v8 = a2;
    }
    else {
      size_t v8 = *a2;
    }
    if (v7 >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    while (1)
    {
      CFStringRef v10 = (uint64_t **)v5;
      uint64_t v13 = (const void *)v5[4];
      uint64_t v11 = v5 + 4;
      uint64_t v12 = v13;
      int v14 = *((char *)v11 + 23);
      if (v14 >= 0) {
        CFDictionaryRef v15 = v11;
      }
      else {
        CFDictionaryRef v15 = v12;
      }
      if (v14 >= 0) {
        size_t v16 = *((unsigned __int8 *)v11 + 23);
      }
      else {
        size_t v16 = v11[1];
      }
      if (v16 >= v9) {
        size_t v17 = v9;
      }
      else {
        size_t v17 = v16;
      }
      int v18 = memcmp(v8, v15, v17);
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_8;
        }
LABEL_22:
        int v19 = memcmp(v15, v8, v17);
        if (v19)
        {
          if ((v19 & 0x80000000) == 0) {
            return v10;
          }
        }
        else if (v16 >= v9)
        {
          return v10;
        }
        uint64_t v5 = v10[1];
        if (!v5)
        {
          long long v6 = v10 + 1;
          goto LABEL_29;
        }
      }
      else
      {
        if (v9 >= v16) {
          goto LABEL_22;
        }
LABEL_8:
        uint64_t v5 = *v10;
        long long v6 = v10;
        if (!*v10) {
          goto LABEL_29;
        }
      }
    }
  }
  CFStringRef v10 = a1 + 1;
LABEL_29:
  uint64_t v20 = operator new(0x40uLL);
  int v21 = v20 + 4;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_19E39369C(v21, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)int v21 = *(_OWORD *)a3;
    v20[6] = *(void *)(a3 + 16);
  }
  v20[7] = 0;
  *uint64_t v20 = 0;
  v20[1] = 0;
  v20[2] = v10;
  *long long v6 = v20;
  unint64_t v22 = (uint64_t *)**a1;
  uint64_t v23 = v20;
  if (v22)
  {
    *a1 = v22;
    uint64_t v23 = *v6;
  }
  sub_19E37D324(a1[1], v23);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v20;
}

void sub_19E440278(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_19E44028C(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0093C8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E43E210;
    v5[4] = &unk_1E599FA18;
    void v5[5] = v5;
    long long v6 = xmmword_1E599FA00;
    uint64_t v7 = 0;
    qword_1EC0093C8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0093C8;
    if (qword_1EC0093C8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0093C8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkTensorAppendData");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC009200 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E4403CC(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0093C8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E43E210;
    v5[4] = &unk_1E599FA18;
    void v5[5] = v5;
    long long v6 = xmmword_1E599FA00;
    uint64_t v7 = 0;
    qword_1EC0093C8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0093C8;
    if (qword_1EC0093C8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0093C8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkSetInputTensor");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0091F8 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

const void **sub_19E44050C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

uint64_t sub_19E440544(uint64_t a1, char *a2, uint64_t *a3)
{
  sub_19E440758((CFStringRef *)a1, a2);
  uint64_t valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  *(void *)(a1 + 8) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  return a1;
}

void sub_19E4405DC(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  sub_19E3C60A8((const void **)v1);
  _Unwind_Resume(a1);
}

void *sub_19E440618(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0093C8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E43E210;
    v5[4] = &unk_1E599FA18;
    void v5[5] = v5;
    long long v6 = xmmword_1E599FA00;
    uint64_t v7 = 0;
    qword_1EC0093C8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0093C8;
    if (qword_1EC0093C8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0093C8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkTensorCreate");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0091F0 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

CFStringRef *sub_19E440758(CFStringRef *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (void **)operator new(v7 + 1);
    size_t v15 = v5;
    int64_t v16 = v8 | 0x8000000000000000;
    std::string __dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v16) = v4;
  p_dst = (void **)&__dst;
  if (v4) {
LABEL_8:
  }
    memcpy(p_dst, __s, v5);
  *((unsigned char *)p_dst + v5) = 0;
  if (v16 >= 0) {
    size_t v9 = (const UInt8 *)&__dst;
  }
  else {
    size_t v9 = (const UInt8 *)__dst;
  }
  if (v16 >= 0) {
    CFIndex v10 = HIBYTE(v16);
  }
  else {
    CFIndex v10 = v15;
  }
  CFStringRef v11 = CFStringCreateWithBytes(0, v9, v10, 0x8000100u, 0);
  *a1 = v11;
  if (!v11)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst);
  }
  return a1;
}

void sub_19E440898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*v15) {
    CFRelease(*v15);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E4408DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = 0;
  size_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  CFIndex v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))off_1E9459FD8;
  size_t v17 = off_1E9459FD8;
  if (!off_1E9459FD8)
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    v13[2] = sub_19E4409F8;
    v13[3] = &unk_1E599FAB8;
    v13[4] = &v14;
    sub_19E4409F8((uint64_t)v13);
    CFIndex v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v15[3];
  }
  _Block_object_dispose(&v14, 8);
  if (!v10)
  {
    dlerror();
    uint64_t v12 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v14, 8);
    _Unwind_Resume(v12);
  }
  return v10(a1, a2, a3, a4, a5);
}

void *sub_19E4409F8(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0093C8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E43E210;
    v5[4] = &unk_1E599FA18;
    void v5[5] = v5;
    long long v6 = xmmword_1E599FA00;
    uint64_t v7 = 0;
    qword_1EC0093C8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0093C8;
    if (qword_1EC0093C8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0093C8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkSetPartialOutputIndices");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E9459FD8 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E440B38(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EC0093C8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E43E210;
    v5[4] = &unk_1E599FA18;
    void v5[5] = v5;
    long long v6 = xmmword_1E599FA00;
    uint64_t v7 = 0;
    qword_1EC0093C8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1EC0093C8;
    if (qword_1EC0093C8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1EC0093C8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkSetInput");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0093D8 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E440C78(uint64_t a1)
{
  return *(void *)(a1 + 200);
}

void sub_19E440C80(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BB750;
  if (*(char *)(a1 + 191) < 0)
  {
    operator delete(*(void **)(a1 + 168));
    if ((*(char *)(a1 + 167) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(a1 + 143) & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_9:
      operator delete(*(void **)(a1 + 120));
LABEL_4:
      sub_19E440D2C(a1 + 16);
      JUMPOUT(0x19F3BDCF0);
    }
  }
  else if ((*(char *)(a1 + 167) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(a1 + 144));
  if ((*(char *)(a1 + 143) & 0x80000000) == 0) {
    goto LABEL_4;
  }
  goto LABEL_9;
}

uint64_t sub_19E440D2C(uint64_t a1)
{
  sub_19E440E14(a1);
  sub_19E440EF0(*(char **)(a1 + 88));
  sub_19E440F68(*(char **)(a1 + 64));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    size_t v4 = *(void **)(a1 + 32);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 24;
      }
      while (v3 != v2);
      size_t v4 = *(void **)(a1 + 32);
    }
    *(void *)(a1 + 40) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = *(void **)(a1 + 8);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0) {
          operator delete(*(void **)(v6 - 24));
        }
        v6 -= 24;
      }
      while (v6 != v5);
      uint64_t v7 = *(void **)(a1 + 8);
    }
    *(void *)(a1 + 16) = v5;
    operator delete(v7);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  *(void *)a1 = 0;
  return a1;
}

void sub_19E440E14(uint64_t a1)
{
  uint64_t v1 = *(long long **)(a1 + 8);
  uint64_t v2 = *(long long **)(a1 + 16);
  if (v1 != v2)
  {
    uint64_t v4 = a1 + 88;
    uint64_t v5 = (uint64_t **)(a1 + 56);
    do
    {
      if (*((char *)v1 + 23) < 0)
      {
        sub_19E39369C(__p, *(void **)v1, *((void *)v1 + 1));
      }
      else
      {
        long long v6 = *v1;
        uint64_t v9 = *((void *)v1 + 2);
        *(_OWORD *)unint64_t __p = v6;
      }
      sub_19E440EF0(*(char **)(a1 + 88));
      *(void *)(a1 + 88) = 0;
      *(void *)(a1 + 96) = 0;
      *(void *)(a1 + 80) = v4;
      uint64_t v7 = sub_19E43FF80(v5, (const void **)__p, (uint64_t)__p);
      v7[8] = v7[7];
      if (SHIBYTE(v9) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v1 = (long long *)((char *)v1 + 24);
    }
    while (v1 != v2);
  }
}

void sub_19E440ED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E440EF0(char *a1)
{
  if (a1)
  {
    sub_19E440EF0(*(void *)a1);
    sub_19E440EF0(*((void *)a1 + 1));
    uint64_t v2 = (const void *)*((void *)a1 + 7);
    if (v2) {
      CFRelease(v2);
    }
    *((void *)a1 + 7) = 0;
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void sub_19E440F68(char *a1)
{
  if (a1)
  {
    sub_19E440F68(*(void *)a1);
    sub_19E440F68(*((void *)a1 + 1));
    uint64_t v2 = (void *)*((void *)a1 + 7);
    if (v2)
    {
      *((void *)a1 + 8) = v2;
      operator delete(v2);
    }
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

uint64_t sub_19E440FD4(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BB750;
  if ((*(char *)(a1 + 191) & 0x80000000) == 0)
  {
    if ((*(char *)(a1 + 167) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    operator delete(*(void **)(a1 + 144));
    if ((*(char *)(a1 + 143) & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_7:
    operator delete(*(void **)(a1 + 120));
    goto LABEL_4;
  }
  operator delete(*(void **)(a1 + 168));
  if (*(char *)(a1 + 167) < 0) {
    goto LABEL_6;
  }
LABEL_3:
  if (*(char *)(a1 + 143) < 0) {
    goto LABEL_7;
  }
LABEL_4:
  sub_19E440D2C(a1 + 16);
  return a1;
}

void sub_19E441060(uint64_t a1, const void **a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1EF0BB750;
  *(_DWORD *)(a1 + 8) = sub_19E4DE320(*a2);
  CFDictionaryGetValue((CFDictionaryRef)*a2, @"URL");
  sub_19E3C2CE4();
}

void sub_19E44180C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E441988(uint64_t a1, const __CFString *a2, CFTypeRef cf)
{
  if (!cf)
  {
    CFDictionaryRef v19 = 0;
LABEL_14:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFRetain(cf);
  sub_19E36E590(&v19, cf);
  if (!v19) {
    goto LABEL_14;
  }
  if (!a2 || !CFDictionaryContainsKey(v19, a2))
  {
    *(unsigned char *)(a1 + 23) = 0;
    *(unsigned char *)a1 = 0;
    CFDictionaryRef v9 = v19;
    if (!v19) {
      return;
    }
    goto LABEL_11;
  }
  if (!v19)
  {
    CFStringRef v11 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v11, "Could not construct");
    __cxa_throw(v11, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v19, a2);
  CFStringRef v7 = Value;
  if (!Value)
  {
LABEL_17:
    LOBYTE(v17) = 0;
    char v18 = 0;
    uint64_t v12 = __cxa_allocate_exception(0x20uLL);
    CFStringRef v13 = a2;
    uint64_t v14 = v12;
    sub_19E37774C(v13, &v15);
    sub_19E420378(&v16, "Malformed language model configuration plist: invalid value for key=", &v15);
    sub_19E3F5604(v14, (long long *)&v16);
    __cxa_throw(v14, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
  }
  CFRetain(Value);
  CFTypeID v8 = CFGetTypeID(v7);
  if (v8 != CFStringGetTypeID())
  {
    CFRelease(v7);
    goto LABEL_17;
  }
  char v18 = 1;
  uint64_t v17 = 0;
  sub_19E37774C(v7, (void *)a1);
  CFDictionaryRef v9 = v19;
  if (!v19) {
    return;
  }
LABEL_11:
  CFRelease(v9);
}

void sub_19E441B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v23 & 1) == 0)
    {
LABEL_8:
      sub_19E441C0C((uint64_t)&a22);
      sub_19E3C6EAC((const void **)(v24 - 40));
      _Unwind_Resume(a1);
    }
  }
  else if (!v23)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v22);
  goto LABEL_8;
}

uint64_t sub_19E441C0C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

os_log_t sub_19E441C48()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "MontrealInferenceEngine");
  qword_1E9459FC8 = (uint64_t)result;
  return result;
}

double sub_19E441C78(uint64_t a1)
{
  return *(double *)(a1 + 8);
}

BOOL sub_19E441C80(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4)
{
  if (!a4) {
    return 1;
  }
  unsigned int v4 = HIWORD(a2);
  unsigned int v5 = *(_DWORD *)(a1 + 56);
  if (HIWORD(a2) >= v5) {
    return 1;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  CFTypeID v8 = (int *)(v6 + 4 * *(unsigned int *)(v7 + 4 * v4));
  unsigned int v9 = v5 - 1;
  if (v4 == v5 - 1)
  {
    CFIndex v10 = (int *)(*(void *)(a1 + 24) + *(void *)(a1 + 32));
    if (v8 == v10) {
      return 1;
    }
  }
  else
  {
    CFIndex v10 = (int *)(v6 + 4 * *(unsigned int *)(v7 + 4 * (v4 + 1)));
    if (v8 == v10) {
      return 1;
    }
  }
  unint64_t v11 = v10 - v8;
  do
  {
    unint64_t v12 = v11 >> 1;
    CFStringRef v13 = &v8[v11 >> 1];
    unsigned int v14 = *((unsigned __int16 *)v13 + 1);
    std::string v15 = v13 + 1;
    v11 += ~(v11 >> 1);
    if (v14 < (unsigned __int16)a2) {
      CFTypeID v8 = v15;
    }
    else {
      unint64_t v11 = v12;
    }
  }
  while (v11);
  if (v8 >= v10) {
    return 1;
  }
  int v16 = *v8;
  if ((*v8 ^ (a2 << 16)) >> 16) {
    return 1;
  }
  unint64_t v17 = *(unsigned int *)(a3 + 4 * a4 - 4);
  unint64_t v18 = v17 >> 16;
  if (HIWORD(*(_DWORD *)(a3 + 4 * a4 - 4)) >= v5) {
    return 1;
  }
  CFDictionaryRef v19 = (unsigned int *)(v6 + 4 * *(unsigned int *)(v7 + 4 * v18));
  uint64_t v20 = (unsigned int *)(v18 == v9
                       ? *(void *)(a1 + 24) + *(void *)(a1 + 32)
                       : v6 + 4 * *(unsigned int *)(v7 + 4 * (v18 + 1)));
  if (v19 == v20) {
    return 1;
  }
  unint64_t v21 = v20 - v19;
  do
  {
    unint64_t v22 = v21 >> 1;
    int v23 = &v19[v21 >> 1];
    unsigned int v24 = *((unsigned __int16 *)v23 + 1);
    uint64_t v25 = v23 + 1;
    v21 += ~(v21 >> 1);
    if (v24 < (unsigned __int16)*(_DWORD *)(a3 + 4 * a4 - 4)) {
      CFDictionaryRef v19 = v25;
    }
    else {
      unint64_t v21 = v22;
    }
  }
  while (v21);
  if (v19 >= v20) {
    return 1;
  }
  unsigned int v26 = *v19;
  if ((v26 ^ (v17 << 16)) >> 16) {
    return 1;
  }
  if ((v16 & 0x10) == 0)
  {
    uint64_t v27 = 1;
    if ((v16 & 1) == 0 || (v26 & 4) == 0) {
      return v27;
    }
    goto LABEL_34;
  }
  if ((v26 & 1) == 0)
  {
    if ((v26 & 4) != 0)
    {
LABEL_34:
      __int16 v29 = v16 & v26;
      return (v29 & 0x7E0) != 0;
    }
    return 1;
  }
  __int16 v30 = v16 & v26;
  BOOL v31 = ((unsigned __int16)v16 & (unsigned __int16)v26 & 0x7800) != 0;
  uint64_t v27 = (v30 & 0x7E0) != 0 && v31;
  if (a4 < 3) {
    return v27;
  }
  unint64_t v32 = *(unsigned int *)(a3 + 4 * a4 - 8);
  unint64_t v33 = v32 >> 16;
  if (HIWORD(*(_DWORD *)(a3 + 4 * a4 - 8)) >= v5) {
    return v27;
  }
  uint64_t v34 = (int *)(v6 + 4 * *(unsigned int *)(v7 + 4 * v33));
  uint64_t v35 = (int *)(v33 == v9
              ? *(void *)(a1 + 24) + *(void *)(a1 + 32)
              : v6 + 4 * *(unsigned int *)(v7 + 4 * (v33 + 1)));
  if (v34 == v35) {
    return v27;
  }
  unint64_t v36 = v35 - v34;
  do
  {
    unint64_t v37 = v36 >> 1;
    uint64_t v38 = &v34[v36 >> 1];
    unsigned int v39 = *((unsigned __int16 *)v38 + 1);
    uint64_t v40 = v38 + 1;
    v36 += ~(v36 >> 1);
    if (v39 < (unsigned __int16)*(_DWORD *)(a3 + 4 * a4 - 8)) {
      uint64_t v34 = v40;
    }
    else {
      unint64_t v36 = v37;
    }
  }
  while (v36);
  if (v34 >= v35) {
    return v27;
  }
  int v41 = *v34;
  if ((*v34 ^ (v32 << 16)) >> 16) {
    return v27;
  }
  if ((v41 & 4) != 0) {
    uint64_t v42 = 0;
  }
  else {
    uint64_t v42 = v27;
  }
  if ((v41 & 4) != 0)
  {
    char v43 = v27 ^ 1;
    uint64_t v27 = v42;
    if (v43) {
      return v27;
    }
    __int16 v29 = v41 & v16;
    return (v29 & 0x7E0) != 0;
  }
  return v42;
}

void sub_19E441EC8(void *a1)
{
  *a1 = &unk_1EF0BBFC0;
  a1[2] = &unk_1EF0B99D8;
  uint64_t v2 = (void *)a1[3];
  if (v2) {
    munmap(v2, a1[4]);
  }
  a1[4] = 0;
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E441F60(void *a1)
{
  *a1 = &unk_1EF0BBFC0;
  a1[2] = &unk_1EF0B99D8;
  uint64_t v2 = (void *)a1[3];
  if (v2) {
    munmap(v2, a1[4]);
  }
  a1[4] = 0;
  return a1;
}

uint64_t sub_19E441FD8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t sub_19E441FE0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 324);
}

uint64_t sub_19E441FE8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 328);
}

uint64_t sub_19E441FF0(uint64_t a1, unsigned int a2)
{
  return (*(void *)(*(void *)(a1 + 296) + (((unint64_t)a2 >> 3) & 0x1FFFFFF8)) >> a2) & 1;
}

uint64_t sub_19E442010()
{
  return 0;
}

BOOL sub_19E442018(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 344);
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v2 <= a2) {
        unint64_t v4 = a2 % v2;
      }
    }
    else
    {
      unint64_t v4 = (v2 - 1) & a2;
    }
    unsigned int v5 = *(uint64_t **)(*(void *)(a1 + 336) + 8 * v4);
    if (v5)
    {
      unsigned int v5 = (uint64_t *)*v5;
      if (v5)
      {
        if (v3.u32[0] < 2uLL)
        {
          unint64_t v6 = v2 - 1;
          while (1)
          {
            uint64_t v8 = v5[1];
            if (v8 == a2)
            {
              if (*((_DWORD *)v5 + 4) == a2) {
                return v5 != 0;
              }
            }
            else if ((v8 & v6) != v4)
            {
              goto LABEL_21;
            }
            unsigned int v5 = (uint64_t *)*v5;
            if (!v5) {
              return v5 != 0;
            }
          }
        }
        do
        {
          unint64_t v7 = v5[1];
          if (v7 == a2)
          {
            if (*((_DWORD *)v5 + 4) == a2) {
              return v5 != 0;
            }
          }
          else
          {
            if (v7 >= v2) {
              v7 %= v2;
            }
            if (v7 != v4) {
              goto LABEL_21;
            }
          }
          unsigned int v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
    }
  }
  else
  {
LABEL_21:
    unsigned int v5 = 0;
  }
  return v5 != 0;
}

BOOL sub_19E4420F8(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = (unsigned __int16 *)(*(void *)(a1 + 8) + 24 * a2);
  if (*((char *)v2 + 23) < 0)
  {
    unint64_t v2 = *(unsigned __int16 **)v2;
    if (*(void *)(*(void *)(a1 + 8) + 24 * a2 + 8) < 3uLL) {
      return 0;
    }
  }
  else if (*((unsigned __int8 *)v2 + 23) < 3uLL)
  {
    return 0;
  }
  int v4 = *v2;
  int v5 = *((unsigned __int8 *)v2 + 2);
  return v4 == 38626 && v5 == 129;
}

uint64_t sub_19E44214C(uint64_t a1, void *a2, unint64_t a3)
{
  if (a3 >= (uint64_t)(a2[1] - *a2) >> 2) {
    __assert_rtn("isWordBoundaryIndex", "CoreLMPrefixCoder.cpp", 35, "index < encoding.size()");
  }
  unsigned int v3 = *(_DWORD *)(*a2 + 4 * a3);
  int v4 = (unsigned __int16 *)(*(void *)(a1 + 8) + 24 * v3);
  if (*((char *)v4 + 23) < 0)
  {
    int v4 = *(unsigned __int16 **)v4;
    if (*(void *)(*(void *)(a1 + 8) + 24 * v3 + 8) < 3uLL) {
      return *(_DWORD *)(a1 + 76) == v3;
    }
  }
  else if (*((unsigned __int8 *)v4 + 23) < 3uLL)
  {
    return *(_DWORD *)(a1 + 76) == v3;
  }
  int v5 = *v4;
  int v6 = *((unsigned __int8 *)v4 + 2);
  if (v5 != 38626 || v6 != 129) {
    return *(_DWORD *)(a1 + 76) == v3;
  }
  return 1;
}

BOOL sub_19E4421F8(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 84) == a2;
}

BOOL sub_19E442208(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 72) == a2;
}

BOOL sub_19E442218(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 80) == a2;
}

BOOL sub_19E442228(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 76) == a2;
}

BOOL sub_19E442238(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 68) == a2;
}

BOOL sub_19E442248(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v2 <= a2) {
        unint64_t v4 = a2 % v2;
      }
    }
    else
    {
      unint64_t v4 = (v2 - 1) & a2;
    }
    int v5 = *(uint64_t **)(*(void *)(a1 + 88) + 8 * v4);
    if (v5)
    {
      int v5 = (uint64_t *)*v5;
      if (v5)
      {
        if (v3.u32[0] < 2uLL)
        {
          unint64_t v6 = v2 - 1;
          while (1)
          {
            uint64_t v8 = v5[1];
            if (v8 == a2)
            {
              if (*((_DWORD *)v5 + 4) == a2) {
                return v5 != 0;
              }
            }
            else if ((v8 & v6) != v4)
            {
              goto LABEL_21;
            }
            int v5 = (uint64_t *)*v5;
            if (!v5) {
              return v5 != 0;
            }
          }
        }
        do
        {
          unint64_t v7 = v5[1];
          if (v7 == a2)
          {
            if (*((_DWORD *)v5 + 4) == a2) {
              return v5 != 0;
            }
          }
          else
          {
            if (v7 >= v2) {
              v7 %= v2;
            }
            if (v7 != v4) {
              goto LABEL_21;
            }
          }
          int v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
    }
  }
  else
  {
LABEL_21:
    int v5 = 0;
  }
  return v5 != 0;
}

uint64_t sub_19E442328(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void sub_19E442330(uint64_t a1@<X8>)
{
  *(unsigned char *)(a1 + 23) = 3;
  *(_DWORD *)a1 = 8492770;
}

unsigned int *sub_19E442348(unsigned int *result, int a2)
{
  switch(a2)
  {
    case 2:
      return (unsigned int *)result[20];
    case 1:
      return (unsigned int *)result[19];
    case 0:
      return (unsigned int *)result[17];
  }
  return result;
}

BOOL sub_19E442378(uint64_t a1, unsigned int a2, void *__s2)
{
  uint64_t v3 = *((unsigned __int8 *)__s2 + 23);
  unsigned __int8 v4 = v3;
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = __s2[1];
  }
  if (!v3) {
    return 1;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 40) - v5) >> 3) <= a2) {
    __assert_rtn("fragmentString", "SentencePieceCoder.hpp", 107, "fragmentID < m_tokenIDToFragmentStrMap.size()");
  }
  unint64_t v6 = __s2;
  unint64_t v7 = (long long *)(v5 + 24 * a2);
  if (*((char *)v7 + 23) < 0)
  {
    sub_19E39369C(&v17, *(void **)v7, *((void *)v7 + 1));
    unsigned __int8 v4 = *((unsigned char *)v6 + 23);
  }
  else
  {
    long long v8 = *v7;
    uint64_t v18 = *((void *)v7 + 2);
    long long v17 = v8;
  }
  unint64_t v10 = HIBYTE(v18);
  int v11 = SHIBYTE(v18);
  if (v18 < 0) {
    unint64_t v10 = *((void *)&v17 + 1);
  }
  if ((v4 & 0x80) == 0)
  {
    size_t v12 = v4;
    if (v10 >= v4) {
      goto LABEL_23;
    }
LABEL_15:
    if ((v4 & 0x80u) == 0) {
      CFStringRef v13 = (long long *)v6;
    }
    else {
      CFStringRef v13 = (long long *)*v6;
    }
    unsigned int v14 = (void *)v17;
    if (v18 >= 0) {
      std::string v15 = &v17;
    }
    else {
      std::string v15 = (long long *)v17;
    }
    size_t v12 = v10;
    goto LABEL_27;
  }
  size_t v12 = v6[1];
  if (v10 < v12) {
    goto LABEL_15;
  }
  unint64_t v6 = (void *)*v6;
LABEL_23:
  unsigned int v14 = (void *)v17;
  if (v18 >= 0) {
    CFStringRef v13 = &v17;
  }
  else {
    CFStringRef v13 = (long long *)v17;
  }
  std::string v15 = (long long *)v6;
LABEL_27:
  BOOL v9 = memcmp(v13, v15, v12) == 0;
  if (v11 < 0) {
    operator delete(v14);
  }
  return v9;
}

void *sub_19E4424D0@<X0>(void *result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[5] - result[4]) >> 3) <= a2) {
    __assert_rtn("fragmentStringWithDelimiters", "SentencePieceCoder.hpp", 99, "fragmentID < m_tokenIDToFragmentStrMap.size()");
  }
  uint64_t v3 = result[1] + 24 * a2;
  if (*(char *)(v3 + 23) < 0)
  {
    uint64_t v5 = *(void **)v3;
    unint64_t v6 = *(void *)(v3 + 8);
    return sub_19E39369C((unsigned char *)a3, v5, v6);
  }
  else
  {
    long long v4 = *(_OWORD *)v3;
    *(void *)(a3 + 16) = *(void *)(v3 + 16);
    *(_OWORD *)a3 = v4;
  }
  return result;
}

void *sub_19E44256C@<X0>(void *result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = result[4];
  if (0xAAAAAAAAAAAAAAABLL * ((result[5] - v3) >> 3) <= a2) {
    __assert_rtn("fragmentString", "SentencePieceCoder.hpp", 107, "fragmentID < m_tokenIDToFragmentStrMap.size()");
  }
  long long v4 = (long long *)(v3 + 24 * a2);
  if (*((char *)v4 + 23) < 0)
  {
    unint64_t v6 = *(void **)v4;
    unint64_t v7 = *((void *)v4 + 1);
    return sub_19E39369C((unsigned char *)a3, v6, v7);
  }
  else
  {
    long long v5 = *v4;
    *(void *)(a3 + 16) = *((void *)v4 + 2);
    *(_OWORD *)a3 = v5;
  }
  return result;
}

void sub_19E442604(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  long long v8 = a2;
  uint64_t v9 = a3 - 1;
  if (a3 == 1 && *a2 == *(_DWORD *)(a1 + 68))
  {
    *(unsigned char *)(a4 + 23) = 5;
    strcpy((char *)a4, "<unk>");
  }
  else
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    uint64_t v10 = a3;
    unint64_t __p = 0;
    unsigned int v24 = 0;
    uint64_t v25 = 0;
    if (4 * a3)
    {
      if (v10 * 4 < 0) {
        sub_19E37C7C4();
      }
      int v11 = operator new(4 * a3);
      unint64_t __p = v11;
      uint64_t v25 = &v11[(4 * a3) >> 2];
      if (a3)
      {
        if ((v9 & 0x3FFFFFFFFFFFFFFFuLL) < 7) {
          goto LABEL_25;
        }
        if ((unint64_t)((char *)v11 - (char *)a2) < 0x20) {
          goto LABEL_25;
        }
        uint64_t v12 = (v9 & 0x3FFFFFFFFFFFFFFFLL) + 1;
        uint64_t v13 = v12 & 0x7FFFFFFFFFFFFFF8;
        long long v8 = &a2[v13];
        unsigned int v14 = v11 + 4;
        std::string v15 = (long long *)(a2 + 4);
        uint64_t v16 = v12 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v17 = *v15;
          *(v14 - 1) = *(v15 - 1);
          _OWORD *v14 = v17;
          v14 += 2;
          v15 += 2;
          v16 -= 8;
        }
        while (v16);
        int v11 = (_DWORD *)((char *)v11 + v13 * 4);
        if (v12 != (v12 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_25:
          do
          {
            int v18 = *v8++;
            *v11++ = v18;
          }
          while (v8 != &a2[v10]);
        }
      }
      unsigned int v24 = v11;
    }
    sub_19E387170(a1 + 128, (uint64_t)&__p, a4, &v22);
    if (v22)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      sub_19E3AD800((uint64_t)&v22, &v21);
      if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &v21;
      }
      else {
        uint64_t v20 = (std::string *)v21.__r_.__value_.__r.__words[0];
      }
      MEMORY[0x19F3BD790](exception, v20);
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    sub_19E3AD4CC(&v22);
    if (__p)
    {
      unsigned int v24 = __p;
      operator delete(__p);
    }
  }
}

void sub_19E4427D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    operator delete(__p);
    if ((*(char *)(v18 + 23) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v18 + 23) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)v18);
  _Unwind_Resume(exception_object);
}

void sub_19E442850(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E39369C(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    uint64_t v9 = *(void *)(a2 + 16);
  }
  int v10 = 0;
  sub_19E371C70(__p, (const UInt8 *)__dst);
  int v7 = v10;
  sub_19E442948(a1, (uint64_t)__p, a3);
  if ((v6 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v9) & 0x80000000) == 0) {
      return;
    }
LABEL_8:
    operator delete(__dst[0]);
    return;
  }
  operator delete(__p[0]);
  if (SHIBYTE(v9) < 0) {
    goto LABEL_8;
  }
}

void sub_19E4428FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a21 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a21 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a16);
  _Unwind_Resume(exception_object);
}

void sub_19E442948(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  switch(*(_DWORD *)(a2 + 24))
  {
    case 1:
      int v6 = *(_DWORD *)(a1 + 76);
      goto LABEL_9;
    case 2:
      int v6 = *(_DWORD *)(a1 + 80);
LABEL_9:
      a3[1] = 0;
      a3[2] = 0;
      *a3 = 0;
      int v10 = operator new(4uLL);
      *a3 = v10;
      *v10++ = v6;
      a3[1] = v10;
      a3[2] = v10;
      return;
    case 3:
      int v7 = *(char *)(a2 + 23);
      if ((v7 & 0x80000000) == 0)
      {
        *(_OWORD *)size_t __n = *(_OWORD *)a2;
        uint64_t v70 = *(void *)(a2 + 16);
        long long v8 = (const void *)language_modeling::v1::kClassLabelNumber;
        size_t v9 = strlen((const char *)language_modeling::v1::kClassLabelNumber);
        goto LABEL_11;
      }
      sub_19E39369C(__n, *(void **)a2, *(void *)(a2 + 8));
      int v7 = *(char *)(a2 + 23);
      long long v8 = (const void *)language_modeling::v1::kClassLabelNumber;
      size_t v11 = strlen((const char *)language_modeling::v1::kClassLabelNumber);
      size_t v9 = v11;
      if ((v7 & 0x80000000) == 0)
      {
LABEL_11:
        if (v9 != -1)
        {
          int v12 = 0;
          size_t v13 = v7;
          unsigned int v14 = (const void *)a2;
          goto LABEL_13;
        }
LABEL_144:
        sub_19E3C4C28();
      }
      if (v11 == -1) {
        goto LABEL_144;
      }
      unsigned int v14 = *(const void **)a2;
      size_t v13 = *(void *)(a2 + 8);
      int v12 = 1;
LABEL_13:
      std::string v15 = (size_t *)((char *)__n + 1);
      if (v13 >= v9) {
        size_t v16 = v9;
      }
      else {
        size_t v16 = v13;
      }
      if (!memcmp(v14, v8, v16) && v13 == v9) {
        goto LABEL_30;
      }
      size_t v18 = strlen((const char *)language_modeling::v1::kClassLabelPluralNumber);
      size_t v19 = v18;
      if (v12)
      {
        if (v18 != -1)
        {
          uint64_t v20 = *(const void **)a2;
          size_t v21 = *(void *)(a2 + 8);
          goto LABEL_25;
        }
LABEL_145:
        sub_19E3C4C28();
      }
      if (v18 == -1) {
        goto LABEL_145;
      }
      size_t v21 = v7;
      uint64_t v20 = (const void *)a2;
LABEL_25:
      if (v21 >= v19) {
        size_t v22 = v19;
      }
      else {
        size_t v22 = v21;
      }
      if (!memcmp(v20, (const void *)language_modeling::v1::kClassLabelPluralNumber, v22) && v21 == v19)
      {
LABEL_30:
        if (SHIBYTE(v70) < 0)
        {
          __n[1] = 1;
          int v23 = (size_t *)__n[0];
          std::string v15 = (size_t *)(__n[0] + 1);
        }
        else
        {
          HIBYTE(v70) = 1;
          int v23 = __n;
        }
        char v24 = 57;
LABEL_34:
        *(unsigned char *)int v23 = v24;
        goto LABEL_35;
      }
      size_t v34 = strlen((const char *)language_modeling::v1::kClassLabelSingularNumber);
      size_t v35 = v34;
      if (v12)
      {
        if (v34 != -1)
        {
          unint64_t v36 = *(const void **)a2;
          size_t v37 = *(void *)(a2 + 8);
          goto LABEL_71;
        }
LABEL_146:
        sub_19E3C4C28();
      }
      if (v34 == -1) {
        goto LABEL_146;
      }
      size_t v37 = v7;
      unint64_t v36 = (const void *)a2;
LABEL_71:
      if (v37 >= v35) {
        size_t v39 = v35;
      }
      else {
        size_t v39 = v37;
      }
      if (!memcmp(v36, (const void *)language_modeling::v1::kClassLabelSingularNumber, v39) && v37 == v35)
      {
        if (SHIBYTE(v70) < 0)
        {
          __n[1] = 1;
          int v23 = (size_t *)__n[0];
          std::string v15 = (size_t *)(__n[0] + 1);
        }
        else
        {
          HIBYTE(v70) = 1;
          int v23 = __n;
        }
        char v24 = 49;
        goto LABEL_34;
      }
      size_t v40 = strlen((const char *)language_modeling::v1::kClassLabelPause);
      size_t v41 = v40;
      if (v12)
      {
        if (v40 != -1)
        {
          uint64_t v42 = *(const void **)a2;
          size_t v43 = *(void *)(a2 + 8);
          goto LABEL_86;
        }
LABEL_147:
        sub_19E3C4C28();
      }
      if (v40 == -1) {
        goto LABEL_147;
      }
      size_t v43 = v7;
      uint64_t v42 = (const void *)a2;
LABEL_86:
      if (v43 >= v41) {
        size_t v44 = v41;
      }
      else {
        size_t v44 = v43;
      }
      if (!memcmp(v42, (const void *)language_modeling::v1::kClassLabelPause, v44) && v43 == v41)
      {
        if (SHIBYTE(v70) < 0)
        {
          __n[1] = 3;
          uint64_t v45 = (size_t *)__n[0];
          std::string v15 = (size_t *)(__n[0] + 3);
        }
        else
        {
          std::string v15 = (size_t *)((char *)__n + 3);
          HIBYTE(v70) = 3;
          uint64_t v45 = __n;
        }
        *((unsigned char *)v45 + 2) = 46;
        *(_WORD *)uint64_t v45 = 11822;
        goto LABEL_35;
      }
      size_t v46 = strlen((const char *)language_modeling::v1::kClassLabelSentenceDelimiter);
      size_t v47 = v46;
      if (v12)
      {
        if (v46 != -1)
        {
          uint64_t v48 = *(const void **)a2;
          size_t v49 = *(void *)(a2 + 8);
          goto LABEL_100;
        }
LABEL_148:
        sub_19E3C4C28();
      }
      if (v46 == -1) {
        goto LABEL_148;
      }
      size_t v49 = v7;
      uint64_t v48 = (const void *)a2;
LABEL_100:
      if (v49 >= v47) {
        size_t v50 = v47;
      }
      else {
        size_t v50 = v49;
      }
      if (!memcmp(v48, (const void *)language_modeling::v1::kClassLabelSentenceDelimiter, v50) && v49 == v47)
      {
        if (SHIBYTE(v70) < 0)
        {
          __n[1] = 1;
          int v23 = (size_t *)__n[0];
          std::string v15 = (size_t *)(__n[0] + 1);
        }
        else
        {
          HIBYTE(v70) = 1;
          int v23 = __n;
        }
        char v24 = 46;
        goto LABEL_34;
      }
      size_t v51 = strlen((const char *)language_modeling::v1::kClassLabelReplacementCharacter);
      size_t v52 = v51;
      if (v12)
      {
        if (v51 != -1)
        {
          uint64_t v53 = *(const void **)a2;
          size_t v54 = *(void *)(a2 + 8);
          goto LABEL_114;
        }
LABEL_149:
        sub_19E3C4C28();
      }
      if (v51 == -1) {
        goto LABEL_149;
      }
      size_t v54 = v7;
      uint64_t v53 = (const void *)a2;
LABEL_114:
      if (v54 >= v52) {
        size_t v55 = v52;
      }
      else {
        size_t v55 = v54;
      }
      if (!memcmp(v53, (const void *)language_modeling::v1::kClassLabelReplacementCharacter, v55) && v54 == v52)
      {
        if ((SHIBYTE(v70) & 0x80000000) == 0)
        {
LABEL_120:
          HIBYTE(v70) = 0;
          std::string v15 = __n;
          goto LABEL_35;
        }
LABEL_137:
        __n[1] = 0;
        std::string v15 = (size_t *)__n[0];
        goto LABEL_35;
      }
      size_t v56 = strlen((const char *)language_modeling::v1::kClassLabelUsername);
      size_t v57 = v56;
      if (v12)
      {
        if (v56 != -1)
        {
          BOOL v58 = *(const void **)a2;
          size_t v59 = *(void *)(a2 + 8);
          goto LABEL_128;
        }
LABEL_150:
        sub_19E3C4C28();
      }
      if (v56 == -1) {
        goto LABEL_150;
      }
      size_t v59 = v7;
      BOOL v58 = (const void *)a2;
LABEL_128:
      if (v59 >= v57) {
        size_t v60 = v57;
      }
      else {
        size_t v60 = v59;
      }
      if (!memcmp(v58, (const void *)language_modeling::v1::kClassLabelUsername, v60) && v59 == v57)
      {
        if (SHIBYTE(v70) < 0)
        {
          __n[1] = 4;
          int v61 = (size_t *)__n[0];
          std::string v15 = (size_t *)(__n[0] + 4);
        }
        else
        {
          std::string v15 = (size_t *)((char *)__n + 4);
          HIBYTE(v70) = 4;
          int v61 = __n;
        }
        *(_DWORD *)int v61 = 1852337994;
      }
      else
      {
        if (std::string::compare((const std::string *)a2, (const std::string::value_type *)language_modeling::v1::kClassLabelLink))
        {
          if ((SHIBYTE(v70) & 0x80000000) == 0) {
            goto LABEL_120;
          }
          goto LABEL_137;
        }
        if (SHIBYTE(v70) < 0)
        {
          __n[1] = 7;
          CFIndex v62 = (size_t *)__n[0];
          std::string v15 = (size_t *)(__n[0] + 7);
        }
        else
        {
          std::string v15 = (size_t *)((char *)__n + 7);
          HIBYTE(v70) = 7;
          CFIndex v62 = __n;
        }
        *(_DWORD *)((char *)v62 + 3) = 1836016430;
        *(_DWORD *)CFIndex v62 = 779778424;
      }
LABEL_35:
      *(unsigned char *)std::string v15 = 0;
      unint64_t v25 = __n[1];
      if (v70 >= 0) {
        size_t v26 = HIBYTE(v70);
      }
      else {
        size_t v26 = __n[1];
      }
      uint64_t v27 = *(unsigned __int8 *)(a2 + 23);
      int v28 = (char)v27;
      unint64_t v29 = *(void *)(a2 + 8);
      if ((v27 & 0x80u) != 0) {
        uint64_t v27 = *(void *)(a2 + 8);
      }
      if (v26 == v27)
      {
        __int16 v30 = *(void **)a2;
        if (v28 >= 0) {
          BOOL v31 = (unsigned __int8 *)a2;
        }
        else {
          BOOL v31 = *(unsigned __int8 **)a2;
        }
        if (v70 < 0)
        {
          uint64_t v38 = (void *)__n[0];
          if (memcmp((const void *)__n[0], v31, __n[1])) {
            goto LABEL_57;
          }
        }
        else if (HIBYTE(v70))
        {
          unint64_t v32 = __n;
          uint64_t v33 = HIBYTE(v70);
          while (*(unsigned __int8 *)v32 == *v31)
          {
            unint64_t v32 = (size_t *)((char *)v32 + 1);
            ++v31;
            if (!--v33) {
              goto LABEL_65;
            }
          }
          goto LABEL_50;
        }
LABEL_65:
        if (v28 < 0)
        {
          sub_19E39369C(v63, v30, v29);
        }
        else
        {
          *(_OWORD *)unsigned __int8 v63 = *(_OWORD *)a2;
          uint64_t v64 = *(void *)(a2 + 16);
        }
        int v65 = *(_DWORD *)(a2 + 24);
        if ((SHIBYTE(v70) & 0x80000000) == 0) {
          goto LABEL_62;
        }
        goto LABEL_61;
      }
LABEL_50:
      if ((v70 & 0x8000000000000000) == 0)
      {
        *(_OWORD *)unint64_t __p = *(_OWORD *)__n;
        uint64_t v67 = v70;
        goto LABEL_58;
      }
      uint64_t v38 = (void *)__n[0];
LABEL_57:
      sub_19E39369C(__p, v38, v25);
LABEL_58:
      int v68 = 0;
      sub_19E371C70(v63, (const UInt8 *)__p);
      int v65 = v68;
      if (SHIBYTE(v67) < 0) {
        operator delete(__p[0]);
      }
      if ((SHIBYTE(v70) & 0x80000000) == 0) {
        goto LABEL_62;
      }
LABEL_61:
      operator delete((void *)__n[0]);
LABEL_62:
      sub_19E443044(a1, (uint64_t)v63, a3);
      if (SHIBYTE(v64) < 0) {
        operator delete(v63[0]);
      }
      return;
    default:
      sub_19E443044(a1, a2, a3);
      return;
  }
}

void sub_19E442FD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E443044(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E39369C(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)unint64_t __p = *(_OWORD *)a2;
    uint64_t v27 = *(void *)(a2 + 16);
  }
  int v23 = 0;
  char v24 = 0;
  uint64_t v25 = 0;
  if (v27 >= 0) {
    long long v5 = __p;
  }
  else {
    long long v5 = (void **)__p[0];
  }
  if (v27 >= 0) {
    uint64_t v6 = HIBYTE(v27);
  }
  else {
    uint64_t v6 = (uint64_t)__p[1];
  }
  sub_19E386A68(a1 + 128, (uint64_t)v5, v6, &v23, &v22);
  if (v22)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    sub_19E3AD800((uint64_t)&v22, &v21);
    if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v20 = &v21;
    }
    else {
      uint64_t v20 = (std::string *)v21.__r_.__value_.__r.__words[0];
    }
    MEMORY[0x19F3BD790](exception, v20);
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  sub_19E3AD4CC(&v22);
  int v7 = v23;
  long long v8 = v24;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  uint64_t v9 = v8 - v7;
  if (v8 == v7)
  {
LABEL_21:
    if (!v7) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  if (v9 < 0) {
    sub_19E37C7C4();
  }
  int v10 = operator new(v8 - v7);
  *a3 = v10;
  a3[2] = &v10[v9 >> 2];
  bzero(v10, v8 - v7);
  a3[1] = (char *)v10 + v9;
  if ((unint64_t)(v9 - 4) < 0x1C)
  {
    size_t v11 = v7;
    do
    {
LABEL_20:
      int v18 = *(_DWORD *)v11;
      v11 += 4;
      *v10++ = v18;
    }
    while (v11 != v8);
    goto LABEL_21;
  }
  size_t v11 = v7;
  if ((unint64_t)((char *)v10 - v7) < 0x20) {
    goto LABEL_20;
  }
  unint64_t v12 = ((unint64_t)(v9 - 4) >> 2) + 1;
  uint64_t v13 = 4 * (v12 & 0x7FFFFFFFFFFFFFF8);
  unsigned int v14 = (long long *)(v7 + 16);
  std::string v15 = v10 + 4;
  uint64_t v16 = v12 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    long long v17 = *v14;
    *(v15 - 1) = *(v14 - 1);
    *std::string v15 = v17;
    v14 += 2;
    v15 += 2;
    v16 -= 8;
  }
  while (v16);
  if (v12 != (v12 & 0x7FFFFFFFFFFFFFF8))
  {
    size_t v11 = &v7[v13];
    int v10 = (_DWORD *)((char *)v10 + v13);
    goto LABEL_20;
  }
LABEL_22:
  char v24 = v7;
  operator delete(v7);
LABEL_23:
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
}

void sub_19E44323C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (__p)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  _Unwind_Resume(exception_object);
}

void sub_19E4432E4(void *a1)
{
  *a1 = &unk_1EF0BA440;
  unint64_t v2 = (void *)a1[44];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  long long v4 = (void *)a1[42];
  a1[42] = 0;
  if (v4) {
    operator delete(v4);
  }
  *a1 = &unk_1EF0B9A98;
  long long v5 = (void *)a1[37];
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = (void *)a1[33];
  if (v6)
  {
    do
    {
      int v7 = (void *)*v6;
      operator delete(v6);
      uint64_t v6 = v7;
    }
    while (v7);
  }
  long long v8 = (void *)a1[31];
  a1[31] = 0;
  if (v8) {
    operator delete(v8);
  }
  sub_19E4433C0(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4433C0(void *a1)
{
  *a1 = &unk_1EF0BAB60;
  sub_19E382EFC((uint64_t)(a1 + 16));
  unint64_t v2 = (void *)a1[13];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  long long v4 = (void *)a1[11];
  a1[11] = 0;
  if (v4) {
    operator delete(v4);
  }
  long long v5 = (const void *)a1[7];
  if (v5) {
    CFRelease(v5);
  }
  a1[7] = 0;
  uint64_t v6 = a1[4];
  if (v6)
  {
    uint64_t v7 = a1[5];
    long long v8 = (void *)a1[4];
    if (v7 != v6)
    {
      do
      {
        if (*(char *)(v7 - 1) < 0) {
          operator delete(*(void **)(v7 - 24));
        }
        v7 -= 24;
      }
      while (v7 != v6);
      long long v8 = (void *)a1[4];
    }
    a1[5] = v6;
    operator delete(v8);
  }
  uint64_t v9 = a1[1];
  if (v9)
  {
    uint64_t v10 = a1[2];
    size_t v11 = (void *)a1[1];
    if (v10 != v9)
    {
      do
      {
        if (*(char *)(v10 - 1) < 0) {
          operator delete(*(void **)(v10 - 24));
        }
        v10 -= 24;
      }
      while (v10 != v9);
      size_t v11 = (void *)a1[1];
    }
    a1[2] = v9;
    operator delete(v11);
  }
  return a1;
}

void *sub_19E4434E8(void *a1)
{
  *a1 = &unk_1EF0BA440;
  unint64_t v2 = (void *)a1[44];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  long long v4 = (void *)a1[42];
  a1[42] = 0;
  if (v4) {
    operator delete(v4);
  }
  *a1 = &unk_1EF0B9A98;
  long long v5 = (void *)a1[37];
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = (void *)a1[33];
  if (v6)
  {
    do
    {
      uint64_t v7 = (void *)*v6;
      operator delete(v6);
      uint64_t v6 = v7;
    }
    while (v7);
  }
  long long v8 = (void *)a1[31];
  a1[31] = 0;
  if (v8) {
    operator delete(v8);
  }
  return sub_19E4433C0(a1);
}

void sub_19E4435B0(float *a1, unsigned int a2, int a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (uint64_t *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = operator new(0x18uLL);
  void *v13 = 0;
  v13[1] = v6;
  *((_DWORD *)v13 + 4) = a3;
  float v14 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v15 = a1[8];
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v6 = v3;
    goto LABEL_72;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v20 = operator new(8 * prime);
    std::string v21 = *(void **)a1;
    *(void *)a1 = v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v22++) = 0;
    while (prime != v22);
    char v24 = (uint64_t *)(a1 + 4);
    int v23 = (void *)*((void *)a1 + 2);
    if (!v23) {
      goto LABEL_59;
    }
    size_t v25 = v23[1];
    size_t v26 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v27 = v25 & v26;
      *(void *)(*(void *)a1 + 8 * v27) = v24;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v29 = i[1] & v26;
        if (v29 == v27)
        {
          int v23 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v29))
        {
          *int v23 = *i;
          uint64_t v30 = 8 * v29;
          void *i = **(void **)(*(void *)a1 + v30);
          **(void **)(*(void *)a1 + v30) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v29) = v23;
          int v23 = i;
          size_t v27 = v29;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v25 >= prime) {
      v25 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v25) = v24;
    size_t v34 = (void *)*v23;
    if (!*v23) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v36 = v34[1];
      if (v36 >= prime) {
        v36 %= prime;
      }
      if (v36 != v25)
      {
        if (!*(void *)(*(void *)a1 + 8 * v36))
        {
          *(void *)(*(void *)a1 + 8 * v36) = v23;
          goto LABEL_64;
        }
        *int v23 = *v34;
        uint64_t v35 = 8 * v36;
        *size_t v34 = **(void **)(*(void *)a1 + v35);
        **(void **)(*(void *)a1 + v35) = v34;
        size_t v34 = v23;
      }
      size_t v36 = v25;
LABEL_64:
      int v23 = v34;
      size_t v34 = (void *)*v34;
      size_t v25 = v36;
      if (!v34) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v31 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
  if (v7 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
  {
    unint64_t v31 = std::__next_prime(v31);
  }
  else
  {
    uint64_t v33 = 1 << -(char)__clz(v31 - 1);
    if (v31 >= 2) {
      unint64_t v31 = v33;
    }
  }
  if (prime <= v31) {
    size_t prime = v31;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      size_t v40 = *(void **)a1;
      *(void *)a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = *((void *)a1 + 1);
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_72:
  size_t v37 = *(void **)a1;
  uint64_t v38 = *(void **)(*(void *)a1 + 8 * v6);
  if (v38)
  {
    void *v13 = *v38;
LABEL_80:
    *uint64_t v38 = v13;
    goto LABEL_81;
  }
  void *v13 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v13;
  v37[v6] = a1 + 4;
  if (*v13)
  {
    unint64_t v39 = *(void *)(*v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v39 >= v7) {
        v39 %= v7;
      }
    }
    else
    {
      v39 &= v7 - 1;
    }
    uint64_t v38 = (void *)(*(void *)a1 + 8 * v39);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
}

void sub_19E4439FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_19E443A10(unint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, std::string::value_type *a5, char *a6, char *a7, unint64_t a8, std::string::value_type *a9)
{
  uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
  uint64_t v12 = *(char **)a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if ((v11 & 0x80u) == 0) {
    uint64_t v13 = (char *)a2;
  }
  else {
    uint64_t v13 = v12;
  }
  *(void *)a1 = 0;
  if (a6 == a7)
  {
    uint64_t v33 = 0;
    unint64_t v32 = 0;
    unsigned int v31 = 0;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a2 + 8);
    }
    uint64_t v20 = v13;
  }
  else
  {
    float v15 = a7;
    uint64_t v20 = v13;
    while (1)
    {
      uint64_t v21 = *(unsigned __int8 *)(a1 + 23);
      if ((v21 & 0x80u) == 0) {
        unint64_t v22 = a1;
      }
      else {
        unint64_t v22 = *(void *)a1;
      }
      if ((v21 & 0x80u) != 0) {
        uint64_t v21 = *(void *)(a1 + 8);
      }
      sub_19E443C00(a1, v22 + v21, v20, a6, a6 - v20);
      uint64_t v23 = *(unsigned __int8 *)(a1 + 23);
      if ((v23 & 0x80u) == 0) {
        unint64_t v24 = a1;
      }
      else {
        unint64_t v24 = *(void *)a1;
      }
      if ((v23 & 0x80u) != 0) {
        uint64_t v23 = *(void *)(a1 + 8);
      }
      sub_19E443D84((unint64_t *)a1, v24 + v23, a8, a9, (unint64_t)&a9[-a8]);
      uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
      if ((v11 & 0x80u) == 0) {
        uint64_t v13 = (char *)a2;
      }
      else {
        uint64_t v13 = *(char **)a2;
      }
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a2 + 8);
      }
      size_t v25 = &v13[v11];
      if (v15 == &v13[v11]) {
        break;
      }
      uint64_t v26 = *a3;
      uint64_t v27 = a3[1];
      if (*a3 == v27) {
        break;
      }
      a6 = v15;
      while (1)
      {
        uint64_t v28 = 0;
        do
        {
          if (a6[v28] != *(unsigned char *)(v26 + v28)) {
            break;
          }
          if (&a6[++v28] == v25) {
            break;
          }
        }
        while (v28 + v26 != v27);
        uint64_t v29 = v26 + v28;
        uint64_t v30 = &a6[v28];
        if (v29 == v27) {
          break;
        }
        if (++a6 == v25) {
          goto LABEL_34;
        }
      }
      uint64_t v20 = v15;
      float v15 = v30;
      if (a6 == v30) {
        goto LABEL_35;
      }
      a9 = a5;
      a8 = a4;
    }
LABEL_34:
    uint64_t v20 = v15;
LABEL_35:
    unsigned int v31 = *(unsigned __int8 *)(a1 + 23);
    unint64_t v32 = *(void *)a1;
    uint64_t v33 = *(void *)(a1 + 8);
  }
  if ((v31 & 0x80u) == 0)
  {
    unint64_t v32 = a1;
    uint64_t v33 = v31;
  }
  sub_19E443C00(a1, v32 + v33, v20, &v13[v11], &v13[v11] - v20);
}

void sub_19E443BE0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E443C00(unint64_t a1, uint64_t a2, char *a3, char *a4, unint64_t a5)
{
  unint64_t v7 = a3;
  if (*(char *)(a1 + 23) < 0)
  {
    if (!a5) {
      return;
    }
    unint64_t v10 = *(void *)a1;
    uint64_t v9 = *(void *)(a1 + 8);
  }
  else
  {
    if (!a5) {
      return;
    }
    uint64_t v9 = *(unsigned __int8 *)(a1 + 23);
    unint64_t v10 = a1;
  }
  size_t v11 = a2 - v10;
  if (v10 > (unint64_t)a3 || v10 + v9 + 1 <= (unint64_t)a3)
  {
    sub_19E44412C((void *)a1, a5, v11, a3, a4);
  }
  else
  {
    memset(&v16, 0, sizeof(v16));
    if (a3 == a4)
    {
      std::string::size_type size = 0;
      std::string::size_type v14 = 0;
      unsigned int v12 = 0;
    }
    else
    {
      do
        std::string::push_back(&v16, *v7++);
      while (v7 != a4);
      unsigned int v12 = HIBYTE(v16.__r_.__value_.__r.__words[2]);
      std::string::size_type size = v16.__r_.__value_.__l.__size_;
      std::string::size_type v14 = v16.__r_.__value_.__r.__words[0];
    }
    if ((v12 & 0x80u) == 0) {
      float v15 = &v16;
    }
    else {
      float v15 = (std::string *)v14;
    }
    if ((v12 & 0x80u) == 0) {
      std::string::size_type size = v12;
    }
    sub_19E44412C((void *)a1, a5, v11, (char *)v15, (char *)v15 + size);
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
  }
}

void sub_19E443D38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E443D84(unint64_t *a1, uint64_t a2, unint64_t a3, std::string::value_type *a4, unint64_t a5)
{
  unint64_t v7 = (std::string::value_type *)a3;
  LODWORD(v9) = *((char *)a1 + 23);
  if ((v9 & 0x80000000) == 0)
  {
    if (!a5) {
      return;
    }
    size_t v10 = *((unsigned __int8 *)a1 + 23);
    size_t v11 = a2 - (void)a1;
    if ((unint64_t)a1 > a3 || (unint64_t)a1 + v10 + 1 <= a3)
    {
      if (22 - v10 < a5)
      {
        unint64_t v12 = v10 + a5;
        if (v10 + a5 - 0x7FFFFFFFFFFFFFF8 >= 0x800000000000001ELL)
        {
          unint64_t v13 = 22;
          std::string::size_type v14 = (char *)a1;
          goto LABEL_16;
        }
        goto LABEL_67;
      }
      uint64_t v21 = a1;
      goto LABEL_43;
    }
LABEL_30:
    memset(&v42, 0, sizeof(v42));
    if ((std::string::value_type *)a3 == a4)
    {
      std::string::size_type size = 0;
      std::string::size_type v25 = 0;
      unsigned int v23 = 0;
    }
    else
    {
      do
        std::string::push_back(&v42, *v7++);
      while (v7 != a4);
      unsigned int v23 = HIBYTE(v42.__r_.__value_.__r.__words[2]);
      std::string::size_type size = v42.__r_.__value_.__l.__size_;
      std::string::size_type v25 = v42.__r_.__value_.__r.__words[0];
    }
    if ((v23 & 0x80u) == 0) {
      uint64_t v26 = &v42;
    }
    else {
      uint64_t v26 = (std::string *)v25;
    }
    if ((v23 & 0x80u) == 0) {
      std::string::size_type size = v23;
    }
    sub_19E44412C(a1, a5, v11, (char *)v26, (char *)v26 + size);
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v42.__r_.__value_.__l.__data_);
    }
    return;
  }
  if (!a5) {
    return;
  }
  size_t v11 = a2 - *a1;
  if (*a1 <= a3 && *a1 + a1[1] + 1 > a3) {
    goto LABEL_30;
  }
  size_t v10 = a1[1];
  unint64_t v16 = a1[2];
  uint64_t v17 = v16 & 0x7FFFFFFFFFFFFFFFLL;
  unint64_t v13 = (v16 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v13 - v10 < a5)
  {
    unint64_t v12 = v10 + a5;
    if (0x7FFFFFFFFFFFFFF8 - v17 >= v10 + a5 - v13)
    {
      std::string::size_type v14 = (char *)*a1;
      if (v13 > 0x3FFFFFFFFFFFFFF2)
      {
        size_t v19 = 0x7FFFFFFFFFFFFFF7;
LABEL_23:
        uint64_t v20 = operator new(v19);
        uint64_t v21 = v20;
        if (v11) {
          memmove(v20, v14, v11);
        }
        if (v10 != v11) {
          memmove(&v21[v11 + a5], &v14[v11], v10 - v11);
        }
        if (v13 != 22) {
          operator delete(v14);
        }
        *a1 = (unint64_t)v21;
        a1[2] = v19 | 0x8000000000000000;
        size_t v22 = v10 + a5;
LABEL_47:
        a1[1] = v22;
        goto LABEL_48;
      }
LABEL_16:
      if (v12 <= 2 * v13) {
        unint64_t v12 = 2 * v13;
      }
      uint64_t v18 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17) {
        uint64_t v18 = v12 | 7;
      }
      if (v12 >= 0x17) {
        size_t v19 = v18 + 1;
      }
      else {
        size_t v19 = 23;
      }
      goto LABEL_23;
    }
LABEL_67:
    sub_19E37C958();
  }
  unint64_t v9 = HIBYTE(v16);
  uint64_t v21 = (unsigned char *)*a1;
LABEL_43:
  size_t v27 = v11;
  if (v10 != v11)
  {
    memmove(&v21[v11 + a5], &v21[v11], v10 - v11);
    LOBYTE(v9) = *((unsigned char *)a1 + 23);
    size_t v27 = v10;
  }
  size_t v22 = v27 + a5;
  if ((v9 & 0x80) != 0) {
    goto LABEL_47;
  }
  *((unsigned char *)a1 + 23) = v22 & 0x7F;
LABEL_48:
  v21[v22] = 0;
  if (v7 == a4) {
    return;
  }
  uint64_t v28 = &v21[v11];
  unint64_t v29 = a4 - v7;
  if ((unint64_t)(a4 - v7) < 8)
  {
    uint64_t v30 = v7;
    goto LABEL_65;
  }
  if ((unint64_t)(&v21[v11] - v7) < 0x20)
  {
    uint64_t v30 = v7;
    goto LABEL_65;
  }
  if (v29 >= 0x20)
  {
    unint64_t v31 = v29 & 0xFFFFFFFFFFFFFFE0;
    unint64_t v32 = &v21[v11 + 16];
    uint64_t v33 = (long long *)(v7 + 16);
    unint64_t v34 = v29 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      long long v35 = *v33;
      *(v32 - 1) = *(v33 - 1);
      *unint64_t v32 = v35;
      v32 += 2;
      v33 += 2;
      v34 -= 32;
    }
    while (v34);
    if (v29 == v31) {
      return;
    }
    if ((v29 & 0x18) == 0)
    {
      v28 += v31;
      uint64_t v30 = &v7[v31];
      do
      {
LABEL_65:
        char v41 = *v30++;
        *v28++ = v41;
      }
      while (v30 != a4);
      return;
    }
  }
  else
  {
    unint64_t v31 = 0;
  }
  unint64_t v36 = v29 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v30 = &v7[v29 & 0xFFFFFFFFFFFFFFF8];
  unint64_t v37 = v31 - (v29 & 0xFFFFFFFFFFFFFFF8);
  uint64_t v38 = &v21[v11 + v31];
  unint64_t v39 = &v7[v31];
  do
  {
    uint64_t v40 = *(void *)v39;
    v39 += 8;
    *v38++ = v40;
    v37 += 8;
  }
  while (v37);
  if (v29 != v36)
  {
    v28 += v36;
    goto LABEL_65;
  }
}

void sub_19E4440E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

size_t sub_19E44412C(void *a1, unint64_t a2, size_t a3, char *a4, char *a5)
{
  unint64_t v9 = a1;
  LODWORD(v10) = *((char *)a1 + 23);
  if ((v10 & 0x80000000) != 0)
  {
    size_t v11 = a1[1];
    unint64_t v15 = a1[2];
    uint64_t v16 = v15 & 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v13 = (v15 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v13 - v11 < a2)
    {
      unint64_t v12 = v11 + a2;
      if (0x7FFFFFFFFFFFFFF8 - v16 >= v11 + a2 - v13)
      {
        std::string::size_type v14 = (char *)*a1;
        if (v13 > 0x3FFFFFFFFFFFFFF2)
        {
          size_t v18 = 0x7FFFFFFFFFFFFFF7;
LABEL_15:
          size_t v19 = (char *)operator new(v18);
          uint64_t v20 = v19;
          if (a3) {
            memmove(v19, v14, a3);
          }
          if (v11 != a3) {
            memmove(&v20[a3 + a2], &v14[a3], v11 - a3);
          }
          if (v13 != 22) {
            operator delete(v14);
          }
          *unint64_t v9 = v20;
          _OWORD v9[2] = v18 | 0x8000000000000000;
          size_t v21 = v11 + a2;
          goto LABEL_28;
        }
LABEL_8:
        if (v12 <= 2 * v13) {
          unint64_t v12 = 2 * v13;
        }
        uint64_t v17 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v17 = v12 | 7;
        }
        if (v12 >= 0x17) {
          size_t v18 = v17 + 1;
        }
        else {
          size_t v18 = 23;
        }
        goto LABEL_15;
      }
LABEL_48:
      sub_19E37C958();
    }
    unint64_t v10 = HIBYTE(v15);
    uint64_t v20 = (char *)*a1;
  }
  else
  {
    size_t v11 = *((unsigned __int8 *)a1 + 23);
    if (22 - v11 < a2)
    {
      unint64_t v12 = v11 + a2;
      if (v11 + a2 - 0x7FFFFFFFFFFFFFF8 >= 0x800000000000001ELL)
      {
        unint64_t v13 = 22;
        std::string::size_type v14 = (char *)a1;
        goto LABEL_8;
      }
      goto LABEL_48;
    }
    uint64_t v20 = (char *)a1;
  }
  size_t v22 = a3;
  size_t v23 = v11 - a3;
  if (v11 != a3)
  {
    memmove(&v20[a3 + a2], &v20[a3], v23);
    LOBYTE(v10) = *((unsigned char *)v9 + 23);
    size_t v22 = v11;
  }
  size_t v21 = v22 + a2;
  if ((v10 & 0x80) == 0)
  {
    *((unsigned char *)v9 + 23) = v21 & 0x7F;
    goto LABEL_29;
  }
LABEL_28:
  v9[1] = v21;
LABEL_29:
  v20[v21] = 0;
  if (a4 == a5) {
    goto LABEL_45;
  }
  unint64_t v24 = &v20[a3];
  unint64_t v25 = a5 - a4;
  if ((unint64_t)(a5 - a4) < 8 || (unint64_t)(v24 - a4) < 0x20) {
    goto LABEL_44;
  }
  if (v25 >= 0x20)
  {
    unint64_t v26 = v25 & 0xFFFFFFFFFFFFFFE0;
    size_t v27 = (long long *)(a4 + 16);
    uint64_t v28 = &v20[a3 + 16];
    unint64_t v29 = v25 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      long long v30 = *v27;
      *((_OWORD *)v28 - 1) = *(v27 - 1);
      *(_OWORD *)uint64_t v28 = v30;
      v27 += 2;
      v28 += 32;
      v29 -= 32;
    }
    while (v29);
    if (v25 == v26) {
      goto LABEL_45;
    }
    if ((v25 & 0x18) == 0)
    {
      a4 += v26;
      v24 += v26;
      do
      {
LABEL_44:
        char v36 = *a4++;
        *v24++ = v36;
      }
      while (a4 != a5);
      goto LABEL_45;
    }
  }
  else
  {
    unint64_t v26 = 0;
  }
  unint64_t v31 = v25 & 0xFFFFFFFFFFFFFFF8;
  v24 += v25 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v32 = v26 - (v25 & 0xFFFFFFFFFFFFFFF8);
  uint64_t v33 = (uint64_t *)&a4[v26];
  unint64_t v34 = &v20[v26 + a3];
  do
  {
    uint64_t v35 = *v33++;
    *(void *)unint64_t v34 = v35;
    v34 += 8;
    v32 += 8;
  }
  while (v32);
  if (v25 != v31)
  {
    a4 += v31;
    goto LABEL_44;
  }
LABEL_45:
  if (*((char *)v9 + 23) < 0) {
    unint64_t v9 = (void *)*v9;
  }
  return (size_t)v9 + a3;
}

double sub_19E4443C0@<D0>(uint64_t a1@<X8>)
{
  unint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)a1 = v2;
  *(_OWORD *)(a1 + 8) = xmmword_19E573070;
  strcpy(v2, "Beam Search V1 (Length Normalized Prediction Queue)");
  return *(double *)"d Prediction Queue)";
}

int64_t sub_19E444420@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  int64_t result = v3 - *a1;
  if (v3 != *a1)
  {
    unint64_t v6 = 0x86BCA1AF286BCA1BLL * (result >> 4);
    if (v6 >= 0xD79435E50D7944) {
      sub_19E37C7C4();
    }
    unint64_t v7 = (char *)operator new(result);
    uint64_t v8 = 0;
    *a2 = v7;
    a2[1] = v7;
    a2[2] = &v7[304 * v6];
    do
    {
      int64_t result = sub_19E444550((uint64_t)&v7[v8], v2 + v8);
      v8 += 304;
    }
    while (v2 + v8 != v3);
    a2[1] = &v7[v8];
  }
  return result;
}

void sub_19E4444E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = 0;
  long long v4 = *v1;
  if (*v1)
  {
    do
    {
      v3 -= 304;
      sub_19E4446FC(v3);
    }
    while ((void *)v3 != v4);
    long long v5 = *v1;
    v1[1] = v4;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E444550(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  long long v5 = *(const void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  int64_t v6 = v4 - *(void *)a2;
  if (v4 != *(void *)a2)
  {
    if (v6 < 0) {
      sub_19E37C7C4();
    }
    unint64_t v7 = (char *)operator new(v4 - *(void *)a2);
    *(void *)a1 = v7;
    *(void *)(a1 + 8) = v7;
    uint64_t v8 = &v7[4 * (v6 >> 2)];
    *(void *)(a1 + 16) = v8;
    memcpy(v7, v5, v6);
    *(void *)(a1 + 8) = v8;
  }
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_19E39369C((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v9;
  }
  sub_19E3C36C4(a1 + 56, a2 + 56);
  sub_19E444868((void *)(a1 + 240), a2 + 240);
  uint64_t v10 = *(void *)(a2 + 264);
  *(_DWORD *)(a1 + 272) = *(_DWORD *)(a2 + 272);
  *(void *)(a1 + 264) = v10;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 280) = 0;
  unint64_t v12 = *(unsigned char **)(a2 + 280);
  size_t v11 = *(unsigned char **)(a2 + 288);
  int64_t v13 = v11 - v12;
  if (v11 != v12)
  {
    if (v13 < 0) {
      sub_19E37C7C4();
    }
    std::string::size_type v14 = (char *)operator new(v11 - v12);
    *(void *)(a1 + 280) = v14;
    *(void *)(a1 + 288) = v14;
    unint64_t v15 = &v14[4 * (v13 >> 2)];
    *(void *)(a1 + 296) = v15;
    memcpy(v14, v12, v13);
    *(void *)(a1 + 288) = v15;
  }
  return a1;
}

void sub_19E444694(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E4446FC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 280);
  if (v2)
  {
    *(void *)(a1 + 288) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void *)(a1 + 240);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 248);
    long long v5 = *(void **)(a1 + 240);
    if (v4 != v3)
    {
      do
      {
        int64_t v6 = *(std::__shared_weak_count **)(v4 - 16);
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        v4 -= 24;
      }
      while (v4 != v3);
      long long v5 = *(void **)(a1 + 240);
    }
    *(void *)(a1 + 248) = v3;
    operator delete(v5);
  }
  sub_19E3C3D24((void **)(a1 + 56));
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    unint64_t v7 = *(void **)a1;
    if (!*(void *)a1) {
      return a1;
    }
    goto LABEL_14;
  }
  unint64_t v7 = *(void **)a1;
  if (*(void *)a1)
  {
LABEL_14:
    *(void *)(a1 + 8) = v7;
    operator delete(v7);
  }
  return a1;
}

void ***sub_19E4447F4(void ***a1)
{
  if (!*((unsigned char *)a1 + 8))
  {
    uint64_t v2 = *a1;
    uint64_t v3 = **a1;
    if (v3)
    {
      uint64_t v4 = (uint64_t)v2[1];
      long long v5 = **a1;
      if ((void *)v4 != v3)
      {
        do
          uint64_t v4 = sub_19E4446FC(v4 - 304);
        while ((void *)v4 != v3);
        long long v5 = **a1;
      }
      v2[1] = v3;
      operator delete(v5);
    }
  }
  return a1;
}

void *sub_19E444868(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v3 = *(void **)a2;
  uint64_t v4 = *(void **)(a2 + 8);
  int64_t v5 = (int64_t)v4 - *(void *)a2;
  if (v4 != *(void **)a2)
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * (v5 >> 3);
    if (v6 >= 0xAAAAAAAAAAAAAABLL) {
      sub_19E37C7C4();
    }
    unint64_t v7 = operator new(v5);
    *a1 = v7;
    a1[1] = v7;
    a1[2] = &v7[3 * v6];
    do
    {
      uint64_t v8 = v3[1];
      *unint64_t v7 = *v3;
      v7[1] = v8;
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      void v7[2] = v3[2];
      v7 += 3;
      v3 += 3;
    }
    while (v3 != v4);
    a1[1] = v7;
  }
  return a1;
}

void sub_19E44492C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (char *)*v1;
  if (*v1)
  {
    uint64_t v4 = (char *)v1[1];
    int64_t v5 = *v1;
    if (v4 != v3)
    {
      do
      {
        unint64_t v6 = (std::__shared_weak_count *)*((void *)v4 - 2);
        if (v6)
        {
          if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
        }
        v4 -= 24;
      }
      while (v4 != v3);
      int64_t v5 = *v1;
    }
    v1[1] = v3;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void **sub_19E4449B8(void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        int64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 2);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void sub_19E444A6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(void **)a3;
  if (0xD37A6F4DE9BD37A7 * ((uint64_t)(*(void *)(a3 + 8) - (void)v7) >> 3) >= 2) {
    __assert_rtn("_completions", "MultiWordBeamSearchPredictor.cpp", 473, "stems.size()<2");
  }
  if (byte_1E9459939)
  {
    sub_19E4E1EBC((void *)(a1 + 72), (uint64_t *)(a1 + 208), v7, a4);
    if (v9 > 0.0001) {
      __assert_rtn("_completions", "MultiWordBeamSearchPredictor.cpp", 478, "prefixProbabilityFirstWord<=1e-4");
    }
  }
  if (a7)
  {
    if (qword_1E9459E20 != -1) {
      dispatch_once(&qword_1E9459E20, &unk_1EF0BEC20);
    }
    uint64_t v10 = qword_1E9459E18;
    if (os_log_type_enabled((os_log_t)qword_1E9459E18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      size_t v11 = "Starting Inline Completions Beam Search in Lexicon Constrained Prediction Mode";
LABEL_14:
      _os_log_impl(&dword_19E36B000, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 2u);
    }
  }
  else
  {
    if (qword_1E9459E20 != -1) {
      dispatch_once(&qword_1E9459E20, &unk_1EF0BEC20);
    }
    uint64_t v10 = qword_1E9459E18;
    if (os_log_type_enabled((os_log_t)qword_1E9459E18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      size_t v11 = "Starting Inline Completions Beam Search in Open Ended Prediction Mode";
      goto LABEL_14;
    }
  }
  operator new();
}

void sub_19E447128(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_19E37B770(a1);
}

void sub_19E447338()
{
  if (STACK[0x578])
  {
    STACK[0x580] = STACK[0x578];
    JUMPOUT(0x19E4477A0);
  }
  JUMPOUT(0x19E4477A4);
}

void sub_19E44734C()
{
}

void sub_19E447354(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
}

void sub_19E447364(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,uint64_t a56,void *a57)
{
}

void sub_19E4473FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  if (a62 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x19E447430);
}

void sub_19E447438(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
}

void sub_19E447454()
{
  if (!STACK[0x2D0])
  {
    if (!STACK[0x548])
    {
      if (!STACK[0x560])
      {
        if (STACK[0x578]) {
          operator delete((void *)STACK[0x578]);
        }
        sub_19E4446FC((uint64_t)&STACK[0x590]);
        JUMPOUT(0x19E4477ACLL);
      }
      JUMPOUT(0x19E4477E0);
    }
    JUMPOUT(0x19E4477D4);
  }
  JUMPOUT(0x19E4476D4);
}

void sub_19E4474F8()
{
}

void sub_19E447508(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  if (a62 < 0) {
    JUMPOUT(0x19E4476C4);
  }
  JUMPOUT(0x19E4476B0);
}

void sub_19E447520(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  if (a62 < 0) {
    operator delete(__p);
  }
  CFIndex v62 = (void *)STACK[0x2B8];
  if (STACK[0x2B8])
  {
    unint64_t v63 = STACK[0x2C0];
    if ((void *)STACK[0x2C0] != v62)
    {
      do
      {
        uint64_t v64 = *(std::__shared_weak_count **)(v63 - 16);
        if (v64 && !atomic_fetch_add(&v64->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
        v63 -= 24;
      }
      while ((void *)v63 != v62);
      CFIndex v62 = (void *)STACK[0x2B8];
    }
    operator delete(v62);
  }
  sub_19E4446FC((uint64_t)&STACK[0x2D0]);
  sub_19E4446FC((uint64_t)&STACK[0x400]);
  if (SLOBYTE(STACK[0x547]) < 0) {
    operator delete((void *)STACK[0x530]);
  }
  if (!STACK[0x548])
  {
    if (!STACK[0x560])
    {
      if (STACK[0x578]) {
        operator delete((void *)STACK[0x578]);
      }
      sub_19E4446FC((uint64_t)&STACK[0x590]);
      JUMPOUT(0x19E4477ACLL);
    }
    JUMPOUT(0x19E4477E0);
  }
  JUMPOUT(0x19E4477D4);
}

void sub_19E447570()
{
}

void sub_19E447578()
{
  if (!v0) {
    JUMPOUT(0x19E4475ECLL);
  }
  JUMPOUT(0x19E4475ACLL);
}

void sub_19E447600(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62,uint64_t a63)
{
  if (a62 < 0) {
    operator delete(__p);
  }
  if (a56 < 0) {
    operator delete(a51);
  }
  sub_19E3D73EC((uint64_t)&a48);
  sub_19E4446FC((uint64_t)&a63);
  unint64_t v63 = (void *)STACK[0x2B8];
  if (STACK[0x2B8])
  {
    unint64_t v64 = STACK[0x2C0];
    if ((void *)STACK[0x2C0] != v63)
    {
      do
      {
        int v65 = *(std::__shared_weak_count **)(v64 - 16);
        if (v65 && !atomic_fetch_add(&v65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
          std::__shared_weak_count::__release_weak(v65);
        }
        v64 -= 24;
      }
      while ((void *)v64 != v63);
      unint64_t v63 = (void *)STACK[0x2B8];
    }
    operator delete(v63);
  }
  sub_19E4446FC((uint64_t)&STACK[0x2D0]);
  sub_19E4446FC((uint64_t)&STACK[0x400]);
  if (SLOBYTE(STACK[0x547]) < 0) {
    operator delete((void *)STACK[0x530]);
  }
  if (STACK[0x548])
  {
    operator delete((void *)STACK[0x548]);
    char v66 = (void *)STACK[0x560];
    if (!STACK[0x560])
    {
LABEL_18:
      uint64_t v67 = (void *)STACK[0x578];
      if (!STACK[0x578])
      {
LABEL_20:
        sub_19E4446FC((uint64_t)&STACK[0x590]);
        JUMPOUT(0x19E4477ACLL);
      }
LABEL_19:
      operator delete(v67);
      goto LABEL_20;
    }
  }
  else
  {
    char v66 = (void *)STACK[0x560];
    if (!STACK[0x560]) {
      goto LABEL_18;
    }
  }
  STACK[0x568] = (unint64_t)v66;
  operator delete(v66);
  uint64_t v67 = (void *)STACK[0x578];
  if (!STACK[0x578]) {
    goto LABEL_20;
  }
  goto LABEL_19;
}

void sub_19E44763C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  sub_19E3D73EC((uint64_t)&STACK[0x400]);
  if (a54) {
    (*(void (**)(uint64_t))(*(void *)a54 + 8))(a54);
  }
  sub_19E4449B8((void **)&STACK[0x2B8]);
  if (SLOBYTE(STACK[0x547]) < 0)
  {
    operator delete((void *)STACK[0x530]);
    if ((a62 & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  else if ((a62 & 0x80000000) == 0)
  {
LABEL_5:
    unint64_t v62 = STACK[0x2D0];
    if (!STACK[0x2D0]) {
LABEL_10:
    }
      JUMPOUT(0x19E447788);
LABEL_9:
    STACK[0x2D8] = v62;
    JUMPOUT(0x19E447784);
  }
  operator delete(a57);
  unint64_t v62 = STACK[0x2D0];
  if (!STACK[0x2D0]) {
    goto LABEL_10;
  }
  goto LABEL_9;
}

void sub_19E4476DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46)
{
}

void sub_19E4477F4(uint64_t a1, uint64_t a2, char a3)
{
  if (a3) {
    sub_19E3FC4DC(*(void *)(a2 + 104));
  }
  uint64_t v3 = *(void *)(a2 + 104);
  memset(buf, 0, sizeof(buf));
  unint64_t v11 = 0;
  uint64_t v4 = *(void *)(v3 + 208);
  uint64_t v5 = *(void *)(v3 + 216);
  if (v4 != v5)
  {
    unint64_t v6 = 0;
    do
    {
      (*(void (**)(uint64_t *__return_ptr))(**(void **)v4 + 56))(&v9);
      if ((unint64_t)v6 >= v11)
      {
        unint64_t v6 = sub_19E415068(buf, &v9);
      }
      else
      {
        uint64_t v7 = v9;
        uint64_t v9 = 0;
        *v6++ = v7;
      }
      *(void *)&uint8_t buf[8] = v6;
      uint64_t v8 = v9;
      uint64_t v9 = 0;
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      }
      v4 += 8;
    }
    while (v4 != v5);
  }
  operator new();
}

void sub_19E447A50(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_19E447ABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  JUMPOUT(0x19E447AF8);
}

void sub_19E447B08(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(unsigned char **)a1;
  if (0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) >= a2) {
    return;
  }
  if (a2 >= 0xD79435E50D7944) {
    sub_19E37C7C4();
  }
  uint64_t v4 = *(unsigned char **)(a1 + 8);
  uint64_t v5 = 304 * a2;
  unint64_t v6 = (char *)operator new(304 * a2);
  uint64_t v7 = &v6[v5];
  uint64_t v8 = &v6[v4 - v2];
  if (v4 == v2)
  {
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 16) = v7;
    if (!v2) {
      return;
    }
    goto LABEL_9;
  }
  uint64_t v9 = 0;
  do
  {
    uint64_t v10 = &v8[v9];
    unint64_t v11 = &v4[v9];
    uint64_t v12 = (uint64_t)&v4[v9 - 304];
    *(_OWORD *)&v8[v9 - 304] = *(_OWORD *)v12;
    *(void *)&v8[v9 - 288] = *(void *)&v4[v9 - 288];
    *(void *)&v4[v9 - 296] = 0;
    *(void *)uint64_t v12 = 0;
    *(void *)(v12 + 16) = 0;
    *(void *)&v8[v9 - 280] = *(void *)&v4[v9 - 280];
    uint64_t v13 = (uint64_t)&v4[v9 - 272];
    long long v14 = *(_OWORD *)v13;
    *((void *)v10 - 32) = *(void *)&v4[v9 - 256];
    *(_OWORD *)&v8[v9 - 272] = v14;
    *((void *)v11 - 32) = 0;
    *(void *)uint64_t v13 = 0;
    *(void *)(v13 + 8) = 0;
    *(_OWORD *)(v10 - 248) = *(_OWORD *)&v4[v9 - 248];
    *((void *)v10 - 29) = *(void *)&v4[v9 - 232];
    *((void *)v11 - 31) = 0;
    *((void *)v11 - 30) = 0;
    *((void *)v11 - 29) = 0;
    *((_OWORD *)v10 - 14) = *(_OWORD *)&v4[v9 - 224];
    *((void *)v10 - 26) = *(void *)&v4[v9 - 208];
    *((void *)v11 - 28) = 0;
    *((void *)v11 - 27) = 0;
    *((void *)v11 - 26) = 0;
    *(_OWORD *)(v10 - 200) = *(_OWORD *)&v4[v9 - 200];
    *((void *)v10 - 23) = *(void *)&v4[v9 - 184];
    *((void *)v11 - 25) = 0;
    *((void *)v11 - 24) = 0;
    *((void *)v11 - 23) = 0;
    *((_OWORD *)v10 - 11) = *(_OWORD *)&v4[v9 - 176];
    *((void *)v10 - 20) = *(void *)&v4[v9 - 160];
    *((void *)v11 - 22) = 0;
    *((void *)v11 - 21) = 0;
    *((void *)v11 - 20) = 0;
    *(_OWORD *)(v10 - 152) = *(_OWORD *)&v4[v9 - 152];
    *((void *)v10 - 17) = *(void *)&v4[v9 - 136];
    *((void *)v11 - 19) = 0;
    *((void *)v11 - 18) = 0;
    long long v15 = *(_OWORD *)&v4[v9 - 128];
    *((void *)v11 - 17) = 0;
    *((_OWORD *)v10 - 8) = v15;
    *((_OWORD *)v10 - 7) = *(_OWORD *)&v4[v9 - 112];
    *((void *)v10 - 12) = *(void *)&v4[v9 - 96];
    *((void *)v11 - 14) = 0;
    *((void *)v11 - 13) = 0;
    *((void *)v11 - 12) = 0;
    *(_OWORD *)(v10 - 88) = *(_OWORD *)&v4[v9 - 88];
    *((void *)v10 - 9) = *(void *)&v4[v9 - 72];
    *((void *)v11 - 11) = 0;
    *((void *)v11 - 10) = 0;
    *((void *)v11 - 9) = 0;
    *((_OWORD *)v10 - 4) = *(_OWORD *)&v4[v9 - 64];
    *((void *)v10 - 6) = *(void *)&v4[v9 - 48];
    *((void *)v11 - 8) = 0;
    *((void *)v11 - 7) = 0;
    uint64_t v16 = *(void *)&v4[v9 - 40];
    LODWORD(v13) = *(_DWORD *)&v4[v9 - 32];
    *((void *)v11 - 6) = 0;
    *((_DWORD *)v10 - 8) = v13;
    *((void *)v10 - 5) = v16;
    *(_OWORD *)(v10 - 24) = *(_OWORD *)&v4[v9 - 24];
    *((void *)v10 - 1) = *(void *)&v4[v9 - 8];
    *((void *)v11 - 3) = 0;
    *((void *)v11 - 2) = 0;
    *((void *)v11 - 1) = 0;
    v9 -= 304;
  }
  while (&v4[v9] != v2);
  uint64_t v2 = *(unsigned char **)a1;
  uint64_t v17 = *(void *)(a1 + 8);
  *(void *)a1 = &v8[v9];
  *(void *)(a1 + 8) = v8;
  for (*(void *)(a1 + 16) = v7; (unsigned char *)v17 != v2; uint64_t v17 = sub_19E4446FC(v17 - 304))
    ;
  if (v2)
  {
LABEL_9:
    operator delete(v2);
  }
}

void sub_19E447D64(uint64_t a1, uint64_t a2, char a3)
{
  __dst[38] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a2 + 16) != *(void *)(a2 + 24)) {
    sub_19E4477F4((uint64_t)__dst, a1, a3);
  }
  __assert_rtn("_prepMultiWordCandidateHypothesisQueue", "MultiWordBeamSearchPredictor.cpp", 191, "!candidateHypothesisQueue.empty()");
}

void sub_19E448AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char *__p,char *a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  sub_19E4446FC((uint64_t)&a30);
  char v36 = __p;
  if (__p)
  {
    unint64_t v37 = a28;
    if (a28 != __p)
    {
      do
      {
        uint64_t v38 = (std::__shared_weak_count *)*((void *)v37 - 2);
        if (v38)
        {
          if (!atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
            std::__shared_weak_count::__release_weak(v38);
          }
        }
        v37 -= 24;
      }
      while (v37 != __p);
      char v36 = __p;
    }
    operator delete(v36);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E448C34(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xD79435E50D7944) {
      sub_19E37C7C4();
    }
    uint64_t v7 = (void *)result;
    int64_t result = (uint64_t)operator new(304 * a4);
    uint64_t v8 = result;
    *uint64_t v7 = result;
    v7[1] = result;
    void v7[2] = result + 304 * a4;
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        int64_t result = sub_19E444550(v8 + v9, a2 + v9);
        v9 += 304;
      }
      while (a2 + v9 != a3);
      v8 += v9;
    }
    v7[1] = v8;
  }
  return result;
}

void sub_19E448CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_19E448D34(uint64_t a1, uint64_t a2)
{
  long long v13 = *(_OWORD *)a1;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  uint64_t v14 = v3;
  uint64_t v15 = v4;
  long long v16 = *(_OWORD *)(a1 + 32);
  uint64_t v17 = *(void *)(a1 + 48);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  long long v18 = *(_OWORD *)(a1 + 56);
  uint64_t v19 = *(void *)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  long long v20 = *(_OWORD *)(a1 + 80);
  uint64_t v21 = *(void *)(a1 + 96);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  long long v22 = *(_OWORD *)(a1 + 104);
  uint64_t v23 = *(void *)(a1 + 120);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  long long v24 = *(_OWORD *)(a1 + 128);
  uint64_t v5 = *(void *)(a1 + 144);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  long long v26 = *(_OWORD *)(a1 + 152);
  uint64_t v6 = *(void *)(a1 + 168);
  uint64_t v25 = v5;
  uint64_t v27 = v6;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  long long v7 = *(_OWORD *)(a1 + 192);
  long long v28 = *(_OWORD *)(a1 + 176);
  long long v29 = v7;
  uint64_t v8 = *(void *)(a1 + 208);
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  long long v31 = *(_OWORD *)(a1 + 216);
  uint64_t v9 = *(void *)(a1 + 232);
  uint64_t v30 = v8;
  uint64_t v32 = v9;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  long long v33 = *(_OWORD *)(a1 + 240);
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  int v36 = *(_DWORD *)(a1 + 272);
  uint64_t v10 = *(void *)(a1 + 256);
  uint64_t v11 = *(void *)(a1 + 264);
  *(void *)(a1 + 256) = 0;
  uint64_t v34 = v10;
  uint64_t v35 = v11;
  uint64_t v37 = *(void *)(a1 + 280);
  long long v38 = *(_OWORD *)(a1 + 288);
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 280) = 0;
  sub_19E448F5C(a1, a2);
  sub_19E448F5C(a2, (uint64_t)&v13);
  return sub_19E4446FC((uint64_t)&v13);
}

void **sub_19E448E78(void **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = v2;
    if ((void *)v3 != v2)
    {
      do
        uint64_t v3 = sub_19E4446FC(v3 - 304);
      while ((void *)v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t *sub_19E448ED4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      uint64_t v4 = *(void *)(v2 + 24);
      uint64_t v5 = *(void **)(v2 + 16);
      if (v4 != v3)
      {
        do
          uint64_t v4 = sub_19E4446FC(v4 - 304);
        while (v4 != v3);
        uint64_t v5 = *(void **)(v2 + 16);
      }
      *(void *)(v2 + 24) = v3;
      operator delete(v5);
    }
    MEMORY[0x19F3BDCF0](v2, 0x1020C402564D6C4);
  }
  return a1;
}

uint64_t sub_19E448F5C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  uint64_t v5 = (void **)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)uint64_t v5 = v6;
  *(unsigned char *)(a2 + 55) = 0;
  *(unsigned char *)(a2 + 32) = 0;
  sub_19E4490FC(a1 + 56, a2 + 56);
  long long v7 = (void **)(a1 + 240);
  uint64_t v8 = *(void *)(a1 + 240);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 248);
    uint64_t v10 = *(void **)(a1 + 240);
    if (v9 != v8)
    {
      do
      {
        uint64_t v11 = *(std::__shared_weak_count **)(v9 - 16);
        if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
        v9 -= 24;
      }
      while (v9 != v8);
      uint64_t v10 = *v7;
    }
    *(void *)(a1 + 248) = v8;
    operator delete(v10);
    *long long v7 = 0;
    *(void *)(a1 + 248) = 0;
    *(void *)(a1 + 256) = 0;
  }
  *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
  *(void *)(a1 + 256) = *(void *)(a2 + 256);
  *(void *)(a2 + 248) = 0;
  *(void *)(a2 + 256) = 0;
  *(void *)(a2 + 240) = 0;
  uint64_t v12 = *(void *)(a2 + 264);
  *(_DWORD *)(a1 + 272) = *(_DWORD *)(a2 + 272);
  *(void *)(a1 + 264) = v12;
  long long v13 = *(void **)(a1 + 280);
  if (v13)
  {
    *(void *)(a1 + 288) = v13;
    operator delete(v13);
    *(void *)(a1 + 280) = 0;
    *(void *)(a1 + 288) = 0;
    *(void *)(a1 + 296) = 0;
  }
  uint64_t v14 = *(void *)(a2 + 288);
  *(void *)(a1 + 280) = *(void *)(a2 + 280);
  *(void *)(a1 + 288) = v14;
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  *(void *)(a2 + 280) = 0;
  *(void *)(a2 + 288) = 0;
  *(void *)(a2 + 296) = 0;
  return a1;
}

uint64_t sub_19E4490FC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void ***)a1;
  if (*(void *)a1)
  {
    uint64_t v5 = *(void ***)(a1 + 8);
    long long v6 = *(void ***)a1;
    if (v5 != v4)
    {
      do
      {
        if (*((char *)v5 - 9) < 0) {
          operator delete(*(v5 - 4));
        }
        v5 -= 4;
      }
      while (v5 != v4);
      long long v6 = *(void ***)a1;
    }
    *(void *)(a1 + 8) = v4;
    operator delete(v6);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v7 = (void **)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 24);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void **)(a1 + 24);
    if (v9 != v8)
    {
      do
      {
        if (*(char *)(v9 - 9) < 0) {
          operator delete(*(void **)(v9 - 32));
        }
        v9 -= 32;
      }
      while (v9 != v8);
      uint64_t v10 = *v7;
    }
    *(void *)(a1 + 32) = v8;
    operator delete(v10);
    *long long v7 = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
  }
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v11 = (void **)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 48);
  if (v12)
  {
    uint64_t v13 = *(void *)(a1 + 56);
    uint64_t v14 = *(void **)(a1 + 48);
    if (v13 != v12)
    {
      do
      {
        if (*(char *)(v13 - 9) < 0) {
          operator delete(*(void **)(v13 - 32));
        }
        v13 -= 32;
      }
      while (v13 != v12);
      uint64_t v14 = *v11;
    }
    *(void *)(a1 + 56) = v12;
    operator delete(v14);
    std::__shared_weak_count *v11 = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
  }
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  uint64_t v15 = *(void **)(a1 + 72);
  if (v15)
  {
    *(void *)(a1 + 80) = v15;
    operator delete(v15);
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  long long v16 = *(void **)(a1 + 96);
  if (v16)
  {
    *(void *)(a1 + 104) = v16;
    operator delete(v16);
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
  }
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  uint64_t v17 = (void **)(a1 + 136);
  long long v18 = *(void ***)(a1 + 136);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  if (v18)
  {
    uint64_t v19 = *(void ***)(a1 + 144);
    long long v20 = v18;
    if (v19 != v18)
    {
      do
      {
        if (*((char *)v19 - 9) < 0) {
          operator delete(*(v19 - 4));
        }
        v19 -= 4;
      }
      while (v19 != v18);
      long long v20 = *v17;
    }
    *(void *)(a1 + 144) = v18;
    operator delete(v20);
    *uint64_t v17 = 0;
    *(void *)(a1 + 144) = 0;
    *(void *)(a1 + 152) = 0;
  }
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0;
  uint64_t v21 = (void **)(a1 + 160);
  uint64_t v22 = *(void *)(a1 + 160);
  if (v22)
  {
    uint64_t v23 = *(void *)(a1 + 168);
    long long v24 = *(void **)(a1 + 160);
    if (v23 != v22)
    {
      do
      {
        if (*(char *)(v23 - 9) < 0) {
          operator delete(*(void **)(v23 - 32));
        }
        v23 -= 32;
      }
      while (v23 != v22);
      long long v24 = *v21;
    }
    *(void *)(a1 + 168) = v22;
    operator delete(v24);
    unsigned char *v21 = 0;
    *(void *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
  }
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(void *)(a2 + 160) = 0;
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 176) = 0;
  return a1;
}

void sub_19E4493D0(void *a1, uint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = a1[2];
  unint64_t v4 = a1[3];
  unint64_t v5 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v4 - v3) >> 4);
  if (v5 >= a1[1])
  {
    if (v3 == v4) {
      __assert_rtn("worst", "PriorityQueue.h", 55, "!m_predictions.empty()");
    }
    double v14 = *(double *)(a2 + 184) + *(float *)(a2 + 24);
    if (v14 >= *(double *)(v3 + 184) + *(float *)(v3 + 24))
    {
      uint64_t v15 = a1[2];
      do
      {
        unint64_t v16 = v5 >> 1;
        uint64_t v17 = v15 + 304 * (v5 >> 1);
        double v18 = *(double *)(v17 + 184) + *(float *)(v17 + 24);
        uint64_t v19 = v17 + 304;
        v5 += ~(v5 >> 1);
        if (v14 < v18) {
          unint64_t v5 = v16;
        }
        else {
          uint64_t v15 = v19;
        }
      }
      while (v5);
      uint64_t v20 = v3 + 304;
      if (v3 + 304 != v15)
      {
        while (1)
        {
          uint64_t v21 = v3 + 304;
          sub_19E448D34(v3, v3 + 304);
          if (v3 + 608 == v15) {
            break;
          }
          if (v21 == v20) {
            uint64_t v20 = v3 + 608;
          }
          v3 += 304;
        }
        if (v21 != v20)
        {
          uint64_t v34 = v20;
          while (1)
          {
            sub_19E448D34(v21, v20);
            v20 += 304;
            BOOL v35 = v21 + 304 == v34;
            if (v20 == v15)
            {
              if (v21 + 304 == v34) {
                break;
              }
              uint64_t v20 = v34 + 304;
              v21 += 608;
              while (1)
              {
                sub_19E448D34(v21 - 304, v34);
                BOOL v35 = v21 == v34;
                if (v20 != v15) {
                  break;
                }
                BOOL v36 = v21 == v34;
                v21 += 304;
                if (v36) {
                  goto LABEL_49;
                }
              }
            }
            else
            {
              v21 += 304;
            }
            if (v35) {
              uint64_t v34 = v20;
            }
          }
        }
      }
LABEL_49:
      uint64_t v37 = v15 - 304;
LABEL_62:
      sub_19E449FE0(v37, v2);
    }
  }
  else
  {
    if (v4 == v3)
    {
      int64_t v13 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v4 - v3) >> 4);
    }
    else
    {
      unint64_t v7 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v4 - v3) >> 4);
      uint64_t v8 = a1[2];
      do
      {
        unint64_t v9 = v7 >> 1;
        uint64_t v10 = v8 + 304 * (v7 >> 1);
        double v11 = *(double *)(v10 + 184) + *(float *)(v10 + 24);
        uint64_t v12 = v10 + 304;
        v7 += ~(v7 >> 1);
        if (*(double *)(a2 + 184) + *(float *)(a2 + 24) < v11) {
          unint64_t v7 = v9;
        }
        else {
          uint64_t v8 = v12;
        }
      }
      while (v7);
      int64_t v13 = 0x86BCA1AF286BCA1BLL * ((v8 - v3) >> 4);
    }
    uint64_t v22 = (char *)(v3 + 304 * v13);
    unint64_t v23 = a1[4];
    if (v4 < v23)
    {
      if (v22 == (char *)v4)
      {
        sub_19E444550(a1[3], a2);
        a1[3] = v4 + 304;
        return;
      }
      long long v24 = v22 + 304;
      uint64_t v25 = v4 - 304;
      if (v4 < 0x130)
      {
        unint64_t v27 = v4;
      }
      else
      {
        unint64_t v26 = v4 - 304;
        unint64_t v27 = v4;
        do
        {
          *(void *)unint64_t v27 = 0;
          *(void *)(v27 + 8) = 0;
          *(void *)(v27 + 16) = 0;
          *(_OWORD *)unint64_t v27 = *(_OWORD *)v26;
          *(void *)(v27 + 16) = *(void *)(v26 + 16);
          *(void *)unint64_t v26 = 0;
          *(void *)(v26 + 8) = 0;
          *(void *)(v26 + 16) = 0;
          *(void *)(v27 + 24) = *(void *)(v26 + 24);
          long long v28 = *(_OWORD *)(v26 + 32);
          *(void *)(v27 + 48) = *(void *)(v26 + 48);
          *(_OWORD *)(v27 + 32) = v28;
          *(void *)(v26 + 40) = 0;
          *(void *)(v26 + 48) = 0;
          *(void *)(v26 + 32) = 0;
          *(void *)(v27 + 56) = 0;
          *(void *)(v27 + 64) = 0;
          *(void *)(v27 + 72) = 0;
          *(_OWORD *)(v27 + 56) = *(_OWORD *)(v26 + 56);
          *(void *)(v27 + 72) = *(void *)(v26 + 72);
          *(void *)(v26 + 56) = 0;
          *(void *)(v26 + 64) = 0;
          *(void *)(v26 + 72) = 0;
          *(void *)(v27 + 80) = 0;
          *(void *)(v27 + 88) = 0;
          *(void *)(v27 + 96) = 0;
          *(_OWORD *)(v27 + 80) = *(_OWORD *)(v26 + 80);
          *(void *)(v27 + 96) = *(void *)(v26 + 96);
          *(void *)(v26 + 80) = 0;
          *(void *)(v26 + 88) = 0;
          *(void *)(v26 + 96) = 0;
          *(void *)(v27 + 104) = 0;
          *(void *)(v27 + 112) = 0;
          *(void *)(v27 + 120) = 0;
          *(_OWORD *)(v27 + 104) = *(_OWORD *)(v26 + 104);
          *(void *)(v27 + 120) = *(void *)(v26 + 120);
          *(void *)(v26 + 104) = 0;
          *(void *)(v26 + 112) = 0;
          *(void *)(v26 + 120) = 0;
          *(void *)(v27 + 128) = 0;
          *(void *)(v27 + 136) = 0;
          *(void *)(v27 + 144) = 0;
          *(_OWORD *)(v27 + 128) = *(_OWORD *)(v26 + 128);
          *(void *)(v27 + 144) = *(void *)(v26 + 144);
          *(void *)(v26 + 128) = 0;
          *(void *)(v26 + 136) = 0;
          *(void *)(v26 + 144) = 0;
          *(void *)(v27 + 152) = 0;
          *(void *)(v27 + 160) = 0;
          *(void *)(v27 + 168) = 0;
          *(_OWORD *)(v27 + 152) = *(_OWORD *)(v26 + 152);
          *(void *)(v27 + 168) = *(void *)(v26 + 168);
          *(void *)(v26 + 160) = 0;
          *(void *)(v26 + 168) = 0;
          *(void *)(v26 + 152) = 0;
          *(_OWORD *)(v27 + 176) = *(_OWORD *)(v26 + 176);
          *(void *)(v27 + 200) = 0;
          *(void *)(v27 + 208) = 0;
          *(void *)(v27 + 192) = 0;
          *(_OWORD *)(v27 + 192) = *(_OWORD *)(v26 + 192);
          *(void *)(v27 + 208) = *(void *)(v26 + 208);
          *(void *)(v26 + 192) = 0;
          *(void *)(v26 + 200) = 0;
          *(void *)(v26 + 208) = 0;
          *(void *)(v27 + 216) = 0;
          *(void *)(v27 + 224) = 0;
          *(void *)(v27 + 232) = 0;
          *(_OWORD *)(v27 + 216) = *(_OWORD *)(v26 + 216);
          *(void *)(v27 + 232) = *(void *)(v26 + 232);
          *(void *)(v26 + 216) = 0;
          *(void *)(v26 + 224) = 0;
          *(void *)(v26 + 232) = 0;
          *(void *)(v27 + 240) = 0;
          *(void *)(v27 + 248) = 0;
          *(void *)(v27 + 256) = 0;
          *(_OWORD *)(v27 + 240) = *(_OWORD *)(v26 + 240);
          *(void *)(v27 + 256) = *(void *)(v26 + 256);
          *(void *)(v26 + 240) = 0;
          *(void *)(v26 + 248) = 0;
          *(void *)(v26 + 256) = 0;
          uint64_t v29 = *(void *)(v26 + 264);
          *(_DWORD *)(v27 + 272) = *(_DWORD *)(v26 + 272);
          *(void *)(v27 + 264) = v29;
          *(void *)(v27 + 288) = 0;
          *(void *)(v27 + 296) = 0;
          *(void *)(v27 + 280) = 0;
          *(void *)(v27 + 280) = *(void *)(v26 + 280);
          *(void *)(v27 + 288) = *(void *)(v26 + 288);
          *(void *)(v27 + 296) = *(void *)(v26 + 296);
          *(void *)(v26 + 280) = 0;
          *(void *)(v26 + 288) = 0;
          *(void *)(v26 + 296) = 0;
          v27 += 304;
          v26 += 304;
        }
        while (v26 < v4);
      }
      a1[3] = v27;
      if ((char *)v4 != v24)
      {
        uint64_t v39 = 16 * ((uint64_t)(v4 - (void)v24) >> 4);
        uint64_t v40 = v3 + 304 * v13 - 304;
        do
        {
          uint64_t v25 = sub_19E448F5C(v25, v40 + v39) - 304;
          v39 -= 304;
        }
        while (v39);
      }
      if ((unint64_t)v22 <= v2) {
        v2 += 304 * (a1[3] > v2);
      }
      uint64_t v37 = (uint64_t)v22;
      goto LABEL_62;
    }
    unint64_t v30 = v5 + 1;
    if (v30 > 0xD79435E50D7943) {
      sub_19E37C7C4();
    }
    unint64_t v31 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v23 - v3) >> 4);
    if (2 * v31 > v30) {
      unint64_t v30 = 2 * v31;
    }
    if (v31 >= 0x6BCA1AF286BCA1) {
      unint64_t v32 = 0xD79435E50D7943;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32)
    {
      if (v32 > 0xD79435E50D7943) {
        sub_19E37C2B8();
      }
      long long v33 = (char *)operator new(304 * v32);
    }
    else
    {
      long long v33 = 0;
    }
    uint64_t v38 = (uint64_t)&v33[304 * v13];
    uint64_t v59 = v38;
    uint64_t v61 = v38;
    unint64_t v63 = &v33[304 * v32];
    if (v13 == v32)
    {
      if (v13 < 1)
      {
        if (v13) {
          unint64_t v41 = 2 * v13;
        }
        else {
          unint64_t v41 = 1;
        }
        if (v41 > 0xD79435E50D7943) {
          sub_19E37C2B8();
        }
        std::string v42 = (char *)operator new(304 * v41);
        uint64_t v38 = (uint64_t)&v42[304 * (v41 >> 2)];
        uint64_t v59 = v38;
        uint64_t v61 = v38;
        unint64_t v63 = &v42[304 * v41];
        if (v33) {
          operator delete(v33);
        }
      }
      else
      {
        v38 -= 304 * ((v13 + 1) >> 1);
        uint64_t v59 = v38;
        uint64_t v61 = v38;
      }
    }
    sub_19E444550(v38, v2);
    uint64_t v43 = v59;
    uint64_t v44 = v61 + 304;
    uint64_t v62 = v61 + 304;
    uint64_t v45 = (char *)a1[2];
    if (v45 != v22)
    {
      uint64_t v46 = 0;
      do
      {
        uint64_t v47 = v59 + v46;
        uint64_t v48 = (void *)(v59 + v46 - 304);
        size_t v49 = &v22[v46];
        uint64_t v50 = (uint64_t)&v22[v46 - 304];
        *(void *)(v59 + v46 - 296) = 0;
        *uint64_t v48 = 0;
        v48[2] = 0;
        *(_OWORD *)uint64_t v48 = *(_OWORD *)v50;
        *(void *)(v59 + v46 - 288) = *(void *)&v22[v46 - 288];
        *(void *)&v22[v46 - 296] = 0;
        *(void *)uint64_t v50 = 0;
        *(void *)(v50 + 16) = 0;
        *(void *)(v59 + v46 - 280) = *(void *)&v22[v46 - 280];
        uint64_t v51 = (uint64_t)&v22[v46 - 272];
        long long v52 = *(_OWORD *)v51;
        *(void *)(v47 - 256) = *(void *)&v22[v46 - 256];
        *(_OWORD *)(v59 + v46 - 272) = v52;
        *((void *)v49 - 32) = 0;
        *(void *)uint64_t v51 = 0;
        *(void *)(v51 + 8) = 0;
        *(void *)(v47 - 248) = 0;
        *(void *)(v47 - 240) = 0;
        *(void *)(v47 - 232) = 0;
        *(_OWORD *)(v47 - 248) = *(_OWORD *)&v22[v46 - 248];
        *(void *)(v47 - 232) = *(void *)&v22[v46 - 232];
        *((void *)v49 - 31) = 0;
        *((void *)v49 - 30) = 0;
        *((void *)v49 - 29) = 0;
        *(void *)(v47 - 224) = 0;
        *(void *)(v47 - 216) = 0;
        *(void *)(v47 - 208) = 0;
        *(_OWORD *)(v47 - 224) = *(_OWORD *)&v22[v46 - 224];
        *(void *)(v47 - 208) = *(void *)&v22[v46 - 208];
        *((void *)v49 - 28) = 0;
        *((void *)v49 - 27) = 0;
        *((void *)v49 - 26) = 0;
        *(void *)(v47 - 200) = 0;
        *(void *)(v47 - 192) = 0;
        *(void *)(v47 - 184) = 0;
        *(_OWORD *)(v47 - 200) = *(_OWORD *)&v22[v46 - 200];
        *(void *)(v47 - 184) = *(void *)&v22[v46 - 184];
        *((void *)v49 - 25) = 0;
        *((void *)v49 - 24) = 0;
        *((void *)v49 - 23) = 0;
        *(void *)(v47 - 176) = 0;
        *(void *)(v47 - 168) = 0;
        *(void *)(v47 - 160) = 0;
        *(_OWORD *)(v47 - 176) = *(_OWORD *)&v22[v46 - 176];
        *(void *)(v47 - 160) = *(void *)&v22[v46 - 160];
        *((void *)v49 - 22) = 0;
        *((void *)v49 - 21) = 0;
        *((void *)v49 - 20) = 0;
        *(void *)(v47 - 152) = 0;
        *(void *)(v47 - 144) = 0;
        *(void *)(v47 - 136) = 0;
        *(_OWORD *)(v47 - 152) = *(_OWORD *)&v22[v46 - 152];
        *(void *)(v47 - 136) = *(void *)&v22[v46 - 136];
        *((void *)v49 - 18) = 0;
        *((void *)v49 - 17) = 0;
        long long v53 = *(_OWORD *)&v22[v46 - 128];
        *((void *)v49 - 19) = 0;
        *(_OWORD *)(v47 - 128) = v53;
        *(void *)(v47 - 104) = 0;
        *(void *)(v47 - 96) = 0;
        *(void *)(v47 - 112) = 0;
        *(_OWORD *)(v47 - 112) = *(_OWORD *)&v22[v46 - 112];
        *(void *)(v47 - 96) = *(void *)&v22[v46 - 96];
        *((void *)v49 - 14) = 0;
        *((void *)v49 - 13) = 0;
        *((void *)v49 - 12) = 0;
        *(void *)(v47 - 88) = 0;
        *(void *)(v47 - 80) = 0;
        *(void *)(v47 - 72) = 0;
        *(_OWORD *)(v47 - 88) = *(_OWORD *)&v22[v46 - 88];
        *(void *)(v47 - 72) = *(void *)&v22[v46 - 72];
        *((void *)v49 - 11) = 0;
        *((void *)v49 - 10) = 0;
        *((void *)v49 - 9) = 0;
        *(void *)(v47 - 64) = 0;
        *(void *)(v47 - 56) = 0;
        *(void *)(v47 - 48) = 0;
        *(_OWORD *)(v47 - 64) = *(_OWORD *)&v22[v46 - 64];
        *(void *)(v47 - 48) = *(void *)&v22[v46 - 48];
        *((void *)v49 - 8) = 0;
        *((void *)v49 - 7) = 0;
        *((void *)v49 - 6) = 0;
        uint64_t v54 = *(void *)&v22[v46 - 40];
        *(_DWORD *)(v47 - 32) = *(_DWORD *)&v22[v46 - 32];
        *(void *)(v47 - 16) = 0;
        *(void *)(v47 - 8) = 0;
        *(void *)(v47 - 40) = v54;
        *(void *)(v47 - 24) = 0;
        *(_OWORD *)(v47 - 24) = *(_OWORD *)&v22[v46 - 24];
        *(void *)(v47 - 8) = *(void *)&v22[v46 - 8];
        *((void *)v49 - 3) = 0;
        *((void *)v49 - 2) = 0;
        *((void *)v49 - 1) = 0;
        v46 -= 304;
      }
      while (&v22[v46] != v45);
      uint64_t v43 = v59 + v46;
      uint64_t v44 = v62;
    }
    uint64_t v60 = v43;
    size_t v55 = (char *)a1[3];
    if (v55 != v22)
    {
      do
      {
        *(void *)uint64_t v44 = 0;
        *(void *)(v44 + 8) = 0;
        *(void *)(v44 + 16) = 0;
        *(_OWORD *)uint64_t v44 = *(_OWORD *)v22;
        *(void *)(v44 + 16) = *((void *)v22 + 2);
        *(void *)uint64_t v22 = 0;
        *((void *)v22 + 1) = 0;
        *((void *)v22 + 2) = 0;
        *(void *)(v44 + 24) = *((void *)v22 + 3);
        long long v56 = *((_OWORD *)v22 + 2);
        *(void *)(v44 + 48) = *((void *)v22 + 6);
        *(_OWORD *)(v44 + 32) = v56;
        *((void *)v22 + 5) = 0;
        *((void *)v22 + 6) = 0;
        *((void *)v22 + 4) = 0;
        *(void *)(v44 + 56) = 0;
        *(void *)(v44 + 64) = 0;
        *(void *)(v44 + 72) = 0;
        *(_OWORD *)(v44 + 56) = *(_OWORD *)(v22 + 56);
        *(void *)(v44 + 72) = *((void *)v22 + 9);
        *((void *)v22 + 7) = 0;
        *((void *)v22 + 8) = 0;
        *((void *)v22 + 9) = 0;
        *(void *)(v44 + 80) = 0;
        *(void *)(v44 + 88) = 0;
        *(void *)(v44 + 96) = 0;
        *(_OWORD *)(v44 + 80) = *((_OWORD *)v22 + 5);
        *(void *)(v44 + 96) = *((void *)v22 + 12);
        *((void *)v22 + 10) = 0;
        *((void *)v22 + 11) = 0;
        *((void *)v22 + 12) = 0;
        *(void *)(v44 + 104) = 0;
        *(void *)(v44 + 112) = 0;
        *(void *)(v44 + 120) = 0;
        *(_OWORD *)(v44 + 104) = *(_OWORD *)(v22 + 104);
        *(void *)(v44 + 120) = *((void *)v22 + 15);
        *((void *)v22 + 13) = 0;
        *((void *)v22 + 14) = 0;
        *((void *)v22 + 15) = 0;
        *(void *)(v44 + 128) = 0;
        *(void *)(v44 + 136) = 0;
        *(void *)(v44 + 144) = 0;
        *(_OWORD *)(v44 + 128) = *((_OWORD *)v22 + 8);
        *(void *)(v44 + 144) = *((void *)v22 + 18);
        *((void *)v22 + 16) = 0;
        *((void *)v22 + 17) = 0;
        *((void *)v22 + 18) = 0;
        *(void *)(v44 + 152) = 0;
        *(void *)(v44 + 160) = 0;
        *(void *)(v44 + 168) = 0;
        *(_OWORD *)(v44 + 152) = *(_OWORD *)(v22 + 152);
        *(void *)(v44 + 168) = *((void *)v22 + 21);
        *((void *)v22 + 20) = 0;
        *((void *)v22 + 21) = 0;
        *((void *)v22 + 19) = 0;
        *(_OWORD *)(v44 + 176) = *((_OWORD *)v22 + 11);
        *(void *)(v44 + 200) = 0;
        *(void *)(v44 + 208) = 0;
        *(void *)(v44 + 192) = 0;
        *(_OWORD *)(v44 + 192) = *((_OWORD *)v22 + 12);
        *(void *)(v44 + 208) = *((void *)v22 + 26);
        *((void *)v22 + 24) = 0;
        *((void *)v22 + 25) = 0;
        *((void *)v22 + 26) = 0;
        *(void *)(v44 + 216) = 0;
        *(void *)(v44 + 224) = 0;
        *(void *)(v44 + 232) = 0;
        *(_OWORD *)(v44 + 216) = *(_OWORD *)(v22 + 216);
        *(void *)(v44 + 232) = *((void *)v22 + 29);
        *((void *)v22 + 27) = 0;
        *((void *)v22 + 28) = 0;
        *((void *)v22 + 29) = 0;
        *(void *)(v44 + 240) = 0;
        *(void *)(v44 + 248) = 0;
        *(void *)(v44 + 256) = 0;
        *(_OWORD *)(v44 + 240) = *((_OWORD *)v22 + 15);
        *(void *)(v44 + 256) = *((void *)v22 + 32);
        *((void *)v22 + 30) = 0;
        *((void *)v22 + 31) = 0;
        *((void *)v22 + 32) = 0;
        uint64_t v57 = *((void *)v22 + 33);
        *(_DWORD *)(v44 + 272) = *((_DWORD *)v22 + 68);
        *(void *)(v44 + 264) = v57;
        *(void *)(v44 + 288) = 0;
        *(void *)(v44 + 296) = 0;
        *(void *)(v44 + 280) = 0;
        *(void *)(v44 + 280) = *((void *)v22 + 35);
        *(void *)(v44 + 288) = *((void *)v22 + 36);
        *(void *)(v44 + 296) = *((void *)v22 + 37);
        *((void *)v22 + 35) = 0;
        *((void *)v22 + 36) = 0;
        *((void *)v22 + 37) = 0;
        v44 += 304;
        v22 += 304;
      }
      while (v22 != v55);
      uint64_t v43 = v60;
      uint64_t v22 = (char *)a1[3];
    }
    BOOL v58 = (char *)a1[2];
    a1[2] = v43;
    a1[3] = v44;
    a1[4] = v63;
    if (v22 != v58)
    {
      do
      {
        v22 -= 304;
        sub_19E4446FC((uint64_t)v22);
      }
      while (v22 != v58);
      uint64_t v22 = v58;
    }
    if (v22) {
      operator delete(v22);
    }
  }
}

void sub_19E449D7C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = v2;
  _Unwind_Resume(a1);
}

void sub_19E449D84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E44AD68((uint64_t)va);
  _Unwind_Resume(a1);
}

char *sub_19E449D98(char **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_19E37C7C4();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
    unint64_t v5 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v5 = v3;
  }
  if (v5 > 0xAAAAAAAAAAAAAAALL) {
    sub_19E37C2B8();
  }
  uint64_t v7 = 24 * v5;
  uint64_t v8 = (char *)operator new(24 * v5);
  unint64_t v9 = &v8[24 * v2];
  uint64_t v10 = &v8[v7];
  *(_OWORD *)unint64_t v9 = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *((void *)v9 + 2) = *(void *)(a2 + 16);
  double v11 = v9 + 24;
  uint64_t v12 = *a1;
  int64_t v13 = a1[1];
  if (v13 == *a1)
  {
    *a1 = v9;
    a1[1] = v11;
    a1[2] = v10;
  }
  else
  {
    do
    {
      long long v14 = *(_OWORD *)(v13 - 24);
      v13 -= 24;
      *(_OWORD *)(v9 - 24) = v14;
      v9 -= 24;
      *(void *)int64_t v13 = 0;
      *((void *)v13 + 1) = 0;
      *((void *)v9 + 2) = *((void *)v13 + 2);
    }
    while (v13 != v12);
    int64_t v13 = *a1;
    uint64_t v15 = a1[1];
    *a1 = v9;
    a1[1] = v11;
    for (a1[2] = v10; v15 != v13; v15 -= 24)
    {
      unint64_t v16 = (std::__shared_weak_count *)*((void *)v15 - 2);
      if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  if (v13) {
    operator delete(v13);
  }
  return v11;
}

uint64_t sub_19E449F1C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__114default_deleteIN2LM13LexiconCursorEEE"
    || ((v3 & (unint64_t)"NSt3__114default_deleteIN2LM13LexiconCursorEEE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__114default_deleteIN2LM13LexiconCursorEEE")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__114default_deleteIN2LM13LexiconCursorEEE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E449F74(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_19E449FA4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E449FE0(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
  {
    sub_19E44A58C(a1 + 56, (char **)(a1 + 56));
  }
  else
  {
    sub_19E44A444((void *)a1, *(char **)a2, *(char **)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    unint64_t v4 = (void **)(a1 + 32);
    char v5 = *(unsigned char *)(a2 + 55);
    if (*(char *)(a1 + 55) < 0)
    {
      if (v5 >= 0) {
        uint64_t v7 = (void *)(a2 + 32);
      }
      else {
        uint64_t v7 = *(void **)(a2 + 32);
      }
      if (v5 >= 0) {
        size_t v8 = *(unsigned __int8 *)(a2 + 55);
      }
      else {
        size_t v8 = *(void *)(a2 + 40);
      }
      sub_19E3C6D44(v4, v7, v8);
    }
    else if ((*(unsigned char *)(a2 + 55) & 0x80) != 0)
    {
      sub_19E3C6C7C(v4, *(void **)(a2 + 32), *(void *)(a2 + 40));
    }
    else
    {
      long long v6 = *(_OWORD *)(a2 + 32);
      *(void *)(a1 + 48) = *(void *)(a2 + 48);
      *(_OWORD *)unint64_t v4 = v6;
    }
    sub_19E44A58C(a1 + 56, (char **)(a2 + 56));
    uint64_t v10 = (void **)(a1 + 240);
    unint64_t v9 = *(uint64_t **)(a1 + 240);
    uint64_t v12 = *(uint64_t **)(a2 + 240);
    double v11 = *(uint64_t **)(a2 + 248);
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (v11 - v12);
    uint64_t v14 = *(void *)(a1 + 256);
    if (0xAAAAAAAAAAAAAAABLL * ((v14 - (uint64_t)v9) >> 3) >= v13)
    {
      double v18 = *(uint64_t **)(a1 + 248);
      if (0xAAAAAAAAAAAAAAABLL * (v18 - v9) >= v13)
      {
        if (v12 != v11)
        {
          do
          {
            uint64_t v24 = *v12;
            uint64_t v23 = v12[1];
            if (v23) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v25 = (std::__shared_weak_count *)v9[1];
            *unint64_t v9 = v24;
            v9[1] = v23;
            if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
              std::__shared_weak_count::__release_weak(v25);
            }
            _OWORD v9[2] = v12[2];
            v9 += 3;
            v12 += 3;
          }
          while (v12 != v11);
          double v18 = *(uint64_t **)(a1 + 248);
        }
        for (; v18 != v9; v18 -= 3)
        {
          uint64_t v34 = (std::__shared_weak_count *)*(v18 - 2);
          if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v34);
          }
        }
        *(void *)(a1 + 248) = v9;
      }
      else
      {
        uint64_t v19 = &v12[v18 - v9];
        if (v18 != v9)
        {
          do
          {
            uint64_t v21 = *v12;
            uint64_t v20 = v12[1];
            if (v20) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v22 = (std::__shared_weak_count *)v9[1];
            *unint64_t v9 = v21;
            v9[1] = v20;
            if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
              std::__shared_weak_count::__release_weak(v22);
            }
            _OWORD v9[2] = v12[2];
            v12 += 3;
            v9 += 3;
          }
          while (v12 != v19);
          unint64_t v9 = *(uint64_t **)(a1 + 248);
        }
        unint64_t v32 = v9;
        if (v19 != v11)
        {
          unint64_t v32 = v9;
          do
          {
            uint64_t v33 = v19[1];
            *unint64_t v32 = *v19;
            v32[1] = v33;
            if (v33) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v33 + 8), 1uLL, memory_order_relaxed);
            }
            void v32[2] = v19[2];
            v32 += 3;
            v19 += 3;
          }
          while (v19 != v11);
        }
        *(void *)(a1 + 248) = v32;
      }
    }
    else
    {
      if (v9)
      {
        uint64_t v15 = *(uint64_t **)(a1 + 248);
        unint64_t v16 = *(void **)(a1 + 240);
        if (v15 != v9)
        {
          do
          {
            uint64_t v17 = (std::__shared_weak_count *)*(v15 - 2);
            if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
              std::__shared_weak_count::__release_weak(v17);
            }
            v15 -= 3;
          }
          while (v15 != v9);
          unint64_t v16 = *v10;
        }
        *(void *)(a1 + 248) = v9;
        operator delete(v16);
        uint64_t v14 = 0;
        *uint64_t v10 = 0;
        *(void *)(a1 + 248) = 0;
        *(void *)(a1 + 256) = 0;
      }
      if (v13 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_71;
      }
      unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * (v14 >> 3);
      uint64_t v27 = 2 * v26;
      if (2 * v26 <= v13) {
        uint64_t v27 = 0xAAAAAAAAAAAAAAABLL * (v11 - v12);
      }
      unint64_t v28 = v26 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v27;
      if (v28 > 0xAAAAAAAAAAAAAAALL) {
LABEL_71:
      }
        sub_19E37C7C4();
      uint64_t v29 = 3 * v28;
      unint64_t v30 = operator new(24 * v28);
      *(void *)(a1 + 240) = v30;
      *(void *)(a1 + 248) = v30;
      for (*(void *)(a1 + 256) = &v30[v29]; v12 != v11; v12 += 3)
      {
        uint64_t v31 = v12[1];
        *unint64_t v30 = *v12;
        v30[1] = v31;
        if (v31) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
        }
        void v30[2] = v12[2];
        v30 += 3;
      }
      *(void *)(a1 + 248) = v30;
    }
    uint64_t v35 = *(void *)(a2 + 264);
    *(_DWORD *)(a1 + 272) = *(_DWORD *)(a2 + 272);
    *(void *)(a1 + 264) = v35;
    sub_19E44A444((void *)(a1 + 280), *(char **)(a2 + 280), *(char **)(a2 + 288), (uint64_t)(*(void *)(a2 + 288) - *(void *)(a2 + 280)) >> 2);
  }
  return a1;
}

void *sub_19E44A444(void *result, char *__src, char *a3, size_t __sz)
{
  long long v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  unint64_t v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 2)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (__sz >> 62) {
      goto LABEL_22;
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= __sz) {
      uint64_t v10 = __sz;
    }
    BOOL v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL;
    unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v10;
    }
    if (v12 >> 62) {
LABEL_22:
    }
      sub_19E37C7C4();
    uint64_t v13 = 4 * v12;
    uint64_t result = operator new(4 * v12);
    unint64_t v9 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    void v7[2] = (char *)result + v13;
    size_t v14 = a3 - v6;
    if (v14) {
      uint64_t result = memcpy(result, v6, v14);
    }
    uint64_t v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  uint64_t v15 = (void **)(result + 1);
  unint64_t v16 = (unsigned char *)result[1];
  unint64_t v17 = (v16 - v9) >> 2;
  if (v17 >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    uint64_t v19 = (void *)*result;
LABEL_20:
    uint64_t result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  double v18 = &__src[4 * v17];
  if (v16 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v16 - v9);
    unint64_t v9 = (char *)*v15;
  }
  size_t v14 = a3 - v18;
  if (v14)
  {
    uint64_t v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  *uint64_t v15 = &v9[v14];
  return result;
}

uint64_t sub_19E44A58C(uint64_t a1, char **a2)
{
  if ((char **)a1 != a2)
  {
    char v5 = (void **)*a2;
    unint64_t v4 = a2[1];
    uint64_t v6 = v4 - *a2;
    unint64_t v7 = v6 >> 5;
    uint64_t v8 = *(void *)(a1 + 16);
    unint64_t v9 = *(void ***)a1;
    if (v6 >> 5 <= (unint64_t)((v8 - *(void *)a1) >> 5))
    {
      unint64_t v12 = *(void ***)(a1 + 8);
      unint64_t v13 = ((char *)v12 - (char *)v9) >> 5;
      if (v13 >= v7)
      {
        if (v5 != (void **)v4)
        {
          unint64_t v23 = 0;
          do
          {
            unint64_t v26 = &v9[v23];
            uint64_t v27 = (char *)&v5[v23];
            if (v5 != v9)
            {
              char v28 = v27[23];
              if (*((char *)v26 + 23) < 0)
              {
                if (v28 >= 0) {
                  uint64_t v24 = (char *)&v5[v23];
                }
                else {
                  uint64_t v24 = (char *)v5[v23];
                }
                if (v28 >= 0) {
                  size_t v25 = v27[23];
                }
                else {
                  size_t v25 = (size_t)v5[v23 + 1];
                }
                unint64_t v26 = sub_19E3C6D44(v26, v24, v25);
              }
              else if (v27[23] < 0)
              {
                unint64_t v26 = (void **)sub_19E3C6C7C(v26, v5[v23], (size_t)v5[v23 + 1]);
              }
              else
              {
                long long v29 = *(_OWORD *)v27;
                v26[2] = (void *)*((void *)v27 + 2);
                *(_OWORD *)unint64_t v26 = v29;
              }
            }
            *((_DWORD *)v26 + 6) = *((_DWORD *)v27 + 6);
            v23 += 4;
          }
          while (&v5[v23] != (void **)v4);
          unint64_t v9 = (void **)((char *)v9 + v23 * 8);
          unint64_t v12 = *(void ***)(a1 + 8);
        }
        while (v12 != v9)
        {
          if (*((char *)v12 - 9) < 0) {
            operator delete(*(v12 - 4));
          }
          v12 -= 4;
        }
        *(void *)(a1 + 8) = v9;
      }
      else
      {
        size_t v14 = (char *)&v5[4 * v13];
        if (v12 != v9)
        {
          unint64_t v15 = 0;
          uint64_t v16 = 32 * v13;
          do
          {
            uint64_t v19 = &v9[v15 / 8];
            uint64_t v20 = (char *)&v5[v15 / 8];
            if (v5 != v9)
            {
              char v21 = v20[23];
              if (*((char *)v19 + 23) < 0)
              {
                if (v21 >= 0) {
                  unint64_t v17 = (char *)&v5[v15 / 8];
                }
                else {
                  unint64_t v17 = (char *)v5[v15 / 8];
                }
                if (v21 >= 0) {
                  size_t v18 = v20[23];
                }
                else {
                  size_t v18 = (size_t)v5[v15 / 8 + 1];
                }
                uint64_t v19 = sub_19E3C6D44(v19, v17, v18);
              }
              else if (v20[23] < 0)
              {
                uint64_t v19 = (void **)sub_19E3C6C7C(v19, v5[v15 / 8], (size_t)v5[v15 / 8 + 1]);
              }
              else
              {
                long long v22 = *(_OWORD *)v20;
                v19[2] = (void *)*((void *)v20 + 2);
                *(_OWORD *)uint64_t v19 = v22;
              }
            }
            *((_DWORD *)v19 + 6) = *((_DWORD *)v20 + 6);
            v15 += 32;
          }
          while (v16 != v15);
          unint64_t v9 = *(void ***)(a1 + 8);
        }
        uint64_t v39 = v9;
        if (v14 != v4)
        {
          uint64_t v40 = 0;
          do
          {
            std::string v42 = &v9[v40];
            uint64_t v43 = &v14[v40 * 8];
            if (v14[v40 * 8 + 23] < 0)
            {
              sub_19E39369C(&v9[v40], *(void **)v43, *((void *)v43 + 1));
            }
            else
            {
              long long v41 = *(_OWORD *)v43;
              void v42[2] = (void *)*((void *)v43 + 2);
              *(_OWORD *)std::string v42 = v41;
            }
            LODWORD(v9[v40 + 3]) = *(_DWORD *)&v14[v40 * 8 + 24];
            v40 += 4;
          }
          while (&v14[v40 * 8] != v4);
          uint64_t v39 = &v9[v40];
        }
        *(void *)(a1 + 8) = v39;
      }
    }
    else
    {
      if (v9)
      {
        uint64_t v10 = *(void ***)(a1 + 8);
        BOOL v11 = *(void ***)a1;
        if (v10 != v9)
        {
          do
          {
            if (*((char *)v10 - 9) < 0) {
              operator delete(*(v10 - 4));
            }
            v10 -= 4;
          }
          while (v10 != v9);
          BOOL v11 = *(void ***)a1;
        }
        *(void *)(a1 + 8) = v9;
        operator delete(v11);
        uint64_t v8 = 0;
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
      }
      if (v6 < 0) {
        goto LABEL_73;
      }
      uint64_t v30 = v8 >> 4;
      if (v8 >> 4 <= v7) {
        uint64_t v30 = v6 >> 5;
      }
      BOOL v31 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0;
      unint64_t v32 = 0x7FFFFFFFFFFFFFFLL;
      if (!v31) {
        unint64_t v32 = v30;
      }
      if (v32 >> 59) {
LABEL_73:
      }
        sub_19E37C7C4();
      uint64_t v33 = 32 * v32;
      uint64_t v34 = operator new(32 * v32);
      *(void *)a1 = v34;
      *(void *)(a1 + 8) = v34;
      *(void *)(a1 + 16) = &v34[v33];
      if (v5 != (void **)v4)
      {
        uint64_t v35 = 0;
        do
        {
          uint64_t v37 = &v34[v35 * 8];
          uint64_t v38 = (char *)&v5[v35];
          if (SHIBYTE(v5[v35 + 2]) < 0)
          {
            sub_19E39369C(&v34[v35 * 8], *(void **)v38, *((void *)v38 + 1));
          }
          else
          {
            long long v36 = *(_OWORD *)v38;
            *((void *)v37 + 2) = *((void *)v38 + 2);
            *(_OWORD *)uint64_t v37 = v36;
          }
          *(_DWORD *)&v34[v35 * 8 + 24] = v5[v35 + 3];
          v35 += 4;
        }
        while (&v5[v35] != (void **)v4);
        v34 += v35 * 8;
      }
      *(void *)(a1 + 8) = v34;
    }
    sub_19E44A9C4((void ***)(a1 + 24), (void **)a2[3], a2[4], (a2[4] - a2[3]) >> 5);
    sub_19E44A9C4((void ***)(a1 + 48), (void **)a2[6], a2[7], (a2[7] - a2[6]) >> 5);
    sub_19E44A444((void *)(a1 + 72), a2[9], a2[10], (a2[10] - a2[9]) >> 2);
    sub_19E44A444((void *)(a1 + 96), a2[12], a2[13], (a2[13] - a2[12]) >> 2);
    *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 15);
    sub_19E44A9C4((void ***)(a1 + 136), (void **)a2[17], a2[18], (a2[18] - a2[17]) >> 5);
    sub_19E44A9C4((void ***)(a1 + 160), (void **)a2[20], a2[21], (a2[21] - a2[20]) >> 5);
  }
  return a1;
}

void sub_19E44A9C4(void ***a1, void **a2, char *a3, unint64_t a4)
{
  uint64_t v8 = (uint64_t)a1[2];
  unint64_t v9 = *a1;
  if (a4 <= (v8 - (uint64_t)*a1) >> 5)
  {
    unint64_t v12 = a1[1];
    unint64_t v13 = ((char *)v12 - (char *)v9) >> 5;
    if (v13 >= a4)
    {
      if (a2 != (void **)a3)
      {
        unint64_t v23 = 0;
        do
        {
          unint64_t v26 = &v9[v23];
          uint64_t v27 = (char *)&a2[v23];
          if (a2 != v9)
          {
            char v28 = v27[23];
            if (*((char *)v26 + 23) < 0)
            {
              if (v28 >= 0) {
                uint64_t v24 = (char *)&a2[v23];
              }
              else {
                uint64_t v24 = (char *)a2[v23];
              }
              if (v28 >= 0) {
                size_t v25 = v27[23];
              }
              else {
                size_t v25 = (size_t)a2[v23 + 1];
              }
              unint64_t v26 = sub_19E3C6D44(v26, v24, v25);
            }
            else if (v27[23] < 0)
            {
              unint64_t v26 = (void **)sub_19E3C6C7C(v26, a2[v23], (size_t)a2[v23 + 1]);
            }
            else
            {
              long long v29 = *(_OWORD *)v27;
              v26[2] = (void *)*((void *)v27 + 2);
              *(_OWORD *)unint64_t v26 = v29;
            }
          }
          *((_DWORD *)v26 + 6) = *((_DWORD *)v27 + 6);
          v23 += 4;
        }
        while (&a2[v23] != (void **)a3);
        unint64_t v9 = (void **)((char *)v9 + v23 * 8);
        unint64_t v12 = a1[1];
      }
      while (v12 != v9)
      {
        if (*((char *)v12 - 9) < 0) {
          operator delete(*(v12 - 4));
        }
        v12 -= 4;
      }
      a1[1] = v9;
    }
    else
    {
      size_t v14 = (char *)&a2[4 * v13];
      if (v12 != v9)
      {
        unint64_t v15 = 0;
        uint64_t v16 = 32 * v13;
        do
        {
          uint64_t v19 = &v9[v15 / 8];
          uint64_t v20 = (char *)&a2[v15 / 8];
          if (a2 != v9)
          {
            char v21 = v20[23];
            if (*((char *)v19 + 23) < 0)
            {
              if (v21 >= 0) {
                unint64_t v17 = (char *)&a2[v15 / 8];
              }
              else {
                unint64_t v17 = (char *)a2[v15 / 8];
              }
              if (v21 >= 0) {
                size_t v18 = v20[23];
              }
              else {
                size_t v18 = (size_t)a2[v15 / 8 + 1];
              }
              uint64_t v19 = sub_19E3C6D44(v19, v17, v18);
            }
            else if (v20[23] < 0)
            {
              uint64_t v19 = (void **)sub_19E3C6C7C(v19, a2[v15 / 8], (size_t)a2[v15 / 8 + 1]);
            }
            else
            {
              long long v22 = *(_OWORD *)v20;
              v19[2] = (void *)*((void *)v20 + 2);
              *(_OWORD *)uint64_t v19 = v22;
            }
          }
          *((_DWORD *)v19 + 6) = *((_DWORD *)v20 + 6);
          v15 += 32;
        }
        while (v16 != v15);
        unint64_t v9 = a1[1];
      }
      uint64_t v38 = v9;
      if (v14 != a3)
      {
        uint64_t v39 = 0;
        do
        {
          long long v41 = &v9[v39];
          std::string v42 = &v14[v39 * 8];
          if (v14[v39 * 8 + 23] < 0)
          {
            sub_19E39369C(&v9[v39], *(void **)v42, *((void *)v42 + 1));
          }
          else
          {
            long long v40 = *(_OWORD *)v42;
            void v41[2] = (void *)*((void *)v42 + 2);
            *(_OWORD *)long long v41 = v40;
          }
          LODWORD(v9[v39 + 3]) = *(_DWORD *)&v14[v39 * 8 + 24];
          v39 += 4;
        }
        while (&v14[v39 * 8] != a3);
        uint64_t v38 = &v9[v39];
      }
      a1[1] = v38;
    }
  }
  else
  {
    if (v9)
    {
      uint64_t v10 = a1[1];
      BOOL v11 = *a1;
      if (v10 != v9)
      {
        do
        {
          if (*((char *)v10 - 9) < 0) {
            operator delete(*(v10 - 4));
          }
          v10 -= 4;
        }
        while (v10 != v9);
        BOOL v11 = *a1;
      }
      a1[1] = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 59) {
      goto LABEL_70;
    }
    uint64_t v30 = v8 >> 4;
    if (v8 >> 4 <= a4) {
      uint64_t v30 = a4;
    }
    BOOL v31 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0;
    unint64_t v32 = 0x7FFFFFFFFFFFFFFLL;
    if (!v31) {
      unint64_t v32 = v30;
    }
    if (v32 >> 59) {
LABEL_70:
    }
      sub_19E37C7C4();
    uint64_t v33 = 4 * v32;
    uint64_t v34 = (void **)operator new(32 * v32);
    *a1 = v34;
    a1[1] = v34;
    a1[2] = &v34[v33];
    if (a2 != (void **)a3)
    {
      uint64_t v35 = 0;
      do
      {
        long long v36 = &v34[v35];
        uint64_t v37 = (char *)&a2[v35];
        if (SHIBYTE(a2[v35 + 2]) < 0)
        {
          sub_19E39369C(&v34[v35], *(void **)v37, *((void *)v37 + 1));
        }
        else
        {
          *(_OWORD *)long long v36 = *(_OWORD *)v37;
          v36[2] = (void *)*((void *)v37 + 2);
        }
        LODWORD(v34[v35 + 3]) = a2[v35 + 3];
        v35 += 4;
      }
      while (&a2[v35] != (void **)a3);
      uint64_t v34 = (void **)((char *)v34 + v35 * 8);
    }
    a1[1] = v34;
  }
}

uint64_t sub_19E44AD68(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 304;
    sub_19E4446FC(i - 304);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

os_log_t sub_19E44ADBC()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "InlineCompletionHypothesis");
  qword_1E9459E18 = (uint64_t)result;
  return result;
}

void sub_19E44ADEC(uint64_t a1)
{
  sub_19E4477F4((uint64_t)v1, a1, 0);
}

void sub_19E44BF8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void **a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,char a26)
{
  sub_19E4446FC((uint64_t)&a26);
  sub_19E448E78((void **)&STACK[0x3D8]);
  if (SLOBYTE(STACK[0x407]) < 0) {
    operator delete((void *)STACK[0x3F0]);
  }
  sub_19E3EC22C(a20);
  sub_19E3D73EC(v26 - 248);
  _Unwind_Resume(a1);
}

void sub_19E44C29C(void **a1, long long *a2)
{
  unint64_t v4 = (char *)a1[1];
  char v5 = (char *)a1[2];
  if (v4 >= v5)
  {
    unint64_t v8 = 0x84BDA12F684BDA13 * ((v4 - (unsigned char *)*a1) >> 3);
    unint64_t v9 = v8 + 1;
    if (v8 + 1 > 0x12F684BDA12F684) {
      sub_19E37C7C4();
    }
    unint64_t v10 = 0x84BDA12F684BDA13 * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x97B425ED097B42) {
      unint64_t v9 = 0x12F684BDA12F684;
    }
    if (v9 > 0x12F684BDA12F684) {
      sub_19E37C2B8();
    }
    uint64_t v11 = 216 * v9;
    unint64_t v12 = (char *)operator new(216 * v9);
    unint64_t v13 = &v12[216 * v8];
    *(_OWORD *)unint64_t v13 = *a2;
    size_t v14 = &v12[v11];
    *((void *)v13 + 2) = *((void *)a2 + 2);
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((_DWORD *)v13 + 6) = *((_DWORD *)a2 + 6);
    *((_OWORD *)v13 + 2) = a2[2];
    *((void *)v13 + 6) = *((void *)a2 + 6);
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)v13 + 9) = 0;
    *(_OWORD *)(v13 + 56) = *(long long *)((char *)a2 + 56);
    *((void *)v13 + 9) = *((void *)a2 + 9);
    *((void *)a2 + 6) = 0;
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 9) = 0;
    *((void *)v13 + 12) = 0;
    *((_OWORD *)v13 + 5) = a2[5];
    *((void *)v13 + 12) = *((void *)a2 + 12);
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 11) = 0;
    *((void *)v13 + 15) = 0;
    *(_OWORD *)(v13 + 104) = *(long long *)((char *)a2 + 104);
    *((void *)v13 + 15) = *((void *)a2 + 15);
    *((void *)a2 + 12) = 0;
    *((void *)a2 + 13) = 0;
    *((void *)a2 + 14) = 0;
    *((void *)a2 + 15) = 0;
    *((void *)v13 + 18) = 0;
    *((_OWORD *)v13 + 8) = a2[8];
    *((void *)v13 + 18) = *((void *)a2 + 18);
    *((void *)a2 + 16) = 0;
    *((void *)a2 + 17) = 0;
    *((void *)a2 + 18) = 0;
    *(_OWORD *)(v13 + 152) = *(long long *)((char *)a2 + 152);
    *((void *)v13 + 23) = 0;
    *(_OWORD *)(v13 + 168) = *(long long *)((char *)a2 + 168);
    *((void *)v13 + 23) = *((void *)a2 + 23);
    *((void *)a2 + 21) = 0;
    *((void *)a2 + 22) = 0;
    *((void *)v13 + 26) = 0;
    *((_OWORD *)v13 + 12) = a2[12];
    *((void *)v13 + 26) = *((void *)a2 + 26);
    *((void *)a2 + 23) = 0;
    *((void *)a2 + 24) = 0;
    *((void *)a2 + 25) = 0;
    *((void *)a2 + 26) = 0;
    unint64_t v7 = v13 + 216;
    unint64_t v15 = (char *)*a1;
    uint64_t v16 = (void **)a1[1];
    if (v16 == *a1)
    {
      *a1 = v13;
      a1[1] = v7;
      a1[2] = v14;
    }
    else
    {
      uint64_t v17 = 0;
      do
      {
        size_t v18 = (char *)&v16[v17];
        uint64_t v19 = &v13[v17 * 8];
        long long v20 = *(_OWORD *)&v16[v17 - 27];
        *((void *)v19 - 25) = v16[v17 - 25];
        *(_OWORD *)(v19 - 216) = v20;
        *((void *)v18 - 26) = 0;
        *((void *)v18 - 25) = 0;
        *((void *)v18 - 27) = 0;
        LODWORD(v20) = v16[v17 - 24];
        *((void *)v19 - 22) = 0;
        *((void *)v19 - 21) = 0;
        *((void *)v19 - 23) = 0;
        *((_DWORD *)v19 - 48) = v20;
        *(_OWORD *)(v19 - 184) = *(_OWORD *)&v16[v17 - 23];
        *((void *)v19 - 21) = v16[v17 - 21];
        *((void *)v18 - 23) = 0;
        *((void *)v18 - 22) = 0;
        *((void *)v18 - 21) = 0;
        *((void *)v19 - 20) = 0;
        *((void *)v19 - 19) = 0;
        *((void *)v19 - 18) = 0;
        *((_OWORD *)v19 - 10) = *(_OWORD *)&v16[v17 - 20];
        *((void *)v19 - 18) = v16[v17 - 18];
        *((void *)v18 - 20) = 0;
        *((void *)v18 - 19) = 0;
        *((void *)v18 - 18) = 0;
        *((void *)v19 - 17) = 0;
        *((void *)v19 - 16) = 0;
        *((void *)v19 - 15) = 0;
        *(_OWORD *)(v19 - 136) = *(_OWORD *)&v16[v17 - 17];
        *((void *)v19 - 15) = v16[v17 - 15];
        *((void *)v18 - 17) = 0;
        *((void *)v18 - 16) = 0;
        *((void *)v18 - 15) = 0;
        *((void *)v19 - 14) = 0;
        *((void *)v19 - 13) = 0;
        *((void *)v19 - 12) = 0;
        *((_OWORD *)v19 - 7) = *(_OWORD *)&v16[v17 - 14];
        *((void *)v19 - 12) = v16[v17 - 12];
        *((void *)v18 - 14) = 0;
        *((void *)v18 - 13) = 0;
        *((void *)v18 - 12) = 0;
        *((void *)v19 - 11) = 0;
        *((void *)v19 - 10) = 0;
        *((void *)v19 - 9) = 0;
        *(_OWORD *)(v19 - 88) = *(_OWORD *)&v16[v17 - 11];
        *((void *)v19 - 9) = v16[v17 - 9];
        *((void *)v18 - 10) = 0;
        *((void *)v18 - 9) = 0;
        long long v21 = *(_OWORD *)&v16[v17 - 8];
        *((void *)v18 - 11) = 0;
        *((_OWORD *)v19 - 4) = v21;
        *((void *)v19 - 5) = 0;
        *((void *)v19 - 4) = 0;
        *((void *)v19 - 6) = 0;
        *((_OWORD *)v19 - 3) = *(_OWORD *)&v16[v17 - 6];
        *((void *)v19 - 4) = v16[v17 - 4];
        *((void *)v18 - 6) = 0;
        *((void *)v18 - 5) = 0;
        *((void *)v18 - 4) = 0;
        *((void *)v19 - 3) = 0;
        *((void *)v19 - 2) = 0;
        *((void *)v19 - 1) = 0;
        *(_OWORD *)(v19 - 24) = *(_OWORD *)&v16[v17 - 3];
        *((void *)v19 - 1) = v16[v17 - 1];
        *((void *)v18 - 3) = 0;
        *((void *)v18 - 2) = 0;
        *((void *)v18 - 1) = 0;
        v17 -= 27;
      }
      while (&v16[v17] != (void **)v15);
      uint64_t v16 = (void **)*a1;
      long long v22 = (void **)a1[1];
      *a1 = &v13[v17 * 8];
      a1[1] = v7;
      a1[2] = v14;
      while (v22 != v16)
      {
        sub_19E3C3D24(v22 - 23);
        if (*((char *)v22 - 193) < 0) {
          operator delete(*(v22 - 27));
        }
        v22 -= 27;
      }
    }
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    long long v6 = *a2;
    *((void *)v4 + 2) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v4 = v6;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *((_DWORD *)v4 + 6) = *((_DWORD *)a2 + 6);
    *((void *)v4 + 5) = 0;
    *((void *)v4 + 6) = 0;
    *((void *)v4 + 4) = 0;
    *((_OWORD *)v4 + 2) = a2[2];
    *((void *)v4 + 6) = *((void *)a2 + 6);
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 6) = 0;
    *((void *)v4 + 7) = 0;
    *((void *)v4 + 8) = 0;
    *((void *)v4 + 9) = 0;
    *(_OWORD *)(v4 + 56) = *(long long *)((char *)a2 + 56);
    *((void *)v4 + 9) = *((void *)a2 + 9);
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 9) = 0;
    *((void *)v4 + 10) = 0;
    *((void *)v4 + 11) = 0;
    *((void *)v4 + 12) = 0;
    *((_OWORD *)v4 + 5) = a2[5];
    *((void *)v4 + 12) = *((void *)a2 + 12);
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 11) = 0;
    *((void *)a2 + 12) = 0;
    *((void *)v4 + 13) = 0;
    *((void *)v4 + 14) = 0;
    *((void *)v4 + 15) = 0;
    *(_OWORD *)(v4 + 104) = *(long long *)((char *)a2 + 104);
    *((void *)v4 + 15) = *((void *)a2 + 15);
    *((void *)a2 + 13) = 0;
    *((void *)a2 + 14) = 0;
    *((void *)a2 + 15) = 0;
    *((void *)v4 + 16) = 0;
    *((void *)v4 + 17) = 0;
    *((void *)v4 + 18) = 0;
    *((_OWORD *)v4 + 8) = a2[8];
    *((void *)v4 + 18) = *((void *)a2 + 18);
    *((void *)a2 + 17) = 0;
    *((void *)a2 + 18) = 0;
    *((void *)a2 + 16) = 0;
    *(_OWORD *)(v4 + 152) = *(long long *)((char *)a2 + 152);
    *((void *)v4 + 22) = 0;
    *((void *)v4 + 23) = 0;
    *((void *)v4 + 21) = 0;
    *(_OWORD *)(v4 + 168) = *(long long *)((char *)a2 + 168);
    *((void *)v4 + 23) = *((void *)a2 + 23);
    *((void *)a2 + 21) = 0;
    *((void *)a2 + 22) = 0;
    *((void *)a2 + 23) = 0;
    *((void *)v4 + 24) = 0;
    *((void *)v4 + 25) = 0;
    *((void *)v4 + 26) = 0;
    *((_OWORD *)v4 + 12) = a2[12];
    *((void *)v4 + 26) = *((void *)a2 + 26);
    *((void *)a2 + 24) = 0;
    *((void *)a2 + 25) = 0;
    *((void *)a2 + 26) = 0;
    unint64_t v7 = v4 + 216;
  }
  a1[1] = v7;
}

uint64_t sub_19E44C6E4(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E44C720(uint64_t a1)
{
  v6[14] = *(void **)MEMORY[0x1E4F143B8];
  unint64_t v2 = *(void **)(a1 + 72);
  uint64_t v4 = a1;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  v6[6] = v2;
  v6[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(void **__return_ptr))(*(void *)v2 + 32))(v6);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  sub_19E4477F4((uint64_t)v5, v4, 0);
}

void sub_19E44CFA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a44 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E44D0A4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  uint64_t v12 = a4;
  unint64_t v9 = operator new(0x28uLL);
  *unint64_t v9 = &unk_1EF0B50E0;
  v9[1] = &cf;
  _OWORD v9[2] = a2;
  v9[3] = &v12;
  v9[4] = a5;
  size_t v14 = v9;
  sub_19E3FCB90(a1, a2, a3, (uint64_t)v13);
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
    CFTypeRef v10 = cf;
    if (!cf) {
      return;
    }
    goto LABEL_7;
  }
  if (v14) {
    (*(void (**)(void))(*v14 + 40))();
  }
  CFTypeRef v10 = cf;
  if (cf) {
LABEL_7:
  }
    CFRelease(v10);
}

void sub_19E44D1D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E44D20C()
{
  return &unk_1EF0B4B98;
}

uint64_t sub_19E44D218(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v133enumerateComparableLexiconEntriesIN2LM22CompositeLanguageModelEEEvRKT_RKN"
                     "St3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS2_22TokenEnumerationPolicyEmRKNS7_"
                     "8functionIFvPK10__CFStringjdNS2_13SourceLexiconEPK10__CFLocaleRbEEEEUlSK_jdSL_SO_SP_E_"
    || ((v3 & (unint64_t)"ZN17language_modeling2v133enumerateComparableLexiconEntriesIN2LM22CompositeLanguageModel"
                                "EEEvRKT_RKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS2_22TokenEnu"
                                "merationPolicyEmRKNS7_8functionIFvPK10__CFStringjdNS2_13SourceLexiconEPK10__CFLocaleRbEE"
                                "EEUlSK_jdSL_SO_SP_E_" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v133enumerateComparableLexiconEntriesIN2LM22CompositeLanguageModelEEEvRKT_RKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS2_22TokenEnumerationPolicyEmRKNS7_8functionIFvPK10__CFStringjdNS2_13SourceLexiconEPK10__CFLocaleRbEEEEUlSK_jdSL_SO_SP_E_")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v133enumerateComparableLexiconEntriesIN2LM22CompositeLanguageModelEEEvRKT_RKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS2_22TokenEnumerationPolicyEmRKNS7_8functionIFvPK10__CFStringjdNS2_13SourceLexiconEPK10__CFLocaleRbEEEEUlSK_jdSL_SO_SP_E_" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

CFComparisonResult sub_19E44D270(uint64_t a1, const __CFString **a2, int *a3, uint64_t *a4, int *a5, const __CFLocale **a6, uint64_t a7)
{
  CFStringRef v9 = *a2;
  int v10 = *a3;
  uint64_t v11 = *a4;
  int v12 = *a5;
  CFLocaleRef v13 = *a6;
  size_t v14 = *(void **)(a1 + 8);
  if (!*v14)
  {
    uint64_t v15 = *(const UInt8 **)(a1 + 16);
    if ((char)v15[23] < 0)
    {
      if (!*(void *)v15)
      {
        void *v14 = 0;
        goto LABEL_10;
      }
      CFIndex v16 = *((void *)v15 + 1);
      uint64_t v15 = *(const UInt8 **)v15;
    }
    else
    {
      CFIndex v16 = v15[23];
    }
    CFStringRef v17 = CFStringCreateWithBytes(0, v15, v16, 0x8000100u, 0);
    if (!v17)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    CFStringRef v18 = v17;
    uint64_t v19 = *(const void ***)(a1 + 8);
    long long v20 = *v19;
    char *v19 = v18;
    if (v20) {
      CFRelease(v20);
    }
  }
LABEL_10:
  CFStringRef v21 = **(const __CFString ***)(a1 + 8);
  v31.length = CFStringGetLength(v21);
  v31.CFIndex location = 0;
  CFComparisonResult result = CFStringCompareWithOptionsAndLocale(v21, v9, v31, **(void **)(a1 + 24), v13);
  if (result == kCFCompareEqualTo)
  {
    uint64_t v23 = *(void *)(a1 + 32);
    CFStringRef v30 = v9;
    int v29 = v10;
    uint64_t v28 = v11;
    int v27 = v12;
    CFLocaleRef v26 = v13;
    uint64_t v24 = *(void *)(v23 + 24);
    if (!v24) {
      sub_19E3ACB9C();
    }
    return (*(uint64_t (**)(uint64_t, const __CFString **, int *, uint64_t *, int *, const __CFLocale **, uint64_t))(*(void *)v24 + 48))(v24, &v30, &v29, &v28, &v27, &v26, a7);
  }
  return result;
}

void sub_19E44D404(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 sub_19E44D424(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0B50E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E44D454(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = &unk_1EF0B50E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_19E44D4A8()
{
}

void *sub_19E44D4C0()
{
  return &unk_1EF0B8158;
}

uint64_t sub_19E44D4CC(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN2LML24isPhraseMatchFromLexiconERKNS_22CompositeLanguageModelERKNSt3__112basic_stringIcNS3_11char_"
                     "traitsIcEENS3_9allocatorIcEEEEE3$_0"
    || ((v3 & (unint64_t)"ZN2LML24isPhraseMatchFromLexiconERKNS_22CompositeLanguageModelERKNSt3__112basic_stringIc"
                                "NS3_11char_traitsIcEENS3_9allocatorIcEEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN2LML24isPhraseMatchFromLexiconERKNS_22CompositeLanguageModelERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN2LML24isPhraseMatchFromLexiconERKNS_22CompositeLanguageModelERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E44D524(uint64_t a1, const __CFString **a2, uint64_t a3, double *a4, uint64_t a5, const __CFLocale **a6, unsigned char *a7)
{
  CFStringRef v8 = *a2;
  double v9 = *a4;
  CFLocaleRef v10 = *a6;
  uint64_t v11 = *(uint64_t **)(a1 + 8);
  CFStringRef v12 = **(const __CFString ***)(a1 + 16);
  double v13 = **(double **)(a1 + 24);
  CFIndex Length = CFStringGetLength(v12);
  if (Length == CFStringGetLength(v8)
    && (v23.length = CFStringGetLength(v12),
        v23.CFIndex location = 0,
        CFStringCompareWithOptionsAndLocale(v12, v8, v23, 0, v10) == kCFCompareEqualTo))
  {
    sub_19E37774C(v8, &v21);
    uint64_t v17 = *v11;
    if (*(unsigned char *)(*v11 + 24))
    {
      if (*(char *)(v17 + 23) < 0) {
        operator delete(*(void **)v17);
      }
      long long v18 = v21;
      *(void *)(v17 + 16) = v22;
      *(_OWORD *)uint64_t v17 = v18;
    }
    else
    {
      long long v20 = v21;
      *(void *)(v17 + 16) = v22;
      *(_OWORD *)uint64_t v17 = v20;
      *(unsigned char *)(v17 + 24) = 1;
    }
    *a7 = 1;
  }
  else if (v13 < v9)
  {
    sub_19E37774C(v8, &v21);
    uint64_t v15 = *v11;
    if (*(unsigned char *)(*v11 + 24))
    {
      if (*(char *)(v15 + 23) < 0) {
        operator delete(*(void **)v15);
      }
      long long v16 = v21;
      *(void *)(v15 + 16) = v22;
      *(_OWORD *)uint64_t v15 = v16;
    }
    else
    {
      long long v19 = v21;
      *(void *)(v15 + 16) = v22;
      *(_OWORD *)uint64_t v15 = v19;
      *(unsigned char *)(v15 + 24) = 1;
    }
  }
}

__n128 sub_19E44D688(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0B5608;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E44D6B8(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &unk_1EF0B5608;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E44D70C()
{
}

uint64_t sub_19E44D724(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 216;
    sub_19E3C3D24((void **)(i - 184));
    if (*(char *)(i - 193) < 0) {
      operator delete(*(void **)(i - 216));
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E44D794(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, unsigned int a7, uint64_t a8, uint64_t a9)
{
  if (qword_1EC009570 != -1) {
    dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
  }
  os_signpost_id_t v14 = os_signpost_id_generate((os_log_t)qword_1EC009568);
  if (qword_1EC009570 != -1) {
    dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
  }
  unint64_t v15 = v14 - 1;
  if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    long long v16 = qword_1EC009568;
    if (os_signpost_enabled((os_log_t)qword_1EC009568))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl(&dword_19E36B000, v16, OS_SIGNPOST_INTERVAL_BEGIN, v14, "ToucanGenerateInlineCompletions", (const char *)&unk_19E5812E5, buf, 2u);
    }
  }
  if (*a2 == a2[1]) {
    __assert_rtn("generateCompletions", "MultiWordBeamSearchPredictor.cpp", 554, "!stems.empty()");
  }
  if (!a5 || !a6) {
    __assert_rtn("generateCompletions", "MultiWordBeamSearchPredictor.cpp", 555, "minWordsPerPrediction > 0 && maxWordsPerPrediction > 0");
  }
  if (a6 < a5) {
    __assert_rtn("generateCompletions", "MultiWordBeamSearchPredictor.cpp", 556, "maxWordsPerPrediction >= minWordsPerPrediction");
  }
  (*(void (**)(uint64_t, uint64_t, void *, uint64_t, unint64_t, unint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 32))(a1, a3, a2, a4, a5, a6, a7, a8, a9);
  if (qword_1EC009570 == -1)
  {
    if (v15 > 0xFFFFFFFFFFFFFFFDLL) {
      return;
    }
  }
  else
  {
    dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
    if (v15 > 0xFFFFFFFFFFFFFFFDLL) {
      return;
    }
  }
  uint64_t v17 = qword_1EC009568;
  if (os_signpost_enabled((os_log_t)qword_1EC009568))
  {
    *(_WORD *)long long v21 = 0;
    _os_signpost_emit_with_name_impl(&dword_19E36B000, v17, OS_SIGNPOST_INTERVAL_END, v14, "ToucanGenerateInlineCompletions", (const char *)&unk_19E5812E5, v21, 2u);
  }
}

void sub_19E44D9F4(void *a1)
{
  sub_19E44DA2C(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E44DA2C(void *a1)
{
  *a1 = &unk_1EF0BBCE0;
  uint64_t v2 = (void *)a1[26];
  if (v2)
  {
    a1[27] = v2;
    operator delete(v2);
  }
  sub_19E44DB14(a1 + 9);
  unint64_t v3 = (void *)a1[6];
  if (v3)
  {
    do
    {
      uint64_t v4 = (void *)*v3;
      operator delete(v3);
      unint64_t v3 = v4;
    }
    while (v4);
  }
  char v5 = (void *)a1[4];
  a1[4] = 0;
  if (v5) {
    operator delete(v5);
  }
  long long v6 = (std::__shared_weak_count *)a1[3];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    unint64_t v7 = (const void *)a1[1];
    if (!v7) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  unint64_t v7 = (const void *)a1[1];
  if (v7) {
LABEL_10:
  }
    CFRelease(v7);
LABEL_11:
  a1[1] = 0;
  return a1;
}

void *sub_19E44DB14(void *a1)
{
  uint64_t v2 = (void *)a1[14];
  if (v2)
  {
    do
    {
      CFLocaleRef v10 = (void *)*v2;
      uint64_t v11 = (void *)v2[5];
      if (v11)
      {
        do
        {
          CFStringRef v12 = (void *)*v11;
          operator delete(v11);
          uint64_t v11 = v12;
        }
        while (v12);
      }
      double v13 = (void *)v2[3];
      v2[3] = 0;
      if (v13) {
        operator delete(v13);
      }
      operator delete(v2);
      uint64_t v2 = v10;
    }
    while (v10);
  }
  unint64_t v3 = (void *)a1[12];
  a1[12] = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[9];
  if (v4)
  {
    do
    {
      os_signpost_id_t v14 = (void *)*v4;
      unint64_t v15 = (void *)v4[5];
      if (v15)
      {
        do
        {
          long long v16 = (void *)*v15;
          operator delete(v15);
          unint64_t v15 = v16;
        }
        while (v16);
      }
      uint64_t v17 = (void *)v4[3];
      void v4[3] = 0;
      if (v17) {
        operator delete(v17);
      }
      operator delete(v4);
      uint64_t v4 = v14;
    }
    while (v14);
  }
  char v5 = (void *)a1[7];
  a1[7] = 0;
  if (v5) {
    operator delete(v5);
  }
  long long v6 = (const void *)a1[5];
  if (v6) {
    CFRelease(v6);
  }
  a1[5] = 0;
  unint64_t v7 = (std::__shared_weak_count *)a1[3];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  CFStringRef v8 = (std::__shared_weak_count *)a1[1];
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  return a1;
}

uint64_t sub_19E44DC98(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4, int a5, uint64_t a6, uint64_t a7, int a8)
{
  *(void *)a1 = &unk_1EF0BBCE0;
  unint64_t v15 = (CFLocaleRef *)(a1 + 8);
  char v16 = *(unsigned char *)(a6 + 23);
  if (v16 >= 0) {
    uint64_t v17 = (const UInt8 *)a6;
  }
  else {
    uint64_t v17 = *(const UInt8 **)a6;
  }
  if (v17)
  {
    if (v16 >= 0) {
      CFIndex v18 = *(unsigned __int8 *)(a6 + 23);
    }
    else {
      CFIndex v18 = *(void *)(a6 + 8);
    }
    CFStringRef v19 = CFStringCreateWithBytes(0, v17, v18, 0x8000100u, 0);
    __p[0] = (void *)v19;
    if (!v19)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFStringRef v19 = 0;
    __p[0] = 0;
  }
  *unint64_t v15 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v19);
  if (v19) {
    CFRelease(v19);
  }
  int v36 = a5;
  uint64_t v37 = a7;
  int v38 = a8;
  *(void *)(a1 + 16) = *a4;
  uint64_t v21 = a4[1];
  *(void *)(a1 + 24) = v21;
  if (v21) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = 0;
  uint64_t v23 = *a3;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 1065353216;
  do
  {
    uint64_t v24 = off_1E599FF58[v22];
    size_t v25 = strlen(v24);
    if (v25 >= 0x7FFFFFFFFFFFFFF8) {
      sub_19E37C958();
    }
    CFLocaleRef v26 = (void *)v25;
    if (v25 >= 0x17)
    {
      uint64_t v28 = (v25 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v25 | 7) != 0x17) {
        uint64_t v28 = v25 | 7;
      }
      uint64_t v29 = v28 + 1;
      int v27 = (void **)operator new(v28 + 1);
      __dst[1] = v26;
      unint64_t v43 = v29 | 0x8000000000000000;
      __dst[0] = v27;
LABEL_24:
      memmove(v27, v24, (size_t)v26);
      goto LABEL_25;
    }
    HIBYTE(v43) = v25;
    int v27 = __dst;
    if (v25) {
      goto LABEL_24;
    }
LABEL_25:
    *((unsigned char *)v26 + (void)v27) = 0;
    int v44 = 0;
    sub_19E371C70(__p, (const UInt8 *)__dst);
    int v47 = v44;
    (*(void (**)(unsigned int **__return_ptr, uint64_t, void **))(*(void *)v23 + 16))(&v48, v23, __p);
    if (v46 < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v43) & 0x80000000) == 0) {
        goto LABEL_27;
      }
    }
    else if ((SHIBYTE(v43) & 0x80000000) == 0)
    {
      goto LABEL_27;
    }
    operator delete(__dst[0]);
LABEL_27:
    CFStringRef v30 = v48;
    if ((char *)v49 - (char *)v48 == 4)
    {
      sub_19E4435B0((float *)(a1 + 32), *v48, *v48);
      CFStringRef v30 = v48;
    }
    if (v30)
    {
      size_t v49 = v30;
      operator delete(v30);
    }
    ++v22;
  }
  while (v22 != 5);
  uint64_t v31 = a2[1];
  uint64_t v40 = *a2;
  long long v41 = (std::__shared_weak_count *)v31;
  if (v31) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v32 = *a3;
  uint64_t v33 = (std::__shared_weak_count *)a3[1];
  if (v33) {
    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_19E4E11C0((uint64_t *)(a1 + 72), &v40, v32, (uint64_t)v33, v36, a6, v37, v38);
  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  uint64_t v34 = v41;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  return a1;
}

void sub_19E44E054(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E44E070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  sub_19E3D73EC((uint64_t)&a17);
  sub_19E3D73EC((uint64_t)&a19);
  sub_19E397D90(v33);
  sub_19E3D73EC(a9);
  sub_19E3F68C0(a10);
  _Unwind_Resume(a1);
}

os_log_t sub_19E44E110()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "Default");
  qword_1EC0095B0 = (uint64_t)result;
  return result;
}

os_log_t sub_19E44E140()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "LanguageModelingSignposts");
  qword_1EC009568 = (uint64_t)result;
  return result;
}

void sub_19E44E170(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v2 = *(void ***)(a1 + 40);
    if (v2)
    {
      do
      {
        CFStringRef v8 = (void **)*v2;
        if (*((char *)v2 + 39) < 0) {
          operator delete(v2[2]);
        }
        operator delete(v2);
        uint64_t v2 = v8;
      }
      while (v8);
    }
    *(void *)(a1 + 40) = 0;
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(a1 + 24) + 8 * i) = 0;
    }
    *(void *)(a1 + 48) = 0;
  }
  if (*(void *)(a1 + 88))
  {
    char v5 = *(void ***)(a1 + 80);
    if (v5)
    {
      do
      {
        double v9 = (void **)*v5;
        if (*((char *)v5 + 55) < 0) {
          operator delete(v5[4]);
        }
        operator delete(v5);
        char v5 = v9;
      }
      while (v9);
    }
    *(void *)(a1 + 80) = 0;
    uint64_t v6 = *(void *)(a1 + 72);
    if (v6)
    {
      for (uint64_t j = 0; j != v6; ++j)
        *(void *)(*(void *)(a1 + 64) + 8 * j) = 0;
    }
    *(void *)(a1 + 88) = 0;
  }
  *(void *)(a1 + 112) = *(void *)(a1 + 104);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
  *(unsigned char *)(a1 + 152) = 0;
}

void sub_19E44E26C(unsigned char *a1)
{
  if (a1[152])
  {
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterPostNotification(LocalCenter, @"VocabularyDidChange", a1, 0, 0);
    a1[152] = 0;
  }
}

void sub_19E44E2B4(const void *a1, const void *a2)
{
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(LocalCenter, a2, @"VocabularyDidChange", a1);
}

void sub_19E44E2FC(const void *a1, const void *a2, void (__cdecl *a3)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))
{
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, a2, a3, @"VocabularyDidChange", a1, CFNotificationSuspensionBehaviorHold);
}

BOOL sub_19E44E358(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[9];
  if (!v2) {
    goto LABEL_21;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  char v5 = *(uint64_t ***)(a1[8] + 8 * v4);
  if (!v5 || (uint64_t v6 = *v5) == 0)
  {
LABEL_21:
    int v10 = 0;
    return v10 && v10 == a2;
  }
  if (v3.u32[0] < 2uLL)
  {
    unint64_t v7 = v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (*((_DWORD *)v6 + 4) == a2) {
          goto LABEL_28;
        }
      }
      else if ((v9 & v7) != v4)
      {
        goto LABEL_21;
      }
      uint64_t v6 = (uint64_t *)*v6;
      if (!v6) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= v2) {
      v8 %= v2;
    }
    if (v8 != v4) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v6 = (uint64_t *)*v6;
    if (!v6) {
      goto LABEL_21;
    }
  }
  if (*((_DWORD *)v6 + 4) != a2) {
    goto LABEL_11;
  }
LABEL_28:
  int v10 = *(_DWORD *)(a1[13] + 24 * *((unsigned int *)v6 + 6));
  return v10 && v10 == a2;
}

void sub_19E44E454(uint64_t a1, unsigned __int32 a2, uint64_t a3, __n128 a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(void *)(a1 + 112);
  if (v5 == v6)
  {
    unint64_t v8 = 0;
    int v10 = 0;
  }
  else
  {
    unint64_t v8 = 0;
    uint64_t v9 = 0;
    int v10 = 0;
    do
    {
      unsigned __int32 v12 = *(_DWORD *)v5;
      int v11 = *(_DWORD *)(v5 + 4);
      int v13 = *(_DWORD *)(v5 + 8);
      unint64_t v28 = *(void *)(v5 + 12);
      unsigned __int32 v29 = *(_DWORD *)(v5 + 20);
      if (v12 == v11 && v13 == a2)
      {
        if (v8 < v9)
        {
          v8->n128_u32[0] = v12;
          v8->n128_u32[1] = v12;
          v8->n128_u32[2] = a2;
          *(unint64_t *)((char *)&v8->n128_u64[1] + 4) = v28;
          v8[1].n128_u32[1] = v29;
          unint64_t v8 = (__n128 *)((char *)v8 + 24);
        }
        else
        {
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (char *)v10) >> 3) + 1;
          if (v15 > 0xAAAAAAAAAAAAAAALL) {
            sub_19E37C7C4();
          }
          if (0x5555555555555556 * (((char *)v9 - (char *)v10) >> 3) > v15) {
            unint64_t v15 = 0x5555555555555556 * (((char *)v9 - (char *)v10) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (char *)v10) >> 3) >= 0x555555555555555) {
            unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v16 = v15;
          }
          if (v16)
          {
            if (v16 > 0xAAAAAAAAAAAAAAALL) {
              sub_19E37C2B8();
            }
            uint64_t v17 = (char *)operator new(24 * v16);
          }
          else
          {
            uint64_t v17 = 0;
          }
          CFIndex v18 = &v17[8 * (((char *)v8 - (char *)v10) >> 3)];
          *(_DWORD *)CFIndex v18 = v12;
          *((_DWORD *)v18 + 1) = v12;
          *((_DWORD *)v18 + 2) = a2;
          *(void *)(v18 + 12) = v28;
          *((_DWORD *)v18 + 5) = v29;
          if (v8 == v10)
          {
            long long v20 = &v17[8 * (((char *)v8 - (char *)v10) >> 3)];
          }
          else
          {
            CFStringRef v19 = &v17[8 * (((char *)v8 - (char *)v10) >> 3)];
            do
            {
              a4 = *(__n128 *)((char *)v8 - 24);
              long long v20 = v19 - 24;
              *((void *)v19 - 1) = v8[-1].n128_u64[1];
              *(__n128 *)(v19 - 24) = a4;
              unint64_t v8 = (__n128 *)((char *)v8 - 24);
              v19 -= 24;
            }
            while (v8 != v10);
          }
          uint64_t v9 = (__n128 *)&v17[24 * v16];
          unint64_t v8 = (__n128 *)(v18 + 24);
          if (v10) {
            operator delete(v10);
          }
          int v10 = (__n128 *)v20;
        }
      }
      v5 += 24;
    }
    while (v5 != v6);
  }
  unint64_t v21 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (char *)v10) >> 3));
  if (v8 == v10) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = v21;
  }
  sub_19E44E6F8((unint64_t)v10, v8, v22, 1, a4);
  LOBYTE(v28) = 0;
  if (v10 != v8)
  {
    uint64_t v23 = (__n128 *)((char *)v10 + 24);
    do
    {
      long long v24 = *(long long *)((char *)&v23[-2] + 8);
      uint64_t v27 = v23[-1].n128_i64[1];
      long long v26 = v24;
      (*(void (**)(uint64_t, long long *, unint64_t *))(a3 + 16))(a3, &v26, &v28);
      if ((_BYTE)v28) {
        BOOL v25 = 1;
      }
      else {
        BOOL v25 = v23 == v8;
      }
      uint64_t v23 = (__n128 *)((char *)v23 + 24);
    }
    while (!v25);
  }
  if (v10) {
    operator delete(v10);
  }
}

void sub_19E44E6D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

double sub_19E44E6F8(unint64_t a1, __n128 *a2, uint64_t a3, char a4, __n128 a5)
{
  while (2)
  {
    int v11 = (__n128 *)((char *)a2 - 24);
    unsigned __int32 v12 = a2 - 3;
    int v13 = &a2[-5].n128_i8[8];
    unint64_t v14 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v14;
          uint64_t v15 = (uint64_t)a2 - v14;
          uint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v14) >> 3);
          if (v6 || !v5)
          {
            switch(v16)
            {
              case 0:
              case 1:
                return a5.n128_f64[0];
              case 2:
                a5.n128_u64[0] = a2[-1].n128_u64[1];
                if (a5.n128_f64[0] <= *(double *)(v14 + 16)) {
                  return a5.n128_f64[0];
                }
                goto LABEL_103;
              case 3:
                unint64_t v92 = (__n128 *)(v14 + 24);
                a5.n128_u64[0] = *(void *)(v14 + 40);
                double v93 = a2[-1].n128_f64[1];
                if (a5.n128_f64[0] > *(double *)(v14 + 16))
                {
                  if (v93 <= a5.n128_f64[0])
                  {
                    uint64_t v193 = *(void *)(v14 + 16);
                    __n128 v170 = *(__n128 *)v14;
                    *(__n128 *)unint64_t v14 = *v92;
                    *(void *)(v14 + 16) = *(void *)(v14 + 40);
                    *unint64_t v92 = v170;
                    *(void *)(v14 + 40) = v193;
                    a5.n128_u64[0] = a2[-1].n128_u64[1];
                    if (a5.n128_f64[0] <= *(double *)(v14 + 40)) {
                      return a5.n128_f64[0];
                    }
                    a5 = *v92;
                    unint64_t v139 = *(void *)(v14 + 40);
                    unint64_t v140 = a2[-1].n128_u64[1];
                    *unint64_t v92 = *v11;
                    *(void *)(v14 + 40) = v140;
                    a2[-1].n128_u64[1] = v139;
                  }
                  else
                  {
LABEL_103:
                    unint64_t v189 = *(void *)(v14 + 16);
                    __n128 v163 = *(__n128 *)v14;
                    __n128 v94 = *v11;
                    *(void *)(v14 + 16) = a2[-1].n128_u64[1];
                    *(__n128 *)unint64_t v14 = v94;
                    a5 = v163;
                    a2[-1].n128_u64[1] = v189;
                  }
                  __n128 *v11 = a5;
                  return a5.n128_f64[0];
                }
                if (v93 > a5.n128_f64[0])
                {
                  a5 = *v92;
                  unint64_t v134 = *(void *)(v14 + 40);
                  unint64_t v135 = a2[-1].n128_u64[1];
                  *unint64_t v92 = *v11;
                  *(void *)(v14 + 40) = v135;
                  a2[-1].n128_u64[1] = v134;
                  __n128 *v11 = a5;
                  a5.n128_u64[0] = *(void *)(v14 + 40);
                  if (a5.n128_f64[0] > *(double *)(v14 + 16))
                  {
                    uint64_t v192 = *(void *)(v14 + 16);
                    __n128 v168 = *(__n128 *)v14;
                    *(__n128 *)unint64_t v14 = *v92;
                    *(void *)(v14 + 16) = *(void *)(v14 + 40);
                    a5.n128_u64[0] = v168.n128_u64[0];
                    *unint64_t v92 = v168;
                    *(void *)(v14 + 40) = v192;
                  }
                }
                break;
              case 4:
                a5.n128_u64[0] = sub_19E44F680((__n128 *)v14, (__n128 *)(v14 + 24), (__n128 *)(v14 + 48), (__n128 *)((char *)a2 - 24), a5).n128_u64[0];
                return a5.n128_f64[0];
              case 5:
                uint64_t v95 = (__n128 *)(v14 + 24);
                char v96 = (__n128 *)(v14 + 48);
                unint64_t v97 = (__n128 *)(v14 + 72);
                sub_19E44F680((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a1 + 72), a5);
                a5.n128_u64[0] = a2[-1].n128_u64[1];
                if (a5.n128_f64[0] > *(double *)(a1 + 88))
                {
                  a5 = *v97;
                  unint64_t v98 = *(void *)(a1 + 88);
                  unint64_t v99 = a2[-1].n128_u64[1];
                  *unint64_t v97 = *v11;
                  *(void *)(a1 + 88) = v99;
                  a2[-1].n128_u64[1] = v98;
                  __n128 *v11 = a5;
                  a5.n128_u64[0] = *(void *)(a1 + 88);
                  if (a5.n128_f64[0] > *(double *)(a1 + 64))
                  {
                    uint64_t v100 = *(void *)(a1 + 64);
                    a5 = *v96;
                    __n128 *v96 = *v97;
                    *(void *)(a1 + 64) = *(void *)(a1 + 88);
                    *unint64_t v97 = a5;
                    *(void *)(a1 + 88) = v100;
                    a5.n128_u64[0] = *(void *)(a1 + 64);
                    if (a5.n128_f64[0] > *(double *)(a1 + 40))
                    {
                      uint64_t v101 = *(void *)(a1 + 40);
                      a5 = *v95;
                      *uint64_t v95 = *v96;
                      *(void *)(a1 + 40) = *(void *)(a1 + 64);
                      __n128 *v96 = a5;
                      *(void *)(a1 + 64) = v101;
                      a5.n128_u64[0] = *(void *)(a1 + 40);
                      if (a5.n128_f64[0] > *(double *)(a1 + 16))
                      {
                        uint64_t v190 = *(void *)(a1 + 16);
                        __n128 v164 = *(__n128 *)a1;
                        *(__n128 *)a1 = *v95;
                        *(void *)(a1 + 16) = *(void *)(a1 + 40);
                        a5.n128_u64[0] = v164.n128_u64[0];
                        *uint64_t v95 = v164;
                        *(void *)(a1 + 40) = v190;
                      }
                    }
                  }
                }
                return a5.n128_f64[0];
              default:
                JUMPOUT(0);
            }
            return a5.n128_f64[0];
          }
          if (v15 <= 575)
          {
            long long v102 = (__n128 *)(v14 + 24);
            BOOL v104 = (__n128 *)v14 == a2 || v102 == a2;
            if (a4)
            {
              if (!v104)
              {
                uint64_t v105 = 0;
                size_t v106 = (__n128 *)v14;
                do
                {
                  a5.n128_u64[0] = v106[2].n128_u64[1];
                  double v108 = v106[1].n128_f64[0];
                  size_t v106 = v102;
                  if (a5.n128_f64[0] > v108)
                  {
                    __n128 v165 = *v102;
                    uint64_t v109 = v105;
                    do
                    {
                      uint64_t v110 = v14 + v109;
                      *(_OWORD *)(v110 + 24) = *(_OWORD *)(v14 + v109);
                      *(void *)(v110 + 40) = *(void *)(v14 + v109 + 16);
                      if (!v109)
                      {
                        uint64_t v107 = v14;
                        goto LABEL_123;
                      }
                      v109 -= 24;
                    }
                    while (a5.n128_f64[0] > *(double *)(v110 - 8));
                    uint64_t v107 = v14 + v109 + 24;
LABEL_123:
                    *(__n128 *)uint64_t v107 = v165;
                    *(void *)(v107 + 16) = a5.n128_u64[0];
                  }
                  long long v102 = (__n128 *)((char *)v106 + 24);
                  v105 += 24;
                }
                while (&v106[1].n128_i8[8] != (__int8 *)a2);
              }
            }
            else if (!v104)
            {
              do
              {
                a5.n128_u64[0] = *(void *)(a1 + 40);
                double v136 = *(double *)(a1 + 16);
                a1 = (unint64_t)v102;
                if (a5.n128_f64[0] > v136)
                {
                  __n128 v169 = *v102;
                  size_t v137 = v102;
                  do
                  {
                    *size_t v137 = *(__n128 *)((char *)v137 - 24);
                    v137[1].n128_u64[0] = v137[-1].n128_u64[1];
                    double v138 = v137[-2].n128_f64[0];
                    size_t v137 = (__n128 *)((char *)v137 - 24);
                  }
                  while (a5.n128_f64[0] > v138);
                  *size_t v137 = v169;
                  v137[1].n128_u64[0] = a5.n128_u64[0];
                }
                long long v102 = (__n128 *)((char *)v102 + 24);
              }
              while ((__n128 *)(a1 + 24) != a2);
            }
            return a5.n128_f64[0];
          }
          if (!a3)
          {
            if ((__n128 *)v14 != a2)
            {
              int64_t v111 = (unint64_t)(v16 - 2) >> 1;
              int64_t v112 = v111;
              do
              {
                if (v111 >= v112)
                {
                  uint64_t v114 = (2 * v112) | 1;
                  unint64_t v115 = v14 + 24 * v114;
                  if (2 * v112 + 2 < v16 && *(double *)(v115 + 16) > *(double *)(v115 + 40))
                  {
                    v115 += 24;
                    uint64_t v114 = 2 * v112 + 2;
                  }
                  unint64_t v116 = v14 + 24 * v112;
                  double v117 = *(double *)(v116 + 16);
                  if (*(double *)(v115 + 16) <= v117)
                  {
                    long long v166 = *(_OWORD *)v116;
                    do
                    {
                      unint64_t v118 = v116;
                      unint64_t v116 = v115;
                      long long v119 = *(_OWORD *)v115;
                      *(void *)(v118 + 16) = *(void *)(v115 + 16);
                      *(_OWORD *)unint64_t v118 = v119;
                      if (v111 < v114) {
                        break;
                      }
                      uint64_t v120 = 2 * v114;
                      uint64_t v114 = (2 * v114) | 1;
                      unint64_t v115 = v14 + 24 * v114;
                      uint64_t v121 = v120 + 2;
                      if (v121 < v16 && *(double *)(v115 + 16) > *(double *)(v115 + 40))
                      {
                        v115 += 24;
                        uint64_t v114 = v121;
                      }
                    }
                    while (*(double *)(v115 + 16) <= v117);
                    *(_OWORD *)unint64_t v116 = v166;
                    *(double *)(v116 + 16) = v117;
                  }
                }
                BOOL v113 = v112-- <= 0;
              }
              while (!v113);
              int64_t v122 = v15 / 0x18uLL;
              do
              {
                uint64_t v123 = 0;
                unint64_t v191 = *(void *)(v14 + 16);
                __n128 v167 = *(__n128 *)v14;
                uint64_t v124 = (__n128 *)v14;
                do
                {
                  uint64_t v126 = v124;
                  uint64_t v124 = (__n128 *)((char *)v124 + 24 * v123 + 24);
                  uint64_t v127 = 2 * v123;
                  uint64_t v123 = (2 * v123) | 1;
                  int64_t v128 = v127 + 2;
                  if (v128 < v122 && v124[1].n128_f64[0] > v124[2].n128_f64[1])
                  {
                    uint64_t v124 = (__n128 *)((char *)v124 + 24);
                    uint64_t v123 = v128;
                  }
                  __n128 v125 = *v124;
                  v126[1].n128_u64[0] = v124[1].n128_u64[0];
                  __n128 *v126 = v125;
                }
                while (v123 <= (uint64_t)((unint64_t)(v122 - 2) >> 1));
                a2 = (__n128 *)((char *)a2 - 24);
                if (v124 == a2)
                {
                  a5.n128_u64[0] = v167.n128_u64[0];
                  v124[1].n128_u64[0] = v191;
                  *uint64_t v124 = v167;
                }
                else
                {
                  a5 = *a2;
                  v124[1].n128_u64[0] = a2[1].n128_u64[0];
                  *uint64_t v124 = a5;
                  a5.n128_u64[0] = v167.n128_u64[0];
                  a2[1].n128_u64[0] = v191;
                  *a2 = v167;
                  uint64_t v129 = (uint64_t)&v124[1].n128_i64[1] - v14;
                  if (v129 >= 25)
                  {
                    unint64_t v130 = (v129 / 0x18uLL - 2) >> 1;
                    unint64_t v131 = v14 + 24 * v130;
                    a5.n128_u64[0] = v124[1].n128_u64[0];
                    if (*(double *)(v131 + 16) > a5.n128_f64[0])
                    {
                      __n128 v144 = *v124;
                      do
                      {
                        uint64_t v132 = v124;
                        uint64_t v124 = (__n128 *)v131;
                        __n128 v133 = *(__n128 *)v131;
                        v132[1].n128_u64[0] = *(void *)(v131 + 16);
                        __n128 *v132 = v133;
                        if (!v130) {
                          break;
                        }
                        unint64_t v130 = (v130 - 1) >> 1;
                        unint64_t v131 = v14 + 24 * v130;
                      }
                      while (*(double *)(v131 + 16) > a5.n128_f64[0]);
                      *uint64_t v124 = v144;
                      v124[1].n128_u64[0] = a5.n128_u64[0];
                    }
                  }
                }
                BOOL v113 = v122-- <= 2;
              }
              while (!v113);
            }
            return a5.n128_f64[0];
          }
          unint64_t v17 = (unint64_t)v16 >> 1;
          CFIndex v18 = (__n128 *)(v14 + 24 * ((unint64_t)v16 >> 1));
          double v19 = a2[-1].n128_f64[1];
          if ((unint64_t)v15 >= 0xC01) {
            break;
          }
          double v22 = *(double *)(v14 + 16);
          if (v22 > v18[1].n128_f64[0])
          {
            if (v19 <= v22)
            {
              unint64_t v179 = v18[1].n128_u64[0];
              __n128 v153 = *v18;
              a5 = *(__n128 *)v14;
              v18[1].n128_u64[0] = *(void *)(v14 + 16);
              *CFIndex v18 = a5;
              a5.n128_u64[1] = v153.n128_u64[1];
              *(void *)(v14 + 16) = v179;
              *(__n128 *)unint64_t v14 = v153;
              if (a2[-1].n128_f64[1] <= *(double *)(v14 + 16)) {
                goto LABEL_32;
              }
              unint64_t v172 = *(void *)(v14 + 16);
              __n128 v146 = *(__n128 *)v14;
              __n128 v40 = *v11;
              *(void *)(v14 + 16) = a2[-1].n128_u64[1];
              *(__n128 *)unint64_t v14 = v40;
            }
            else
            {
              unint64_t v172 = v18[1].n128_u64[0];
              __n128 v146 = *v18;
              __n128 v23 = *v11;
              v18[1].n128_u64[0] = a2[-1].n128_u64[1];
              *CFIndex v18 = v23;
            }
            a5.n128_u64[1] = v146.n128_u64[1];
            a2[-1].n128_u64[1] = v172;
            __n128 *v11 = v146;
LABEL_32:
            --a3;
            if ((a4 & 1) == 0) {
              goto LABEL_56;
            }
            goto LABEL_33;
          }
          if (v19 <= v22) {
            goto LABEL_32;
          }
          unint64_t v175 = *(void *)(v14 + 16);
          __n128 v149 = *(__n128 *)v14;
          a5 = *v11;
          *(void *)(v14 + 16) = a2[-1].n128_u64[1];
          *(__n128 *)unint64_t v14 = a5;
          a5.n128_u64[1] = v149.n128_u64[1];
          a2[-1].n128_u64[1] = v175;
          __n128 *v11 = v149;
          if (*(double *)(v14 + 16) <= v18[1].n128_f64[0]) {
            goto LABEL_32;
          }
          unint64_t v176 = v18[1].n128_u64[0];
          __n128 v150 = *v18;
          a5 = *(__n128 *)v14;
          v18[1].n128_u64[0] = *(void *)(v14 + 16);
          *CFIndex v18 = a5;
          a5.n128_u64[1] = v150.n128_u64[1];
          *(void *)(v14 + 16) = v176;
          *(__n128 *)unint64_t v14 = v150;
          --a3;
          if (a4) {
            goto LABEL_33;
          }
LABEL_56:
          a5.n128_u64[0] = *(void *)(v14 + 16);
          if (*(double *)(v14 - 8) > a5.n128_f64[0]) {
            goto LABEL_57;
          }
          a5 = *(__n128 *)v14;
          __n128 v143 = *(__n128 *)v14;
          a5.n128_u64[0] = *(void *)(v14 + 16);
          if (a5.n128_f64[0] > a2[-1].n128_f64[1])
          {
            unint64_t v80 = v14;
            do
            {
              unint64_t v14 = v80 + 24;
              double v81 = *(double *)(v80 + 40);
              v80 += 24;
            }
            while (a5.n128_f64[0] <= v81);
          }
          else
          {
            unint64_t v82 = v14 + 24;
            do
            {
              unint64_t v14 = v82;
              if (v82 >= (unint64_t)a2) {
                break;
              }
              double v83 = *(double *)(v82 + 16);
              v82 += 24;
            }
            while (a5.n128_f64[0] <= v83);
          }
          uint64_t v84 = a2;
          if (v14 < (unint64_t)a2)
          {
            int64_t v85 = a2;
            do
            {
              uint64_t v84 = (__n128 *)((char *)v85 - 24);
              double v86 = v85[-1].n128_f64[1];
              int64_t v85 = (__n128 *)((char *)v85 - 24);
            }
            while (a5.n128_f64[0] > v86);
          }
          while (v14 < (unint64_t)v84)
          {
            unint64_t v188 = *(void *)(v14 + 16);
            __n128 v162 = *(__n128 *)v14;
            __n128 v87 = *v84;
            *(void *)(v14 + 16) = v84[1].n128_u64[0];
            *(__n128 *)unint64_t v14 = v87;
            v84[1].n128_u64[0] = v188;
            *uint64_t v84 = v162;
            do
            {
              double v88 = *(double *)(v14 + 40);
              v14 += 24;
            }
            while (a5.n128_f64[0] <= v88);
            do
            {
              double v89 = v84[-1].n128_f64[1];
              uint64_t v84 = (__n128 *)((char *)v84 - 24);
            }
            while (a5.n128_f64[0] > v89);
          }
          unint64_t v90 = (__n128 *)(v14 - 24);
          BOOL v5 = v14 - 24 >= a1;
          BOOL v6 = v14 - 24 == a1;
          if (v14 - 24 != a1)
          {
            __n128 v91 = *v90;
            *(void *)(a1 + 16) = *(void *)(v14 - 8);
            *(__n128 *)a1 = v91;
          }
          a4 = 0;
          __n128 *v90 = v143;
          *(void *)(v14 - 8) = a5.n128_u64[0];
        }
        double v20 = v18[1].n128_f64[0];
        if (v20 <= *(double *)(v14 + 16))
        {
          if (v19 > v20)
          {
            unint64_t v173 = v18[1].n128_u64[0];
            __n128 v147 = *v18;
            __n128 v24 = *v11;
            v18[1].n128_u64[0] = a2[-1].n128_u64[1];
            *CFIndex v18 = v24;
            a2[-1].n128_u64[1] = v173;
            __n128 *v11 = v147;
            if (v18[1].n128_f64[0] > *(double *)(v14 + 16))
            {
              unint64_t v174 = *(void *)(v14 + 16);
              __n128 v148 = *(__n128 *)v14;
              __n128 v25 = *v18;
              *(void *)(v14 + 16) = v18[1].n128_u64[0];
              *(__n128 *)unint64_t v14 = v25;
              v18[1].n128_u64[0] = v174;
              *CFIndex v18 = v148;
            }
          }
        }
        else
        {
          if (v19 <= v20)
          {
            unint64_t v177 = *(void *)(v14 + 16);
            __n128 v151 = *(__n128 *)v14;
            __n128 v26 = *v18;
            *(void *)(v14 + 16) = v18[1].n128_u64[0];
            *(__n128 *)unint64_t v14 = v26;
            v18[1].n128_u64[0] = v177;
            *CFIndex v18 = v151;
            if (a2[-1].n128_f64[1] <= v18[1].n128_f64[0]) {
              goto LABEL_23;
            }
            unint64_t v171 = v18[1].n128_u64[0];
            __n128 v145 = *v18;
            __n128 v27 = *v11;
            v18[1].n128_u64[0] = a2[-1].n128_u64[1];
            *CFIndex v18 = v27;
          }
          else
          {
            unint64_t v171 = *(void *)(v14 + 16);
            __n128 v145 = *(__n128 *)v14;
            __n128 v21 = *v11;
            *(void *)(v14 + 16) = a2[-1].n128_u64[1];
            *(__n128 *)unint64_t v14 = v21;
          }
          a2[-1].n128_u64[1] = v171;
          __n128 *v11 = v145;
        }
LABEL_23:
        unint64_t v28 = (__n128 *)(v14 + 24);
        unint64_t v29 = v14 + 24 * v17;
        uint64_t v30 = (__n128 *)(v29 - 24);
        double v31 = *(double *)(v29 - 8);
        double v32 = a2[-2].n128_f64[0];
        if (v31 <= *(double *)(v14 + 40))
        {
          if (v32 > v31)
          {
            unint64_t v178 = *(void *)(v29 - 8);
            __n128 v152 = *v30;
            __n128 v36 = *v12;
            *(void *)(v29 - 8) = a2[-2].n128_u64[0];
            *uint64_t v30 = v36;
            a2[-2].n128_u64[0] = v178;
            *unsigned __int32 v12 = v152;
            if (*(double *)(v29 - 8) > *(double *)(v14 + 40))
            {
              __n128 v37 = *v28;
              unint64_t v38 = *(void *)(v14 + 40);
              uint64_t v39 = v30[1].n128_i64[0];
              *unint64_t v28 = *v30;
              *(void *)(v14 + 40) = v39;
              v30[1].n128_u64[0] = v38;
              *uint64_t v30 = v37;
            }
          }
        }
        else
        {
          if (v32 <= v31)
          {
            __n128 v41 = *v28;
            unint64_t v42 = *(void *)(v14 + 40);
            uint64_t v43 = v30[1].n128_i64[0];
            *unint64_t v28 = *v30;
            *(void *)(v14 + 40) = v43;
            v30[1].n128_u64[0] = v42;
            *uint64_t v30 = v41;
            if (a2[-2].n128_f64[0] <= v30[1].n128_f64[0]) {
              goto LABEL_37;
            }
            unint64_t v180 = v30[1].n128_u64[0];
            __n128 v154 = *v30;
            __n128 v44 = *v12;
            v30[1].n128_u64[0] = a2[-2].n128_u64[0];
            *uint64_t v30 = v44;
            __n128 v33 = v154;
            a2[-2].n128_u64[0] = v180;
          }
          else
          {
            __n128 v33 = *v28;
            unint64_t v34 = *(void *)(v14 + 40);
            unint64_t v35 = a2[-2].n128_u64[0];
            *unint64_t v28 = *v12;
            *(void *)(v14 + 40) = v35;
            a2[-2].n128_u64[0] = v34;
          }
          *unsigned __int32 v12 = v33;
        }
LABEL_37:
        uint64_t v45 = (__n128 *)(v14 + 48);
        unint64_t v46 = v14 + 24 * v17;
        int v47 = (__n128 *)(v46 + 24);
        double v48 = *(double *)(v46 + 40);
        double v49 = a2[-4].n128_f64[1];
        if (v48 <= *(double *)(v14 + 64))
        {
          if (v49 > v48)
          {
            unint64_t v181 = *(void *)(v46 + 40);
            __n128 v155 = *v47;
            __n128 v53 = *(__n128 *)v13;
            *(void *)(v46 + 40) = a2[-4].n128_u64[1];
            *int v47 = v53;
            a2[-4].n128_u64[1] = v181;
            *(__n128 *)int v13 = v155;
            if (*(double *)(v46 + 40) > *(double *)(v14 + 64))
            {
              __n128 v54 = *v45;
              unint64_t v55 = *(void *)(v14 + 64);
              uint64_t v56 = v47[1].n128_i64[0];
              *uint64_t v45 = *v47;
              *(void *)(v14 + 64) = v56;
              v47[1].n128_u64[0] = v55;
              *int v47 = v54;
            }
          }
        }
        else
        {
          if (v49 <= v48)
          {
            __n128 v57 = *v45;
            unint64_t v58 = *(void *)(v14 + 64);
            uint64_t v59 = v47[1].n128_i64[0];
            *uint64_t v45 = *v47;
            *(void *)(v14 + 64) = v59;
            v47[1].n128_u64[0] = v58;
            *int v47 = v57;
            if (a2[-4].n128_f64[1] <= v47[1].n128_f64[0]) {
              goto LABEL_46;
            }
            unint64_t v182 = v47[1].n128_u64[0];
            __n128 v156 = *v47;
            __n128 v60 = *(__n128 *)v13;
            v47[1].n128_u64[0] = a2[-4].n128_u64[1];
            *int v47 = v60;
            __n128 v50 = v156;
            a2[-4].n128_u64[1] = v182;
          }
          else
          {
            __n128 v50 = *v45;
            unint64_t v51 = *(void *)(v14 + 64);
            unint64_t v52 = a2[-4].n128_u64[1];
            *uint64_t v45 = *(__n128 *)v13;
            *(void *)(v14 + 64) = v52;
            a2[-4].n128_u64[1] = v51;
          }
          *(__n128 *)int v13 = v50;
        }
LABEL_46:
        double v61 = v18[1].n128_f64[0];
        double v62 = v47[1].n128_f64[0];
        if (v61 <= v30[1].n128_f64[0])
        {
          if (v62 > v61)
          {
            unint64_t v184 = v18[1].n128_u64[0];
            __n128 v158 = *v18;
            *CFIndex v18 = *v47;
            v18[1].n128_u64[0] = v47[1].n128_u64[0];
            v47[1].n128_u64[0] = v184;
            *int v47 = v158;
            if (v18[1].n128_f64[0] > v30[1].n128_f64[0])
            {
              unint64_t v185 = v30[1].n128_u64[0];
              __n128 v159 = *v30;
              *uint64_t v30 = *v18;
              v30[1].n128_u64[0] = v18[1].n128_u64[0];
              v18[1].n128_u64[0] = v185;
              *CFIndex v18 = v159;
            }
          }
        }
        else
        {
          if (v62 <= v61)
          {
            unint64_t v186 = v30[1].n128_u64[0];
            __n128 v160 = *v30;
            *uint64_t v30 = *v18;
            v30[1].n128_u64[0] = v18[1].n128_u64[0];
            v18[1].n128_u64[0] = v186;
            *CFIndex v18 = v160;
            if (v47[1].n128_f64[0] <= v18[1].n128_f64[0]) {
              goto LABEL_55;
            }
            unint64_t v183 = v18[1].n128_u64[0];
            __n128 v157 = *v18;
            *CFIndex v18 = *v47;
            v18[1].n128_u64[0] = v47[1].n128_u64[0];
          }
          else
          {
            unint64_t v183 = v30[1].n128_u64[0];
            __n128 v157 = *v30;
            *uint64_t v30 = *v47;
            v30[1].n128_u64[0] = v47[1].n128_u64[0];
          }
          v47[1].n128_u64[0] = v183;
          *int v47 = v157;
        }
LABEL_55:
        unint64_t v187 = *(void *)(v14 + 16);
        __n128 v161 = *(__n128 *)v14;
        a5 = *v18;
        *(void *)(v14 + 16) = v18[1].n128_u64[0];
        *(__n128 *)unint64_t v14 = a5;
        a5.n128_u64[1] = v161.n128_u64[1];
        v18[1].n128_u64[0] = v187;
        *CFIndex v18 = v161;
        --a3;
        if ((a4 & 1) == 0) {
          goto LABEL_56;
        }
LABEL_33:
        a5.n128_u64[0] = *(void *)(v14 + 16);
LABEL_57:
        __n128 v142 = *(__n128 *)v14;
        unint64_t v63 = v14;
        do
        {
          unint64_t v64 = v63;
          v63 += 24;
        }
        while (*(double *)(v64 + 40) > a5.n128_f64[0]);
        int v65 = a2;
        if (v64 == v14)
        {
          int v68 = a2;
          while (v63 < (unint64_t)v68)
          {
            char v66 = (__n128 *)((char *)v68 - 24);
            double v69 = v68[-1].n128_f64[1];
            int v68 = (__n128 *)((char *)v68 - 24);
            if (v69 > a5.n128_f64[0]) {
              goto LABEL_66;
            }
          }
          char v66 = v68;
        }
        else
        {
          do
          {
            char v66 = (__n128 *)((char *)v65 - 24);
            double v67 = v65[-1].n128_f64[1];
            int v65 = (__n128 *)((char *)v65 - 24);
          }
          while (v67 <= a5.n128_f64[0]);
        }
LABEL_66:
        unint64_t v14 = v63;
        if (v63 < (unint64_t)v66)
        {
          unint64_t v70 = (unint64_t)v66;
          do
          {
            __n128 v71 = *(__n128 *)v14;
            uint64_t v72 = *(void *)(v14 + 16);
            uint64_t v73 = *(void *)(v70 + 16);
            *(_OWORD *)unint64_t v14 = *(_OWORD *)v70;
            *(void *)(v14 + 16) = v73;
            *(void *)(v70 + 16) = v72;
            *(__n128 *)unint64_t v70 = v71;
            do
            {
              double v74 = *(double *)(v14 + 40);
              v14 += 24;
            }
            while (v74 > a5.n128_f64[0]);
            do
            {
              double v75 = *(double *)(v70 - 8);
              v70 -= 24;
            }
            while (v75 <= a5.n128_f64[0]);
          }
          while (v14 < v70);
        }
        double v76 = (__n128 *)(v14 - 24);
        if (v14 - 24 != a1)
        {
          __n128 v77 = *v76;
          *(void *)(a1 + 16) = *(void *)(v14 - 8);
          *(__n128 *)a1 = v77;
        }
        __n128 *v76 = v142;
        *(void *)(v14 - 8) = a5.n128_u64[0];
        if (v63 >= (unint64_t)v66) {
          break;
        }
LABEL_77:
        sub_19E44E6F8(a1, v14 - 24, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v78 = sub_19E44F808(a1, v14 - 24, a5);
      if (sub_19E44F808(v14, (uint64_t)a2, v79)) {
        break;
      }
      if (!v78) {
        goto LABEL_77;
      }
    }
    a2 = (__n128 *)(v14 - 24);
    if (!v78) {
      continue;
    }
    return a5.n128_f64[0];
  }
}

__n128 sub_19E44F680(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 result)
{
  double v5 = a2[1].n128_f64[0];
  double v6 = a3[1].n128_f64[0];
  if (v5 <= a1[1].n128_f64[0])
  {
    if (v6 > v5)
    {
      unint64_t v9 = a2[1].n128_u64[0];
      os_log_t result = *a2;
      unint64_t v10 = a3[1].n128_u64[0];
      *a2 = *a3;
      a2[1].n128_u64[0] = v10;
      *a3 = result;
      a3[1].n128_u64[0] = v9;
      if (a2[1].n128_f64[0] > a1[1].n128_f64[0])
      {
        unint64_t v11 = a1[1].n128_u64[0];
        os_log_t result = *a1;
        unint64_t v12 = a2[1].n128_u64[0];
        *a1 = *a2;
        a1[1].n128_u64[0] = v12;
        *a2 = result;
        a2[1].n128_u64[0] = v11;
      }
    }
  }
  else
  {
    if (v6 > v5)
    {
      unint64_t v7 = a1[1].n128_u64[0];
      os_log_t result = *a1;
      unint64_t v8 = a3[1].n128_u64[0];
      *a1 = *a3;
      a1[1].n128_u64[0] = v8;
LABEL_9:
      *a3 = result;
      a3[1].n128_u64[0] = v7;
      goto LABEL_10;
    }
    unint64_t v13 = a1[1].n128_u64[0];
    os_log_t result = *a1;
    unint64_t v14 = a2[1].n128_u64[0];
    *a1 = *a2;
    a1[1].n128_u64[0] = v14;
    *a2 = result;
    a2[1].n128_u64[0] = v13;
    if (a3[1].n128_f64[0] > a2[1].n128_f64[0])
    {
      unint64_t v7 = a2[1].n128_u64[0];
      os_log_t result = *a2;
      unint64_t v15 = a3[1].n128_u64[0];
      *a2 = *a3;
      a2[1].n128_u64[0] = v15;
      goto LABEL_9;
    }
  }
LABEL_10:
  result.n128_u64[0] = a4[1].n128_u64[0];
  if (result.n128_f64[0] > a3[1].n128_f64[0])
  {
    unint64_t v16 = a3[1].n128_u64[0];
    os_log_t result = *a3;
    unint64_t v17 = a4[1].n128_u64[0];
    *a3 = *a4;
    a3[1].n128_u64[0] = v17;
    *a4 = result;
    a4[1].n128_u64[0] = v16;
    result.n128_u64[0] = a3[1].n128_u64[0];
    if (result.n128_f64[0] > a2[1].n128_f64[0])
    {
      unint64_t v18 = a2[1].n128_u64[0];
      os_log_t result = *a2;
      unint64_t v19 = a3[1].n128_u64[0];
      *a2 = *a3;
      a2[1].n128_u64[0] = v19;
      *a3 = result;
      a3[1].n128_u64[0] = v18;
      result.n128_u64[0] = a2[1].n128_u64[0];
      if (result.n128_f64[0] > a1[1].n128_f64[0])
      {
        unint64_t v20 = a1[1].n128_u64[0];
        os_log_t result = *a1;
        unint64_t v21 = a2[1].n128_u64[0];
        *a1 = *a2;
        a1[1].n128_u64[0] = v21;
        *a2 = result;
        a2[1].n128_u64[0] = v20;
      }
    }
  }
  return result;
}

BOOL sub_19E44F808(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v5)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 8) > *(double *)(a1 + 16))
      {
        uint64_t v7 = *(void *)(a1 + 16);
        __n128 v8 = *(__n128 *)a1;
        uint64_t v9 = *(void *)(a2 - 8);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 24);
        *(void *)(a1 + 16) = v9;
        *(__n128 *)(a2 - 24) = v8;
        *(void *)(a2 - 8) = v7;
      }
      return result;
    case 3uLL:
      unint64_t v17 = (__n128 *)(a1 + 24);
      unint64_t v18 = (__n128 *)(a2 - 24);
      double v19 = *(double *)(a1 + 40);
      double v20 = *(double *)(a2 - 8);
      if (v19 <= *(double *)(a1 + 16))
      {
        if (v20 > v19)
        {
          uint64_t v40 = *(void *)(a1 + 40);
          __n128 v41 = *v17;
          uint64_t v42 = *(void *)(a2 - 8);
          *unint64_t v17 = *v18;
          *(void *)(a1 + 40) = v42;
          *unint64_t v18 = v41;
          *(void *)(a2 - 8) = v40;
          if (*(double *)(a1 + 40) > *(double *)(a1 + 16))
          {
            uint64_t v43 = *(void *)(a1 + 16);
            __n128 v44 = *(__n128 *)a1;
            *(__n128 *)a1 = *v17;
            *(void *)(a1 + 16) = *(void *)(a1 + 40);
            *unint64_t v17 = v44;
            *(void *)(a1 + 40) = v43;
          }
        }
      }
      else if (v20 <= v19)
      {
        uint64_t v56 = *(void *)(a1 + 16);
        __n128 v57 = *(__n128 *)a1;
        *(__n128 *)a1 = *v17;
        *(void *)(a1 + 16) = *(void *)(a1 + 40);
        *unint64_t v17 = v57;
        *(void *)(a1 + 40) = v56;
        if (*(double *)(a2 - 8) > *(double *)(a1 + 40))
        {
          uint64_t v58 = *(void *)(a1 + 40);
          __n128 v59 = *v17;
          uint64_t v60 = *(void *)(a2 - 8);
          *unint64_t v17 = *v18;
          *(void *)(a1 + 40) = v60;
          *unint64_t v18 = v59;
          *(void *)(a2 - 8) = v58;
        }
      }
      else
      {
        uint64_t v21 = *(void *)(a1 + 16);
        __n128 v22 = *(__n128 *)a1;
        uint64_t v23 = *(void *)(a2 - 8);
        *(__n128 *)a1 = *v18;
        *(void *)(a1 + 16) = v23;
        *unint64_t v18 = v22;
        *(void *)(a2 - 8) = v21;
      }
      return result;
    case 4uLL:
      sub_19E44F680((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a2 - 24), a3);
      return 1;
    case 5uLL:
      __n128 v24 = (__n128 *)(a1 + 24);
      __n128 v25 = (__n128 *)(a1 + 48);
      __n128 v26 = (__n128 *)(a1 + 72);
      sub_19E44F680((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a1 + 72), a3);
      if (*(double *)(a2 - 8) > *(double *)(a1 + 88))
      {
        uint64_t v27 = *(void *)(a1 + 88);
        __n128 v28 = *v26;
        uint64_t v29 = *(void *)(a2 - 8);
        *__n128 v26 = *(__n128 *)(a2 - 24);
        *(void *)(a1 + 88) = v29;
        *(__n128 *)(a2 - 24) = v28;
        *(void *)(a2 - 8) = v27;
        if (*(double *)(a1 + 88) > *(double *)(a1 + 64))
        {
          uint64_t v30 = *(void *)(a1 + 64);
          __n128 v31 = *v25;
          *__n128 v25 = *v26;
          *(void *)(a1 + 64) = *(void *)(a1 + 88);
          *__n128 v26 = v31;
          *(void *)(a1 + 88) = v30;
          if (*(double *)(a1 + 64) > *(double *)(a1 + 40))
          {
            uint64_t v32 = *(void *)(a1 + 40);
            __n128 v33 = *v24;
            *__n128 v24 = *v25;
            *(void *)(a1 + 40) = *(void *)(a1 + 64);
            *__n128 v25 = v33;
            *(void *)(a1 + 64) = v32;
            if (*(double *)(a1 + 40) > *(double *)(a1 + 16))
            {
              uint64_t v34 = *(void *)(a1 + 16);
              __n128 v35 = *(__n128 *)a1;
              *(__n128 *)a1 = *v24;
              *(void *)(a1 + 16) = *(void *)(a1 + 40);
              *__n128 v24 = v35;
              *(void *)(a1 + 40) = v34;
            }
          }
        }
      }
      return 1;
    default:
      unint64_t v10 = (__n128 *)(a1 + 48);
      unint64_t v11 = (__n128 *)(a1 + 24);
      double v12 = *(double *)(a1 + 40);
      double v13 = *(double *)(a1 + 16);
      double v14 = *(double *)(a1 + 64);
      if (v12 <= v13)
      {
        if (v14 > v12)
        {
          uint64_t v36 = *(void *)(a1 + 40);
          __n128 v37 = *v11;
          __n128 *v11 = *v10;
          *(void *)(a1 + 40) = *(void *)(a1 + 64);
          *unint64_t v10 = v37;
          *(void *)(a1 + 64) = v36;
          if (*(double *)(a1 + 40) > v13)
          {
            uint64_t v38 = *(void *)(a1 + 16);
            __n128 v39 = *(__n128 *)a1;
            *(__n128 *)a1 = *v11;
            *(void *)(a1 + 16) = *(void *)(a1 + 40);
            __n128 *v11 = v39;
            *(void *)(a1 + 40) = v38;
          }
        }
      }
      else if (v14 <= v12)
      {
        uint64_t v45 = *(void *)(a1 + 16);
        __n128 v46 = *(__n128 *)a1;
        *(__n128 *)a1 = *v11;
        *(void *)(a1 + 16) = *(void *)(a1 + 40);
        __n128 *v11 = v46;
        *(void *)(a1 + 40) = v45;
        if (v14 > *(double *)(a1 + 40))
        {
          uint64_t v47 = *(void *)(a1 + 40);
          __n128 v48 = *v11;
          __n128 *v11 = *v10;
          *(void *)(a1 + 40) = *(void *)(a1 + 64);
          *unint64_t v10 = v48;
          *(void *)(a1 + 64) = v47;
        }
      }
      else
      {
        uint64_t v15 = *(void *)(a1 + 16);
        __n128 v16 = *(__n128 *)a1;
        *(__n128 *)a1 = *v10;
        *(void *)(a1 + 16) = *(void *)(a1 + 64);
        *unint64_t v10 = v16;
        *(void *)(a1 + 64) = v15;
      }
      uint64_t v49 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1;
      }
      uint64_t v50 = 0;
      int v51 = 0;
      break;
  }
  while (1)
  {
    double v53 = *(double *)(v49 + 16);
    if (v53 > v10[1].n128_f64[0])
    {
      long long v61 = *(_OWORD *)v49;
      uint64_t v54 = v50;
      do
      {
        uint64_t v55 = a1 + v54;
        *(_OWORD *)(v55 + 72) = *(_OWORD *)(a1 + v54 + 48);
        *(void *)(v55 + 88) = *(void *)(a1 + v54 + 64);
        if (v54 == -48)
        {
          uint64_t v52 = a1;
          goto LABEL_27;
        }
        v54 -= 24;
      }
      while (v53 > *(double *)(v55 + 40));
      uint64_t v52 = a1 + v54 + 72;
LABEL_27:
      *(_OWORD *)uint64_t v52 = v61;
      *(double *)(v52 + 16) = v53;
      if (++v51 == 8) {
        return v49 + 24 == a2;
      }
    }
    unint64_t v10 = (__n128 *)v49;
    v50 += 24;
    v49 += 24;
    if (v49 == a2) {
      return 1;
    }
  }
}

double sub_19E44FC90(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[9];
  double result = 0.0;
  if (v2)
  {
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = a2;
      if (v2 <= a2) {
        unint64_t v5 = a2 % v2;
      }
    }
    else
    {
      unint64_t v5 = (v2 - 1) & a2;
    }
    double v6 = *(uint64_t ***)(a1[8] + 8 * v5);
    if (v6)
    {
      uint64_t v7 = *v6;
      if (v7)
      {
        if (v4.u32[0] < 2uLL)
        {
          unint64_t v8 = v2 - 1;
          while (1)
          {
            uint64_t v10 = v7[1];
            if (v10 == a2)
            {
              if (*((_DWORD *)v7 + 4) == a2) {
                return *(double *)(a1[13] + 24 * *((unsigned int *)v7 + 6) + 16);
              }
            }
            else if ((v10 & v8) != v5)
            {
              return result;
            }
            uint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return result;
            }
          }
        }
        do
        {
          unint64_t v9 = v7[1];
          if (v9 == a2)
          {
            if (*((_DWORD *)v7 + 4) == a2) {
              return *(double *)(a1[13] + 24 * *((unsigned int *)v7 + 6) + 16);
            }
          }
          else
          {
            if (v9 >= v2) {
              v9 %= v2;
            }
            if (v9 != v5) {
              return result;
            }
          }
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
  return result;
}

uint64_t sub_19E44FD80(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[9];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  unint64_t v5 = *(uint64_t ***)(a1[8] + 8 * v4);
  if (!v5) {
    return 0;
  }
  double v6 = *v5;
  if (!v6) {
    return 0;
  }
  if (v3.u32[0] < 2uLL)
  {
    unint64_t v7 = v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (*((_DWORD *)v6 + 4) == a2) {
          return *(unsigned int *)(a1[13] + 24 * *((unsigned int *)v6 + 6) + 8);
        }
      }
      else if ((v9 & v7) != v4)
      {
        return 0;
      }
      double v6 = (uint64_t *)*v6;
      if (!v6) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= v2) {
      v8 %= v2;
    }
    if (v8 != v4) {
      return 0;
    }
LABEL_11:
    double v6 = (uint64_t *)*v6;
    if (!v6) {
      return 0;
    }
  }
  if (*((_DWORD *)v6 + 4) != a2) {
    goto LABEL_11;
  }
  return *(unsigned int *)(a1[13] + 24 * *((unsigned int *)v6 + 6) + 8);
}

uint64_t sub_19E44FE70(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[9];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  unint64_t v5 = *(uint64_t ***)(a1[8] + 8 * v4);
  if (!v5) {
    return 0;
  }
  double v6 = *v5;
  if (!v6) {
    return 0;
  }
  if (v3.u32[0] < 2uLL)
  {
    unint64_t v7 = v2 - 1;
    while (1)
    {
      uint64_t v9 = v6[1];
      if (v9 == a2)
      {
        if (*((_DWORD *)v6 + 4) == a2) {
          return *(unsigned int *)(a1[13] + 24 * *((unsigned int *)v6 + 6));
        }
      }
      else if ((v9 & v7) != v4)
      {
        return 0;
      }
      double v6 = (uint64_t *)*v6;
      if (!v6) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v8 >= v2) {
      v8 %= v2;
    }
    if (v8 != v4) {
      return 0;
    }
LABEL_11:
    double v6 = (uint64_t *)*v6;
    if (!v6) {
      return 0;
    }
  }
  if (*((_DWORD *)v6 + 4) != a2) {
    goto LABEL_11;
  }
  return *(unsigned int *)(a1[13] + 24 * *((unsigned int *)v6 + 6));
}

uint64_t *sub_19E44FF60(uint64_t a1, uint64_t a2, void *a3)
{
  if (a3) {
    *a3 = 0;
  }
  double result = sub_19E44FFC0((void *)(a1 + 24), a2);
  if (result)
  {
    unsigned int v6 = *((_DWORD *)result + 10);
    uint64_t v7 = *(void *)(a1 + 104);
    if (a3) {
      *a3 = *(void *)(v7 + 24 * v6 + 16);
    }
    return (uint64_t *)*(unsigned int *)(v7 + 24 * v6 + 4);
  }
  return result;
}

uint64_t *sub_19E44FFC0(void *a1, uint64_t a2)
{
  unint64_t v2 = (unsigned char *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v5 = v4;
  }
  unint64_t v6 = sub_19E37BDA4((uint64_t)&v25, (uint64_t *)a2, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (v7)
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= *(void *)&v7) {
        unint64_t v10 = v6 % *(void *)&v7;
      }
    }
    else
    {
      unint64_t v10 = (*(void *)&v7 - 1) & v6;
    }
    unint64_t v11 = *(uint64_t ***)(*a1 + 8 * v10);
    if (v11)
    {
      double v12 = *v11;
      if (*v11)
      {
        char v13 = v2[23];
        if (v13 >= 0) {
          uint64_t v14 = v2[23];
        }
        else {
          uint64_t v14 = *((void *)v2 + 1);
        }
        if (v13 < 0) {
          unint64_t v2 = *(unsigned char **)v2;
        }
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v15 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v21 = v12[1];
            if (v8 == v21)
            {
              uint64_t v22 = *((unsigned __int8 *)v12 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = *((unsigned __int8 *)v12 + 39);
              }
              else {
                uint64_t v23 = v12[3];
              }
              if (v23 == v14)
              {
                if ((v22 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v12[2], v2, v12[3])) {
                    return v12;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v12 + 39)) {
                    return v12;
                  }
                  uint64_t v24 = 0;
                  while (*((unsigned __int8 *)v12 + v24 + 16) == v2[v24])
                  {
                    if (v22 == ++v24) {
                      return v12;
                    }
                  }
                }
              }
            }
            else if ((v21 & v15) != v10)
            {
              return 0;
            }
            double result = 0;
            double v12 = (uint64_t *)*v12;
            if (!v12) {
              return result;
            }
          }
        }
        while (1)
        {
          unint64_t v17 = v12[1];
          if (v8 == v17)
          {
            uint64_t v18 = *((unsigned __int8 *)v12 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v12 + 39);
            }
            else {
              uint64_t v19 = v12[3];
            }
            if (v19 == v14)
            {
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp((const void *)v12[2], v2, v12[3])) {
                  return v12;
                }
              }
              else
              {
                if (!*((unsigned char *)v12 + 39)) {
                  return v12;
                }
                uint64_t v20 = 0;
                while (*((unsigned __int8 *)v12 + v20 + 16) == v2[v20])
                {
                  if (v18 == ++v20) {
                    return v12;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= *(void *)&v7) {
              v17 %= *(void *)&v7;
            }
            if (v17 != v10) {
              return 0;
            }
          }
          double result = 0;
          double v12 = (uint64_t *)*v12;
          if (!v12) {
            return result;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t sub_19E4501C0(uint64_t a1, const __CFString *a2, void *a3)
{
  sub_19E37774C(a2, __p);
  if (a3) {
    *a3 = 0;
  }
  unint64_t v5 = sub_19E44FFC0((void *)(a1 + 24), (uint64_t)__p);
  if (!v5)
  {
    uint64_t v8 = 0;
    if ((v11 & 0x80000000) == 0) {
      return v8;
    }
    goto LABEL_7;
  }
  unsigned int v6 = *((_DWORD *)v5 + 10);
  uint64_t v7 = *(void *)(a1 + 104);
  if (a3) {
    *a3 = *(void *)(v7 + 24 * v6 + 16);
  }
  uint64_t v8 = *(unsigned int *)(v7 + 24 * v6 + 4);
  if (v11 < 0) {
LABEL_7:
  }
    operator delete(__p[0]);
  return v8;
}

void *sub_19E45025C@<X0>(void *result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t v3 = result[9];
  if (!v3) {
    goto LABEL_21;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = a2;
    if (v3 <= a2) {
      unint64_t v5 = a2 % v3;
    }
  }
  else
  {
    unint64_t v5 = (v3 - 1) & a2;
  }
  unsigned int v6 = *(uint64_t ***)(result[8] + 8 * v5);
  if (!v6 || (uint64_t v7 = *v6) == 0)
  {
LABEL_21:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    return result;
  }
  if (v4.u32[0] < 2uLL)
  {
    unint64_t v8 = v3 - 1;
    while (1)
    {
      uint64_t v10 = v7[1];
      if (v10 == a2)
      {
        if (*((_DWORD *)v7 + 4) == a2) {
          goto LABEL_22;
        }
      }
      else if ((v10 & v8) != v5)
      {
        goto LABEL_21;
      }
      uint64_t v7 = (uint64_t *)*v7;
      if (!v7) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v7[1];
    if (v9 == a2) {
      break;
    }
    if (v9 >= v3) {
      v9 %= v3;
    }
    if (v9 != v5) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v7 = (uint64_t *)*v7;
    if (!v7) {
      goto LABEL_21;
    }
  }
  if (*((_DWORD *)v7 + 4) != a2) {
    goto LABEL_11;
  }
LABEL_22:
  if (*((char *)v7 + 55) < 0) {
    return sub_19E39369C((unsigned char *)a3, (void *)v7[4], v7[5]);
  }
  long long v11 = *((_OWORD *)v7 + 2);
  *(void *)(a3 + 16) = v7[6];
  *(_OWORD *)a3 = v11;
  return result;
}

void sub_19E450364(void *a1, unsigned int a2, uint64_t a3)
{
  sub_19E45025C(a1, a2, (uint64_t)v19);
  unint64_t v5 = sub_19E44FFC0(a1 + 3, (uint64_t)v19);
  if (v5)
  {
    unsigned int v6 = *((_DWORD *)v5 + 10);
    uint64_t v7 = a1[13];
    if (*(_DWORD *)(v7 + 24 * v6 + 4) == *(_DWORD *)(v7 + 24 * v6))
    {
      unsigned __int8 v18 = 0;
      sub_19E4213CC((uint64_t)&__p, a1 + 16, (const void **)v19, *(_DWORD *)(v7 + 24 * v6 + 8));
      unint64_t v8 = (void **)__p;
      unint64_t v9 = v17;
      if (__p != v17)
      {
        do
        {
          uint64_t v10 = sub_19E44FFC0(a1 + 3, (uint64_t)v8);
          if (v10)
          {
            long long v11 = v10;
            CFStringRef v12 = sub_19E3C2A64((uint64_t)v8);
            (*(void (**)(uint64_t, CFStringRef, void, unsigned __int8 *))(a3 + 16))(a3, v12, *(unsigned int *)(a1[13] + 24 * *((unsigned int *)v11 + 10) + 4), &v18);
            int v13 = v18;
            if (v12) {
              CFRelease(v12);
            }
            if (v13) {
              break;
            }
          }
          v8 += 3;
        }
        while (v8 != v9);
        unint64_t v8 = (void **)__p;
      }
      if (v8)
      {
        uint64_t v14 = v17;
        uint64_t v15 = v8;
        if (v17 != v8)
        {
          do
          {
            if (*((char *)v14 - 1) < 0) {
              operator delete(*(v14 - 3));
            }
            v14 -= 3;
          }
          while (v14 != v8);
          uint64_t v15 = __p;
        }
        unint64_t v17 = v8;
        operator delete(v15);
      }
    }
  }
  if (v20 < 0) {
    operator delete(v19[0]);
  }
}

void sub_19E4504E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_19E450524(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v3 = 0;
  if (a2 && a3)
  {
    unint64_t __p = 0;
    size_t v60 = 0;
    unint64_t v61 = 0;
    uint64_t v58 = a3 - 1;
    if (a3 >= 1)
    {
      for (uint64_t i = 0; i < a3; ++i)
      {
        unsigned int v10 = *(unsigned __int16 *)(a2 + 2 * i);
        if ((v10 & 0xFC00) == 0xD800 && i < v58)
        {
          int v12 = *(unsigned __int16 *)(a2 + 2 * (i + 1));
          BOOL v13 = (v12 & 0xFC00) == 56320;
          int v14 = v12 + (v10 << 10) - 56613888;
          if (v13) {
            unsigned int v10 = v14;
          }
          if (v13) {
            ++i;
          }
        }
        if (v10 > 0x7F)
        {
          if (v10 > 0x7FF)
          {
            if (HIWORD(v10))
            {
              unsigned int v15 = (v10 >> 18) | 0xFFFFFFF0;
              char v63 = (v10 >> 12) & 0x3F | 0x80;
              uint64_t v22 = 2;
            }
            else
            {
              unsigned int v15 = (v10 >> 12) | 0xFFFFFFE0;
              uint64_t v22 = 1;
            }
            char v62 = v15;
            uint64_t v20 = v22 + 1;
            *(&v62 + v22) = (v10 >> 6) & 0x3F | 0x80;
          }
          else
          {
            unsigned int v15 = (v10 >> 6) | 0xFFFFFFC0;
            char v62 = (v10 >> 6) | 0xC0;
            uint64_t v20 = 1;
          }
          uint64_t v16 = v20 + 1;
          *(&v62 + v20) = v10 & 0x3F | 0x80;
          unsigned __int8 v17 = HIBYTE(v61);
          if ((SHIBYTE(v61) & 0x80000000) == 0)
          {
LABEL_20:
            if (v17 != 22)
            {
              size_t v19 = v17;
              HIBYTE(v61) = (v17 + 1) & 0x7F;
              p_p = (char *)&__p;
              goto LABEL_47;
            }
            unsigned __int8 v18 = &__p;
            size_t v19 = 22;
LABEL_33:
            if (v19 + 1 > 2 * v19) {
              unint64_t v24 = v19 + 1;
            }
            else {
              unint64_t v24 = 2 * v19;
            }
            uint64_t v25 = (v24 & 0x7FFFFFFFFFFFFFF8) + 8;
            if ((v24 | 7) != 0x17) {
              uint64_t v25 = v24 | 7;
            }
            if (v24 >= 0x17) {
              size_t v23 = v25 + 1;
            }
            else {
              size_t v23 = 23;
            }
LABEL_41:
            __n128 v26 = (char *)operator new(v23);
            p_p = v26;
            if (!v19 || (memmove(v26, v18, v19), v19 != 22)) {
              operator delete(v18);
            }
            unint64_t __p = p_p;
            unint64_t v61 = v23 | 0x8000000000000000;
            goto LABEL_46;
          }
        }
        else
        {
          char v62 = v10;
          LOBYTE(v15) = v10;
          uint64_t v16 = 1;
          unsigned __int8 v17 = HIBYTE(v61);
          if ((SHIBYTE(v61) & 0x80000000) == 0) {
            goto LABEL_20;
          }
        }
        size_t v19 = (v61 & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if (v60 == v19)
        {
          if ((v61 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FFFFFFFFFFFFFF8) {
            goto LABEL_118;
          }
          unsigned __int8 v18 = __p;
          size_t v23 = 0x7FFFFFFFFFFFFFF7;
          if (v19 < 0x3FFFFFFFFFFFFFF3) {
            goto LABEL_33;
          }
          goto LABEL_41;
        }
        p_p = (char *)__p;
        size_t v19 = v60;
LABEL_46:
        size_t v60 = v19 + 1;
LABEL_47:
        uint64_t v27 = &p_p[v19];
        *uint64_t v27 = v15;
        v27[1] = 0;
        if (v16 == 1) {
          continue;
        }
        char v28 = v63;
        if ((SHIBYTE(v61) & 0x80000000) == 0)
        {
          if (HIBYTE(v61) != 22)
          {
            size_t v30 = HIBYTE(v61);
            HIBYTE(v61) = (HIBYTE(v61) + 1) & 0x7F;
            __n128 v33 = (char *)&__p;
            goto LABEL_69;
          }
          uint64_t v29 = &__p;
          size_t v30 = 22;
LABEL_54:
          if (v30 + 1 > 2 * v30) {
            unint64_t v32 = v30 + 1;
          }
          else {
            unint64_t v32 = 2 * v30;
          }
          if (v32 >= 0x17)
          {
            uint64_t v34 = (v32 & 0x7FFFFFFFFFFFFFF8) + 8;
            uint64_t v35 = v32 | 7;
            if (v35 == 23) {
              uint64_t v35 = v34;
            }
            size_t v31 = v35 + 1;
          }
          else
          {
            size_t v31 = 23;
          }
LABEL_63:
          uint64_t v36 = (char *)operator new(v31);
          __n128 v33 = v36;
          if (!v30 || (memmove(v36, v29, v30), v30 != 22)) {
            operator delete(v29);
          }
          unint64_t __p = v33;
          unint64_t v61 = v31 | 0x8000000000000000;
          goto LABEL_68;
        }
        size_t v30 = (v61 & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if (v60 == v30)
        {
          if ((v61 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FFFFFFFFFFFFFF8) {
            goto LABEL_118;
          }
          uint64_t v29 = __p;
          size_t v31 = 0x7FFFFFFFFFFFFFF7;
          if (v30 < 0x3FFFFFFFFFFFFFF3) {
            goto LABEL_54;
          }
          goto LABEL_63;
        }
        __n128 v33 = (char *)__p;
        size_t v30 = v60;
LABEL_68:
        size_t v60 = v30 + 1;
LABEL_69:
        __n128 v37 = &v33[v30];
        *__n128 v37 = v28;
        v37[1] = 0;
        if (v16 == 2) {
          continue;
        }
        char v38 = v64;
        if ((SHIBYTE(v61) & 0x80000000) == 0)
        {
          if (HIBYTE(v61) != 22)
          {
            size_t v40 = HIBYTE(v61);
            HIBYTE(v61) = (HIBYTE(v61) + 1) & 0x7F;
            uint64_t v43 = (char *)&__p;
            goto LABEL_91;
          }
          __n128 v39 = &__p;
          size_t v40 = 22;
LABEL_76:
          if (v40 + 1 > 2 * v40) {
            unint64_t v42 = v40 + 1;
          }
          else {
            unint64_t v42 = 2 * v40;
          }
          if (v42 >= 0x17)
          {
            uint64_t v44 = (v42 & 0x7FFFFFFFFFFFFFF8) + 8;
            uint64_t v45 = v42 | 7;
            if (v45 == 23) {
              uint64_t v45 = v44;
            }
            size_t v41 = v45 + 1;
          }
          else
          {
            size_t v41 = 23;
          }
LABEL_85:
          __n128 v46 = (char *)operator new(v41);
          uint64_t v43 = v46;
          if (!v40 || (memmove(v46, v39, v40), v40 != 22)) {
            operator delete(v39);
          }
          unint64_t __p = v43;
          unint64_t v61 = v41 | 0x8000000000000000;
          goto LABEL_90;
        }
        size_t v40 = (v61 & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if (v60 == v40)
        {
          if ((v61 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FFFFFFFFFFFFFF8) {
            goto LABEL_118;
          }
          __n128 v39 = __p;
          size_t v41 = 0x7FFFFFFFFFFFFFF7;
          if (v40 < 0x3FFFFFFFFFFFFFF3) {
            goto LABEL_76;
          }
          goto LABEL_85;
        }
        uint64_t v43 = (char *)__p;
        size_t v40 = v60;
LABEL_90:
        size_t v60 = v40 + 1;
LABEL_91:
        uint64_t v47 = &v43[v40];
        *uint64_t v47 = v38;
        v47[1] = 0;
        if (v16 == 3) {
          continue;
        }
        char v48 = v65;
        if (SHIBYTE(v61) < 0)
        {
          size_t v7 = (v61 & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if (v60 == v7)
          {
            if ((v61 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FFFFFFFFFFFFFF8) {
LABEL_118:
            }
              sub_19E37C958();
            uint64_t v49 = __p;
            size_t v50 = 0x7FFFFFFFFFFFFFF7;
            if (v7 < 0x3FFFFFFFFFFFFFF3)
            {
LABEL_98:
              if (v7 + 1 > 2 * v7) {
                unint64_t v51 = v7 + 1;
              }
              else {
                unint64_t v51 = 2 * v7;
              }
              if (v51 >= 0x17)
              {
                uint64_t v52 = (v51 & 0x7FFFFFFFFFFFFFF8) + 8;
                uint64_t v53 = v51 | 7;
                if (v53 == 23) {
                  uint64_t v53 = v52;
                }
                size_t v50 = v53 + 1;
              }
              else
              {
                size_t v50 = 23;
              }
            }
            uint64_t v54 = (char *)operator new(v50);
            unint64_t v8 = v54;
            if (!v7 || (memmove(v54, v49, v7), v7 != 22)) {
              operator delete(v49);
            }
            unint64_t __p = v8;
            unint64_t v61 = v50 | 0x8000000000000000;
          }
          else
          {
            unint64_t v8 = (char *)__p;
            size_t v7 = v60;
          }
          size_t v60 = v7 + 1;
          goto LABEL_6;
        }
        if (HIBYTE(v61) == 22)
        {
          uint64_t v49 = &__p;
          size_t v7 = 22;
          goto LABEL_98;
        }
        size_t v7 = HIBYTE(v61);
        HIBYTE(v61) = (HIBYTE(v61) + 1) & 0x7F;
        unint64_t v8 = (char *)&__p;
LABEL_6:
        unint64_t v9 = &v8[v7];
        *unint64_t v9 = v48;
        v9[1] = 0;
      }
    }
    uint64_t v55 = sub_19E44FFC0((void *)(a1 + 24), (uint64_t)&__p);
    if (!v55)
    {
      BOOL v3 = 0;
      if ((SHIBYTE(v61) & 0x80000000) == 0) {
        return v3;
      }
      goto LABEL_114;
    }
    BOOL v3 = *(_DWORD *)(*(void *)(a1 + 104) + 24 * *((unsigned int *)v55 + 10) + 4) == *(_DWORD *)(*(void *)(a1 + 104)
                                                                                                  + 24 * *((unsigned int *)v55 + 10));
    if (SHIBYTE(v61) < 0) {
LABEL_114:
    }
      operator delete(__p);
  }
  return v3;
}

void sub_19E450B48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_19E450B6C(uint64_t a1, const __CFString *a2)
{
  if (!a2) {
    return 0;
  }
  sub_19E37774C(a2, __p);
  BOOL v3 = sub_19E44FFC0((void *)(a1 + 24), (uint64_t)__p);
  if (v3)
  {
    BOOL v4 = *(_DWORD *)(*(void *)(a1 + 104) + 24 * *((unsigned int *)v3 + 10) + 4) == *(_DWORD *)(*(void *)(a1 + 104)
                                                                                                 + 24
                                                                                                 * *((unsigned int *)v3 + 10));
    if (v7 < 0) {
      goto LABEL_7;
    }
  }
  else
  {
    BOOL v4 = 0;
    if (v7 < 0) {
LABEL_7:
    }
      operator delete(__p[0]);
  }
  return v4;
}

uint64_t sub_19E450BFC(uint64_t a1, const __CFString *a2, int a3, double a4)
{
  if (!a2 || *(_DWORD *)(a1 + 8) >= *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  sub_19E37774C(a2, &v38);
  if ((v40 & 0x80u) == 0) {
    char v7 = (uint64_t *)&v38;
  }
  else {
    char v7 = (uint64_t *)v38;
  }
  if ((v40 & 0x80u) == 0) {
    unint64_t v8 = v40;
  }
  else {
    unint64_t v8 = v39;
  }
  unint64_t v9 = sub_19E37BDA4((uint64_t)__p, v7, v8);
  int8x8_t v10 = *(int8x8_t *)(a1 + 32);
  if (v10)
  {
    unint64_t v11 = v9;
    uint8x8_t v12 = (uint8x8_t)vcnt_s8(v10);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v13 = v9;
      if (v9 >= *(void *)&v10) {
        unint64_t v13 = v9 % *(void *)&v10;
      }
    }
    else
    {
      unint64_t v13 = (*(void *)&v10 - 1) & v9;
    }
    unsigned int v15 = *(uint64_t ***)(*(void *)(a1 + 24) + 8 * v13);
    if (v15)
    {
      uint64_t v16 = *v15;
      if (*v15)
      {
        unsigned __int8 v17 = v40;
        if ((v40 & 0x80u) == 0) {
          unint64_t v18 = v40;
        }
        else {
          unint64_t v18 = v39;
        }
        if ((v40 & 0x80u) == 0) {
          size_t v19 = (unsigned __int8 *)&v38;
        }
        else {
          size_t v19 = (unsigned __int8 *)v38;
        }
        if (v12.u32[0] < 2uLL)
        {
          uint64_t v20 = *(void *)&v10 - 1;
          while (1)
          {
            uint64_t v25 = v16[1];
            if (v25 == v11)
            {
              uint64_t v26 = *((unsigned __int8 *)v16 + 39);
              if ((v26 & 0x80u) == 0) {
                uint64_t v27 = *((unsigned __int8 *)v16 + 39);
              }
              else {
                uint64_t v27 = v16[3];
              }
              if (v27 == v18)
              {
                if ((v26 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v16[2], v19, v16[3])) {
                    goto LABEL_58;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v16 + 39)) {
                    goto LABEL_58;
                  }
                  uint64_t v28 = 0;
                  while (*((unsigned __int8 *)v16 + v28 + 16) == v19[v28])
                  {
                    if (v26 == ++v28) {
                      goto LABEL_57;
                    }
                  }
                }
              }
            }
            else if ((v25 & v20) != v13)
            {
              goto LABEL_60;
            }
            uint64_t v16 = (uint64_t *)*v16;
            if (!v16) {
              goto LABEL_60;
            }
          }
        }
        do
        {
          unint64_t v21 = v16[1];
          if (v21 == v11)
          {
            uint64_t v22 = *((unsigned __int8 *)v16 + 39);
            if ((v22 & 0x80u) == 0) {
              uint64_t v23 = *((unsigned __int8 *)v16 + 39);
            }
            else {
              uint64_t v23 = v16[3];
            }
            if (v23 == v18)
            {
              if ((v22 & 0x80) != 0)
              {
                if (!memcmp((const void *)v16[2], v19, v16[3]))
                {
LABEL_58:
                  uint64_t v14 = 0;
                  if ((v17 & 0x80) != 0) {
                    goto LABEL_77;
                  }
                  return v14;
                }
              }
              else
              {
                if (!*((unsigned char *)v16 + 39)) {
                  goto LABEL_58;
                }
                uint64_t v24 = 0;
                while (*((unsigned __int8 *)v16 + v24 + 16) == v19[v24])
                {
                  if (v22 == ++v24)
                  {
LABEL_57:
                    if (!v16) {
                      goto LABEL_60;
                    }
                    goto LABEL_58;
                  }
                }
              }
            }
          }
          else
          {
            if (v21 >= *(void *)&v10) {
              v21 %= *(void *)&v10;
            }
            if (v21 != v13) {
              break;
            }
          }
          uint64_t v16 = (uint64_t *)*v16;
        }
        while (v16);
      }
    }
  }
LABEL_60:
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  if (v14 >= *(_DWORD *)(a1 + 16)) {
    uint64_t v14 = 0;
  }
  else {
    *(_DWORD *)(a1 + 8) = v14 + 1;
  }
  LODWORD(__p[0]) = v14;
  HIDWORD(__p[0]) = v14;
  LODWORD(__p[1]) = a3;
  __p[2] = *(void **)&a4;
  sub_19E450F7C(a1, (uint64_t)&v38, (long long *)__p);
  sub_19E4213CC((uint64_t)__p, (uint64_t *)(a1 + 128), (const void **)&v38, a3);
  uint64_t v29 = (void **)__p[0];
  size_t v30 = (void **)__p[1];
  if (__p[0] != __p[1])
  {
    do
    {
      unsigned int v31 = *(_DWORD *)(a1 + 8);
      if (v31 >= *(_DWORD *)(a1 + 16)) {
        break;
      }
      *(_DWORD *)(a1 + 8) = v31 + 1;
      if (!v31) {
        break;
      }
      *(void *)&long long v35 = __PAIR64__(v31, v14);
      DWORD2(v35) = a3;
      double v36 = a4;
      sub_19E450F7C(a1, (uint64_t)v29, &v35);
      v29 += 3;
    }
    while (v29 != v30);
    uint64_t v29 = (void **)__p[0];
  }
  *(unsigned char *)(a1 + 152) = 1;
  if (v29)
  {
    unint64_t v32 = (void **)__p[1];
    __n128 v33 = v29;
    if (__p[1] != v29)
    {
      do
      {
        if (*((char *)v32 - 1) < 0) {
          operator delete(*(v32 - 3));
        }
        v32 -= 3;
      }
      while (v32 != v29);
      __n128 v33 = (void **)__p[0];
    }
    __p[1] = v29;
    operator delete(v33);
  }
  if ((v40 & 0x80) != 0) {
LABEL_77:
  }
    operator delete(v38);
  return v14;
}

void sub_19E450F48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_19E450F7C(uint64_t a1, uint64_t a2, long long *a3)
{
  char v7 = *(void **)(a1 + 112);
  unint64_t v6 = *(void *)(a1 + 120);
  if ((unint64_t)v7 >= v6)
  {
    int8x8_t v10 = *(void **)(a1 + 104);
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v7 - v10) + 1;
    if (v11 > 0xAAAAAAAAAAAAAAALL) {
      sub_19E37C7C4();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (void)v10) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 > 0xAAAAAAAAAAAAAAALL) {
        sub_19E37C2B8();
      }
      uint64_t v14 = (char *)operator new(24 * v13);
    }
    else
    {
      uint64_t v14 = 0;
    }
    unsigned int v15 = &v14[8 * (v7 - v10)];
    *(_OWORD *)unsigned int v15 = *a3;
    *((void *)v15 + 2) = *((void *)a3 + 2);
    unint64_t v9 = v15 + 24;
    if (v7 != v10)
    {
      do
      {
        long long v16 = *(_OWORD *)(v7 - 3);
        *((void *)v15 - 1) = *(v7 - 1);
        *(_OWORD *)(v15 - 24) = v16;
        v15 -= 24;
        v7 -= 3;
      }
      while (v7 != v10);
      char v7 = *(void **)(a1 + 104);
    }
    *(void *)(a1 + 104) = v15;
    *(void *)(a1 + 112) = v9;
    *(void *)(a1 + 120) = &v14[24 * v13];
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    long long v8 = *a3;
    void v7[2] = *((void *)a3 + 2);
    *(_OWORD *)char v7 = v8;
    unint64_t v9 = v7 + 3;
  }
  *(void *)(a1 + 112) = v9;
  int v17 = -1431655765 * (((unint64_t)v9 - *(void *)(a1 + 104)) >> 3) - 1;
  uint64_t v56 = (long long *)a2;
  *((_DWORD *)sub_19E4515B8(a1 + 24, a2, &v56) + 10) = v17;
  LODWORD(v56) = v17;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E39369C(&v57, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    long long v57 = *(_OWORD *)a2;
    uint64_t v58 = *(void *)(a2 + 16);
  }
  unint64_t v18 = *((unsigned int *)a3 + 1);
  unint64_t v19 = *(void *)(a1 + 72);
  if (v19)
  {
    uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v19);
    v20.i16[0] = vaddlv_u8(v20);
    if (v20.u32[0] > 1uLL)
    {
      a2 = *((unsigned int *)a3 + 1);
      if (v19 <= v18) {
        a2 = v18 % v19;
      }
    }
    else
    {
      a2 = (v19 - 1) & v18;
    }
    unint64_t v21 = *(void ***)(*(void *)(a1 + 64) + 8 * a2);
    if (v21)
    {
      uint64_t v22 = (char *)*v21;
      if (*v21)
      {
        if (v20.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v24 = *((void *)v22 + 1);
            if (v24 == v18)
            {
              if (*((_DWORD *)v22 + 4) == v18) {
                goto LABEL_102;
              }
            }
            else if ((v24 & (v19 - 1)) != a2)
            {
              goto LABEL_42;
            }
            uint64_t v22 = *(char **)v22;
            if (!v22) {
              goto LABEL_42;
            }
          }
        }
        do
        {
          unint64_t v23 = *((void *)v22 + 1);
          if (v23 == v18)
          {
            if (*((_DWORD *)v22 + 4) == v18) {
              goto LABEL_102;
            }
          }
          else
          {
            if (v23 >= v19) {
              v23 %= v19;
            }
            if (v23 != a2) {
              break;
            }
          }
          uint64_t v22 = *(char **)v22;
        }
        while (v22);
      }
    }
  }
LABEL_42:
  uint64_t v22 = (char *)operator new(0x38uLL);
  uint64_t v25 = (void *)(a1 + 80);
  __n128 v59 = v22;
  uint64_t v60 = a1 + 80;
  *(void *)uint64_t v22 = 0;
  *((void *)v22 + 1) = v18;
  *((_DWORD *)v22 + 4) = v18;
  *((_DWORD *)v22 + 6) = 0;
  *((void *)v22 + 5) = 0;
  *((void *)v22 + 6) = 0;
  *((void *)v22 + 4) = 0;
  char v61 = 1;
  float v26 = (float)(unint64_t)(*(void *)(a1 + 88) + 1);
  float v27 = *(float *)(a1 + 96);
  if (v19 && (float)(v27 * (float)v19) >= v26)
  {
    unint64_t v18 = a2;
    goto LABEL_92;
  }
  BOOL v28 = 1;
  if (v19 >= 3) {
    BOOL v28 = (v19 & (v19 - 1)) != 0;
  }
  unint64_t v29 = v28 | (2 * v19);
  unint64_t v30 = vcvtps_u32_f32(v26 / v27);
  if (v29 <= v30) {
    size_t prime = v30;
  }
  else {
    size_t prime = v29;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v19 = *(void *)(a1 + 72);
  }
  if (prime > v19)
  {
LABEL_55:
    if (prime >> 61) {
      sub_19E37C2B8();
    }
    unint64_t v32 = operator new(8 * prime);
    __n128 v33 = *(void **)(a1 + 64);
    *(void *)(a1 + 64) = v32;
    if (v33) {
      operator delete(v33);
    }
    uint64_t v34 = 0;
    *(void *)(a1 + 72) = prime;
    do
      *(void *)(*(void *)(a1 + 64) + 8 * v34++) = 0;
    while (prime != v34);
    long long v35 = (void *)*v25;
    if (!*v25) {
      goto LABEL_79;
    }
    size_t v36 = v35[1];
    size_t v37 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v38 = v36 & v37;
      *(void *)(*(void *)(a1 + 64) + 8 * v38) = v25;
      for (uint64_t i = (void *)*v35; *v35; uint64_t i = (void *)*v35)
      {
        size_t v40 = i[1] & v37;
        if (v40 == v38)
        {
          long long v35 = i;
        }
        else
        {
          uint64_t v41 = *(void *)(a1 + 64);
          if (*(void *)(v41 + 8 * v40))
          {
            *long long v35 = *i;
            uint64_t v42 = 8 * v40;
            void *i = **(void **)(*(void *)(a1 + 64) + v42);
            **(void **)(*(void *)(a1 + 64) + v42) = i;
          }
          else
          {
            *(void *)(v41 + 8 * v40) = v35;
            long long v35 = i;
            size_t v38 = v40;
          }
        }
      }
LABEL_79:
      unint64_t v19 = prime;
      goto LABEL_80;
    }
    if (v36 >= prime) {
      v36 %= prime;
    }
    *(void *)(*(void *)(a1 + 64) + 8 * v36) = v25;
    __n128 v46 = (void *)*v35;
    if (!*v35) {
      goto LABEL_79;
    }
    while (1)
    {
      size_t v48 = v46[1];
      if (v48 >= prime) {
        v48 %= prime;
      }
      if (v48 != v36)
      {
        uint64_t v49 = *(void *)(a1 + 64);
        if (!*(void *)(v49 + 8 * v48))
        {
          *(void *)(v49 + 8 * v48) = v35;
          goto LABEL_84;
        }
        *long long v35 = *v46;
        uint64_t v47 = 8 * v48;
        void *v46 = **(void **)(*(void *)(a1 + 64) + v47);
        **(void **)(*(void *)(a1 + 64) + v47) = v46;
        __n128 v46 = v35;
      }
      size_t v48 = v36;
LABEL_84:
      long long v35 = v46;
      __n128 v46 = (void *)*v46;
      size_t v36 = v48;
      if (!v46) {
        goto LABEL_79;
      }
    }
  }
  if (prime >= v19) {
    goto LABEL_80;
  }
  unint64_t v43 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 88) / *(float *)(a1 + 96));
  if (v19 < 3 || (uint8x8_t v44 = (uint8x8_t)vcnt_s8((int8x8_t)v19), v44.i16[0] = vaddlv_u8(v44), v44.u32[0] > 1uLL))
  {
    unint64_t v43 = std::__next_prime(v43);
  }
  else
  {
    uint64_t v45 = 1 << -(char)__clz(v43 - 1);
    if (v43 >= 2) {
      unint64_t v43 = v45;
    }
  }
  if (prime <= v43) {
    size_t prime = v43;
  }
  if (prime < v19)
  {
    if (!prime)
    {
      uint64_t v55 = *(void **)(a1 + 64);
      *(void *)(a1 + 64) = 0;
      if (v55) {
        operator delete(v55);
      }
      unint64_t v19 = 0;
      *(void *)(a1 + 72) = 0;
      goto LABEL_80;
    }
    goto LABEL_55;
  }
  unint64_t v19 = *(void *)(a1 + 72);
LABEL_80:
  if ((v19 & (v19 - 1)) != 0)
  {
    if (v19 <= v18) {
      v18 %= v19;
    }
  }
  else
  {
    unint64_t v18 = (v19 - 1) & v18;
  }
LABEL_92:
  uint64_t v50 = *(void *)(a1 + 64);
  unint64_t v51 = *(void **)(v50 + 8 * v18);
  if (v51)
  {
    *(void *)uint64_t v22 = *v51;
LABEL_100:
    *unint64_t v51 = v22;
    goto LABEL_101;
  }
  *(void *)uint64_t v22 = *v25;
  *uint64_t v25 = v22;
  *(void *)(v50 + 8 * v18) = v25;
  if (*(void *)v22)
  {
    unint64_t v52 = *(void *)(*(void *)v22 + 8);
    if ((v19 & (v19 - 1)) != 0)
    {
      if (v52 >= v19) {
        v52 %= v19;
      }
    }
    else
    {
      v52 &= v19 - 1;
    }
    unint64_t v51 = (void *)(*(void *)(a1 + 64) + 8 * v52);
    goto LABEL_100;
  }
LABEL_101:
  ++*(void *)(a1 + 88);
LABEL_102:
  *((_DWORD *)v22 + 6) = v56;
  uint64_t v53 = (void **)(v22 + 32);
  if (v22[55] < 0) {
    operator delete(*v53);
  }
  double result = *(double *)&v57;
  *(_OWORD *)uint64_t v53 = v57;
  *((void *)v22 + 6) = v58;
  return result;
}

void sub_19E45158C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_19E4515B8(uint64_t a1, uint64_t a2, long long **a3)
{
  unint64_t v5 = (unsigned char *)a2;
  unint64_t v7 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v8 = v7;
  }
  unint64_t v9 = sub_19E37BDA4((uint64_t)v56, (uint64_t *)a2, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    unint64_t v13 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        char v15 = v5[23];
        if (v15 >= 0) {
          uint64_t v16 = v5[23];
        }
        else {
          uint64_t v16 = *((void *)v5 + 1);
        }
        if (v15 < 0) {
          unint64_t v5 = *(unsigned char **)v5;
        }
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v21 = v14[1];
            if (v21 == v10)
            {
              uint64_t v22 = *((unsigned __int8 *)v14 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = *((unsigned __int8 *)v14 + 39);
              }
              else {
                uint64_t v23 = v14[3];
              }
              if (v23 == v16)
              {
                if ((v22 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v14[2], v5, v14[3])) {
                    return v14;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v14 + 39)) {
                    return v14;
                  }
                  uint64_t v24 = 0;
                  while (*((unsigned __int8 *)v14 + v24 + 16) == v5[v24])
                  {
                    if (v22 == ++v24) {
                      return v14;
                    }
                  }
                }
              }
            }
            else if ((v21 & (v11 - 1)) != v3)
            {
              goto LABEL_51;
            }
            uint64_t v14 = (uint64_t *)*v14;
            if (!v14) {
              goto LABEL_51;
            }
          }
        }
        do
        {
          unint64_t v17 = v14[1];
          if (v17 == v10)
          {
            uint64_t v18 = *((unsigned __int8 *)v14 + 39);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v14 + 39);
            }
            else {
              uint64_t v19 = v14[3];
            }
            if (v19 == v16)
            {
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp((const void *)v14[2], v5, v14[3])) {
                  return v14;
                }
              }
              else
              {
                if (!*((unsigned char *)v14 + 39)) {
                  return v14;
                }
                uint64_t v20 = 0;
                while (*((unsigned __int8 *)v14 + v20 + 16) == v5[v20])
                {
                  if (v18 == ++v20) {
                    return v14;
                  }
                }
              }
            }
          }
          else
          {
            if (v17 >= v11) {
              v17 %= v11;
            }
            if (v17 != v3) {
              break;
            }
          }
          uint64_t v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_51:
  uint64_t v25 = (void *)(a1 + 16);
  float v26 = (char *)operator new(0x30uLL);
  v56[0] = v26;
  v56[1] = a1 + 16;
  char v57 = 0;
  *(void *)float v26 = 0;
  *((void *)v26 + 1) = v10;
  float v27 = v26 + 16;
  BOOL v28 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    sub_19E39369C(v27, *(void **)v28, *((void *)v28 + 1));
  }
  else
  {
    long long v29 = *v28;
    *((void *)v26 + 4) = *((void *)v28 + 2);
    *(_OWORD *)float v27 = v29;
  }
  *((_DWORD *)v26 + 10) = 0;
  char v57 = 1;
  float v30 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v31 = *(float *)(a1 + 32);
  if (!v11 || (float)(v31 * (float)v11) < v30)
  {
    BOOL v32 = 1;
    if (v11 >= 3) {
      BOOL v32 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v33 = v32 | (2 * v11);
    unint64_t v34 = vcvtps_u32_f32(v30 / v31);
    if (v33 <= v34) {
      size_t prime = v34;
    }
    else {
      size_t prime = v33;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    if (prime <= v11)
    {
      if (prime >= v11) {
        goto LABEL_91;
      }
      unint64_t v46 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v47.i16[0] = vaddlv_u8(v47), v47.u32[0] > 1uLL))
      {
        unint64_t v46 = std::__next_prime(v46);
      }
      else
      {
        uint64_t v48 = 1 << -(char)__clz(v46 - 1);
        if (v46 >= 2) {
          unint64_t v46 = v48;
        }
      }
      if (prime <= v46) {
        size_t prime = v46;
      }
      if (prime >= v11)
      {
        unint64_t v11 = *(void *)(a1 + 8);
LABEL_91:
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v10 >= v11) {
            unint64_t v3 = v10 % v11;
          }
          else {
            unint64_t v3 = v10;
          }
        }
        else
        {
          unint64_t v3 = (v11 - 1) & v10;
        }
        goto LABEL_104;
      }
      if (!prime)
      {
        uint64_t v55 = *(void **)a1;
        *(void *)a1 = 0;
        if (v55) {
          operator delete(v55);
        }
        unint64_t v11 = 0;
        *(void *)(a1 + 8) = 0;
        goto LABEL_91;
      }
    }
    if (prime >> 61) {
      sub_19E37C2B8();
    }
    size_t v36 = operator new(8 * prime);
    size_t v37 = *(void **)a1;
    *(void *)a1 = v36;
    if (v37) {
      operator delete(v37);
    }
    uint64_t v38 = 0;
    *(void *)(a1 + 8) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v38++) = 0;
    while (prime != v38);
    unint64_t v39 = (void *)*v25;
    if (!*v25)
    {
LABEL_90:
      unint64_t v11 = prime;
      goto LABEL_91;
    }
    size_t v40 = v39[1];
    size_t v41 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v42 = v40 & v41;
      *(void *)(*(void *)a1 + 8 * v42) = v25;
      for (uint64_t i = (void *)*v39; *v39; uint64_t i = (void *)*v39)
      {
        size_t v44 = i[1] & v41;
        if (v44 == v42)
        {
          unint64_t v39 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v44))
        {
          *unint64_t v39 = *i;
          uint64_t v45 = 8 * v44;
          void *i = **(void **)(*(void *)a1 + v45);
          **(void **)(*(void *)a1 + v45) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v44) = v39;
          unint64_t v39 = i;
          size_t v42 = v44;
        }
      }
      goto LABEL_90;
    }
    if (v40 >= prime) {
      v40 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v40) = v25;
    uint64_t v49 = (void *)*v39;
    if (!*v39) {
      goto LABEL_90;
    }
    while (1)
    {
      size_t v51 = v49[1];
      if (v51 >= prime) {
        v51 %= prime;
      }
      if (v51 != v40)
      {
        if (!*(void *)(*(void *)a1 + 8 * v51))
        {
          *(void *)(*(void *)a1 + 8 * v51) = v39;
          goto LABEL_95;
        }
        *unint64_t v39 = *v49;
        uint64_t v50 = 8 * v51;
        void *v49 = **(void **)(*(void *)a1 + v50);
        **(void **)(*(void *)a1 + v50) = v49;
        uint64_t v49 = v39;
      }
      size_t v51 = v40;
LABEL_95:
      unint64_t v39 = v49;
      uint64_t v49 = (void *)*v49;
      size_t v40 = v51;
      if (!v49) {
        goto LABEL_90;
      }
    }
  }
LABEL_104:
  unint64_t v52 = *(void **)(*(void *)a1 + 8 * v3);
  if (v52)
  {
    *(void *)v56[0] = *v52;
    void *v52 = v56[0];
  }
  else
  {
    *(void *)v56[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v56[0];
    *(void *)(*(void *)a1 + 8 * v3) = v25;
    if (*(void *)v56[0])
    {
      unint64_t v53 = *(void *)(*(void *)v56[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v53 >= v11) {
          v53 %= v11;
        }
      }
      else
      {
        v53 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v53) = v56[0];
    }
  }
  uint64_t v14 = (uint64_t *)v56[0];
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_19E451B4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3F0610((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E451B68(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16) && *(char *)(v2 + 55) < 0) {
      operator delete(*(void **)(v2 + 32));
    }
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t sub_19E451BB8(uint64_t a1, const __CFArray *a2)
{
  sub_19E451D5C((uint64_t)&__p, a2);
  if ((void **)(a1 + 128) != &__p) {
    sub_19E42104C((void ***)(a1 + 128), (void **)__p, v8, 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (unsigned char *)__p) >> 3));
  }
  unint64_t v3 = (void **)__p;
  if (__p)
  {
    BOOL v4 = v8;
    unint64_t v5 = __p;
    if (v8 != __p)
    {
      do
      {
        if (*((char *)v4 - 1) < 0) {
          operator delete(*(v4 - 3));
        }
        v4 -= 3;
      }
      while (v4 != v3);
      unint64_t v5 = __p;
    }
    unint64_t v8 = v3;
    operator delete(v5);
  }
  return 1;
}

#error "19E451D20: call analysis failed (funcsize=54)"

CFIndex sub_19E451D5C(uint64_t a1, CFArrayRef theArray)
{
  CFIndex v4 = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  CFStringRef v5 = (const __CFString *)*MEMORY[0x1E4F1D218];
  while (1)
  {
    CFIndex result = CFArrayGetCount(theArray);
    if (v4 >= result) {
      return result;
    }
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v4);
    CFTypeID v8 = CFGetTypeID(ValueAtIndex);
    CFTypeID TypeID = CFStringGetTypeID();
    if (v8 == TypeID)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFLocaleCreate(0, ValueAtIndex);
    }
    else
    {
      CFTypeID v10 = CFGetTypeID(ValueAtIndex);
      if (v10 != CFLocaleGetTypeID())
      {
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "invalid locale value for creating vocabulary");
        exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4E8] + 16);
        __cxa_throw(exception, (struct type_info *)off_1E599EF10, MEMORY[0x1E4FBA1E8]);
      }
    }
    CFStringRef Value = (const __CFString *)CFLocaleGetValue((CFLocaleRef)ValueAtIndex, v5);
    sub_19E37774C(Value, __p);
    unint64_t v12 = *(void *)(a1 + 8);
    if (v12 < *(void *)(a1 + 16))
    {
      long long v13 = *(_OWORD *)__p;
      *(void *)(v12 + 16) = v18;
      *(_OWORD *)unint64_t v12 = v13;
      *(void *)(a1 + 8) = v12 + 24;
      if (v8 != TypeID) {
        goto LABEL_2;
      }
LABEL_12:
      CFRelease(ValueAtIndex);
      goto LABEL_2;
    }
    uint64_t v14 = sub_19E3EB1B8((void **)a1, (uint64_t)__p);
    int v15 = SHIBYTE(v18);
    *(void *)(a1 + 8) = v14;
    if ((v15 & 0x80000000) == 0)
    {
      if (v8 != TypeID) {
        goto LABEL_2;
      }
      goto LABEL_12;
    }
    operator delete(__p[0]);
    if (v8 == TypeID) {
      goto LABEL_12;
    }
LABEL_2:
    ++v4;
  }
}

void sub_19E451EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_19E3EB09C(v15);
  _Unwind_Resume(a1);
}

void sub_19E451F4C(void *a1)
{
  sub_19E451F84(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E451F84(void *a1)
{
  *a1 = &unk_1EF0B9E80;
  uint64_t v2 = a1[16];
  if (v2)
  {
    uint64_t v3 = a1[17];
    CFIndex v4 = (void *)a1[16];
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 24;
      }
      while (v3 != v2);
      CFIndex v4 = (void *)a1[16];
    }
    a1[17] = v2;
    operator delete(v4);
  }
  CFStringRef v5 = (void *)a1[13];
  if (v5)
  {
    a1[14] = v5;
    operator delete(v5);
  }
  unint64_t v6 = (void **)a1[10];
  if (v6)
  {
    do
    {
      unint64_t v11 = (void **)*v6;
      if (*((char *)v6 + 55) < 0) {
        operator delete(v6[4]);
      }
      operator delete(v6);
      unint64_t v6 = v11;
    }
    while (v11);
  }
  unint64_t v7 = (void *)a1[8];
  a1[8] = 0;
  if (v7) {
    operator delete(v7);
  }
  CFTypeID v8 = (void **)a1[5];
  if (v8)
  {
    do
    {
      unint64_t v12 = (void **)*v8;
      if (*((char *)v8 + 39) < 0) {
        operator delete(v8[2]);
      }
      operator delete(v8);
      CFTypeID v8 = v12;
    }
    while (v12);
  }
  unint64_t v9 = (void *)a1[3];
  a1[3] = 0;
  if (v9) {
    operator delete(v9);
  }
  return a1;
}

void sub_19E4520A8()
{
}

BOOL sub_19E4520D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && (unsigned int v3 = *(_DWORD *)(a2 + 4 * a3 - 4), *(_DWORD *)(a1 + 96) <= v3)) {
    return *(_DWORD *)(a1 + 100) >= v3;
  }
  else {
    return 0;
  }
}

void sub_19E452104(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  if (!a3) {
    goto LABEL_7;
  }
  uint64_t v5 = a2 + 4 * a3;
  unsigned int v6 = *(_DWORD *)(v5 - 4);
  if (a3 != 1)
  {
    unsigned int v7 = *(_DWORD *)(v5 - 8);
    if (*(_DWORD *)(a1 + 88) <= v7 && *(_DWORD *)(a1 + 92) >= v7)
    {
      uint64_t v14 = v6 + (v7 << 16);
      uint64_t v16 = *(uint64_t **)(a1 + 72);
      unint64_t v15 = *(void *)(a1 + 80);
      while (v15)
      {
        unint64_t v17 = v15 >> 1;
        uint64_t v18 = (unint64_t *)&v16[2 * (v15 >> 1)];
        unint64_t v20 = *v18;
        uint64_t v19 = (uint64_t *)(v18 + 2);
        v15 += ~(v15 >> 1);
        if (v20 < (unint64_t)v14 << 16) {
          uint64_t v16 = v19;
        }
        else {
          unint64_t v15 = v17;
        }
      }
      *a4 = 0;
      a4[1] = 0;
      a4[2] = 0;
      uint64_t v41 = *v16;
      if (v14 != (unint64_t)*v16 >> 16) {
        return;
      }
      size_t v42 = 0;
      unint64_t v43 = 0;
      size_t v44 = 0;
      uint64_t v62 = v14;
      while (1)
      {
        int v47 = (unsigned __int16)v41;
        if (!(_WORD)v41) {
          goto LABEL_59;
        }
        if (v44 >= v43) {
          break;
        }
        *(_DWORD *)size_t v44 = (unsigned __int16)v41;
        uint64_t v45 = v44 + 4;
LABEL_58:
        a4[1] = v45;
        size_t v44 = v45;
LABEL_59:
        unint64_t v46 = v16[2];
        v16 += 2;
        LOWORD(v41) = v46;
        if (v14 != v46 >> 16) {
          return;
        }
      }
      uint64_t v48 = (v44 - v42) >> 2;
      unint64_t v49 = v48 + 1;
      if ((unint64_t)(v48 + 1) >> 62) {
        sub_19E37C7C4();
      }
      if ((v43 - v42) >> 1 > v49) {
        unint64_t v49 = (v43 - v42) >> 1;
      }
      if ((unint64_t)(v43 - v42) >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v50 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v50 = v49;
      }
      if (v50)
      {
        if (v50 >> 62) {
          sub_19E37C2B8();
        }
        size_t v51 = operator new(4 * v50);
      }
      else
      {
        size_t v51 = 0;
      }
      unint64_t v52 = &v51[4 * v48];
      *(_DWORD *)unint64_t v52 = v47;
      uint64_t v45 = v52 + 4;
      if (v44 != v42)
      {
        unint64_t v53 = v44 - 4 - v42;
        if (v53 >= 0xBC)
        {
          if (&v51[v44 - v42 - 4 - (v53 & 0xFFFFFFFFFFFFFFFCLL)] > &v51[v44 - v42 - 4])
          {
            uint64_t v54 = v44;
          }
          else if (&v44[-(v53 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v44 - 4)
          {
            uint64_t v54 = v44;
          }
          else if ((unint64_t)(v42 - v51) >= 0x20)
          {
            uint64_t v56 = (v53 >> 2) + 1;
            uint64_t v54 = &v44[-4 * (v56 & 0x7FFFFFFFFFFFFFF8)];
            char v57 = &v51[4 * v48 - 16];
            uint64_t v58 = v44 - 16;
            uint64_t v59 = v56 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v60 = *(_OWORD *)v58;
              *(v57 - 1) = *((_OWORD *)v58 - 1);
              *char v57 = v60;
              v57 -= 2;
              v58 -= 32;
              v59 -= 8;
            }
            while (v59);
            v52 -= 4 * (v56 & 0x7FFFFFFFFFFFFFF8);
            if (v56 == (v56 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_76;
            }
          }
          else
          {
            uint64_t v54 = v44;
          }
        }
        else
        {
          uint64_t v54 = v44;
        }
        do
        {
          int v55 = *((_DWORD *)v54 - 1);
          v54 -= 4;
          *((_DWORD *)v52 - 1) = v55;
          v52 -= 4;
        }
        while (v54 != v42);
      }
LABEL_76:
      unint64_t v43 = &v51[4 * v50];
      *a4 = v52;
      a4[1] = v45;
      a4[2] = v43;
      if (v42) {
        operator delete(v42);
      }
      size_t v42 = v52;
      uint64_t v14 = v62;
      goto LABEL_58;
    }
  }
  if (*(_DWORD *)(a1 + 96) > v6 || *(_DWORD *)(a1 + 100) < v6)
  {
LABEL_7:
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    return;
  }
  unint64_t v9 = *(int **)(a1 + 56);
  unint64_t v8 = *(void *)(a1 + 64);
  while (v8)
  {
    unint64_t v10 = v8 >> 1;
    unint64_t v11 = (unsigned int *)&v9[2 * (v8 >> 1)];
    unsigned int v13 = *v11;
    unint64_t v12 = (int *)(v11 + 2);
    v8 += ~(v8 >> 1);
    if (v13 < v6 << 16) {
      unint64_t v9 = v12;
    }
    else {
      unint64_t v8 = v10;
    }
  }
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  int v21 = *v9;
  if (v6 == HIWORD(*v9))
  {
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    unsigned int v61 = v6;
    while (1)
    {
      int v27 = (unsigned __int16)v21;
      if (!(_WORD)v21) {
        goto LABEL_25;
      }
      if (v24 >= v23) {
        break;
      }
      *(_DWORD *)uint64_t v24 = (unsigned __int16)v21;
      uint64_t v25 = v24 + 4;
LABEL_24:
      a4[1] = v25;
      uint64_t v24 = v25;
LABEL_25:
      unsigned int v26 = v9[2];
      v9 += 2;
      LOWORD(v21) = v26;
      if (v6 != HIWORD(v26)) {
        return;
      }
    }
    uint64_t v28 = (v24 - v22) >> 2;
    unint64_t v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 62) {
      sub_19E37C7C4();
    }
    if ((v23 - v22) >> 1 > v29) {
      unint64_t v29 = (v23 - v22) >> 1;
    }
    if ((unint64_t)(v23 - v22) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v29;
    }
    if (v30)
    {
      if (v30 >> 62) {
        sub_19E37C2B8();
      }
      float v31 = operator new(4 * v30);
    }
    else
    {
      float v31 = 0;
    }
    BOOL v32 = &v31[4 * v28];
    *(_DWORD *)BOOL v32 = v27;
    uint64_t v25 = v32 + 4;
    if (v24 == v22) {
      goto LABEL_42;
    }
    unint64_t v33 = v24 - 4 - v22;
    if (v33 < 0xBC)
    {
      unint64_t v34 = v24;
      goto LABEL_41;
    }
    if (&v31[v24 - v22 - 4 - (v33 & 0xFFFFFFFFFFFFFFFCLL)] > &v31[v24 - v22 - 4])
    {
      unint64_t v34 = v24;
    }
    else
    {
      if (&v24[-(v33 & 0xFFFFFFFFFFFFFFFCLL) - 4] <= v24 - 4)
      {
        if ((unint64_t)(v22 - v31) < 0x20)
        {
          unint64_t v34 = v24;
          goto LABEL_41;
        }
        uint64_t v36 = (v33 >> 2) + 1;
        unint64_t v34 = &v24[-4 * (v36 & 0x7FFFFFFFFFFFFFF8)];
        size_t v37 = &v31[4 * v28 - 16];
        uint64_t v38 = v24 - 16;
        uint64_t v39 = v36 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v40 = *(_OWORD *)v38;
          *(v37 - 1) = *((_OWORD *)v38 - 1);
          *size_t v37 = v40;
          v37 -= 2;
          v38 -= 32;
          v39 -= 8;
        }
        while (v39);
        v32 -= 4 * (v36 & 0x7FFFFFFFFFFFFFF8);
        if (v36 != (v36 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_41;
        }
LABEL_42:
        uint64_t v23 = &v31[4 * v30];
        *a4 = v32;
        a4[1] = v25;
        a4[2] = v23;
        if (v22) {
          operator delete(v22);
        }
        uint64_t v22 = v32;
        unsigned int v6 = v61;
        goto LABEL_24;
      }
      unint64_t v34 = v24;
    }
    do
    {
LABEL_41:
      int v35 = *((_DWORD *)v34 - 1);
      v34 -= 4;
      *((_DWORD *)v32 - 1) = v35;
      v32 -= 4;
    }
    while (v34 != v22);
    goto LABEL_42;
  }
}

void sub_19E452578(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E4525BC(uint64_t a1)
{
  return *(void *)(a1 + 104);
}

uint64_t sub_19E4525C4(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t sub_19E4525CC(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

uint64_t sub_19E4525D4()
{
  return 0;
}

BOOL sub_19E4525DC(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 104) <= a2 && *(_DWORD *)(a1 + 108) >= a2;
}

BOOL sub_19E452600(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 96) <= a2 && *(_DWORD *)(a1 + 100) >= a2;
}

BOOL sub_19E452624(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 88) <= a2 && *(_DWORD *)(a1 + 92) >= a2;
}

BOOL sub_19E452648(uint64_t a1, unsigned int a2)
{
  if (a2 < 4) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 112) <= a2) {
    return *(_DWORD *)(a1 + 116) >= a2;
  }
  return 0;
}

uint64_t sub_19E45267C()
{
  return 4;
}

uint64_t sub_19E452684(void *a1)
{
  uint64_t v1 = a1[4];
  if (v1) {
    LODWORD(v1) = *(_DWORD *)(a1[3] + 8 * v1 - 8);
  }
  uint64_t v2 = a1[6];
  if (v2) {
    LODWORD(v2) = *(_DWORD *)(a1[5] + 16 * v2 - 16);
  }
  if (v1 <= v2) {
    return v2;
  }
  else {
    return v1;
  }
}

uint64_t sub_19E4526B8(void *a1, unsigned int a2, _DWORD *a3, uint64_t a4)
{
  unint64_t v4 = a1[4];
  if (!v4) {
    goto LABEL_14;
  }
  uint64_t v5 = (_DWORD *)a1[3];
  unsigned int v6 = &v5[2 * v4];
  do
  {
    unint64_t v7 = v4 >> 1;
    unint64_t v8 = &v5[2 * (v4 >> 1)];
    unsigned int v10 = *v8;
    unint64_t v9 = v8 + 2;
    v4 += ~(v4 >> 1);
    if (v10 < a2) {
      uint64_t v5 = v9;
    }
    else {
      unint64_t v4 = v7;
    }
  }
  while (v4);
  if (v5 != v6 && *v5 == a2)
  {
    if (a4)
    {
      *a3 = *((unsigned __int16 *)v5 + 3);
      a3[1] = *((unsigned __int16 *)v5 + 2);
    }
    if (*((_WORD *)v5 + 2)) {
      return 2;
    }
    else {
      return 1;
    }
  }
  else
  {
LABEL_14:
    unint64_t v12 = a1[6];
    if (!v12) {
      goto LABEL_25;
    }
    unsigned int v13 = (_DWORD *)a1[5];
    uint64_t v14 = &v13[4 * v12];
    do
    {
      unint64_t v15 = v12 >> 1;
      uint64_t v16 = &v13[4 * (v12 >> 1)];
      unsigned int v18 = *v16;
      unint64_t v17 = v16 + 4;
      v12 += ~(v12 >> 1);
      if (v18 < a2) {
        unsigned int v13 = v17;
      }
      else {
        unint64_t v12 = v15;
      }
    }
    while (v12);
    if (v13 != v14 && *v13 == a2)
    {
      if (a4)
      {
        uint64_t v19 = *((void *)v13 + 1);
        *a3 = HIDWORD(v19);
        a3[1] = WORD1(v19);
        a3[2] = (unsigned __int16)v19;
      }
      return 3;
    }
    else
    {
LABEL_25:
      *a3 = 3;
      return 1;
    }
  }
}

uint64_t sub_19E4527AC(void *a1, unsigned int *a2, unint64_t a3)
{
  if (a3 > 2)
  {
    if (a3 == 3)
    {
      unint64_t v5 = a1[10];
      if (v5)
      {
        unint64_t v6 = ((a2[1] << 16) | ((unint64_t)*a2 << 32)) + a2[2];
        unint64_t v7 = (void *)a1[9];
        unint64_t v8 = &v7[2 * v5];
        do
        {
          unint64_t v9 = v5 >> 1;
          unsigned int v10 = &v7[2 * (v5 >> 1)];
          unint64_t v12 = *v10;
          unint64_t v11 = v10 + 2;
          v5 += ~(v5 >> 1);
          if (v12 < v6) {
            unint64_t v7 = v11;
          }
          else {
            unint64_t v5 = v9;
          }
        }
        while (v5);
        if (v7 != v8 && *v7 == v6) {
          return *((unsigned int *)v7 + 2);
        }
      }
    }
    return 0;
  }
  if (a3 == 2)
  {
    unsigned int v3 = a2[1];
    unint64_t v4 = a1[8];
    if (!v4) {
      return 0;
    }
  }
  else
  {
    unsigned int v3 = 0;
    unint64_t v4 = a1[8];
    if (!v4) {
      return 0;
    }
  }
  unsigned int v14 = v3 + (*a2 << 16);
  unint64_t v15 = (_DWORD *)a1[7];
  uint64_t v16 = &v15[2 * v4];
  do
  {
    unint64_t v17 = v4 >> 1;
    unsigned int v18 = &v15[2 * (v4 >> 1)];
    unsigned int v20 = *v18;
    uint64_t v19 = v18 + 2;
    v4 += ~(v4 >> 1);
    if (v20 < v14) {
      unint64_t v15 = v19;
    }
    else {
      unint64_t v4 = v17;
    }
  }
  while (v4);
  if (v15 != v16 && *v15 == v14) {
    return v15[1];
  }
  return 0;
}

uint64_t sub_19E4528A0()
{
  return 1;
}

void sub_19E4528A8(void *a1)
{
  *a1 = &unk_1EF0BBA60;
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    munmap(v2, a1[2]);
  }
  a1[2] = 0;
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E452920(void *a1)
{
  *a1 = &unk_1EF0BBA60;
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    munmap(v2, a1[2]);
  }
  a1[2] = 0;
  return a1;
}

void *sub_19E452978(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  if (*(char *)(a2 + 23) >= 0) {
    unint64_t v4 = (const char *)a2;
  }
  else {
    unint64_t v4 = *(const char **)a2;
  }
  int v5 = open(v4, 0);
  if (v5 < 0)
  {
    exception = (std::ios_base::failure *)__cxa_allocate_exception(0x20uLL);
    sub_19E382340(&v18, "open()");
    unint64_t v11 = __error();
    sub_19E452DA8(exception, (const void **)&v18, a2, *v11);
    __cxa_throw(exception, MEMORY[0x1E4FBA300], MEMORY[0x1E4FBA298]);
  }
  int v6 = v5;
  if (fstat(v5, &v18) < 0)
  {
    unint64_t v12 = (std::ios_base::failure *)__cxa_allocate_exception(0x20uLL);
    sub_19E382340(&v16, "fstat()");
    unsigned int v13 = __error();
    sub_19E452DA8(v12, &v16, a2, *v13);
    __cxa_throw(v12, MEMORY[0x1E4FBA300], MEMORY[0x1E4FBA298]);
  }
  st_std::string::size_type size = v18.st_size;
  a1[1] = v18.st_size;
  if (st_size >= 0x7FFFFFFF) {
    LODWORD(st_size) = 0x7FFFFFFF;
  }
  int v17 = st_size;
  uint64_t v16 = 0;
  fcntl(v6, 44, &v16);
  unint64_t v8 = mmap(0, a1[1], 1, 1, v6, 0);
  *a1 = v8;
  if (v8 == (void *)-1)
  {
    unsigned int v14 = (std::ios_base::failure *)__cxa_allocate_exception(0x20uLL);
    sub_19E382340(&v16, "mmap()");
    unint64_t v15 = __error();
    sub_19E452DA8(v14, &v16, a2, *v15);
    __cxa_throw(v14, MEMORY[0x1E4FBA300], MEMORY[0x1E4FBA298]);
  }
  close(v6);
  return a1;
}

void sub_19E452B5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v23 & 1) == 0)
    {
LABEL_6:
      close(v21);
      _Unwind_Resume(a1);
    }
  }
  else if (!v23)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v22);
  goto LABEL_6;
}

uint64_t sub_19E452BF0(void *a1)
{
  if (a1[1] <= 0x2FuLL)
  {
    sub_19E393108((uint64_t)v9);
    sub_19E37CA70(v10, (uint64_t)"(file_size=", 11);
    uint64_t v2 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v2, (uint64_t)", offset=", 9);
    unsigned int v3 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v3, (uint64_t)", object_size=", 14);
    unint64_t v4 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v4, (uint64_t)")", 1);
    exception = __cxa_allocate_exception(0x10uLL);
    sub_19E43BFBC(&__dst, (uint64_t)v9);
    __n128 v6 = sub_19E420378(&v8, "attempted to read beyond the end of the mapped file ", &__dst);
    MEMORY[0x19F3BD7A0](exception, &v8, v6);
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  return *a1;
}

void sub_19E452CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v23 & 1) == 0)
    {
LABEL_8:
      sub_19E3933E0((uint64_t)&a22);
      _Unwind_Resume(a1);
    }
  }
  else if (!v23)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v22);
  goto LABEL_8;
}

uint64_t sub_19E452D6C(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2) {
    munmap(v2, *(void *)(a1 + 8));
  }
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_19E452DA8(std::ios_base::failure *a1, const void **a2, uint64_t a3, unsigned int a4)
{
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  unint64_t v6 = v5 + 13;
  if (v5 + 13 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  if (v6 >= 0x17)
  {
    uint64_t v12 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v12 = v6 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (std::string *)operator new(v12 + 1);
    __dst.__r_.__value_.__l.__size_ = v5 + 13;
    __dst.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v5 + 13;
    if (!v5) {
      goto LABEL_15;
    }
  }
  if (v4 >= 0) {
    unsigned int v14 = a2;
  }
  else {
    unsigned int v14 = *a2;
  }
  memmove(p_dst, v14, v5);
LABEL_15:
  strcpy((char *)p_dst + v5, " failed for '");
  int v15 = *(char *)(a3 + 23);
  if (v15 >= 0) {
    uint64_t v16 = (const std::string::value_type *)a3;
  }
  else {
    uint64_t v16 = *(const std::string::value_type **)a3;
  }
  if (v15 >= 0) {
    std::string::size_type v17 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v17 = *(void *)(a3 + 8);
  }
  stat v18 = std::string::append(&__dst, v16, v17);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  unsigned int v20 = std::string::append(&v24, "'", 1uLL);
  long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  __msg.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__msg.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  *(void *)&__ec.__val_ = a4;
  __ec.__cat_ = std::generic_category();
  std::ios_base::failure::failure(a1, &__msg, &__ec);
  if (SHIBYTE(__msg.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__msg.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_23:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
LABEL_27:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return;
    }
  }
  else if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_23;
  }
  operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_27;
  }
}

void sub_19E452F74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0)
  {
    operator delete(__p);
    if ((a23 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a17 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a23 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a18);
  if ((a17 & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(a12);
  _Unwind_Resume(exception_object);
}

void sub_19E452FE8()
{
}

uint64_t sub_19E452FF8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0B9A68;
  sub_19E418A38(*(char **)(a1 + 56));
  sub_19E3CD3E0(*(char **)(a1 + 32));
  return a1;
}

char *sub_19E453048@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  size_t v5 = *(char **)(a1 + 56);
  CFIndex result = (char *)(a1 + 56);
  int v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  unint64_t v6 = result;
  do
  {
    unsigned int v7 = *((_DWORD *)v4 + 8);
    BOOL v8 = v7 >= a2;
    if (v7 >= a2) {
      unint64_t v9 = (char **)v4;
    }
    else {
      unint64_t v9 = (char **)(v4 + 8);
    }
    if (v8) {
      unint64_t v6 = v4;
    }
    int v4 = *v9;
  }
  while (*v9);
  if (v6 != result && *((_DWORD *)v6 + 8) <= a2)
  {
    if (v6[63] < 0)
    {
      return (char *)sub_19E39369C((unsigned char *)a3, *((void **)v6 + 5), *((void *)v6 + 6));
    }
    else
    {
      long long v10 = *(_OWORD *)(v6 + 40);
      *(void *)(a3 + 16) = *((void *)v6 + 7);
      *(_OWORD *)a3 = v10;
    }
  }
  else
  {
LABEL_12:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  return result;
}

uint64_t sub_19E4530B8(uint64_t a1, const void **a2)
{
  unsigned int v3 = sub_19E374C3C(a1 + 24, a2);
  if ((uint64_t *)(a1 + 32) == v3) {
    return 0;
  }
  else {
    return *((unsigned int *)v3 + 14);
  }
}

void sub_19E4530F8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0B9A68;
  sub_19E418A38(*(char **)(a1 + 56));
  sub_19E3CD3E0(*(char **)(a1 + 32));
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E453168(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0B9A68;
  sub_19E418A38(*(char **)(a1 + 56));
  sub_19E3CD3E0(*(char **)(a1 + 32));
  return a1;
}

uint64_t sub_19E4531B8(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD **)(a1 + 128);
  if (v3 == *(_DWORD **)(a1 + 136)) {
    __assert_rtn("getPrediction", "NeuralModelPredictionEnumerator.cpp", 72, "false && \"getPrediction: called without predictions\"");
  }
  *a2 = *v3;
  if (a3)
  {
    *(int64x2_t *)a3 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    *(void *)(a3 + 16) = 0;
    *(_WORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 32) = 1;
    *(_DWORD *)(a3 + 56) = 0;
    *(_OWORD *)(a3 + 64) = xmmword_19E572FD0;
    *(void *)(a3 + 88) = 0;
    *(void *)(a3 + 96) = 0;
    *(void *)(a3 + 80) = 0xFFEFFFFFFFFFFFFFLL;
    uint64_t v4 = *(void *)(a1 + 128);
    *(_DWORD *)(a3 + 116) = 1;
    *(_OWORD *)(a3 + 40) = xmmword_19E573080;
    uint64_t v5 = *(void *)(v4 + 8);
    *(void *)(a3 + 40) = v5;
    *(void *)a3 = v5;
    *(void *)(a3 + 8) = v5;
  }
  return 1;
}

BOOL sub_19E45325C(uint64_t a1)
{
  uint64_t v393 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = *(void *)(a1 + 96);
  if (v1 != -1 && v1 >= *(void *)(a1 + 80)) {
    return 0;
  }
  uint64_t v2 = *(int **)(a1 + 128);
  v359 = (char **)(a1 + 128);
  unsigned int v3 = *(int **)(a1 + 136);
  uint64_t v4 = v2;
  if (v2 != v3)
  {
    uint64_t v5 = (char *)v3 - (char *)v2;
    if ((char *)v3 - (char *)v2 >= 17)
    {
      uint64_t v6 = 0;
      uint64_t v7 = v5 >> 4;
      int v8 = *v2;
      uint64_t v9 = *((void *)v2 + 1);
      int64_t v10 = (unint64_t)((v5 >> 4) - 2) >> 1;
      unint64_t v11 = *(int **)(a1 + 128);
      do
      {
        uint64_t v12 = v11;
        v11 += 4 * v6 + 4;
        uint64_t v13 = 2 * v6;
        uint64_t v6 = (2 * v6) | 1;
        uint64_t v14 = v13 + 2;
        if (v14 < v7 && *((double *)v11 + 1) < *((double *)v11 + 3))
        {
          v11 += 4;
          uint64_t v6 = v14;
        }
        *uint64_t v12 = *v11;
        *((void *)v12 + 1) = *((void *)v11 + 1);
      }
      while (v6 <= v10);
      if (v11 == v3 - 4)
      {
        int *v11 = v8;
        *((void *)v11 + 1) = v9;
      }
      else
      {
        int *v11 = *(v3 - 4);
        *((void *)v11 + 1) = *((void *)v3 - 1);
        *(v3 - 4) = v8;
        *((void *)v3 - 1) = v9;
        uint64_t v16 = (char *)v11 - (char *)v2 + 16;
        if (v16 >= 17)
        {
          unint64_t v17 = (((unint64_t)v16 >> 4) - 2) >> 1;
          double v18 = *(double *)&v2[4 * v17 + 2];
          double v19 = *((double *)v11 + 1);
          if (v18 < v19)
          {
            int v20 = *v11;
            do
            {
              unint64_t v21 = v17;
              uint64_t v22 = v11;
              unint64_t v11 = &v2[4 * v21];
              *uint64_t v22 = *v11;
              *((double *)v22 + 1) = v18;
              if (!v21) {
                break;
              }
              unint64_t v17 = (v21 - 1) >> 1;
              double v18 = *(double *)&v2[4 * v17 + 2];
            }
            while (v18 < v19);
            int *v11 = v20;
            *(double *)&v2[4 * v21 + 2] = v19;
          }
        }
      }
    }
    uint64_t v4 = v3 - 4;
    *(void *)(a1 + 136) = v3 - 4;
  }
  unint64_t v23 = v1 + 1;
  if (v1 + 1 < *(void *)(a1 + 80))
  {
    v364 = (void **)(a1 + 104);
    v360 = *(void **)(MEMORY[0x1E4FBA418] + 24);
    v361 = (void *)*MEMORY[0x1E4FBA418];
    uint64_t v24 = a1;
    while (1)
    {
      uint64_t v25 = v24;
      uint64_t v2 = *(int **)(v24 + 128);
      uint64_t v4 = *(int **)(v25 + 136);
      uint64_t v26 = *(void *)(v25 + 56);
      if (v2 != v4)
      {
        float v27 = *(float *)(v26 + 8 * v23 + 4);
        float v28 = log10f(v27);
        if (v27 <= 0.0) {
          float v28 = -10.0;
        }
        if (*((double *)v2 + 1) >= v28) {
          return v2 != v4;
        }
      }
      unint64_t v29 = v1 + 1;
      *(void *)(a1 + 96) = v1 + 1;
      v366 = 0;
      v367 = 0;
      v369 = 0;
      unint64_t v30 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 48))(*(void *)(a1 + 24));
      unint64_t v31 = v30;
      BOOL v32 = 0;
      if (v30)
      {
        if (v30 >> 62) {
          goto LABEL_445;
        }
        unint64_t v33 = (char *)operator new(4 * v30);
        BOOL v32 = &v33[4 * v31];
        v366 = (int *)v33;
        v367 = v33;
        v369 = v32;
      }
      unint64_t v34 = (_DWORD *)(v26 + 8 * v29);
      int v35 = v367;
      if (v367 >= v32)
      {
        size_t v37 = v366;
        uint64_t v38 = (v367 - (char *)v366) >> 2;
        unint64_t v39 = v38 + 1;
        if ((unint64_t)(v38 + 1) >> 62) {
          goto LABEL_445;
        }
        unint64_t v40 = v32 - (char *)v366;
        unint64_t v41 = (v32 - (char *)v366) >> 1;
        if (v41 > v39) {
          unint64_t v39 = v41;
        }
        if (v40 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v42 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v42 = v39;
        }
        if (v42)
        {
          if (v42 >> 62) {
            goto LABEL_446;
          }
          unint64_t v43 = operator new(4 * v42);
        }
        else
        {
          unint64_t v43 = 0;
        }
        size_t v44 = &v43[4 * v38];
        *size_t v44 = *v34;
        uint64_t v36 = (char *)(v44 + 1);
        if (v367 != (char *)v366)
        {
          unint64_t v45 = v367 - (char *)v366 - 4;
          if (v45 < 0x2C) {
            goto LABEL_458;
          }
          if ((unint64_t)((char *)v366 - v43) < 0x20) {
            goto LABEL_458;
          }
          uint64_t v46 = (v45 >> 2) + 1;
          int v47 = &v43[4 * v38 - 16];
          uint64_t v48 = v367 - 16;
          uint64_t v49 = v46 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v50 = *(_OWORD *)v48;
            *(v47 - 1) = *((_OWORD *)v48 - 1);
            *int v47 = v50;
            v47 -= 2;
            v48 -= 32;
            v49 -= 8;
          }
          while (v49);
          v44 -= v46 & 0x7FFFFFFFFFFFFFF8;
          int v35 = &v367[-4 * (v46 & 0x7FFFFFFFFFFFFFF8)];
          if (v46 != (v46 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_458:
            do
            {
              int v51 = *((_DWORD *)v35 - 1);
              v35 -= 4;
              *--size_t v44 = v51;
            }
            while (v35 != (char *)v366);
          }
        }
        v366 = v44;
        v369 = &v43[4 * v42];
        if (v37) {
          operator delete(v37);
        }
      }
      else
      {
        *(_DWORD *)v367 = *v34;
        uint64_t v36 = v367 + 4;
      }
      uint64_t v52 = a1;
      v368 = v36;
      if (v366 == (int *)v36)
      {
LABEL_444:
        int v356 = 130;
        v357 = "false && \"no tokens provided\"";
        goto LABEL_438;
      }
      float v53 = *(float *)(v26 + 8 * v29 + 4);
      float v54 = log10f(v53);
      if (v53 <= 0.0) {
        float v54 = -10.0;
      }
      double v55 = v54;
      while (1)
      {
        uint64_t v57 = *(void *)(v52 + 24);
        uint64_t v58 = *((unsigned int *)v36 - 1);
        if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v57 + 80))(v57, v58)) {
          goto LABEL_259;
        }
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v57 + 56))(v57, v58)) {
          break;
        }
        if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v57 + 64))(v57, v58) & 1) == 0
          && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v57 + 72))(v57, v58) & 1) == 0)
        {
          int v356 = 145;
          v357 = "mapper.isPrefixID(lastToken) || mapper.isStemID(lastToken)";
          goto LABEL_438;
        }
        uint64_t v60 = a1;
        unsigned int v61 = v366;
        unint64_t v62 = *(void *)(a1 + 104);
        unint64_t v63 = *(void *)(a1 + 112);
        uint64_t v64 = v63 - v62;
        if (v368 - (char *)v366 >= 1)
        {
          uint64_t v65 = (v368 - (char *)v366) >> 2;
          uint64_t v66 = v64 >> 2;
          double v67 = (unsigned char *)(v62 + (v64 & 0xFFFFFFFFFFFFFFFCLL));
          uint64_t v68 = *(void *)(a1 + 120);
          if (v65 > (uint64_t)(v68 - v63) >> 2)
          {
            unint64_t v69 = v66 + v65;
            if ((unint64_t)(v66 + v65) >> 62) {
              goto LABEL_445;
            }
            uint64_t v70 = v68 - v62;
            if (v70 >> 1 > v69) {
              unint64_t v69 = v70 >> 1;
            }
            if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v71 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v71 = v69;
            }
            unint64_t __src = v71;
            if (v71)
            {
              if (v71 >> 62) {
                goto LABEL_446;
              }
              uint64_t v72 = operator new(4 * v71);
            }
            else
            {
              uint64_t v72 = 0;
            }
            unint64_t v97 = &v72[4 * v66];
            unint64_t v98 = &v97[4 * v65];
            unint64_t v99 = (v65 - 1) & 0x3FFFFFFFFFFFFFFFLL;
            if (v99 >= 7)
            {
              uint64_t v100 = &v72[4 * v66];
              if ((unint64_t)(&v72[v64 & 0xFFFFFFFFFFFFFFFCLL] - (unsigned char *)v366) < 0x20) {
                goto LABEL_104;
              }
              unint64_t v101 = v99 + 1;
              uint64_t v102 = v101 & 0x7FFFFFFFFFFFFFF8;
              uint64_t v100 = &v97[v102 * 4];
              int v103 = (long long *)(v366 + 4);
              BOOL v104 = &v72[4 * v66 + 16];
              uint64_t v105 = v101 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                long long v106 = *v103;
                *(v104 - 1) = *(v103 - 1);
                *BOOL v104 = v106;
                v103 += 2;
                v104 += 2;
                v105 -= 8;
              }
              while (v105);
              if (v101 != (v101 & 0x7FFFFFFFFFFFFFF8))
              {
                unsigned int v61 = &v366[v102];
                goto LABEL_104;
              }
            }
            else
            {
              uint64_t v100 = &v72[4 * v66];
              do
              {
LABEL_104:
                int v107 = *v61++;
                *(_DWORD *)uint64_t v100 = v107;
                v100 += 4;
              }
              while (v100 != v98);
            }
            if (v62 != v63)
            {
              if ((unint64_t)(v64 - 4) < 0x3C)
              {
                double v108 = (char *)(v62 + (v64 & 0xFFFFFFFFFFFFFFFCLL));
                goto LABEL_112;
              }
              double v108 = (char *)(v62 + (v64 & 0xFFFFFFFFFFFFFFFCLL));
              if ((unint64_t)(v108 - &v72[v64 & 0xFFFFFFFFFFFFFFFCLL]) < 0x20) {
                goto LABEL_459;
              }
              unint64_t v109 = ((unint64_t)(v64 - 4) >> 2) + 1;
              double v108 = &v67[-4 * (v109 & 0x7FFFFFFFFFFFFFF8)];
              uint64_t v110 = (long long *)(v62 + 4 * v66 - 16);
              int64_t v111 = &v72[4 * v66 - 16];
              uint64_t v112 = v109 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                long long v113 = *v110;
                *(v111 - 1) = *(v110 - 1);
                *int64_t v111 = v113;
                v110 -= 2;
                v111 -= 2;
                v112 -= 8;
              }
              while (v112);
              v97 -= 4 * (v109 & 0x7FFFFFFFFFFFFFF8);
              if (v109 != (v109 & 0x7FFFFFFFFFFFFFF8))
              {
LABEL_459:
                do
                {
LABEL_112:
                  int v114 = *((_DWORD *)v108 - 1);
                  v108 -= 4;
                  *((_DWORD *)v97 - 1) = v114;
                  v97 -= 4;
                }
                while (v108 != (char *)v62);
              }
            }
            if ((unsigned char *)v63 != v67) {
              memmove(v98, (const void *)(v62 + (v64 & 0xFFFFFFFFFFFFFFFCLL)), v63 - (void)v67);
            }
            *(void *)(a1 + 104) = v97;
            *(void *)(a1 + 112) = &v98[v63 - (void)v67];
            uint64_t v60 = a1;
            *(void *)(a1 + 120) = &v72[4 * __src];
            if (v62) {
              operator delete((void *)v62);
            }
            goto LABEL_117;
          }
          uint64_t v73 = v63 - (void)v67;
          uint64_t v74 = (uint64_t)(v63 - (void)v67) >> 2;
          if (v74 >= v65)
          {
            BOOL v78 = &v366[v65];
            __n128 v77 = *(char **)(a1 + 112);
            goto LABEL_80;
          }
          double v75 = (char *)&v366[v74];
          double v76 = (char *)(v368 - v75);
          if (v368 != v75) {
            memmove((void *)v63, &v366[v74], v368 - v75);
          }
          __n128 v77 = &v76[v63];
          *(void *)(a1 + 112) = &v76[v63];
          if (v73 >= 1)
          {
            BOOL v78 = (int *)v75;
            double v67 = (unsigned char *)(v62 + (v64 & 0xFFFFFFFFFFFFFFFCLL));
LABEL_80:
            __n128 v79 = &v67[4 * v65];
            size_t v80 = v77 - v79;
            uint64_t v81 = (v77 - v79) >> 2;
            unint64_t v82 = &v77[-4 * v65];
            double v83 = v77;
            if ((unint64_t)v82 < v63)
            {
              unint64_t v84 = (v64 & 0xFFFFFFFFFFFFFFFCLL) + v80;
              int64_t v85 = (char *)(v84 + v62);
              unint64_t v86 = v84 + v62 + 4;
              if (v63 > v86) {
                unint64_t v86 = v63;
              }
              unint64_t v87 = v86 + ~v62 - v84;
              unint64_t v88 = v77 - v85;
              BOOL v89 = v87 >= 0x2C && v88 > 0x1F;
              double v83 = v77;
              if (!v89) {
                goto LABEL_460;
              }
              uint64_t v90 = (v87 >> 2) + 1;
              uint64_t v91 = 4 * (v90 & 0x7FFFFFFFFFFFFFF8);
              v82 += v91;
              unint64_t v92 = v77 + 16;
              double v93 = (long long *)(v62 + 4 * v81 + 4 * (v64 >> 2) + 16);
              uint64_t v94 = v90 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                long long v95 = *v93;
                *(v92 - 1) = *(v93 - 1);
                *unint64_t v92 = v95;
                v92 += 2;
                v93 += 2;
                v94 -= 8;
              }
              while (v94);
              double v83 = &v77[v91];
              if (v90 != (v90 & 0x7FFFFFFFFFFFFFF8))
              {
LABEL_460:
                do
                {
                  int v96 = *(_DWORD *)v82;
                  v82 += 4;
                  *(_DWORD *)double v83 = v96;
                  v83 += 4;
                }
                while ((unint64_t)v82 < v63);
              }
            }
            *(void *)(a1 + 112) = v83;
            if (v77 != v79) {
              memmove(&v77[-4 * v81], v67, v80);
            }
            size_t v59 = (char *)v78 - (char *)v366;
            if (v78 != v366) {
              memmove(v67, v366, v59);
            }
          }
        }
LABEL_117:
        uint64_t v115 = *(void *)(v60 + 24);
        uint64_t v116 = *(unsigned int *)(*(void *)(v60 + 112) - 4);
        if (((*(uint64_t (**)(uint64_t, uint64_t, size_t))(*(void *)v115 + 64))(v115, v116, v59) & 1) == 0
          && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v115 + 72))(v115, v116) & 1) == 0)
        {
          (*(uint64_t (**)(uint64_t))(*(void *)v115 + 16))(v115);
        }
        (*(void (**)(void **__return_ptr))(**(void **)(a1 + 8) + 40))(v370);
        int v117 = *(_DWORD *)v370[0];
        float v118 = *((float *)v370[0] + 1);
        uint64_t v119 = a1;
        uint64_t v121 = *(int **)(a1 + 112);
        unint64_t v120 = *(void *)(a1 + 120);
        uint64_t v122 = *(v121 - 1);
        if ((unint64_t)v121 >= v120)
        {
          uint64_t v124 = (int *)*v364;
          uint64_t v125 = (char *)v121 - (unsigned char *)*v364;
          uint64_t v126 = v125 >> 2;
          unint64_t v127 = (v125 >> 2) + 1;
          if (v127 >> 62) {
            sub_19E37C7C4();
          }
          uint64_t v128 = v120 - (void)v124;
          if (v128 >> 1 > v127) {
            unint64_t v127 = v128 >> 1;
          }
          if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v129 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v129 = v127;
          }
          if (v129)
          {
            if (v129 >> 62) {
              sub_19E37C2B8();
            }
            unint64_t v130 = operator new(4 * v129);
          }
          else
          {
            unint64_t v130 = 0;
          }
          unint64_t v131 = (int *)&v130[4 * v126];
          int *v131 = v117;
          uint64_t v123 = v131 + 1;
          if (v121 != v124)
          {
            unint64_t v132 = (char *)v121 - (char *)v124 - 4;
            if (v132 < 0x2C) {
              goto LABEL_461;
            }
            if ((unint64_t)((char *)v121 - v130 - v125) < 0x20) {
              goto LABEL_461;
            }
            uint64_t v133 = (v132 >> 2) + 1;
            unint64_t v134 = &v130[4 * v126 - 16];
            unint64_t v135 = v121 - 4;
            uint64_t v136 = v133 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v137 = *(_OWORD *)v135;
              *(v134 - 1) = *((_OWORD *)v135 - 1);
              _OWORD *v134 = v137;
              v134 -= 2;
              v135 -= 8;
              v136 -= 8;
            }
            while (v136);
            v131 -= v133 & 0x7FFFFFFFFFFFFFF8;
            v121 -= v133 & 0x7FFFFFFFFFFFFFF8;
            if (v133 != (v133 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_461:
              do
              {
                int v138 = *--v121;
                *--unint64_t v131 = v138;
              }
              while (v121 != v124);
            }
          }
          uint64_t v119 = a1;
          *(void *)(a1 + 104) = v131;
          *(void *)(a1 + 112) = v123;
          *(void *)(a1 + 120) = &v130[4 * v129];
          if (v124) {
            operator delete(v124);
          }
        }
        else
        {
          *uint64_t v121 = v117;
          uint64_t v123 = v121 + 1;
        }
        *(void *)(v119 + 112) = v123;
        if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(v119 + 24) + 64))(*(void *)(v119 + 24), v122))
        {
          uint64_t v24 = a1;
          goto LABEL_150;
        }
        uint64_t v24 = a1;
        (*(void (**)(void **__return_ptr))(**(void **)(a1 + 24) + 120))(&v373);
        unint64_t v140 = v373;
        unint64_t v139 = v374;
        if (v373)
        {
          v374 = v373;
          operator delete(v373);
        }
        if (v140 == v139)
        {
          uint64_t v141 = *(void *)(a1 + 112);
          *(void *)(a1 + 112) = v141 - 4;
          if (((*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24), *(unsigned int *)(v141 - 8)) & 1) == 0)__assert_rtn("predictValidStemFromPrefix", "NeuralModelPredictionEnumerator.cpp", 174, "m_tokenIDMapper->isPrefixID(context.back())"); {
          (*(void (**)(void **__return_ptr))(**(void **)(a1 + 8) + 40))(&v373);
          }
          __n128 v143 = *(unsigned char **)(a1 + 104);
          __n128 v142 = *(unsigned char **)(a1 + 112);
          unint64_t v386 = 0;
          v387 = 0;
          std::string __dst = 0;
          int64_t v144 = v142 - v143;
          if (v142 == v143)
          {
            __n128 v145 = 0;
          }
          else
          {
            if (v144 < 0) {
              sub_19E37C7C4();
            }
            __n128 v145 = (void **)operator new(v142 - v143);
            std::string __dst = v145;
            v387 = (char *)v145 + 4 * (v144 >> 2);
            memmove(v145, v143, v144);
            unint64_t v386 = (unint64_t)v145 + 4 * (v144 >> 2);
          }
          unint64_t v183 = (float *)v373;
          unint64_t v184 = (float *)v374;
          if (v373 == v374)
          {
            float v118 = 0.0;
            int v117 = 3;
            if (v145) {
              goto LABEL_251;
            }
          }
          else
          {
            int v117 = 3;
            float v118 = 0.0;
            do
            {
              unint64_t v185 = (void **)v386;
              if (v386 >= (unint64_t)v387)
              {
                unint64_t v187 = __dst;
                uint64_t v188 = (uint64_t)(v386 - (void)__dst) >> 2;
                unint64_t v189 = v188 + 1;
                if ((unint64_t)(v188 + 1) >> 62) {
                  sub_19E37C7C4();
                }
                uint64_t v190 = v387 - (unsigned char *)__dst;
                if ((v387 - (unsigned char *)__dst) >> 1 > v189) {
                  unint64_t v189 = v190 >> 1;
                }
                if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v191 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v191 = v189;
                }
                if (v191)
                {
                  if (v191 >> 62) {
                    sub_19E37C2B8();
                  }
                  uint64_t v192 = operator new(4 * v191);
                }
                else
                {
                  uint64_t v192 = 0;
                }
                uint64_t v193 = &v192[4 * v188];
                _DWORD *v193 = *(_DWORD *)v183;
                unint64_t v186 = v193 + 1;
                if (v185 != v187)
                {
                  unint64_t v194 = (char *)v185 - 4 - (char *)v187;
                  if (v194 < 0x2C) {
                    goto LABEL_462;
                  }
                  if ((unint64_t)((char *)v187 - v192) < 0x20) {
                    goto LABEL_462;
                  }
                  uint64_t v195 = (v194 >> 2) + 1;
                  int8x8_t v196 = &v192[4 * v188 - 16];
                  uint64_t v197 = v185 - 2;
                  uint64_t v198 = v195 & 0x7FFFFFFFFFFFFFF8;
                  do
                  {
                    long long v199 = *(_OWORD *)v197;
                    *(v196 - 1) = *((_OWORD *)v197 - 1);
                    _OWORD *v196 = v199;
                    v196 -= 2;
                    v197 -= 4;
                    v198 -= 8;
                  }
                  while (v198);
                  v193 -= v195 & 0x7FFFFFFFFFFFFFF8;
                  unint64_t v185 = (void **)((char *)v185 - 4 * (v195 & 0x7FFFFFFFFFFFFFF8));
                  if (v195 != (v195 & 0x7FFFFFFFFFFFFFF8))
                  {
LABEL_462:
                    do
                    {
                      int v200 = *((_DWORD *)v185 - 1);
                      unint64_t v185 = (void **)((char *)v185 - 4);
                      *--uint64_t v193 = v200;
                    }
                    while (v185 != v187);
                  }
                }
                std::string __dst = (void **)v193;
                unint64_t v386 = (unint64_t)v186;
                v387 = &v192[4 * v191];
                if (v187) {
                  operator delete(v187);
                }
                uint64_t v24 = a1;
              }
              else
              {
                *(float *)unint64_t v386 = *v183;
                unint64_t v186 = (_DWORD *)v185 + 1;
              }
              unint64_t v386 = (unint64_t)v186;
              (*(void (**)(long long *__return_ptr))(**(void **)(v24 + 24) + 120))(&v371);
              if ((void)v371 != *((void *)&v371 + 1))
              {
                int v117 = *(_DWORD *)v183;
                float v118 = v183[1];
              }
              v386 -= 4;
              if ((void)v371)
              {
                *((void *)&v371 + 1) = v371;
                operator delete((void *)v371);
              }
              v183 += 2;
            }
            while (v183 != v184);
            __n128 v145 = __dst;
            if (__dst)
            {
LABEL_251:
              unint64_t v386 = (unint64_t)v145;
              operator delete(v145);
            }
          }
          if (v373)
          {
            v374 = v373;
            operator delete(v373);
          }
        }
LABEL_150:
        if (v117 != 3) {
          goto LABEL_194;
        }
        if (qword_1E9459FE8 != -1) {
          dispatch_once(&qword_1E9459FE8, &unk_1EF0BEC60);
        }
        __n128 v146 = qword_1E9459FE0;
        if (!os_log_type_enabled((os_log_t)qword_1E9459FE0, OS_LOG_TYPE_ERROR)) {
          goto LABEL_194;
        }
        sub_19E37B784((uint64_t)&v373);
        uint64_t v147 = v24;
        uint64_t v148 = *(void *)(v24 + 104);
        uint64_t v149 = *(void *)(v147 + 112);
        if (v148 != v149)
        {
          while (1)
          {
            if ((v383 & 0x10) != 0)
            {
              __n128 v152 = v382;
              __n128 v153 = (const void **)&v378;
              if (v382 < v379)
              {
                v382 = v379;
                __n128 v152 = v379;
                __n128 v153 = (const void **)&v378;
              }
            }
            else
            {
              if ((v383 & 8) == 0)
              {
                size_t v150 = 0;
                HIBYTE(v387) = 0;
                p_dst = (void **)&__dst;
                goto LABEL_169;
              }
              __n128 v152 = v377;
              __n128 v153 = (const void **)v376;
            }
            __n128 v154 = *v153;
            size_t v150 = v152 - (unsigned char *)*v153;
            if (v150 > 0x7FFFFFFFFFFFFFF7) {
              sub_19E37C958();
            }
            if (v150 >= 0x17) {
              break;
            }
            HIBYTE(v387) = (_BYTE)v152 - *(unsigned char *)v153;
            p_dst = (void **)&__dst;
            if (v150) {
              goto LABEL_168;
            }
LABEL_169:
            *((unsigned char *)p_dst + v150) = 0;
            if ((SHIBYTE(v387) & 0x80000000) == 0)
            {
              if (!HIBYTE(v387)) {
                goto LABEL_174;
              }
LABEL_173:
              sub_19E37CA70(&v373, (uint64_t)" ", 1);
              goto LABEL_174;
            }
            unint64_t v157 = v386;
            operator delete(__dst);
            if (v157) {
              goto LABEL_173;
            }
LABEL_174:
            std::ostream::operator<<();
            v148 += 4;
            if (v148 == v149) {
              goto LABEL_175;
            }
          }
          uint64_t v155 = (v150 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v150 | 7) != 0x17) {
            uint64_t v155 = v150 | 7;
          }
          uint64_t v156 = v155 + 1;
          p_dst = (void **)operator new(v155 + 1);
          unint64_t v386 = v150;
          v387 = (unsigned char *)(v156 | 0x8000000000000000);
          std::string __dst = p_dst;
LABEL_168:
          memmove(p_dst, v154, v150);
          goto LABEL_169;
        }
LABEL_175:
        if ((v383 & 0x10) != 0)
        {
          __n128 v158 = v382;
          __n128 v159 = (const void **)&v378;
          uint64_t v24 = a1;
          if (v382 < v379)
          {
            v382 = v379;
            __n128 v158 = v379;
            __n128 v159 = (const void **)&v378;
          }
        }
        else
        {
          uint64_t v24 = a1;
          if ((v383 & 8) == 0)
          {
            size_t v161 = 0;
            HIBYTE(v372) = 0;
            __n128 v162 = &v371;
            goto LABEL_188;
          }
          __n128 v158 = v377;
          __n128 v159 = (const void **)v376;
        }
        __n128 v160 = *v159;
        size_t v161 = v158 - (unsigned char *)*v159;
        if (v161 > 0x7FFFFFFFFFFFFFF7) {
          sub_19E37C958();
        }
        if (v161 >= 0x17)
        {
          uint64_t v163 = (v161 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v161 | 7) != 0x17) {
            uint64_t v163 = v161 | 7;
          }
          uint64_t v164 = v163 + 1;
          __n128 v162 = (long long *)operator new(v163 + 1);
          *((void *)&v371 + 1) = v161;
          int64_t v372 = v164 | 0x8000000000000000;
          *(void *)&long long v371 = v162;
        }
        else
        {
          HIBYTE(v372) = (_BYTE)v158 - *(unsigned char *)v159;
          __n128 v162 = &v371;
          if (!v161) {
            goto LABEL_188;
          }
        }
        memmove(v162, v160, v161);
LABEL_188:
        *((unsigned char *)v162 + v161) = 0;
        v373 = v361;
        *(void **)((char *)&v373 + *((void *)v361 - 3)) = v360;
        v374 = (void *)(MEMORY[0x1E4FBA470] + 16);
        if (v381 < 0) {
          operator delete(__p);
        }
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        MEMORY[0x19F3BDC30](&v384);
        __n128 v165 = &v371;
        if (v372 < 0) {
          __n128 v165 = (long long *)v371;
        }
        *(_DWORD *)int buf = 136315138;
        v392 = v165;
        _os_log_error_impl(&dword_19E36B000, v146, OS_LOG_TYPE_ERROR, "Could not find a valid prediction for context: [%s]", buf, 0xCu);
        if (SHIBYTE(v372) < 0) {
          operator delete((void *)v371);
        }
LABEL_194:
        uint64_t v166 = *(void *)(v24 + 112);
        unint64_t v167 = v166 - *(void *)(v24 + 104);
        if (v167 > v64)
        {
          do
          {
            v166 -= 4;
            v167 -= 4;
          }
          while (v167 > v64);
          *(void *)(v24 + 112) = v166;
        }
        if (v370[0])
        {
          v370[1] = v370[0];
          operator delete(v370[0]);
        }
        if (v117 == 3) {
          goto LABEL_280;
        }
        __n128 v168 = v368;
        if (v368 < v369)
        {
          *(_DWORD *)v368 = v117;
          uint64_t v36 = v368 + 4;
        }
        else
        {
          __n128 v169 = v366;
          uint64_t v170 = (v368 - (char *)v366) >> 2;
          unint64_t v171 = v170 + 1;
          if ((unint64_t)(v170 + 1) >> 62) {
LABEL_445:
          }
            sub_19E37C7C4();
          uint64_t v172 = v369 - (char *)v366;
          if ((v369 - (char *)v366) >> 1 > v171) {
            unint64_t v171 = v172 >> 1;
          }
          if ((unint64_t)v172 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v173 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v173 = v171;
          }
          if (v173)
          {
            if (v173 >> 62) {
LABEL_446:
            }
              sub_19E37C2B8();
            unint64_t v174 = operator new(4 * v173);
          }
          else
          {
            unint64_t v174 = 0;
          }
          unint64_t v175 = (int *)&v174[4 * v170];
          *unint64_t v175 = v117;
          uint64_t v36 = (char *)(v175 + 1);
          if (v368 != (char *)v366)
          {
            unint64_t v176 = v368 - 4 - (char *)v366;
            if (v176 < 0x2C) {
              goto LABEL_463;
            }
            if ((unint64_t)((char *)v366 - v174) < 0x20) {
              goto LABEL_463;
            }
            uint64_t v177 = (v176 >> 2) + 1;
            unint64_t v178 = &v174[4 * v170 - 16];
            unint64_t v179 = v368 - 16;
            uint64_t v180 = v177 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v181 = *(_OWORD *)v179;
              *(v178 - 1) = *((_OWORD *)v179 - 1);
              _OWORD *v178 = v181;
              v178 -= 2;
              v179 -= 32;
              v180 -= 8;
            }
            while (v180);
            v175 -= v177 & 0x7FFFFFFFFFFFFFF8;
            __n128 v168 = &v368[-4 * (v177 & 0x7FFFFFFFFFFFFFF8)];
            if (v177 != (v177 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_463:
              do
              {
                int v182 = *((_DWORD *)v168 - 1);
                v168 -= 4;
                *--unint64_t v175 = v182;
              }
              while (v168 != (char *)v366);
            }
          }
          v366 = v175;
          v369 = &v174[4 * v173];
          if (v169) {
            operator delete(v169);
          }
        }
        uint64_t v52 = a1;
        v368 = v36;
        float v56 = log10f(v118);
        if (v118 <= 0.0) {
          float v56 = -10.0;
        }
        double v55 = v55 + v56;
        if (v366 == (int *)v36) {
          goto LABEL_444;
        }
      }
      if (v368 - (char *)v366 != 4)
      {
        int v356 = 141;
        v357 = "false && \"unexpected non-combining ID\"";
LABEL_438:
        __assert_rtn("wordIsComplete", "NeuralModelPredictionEnumerator.cpp", v356, v357);
      }
LABEL_259:
      uint64_t v24 = a1;
      uint64_t v201 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 24))(*(void *)(a1 + 24));
      uint64_t v202 = v201;
      LODWORD(v371) = v201;
      *((double *)&v371 + 1) = v55;
      unint64_t v203 = *(void **)(a1 + 40);
      if (!v203) {
        goto LABEL_279;
      }
      unint64_t v204 = v203[14];
      if (!v204) {
        goto LABEL_279;
      }
      uint64_t v205 = (_DWORD *)v203[15];
      uint64_t v206 = &v205[v204];
      do
      {
        unint64_t v207 = v204 >> 1;
        unint64_t v208 = &v205[v204 >> 1];
        unsigned int v210 = *v208;
        v209 = v208 + 1;
        v204 += ~(v204 >> 1);
        if (v210 < v201) {
          uint64_t v205 = v209;
        }
        else {
          unint64_t v204 = v207;
        }
      }
      while (v204);
      if (v205 == v206 || *v205 != v201)
      {
LABEL_279:
        sub_19E4552A8(v359, &v371);
        goto LABEL_280;
      }
      unint64_t v211 = *(void *)(a1 + 88);
      v373 = 0;
      v374 = &v373;
      uint64_t v375 = 0x4002000000;
      v376[0] = sub_19E530930;
      v376[1] = sub_19E530954;
      v378 = 0;
      v379 = 0;
      v377 = 0;
      if (!v211) {
        goto LABEL_427;
      }
      v212 = (uint64_t *)v203[10];
      long long v213 = (uint64_t *)v203[11];
      if (v212 != v213)
      {
        uint64_t v214 = (void **)MEMORY[0x1E4F143A8];
        do
        {
          uint64_t v215 = *v212;
          uint64_t v216 = 68;
          switch((int)v202)
          {
            case 123:
              uint64_t v216 = 69;
              break;
            case 124:
            case 125:
              goto LABEL_274;
            case 126:
              break;
            case 127:
            case 128:
              uint64_t v216 = v202;
              break;
            default:
              uint64_t v216 = v202;
              if (v202 != 72) {
LABEL_274:
              }
                uint64_t v216 = 0;
              break;
          }
          std::string __dst = v214;
          unint64_t v386 = 0x40000000;
          v387 = sub_19E53096C;
          v388 = &unk_1E59A1F28;
          v389 = &v373;
          v390 = v203;
          (*(void (**)(uint64_t, uint64_t, void ***))(*(void *)v215 + 104))(v215, v216, &__dst);
          ++v212;
        }
        while (v212 != v213);
      }
      unint64_t v358 = v211;
      unint64_t v217 = v203[3];
      uint64_t v24 = a1;
      if (v217)
      {
        uint64_t v218 = 0;
        for (unsigned int i = 0; i < v217; v218 = ++i)
        {
          v221 = (_DWORD *)(v203[2] + 16 * v218);
          if (v221[1] == v202)
          {
            uint64_t v222 = v374;
            uint64_t v223 = v221 + 2;
            double v225 = (char *)v374[6];
            unint64_t v224 = v374[7];
            if ((unint64_t)v225 < v224)
            {
              *(_DWORD *)double v225 = *v221;
              *((void *)v225 + 1) = *v223;
              uint64_t v220 = v225 + 16;
            }
            else
            {
              double v226 = (unsigned char *)v374[5];
              uint64_t v227 = (v225 - v226) >> 4;
              unint64_t v228 = v227 + 1;
              if ((unint64_t)(v227 + 1) >> 60) {
                sub_19E37C7C4();
              }
              __srca = (void *)v217;
              uint64_t v229 = v224 - (void)v226;
              if (v229 >> 3 > v228) {
                unint64_t v228 = v229 >> 3;
              }
              if ((unint64_t)v229 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v230 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v230 = v228;
              }
              if (v230 >> 60) {
                sub_19E37C2B8();
              }
              uint64_t v231 = (char *)operator new(16 * v230);
              uint64_t v232 = &v231[16 * v227];
              *(_DWORD *)uint64_t v232 = *v221;
              *((void *)v232 + 1) = *v223;
              if (v225 == v226)
              {
                v234 = &v231[16 * v227];
                uint64_t v24 = a1;
              }
              else
              {
                uint64_t v233 = &v231[16 * v227];
                uint64_t v24 = a1;
                do
                {
                  v234 = v233 - 16;
                  *((_OWORD *)v233 - 1) = *((_OWORD *)v225 - 1);
                  v225 -= 16;
                  v233 -= 16;
                }
                while (v225 != v226);
              }
              uint64_t v220 = v232 + 16;
              v222[5] = v234;
              v222[6] = v232 + 16;
              v222[7] = &v231[16 * v230];
              if (v226)
              {
                operator delete(v226);
                unint64_t v217 = v203[3];
              }
              else
              {
                unint64_t v217 = (unint64_t)__srca;
              }
            }
            v222[6] = v220;
          }
        }
      }
      v235 = v374;
      v237 = (int *)v374[5];
      unint64_t v236 = v374[6];
      if (v237 == (int *)v236)
      {
LABEL_427:
        v351 = 0;
        v353 = 0;
        goto LABEL_428;
      }
      unint64_t v238 = (uint64_t)(v236 - (void)v237) >> 4;
      if (v238 >= v358) {
        unint64_t v239 = v358;
      }
      else {
        unint64_t v239 = (uint64_t)(v236 - (void)v237) >> 4;
      }
      unint64_t v240 = (unint64_t)&v237[4 * v239];
      if (v240 == v236) {
        goto LABEL_411;
      }
      while (2)
      {
        unint64_t v241 = (uint64_t)(v236 - (void)v237) >> 4;
        if (v241 >= 2)
        {
          if (v241 == 3)
          {
            double v301 = *((double *)v237 + 3);
            float v302 = v301;
            double v303 = *((double *)v237 + 1);
            float v304 = v303;
            double v305 = *(double *)(v236 - 8);
            float v306 = v305;
            if (v302 <= v304)
            {
              if (v306 > v302)
              {
                int v320 = v237[4];
                v237[4] = *(_DWORD *)(v236 - 16);
                *(_DWORD *)(v236 - 16) = v320;
                *((double *)v237 + 3) = v305;
                *(double *)(v236 - 8) = v301;
                double v321 = *((double *)v237 + 3);
                float v322 = v321;
                double v323 = *((double *)v237 + 1);
                float v324 = v323;
                if (v322 > v324)
                {
                  int v325 = *v237;
                  int *v237 = v237[4];
                  v237[4] = v325;
                  *((double *)v237 + 1) = v321;
                  *((double *)v237 + 3) = v323;
                }
              }
            }
            else
            {
              int v307 = *v237;
              if (v306 <= v302)
              {
                int *v237 = v237[4];
                v237[4] = v307;
                *((double *)v237 + 1) = v301;
                *((double *)v237 + 3) = v303;
                double v326 = *(double *)(v236 - 8);
                float v327 = v326;
                if (v327 <= v304) {
                  break;
                }
                v237[4] = *(_DWORD *)(v236 - 16);
                *(_DWORD *)(v236 - 16) = v307;
                *((double *)v237 + 3) = v326;
              }
              else
              {
                int *v237 = *(_DWORD *)(v236 - 16);
                *(_DWORD *)(v236 - 16) = v307;
                *((double *)v237 + 1) = v305;
              }
              *(double *)(v236 - 8) = v303;
            }
            break;
          }
          if (v241 == 2)
          {
            double v308 = *(double *)(v236 - 8);
            float v309 = v308;
            double v310 = *((double *)v237 + 1);
            float v311 = v310;
            if (v309 > v311)
            {
              int v312 = *v237;
              int *v237 = *(_DWORD *)(v236 - 16);
              *(_DWORD *)(v236 - 16) = v312;
              *((double *)v237 + 1) = v308;
              *(double *)(v236 - 8) = v310;
            }
            break;
          }
          if ((uint64_t)(v236 - (void)v237) <= 127)
          {
            while (v237 != (int *)(v236 - 16))
            {
              v313 = v237;
              v237 += 4;
              if (v313 != (int *)v236 && v237 != (int *)v236)
              {
                v314 = (double *)v237;
                long long v315 = v313;
                do
                {
                  float v316 = v314[1];
                  float v317 = *((double *)v315 + 1);
                  if (v316 > v317) {
                    long long v315 = (int *)v314;
                  }
                  v314 += 2;
                }
                while (v314 != (double *)v236);
                if (v315 != v313)
                {
                  int v318 = *v313;
                  int *v313 = *v315;
                  *long long v315 = v318;
                  uint64_t v319 = *((void *)v313 + 1);
                  *((void *)v313 + 1) = *((void *)v315 + 1);
                  *((void *)v315 + 1) = v319;
                }
              }
            }
            break;
          }
          unint64_t v242 = (unint64_t)&v237[4 * (v241 >> 1)];
          uint64_t v243 = (double *)(v242 + 8);
          double v244 = *(double *)(v242 + 8);
          float v245 = v244;
          double v246 = *((double *)v237 + 1);
          float v247 = v246;
          double v248 = *(double *)(v236 - 8);
          float v249 = v248;
          if (v245 <= v247)
          {
            if (v249 <= v245)
            {
              int v259 = 0;
              goto LABEL_322;
            }
            int v251 = *(_DWORD *)v242;
            *(_DWORD *)unint64_t v242 = *(_DWORD *)(v236 - 16);
            *(_DWORD *)(v236 - 16) = v251;
            double *v243 = v248;
            *(double *)(v236 - 8) = v244;
            double v252 = *v243;
            float v253 = *v243;
            double v254 = *((double *)v237 + 1);
            float v255 = v254;
            if (v253 > v255)
            {
              int v256 = *v237;
              int *v237 = *(_DWORD *)v242;
              *(_DWORD *)unint64_t v242 = v256;
              *((double *)v237 + 1) = v252;
              double *v243 = v254;
              goto LABEL_319;
            }
          }
          else
          {
            int v250 = *v237;
            if (v249 > v245)
            {
              int *v237 = *(_DWORD *)(v236 - 16);
              *(_DWORD *)(v236 - 16) = v250;
              *((double *)v237 + 1) = v248;
              *(double *)(v236 - 8) = v246;
              goto LABEL_320;
            }
            int *v237 = *(_DWORD *)v242;
            *(_DWORD *)unint64_t v242 = v250;
            *((double *)v237 + 1) = v244;
            double *v243 = v246;
            double v257 = *(double *)(v236 - 8);
            float v258 = v257;
            if (v258 > v247)
            {
              *(_DWORD *)unint64_t v242 = *(_DWORD *)(v236 - 16);
              *(_DWORD *)(v236 - 16) = v250;
              double *v243 = v257;
              *(double *)(v236 - 8) = v246;
LABEL_319:
              int v259 = 2;
LABEL_322:
              unint64_t v260 = v236 - 16;
              double v261 = *((double *)v237 + 1);
              float v262 = v261;
              float v263 = *v243;
              if (v262 <= v263)
              {
                unint64_t v265 = v236 - 16;
                while (1)
                {
                  unint64_t v264 = v265 - 16;
                  if ((int *)(v265 - 16) == v237) {
                    break;
                  }
                  double v266 = *(double *)(v265 - 8);
                  float v267 = v266;
                  v265 -= 16;
                  if (v267 > v263)
                  {
                    int v268 = *v237;
                    int *v237 = *(_DWORD *)v264;
                    *(_DWORD *)unint64_t v264 = v268;
                    *((double *)v237 + 1) = v266;
                    *(double *)(v264 + 8) = v261;
                    ++v259;
                    goto LABEL_328;
                  }
                }
                v286 = (double *)(v237 + 4);
                double v287 = *(double *)(v236 - 8);
                float v288 = v287;
                if (v262 <= v288)
                {
                  if (v286 == (double *)v260) {
                    break;
                  }
                  while (1)
                  {
                    double v289 = v286[1];
                    float v290 = v289;
                    if (v262 > v290) {
                      break;
                    }
                    v286 += 2;
                    if (v286 == (double *)v260) {
                      goto LABEL_392;
                    }
                  }
                  int v294 = *(_DWORD *)v286;
                  *(_DWORD *)v286 = *(_DWORD *)(v236 - 16);
                  *(_DWORD *)(v236 - 16) = v294;
                  v286[1] = v287;
                  *(double *)(v236 - 8) = v289;
                  v286 += 2;
                }
                if (v286 == (double *)v260) {
                  break;
                }
                while (1)
                {
                  float v296 = *((double *)v237 + 1);
                  do
                  {
                    unint64_t v283 = (unint64_t)v286;
                    double v297 = v286[1];
                    float v298 = v297;
                    v286 += 2;
                  }
                  while (v296 <= v298);
                  do
                  {
                    double v299 = *(double *)(v260 - 8);
                    v260 -= 16;
                    float v300 = v299;
                  }
                  while (v296 > v300);
                  if (v283 >= v260) {
                    break;
                  }
                  int v295 = *(_DWORD *)v283;
                  *(_DWORD *)unint64_t v283 = *(_DWORD *)v260;
                  *(_DWORD *)unint64_t v260 = v295;
                  *(double *)(v283 + 8) = v299;
                  *(double *)(v260 + 8) = v297;
                }
                if (v283 > v240) {
                  break;
                }
              }
              else
              {
                unint64_t v264 = v236 - 16;
LABEL_328:
                double v269 = v237 + 4;
                if ((unint64_t)(v237 + 4) >= v264)
                {
                  unint64_t v272 = (unint64_t)(v237 + 4);
                }
                else
                {
                  unint64_t v270 = (unint64_t)(v237 + 4);
                  while (1)
                  {
                    float v271 = *(double *)(v242 + 8);
                    do
                    {
                      unint64_t v272 = v270;
                      double v273 = *(double *)(v270 + 8);
                      float v274 = v273;
                      v270 += 16;
                    }
                    while (v274 > v271);
                    do
                    {
                      double v275 = *(double *)(v264 - 8);
                      v264 -= 16;
                      float v276 = v275;
                    }
                    while (v276 <= v271);
                    if (v272 >= v264) {
                      break;
                    }
                    int v277 = *(_DWORD *)v272;
                    *(_DWORD *)unint64_t v272 = *(_DWORD *)v264;
                    *(_DWORD *)unint64_t v264 = v277;
                    *(double *)(v272 + 8) = v275;
                    *(double *)(v264 + 8) = v273;
                    ++v259;
                    if (v242 == v272) {
                      unint64_t v242 = v264;
                    }
                  }
                }
                if (v272 != v242)
                {
                  double v278 = *(double *)(v242 + 8);
                  float v279 = v278;
                  double v280 = *(double *)(v272 + 8);
                  float v281 = v280;
                  if (v279 > v281)
                  {
                    int v282 = *(_DWORD *)v272;
                    *(_DWORD *)unint64_t v272 = *(_DWORD *)v242;
                    *(_DWORD *)unint64_t v242 = v282;
                    *(double *)(v272 + 8) = v278;
                    *(double *)(v242 + 8) = v280;
                    ++v259;
                  }
                }
                if (v272 == v240) {
                  break;
                }
                if (!v259)
                {
                  if (v272 <= v240)
                  {
                    unint64_t v291 = v272 + 16;
                    while (v291 != v236)
                    {
                      float v292 = *(double *)(v291 + 8);
                      float v293 = *(double *)(v291 - 8);
                      v291 += 16;
                      if (v292 > v293) {
                        goto LABEL_343;
                      }
                    }
                  }
                  else
                  {
                    while (v269 != (int *)v272)
                    {
                      float v284 = *((double *)v269 + 1);
                      float v285 = *((double *)v269 - 1);
                      v269 += 4;
                      if (v284 > v285) {
                        goto LABEL_343;
                      }
                    }
                  }
                  break;
                }
LABEL_343:
                if (v272 <= v240)
                {
                  unint64_t v283 = v272 + 16;
                }
                else
                {
                  unint64_t v236 = v272;
                  unint64_t v283 = (unint64_t)v237;
                }
              }
              v237 = (int *)v283;
              if (v236 == v240) {
                break;
              }
              continue;
            }
          }
LABEL_320:
          int v259 = 1;
          goto LABEL_322;
        }
        break;
      }
LABEL_392:
      v235 = v374;
      v237 = (int *)v374[5];
      uint64_t v328 = v374[6];
      unint64_t v238 = (v328 - (uint64_t)v237) >> 4;
      unint64_t v329 = v239 - v238;
      if (v239 <= v238)
      {
        uint64_t v24 = a1;
LABEL_411:
        if (v238 > v239) {
          v235[6] = &v237[4 * v239];
        }
        goto LABEL_424;
      }
      uint64_t v330 = v374[7];
      if (v329 <= (v330 - v328) >> 4)
      {
        uint64_t v343 = v328 + 16 * v329;
        if (((v329 - 1) & 0xFFFFFFFFFFFFFFFLL) != 0)
        {
          uint64_t v344 = ((v329 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
          uint64_t v345 = v328 + 16;
          uint64_t v346 = v344 & 0x1FFFFFFFFFFFFFFELL;
          do
          {
            *(_DWORD *)(v345 - 16) = 0;
            *(_DWORD *)uint64_t v345 = 0;
            *(void *)(v345 - 8) = 0;
            *(void *)(v345 + 8) = 0;
            v345 += 32;
            v346 -= 2;
          }
          while (v346);
          if (v344 != (v344 & 0x1FFFFFFFFFFFFFFELL))
          {
            v328 += 16 * (v344 & 0x1FFFFFFFFFFFFFFELL);
            goto LABEL_418;
          }
        }
        else
        {
          do
          {
LABEL_418:
            *(_DWORD *)uint64_t v328 = 0;
            *(void *)(v328 + 8) = 0;
            v328 += 16;
          }
          while (v328 != v343);
        }
        v235[6] = v343;
        goto LABEL_423;
      }
      if (v239 >> 60) {
        sub_19E37C7C4();
      }
      uint64_t v331 = v330 - (void)v237;
      uint64_t v332 = v331 >> 3;
      if (v331 >> 3 <= v239) {
        uint64_t v332 = v239;
      }
      if ((unint64_t)v331 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v333 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v333 = v332;
      }
      if (v333 >> 60) {
        sub_19E37C2B8();
      }
      v334 = (char *)operator new(16 * v333);
      v335 = &v334[16 * v238];
      v336 = &v334[16 * v239];
      v337 = v335;
      uint64_t v338 = (v329 - 1) & 0xFFFFFFFFFFFFFFFLL;
      if (v338)
      {
        uint64_t v339 = (v338 + 1) & 0x1FFFFFFFFFFFFFFELL;
        v340 = v335 + 16;
        uint64_t v341 = v339;
        do
        {
          *((_DWORD *)v340 - 4) = 0;
          *(_DWORD *)v340 = 0;
          *((void *)v340 - 1) = 0;
          *((void *)v340 + 1) = 0;
          v340 += 32;
          v341 -= 2;
        }
        while (v341);
        if (v338 + 1 != v339)
        {
          v337 = &v335[16 * v339];
          goto LABEL_406;
        }
      }
      else
      {
        do
        {
LABEL_406:
          *(_DWORD *)v337 = 0;
          *((void *)v337 + 1) = 0;
          v337 += 16;
        }
        while (v337 != v336);
      }
      if ((int *)v328 == v237)
      {
        v342 = &v334[16 * v238];
      }
      else
      {
        do
        {
          v342 = v335 - 16;
          *((_OWORD *)v335 - 1) = *(_OWORD *)(v328 - 16);
          v328 -= 16;
          v335 -= 16;
        }
        while ((int *)v328 != v237);
      }
      v347 = (void *)v235[5];
      v235[5] = v342;
      v235[6] = v336;
      v235[7] = &v334[16 * v333];
      if (v347) {
        operator delete(v347);
      }
LABEL_423:
      v235 = v374;
      uint64_t v24 = a1;
LABEL_424:
      v349 = (unsigned char *)v235[5];
      v348 = (unsigned char *)v235[6];
      int64_t v350 = v348 - v349;
      if (v348 == v349) {
        goto LABEL_427;
      }
      if (v350 < 0) {
        sub_19E37C7C4();
      }
      v351 = (char *)operator new(v348 - v349);
      size_t v352 = v350 & 0xFFFFFFFFFFFFFFF0;
      memcpy(v351, v349, v352);
      v353 = &v351[v352];
LABEL_428:
      _Block_object_dispose(&v373, 8);
      if (v377)
      {
        v378 = v377;
        operator delete(v377);
      }
      if (v351 != v353)
      {
        v354 = v351;
        do
        {
          sub_19E4552A8(v359, v354);
          v354 += 16;
        }
        while (v354 != v353);
      }
      if (v351) {
        operator delete(v351);
      }
LABEL_280:
      if (v366) {
        operator delete(v366);
      }
      unint64_t v1 = *(void *)(v24 + 96);
      unint64_t v23 = v1 + 1;
      if (v1 + 1 >= *(void *)(v24 + 80))
      {
        uint64_t v355 = v24;
        uint64_t v2 = *(int **)(v24 + 128);
        uint64_t v4 = *(int **)(v355 + 136);
        return v2 != v4;
      }
    }
  }
  return v2 != v4;
}

void sub_19E455164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38)
{
  if (__p)
  {
    a38 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a23) {
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

void sub_19E4552A8(char **a1, _OWORD *a2)
{
  uint64_t v5 = (double *)a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (double *)*a1;
    uint64_t v8 = ((char *)v5 - *a1) >> 4;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 60) {
      sub_19E37C7C4();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 3 > v9) {
      unint64_t v9 = v10 >> 3;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 60) {
        sub_19E37C2B8();
      }
      uint64_t v12 = (char *)operator new(16 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v13 = &v12[16 * v8];
    *(_OWORD *)uint64_t v13 = *a2;
    uint64_t v6 = (double *)(v13 + 16);
    if (v5 != v7)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
        v13 -= 16;
        v5 -= 2;
      }
      while (v5 != v7);
      uint64_t v5 = (double *)*a1;
    }
    *a1 = v13;
    a1[1] = (char *)v6;
    a1[2] = &v12[16 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v5 = *a2;
    uint64_t v6 = v5 + 2;
  }
  a1[1] = (char *)v6;
  uint64_t v14 = (double *)*a1;
  uint64_t v15 = (char *)v6 - *a1;
  if (v15 >= 17)
  {
    unint64_t v16 = (((unint64_t)v15 >> 4) - 2) >> 1;
    double v17 = v14[2 * v16 + 1];
    double v18 = *(v6 - 1);
    if (v17 < v18)
    {
      int v21 = *((_DWORD *)v6 - 4);
      int v20 = v6 - 2;
      int v19 = v21;
      do
      {
        unint64_t v22 = v16;
        unint64_t v23 = v20;
        int v20 = &v14[2 * v22];
        *(_DWORD *)unint64_t v23 = *(_DWORD *)v20;
        v23[1] = v17;
        if (!v22) {
          break;
        }
        unint64_t v16 = (v22 - 1) >> 1;
        double v17 = v14[2 * v16 + 1];
      }
      while (v17 < v18);
      *(_DWORD *)int v20 = v19;
      v14[2 * v22 + 1] = v18;
    }
  }
}

os_log_t sub_19E45541C()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "Prediction");
  qword_1E9459FE0 = (uint64_t)result;
  return result;
}

void sub_19E45544C(void *a1)
{
  sub_19E455484(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E455484(void *a1)
{
  *a1 = &unk_1EF0BC050;
  uint64_t v2 = (void *)a1[16];
  if (v2)
  {
    a1[17] = v2;
    operator delete(v2);
  }
  unsigned int v3 = (void *)a1[13];
  if (v3)
  {
    a1[14] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)a1[7];
  if (v4)
  {
    a1[8] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    uint64_t v6 = (std::__shared_weak_count *)a1[4];
    if (!v6) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v6 = (std::__shared_weak_count *)a1[4];
    if (!v6) {
      goto LABEL_13;
    }
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_13:
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

void sub_19E4555DC(uint64_t a1, int a2, unsigned __int8 *a3, int a4, unsigned int a5)
{
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v6 = (4 * a2);
  uint64_t v7 = (unsigned int *)(v5 + v6);
  if (a4)
  {
    int v8 = a4;
    do
    {
      uint64_t v13 = *a3;
      uint64_t v14 = &v7[v13];
      unsigned int v16 = v14[1];
      uint64_t v15 = v14 + 1;
      int v17 = v16 & 3;
      unint64_t v18 = (unint64_t)v16 >> 2;
      if (v17 == 3)
      {
        LODWORD(v11) = v18;
        ++a3;
        LODWORD(v12) = v8 - 1;
        goto LABEL_4;
      }
      if (v17 == 1) {
        goto LABEL_23;
      }
      if (v17) {
        return;
      }
      uint64_t v19 = *(void *)(a1 + 80);
      if (v19 != *(void *)(a1 + 72))
      {
        uint64_t v19 = (*(void *)(a1 + 80) & 0xFFFFFFFCLL)
            + *(unsigned int *)(*(void *)(a1 + 120) + (*(void *)(a1 + 80) & 0xFFFFFFFCLL))
            + 4;
        *(void *)(a1 + 72) = v19;
      }
      unint64_t v20 = v19 + 3;
      unint64_t v21 = (v19 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v22 = v21 + *(unsigned int *)(a1 + 200);
      unint64_t v23 = *(void *)(a1 + 64);
      if (v22 <= v23)
      {
LABEL_11:
        *(void *)(a1 + 72) = v22;
        *(void *)(a1 + 80) = v21;
        unint64_t v18 = (v20 >> 2) | 0x100000000;
        goto LABEL_12;
      }
      while (1)
      {
        while (1)
        {
          int v25 = 2 * (int)v23 ? 2 * v23 : 0x10000;
          if (!*(_DWORD *)(a1 + 88)) {
            break;
          }
          uint64_t v26 = *(uint64_t (**)(void *, void, void))(a1 + 104);
          float v27 = *(void **)(a1 + 120);
          unint64_t v23 = v25;
          if (!v26)
          {
            uint64_t v24 = (char *)malloc_type_realloc(v27, v25, 0x837F6817uLL);
            *(void *)(a1 + 120) = v24;
            **(_DWORD **)(a1 + 96) = 1;
            goto LABEL_14;
          }
          *(void *)(a1 + 120) = v26(v27, v25, *(void *)(a1 + 112));
          *(void *)(a1 + 64) = v23;
          if (v22 <= v23) {
            goto LABEL_11;
          }
        }
        unint64_t v23 = v25;
        uint64_t v24 = (char *)malloc_type_realloc(*(void **)(a1 + 120), v25, 0x46E4E2A4uLL);
        *(void *)(a1 + 120) = v24;
        if (!v24) {
          break;
        }
LABEL_14:
        bzero(&v24[*(void *)(a1 + 64)], v23 - *(void *)(a1 + 64));
        *(void *)(a1 + 64) = v23;
        if (v22 <= v23) {
          goto LABEL_11;
        }
      }
      unint64_t v18 = 0;
LABEL_12:
      *uint64_t v15 = HIDWORD(v18) | (4 * v18);
LABEL_23:
      float v28 = (unsigned int *)(*(void *)(a1 + 120) + (4 * v18));
      size_t v12 = (v8 - 1);
      if (v8 == 1)
      {
        *float v28 = 4;
        v28[1] = a5;
        return;
      }
      uint64_t v29 = *v28;
      if (!v29)
      {
        *(void *)float v28 = 4;
        uint64_t v29 = 4;
      }
      ++a3;
      uint64_t v30 = (v8 + 4);
      uint64_t v31 = v29 + 4;
      if (v31 + v30 < (unint64_t)*(unsigned int *)(a1 + 200))
      {
        *((unsigned char *)v28 + v31) = v12;
        BOOL v32 = (char *)v28 + v31 + 1;
        memcpy(v32, a3, v12);
        *(_DWORD *)&v32[v12] = a5;
        *v28 += v30;
        return;
      }
      uint64_t v11 = sub_19E455B98(a1);
      uint64_t v5 = *(void *)(a1 + 56);
      *(_DWORD *)(v5 + v6 + 4 * v13 + 4) = HIDWORD(v11) | (4 * v11);
LABEL_4:
      uint64_t v6 = (4 * v11);
      uint64_t v7 = (unsigned int *)(v5 + v6);
      int v8 = v12;
    }
    while (v12);
  }
  *uint64_t v7 = a5;
}

unint64_t sub_19E455864(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  LODWORD(v4) = a2;
  unint64_t v5 = HIDWORD(a2);
  if (HIDWORD(a2) == 3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a1 + 56);
    uint64_t v10 = (4 * a2);
    uint64_t v11 = v9 + v10;
    __n128 v12 = 0uLL;
    v13.i64[0] = 0x300000003;
    v13.i64[1] = 0x300000003;
    __n128 v14 = 0uLL;
    do
    {
      __n128 v12 = (__n128)vsubq_s32((int32x4_t)v12, vtstq_s32(*(int32x4_t *)(v11 + v8 + 4), v13));
      __n128 v14 = (__n128)vsubq_s32((int32x4_t)v14, vtstq_s32(*(int32x4_t *)(v11 + v8 + 20), v13));
      v8 += 32;
    }
    while (v8 != 1024);
    if (!a4)
    {
      __n128 v12 = (__n128)vaddq_s32((int32x4_t)v14, (int32x4_t)v12);
      v12.n128_u32[0] = vaddvq_s32((int32x4_t)v12);
      unsigned __int8 v15 = v12.n128_u8[0];
      if (v12.n128_u32[0] < 0x21)
      {
        unint64_t v16 = *(void *)a3;
        unint64_t v17 = *(void *)(a3 + 8) + 3;
        unint64_t v18 = (v17 & 0xFFFFFFFFFFFFFFFCLL) + 4 * v12.n128_u32[0] + 40;
        if (v18 > *(void *)a3)
        {
          do
          {
            if (2 * v16) {
              int v20 = 2 * v16;
            }
            else {
              int v20 = 0x10000;
            }
            if (*(_DWORD *)(a3 + 24))
            {
              unint64_t v21 = *(uint64_t (**)(void *, void, void))(a3 + 40);
              unint64_t v22 = *(void **)(a3 + 56);
              unint64_t v16 = v20;
              if (v21)
              {
                *(void *)(a3 + 56) = v21(v22, v20, *(void *)(a3 + 48));
                goto LABEL_10;
              }
              uint64_t v19 = (char *)malloc_type_realloc(v22, v20, 0x837F6817uLL);
              *(void *)(a3 + 56) = v19;
              **(_DWORD **)(a3 + 32) = 1;
            }
            else
            {
              unint64_t v16 = v20;
              uint64_t v19 = (char *)malloc_type_realloc(*(void **)(a3 + 56), v20, 0x46E4E2A4uLL);
              *(void *)(a3 + 56) = v19;
            }
            bzero(&v19[*(void *)a3], v16 - *(void *)a3);
LABEL_10:
            *(void *)a3 = v16;
          }
          while (v18 > v16);
        }
        uint64_t v30 = 0;
        *(void *)(a3 + 8) = v18;
        *(void *)(a3 + 16) = v17 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v4 = (v17 >> 2) | 0x200000000;
        uint64_t v31 = v17 & 0xFFFFFFFC;
        uint64_t v32 = *(void *)(a3 + 56) + v31;
        unint64_t v33 = (int *)(v9 + v10);
        int v35 = *v33;
        unint64_t v34 = v33 + 1;
        *(_DWORD *)uint64_t v32 = v35;
        *(unsigned char *)(v32 + 37) = v15;
        do
        {
          unint64_t v36 = sub_19E455864(a1, ((unint64_t)v34[v30] >> 2) | ((unint64_t)(v34[v30] & 3) << 32), a3, 0, v12, v14);
          if (HIDWORD(v36))
          {
            uint64_t v37 = *(void *)(a3 + 56) + v31;
            uint64_t v38 = *(unsigned __int8 *)(v37 + 36);
            *(unsigned char *)(v37 + 36) = v38 + 1;
            *(_DWORD *)(v37 + 4 * v38 + 40) = HIDWORD(v36) + 4 * v36;
            *(_DWORD *)(v37 + 4 * (v30 >> 5) + 4) |= 1 << v30;
          }
          ++v30;
        }
        while (v30 != 256);
        goto LABEL_36;
      }
    }
    unint64_t v23 = *(void *)a3;
    unint64_t v24 = *(void *)(a3 + 8) + 3;
    unint64_t v25 = (v24 & 0xFFFFFFFFFFFFFFFCLL) + 1028;
    if (v25 <= *(void *)a3)
    {
LABEL_34:
      uint64_t v39 = 0;
      *(void *)(a3 + 8) = v25;
      *(void *)(a3 + 16) = v24 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v4 = (v24 >> 2) | 0x300000000;
      unint64_t v40 = (int *)(v9 + v10);
      int v42 = *v40;
      unint64_t v41 = v40 + 1;
      *(_DWORD *)(*(void *)(a3 + 56) + (v24 & 0xFFFFFFFC)) = v42;
      do
      {
        uint64_t v43 = sub_19E455864(a1, ((unint64_t)v41[v39] >> 2) | ((unint64_t)(v41[v39] & 3) << 32), a3, 0, v12, v14);
        *(_DWORD *)(*(void *)(a3 + 56) + (v24 & 0xFFFFFFFC) + 4 + v39 * 4) = HIDWORD(v43) + 4 * v43;
        ++v39;
      }
      while (v39 != 256);
LABEL_36:
      unint64_t v5 = HIDWORD(v4);
      return v4 | ((unint64_t)v5 << 32);
    }
    while (1)
    {
      if (2 * v23) {
        int v27 = 2 * v23;
      }
      else {
        int v27 = 0x10000;
      }
      if (*(_DWORD *)(a3 + 24))
      {
        float v28 = *(uint64_t (**)(void *, void, void, __n128, __n128))(a3 + 40);
        uint64_t v29 = *(void **)(a3 + 56);
        unint64_t v23 = v27;
        if (v28)
        {
          *(void *)(a3 + 56) = v28(v29, v27, *(void *)(a3 + 48), v12, v14);
          goto LABEL_22;
        }
        uint64_t v26 = (char *)malloc_type_realloc(v29, v27, 0x837F6817uLL);
        *(void *)(a3 + 56) = v26;
        **(_DWORD **)(a3 + 32) = 1;
      }
      else
      {
        unint64_t v23 = v27;
        uint64_t v26 = (char *)malloc_type_realloc(*(void **)(a3 + 56), v27, 0x46E4E2A4uLL);
        *(void *)(a3 + 56) = v26;
      }
      bzero(&v26[*(void *)a3], v23 - *(void *)a3);
LABEL_22:
      *(void *)a3 = v23;
      if (v25 <= v23) {
        goto LABEL_34;
      }
    }
  }
  return v4 | ((unint64_t)v5 << 32);
}

uint64_t sub_19E455B98(uint64_t a1)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = MEMORY[0x1F4188790]();
  unint64_t v4 = (_DWORD *)((char *)v20 - ((v3 + 19) & 0x1FFFFFFF0));
  uint64_t v6 = (4 * v5);
  uint64_t v7 = (unsigned int *)(*(void *)(v2 + 120) + v6);
  size_t v8 = *v7;
  _DWORD *v4 = v8;
  memcpy(v4 + 1, v7 + 1, v8);
  if (*(void *)(a1 + 80) == v6)
  {
    bzero(v7, *(void *)(a1 + 72) - v6);
    *(void *)(a1 + 72) = *(void *)(a1 + 80);
  }
  unint64_t v9 = *(void *)a1;
  unint64_t v10 = *(void *)(a1 + 8) + 3;
  unint64_t v11 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 1028;
  if (v11 > *(void *)a1)
  {
    do
    {
      if (2 * v9) {
        int v13 = 2 * v9;
      }
      else {
        int v13 = 0x10000;
      }
      if (*(_DWORD *)(a1 + 24))
      {
        __n128 v14 = *(uint64_t (**)(void *, void, void))(a1 + 40);
        unsigned __int8 v15 = *(void **)(a1 + 56);
        unint64_t v9 = v13;
        if (v14)
        {
          *(void *)(a1 + 56) = v14(v15, v13, *(void *)(a1 + 48));
          goto LABEL_7;
        }
        __n128 v12 = (char *)malloc_type_realloc(v15, v13, 0x837F6817uLL);
        *(void *)(a1 + 56) = v12;
        **(_DWORD **)(a1 + 32) = 1;
      }
      else
      {
        unint64_t v9 = v13;
        __n128 v12 = (char *)malloc_type_realloc(*(void **)(a1 + 56), v13, 0x46E4E2A4uLL);
        *(void *)(a1 + 56) = v12;
      }
      bzero(&v12[*(void *)a1], v9 - *(void *)a1);
LABEL_7:
      *(void *)a1 = v9;
    }
    while (v11 > v9);
  }
  *(void *)(a1 + 8) = v11;
  *(void *)(a1 + 16) = v10 & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(*(void *)(a1 + 56) + (v10 & 0xFFFFFFFC)) = v4[1];
  unint64_t v16 = (unsigned __int8 *)(v4 + 2);
  unint64_t v17 = (unint64_t)v4 + v8 + 4;
  if ((unint64_t)(v4 + 2) < v17)
  {
    do
    {
      unint64_t v18 = (unint64_t)&v16[*v16 + 5];
      sub_19E4555DC(a1, (v10 >> 2) | 0x300000000);
      unint64_t v16 = (unsigned __int8 *)v18;
    }
    while (v18 < v17);
  }
  return (v10 >> 2) | 0x300000000;
}

void *sub_19E455D8C(void *result, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  size_t v8 = result;
  if (*a2)
  {
    if (qword_1E9459FB0 != -1) {
      dispatch_once(&qword_1E9459FB0, &unk_1EF0BEBA0);
    }
    os_log_t result = (*(void *(**)(long long *__return_ptr))(**(void **)(qword_1E9459FB8 + 8 * (*a3 & 3)) + 16))(&v12);
    *(_DWORD *)size_t v8 = v12;
    v8[1] = *((void *)&v12 + 1);
    *((unsigned char *)v8 + 16) = v13;
  }
  else
  {
    *(_DWORD *)os_log_t result = 0;
    result[1] = 0;
    *((unsigned char *)result + 16) = 0;
  }
  uint64_t v10 = a5 - 1;
  uint64_t v11 = a4 + 1;
  do
  {
    if ((*(unsigned char *)v8 & 3) == 0) {
      break;
    }
    if (*a2)
    {
      if (qword_1E9459FB0 != -1) {
        dispatch_once(&qword_1E9459FB0, &unk_1EF0BEBA0);
      }
      os_log_t result = (*(void *(**)(long long *__return_ptr))(**(void **)(qword_1E9459FB8
                                                                               + 8 * (*(_DWORD *)v8 & 3))
                                                                 + 16))(&v12);
      *(_OWORD *)size_t v8 = v12;
      void v8[2] = v13;
    }
    ++v11;
    --v10;
  }
  while (v10);
  return result;
}

uint64_t sub_19E455F3C(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v8 = *(void *)(a1 + 16);
  unint64_t v9 = *(void *)(a1 + 168);
  if (v8 > v9) {
    unint64_t v9 = *(void *)(a1 + 16);
  }
  unint64_t v10 = a2 + 4 * a3 + 4 * (1 - v9);
  if (a3 >= v9)
  {
    unint64_t v11 = v9 - 1;
  }
  else
  {
    unint64_t v10 = a2;
    unint64_t v11 = a3;
  }
  if (v11)
  {
    long long v12 = (const float *)(a1 + 24);
    unint64_t v13 = *(void *)(a1 + 56);
    if (v11 > 7)
    {
      unint64_t v14 = 0;
      unint64_t v15 = v13 + 4 * v11;
      BOOL v17 = v13 < a1 + 28 && (unint64_t)v12 < v15;
      if ((v10 >= v15 || v13 >= v10 + 4 * v11) && !v17)
      {
        unint64_t v14 = v11 & 0xFFFFFFFFFFFFFFF8;
        uint32x4_t v19 = (uint32x4_t)vld1q_dup_f32(v12);
        int v20 = (int8x16_t *)(v13 + 16);
        unint64_t v21 = (int8x16_t *)(v10 + 16);
        unint64_t v22 = v11 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          int8x16_t v23 = vbicq_s8(*v21, (int8x16_t)vcgtq_u32(*(uint32x4_t *)v21, v19));
          v20[-1] = vbicq_s8(v21[-1], (int8x16_t)vcgtq_u32((uint32x4_t)v21[-1], v19));
          *int v20 = v23;
          v20 += 2;
          v21 += 2;
          v22 -= 8;
        }
        while (v22);
        if (v11 == v14)
        {
LABEL_28:
          uint64_t v30 = a1 + 304;
          uint64_t v31 = *(int **)(a1 + 440);
          uint64_t v32 = *(_DWORD **)(a1 + 416);
          unint64_t v33 = v11;
          while (1)
          {
            uint64_t v35 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, int *, uint64_t))(*(void *)v30 + 24))(a1 + 304, v13, 1, &dword_1E945A238, 3);
            if (v35 != 1) {
              break;
            }
            *v32++ = dword_1E945A238;
            if (v31)
            {
              unint64_t v34 = &dword_1E945A238;
LABEL_31:
              *v31++ = *v34;
            }
LABEL_32:
            v13 += 4;
            if (!--v33) {
              goto LABEL_37;
            }
          }
          if (v35 != 3) {
            goto LABEL_32;
          }
          unint64_t v34 = &dword_1E945A240;
          *v32++ = dword_1E945A238;
          if (!v31) {
            goto LABEL_32;
          }
          goto LABEL_31;
        }
      }
    }
    else
    {
      unint64_t v14 = 0;
    }
    unint64_t v24 = v11 - v14;
    uint64_t v25 = 4 * v14;
    uint64_t v26 = (unsigned int *)(v13 + 4 * v14);
    int v27 = (unsigned int *)(v10 + v25);
    do
    {
      unsigned int v29 = *v27++;
      unsigned int v28 = v29;
      if (v29 > *(_DWORD *)v12) {
        unsigned int v28 = 0;
      }
      *v26++ = v28;
      --v24;
    }
    while (v24);
    goto LABEL_28;
  }
LABEL_37:
  if (v8 > a4)
  {
    if (v11 >= v8 - 1) {
      unint64_t v36 = v8 - 1;
    }
    else {
      unint64_t v36 = v11;
    }
    double v37 = 0.0;
    if (v36 > a4)
    {
      uint64_t v38 = 4 * v11 - 4 * v36;
      do
      {
        if (sub_19E4B0FF0(*(uint64_t ***)(a1 + 80), (unsigned int *)(*(void *)(a1 + 416) + v38), v36, v44) != 2)double v37 = *(double *)(**(void **)(a1 + 96) + 8 * BYTE1(v44[0])) + v37; {
        --v36;
        }
        v38 += 4;
      }
      while (v36 > a4);
    }
    if (!a4 && (a5 & 0x8000000000000000) == 0)
    {
      if (!*(void *)(a1 + 88))
      {
        v44[0] = &unk_1EF0BBFF0;
        v44[1] = a1;
        *(double *)&v44[2] = v37;
        v44[3] = 0;
        v44[4] = a6;
        long long v45 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        int v39 = *(_DWORD *)(**(void **)(a1 + 80) + 32);
        if (v39 != 5 && v39 != 3) {
          operator new();
        }
        operator new();
      }
      operator new();
    }
    operator new();
  }
  return 0;
}

void sub_19E4563A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  MEMORY[0x19F3BDCF0](v4, 0x30C400D66AB62);
  sub_19E456454((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E4563DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24)
{
  if (__p)
  {
    operator delete(__p);
    uint64_t v25 = a20;
    if (!a20)
    {
LABEL_3:
      uint64_t v26 = a17;
      if (!a17) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v25 = a20;
    if (!a20) {
      goto LABEL_3;
    }
  }
  operator delete(v25);
  uint64_t v26 = a17;
  if (!a17) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(v26);
  _Unwind_Resume(exception_object);
}

void sub_19E456430(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B1C40D29F17F9);
  _Unwind_Resume(a1);
}

void *sub_19E456454(void *a1)
{
  *a1 = &unk_1EF0BBFF0;
  uint64_t v2 = a1[17];
  if (v2)
  {
    uint64_t v3 = a1[18];
    uint64_t v4 = (void *)a1[17];
    if (v3 != v2)
    {
      do
      {
        int v5 = *(void **)(v3 - 24);
        if (v5)
        {
          *(void *)(v3 - 16) = v5;
          operator delete(v5);
        }
        v3 -= 40;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[17];
    }
    a1[18] = v2;
    operator delete(v4);
  }
  uint64_t v6 = (void *)a1[16];
  a1[16] = 0;
  if (v6)
  {
    if (*v6) {
      (*(void (**)(void))(*(void *)*v6 + 8))(*v6);
    }
    MEMORY[0x19F3BDCF0](v6, 0x1020C40EDED9539);
  }
  uint64_t v7 = a1[15];
  a1[15] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  unint64_t v8 = (void *)a1[11];
  if (v8)
  {
    a1[12] = v8;
    operator delete(v8);
  }
  unint64_t v9 = (void *)a1[8];
  if (v9)
  {
    a1[9] = v9;
    operator delete(v9);
  }
  unint64_t v10 = (void *)a1[5];
  if (v10)
  {
    a1[6] = v10;
    operator delete(v10);
  }
  return a1;
}

void sub_19E456594(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, double a8)
{
  *(void *)a1 = &unk_1EF0BBFF0;
  *(void *)(a1 + 8) = a2;
  *(double *)(a1 + 16) = a8;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = a7;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  if (a4)
  {
    if (a4 < 0) {
      sub_19E37C7C4();
    }
    unint64_t v14 = (char *)operator new(4 * a4);
    *(void *)(a1 + 40) = v14;
    *(void *)(a1 + 48) = v14;
    unint64_t v15 = &v14[4 * a4];
    *(void *)(a1 + 56) = v15;
    memcpy(v14, a3, 4 * a4);
    *(void *)(a1 + 48) = v15;
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  if (a6)
  {
    if (a6 < 0) {
      sub_19E37C7C4();
    }
    size_t v16 = 4 * a6;
    BOOL v17 = (char *)operator new(4 * a6);
    *(void *)(a1 + 64) = v17;
    *(void *)(a1 + 72) = v17;
    unint64_t v18 = &v17[4 * a6];
    *(void *)(a1 + 80) = v18;
    memcpy(v17, a5, v16);
    *(void *)(a1 + 72) = v18;
  }
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  sub_19E4B248C(*(uint64_t **)(a2 + 80), (unsigned int *)a3, a4);
}

void sub_19E4566CC(_Unwind_Exception *exception_object)
{
  uint64_t v6 = *v3;
  if (*v3)
  {
    v1[12] = v6;
    operator delete(v6);
    uint64_t v7 = *v4;
    if (!*v4)
    {
LABEL_3:
      unint64_t v8 = *v2;
      if (!*v2) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v7 = *v4;
    if (!*v4) {
      goto LABEL_3;
    }
  }
  v1[9] = v7;
  operator delete(v7);
  unint64_t v8 = *v2;
  if (!*v2) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  v1[6] = v8;
  operator delete(v8);
  _Unwind_Resume(exception_object);
}

unint64_t sub_19E456740(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 136);
  unint64_t v5 = (*(void *)(a1 + 144) - v4) / 40;
  if (*(void *)(a1 + 144) == v4)
  {
    double v8 = 0.0;
    goto LABEL_17;
  }
  if (v5 <= 1) {
    unint64_t v6 = 1;
  }
  else {
    unint64_t v6 = (*(void *)(a1 + 144) - v4) / 40;
  }
  if (a2)
  {
    uint64_t v7 = (double *)(v4 + 8);
    double v8 = 0.0;
    do
    {
      double v8 = *(v7 - 1) + v8;
      int v9 = *(_DWORD *)v7;
      v7 += 5;
      *a2++ = v9;
      --v6;
    }
    while (v6);
    goto LABEL_17;
  }
  if (v6 < 2)
  {
    unint64_t v10 = 0;
    double v8 = 0.0;
LABEL_15:
    unint64_t v15 = v6 - v10;
    size_t v16 = (double *)(v4 + 40 * v10);
    do
    {
      double v17 = *v16;
      v16 += 5;
      double v8 = v17 + v8;
      --v15;
    }
    while (v15);
    goto LABEL_17;
  }
  unint64_t v10 = v6 & 0xFFFFFFFFFFFFFFFELL;
  double v11 = 0.0;
  long long v12 = *(double **)(a1 + 136);
  unint64_t v13 = v6 & 0xFFFFFFFFFFFFFFFELL;
  double v14 = 0.0;
  do
  {
    double v11 = *v12 + v11;
    double v14 = v12[5] + v14;
    v12 += 10;
    v13 -= 2;
  }
  while (v13);
  double v8 = v14 + v11;
  if (v6 != v10) {
    goto LABEL_15;
  }
LABEL_17:
  if (a3)
  {
    *(int64x2_t *)a3 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    *(void *)(a3 + 16) = 0;
    *(_WORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 32) = 1;
    *(_OWORD *)(a3 + 40) = xmmword_19E572FD0;
    *(_DWORD *)(a3 + 56) = 0;
    *(_OWORD *)(a3 + 64) = xmmword_19E572FD0;
    *(void *)(a3 + 88) = 0;
    *(void *)(a3 + 96) = 0;
    *(void *)(a3 + 80) = 0xFFEFFFFFFFFFFFFFLL;
    *(void *)(a3 + 104) = (*(uint64_t (**)(void, _DWORD *))(**(void **)(a1 + 120) + 32))(*(void *)(a1 + 120), a2);
    *(double *)a3 = v8;
    *(unsigned char *)(a3 + 112) = 0;
  }
  return v5;
}

uint64_t sub_19E4568A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 136);
  long long v137 = (uint64_t **)(a1 + 136);
  if ((unint64_t)(*(void *)(a1 + 24) - 1) > 2
    || *(void *)(a1 + 32) < 2uLL
    || (uint64_t v3 = *(void *)(a1 + 144), v4 = (v3 - v2) / 40, v4 >= *(void *)(*(void *)(a1 + 8) + 16) - 1)
    || (uint64_t v5 = *(void *)(a1 + 40),
        unint64_t v6 = *(unsigned char **)(a1 + 48),
        unint64_t v7 = (unint64_t)&v6[-v5],
        unint64_t v8 = (uint64_t)&v6[-v5] >> 2,
        unint64_t v9 = v8 - v4,
        v8 <= v4))
  {
    __int32 v143 = 0;
    goto LABEL_10;
  }
  int64x2_t v144 = 0uLL;
  *(void *)&long long v145 = 0;
  if ((v7 & 0x8000000000000000) != 0) {
    sub_19E37C7C4();
  }
  uint64_t v10 = (uint64_t)operator new((size_t)&v6[-v5]);
  v144.i64[0] = v10;
  *(void *)&long long v145 = v10 + 4 * v8;
  bzero((void *)v10, (size_t)&v6[-v5]);
  v144.i64[1] = v10 + v7;
  long long v12 = *(unsigned char **)(a1 + 64);
  double v11 = *(unsigned char **)(a1 + 72);
  unint64_t v157 = 0;
  __n128 v158 = 0;
  uint64_t v156 = 0;
  unint64_t v139 = v12;
  uint64_t v141 = v11;
  int64_t v13 = v11 - v12;
  if (v11 == v12)
  {
    double v14 = 0;
  }
  else
  {
    if (v13 < 0) {
      sub_19E37C7C4();
    }
    double v14 = (char *)operator new(v11 - v12);
    uint64_t v156 = v14;
    __n128 v158 = &v14[4 * (v13 >> 2)];
    bzero(v14, v13);
    unint64_t v157 = &v14[v13];
  }
  unint64_t v129 = (unsigned char *)(v5 + 4 * v4);
  if (v6 != v129) {
    memmove((void *)v10, v129, v6 - v129);
  }
  unint64_t v130 = &v139[4 * v4];
  if (v141 != v130) {
    memmove(v14, v130, v141 - v130);
  }
  if (v3 == v2) {
LABEL_163:
  }
    operator new();
  if (v4 <= 1) {
    uint64_t v131 = 1;
  }
  else {
    uint64_t v131 = (v3 - v2) / 40;
  }
  unint64_t v132 = (void *)(v2 + 24);
  while (1)
  {
    uint64_t v133 = (int *)*(v132 - 1);
    uint64_t v136 = *v132 - (void)v133;
    if (v136 != 12) {
      break;
    }
    int v135 = *v133;
    v133 += 2;
    int v134 = v135;
LABEL_157:
    *(_DWORD *)(v10 + 4 * v9) = v134;
    *(_DWORD *)&v14[4 * v9] = *v133;
    v132 += 5;
    if (!--v131) {
      goto LABEL_163;
    }
  }
  if (v136 == 4)
  {
    int v134 = *v133;
    if (*v133 == *((_DWORD *)v132 - 4)) {
      goto LABEL_157;
    }
  }
  if (v14) {
    operator delete(v14);
  }
  operator delete((void *)v10);
  __int32 v143 = 0;
LABEL_10:
  unint64_t v15 = (void **)(a1 + 88);
  double v16 = 0.0;
  int64x2_t v138 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  while (2)
  {
    while (2)
    {
      while (2)
      {
        double v17 = *(uint64_t **)(a1 + 128);
        if (v17)
        {
          uint64_t v18 = *v17;
          if (*v17)
          {
            unint64_t v19 = v17[1];
            if (v19 <= 2)
            {
              v17[1] = v19 + 1;
              if ((*(unsigned int (**)(uint64_t))(*(void *)v18 + 16))(v18))
              {
                double v75 = (char *)(*(void *)(a1 + 96) - 4);
                *(void *)(a1 + 96) = v75;
                double v76 = *(uint64_t **)(a1 + 128);
                int64x2_t v144 = v138;
                *(void *)&long long v145 = 0;
                WORD4(v145) = 0;
                LOBYTE(v146) = 1;
                long long v147 = xmmword_19E572FD0;
                int v148 = 0;
                long long v149 = xmmword_19E572FD0;
                unint64_t v150 = 0xFFEFFFFFFFFFFFFFLL;
                int v155 = 0;
                uint64_t v152 = 0;
                uint64_t v153 = 0;
                uint64_t v151 = 0;
                __int16 v154 = 0;
                uint64_t v77 = *v76;
                if (*v76 && (unint64_t)v76[1] <= 2)
                {
                  LODWORD(v156) = 0;
                  (*(void (**)(uint64_t, char **, int64x2_t *))(*(void *)v77 + 24))(v77, &v156, &v144);
                  double v16 = *(double *)v144.i64;
                  int v78 = (int)v156;
                  double v75 = *(char **)(a1 + 96);
                }
                else
                {
                  int v78 = 0;
                }
                unint64_t v82 = *(void *)(a1 + 104);
                if ((unint64_t)v75 < v82)
                {
                  *(_DWORD *)double v75 = v78;
                  *(void *)(a1 + 96) = v75 + 4;
                  continue;
                }
                double v83 = (char *)*v15;
                uint64_t v84 = v75 - (unsigned char *)*v15;
                uint64_t v85 = v84 >> 2;
                unint64_t v86 = (v84 >> 2) + 1;
                if (v86 >> 62) {
LABEL_166:
                }
                  sub_19E37C7C4();
                uint64_t v87 = v82 - (void)v83;
                if (v87 >> 1 > v86) {
                  unint64_t v86 = v87 >> 1;
                }
                if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v88 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v88 = v86;
                }
                if (v88)
                {
                  if (v88 >> 62) {
LABEL_167:
                  }
                    sub_19E37C2B8();
                  BOOL v89 = operator new(4 * v88);
                }
                else
                {
                  BOOL v89 = 0;
                }
                int v96 = &v89[4 * v85];
                _DWORD *v96 = v78;
                unint64_t v97 = v96 + 1;
                if (v75 == v83) {
                  goto LABEL_118;
                }
                unint64_t v98 = v75 - 4 - v83;
                if (v98 >= 0x2C)
                {
                  if ((unint64_t)(v75 - &v89[v84]) >= 0x20)
                  {
                    uint64_t v102 = (v98 >> 2) + 1;
                    unint64_t v99 = &v75[-4 * (v102 & 0x7FFFFFFFFFFFFFF8)];
                    int v103 = &v89[4 * v85 - 16];
                    BOOL v104 = v75 - 16;
                    uint64_t v105 = v102 & 0x7FFFFFFFFFFFFFF8;
                    do
                    {
                      long long v106 = *(_OWORD *)v104;
                      *(v103 - 1) = *((_OWORD *)v104 - 1);
                      _OWORD *v103 = v106;
                      v103 -= 2;
                      v104 -= 32;
                      v105 -= 8;
                    }
                    while (v105);
                    v96 -= v102 & 0x7FFFFFFFFFFFFFF8;
                    if (v102 == (v102 & 0x7FFFFFFFFFFFFFF8)) {
                      goto LABEL_118;
                    }
                  }
                  else
                  {
                    unint64_t v99 = v75;
                  }
                }
                else
                {
                  unint64_t v99 = v75;
                }
                do
                {
                  int v107 = *((_DWORD *)v99 - 1);
                  v99 -= 4;
                  *--int v96 = v107;
                }
                while (v99 != v83);
LABEL_118:
                *(void *)(a1 + 88) = v96;
                *(void *)(a1 + 96) = v97;
                *(void *)(a1 + 104) = &v89[4 * v88];
                if (v83) {
                  operator delete(v83);
                }
                *(void *)(a1 + 96) = v97;
                continue;
              }
            }
          }
        }
        break;
      }
      *(void *)(a1 + 96) = *(void *)(a1 + 88);
      uint64_t v20 = *(void *)(a1 + 136);
      for (uint64_t i = *(void *)(a1 + 144); i != v20; i -= 40)
      {
        unint64_t v22 = *(void **)(i - 24);
        if (v22)
        {
          *(void *)(i - 16) = v22;
          operator delete(v22);
        }
      }
      *(void *)(a1 + 144) = v20;
      *(void *)(a1 + 112) = 0;
      if ((***(unsigned int (****)(void))(a1 + 120))(*(void *)(a1 + 120)))
      {
        BOOL v26 = (v142 = 0,
               unsigned int v23 = (*(uint64_t (**)(void, unsigned __int8 *))(**(void **)(a1 + 120) + 8))(*(void *)(a1 + 120), &v142), v24 = v23, v25 = *(void *)(a1 + 8), *(_DWORD *)(v25 + 336) <= v23)&& *(_DWORD *)(v25 + 340) >= v23|| *(_DWORD *)(v25 + 344) <= v23 && *(_DWORD *)(v25 + 348) >= v23;
        double v27 = *(double *)(a1 + 16);
        double v28 = *(double *)(**(void **)(v25 + 104) + 8 * v142);
        uint64_t v30 = *(unsigned int **)(a1 + 96);
        unint64_t v29 = *(void *)(a1 + 104);
        if ((unint64_t)v30 >= v29)
        {
          uint64_t v32 = (unsigned int *)*v15;
          uint64_t v33 = (char *)v30 - (unsigned char *)*v15;
          uint64_t v34 = v33 >> 2;
          unint64_t v35 = (v33 >> 2) + 1;
          if (v35 >> 62) {
            goto LABEL_166;
          }
          uint64_t v36 = v29 - (void)v32;
          if (v36 >> 1 > v35) {
            unint64_t v35 = v36 >> 1;
          }
          unint64_t v37 = (unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v35;
          if (v37)
          {
            if (v37 >> 62) {
              goto LABEL_167;
            }
            uint64_t v38 = operator new(4 * v37);
          }
          else
          {
            uint64_t v38 = 0;
          }
          int v39 = (unsigned int *)&v38[4 * v34];
          *int v39 = v24;
          uint64_t v31 = (int *)(v39 + 1);
          if (v30 != v32)
          {
            unint64_t v40 = (char *)(v30 - 1) - (char *)v32;
            if (v40 < 0x2C) {
              goto LABEL_178;
            }
            if ((unint64_t)((char *)v30 - &v38[v33]) < 0x20) {
              goto LABEL_178;
            }
            uint64_t v41 = (v40 >> 2) + 1;
            int v42 = &v38[4 * v34 - 16];
            uint64_t v43 = (long long *)(v30 - 4);
            uint64_t v44 = v41 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v45 = *v43;
              *(v42 - 1) = *(v43 - 1);
              *int v42 = v45;
              v42 -= 2;
              v43 -= 2;
              v44 -= 8;
            }
            while (v44);
            v39 -= v41 & 0x7FFFFFFFFFFFFFF8;
            v30 -= v41 & 0x7FFFFFFFFFFFFFF8;
            if (v41 != (v41 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_178:
              do
              {
                unsigned int v46 = *--v30;
                *--int v39 = v46;
              }
              while (v30 != v32);
            }
          }
          *(void *)(a1 + 88) = v39;
          *(void *)(a1 + 96) = v31;
          *(void *)(a1 + 104) = &v38[4 * v37];
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          *uint64_t v30 = v23;
          uint64_t v31 = (int *)(v30 + 1);
        }
        *(void *)(a1 + 96) = v31;
        *(double *)(a1 + 112) = v28 + v27 + *(double *)(a1 + 112);
        if (v26)
        {
          uint64_t v48 = *(void *)(a1 + 64);
          uint64_t v47 = *(void *)(a1 + 72);
          uint64_t v49 = v47 - v48;
          if ((unint64_t)(v47 - v48) < 8) {
            continue;
          }
          uint64_t v156 = 0;
          unint64_t v157 = 0;
          __n128 v158 = 0;
          if (v49 < 0) {
            sub_19E37C7C4();
          }
          long long v50 = (char *)operator new(v47 - v48);
          uint64_t v156 = v50;
          int v51 = &v50[v49];
          __n128 v158 = &v50[v49];
          bzero(v50, v47 - v48);
          unint64_t v157 = &v50[v49];
          if (v47 != v48 + 4) {
            memmove(v50, (const void *)(v48 + 4), v47 - (v48 + 4));
          }
          uint64_t v52 = *(void *)(a1 + 8);
          unsigned int v53 = v24 - *(_DWORD *)(v52 + 336);
          int v54 = *(_DWORD *)(v52 + 404);
          int v55 = *(_DWORD *)(v52 + 408);
          char v56 = v55 + v54;
          uint64_t v57 = *(void *)(v52 + 360);
          uint64_t v58 = *(void *)(v52 + 368);
          if (v58 != v57)
          {
            unint64_t v59 = (v58 - v57) >> 3;
            do
            {
              unint64_t v60 = v59 >> 1;
              uint64_t v61 = v57 + 8 * (v59 >> 1);
              unsigned int v62 = *(_DWORD *)(v61 + 4);
              uint64_t v63 = v61 + 8;
              v59 += ~(v59 >> 1);
              if (v62 < v53 << v56) {
                uint64_t v57 = v63;
              }
              else {
                unint64_t v59 = v60;
              }
            }
            while (v59);
          }
          if (v57 == v58 || (unsigned int v64 = *(_DWORD *)(v57 + 4), ((v64 >> v56) & ~(-1 << *(_DWORD *)(v52 + 400))) != v53)) {
            int v65 = 0;
          }
          else {
            int v65 = *(_DWORD *)(v52 + 344) + ((v64 >> v55) & ~(-1 << v54));
          }
          unint64_t v66 = *(void *)(a1 + 104);
          if ((unint64_t)v31 < v66)
          {
            *uint64_t v31 = v65;
            double v67 = v31 + 1;
            goto LABEL_104;
          }
          unint64_t v140 = &v50[v49];
          uint64_t v68 = (int *)*v15;
          uint64_t v69 = (char *)v31 - (unsigned char *)*v15;
          uint64_t v70 = v69 >> 2;
          unint64_t v71 = (v69 >> 2) + 1;
          if (v71 >> 62) {
            sub_19E37C7C4();
          }
          uint64_t v72 = v66 - (void)v68;
          if (v72 >> 1 > v71) {
            unint64_t v71 = v72 >> 1;
          }
          if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v73 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v73 = v71;
          }
          if (v73)
          {
            if (v73 >> 62) {
              sub_19E37C2B8();
            }
            uint64_t v74 = operator new(4 * v73);
          }
          else
          {
            uint64_t v74 = 0;
          }
          __n128 v79 = (int *)&v74[4 * v70];
          *__n128 v79 = v65;
          double v67 = v79 + 1;
          if (v31 != v68)
          {
            unint64_t v80 = (char *)(v31 - 1) - (char *)v68;
            if (v80 < 0x2C)
            {
              uint64_t v81 = v31;
              goto LABEL_100;
            }
            if ((unint64_t)((char *)v31 - v74 - v69) < 0x20)
            {
              uint64_t v81 = v31;
              goto LABEL_100;
            }
            uint64_t v90 = (v80 >> 2) + 1;
            uint64_t v81 = &v31[-(v90 & 0x7FFFFFFFFFFFFFF8)];
            uint64_t v91 = &v74[4 * v70 - 16];
            unint64_t v92 = v31 - 4;
            uint64_t v93 = v90 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v94 = *(_OWORD *)v92;
              *(v91 - 1) = *((_OWORD *)v92 - 1);
              _OWORD *v91 = v94;
              v91 -= 2;
              v92 -= 8;
              v93 -= 8;
            }
            while (v93);
            v79 -= v90 & 0x7FFFFFFFFFFFFFF8;
            if (v90 != (v90 & 0x7FFFFFFFFFFFFFF8))
            {
              do
              {
LABEL_100:
                int v95 = *--v81;
                *--__n128 v79 = v95;
              }
              while (v81 != v68);
            }
          }
          *(void *)(a1 + 88) = v79;
          *(void *)(a1 + 96) = v67;
          *(void *)(a1 + 104) = &v74[4 * v73];
          if (v68) {
            operator delete(v68);
          }
          int v51 = v140;
LABEL_104:
          *(void *)(a1 + 96) = v67;
          *((_DWORD *)v51 - 1) = v65;
          operator new();
        }
      }
      break;
    }
    uint64_t v100 = *(char **)(a1 + 88);
    uint64_t v101 = *(void *)(a1 + 96) - (void)v100;
    if (!v101) {
      return 0;
    }
    if (sub_19E4C4D40(*(void *)(a1 + 8) + 304, v100, v101 >> 2, (unsigned int *)&v143, 1) != 1) {
      continue;
    }
    break;
  }
  *(double *)v144.i64 = *(double *)(a1 + 112) + v16;
  v144.i32[2] = v143;
  uint64_t v146 = 0;
  long long v145 = 0uLL;
  uint64_t v110 = *(unsigned char **)(a1 + 88);
  unint64_t v109 = *(unsigned char **)(a1 + 96);
  int64_t v111 = v109 - v110;
  if (v109 == v110)
  {
    uint64_t v112 = 0;
  }
  else
  {
    if (v111 < 0) {
      sub_19E37C7C4();
    }
    *(void *)&long long v145 = operator new(v109 - v110);
    uint64_t v112 = v145 + 4 * (v111 >> 2);
    memcpy((void *)v145, v110, v111);
    *((void *)&v145 + 1) = v112;
  }
  int v114 = *(uint64_t **)(a1 + 144);
  unint64_t v113 = *(void *)(a1 + 152);
  if ((unint64_t)v114 >= v113)
  {
    int v117 = *v137;
    unint64_t v118 = 0xCCCCCCCCCCCCCCCDLL * (v114 - *v137);
    unint64_t v119 = v118 + 1;
    if (v118 + 1 > 0x666666666666666) {
      sub_19E37C7C4();
    }
    unint64_t v120 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v113 - (void)v117) >> 3);
    if (2 * v120 > v119) {
      unint64_t v119 = 2 * v120;
    }
    if (v120 >= 0x333333333333333) {
      unint64_t v121 = 0x666666666666666;
    }
    else {
      unint64_t v121 = v119;
    }
    if (v121 > 0x666666666666666) {
      sub_19E37C2B8();
    }
    uint64_t v122 = (char *)operator new(40 * v121);
    uint64_t v123 = &v122[40 * v118];
    uint64_t v124 = &v122[40 * v121];
    *(void *)uint64_t v123 = v144.i64[0];
    *((_DWORD *)v123 + 2) = v144.i32[2];
    *((_OWORD *)v123 + 1) = v145;
    *((void *)v123 + 4) = v112;
    uint64_t v116 = v123 + 40;
    if (v114 == v117)
    {
      *(void *)(a1 + 136) = v123;
      *(void *)(a1 + 144) = v116;
      *(void *)(a1 + 152) = v124;
    }
    else
    {
      do
      {
        uint64_t v125 = *(v114 - 5);
        v114 -= 5;
        int v126 = *((_DWORD *)v114 + 2);
        *((void *)v123 - 5) = v125;
        v123 -= 40;
        *((_DWORD *)v123 + 2) = v126;
        *((_OWORD *)v123 + 1) = *((_OWORD *)v114 + 1);
        *((void *)v123 + 4) = v114[4];
        v114[2] = 0;
        v114[3] = 0;
        v114[4] = 0;
      }
      while (v114 != v117);
      int v114 = *(uint64_t **)(a1 + 136);
      unint64_t v127 = *(uint64_t **)(a1 + 144);
      *(void *)(a1 + 136) = v123;
      *(void *)(a1 + 144) = v116;
      *(void *)(a1 + 152) = v124;
      while (v127 != v114)
      {
        uint64_t v128 = (void *)*(v127 - 3);
        if (v128)
        {
          *(v127 - 2) = (uint64_t)v128;
          operator delete(v128);
        }
        v127 -= 5;
      }
    }
    if (v114) {
      operator delete(v114);
    }
  }
  else
  {
    uint64_t v115 = v144.i64[0];
    *((_DWORD *)v114 + 2) = v144.i32[2];
    *int v114 = v115;
    *((_OWORD *)v114 + 1) = v145;
    v114[4] = v112;
    uint64_t v116 = v114 + 5;
  }
  *(void *)(a1 + 144) = v116;
  ++*(void *)(a1 + 24);
  return 1;
}

void sub_19E4578A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24)
{
  unint64_t v29 = *(void **)(v25 + 16);
  if (v29)
  {
    *BOOL v26 = v29;
    operator delete(v29);
  }
  *(void *)(v24 + 144) = v25;
  if (*(void *)(v27 - 152)) {
    operator delete(*(void **)(v27 - 152));
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_19E4579AC(void *a1, uint64_t a2)
{
  uint64_t v3 = (char *)*a1;
  uint64_t v2 = (char *)a1[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v2[-*a1] >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666) {
    sub_19E37C7C4();
  }
  if (0x999999999999999ALL * ((uint64_t)(a1[2] - (void)v3) >> 3) > v5) {
    unint64_t v5 = 0x999999999999999ALL * ((uint64_t)(a1[2] - (void)v3) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[2] - (void)v3) >> 3) >= 0x333333333333333) {
    unint64_t v8 = 0x666666666666666;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0x666666666666666) {
      sub_19E37C2B8();
    }
    unint64_t v9 = (char *)operator new(40 * v8);
  }
  else
  {
    unint64_t v9 = 0;
  }
  uint64_t v10 = &v9[40 * v4];
  double v11 = &v9[40 * v8];
  *((void *)&v26 + 1) = v11;
  *(void *)uint64_t v10 = *(void *)a2;
  *((_DWORD *)v10 + 2) = *(_DWORD *)(a2 + 8);
  *((void *)v10 + 2) = 0;
  *((void *)v10 + 3) = 0;
  long long v12 = (char **)(v10 + 24);
  *((void *)v10 + 4) = 0;
  double v14 = *(unsigned char **)(a2 + 16);
  int64_t v13 = *(unsigned char **)(a2 + 24);
  int64_t v15 = v13 - v14;
  if (v13 != v14)
  {
    if (v15 < 0) {
      sub_19E37C7C4();
    }
    double v16 = (char *)operator new(v13 - v14);
    *((void *)v10 + 2) = v16;
    *long long v12 = v16;
    double v17 = &v16[4 * (v15 >> 2)];
    *((void *)v10 + 4) = v17;
    memcpy(v16, v14, v15);
    *long long v12 = v17;
  }
  uint64_t v18 = v10 + 40;
  if (v2 == v3)
  {
    *a1 = v10;
    a1[1] = v18;
    a1[2] = v11;
  }
  else
  {
    uint64_t v19 = 0;
    do
    {
      uint64_t v20 = &v10[v19];
      unint64_t v21 = &v2[v19];
      uint64_t v22 = *(void *)&v2[v19 - 40];
      *((_DWORD *)v20 - 8) = *(_DWORD *)&v2[v19 - 32];
      *((void *)v20 - 5) = v22;
      *((void *)v20 - 2) = 0;
      *((void *)v20 - 1) = 0;
      *(_OWORD *)(v20 - 24) = *(_OWORD *)&v2[v19 - 24];
      *((void *)v20 - 1) = *(void *)&v2[v19 - 8];
      *((void *)v21 - 3) = 0;
      *((void *)v21 - 2) = 0;
      *((void *)v21 - 1) = 0;
      v19 -= 40;
    }
    while (&v2[v19] != v3);
    uint64_t v2 = (char *)*a1;
    unsigned int v23 = (char *)a1[1];
    *a1 = &v10[v19];
    *(void *)&long long v26 = v10 + 40;
    *(_OWORD *)(a1 + 1) = v26;
    uint64_t v18 = v10 + 40;
    while (v23 != v2)
    {
      uint64_t v24 = (void *)*((void *)v23 - 3);
      if (v24)
      {
        *((void *)v23 - 2) = v24;
        operator delete(v24);
      }
      v23 -= 40;
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v18;
}

void sub_19E457BB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  unint64_t v5 = *v2;
  if (*v2)
  {
    *uint64_t v3 = v5;
    operator delete(v5);
  }
  sub_19E457BD4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E457BD4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      while (1)
      {
        uint64_t v4 = v2 - 40;
        *(void *)(a1 + 16) = v2 - 40;
        unint64_t v5 = *(void **)(v2 - 24);
        if (!v5) {
          break;
        }
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
        uint64_t v2 = *(void *)(a1 + 16);
        if (v2 == v3) {
          goto LABEL_6;
        }
      }
      v2 -= 40;
    }
    while (v4 != v3);
  }
LABEL_6:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E457C44(void *a1)
{
  sub_19E456454(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E457C80(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4, double *a5, unint64_t *a6)
{
  unint64_t v6 = a6;
  unint64_t v7 = a5;
  unint64_t v9 = *(void *)(a1 + 16);
  unint64_t v10 = *(void *)(a1 + 168);
  if (v9 <= v10) {
    unint64_t v11 = *(void *)(a1 + 168);
  }
  else {
    unint64_t v11 = *(void *)(a1 + 16);
  }
  unint64_t v12 = a3 + 4 * a4 + 4 * (1 - v11);
  if (a4 >= v11)
  {
    unint64_t v13 = v11 - 1;
  }
  else
  {
    unint64_t v12 = a3;
    unint64_t v13 = a4;
  }
  if (v13)
  {
    double v14 = (const float *)(a1 + 24);
    unint64_t v15 = *(void *)(a1 + 56);
    if (v13 >= 8)
    {
      unint64_t v16 = 0;
      unint64_t v17 = v15 + 4 * v13;
      BOOL v18 = v15 >= a1 + 28 || (unint64_t)v14 >= v17;
      char v19 = !v18;
      BOOL v20 = v12 >= v17 || v15 >= v12 + 4 * v13;
      if (v20 && (v19 & 1) == 0)
      {
        uint64_t v21 = 0;
        unint64_t v16 = v13 & 0xFFFFFFFFFFFFFFF8;
        uint32x4_t v22 = (uint32x4_t)vld1q_dup_f32(v14);
        unint64_t v23 = v13 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          uint64_t v24 = (int8x16_t *)(v15 + v21);
          int8x16_t v25 = vbicq_s8(*(int8x16_t *)(v12 + v21 + 16), (int8x16_t)vcgtq_u32(*(uint32x4_t *)(v12 + v21 + 16), v22));
          *uint64_t v24 = vbicq_s8(*(int8x16_t *)(v12 + v21), (int8x16_t)vcgtq_u32(*(uint32x4_t *)(v12 + v21), v22));
          v24[1] = v25;
          v21 += 32;
          v23 -= 8;
        }
        while (v23);
        goto LABEL_29;
      }
    }
    else
    {
      unint64_t v16 = 0;
    }
    do
    {
      unsigned int v26 = *(_DWORD *)(v12 + 4 * v16);
      if (v26 > *(_DWORD *)v14) {
        unsigned int v26 = 0;
      }
      *(_DWORD *)(v15 + 4 * v16++) = v26;
LABEL_29:
      ;
    }
    while (v13 != v16);
  }
  else
  {
    unint64_t v15 = *(void *)(a1 + 56);
  }
  if (*(_DWORD *)(a1 + 24) >= a2) {
    unsigned int v27 = a2;
  }
  else {
    unsigned int v27 = 0;
  }
  *(_DWORD *)(v15 + 4 * v13) = v27;
  double v28 = *(_DWORD **)(a1 + 416);
  uint64_t v29 = *(void *)(a1 + 440);
  BOOL v18 = __CFADD__(v13, 1);
  unint64_t v30 = v13 + 1;
  unint64_t v54 = v30;
  if (v18)
  {
    uint64_t v31 = *(int **)(a1 + 440);
    uint64_t v32 = *(void *)(a1 + 416);
    unint64_t v35 = v31;
    goto LABEL_47;
  }
  unint64_t v51 = v10;
  uint64_t v33 = a1 + 304;
  unint64_t v34 = v30;
  unint64_t v35 = *(int **)(a1 + 440);
  do
  {
    uint64_t v36 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, int *, uint64_t))(*(void *)v33 + 24))(a1 + 304, v15, 1, &dword_1E945A238, 3);
    if (v36 == 3)
    {
      *v28++ = dword_1E945A238;
      if (v35)
      {
        unint64_t v37 = &dword_1E945A240;
        if (v34 == 1) {
          *v35++ = dword_1E945A23C;
        }
        goto LABEL_37;
      }
    }
    else if (v36 == 1)
    {
      *v28++ = dword_1E945A238;
      if (v35)
      {
        unint64_t v37 = &dword_1E945A238;
LABEL_37:
        *v35++ = *v37;
      }
    }
    v15 += 4;
    --v34;
  }
  while (v34);
  uint64_t v32 = *(void *)(a1 + 416);
  uint64_t v31 = *(int **)(a1 + 440);
  unint64_t v6 = a6;
  unint64_t v7 = a5;
  unint64_t v10 = v51;
LABEL_47:
  unint64_t v38 = ((uint64_t)v28 - v32) >> 2;
  if (v38 >= v9) {
    unint64_t v39 = v38 - v9;
  }
  else {
    unint64_t v39 = 0;
  }
  if (v9 >= v38) {
    unint64_t v40 = v38;
  }
  else {
    unint64_t v40 = v9;
  }
  double v41 = sub_19E4FB818(a1, (unsigned int *)(v32 + 4 * v39), v40, v6, 1, *(double *)(a1 + 32));
  unsigned int v42 = *(_DWORD *)(*(void *)(a1 + 416) + 4 * (v40 + v39) - 4);
  if (*(_DWORD *)(a1 + 336) <= v42 && *(_DWORD *)(a1 + 340) >= v42
    || *(_DWORD *)(a1 + 344) <= v42 && *(_DWORD *)(a1 + 348) >= v42)
  {
    unint64_t v43 = v35 - v31;
    uint64_t v44 = (char *)v35 - (char *)v31 - 4 * v10;
    if (v43 >= v10) {
      unint64_t v45 = v10;
    }
    else {
      unint64_t v45 = v35 - v31;
    }
    if (v43 <= v10) {
      uint64_t v44 = 0;
    }
    double v46 = sub_19E4FB818(a1 + 152, (unsigned int *)(v29 + v44), v45, 0, 0, *(double *)(a1 + 32)) + v41;
    double v47 = sub_19E4FB818(a1, *(unsigned int **)(a1 + 56), v54, v6, 1, *(double *)(a1 + 32));
    double v48 = __exp10(v46);
    double v49 = __exp10(v47);
    double v41 = log10(v49 + v48);
  }
  *unint64_t v7 = v41;
  return 1;
}

void sub_19E457FBC(void *a1)
{
  sub_19E457FF4(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E457FF4(void *a1)
{
  *a1 = &unk_1EF0BA1B8;
  uint64_t v2 = (void *)a1[55];
  if (v2)
  {
    a1[56] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[52];
  if (v3)
  {
    a1[53] = v3;
    operator delete(v3);
  }
  a1[38] = &unk_1EF0BB518;
  uint64_t v4 = (void *)a1[45];
  if (v4)
  {
    a1[46] = v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)a1[39];
  if (v5) {
    munmap(v5, a1[40]);
  }
  a1[40] = 0;
  sub_19E4580B4(a1 + 19);
  return sub_19E4580B4(a1);
}

void *sub_19E4580B4(void *a1)
{
  *a1 = &unk_1EF0B9A00;
  uint64_t v2 = (void *)a1[14];
  if (v2) {
    munmap(v2, a1[15]);
  }
  a1[15] = 0;
  uint64_t v3 = a1[13];
  a1[13] = 0;
  if (v3)
  {
    uint64_t v4 = *(void **)v3;
    if (*(void *)v3)
    {
      *(void *)(v3 + 8) = v4;
      operator delete(v4);
    }
    MEMORY[0x19F3BDCF0](v3, 0x1080C409A65DFB4);
  }
  uint64_t v5 = a1[12];
  a1[12] = 0;
  if (v5)
  {
    unint64_t v6 = *(void **)v5;
    if (*(void *)v5)
    {
      *(void *)(v5 + 8) = v6;
      operator delete(v6);
    }
    MEMORY[0x19F3BDCF0](v5, 0x1080C409A65DFB4);
  }
  uint64_t v7 = a1[11];
  a1[11] = 0;
  if (v7)
  {
    unint64_t v8 = *(void **)(v7 + 24);
    if (v8)
    {
      *(void *)(v7 + 32) = v8;
      operator delete(v8);
    }
    unint64_t v9 = *(void **)v7;
    if (*(void *)v7)
    {
      *(void *)(v7 + 8) = v9;
      operator delete(v9);
    }
    MEMORY[0x19F3BDCF0](v7, 0x30C400D66AB62);
  }
  unint64_t v10 = (uint64_t *)a1[10];
  a1[10] = 0;
  if (v10)
  {
    uint64_t v11 = *v10;
    if (*v10)
    {
      uint64_t v12 = *(void *)(v11 + 24);
      if (v12)
      {
        sub_19E4AB828(v12 + 8);
        MEMORY[0x19F3BDCF0](v12, 0x1020C403F824CD1);
        if (*(void *)v11) {
          free(*(void **)v11);
        }
      }
      MEMORY[0x19F3BDCF0](v11, 0x1030C40FC63861FLL);
    }
    MEMORY[0x19F3BDCF0](v10, 0x20C4093837F09);
  }
  unint64_t v13 = (void *)a1[7];
  if (v13)
  {
    a1[8] = v13;
    operator delete(v13);
  }
  return a1;
}

void *sub_19E45824C(void *a1)
{
  *a1 = &unk_1EF0BB518;
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3) {
    munmap(v3, a1[2]);
  }
  a1[2] = 0;
  return a1;
}

uint64_t sub_19E4582B4(uint64_t a1, void *a2, _DWORD *a3)
{
  if (*(void *)(a1 + 8) == *(void *)(a1 + 16)) {
    __assert_rtn("getToken", "LMLexiconCursorImpl.cpp", 71, "!m_entries.empty()");
  }
  if (a2)
  {
    LXEntryGetProbability();
    *a2 = v6;
  }
  if (a3) {
    *a3 = *(_DWORD *)(a1 + 152);
  }
  uint64_t result = **(void **)(a1 + 8);
  if (result)
  {
    LODWORD(result) = LXEntryGetTokenID();
    if (result) {
      return result;
    }
    else {
      return 500;
    }
  }
  return result;
}

BOOL sub_19E458348(void *a1)
{
  uint64_t v2 = (CFTypeRef *)a1[1];
  uint64_t v3 = (uint64_t)(a1 + 1);
  if (v2 != (CFTypeRef *)a1[2])
  {
    CFRelease(*v2);
    sub_19E4584EC(v3);
  }
  for (uint64_t i = (const void **)a1[8]; i != (const void **)a1[9]; uint64_t i = (const void **)a1[8])
  {
    if (a1[1] != a1[2])
    {
      LXEntryGetProbability();
      double v6 = v5;
      LXCursorPrefixProbability();
      if (v6 >= v7) {
        return a1[1] != a1[2];
      }
      uint64_t i = (const void **)a1[8];
    }
    unint64_t v8 = *i;
    sub_19E458820((uint64_t)(a1 + 8));
    LXCursorEnumerateEntries();
    LXCursorEnumerateChildren();
    if (v8) {
      CFRelease(v8);
    }
  }
  return a1[1] != a1[2];
}

void sub_19E4584D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  sub_19E421014((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E4584EC(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    if (v4 == a1 + 24)
    {
      double v28 = v27;
      (*(void (**)(uint64_t, void *))(*(void *)v4 + 24))(v4, v27);
    }
    else
    {
      double v28 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
    }
  }
  else
  {
    double v28 = 0;
  }
  uint64_t v5 = v3 - (void)v2;
  if (v3 - (uint64_t)v2 >= 9)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v5 >> 3;
    uint64_t v24 = *v2;
    int64_t v8 = (unint64_t)((v5 >> 3) - 2) >> 1;
    unint64_t v9 = v2;
    do
    {
      unint64_t v10 = &v9[v6 + 1];
      uint64_t v11 = (2 * v6) | 1;
      uint64_t v12 = 2 * v6 + 2;
      if (v12 < v7)
      {
        uint64_t v13 = *v10;
        uint64_t v25 = v10[1];
        uint64_t v26 = v13;
        if (!v28) {
          goto LABEL_29;
        }
        if ((*(unsigned int (**)(void *, uint64_t *, uint64_t *))(*v28 + 48))(v28, &v26, &v25))
        {
          ++v10;
          uint64_t v11 = v12;
        }
      }
      *unint64_t v9 = *v10;
      unint64_t v9 = v10;
      uint64_t v6 = v11;
    }
    while (v11 <= v8);
    unint64_t v15 = (void *)(v3 - 8);
    if (v10 == (void *)(v3 - 8))
    {
      *unint64_t v10 = v24;
    }
    else
    {
      *unint64_t v10 = *v15;
      *unint64_t v15 = v24;
      uint64_t v16 = (char *)v10 - (char *)v2 + 8;
      if (v16 >= 9)
      {
        unint64_t v17 = (((unint64_t)v16 >> 3) - 2) >> 1;
        BOOL v18 = &v2[v17];
        uint64_t v19 = *v18;
        uint64_t v25 = *v10;
        uint64_t v26 = v19;
        if (!v28) {
LABEL_29:
        }
          sub_19E3ACB9C();
        if ((*(unsigned int (**)(void *, uint64_t *, uint64_t *))(*v28 + 48))(v28, &v26, &v25))
        {
          uint64_t v20 = *v10;
          do
          {
            uint64_t v21 = v18;
            *unint64_t v10 = *v18;
            if (!v17) {
              break;
            }
            unint64_t v17 = (v17 - 1) >> 1;
            BOOL v18 = &v2[v17];
            uint64_t v22 = *v18;
            uint64_t v25 = v20;
            uint64_t v26 = v22;
            if (!v28) {
              goto LABEL_29;
            }
            unint64_t v10 = v21;
          }
          while (((*(uint64_t (**)(void *, uint64_t *, uint64_t *))(*v28 + 48))(v28, &v26, &v25) & 1) != 0);
          void *v21 = v20;
        }
      }
    }
  }
  uint64_t result = (uint64_t)v28;
  if (v28 == v27)
  {
    uint64_t result = (*(uint64_t (**)(void *))(v27[0] + 32))(v27);
  }
  else if (v28)
  {
    uint64_t result = (*(uint64_t (**)(void))(*v28 + 40))();
  }
  *(void *)(a1 + 8) -= 8;
  return result;
}

void sub_19E458804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E45933C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E458820(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    if (v4 == a1 + 24)
    {
      double v28 = v27;
      (*(void (**)(uint64_t, void *))(*(void *)v4 + 24))(v4, v27);
    }
    else
    {
      double v28 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
    }
  }
  else
  {
    double v28 = 0;
  }
  uint64_t v5 = v3 - (void)v2;
  if (v3 - (uint64_t)v2 >= 9)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v5 >> 3;
    uint64_t v24 = *v2;
    int64_t v8 = (unint64_t)((v5 >> 3) - 2) >> 1;
    unint64_t v9 = v2;
    do
    {
      unint64_t v10 = &v9[v6 + 1];
      uint64_t v11 = (2 * v6) | 1;
      uint64_t v12 = 2 * v6 + 2;
      if (v12 < v7)
      {
        uint64_t v13 = *v10;
        uint64_t v25 = v10[1];
        uint64_t v26 = v13;
        if (!v28) {
          goto LABEL_29;
        }
        if ((*(unsigned int (**)(void *, uint64_t *, uint64_t *))(*v28 + 48))(v28, &v26, &v25))
        {
          ++v10;
          uint64_t v11 = v12;
        }
      }
      *unint64_t v9 = *v10;
      unint64_t v9 = v10;
      uint64_t v6 = v11;
    }
    while (v11 <= v8);
    unint64_t v15 = (void *)(v3 - 8);
    if (v10 == (void *)(v3 - 8))
    {
      *unint64_t v10 = v24;
    }
    else
    {
      *unint64_t v10 = *v15;
      *unint64_t v15 = v24;
      uint64_t v16 = (char *)v10 - (char *)v2 + 8;
      if (v16 >= 9)
      {
        unint64_t v17 = (((unint64_t)v16 >> 3) - 2) >> 1;
        BOOL v18 = &v2[v17];
        uint64_t v19 = *v18;
        uint64_t v25 = *v10;
        uint64_t v26 = v19;
        if (!v28) {
LABEL_29:
        }
          sub_19E3ACB9C();
        if ((*(unsigned int (**)(void *, uint64_t *, uint64_t *))(*v28 + 48))(v28, &v26, &v25))
        {
          uint64_t v20 = *v10;
          do
          {
            uint64_t v21 = v18;
            *unint64_t v10 = *v18;
            if (!v17) {
              break;
            }
            unint64_t v17 = (v17 - 1) >> 1;
            BOOL v18 = &v2[v17];
            uint64_t v22 = *v18;
            uint64_t v25 = v20;
            uint64_t v26 = v22;
            if (!v28) {
              goto LABEL_29;
            }
            unint64_t v10 = v21;
          }
          while (((*(uint64_t (**)(void *, uint64_t *, uint64_t *))(*v28 + 48))(v28, &v26, &v25) & 1) != 0);
          void *v21 = v20;
        }
      }
    }
  }
  uint64_t result = (uint64_t)v28;
  if (v28 == v27)
  {
    uint64_t result = (*(uint64_t (**)(void *))(v27[0] + 32))(v27);
  }
  else if (v28)
  {
    uint64_t result = (*(uint64_t (**)(void))(*v28 + 40))();
  }
  *(void *)(a1 + 8) -= 8;
  return result;
}

void sub_19E458B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E4592B8((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E458B54(uint64_t a1, const void *a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(a1 + 32);
  v38[0] = a2;
  uint64_t v3 = v2[18];
  if (!v3) {
    sub_19E3ACB9C();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 48))(v3, v38);
  if (result)
  {
    CFTypeRef v6 = CFRetain(a2);
    CFTypeRef v7 = v6;
    unint64_t v9 = (char *)v2[2];
    unint64_t v8 = v2[3];
    if ((unint64_t)v9 >= v8)
    {
      uint64_t v11 = (char *)v2[1];
      uint64_t v12 = (v9 - v11) >> 3;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        sub_19E37C7C4();
      }
      uint64_t v14 = v8 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
          sub_19E37C2B8();
        }
        uint64_t v16 = operator new(8 * v15);
      }
      else
      {
        uint64_t v16 = 0;
      }
      unint64_t v17 = &v16[8 * v12];
      BOOL v18 = &v16[8 * v15];
      *unint64_t v17 = v7;
      unint64_t v10 = v17 + 1;
      if (v9 == v11)
      {
        uint64_t v11 = v9;
      }
      else
      {
        unint64_t v19 = v9 - v11 - 8;
        if (v19 < 0x58) {
          goto LABEL_50;
        }
        if ((unint64_t)(v11 - v16) < 0x20) {
          goto LABEL_50;
        }
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = &v16[8 * v12 - 16];
        uint64_t v22 = v9 - 16;
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *(_OWORD *)v22;
          *(v21 - 1) = *((_OWORD *)v22 - 1);
          _OWORD *v21 = v24;
          v21 -= 2;
          v22 -= 32;
          v23 -= 4;
        }
        while (v23);
        v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
        v9 -= 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
        if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_50:
          do
          {
            uint64_t v25 = *((void *)v9 - 1);
            v9 -= 8;
            *--unint64_t v17 = v25;
          }
          while (v9 != v11);
          uint64_t v11 = (char *)v2[1];
        }
      }
      v2[1] = v17;
      uint64_t v2[2] = v10;
      v2[3] = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *(void *)unint64_t v9 = v6;
      unint64_t v10 = v9 + 8;
    }
    uint64_t v2[2] = v10;
    uint64_t v26 = v2[1];
    unsigned int v27 = (void *)v2[7];
    if (v27)
    {
      if (v27 == v2 + 4)
      {
        unint64_t v39 = v38;
        (*(void (**)(void *, void *))(*v27 + 24))(v27, v38);
      }
      else
      {
        unint64_t v39 = (void *)(*(uint64_t (**)(void *))(*v27 + 16))(v27);
      }
    }
    else
    {
      unint64_t v39 = 0;
    }
    if ((uint64_t)v10 - v26 >= 9)
    {
      unint64_t v28 = ((((unint64_t)v10 - v26) >> 3) - 2) >> 1;
      uint64_t v29 = (uint64_t *)(v26 + 8 * v28);
      uint64_t v30 = *v29;
      uint64_t v32 = *(v10 - 1);
      uint64_t v31 = v10 - 1;
      uint64_t v36 = v32;
      uint64_t v37 = v30;
      if (!v39) {
LABEL_44:
      }
        sub_19E3ACB9C();
      if ((*(unsigned int (**)(void *, uint64_t *, uint64_t *))(*v39 + 48))(v39, &v37, &v36))
      {
        uint64_t v33 = *v31;
        do
        {
          unint64_t v34 = v29;
          *uint64_t v31 = *v29;
          if (!v28) {
            break;
          }
          unint64_t v28 = (v28 - 1) >> 1;
          uint64_t v29 = (uint64_t *)(v26 + 8 * v28);
          uint64_t v35 = *v29;
          uint64_t v36 = v33;
          uint64_t v37 = v35;
          if (!v39) {
            goto LABEL_44;
          }
          uint64_t v31 = v34;
        }
        while (((*(uint64_t (**)(void *, uint64_t *, uint64_t *))(*v39 + 48))(v39, &v37, &v36) & 1) != 0);
        *unint64_t v34 = v33;
      }
    }
    uint64_t result = (uint64_t)v39;
    if (v39 == v38)
    {
      return (*(uint64_t (**)(void *))(v38[0] + 32))(v38);
    }
    else if (v39)
    {
      return (*(uint64_t (**)(void))(*v39 + 40))();
    }
  }
  return result;
}

void sub_19E458EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E45933C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E458F0C(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = *(void *)(a1 + 32) + 64;
  CFTypeRef v3 = CFRetain(cf);
  return sub_19E458F50(v2, (uint64_t)v3);
}

uint64_t sub_19E458F50(uint64_t a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  CFTypeRef v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v8 = *(unsigned char **)a1;
    uint64_t v9 = (uint64_t)v5 - *(void *)a1;
    uint64_t v10 = v9 >> 3;
    unint64_t v11 = (v9 >> 3) + 1;
    if (v11 >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v12 = v4 - (void)v8;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 >> 61) {
        sub_19E37C2B8();
      }
      uint64_t v14 = operator new(8 * v13);
    }
    else
    {
      uint64_t v14 = 0;
    }
    unint64_t v15 = &v14[8 * v10];
    uint64_t v16 = &v14[8 * v13];
    *unint64_t v15 = a2;
    CFTypeRef v7 = (char *)(v15 + 1);
    if (v5 == (void *)v8)
    {
      unint64_t v8 = v5;
    }
    else
    {
      unint64_t v17 = (char *)v5 - v8 - 8;
      if (v17 < 0x58) {
        goto LABEL_47;
      }
      if ((unint64_t)((char *)v5 - v14 - v9) < 0x20) {
        goto LABEL_47;
      }
      uint64_t v18 = (v17 >> 3) + 1;
      CFTypeRef v6 = &v5[-(v18 & 0x3FFFFFFFFFFFFFFCLL)];
      unint64_t v19 = &v14[8 * v10 - 16];
      uint64_t v20 = (long long *)(v5 - 2);
      uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *v20;
        *(v19 - 1) = *(v20 - 1);
        _OWORD *v19 = v22;
        v19 -= 2;
        v20 -= 2;
        v21 -= 4;
      }
      while (v21);
      v15 -= v18 & 0x3FFFFFFFFFFFFFFCLL;
      if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_47:
        do
        {
          uint64_t v23 = *--v6;
          *--unint64_t v15 = v23;
        }
        while (v6 != (void *)v8);
        unint64_t v8 = *(unsigned char **)a1;
      }
    }
    *(void *)a1 = v15;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *uint64_t v5 = a2;
    CFTypeRef v7 = (char *)(v5 + 1);
  }
  *(void *)(a1 + 8) = v7;
  long long v24 = *(unsigned char **)a1;
  uint64_t v25 = *(void *)(a1 + 48);
  if (v25)
  {
    if (v25 == a1 + 24)
    {
      unint64_t v38 = v37;
      (*(void (**)(uint64_t, void *))(*(void *)v25 + 24))(v25, v37);
    }
    else
    {
      unint64_t v38 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v25 + 16))(v25);
    }
  }
  else
  {
    unint64_t v38 = 0;
  }
  if (v7 - v24 >= 9)
  {
    unint64_t v26 = (((unint64_t)(v7 - v24) >> 3) - 2) >> 1;
    unsigned int v27 = &v24[8 * v26];
    uint64_t v28 = *(void *)v27;
    uint64_t v30 = *((void *)v7 - 1);
    uint64_t v29 = v7 - 8;
    uint64_t v35 = v30;
    uint64_t v36 = v28;
    if (!v38) {
LABEL_42:
    }
      sub_19E3ACB9C();
    if ((*(unsigned int (**)(void *, uint64_t *, uint64_t *))(*v38 + 48))(v38, &v36, &v35))
    {
      uint64_t v31 = *(void *)v29;
      do
      {
        uint64_t v32 = v27;
        *(void *)uint64_t v29 = *(void *)v27;
        if (!v26) {
          break;
        }
        unint64_t v26 = (v26 - 1) >> 1;
        unsigned int v27 = &v24[8 * v26];
        uint64_t v33 = *(void *)v27;
        uint64_t v35 = v31;
        uint64_t v36 = v33;
        if (!v38) {
          goto LABEL_42;
        }
        uint64_t v29 = v32;
      }
      while (((*(uint64_t (**)(void *, uint64_t *, uint64_t *))(*v38 + 48))(v38, &v36, &v35) & 1) != 0);
      *(void *)uint64_t v32 = v31;
    }
  }
  uint64_t result = (uint64_t)v38;
  if (v38 == v37) {
    return (*(uint64_t (**)(void *))(v37[0] + 32))(v37);
  }
  if (v38) {
    return (*(uint64_t (**)(void))(*v38 + 40))();
  }
  return result;
}

void sub_19E4592A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E4592B8((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_19E4592B8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E45933C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_19E4593C0(void *a1)
{
  sub_19E4593F8(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4593F8(void *a1)
{
  *a1 = &unk_1EF0BA718;
  for (uint64_t i = (void **)(a1 + 1); ; sub_19E4584EC((uint64_t)i))
  {
    CFTypeRef v3 = (CFTypeRef *)a1[1];
    if (v3 == (CFTypeRef *)a1[2]) {
      break;
    }
    CFRelease(*v3);
  }
  unint64_t v4 = (void **)(a1 + 8);
  while (1)
  {
    uint64_t v5 = (CFTypeRef *)a1[8];
    if (v5 == (CFTypeRef *)a1[9]) {
      break;
    }
    CFRelease(*v5);
    sub_19E458820((uint64_t)(a1 + 8));
  }
  CFTypeRef v6 = (void *)a1[18];
  if (v6 == a1 + 15)
  {
    (*(void (**)(void *))(a1[15] + 32))(a1 + 15);
  }
  else if (v6)
  {
    (*(void (**)(void *))(*v6 + 40))(v6);
  }
  CFTypeRef v7 = (void *)a1[14];
  if (v7 == a1 + 11)
  {
    (*(void (**)(void *))(a1[11] + 32))(a1 + 11);
    unint64_t v8 = *v4;
    if (*v4)
    {
LABEL_15:
      a1[9] = v8;
      operator delete(v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(void *))(*v7 + 40))(v7);
    }
    unint64_t v8 = *v4;
    if (*v4) {
      goto LABEL_15;
    }
  }
  uint64_t v9 = (void *)a1[7];
  if (v9 == a1 + 4)
  {
    (*(void (**)(void *))(a1[4] + 32))(a1 + 4);
    uint64_t v10 = *i;
    if (!*i) {
      return a1;
    }
    goto LABEL_20;
  }
  if (v9) {
    (*(void (**)(void *))(*v9 + 40))(v9);
  }
  uint64_t v10 = *i;
  if (*i)
  {
LABEL_20:
    a1[2] = v10;
    operator delete(v10);
  }
  return a1;
}

void *sub_19E4595F0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E459674()
{
  return &unk_1EF0B80E8;
}

uint64_t sub_19E459680(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN2LM17LexiconCursorImplC1EPK9_LXCursorNSt3__18functionIFbPK8_LXEntryEEENS_11TokenSourceEE3$_1"
    || ((v3 & (unint64_t)"ZN2LM17LexiconCursorImplC1EPK9_LXCursorNSt3__18functionIFbPK8_LXEntryEEENS_11TokenSourceEE3$_1" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN2LM17LexiconCursorImplC1EPK9_LXCursorNSt3__18functionIFbPK8_LXEntryEEENS_11TokenSourceEE3$_1")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN2LM17LexiconCursorImplC1EPK9_LXCursorNSt3__18functionIFbPK8_LXEntryEEENS_11TokenSourceEE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

BOOL sub_19E4596D8()
{
  LXCursorPrefixProbability();
  double v1 = v0;
  LXCursorPrefixProbability();
  return v1 < v2;
}

void sub_19E459724(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF0BD770;
}

void *sub_19E459744()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF0BD770;
  return result;
}

void sub_19E45977C()
{
}

void *sub_19E459794()
{
  return &unk_1EF0B80D8;
}

uint64_t sub_19E4597A0(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN2LM17LexiconCursorImplC1EPK9_LXCursorNSt3__18functionIFbPK8_LXEntryEEENS_11TokenSourceEE3$_0"
    || ((v3 & (unint64_t)"ZN2LM17LexiconCursorImplC1EPK9_LXCursorNSt3__18functionIFbPK8_LXEntryEEENS_11TokenSourceEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN2LM17LexiconCursorImplC1EPK9_LXCursorNSt3__18functionIFbPK8_LXEntryEEENS_11TokenSourceEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN2LM17LexiconCursorImplC1EPK9_LXCursorNSt3__18functionIFbPK8_LXEntryEEENS_11TokenSourceEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

BOOL sub_19E4597F8()
{
  LXEntryGetProbability();
  double v1 = v0;
  LXEntryGetProbability();
  return v1 < v2;
}

void sub_19E459844(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF0BD718;
}

void *sub_19E459864()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF0BD718;
  return result;
}

void sub_19E45989C()
{
}

uint64_t sub_19E4598B4(uint64_t a1, CFTypeRef cf, uint64_t a3, int a4)
{
  *(void *)a1 = &unk_1EF0BA718;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = a1 + 32;
  *(void *)(a1 + 32) = &unk_1EF0BD718;
  *(void *)(a1 + 64) = 0;
  uint64_t v7 = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 112) = a1 + 88;
  *(void *)(a1 + 88) = &unk_1EF0BD770;
  uint64_t v8 = a1 + 120;
  uint64_t v9 = *(void *)(a3 + 24);
  if (!v9) {
    goto LABEL_4;
  }
  if (v9 != a3)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
LABEL_4:
    *(void *)(a1 + 144) = v9;
    goto LABEL_6;
  }
  *(void *)(a1 + 144) = v8;
  (*(void (**)(void, uint64_t))(**(void **)(a3 + 24) + 24))(*(void *)(a3 + 24), v8);
LABEL_6:
  *(_DWORD *)(a1 + 152) = a4;
  if (cf)
  {
    CFTypeRef v10 = CFRetain(cf);
    sub_19E458F50(v7, (uint64_t)v10);
  }
  return a1;
}

void sub_19E459A00(_Unwind_Exception *a1)
{
  uint64_t v7 = v1[14];
  if (v7 == v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  else if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
  }
  uint64_t v8 = *v3;
  if (*v3)
  {
    v1[9] = v8;
    operator delete(v8);
  }
  uint64_t v9 = v1[7];
  if (v9 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
    CFTypeRef v10 = *v5;
    if (*v5)
    {
LABEL_14:
      v1[2] = v10;
      operator delete(v10);
      _Unwind_Resume(a1);
    }
  }
  else if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 40))(v9);
    CFTypeRef v10 = *v5;
    if (*v5) {
      goto LABEL_14;
    }
  }
  else
  {
    CFTypeRef v10 = *v5;
    if (*v5) {
      goto LABEL_14;
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E459B70(uint64_t *a1, unint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5, char a6)
{
  BOOL v6 = a4 > a2;
  if (a4 == a2) {
    return;
  }
  unint64_t v8 = a4;
  uint64_t v10 = a2;
  while (1)
  {
    uint64_t v12 = 102 * (a3 - a1);
    uint64_t v13 = *a3;
    uint64_t v14 = v8 - *a3;
    uint64_t v15 = v14 / 40;
    uint64_t v16 = *a1;
    uint64_t v17 = v10 - *a1;
    uint64_t v18 = v14 / 40 + v12 + 0x3333333333333333 * (v17 >> 3);
    if (!v6) {
      break;
    }
    uint64_t v371 = v10;
    if (v18 <= 23)
    {
      if (a6)
      {
        if (v10 != v8)
        {
          for (uint64_t i = v10 + 40; ; i += 40)
          {
            if (i - v16 == 4080)
            {
              uint64_t v217 = a1[1];
              ++a1;
              uint64_t v16 = v217;
              uint64_t i = v217;
            }
            if (i == v8) {
              break;
            }
            uint64_t v218 = (void ***)a1;
            uint64_t v219 = i;
            if (i == v16)
            {
              uint64_t v218 = (void ***)(a1 - 1);
              uint64_t v219 = *(a1 - 1) + 4080;
            }
            double v220 = *(double *)(i + 32);
            if (v220 < *(double *)(v219 - 8))
            {
              v221 = *(void **)i;
              *(void *)v379 = *(void *)(i + 8);
              *(void *)&v379[7] = *(void *)(i + 15);
              char v222 = *(unsigned char *)(i + 23);
              *(void *)(i + 8) = 0;
              *(void *)(i + 16) = 0;
              *(void *)uint64_t i = 0;
              uint64_t v223 = *(void *)(i + 24);
              uint64_t v224 = i;
              while (1)
              {
                uint64_t v226 = v219;
                if (*(char *)(v224 + 23) < 0) {
                  operator delete(*(void **)v224);
                }
                uint64_t v227 = (void **)(v226 - 40);
                long long v228 = *(_OWORD *)(v226 - 40);
                *(void *)(v224 + 16) = *(void *)(v226 - 24);
                *(_OWORD *)uint64_t v224 = v228;
                *(unsigned char *)(v226 - 17) = 0;
                *(unsigned char *)(v226 - 40) = 0;
                *(_OWORD *)(v224 + 24) = *(_OWORD *)(v226 - 16);
                if (v226 - 40 == v371) {
                  break;
                }
                if (v227 == *v218)
                {
                  uint64_t v225 = (uint64_t)*--v218;
                  uint64_t v219 = v225 + 4080;
                }
                else
                {
                  uint64_t v219 = v226 - 40;
                }
                uint64_t v224 = v226 - 40;
                if (v220 >= *(double *)(v219 - 8)) {
                  goto LABEL_203;
                }
              }
              uint64_t v227 = (void **)v371;
LABEL_203:
              if (*(char *)(v226 - 17) < 0) {
                operator delete(*v227);
              }
              uint64_t *v227 = v221;
              *(void *)(v226 - 25) = *(void *)&v379[7];
              *(void *)(v226 - 32) = *(void *)v379;
              *(unsigned char *)(v226 - 17) = v222;
              *(void *)(v226 - 16) = v223;
              *(double *)(v226 - 8) = v220;
              uint64_t v16 = *a1;
            }
          }
        }
      }
      else if (v10 != v8)
      {
        uint64_t v327 = v17 / 40;
        if (v17 >= -39)
        {
          unint64_t v328 = v327 + 1;
          unint64_t v333 = &a1[(v327 + 1) / 0x66uLL];
          v334 = (char *)*v333;
          unint64_t v335 = v328 % 0x66;
        }
        else
        {
          unint64_t v332 = 100 - v327;
          unint64_t v333 = &a1[-((100 - v327) / 0x66uLL)];
          v334 = (char *)*v333;
          unint64_t v335 = 101 - v332 % 0x66;
        }
        v336 = (uint64_t *)&v334[40 * v335];
        while (v336 != (uint64_t *)v8)
        {
          uint64_t v337 = ((char *)v336 - v334) / 40;
          if ((char *)v336 - v334 >= 41)
          {
            unint64_t v338 = v337 - 1;
            v340 = &v333[v338 / 0x66];
            uint64_t v341 = *v340;
            unint64_t v342 = v338 % 0x66;
          }
          else
          {
            unint64_t v339 = 102 - v337;
            v340 = &v333[-(v339 / 0x66)];
            uint64_t v341 = *v340;
            unint64_t v342 = 101 - v339 % 0x66;
          }
          uint64_t v343 = (double *)(v341 + 40 * v342);
          double v344 = *((double *)v336 + 4);
          if (v344 < v343[4])
          {
            unint64_t v345 = v8;
            uint64_t v346 = *v336;
            *(void *)v382 = v336[1];
            *(void *)&v382[7] = *(uint64_t *)((char *)v336 + 15);
            char v347 = *((unsigned char *)v336 + 23);
            v336[1] = 0;
            v336[2] = 0;
            uint64_t *v336 = 0;
            uint64_t v348 = v336[3];
            v349 = (long long *)v336;
            do
            {
              size_t v352 = (long long *)v343;
              if (*((char *)v349 + 23) < 0) {
                operator delete(*(void **)v349);
              }
              long long v353 = *v352;
              *((void *)v349 + 2) = *((void *)v352 + 2);
              long long *v349 = v353;
              *((unsigned char *)v352 + 23) = 0;
              *(unsigned char *)size_t v352 = 0;
              *(long long *)((char *)v349 + 24) = *(long long *)((char *)v352 + 24);
              if (v352 == (long long *)*v340)
              {
                uint64_t v350 = *--v340;
                v351 = (double *)(v350 + 4080);
              }
              else
              {
                v351 = (double *)v352;
              }
              uint64_t v343 = v351 - 5;
              v349 = v352;
            }
            while (v344 < *(v351 - 1));
            if (*((char *)v352 + 23) < 0) {
              operator delete(*(void **)v352);
            }
            *(void *)size_t v352 = v346;
            *((void *)v352 + 1) = *(void *)v382;
            *(void *)((char *)v352 + 15) = *(void *)&v382[7];
            *((unsigned char *)v352 + 23) = v347;
            *((void *)v352 + 3) = v348;
            *((double *)v352 + 4) = v344;
            v334 = (char *)*v333;
            unint64_t v8 = v345;
          }
          v336 += 5;
          if ((char *)v336 - v334 == 4080)
          {
            v354 = (char *)v333[1];
            ++v333;
            v334 = v354;
            v336 = (uint64_t *)v354;
          }
        }
      }
      return;
    }
    v369 = a3;
    if (!a5)
    {
      if (v10 == v8) {
        return;
      }
      int64_t v229 = (unint64_t)(v18 - 2) >> 1;
      int64_t v230 = v229;
      unint64_t v355 = v8;
      while (2)
      {
        uint64_t v232 = (v10 - *a1) >> 3;
        unint64_t v233 = 0xCCCCCCCCCCCCCCCDLL * v232;
        if (!v230) {
          goto LABEL_218;
        }
        unint64_t v234 = v233 + v230;
        if ((uint64_t)(v233 + v230) >= 1)
        {
          unint64_t v236 = &a1[v234 / 0x66];
          uint64_t v237 = *v236;
          unint64_t v238 = v234 % 0x66;
        }
        else
        {
          unint64_t v235 = 101 - v234;
          unint64_t v236 = &a1[-(v235 / 0x66)];
          uint64_t v237 = *v236;
          unint64_t v238 = 101 - v235 % 0x66;
        }
        uint64_t v239 = v237 + 40 * v238;
        if (v239 == v10)
        {
LABEL_218:
          uint64_t v240 = 0;
          uint64_t v239 = v10;
          goto LABEL_219;
        }
        uint64_t v240 = 102 * (v236 - a1) - 0x3333333333333333 * ((uint64_t)(40 * v238) >> 3) + 0x3333333333333333 * v232;
        if (v229 >= v240)
        {
LABEL_219:
          uint64_t v241 = (2 * v240) | 1;
          uint64_t v242 = v233 + v241;
          if (v242 >= 1)
          {
            double v244 = &a1[v242 / 0x66uLL];
            uint64_t v245 = *v244;
            unint64_t v246 = v242 % 0x66uLL;
          }
          else
          {
            unint64_t v243 = 101 - v242;
            double v244 = &a1[-(v243 / 0x66)];
            uint64_t v245 = *v244;
            unint64_t v246 = 101 - v243 % 0x66;
          }
          uint64_t v247 = v245 + 40 * v246;
          uint64_t v248 = 2 * v240 + 2;
          if (v248 >= v18
            || ((uint64_t v249 = (v247 - v245) / 40, v247 - v245 >= -39)
              ? (v250 = v249 + 1, uint64_t v252 = v244[v250 / 0x66], v253 = v250 % 0x66)
              : (v251 = 100 - v249, uint64_t v252 = v244[-(v251 / 0x66)], v253 = 101 - v251 % 0x66),
                *(double *)(v247 + 32) >= *(double *)(v252 + 40 * v253 + 32)))
          {
            uint64_t v248 = v241;
          }
          else
          {
            v247 += 40;
            if (v247 - v245 == 4080) {
              uint64_t v247 = v244[1];
            }
          }
          double v254 = *(double *)(v239 + 32);
          if (*(double *)(v247 + 32) >= v254)
          {
            v366 = *(void **)v239;
            *(void *)v380 = *(void *)(v239 + 8);
            *(void *)&v380[7] = *(void *)(v239 + 15);
            char v363 = *(unsigned char *)(v239 + 23);
            *(void *)(v239 + 8) = 0;
            *(void *)(v239 + 16) = 0;
            *(void *)uint64_t v239 = 0;
            uint64_t v360 = *(void *)(v239 + 24);
            do
            {
              uint64_t v255 = v239;
              uint64_t v239 = v247;
              if (*(char *)(v255 + 23) < 0) {
                operator delete(*(void **)v255);
              }
              long long v256 = *(_OWORD *)v239;
              *(void *)(v255 + 16) = *(void *)(v239 + 16);
              *(_OWORD *)uint64_t v255 = v256;
              *(unsigned char *)(v239 + 23) = 0;
              *(unsigned char *)uint64_t v239 = 0;
              *(_OWORD *)(v255 + 24) = *(_OWORD *)(v239 + 24);
              if (v229 < v248) {
                break;
              }
              uint64_t v257 = (2 * v248) | 1;
              uint64_t v258 = v257 - 0x3333333333333333 * ((v371 - *a1) >> 3);
              if (v258 >= 1)
              {
                unint64_t v260 = &a1[v258 / 0x66uLL];
                uint64_t v261 = *v260;
                unint64_t v262 = v258 % 0x66uLL;
              }
              else
              {
                unint64_t v259 = 101 - v258;
                unint64_t v260 = &a1[-(v259 / 0x66)];
                uint64_t v261 = *v260;
                unint64_t v262 = 101 - v259 % 0x66;
              }
              uint64_t v247 = v261 + 40 * v262;
              uint64_t v248 = 2 * v248 + 2;
              if (v248 >= v18
                || ((uint64_t v263 = (v247 - v261) / 40, v247 - v261 >= -39)
                  ? (v264 = v263 + 1, uint64_t v266 = v260[v264 / 0x66], v267 = v264 % 0x66)
                  : (unint64_t v265 = 100 - v263, v266 = v260[-(v265 / 0x66)], v267 = 101 - v265 % 0x66),
                    *(double *)(v247 + 32) >= *(double *)(v266 + 40 * v267 + 32)))
              {
                uint64_t v248 = v257;
              }
              else
              {
                v247 += 40;
                if (v247 - v261 == 4080) {
                  uint64_t v247 = v260[1];
                }
              }
            }
            while (*(double *)(v247 + 32) >= v254);
            if (*(char *)(v239 + 23) < 0) {
              operator delete(*(void **)v239);
            }
            *(void *)uint64_t v239 = v366;
            *(void *)(v239 + 8) = *(void *)v380;
            *(void *)(v239 + 15) = *(void *)&v380[7];
            *(unsigned char *)(v239 + 23) = v363;
            *(void *)(v239 + 24) = v360;
            *(double *)(v239 + 32) = v254;
          }
        }
        BOOL v6 = v230-- <= 0;
        uint64_t v231 = v355;
        uint64_t v10 = v371;
        if (!v6) {
          continue;
        }
        break;
      }
      int v268 = v369;
      uint64_t v269 = v12 - 0x3333333333333333 * ((uint64_t)(v355 - *v369) >> 3) + 0x3333333333333333 * ((v371 - *a1) >> 3);
      if (v269 < 2) {
        return;
      }
      while (2)
      {
        v370 = v268;
        uint64_t v270 = 0;
        uint64_t v364 = *(void *)v10;
        *(void *)v374 = *(void *)(v371 + 8);
        *(void *)&v374[7] = *(void *)(v371 + 15);
        char v367 = *(unsigned char *)(v10 + 23);
        *(void *)uint64_t v10 = 0;
        *(void *)(v10 + 8) = 0;
        *(void *)(v10 + 16) = 0;
        uint64_t v271 = v10;
        unint64_t v272 = a1;
        long long v381 = *(_OWORD *)(v371 + 24);
LABEL_253:
        if (v270 == -1)
        {
          uint64_t v274 = v271;
        }
        else
        {
          uint64_t v275 = v270 + 1 - 0x3333333333333333 * ((v271 - *v272) >> 3);
          if (v275 < 1)
          {
            unint64_t v278 = 101 - v275;
            v272 -= v278 / 0x66;
            uint64_t v276 = *v272;
            unint64_t v277 = 101 - v278 % 0x66;
          }
          else
          {
            v272 += v275 / 0x66uLL;
            uint64_t v276 = *v272;
            unint64_t v277 = v275 % 0x66uLL;
          }
          uint64_t v274 = v276 + 40 * v277;
        }
        uint64_t v279 = (2 * v270) | 1;
        uint64_t v270 = 2 * v270 + 2;
        if (v270 >= v269
          || ((uint64_t v280 = v274 - *v272, v281 = v280 / 40, v280 < -39)
            ? (v285 = 100 - v281, uint64_t v283 = v272[-(v285 / 0x66)], v284 = 101 - v285 % 0x66)
            : (unint64_t v282 = v281 + 1, v283 = v272[v282 / 0x66], v284 = v282 % 0x66),
              *(double *)(v274 + 32) >= *(double *)(v283 + 40 * v284 + 32)))
        {
          uint64_t v270 = v279;
          if (*(char *)(v271 + 23) < 0) {
            goto LABEL_267;
          }
        }
        else
        {
          v274 += 40;
          if (v274 - *v272 == 4080)
          {
            uint64_t v286 = v272[1];
            ++v272;
            uint64_t v274 = v286;
          }
          if (*(char *)(v271 + 23) < 0) {
LABEL_267:
          }
            operator delete(*(void **)v271);
        }
        long long v273 = *(_OWORD *)v274;
        *(void *)(v271 + 16) = *(void *)(v274 + 16);
        *(_OWORD *)uint64_t v271 = v273;
        *(unsigned char *)(v274 + 23) = 0;
        *(unsigned char *)uint64_t v274 = 0;
        *(_OWORD *)(v271 + 24) = *(_OWORD *)(v274 + 24);
        uint64_t v271 = v274;
        if (v270 > (uint64_t)((unint64_t)(v269 - 2) >> 1))
        {
          uint64_t v287 = v231;
          if (*v370 == v231) {
            uint64_t v287 = *(v370 - 1) + 4080;
          }
          float v288 = (_OWORD *)(v274 + 24);
          double v289 = (void **)(v287 - 40);
          int v290 = *(char *)(v274 + 23);
          if (v287 - 40 == v274)
          {
            if (v290 < 0) {
              operator delete(*(void **)v274);
            }
            *(void *)uint64_t v274 = v364;
            *(void *)(v274 + 8) = *(void *)v374;
            *(void *)(v274 + 15) = *(void *)&v374[7];
            *(unsigned char *)(v274 + 23) = v367;
            *float v288 = v381;
LABEL_303:
            int v268 = v370;
            uint64_t v10 = v371;
          }
          else
          {
            if (v290 < 0) {
              operator delete(*(void **)v274);
            }
            long long v291 = *(_OWORD *)v289;
            *(void *)(v274 + 16) = *(void *)(v287 - 24);
            *(_OWORD *)uint64_t v274 = v291;
            *(unsigned char *)(v287 - 17) = 0;
            *(unsigned char *)(v287 - 40) = 0;
            *float v288 = *(_OWORD *)(v287 - 16);
            uint64_t v292 = v274 + 40;
            if (v274 + 40 - *v272 == 4080)
            {
              uint64_t v293 = v272[1];
              ++v272;
              uint64_t v292 = v293;
            }
            uint64_t v10 = v371;
            if (*(char *)(v287 - 17) < 0) {
              operator delete(*v289);
            }
            *(void *)(v287 - 40) = v364;
            *(void *)(v287 - 25) = *(void *)&v374[7];
            *(void *)(v287 - 32) = *(void *)v374;
            *(unsigned char *)(v287 - 17) = v367;
            *(_OWORD *)(v287 - 16) = v381;
            int v268 = v370;
            if (v292 != v371)
            {
              uint64_t v294 = (v371 - *a1) >> 3;
              uint64_t v295 = 102 * (v272 - a1) - 0x3333333333333333 * ((v292 - *v272) >> 3) + 0x3333333333333333 * v294;
              unint64_t v296 = v295 - 2;
              if (v295 >= 2)
              {
                unint64_t v297 = v296 >> 1;
                uint64_t v298 = v371;
                if (v296 >= 2)
                {
                  uint64_t v299 = v297 - 0x3333333333333333 * v294;
                  if (v299 < 1)
                  {
                    unint64_t v302 = 101 - v299;
                    uint64_t v300 = a1[-(v302 / 0x66)];
                    unint64_t v301 = 101 - v302 % 0x66;
                  }
                  else
                  {
                    uint64_t v300 = a1[v299 / 0x66uLL];
                    unint64_t v301 = v299 % 0x66uLL;
                  }
                  uint64_t v298 = v300 + 40 * v301;
                }
                if (*v272 == v292) {
                  uint64_t v292 = *(v272 - 1) + 4080;
                }
                double v303 = *(double *)(v292 - 8);
                if (*(double *)(v298 + 32) < v303)
                {
                  uint64_t v305 = *(void *)(v292 - 40);
                  uint64_t v304 = v292 - 40;
                  uint64_t v368 = v305;
                  *(void *)&v387[7] = *(void *)(v304 + 15);
                  *(void *)v387 = *(void *)(v304 + 8);
                  char v306 = *(unsigned char *)(v304 + 23);
                  *(void *)uint64_t v304 = 0;
                  *(void *)(v304 + 8) = 0;
                  *(void *)(v304 + 16) = 0;
                  uint64_t v307 = *(void *)(v304 + 24);
                  do
                  {
                    uint64_t v311 = v231;
                    uint64_t v312 = v304;
                    uint64_t v304 = v298;
                    if (*(char *)(v312 + 23) < 0) {
                      operator delete(*(void **)v312);
                    }
                    long long v313 = *(_OWORD *)v304;
                    *(void *)(v312 + 16) = *(void *)(v304 + 16);
                    *(_OWORD *)uint64_t v312 = v313;
                    *(unsigned char *)(v304 + 23) = 0;
                    *(unsigned char *)uint64_t v304 = 0;
                    *(_OWORD *)(v312 + 24) = *(_OWORD *)(v304 + 24);
                    uint64_t v231 = v311;
                    if (!v297) {
                      break;
                    }
                    uint64_t v298 = v371;
                    if (v297 >= 3)
                    {
                      unint64_t v314 = ((v297 - 1) >> 1) - 0x3333333333333333 * ((v371 - *a1) >> 3);
                      if ((uint64_t)v314 < 1)
                      {
                        unint64_t v308 = 101 - v314;
                        uint64_t v309 = a1[-(v308 / 0x66)];
                        unint64_t v310 = 101 - v308 % 0x66;
                      }
                      else
                      {
                        uint64_t v309 = a1[v314 / 0x66];
                        unint64_t v310 = v314 % 0x66;
                      }
                      uint64_t v298 = v309 + 40 * v310;
                    }
                    unint64_t v297 = (v297 - 1) >> 1;
                  }
                  while (*(double *)(v298 + 32) < v303);
                  if (*(char *)(v304 + 23) < 0) {
                    operator delete(*(void **)v304);
                  }
                  *(void *)uint64_t v304 = v368;
                  *(void *)(v304 + 8) = *(void *)v387;
                  *(void *)(v304 + 15) = *(void *)&v387[7];
                  *(unsigned char *)(v304 + 23) = v306;
                  *(void *)(v304 + 24) = v307;
                  *(double *)(v304 + 32) = v303;
                  goto LABEL_303;
                }
              }
            }
          }
          if (v231 == *v268)
          {
            uint64_t v315 = *--v268;
            uint64_t v231 = v315 + 4080;
          }
          v231 -= 40;
          BOOL v6 = v269-- <= 2;
          if (v6) {
            return;
          }
          continue;
        }
        goto LABEL_253;
      }
    }
    unint64_t v19 = (unint64_t)v18 >> 1;
    uint64_t v20 = v17 / 40 + ((unint64_t)v18 >> 1);
    if ((unint64_t)v18 < 0x81)
    {
      if (v20 < 1)
      {
        unint64_t v47 = 101 - v20;
        long long v24 = &a1[-(v47 / 0x66)];
        uint64_t v25 = *v24;
        unint64_t v26 = 101 - v47 % 0x66;
      }
      else
      {
        long long v24 = &a1[v20 / 0x66uLL];
        uint64_t v25 = *v24;
        unint64_t v26 = v20 % 0x66uLL;
      }
      double v48 = (uint64_t *)(v25 + 40 * v26);
      if (v14 < 41)
      {
        uint64_t v54 = 102 - v15;
        unint64_t v55 = (102 - v15) / 0x66uLL;
        unint64_t v51 = &a3[-v55];
        uint64_t v52 = *v51;
        uint64_t v53 = 101 - (v54 - 102 * v55);
      }
      else
      {
        uint64_t v49 = v15 - 1;
        unint64_t v50 = (v15 - 1) / 0x66uLL;
        unint64_t v51 = &a3[v50];
        uint64_t v52 = *v51;
        uint64_t v53 = v49 - 102 * v50;
      }
      sub_19E45BE10((uint64_t)v24, v48, (uint64_t)a1, (long long *)v10, (uint64_t)v51, (long long *)(v52 + 40 * v53));
    }
    else
    {
      if (v20 < 1)
      {
        unint64_t v27 = 101 - v20;
        uint64_t v21 = &a1[-(v27 / 0x66)];
        uint64_t v22 = *v21;
        unint64_t v23 = 101 - v27 % 0x66;
      }
      else
      {
        uint64_t v21 = &a1[v20 / 0x66uLL];
        uint64_t v22 = *v21;
        unint64_t v23 = v20 % 0x66uLL;
      }
      uint64_t v28 = (long long *)(v22 + 40 * v23);
      if (v14 < 41)
      {
        uint64_t v34 = 102 - v15;
        unint64_t v35 = (102 - v15) / 0x66uLL;
        uint64_t v31 = &a3[-v35];
        uint64_t v32 = *v31;
        uint64_t v33 = 101 - (v34 - 102 * v35);
      }
      else
      {
        uint64_t v29 = v15 - 1;
        unint64_t v30 = (v15 - 1) / 0x66uLL;
        uint64_t v31 = &a3[v30];
        uint64_t v32 = *v31;
        uint64_t v33 = v29 - 102 * v30;
      }
      sub_19E45BE10((uint64_t)a1, (uint64_t *)v10, (uint64_t)v21, v28, (uint64_t)v31, (long long *)(v32 + 40 * v33));
      uint64_t v36 = v10 - *a1;
      uint64_t v37 = v36 / 40;
      if (v36 < -39)
      {
        unint64_t v38 = &a1[-((100 - v37) / 0x66uLL)];
        uint64_t v39 = *v38;
        unint64_t v40 = 101 - (100 - v37) % 0x66uLL;
      }
      else
      {
        unint64_t v38 = &a1[(v37 + 1) / 0x66uLL];
        uint64_t v39 = *v38;
        unint64_t v40 = (v37 + 1) % 0x66uLL;
      }
      double v41 = (uint64_t *)(v39 + 40 * v40);
      unint64_t v42 = v19 - 1;
      uint64_t v43 = v37 + v19 - 1;
      if (v43 < 1)
      {
        unint64_t v56 = 101 - v43;
        uint64_t v44 = &a1[-(v56 / 0x66)];
        uint64_t v45 = *v44;
        unint64_t v46 = 101 - v56 % 0x66;
      }
      else
      {
        uint64_t v44 = &a1[v43 / 0x66uLL];
        uint64_t v45 = *v44;
        unint64_t v46 = v43 % 0x66uLL;
      }
      uint64_t v57 = (long long *)(v45 + 40 * v46);
      uint64_t v58 = v8 - *a3;
      uint64_t v59 = v58 / 40;
      if (v58 < 81)
      {
        unint64_t v64 = 103 - v59;
        uint64_t v61 = &a3[-(v64 / 0x66)];
        uint64_t v62 = *v61;
        unint64_t v63 = 101 - v64 % 0x66;
      }
      else
      {
        unint64_t v60 = v59 - 2;
        uint64_t v61 = &a3[v60 / 0x66];
        uint64_t v62 = *v61;
        unint64_t v63 = v60 % 0x66;
      }
      sub_19E45BE10((uint64_t)v38, v41, (uint64_t)v44, v57, (uint64_t)v61, (long long *)(v62 + 40 * v63));
      uint64_t v65 = v10 - *a1;
      uint64_t v66 = v65 / 40;
      if (v65 < -79)
      {
        double v67 = &a1[-((99 - v66) / 0x66uLL)];
        uint64_t v68 = *v67;
        unint64_t v69 = 101 - (99 - v66) % 0x66uLL;
      }
      else
      {
        double v67 = &a1[(v66 + 2) / 0x66uLL];
        uint64_t v68 = *v67;
        unint64_t v69 = (v66 + 2) % 0x66uLL;
      }
      uint64_t v70 = (uint64_t *)(v68 + 40 * v69);
      uint64_t v71 = v66 + v19 + 1;
      if (v71 < 1)
      {
        unint64_t v75 = 101 - v71;
        uint64_t v72 = &a1[-(v75 / 0x66)];
        uint64_t v73 = *v72;
        unint64_t v74 = 101 - v75 % 0x66;
      }
      else
      {
        uint64_t v72 = &a1[v71 / 0x66uLL];
        uint64_t v73 = *v72;
        unint64_t v74 = v71 % 0x66uLL;
      }
      double v76 = (long long *)(v73 + 40 * v74);
      uint64_t v77 = v8 - *a3;
      uint64_t v78 = v77 / 40;
      if (v77 < 121)
      {
        unint64_t v83 = 104 - v78;
        unint64_t v80 = &a3[-(v83 / 0x66)];
        uint64_t v81 = *v80;
        unint64_t v82 = 101 - v83 % 0x66;
      }
      else
      {
        unint64_t v79 = v78 - 3;
        unint64_t v80 = &a3[v79 / 0x66];
        uint64_t v81 = *v80;
        unint64_t v82 = v79 % 0x66;
      }
      sub_19E45BE10((uint64_t)v67, v70, (uint64_t)v72, v76, (uint64_t)v80, (long long *)(v81 + 40 * v82));
      uint64_t v84 = (v10 - *a1) / 40;
      unint64_t v85 = v84 + v42;
      if ((uint64_t)(v84 + v42) < 1)
      {
        unint64_t v89 = 101 - v85;
        unint64_t v86 = &a1[-(v89 / 0x66)];
        uint64_t v87 = *v86;
        unint64_t v88 = 101 - v89 % 0x66;
      }
      else
      {
        unint64_t v86 = &a1[v85 / 0x66];
        uint64_t v87 = *v86;
        unint64_t v88 = v85 % 0x66;
      }
      uint64_t v90 = (uint64_t *)(v87 + 40 * v88);
      unint64_t v91 = v84 + v19;
      if ((uint64_t)(v84 + v19) < 1)
      {
        unint64_t v95 = 101 - v91;
        unint64_t v92 = &a1[-(v95 / 0x66)];
        uint64_t v93 = *v92;
        unint64_t v94 = 101 - v95 % 0x66;
      }
      else
      {
        unint64_t v92 = &a1[v91 / 0x66];
        uint64_t v93 = *v92;
        unint64_t v94 = v91 % 0x66;
      }
      uint64_t v96 = v84 + v19 + 1;
      if (v96 < 1)
      {
        unint64_t v100 = 101 - v96;
        unint64_t v97 = &a1[-(v100 / 0x66)];
        uint64_t v98 = *v97;
        unint64_t v99 = 101 - v100 % 0x66;
      }
      else
      {
        unint64_t v97 = &a1[v96 / 0x66uLL];
        uint64_t v98 = *v97;
        unint64_t v99 = v96 % 0x66uLL;
      }
      sub_19E45BE10((uint64_t)v86, v90, (uint64_t)v92, (long long *)(v93 + 40 * v94), (uint64_t)v97, (long long *)(v98 + 40 * v99));
      uint64_t v101 = (v10 - *a1) / 40 + v19;
      if (v101 < 1)
      {
        unint64_t v104 = 101 - v101;
        uint64_t v102 = a1[-(v104 / 0x66)];
        unint64_t v103 = 101 - v104 % 0x66;
      }
      else
      {
        uint64_t v102 = a1[v101 / 0x66uLL];
        unint64_t v103 = v101 % 0x66uLL;
      }
      unint64_t v105 = v102 + 40 * v103;
      uint64_t v106 = *(void *)v10;
      *(void *)int v383 = *(void *)(v10 + 8);
      *(void *)&v383[7] = *(void *)(v10 + 15);
      char v107 = *(unsigned char *)(v10 + 23);
      *(void *)uint64_t v10 = 0;
      *(void *)(v10 + 8) = 0;
      *(void *)(v10 + 16) = 0;
      long long v375 = *(_OWORD *)(v10 + 24);
      uint64_t v108 = *(void *)(v105 + 16);
      *(_OWORD *)uint64_t v10 = *(_OWORD *)v105;
      *(void *)(v10 + 16) = v108;
      *(unsigned char *)(v105 + 23) = 0;
      *(unsigned char *)unint64_t v105 = 0;
      *(_OWORD *)(v10 + 24) = *(_OWORD *)(v105 + 24);
      if (*(char *)(v105 + 23) < 0) {
        operator delete(*(void **)v105);
      }
      *(void *)unint64_t v105 = v106;
      *(void *)(v105 + 8) = *(void *)v383;
      *(void *)(v105 + 15) = *(void *)&v383[7];
      *(unsigned char *)(v105 + 23) = v107;
      *(_OWORD *)(v105 + 24) = v375;
    }
    uint64_t v109 = a5 - 1;
    if (a6)
    {
      uint64_t v361 = v109;
      double v110 = *(double *)(v10 + 32);
    }
    else
    {
      uint64_t v111 = v10 - *a1;
      uint64_t v112 = v111 / 40;
      if (v111 < 41)
      {
        unint64_t v116 = 102 - v112;
        uint64_t v114 = a1[-(v116 / 0x66)];
        unint64_t v115 = 101 - v116 % 0x66;
      }
      else
      {
        unint64_t v113 = v112 - 1;
        uint64_t v114 = a1[v113 / 0x66];
        unint64_t v115 = v113 % 0x66;
      }
      double v110 = *(double *)(v10 + 32);
      if (*(double *)(v114 + 40 * v115 + 32) >= v110)
      {
        uint64_t v362 = *(void *)v10;
        *(void *)v373 = *(void *)(v10 + 8);
        *(void *)&v373[7] = *(void *)(v10 + 15);
        char v359 = *(unsigned char *)(v10 + 23);
        *(void *)(v10 + 8) = 0;
        *(void *)(v10 + 16) = 0;
        *(void *)uint64_t v10 = 0;
        uint64_t v137 = *a3;
        uint64_t v138 = v8 - *a3;
        uint64_t v139 = v138 / 40;
        if (v138 < 41)
        {
          unint64_t v143 = 102 - v139;
          uint64_t v141 = a3[-(v143 / 0x66)];
          unint64_t v142 = 101 - v143 % 0x66;
        }
        else
        {
          unint64_t v140 = v139 - 1;
          uint64_t v141 = a3[v140 / 0x66];
          unint64_t v142 = v140 % 0x66;
        }
        double v144 = *(double *)(v141 + 40 * v142 + 32);
        uint64_t v145 = *a1;
        unint64_t v146 = v10;
        if (v110 < v144)
        {
          do
          {
            v146 += 40;
            if (v146 - v145 == 4080)
            {
              unint64_t v147 = a1[1];
              ++a1;
              uint64_t v145 = v147;
              unint64_t v146 = v147;
            }
          }
          while (v110 >= *(double *)(v146 + 32));
        }
        else
        {
          do
          {
            v146 += 40;
            if (v146 - v145 == 4080)
            {
              unint64_t v148 = a1[1];
              ++a1;
              uint64_t v145 = v148;
              unint64_t v146 = v148;
            }
          }
          while ((a1 < a3 || a1 == a3 && v146 < v8) && v110 >= *(double *)(v146 + 32));
        }
        uint64_t v149 = v109;
        if (a1 < a3 || (unint64_t v150 = a3, v151 = v8, a1 == a3) && (unint64_t v150 = a3, v151 = v8, v146 < v8))
        {
          unint64_t v150 = a3;
          unint64_t v152 = v8;
          do
          {
            if (v152 == v137)
            {
              uint64_t v154 = *--v150;
              uint64_t v137 = v154;
              unint64_t v152 = v154 + 4080;
            }
            unint64_t v151 = v152 - 40;
            double v153 = *(double *)(v152 - 8);
            v152 -= 40;
          }
          while (v110 < v153);
        }
        uint64_t v155 = *(void *)(v371 + 24);
        while (a1 < v150 || a1 == v150 && v146 < v151)
        {
          uint64_t v156 = *(void *)v146;
          *(void *)uint64_t v384 = *(void *)(v146 + 8);
          *(void *)&v384[7] = *(void *)(v146 + 15);
          char v157 = *(unsigned char *)(v146 + 23);
          *(void *)unint64_t v146 = 0;
          *(void *)(v146 + 8) = 0;
          *(void *)(v146 + 16) = 0;
          long long v376 = *(_OWORD *)(v146 + 24);
          uint64_t v158 = *(void *)(v151 + 16);
          *(_OWORD *)unint64_t v146 = *(_OWORD *)v151;
          *(void *)(v146 + 16) = v158;
          *(unsigned char *)(v151 + 23) = 0;
          *(unsigned char *)unint64_t v151 = 0;
          *(_OWORD *)(v146 + 24) = *(_OWORD *)(v151 + 24);
          if (*(char *)(v151 + 23) < 0) {
            operator delete(*(void **)v151);
          }
          *(void *)unint64_t v151 = v156;
          *(void *)(v151 + 8) = *(void *)v384;
          *(void *)(v151 + 15) = *(void *)&v384[7];
          *(unsigned char *)(v151 + 23) = v157;
          *(_OWORD *)(v151 + 24) = v376;
          uint64_t v145 = *a1;
          do
          {
            v146 += 40;
            if (v146 - v145 == 4080)
            {
              unint64_t v159 = a1[1];
              ++a1;
              uint64_t v145 = v159;
              unint64_t v146 = v159;
            }
          }
          while (v110 >= *(double *)(v146 + 32));
          uint64_t v160 = *v150;
          do
          {
            if (v151 == v160)
            {
              uint64_t v162 = *--v150;
              uint64_t v160 = v162;
              unint64_t v151 = v162 + 4080;
            }
            double v161 = *(double *)(v151 - 8);
            v151 -= 40;
          }
          while (v110 < v161);
        }
        uint64_t v163 = v146 - v145;
        uint64_t v164 = (unsigned __int128)((uint64_t)(v146 - v145) * (__int128)0x6666666666666667) >> 64;
        uint64_t v165 = (v164 >> 4) + ((unint64_t)v164 >> 63);
        if (v163 < 41)
        {
          unint64_t v169 = 102 - v165;
          uint64_t v167 = a1[-(v169 / 0x66)];
          unint64_t v168 = 101 - v169 % 0x66;
        }
        else
        {
          unint64_t v166 = v165 - 1;
          uint64_t v167 = a1[v166 / 0x66];
          unint64_t v168 = v166 % 0x66;
        }
        uint64_t v170 = (long long *)(v167 + 40 * v168);
        a5 = v149;
        if (v170 != (long long *)v371)
        {
          if (*(char *)(v371 + 23) < 0) {
            operator delete(*(void **)v371);
          }
          long long v171 = *v170;
          *(void *)(v371 + 16) = *((void *)v170 + 2);
          *(_OWORD *)uint64_t v371 = v171;
          *((unsigned char *)v170 + 23) = 0;
          *(unsigned char *)uint64_t v170 = 0;
          *(_OWORD *)(v371 + 24) = *(long long *)((char *)v170 + 24);
        }
        if (*((char *)v170 + 23) < 0) {
          operator delete(*(void **)v170);
        }
        a6 = 0;
        *(void *)uint64_t v170 = v362;
        *((void *)v170 + 1) = *(void *)v373;
        *(void *)((char *)v170 + 15) = *(void *)&v373[7];
        *((unsigned char *)v170 + 23) = v359;
        *((void *)v170 + 3) = v155;
        *((double *)v170 + 4) = v110;
        goto LABEL_4;
      }
      uint64_t v361 = v109;
    }
    uint64_t v358 = *(void *)v10;
    *(void *)int64_t v372 = *(void *)(v10 + 8);
    *(void *)&v372[7] = *(void *)(v10 + 15);
    char v357 = *(unsigned char *)(v10 + 23);
    *(void *)(v10 + 8) = 0;
    *(void *)(v10 + 16) = 0;
    *(void *)uint64_t v10 = 0;
    int v117 = (_OWORD *)(v10 + 24);
    uint64_t v356 = *(void *)(v10 + 24);
    uint64_t v118 = *a1;
    unint64_t v119 = a1;
    unint64_t v120 = v10;
    do
    {
      v120 += 40;
      if (v120 - v118 == 4080)
      {
        unint64_t v121 = v119[1];
        ++v119;
        uint64_t v118 = v121;
        unint64_t v120 = v121;
      }
    }
    while (*(double *)(v120 + 32) < v110);
    uint64_t v122 = (uint64_t)(v120 - v118) / 40;
    if ((uint64_t)(v120 - v118) < 41)
    {
      unint64_t v126 = 102 - v122;
      uint64_t v124 = v119[-(v126 / 0x66)];
      unint64_t v125 = 101 - v126 % 0x66;
    }
    else
    {
      unint64_t v123 = v122 - 1;
      uint64_t v124 = v119[v123 / 0x66];
      unint64_t v125 = v123 % 0x66;
    }
    unint64_t v127 = v124 + 40 * v125;
    uint64_t v128 = a3;
    unint64_t v129 = v8;
    if (v127 == v371)
    {
      while (1)
      {
        if (v119 >= v128)
        {
          if (v119 != v128)
          {
            unint64_t v132 = v129;
            goto LABEL_128;
          }
          if (v120 >= v129) {
            break;
          }
        }
        if (v129 == *v128)
        {
          uint64_t v136 = *--v128;
          unint64_t v129 = v136 + 4080;
        }
        unint64_t v132 = v129 - 40;
        double v135 = *(double *)(v129 - 8);
        v129 -= 40;
        if (v135 < v110) {
          goto LABEL_128;
        }
      }
      unint64_t v132 = v129;
      BOOL v172 = v119 == v128;
      if (v119 < v128)
      {
LABEL_129:
        int v173 = 0;
        goto LABEL_137;
      }
    }
    else
    {
      uint64_t v130 = *a3;
      uint64_t v128 = a3;
      unint64_t v131 = v8;
      do
      {
        if (v131 == v130)
        {
          uint64_t v134 = *--v128;
          uint64_t v130 = v134;
          unint64_t v131 = v134 + 4080;
        }
        unint64_t v132 = v131 - 40;
        double v133 = *(double *)(v131 - 8);
        v131 -= 40;
      }
      while (v133 >= v110);
LABEL_128:
      BOOL v172 = v119 == v128;
      if (v119 < v128) {
        goto LABEL_129;
      }
    }
    int v173 = !v172 || v120 >= v132;
LABEL_137:
    while (v119 < v128 || v119 == v128 && v120 < v132)
    {
      uint64_t v175 = *(void *)v120;
      *(void *)v385 = *(void *)(v120 + 8);
      *(void *)&v385[7] = *(void *)(v120 + 15);
      char v176 = *(unsigned char *)(v120 + 23);
      *(void *)unint64_t v120 = 0;
      *(void *)(v120 + 8) = 0;
      *(void *)(v120 + 16) = 0;
      long long v377 = *(_OWORD *)(v120 + 24);
      uint64_t v177 = *(void *)(v132 + 16);
      *(_OWORD *)unint64_t v120 = *(_OWORD *)v132;
      *(void *)(v120 + 16) = v177;
      *(unsigned char *)(v132 + 23) = 0;
      *(unsigned char *)unint64_t v132 = 0;
      *(_OWORD *)(v120 + 24) = *(_OWORD *)(v132 + 24);
      if (*(char *)(v132 + 23) < 0) {
        operator delete(*(void **)v132);
      }
      *(void *)unint64_t v132 = v175;
      *(void *)(v132 + 8) = *(void *)v385;
      *(void *)(v132 + 15) = *(void *)&v385[7];
      *(unsigned char *)(v132 + 23) = v176;
      *(_OWORD *)(v132 + 24) = v377;
      uint64_t v118 = *v119;
      do
      {
        v120 += 40;
        if (v120 - v118 == 4080)
        {
          unint64_t v178 = v119[1];
          ++v119;
          uint64_t v118 = v178;
          unint64_t v120 = v178;
        }
      }
      while (*(double *)(v120 + 32) < v110);
      uint64_t v179 = *v128;
      do
      {
        if (v132 == v179)
        {
          uint64_t v181 = *--v128;
          uint64_t v179 = v181;
          unint64_t v132 = v181 + 4080;
        }
        double v180 = *(double *)(v132 - 8);
        v132 -= 40;
      }
      while (v180 >= v110);
    }
    uint64_t v182 = v120 - v118;
    uint64_t v183 = (unsigned __int128)((uint64_t)(v120 - v118) * (__int128)0x6666666666666667) >> 64;
    uint64_t v184 = (v183 >> 4) + ((unint64_t)v183 >> 63);
    if (v182 < 41)
    {
      unint64_t v189 = 102 - v184;
      unint64_t v186 = &v119[-(v189 / 0x66)];
      uint64_t v187 = *v186;
      unint64_t v188 = 101 - v189 % 0x66;
    }
    else
    {
      unint64_t v185 = v184 - 1;
      unint64_t v186 = &v119[v185 / 0x66];
      uint64_t v187 = *v186;
      unint64_t v188 = v185 % 0x66;
    }
    uint64_t v190 = v187 + 40 * v188;
    unint64_t v146 = v371;
    if (v190 != v371)
    {
      if (*(char *)(v371 + 23) < 0) {
        operator delete(*(void **)v371);
      }
      long long v191 = *(_OWORD *)v190;
      *(void *)(v371 + 16) = *(void *)(v190 + 16);
      *(_OWORD *)uint64_t v371 = v191;
      *(unsigned char *)(v190 + 23) = 0;
      *(unsigned char *)uint64_t v190 = 0;
      *int v117 = *(_OWORD *)(v190 + 24);
    }
    if (*(char *)(v190 + 23) < 0) {
      operator delete(*(void **)v190);
    }
    *(void *)uint64_t v190 = v358;
    *(void *)(v190 + 8) = *(void *)v372;
    *(void *)(v190 + 15) = *(void *)&v372[7];
    *(unsigned char *)(v190 + 23) = v357;
    *(void *)(v190 + 24) = v356;
    *(double *)(v190 + 32) = v110;
    if (!v173) {
      goto LABEL_167;
    }
    BOOL v192 = sub_19E45C628(a1, v371, v186, v190);
    uint64_t v193 = v190 - *v186;
    uint64_t v194 = v193 / 40;
    if (v193 < -39)
    {
      unint64_t v199 = 100 - v194;
      int8x8_t v196 = &v186[-(v199 / 0x66)];
      uint64_t v197 = *v196;
      unint64_t v198 = 101 - v199 % 0x66;
    }
    else
    {
      unint64_t v195 = v194 + 1;
      int8x8_t v196 = &v186[v195 / 0x66];
      uint64_t v197 = *v196;
      unint64_t v198 = v195 % 0x66;
    }
    if (!sub_19E45C628(v196, v197 + 40 * v198, v369, v8))
    {
      if (!v192)
      {
LABEL_167:
        sub_19E459B70(a1, v371, v186, v190, v361, a6 & 1);
        a6 = 0;
      }
      unint64_t v146 = v190 + 40;
      if (v190 + 40 - *v186 == 4080)
      {
        uint64_t v200 = v186[1];
        ++v186;
        unint64_t v146 = v200;
      }
      a1 = v186;
      a3 = v369;
      a5 = v361;
      goto LABEL_4;
    }
    unint64_t v8 = v190;
    a3 = v186;
    a5 = v361;
    if (v192) {
      return;
    }
LABEL_4:
    uint64_t v10 = v146;
    BOOL v6 = v8 > v146;
    if (v8 == v146) {
      return;
    }
  }
  switch(v18)
  {
    case 0:
    case 1:
      return;
    case 2:
      if (v8 == v13) {
        unint64_t v8 = *(a3 - 1) + 4080;
      }
      if (*(double *)(v8 - 8) < *(double *)(v10 + 32))
      {
        uint64_t v201 = *(void *)v10;
        *(void *)unint64_t v386 = *(void *)(v10 + 8);
        *(void *)&v386[7] = *(void *)(v10 + 15);
        char v202 = *(unsigned char *)(v10 + 23);
        *(void *)uint64_t v10 = 0;
        *(void *)(v10 + 8) = 0;
        *(void *)(v10 + 16) = 0;
        long long v378 = *(_OWORD *)(v10 + 24);
        uint64_t v203 = *(void *)(v8 - 24);
        *(_OWORD *)uint64_t v10 = *(_OWORD *)(v8 - 40);
        *(void *)(v10 + 16) = v203;
        *(unsigned char *)(v8 - 17) = 0;
        *(unsigned char *)(v8 - 40) = 0;
        *(_OWORD *)(v10 + 24) = *(_OWORD *)(v8 - 16);
        if (*(char *)(v8 - 17) < 0) {
          operator delete(*(void **)(v8 - 40));
        }
        *(void *)(v8 - 40) = v201;
        *(void *)(v8 - 25) = *(void *)&v386[7];
        *(void *)(v8 - 32) = *(void *)v386;
        *(unsigned char *)(v8 - 17) = v202;
        *(_OWORD *)(v8 - 16) = v378;
      }
      return;
    case 3:
      uint64_t v204 = v17 / 40;
      if (v17 < -39)
      {
        uint64_t v205 = &a1[-((100 - v204) / 0x66uLL)];
        uint64_t v206 = *v205;
        unint64_t v207 = 101 - (100 - v204) % 0x66uLL;
      }
      else
      {
        uint64_t v205 = &a1[(v204 + 1) / 0x66uLL];
        uint64_t v206 = *v205;
        unint64_t v207 = (v204 + 1) % 0x66uLL;
      }
      if (v8 == v13)
      {
        uint64_t v316 = *--a3;
        unint64_t v8 = v316 + 4080;
      }
      sub_19E45BE10((uint64_t)a1, (uint64_t *)v10, (uint64_t)v205, (long long *)(v206 + 40 * v207), (uint64_t)a3, (long long *)(v8 - 40));
      return;
    case 4:
      uint64_t v208 = v17 / 40;
      if (v17 >= -39)
      {
        v209 = &a1[(v208 + 1) / 0x66uLL];
        unsigned int v210 = (uint64_t *)(*v209 + 40 * ((v208 + 1) % 0x66uLL));
        unint64_t v211 = v208 + 2;
LABEL_314:
        float v317 = &a1[v211 / 0x66];
        uint64_t v318 = *v317;
        unint64_t v319 = v211 % 0x66;
        goto LABEL_328;
      }
      v209 = &a1[-((100 - v208) / 0x66uLL)];
      unsigned int v210 = (uint64_t *)(*v209 + 40 * (101 - (100 - v208) % 0x66uLL));
      if ((unint64_t)v17 >= 0xFFFFFFFFFFFFFFB1)
      {
        unint64_t v211 = 1;
        goto LABEL_314;
      }
      uint64_t v329 = 99 - v208;
      unint64_t v330 = (99 - v208) / 0x66uLL;
      float v317 = &a1[-v330];
      uint64_t v318 = *v317;
      unint64_t v319 = 101 - (v329 - 102 * v330);
LABEL_328:
      if (v8 == v13)
      {
        uint64_t v331 = *--a3;
        unint64_t v8 = v331 + 4080;
      }
      sub_19E45C138((uint64_t)a1, v10, (uint64_t)v209, v210, (uint64_t)v317, (uint64_t *)(v318 + 40 * v319), (uint64_t)a3, v8 - 40);
      return;
    case 5:
      uint64_t v212 = v17 / 40;
      if (v17 >= -39)
      {
        long long v213 = &a1[(v212 + 1) / 0x66uLL];
        uint64_t v214 = (long long *)(*v213 + 40 * ((v212 + 1) % 0x66uLL));
        unint64_t v215 = v212 + 2;
LABEL_317:
        int v320 = &a1[v215 / 0x66];
        double v321 = (long long *)(*v320 + 40 * (v215 % 0x66));
        unint64_t v322 = v212 + 3;
LABEL_318:
        double v323 = &a1[v322 / 0x66];
        uint64_t v324 = *v323;
        unint64_t v325 = v322 % 0x66;
        goto LABEL_319;
      }
      long long v213 = &a1[-((100 - v212) / 0x66uLL)];
      uint64_t v214 = (long long *)(*v213 + 40 * (101 - (100 - v212) % 0x66uLL));
      if ((unint64_t)v17 >= 0xFFFFFFFFFFFFFFB1)
      {
        unint64_t v215 = 1;
        goto LABEL_317;
      }
      int v320 = &a1[-((99 - v212) / 0x66uLL)];
      double v321 = (long long *)(*v320 + 40 * (101 - (99 - v212) % 0x66uLL));
      if ((unint64_t)v17 >= 0xFFFFFFFFFFFFFF89)
      {
        unint64_t v322 = 1;
        goto LABEL_318;
      }
      double v323 = &a1[-((98 - v212) / 0x66uLL)];
      uint64_t v324 = *v323;
      unint64_t v325 = 101 - (98 - v212) % 0x66uLL;
LABEL_319:
      if (v8 == v13)
      {
        uint64_t v326 = *--a3;
        unint64_t v8 = v326 + 4080;
      }
      sub_19E45C360((uint64_t)a1, v10, (uint64_t)v213, v214, (uint64_t)v320, v321, (uint64_t)v323, v324 + 40 * v325, (uint64_t)a3, v8 - 40);
      break;
    default:
      JUMPOUT(0);
  }
}

uint64_t **sub_19E45BC8C(uint64_t **a1, const void **a2, uint64_t a3)
{
  BOOL v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *((char *)a2 + 23);
    if (v7 >= 0) {
      unint64_t v8 = a2;
    }
    else {
      unint64_t v8 = *a2;
    }
    if (v7 >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    while (1)
    {
      uint64_t v10 = (uint64_t **)v5;
      uint64_t v13 = (const void *)v5[4];
      unint64_t v11 = v5 + 4;
      uint64_t v12 = v13;
      int v14 = *((char *)v11 + 23);
      if (v14 >= 0) {
        uint64_t v15 = v11;
      }
      else {
        uint64_t v15 = v12;
      }
      if (v14 >= 0) {
        size_t v16 = *((unsigned __int8 *)v11 + 23);
      }
      else {
        size_t v16 = v11[1];
      }
      if (v16 >= v9) {
        size_t v17 = v9;
      }
      else {
        size_t v17 = v16;
      }
      int v18 = memcmp(v8, v15, v17);
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_8;
        }
LABEL_22:
        int v19 = memcmp(v15, v8, v17);
        if (v19)
        {
          if ((v19 & 0x80000000) == 0) {
            return v10;
          }
        }
        else if (v16 >= v9)
        {
          return v10;
        }
        uint64_t v5 = v10[1];
        if (!v5)
        {
          BOOL v6 = v10 + 1;
          goto LABEL_29;
        }
      }
      else
      {
        if (v9 >= v16) {
          goto LABEL_22;
        }
LABEL_8:
        uint64_t v5 = *v10;
        BOOL v6 = v10;
        if (!*v10) {
          goto LABEL_29;
        }
      }
    }
  }
  uint64_t v10 = a1 + 1;
LABEL_29:
  uint64_t v20 = (char *)operator new(0x40uLL);
  uint64_t v21 = v20 + 32;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_19E39369C(v21, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v21 = *(_OWORD *)a3;
    *((void *)v20 + 6) = *(void *)(a3 + 16);
  }
  *((_DWORD *)v20 + 14) = 0;
  *(void *)uint64_t v20 = 0;
  *((void *)v20 + 1) = 0;
  *((void *)v20 + 2) = v10;
  *BOOL v6 = (uint64_t *)v20;
  uint64_t v22 = (uint64_t *)**a1;
  unint64_t v23 = (uint64_t *)v20;
  if (v22)
  {
    *a1 = v22;
    unint64_t v23 = *v6;
  }
  sub_19E37D324(a1[1], v23);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v20;
}

void sub_19E45BDFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_19E45BE10(uint64_t a1, uint64_t *a2, uint64_t a3, long long *a4, uint64_t a5, long long *a6)
{
  double v9 = *((double *)a4 + 4);
  double v10 = *((double *)a6 + 4);
  if (v9 >= *((double *)a2 + 4))
  {
    if (v10 < v9)
    {
      size_t v16 = *(void **)a4;
      *(void *)uint64_t v33 = *((void *)a4 + 1);
      *(void *)&v33[7] = *(void *)((char *)a4 + 15);
      char v17 = *((unsigned char *)a4 + 23);
      *((void *)a4 + 2) = 0;
      *((void *)a4 + 1) = 0;
      *(void *)a4 = 0;
      long long v28 = *(long long *)((char *)a4 + 24);
      uint64_t v18 = *((void *)a6 + 2);
      *a4 = *a6;
      *((void *)a4 + 2) = v18;
      *((unsigned char *)a6 + 23) = 0;
      *(unsigned char *)a6 = 0;
      *(long long *)((char *)a4 + 24) = *(long long *)((char *)a6 + 24);
      if (*((char *)a6 + 23) < 0) {
        operator delete(*(void **)a6);
      }
      *(void *)a6 = v16;
      *((void *)a6 + 1) = *(void *)v33;
      *(void *)((char *)a6 + 15) = *(void *)&v33[7];
      *((unsigned char *)a6 + 23) = v17;
      *(long long *)((char *)a6 + 24) = v28;
      if (*((double *)a4 + 4) < *((double *)a2 + 4))
      {
        uint64_t v19 = *a2;
        *(void *)uint64_t v34 = a2[1];
        *(void *)&v34[7] = *(uint64_t *)((char *)a2 + 15);
        char v20 = *((unsigned char *)a2 + 23);
        a2[1] = 0;
        a2[2] = 0;
        *a2 = 0;
        long long v29 = *(_OWORD *)(a2 + 3);
        long long v21 = *a4;
        a2[2] = *((void *)a4 + 2);
        *(_OWORD *)a2 = v21;
        *((unsigned char *)a4 + 23) = 0;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a2 + 3) = *(long long *)((char *)a4 + 24);
        if (*((char *)a4 + 23) < 0) {
          operator delete(*(void **)a4);
        }
        *(void *)a4 = v19;
        *((void *)a4 + 1) = *(void *)v34;
        *(void *)((char *)a4 + 15) = *(void *)&v34[7];
        *((unsigned char *)a4 + 23) = v20;
        *(long long *)((char *)a4 + 24) = v29;
      }
    }
  }
  else
  {
    unint64_t v11 = a2 + 1;
    uint64_t v12 = (long long *)(a2 + 3);
    if (v10 >= v9)
    {
      uint64_t v22 = *a2;
      *(void *)unint64_t v35 = *v11;
      *(void *)&v35[7] = *(uint64_t *)((char *)a2 + 15);
      char v23 = *((unsigned char *)a2 + 23);
      a2[1] = 0;
      a2[2] = 0;
      *a2 = 0;
      long long v30 = *v12;
      long long v24 = *a4;
      a2[2] = *((void *)a4 + 2);
      *(_OWORD *)a2 = v24;
      *((unsigned char *)a4 + 23) = 0;
      *(unsigned char *)a4 = 0;
      uint64_t v25 = (long long *)((char *)a4 + 24);
      *uint64_t v12 = *(long long *)((char *)a4 + 24);
      if (*((char *)a4 + 23) < 0) {
        operator delete(*(void **)a4);
      }
      *(void *)a4 = v22;
      *((void *)a4 + 1) = *(void *)v35;
      *(void *)((char *)a4 + 15) = *(void *)&v35[7];
      *((unsigned char *)a4 + 23) = v23;
      *uint64_t v25 = v30;
      if (*((double *)a6 + 4) < *((double *)a4 + 4))
      {
        *(void *)uint64_t v36 = *((void *)a4 + 1);
        *(void *)&v36[7] = *(void *)((char *)a4 + 15);
        *((void *)a4 + 1) = 0;
        *((void *)a4 + 2) = 0;
        *(void *)a4 = 0;
        long long v31 = *v25;
        long long v26 = *a6;
        *((void *)a4 + 2) = *((void *)a6 + 2);
        *a4 = v26;
        *((unsigned char *)a6 + 23) = 0;
        *(unsigned char *)a6 = 0;
        *uint64_t v25 = *(long long *)((char *)a6 + 24);
        if (*((char *)a6 + 23) < 0) {
          operator delete(*(void **)a6);
        }
        *(void *)a6 = v22;
        *((void *)a6 + 1) = *(void *)v36;
        *(void *)((char *)a6 + 15) = *(void *)&v36[7];
        *((unsigned char *)a6 + 23) = v23;
        *(long long *)((char *)a6 + 24) = v31;
      }
    }
    else
    {
      uint64_t v13 = *a2;
      *(void *)uint64_t v32 = *v11;
      *(void *)&v32[7] = *(uint64_t *)((char *)a2 + 15);
      char v14 = *((unsigned char *)a2 + 23);
      a2[1] = 0;
      a2[2] = 0;
      *a2 = 0;
      long long v27 = *v12;
      long long v15 = *a6;
      a2[2] = *((void *)a6 + 2);
      *(_OWORD *)a2 = v15;
      *((unsigned char *)a6 + 23) = 0;
      *(unsigned char *)a6 = 0;
      *uint64_t v12 = *(long long *)((char *)a6 + 24);
      if (*((char *)a6 + 23) < 0) {
        operator delete(*(void **)a6);
      }
      *(void *)a6 = v13;
      *((void *)a6 + 1) = *(void *)v32;
      *(void *)((char *)a6 + 15) = *(void *)&v32[7];
      *((unsigned char *)a6 + 23) = v14;
      *(long long *)((char *)a6 + 24) = v27;
    }
  }
}

void sub_19E45C138(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  sub_19E45BE10(a1, (uint64_t *)a2, a3, (long long *)a4, a5, (long long *)a6);
  if (*(double *)(a8 + 32) < *((double *)a6 + 4))
  {
    uint64_t v12 = *a6;
    *(void *)long long v24 = a6[1];
    *(void *)&v24[7] = *(uint64_t *)((char *)a6 + 15);
    char v13 = *((unsigned char *)a6 + 23);
    a6[2] = 0;
    a6[1] = 0;
    *a6 = 0;
    long long v21 = *(_OWORD *)(a6 + 3);
    uint64_t v14 = *(void *)(a8 + 16);
    *(_OWORD *)a6 = *(_OWORD *)a8;
    a6[2] = v14;
    *(unsigned char *)(a8 + 23) = 0;
    *(unsigned char *)a8 = 0;
    *(_OWORD *)(a6 + 3) = *(_OWORD *)(a8 + 24);
    if (*(char *)(a8 + 23) < 0) {
      operator delete(*(void **)a8);
    }
    *(void *)a8 = v12;
    *(void *)(a8 + 8) = *(void *)v24;
    *(void *)(a8 + 15) = *(void *)&v24[7];
    *(unsigned char *)(a8 + 23) = v13;
    *(_OWORD *)(a8 + 24) = v21;
    if (*((double *)a6 + 4) < *((double *)a4 + 4))
    {
      uint64_t v15 = *a4;
      *(void *)uint64_t v25 = a4[1];
      *(void *)&v25[7] = *(uint64_t *)((char *)a4 + 15);
      char v16 = *((unsigned char *)a4 + 23);
      a4[2] = 0;
      a4[1] = 0;
      *a4 = 0;
      long long v22 = *(_OWORD *)(a4 + 3);
      long long v17 = *(_OWORD *)a6;
      a4[2] = a6[2];
      *(_OWORD *)a4 = v17;
      *((unsigned char *)a6 + 23) = 0;
      *(unsigned char *)a6 = 0;
      *(_OWORD *)(a4 + 3) = *(_OWORD *)(a6 + 3);
      if (*((char *)a6 + 23) < 0) {
        operator delete((void *)*a6);
      }
      *a6 = v15;
      a6[1] = *(void *)v25;
      *(uint64_t *)((char *)a6 + 15) = *(void *)&v25[7];
      *((unsigned char *)a6 + 23) = v16;
      *(_OWORD *)(a6 + 3) = v22;
      if (*((double *)a4 + 4) < *(double *)(a2 + 32))
      {
        uint64_t v18 = *(void *)a2;
        *(void *)long long v26 = *(void *)(a2 + 8);
        *(void *)&v26[7] = *(void *)(a2 + 15);
        char v19 = *(unsigned char *)(a2 + 23);
        *(void *)(a2 + 8) = 0;
        *(void *)(a2 + 16) = 0;
        *(void *)a2 = 0;
        long long v23 = *(_OWORD *)(a2 + 24);
        long long v20 = *(_OWORD *)a4;
        *(void *)(a2 + 16) = a4[2];
        *(_OWORD *)a2 = v20;
        *((unsigned char *)a4 + 23) = 0;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a2 + 24) = *(_OWORD *)(a4 + 3);
        if (*((char *)a4 + 23) < 0) {
          operator delete((void *)*a4);
        }
        *a4 = v18;
        a4[1] = *(void *)v26;
        *(uint64_t *)((char *)a4 + 15) = *(void *)&v26[7];
        *((unsigned char *)a4 + 23) = v19;
        *(_OWORD *)(a4 + 3) = v23;
      }
    }
  }
}

void sub_19E45C360(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, long long *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_19E45C138(a1, a2, a3, (uint64_t *)a4, a5, (uint64_t *)a6, a7, a8);
  if (*(double *)(a10 + 32) < *(double *)(a8 + 32))
  {
    uint64_t v14 = *(void **)a8;
    *(void *)long long v30 = *(void *)(a8 + 8);
    *(void *)&v30[7] = *(void *)(a8 + 15);
    char v15 = *(unsigned char *)(a8 + 23);
    *(void *)(a8 + 16) = 0;
    *(void *)(a8 + 8) = 0;
    *(void *)a8 = 0;
    long long v26 = *(_OWORD *)(a8 + 24);
    uint64_t v16 = *(void *)(a10 + 16);
    *(_OWORD *)a8 = *(_OWORD *)a10;
    *(void *)(a8 + 16) = v16;
    *(unsigned char *)(a10 + 23) = 0;
    *(unsigned char *)a10 = 0;
    *(_OWORD *)(a8 + 24) = *(_OWORD *)(a10 + 24);
    if (*(char *)(a10 + 23) < 0) {
      operator delete(*(void **)a10);
    }
    *(void *)a10 = v14;
    *(void *)(a10 + 8) = *(void *)v30;
    *(void *)(a10 + 15) = *(void *)&v30[7];
    *(unsigned char *)(a10 + 23) = v15;
    *(_OWORD *)(a10 + 24) = v26;
    if (*(double *)(a8 + 32) < *((double *)a6 + 4))
    {
      uint64_t v17 = *(void *)a6;
      *(void *)long long v31 = *((void *)a6 + 1);
      *(void *)&v31[7] = *(void *)((char *)a6 + 15);
      char v18 = *((unsigned char *)a6 + 23);
      *((void *)a6 + 2) = 0;
      *((void *)a6 + 1) = 0;
      *(void *)a6 = 0;
      long long v27 = *(long long *)((char *)a6 + 24);
      long long v19 = *(_OWORD *)a8;
      *((void *)a6 + 2) = *(void *)(a8 + 16);
      *a6 = v19;
      *(unsigned char *)(a8 + 23) = 0;
      *(unsigned char *)a8 = 0;
      *(long long *)((char *)a6 + 24) = *(_OWORD *)(a8 + 24);
      if (*(char *)(a8 + 23) < 0) {
        operator delete(*(void **)a8);
      }
      *(void *)a8 = v17;
      *(void *)(a8 + 8) = *(void *)v31;
      *(void *)(a8 + 15) = *(void *)&v31[7];
      *(unsigned char *)(a8 + 23) = v18;
      *(_OWORD *)(a8 + 24) = v27;
      if (*((double *)a6 + 4) < *((double *)a4 + 4))
      {
        uint64_t v20 = *(void *)a4;
        *(void *)uint64_t v32 = *((void *)a4 + 1);
        *(void *)&v32[7] = *(void *)((char *)a4 + 15);
        char v21 = *((unsigned char *)a4 + 23);
        *((void *)a4 + 2) = 0;
        *((void *)a4 + 1) = 0;
        *(void *)a4 = 0;
        long long v28 = *(long long *)((char *)a4 + 24);
        long long v22 = *a6;
        *((void *)a4 + 2) = *((void *)a6 + 2);
        *a4 = v22;
        *((unsigned char *)a6 + 23) = 0;
        *(unsigned char *)a6 = 0;
        *(long long *)((char *)a4 + 24) = *(long long *)((char *)a6 + 24);
        if (*((char *)a6 + 23) < 0) {
          operator delete(*(void **)a6);
        }
        *(void *)a6 = v20;
        *((void *)a6 + 1) = *(void *)v32;
        *(void *)((char *)a6 + 15) = *(void *)&v32[7];
        *((unsigned char *)a6 + 23) = v21;
        *(long long *)((char *)a6 + 24) = v28;
        if (*((double *)a4 + 4) < *(double *)(a2 + 32))
        {
          uint64_t v23 = *(void *)a2;
          *(void *)uint64_t v33 = *(void *)(a2 + 8);
          *(void *)&v33[7] = *(void *)(a2 + 15);
          char v24 = *(unsigned char *)(a2 + 23);
          *(void *)(a2 + 8) = 0;
          *(void *)(a2 + 16) = 0;
          *(void *)a2 = 0;
          long long v29 = *(_OWORD *)(a2 + 24);
          long long v25 = *a4;
          *(void *)(a2 + 16) = *((void *)a4 + 2);
          *(_OWORD *)a2 = v25;
          *((unsigned char *)a4 + 23) = 0;
          *(unsigned char *)a4 = 0;
          *(_OWORD *)(a2 + 24) = *(long long *)((char *)a4 + 24);
          if (*((char *)a4 + 23) < 0) {
            operator delete(*(void **)a4);
          }
          *(void *)a4 = v23;
          *((void *)a4 + 1) = *(void *)v33;
          *(void *)((char *)a4 + 15) = *(void *)&v33[7];
          *((unsigned char *)a4 + 23) = v24;
          *(long long *)((char *)a4 + 24) = v29;
        }
      }
    }
  }
}

BOOL sub_19E45C628(void *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (a4 != a2)
  {
    uint64_t v4 = a4;
    uint64_t v5 = (uint64_t)a3;
    uint64_t v7 = *a3;
    uint64_t v8 = a2 - *a1;
    uint64_t v9 = 1;
    switch(102 * (a3 - a1) - 0x3333333333333333 * ((a4 - *a3) >> 3) + 0x3333333333333333 * (v8 >> 3))
    {
      case 0:
      case 1:
        return v9;
      case 2:
        if (v7 == a4) {
          uint64_t v4 = *(a3 - 1) + 4080;
        }
        if (*(double *)(v4 - 8) >= *(double *)(a2 + 32)) {
          return v9;
        }
        uint64_t v10 = *(void *)a2;
        *(void *)unint64_t v75 = *(void *)(a2 + 8);
        *(void *)&v75[7] = *(void *)(a2 + 15);
        char v11 = *(unsigned char *)(a2 + 23);
        *(void *)(a2 + 8) = 0;
        *(void *)(a2 + 16) = 0;
        *(void *)a2 = 0;
        long long v73 = *(_OWORD *)(a2 + 24);
        uint64_t v12 = *(void *)(v4 - 24);
        *(_OWORD *)a2 = *(_OWORD *)(v4 - 40);
        *(void *)(a2 + 16) = v12;
        *(unsigned char *)(v4 - 17) = 0;
        *(unsigned char *)(v4 - 40) = 0;
        *(_OWORD *)(a2 + 24) = *(_OWORD *)(v4 - 16);
        if (*(char *)(v4 - 17) < 0) {
          operator delete(*(void **)(v4 - 40));
        }
        *(void *)(v4 - 40) = v10;
        *(void *)(v4 - 32) = *(void *)v75;
        *(void *)(v4 - 25) = *(void *)&v75[7];
        *(unsigned char *)(v4 - 17) = v11;
        *(_OWORD *)(v4 - 16) = v73;
        return 1;
      case 3:
        uint64_t v19 = v8 / 40;
        if (v8 < -39)
        {
          unint64_t v32 = 100 - v19;
          char v21 = &a1[-(v32 / 0x66)];
          uint64_t v22 = *v21;
          unint64_t v23 = 101 - v32 % 0x66;
        }
        else
        {
          unint64_t v20 = v19 + 1;
          char v21 = &a1[v20 / 0x66];
          uint64_t v22 = *v21;
          unint64_t v23 = v20 % 0x66;
        }
        if (v7 == a4)
        {
          uint64_t v33 = *(void *)(v5 - 8);
          v5 -= 8;
          uint64_t v4 = v33 + 4080;
        }
        sub_19E45BE10((uint64_t)a1, (uint64_t *)a2, (uint64_t)v21, (long long *)(v22 + 40 * v23), v5, (long long *)(v4 - 40));
        return 1;
      case 4:
        uint64_t v24 = v8 / 40;
        if (v8 >= -39)
        {
          long long v25 = &a1[(v24 + 1) / 0x66uLL];
          long long v26 = (uint64_t *)(*v25 + 40 * ((v24 + 1) % 0x66uLL));
          unint64_t v27 = v24 + 2;
LABEL_27:
          uint64_t v34 = &a1[v27 / 0x66];
          uint64_t v35 = *v34;
          unint64_t v36 = v27 % 0x66;
          goto LABEL_59;
        }
        long long v25 = &a1[-((100 - v24) / 0x66uLL)];
        long long v26 = (uint64_t *)(*v25 + 40 * (101 - (100 - v24) % 0x66uLL));
        if ((unint64_t)v8 >= 0xFFFFFFFFFFFFFFB1)
        {
          unint64_t v27 = 1;
          goto LABEL_27;
        }
        unint64_t v66 = 99 - v24;
        uint64_t v34 = &a1[-(v66 / 0x66)];
        uint64_t v35 = *v34;
        unint64_t v36 = 101 - v66 % 0x66;
LABEL_59:
        if (v7 == v4)
        {
          uint64_t v67 = *(void *)(v5 - 8);
          v5 -= 8;
          uint64_t v4 = v67 + 4080;
        }
        sub_19E45C138((uint64_t)a1, a2, (uint64_t)v25, v26, (uint64_t)v34, (uint64_t *)(v35 + 40 * v36), v5, v4 - 40);
        return 1;
      case 5:
        uint64_t v28 = v8 / 40;
        if (v8 >= -39)
        {
          long long v29 = &a1[(v28 + 1) / 0x66uLL];
          long long v30 = (long long *)(*v29 + 40 * ((v28 + 1) % 0x66uLL));
          unint64_t v31 = v28 + 2;
LABEL_30:
          uint64_t v37 = &a1[v31 / 0x66];
          unint64_t v38 = (long long *)(*v37 + 40 * (v31 % 0x66));
          unint64_t v39 = v28 + 3;
LABEL_31:
          unint64_t v40 = &a1[v39 / 0x66];
          uint64_t v41 = *v40;
          unint64_t v42 = v39 % 0x66;
          goto LABEL_32;
        }
        long long v29 = &a1[-((100 - v28) / 0x66uLL)];
        long long v30 = (long long *)(*v29 + 40 * (101 - (100 - v28) % 0x66uLL));
        if ((unint64_t)v8 >= 0xFFFFFFFFFFFFFFB1)
        {
          unint64_t v31 = 1;
          goto LABEL_30;
        }
        uint64_t v37 = &a1[-((99 - v28) / 0x66uLL)];
        unint64_t v38 = (long long *)(*v37 + 40 * (101 - (99 - v28) % 0x66uLL));
        if ((unint64_t)v8 >= 0xFFFFFFFFFFFFFF89)
        {
          unint64_t v39 = 1;
          goto LABEL_31;
        }
        unint64_t v70 = 98 - v28;
        unint64_t v40 = &a1[-(v70 / 0x66)];
        uint64_t v41 = *v40;
        unint64_t v42 = 101 - v70 % 0x66;
LABEL_32:
        if (v7 == v4)
        {
          uint64_t v43 = *(void *)(v5 - 8);
          v5 -= 8;
          uint64_t v4 = v43 + 4080;
        }
        sub_19E45C360((uint64_t)a1, a2, (uint64_t)v29, v30, (uint64_t)v37, v38, (uint64_t)v40, v41 + 40 * v42, v5, v4 - 40);
        break;
      default:
        uint64_t v13 = v8 / 40;
        if (v8 <= -80)
        {
          uint64_t v14 = &a1[-((99 - v13) / 0x66uLL)];
          unint64_t v15 = *v14 + 40 * (101 - (99 - v13) % 0x66uLL);
          unint64_t v18 = 100 - v13;
        }
        else
        {
          uint64_t v14 = &a1[(v13 + 2) / 0x66uLL];
          unint64_t v15 = *v14 + 40 * ((v13 + 2) % 0x66uLL);
          BOOL v16 = __CFADD__(v13, 1);
          unint64_t v17 = v13 + 1;
          if (!v16)
          {
            uint64_t v44 = &a1[v17 / 0x66];
            uint64_t v45 = (long long *)(*v44 + 40 * (v17 % 0x66));
            goto LABEL_35;
          }
          unint64_t v18 = 101;
        }
        uint64_t v44 = &a1[-(v18 / 0x66)];
        uint64_t v45 = (long long *)(*v44 + 40 * (101 - v18 % 0x66));
LABEL_35:
        sub_19E45BE10((uint64_t)a1, (uint64_t *)a2, (uint64_t)v44, v45, (uint64_t)v14, (long long *)v15);
        uint64_t v46 = v15 - *v14;
        uint64_t v47 = v46 / 40;
        if (v46 < -39)
        {
          unint64_t v52 = 100 - v47;
          uint64_t v49 = &v14[-((100 - v47) / 0x66uLL)];
          unint64_t v50 = *v49;
          unint64_t v51 = 101 - v52 % 0x66;
        }
        else
        {
          unint64_t v48 = v47 + 1;
          uint64_t v49 = &v14[(v47 + 1) / 0x66uLL];
          unint64_t v50 = *v49;
          unint64_t v51 = v48 % 0x66;
        }
        unint64_t v53 = v50 + 40 * v51;
        if (v53 == v4) {
          return 1;
        }
        int v54 = 0;
        uint64_t v71 = v4;
        while (2)
        {
          unint64_t v55 = v53;
          unint64_t v56 = v49;
          double v57 = *(double *)(v53 + 32);
          if (v57 >= *(double *)(v15 + 32)) {
            goto LABEL_56;
          }
          uint64_t v58 = *(void *)v53;
          *(void *)unint64_t v74 = *(void *)(v53 + 8);
          *(void *)&v74[7] = *(void *)(v53 + 15);
          char v59 = *(unsigned char *)(v53 + 23);
          *(void *)(v53 + 8) = 0;
          *(void *)(v53 + 16) = 0;
          *(void *)unint64_t v53 = 0;
          uint64_t v72 = *(void *)(v53 + 24);
          unint64_t v60 = v53;
          do
          {
            unint64_t v63 = v15;
            if (*(char *)(v60 + 23) < 0) {
              operator delete(*(void **)v60);
            }
            long long v64 = *(_OWORD *)v15;
            *(void *)(v60 + 16) = *(void *)(v15 + 16);
            *(_OWORD *)unint64_t v60 = v64;
            *(unsigned char *)(v15 + 23) = 0;
            *(unsigned char *)unint64_t v15 = 0;
            *(_OWORD *)(v60 + 24) = *(_OWORD *)(v15 + 24);
            if (v15 == a2)
            {
              uint64_t v65 = a2;
              goto LABEL_52;
            }
            if (v15 == *v14)
            {
              uint64_t v61 = *--v14;
              unint64_t v62 = v61 + 4080;
            }
            else
            {
              unint64_t v62 = v15;
            }
            unint64_t v15 = v62 - 40;
            unint64_t v60 = v63;
          }
          while (v57 < *(double *)(v62 - 8));
          uint64_t v65 = v63;
LABEL_52:
          if (*(char *)(v65 + 23) < 0) {
            operator delete(*(void **)v65);
          }
          *(void *)uint64_t v65 = v58;
          *(void *)(v65 + 8) = *(void *)v74;
          *(void *)(v65 + 15) = *(void *)&v74[7];
          *(unsigned char *)(v65 + 23) = v59;
          *(void *)(v63 + 24) = v72;
          *(double *)(v65 + 32) = v57;
          if (++v54 != 8)
          {
            unint64_t v50 = *v56;
            uint64_t v4 = v71;
LABEL_56:
            unint64_t v53 = v55 + 40;
            uint64_t v49 = v56;
            if (v55 + 40 - v50 == 4080)
            {
              uint64_t v49 = v56 + 1;
              unint64_t v50 = v56[1];
              unint64_t v53 = v50;
            }
            uint64_t v14 = v56;
            unint64_t v15 = v55;
            if (v53 == v4) {
              return 1;
            }
            continue;
          }
          break;
        }
        unint64_t v69 = v55 + 40;
        if (v55 + 40 - *v56 == 4080) {
          unint64_t v69 = v56[1];
        }
        return v69 == v71;
    }
  }
  return 1;
}

uint64_t sub_19E45CE64(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (*(void *)(a1 + 8) == v1) {
    return 0;
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)(v1 - 8) + 24))();
  }
}

uint64_t sub_19E45CEA0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (*(void **)(a1 + 8) == v1) {
    return 0;
  }
  do
  {
    uint64_t v3 = (*(uint64_t (**)(void))(*(void *)*(v1 - 1) + 16))(*(v1 - 1));
    if (v3) {
      break;
    }
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v6 = *(void *)(v4 - 8);
    uint64_t v1 = (void *)(v4 - 8);
    uint64_t v5 = v6;
    *uint64_t v1 = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    *(void *)(a1 + 16) = v1;
  }
  while (*(void **)(a1 + 8) != v1);
  return v3;
}

void sub_19E45CF58(void *a1)
{
  *a1 = &unk_1EF0B4CE8;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    uint64_t v3 = (void *)a1[2];
    uint64_t v4 = (void *)a1[1];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[1];
    }
    a1[2] = v2;
    operator delete(v4);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E45D024(void *a1)
{
  *a1 = &unk_1EF0B4CE8;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    uint64_t v3 = (void *)a1[2];
    uint64_t v4 = (void *)a1[1];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[1];
    }
    a1[2] = v2;
    operator delete(v4);
  }
  return a1;
}

char *sub_19E45D0D0(void **a1, uint64_t a2)
{
  uint64_t v2 = ((unsigned char *)a1[1] - (unsigned char *)*a1) >> 5;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 59) {
    sub_19E37C7C4();
  }
  uint64_t v5 = (unsigned char *)a1[2] - (unsigned char *)*a1;
  if (v5 >> 4 > v3) {
    unint64_t v3 = v5 >> 4;
  }
  BOOL v6 = (unint64_t)v5 >= 0x7FFFFFFFFFFFFFE0;
  unint64_t v7 = 0x7FFFFFFFFFFFFFFLL;
  if (!v6) {
    unint64_t v7 = v3;
  }
  if (v7 >> 59) {
    sub_19E37C2B8();
  }
  uint64_t v9 = 32 * v7;
  uint64_t v10 = (char *)operator new(32 * v7);
  char v11 = &v10[32 * v2];
  uint64_t v12 = &v10[v9];
  *(_OWORD *)char v11 = *(_OWORD *)a2;
  *((void *)v11 + 2) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *((void *)v11 + 3) = *(void *)(a2 + 24);
  uint64_t v13 = v11 + 32;
  uint64_t v14 = (void **)*a1;
  unint64_t v15 = (void **)a1[1];
  if (v15 == *a1)
  {
    *a1 = v11;
    a1[1] = v13;
    a1[2] = v12;
  }
  else
  {
    do
    {
      long long v16 = *((_OWORD *)v15 - 2);
      *((void *)v11 - 2) = *(v15 - 2);
      *((_OWORD *)v11 - 2) = v16;
      *(v15 - 3) = 0;
      *(v15 - 2) = 0;
      *(v15 - 4) = 0;
      *((void *)v11 - 1) = *(v15 - 1);
      v11 -= 32;
      v15 -= 4;
    }
    while (v15 != v14);
    unint64_t v15 = (void **)*a1;
    unint64_t v17 = (void **)a1[1];
    *a1 = v11;
    a1[1] = v13;
    a1[2] = v12;
    while (v17 != v15)
    {
      if (*((char *)v17 - 9) < 0) {
        operator delete(*(v17 - 4));
      }
      v17 -= 4;
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

uint64_t sub_19E45D208(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    if ((*(char *)(a1 + 31) & 0x80000000) == 0) {
      return a1;
    }
LABEL_5:
    operator delete(*(void **)(a1 + 8));
    return a1;
  }
  if (*(char *)(a1 + 31) < 0) {
    goto LABEL_5;
  }
  return a1;
}

void sub_19E45D258()
{
}

void sub_19E45D354(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v2, 0x10B3C40637D23BDLL);
  MEMORY[0x19F3BDCF0](v1, 0x10B1C402DF695F1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45D398(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = 0;
  uint64_t v2 = (uint64_t *)(a1 + 40);
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 1;
  *(void *)(a1 + 64) = 0;
  unint64_t v3 = (void *)(a1 + 64);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = -1;
  *(void *)a1 = &unk_1EF0BCA28;
  *(void *)(a1 + 8) = 0;
  strcpy((char *)(a1 + 16), "vector");
  *(unsigned char *)(a1 + 39) = 6;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 96))(a2);
  if (*v2) {
    (*(void (**)(uint64_t))(*(void *)*v2 + 8))(*v2);
  }
  if (v4) {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  else {
    uint64_t v5 = 0;
  }
  *uint64_t v2 = v5;
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  uint64_t v7 = *(void *)(a1 + 48);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  if (v6) {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  }
  else {
    uint64_t v8 = 0;
  }
  *(void *)(a1 + 48) = v8;
  *(_DWORD *)(a1 + 88) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  if (!(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a2 + 56))(a2, 1, 0)) {
    goto LABEL_24;
  }
  int v9 = sub_19E45DC88(a2);
  uint64_t v10 = v9;
  char v11 = *(unsigned char **)(a1 + 64);
  if (v9 <= (unint64_t)((uint64_t)(*(void *)(a1 + 80) - (void)v11) >> 3)) {
    goto LABEL_24;
  }
  if (v9 < 0) {
    sub_19E37C7C4();
  }
  uint64_t v12 = *(unsigned char **)(a1 + 72);
  uint64_t v13 = (char *)operator new(8 * v9);
  uint64_t v14 = v12 - v11;
  unint64_t v15 = &v13[(v12 - v11) & 0xFFFFFFFFFFFFFFF8];
  long long v16 = v15;
  if (v12 != v11)
  {
    if ((unint64_t)(v14 - 8) < 0x58)
    {
      long long v16 = &v13[(v12 - v11) & 0xFFFFFFFFFFFFFFF8];
      do
      {
LABEL_21:
        uint64_t v23 = *((void *)v12 - 1);
        v12 -= 8;
        *((void *)v16 - 1) = v23;
        v16 -= 8;
      }
      while (v12 != v11);
      goto LABEL_22;
    }
    long long v16 = &v13[(v12 - v11) & 0xFFFFFFFFFFFFFFF8];
    if (v12 - v13 - (v14 & 0xFFFFFFFFFFFFFFF8) < 0x20) {
      goto LABEL_21;
    }
    uint64_t v17 = v14 >> 3;
    unint64_t v18 = ((unint64_t)(v14 - 8) >> 3) + 1;
    uint64_t v19 = &v13[8 * v17 - 16];
    unint64_t v20 = (long long *)(v12 - 16);
    uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v22 = *v20;
      *((_OWORD *)v19 - 1) = *(v20 - 1);
      *(_OWORD *)uint64_t v19 = v22;
      v19 -= 32;
      v20 -= 2;
      v21 -= 4;
    }
    while (v21);
    long long v16 = &v15[-8 * (v18 & 0x3FFFFFFFFFFFFFFCLL)];
    v12 -= 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
    if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_21;
    }
  }
LABEL_22:
  *(void *)(a1 + 64) = v16;
  *(void *)(a1 + 72) = v15;
  *(void *)(a1 + 80) = &v13[8 * v10];
  if (v11) {
    operator delete(v11);
  }
LABEL_24:
  unsigned int v62 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a2 + 112))(a2, &v60);
  while (1)
  {
    if (!v60)
    {
      uint64_t v24 = v62;
      if ((int)v62 >= v61) {
        goto LABEL_81;
      }
      goto LABEL_33;
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v60 + 16))(v60)) {
      break;
    }
    if (v60) {
      uint64_t v24 = (*(uint64_t (**)(void))(*(void *)v60 + 24))();
    }
    else {
      uint64_t v24 = v62;
    }
LABEL_33:
    sub_19E45DE4C((void *)a1);
    (*(void (**)(int *__return_ptr))(*(void *)a2 + 24))(&v59);
    **(_DWORD **)(*v3 + 8 * (int)v24) = v59;
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v24);
    unint64_t v26 = v25;
    uint64_t v27 = (int)v24;
    uint64_t v28 = *(void **)(*v3 + 8 * (int)v24);
    long long v29 = (unsigned char *)v28[3];
    if (v25 > (uint64_t)(v28[5] - (void)v29) >> 4)
    {
      if (v25 >> 60) {
        sub_19E37C7C4();
      }
      long long v30 = (unsigned char *)v28[4];
      unint64_t v31 = (char *)operator new(16 * v25);
      unint64_t v32 = &v31[v30 - v29];
      uint64_t v33 = v32;
      if (v30 != v29)
      {
        uint64_t v34 = 0;
        do
        {
          uint64_t v35 = &v32[v34];
          *((void *)v35 - 2) = *(void *)&v30[v34 - 16];
          *((_DWORD *)v35 - 2) = *(_DWORD *)&v30[v34 - 8];
          *((_DWORD *)v35 - 1) = *(_DWORD *)&v30[v34 - 4];
          v34 -= 16;
        }
        while (&v30[v34] != v29);
        uint64_t v33 = &v32[v34];
      }
      v28[3] = v33;
      v28[4] = v32;
      v28[5] = &v31[16 * v26];
      if (v29) {
        operator delete(v29);
      }
    }
    unint64_t v58 = 0;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)a2 + 120))(a2, v24, v56);
    while (1)
    {
      if (!v56[0])
      {
        unint64_t v37 = v58;
        if (v58 >= v56[2]) {
          goto LABEL_75;
        }
        goto LABEL_50;
      }
      if ((*(unsigned int (**)(void))(*(void *)v56[0] + 16))(v56[0])) {
        break;
      }
      if (v56[0])
      {
        unint64_t v36 = (_DWORD *)(*(uint64_t (**)(void))(*(void *)v56[0] + 24))();
        goto LABEL_51;
      }
      unint64_t v37 = v58;
LABEL_50:
      unint64_t v36 = (_DWORD *)(v56[1] + 16 * v37);
LABEL_51:
      unint64_t v38 = *(void **)(*v3 + 8 * v27);
      if (*v36)
      {
        if (v36[1]) {
          goto LABEL_53;
        }
      }
      else
      {
        ++v38[1];
        if (v36[1]) {
          goto LABEL_53;
        }
      }
      ++v38[2];
LABEL_53:
      unint64_t v40 = (char *)v38[4];
      unint64_t v39 = v38[5];
      if ((unint64_t)v40 >= v39)
      {
        unint64_t v42 = (char *)v38[3];
        uint64_t v43 = (v40 - v42) >> 4;
        unint64_t v44 = v43 + 1;
        if ((unint64_t)(v43 + 1) >> 60) {
          sub_19E37C7C4();
        }
        uint64_t v45 = v39 - (void)v42;
        if (v45 >> 3 > v44) {
          unint64_t v44 = v45 >> 3;
        }
        if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v46 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v46 = v44;
        }
        if (v46 >> 60) {
          sub_19E37C2B8();
        }
        uint64_t v47 = (char *)operator new(16 * v46);
        unint64_t v48 = &v47[16 * v43];
        *(void *)unint64_t v48 = *(void *)v36;
        *((_DWORD *)v48 + 2) = v36[2];
        *((_DWORD *)v48 + 3) = v36[3];
        if (v40 == v42)
        {
          unint64_t v51 = &v47[16 * v43];
        }
        else
        {
          uint64_t v49 = 0;
          do
          {
            unint64_t v50 = &v48[v49];
            *((void *)v50 - 2) = *(void *)&v40[v49 - 16];
            *((_DWORD *)v50 - 2) = *(_DWORD *)&v40[v49 - 8];
            *((_DWORD *)v50 - 1) = *(_DWORD *)&v40[v49 - 4];
            v49 -= 16;
          }
          while (&v40[v49] != v42);
          unint64_t v51 = &v48[v49];
        }
        unint64_t v52 = &v47[16 * v46];
        uint64_t v41 = v48 + 16;
        void v38[3] = v51;
        v38[4] = v48 + 16;
        v38[5] = v52;
        if (v42) {
          operator delete(v42);
        }
      }
      else
      {
        *(void *)unint64_t v40 = *(void *)v36;
        *((_DWORD *)v40 + 2) = v36[2];
        *((_DWORD *)v40 + 3) = v36[3];
        uint64_t v41 = v40 + 16;
      }
      v38[4] = v41;
      if (v56[0]) {
        (*(void (**)(void))(*(void *)v56[0] + 32))(v56[0]);
      }
      else {
        ++v58;
      }
    }
    if (v56[0])
    {
      (*(void (**)(void))(*(void *)v56[0] + 8))();
      goto LABEL_77;
    }
LABEL_75:
    if (v57) {
      --*v57;
    }
LABEL_77:
    if (v60) {
      (*(void (**)(uint64_t))(*(void *)v60 + 32))(v60);
    }
    else {
      ++v62;
    }
  }
  if (v60) {
    (*(void (**)(void))(*(void *)v60 + 8))();
  }
LABEL_81:
  *(void *)(a1 + 8) = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a2 + 56))(a2, 0x3FFFFFFF0004, 0) | *(void *)(a1 + 8) & 4 | 3;
  return a1;
}

void sub_19E45DBD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_19E45DC88(uint64_t a1)
{
  if ((*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 56))(a1, 1, 0))
  {
    uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 136);
    return v2(a1);
  }
  int v8 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 112))(a1, &v6);
  uint64_t v4 = 0;
  while (1)
  {
    while (!v6)
    {
      int v5 = v8;
      if (v8 >= v7) {
        return v4;
      }
      uint64_t v4 = (v4 + 1);
LABEL_7:
      int v8 = v5 + 1;
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 16))(v6)) {
      break;
    }
    uint64_t v4 = (v4 + 1);
    if (!v6)
    {
      int v5 = v8;
      goto LABEL_7;
    }
    (*(void (**)(void))(*(void *)v6 + 32))();
  }
  if (v6) {
    (*(void (**)(void))(*(void *)v6 + 8))();
  }
  return v4;
}

void sub_19E45DE14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E45DE4C(void *a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  unint64_t v3 = v2;
  *(_DWORD *)uint64_t v2 = 2139095039;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  *((void *)v2 + 5) = 0;
  int v5 = (char *)a1[9];
  unint64_t v4 = a1[10];
  uint64_t v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    int v8 = (char *)a1[8];
    uint64_t v9 = (v5 - v8) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v11 = v4 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        sub_19E37C2B8();
      }
      uint64_t v13 = operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    unint64_t v15 = &v13[8 * v12];
    void *v14 = v3;
    int v7 = v14 + 1;
    if (v5 == v8)
    {
      int v8 = v5;
    }
    else
    {
      unint64_t v16 = v5 - v8 - 8;
      if (v16 < 0x58) {
        goto LABEL_29;
      }
      if ((unint64_t)(v8 - v13) < 0x20) {
        goto LABEL_29;
      }
      uint64_t v17 = (v16 >> 3) + 1;
      uint64_t v6 = &v5[-8 * (v17 & 0x3FFFFFFFFFFFFFFCLL)];
      unint64_t v18 = &v13[8 * v9 - 16];
      uint64_t v19 = v5 - 16;
      uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v21 = *(_OWORD *)v19;
        *(v18 - 1) = *((_OWORD *)v19 - 1);
        *unint64_t v18 = v21;
        v18 -= 2;
        v19 -= 32;
        v20 -= 4;
      }
      while (v20);
      v14 -= v17 & 0x3FFFFFFFFFFFFFFCLL;
      if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_29:
        do
        {
          uint64_t v22 = *((void *)v6 - 1);
          v6 -= 8;
          *--uint64_t v14 = v22;
        }
        while (v6 != v8);
        int v8 = (char *)a1[8];
      }
    }
    a1[8] = v14;
    a1[9] = v7;
    a1[10] = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(void *)int v5 = v2;
    int v7 = v5 + 8;
  }
  a1[9] = v7;
  return (((unint64_t)v7 - a1[8]) >> 3) - 1;
}

uint64_t sub_19E45DFE4(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BCE68;
  uint64_t v4 = a1 + 64;
  uint64_t v2 = *(void **)(a1 + 64);
  unint64_t v3 = *(void **)(v4 + 8);
  if (v3 == v2)
  {
    uint64_t v2 = v3;
  }
  else
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = (void *)v2[v5];
      if (v6)
      {
        int v7 = (void *)v6[3];
        if (v7)
        {
          v6[4] = v7;
          operator delete(v7);
        }
        operator delete(v6);
        uint64_t v2 = *(void **)(a1 + 64);
        unint64_t v3 = *(void **)(a1 + 72);
      }
      ++v5;
    }
    while (v5 < v3 - v2);
  }
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  *(void *)a1 = &unk_1EF0BCF98;
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 48);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

uint64_t sub_19E45E10C(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 8) & a2;
}

uint64_t sub_19E45E118(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void sub_19E45E120(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BCF98;
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E45E1E8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BCF98;
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_19E45E290(uint64_t a1)
{
  sub_19E45DFE4(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E45E2CC(uint64_t a1)
{
  sub_19E45DFE4(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E45E308(uint64_t result, float *a2)
{
  uint64_t v2 = *(void **)(result + 8);
  uint64_t v3 = *(void *)(result + 24);
  uint64_t v4 = v2[3];
  unint64_t v5 = (int *)(v4 + 16 * v3);
  int v7 = *v5;
  int v6 = v5[1];
  if (*v5 != v6) {
    **(void **)(result + 16) &= ~0x20000uLL;
  }
  if (v7)
  {
    if (!v6)
    {
      uint64_t v8 = *(unint64_t **)(result + 16);
      unint64_t v9 = *v8;
LABEL_8:
      *uint64_t v8 = v9 & 0xFFFFFFFFFBFFFFFFLL;
    }
  }
  else
  {
    uint64_t v8 = *(unint64_t **)(result + 16);
    unint64_t v10 = *v8;
    *v8 &= ~0x1000000uLL;
    if (!v6)
    {
      unint64_t v9 = v10 & 0xFFFFFFFFFEBFFFFFLL;
      *uint64_t v8 = v9;
      goto LABEL_8;
    }
  }
  uint64_t v11 = v4 + 16 * v3;
  float v13 = *(float *)(v11 + 8);
  unint64_t v12 = (_DWORD *)(v11 + 8);
  float v14 = v13;
  if (v13 != 3.4028e38 && v14 != 0.0) {
    **(void **)(result + 16) &= ~0x100000000uLL;
  }
  if (v7)
  {
    if (v6) {
      goto LABEL_14;
    }
  }
  else
  {
    --v2[1];
    if (v6)
    {
LABEL_14:
      if (*(_DWORD *)a2) {
        goto LABEL_15;
      }
      goto LABEL_24;
    }
  }
  --v2[2];
  if (*(_DWORD *)a2)
  {
LABEL_15:
    if (*((_DWORD *)a2 + 1)) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_24:
  ++v2[1];
  if (!*((_DWORD *)a2 + 1)) {
LABEL_16:
  }
    ++v2[2];
LABEL_17:
  *(void *)unint64_t v5 = *(void *)a2;
  *unint64_t v12 = *((_DWORD *)a2 + 2);
  *(float *)(v4 + 16 * v3 + 12) = a2[3];
  int v15 = *(_DWORD *)a2;
  int v16 = *((_DWORD *)a2 + 1);
  if (*(_DWORD *)a2 != v16) {
    **(void **)(result + 16) = **(void **)(result + 16) & 0xFFFFFFFFFFFCFFFFLL | 0x20000;
  }
  if (v15)
  {
    if (!v16)
    {
      uint64_t v17 = *(unint64_t **)(result + 16);
      unint64_t v18 = *v17;
LABEL_28:
      *uint64_t v17 = v18 & 0xFFFFFFFFF3FFFFFFLL | 0x4000000;
    }
  }
  else
  {
    uint64_t v17 = *(unint64_t **)(result + 16);
    unint64_t v19 = *v17 & 0xFFFFFFFFFCFFFFFFLL | 0x1000000;
    *uint64_t v17 = v19;
    if (!v16)
    {
      unint64_t v18 = v19 & 0xFFFFFFFFFD3FFFFFLL | 0x400000;
      *uint64_t v17 = v18;
      goto LABEL_28;
    }
  }
  if (a2[2] != 3.4028e38 && a2[2] != 0.0) {
    **(void **)(result + 16) = **(void **)(result + 16) & 0xFFFFFFFCFFFFFFFFLL | 0x100000000;
  }
  **(void **)(result + 16) &= 0x30FC30007uLL;
  return result;
}

uint64_t sub_19E45E538()
{
  return 15;
}

uint64_t sub_19E45E540(uint64_t result, uint64_t a2)
{
  *(void *)(result + 24) = a2;
  return result;
}

uint64_t sub_19E45E548(uint64_t result)
{
  *(void *)(result + 24) = 0;
  return result;
}

uint64_t sub_19E45E550(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_19E45E558(uint64_t result)
{
  return result;
}

uint64_t sub_19E45E568(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 24) + 16 * *(void *)(a1 + 24);
}

BOOL sub_19E45E57C(uint64_t a1)
{
  return *(void *)(a1 + 24) >= (unint64_t)((uint64_t)(*(void *)(*(void *)(a1 + 8) + 32)
                                                            - *(void *)(*(void *)(a1 + 8) + 24)) >> 4);
}

void sub_19E45E598()
{
}

uint64_t sub_19E45E5B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(int *)(v3 + 56) >= 2) {
    operator new();
  }
  uint64_t v4 = *(void *)(v3 + 48);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  if (a2) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  }
  else {
    uint64_t result = 0;
  }
  *(void *)(v3 + 48) = result;
  return result;
}

void sub_19E45E6B4(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45E6D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(int *)(v3 + 56) >= 2) {
    operator new();
  }
  uint64_t v4 = *(void *)(v3 + 40);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  if (a2) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  }
  else {
    uint64_t result = 0;
  }
  *(void *)(v3 + 40) = result;
  return result;
}

void sub_19E45E7DC(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45E800(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(int *)(v1 + 56) >= 2) {
    operator new();
  }
  return *(void *)(v1 + 48);
}

void sub_19E45E898(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45E8BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(int *)(v1 + 56) >= 2) {
    operator new();
  }
  return *(void *)(v1 + 40);
}

void sub_19E45E954(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

void sub_19E45E978(uint64_t a1, int a2, size_t __sz)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(int *)(v3 + 56) >= 2) {
    operator new();
  }
  uint64_t v4 = *(void **)(*(void *)(v3 + 64) + 8 * a2);
  unint64_t v5 = (unsigned char *)v4[3];
  if (__sz > (uint64_t)(v4[5] - (void)v5) >> 4)
  {
    if (__sz >> 60) {
      sub_19E37C7C4();
    }
    int v6 = (unsigned char *)v4[4];
    size_t v7 = 16 * __sz;
    uint64_t v8 = (char *)operator new(16 * __sz);
    unint64_t v9 = &v8[v6 - v5];
    unint64_t v10 = v9;
    if (v6 != v5)
    {
      uint64_t v11 = 0;
      do
      {
        unint64_t v12 = &v9[v11];
        *((void *)v12 - 2) = *(void *)&v6[v11 - 16];
        *((_DWORD *)v12 - 2) = *(_DWORD *)&v6[v11 - 8];
        *((_DWORD *)v12 - 1) = *(_DWORD *)&v6[v11 - 4];
        v11 -= 16;
      }
      while (&v6[v11] != v5);
      unint64_t v10 = &v9[v11];
    }
    void v4[3] = v10;
    v4[4] = v9;
    v4[5] = &v8[v7];
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_19E45EAD0(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

void sub_19E45EAF4(uint64_t a1, size_t __sz)
{
  int v2 = __sz;
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(int *)(v3 + 56) >= 2) {
    operator new();
  }
  uint64_t v4 = *(unsigned char **)(v3 + 64);
  if ((int)__sz > (unint64_t)((uint64_t)(*(void *)(v3 + 80) - (void)v4) >> 3))
  {
    if ((__sz & 0x80000000) != 0) {
      sub_19E37C7C4();
    }
    unint64_t v5 = *(unsigned char **)(v3 + 72);
    int v6 = (char *)operator new(8 * (int)__sz);
    uint64_t v7 = v5 - v4;
    uint64_t v8 = &v6[(v5 - v4) & 0xFFFFFFFFFFFFFFF8];
    unint64_t v9 = v8;
    if (v5 == v4) {
      goto LABEL_13;
    }
    if ((unint64_t)(v7 - 8) >= 0x58)
    {
      unint64_t v9 = &v6[(v5 - v4) & 0xFFFFFFFFFFFFFFF8];
      if ((unint64_t)(v5 - &v6[v7 & 0xFFFFFFFFFFFFFFF8]) >= 0x20)
      {
        uint64_t v10 = v7 >> 3;
        unint64_t v11 = ((unint64_t)(v7 - 8) >> 3) + 1;
        unint64_t v12 = &v6[8 * v10 - 16];
        float v13 = (long long *)(v5 - 16);
        uint64_t v14 = v11 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v15 = *v13;
          *((_OWORD *)v12 - 1) = *(v13 - 1);
          *(_OWORD *)unint64_t v12 = v15;
          v12 -= 32;
          v13 -= 2;
          v14 -= 4;
        }
        while (v14);
        unint64_t v9 = &v8[-8 * (v11 & 0x3FFFFFFFFFFFFFFCLL)];
        v5 -= 8 * (v11 & 0x3FFFFFFFFFFFFFFCLL);
        if (v11 == (v11 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_13:
          *(void *)(v3 + 64) = v9;
          *(void *)(v3 + 72) = v8;
          *(void *)(v3 + 80) = &v6[8 * v2];
          if (v4)
          {
            operator delete(v4);
          }
          return;
        }
      }
    }
    else
    {
      unint64_t v9 = &v6[(v5 - v4) & 0xFFFFFFFFFFFFFFF8];
    }
    do
    {
      uint64_t v16 = *((void *)v5 - 1);
      v5 -= 8;
      *((void *)v9 - 1) = v16;
      v9 -= 8;
    }
    while (v5 != v4);
    goto LABEL_13;
  }
}

void sub_19E45EC9C(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45ECC0(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(int *)(v2 + 56) >= 2) {
    operator new();
  }
  uint64_t v3 = *(void **)(*(void *)(v2 + 64) + 8 * a2);
  v3[1] = 0;
  v3[2] = 0;
  v3[4] = v3[3];
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  *(void *)(v2 + 8) = *(void *)(v2 + 8) & 4 | result & 0xA6A5A950007;
  return result;
}

void sub_19E45EDBC(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45EDE0(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(int *)(v3 + 56) >= 2) {
    operator new();
  }
  if (a3)
  {
    uint64_t v4 = *(void **)(*(void *)(v3 + 64) + 8 * a2);
    uint64_t v5 = v4[4];
    int v6 = (_DWORD *)(v5 - 16);
    uint64_t v7 = a3;
    while (1)
    {
      if (*v6)
      {
        if (!v6[1]) {
          goto LABEL_10;
        }
      }
      else
      {
        --v4[1];
        if (!v6[1]) {
LABEL_10:
        }
          --v4[2];
      }
      v6 -= 4;
      if (!--v7)
      {
        v4[4] = v5 - 16 * a3;
        break;
      }
    }
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  *(void *)(v3 + 8) = *(void *)(v3 + 8) & 4 | result & 0xA6A5A950007;
  return result;
}

void sub_19E45EF34(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45EF58(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(int *)(v1 + 56) >= 2) {
    operator new();
  }
  uint64_t v3 = *(void *)(v1 + 64);
  uint64_t v2 = *(void *)(v1 + 72);
  if (v2 == v3)
  {
    uint64_t v3 = *(void *)(v1 + 72);
  }
  else
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void **)(v3 + 8 * v4);
      if (v5)
      {
        int v6 = (void *)v5[3];
        if (v6)
        {
          v5[4] = v6;
          operator delete(v6);
        }
        operator delete(v5);
        uint64_t v3 = *(void *)(v1 + 64);
        uint64_t v2 = *(void *)(v1 + 72);
      }
      ++v4;
    }
    while (v4 < (v2 - v3) >> 3);
  }
  *(void *)(v1 + 72) = v3;
  *(_DWORD *)(v1 + 88) = -1;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
  *(void *)(v1 + 8) = (*(_DWORD *)(v1 + 8) | result) & 4 | 0x156A5A950003;
  return result;
}

void sub_19E45F098(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45F0BC(uint64_t a1, char **a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(int *)(v3 + 56) >= 2) {
    operator new();
  }
  uint64_t v5 = *(char **)(v3 + 64);
  unint64_t v4 = *(char **)(v3 + 72);
  unint64_t v6 = v4 - v5;
  unint64_t v7 = (v4 - v5) >> 3;
  if (v4 == v5)
  {
    uint64_t v8 = 0;
  }
  else
  {
    if ((v6 & 0x8000000000000000) != 0) {
      sub_19E37C7C4();
    }
    uint64_t v8 = operator new(v6 >> 1);
    bzero(v8, 4 * v7);
  }
  unint64_t v9 = *a2;
  uint64_t v10 = a2[1] - *a2;
  if (v10)
  {
    unint64_t v11 = v10 >> 2;
    if (v11 <= 1) {
      unint64_t v11 = 1;
    }
    do
    {
      uint64_t v12 = *(int *)v9;
      v9 += 4;
      *((_DWORD *)v8 + v12) = -1;
      --v11;
    }
    while (v11);
  }
  if (v4 == v5)
  {
    int v14 = 0;
    long long v15 = v4;
  }
  else
  {
    unint64_t v13 = 0;
    int v14 = 0;
    unint64_t v4 = v5;
    do
    {
      if (*((_DWORD *)v8 + v13) == -1)
      {
        uint64_t v16 = *(void **)&v4[8 * v13];
        if (v16)
        {
          uint64_t v17 = (void *)v16[3];
          if (v17)
          {
            v16[4] = v17;
            operator delete(v17);
          }
          operator delete(v16);
        }
      }
      else
      {
        *((_DWORD *)v8 + v13) = v14;
        if (v13 != v14) {
          *(void *)&v4[8 * v14] = *(void *)&v4[8 * v13];
        }
        ++v14;
      }
      ++v13;
      unint64_t v4 = *(char **)(v3 + 64);
      long long v15 = *(char **)(v3 + 72);
      unint64_t v7 = (v15 - v4) >> 3;
    }
    while (v7 > v13);
  }
  uint64_t v18 = v14;
  BOOL v19 = v14 >= v7;
  unint64_t v20 = v14 - v7;
  if (v20 == 0 || !v19)
  {
    if (!v19)
    {
      long long v29 = &v4[8 * v18];
      *(void *)(v3 + 72) = v29;
      if (v29 == v4) {
        goto LABEL_74;
      }
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  uint64_t v22 = *(char **)(v3 + 72);
  uint64_t v21 = *(void *)(v3 + 80);
  if (v20 <= (v21 - (uint64_t)v22) >> 3)
  {
    bzero(*(void **)(v3 + 72), 8 * v20);
    long long v15 = &v22[8 * v20];
    *(void *)(v3 + 72) = v15;
    unint64_t v4 = *(char **)(v3 + 64);
LABEL_39:
    if (v15 == v4) {
      goto LABEL_74;
    }
    goto LABEL_40;
  }
  uint64_t v23 = *(unsigned char **)(v3 + 64);
  uint64_t v24 = (v22 - v23) >> 3;
  unint64_t v25 = v24 + v20;
  if ((v24 + v20) >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v26 = v21 - (void)v23;
  if (v26 >> 2 > v25) {
    unint64_t v25 = v26 >> 2;
  }
  if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v27 = v25;
  }
  if (v27)
  {
    if (v27 >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v28 = (char *)operator new(8 * v27);
  }
  else
  {
    uint64_t v28 = 0;
  }
  unint64_t v48 = &v28[8 * v24];
  size_t v49 = 8 * v20;
  unint64_t v50 = &v28[8 * v27];
  bzero(v48, v49);
  unint64_t v51 = &v48[v49];
  if (v22 != v23)
  {
    unint64_t v52 = v22 - v23 - 8;
    if (v52 < 0x58) {
      goto LABEL_84;
    }
    if ((unint64_t)(v23 - v28) < 0x20) {
      goto LABEL_84;
    }
    uint64_t v53 = (v52 >> 3) + 1;
    int v54 = &v28[8 * v24 - 16];
    unint64_t v55 = v22 - 16;
    uint64_t v56 = v53 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v57 = *(_OWORD *)v55;
      *((_OWORD *)v54 - 1) = *((_OWORD *)v55 - 1);
      *(_OWORD *)int v54 = v57;
      v54 -= 32;
      v55 -= 32;
      v56 -= 4;
    }
    while (v56);
    v48 -= 8 * (v53 & 0x3FFFFFFFFFFFFFFCLL);
    v22 -= 8 * (v53 & 0x3FFFFFFFFFFFFFFCLL);
    if (v53 != (v53 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_84:
      do
      {
        uint64_t v58 = *((void *)v22 - 1);
        v22 -= 8;
        *((void *)v48 - 1) = v58;
        v48 -= 8;
      }
      while (v22 != v23);
    }
    uint64_t v22 = *(char **)(v3 + 64);
  }
  *(void *)(v3 + 64) = v48;
  *(void *)(v3 + 72) = v51;
  *(void *)(v3 + 80) = v50;
  if (v22)
  {
    operator delete(v22);
    unint64_t v51 = *(char **)(v3 + 72);
  }
  unint64_t v4 = *(char **)(v3 + 64);
  if (v51 != v4)
  {
LABEL_40:
    uint64_t v30 = 0;
    while (1)
    {
      uint64_t v31 = *(void *)&v4[8 * v30];
      uint64_t v32 = *(void *)(v31 + 24);
      uint64_t v33 = *(void *)(v31 + 32);
      int64x2_t v34 = *(int64x2_t *)(v31 + 8);
      uint64_t v35 = v33 - v32;
      uint64_t v36 = v33 == v32 ? 0 : *(void *)(v31 + 24);
      if (v33 == v32)
      {
        uint64_t v38 = 0;
        unint64_t v40 = v35 >> 4;
      }
      else
      {
        unint64_t v37 = 0;
        uint64_t v38 = 0;
        unint64_t v39 = (int *)(v36 + 12);
        do
        {
          int v41 = *((_DWORD *)v8 + *v39);
          if (v41 == -1)
          {
            uint64_t v43 = *(void *)(v39 - 3);
            v44.i64[0] = v43;
            v44.i64[1] = HIDWORD(v43);
            int64x2_t v34 = vaddq_s64(v34, vceqzq_s64(v44));
          }
          else
          {
            *unint64_t v39 = v41;
            if (v37 != v38)
            {
              uint64_t v42 = v36 + 16 * v38;
              *(void *)uint64_t v42 = *(void *)(v39 - 3);
              *(_DWORD *)(v42 + 8) = *(v39 - 1);
              *(_DWORD *)(v42 + 12) = v41;
              unint64_t v4 = *(char **)(v3 + 64);
            }
            ++v38;
          }
          ++v37;
          uint64_t v31 = *(void *)&v4[8 * v30];
          uint64_t v33 = *(void *)(v31 + 32);
          unint64_t v40 = (v33 - *(void *)(v31 + 24)) >> 4;
          v39 += 4;
        }
        while (v37 < v40);
      }
      uint64_t v45 = v40 - v38;
      if (v45) {
        break;
      }
LABEL_42:
      *(int64x2_t *)(v31 + 8) = v34;
      if (++v30 >= (unint64_t)((uint64_t)(*(void *)(v3 + 72) - (void)v4) >> 3)) {
        goto LABEL_74;
      }
    }
    unint64_t v46 = (_DWORD *)(v33 - 16);
    uint64_t v47 = v45;
    while (1)
    {
      if (*v46)
      {
        if (!v46[1]) {
LABEL_61:
        }
          --*(void *)(v31 + 16);
      }
      else
      {
        --*(void *)(v31 + 8);
        if (!v46[1]) {
          goto LABEL_61;
        }
      }
      v46 -= 4;
      if (!--v47)
      {
        *(void *)(v31 + 32) = v33 - 16 * v45;
        uint64_t v31 = *(void *)&v4[8 * v30];
        goto LABEL_42;
      }
    }
  }
LABEL_74:
  uint64_t v59 = *(int *)(v3 + 88);
  if (v59 != -1)
  {
    *(_DWORD *)(v3 + 88) = *((_DWORD *)v8 + v59);
LABEL_77:
    operator delete(v8);
    goto LABEL_78;
  }
  if (v8) {
    goto LABEL_77;
  }
LABEL_78:
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  *(void *)(v3 + 8) = *(void *)(v3 + 8) & 4 | result & 0x6A5A950007;
  return result;
}

void sub_19E45F598(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

void sub_19E45F5BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (v11)
  {
    operator delete(v11);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E45F5F0(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  if (*(int *)(v5 + 56) >= 2) {
    operator new();
  }
  uint64_t v6 = *(void *)(*(void *)(*(void *)(v5 + 64) + 8 * a2) + 32);
  if (v6 == *(void *)(*(void *)(*(void *)(v5 + 64) + 8 * a2) + 24)) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = (unsigned int *)(v6 - 16);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  unsigned int v10 = *a3;
  unsigned int v9 = a3[1];
  unint64_t v11 = v8 & 0xFFFFFFFFFFFCFFFFLL | 0x20000;
  if (*a3 == v9) {
    unint64_t v11 = v8;
  }
  unint64_t v12 = v11 & 0xFFFFFFFFFCFFFFFFLL | 0x1000000;
  if (!v9) {
    unint64_t v12 = v11 & 0xFFFFFFFFFC3FFFFFLL | 0x1400000;
  }
  if (!v10) {
    unint64_t v11 = v12;
  }
  if (!v9) {
    unint64_t v11 = v11 & 0xFFFFFFFFF3FFFFFFLL | 0x4000000;
  }
  if (v7)
  {
    if (*v7 > v10) {
      unint64_t v11 = v11 & 0xFFFFFFFFCFFFFFFFLL | 0x20000000;
    }
    if (v7[1] > v9) {
      unint64_t v11 = v11 & 0xFFFFFFFF3FFFFFFFLL | 0x80000000;
    }
  }
  float v13 = *((float *)a3 + 2);
  if (v13 != 3.4028e38 && v13 != 0.0) {
    unint64_t v11 = v11 & 0xFFFFFFFCFFFFFFFFLL | 0x100000000;
  }
  int v14 = a3[3];
  if (v14 <= a2) {
    unint64_t v11 = v11 & 0xFFFFFF3FFFFFFFFFLL | 0x8000000000;
  }
  if ((v11 & 0x4000000000) != 0) {
    uint64_t v15 = v11 & 0x5D7FFEB0007 | 0x2800000000;
  }
  else {
    uint64_t v15 = v11 & 0x5D7FFEB0007;
  }
  *(void *)(v5 + 8) = *(void *)(v5 + 8) & 4 | v15;
  uint64_t v16 = *(void **)(*(void *)(v5 + 64) + 8 * a2);
  if (v10)
  {
    if (v9) {
      goto LABEL_29;
    }
  }
  else
  {
    ++v16[1];
    if (v9) {
      goto LABEL_29;
    }
  }
  ++v16[2];
LABEL_29:
  uint64_t v18 = (char *)v16[4];
  unint64_t v17 = v16[5];
  if ((unint64_t)v18 >= v17)
  {
    unint64_t v20 = (char *)v16[3];
    uint64_t v21 = (v18 - v20) >> 4;
    unint64_t v22 = v21 + 1;
    if ((unint64_t)(v21 + 1) >> 60) {
      sub_19E37C7C4();
    }
    uint64_t v23 = v17 - (void)v20;
    if (v23 >> 3 > v22) {
      unint64_t v22 = v23 >> 3;
    }
    BOOL v24 = (unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
    if (!v24) {
      unint64_t v25 = v22;
    }
    if (v25 >> 60) {
      sub_19E37C2B8();
    }
    uint64_t v26 = 16 * v25;
    unint64_t v27 = (char *)operator new(16 * v25);
    uint64_t v28 = (float *)&v27[16 * v21];
    *(void *)uint64_t v28 = *(void *)a3;
    v28[2] = v13;
    *((_DWORD *)v28 + 3) = v14;
    BOOL v19 = (char *)(v28 + 4);
    if (v18 != v20)
    {
      unint64_t v29 = 0;
      do
      {
        uint64_t v30 = (char *)&v28[v29 / 4];
        *((void *)v30 - 2) = *(void *)&v18[v29 - 16];
        *((_DWORD *)v30 - 2) = *(_DWORD *)&v18[v29 - 8];
        *((_DWORD *)v30 - 1) = *(_DWORD *)&v18[v29 - 4];
        v29 -= 16;
      }
      while (&v18[v29] != v20);
      uint64_t v28 = (float *)((char *)v28 + v29);
    }
    v16[3] = v28;
    v16[4] = v19;
    v16[5] = &v27[v26];
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    *(void *)uint64_t v18 = *(void *)a3;
    *((_DWORD *)v18 + 2) = a3[2];
    *((_DWORD *)v18 + 3) = a3[3];
    BOOL v19 = v18 + 16;
  }
  v16[4] = v19;
}

void sub_19E45F920(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45F944(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(int *)(v1 + 56) >= 2) {
    operator new();
  }
  uint64_t v2 = sub_19E45DE4C((void *)v1);
  *(void *)(v1 + 8) = *(void *)(v1 + 8) & 4 | (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1) & 0x2AFFFFFF0007;
  return v2;
}

void sub_19E45FA30(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45FA54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a3 & 4;
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), v6);
  uint64_t v8 = v6 & a2;
  uint64_t v9 = *(void *)(a1 + 8);
  if (result != v8 && *(int *)(v9 + 56) >= 2) {
    operator new();
  }
  *(void *)(v9 + 8) = *(void *)(v9 + 8) & (~a3 | 4) | a3 & a2;
  return result;
}

void sub_19E45FB50(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

unint64_t sub_19E45FB74(uint64_t a1, int a2, float *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(int *)(v3 + 56) >= 2) {
    operator new();
  }
  float v4 = *a3;
  uint64_t v5 = *(float **)(*(void *)(v3 + 64) + 8 * a2);
  float v6 = *v5;
  *uint64_t v5 = *a3;
  unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  if (v6 != 3.4028e38 && v6 != 0.0) {
    result &= ~0x100000000uLL;
  }
  if (v4 != 3.4028e38 && v4 != 0.0) {
    unint64_t result = result & 0xFFFFFFFCFFFFFFFFLL | 0x100000000;
  }
  *(void *)(v3 + 8) = *(void *)(v3 + 8) & 4 | result & 0x3FFFFFF0007;
  return result;
}

void sub_19E45FD0C(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

unint64_t sub_19E45FD30(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(int *)(v2 + 56) >= 2) {
    operator new();
  }
  *(_DWORD *)(v2 + 88) = a2;
  unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  *(void *)(v2 + 8) = result & 0xCCFFFFF0007 | (((result >> 35) & 1) << 37) | *(void *)(v2 + 8) & 4;
  return result;
}

void sub_19E45FE24(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45FE48(uint64_t result, uint64_t a2)
{
  if (result != a2) {
    operator new();
  }
  return result;
}

void sub_19E45FEE4(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10B3C40637D23BDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E45FF08(uint64_t a1)
{
  return (*(void *)(*(void *)(a1 + 8) + 72) - *(void *)(*(void *)(a1 + 8) + 64)) >> 3;
}

uint64_t sub_19E45FF1C()
{
  return 0;
}

uint64_t sub_19E45FF24(uint64_t result, int a2, void *a3)
{
  uint64_t v3 = *(void *)(result + 8);
  *a3 = 0;
  uint64_t v5 = (uint64_t *)(*(void *)(*(void *)(v3 + 64) + 8 * a2) + 24);
  uint64_t v4 = *v5;
  uint64_t v6 = (v5[1] - *v5) >> 4;
  if (v5[1] == *v5) {
    uint64_t v4 = 0;
  }
  a3[1] = v4;
  a3[2] = v6;
  a3[3] = 0;
  return result;
}

uint64_t sub_19E45FF50(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 8) = (*(void *)(v2 + 72) - *(void *)(v2 + 64)) >> 3;
  return result;
}

uint64_t sub_19E45FF6C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 48);
}

uint64_t sub_19E45FF78(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 40);
}

uint64_t sub_19E45FF88(uint64_t *a1, void **a2)
{
  v19[19] = *MEMORY[0x1E4F143B8];
  if (*((char *)a2 + 23) < 0)
  {
    if (a2[1])
    {
LABEL_5:
      sub_19E3AB0C4((uint64_t *)v15);
      if ((v18[*((void *)v15[0] - 3)] & 5) != 0)
      {
        HIBYTE(v13) = 5;
        strcpy((char *)__p, "ERROR");
        uint64_t v4 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
        sub_19E37CA70(v4, (uint64_t)": ", 2);
        uint64_t v5 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Fst::Write: Can't open file: ", 29);
        int v6 = *((char *)a2 + 23);
        if (v6 >= 0) {
          unint64_t v7 = a2;
        }
        else {
          unint64_t v7 = *a2;
        }
        if (v6 >= 0) {
          uint64_t v8 = *((unsigned __int8 *)a2 + 23);
        }
        else {
          uint64_t v8 = (uint64_t)a2[1];
        }
        sub_19E37CA70(v5, (uint64_t)v7, v8);
        sub_19E43C8CC();
        if (SHIBYTE(v13) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v9 = 0;
      }
      else
      {
        if (*((char *)a2 + 23) < 0)
        {
          sub_19E39369C(__p, *a2, (unint64_t)a2[1]);
        }
        else
        {
          *(_OWORD *)unint64_t __p = *(_OWORD *)a2;
          float v13 = a2[2];
        }
        int v14 = 65793;
        uint64_t v9 = (*(uint64_t (**)(uint64_t *, void **, void **))(*a1 + 80))(a1, v15, __p);
        if (SHIBYTE(v13) < 0) {
          operator delete(__p[0]);
        }
      }
      v15[0] = *(void **)MEMORY[0x1E4FBA400];
      *(void **)((char *)v15 + *((void *)v15[0] - 3)) = *(void **)(MEMORY[0x1E4FBA400] + 24);
      MEMORY[0x19F3BD8C0](&v15[1]);
      std::ostream::~ostream();
      MEMORY[0x19F3BDC30](v19);
      return v9;
    }
  }
  else if (*((unsigned char *)a2 + 23))
  {
    goto LABEL_5;
  }
  strcpy((char *)v15, "standard output");
  uint64_t v10 = *a1;
  int v16 = 16843023;
  char v17 = 0;
  uint64_t v9 = (*(uint64_t (**)(uint64_t *, void, void **))(v10 + 80))(a1, MEMORY[0x1E4FBA250], v15);
  if ((char)v16 < 0) {
    operator delete(v15[0]);
  }
  return v9;
}

void sub_19E460280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

uint64_t sub_19E4602E4(void *a1, void *a2, uint64_t a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  long long v31 = 0u;
  long long v32 = 0u;
  *(_OWORD *)unint64_t v29 = 0u;
  *(_OWORD *)uint64_t v30 = 0u;
  uint64_t v6 = -1;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v33 = -1;
  uint64_t v33 = (*(int (**)(void *))(*a1 + 16))(a1);
  uint64_t v34 = -1;
  if ((*(uint64_t (**)(void *, uint64_t, void))(*a1 + 56))(a1, 1, 0))
  {
    uint64_t v6 = 0;
LABEL_3:
    int v7 = 0;
    uint64_t v34 = (int)sub_19E45DC88((uint64_t)a1);
    goto LABEL_6;
  }
  uint64_t v8 = (char *)a2 + *(void *)(*a2 - 24);
  if ((v8[32] & 5) == 0)
  {
    (*(void (**)(void **__return_ptr))(**((void **)v8 + 5) + 32))(__p);
    uint64_t v6 = v38;
    if (v38 != -1) {
      goto LABEL_3;
    }
  }
  int v7 = 1;
LABEL_6:
  uint64_t v9 = (*(uint64_t (**)(void *, uint64_t, void))(*a1 + 56))(a1, 0x3FFFFFFF0004, 0) | 3;
  char v37 = 6;
  strcpy((char *)__p, "vector");
  sub_19E4608AC((uint64_t)a1, (uint64_t)a2, (unsigned char *)a3, 2, __p, v9, (uint64_t)&v28 + 4);
  uint64_t v27 = v6;
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  unint64_t v10 = *(void *)(a1[1] + 72) - *(void *)(a1[1] + 64);
  unint64_t v11 = v10 >> 3;
  if ((int)(v10 >> 3) < 1)
  {
    LODWORD(v11) = 0;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v13 = (v10 >> 3);
    do
    {
      (*(void (**)(void **__return_ptr, void *, uint64_t))(*a1 + 24))(&v28, a1, v12);
      LODWORD(__p[0]) = v28;
      std::ostream::write();
      __p[0] = (void *)(*(uint64_t (**)(void *, uint64_t))(*a1 + 32))(a1, v12);
      std::ostream::write();
      uint64_t v14 = *(void *)(*(void *)(*(void *)(a1[1] + 64) + 8 * v12) + 24);
      uint64_t v15 = *(void *)(*(void *)(*(void *)(a1[1] + 64) + 8 * v12) + 32) - v14;
      if (v15)
      {
        unint64_t v16 = v15 >> 4;
        if (v16 <= 1) {
          uint64_t v17 = 1;
        }
        else {
          uint64_t v17 = v16;
        }
        uint64_t v18 = (_DWORD *)(v14 + 8);
        do
        {
          LODWORD(__p[0]) = *(v18 - 2);
          std::ostream::write();
          LODWORD(__p[0]) = *(v18 - 1);
          std::ostream::write();
          LODWORD(__p[0]) = *v18;
          std::ostream::write();
          LODWORD(__p[0]) = v18[1];
          std::ostream::write();
          v18 += 4;
          --v17;
        }
        while (v17);
      }
      ++v12;
    }
    while (v12 != v13);
  }
  std::ostream::flush();
  if ((*((unsigned char *)a2 + *(void *)(*a2 - 24) + 32) & 5) != 0)
  {
    char v37 = 5;
    strcpy((char *)__p, "ERROR");
    BOOL v19 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
    sub_19E37CA70(v19, (uint64_t)": ", 2);
    unint64_t v20 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"VectorFst::Write: write failed: ", 32);
    int v21 = *(char *)(a3 + 23);
    if (v21 >= 0) {
      uint64_t v22 = a3;
    }
    else {
      uint64_t v22 = *(void *)a3;
    }
    if (v21 >= 0) {
      uint64_t v23 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v23 = *(void *)(a3 + 8);
    }
    sub_19E37CA70(v20, v22, v23);
LABEL_27:
    sub_19E43C8CC();
    if (v37 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v24 = 0;
    goto LABEL_30;
  }
  if (!v7)
  {
    if (v34 == v11)
    {
      uint64_t v24 = 1;
      goto LABEL_30;
    }
    char v37 = 5;
    strcpy((char *)__p, "ERROR");
    uint64_t v26 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
    sub_19E37CA70(v26, (uint64_t)": ", 2);
    sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Inconsistent number of states observed during write", 51);
    goto LABEL_27;
  }
  uint64_t v34 = v11;
  char v37 = 6;
  strcpy((char *)__p, "vector");
  uint64_t v24 = sub_19E460CC0((uint64_t)a1, a2, a3, 2, __p, v9, (uint64_t)&v28 + 4, v27);
  if (v37 < 0) {
    operator delete(__p[0]);
  }
LABEL_30:
  if (SHIBYTE(v31) < 0)
  {
    operator delete(v30[1]);
    if ((SHIBYTE(v30[0]) & 0x80000000) == 0) {
      return v24;
    }
LABEL_37:
    operator delete(v29[0]);
    return v24;
  }
  if (SHIBYTE(v30[0]) < 0) {
    goto LABEL_37;
  }
  return v24;
}

void sub_19E460810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
  {
    operator delete(__p);
    if ((a24 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a18 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a24 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a19);
  if ((a18 & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(a1);
LABEL_7:
  operator delete(a13);
  _Unwind_Resume(a1);
}

uint64_t sub_19E4608AC(uint64_t a1, uint64_t a2, unsigned char *a3, int a4, void **a5, uint64_t a6, uint64_t a7)
{
  if (a3[24])
  {
    if ((void **)(a7 + 8) != a5)
    {
      char v13 = *((unsigned char *)a5 + 23);
      if (*(char *)(a7 + 31) < 0)
      {
        if (v13 >= 0) {
          uint64_t v15 = a5;
        }
        else {
          uint64_t v15 = *a5;
        }
        if (v13 >= 0) {
          size_t v16 = *((unsigned __int8 *)a5 + 23);
        }
        else {
          size_t v16 = (size_t)a5[1];
        }
        sub_19E3C6D44((void **)(a7 + 8), v15, v16);
      }
      else if ((*((unsigned char *)a5 + 23) & 0x80) != 0)
      {
        sub_19E3C6C7C((void *)(a7 + 8), *a5, (size_t)a5[1]);
      }
      else
      {
        long long v14 = *(_OWORD *)a5;
        *(void *)(a7 + ++*(void *)(result + 24) = a5[2];
        *(_OWORD *)(a7 + 8) = v14;
      }
    }
    sub_19E461128();
    if ((long long *)(a7 + 32) != &xmmword_1EC009620)
    {
      if (*(char *)(a7 + 55) < 0)
      {
        if (byte_1EC009637 >= 0) {
          uint64_t v17 = &xmmword_1EC009620;
        }
        else {
          uint64_t v17 = (long long *)xmmword_1EC009620;
        }
        if (byte_1EC009637 >= 0) {
          size_t v18 = byte_1EC009637;
        }
        else {
          size_t v18 = *((void *)&xmmword_1EC009620 + 1);
        }
        sub_19E3C6D44((void **)(a7 + 32), v17, v18);
      }
      else if (byte_1EC009637 < 0)
      {
        sub_19E3C6C7C((void *)(a7 + 32), (void *)xmmword_1EC009620, *((size_t *)&xmmword_1EC009620 + 1));
      }
      else
      {
        *(_OWORD *)(a7 + 32) = xmmword_1EC009620;
        *(void *)(a7 + 48) = unk_1EC009630;
      }
    }
    *(_DWORD *)(a7 + 56) = a4;
    *(void *)(a7 + 64) = a6;
    if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1)) {
      BOOL v19 = a3[25] == 0;
    }
    else {
      BOOL v19 = 1;
    }
    int v20 = !v19;
    uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104))(a1);
    if (a3[26]) {
      BOOL v22 = v21 == 0;
    }
    else {
      BOOL v22 = 1;
    }
    int v23 = v20 | 2;
    if (v22) {
      int v23 = v20;
    }
    if (a3[27]) {
      v23 |= 4u;
    }
    *(_DWORD *)(a7 + 60) = v23;
    std::ostream::write();
    std::ostream::write();
    std::ostream::write();
    std::ostream::write();
    std::ostream::write();
    std::ostream::write();
    std::ostream::write();
    std::ostream::write();
    std::ostream::write();
    std::ostream::write();
    std::ostream::write();
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1)) {
    BOOL v24 = a3[25] == 0;
  }
  else {
    BOOL v24 = 1;
  }
  if (!v24)
  {
    uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 72))(v25, a2);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104))(a1);
  if (result) {
    BOOL v27 = a3[26] == 0;
  }
  else {
    BOOL v27 = 1;
  }
  if (!v27)
  {
    uint64_t v28 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 104))(a1) + 72);
    return v28();
  }
  return result;
}

uint64_t sub_19E460CC0(uint64_t a1, void *a2, uint64_t a3, int a4, void **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  MEMORY[0x19F3BD970](v29);
  size_t v16 = (char *)a2 + *(void *)(*a2 - 24);
  if ((v16[32] & 5) == 0)
  {
    uint64_t v17 = *((void *)v16 + 5);
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long __p = 0u;
    long long v32 = 0u;
    uint64_t v39 = a8;
    (*(void (**)(void *__return_ptr))(*(void *)v17 + 40))(v30);
    if (v30[16] == -1) {
      std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 4);
    }
  }
  MEMORY[0x19F3BD980](v29);
  if ((*((unsigned char *)a2 + *(void *)(*a2 - 24) + 32) & 5) != 0)
  {
    BYTE7(v32) = 5;
    strcpy((char *)&__p, "ERROR");
    size_t v18 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)&__p, 5);
    sub_19E37CA70(v18, (uint64_t)": ", 2);
    BOOL v19 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Fst::UpdateFstHeader: write failed: ", 36);
    int v20 = *(char *)(a3 + 23);
    if (v20 >= 0) {
      uint64_t v21 = a3;
    }
    else {
      uint64_t v21 = *(void *)a3;
    }
    if (v20 >= 0) {
      uint64_t v22 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v22 = *(void *)(a3 + 8);
    }
  }
  else
  {
    sub_19E4608AC(a1, (uint64_t)a2, (unsigned char *)a3, a4, a5, a6, a7);
    if ((*((unsigned char *)a2 + *(void *)(*a2 - 24) + 32) & 5) != 0)
    {
      BYTE7(v32) = 5;
      strcpy((char *)&__p, "ERROR");
      int v23 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)&__p, 5);
      sub_19E37CA70(v23, (uint64_t)": ", 2);
      BOOL v19 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Fst::UpdateFstHeader: write failed: ", 36);
      int v24 = *(char *)(a3 + 23);
      if (v24 >= 0) {
        uint64_t v21 = a3;
      }
      else {
        uint64_t v21 = *(void *)a3;
      }
      if (v24 >= 0) {
        uint64_t v22 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v22 = *(void *)(a3 + 8);
      }
    }
    else
    {
      MEMORY[0x19F3BD970](v30, a2);
      uint64_t v25 = (char *)a2 + *(void *)(*a2 - 24);
      if ((v25[32] & 5) == 0)
      {
        (*(void (**)(long long *__return_ptr))(**((void **)v25 + 5) + 32))(&__p);
        if (v39 == -1) {
          std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 4);
        }
      }
      MEMORY[0x19F3BD980](v30);
      if ((*((unsigned char *)a2 + *(void *)(*a2 - 24) + 32) & 5) == 0) {
        return 1;
      }
      BYTE7(v32) = 5;
      strcpy((char *)&__p, "ERROR");
      uint64_t v26 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)&__p, 5);
      sub_19E37CA70(v26, (uint64_t)": ", 2);
      BOOL v19 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Fst::UpdateFstHeader: write failed: ", 36);
      int v27 = *(char *)(a3 + 23);
      if (v27 >= 0) {
        uint64_t v21 = a3;
      }
      else {
        uint64_t v21 = *(void *)a3;
      }
      if (v27 >= 0) {
        uint64_t v22 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v22 = *(void *)(a3 + 8);
      }
    }
  }
  sub_19E37CA70(v19, v21, v22);
  sub_19E43C8CC();
  if (SBYTE7(v32) < 0) {
    operator delete((void *)__p);
  }
  return 0;
}

void sub_19E4610BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
}

void sub_19E4610F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void sub_19E461128()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009600, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC009600))
  {
    sub_19E461238();
    if (sub_19E461308((const void **)&xmmword_1EC009608, "tropical"))
    {
      sub_19E382340(&xmmword_1EC009620, "standard");
    }
    else
    {
      sub_19E461238();
      if (byte_1EC00961F < 0)
      {
        sub_19E39369C(&xmmword_1EC009620, (void *)xmmword_1EC009608, *((unint64_t *)&xmmword_1EC009608 + 1));
      }
      else
      {
        xmmword_1EC009620 = xmmword_1EC009608;
        unk_1EC009630 = unk_1EC009618;
      }
    }
    __cxa_atexit(MEMORY[0x1E4FBA210], &xmmword_1EC009620, &dword_19E36B000);
    __cxa_guard_release(&qword_1EC009600);
  }
}

void sub_19E461220(_Unwind_Exception *a1)
{
}

void sub_19E461238()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC0095F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EC0095F8))
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    sub_19E420378((std::string *)&xmmword_1EC009608, "tropical", &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    __cxa_atexit(MEMORY[0x1E4FBA210], &xmmword_1EC009608, &dword_19E36B000);
    __cxa_guard_release(&qword_1EC0095F8);
  }
}

void sub_19E4612E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  __cxa_guard_abort(&qword_1EC0095F8);
  _Unwind_Resume(a1);
}

BOOL sub_19E461308(const void **a1, char *__s)
{
  int v4 = *((char *)a1 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (v5 != strlen(__s)) {
    return 0;
  }
  if (v4 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *a1;
  }
  return memcmp(v6, __s, v5) == 0;
}

void sub_19E461380()
{
}

uint64_t sub_19E4613E8(uint64_t a1)
{
  return *(void *)(a1 + 8) + 16;
}

uint64_t sub_19E4613F4(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v8 = 0;
    unint64_t v5 = sub_19E4614A8(a1, a2, &v8);
    *(void *)(*(void *)(a1 + 8) + 8) = *(void *)(*(void *)(a1 + 8) + 8) & (~v8 | 4) | v8 & v5;
    return v5 & a2;
  }
  else
  {
    int v7 = *(uint64_t (**)(void))(**(void **)(a1 + 8) + 24);
    return v7();
  }
}

unint64_t sub_19E4614A8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = 0x155555550000;
  unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 56))(a1, 0x3FFFFFFF0007, 0);
  uint64_t v8 = result & 0x3FFFFFFF0000 | (2 * result) & 0x2AAAAAAA0000 | (result >> 1) & 0x155555550000 | 7;
  if ((a2 & ~v8) != 0)
  {
    result &= 7u;
    unint64_t v31 = result;
    if ((a2 & 0xF3C00000000) != 0)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      unint64_t v28 = 0;
      unint64_t v29 = &v31;
      sub_19E461EC4(a1, (uint64_t)&v26);
    }
    if ((a2 & 0xFFFFF0C3FFFFFFF8) == 0) {
      goto LABEL_79;
    }
    uint64_t v22 = a2 & 0xC0000;
    uint64_t v9 = 0x10425A810000;
    if ((a2 & 0xC0000) != 0) {
      uint64_t v9 = 0x10425A850000;
    }
    unint64_t v10 = result | v9;
    if ((a2 & 0x300000) != 0) {
      v10 |= 0x100000uLL;
    }
    unint64_t v31 = v10;
    unsigned int v25 = 0;
    (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 112))(a1, &v23);
    int v11 = 0;
LABEL_11:
    if (!v23)
    {
      uint64_t v12 = v25;
      if ((int)v25 >= v24) {
        goto LABEL_74;
      }
      if (v22) {
LABEL_18:
      }
        operator new();
      goto LABEL_19;
    }
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v23 + 16))(v23))
    {
      if (v23)
      {
        uint64_t v12 = (*(uint64_t (**)(void))(*(void *)v23 + 24))();
        if (v22) {
          goto LABEL_18;
        }
      }
      else
      {
        uint64_t v12 = v25;
        if (v22) {
          goto LABEL_18;
        }
      }
LABEL_19:
      if ((a2 & 0x300000) != 0) {
        operator new();
      }
      unint64_t v30 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 120))(a1, v12, &v26);
      int v13 = v12 + 1;
      char v14 = 1;
      while (1)
      {
        if (v26)
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)v26 + 16))(v26))
          {
            if (v26)
            {
              (*(void (**)(void))(*(void *)v26 + 8))();
              goto LABEL_60;
            }
LABEL_58:
            if (v29) {
              --*(_DWORD *)v29;
            }
LABEL_60:
            if (v11 > 0) {
              unint64_t v31 = v31 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000;
            }
            (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 24))(&v32, a1, v12);
            LODWORD(v26) = v32;
            HIDWORD(v32) = 2139095039;
            if (*(float *)&v32 == 3.4028e38)
            {
              if ((*(uint64_t (**)(uint64_t, uint64_t, float, float))(*(void *)a1 + 32))(a1, v12, 3.4028e38, *(float *)&v32) != 1)unint64_t v31 = v31 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000; {
            }
              }
            else
            {
              LODWORD(v26) = v32;
              HIDWORD(v32) = 0;
              if (*(float *)&v32 != 0.0) {
                unint64_t v31 = v31 & 0xFFFFFFFCFFFFFFFFLL | 0x100000000;
              }
              ++v11;
            }
            if (v23) {
              (*(void (**)(uint64_t))(*(void *)v23 + 32))(v23);
            }
            else {
              ++v25;
            }
            goto LABEL_11;
          }
          if (v26)
          {
            uint64_t v15 = (*(uint64_t (**)(void))(*(void *)v26 + 24))();
            goto LABEL_31;
          }
          unint64_t v16 = v30;
        }
        else
        {
          unint64_t v16 = v30;
          if (v30 >= v28) {
            goto LABEL_58;
          }
        }
        uint64_t v15 = v27 + 16 * v16;
LABEL_31:
        unsigned int v17 = *(_DWORD *)v15;
        unsigned int v18 = *(_DWORD *)v15;
        if (*(_DWORD *)v15 != *(_DWORD *)(v15 + 4))
        {
          unint64_t v31 = v31 & 0xFFFFFFFFFFFCFFFFLL | 0x20000;
          unsigned int v18 = *(_DWORD *)(v15 + 4);
        }
        if (v17 | v18)
        {
          if (v17)
          {
            if (!v18) {
              goto LABEL_41;
            }
            goto LABEL_37;
          }
          unint64_t v19 = v31;
        }
        else
        {
          unint64_t v19 = v31 & 0xFFFFFFFFFF3FFFFFLL | 0x400000;
        }
        unint64_t v31 = v19 & 0xFFFFFFFFFCFFFFFFLL | 0x1000000;
        if (!v18)
        {
LABEL_41:
          unint64_t v31 = v31 & 0xFFFFFFFFF3FFFFFFLL | 0x4000000;
          if (v14) {
            goto LABEL_46;
          }
          goto LABEL_42;
        }
LABEL_37:
        if (v14) {
          goto LABEL_46;
        }
LABEL_42:
        if (v17 < v6) {
          unint64_t v31 = v31 & 0xFFFFFFFFCFFFFFFFLL | 0x20000000;
        }
        if (v18 < HIDWORD(v6)) {
          unint64_t v31 = v31 & 0xFFFFFFFF3FFFFFFFLL | 0x80000000;
        }
LABEL_46:
        HIDWORD(v32) = 0;
        float v20 = *(float *)(v15 + 8);
        *((float *)&v32 + 1) = v20;
        LODWORD(v32) = 0;
        if (v20 != 0.0)
        {
          *((float *)&v32 + 1) = v20;
          LODWORD(v32) = 2139095039;
          if (v20 != 3.4028e38) {
            unint64_t v31 = v31 & 0xFFFFFFFCFFFFFFFFLL | 0x100000000;
          }
        }
        int v21 = *(_DWORD *)(v15 + 12);
        if (v21 <= (int)v12)
        {
          unint64_t v31 = v31 & 0xFFFFFF3FFFFFFFFFLL | 0x8000000000;
          if (v21 != v13)
          {
LABEL_53:
            unint64_t v31 = v31 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000;
            uint64_t v6 = *(void *)v15;
            goto LABEL_54;
          }
        }
        else if (v21 != v13)
        {
          goto LABEL_53;
        }
        uint64_t v6 = *(void *)v15;
LABEL_54:
        if (v26)
        {
          (*(void (**)(uint64_t))(*(void *)v26 + 32))(v26);
          char v14 = 0;
        }
        else
        {
          char v14 = 0;
          ++v30;
        }
      }
    }
    if (v23) {
      (*(void (**)(void))(*(void *)v23 + 8))();
    }
LABEL_74:
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1) == -1)
    {
      unint64_t result = v31;
    }
    else if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1))
    {
      unint64_t result = v31 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000;
    }
    else
    {
      unint64_t result = v31;
    }
LABEL_79:
    uint64_t v8 = result & 0x3FFFFFFF0000 | (2 * result) & 0x2AAAAAAA0000 | (result >> 1) & 0x155555550000 | 7;
  }
  *a3 = v8;
  return result;
}

void sub_19E461E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (!a12) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  _Unwind_Resume(exception_object);
}

void sub_19E461EC4(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2) {
    *(void *)(*(void *)a2 + 8) = **(void **)a2;
  }
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3) {
    *(void *)(v3 + 8) = 0;
  }
  uint64_t v4 = *(void *)(a2 + 16);
  if (v4)
  {
    *(void *)(v4 + 8) = 0;
    *(unsigned char *)(a2 + 52) = 0;
    **(void **)(a2 + ++*(void *)(result + 24) = **(void **)(a2 + 24) & 0xFFFFF0C3FFFFFFFFLL | 0x52800000000;
    *(void *)(a2 + 32) = a1;
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    *(_DWORD *)(a2 + 44) = 0;
    *(_DWORD *)(a2 + 48) = 0;
    *(_DWORD *)(a2 + 40) = v5;
    operator new();
  }
  operator new();
}

void sub_19E462E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  sub_19E464434(&a23);
  long long v33 = *(void **)(v31 + 56);
  sub_19E464514((uint64_t)&a31);
  if (v33) {
    operator delete(v33);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E462F7C(uint64_t result)
{
  uint64_t v1 = (void *)result;
  uint64_t v2 = *(unint64_t **)result;
  if (*(void *)result)
  {
    unint64_t v3 = *v2;
    uint64_t v4 = v2[1] - *v2;
    if (v4)
    {
      unint64_t v5 = v4 >> 2;
      uint64_t v6 = (const float *)(result + 48);
      if (v5 <= 1) {
        unint64_t v5 = 1;
      }
      if (v5 < 8 || (v3 < result + 52 ? (BOOL v7 = (unint64_t)v6 >= v3 + 4 * v5) : (BOOL v7 = 1), !v7))
      {
        unint64_t v8 = 0;
LABEL_16:
        unint64_t v13 = v5 - v8;
        char v14 = (_DWORD *)(v3 + 4 * v8);
        do
        {
          _DWORD *v14 = *(_DWORD *)v6 + ~*v14;
          ++v14;
          --v13;
        }
        while (v13);
        goto LABEL_18;
      }
      unint64_t v8 = v5 & 0xFFFFFFFFFFFFFFF8;
      int32x4_t v9 = (int32x4_t)vld1q_dup_f32(v6);
      unint64_t v10 = (int8x16_t *)(v3 + 16);
      unint64_t v11 = v5 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        int32x4_t v12 = vaddq_s32(v9, (int32x4_t)vmvnq_s8(*v10));
        v10[-1] = (int8x16_t)vaddq_s32(v9, (int32x4_t)vmvnq_s8(v10[-1]));
        *unint64_t v10 = (int8x16_t)v12;
        v10 += 2;
        v11 -= 8;
      }
      while (v11);
      if (v5 != v8) {
        goto LABEL_16;
      }
    }
  }
LABEL_18:
  if (*(unsigned char *)(result + 52))
  {
    uint64_t v15 = *(void ***)(result + 16);
    if (v15)
    {
      if (*v15) {
        operator delete(*v15);
      }
      unint64_t result = MEMORY[0x19F3BDCF0](v15, 0x1010C40113C0ABBLL);
    }
  }
  uint64_t v16 = v1[7];
  if (v16)
  {
    unsigned int v17 = *(void **)v16;
    if (*(void *)v16)
    {
      *(void *)(v16 + 8) = v17;
      operator delete(v17);
    }
    unint64_t result = MEMORY[0x19F3BDCF0](v16, 0x10C402FEFCB83);
  }
  uint64_t v18 = v1[8];
  if (v18)
  {
    unint64_t v19 = *(void **)v18;
    if (*(void *)v18)
    {
      *(void *)(v18 + 8) = v19;
      operator delete(v19);
    }
    unint64_t result = MEMORY[0x19F3BDCF0](v18, 0x10C402FEFCB83);
  }
  float v20 = (void **)v1[9];
  if (v20)
  {
    if (*v20) {
      operator delete(*v20);
    }
    unint64_t result = MEMORY[0x19F3BDCF0](v20, 0x1010C40113C0ABBLL);
  }
  uint64_t v21 = v1[10];
  if (v21)
  {
    uint64_t v22 = *(void **)v21;
    if (*(void *)v21)
    {
      *(void *)(v21 + 8) = v22;
      operator delete(v22);
    }
    JUMPOUT(0x19F3BDCF0);
  }
  return result;
}

void sub_19E46314C(unint64_t *a1, unint64_t a2, const char *a3)
{
  unint64_t v7 = a1[1];
  unint64_t v6 = a1[2];
  unint64_t v8 = (char *)v7;
  if (v6 - v7 >= a2)
  {
    if (!a2)
    {
LABEL_60:
      a1[1] = (unint64_t)v8;
      return;
    }
    uint64_t v15 = (char *)(v7 + a2);
    if (a2 < 8) {
      goto LABEL_58;
    }
    if (v7 < (unint64_t)(a3 + 1) && v15 > a3) {
      goto LABEL_58;
    }
    if (a2 >= 0x20)
    {
      unint64_t v17 = a2 & 0xFFFFFFFFFFFFFFE0;
      int8x16_t v27 = vld1q_dup_s8(a3);
      unint64_t v28 = (int8x16_t *)(v7 + 16);
      unint64_t v29 = a2 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v28[-1] = v27;
        *unint64_t v28 = v27;
        v28 += 2;
        v29 -= 32;
      }
      while (v29);
      if (v17 == a2) {
        goto LABEL_59;
      }
      if ((a2 & 0x18) == 0)
      {
        unint64_t v8 = (char *)(v7 + v17);
        goto LABEL_58;
      }
    }
    else
    {
      unint64_t v17 = 0;
    }
    unint64_t v30 = a2 & 0xFFFFFFFFFFFFFFF8;
    int8x8_t v31 = vld1_dup_s8(a3);
    unint64_t v32 = v17 - (a2 & 0xFFFFFFFFFFFFFFF8);
    long long v33 = (int8x8_t *)(v7 + v17);
    do
    {
      *v33++ = v31;
      v32 += 8;
    }
    while (v32);
    if (v30 == a2) {
      goto LABEL_59;
    }
    unint64_t v8 = (char *)(v7 + v30);
    do
LABEL_58:
      *v8++ = *a3;
    while (v8 != v15);
LABEL_59:
    unint64_t v8 = (char *)(v7 + a2);
    goto LABEL_60;
  }
  int32x4_t v9 = (char *)*a1;
  unint64_t v10 = v7 - *a1;
  unint64_t v11 = v10 + a2;
  if ((uint64_t)(v10 + a2) < 0) {
    sub_19E37C7C4();
  }
  unint64_t v12 = v6 - (void)v9;
  if (2 * v12 > v11) {
    unint64_t v11 = 2 * v12;
  }
  if (v12 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v13 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v13 = v11;
  }
  if (v13) {
    char v14 = (char *)operator new(v13);
  }
  else {
    char v14 = 0;
  }
  unint64_t v18 = (unint64_t)&v14[v10];
  unint64_t v19 = &v14[v10 + a2];
  float v20 = &v14[v10];
  if (a2 < 8) {
    goto LABEL_42;
  }
  if (v18 < (unint64_t)(a3 + 1))
  {
    float v20 = &v14[v10];
    if (v19 > a3) {
      goto LABEL_42;
    }
  }
  unsigned int v21 = *(unsigned __int8 *)a3;
  if (a2 >= 0x20)
  {
    unint64_t v22 = a2 & 0xFFFFFFFFFFFFFFE0;
    int8x16_t v23 = vdupq_n_s8(v21);
    int v24 = (int8x16_t *)&v14[v10 + 16];
    unint64_t v25 = a2 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v24[-1] = v23;
      *int v24 = v23;
      v24 += 2;
      v25 -= 32;
    }
    while (v25);
    if (v22 == a2)
    {
      uint64_t v26 = v9;
      goto LABEL_44;
    }
    if ((a2 & 0x18) == 0)
    {
      float v20 = (char *)(v18 + v22);
      goto LABEL_42;
    }
  }
  else
  {
    unint64_t v22 = 0;
  }
  unint64_t v34 = a2 & 0xFFFFFFFFFFFFFFF8;
  int8x8_t v35 = vdup_n_s8(v21);
  unint64_t v36 = v22 - (a2 & 0xFFFFFFFFFFFFFFF8);
  long long v37 = (int8x8_t *)&v14[v22 + v7 - (void)v9];
  do
  {
    *v37++ = v35;
    v36 += 8;
  }
  while (v36);
  uint64_t v26 = v9;
  if (v34 != a2)
  {
    float v20 = (char *)(v18 + v34);
    do
LABEL_42:
      *v20++ = *a3;
    while (v20 != v19);
    uint64_t v26 = (char *)*a1;
  }
LABEL_44:
  unint64_t v38 = v7 - (void)v26;
  if ((char *)v7 != v26)
  {
    if (v38 < 0x20) {
      goto LABEL_65;
    }
    if ((unint64_t)(v9 - v14) < 0x20) {
      goto LABEL_65;
    }
    unint64_t v8 = (char *)(v7 - (v38 & 0xFFFFFFFFFFFFFFE0));
    uint64_t v39 = (long long *)(v7 - 16);
    uint64_t v40 = &v14[v7 - 16 - (void)v9];
    unint64_t v41 = v38 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      long long v42 = *v39;
      *((_OWORD *)v40 - 1) = *(v39 - 1);
      *(_OWORD *)uint64_t v40 = v42;
      v39 -= 2;
      v40 -= 32;
      v41 -= 32;
    }
    while (v41);
    v18 -= v38 & 0xFFFFFFFFFFFFFFE0;
    if (v38 == (v38 & 0xFFFFFFFFFFFFFFE0))
    {
      unint64_t v8 = v26;
    }
    else
    {
LABEL_65:
      do
      {
        char v43 = *--v8;
        *(unsigned char *)--unint64_t v18 = v43;
      }
      while (v8 != v26);
      unint64_t v8 = (char *)*a1;
    }
  }
  *a1 = v18;
  a1[1] = (unint64_t)v19;
  a1[2] = (unint64_t)&v14[v13];
  if (v8)
  {
    operator delete(v8);
  }
}

void sub_19E463418(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unint64_t v6 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_88:
      *(void *)unint64_t v5 = v8;
      goto LABEL_89;
    }
    int32x4_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v33 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v33 = 1;
      }
      if (!(v33 >> 61))
      {
        unint64_t v34 = v33 >> 2;
        uint64_t v35 = 8 * v33;
        unint64_t v36 = (char *)operator new(8 * v33);
        long long v37 = &v36[8 * v34];
        unint64_t v38 = &v36[v35];
        int64_t v40 = v5 - v7;
        BOOL v39 = v5 == v7;
        unint64_t v5 = v37;
        if (!v39)
        {
          unint64_t v5 = &v37[v40 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v41 = v40 - 8;
          if ((unint64_t)(v40 - 8) >= 0x38)
          {
            unint64_t v83 = &v36[8 * v34];
            long long v42 = v83;
            if ((unint64_t)(v83 - v7) >= 0x20)
            {
              uint64_t v84 = (v41 >> 3) + 1;
              uint64_t v85 = 8 * (v84 & 0x3FFFFFFFFFFFFFFCLL);
              long long v42 = &v37[v85];
              unint64_t v86 = (long long *)(v6 + 3);
              uint64_t v87 = v83 + 16;
              uint64_t v88 = v84 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v89 = *v86;
                *(v87 - 1) = *(v86 - 1);
                _OWORD *v87 = v89;
                v86 += 2;
                v87 += 2;
                v88 -= 4;
              }
              while (v88);
              if (v84 == (v84 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_81;
              }
              v7 += v85;
            }
          }
          else
          {
            long long v42 = &v36[8 * v34];
          }
          do
          {
            uint64_t v90 = *(void *)v7;
            v7 += 8;
            *(void *)long long v42 = v90;
            v42 += 8;
          }
          while (v42 != v5);
        }
        goto LABEL_81;
      }
LABEL_106:
      sub_19E37C2B8();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      unint64_t v7 = *(char **)(a1 + 8);
    }
    unint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_88;
  }
  unint64_t v18 = *(char **)(a1 + 16);
  unint64_t v17 = *(char **)(a1 + 24);
  float v20 = *(char **)a1;
  unint64_t v19 = *(char **)(a1 + 8);
  uint64_t v21 = v18 - v19;
  uint64_t v22 = (v18 - v19) >> 3;
  uint64_t v23 = (uint64_t)&v17[-*(void *)a1];
  if (v22 < (unint64_t)(v23 >> 3))
  {
    int v24 = operator new(0x1000uLL);
    unint64_t v25 = v24;
    if (v17 != v18)
    {
      *(void *)unint64_t v18 = v24;
LABEL_89:
      *(void *)(a1 + 16) += 8;
      return;
    }
    if (v19 != v20)
    {
      char v43 = v19;
      goto LABEL_87;
    }
    unint64_t v68 = (v17 - v19) >> 2;
    if (v18 == v19) {
      unint64_t v68 = 1;
    }
    if (v68 >> 61) {
      goto LABEL_106;
    }
    unint64_t v69 = (v68 + 3) >> 2;
    uint64_t v70 = 8 * v68;
    uint64_t v71 = (char *)operator new(8 * v68);
    char v43 = &v71[8 * v69];
    uint64_t v72 = &v71[v70];
    long long v73 = v43;
    if (v18 != v19)
    {
      long long v73 = &v43[8 * v22];
      unint64_t v74 = &v71[8 * v69];
      unint64_t v75 = v19;
      if ((unint64_t)(v21 - 8) > 0x37)
      {
        double v76 = &v71[8 * v69];
        unint64_t v74 = v76;
        unint64_t v75 = v19;
        if ((unint64_t)(v76 - v19) >= 0x20)
        {
          unint64_t v77 = ((unint64_t)(v21 - 8) >> 3) + 1;
          uint64_t v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v74 = &v43[v78];
          unint64_t v79 = (long long *)(v19 + 16);
          unint64_t v80 = v76 + 16;
          uint64_t v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v82 = *v79;
            *(v80 - 1) = *(v79 - 1);
            _OWORD *v80 = v82;
            v79 += 2;
            v80 += 2;
            v81 -= 4;
          }
          while (v81);
          if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *(void *)a1 = v71;
            *(void *)(a1 + 8) = v43;
            *(void *)(a1 + 16) = v73;
            *(void *)(a1 + ++*(void *)(result + 24) = v72;
LABEL_86:
            operator delete(v19);
            char v43 = *(char **)(a1 + 8);
LABEL_87:
            *((void *)v43 - 1) = v25;
            unint64_t v7 = *(char **)(a1 + 8);
            unint64_t v5 = *(char **)(a1 + 16);
            *(void *)(a1 + 8) = v7 - 8;
            uint64_t v8 = *((void *)v7 - 1);
            *(void *)(a1 + 8) = v7;
            if (v5 != *(char **)(a1 + 24)) {
              goto LABEL_88;
            }
            int32x4_t v9 = *(char **)a1;
            uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
            if ((unint64_t)v7 <= *(void *)a1)
            {
              unint64_t v92 = (v5 - v9) >> 2;
              if (v5 == v9) {
                unint64_t v92 = 1;
              }
              if (!(v92 >> 61))
              {
                unint64_t v93 = v92 >> 2;
                uint64_t v94 = 8 * v92;
                unint64_t v36 = (char *)operator new(8 * v92);
                long long v37 = &v36[8 * v93];
                unint64_t v38 = &v36[v94];
                int64_t v95 = v5 - v7;
                BOOL v39 = v5 == v7;
                unint64_t v5 = v37;
                if (!v39)
                {
                  unint64_t v5 = &v37[v95 & 0xFFFFFFFFFFFFFFF8];
                  unint64_t v96 = v95 - 8;
                  if ((unint64_t)(v95 - 8) >= 0x38)
                  {
                    uint64_t v98 = &v36[8 * v93];
                    unint64_t v97 = v98;
                    if ((unint64_t)(v98 - v7) >= 0x20)
                    {
                      uint64_t v99 = (v96 >> 3) + 1;
                      uint64_t v100 = 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
                      unint64_t v97 = &v37[v100];
                      uint64_t v101 = (long long *)(v7 + 16);
                      uint64_t v102 = v98 + 16;
                      uint64_t v103 = v99 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v104 = *v101;
                        *(v102 - 1) = *(v101 - 1);
                        *uint64_t v102 = v104;
                        v101 += 2;
                        v102 += 2;
                        v103 -= 4;
                      }
                      while (v103);
                      if (v99 == (v99 & 0x3FFFFFFFFFFFFFFCLL)) {
                        goto LABEL_81;
                      }
                      v7 += v100;
                    }
                  }
                  else
                  {
                    unint64_t v97 = &v36[8 * v93];
                  }
                  do
                  {
                    uint64_t v105 = *(void *)v7;
                    v7 += 8;
                    *(void *)unint64_t v97 = v105;
                    v97 += 8;
                  }
                  while (v97 != v5);
                }
LABEL_81:
                *(void *)a1 = v36;
                *(void *)(a1 + 8) = v37;
                *(void *)(a1 + 16) = v5;
                *(void *)(a1 + ++*(void *)(result + 24) = v38;
                if (v9)
                {
                  operator delete(v9);
                  unint64_t v5 = *(char **)(a1 + 16);
                }
                goto LABEL_88;
              }
              goto LABEL_106;
            }
            goto LABEL_5;
          }
          unint64_t v75 = &v19[v78];
        }
      }
      do
      {
        uint64_t v91 = *(void *)v75;
        v75 += 8;
        *(void *)unint64_t v74 = v91;
        v74 += 8;
      }
      while (v74 != v73);
    }
    *(void *)a1 = v71;
    *(void *)(a1 + 8) = v43;
    *(void *)(a1 + 16) = v73;
    *(void *)(a1 + ++*(void *)(result + 24) = v72;
    if (!v19) {
      goto LABEL_87;
    }
    goto LABEL_86;
  }
  uint64_t v26 = v23 >> 2;
  if (v17 == v20) {
    unint64_t v27 = 1;
  }
  else {
    unint64_t v27 = v26;
  }
  if (v27 >> 61) {
    goto LABEL_106;
  }
  unint64_t v28 = (char *)operator new(8 * v27);
  unint64_t v29 = operator new(0x1000uLL);
  unint64_t v30 = &v28[8 * v22];
  int8x8_t v31 = &v28[8 * v27];
  if (v22 == v27)
  {
    if (v21 < 1)
    {
      if (v18 == v19) {
        unint64_t v44 = 1;
      }
      else {
        unint64_t v44 = v21 >> 2;
      }
      if (v44 >> 61) {
        sub_19E37C2B8();
      }
      unint64_t v30 = (char *)operator new(8 * v44);
      int8x8_t v31 = &v30[8 * v44];
      operator delete(v28);
      unint64_t v19 = *(char **)(a1 + 8);
      unint64_t v18 = *(char **)(a1 + 16);
      unint64_t v28 = v30;
    }
    else
    {
      unint64_t v32 = v22 + 2;
      if (v22 >= -1) {
        unint64_t v32 = v22 + 1;
      }
      v30 -= 8 * (v32 >> 1);
    }
  }
  *(void *)unint64_t v30 = v29;
  uint64_t v45 = v30 + 8;
  if (v18 != v19)
  {
    while (v30 != v28)
    {
      size_t v49 = v30;
      uint64_t v47 = v45;
LABEL_43:
      uint64_t v50 = *((void *)v18 - 1);
      v18 -= 8;
      *((void *)v49 - 1) = v50;
      unint64_t v46 = v49 - 8;
      uint64_t v45 = v47;
      unint64_t v30 = v46;
      if (v18 == *(char **)(a1 + 8)) {
        goto LABEL_38;
      }
    }
    if (v45 < v31)
    {
      uint64_t v51 = (v31 - v45) >> 3;
      if (v51 >= -1) {
        unint64_t v52 = v51 + 1;
      }
      else {
        unint64_t v52 = v51 + 2;
      }
      uint64_t v47 = &v45[8 * (v52 >> 1)];
      size_t v49 = &v30[8 * (v52 >> 1)];
      if (v45 == v30)
      {
        unint64_t v28 = v45;
      }
      else
      {
        memmove(&v30[8 * (v52 >> 1)], v30, v45 - v30);
        unint64_t v28 = v30;
      }
      goto LABEL_43;
    }
    if (v31 == v30) {
      unint64_t v53 = 1;
    }
    else {
      unint64_t v53 = (v31 - v30) >> 2;
    }
    if (v53 >> 61) {
      sub_19E37C2B8();
    }
    int v54 = (char *)operator new(8 * v53);
    unint64_t v28 = v54;
    unint64_t v55 = (v53 + 3) >> 2;
    size_t v49 = &v54[8 * v55];
    uint64_t v47 = v49;
    int64_t v56 = v45 - v30;
    if (v45 != v30)
    {
      uint64_t v47 = &v49[v56 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v57 = v56 - 8;
      uint64_t v58 = &v54[8 * v55];
      uint64_t v59 = v30;
      if (v57 >= 0x38)
      {
        uint64_t v60 = 8 * v55;
        uint64_t v58 = &v54[8 * v55];
        uint64_t v59 = v30;
        if ((unint64_t)(v58 - v30) >= 0x20)
        {
          uint64_t v61 = (v57 >> 3) + 1;
          uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v58 = &v49[v62];
          unint64_t v63 = (long long *)(v30 + 16);
          long long v64 = &v54[v60 + 16];
          uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v66 = *v63;
            *((_OWORD *)v64 - 1) = *(v63 - 1);
            *(_OWORD *)long long v64 = v66;
            v63 += 2;
            v64 += 32;
            v65 -= 4;
          }
          while (v65);
          if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_63;
          }
          uint64_t v59 = &v30[v62];
        }
      }
      do
      {
        uint64_t v67 = *(void *)v59;
        v59 += 8;
        *(void *)uint64_t v58 = v67;
        v58 += 8;
      }
      while (v58 != v47);
    }
LABEL_63:
    int8x8_t v31 = &v54[8 * v53];
    operator delete(v30);
    goto LABEL_43;
  }
  unint64_t v46 = v30;
  uint64_t v47 = v30 + 8;
LABEL_38:
  unint64_t v48 = *(char **)a1;
  *(void *)a1 = v28;
  *(void *)(a1 + 8) = v46;
  *(void *)(a1 + 16) = v47;
  *(void *)(a1 + ++*(void *)(result + 24) = v31;
  if (v48)
  {
    operator delete(v48);
  }
}

void sub_19E463A3C(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_19E463A70(uint64_t *a1, int a2, int a3)
{
  uint64_t v5 = a1[10];
  unint64_t v7 = *(char **)(v5 + 8);
  unint64_t v6 = *(void *)(v5 + 16);
  uint64_t v8 = v7;
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = *(char **)v5;
    uint64_t v11 = (uint64_t)&v7[-*(void *)v5];
    uint64_t v12 = v11 >> 2;
    unint64_t v13 = (v11 >> 2) + 1;
    if (v13 >> 62) {
      sub_19E37C7C4();
    }
    int v14 = a3;
    uint64_t v15 = v6 - (void)v10;
    if (v15 >> 1 > v13) {
      unint64_t v13 = v15 >> 1;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v13;
    }
    if (v16)
    {
      if (v16 >> 62) {
LABEL_127:
      }
        sub_19E37C2B8();
      unint64_t v17 = operator new(4 * v16);
    }
    else
    {
      unint64_t v17 = 0;
    }
    unint64_t v18 = &v17[4 * v12];
    unint64_t v19 = &v17[4 * v16];
    *unint64_t v18 = a2;
    int32x4_t v9 = v18 + 1;
    if (v7 != v10)
    {
      unint64_t v20 = v7 - v10 - 4;
      if (v20 < 0x2C) {
        goto LABEL_131;
      }
      if ((unint64_t)(v7 - v17 - v11) < 0x20) {
        goto LABEL_131;
      }
      uint64_t v21 = (v20 >> 2) + 1;
      uint64_t v8 = &v7[-4 * (v21 & 0x7FFFFFFFFFFFFFF8)];
      uint64_t v22 = &v17[4 * v12 - 16];
      uint64_t v23 = v7 - 16;
      uint64_t v24 = v21 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v25 = *(_OWORD *)v23;
        *(v22 - 1) = *((_OWORD *)v23 - 1);
        *uint64_t v22 = v25;
        v22 -= 2;
        v23 -= 32;
        v24 -= 8;
      }
      while (v24);
      v18 -= v21 & 0x7FFFFFFFFFFFFFF8;
      if (v21 != (v21 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_131:
        do
        {
          int v26 = *((_DWORD *)v8 - 1);
          v8 -= 4;
          *--unint64_t v18 = v26;
        }
        while (v8 != v10);
      }
    }
    *(void *)uint64_t v5 = v18;
    *(void *)(v5 + 8) = v9;
    *(void *)(v5 + 16) = v19;
    if (v10) {
      operator delete(v10);
    }
    a3 = v14;
  }
  else
  {
    *(_DWORD *)unint64_t v7 = a2;
    int32x4_t v9 = v7 + 4;
  }
  *(void *)(v5 + 8) = v9;
  uint64_t v27 = *(void *)a1[7];
  unint64_t v106 = a2;
  if (a2 >= (unint64_t)((*(void *)(a1[7] + 8) - v27) >> 2))
  {
    int v105 = a3;
    do
    {
      uint64_t v28 = *a1;
      if (*a1)
      {
        unint64_t v30 = *(char **)(v28 + 8);
        unint64_t v29 = *(void *)(v28 + 16);
        if ((unint64_t)v30 >= v29)
        {
          unint64_t v32 = *(char **)v28;
          uint64_t v33 = (uint64_t)&v30[-*(void *)v28];
          uint64_t v34 = v33 >> 2;
          unint64_t v35 = (v33 >> 2) + 1;
          if (v35 >> 62) {
            goto LABEL_125;
          }
          uint64_t v36 = v29 - (void)v32;
          if (v36 >> 1 > v35) {
            unint64_t v35 = v36 >> 1;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            if (v37 >> 62) {
              goto LABEL_127;
            }
            unint64_t v38 = operator new(4 * v37);
          }
          else
          {
            unint64_t v38 = 0;
          }
          BOOL v39 = &v38[4 * v34];
          *BOOL v39 = -1;
          int8x8_t v31 = v39 + 1;
          if (v30 != v32)
          {
            unint64_t v40 = v30 - 4 - v32;
            if (v40 < 0x2C) {
              goto LABEL_132;
            }
            if ((unint64_t)(v30 - &v38[v33]) < 0x20) {
              goto LABEL_132;
            }
            uint64_t v41 = (v40 >> 2) + 1;
            long long v42 = &v38[4 * v34 - 16];
            char v43 = v30 - 16;
            uint64_t v44 = v41 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v45 = *(_OWORD *)v43;
              *(v42 - 1) = *((_OWORD *)v43 - 1);
              *long long v42 = v45;
              v42 -= 2;
              v43 -= 32;
              v44 -= 8;
            }
            while (v44);
            v39 -= v41 & 0x7FFFFFFFFFFFFFF8;
            v30 -= 4 * (v41 & 0x7FFFFFFFFFFFFFF8);
            if (v41 != (v41 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_132:
              do
              {
                int v46 = *((_DWORD *)v30 - 1);
                v30 -= 4;
                *--BOOL v39 = v46;
              }
              while (v30 != v32);
            }
          }
          *(void *)uint64_t v28 = v39;
          *(void *)(v28 + 8) = v31;
          *(void *)(v28 + 16) = &v38[4 * v37];
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          *(_DWORD *)unint64_t v30 = -1;
          int8x8_t v31 = v30 + 4;
        }
        *(void *)(v28 + 8) = v31;
      }
      uint64_t v47 = (void *)a1[1];
      if (v47)
      {
        unint64_t v48 = v47[1];
        uint64_t v49 = v47[2];
        if (v48 == v49 << 6)
        {
          if ((uint64_t)(v48 + 1) < 0) {
            goto LABEL_126;
          }
          unint64_t v50 = v49 << 7;
          if (v50 <= (v48 & 0xFFFFFFFFFFFFFFC0) + 64) {
            unint64_t v50 = (v48 & 0xFFFFFFFFFFFFFFC0) + 64;
          }
          if (v48 <= 0x3FFFFFFFFFFFFFFELL) {
            unint64_t v51 = v50;
          }
          else {
            unint64_t v51 = 0x7FFFFFFFFFFFFFFFLL;
          }
          sub_19E4645DC(a1[1], v51);
          unint64_t v48 = v47[1];
        }
        v47[1] = v48 + 1;
        *(void *)(*v47 + ((v48 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v48);
      }
      unint64_t v52 = (void *)a1[2];
      unint64_t v53 = v52[1];
      uint64_t v54 = v52[2];
      if (v53 == v54 << 6)
      {
        if ((uint64_t)(v53 + 1) < 0) {
          goto LABEL_126;
        }
        unint64_t v55 = v54 << 7;
        if (v55 <= (v53 & 0xFFFFFFFFFFFFFFC0) + 64) {
          unint64_t v55 = (v53 & 0xFFFFFFFFFFFFFFC0) + 64;
        }
        if (v53 <= 0x3FFFFFFFFFFFFFFELL) {
          unint64_t v56 = v55;
        }
        else {
          unint64_t v56 = 0x7FFFFFFFFFFFFFFFLL;
        }
        sub_19E4645DC(a1[2], v56);
        unint64_t v53 = v52[1];
      }
      v52[1] = v53 + 1;
      *(void *)(*v52 + ((v53 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v53);
      uint64_t v57 = a1[7];
      uint64_t v59 = *(char **)(v57 + 8);
      unint64_t v58 = *(void *)(v57 + 16);
      if ((unint64_t)v59 >= v58)
      {
        uint64_t v61 = *(char **)v57;
        uint64_t v62 = (uint64_t)&v59[-*(void *)v57];
        uint64_t v63 = v62 >> 2;
        unint64_t v64 = (v62 >> 2) + 1;
        if (v64 >> 62) {
          goto LABEL_125;
        }
        uint64_t v65 = v58 - (void)v61;
        if (v65 >> 1 > v64) {
          unint64_t v64 = v65 >> 1;
        }
        if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v66 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v66 = v64;
        }
        if (v66)
        {
          if (v66 >> 62) {
            goto LABEL_127;
          }
          uint64_t v67 = operator new(4 * v66);
        }
        else
        {
          uint64_t v67 = 0;
        }
        unint64_t v68 = &v67[4 * v63];
        *unint64_t v68 = -1;
        uint64_t v60 = v68 + 1;
        if (v59 != v61)
        {
          unint64_t v69 = v59 - 4 - v61;
          if (v69 < 0x2C) {
            goto LABEL_133;
          }
          if ((unint64_t)(v59 - &v67[v62]) < 0x20) {
            goto LABEL_133;
          }
          uint64_t v70 = (v69 >> 2) + 1;
          uint64_t v71 = &v67[4 * v63 - 16];
          uint64_t v72 = v59 - 16;
          uint64_t v73 = v70 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v74 = *(_OWORD *)v72;
            *(v71 - 1) = *((_OWORD *)v72 - 1);
            _OWORD *v71 = v74;
            v71 -= 2;
            v72 -= 32;
            v73 -= 8;
          }
          while (v73);
          v68 -= v70 & 0x7FFFFFFFFFFFFFF8;
          v59 -= 4 * (v70 & 0x7FFFFFFFFFFFFFF8);
          if (v70 != (v70 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_133:
            do
            {
              int v75 = *((_DWORD *)v59 - 1);
              v59 -= 4;
              *--unint64_t v68 = v75;
            }
            while (v59 != v61);
          }
        }
        *(void *)uint64_t v57 = v68;
        *(void *)(v57 + 8) = v60;
        *(void *)(v57 + 16) = &v67[4 * v66];
        if (v61) {
          operator delete(v61);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v59 = -1;
        uint64_t v60 = v59 + 4;
      }
      *(void *)(v57 + 8) = v60;
      uint64_t v76 = a1[8];
      uint64_t v78 = *(char **)(v76 + 8);
      unint64_t v77 = *(void *)(v76 + 16);
      if ((unint64_t)v78 >= v77)
      {
        unint64_t v80 = *(char **)v76;
        uint64_t v81 = (uint64_t)&v78[-*(void *)v76];
        uint64_t v82 = v81 >> 2;
        unint64_t v83 = (v81 >> 2) + 1;
        if (v83 >> 62) {
LABEL_125:
        }
          sub_19E37C7C4();
        uint64_t v84 = v77 - (void)v80;
        if (v84 >> 1 > v83) {
          unint64_t v83 = v84 >> 1;
        }
        if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v85 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v85 = v83;
        }
        if (v85)
        {
          if (v85 >> 62) {
            goto LABEL_127;
          }
          unint64_t v86 = operator new(4 * v85);
        }
        else
        {
          unint64_t v86 = 0;
        }
        uint64_t v87 = &v86[4 * v82];
        _DWORD *v87 = -1;
        unint64_t v79 = v87 + 1;
        if (v78 != v80)
        {
          unint64_t v88 = v78 - 4 - v80;
          if (v88 < 0x2C) {
            goto LABEL_134;
          }
          if ((unint64_t)(v78 - &v86[v81]) < 0x20) {
            goto LABEL_134;
          }
          uint64_t v89 = (v88 >> 2) + 1;
          uint64_t v90 = &v86[4 * v82 - 16];
          uint64_t v91 = v78 - 16;
          uint64_t v92 = v89 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v93 = *(_OWORD *)v91;
            *(v90 - 1) = *((_OWORD *)v91 - 1);
            _OWORD *v90 = v93;
            v90 -= 2;
            v91 -= 32;
            v92 -= 8;
          }
          while (v92);
          v87 -= v89 & 0x7FFFFFFFFFFFFFF8;
          v78 -= 4 * (v89 & 0x7FFFFFFFFFFFFFF8);
          if (v89 != (v89 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_134:
            do
            {
              int v94 = *((_DWORD *)v78 - 1);
              v78 -= 4;
              *--uint64_t v87 = v94;
            }
            while (v78 != v80);
          }
        }
        *(void *)uint64_t v76 = v87;
        *(void *)(v76 + 8) = v79;
        *(void *)(v76 + 16) = &v86[4 * v85];
        if (v80) {
          operator delete(v80);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v78 = -1;
        unint64_t v79 = v78 + 4;
      }
      *(void *)(v76 + 8) = v79;
      int64_t v95 = (void *)a1[9];
      unint64_t v96 = v95[1];
      uint64_t v97 = v95[2];
      if (v96 == v97 << 6)
      {
        if ((uint64_t)(v96 + 1) < 0) {
LABEL_126:
        }
          sub_19E37C7C4();
        unint64_t v98 = v97 << 7;
        if (v98 <= (v96 & 0xFFFFFFFFFFFFFFC0) + 64) {
          unint64_t v98 = (v96 & 0xFFFFFFFFFFFFFFC0) + 64;
        }
        if (v96 <= 0x3FFFFFFFFFFFFFFELL) {
          unint64_t v99 = v98;
        }
        else {
          unint64_t v99 = 0x7FFFFFFFFFFFFFFFLL;
        }
        sub_19E4645DC(a1[9], v99);
        unint64_t v96 = v95[1];
      }
      v95[1] = v96 + 1;
      *(void *)(*v95 + ((v96 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v96);
      uint64_t v27 = *(void *)a1[7];
    }
    while (v106 >= (*(void *)(a1[7] + 8) - v27) >> 2);
    a3 = v105;
  }
  uint64_t v100 = 4 * v106;
  *(_DWORD *)(v27 + v100) = *((_DWORD *)a1 + 11);
  uint64_t v101 = (void *)a1[9];
  *(_DWORD *)(*(void *)a1[8] + v100) = *((_DWORD *)a1 + 11);
  uint64_t v102 = 8 * (v106 >> 6);
  uint64_t v103 = 1 << v106;
  *(void *)(*v101 + v102) |= 1 << v106;
  long long v104 = (void *)a1[1];
  if (*((_DWORD *)a1 + 10) == a3)
  {
    if (v104) {
      *(void *)(*v104 + v102) |= v103;
    }
  }
  else
  {
    if (v104) {
      *(void *)(*v104 + v102) &= ~v103;
    }
    *(void *)a1[3] = *(void *)a1[3] & 0xFFFFFCFFFFFFFFFFLL | 0x20000000000;
  }
  ++*((_DWORD *)a1 + 11);
}

uint64_t sub_19E46419C(uint64_t a1, int a2, int a3)
{
  uint64_t result = (uint64_t)(*(void *(**)(uint64_t *__return_ptr))(**(void **)(a1 + 32) + 24))(&v27);
  int v28 = v27;
  HIDWORD(v27) = 2139095039;
  if (*(float *)&v27 != 3.4028e38) {
    *(void *)(**(void **)(a1 + 16) + (((unint64_t)a2 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << a2;
  }
  uint64_t v7 = **(void **)(a1 + 64);
  if (*(_DWORD *)(**(void **)(a1 + 56) + 4 * a2) == *(_DWORD *)(v7 + 4 * a2))
  {
    char v8 = 0;
    int32x4_t v9 = *(void **)(a1 + 80);
    uint64_t v10 = v9[1];
    uint64_t v11 = **(void **)(a1 + 16);
    uint64_t v12 = (int *)(((v10 - *v9) & 0xFFFFFFFFFFFFFFFCLL) + *v9 - 4);
    do
    {
      unint64_t v13 = *v12--;
      v8 |= *(void *)(v11 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v13;
    }
    while (v13 != a2);
    int v14 = *(uint64_t **)a1;
    uint64_t v15 = **(void **)(a1 + 72);
    if (v8)
    {
      if (v14)
      {
        uint64_t v16 = *v14;
        do
        {
          unint64_t v17 = *(int *)(v10 - 4);
          v10 -= 4;
          *(_DWORD *)(v16 + 4 * v17) = *(_DWORD *)(a1 + 48);
          uint64_t result = (v17 >> 3) & 0x1FFFFFFFFFFFFFF8;
          *(void *)(v11 + result) |= 1 << v17;
          *(void *)(v15 + result) &= ~(1 << v17);
        }
        while (v17 != a2);
      }
      else
      {
        do
        {
          unint64_t v21 = *(int *)(v10 - 4);
          v10 -= 4;
          uint64_t v22 = (v21 >> 3) & 0x1FFFFFFFFFFFFFF8;
          *(void *)(v11 + v22) |= 1 << v21;
          uint64_t result = *(void *)(v15 + v22) & ~(1 << v21);
          *(void *)(v15 + v22) = result;
        }
        while (v21 != a2);
      }
    }
    else if (v14)
    {
      uint64_t v18 = *v14;
      do
      {
        unint64_t v19 = *(int *)(v10 - 4);
        v10 -= 4;
        *(_DWORD *)(v18 + 4 * v19) = *(_DWORD *)(a1 + 48);
        uint64_t v20 = (v19 >> 3) & 0x1FFFFFFFFFFFFFF8;
        uint64_t result = *(void *)(v15 + v20) & ~(1 << v19);
        *(void *)(v15 + v20) = result;
      }
      while (v19 != a2);
    }
    else
    {
      do
      {
        unint64_t v23 = *(int *)(v10 - 4);
        v10 -= 4;
        uint64_t v24 = (v23 >> 3) & 0x1FFFFFFFFFFFFFF8;
        uint64_t result = *(void *)(v15 + v24);
        *(void *)(v15 + v++*(void *)(result + 24) = result & ~(1 << v23);
      }
      while (v23 != a2);
    }
    v9[1] = v10;
    if ((v8 & 1) == 0) {
      **(void **)(a1 + ++*(void *)(result + 24) = **(void **)(a1 + 24) & 0xFFFFF3FFFFFFFFFFLL | 0x80000000000;
    }
    ++*(_DWORD *)(a1 + 48);
  }
  if (a3 != -1)
  {
    uint64_t v25 = **(void **)(a1 + 16);
    if ((*(void *)(v25 + (((unint64_t)a2 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a2)) {
      *(void *)(v25 + (((unint64_t)a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << a3;
    }
    int v26 = *(_DWORD *)(v7 + 4 * a2);
    if (v26 < *(_DWORD *)(v7 + 4 * a3)) {
      *(_DWORD *)(v7 + 4 * a3) = v26;
    }
  }
  return result;
}

void *sub_19E464434(void *a1)
{
  *a1 = &unk_1EF0BC550;
  a1[1] = &unk_1EF0BC848;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        char v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E464514(uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  BOOL v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E4645DC(uint64_t a1, unint64_t a2)
{
  if (a2 > *(void *)(a1 + 16) << 6)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      sub_19E37C7C4();
    }
    unint64_t v3 = ((a2 - 1) >> 6) + 1;
    unint64_t v4 = (uint64_t *)operator new(8 * v3);
    unint64_t v5 = *(void **)a1;
    unint64_t v6 = *(void *)(a1 + 8);
    int v7 = v6 & 0x3F;
    unint64_t v8 = (v6 - 1) >> 6;
    if (v6 < 0x41) {
      unint64_t v8 = 0;
    }
    v4[v8] = 0;
    if (v6 > 0x3F || (v6 & 0x3F) != 0)
    {
      int v9 = 0;
      int v10 = 0;
      uint64_t v11 = &v5[v6 >> 6];
      uint64_t v12 = v4;
      unint64_t v13 = v5;
      do
      {
        uint64_t v14 = 1 << v9;
        if ((*v13 >> v10)) {
          uint64_t v15 = *v12 | v14;
        }
        else {
          uint64_t v15 = *v12 & ~v14;
        }
        *uint64_t v12 = v15;
        v13 += v10 == 63;
        if (v10 == 63) {
          int v10 = 0;
        }
        else {
          ++v10;
        }
        v12 += v9 == 63;
        if (v9 == 63) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
      }
      while (v10 != v7 || v13 != v11);
    }
    *(void *)a1 = v4;
    *(void *)(a1 + 16) = v3;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

uint64_t sub_19E4646F0()
{
  return 56;
}

void sub_19E4646F8(void *a1)
{
  *a1 = &unk_1EF0BC848;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    unint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        unint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4647D8(void *a1)
{
  *a1 = &unk_1EF0BC848;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    unint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        unint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E464898()
{
  return 48;
}

void sub_19E4648A0(void *a1)
{
  *a1 = &unk_1EF0BC550;
  a1[1] = &unk_1EF0BC848;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    unint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        unint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E4649A0(uint64_t a1, int a2)
{
  return *(void *)(*(void *)(*(void *)(*(void *)(a1 + 8) + 64) + 8 * a2) + 16);
}

uint64_t sub_19E4649B4(uint64_t a1, int a2)
{
  return *(void *)(*(void *)(*(void *)(*(void *)(a1 + 8) + 64) + 8 * a2) + 8);
}

uint64_t sub_19E4649C8(uint64_t a1, int a2)
{
  return (uint64_t)(*(void *)(*(void *)(*(void *)(*(void *)(a1 + 8) + 64) + 8 * a2) + 32)
                 - *(void *)(*(void *)(*(void *)(*(void *)(a1 + 8) + 64) + 8 * a2) + 24)) >> 4;
}

float sub_19E4649E4@<S0>(uint64_t a1@<X0>, int a2@<W1>, _DWORD *a3@<X8>)
{
  unint64_t v3 = *(float **)(*(void *)(*(void *)(a1 + 8) + 64) + 8 * a2);
  float result = *v3;
  *a3 = *(_DWORD *)v3;
  return result;
}

uint64_t sub_19E4649FC(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 88);
}

void sub_19E464A08(void *a1)
{
  *a1 = &unk_1EF0BD108;
  uint64_t v1 = (_DWORD *)a1[1];
  int v2 = v1[14] - 1;
  v1[14] = v2;
  if (!v2) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E464AA8(uint64_t a1)
{
  char v5 = 5;
  strcpy((char *)__p, "FATAL");
  int v2 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
  sub_19E37CA70(v2, (uint64_t)": ", 2);
  sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"ImplToFst: Assignment operator disallowed", 41);
  sub_19E43C8CC();
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  *(void *)(*(void *)(a1 + 8) + 8) |= 4uLL;
  return a1;
}

void sub_19E464B50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E464B78(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 48);
}

uint64_t sub_19E464B84(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 40);
}

uint64_t sub_19E464B90(uint64_t a1)
{
  char v11 = 5;
  strcpy((char *)__p, "ERROR");
  int v2 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
  sub_19E37CA70(v2, (uint64_t)": ", 2);
  unint64_t v3 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Fst::Write: No write filename method for ", 41);
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  int v5 = *(char *)(v4 + 23);
  if (v5 >= 0) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = *(void *)v4;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(v4 + 23);
  }
  else {
    uint64_t v7 = *(void *)(v4 + 8);
  }
  unint64_t v8 = sub_19E37CA70(v3, v6, v7);
  sub_19E37CA70(v8, (uint64_t)" Fst type", 9);
  sub_19E43C8CC();
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_19E464C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E464CAC(uint64_t a1)
{
  char v11 = 5;
  strcpy((char *)__p, "ERROR");
  int v2 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
  sub_19E37CA70(v2, (uint64_t)": ", 2);
  unint64_t v3 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Fst::Write: No write stream method for ", 39);
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  int v5 = *(char *)(v4 + 23);
  if (v5 >= 0) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = *(void *)v4;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(v4 + 23);
  }
  else {
    uint64_t v7 = *(void *)(v4 + 8);
  }
  unint64_t v8 = sub_19E37CA70(v3, v6, v7);
  sub_19E37CA70(v8, (uint64_t)" Fst type", 9);
  sub_19E43C8CC();
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_19E464DA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E464DD0(void *a1)
{
  *a1 = &unk_1EF0BD108;
  int v2 = (_DWORD *)a1[1];
  int v3 = v2[14] - 1;
  v2[14] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_19E464E48(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a3 + 24);
  if (v8)
  {
    *(_DWORD *)a4 = *(_DWORD *)v8;
    int v9 = (void **)(a4 + 8);
    if (v8 != a4)
    {
      char v10 = *(unsigned char *)(v8 + 31);
      if (*(char *)(a4 + 31) < 0)
      {
        if (v10 >= 0) {
          unint64_t v13 = (void *)(v8 + 8);
        }
        else {
          unint64_t v13 = *(void **)(v8 + 8);
        }
        if (v10 >= 0) {
          size_t v14 = *(unsigned __int8 *)(v8 + 31);
        }
        else {
          size_t v14 = *(void *)(v8 + 16);
        }
        sub_19E3C6D44(v9, v13, v14);
      }
      else if ((*(unsigned char *)(v8 + 31) & 0x80) != 0)
      {
        sub_19E3C6C7C(v9, *(void **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v11 = *(_OWORD *)(v8 + 8);
        *(void *)(a4 + ++*(void *)(result + 24) = *(void *)(v8 + 24);
        *(_OWORD *)int v9 = v11;
      }
      uint64_t v15 = (void **)(a4 + 32);
      char v16 = *(unsigned char *)(v8 + 55);
      if (*(char *)(a4 + 55) < 0)
      {
        if (v16 >= 0) {
          uint64_t v18 = (void *)(v8 + 32);
        }
        else {
          uint64_t v18 = *(void **)(v8 + 32);
        }
        if (v16 >= 0) {
          size_t v19 = *(unsigned __int8 *)(v8 + 55);
        }
        else {
          size_t v19 = *(void *)(v8 + 40);
        }
        sub_19E3C6D44(v15, v18, v19);
      }
      else if ((*(unsigned char *)(v8 + 55) & 0x80) != 0)
      {
        sub_19E3C6C7C(v15, *(void **)(v8 + 32), *(void *)(v8 + 40));
      }
      else
      {
        long long v17 = *(_OWORD *)(v8 + 32);
        *(void *)(a4 + 48) = *(void *)(v8 + 48);
        *(_OWORD *)uint64_t v15 = v17;
      }
    }
    long long v20 = *(_OWORD *)(v8 + 56);
    long long v21 = *(_OWORD *)(v8 + 72);
    *(void *)(a4 + 88) = *(void *)(v8 + 88);
    *(_OWORD *)(a4 + 72) = v21;
    *(_OWORD *)(a4 + 56) = v20;
  }
  else
  {
    uint64_t result = sub_19E535C5C(a4, (uint64_t)a2, a3);
    if (!result) {
      return result;
    }
  }
  uint64_t v22 = *(unsigned __int8 *)(a4 + 31);
  if ((v22 & 0x80u) == 0) {
    uint64_t v23 = *(unsigned __int8 *)(a4 + 31);
  }
  else {
    uint64_t v23 = *(void *)(a4 + 16);
  }
  uint64_t v24 = *(unsigned __int8 *)(a1 + 39);
  int v25 = (char)v24;
  if ((v24 & 0x80u) != 0) {
    uint64_t v24 = *(void *)(a1 + 24);
  }
  if (v23 != v24) {
    goto LABEL_43;
  }
  int v26 = (const void **)(a4 + 8);
  if (v25 >= 0) {
    uint64_t v27 = (unsigned __int8 *)(a1 + 16);
  }
  else {
    uint64_t v27 = *(unsigned __int8 **)(a1 + 16);
  }
  if ((v22 & 0x80) != 0)
  {
    if (memcmp(*v26, v27, *(void *)(a4 + 16)))
    {
LABEL_43:
      char v63 = 5;
      strcpy((char *)__p, "ERROR");
      int v28 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
      sub_19E37CA70(v28, (uint64_t)": ", 2);
      unint64_t v29 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"FstImpl::ReadHeader: Fst not of type \"", 38);
      int v30 = *(char *)(a1 + 39);
      if (v30 >= 0) {
        uint64_t v31 = a1 + 16;
      }
      else {
        uint64_t v31 = *(void *)(a1 + 16);
      }
      if (v30 >= 0) {
        uint64_t v32 = *(unsigned __int8 *)(a1 + 39);
      }
      else {
        uint64_t v32 = *(void *)(a1 + 24);
      }
      uint64_t v33 = sub_19E37CA70(v29, v31, v32);
      uint64_t v34 = sub_19E37CA70(v33, (uint64_t)"\": ", 3);
      int v35 = *(char *)(a3 + 23);
      if (v35 >= 0) {
        uint64_t v36 = a3;
      }
      else {
        uint64_t v36 = *(void *)a3;
      }
      if (v35 >= 0) {
        uint64_t v37 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v37 = *(void *)(a3 + 8);
      }
      goto LABEL_82;
    }
  }
  else if (*(unsigned char *)(a4 + 31))
  {
    while (*(unsigned __int8 *)v26 == *v27)
    {
      int v26 = (const void **)((char *)v26 + 1);
      ++v27;
      if (!--v22) {
        goto LABEL_55;
      }
    }
    goto LABEL_43;
  }
LABEL_55:
  sub_19E461128();
  uint64_t v38 = *(unsigned __int8 *)(a4 + 55);
  if ((v38 & 0x80u) == 0) {
    uint64_t v39 = *(unsigned __int8 *)(a4 + 55);
  }
  else {
    uint64_t v39 = *(void *)(a4 + 40);
  }
  uint64_t v40 = *((void *)&xmmword_1EC009620 + 1);
  if (byte_1EC009637 >= 0) {
    uint64_t v40 = byte_1EC009637;
  }
  if (v39 != v40) {
    goto LABEL_70;
  }
  uint64_t v41 = (const void **)(a4 + 32);
  if (byte_1EC009637 >= 0) {
    long long v42 = &xmmword_1EC009620;
  }
  else {
    long long v42 = (long long *)xmmword_1EC009620;
  }
  if ((v38 & 0x80) != 0)
  {
    if (memcmp(*v41, v42, *(void *)(a4 + 40)))
    {
LABEL_70:
      char v63 = 5;
      strcpy((char *)__p, "ERROR");
      char v43 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
      sub_19E37CA70(v43, (uint64_t)": ", 2);
      uint64_t v44 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"FstImpl::ReadHeader: Arc not of type \"", 38);
      sub_19E461128();
      if (byte_1EC009637 >= 0) {
        long long v45 = &xmmword_1EC009620;
      }
      else {
        long long v45 = (long long *)xmmword_1EC009620;
      }
      if (byte_1EC009637 >= 0) {
        uint64_t v46 = byte_1EC009637;
      }
      else {
        uint64_t v46 = *((void *)&xmmword_1EC009620 + 1);
      }
      uint64_t v47 = sub_19E37CA70(v44, (uint64_t)v45, v46);
      uint64_t v34 = sub_19E37CA70(v47, (uint64_t)"\": ", 3);
      int v48 = *(char *)(a3 + 23);
      if (v48 >= 0) {
        uint64_t v36 = a3;
      }
      else {
        uint64_t v36 = *(void *)a3;
      }
      if (v48 >= 0) {
        uint64_t v37 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v37 = *(void *)(a3 + 8);
      }
      goto LABEL_82;
    }
  }
  else if (*(unsigned char *)(a4 + 55))
  {
    while (*(unsigned __int8 *)v41 == *(unsigned __int8 *)v42)
    {
      uint64_t v41 = (const void **)((char *)v41 + 1);
      long long v42 = (long long *)((char *)v42 + 1);
      if (!--v38) {
        goto LABEL_85;
      }
    }
    goto LABEL_70;
  }
LABEL_85:
  if (*(int *)(a4 + 56) > 0)
  {
    *(void *)(a1 + 8) = *(void *)(a4 + 64);
    if (*(unsigned char *)(a4 + 60))
    {
      *(void *)(a1 + 40) = sub_19E465470(a2, a3);
      if (*(unsigned char *)(a3 + 52))
      {
LABEL_88:
        if ((*(unsigned char *)(a4 + 60) & 2) == 0) {
          goto LABEL_89;
        }
        goto LABEL_108;
      }
    }
    else if (*(unsigned char *)(a3 + 52))
    {
      goto LABEL_88;
    }
    uint64_t v57 = *(void *)(a1 + 40);
    if (v57) {
      (*(void (**)(uint64_t, long long *))(*(void *)v57 + 8))(v57, v42);
    }
    *(void *)(a1 + 40) = 0;
    if ((*(unsigned char *)(a4 + 60) & 2) == 0)
    {
LABEL_89:
      if (*(unsigned char *)(a3 + 53)) {
        goto LABEL_90;
      }
      goto LABEL_109;
    }
LABEL_108:
    *(void *)(a1 + 48) = sub_19E465470(a2, a3);
    if (*(unsigned char *)(a3 + 53))
    {
LABEL_90:
      uint64_t v49 = *(void *)(a3 + 32);
      if (!v49)
      {
LABEL_115:
        uint64_t v60 = *(void *)(a3 + 40);
        if (v60)
        {
          uint64_t v61 = *(void *)(a1 + 48);
          if (v61)
          {
            (*(void (**)(void, long long *))(*(void *)v61 + 8))(*(void *)(a1 + 48), v42);
            uint64_t v60 = *(void *)(a3 + 40);
          }
          *(void *)(a1 + 48) = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v60 + 16))(v60, v42);
        }
        return 1;
      }
LABEL_112:
      uint64_t v59 = *(void *)(a1 + 40);
      if (v59)
      {
        (*(void (**)(void, long long *))(*(void *)v59 + 8))(*(void *)(a1 + 40), v42);
        uint64_t v49 = *(void *)(a3 + 32);
      }
      *(void *)(a1 + 40) = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v49 + 16))(v49, v42);
      goto LABEL_115;
    }
LABEL_109:
    uint64_t v58 = *(void *)(a1 + 48);
    if (v58) {
      (*(void (**)(uint64_t, long long *))(*(void *)v58 + 8))(v58, v42);
    }
    *(void *)(a1 + 48) = 0;
    uint64_t v49 = *(void *)(a3 + 32);
    if (!v49) {
      goto LABEL_115;
    }
    goto LABEL_112;
  }
  char v63 = 5;
  strcpy((char *)__p, "ERROR");
  unint64_t v50 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
  sub_19E37CA70(v50, (uint64_t)": ", 2);
  unint64_t v51 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"FstImpl::ReadHeader: Obsolete ", 30);
  int v52 = *(char *)(a1 + 39);
  if (v52 >= 0) {
    uint64_t v53 = a1 + 16;
  }
  else {
    uint64_t v53 = *(void *)(a1 + 16);
  }
  if (v52 >= 0) {
    uint64_t v54 = *(unsigned __int8 *)(a1 + 39);
  }
  else {
    uint64_t v54 = *(void *)(a1 + 24);
  }
  unint64_t v55 = sub_19E37CA70(v51, v53, v54);
  uint64_t v34 = sub_19E37CA70(v55, (uint64_t)" Fst version: ", 14);
  int v56 = *(char *)(a3 + 23);
  if (v56 >= 0) {
    uint64_t v36 = a3;
  }
  else {
    uint64_t v36 = *(void *)a3;
  }
  if (v56 >= 0) {
    uint64_t v37 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v37 = *(void *)(a3 + 8);
  }
LABEL_82:
  sub_19E37CA70(v34, v36, v37);
  sub_19E43C8CC();
  if (v63 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_19E465430(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E465470(void *a1, uint64_t a2)
{
  memset(v6, 0, sizeof(v6));
  if (&v6[1] != (void **)a2)
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_19E3C6C7C(&v6[1], *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)&v6[1] = *(_OWORD *)a2;
      v6[3] = *(void **)(a2 + 16);
    }
  }
  int v10 = 0;
  std::istream::read();
  if ((*((unsigned char *)a1 + *(void *)(*a1 - 24) + 32) & 5) == 0)
  {
    memset(&v9, 0, sizeof(v9));
    LODWORD(__p) = 0;
    std::istream::read();
    if ((int)__p >= 1)
    {
      int v4 = 0;
      do
      {
        __c[0] = 0;
        std::istream::read();
        std::string::push_back(&v9, __c[0]);
        ++v4;
      }
      while (v4 < (int)__p);
    }
    operator new();
  }
  *((unsigned char *)&v9.__r_.__value_.__s + 23) = 5;
  strcpy((char *)&v9, "ERROR");
  int v3 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)&v9, 5);
  sub_19E37CA70(v3, (uint64_t)": ", 2);
  sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"SymbolTable::Read: read failed", 30);
  sub_19E43C8CC();
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v6[3]) < 0) {
    operator delete(v6[1]);
  }
  return 0;
}

void sub_19E4659A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  sub_19E43C8CC();
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (*(char *)(v27 - 57) < 0) {
    operator delete(*(void **)(v27 - 80));
  }
  sub_19E465A84((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_19E465A84(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
  {
    operator delete(*(void **)(a1 + 24));
    int v2 = *(void **)a1;
    if (!*(void *)a1) {
      return a1;
    }
    goto LABEL_3;
  }
  int v2 = *(void **)a1;
  if (*(void *)a1)
  {
LABEL_3:
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_19E465AD4(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 96);
}

uint64_t sub_19E465AE0(uint64_t result, int a2, void *a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 8) + 80) + 20 * a2;
  uint64_t v5 = *(unsigned int *)(v3 + 4);
  uint64_t v4 = *(unsigned int *)(v3 + 8);
  uint64_t v6 = *(void *)(*(void *)(result + 8) + 88) + 16 * v5;
  *a3 = 0;
  a3[1] = v6;
  a3[2] = v4;
  a3[3] = 0;
  return result;
}

uint64_t sub_19E465B04(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v2 + 96);
  return result;
}

uint64_t sub_19E465B18(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 48);
}

uint64_t sub_19E465B24(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 40);
}

uint64_t sub_19E465B34(void *a1, void *a2, uint64_t a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a3 + 27)) {
    int v6 = 1;
  }
  else {
    int v6 = 2;
  }
  uint64_t v7 = a1[1];
  if (v7)
  {
    uint64_t v8 = 0;
    int v35 = 0;
    uint64_t v9 = *(void *)(v7 + 104);
    uint64_t v10 = *(int *)(v7 + 96);
  }
  else
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)((char *)a2 + *(void *)(*a2 - 24) + 40) + 32))(&v41);
    uint64_t v8 = v49;
    if (v49 == -1)
    {
      uint64_t v10 = *(unsigned int *)(a1[1] + 96);
      if ((int)v10 < 1)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 0;
      }
      else
      {
        uint64_t v11 = 0;
        uint64_t v9 = 0;
        do
          v9 += (*(uint64_t (**)(void *, uint64_t))(*a1 + 32))(a1, v11++);
        while (v10 != v11);
      }
      int v35 = 0;
      uint64_t v8 = -1;
    }
    else
    {
      int v35 = 1;
      uint64_t v9 = -1;
      uint64_t v10 = -1;
    }
  }
  long long v44 = 0u;
  long long v45 = 0u;
  *(_OWORD *)long long v42 = 0u;
  *(_OWORD *)char v43 = 0u;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v46 = -1;
  uint64_t v46 = (*(int (**)(void *))(*a1 + 16))(a1);
  uint64_t v47 = v10;
  uint64_t v48 = v9;
  char v40 = 5;
  strcpy((char *)v39, "const");
  uint64_t v34 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*a1 + 56))(a1, 0x3FFFFFFF0004, 1) | 1;
  sub_19E4608AC((uint64_t)a1, (uint64_t)a2, (unsigned char *)a3, v6, v39, v34, (uint64_t)&v41);
  if (*(unsigned char *)(a3 + 27) && (sub_19E5351A0(a2) & 1) == 0)
  {
    char v38 = 5;
    strcpy((char *)__p, "ERROR");
    uint64_t v15 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
    sub_19E37CA70(v15, (uint64_t)": ", 2);
    sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Could not align file during write after header", 46);
  }
  else
  {
    uint64_t v32 = v8;
    int v33 = v6;
    uint64_t v12 = *(unsigned int *)(a1[1] + 96);
    if ((int)v12 < 1)
    {
      uint64_t v14 = 0;
      uint64_t v12 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      do
      {
        (*(void (**)(void **__return_ptr, void *, uint64_t))(*a1 + 24))(__p, a1, v13);
        unsigned int v36 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 32))(a1, v13);
        (*(void (**)(void *, uint64_t))(*a1 + 40))(a1, v13);
        (*(void (**)(void *, uint64_t))(*a1 + 48))(a1, v13);
        std::ostream::write();
        v14 += v36;
        ++v13;
      }
      while (v12 != v13);
    }
    uint64_t v47 = v12;
    uint64_t v48 = v14;
    if (*(unsigned char *)(a3 + 27))
    {
      if ((sub_19E5351A0(a2) & 1) == 0)
      {
        char v38 = 5;
        strcpy((char *)__p, "ERROR");
        char v16 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
        sub_19E37CA70(v16, (uint64_t)": ", 2);
        sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Could not align file during write after writing states", 54);
        sub_19E43C8CC();
        if (v38 < 0) {
          operator delete(__p[0]);
        }
      }
    }
    uint64_t v17 = *(unsigned int *)(a1[1] + 96);
    if ((int)v17 >= 1)
    {
      for (uint64_t i = 0; i != v17; ++i)
      {
        uint64_t v19 = a1[1];
        uint64_t v20 = *(void *)(v19 + 80) + 20 * i;
        uint64_t v21 = *(unsigned int *)(v20 + 8);
        if (v21)
        {
          uint64_t v22 = *(void *)(v19 + 88) + 16 * *(unsigned int *)(v20 + 4);
          do
          {
            std::ostream::write();
            v22 += 16;
            --v21;
          }
          while (v21);
        }
      }
    }
    std::ostream::flush();
    if ((*((unsigned char *)a2 + *(void *)(*a2 - 24) + 32) & 5) != 0)
    {
      char v38 = 5;
      strcpy((char *)__p, "ERROR");
      uint64_t v23 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
      sub_19E37CA70(v23, (uint64_t)": ", 2);
      uint64_t v24 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"ConstFst Write write failed: ", 29);
      int v25 = *(char *)(a3 + 23);
      if (v25 >= 0) {
        uint64_t v26 = a3;
      }
      else {
        uint64_t v26 = *(void *)a3;
      }
      if (v25 >= 0) {
        uint64_t v27 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v27 = *(void *)(a3 + 8);
      }
      sub_19E37CA70(v24, v26, v27);
    }
    else
    {
      if (v35)
      {
        uint64_t v28 = sub_19E460CC0((uint64_t)a1, a2, a3, v33, v39, v34, (uint64_t)&v41, v32);
        goto LABEL_44;
      }
      if (v47 == v10)
      {
        if (v48 == v9)
        {
          uint64_t v28 = 1;
          goto LABEL_44;
        }
        char v38 = 5;
        strcpy((char *)__p, "ERROR");
        uint64_t v31 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
        sub_19E37CA70(v31, (uint64_t)": ", 2);
        sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Inconsistent number of arcs observed during write", 49);
      }
      else
      {
        char v38 = 5;
        strcpy((char *)__p, "ERROR");
        int v30 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
        sub_19E37CA70(v30, (uint64_t)": ", 2);
        sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Inconsistent number of states observed during write", 51);
      }
    }
  }
  sub_19E43C8CC();
  if (v38 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v28 = 0;
LABEL_44:
  if ((v40 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v44) & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_49:
    operator delete(v43[1]);
    if ((SHIBYTE(v43[0]) & 0x80000000) == 0) {
      return v28;
    }
LABEL_50:
    operator delete(v42[0]);
    return v28;
  }
  operator delete(v39[0]);
  if (SHIBYTE(v44) < 0) {
    goto LABEL_49;
  }
LABEL_46:
  if (SHIBYTE(v43[0]) < 0) {
    goto LABEL_50;
  }
  return v28;
}

void sub_19E46620C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a21 < 0)
  {
    operator delete(__p);
    if (a27 < 0)
    {
LABEL_5:
      operator delete(a22);
      if ((a40 & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
  }
  else if (a27 < 0)
  {
    goto LABEL_5;
  }
  if ((a40 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a34 & 0x80000000) == 0) {
LABEL_11:
    }
      _Unwind_Resume(a1);
LABEL_10:
    operator delete(a29);
    goto LABEL_11;
  }
LABEL_9:
  operator delete(a35);
  if ((a34 & 0x80000000) == 0) {
    goto LABEL_11;
  }
  goto LABEL_10;
}

void sub_19E4662DC()
{
}

uint64_t sub_19E466344(uint64_t a1)
{
  return *(void *)(a1 + 8) + 16;
}

uint64_t sub_19E466350(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v8 = 0;
    unint64_t v5 = sub_19E4614A8(a1, a2, &v8);
    *(void *)(*(void *)(a1 + 8) + 8) = *(void *)(*(void *)(a1 + 8) + 8) & (~v8 | 4) | v8 & v5;
    return v5 & a2;
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(void))(**(void **)(a1 + 8) + 24);
    return v7();
  }
}

uint64_t sub_19E466404(uint64_t a1, int a2)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 8) + 80) + 20 * a2 + 16);
}

uint64_t sub_19E46641C(uint64_t a1, int a2)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 8) + 80) + 20 * a2 + 12);
}

uint64_t sub_19E466434(uint64_t a1, int a2)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 8) + 80) + 20 * a2 + 8);
}

float sub_19E46644C@<S0>(uint64_t a1@<X0>, int a2@<W1>, float *a3@<X8>)
{
  float result = *(float *)(*(void *)(*(void *)(a1 + 8) + 80) + 20 * a2);
  *a3 = result;
  return result;
}

uint64_t sub_19E466468(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 112);
}

void sub_19E466474(void *a1)
{
  *a1 = &unk_1EF0BD068;
  uint64_t v1 = (_DWORD *)a1[1];
  int v2 = v1[14] - 1;
  v1[14] = v2;
  if (!v2) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E466514(void *a1)
{
  *a1 = &unk_1EF0BD068;
  int v2 = (_DWORD *)a1[1];
  int v3 = v2[14] - 1;
  v2[14] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_19E46658C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BC908;
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *(void *)a1 = &unk_1EF0BCF98;
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E4666C8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BC908;
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *(void *)a1 = &unk_1EF0BCF98;
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

uint64_t sub_19E4667E4(uint64_t a1)
{
  std::mutex::~mutex((std::mutex *)(a1 + 8));
  uint64_t v2 = *(uint64_t **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    MEMORY[0x19F3BDCF0](v2, 0x1020C405F07FB98);
  }
  return a1;
}

BOOL sub_19E466864(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  memset(v22, 0, 7);
  if (a2 == a3) {
    return 0;
  }
  int v6 = a2;
  uint64_t v8 = 0;
  LOBYTE(v9) = 0;
  while (1)
  {
    uint64_t v10 = *v6;
    uint64_t v11 = (*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 80))(*v6, a1);
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t))(*(void *)v10 + 56))(&__s, v10, v11);
    if ((v9 & 0x80) != 0) {
      operator delete(v8);
    }
    uint64_t v8 = __s;
    unint64_t v12 = v20;
    v22[0] = DWORD2(v20);
    *(_DWORD *)((char *)v22 + 3) = *(_DWORD *)((char *)&v20 + 11);
    int v9 = SHIBYTE(v20);
    uint64_t v13 = HIBYTE(v20);
    if (v20 < 0) {
      uint64_t v13 = v20;
    }
    BOOL v14 = v13 != 0;
    if (v13) {
      break;
    }
    if (++v6 == a3) {
      goto LABEL_16;
    }
  }
  int v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 88))(v10, a1);
  switch(v15)
  {
    case 'Y':
      __s = "xFULLNAMEx";
      if ((v9 & 0x80000000) == 0)
      {
        *(void *)&long long v20 = v8;
        *((void *)&v20 + 1) = v12;
        LODWORD(v21) = v22[0];
        *(_DWORD *)((char *)&v21 + 3) = *(_DWORD *)((char *)v22 + 3);
        HIBYTE(v21) = v9;
        char v16 = "xFULLNAMEx";
        goto LABEL_24;
      }
      break;
    case 'E':
      __s = "xSURNAMEx";
      if ((v9 & 0x80000000) == 0)
      {
        *(void *)&long long v20 = v8;
        *((void *)&v20 + 1) = v12;
        LODWORD(v21) = v22[0];
        *(_DWORD *)((char *)&v21 + 3) = *(_DWORD *)((char *)v22 + 3);
        HIBYTE(v21) = v9;
        char v16 = "xSURNAMEx";
        goto LABEL_24;
      }
      break;
    case 'D':
      __s = "xGIVENNAMEx";
      if ((v9 & 0x80000000) == 0)
      {
        *(void *)&long long v20 = v8;
        *((void *)&v20 + 1) = v12;
        LODWORD(v21) = v22[0];
        *(_DWORD *)((char *)&v21 + 3) = *(_DWORD *)((char *)v22 + 3);
        HIBYTE(v21) = v9;
        char v16 = "xGIVENNAMEx";
        goto LABEL_24;
      }
      break;
    default:
LABEL_16:
      if ((v9 & 0x80000000) == 0) {
        return v14;
      }
      goto LABEL_17;
  }
  sub_19E39369C(&v20, v8, v12);
  char v16 = __s;
LABEL_24:
  sub_19E3F7C4C((void **)a4, v16);
  uint64_t v18 = (void **)(a4 + 24);
  if (*(char *)(a4 + 47) < 0) {
    operator delete(*v18);
  }
  *(_OWORD *)uint64_t v18 = v20;
  *(void *)(a4 + 40) = v21;
  if (v9 < 0) {
LABEL_17:
  }
    operator delete(v8);
  return v14;
}

void sub_19E466B20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (v17 < 0)
  {
    operator delete(v16);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E466B7C(uint64_t **a1, const void **a2, uint64_t a3)
{
  int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (!v5)
  {
    uint64_t v10 = a1 + 1;
    goto LABEL_29;
  }
  int v7 = *((char *)a2 + 23);
  if (v7 >= 0) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = *a2;
  }
  if (v7 >= 0) {
    int v9 = (const void *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    int v9 = a2[1];
  }
  do
  {
    while (1)
    {
      uint64_t v10 = (uint64_t **)v5;
      uint64_t v13 = v5[4];
      uint64_t v11 = v5 + 4;
      unint64_t v12 = (void *)v13;
      int v14 = *((char *)v11 + 23);
      int v15 = v14 >= 0 ? v11 : v12;
      char v16 = v14 >= 0 ? (const void *)*((unsigned __int8 *)v11 + 23) : (const void *)v11[1];
      size_t v17 = (size_t)(v16 >= v9 ? v9 : v16);
      int v18 = memcmp(v8, v15, v17);
      if (v18) {
        break;
      }
      if (v9 >= v16) {
        goto LABEL_22;
      }
LABEL_8:
      uint64_t v5 = *v10;
      int v6 = v10;
      if (!*v10) {
        goto LABEL_29;
      }
    }
    if (v18 < 0) {
      goto LABEL_8;
    }
LABEL_22:
    float result = (uint64_t *)memcmp(v15, v8, v17);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        return result;
      }
    }
    else if (v16 >= v9)
    {
      return result;
    }
    uint64_t v5 = v10[1];
  }
  while (v5);
  int v6 = v10 + 1;
LABEL_29:
  long long v20 = (uint64_t *)operator new(0x50uLL);
  uint64_t v21 = v20;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_19E39369C((unsigned char *)v20 + 32, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *((_OWORD *)v20 + 2) = *(_OWORD *)a3;
    v20[6] = *(void *)(a3 + 16);
  }
  uint64_t v22 = v21 + 7;
  if (*(char *)(a3 + 47) < 0)
  {
    sub_19E39369C(v22, *(void **)(a3 + 24), *(void *)(a3 + 32));
  }
  else
  {
    *(_OWORD *)uint64_t v22 = *(_OWORD *)(a3 + 24);
    v21[9] = *(void *)(a3 + 40);
  }
  uint64_t *v21 = 0;
  v21[1] = 0;
  v21[2] = (uint64_t)v10;
  *int v6 = v21;
  uint64_t v23 = (uint64_t *)**a1;
  if (v23)
  {
    *a1 = v23;
    uint64_t v21 = *v6;
  }
  float result = sub_19E37D324(a1[1], v21);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void sub_19E466D0C(_Unwind_Exception *a1)
{
  if (v1[55] < 0) {
    operator delete(*v2);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E466D38(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  switch(*(_DWORD *)(a4 + 4))
  {
    case 0:
      uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 128))(result, 1);
      uint64_t v8 = v5;
      if (!v5) {
        operator new();
      }
      LOBYTE(v9) = 0;
      uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 128))(a2, 0);
      uint64_t v14 = v6;
      if (!v6) {
        operator new();
      }
      LOBYTE(v15) = 0;
      int v7 = sub_19E48266C(&v8, &v14);
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      if (v7)
      {
        if (v7 == 1)
        {
          LOBYTE(v8) = 1;
          long long v9 = 0u;
          long long v10 = 0u;
          long long v11 = 0u;
          operator new();
        }
        LOBYTE(v8) = 1;
        long long v9 = 0u;
        long long v10 = 0u;
        long long v11 = 0u;
        operator new();
      }
      LOBYTE(v8) = 1;
      long long v9 = 0u;
      long long v10 = 0u;
      long long v11 = 0u;
      operator new();
    case 1:
      LOBYTE(v8) = 1;
      long long v9 = 0u;
      long long v10 = 0u;
      long long v11 = 0u;
      operator new();
    case 2:
      LOBYTE(v8) = 1;
      long long v9 = 0u;
      long long v10 = 0u;
      long long v11 = 0u;
      operator new();
    case 3:
      LOBYTE(v8) = 1;
      long long v9 = 0u;
      long long v10 = 0u;
      long long v11 = 0u;
      operator new();
    case 4:
      LOBYTE(v8) = 1;
      long long v9 = 0u;
      long long v10 = 0u;
      long long v11 = 0u;
      operator new();
    default:
      if (*(unsigned char *)a4)
      {
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        memset(v13, 0, sizeof(v13));
        uint64_t v12 = 0;
        uint64_t v8 = 0;
        *(void *)&long long v9 = &v14;
        *((void *)&v9 + 1) = v13;
        *(void *)&long long v10 = &v12;
        sub_19E461EC4(a3, (uint64_t)&v8);
      }
      return result;
  }
}

void sub_19E469D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p)
{
  sub_19E43C8CC();
  if (*(char *)(v27 - 89) < 0) {
    operator delete(*(void **)(v27 - 112));
  }
  sub_19E46B1C8(v26);
  MEMORY[0x19F3BDCF0](v26, 0x10F3C405A371F01);
  _Unwind_Resume(a1);
}

void sub_19E46A268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  if (a11)
  {
    operator delete(a11);
    uint64_t v28 = a26;
    if (!a26)
    {
LABEL_3:
      unint64_t v29 = *(void **)(v26 - 112);
      if (!v29) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v28 = a26;
    if (!a26) {
      goto LABEL_3;
    }
  }
  operator delete(v28);
  unint64_t v29 = *(void **)(v26 - 112);
  if (!v29) {
LABEL_4:
  }
    _Unwind_Resume(a1);
LABEL_7:
  operator delete(v29);
  _Unwind_Resume(a1);
}

void *sub_19E46A2CC(void *a1)
{
  *a1 = &unk_1EF0BD230;
  uint64_t v2 = (_DWORD *)a1[1];
  int v3 = v2[14] - 1;
  v2[14] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_19E46A344(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (void *)sub_19E46AB6C(a1, a4);
  *uint64_t v8 = &unk_1EF0BCED8;
  sub_19E46ACCC((uint64_t)v8, a2, a3);
  *(void *)a1 = &unk_1EF0BCB08;
  long long v9 = *(long long **)(a4 + 40);
  if (!v9) {
    operator new();
  }
  *(void *)(a1 + 136) = v9;
  long long v10 = *v9;
  *(_OWORD *)(a1 + 144) = *v9;
  *(void *)(a1 + 160) = (*(uint64_t (**)(void))(**(void **)v10 + 32))();
  *(void *)(a1 + 168) = (*(uint64_t (**)(void))(***(void ***)(a1 + 152) + 32))(**(void **)(a1 + 152));
  uint64_t v11 = *(void *)(a4 + 48);
  if (!v11) {
    operator new();
  }
  *(void *)(a1 + 176) = v11;
  if (((*(uint64_t (**)(void))(***(void ***)(a1 + 144) + 48))(**(void **)(a1 + 144)) & 1) != 0
    && (*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 144) + 24))(**(void **)(a1 + 144), 1) != 1)
  {
    char v31 = 5;
    strcpy((char *)__p, "FATAL");
    int v18 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
    sub_19E37CA70(v18, (uint64_t)": ", 2);
    sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"ComposeFst: 1st argument requires matching but cannot.", 54);
    goto LABEL_26;
  }
  if (((*(uint64_t (**)(void))(***(void ***)(a1 + 152) + 48))(**(void **)(a1 + 152)) & 1) != 0
    && (*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 152) + 24))(**(void **)(a1 + 152), 1))
  {
    char v31 = 5;
    strcpy((char *)__p, "FATAL");
    uint64_t v12 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
    sub_19E37CA70(v12, (uint64_t)": ", 2);
    sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"ComposeFst: 2nd argument requires matching but cannot.", 54);
    goto LABEL_26;
  }
  int v13 = (*(uint64_t (**)(void, void))(***(void ***)(a1 + 144) + 24))(**(void **)(a1 + 144), 0);
  int v14 = (*(uint64_t (**)(void, void))(***(void ***)(a1 + 152) + 24))(**(void **)(a1 + 152), 0);
  if (v14) {
    BOOL v15 = 0;
  }
  else {
    BOOL v15 = v13 == 1;
  }
  if (v15) {
    int v16 = 2;
  }
  else {
    int v16 = 1;
  }
  if (v13 == 1)
  {
    BOOL v17 = 1;
  }
  else
  {
    int v16 = 0;
    BOOL v17 = v14 == 0;
  }
  if (v17)
  {
LABEL_22:
    *(_DWORD *)(a1 + 184) = v16;
    goto LABEL_29;
  }
  if ((*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 144) + 24))(**(void **)(a1 + 144), 1) == 1)
  {
    int v16 = 1;
    goto LABEL_22;
  }
  if (!(*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 152) + 24))(**(void **)(a1 + 152), 1))
  {
    *(_DWORD *)(a1 + 184) = 0;
    goto LABEL_29;
  }
  char v31 = 5;
  strcpy((char *)__p, "FATAL");
  uint64_t v19 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
  sub_19E37CA70(v19, (uint64_t)": ", 2);
  long long v20 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"ComposeFst: 1st argument cannot match on output labels ", 55);
  sub_19E37CA70(v20, (uint64_t)"and 2nd argument cannot match on input labels (sort?).", 54);
LABEL_26:
  sub_19E43C8CC();
  if (v31 < 0) {
    operator delete(__p[0]);
  }
  *(_DWORD *)(a1 + 184) = 3;
  *(void *)(a1 + 8) |= 4uLL;
LABEL_29:
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a2 + 56))(a2, 0x3FFFFFFF0007, 0);
  uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a3 + 56))(a3, 0x3FFFFFFF0007, 0);
  uint64_t v23 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 144) + 40))(**(void **)(a1 + 144), v21);
  uint64_t v24 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 152) + 40))(**(void **)(a1 + 152), v22);
  uint64_t v25 = (v24 | v23) & 4;
  uint64_t v26 = v24 & v23;
  uint64_t v27 = v24 & v23 & 0x2802010000 | v25 | 0x10000000000;
  if ((v24 & v23 & 0x2000000) != 0) {
    v27 |= v24 & v23 & 0x40000;
  }
  uint64_t v28 = v26 & 0x280A800000 | v25 | 0x10000010000;
  if ((v26 & 0x2000000) != 0) {
    v28 |= v26 & 0x140000;
  }
  if ((v26 & 0x10000) == 0) {
    uint64_t v28 = v27;
  }
  *(void *)(a1 + 8) = *(void *)(a1 + 8) & 0xFFFFC0000000FFFFLL | v28 & 0x13FFFFF0004;
  return a1;
}

void sub_19E46AA88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  MEMORY[0x19F3BDCF0](v18, 0x10E1C4003B7394BLL);
  MEMORY[0x19F3BDCF0](v17, 0x20C4093837F09);
  MEMORY[0x19F3BDCF0](v16, 0x1060C40AD892F49);
  sub_19E46B1C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_19E46AB6C(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(result + 39) = 4;
  strcpy((char *)(result + 16), "null");
  *(void *)(result + 40) = 0;
  *(void *)(result + 48) = 0;
  *(_DWORD *)(result + 56) = 1;
  *(void *)float result = &unk_1EF0BC938;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 64) = -1;
  *(_OWORD *)(result + 68) = 0u;
  *(_OWORD *)(result + 84) = 0u;
  *(_DWORD *)(result + 100) = -1;
  *(unsigned char *)(result + 104) = *(unsigned char *)a2;
  uint64_t v2 = *(void *)(a2 + 16);
  *(void *)(result + 112) = *(void *)(a2 + 8);
  *(unsigned char *)(result + 60) = 0;
  if (!v2) {
    operator new();
  }
  *(void *)(result + 120) = v2;
  *(unsigned char *)(result + 128) = v2 == 0;
  return result;
}

void sub_19E46AC8C(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v2, 0x10A0C40690396FALL);
  uint64_t v4 = *(void **)(v1 + 72);
  if (v4) {
    operator delete(v4);
  }
  sub_19E47A394(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E46ACCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  HIBYTE(v37) = 7;
  strcpy((char *)__s1, "compose");
  uint64_t v6 = a1 + 16;
  if (*(char *)(a1 + 39) < 0)
  {
    sub_19E3C6D44((void **)v6, __s1, 7uLL);
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)__s1;
    *(void *)(v6 + 16) = v37;
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 96))(a3);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (v7) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    goto LABEL_41;
  }
  uint64_t v10 = v8;
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v7 + 64))(__s1, v7);
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v10 + 64))(__p, v10);
  char v11 = HIBYTE(v37);
  if (v37 >= 0) {
    uint64_t v12 = (void *)HIBYTE(v37);
  }
  else {
    uint64_t v12 = __s1[1];
  }
  unint64_t v13 = v35;
  int v14 = (char)v35;
  if ((v35 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)__p[1];
  }
  if (v12 != (void *)v13)
  {
    BOOL v21 = 1;
    if (((char)v35 & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_34;
  }
  if ((v35 & 0x80u) == 0) {
    uint64_t v15 = __p;
  }
  else {
    uint64_t v15 = (void **)__p[0];
  }
  if (SHIBYTE(v37) < 0)
  {
    BOOL v21 = memcmp(__s1[0], v15, (size_t)__s1[1]) != 0;
    goto LABEL_29;
  }
  if (HIBYTE(v37))
  {
    uint64_t v16 = HIBYTE(v37) - 1;
    uint64_t v17 = __s1;
    do
    {
      int v19 = *(unsigned __int8 *)v17;
      uint64_t v17 = (void **)((char *)v17 + 1);
      int v18 = v19;
      int v20 = *(unsigned __int8 *)v15;
      uint64_t v15 = (void **)((char *)v15 + 1);
      BOOL v21 = v18 != v20;
    }
    while (v18 == v20 && v16-- != 0);
LABEL_29:
    if ((v14 & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_34;
  }
  BOOL v21 = 0;
  if (((char)v35 & 0x80000000) == 0)
  {
LABEL_30:
    if ((v11 & 0x80) == 0) {
      goto LABEL_31;
    }
    goto LABEL_35;
  }
LABEL_34:
  operator delete(__p[0]);
  if ((v37 & 0x8000000000000000) == 0)
  {
LABEL_31:
    if (!v21) {
      goto LABEL_41;
    }
    goto LABEL_36;
  }
LABEL_35:
  operator delete(__s1[0]);
  if (!v21) {
    goto LABEL_41;
  }
LABEL_36:
  HIBYTE(v37) = 7;
  strcpy((char *)__s1, "WARNING");
  uint64_t v23 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__s1, 7);
  sub_19E37CA70(v23, (uint64_t)": ", 2);
  uint64_t v24 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"CompatSymbols: Symbol table check sums do not match. ", 53);
  sub_19E37CA70(v24, (uint64_t)"Table sizes are ", 16);
  (*(void (**)(uint64_t))(*(void *)v7 + 120))(v7);
  uint64_t v25 = (void *)std::ostream::operator<<();
  sub_19E37CA70(v25, (uint64_t)" and ", 5);
  (*(void (**)(uint64_t))(*(void *)v10 + 120))(v10);
  std::ostream::operator<<();
  sub_19E43C8CC();
  if (SHIBYTE(v37) < 0) {
    operator delete(__s1[0]);
  }
  HIBYTE(v37) = 5;
  strcpy((char *)__s1, "FATAL");
  uint64_t v26 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__s1, 5);
  sub_19E37CA70(v26, (uint64_t)": ", 2);
  uint64_t v27 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"ComposeFst: output symbol table of 1st argument ", 48);
  sub_19E37CA70(v27, (uint64_t)"does not match input symbol table of 2nd argument", 49);
  sub_19E43C8CC();
  if (SHIBYTE(v37) < 0) {
    operator delete(__s1[0]);
  }
  *(void *)(a1 + 8) |= 4uLL;
LABEL_41:
  uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 96))(a2);
  uint64_t v29 = *(void *)(a1 + 40);
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  }
  if (v28) {
    uint64_t v30 = (*(uint64_t (**)(uint64_t))(*(void *)v28 + 16))(v28);
  }
  else {
    uint64_t v30 = 0;
  }
  *(void *)(a1 + 40) = v30;
  uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 104))(a3);
  uint64_t v32 = *(void *)(a1 + 48);
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
  }
  if (v31) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 16))(v31);
  }
  else {
    uint64_t result = 0;
  }
  *(void *)(a1 + 48) = result;
  return result;
}

void sub_19E46B18C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E46B1C8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BC938;
  uint64_t v2 = *(void **)(a1 + 120);
  if (v2)
  {
    sub_19E47A43C(*(void **)(a1 + 120));
    int v3 = (void *)v2[10];
    uint64_t v4 = v3[1] - 1;
    v3[1] = v4;
    if (!v4)
    {
      uint64_t v5 = (void *)v3[2];
      uint64_t v6 = (unsigned char *)v3[3];
      if (v6 == (unsigned char *)v5)
      {
        uint64_t v5 = (void *)v3[3];
      }
      else
      {
        unint64_t v7 = 0;
        do
        {
          uint64_t v8 = v5[v7];
          if (v8)
          {
            (*(void (**)(void))(*(void *)v8 + 8))(v5[v7]);
            uint64_t v5 = (void *)v3[2];
            uint64_t v6 = (unsigned char *)v3[3];
          }
          ++v7;
        }
        while (v7 < (v6 - (unsigned char *)v5) >> 3);
      }
      if (v5)
      {
        v3[3] = v5;
        operator delete(v5);
      }
      MEMORY[0x19F3BDCF0](v3, 0x1080C40B69A5871);
    }
    BOOL v9 = (void *)v2[9];
    uint64_t v10 = v9[1] - 1;
    v9[1] = v10;
    if (!v10)
    {
      char v11 = (void *)v9[2];
      uint64_t v12 = (unsigned char *)v9[3];
      if (v12 == (unsigned char *)v11)
      {
        char v11 = (void *)v9[3];
      }
      else
      {
        unint64_t v13 = 0;
        do
        {
          uint64_t v14 = v11[v13];
          if (v14)
          {
            (*(void (**)(void))(*(void *)v14 + 8))(v11[v13]);
            char v11 = (void *)v9[2];
            uint64_t v12 = (unsigned char *)v9[3];
          }
          ++v13;
        }
        while (v13 < (v12 - (unsigned char *)v11) >> 3);
      }
      if (v11)
      {
        v9[3] = v11;
        operator delete(v11);
      }
      MEMORY[0x19F3BDCF0](v9, 0x1080C40B69A5871);
    }
    sub_19E47A620(v2 + 4);
    uint64_t v15 = (void *)v2[1];
    if (v15)
    {
      uint64_t v2[2] = v15;
      operator delete(v15);
    }
    MEMORY[0x19F3BDCF0](v2, 0x10A0C40690396FALL);
  }
  uint64_t v16 = *(void **)(a1 + 72);
  if (v16) {
    operator delete(v16);
  }
  *(void *)a1 = &unk_1EF0BCF98;
  uint64_t v17 = *(void *)(a1 + 40);
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  uint64_t v18 = *(void *)(a1 + 48);
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_19E46B414()
{
}

void sub_19E46B57C(_Unwind_Exception *a1)
{
  sub_19E46B83C(v1);
  _Unwind_Resume(a1);
}

void sub_19E46B590(_Unwind_Exception *a1)
{
  sub_19E46B5A4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E46B5A4(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    sub_19E46C948((uint64_t *)(a1 + 16), v2, *(void *)(a1 + 8));
  }
  int v3 = *(void **)(a1 + 16);
  uint64_t v4 = v3[1] - 1;
  v3[1] = v4;
  if (!v4)
  {
    uint64_t v5 = (void *)v3[2];
    uint64_t v6 = (unsigned char *)v3[3];
    if (v6 == (unsigned char *)v5)
    {
      uint64_t v5 = (void *)v3[3];
    }
    else
    {
      unint64_t v7 = 0;
      do
      {
        uint64_t v8 = v5[v7];
        if (v8)
        {
          (*(void (**)(void))(*(void *)v8 + 8))(v5[v7]);
          uint64_t v5 = (void *)v3[2];
          uint64_t v6 = (unsigned char *)v3[3];
        }
        ++v7;
      }
      while (v7 < (v6 - (unsigned char *)v5) >> 3);
    }
    if (v5)
    {
      v3[3] = v5;
      operator delete(v5);
    }
    MEMORY[0x19F3BDCF0](v3, 0x1080C40B69A5871);
  }
  return a1;
}

void sub_19E46B684(uint64_t a1, unint64_t a2)
{
  if (!a2)
  {
    uint64_t v15 = *(void **)a1;
    *(void *)a1 = 0;
    if (v15) {
      sub_19E46C948((uint64_t *)(a1 + 16), v15, *(void *)(a1 + 8));
    }
    *(void *)(a1 + 8) = 0;
    return;
  }
  uint64_t v4 = sub_19E46C10C((uint64_t *)(a1 + 16), a2);
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    sub_19E46C948((uint64_t *)(a1 + 16), v5, *(void *)(a1 + 8));
  }
  uint64_t v6 = 0;
  *(void *)(a1 + 8) = a2;
  do
    *(void *)(*(void *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  uint64_t v8 = a1 + 24;
  unint64_t v7 = *(void **)(a1 + 24);
  if (v7)
  {
    unint64_t v9 = v7[1];
    unint64_t v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      unint64_t v11 = v9 & v10;
      *(void *)(*(void *)a1 + 8 * v11) = v8;
      while (1)
      {
        uint64_t v12 = (void *)*v7;
        if (!*v7) {
          break;
        }
        unint64_t v13 = v12[1] & v10;
        if (v13 == v11)
        {
          unint64_t v7 = (void *)*v7;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          *unint64_t v7 = *v12;
          uint64_t v14 = 8 * v13;
          *uint64_t v12 = **(void **)(*(void *)a1 + v14);
          **(void **)(*(void *)a1 + v14) = v12;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          unint64_t v7 = v12;
          unint64_t v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2) {
      v9 %= a2;
    }
    *(void *)(*(void *)a1 + 8 * v9) = v8;
    uint64_t v16 = (void *)*v7;
    if (*v7)
    {
      do
      {
        unint64_t v18 = v16[1];
        if (v18 >= a2) {
          v18 %= a2;
        }
        if (v18 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v18))
          {
            *(void *)(*(void *)a1 + 8 * v18) = v7;
            goto LABEL_25;
          }
          *unint64_t v7 = *v16;
          uint64_t v17 = 8 * v18;
          *uint64_t v16 = **(void **)(*(void *)a1 + v17);
          **(void **)(*(void *)a1 + v17) = v16;
          uint64_t v16 = v7;
        }
        unint64_t v18 = v9;
LABEL_25:
        unint64_t v7 = v16;
        uint64_t v16 = (void *)*v16;
        unint64_t v9 = v18;
      }
      while (v16);
    }
  }
}

uint64_t sub_19E46B83C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  int v3 = (void *)(a1 + 32);
  while (v2)
  {
    uint64_t v4 = (void *)*v2;
    sub_19E46B934((uint64_t)v3, (uint64_t)v2);
    uint64_t v2 = v4;
  }
  uint64_t v5 = (void *)*v3;
  uint64_t v6 = v5[1] - 1;
  v5[1] = v6;
  if (!v6)
  {
    unint64_t v7 = (void *)v5[2];
    uint64_t v8 = (unsigned char *)v5[3];
    if (v8 == (unsigned char *)v7)
    {
      unint64_t v7 = (void *)v5[3];
    }
    else
    {
      unint64_t v9 = 0;
      do
      {
        uint64_t v10 = v7[v9];
        if (v10)
        {
          (*(void (**)(void))(*(void *)v10 + 8))(v7[v9]);
          unint64_t v7 = (void *)v5[2];
          uint64_t v8 = (unsigned char *)v5[3];
        }
        ++v9;
      }
      while (v9 < (v8 - (unsigned char *)v7) >> 3);
    }
    if (v7)
    {
      v5[3] = v7;
      operator delete(v7);
    }
    MEMORY[0x19F3BDCF0](v5, 0x1080C40B69A5871);
  }
  return sub_19E46B5A4(a1);
}

void sub_19E46B934(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (unint64_t *)(*(void *)a1 + 16);
  unint64_t v3 = *v4;
  unint64_t v5 = *(void *)(*(void *)a1 + 24) - *v4;
  if (v5 <= 0xC7)
  {
    uint64_t v7 = 0;
    sub_19E46BA20(v4, 25 - (v5 >> 3), (const double *)&v7);
    unint64_t v3 = *v4;
  }
  uint64_t v6 = *(void *)(v3 + 192);
  if (!v6) {
    operator new();
  }
  *(void *)(a2 + ++*(void *)(result + 24) = *(void *)(v6 + 56);
  *(void *)(v6 + 56) = a2;
}

void sub_19E46B9FC(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10A1C40E79ACBF4);
  _Unwind_Resume(a1);
}

void sub_19E46BA20(unint64_t *a1, unint64_t a2, const double *a3)
{
  unint64_t v7 = a1[1];
  unint64_t v6 = a1[2];
  uint64_t v8 = (double *)v7;
  if (a2 <= (uint64_t)(v6 - v7) >> 3)
  {
    uint64_t v16 = (const double *)(v7 + 8 * a2);
    unint64_t v17 = (a2 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v17 >= 0xF && (v7 >= (unint64_t)(a3 + 1) || v16 <= a3))
    {
      unint64_t v18 = v17 + 1;
      float64x2_t v19 = vld1q_dup_f64(a3);
      int v20 = (float64x2_t *)(v7 + 16);
      uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v20[-1] = v19;
        *int v20 = v19;
        v20 += 2;
        v21 -= 4;
      }
      while (v21);
      if (v18 == (v18 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_19;
      }
      uint64_t v8 = (double *)(v7 + 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL));
    }
    do
      *v8++ = *a3;
    while (v8 != v16);
LABEL_19:
    a1[1] = (unint64_t)v16;
    return;
  }
  unint64_t v9 = (double *)*a1;
  uint64_t v10 = v7 - *a1;
  uint64_t v11 = v10 >> 3;
  unint64_t v12 = (v10 >> 3) + a2;
  if (v12 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v13 = v6 - (void)v9;
  if (v13 >> 2 > v12) {
    unint64_t v12 = v13 >> 2;
  }
  if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v14 = v12;
  }
  if (v14)
  {
    if (v14 >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v15 = (char *)operator new(8 * v14);
  }
  else
  {
    uint64_t v15 = 0;
  }
  unint64_t v22 = (unint64_t)&v15[8 * v11];
  uint64_t v23 = (char *)(v22 + 8 * a2);
  unint64_t v24 = (a2 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  uint64_t v25 = (char *)v22;
  if (v24 < 0x13) {
    goto LABEL_28;
  }
  if (v22 < (unint64_t)(a3 + 1))
  {
    uint64_t v25 = &v15[8 * v11];
    if (&v15[8 * a2 + v10] > (char *)a3) {
      goto LABEL_28;
    }
  }
  unint64_t v26 = v24 + 1;
  float64x2_t v27 = vld1q_dup_f64(a3);
  uint64_t v28 = (float64x2_t *)&v15[8 * v11 + 16];
  uint64_t v29 = v26 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v28[-1] = v27;
    *uint64_t v28 = v27;
    v28 += 2;
    v29 -= 4;
  }
  while (v29);
  if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
  {
    uint64_t v25 = (char *)(v22 + 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL));
    do
    {
LABEL_28:
      *(double *)uint64_t v25 = *a3;
      v25 += 8;
    }
    while (v25 != v23);
    unint64_t v9 = (double *)*a1;
  }
  if ((double *)v7 != v9)
  {
    unint64_t v30 = v7 - (void)v9 - 8;
    if (v30 < 0x58) {
      goto LABEL_48;
    }
    if (v7 - (unint64_t)&v15[v10] < 0x20) {
      goto LABEL_48;
    }
    uint64_t v31 = (v30 >> 3) + 1;
    uint64_t v8 = (double *)(v7 - 8 * (v31 & 0x3FFFFFFFFFFFFFFCLL));
    uint64_t v32 = &v15[8 * v11 - 16];
    int v33 = (long long *)(v7 - 16);
    uint64_t v34 = v31 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v35 = *v33;
      *((_OWORD *)v32 - 1) = *(v33 - 1);
      *(_OWORD *)uint64_t v32 = v35;
      v32 -= 32;
      v33 -= 2;
      v34 -= 4;
    }
    while (v34);
    v22 -= 8 * (v31 & 0x3FFFFFFFFFFFFFFCLL);
    if (v31 == (v31 & 0x3FFFFFFFFFFFFFFCLL))
    {
      uint64_t v8 = v9;
    }
    else
    {
LABEL_48:
      do
      {
        uint64_t v36 = *((void *)v8-- - 1);
        *(void *)(v22 - 8) = v36;
        v22 -= 8;
      }
      while (v8 != v9);
      uint64_t v8 = (double *)*a1;
    }
  }
  *a1 = v22;
  a1[1] = (unint64_t)v23;
  a1[2] = (unint64_t)&v15[8 * v14];
  if (v8)
  {
    operator delete(v8);
  }
}

void sub_19E46BCA0(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0BC6E0;
  a1[1] = 32 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E46BD30(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    uint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        unint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        uint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E46BD7C()
{
  return 32;
}

void sub_19E46BD84(void *a1)
{
  *a1 = &unk_1EF0BC6E0;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        uint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46BE64(void *a1)
{
  *a1 = &unk_1EF0BC6E0;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        uint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46BF24()
{
  return 24;
}

void sub_19E46BF2C(void *a1)
{
  *a1 = &unk_1EF0BC3E8;
  a1[1] = &unk_1EF0BC6E0;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        uint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46C02C(void *a1)
{
  *a1 = &unk_1EF0BC3E8;
  a1[1] = &unk_1EF0BC6E0;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        uint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

void *sub_19E46C10C(uint64_t *a1, unint64_t a2)
{
  if (a2 == 2)
  {
    unint64_t v9 = (unint64_t *)(*a1 + 16);
    unint64_t v8 = *v9;
    unint64_t v10 = *(void *)(*a1 + 24) - *v9;
    if (v10 <= 0x87)
    {
      uint64_t v33 = 0;
      sub_19E46BA20(v9, 17 - (v10 >> 3), (const double *)&v33);
      unint64_t v8 = *v9;
    }
    uint64_t v5 = *(void **)(v8 + 128);
    if (!v5) {
      operator new();
    }
    uint64_t v6 = (void *)v5[7];
    if (!v6)
    {
      unint64_t v18 = v5[2];
      if (v18 <= 0x5F) {
        operator new[]();
      }
      uint64_t v24 = v5[3];
      if (v24 + 24 > v18) {
        operator new[]();
      }
      uint64_t v6 = (void *)(*(void *)(v5[5] + 16) + v24);
      v5[3] = v24 + 24;
      uint64_t v6[2] = 0;
      return v6;
    }
    uint64_t v7 = v6[2];
    goto LABEL_53;
  }
  if (a2 == 1)
  {
    unint64_t v3 = (unint64_t *)(*a1 + 16);
    unint64_t v2 = *v3;
    unint64_t v4 = *(void *)(*a1 + 24) - *v3;
    if (v4 <= 0x47)
    {
      uint64_t v33 = 0;
      sub_19E46BA20(v3, 9 - (v4 >> 3), (const double *)&v33);
      unint64_t v2 = *v3;
    }
    uint64_t v5 = *(void **)(v2 + 64);
    if (!v5) {
      operator new();
    }
    uint64_t v6 = (void *)v5[7];
    if (!v6)
    {
      unint64_t v17 = v5[2];
      if (v17 <= 0x3F) {
        operator new[]();
      }
      uint64_t v23 = v5[3];
      if (v23 + 16 > v17) {
        operator new[]();
      }
      uint64_t v6 = (void *)(*(void *)(v5[5] + 16) + v23);
      v5[3] = v23 + 16;
      v6[1] = 0;
      return v6;
    }
    uint64_t v7 = v6[1];
    goto LABEL_53;
  }
  if (a2 <= 4)
  {
    unint64_t v12 = (unint64_t *)(*a1 + 16);
    unint64_t v11 = *v12;
    unint64_t v13 = *(void *)(*a1 + 24) - *v12;
    if (v13 <= 0x107)
    {
      uint64_t v33 = 0;
      sub_19E46BA20(v12, 33 - (v13 >> 3), (const double *)&v33);
      unint64_t v11 = *v12;
    }
    uint64_t v5 = *(void **)(v11 + 256);
    if (!v5) {
      operator new();
    }
    uint64_t v6 = (void *)v5[7];
    if (!v6)
    {
      unint64_t v22 = v5[2];
      if (v22 <= 0x9F) {
        operator new[]();
      }
      uint64_t v30 = v5[3];
      if (v30 + 40 > v22) {
        operator new[]();
      }
      uint64_t v6 = (void *)(*(void *)(v5[5] + 16) + v30);
      v5[3] = v30 + 40;
      v6[4] = 0;
      return v6;
    }
    uint64_t v7 = v6[4];
    goto LABEL_53;
  }
  if (a2 <= 8)
  {
    uint64_t v15 = (unint64_t *)(*a1 + 16);
    unint64_t v14 = *v15;
    unint64_t v16 = *(void *)(*a1 + 24) - *v15;
    if (v16 <= 0x207)
    {
      uint64_t v33 = 0;
      sub_19E46BA20(v15, 65 - (v16 >> 3), (const double *)&v33);
      unint64_t v14 = *v15;
    }
    uint64_t v5 = *(void **)(v14 + 512);
    if (!v5) {
      operator new();
    }
    uint64_t v6 = (void *)v5[7];
    if (!v6)
    {
      unint64_t v29 = v5[2];
      if (v29 <= 0x11F) {
        operator new[]();
      }
      uint64_t v32 = v5[3];
      if (v32 + 72 > v29) {
        operator new[]();
      }
      uint64_t v6 = (void *)(*(void *)(v5[5] + 16) + v32);
      v5[3] = v32 + 72;
      v6[8] = 0;
      return v6;
    }
    uint64_t v7 = v6[8];
    goto LABEL_53;
  }
  if (a2 <= 0x10)
  {
    int v20 = (unint64_t *)(*a1 + 16);
    unint64_t v19 = *v20;
    unint64_t v21 = *(void *)(*a1 + 24) - *v20;
    if (v21 <= 0x407)
    {
      uint64_t v33 = 0;
      sub_19E46BA20(v20, 129 - (v21 >> 3), (const double *)&v33);
      unint64_t v19 = *v20;
    }
    uint64_t v5 = *(void **)(v19 + 1024);
    if (!v5) {
      operator new();
    }
    uint64_t v6 = (void *)v5[7];
    if (!v6)
    {
      uint64_t v6 = (void *)sub_19E46ED80(v5 + 1);
      v6[16] = 0;
      return v6;
    }
    uint64_t v7 = v6[16];
LABEL_53:
    v5[7] = v7;
    return v6;
  }
  if (a2 <= 0x20)
  {
    unint64_t v26 = (unint64_t *)(*a1 + 16);
    unint64_t v25 = *v26;
    unint64_t v27 = *(void *)(*a1 + 24) - *v26;
    if (v27 <= 0x807)
    {
      uint64_t v33 = 0;
      sub_19E46BA20(v26, 257 - (v27 >> 3), (const double *)&v33);
      unint64_t v25 = *v26;
    }
    uint64_t v5 = *(void **)(v25 + 2048);
    if (!v5) {
      operator new();
    }
    uint64_t v6 = (void *)v5[7];
    if (!v6)
    {
      uint64_t v6 = (void *)sub_19E46EE68(v5 + 1);
      v6[32] = 0;
      return v6;
    }
    uint64_t v7 = v6[32];
    goto LABEL_53;
  }
  if (a2 <= 0x40)
  {
    uint64_t v31 = sub_19E46D308(*a1);
    uint64_t v6 = *(void **)(v31 + 56);
    if (v6)
    {
      *(void *)(v31 + 56) = v6[64];
    }
    else
    {
      uint64_t v6 = (void *)sub_19E46EF50((void *)(v31 + 8));
      v6[64] = 0;
    }
    return v6;
  }
  if (a2 >> 61) {
    sub_19E37C2B8();
  }
  return operator new(8 * a2);
}

void sub_19E46C910(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10A1C40E79ACBF4);
  _Unwind_Resume(a1);
}

void sub_19E46C948(uint64_t *a1, void *__p, unint64_t a3)
{
  if (a3 == 2)
  {
    unint64_t v9 = (unint64_t *)(*a1 + 16);
    unint64_t v8 = *v9;
    unint64_t v10 = *(void *)(*a1 + 24) - *v9;
    if (v10 <= 0x87)
    {
      uint64_t v29 = 0;
      sub_19E46BA20(v9, 17 - (v10 >> 3), (const double *)&v29);
      unint64_t v8 = *v9;
    }
    uint64_t v11 = *(void *)(v8 + 128);
    if (!v11) {
      operator new();
    }
    __p[2] = *(void *)(v11 + 56);
    *(void *)(v11 + 56) = __p;
  }
  else if (a3 == 1)
  {
    uint64_t v5 = (unint64_t *)(*a1 + 16);
    unint64_t v4 = *v5;
    unint64_t v6 = *(void *)(*a1 + 24) - *v5;
    if (v6 <= 0x47)
    {
      uint64_t v29 = 0;
      sub_19E46BA20(v5, 9 - (v6 >> 3), (const double *)&v29);
      unint64_t v4 = *v5;
    }
    uint64_t v7 = *(void *)(v4 + 64);
    if (!v7) {
      operator new();
    }
    __p[1] = *(void *)(v7 + 56);
    *(void *)(v7 + 56) = __p;
  }
  else if (a3 > 4)
  {
    if (a3 > 8)
    {
      if (a3 > 0x10)
      {
        if (a3 > 0x20)
        {
          if (a3 > 0x40)
          {
            operator delete(__p);
          }
          else
          {
            uint64_t v28 = sub_19E46D308(*a1);
            __p[64] = *(void *)(v28 + 56);
            *(void *)(v28 + 56) = __p;
          }
        }
        else
        {
          unint64_t v25 = (unint64_t *)(*a1 + 16);
          unint64_t v24 = *v25;
          unint64_t v26 = *(void *)(*a1 + 24) - *v25;
          if (v26 <= 0x807)
          {
            uint64_t v29 = 0;
            sub_19E46BA20(v25, 257 - (v26 >> 3), (const double *)&v29);
            unint64_t v24 = *v25;
          }
          uint64_t v27 = *(void *)(v24 + 2048);
          if (!v27) {
            operator new();
          }
          __p[32] = *(void *)(v27 + 56);
          *(void *)(v27 + 56) = __p;
        }
      }
      else
      {
        unint64_t v21 = (unint64_t *)(*a1 + 16);
        unint64_t v20 = *v21;
        unint64_t v22 = *(void *)(*a1 + 24) - *v21;
        if (v22 <= 0x407)
        {
          uint64_t v29 = 0;
          sub_19E46BA20(v21, 129 - (v22 >> 3), (const double *)&v29);
          unint64_t v20 = *v21;
        }
        uint64_t v23 = *(void *)(v20 + 1024);
        if (!v23) {
          operator new();
        }
        __p[16] = *(void *)(v23 + 56);
        *(void *)(v23 + 56) = __p;
      }
    }
    else
    {
      unint64_t v17 = (unint64_t *)(*a1 + 16);
      unint64_t v16 = *v17;
      unint64_t v18 = *(void *)(*a1 + 24) - *v17;
      if (v18 <= 0x207)
      {
        uint64_t v29 = 0;
        sub_19E46BA20(v17, 65 - (v18 >> 3), (const double *)&v29);
        unint64_t v16 = *v17;
      }
      uint64_t v19 = *(void *)(v16 + 512);
      if (!v19) {
        operator new();
      }
      __p[8] = *(void *)(v19 + 56);
      *(void *)(v19 + 56) = __p;
    }
  }
  else
  {
    unint64_t v13 = (unint64_t *)(*a1 + 16);
    unint64_t v12 = *v13;
    unint64_t v14 = *(void *)(*a1 + 24) - *v13;
    if (v14 <= 0x107)
    {
      uint64_t v29 = 0;
      sub_19E46BA20(v13, 33 - (v14 >> 3), (const double *)&v29);
      unint64_t v12 = *v13;
    }
    uint64_t v15 = *(void *)(v12 + 256);
    if (!v15) {
      operator new();
    }
    __p[4] = *(void *)(v15 + 56);
    *(void *)(v15 + 56) = __p;
  }
}

void sub_19E46CD94(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10A1C40E79ACBF4);
  _Unwind_Resume(a1);
}

void sub_19E46CDCC(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0BC758;
  a1[1] = 16 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E46CE5C(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    unint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E46CEA8(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0BC780;
  a1[1] = 24 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E46CF3C(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    unint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E46CF88(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0BC7D0;
  a1[1] = 40 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E46D01C(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    unint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E46D068(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0BC820;
  a1[1] = 72 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E46D0FC(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    unint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E46D148(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0BC730;
  a1[1] = 136 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E46D1DC(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    unint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E46D228(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0BC7A8;
  a1[1] = 264 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E46D2BC(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    unint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E46D308(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  unint64_t v2 = (uint64_t *)(a1 + 16);
  unint64_t v3 = *(void *)(a1 + 24) - v1;
  if (v3 >> 3 <= 0x200)
  {
    uint64_t v5 = 0;
    sub_19E46BA20((unint64_t *)(a1 + 16), 513 - (v3 >> 3), (const double *)&v5);
    uint64_t v1 = *v2;
  }
  if (!*(void *)(v1 + 4096)) {
    operator new();
  }
  return *(void *)(v1 + 4096);
}

void sub_19E46D42C(_Unwind_Exception *a1)
{
  if (v1[6])
  {
    uint64_t v5 = v1[4];
    unint64_t v4 = (uint64_t *)v1[5];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[6] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  MEMORY[0x19F3BDCF0](v1, 0x10A1C40E79ACBF4);
  _Unwind_Resume(a1);
}

uint64_t sub_19E46D490()
{
  return 520;
}

void sub_19E46D498(void *a1)
{
  *a1 = &unk_1EF0BC7F8;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46D578(void *a1)
{
  *a1 = &unk_1EF0BC7F8;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46D638()
{
  return 512;
}

void sub_19E46D640(void *a1)
{
  *a1 = &unk_1EF0BC500;
  a1[1] = &unk_1EF0BC7F8;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46D740(void *a1)
{
  *a1 = &unk_1EF0BC500;
  a1[1] = &unk_1EF0BC7F8;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46D820()
{
  return 264;
}

void sub_19E46D828(void *a1)
{
  *a1 = &unk_1EF0BC7A8;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46D908(void *a1)
{
  *a1 = &unk_1EF0BC7A8;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46D9C8()
{
  return 256;
}

void sub_19E46D9D0(void *a1)
{
  *a1 = &unk_1EF0BC4B0;
  a1[1] = &unk_1EF0BC7A8;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46DAD0(void *a1)
{
  *a1 = &unk_1EF0BC4B0;
  a1[1] = &unk_1EF0BC7A8;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46DBB0()
{
  return 136;
}

void sub_19E46DBB8(void *a1)
{
  *a1 = &unk_1EF0BC730;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46DC98(void *a1)
{
  *a1 = &unk_1EF0BC730;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46DD58()
{
  return 128;
}

void sub_19E46DD60(void *a1)
{
  *a1 = &unk_1EF0BC438;
  a1[1] = &unk_1EF0BC730;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46DE60(void *a1)
{
  *a1 = &unk_1EF0BC438;
  a1[1] = &unk_1EF0BC730;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46DF40()
{
  return 72;
}

void sub_19E46DF48(void *a1)
{
  *a1 = &unk_1EF0BC820;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46E028(void *a1)
{
  *a1 = &unk_1EF0BC820;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46E0E8()
{
  return 64;
}

void sub_19E46E0F0(void *a1)
{
  *a1 = &unk_1EF0BC528;
  a1[1] = &unk_1EF0BC820;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46E1F0(void *a1)
{
  *a1 = &unk_1EF0BC528;
  a1[1] = &unk_1EF0BC820;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46E2D0()
{
  return 40;
}

void sub_19E46E2D8(void *a1)
{
  *a1 = &unk_1EF0BC7D0;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46E3B8(void *a1)
{
  *a1 = &unk_1EF0BC7D0;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46E478()
{
  return 32;
}

void sub_19E46E480(void *a1)
{
  *a1 = &unk_1EF0BC4D8;
  a1[1] = &unk_1EF0BC7D0;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46E580(void *a1)
{
  *a1 = &unk_1EF0BC4D8;
  a1[1] = &unk_1EF0BC7D0;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46E660()
{
  return 24;
}

void sub_19E46E668(void *a1)
{
  *a1 = &unk_1EF0BC780;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46E748(void *a1)
{
  *a1 = &unk_1EF0BC780;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46E808()
{
  return 16;
}

void sub_19E46E810(void *a1)
{
  *a1 = &unk_1EF0BC488;
  a1[1] = &unk_1EF0BC780;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46E910(void *a1)
{
  *a1 = &unk_1EF0BC488;
  a1[1] = &unk_1EF0BC780;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46E9F0()
{
  return 16;
}

void sub_19E46E9F8(void *a1)
{
  *a1 = &unk_1EF0BC758;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46EAD8(void *a1)
{
  *a1 = &unk_1EF0BC758;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46EB98()
{
  return 8;
}

void sub_19E46EBA0(void *a1)
{
  *a1 = &unk_1EF0BC460;
  a1[1] = &unk_1EF0BC758;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46ECA0(void *a1)
{
  *a1 = &unk_1EF0BC460;
  a1[1] = &unk_1EF0BC758;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46ED80(void *a1)
{
  unint64_t v2 = a1[1];
  if (v2 <= 0x21F) {
    operator new[]();
  }
  uint64_t v3 = a1[2];
  if (v3 + 136 > v2) {
    operator new[]();
  }
  uint64_t v4 = *(void *)(a1[4] + 16) + v3;
  a1[2] = v3 + 136;
  return v4;
}

uint64_t sub_19E46EE68(void *a1)
{
  unint64_t v2 = a1[1];
  if (v2 <= 0x41F) {
    operator new[]();
  }
  uint64_t v3 = a1[2];
  if (v3 + 264 > v2) {
    operator new[]();
  }
  uint64_t v4 = *(void *)(a1[4] + 16) + v3;
  a1[2] = v3 + 264;
  return v4;
}

uint64_t sub_19E46EF50(void *a1)
{
  unint64_t v2 = a1[1];
  if (v2 <= 0x81F) {
    operator new[]();
  }
  uint64_t v3 = a1[2];
  if (v3 + 520 > v2) {
    operator new[]();
  }
  uint64_t v4 = *(void *)(a1[4] + 16) + v3;
  a1[2] = v3 + 520;
  return v4;
}

void sub_19E46F038(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)a1 = &unk_1EF0BC968;
  *(void *)(a1 + 8) = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 72))(a2, 0);
  *(_DWORD *)(a1 + 16) = -1;
  *(void *)(a1 + ++*(void *)(result + 24) = 0;
  *(_DWORD *)(a1 + 32) = a3;
  *(void *)(a1 + 36) = 0xFFFFFFFF00000001;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0xFFFFFFFFLL;
  *(void *)(a1 + 64) = 0xFFFFFFFF00000000;
  *(unsigned char *)(a1 + 74) = 0;
  *(void *)(a1 + 80) = &unk_1EF0BC280;
  *(void *)(a1 + 88) = &unk_1EF0BC578;
  *(_OWORD *)(a1 + 96) = xmmword_19E5730B0;
  *(void *)(a1 + 112) = a1 + 112;
  *(void *)(a1 + 120) = a1 + 112;
  *(void *)(a1 + 128) = 0;
  operator new[]();
}

void sub_19E46F230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_19E43C8CC();
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_19E46F2AC(v15);
  _Unwind_Resume(a1);
}

void sub_19E46F260(_Unwind_Exception *exception_object)
{
  if (v1[16])
  {
    uint64_t v5 = v1[14];
    uint64_t v4 = (uint64_t *)v1[15];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[16] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        uint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E46F2AC(void *a1)
{
  *a1 = &unk_1EF0BC280;
  a1[1] = &unk_1EF0BC578;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46F38C()
{
  return 48;
}

void sub_19E46F394(void *a1)
{
  *a1 = &unk_1EF0BC578;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E46F474(void *a1)
{
  *a1 = &unk_1EF0BC578;
  unint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E46F534()
{
  return 40;
}

void sub_19E46F53C(void *a1)
{
  *a1 = &unk_1EF0BC280;
  a1[1] = &unk_1EF0BC578;
  unint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E46F63C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))();
}

uint64_t sub_19E46F664(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

uint64_t sub_19E46F68C(uint64_t result)
{
  if (*(unsigned char *)(result + 72))
  {
    *(unsigned char *)(result + 72) = 0;
  }
  else
  {
    uint64_t v1 = *(uint64_t **)(result + 24);
    uint64_t result = *v1;
    if (*v1) {
      return (*(uint64_t (**)(void))(*(void *)result + 32))();
    }
    else {
      ++v1[4];
    }
  }
  return result;
}

uint64_t sub_19E46F6DC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72)) {
    return a1 + 56;
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (!*v3) {
    return v3[1] + 16 * v3[4];
  }
  (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v3 + 72))(*v3, 15, 15);
  uint64_t v3 = *(void **)(a1 + 24);
  if (!*v3) {
    return v3[1] + 16 * v3[4];
  }
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)*v3 + 24);
  return v4();
}

BOOL sub_19E46F798(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72)) {
    return 0;
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (*v3)
  {
    if ((*(uint64_t (**)(void))(*(void *)*v3 + 16))(*v3)) {
      return 1;
    }
  }
  else if (v3[4] >= v3[2])
  {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 73)) {
    return 0;
  }
  uint64_t v4 = *(uint64_t **)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 32);
  uint64_t v6 = *v4;
  if (*v4)
  {
    if (v5) {
      uint64_t v7 = 2;
    }
    else {
      uint64_t v7 = 1;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 72))(v6, v7, 15);
    int v5 = *(_DWORD *)(a1 + 32);
    uint64_t v4 = *(uint64_t **)(a1 + 24);
    uint64_t v6 = *v4;
  }
  if (v5)
  {
    if (v6) {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
    }
    else {
      uint64_t v8 = v4[1] + 16 * v4[4];
    }
    unint64_t v9 = (_DWORD *)(v8 + 4);
  }
  else if (v6)
  {
    unint64_t v9 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  else
  {
    unint64_t v9 = (_DWORD *)(v4[1] + 16 * v4[4]);
  }
  return *v9 != *(_DWORD *)(a1 + 40);
}

uint64_t sub_19E46F8F8(uint64_t a1, unsigned int a2)
{
  *(unsigned char *)(a1 + 73) = 1;
  if (*(unsigned char *)(a1 + 74))
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 40) = -1;
    return result;
  }
  *(unsigned char *)(a1 + 72) = a2 == 0;
  if (a2 == -1) {
    unsigned int v4 = 0;
  }
  else {
    unsigned int v4 = a2;
  }
  *(_DWORD *)(a1 + 40) = v4;
  uint64_t v5 = **(void **)(a1 + 24);
  if (v5)
  {
    if (*(_DWORD *)(a1 + 32)) {
      uint64_t v6 = 2;
    }
    else {
      uint64_t v6 = 1;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 72))(v5, v6, 15);
    unsigned int v4 = *(_DWORD *)(a1 + 40);
  }
  if (v4 >= *(_DWORD *)(a1 + 36))
  {
    unint64_t v8 = *(void *)(a1 + 48);
    if (!v8)
    {
      unint64_t v9 = 0;
      goto LABEL_68;
    }
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v10 = (v8 + v9) >> 1;
      uint64_t v11 = *(uint64_t **)(a1 + 24);
      uint64_t v12 = *v11;
      if (*v11)
      {
        (*(void (**)(uint64_t, unint64_t))(*(void *)v12 + 56))(v12, (v8 + v9) >> 1);
        uint64_t v11 = *(uint64_t **)(a1 + 24);
        uint64_t v12 = *v11;
        if (*(_DWORD *)(a1 + 32)) {
          goto LABEL_19;
        }
      }
      else
      {
        v11[4] = v10;
        if (*(_DWORD *)(a1 + 32))
        {
LABEL_19:
          if (v12) {
            uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 24))(v12);
          }
          else {
            uint64_t v13 = v11[1] + 16 * v11[4];
          }
          unint64_t v14 = (unsigned int *)(v13 + 4);
          goto LABEL_26;
        }
      }
      if (v12) {
        unint64_t v14 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 24))(v12);
      }
      else {
        unint64_t v14 = (unsigned int *)(v11[1] + 16 * v11[4]);
      }
LABEL_26:
      unsigned int v15 = *(_DWORD *)(a1 + 40);
      if (*v14 > v15)
      {
        unint64_t v8 = (v8 + v9) >> 1;
        if (v9 >= v10) {
          goto LABEL_68;
        }
      }
      else
      {
        if (*v14 >= v15)
        {
          while (1)
          {
            if (v10 <= v9) {
              return 1;
            }
            unint64_t v18 = *(uint64_t **)(a1 + 24);
            --v10;
            uint64_t v19 = *v18;
            if (*v18)
            {
              (*(void (**)(uint64_t, unint64_t))(*(void *)v19 + 56))(v19, v10);
              unint64_t v18 = *(uint64_t **)(a1 + 24);
              uint64_t v19 = *v18;
              if (*(_DWORD *)(a1 + 32)) {
                goto LABEL_37;
              }
            }
            else
            {
              v18[4] = v10;
              if (*(_DWORD *)(a1 + 32))
              {
LABEL_37:
                if (v19) {
                  uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 24))(v19);
                }
                else {
                  uint64_t v16 = v18[1] + 16 * v18[4];
                }
                unint64_t v17 = (_DWORD *)(v16 + 4);
                goto LABEL_33;
              }
            }
            if (v19) {
              unint64_t v17 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v19 + 24))(v19);
            }
            else {
              unint64_t v17 = (_DWORD *)(v18[1] + 16 * v18[4]);
            }
LABEL_33:
            if (*v17 != *(_DWORD *)(a1 + 40))
            {
              unint64_t v28 = v10 + 1;
              uint64_t v29 = *(void **)(a1 + 24);
              if (*v29) {
                (*(void (**)(void, unint64_t))(*(void *)*v29 + 56))(*v29, v28);
              }
              else {
                v29[4] = v28;
              }
              return 1;
            }
          }
        }
        unint64_t v9 = v10 + 1;
        if (v10 + 1 >= v8)
        {
LABEL_68:
          uint64_t v27 = *(void **)(a1 + 24);
          if (*v27) {
            (*(void (**)(void, unint64_t))(*(void *)*v27 + 56))(*v27, v9);
          }
          else {
            v27[4] = v9;
          }
          return *(unsigned char *)(a1 + 72) != 0;
        }
      }
    }
  }
  uint64_t v7 = *(void **)(a1 + 24);
  if (*v7) {
    (*(void (**)(void))(*(void *)*v7 + 48))(*v7);
  }
  else {
    v7[4] = 0;
  }
  while (1)
  {
    unint64_t v20 = *(void **)(a1 + 24);
    if (*v20)
    {
      if ((*(uint64_t (**)(void))(*(void *)*v20 + 16))(*v20)) {
        return *(unsigned char *)(a1 + 72) != 0;
      }
      unint64_t v20 = *(void **)(a1 + 24);
      uint64_t v21 = *v20;
      if (!*(_DWORD *)(a1 + 32)) {
        goto LABEL_52;
      }
    }
    else
    {
      if (v20[4] >= v20[2]) {
        return *(unsigned char *)(a1 + 72) != 0;
      }
      uint64_t v21 = 0;
      if (!*(_DWORD *)(a1 + 32))
      {
LABEL_52:
        if (v21) {
          uint64_t v23 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v21 + 24))(v21);
        }
        else {
          uint64_t v23 = (unsigned int *)(v20[1] + 16 * v20[4]);
        }
        goto LABEL_56;
      }
    }
    uint64_t v22 = v21 ? (*(uint64_t (**)(uint64_t))(*(void *)v21 + 24))(v21) : v20[1] + 16 * v20[4];
    uint64_t v23 = (unsigned int *)(v22 + 4);
LABEL_56:
    unsigned int v24 = *(_DWORD *)(a1 + 40);
    int v25 = *v23 <= v24 ? 0 : 7;
    if (*v23 == v24) {
      int v25 = 1;
    }
    if (v25) {
      break;
    }
    unint64_t v26 = *(void **)(a1 + 24);
    if (*v26) {
      (*(void (**)(void))(*(void *)*v26 + 32))(*v26);
    }
    else {
      ++v26[4];
    }
  }
  if (v25 == 1) {
    return 1;
  }
  return *(unsigned char *)(a1 + 72) != 0;
}

uint64_t sub_19E46FDB0(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 16) == a2) {
    return result;
  }
  uint64_t v3 = result;
  *(_DWORD *)(result + 16) = a2;
  if (*(_DWORD *)(result + 32) == 3)
  {
    char v12 = 5;
    strcpy((char *)__p, "FATAL");
    unsigned int v4 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
    sub_19E37CA70(v4, (uint64_t)": ", 2);
    sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"SortedMatcher: bad match type", 29);
    sub_19E43C8CC();
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    *(unsigned char *)(v3 + 74) = 1;
  }
  uint64_t v5 = *(void **)(v3 + 24);
  if (v5)
  {
    if (*v5)
    {
      (*(void (**)(void))(*(void *)*v5 + 8))(*v5);
    }
    else
    {
      uint64_t v7 = (_DWORD *)v5[3];
      if (v7) {
        --*v7;
      }
    }
    uint64_t v6 = *(void *)(v3 + 136);
    void v5[5] = v6;
    *(void *)(v3 + 136) = v5;
  }
  else
  {
    uint64_t v5 = *(void **)(v3 + 136);
    if (!v5)
    {
      unint64_t v9 = *(void *)(v3 + 96);
      if (v9 <= 0xBF) {
        operator new[]();
      }
      uint64_t v10 = *(void *)(v3 + 104);
      if (v10 + 48 > v9) {
        operator new[]();
      }
      uint64_t v5 = (void *)(*(void *)(*(void *)(v3 + 120) + 16) + v10);
      *(void *)(v3 + 104) = v10 + 48;
      void v5[5] = 0;
      goto LABEL_15;
    }
    uint64_t v6 = v5[5];
  }
  *(void *)(v3 + 136) = v6;
LABEL_15:
  uint64_t v8 = *(void *)(v3 + 8);
  v5[4] = 0;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v8 + 120))(v8, a2, v5);
  *(void *)(v3 + ++*(void *)(result + 24) = v5;
  if (*v5) {
    (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v5 + 72))(*v5, 16, 16);
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 8) + 32))(*(void *)(v3 + 8), a2);
  *(void *)(v3 + 48) = result;
  *(_DWORD *)(v3 + 68) = a2;
  return result;
}

void sub_19E470050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E470078()
{
  return 0;
}

uint64_t sub_19E470080(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 74)) {
    return a2 | 4;
  }
  else {
    return a2;
  }
}

uint64_t sub_19E470094(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_19E47009C(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 32);
  if (v2 == 3) {
    return 3;
  }
  if (v2) {
    uint64_t v6 = 0x40000000;
  }
  else {
    uint64_t v6 = 0x10000000;
  }
  uint64_t v7 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v8 = 3221225472;
  }
  else {
    uint64_t v8 = 805306368;
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 56))(v7, v8, a2);
  if ((v9 & v6) != 0) {
    return *(unsigned int *)(a1 + 32);
  }
  uint64_t v10 = 0x80000000;
  if (!v2) {
    uint64_t v10 = 0x20000000;
  }
  if ((v9 & v10) != 0) {
    return 3;
  }
  else {
    return 4;
  }
}

void sub_19E47014C()
{
}

void sub_19E4702B4(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10E1C4003B7394BLL);
  _Unwind_Resume(a1);
}

void sub_19E470320(void *a1)
{
  sub_19E470358(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E470358(void *a1)
{
  *a1 = &unk_1EF0BC968;
  int v2 = (void *)a1[3];
  if (v2)
  {
    if (*v2)
    {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    else
    {
      uint64_t v3 = (_DWORD *)v2[3];
      if (v3) {
        --*v3;
      }
    }
    v2[5] = a1[17];
    a1[17] = v2;
  }
  uint64_t v4 = a1[1];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  a1[10] = &unk_1EF0BC280;
  a1[11] = &unk_1EF0BC578;
  uint64_t v5 = a1 + 14;
  for (uint64_t i = (uint64_t *)a1[15]; i != v5; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v7 = i[2];
    if (v7) {
      MEMORY[0x19F3BDCC0](v7, 0x1000C8077774924);
    }
  }
  if (a1[16])
  {
    uint64_t v9 = a1[14];
    uint64_t v8 = (uint64_t *)a1[15];
    uint64_t v10 = *v8;
    *(void *)(v10 + 8) = *(void *)(v9 + 8);
    **(void **)(v9 + 8) = v10;
    a1[16] = 0;
    if (v8 != v5)
    {
      do
      {
        uint64_t v11 = (uint64_t *)v8[1];
        operator delete(v8);
        uint64_t v8 = v11;
      }
      while (v11 != v5);
    }
  }
  return a1;
}

void sub_19E4704E0(uint64_t a1@<X0>, int a2@<W1>, float *a3@<X8>)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 176) + 104);
  uint64_t v7 = (unsigned int *)(v6 + 12 * a2);
  uint64_t v8 = *v7;
  (*(void (**)(char *__return_ptr))(***(void ***)(a1 + 144) + 96))((char *)&v19 + 4);
  float v9 = *((float *)&v19 + 1);
  int v21 = HIDWORD(v19);
  int v20 = 2139095039;
  if (*((float *)&v19 + 1) != 3.4028e38)
  {
    uint64_t v10 = v7[1];
    (*(void (**)(uint64_t *__return_ptr))(***(void ***)(a1 + 152) + 96))(&v19);
    float v9 = *(float *)&v19;
    int v21 = v19;
    int v20 = 2139095039;
    if (*(float *)&v19 != 3.4028e38)
    {
      uint64_t v11 = *(void **)(a1 + 136);
      LOBYTE(v21) = *(unsigned char *)(v6 + 12 * a2 + 8);
      sub_19E4706EC(v11, v8, v10, &v21);
      float v12 = *((float *)&v19 + 1);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009378, memory_order_acquire) & 1) == 0)
      {
        float v17 = v12;
        int v15 = __cxa_guard_acquire(&qword_1EC009378);
        float v12 = v17;
        if (v15)
        {
          dword_1EC009380 = -8388609;
          __cxa_guard_release(&qword_1EC009378);
          float v12 = v17;
        }
      }
      if (v12 == *(float *)&dword_1EC009380) {
        goto LABEL_13;
      }
      float v13 = *(float *)&v19;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EC009378, memory_order_acquire) & 1) == 0)
      {
        float v18 = v13;
        int v16 = __cxa_guard_acquire(&qword_1EC009378);
        float v13 = v18;
        if (v16)
        {
          dword_1EC009380 = -8388609;
          __cxa_guard_release(&qword_1EC009378);
          float v13 = v18;
        }
      }
      if (v13 == *(float *)&dword_1EC009380)
      {
LABEL_13:
        float v9 = NAN;
      }
      else
      {
        BOOL v14 = *(float *)&v19 == 3.4028e38 || *((float *)&v19 + 1) == 3.4028e38;
        float v9 = *(float *)&v19 + *((float *)&v19 + 1);
        if (v14) {
          float v9 = 3.4028e38;
        }
      }
    }
  }
  *a3 = v9;
}

void *sub_19E4706EC(void *result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v6 = result;
  if (*((_DWORD *)result + 8) != a2 || *((_DWORD *)result + 9) != a3 || *a4 != *((unsigned char *)result + 40))
  {
    *((_DWORD *)result + 8) = a2;
    *((_DWORD *)result + 9) = a3;
    *((unsigned char *)result + 40) = *a4;
    uint64_t v7 = (*(uint64_t (**)(void, uint64_t))(*(void *)result[2] + 32))(result[2], a2);
    uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(*(void *)v6[2] + 48))(v6[2], a2);
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v6[2] + 24))(&v16);
    int v17 = v16;
    HIDWORD(v16) = 2139095039;
    v9.n128_u32[0] = v16;
    BOOL v11 = *(float *)&v16 == 3.4028e38 && v7 == v8;
    *((unsigned char *)v6 + 41) = v11;
    *((unsigned char *)v6 + 43) = v8 == 0;
    uint64_t v12 = (*(uint64_t (**)(void, uint64_t, __n128))(*(void *)v6[3] + 32))(v6[3], a3, v9);
    uint64_t v13 = (*(uint64_t (**)(void, uint64_t))(*(void *)v6[3] + 40))(v6[3], a3);
    uint64_t result = (*(void *(**)(uint64_t *__return_ptr))(*(void *)v6[3] + 24))(&v16);
    int v17 = v16;
    HIDWORD(v16) = 2139095039;
    BOOL v15 = *(float *)&v16 == 3.4028e38 && v12 == v13;
    *((unsigned char *)v6 + 42) = v15;
    *((unsigned char *)v6 + 44) = v13 == 0;
  }
  return result;
}

uint64_t sub_19E4708F4(void **a1)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1[20] + 16))(a1[20]);
  if (result != -1)
  {
    unsigned int v3 = result;
    uint64_t result = (*(uint64_t (**)(void *))(*a1[21] + 16))(a1[21]);
    if (result != -1)
    {
      unint64_t v4 = __PAIR64__(result, v3);
      char v5 = 0;
      return sub_19E470994(a1[22], (uint64_t *)&v4);
    }
  }
  return result;
}

uint64_t sub_19E470994(void *a1, uint64_t *a2)
{
  a1[16] = a2;
  unint64_t v4 = a1 + 4;
  int8x8_t v5 = (int8x8_t)a1[5];
  if (v5)
  {
    unint64_t v6 = **(int **)(a1[10] + 128)
       + 7853 * *(int *)(*(void *)(a1[10] + 128) + 4)
       + 7867 * *(char *)(*(void *)(a1[10] + 128) + 8);
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      uint64_t v8 = **(int **)(a1[10] + 128)
         + 7853 * *(int *)(*(void *)(a1[10] + 128) + 4)
         + 7867 * *(char *)(*(void *)(a1[10] + 128) + 8);
      if (v6 >= *(void *)&v5) {
        uint64_t v8 = v6 % *(void *)&v5;
      }
    }
    else
    {
      uint64_t v8 = (*(void *)&v5 - 1) & v6;
    }
    __n128 v9 = *(uint64_t ****)(*v4 + 8 * v8);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v11 = (unint64_t)i[1];
        if (v11 == v6)
        {
          uint64_t result = *((unsigned int *)i + 4);
          if ((int)result >= -1)
          {
            uint64_t v13 = a1[12];
            if (result == -1)
            {
              uint64_t v15 = *(void *)(v13 + 128);
              uint64_t v14 = v15;
            }
            else
            {
              uint64_t v14 = *(void *)(v13 + 104) + 12 * result;
              uint64_t v15 = *(void *)(v13 + 128);
            }
            if (v14 == v15) {
              return result;
            }
            BOOL v16 = *(_DWORD *)v14 == *(_DWORD *)v15 && *(_DWORD *)(v14 + 4) == *(_DWORD *)(v15 + 4);
            if (v16 && *(unsigned __int8 *)(v14 + 8) == *(unsigned __int8 *)(v15 + 8)) {
              return result;
            }
          }
        }
        else
        {
          if (v7.u32[0] <= 1uLL)
          {
            v11 &= *(void *)&v5 - 1;
          }
          else if (v11 >= *(void *)&v5)
          {
            v11 %= *(void *)&v5;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  float v18 = (char *)a1[13];
  int v17 = (char *)a1[14];
  uint64_t v19 = (v17 - v18) / 12;
  int v30 = v19;
  unint64_t v20 = a1[15];
  if ((unint64_t)v17 >= v20)
  {
    unint64_t v23 = v19 + 1;
    if ((unint64_t)(v19 + 1) > 0x1555555555555555) {
      sub_19E37C7C4();
    }
    unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - (void)v18) >> 2);
    if (2 * v24 > v23) {
      unint64_t v23 = 2 * v24;
    }
    if (v24 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v25 = 0x1555555555555555;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      if (v25 > 0x1555555555555555) {
        sub_19E37C2B8();
      }
      unint64_t v26 = (char *)operator new(12 * v25);
    }
    else
    {
      unint64_t v26 = 0;
    }
    uint64_t v27 = &v26[12 * v19];
    *(void *)uint64_t v27 = *a2;
    *((_DWORD *)v27 + 2) = *((_DWORD *)a2 + 2);
    uint64_t v22 = v27 + 12;
    if (v17 != v18)
    {
      do
      {
        uint64_t v28 = *(void *)(v17 - 12);
        v17 -= 12;
        int v29 = *((_DWORD *)v17 + 2);
        *(void *)(v27 - 12) = v28;
        v27 -= 12;
        *((_DWORD *)v27 + 2) = v29;
      }
      while (v17 != v18);
      int v17 = (char *)a1[13];
    }
    a1[13] = v27;
    a1[14] = v22;
    a1[15] = &v26[12 * v25];
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    uint64_t v21 = *a2;
    *((_DWORD *)v17 + 2) = *((_DWORD *)a2 + 2);
    *(void *)int v17 = v21;
    uint64_t v22 = v17 + 12;
  }
  a1[14] = v22;
  sub_19E470C24((uint64_t)v4, v19, &v30);
  return v19;
}

void sub_19E470C24(uint64_t a1, int a2, _DWORD *a3)
{
  if (a2 < -1)
  {
    unint64_t v8 = 0;
    unint64_t v9 = *(void *)(a1 + 8);
    if (!v9) {
      goto LABEL_38;
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 48);
    if (a2 == -1) {
      uint8x8_t v7 = *(int **)(v6 + 128);
    }
    else {
      uint8x8_t v7 = (int *)(*(void *)(v6 + 104) + 12 * a2);
    }
    unint64_t v8 = *v7 + 7853 * v7[1] + 7867 * *((char *)v7 + 8);
    unint64_t v9 = *(void *)(a1 + 8);
    if (!v9) {
      goto LABEL_38;
    }
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v3 = v8;
    if (v8 >= v9) {
      unint64_t v3 = v8 % v9;
    }
  }
  else
  {
    unint64_t v3 = (v9 - 1) & v8;
  }
  unint64_t v11 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
  if (v11)
  {
    uint64_t v12 = *v11;
    if (v12)
    {
      unint64_t v13 = v9 - 1;
      if (a2 < -1)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v31 = v12[1];
            if (v31 == v8)
            {
              if (*((_DWORD *)v12 + 4) == a2) {
                return;
              }
            }
            else if ((v31 & v13) != v3)
            {
              goto LABEL_38;
            }
            uint64_t v12 = (uint64_t *)*v12;
            if (!v12) {
              goto LABEL_38;
            }
          }
        }
        while (1)
        {
          unint64_t v32 = v12[1];
          if (v32 == v8)
          {
            if (*((_DWORD *)v12 + 4) == a2) {
              return;
            }
          }
          else
          {
            if (v32 >= v9) {
              v32 %= v9;
            }
            if (v32 != v3) {
              goto LABEL_38;
            }
          }
          uint64_t v12 = (uint64_t *)*v12;
          if (!v12) {
            goto LABEL_38;
          }
        }
      }
      while (1)
      {
        unint64_t v14 = v12[1];
        if (v14 == v8) {
          break;
        }
        if (v10.u32[0] > 1uLL)
        {
          if (v14 >= v9) {
            v14 %= v9;
          }
        }
        else
        {
          v14 &= v13;
        }
        if (v14 != v3) {
          goto LABEL_38;
        }
LABEL_14:
        uint64_t v12 = (uint64_t *)*v12;
        if (!v12) {
          goto LABEL_38;
        }
      }
      int v15 = *((_DWORD *)v12 + 4);
      if (v15 < -1)
      {
        if (v15 == a2) {
          return;
        }
        goto LABEL_14;
      }
      uint64_t v16 = *(void *)(a1 + 64);
      if (v15 == -1)
      {
        uint64_t v17 = *(void *)(v16 + 128);
        if (a2 != -1) {
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v17 = *(void *)(v16 + 104) + 12 * v15;
        if (a2 != -1)
        {
LABEL_19:
          uint64_t v18 = *(void *)(v16 + 104) + 12 * a2;
LABEL_28:
          if (v17 == v18) {
            return;
          }
          BOOL v19 = *(_DWORD *)v17 == *(_DWORD *)v18 && *(_DWORD *)(v17 + 4) == *(_DWORD *)(v18 + 4);
          if (v19 && *(unsigned __int8 *)(v17 + 8) == *(unsigned __int8 *)(v18 + 8)) {
            return;
          }
          goto LABEL_14;
        }
      }
      uint64_t v18 = *(void *)(v16 + 128);
      goto LABEL_28;
    }
  }
LABEL_38:
  uint64_t v20 = sub_19E471038(a1 + 32);
  *(void *)uint64_t v20 = 0;
  *(void *)(v20 + 8) = v8;
  *(_DWORD *)(v20 + 16) = *a3;
  float v21 = (float)(unint64_t)(*(void *)(a1 + 40) + 1);
  float v22 = *(float *)(a1 + 56);
  if (!v9 || (float)(v22 * (float)v9) < v21)
  {
    BOOL v23 = 1;
    if (v9 >= 3) {
      BOOL v23 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v9);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v27 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v27) {
      goto LABEL_50;
    }
    if (prime < *(void *)&v27)
    {
      unint64_t v28 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 40) / *(float *)(a1 + 56));
      if (*(void *)&v27 < 3uLL || (uint8x8_t v29 = (uint8x8_t)vcnt_s8(v27), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (prime <= v28) {
        size_t prime = v28;
      }
      if (prime < *(void *)&v27) {
LABEL_50:
      }
        sub_19E46B684(a1, prime);
    }
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v33 = *(uint64_t **)(*(void *)a1 + 8 * v3);
  if (v33)
  {
    *(void *)uint64_t v20 = *v33;
LABEL_88:
    *uint64_t v33 = v20;
    goto LABEL_89;
  }
  *(void *)uint64_t v20 = *(void *)(a1 + 24);
  *(void *)(a1 + ++*(void *)(result + 24) = v20;
  *(void *)(*(void *)a1 + 8 * v3) = a1 + 24;
  if (*(void *)v20)
  {
    unint64_t v34 = *(void *)(*(void *)v20 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v34 >= v9) {
        v34 %= v9;
      }
    }
    else
    {
      v34 &= v9 - 1;
    }
    uint64_t v33 = (uint64_t *)(*(void *)a1 + 8 * v34);
    goto LABEL_88;
  }
LABEL_89:
  ++*(void *)(a1 + 40);
}

void sub_19E471024(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E4711F8((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E471038(uint64_t a1)
{
  int v2 = (unint64_t *)(*(void *)a1 + 16);
  unint64_t v1 = *v2;
  unint64_t v3 = *(void *)(*(void *)a1 + 24) - *v2;
  if (v3 <= 0xC7)
  {
    uint64_t v9 = 0;
    sub_19E46BA20(v2, 25 - (v3 >> 3), (const double *)&v9);
    unint64_t v1 = *v2;
  }
  unint64_t v4 = *(void **)(v1 + 192);
  if (!v4) {
    operator new();
  }
  uint64_t v5 = v4[7];
  if (v5)
  {
    v4[7] = *(void *)(v5 + 24);
  }
  else
  {
    unint64_t v6 = v4[2];
    if (v6 <= 0x7F) {
      operator new[]();
    }
    uint64_t v7 = v4[3];
    if (v7 + 32 > v6) {
      operator new[]();
    }
    uint64_t v5 = *(void *)(v4[5] + 16) + v7;
    void v4[3] = v7 + 32;
    *(void *)(v5 + ++*(void *)(result + 24) = 0;
  }
  return v5;
}

void sub_19E4711D4(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10A1C40E79ACBF4);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E4711F8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    sub_19E46B934(a1[1], v2);
  }
  return a1;
}

uint64_t sub_19E471234(uint64_t a1, uint64_t a2, int a3)
{
  if ((*(unsigned int (**)(void, void))(***(void ***)(a1 + 144) + 24))(**(void **)(a1 + 144), 0) == a3
    && (*(unsigned int (**)(void, void))(***(void ***)(a1 + 152) + 24))(**(void **)(a1 + 152), 0) == a3)
  {
    operator new();
  }
  return 0;
}

void sub_19E4713FC(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v2, 0x20C4093837F09);
  MEMORY[0x19F3BDCF0](v1, 0x10E1C40868C5753);
  _Unwind_Resume(a1);
}

uint64_t sub_19E471444(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))();
}

uint64_t sub_19E47146C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 24);
  return v1();
}

uint64_t sub_19E4714EC(uint64_t result)
{
  if (*(unsigned char *)(result + 48))
  {
    *(unsigned char *)(result + 48) = 0;
  }
  else
  {
    if (*(_DWORD *)(result + 28))
    {
      uint64_t v2 = *(void **)(result + 32);
      uint64_t v1 = *(void *)(result + 40);
    }
    else
    {
      uint64_t v1 = *(void *)(result + 32);
      uint64_t v2 = *(void **)(result + 40);
    }
    return sub_19E471514(result, v1, v2);
  }
  return result;
}

uint64_t sub_19E471514(uint64_t a1, uint64_t a2, void *a3)
{
uint64_t sub_19E47193C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48)) {
    return a1 + 52;
  }
  else {
    return a1 + 68;
  }
}

uint64_t sub_19E471954(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48)
    || !(*(unsigned int (**)(void))(***(void ***)(a1 + 32) + 72))(**(void **)(a1 + 32)))
  {
    return 0;
  }
  uint64_t v2 = *(uint64_t (**)(void))(***(void ***)(a1 + 40) + 72);
  return v2();
}

uint64_t sub_19E4719F4(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 48) = a2 == 0;
  if (*(_DWORD *)(a1 + 28))
  {
    if (a2)
    {
      unint64_t v4 = *(void **)(a1 + 32);
      uint64_t v3 = *(void *)(a1 + 40);
      goto LABEL_6;
    }
    return 1;
  }
  if (!a2) {
    return 1;
  }
  uint64_t v3 = *(void *)(a1 + 32);
  unint64_t v4 = *(void **)(a1 + 40);
LABEL_6:
  uint64_t result = (*(uint64_t (**)(void))(**(void **)v3 + 64))();
  if (result)
  {
    int v6 = *(_DWORD *)(a1 + 28);
    uint64_t v7 = (*(uint64_t (**)(void))(**(void **)v3 + 80))();
    unint64_t v8 = (unsigned int *)(v7 + 4);
    if (v6) {
      unint64_t v8 = (unsigned int *)v7;
    }
    (*(void (**)(void, void))(*(void *)*v4 + 64))(*v4, *v8);
    return sub_19E471514(a1, v3, v4);
  }
  return result;
}

uint64_t sub_19E471B04(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 24) != a2)
  {
    uint64_t v2 = result;
    *(_DWORD *)(result + ++*(void *)(result + 24) = a2;
    uint64_t v3 = (unsigned int *)(*(void *)(*(void *)(*(void *)(result + 16) + 176) + 104) + 12 * a2);
    uint64_t v4 = v3[1];
    (*(void (**)(void, void))(***(void ***)(result + 32) + 56))(**(void **)(result + 32), *v3);
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(***(void ***)(v2 + 40) + 56))(**(void **)(v2 + 40), v4);
    *(_DWORD *)(v2 + 64) = *(_DWORD *)(v2 + 24);
  }
  return result;
}

uint64_t sub_19E471BB0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 84)) {
    return a2 | 4;
  }
  else {
    return a2;
  }
}

uint64_t sub_19E471BC4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_19E471BCC(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void))(***(void ***)(a1 + 32) + 24))(**(void **)(a1 + 32));
  if (result != 3)
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 40) + 24))(**(void **)(a1 + 40), a2);
    if (result != 3)
    {
      if ((*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 32) + 24))(**(void **)(a1 + 32), a2) != 4|| (uint64_t result = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 40) + 24))(**(void **)(a1 + 40), a2), result != 4))
      {
        if ((*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 32) + 24))(**(void **)(a1 + 32), a2) == 4&& (*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 40) + 24))(**(void **)(a1 + 40), a2) == *(_DWORD *)(a1 + 28))
        {
          return 4;
        }
        else if ((*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 32) + 24))(**(void **)(a1 + 32), a2) != *(_DWORD *)(a1 + 28)|| (uint64_t result = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 40) + 24))(**(void **)(a1 + 40), a2), result != 4))
        {
          if ((*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 32) + 24))(**(void **)(a1 + 32), a2) != *(_DWORD *)(a1 + 28))return 3; {
          uint64_t result = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 40) + 24))(**(void **)(a1 + 40), a2);
          }
          if (result != *(_DWORD *)(a1 + 28)) {
            return 3;
          }
        }
      }
    }
  }
  return result;
}

void sub_19E471E38()
{
}

void sub_19E472018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_19E43C8CC();
  if (a15 < 0) {
    operator delete(__p);
  }
  MEMORY[0x19F3BDCF0](v15, 0x10E1C40868C5753);
  _Unwind_Resume(a1);
}

void sub_19E472084(void *a1)
{
  *a1 = &unk_1EF0BCCE8;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    MEMORY[0x19F3BDCF0](v2, 0x20C4093837F09);
  }
  uint64_t v3 = (void *)a1[5];
  if (v3)
  {
    if (*v3) {
      (*(void (**)(void))(*(void *)*v3 + 8))(*v3);
    }
    MEMORY[0x19F3BDCF0](v3, 0x20C4093837F09);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E47217C(void *a1)
{
  *a1 = &unk_1EF0BCCE8;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    MEMORY[0x19F3BDCF0](v2, 0x20C4093837F09);
  }
  uint64_t v3 = (void *)a1[5];
  if (v3)
  {
    if (*v3) {
      (*(void (**)(void))(*(void *)*v3 + 8))(*v3);
    }
    MEMORY[0x19F3BDCF0](v3, 0x20C4093837F09);
  }
  return a1;
}

void sub_19E472254(uint64_t a1, int a2)
{
  uint64_t v4 = (unsigned int *)(*(void *)(*(void *)(a1 + 176) + 104) + 12 * a2);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  uint64_t v7 = *(void **)(a1 + 136);
  LOBYTE(__p[0]) = *((unsigned char *)v4 + 8);
  sub_19E4706EC(v7, v5, v6, __p);
  int v8 = *(_DWORD *)(a1 + 184);
  if (!v8) {
    goto LABEL_24;
  }
  if (v8 != 1)
  {
    uint64_t v9 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 144) + 104))(**(void **)(a1 + 144), v5);
    uint64_t v10 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 152) + 104))(**(void **)(a1 + 152), v6);
    if (v9 == -1 && v10 == -1)
    {
      char v19 = 5;
      strcpy((char *)__p, "FATAL");
      unsigned int v17 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
      sub_19E37CA70(v17, (uint64_t)": ", 2);
      sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"ComposeFst: both sides can't require match", 42);
      sub_19E43C8CC();
      if (v19 < 0) {
        operator delete(__p[0]);
      }
      *(void *)(a1 + 8) |= 4uLL;
      goto LABEL_24;
    }
    BOOL v12 = v10 == -1 || v9 <= v10;
    BOOL v13 = v12;
    if (v9 != -1 && v13)
    {
LABEL_24:
      sub_19E472458(a1, a2, v6, *(void *)(a1 + 160), v5, *(void **)(a1 + 152), 1);
      return;
    }
  }
  uint64_t v15 = *(void *)(a1 + 168);
  float v16 = *(void **)(a1 + 144);
  sub_19E472458(a1, a2, v5, v15, v6, v16, 0);
}

void sub_19E472430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_19E472458(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, int a7)
{
  (*(void (**)(void, uint64_t))(*(void *)*a6 + 56))(*a6, a3);
  v18[0] = a7 - 1;
  v18[1] = a7 << 31 >> 31;
  v18[2] = 0;
  v18[3] = a5;
  sub_19E4726A8(a1, a2, a6, v18, a7);
  unint64_t v17 = 0;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)a4 + 120))(a4, a5, v15);
  while (1)
  {
    if (!v15[0])
    {
      unint64_t v14 = v17;
      if (v17 >= v15[2]) {
        goto LABEL_15;
      }
      goto LABEL_10;
    }
    if ((*(unsigned int (**)(void))(*(void *)v15[0] + 16))(v15[0])) {
      break;
    }
    if (!v15[0])
    {
      unint64_t v14 = v17;
LABEL_10:
      BOOL v13 = (unsigned int *)(v15[1] + 16 * v14);
      goto LABEL_11;
    }
    BOOL v13 = (unsigned int *)(*(uint64_t (**)(void))(*(void *)v15[0] + 24))();
LABEL_11:
    sub_19E4726A8(a1, a2, a6, v13, a7);
    if (v15[0]) {
      (*(void (**)(void))(*(void *)v15[0] + 32))(v15[0]);
    }
    else {
      ++v17;
    }
  }
  if (v15[0])
  {
    (*(void (**)(void))(*(void *)v15[0] + 8))();
    goto LABEL_17;
  }
LABEL_15:
  if (v16) {
    --*v16;
  }
LABEL_17:
  sub_19E472A04(a1, a2);
}

void sub_19E472654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _DWORD *a13)
{
  if (!a10)
  {
    if (a13) {
      --*a13;
    }
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E4726A8(uint64_t a1, int a2, void *a3, unsigned int *a4, int a5)
{
  char v5 = a5;
  uint64_t v10 = a4 + 1;
  if (!a5) {
    uint64_t v10 = a4;
  }
  uint64_t result = (*(uint64_t (**)(void, void))(*(void *)*a3 + 64))(*a3, *v10);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)*a3 + 72))();
    if ((result & 1) == 0)
    {
      if (v5)
      {
        while (1)
        {
          uint64_t v13 = (*(uint64_t (**)(void))(*(void *)*a3 + 80))();
          unint64_t v30 = *(void *)v13;
          int v31 = *(_DWORD *)(v13 + 8);
          int v32 = *(_DWORD *)(v13 + 12);
          unint64_t v14 = *(void *)a4;
          uint64_t v27 = *(void *)a4;
          unsigned int v28 = a4[2];
          unsigned int v29 = a4[3];
          uint64_t v15 = *(unsigned __int8 **)(a1 + 136);
          if (v30 == -1)
          {
            int v12 = v15[40];
            if (v12 == 1) {
              goto LABEL_9;
            }
            if (v15[40]) {
              goto LABEL_11;
            }
            if (!v15[44])
            {
              if (v15[42]) {
                goto LABEL_11;
              }
              LOBYTE(v12) = 1;
              goto LABEL_9;
            }
          }
          else
          {
            unint64_t v16 = HIDWORD(v14);
            if (v16 == -1)
            {
              int v12 = v15[40];
              if (v12 == 2) {
                goto LABEL_9;
              }
              if (v15[40]) {
                goto LABEL_11;
              }
              if (!v15[43])
              {
                if (v15[41]) {
                  goto LABEL_11;
                }
                LOBYTE(v12) = 2;
                goto LABEL_9;
              }
            }
            else if (!v16)
            {
              int v17 = v15[40];
              if (v17) {
                char v18 = -1;
              }
              else {
                char v18 = 0;
              }
              char v26 = v18;
              if (v17) {
                goto LABEL_11;
              }
              goto LABEL_10;
            }
          }
          LOBYTE(v12) = 0;
LABEL_9:
          char v26 = v12;
LABEL_10:
          sub_19E478A10(a1, a2, (float *)&v27, (uint64_t)&v30, &v26);
LABEL_11:
          (*(void (**)(void))(*(void *)*a3 + 88))();
          uint64_t result = (*(uint64_t (**)(void))(*(void *)*a3 + 72))();
          if (result) {
            return result;
          }
        }
      }
      do
      {
        uint64_t v19 = (*(uint64_t (**)(void))(*(void *)*a3 + 80))();
        unint64_t v20 = *(void *)v19;
        unint64_t v30 = *(void *)v19;
        int v31 = *(_DWORD *)(v19 + 8);
        int v32 = *(_DWORD *)(v19 + 12);
        uint64_t v27 = *(void *)a4;
        unsigned int v28 = a4[2];
        unsigned int v29 = a4[3];
        unsigned int v21 = *(unsigned __int8 **)(a1 + 136);
        if (v27 == -1)
        {
          int v22 = v21[40];
          if (v22 == 1) {
            goto LABEL_46;
          }
          if (v21[40]) {
            goto LABEL_32;
          }
          if (!v21[44])
          {
            if (v21[42]) {
              goto LABEL_32;
            }
            LOBYTE(v22) = 1;
            goto LABEL_46;
          }
        }
        else
        {
          unint64_t v23 = HIDWORD(v20);
          if (!v23)
          {
            int v24 = v21[40];
            if (v24) {
              char v25 = -1;
            }
            else {
              char v25 = 0;
            }
            char v26 = v25;
            if (v24) {
              goto LABEL_32;
            }
            goto LABEL_31;
          }
          if (v23 == -1)
          {
            int v22 = v21[40];
            if (v22 == 2) {
              goto LABEL_46;
            }
            if (v21[40]) {
              goto LABEL_32;
            }
            if (!v21[43])
            {
              if (v21[41]) {
                goto LABEL_32;
              }
              LOBYTE(v22) = 2;
LABEL_46:
              char v26 = v22;
              goto LABEL_31;
            }
          }
        }
        char v26 = 0;
LABEL_31:
        sub_19E478A10(a1, a2, (float *)&v30, (uint64_t)&v27, &v26);
LABEL_32:
        (*(void (**)(void))(*(void *)*a3 + 88))();
        uint64_t result = (*(uint64_t (**)(void))(*(void *)*a3 + 72))();
      }
      while (!result);
    }
  }
  return result;
}

void sub_19E472A04(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 120);
  uint64_t v5 = sub_19E472B88(v4, a2);
  uint64_t v6 = v5;
  if (*(unsigned char *)(v4 + 104))
  {
    int v7 = *(_DWORD *)(v5 + 56);
    if ((v7 & 4) == 0)
    {
      *(_DWORD *)(v5 + 56) = v7 | 4;
      unint64_t v8 = *(void *)(v5 + 32) - *(void *)(v5 + 24) + *(void *)(v4 + 128) + 64;
      *(void *)(v4 + 128) = v8;
      *(unsigned char *)(v4 + 120) = 1;
      if (v8 > *(void *)(v4 + 112)) {
        sub_19E472D04(v4, v5);
      }
    }
  }
  uint64_t v9 = *(void *)(a1 + 120);
  uint64_t v10 = *(void *)(v6 + 24);
  uint64_t v11 = *(void *)(v6 + 32);
  uint64_t v12 = v11 - v10;
  if (v11 != v10)
  {
    uint64_t v13 = v12 >> 4;
    if ((unint64_t)(v12 >> 4) <= 1) {
      uint64_t v13 = 1;
    }
    unint64_t v14 = (_DWORD *)(v10 + 4);
    do
    {
      if (*(v14 - 1))
      {
        if (!*v14) {
          goto LABEL_14;
        }
      }
      else
      {
        ++*(void *)(v6 + 8);
        if (!*v14) {
LABEL_14:
        }
          ++*(void *)(v6 + 16);
      }
      v14 += 4;
      --v13;
    }
    while (v13);
  }
  if (*(unsigned char *)(v9 + 120))
  {
    if ((*(unsigned char *)(v6 + 56) & 4) != 0)
    {
      unint64_t v15 = *(void *)(v9 + 128) + v12;
      *(void *)(v9 + 128) = v15;
      if (v15 > *(void *)(v9 + 112))
      {
        sub_19E472D04(v9, v6);
        uint64_t v10 = *(void *)(v6 + 24);
        uint64_t v11 = *(void *)(v6 + 32);
      }
    }
  }
  uint64_t v16 = v11 - v10;
  if (v16)
  {
    unint64_t v17 = v16 >> 4;
    int v18 = *(_DWORD *)(a1 + 68);
    if (v17 <= 1) {
      unint64_t v17 = 1;
    }
    uint64_t v19 = (int *)(v10 + 12);
    do
    {
      int v21 = *v19;
      v19 += 4;
      int v20 = v21;
      if (v21 >= v18)
      {
        int v18 = v20 + 1;
        *(_DWORD *)(a1 + 68) = v20 + 1;
      }
      --v17;
    }
    while (v17);
  }
  sub_19E472F9C(a1, a2);
  *(_DWORD *)(v6 + 56) |= 0xAu;
}

uint64_t sub_19E472B88(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 92);
  if (v3 == a2) {
    return *(void *)(a1 + 96);
  }
  if (*(unsigned char *)(a1 + 88))
  {
    if (v3 == -1)
    {
      *(_DWORD *)(a1 + 92) = a2;
      uint64_t v7 = sub_19E4780E4(a1, 0);
      *(void *)(a1 + 96) = v7;
      *(_DWORD *)(v7 + 56) |= 4u;
      unint64_t v8 = *(char **)(v7 + 24);
      unint64_t v9 = *(void *)(v7 + 40) - (void)v8;
      if (v9 <= 0x7FF)
      {
        uint64_t v10 = (void *)v7;
        uint64_t v11 = *(char **)(v7 + 32);
        uint64_t v12 = (char *)operator new(0x800uLL);
        uint64_t v13 = &v12[v11 - v8];
        unint64_t v14 = v13;
        if (v11 != v8)
        {
          uint64_t v15 = 0;
          do
          {
            uint64_t v16 = &v13[v15];
            *((void *)v16 - 2) = *(void *)&v11[v15 - 16];
            *((_DWORD *)v16 - 2) = *(_DWORD *)&v11[v15 - 8];
            *((_DWORD *)v16 - 1) = *(_DWORD *)&v11[v15 - 4];
            v15 -= 16;
          }
          while (&v11[v15] != v8);
          unint64_t v14 = &v13[v15];
        }
        v10[3] = v14;
        v10[4] = v13;
        v10[5] = v12 + 2048;
        if (v8) {
          sub_19E475CA4(v10 + 6, v8, v9 >> 4);
        }
      }
      return *(void *)(a1 + 96);
    }
    uint64_t v5 = *(void *)(a1 + 96);
    if (!*(_DWORD *)(v5 + 60))
    {
      *(_DWORD *)(a1 + 92) = a2;
      *(_DWORD *)uint64_t v5 = 2139095039;
      *(void *)(v5 + 56) = 0;
      *(void *)(v5 + 8) = 0;
      *(void *)(v5 + 16) = 0;
      *(void *)(v5 + 32) = *(void *)(v5 + 24);
      uint64_t result = *(void *)(a1 + 96);
      *(_DWORD *)(result + 56) |= 4u;
      return result;
    }
    *(_DWORD *)(v5 + 56) &= ~4u;
    *(unsigned char *)(a1 + 88) = 0;
  }
  int v6 = a2 + 1;
  return sub_19E4780E4(a1, v6);
}

void sub_19E472D04(uint64_t a1, uint64_t a2)
{
  char v4 = 0;
  uint64_t v5 = a1 + 32;
  while (*(unsigned char *)(a1 + 120))
  {
    unint64_t v8 = (unint64_t)(float)((float)*(unint64_t *)(a1 + 112) * 0.666);
    uint64_t v9 = *(void *)(a1 + 40);
    *(void *)(a1 + 64) = v9;
    if (v9 != v5)
    {
      if (v4)
      {
        do
        {
          int v16 = *(_DWORD *)(v9 + 16);
          if (v16) {
            int v17 = v16 - 1;
          }
          else {
            int v17 = *(_DWORD *)(a1 + 92);
          }
          uint64_t v18 = sub_19E472B88(a1, v17);
          unint64_t v19 = *(void *)(a1 + 128);
          if (v19 <= v8 || (!*(_DWORD *)(v18 + 60) ? (BOOL v20 = v18 == a2) : (BOOL v20 = 1), v20))
          {
            *(_DWORD *)(v18 + 56) &= ~8u;
            uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
            *(void *)(a1 + 64) = v9;
          }
          else
          {
            if ((*(unsigned char *)(v18 + 56) & 4) != 0)
            {
              unint64_t v21 = *(void *)(v18 + 32) - *(void *)(v18 + 24) + 64;
              sub_19E4730C4(v21 <= v19);
              *(void *)(a1 + 128) -= v21;
            }
            sub_19E4731C8(a1);
            uint64_t v9 = *(void *)(a1 + 64);
          }
        }
        while (v9 != v5);
      }
      else
      {
        do
        {
          while (1)
          {
            int v10 = *(_DWORD *)(v9 + 16);
            int v11 = v10 ? v10 - 1 : *(_DWORD *)(a1 + 92);
            uint64_t v12 = sub_19E472B88(a1, v11);
            unint64_t v13 = *(void *)(a1 + 128);
            if (v13 > v8 && !*(_DWORD *)(v12 + 60))
            {
              int v14 = *(_DWORD *)(v12 + 56);
              if ((v14 & 8) == 0 && v12 != a2) {
                break;
              }
            }
            *(_DWORD *)(v12 + 56) &= ~8u;
            uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
            *(void *)(a1 + 64) = v9;
            if (v9 == v5) {
              goto LABEL_2;
            }
          }
          if ((v14 & 4) != 0)
          {
            unint64_t v15 = *(void *)(v12 + 32) - *(void *)(v12 + 24) + 64;
            sub_19E4730C4(v15 <= v13);
            *(void *)(a1 + 128) -= v15;
          }
          sub_19E4731C8(a1);
          uint64_t v9 = *(void *)(a1 + 64);
        }
        while (v9 != v5);
      }
    }
LABEL_2:
    unint64_t v6 = *(void *)(a1 + 128);
    char v7 = v4 | (v6 <= v8);
    char v4 = 1;
    if (v7)
    {
      if (v8)
      {
        if (v6 > v8)
        {
          uint64_t v22 = *(void *)(a1 + 112);
          do
          {
            v22 *= 2;
            v8 *= 2;
          }
          while (v6 > v8);
          *(void *)(a1 + 112) = v22;
        }
      }
      else if (v6)
      {
        char v25 = 5;
        strcpy((char *)__p, "FATAL");
        unint64_t v23 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
        sub_19E37CA70(v23, (uint64_t)": ", 2);
        sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"GCCacheStore:GC: Unable to free all cached states", 49);
        sub_19E43C8CC();
        if (v25 < 0) {
          operator delete(__p[0]);
        }
      }
      return;
    }
  }
}

void sub_19E472F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_19E472F9C(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 100) < a2) {
    *(_DWORD *)(a1 + 100) = a2;
  }
  int v3 = *(_DWORD *)(a1 + 96);
  if (v3 <= a2)
  {
    if (v3 == a2) {
      *(_DWORD *)(a1 + 96) = a2 + 1;
    }
    if (*(unsigned char *)(a1 + 104) || !*(void *)(a1 + 112))
    {
      unint64_t v4 = a2;
      unint64_t v5 = *(void *)(a1 + 80);
      if (v5 <= a2)
      {
        do
        {
          uint64_t v7 = *(void *)(a1 + 88);
          if (v5 == v7 << 6)
          {
            if ((uint64_t)(v5 + 1) < 0) {
              sub_19E37C7C4();
            }
            unint64_t v8 = v7 << 7;
            if (v8 <= (v5 & 0xFFFFFFFFFFFFFFC0) + 64) {
              unint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFC0) + 64;
            }
            if (v5 <= 0x3FFFFFFFFFFFFFFELL) {
              unint64_t v9 = v8;
            }
            else {
              unint64_t v9 = 0x7FFFFFFFFFFFFFFFLL;
            }
            sub_19E4645DC(a1 + 72, v9);
            unint64_t v5 = *(void *)(a1 + 80);
          }
          *(void *)(a1 + 80) = v5 + 1;
          uint64_t v6 = *(void *)(a1 + 72);
          *(void *)(v6 + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v5);
          unint64_t v5 = *(void *)(a1 + 80);
        }
        while (v5 <= v4);
      }
      else
      {
        uint64_t v6 = *(void *)(a1 + 72);
      }
      *(void *)(v6 + ((v4 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v4;
    }
  }
}

void sub_19E4730C4(char a1)
{
  if ((a1 & 1) == 0)
  {
    char v7 = 5;
    strcpy((char *)__p, "FATAL");
    uint64_t v1 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
    sub_19E37CA70(v1, (uint64_t)": ", 2);
    uint64_t v2 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"Check failed: \"", 15);
    int v3 = sub_19E37CA70(v2, (uint64_t)"(size) <= (cache_size_)", 23);
    unint64_t v4 = sub_19E37CA70(v3, (uint64_t)"\" file: ", 8);
    unint64_t v5 = sub_19E37CA70(v4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/LanguageModeling/Source/fst/cache.h", 73);
    sub_19E37CA70(v5, (uint64_t)" line: ", 7);
    std::ostream::operator<<();
    sub_19E43C8CC();
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_19E4731A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E4731C8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  LODWORD(v3) = *(_DWORD *)(v2 + 16);
  if (!v3 || v3 - 1 == *(_DWORD *)(a1 + 92))
  {
    *(_DWORD *)(a1 + 92) = -1;
    *(void *)(a1 + 96) = 0;
    LODWORD(v3) = *(_DWORD *)(v2 + 16);
  }
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 8 * (int)v3);
  if (v5)
  {
    sub_19E47328C(v5 + 24);
    sub_19E473374(a1 + 72, v5);
    uint64_t v3 = *(int *)(*(void *)(a1 + 64) + 16);
    uint64_t v4 = *(void *)(a1 + 8);
  }
  else
  {
    uint64_t v3 = (int)v3;
  }
  *(void *)(v4 + 8 * v3) = 0;
  uint64_t v6 = *(uint64_t **)(a1 + 64);
  uint64_t v8 = *v6;
  uint64_t v7 = v6[1];
  *(void *)(a1 + 64) = v7;
  *(void *)(v8 + 8) = v7;
  *(void *)v6[1] = v8;
  --*(void *)(a1 + 48);
  sub_19E473460((uint64_t *)(a1 + 56), v6, 1uLL);
}

uint64_t sub_19E47328C(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    sub_19E475CA4((uint64_t *)(a1 + 24), v2, (uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 4);
  }
  uint64_t v3 = *(void **)(a1 + 24);
  uint64_t v4 = v3[1] - 1;
  v3[1] = v4;
  if (!v4)
  {
    uint64_t v5 = (void *)v3[2];
    uint64_t v6 = (unsigned char *)v3[3];
    if (v6 == (unsigned char *)v5)
    {
      uint64_t v5 = (void *)v3[3];
    }
    else
    {
      unint64_t v7 = 0;
      do
      {
        uint64_t v8 = v5[v7];
        if (v8)
        {
          (*(void (**)(void))(*(void *)v8 + 8))(v5[v7]);
          uint64_t v5 = (void *)v3[2];
          uint64_t v6 = (unsigned char *)v3[3];
        }
        ++v7;
      }
      while (v7 < (v6 - (unsigned char *)v5) >> 3);
    }
    if (v5)
    {
      v3[3] = v5;
      operator delete(v5);
    }
    MEMORY[0x19F3BDCF0](v3, 0x1080C40B69A5871);
  }
  return a1;
}

void sub_19E473374(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (unint64_t *)(*(void *)a1 + 16);
  unint64_t v3 = *v4;
  unint64_t v5 = *(void *)(*(void *)a1 + 24) - *v4;
  if (v5 <= 0x207)
  {
    uint64_t v7 = 0;
    sub_19E46BA20(v4, 65 - (v5 >> 3), (const double *)&v7);
    unint64_t v3 = *v4;
  }
  uint64_t v6 = *(void *)(v3 + 512);
  if (!v6) {
    operator new();
  }
  *(void *)(a2 + 64) = *(void *)(v6 + 56);
  *(void *)(v6 + 56) = a2;
}

void sub_19E47343C(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10A1C40E79ACBF4);
  _Unwind_Resume(a1);
}

void sub_19E473460(uint64_t *a1, void *__p, unint64_t a3)
{
  if (a3 == 2)
  {
    unint64_t v9 = (unint64_t *)(*a1 + 16);
    unint64_t v8 = *v9;
    unint64_t v10 = *(void *)(*a1 + 24) - *v9;
    if (v10 <= 0x187)
    {
      uint64_t v29 = 0;
      sub_19E46BA20(v9, 49 - (v10 >> 3), (const double *)&v29);
      unint64_t v8 = *v9;
    }
    uint64_t v11 = *(void *)(v8 + 384);
    if (!v11) {
      operator new();
    }
    if (__p)
    {
      __p[6] = *(void *)(v11 + 56);
      *(void *)(v11 + 56) = __p;
    }
  }
  else if (a3 == 1)
  {
    unint64_t v5 = (unint64_t *)(*a1 + 16);
    unint64_t v4 = *v5;
    unint64_t v6 = *(void *)(*a1 + 24) - *v5;
    if (v6 <= 0xC7)
    {
      uint64_t v29 = 0;
      sub_19E46BA20(v5, 25 - (v6 >> 3), (const double *)&v29);
      unint64_t v4 = *v5;
    }
    uint64_t v7 = *(void *)(v4 + 192);
    if (!v7) {
      operator new();
    }
    if (__p)
    {
      __p[3] = *(void *)(v7 + 56);
      *(void *)(v7 + 56) = __p;
    }
  }
  else if (a3 > 4)
  {
    if (a3 > 8)
    {
      if (a3 > 0x10)
      {
        if (a3 > 0x20)
        {
          if (a3 > 0x40)
          {
            operator delete(__p);
          }
          else
          {
            uint64_t v28 = sub_19E473DBC(*a1);
            if (__p)
            {
              __p[192] = *(void *)(v28 + 56);
              *(void *)(v28 + 56) = __p;
            }
          }
        }
        else
        {
          char v25 = (unint64_t *)(*a1 + 16);
          unint64_t v24 = *v25;
          unint64_t v26 = *(void *)(*a1 + 24) - *v25;
          if (v26 >> 3 <= 0x300)
          {
            uint64_t v29 = 0;
            sub_19E46BA20(v25, 769 - (v26 >> 3), (const double *)&v29);
            unint64_t v24 = *v25;
          }
          uint64_t v27 = *(void *)(v24 + 6144);
          if (!v27) {
            operator new();
          }
          if (__p)
          {
            __p[96] = *(void *)(v27 + 56);
            *(void *)(v27 + 56) = __p;
          }
        }
      }
      else
      {
        unint64_t v21 = (unint64_t *)(*a1 + 16);
        unint64_t v20 = *v21;
        unint64_t v22 = *(void *)(*a1 + 24) - *v21;
        if (v22 <= 0xC07)
        {
          uint64_t v29 = 0;
          sub_19E46BA20(v21, 385 - (v22 >> 3), (const double *)&v29);
          unint64_t v20 = *v21;
        }
        uint64_t v23 = *(void *)(v20 + 3072);
        if (!v23) {
          operator new();
        }
        if (__p)
        {
          __p[48] = *(void *)(v23 + 56);
          *(void *)(v23 + 56) = __p;
        }
      }
    }
    else
    {
      int v17 = (unint64_t *)(*a1 + 16);
      unint64_t v16 = *v17;
      unint64_t v18 = *(void *)(*a1 + 24) - *v17;
      if (v18 <= 0x607)
      {
        uint64_t v29 = 0;
        sub_19E46BA20(v17, 193 - (v18 >> 3), (const double *)&v29);
        unint64_t v16 = *v17;
      }
      uint64_t v19 = *(void *)(v16 + 1536);
      if (!v19) {
        operator new();
      }
      if (__p)
      {
        __p[24] = *(void *)(v19 + 56);
        *(void *)(v19 + 56) = __p;
      }
    }
  }
  else
  {
    unint64_t v13 = (unint64_t *)(*a1 + 16);
    unint64_t v12 = *v13;
    unint64_t v14 = *(void *)(*a1 + 24) - *v13;
    if (v14 <= 0x307)
    {
      uint64_t v29 = 0;
      sub_19E46BA20(v13, 97 - (v14 >> 3), (const double *)&v29);
      unint64_t v12 = *v13;
    }
    uint64_t v15 = *(void *)(v12 + 768);
    if (!v15) {
      operator new();
    }
    if (__p)
    {
      unsigned char __p[12] = *(void *)(v15 + 56);
      *(void *)(v15 + 56) = __p;
    }
  }
}

void sub_19E473A1C(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x10A1C40E79ACBF4);
  _Unwind_Resume(a1);
}

void sub_19E473B20(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0BC708;
  a1[1] = 32 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E473BB0(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    unint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E473BFC(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0B4E38;
  a1[1] = 392 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E473C90(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    unint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E473CDC(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF0B4E88;
  a1[1] = 776 * a2;
  a1[2] = 0;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0;
  operator new[]();
}

void sub_19E473D70(_Unwind_Exception *exception_object)
{
  if (v1[5])
  {
    uint64_t v5 = v1[3];
    unint64_t v4 = (uint64_t *)v1[4];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[5] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E473DBC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = (uint64_t *)(a1 + 16);
  unint64_t v3 = *(void *)(a1 + 24) - v1;
  if (v3 >> 3 <= 0x600)
  {
    uint64_t v5 = 0;
    sub_19E46BA20((unint64_t *)(a1 + 16), 1537 - (v3 >> 3), (const double *)&v5);
    uint64_t v1 = *v2;
  }
  if (!*(void *)(v1 + 12288)) {
    operator new();
  }
  return *(void *)(v1 + 12288);
}

void sub_19E473EE0(_Unwind_Exception *a1)
{
  if (v1[6])
  {
    uint64_t v5 = v1[4];
    unint64_t v4 = (uint64_t *)v1[5];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[6] = 0;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        unint64_t v4 = v7;
      }
      while (v7 != v2);
    }
  }
  MEMORY[0x19F3BDCF0](v1, 0x10A1C40E79ACBF4);
  _Unwind_Resume(a1);
}

uint64_t sub_19E473F44()
{
  return 1544;
}

void sub_19E473F4C(void *a1)
{
  *a1 = &unk_1EF0B4ED8;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E47402C(void *a1)
{
  *a1 = &unk_1EF0B4ED8;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E4740EC()
{
  return 1536;
}

void sub_19E4740F4(void *a1)
{
  *a1 = &unk_1EF0B4DE8;
  a1[1] = &unk_1EF0B4ED8;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4741F4(void *a1)
{
  *a1 = &unk_1EF0B4DE8;
  a1[1] = &unk_1EF0B4ED8;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E4742D4()
{
  return 776;
}

void sub_19E4742DC(void *a1)
{
  *a1 = &unk_1EF0B4E88;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4743BC(void *a1)
{
  *a1 = &unk_1EF0B4E88;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E47447C()
{
  return 768;
}

void sub_19E474484(void *a1)
{
  *a1 = &unk_1EF0B4D98;
  a1[1] = &unk_1EF0B4E88;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E474584(void *a1)
{
  *a1 = &unk_1EF0B4D98;
  a1[1] = &unk_1EF0B4E88;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E474664()
{
  return 392;
}

void sub_19E47466C(void *a1)
{
  *a1 = &unk_1EF0B4E38;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E47474C(void *a1)
{
  *a1 = &unk_1EF0B4E38;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E47480C()
{
  return 384;
}

void sub_19E474814(void *a1)
{
  *a1 = &unk_1EF0B4D48;
  a1[1] = &unk_1EF0B4E38;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E474914(void *a1)
{
  *a1 = &unk_1EF0B4D48;
  a1[1] = &unk_1EF0B4E38;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E4749F4()
{
  return 200;
}

void sub_19E4749FC(void *a1)
{
  *a1 = &unk_1EF0B4F00;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E474ADC(void *a1)
{
  *a1 = &unk_1EF0B4F00;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E474B9C()
{
  return 192;
}

void sub_19E474BA4(void *a1)
{
  *a1 = &unk_1EF0B4E10;
  a1[1] = &unk_1EF0B4F00;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E474CA4(void *a1)
{
  *a1 = &unk_1EF0B4E10;
  a1[1] = &unk_1EF0B4F00;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E474D84()
{
  return 104;
}

void sub_19E474D8C(void *a1)
{
  *a1 = &unk_1EF0B4EB0;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E474E6C(void *a1)
{
  *a1 = &unk_1EF0B4EB0;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E474F2C()
{
  return 96;
}

void sub_19E474F34(void *a1)
{
  *a1 = &unk_1EF0B4DC0;
  a1[1] = &unk_1EF0B4EB0;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E475034(void *a1)
{
  *a1 = &unk_1EF0B4DC0;
  a1[1] = &unk_1EF0B4EB0;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E475114()
{
  return 56;
}

void sub_19E47511C(void *a1)
{
  *a1 = &unk_1EF0B4E60;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4751FC(void *a1)
{
  *a1 = &unk_1EF0B4E60;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E4752BC()
{
  return 48;
}

void sub_19E4752C4(void *a1)
{
  *a1 = &unk_1EF0B4D70;
  a1[1] = &unk_1EF0B4E60;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4753C4(void *a1)
{
  *a1 = &unk_1EF0B4D70;
  a1[1] = &unk_1EF0B4E60;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E4754A4()
{
  return 32;
}

void sub_19E4754AC(void *a1)
{
  *a1 = &unk_1EF0BC708;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E47558C(void *a1)
{
  *a1 = &unk_1EF0BC708;
  uint64_t v2 = a1 + 3;
  for (uint64_t i = (uint64_t *)a1[4]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[5])
  {
    uint64_t v6 = a1[3];
    uint64_t v5 = (uint64_t *)a1[4];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[5] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}

uint64_t sub_19E47564C()
{
  return 24;
}

void sub_19E475654(void *a1)
{
  *a1 = &unk_1EF0BC410;
  a1[1] = &unk_1EF0BC708;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E475754(void *a1)
{
  *a1 = &unk_1EF0BC410;
  a1[1] = &unk_1EF0BC708;
  uint64_t v2 = a1 + 4;
  for (uint64_t i = (uint64_t *)a1[5]; i != v2; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    if (v4) {
      MEMORY[0x19F3BDCC0](v4, 0x1000C8077774924);
    }
  }
  if (a1[6])
  {
    uint64_t v6 = a1[4];
    uint64_t v5 = (uint64_t *)a1[5];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    a1[6] = 0;
    if (v5 != v2)
    {
      do
      {
        unint64_t v8 = (uint64_t *)v5[1];
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
  return a1;
}