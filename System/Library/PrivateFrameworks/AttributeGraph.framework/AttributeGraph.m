uint64_t type metadata accessor for Attribute()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t Attribute.init<A>(body:value:flags:update:)(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t CurrentGraphContext = AGSubgraphGetCurrentGraphContext();
  if (CurrentGraphContext)
  {
    uint64_t v11 = MEMORY[0x1F4188790](CurrentGraphContext);
    unsigned int v12 = AGGraphInternAttributeType(v11, a7, sub_1AF907EC8);
    return AGGraphCreateAttribute(v12, a1, a2);
  }
  else
  {
    sub_1AF93CE28();
    sub_1AF93CDC8();
    sub_1AF93CF78();
    sub_1AF93CDC8();
    swift_bridgeObjectRelease();
    uint64_t result = sub_1AF93CE38();
    __break(1u);
  }
  return result;
}

uint64_t type metadata accessor for PointerOffset()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t dispatch thunk of StatefulRule.updateValue()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of Rule.value.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t __swift_instantiateGenericMetadata()
{
  return swift_getGenericMetadata();
}

uint64_t sub_1AF9037CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F41863F8](a1, a2, a3, 24);
}

unint64_t AGCreateWeakAttribute(unsigned int a1)
{
  if (a1 < 4) {
    unint64_t v1 = 0;
  }
  else {
    unint64_t v1 = (unint64_t)(*(_DWORD *)(*(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00)) + 24) & 0x7FFFFFFF) << 32;
  }
  return v1 | a1;
}

uint64_t AGGraphSetUpdate(uint64_t result)
{
  uint64_t v1 = AG::Graph::_current_update_key;
  *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v1) = result;
  return result;
}

uint64_t AGGraphContextGetGraph(uint64_t a1)
{
  return a1 - 16;
}

uint64_t AGGraphCreateOffsetAttribute2(uint64_t a1, const char *a2, unint64_t a3)
{
}

uint64_t AGGraphGetCurrentAttribute()
{
  uint64_t v0 = AG::Graph::_current_update_key;
  uint64_t v1 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v0);
  uint64_t result = 2;
  if ((v1 & 1) == 0)
  {
    unint64_t v3 = v1 & 0xFFFFFFFFFFFFFFFELL;
    if (v3)
    {
      unint64_t v4 = v3 + 32;
      unint64_t v6 = *(void *)(v3 + 96);
      uint64_t v5 = *(void *)(v3 + 104);
      if (v6) {
        unint64_t v4 = v6;
      }
      return *(unsigned int *)(v4 + 8 * v5 - 8);
    }
  }
  return result;
}

uint64_t sub_1AF903878(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F41863F8](a1, a2, a3, 16);
}

uint64_t type metadata accessor for Focus()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t AGGraphClearUpdate()
{
  uint64_t v0 = AG::Graph::_current_update_key;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t result = *(void *)(StatusReg + 8 * v0);
  if (result) {
    BOOL v3 = (*(void *)(StatusReg + 8 * v0) & 1) == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3) {
    *(void *)(StatusReg + 8 * v0) = result | 1;
  }
  return result;
}

uint64_t *AGSubgraphAddChild(uint64_t a1, uint64_t a2)
{
  return AGSubgraphAddChild2(a1, a2, 0);
}

uint64_t AGGraphCreateIndirectAttribute(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

BOOL AGSubgraphIsValid(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return v1 && *(unsigned char *)(v1 + 104) == 0;
}

uint64_t AGSubgraphGetCurrent()
{
  uint64_t v0 = AG::Subgraph::_current_subgraph_key;
  uint64_t v1 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v0);
  if (v1) {
    return *(void *)(v1 + 32);
  }
  else {
    return 0;
  }
}

uint64_t AGGraphGetContext(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  return *(void *)(a1 + 24);
}

uint64_t anonymous namespace'::create_offset_attribute(uint64_t a1, const char *a2, unint64_t a3, char a4)
{
  uint64_t v7 = a1;
  if (a2)
  {
    if ((unint64_t)a2 >= 0x3FFFFFFF) {
      AG::precondition_failure((AG *)"invalid offset: %u, %lu", a2, a1, a2);
    }
  }
  else if (a4)
  {
    int v13 = a1;
    if ((a1 & 3) == 1)
    {
      unint64_t v11 = AG::AttributeID::size((AG::AttributeID *)&v13);
      if (v12)
      {
        if (v11 == a3) {
          return v7;
        }
      }
    }
  }
  uint64_t v8 = AG::Subgraph::_current_subgraph_key;
  v9 = *(uint64_t **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  if (!v9) {
    AG::precondition_failure((AG *)"no subgraph active while adding attribute", 0);
  }
  return AG::Graph::add_indirect_attribute(v9[5], (AG::data::zone *)v9, v7, (uint64_t)a2, a3, a4, 0) | 1;
}

uint64_t AG::Graph::add_indirect_attribute(uint64_t a1, AG::data::zone *this, unsigned int a3, uint64_t a4, unint64_t a5, char a6, char a7)
{
  unsigned int v39 = a3;
  if (*((void *)this + 5) != *(void *)(*(void *)(AG::data::_shared_table_bytes + (a3 & 0xFFFFFE00)) + 40)) {
    AG::precondition_failure((AG *)"attribute references can't cross graph namespaces", (const char *)this);
  }
  if ((a3 & 3) != 0) {
    a3 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v39, (const char *)4);
  }
  else {
    int v13 = 0;
  }
  unsigned int v39 = a3;
  unint64_t v14 = (unint64_t)&v13[a4];
  if (__CFADD__(v13, a4) || v14 >= 0x3FFFFFFF) {
    AG::precondition_failure((AG *)"indirect attribute overflowed: %lu + %lu", v13, v13, a4);
  }
  if (a6)
  {
    unint64_t v15 = AG::AttributeID::size((AG::AttributeID *)&v39);
    if ((_BYTE)v16)
    {
      if (v14 + a5 > v15) {
        AG::precondition_failure((AG *)"invalid size for indirect attribute: %d vs %u", v16, a5 - v14, v15);
      }
    }
  }
  uint64_t v17 = AG::data::_shared_table_bytes;
  v18 = *(AG::data::zone **)(AG::data::_shared_table_bytes + (v39 & 0xFFFFFE00));
  uint64_t v19 = *((void *)v18 + 6);
  uint64_t v20 = *((void *)this + 6);
  if (a7)
  {
    uint64_t v21 = *((unsigned int *)this + 4);
    if (v21
      && (unsigned int v22 = (*(_DWORD *)(AG::data::_shared_table_bytes + v21 + 16) + 3) & 0xFFFFFFFC,
          v22 + 40 <= *(_DWORD *)(AG::data::_shared_table_bytes + v21 + 12)))
    {
      *(_DWORD *)(AG::data::_shared_table_bytes + v21 + 16) = v22 + 40;
      uint64_t v23 = v22 + v21;
    }
    else
    {
      uint64_t v23 = AG::data::zone::alloc_slow(this, 0x28u, 3);
      uint64_t v17 = AG::data::_shared_table_bytes;
    }
    uint64_t v33 = v17 + v23;
    unsigned int v34 = v39;
    *(_DWORD *)uint64_t v33 = v39;
    if (v34 < 4) {
      int v35 = 0;
    }
    else {
      int v35 = *(_DWORD *)(*(void *)(v17 + (v34 & 0xFFFFFE00)) + 24) & 0x7FFFFFFF;
    }
    *(_DWORD *)(v33 + 4) = v35;
    *(_DWORD *)(v33 + 8) = (2 * (v19 != v20)) | (4 * v14) | 1;
    if (a5 >= 0xFFFF || a6 == 0) {
      __int16 v37 = -1;
    }
    else {
      __int16 v37 = a5;
    }
    *(_WORD *)(v33 + 12) = v37;
    *(void *)(v33 + 16) = 0;
    *(_DWORD *)(v33 + 24) = 0;
    *(void *)(v33 + 28) = *(void *)v33;
    *(_DWORD *)(v33 + 36) = v14;
    AG::Graph::add_input_dependencies(a1, v23 | 1, v39);
    v32 = this;
    unsigned int v24 = v23;
    BOOL v31 = 1;
  }
  else
  {
    uint64_t v23 = AG::data::zone::alloc_bytes_recycle(this, 0x10u, 3);
    unsigned int v24 = v23;
    uint64_t v25 = AG::data::_shared_table_bytes;
    uint64_t v26 = AG::data::_shared_table_bytes + v23;
    unsigned int v27 = v39;
    *(_DWORD *)uint64_t v26 = v39;
    if (v27 < 4) {
      int v28 = 0;
    }
    else {
      int v28 = *(_DWORD *)(*(void *)(v25 + (v27 & 0xFFFFFE00)) + 24) & 0x7FFFFFFF;
    }
    *(_DWORD *)(v26 + 4) = v28;
    *(_DWORD *)(v26 + 8) = (2 * (v19 != v20)) | (4 * v14);
    if (a5 >= 0xFFFF || a6 == 0) {
      __int16 v30 = -1;
    }
    else {
      __int16 v30 = a5;
    }
    *(_WORD *)(v26 + 12) = v30;
    BOOL v31 = v18 != this;
    v32 = this;
  }
  AG::Subgraph::add_indirect((uint64_t)v32, v24, v31);
  return v23;
}

unint64_t AG::AttributeID::size(AG::AttributeID *this)
{
  uint64_t v1 = *(unsigned int *)this;
  if ((*(_DWORD *)this & 3) == 1)
  {
    int v4 = *(unsigned __int16 *)(AG::data::_shared_table_bytes + (v1 & 0xFFFFFFFC) + 12);
    if (v4 == 0xFFFF) {
      LODWORD(v2) = 0;
    }
    else {
      LODWORD(v2) = v4;
    }
    unint64_t v3 = v2 >> 8;
  }
  else if ((v1 & 3) != 0)
  {
    LOBYTE(v2) = 0;
    unint64_t v3 = 0;
  }
  else
  {
    unint64_t v2 = *(void *)(*(void *)(*(void *)(*(void *)(*(void *)(*(void *)(*(void *)(AG::data::_shared_table_bytes
                                                                                           + (v1 & 0xFFFFFE00))
                                                                               + 40)
                                                                   + 128)
                                                       + (((unint64_t)*(unsigned int *)(AG::data::_shared_table_bytes
                                                                                             + v1) >> 5) & 0x7FFFFF8))
                                           + 8)
                               - 8)
                   + 64);
    unint64_t v3 = v2 >> 8;
  }
  return v2 | (v3 << 8);
}

uint64_t AG::Graph::add_attribute(int64x2_t *this, AG::Subgraph *a2, unsigned int a3, const void *a4, unint64_t a5)
{
  uint64_t v9 = *(void *)(this[8].i64[0] + 8 * a3);
  int v10 = *(_DWORD *)(v9 + 40);
  if ((v10 & 0x10) != 0) {
    unint64_t v11 = this;
  }
  else {
    unint64_t v11 = 0;
  }
  if (a5 | *(void *)(*(void *)(*(void *)(v9 + 8) - 8) + 64)) {
    char v12 = (unsigned __int8 *)a5;
  }
  else {
    char v12 = (unsigned __int8 *)v11;
  }
  uint64_t v13 = *(void *)(*(void *)v9 - 8);
  int v14 = *(_DWORD *)(v13 + 80);
  size_t v15 = *(void *)(v13 + 64);
  if ((v14 & 0x100000) != 0 || v15 > 0x80)
  {
    v16 = AG::data::zone::alloc_persistent(a2, v15);
    LODWORD(v15) = 8;
    int v17 = 7;
  }
  else
  {
    v16 = 0;
    int v17 = v14;
  }
  unsigned int v18 = v10 & 8;
  uint64_t v19 = (const char *)(((v17 + 28) & ~v17) + v15);
  int v20 = v17 | 3;
  if (v19 > 0x10)
  {
    uint64_t v22 = *((unsigned int *)a2 + 4);
    if (v22
      && (int v23 = (*(_DWORD *)(AG::data::_shared_table_bytes + v22 + 16) + v20) & ~v20,
          (v23 + v19) <= *(_DWORD *)(AG::data::_shared_table_bytes + v22 + 12)))
    {
      *(_DWORD *)(AG::data::_shared_table_bytes + v22 + 16) = v23 + v19;
      unsigned int v21 = v23 + v22;
    }
    else
    {
      unsigned int v21 = AG::data::zone::alloc_slow(a2, v19, v20);
    }
  }
  else
  {
    unsigned int v21 = AG::data::zone::alloc_bytes_recycle(a2, v19, v20);
  }
  uint64_t v24 = AG::data::_shared_table_bytes + v21;
  *(_DWORD *)uint64_t v24 = (v18 >> 1) | (a3 << 8) | v18;
  *(unsigned char *)(v24 + 7) = 32;
  *(void *)(v24 + 8) = 0;
  *(void *)(v24 + 16) = 0;
  *(_DWORD *)(v24 + 24) = 0;
  if (a3 >= 0x100000) {
    AG::precondition_failure((AG *)"too many node types allocated", v19);
  }
  uint64_t v25 = v21;
  uint64_t v26 = (unsigned __int8 *)(AG::data::_shared_table_bytes + v21);
  int v27 = *(_DWORD *)v26;
  *(_DWORD *)v26 |= 0x20u;
  if (v27 & 8) != 0 && (*(unsigned char *)(*(void *)(*(void *)(v9 + 8) - 8) + 82)) {
    int v28 = ~*(_DWORD *)(v9 + 40) & 0x20;
  }
  else {
    LOBYTE(v28) = 0;
  }
  unsigned __int8 v29 = v26[7] & 0xDF | v28;
  v26[7] = v29;
  if (v16)
  {
    v26[7] = v29 | 1;
    *(void *)(AG::data::_shared_table_bytes + v21 + *(unsigned int *)(v9 + 44)) = v16;
  }
  uint64_t v30 = *(void *)(*(void *)(v9 + 8) - 8);
  if ((*(unsigned char *)(v30 + 82) & 0x10) != 0 || *(void *)(v30 + 64) >= 0x81uLL) {
    v26[7] |= 2u;
  }
  uint64_t v31 = *(void *)(*(void *)v9 - 8);
  this[16] = vaddq_s64(this[16], vdupq_n_s64(1uLL));
  if (*(void *)(v31 + 64))
  {
    v32 = &v26[*(unsigned int *)(v9 + 44)];
    if (v26[7]) {
      v32 = *(unsigned __int8 **)v32;
    }
    (*(void (**)(unsigned __int8 *, const void *))(v31 + 16))(v32, a4);
  }
  if (v12)
  {
    AG::Graph::value_set_internal((AG::Graph *)this, v25, (AG::Node *)v26, v12, *(AG::LayoutDescriptor **)(v9 + 8));
  }
  else
  {
    *(_DWORD *)v26 |= 3u;
    int v33 = v26[6];
    unsigned int v34 = *((_DWORD *)a2 + 25);
    if ((v33 & ~HIWORD(v34)) != 0)
    {
      *((_DWORD *)a2 + 25) = v34 & 0xFF00FFFF | ((BYTE2(v34) | v33) << 16);
      AG::Subgraph::propagate_dirty_flags(a2);
    }
  }
  AG::Subgraph::add_node((uint64_t)a2, v25);
  return v25;
}

void AG::Subgraph::add_node(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = a2;
  *(unsigned char *)(AG::data::_shared_table_bytes + a2 + 6) = 0;
  AG::Subgraph::insert_attribute(a1, a2, 1);
  if (*(_DWORD *)(a1 + 96))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 328);
    if (!v7) {
      operator new();
    }
    uint64_t v16 = a1;
    int v17 = &v16;
    uint64_t v8 = std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::__emplace_unique_key_args<AG::Subgraph *,std::piecewise_construct_t const&,std::tuple<AG::Subgraph *&&>,std::tuple<>>(v7, &v16, (uint64_t)&std::piecewise_construct, &v17);
    uint64_t v9 = *((void *)v8 + 4);
    unint64_t v10 = v9 + 1;
    if (*((void *)v8 + 5) < (unint64_t)(v9 + 1))
    {
      size_t v15 = v8;
      AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)(v8 + 24), v10);
      uint64_t v8 = v15;
      uint64_t v9 = *((void *)v15 + 4);
      unint64_t v10 = v9 + 1;
    }
    unint64_t v11 = (_DWORD *)(*((void *)v8 + 3) + 8 * v9);
    *unint64_t v11 = *(_DWORD *)(a1 + 96);
    v11[1] = a2;
    *((void *)v8 + 4) = v10;
    v8[48] = 0;
  }
  uint64_t v5 = *(void *)(a1 + 40);
  int v6 = *(_DWORD *)(v5 + 232);
  if (v6)
  {
    unsigned int v12 = v6 - 1;
    do
    {
      uint64_t v13 = v12;
      uint64_t v14 = *(void *)(*(void *)(v5 + 224) + 8 * v12);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 224))(v14, v4);
      --v12;
    }
    while (v13);
  }
}

void AG::Subgraph::insert_attribute(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v3 = a2 & 0xFFFFFE00;
  int v4 = a2 & 3;
  if (!a3) {
    goto LABEL_12;
  }
  if ((a2 & 3) == 0 && *(unsigned char *)(AG::data::_shared_table_bytes + a2 + 6))
  {
    unsigned int v8 = 2;
    goto LABEL_19;
  }
  uint64_t v5 = AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00);
  int v6 = *(unsigned __int16 *)(v5 + 20);
  if (*(_WORD *)(v5 + 20))
  {
    uint64_t v7 = AG::data::_shared_table_bytes + 4;
    unsigned int v8 = 2;
    do
    {
      while ((v6 & 3) != 0)
      {
        if ((v6 & 3u) - 1 < 2 || !v6) {
          goto LABEL_13;
        }
      }
      uint64_t v9 = v6 + v3;
      if (!*(unsigned char *)(AG::data::_shared_table_bytes + 6 + v9)) {
        break;
      }
      int v6 = *(unsigned __int16 *)(v7 + v9);
      unsigned int v8 = v9;
    }
    while (*(_WORD *)(v7 + v9));
  }
  else
  {
LABEL_12:
    unsigned int v8 = 2;
  }
LABEL_13:
  if (v4 == 1)
  {
    unint64_t v10 = (_WORD *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFFFC) + 14);
    LOWORD(v4) = 1;
    goto LABEL_20;
  }
  if ((a2 & 3) != 0)
  {
    unint64_t v10 = 0;
    goto LABEL_20;
  }
LABEL_19:
  LOWORD(v4) = 0;
  unint64_t v10 = (_WORD *)(AG::data::_shared_table_bytes + a2 + 4);
LABEL_20:
  uint64_t v11 = v8;
  int v12 = v8 & 3;
  if (v12 == 1)
  {
    uint64_t v13 = (_WORD *)(AG::data::_shared_table_bytes + (v11 & 0xFFFFFFFC) + 14);
  }
  else if (v12)
  {
    uint64_t v14 = AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00);
    size_t v15 = (_WORD *)(v14 + 22);
    uint64_t v13 = (_WORD *)(v14 + 20);
    if (!a3) {
      uint64_t v13 = v15;
    }
  }
  else
  {
    uint64_t v13 = (_WORD *)(AG::data::_shared_table_bytes + v11 + 4);
  }
  *unint64_t v10 = *v13;
  *uint64_t v13 = ((a2 & 0xFFFC) - v3) | v4;
}

uint64_t AGGraphInternAttributeType(uint64_t a1, uint64_t *a2, uint64_t (*a3)(void))
{
  return AG::Graph::intern_type(a1, a2, a3);
}

uint64_t *AG::Graph::intern_type(uint64_t a1, uint64_t *a2, uint64_t (*a3)(void))
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v6 = (util::UntypedTable *)(a1 + 48);
  uint64_t v7 = util::UntypedTable::lookup((util::UntypedTable *)(a1 + 48), a2, 0);
  if (!v7)
  {
    uint64_t v8 = a3();
    uint64_t v10 = v8;
    uint64_t v11 = *(void *)(*(void *)v8 - 8);
    int v12 = 7;
    if ((*(_DWORD *)(v11 + 80) & 0x100000) == 0)
    {
      if (*(void *)(v11 + 64) <= 0x80uLL) {
        int v12 = *(_DWORD *)(v11 + 80);
      }
      else {
        int v12 = 7;
      }
    }
    *(_DWORD *)(v8 + 44) = (v12 + 28) & ~v12;
    if ((atomic_load_explicit((atomic_uchar *volatile)&_ZGVZN2AG5Graph11intern_typeEPKNS_5swift8metadataENS_17ClosureFunctionVPIPvJEEEE16prefetch_layouts, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&_ZGVZN2AG5Graph11intern_typeEPKNS_5swift8metadataENS_17ClosureFunctionVPIPvJEEEE16prefetch_layouts))
    {
      _ZZN2AG5Graph11intern_typeEPKNS_5swift8metadataENS_17ClosureFunctionVPIPvJEEEE16prefetch_layouts = _ZZN2AG5Graph11intern_typeEPKNS_5swift8metadataENS_17ClosureFunctionVPIPvJEEEENK3__0clEv();
      __cxa_guard_release(&_ZGVZN2AG5Graph11intern_typeEPKNS_5swift8metadataENS_17ClosureFunctionVPIPvJEEEE16prefetch_layouts);
    }
    if (_ZZN2AG5Graph11intern_typeEPKNS_5swift8metadataENS_17ClosureFunctionVPIPvJEEEE16prefetch_layouts
      && !*(void *)(v10 + 48))
    {
      *(void *)(v10 + 48) = AG::LayoutDescriptor::fetch(*(AG::LayoutDescriptor **)(v10 + 8), (const AG::swift::metadata *)(*(_DWORD *)(v10 + 40) & 3), -1);
    }
    uint64_t v7 = (uint64_t *)*(unsigned int *)(a1 + 136);
    if (v7 >= 0xFFFFFF) {
      AG::precondition_failure((AG *)"overflowed max type id: %u", v9, *(unsigned int *)(a1 + 136));
    }
    unsigned int v13 = *(_DWORD *)(a1 + 136);
    if (*(_DWORD *)(a1 + 140) <= v7)
    {
      AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow(a1 + 128, v7 + 1);
      unsigned int v13 = *(_DWORD *)(a1 + 136);
    }
    *(void *)(*(void *)(a1 + 128) + 8 * v13) = v10;
    *(_DWORD *)(a1 + 136) = v13 + 1;
    uint64_t v14 = (AG *)util::UntypedTable::insert(v6, a2, v7);
    if (*(void *)(*(void *)(*(void *)v10 - 8) + 64) >= 0x2000uLL)
    {
      size_t v15 = AG::misc_log(v14);
      uint64_t v14 = (AG *)os_log_type_enabled(v15, OS_LOG_TYPE_INFO);
      if (v14)
      {
        uint64_t v16 = *(void *)(*(void *)(*(void *)(v10 + 8) - 8) + 64);
        uint64_t v17 = AG::swift::metadata::name(*(AG::swift::metadata **)v10, 0);
        *(_DWORD *)buf = 67109378;
        int v25 = v16;
        __int16 v26 = 2080;
        uint64_t v27 = v17;
        _os_log_impl(&dword_1AF901000, v15, OS_LOG_TYPE_INFO, "large attribute self: %u bytes, %s", buf, 0x12u);
      }
    }
    if (*(void *)(*(void *)(*(void *)(v10 + 8) - 8) + 64) >= 0x2000uLL)
    {
      unsigned int v18 = AG::misc_log(v14);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        uint64_t v19 = (AG::swift::metadata **)(v10 + 8);
        int v20 = *(_DWORD *)(*(void *)(*(void *)(v10 + 8) - 8) + 64);
        uint64_t v21 = AG::swift::metadata::name(*(AG::swift::metadata **)v10, 0);
        uint64_t v22 = AG::swift::metadata::name(*v19, 0);
        *(_DWORD *)buf = 67109634;
        int v25 = v20;
        __int16 v26 = 2080;
        uint64_t v27 = v21;
        __int16 v28 = 2080;
        uint64_t v29 = v22;
        _os_log_impl(&dword_1AF901000, v18, OS_LOG_TYPE_INFO, "large attribute value: %u bytes, %s -> %s", buf, 0x1Cu);
      }
    }
  }
  return v7;
}

char *AGGraphGetValue(unint64_t a1, const char *a2, AG::swift::metadata *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a3;
  if ((a2 & 4) == 0)
  {
    uint64_t v6 = AG::Graph::_current_update_key;
    uint64_t v7 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
    if ((v7 & 1) == 0)
    {
      unint64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
      if ((v7 & 0xFFFFFFFFFFFFFFFELL) != 0)
      {
        char v9 = (char)a2;
        char v44 = 0;
        uint64_t v10 = *(__n128 **)v8;
        unint64_t v11 = v8 + 32;
        unint64_t v13 = *(void *)(v8 + 96);
        uint64_t v12 = *(void *)(v8 + 104);
        if (v13) {
          unint64_t v11 = v13;
        }
        uint64_t v14 = *(unsigned int *)(v11 + 8 * v12 - 8);
        int v45 = a1;
        uint64_t v15 = v9 & 3;
        uint64_t v16 = AG::data::_shared_table_bytes + v14;
        unint64_t v17 = *(unsigned int *)(AG::data::_shared_table_bytes + v14 + 12);
        if (v17 > 0x11F)
        {
          int v33 = a1;
          int v39 = v14;
          v41 = v10;
          char v35 = v9;
          uint64_t v31 = AG::data::_shared_table_bytes + v14;
          a1 = AG::Graph::index_of_input_slow((uint64_t)v10, AG::data::_shared_table_bytes + v14, a1 | (unint64_t)(v15 << 40) | 0x700000000);
          LODWORD(v14) = v39;
          uint64_t v10 = v41;
          char v9 = v35;
          uint64_t v5 = a3;
          unint64_t v18 = a1;
          uint64_t v16 = v31;
          LODWORD(a1) = v33;
        }
        else
        {
          if (v17 < 0x20)
          {
LABEL_12:
            unint64_t v18 = -1;
            return AG::Graph::input_value_ref_slow(v10, v14, (const char *)a1, 0, v9, v5, &v44, v18);
          }
          unint64_t v18 = 0;
          unint64_t v19 = v17 >> 5;
          int v20 = (unsigned char *)(*(unsigned int *)(v16 + 16) + AG::data::_shared_table_bytes + 4);
          while (*((_DWORD *)v20 - 1) != a1 || (*v20 & 7) != v15)
          {
            ++v18;
            v20 += 5;
            if (v19 == v18) {
              goto LABEL_12;
            }
          }
        }
        if ((v18 & 0x8000000000000000) == 0)
        {
          uint64_t v24 = *(unsigned int *)(v16 + 16);
          uint64_t v25 = AG::data::_shared_table_bytes;
          if ((a1 & 3) != 0)
          {
            int v40 = v14;
            v42 = v10;
            v38 = v5;
            char v36 = v9;
            uint64_t v32 = *(unsigned int *)(v16 + 16);
            unint64_t v34 = v18;
            uint64_t v30 = AG::data::_shared_table_bytes;
            LODWORD(a1) = AG::AttributeID::resolve_slow((AG::AttributeID *)&v45, (const char *)3);
            uint64_t v25 = v30;
            uint64_t v24 = v32;
            unint64_t v18 = v34;
            char v9 = v36;
            uint64_t v5 = v38;
            uint64_t v26 = v14;
            LODWORD(v14) = v40;
            uint64_t v10 = v42;
          }
          else
          {
            uint64_t v26 = 0;
          }
          uint64_t v27 = AG::data::_shared_table_bytes;
          uint64_t v28 = AG::data::_shared_table_bytes + a1;
          if ((*(_DWORD *)v28 & 0x11) == 0x10)
          {
            *(unsigned char *)(v25 + v24 + 5 * v18 + 4) |= 0x10u;
            uint64_t v29 = (void *)(v27 + *(unsigned int *)(v28 + 8));
            if ((*(unsigned char *)(v28 + 7) & 2) != 0) {
              uint64_t v29 = (void *)*v29;
            }
            return (char *)v29 + v26;
          }
          LODWORD(a1) = v45;
        }
        return AG::Graph::input_value_ref_slow(v10, v14, (const char *)a1, 0, v9, v5, &v44, v18);
      }
    }
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a3, a4, a5, a3, a1 & 0xFFFFFFFC);
  }
  uint64_t v22 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v22) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a3, a4, a5, a3, a1);
  }
  int v23 = *(__n128 **)(v22 + 40);
  char v43 = 0;
  return AG::Graph::value_ref(v23, (const char *)a1, 0, a3, &v43);
}

char *AG::Graph::input_value_ref_slow(__n128 *a1, unsigned int a2, const char *a3, int a4, char a5, AG::swift::metadata *a6, unsigned char *a7, unint64_t a8)
{
  unint64_t v11 = a3;
  int v61 = (int)a3;
  uint64_t v14 = AG::data::_shared_table_bytes + a2;
  if ((a5 & 2) != 0)
  {
    __int16 v37 = a6;
    v38 = a7;
    unint64_t v39 = AG::Graph::index_of_input((uint64_t)a1, AG::data::_shared_table_bytes + a2, a3 | ((unint64_t)(a5 & 1) << 40) | 0x500000000);
    a7 = v38;
    a6 = v37;
    a8 = v39;
  }
  uint64_t v15 = (const char *)a2;
  if (a4) {
    uint64_t v16 = 17;
  }
  else {
    uint64_t v16 = 3;
  }
  if ((a8 & 0x8000000000000000) == 0)
  {
    int v17 = a5 & 1;
    goto LABEL_20;
  }
  if (dword_1EB3D3240 <= (v11 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", (const char *)a2, v11 & 0xFFFFFFFC);
  }
  uint64_t v18 = *(void *)(AG::data::_shared_table_bytes + (v11 & 0xFFFFFE00));
  if (!v18 || *(__n128 **)(v18 + 40) != a1) {
    AG::precondition_failure((AG *)"accessing attribute in a different namespace: %u", (const char *)a2, v11);
  }
  if (*(unsigned char *)v14)
  {
    uint64_t v57 = v14;
    int v20 = v16;
    uint64_t v16 = (uint64_t)a7;
    uint64_t v21 = a6;
    goto LABEL_18;
  }
  if ((v11 & 3) != 0)
  {
    unint64_t v11 = (const char *)a2;
    v52 = a6;
    v53 = a7;
    int v54 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v61, (const char *)v16);
    uint64_t v15 = v11;
    a7 = v53;
    a6 = v52;
    LODWORD(v11) = v54;
    if (a4) {
      goto LABEL_14;
    }
  }
  else if (a4)
  {
LABEL_14:
    uint64_t result = 0;
    if (v11 < 4 || (v11 & 3) != 0) {
      return result;
    }
  }
  uint64_t v57 = v14;
  int v20 = v16;
  uint64_t v16 = (uint64_t)a7;
  uint64_t v21 = a6;
  uint64_t v22 = v15;
  AG::Graph::update_attribute(a1, v11, 0);
  uint64_t v15 = v22;
  LODWORD(v11) = v61;
LABEL_18:
  int v17 = a5 & 1;
  unsigned int v23 = v11;
  uint64_t v24 = v15;
  uint64_t v25 = AG::Graph::add_input((uint64_t)a1, v15, v23, a4 != 0, a5 & 1);
  if (v25 < 0) {
    return 0;
  }
  a8 = v25;
  a6 = v21;
  a7 = (unsigned char *)v16;
  uint64_t v15 = v24;
  LODWORD(v16) = v20;
  uint64_t v14 = v57;
LABEL_20:
  uint64_t v26 = AG::data::_shared_table_bytes + *(unsigned int *)(v14 + 16);
  uint64_t v27 = (unsigned int *)(v26 + 5 * a8);
  *((unsigned char *)v27 + 4) |= (v17 != 0) | 0x10;
  uint64_t v28 = *v27;
  int v60 = v28;
  if ((v28 & 3) != 0)
  {
    v59 = v15;
    int v40 = a6;
    v41 = a7;
    uint64_t v42 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v60, (const char *)(v16 | 8));
    a7 = v41;
    a6 = v40;
    uint64_t v28 = v42;
    uint64_t v29 = v43;
    uint64_t v15 = v59;
    if (a4) {
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v29 = 0;
    if (a4)
    {
LABEL_22:
      if (v28 < 4 || (v28 & 3) != 0) {
        return 0;
      }
      uint64_t v31 = a1;
      uint64_t v32 = (unsigned int *)(AG::data::_shared_table_bytes + v28);
      if ((*v32 & 0x11) == 0x10) {
        goto LABEL_39;
      }
      v56 = a6;
      v58 = v15;
      v55 = a7;
      uint64_t v33 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(v28 & 0xFFFFFE00));
      AG::Graph::update_attribute(v31, v28, 0);
      if ((v33 & 0xFF00000000) != 0)
      {
        int v34 = v33 & 0x7FFFFFFF;
        uint64_t v35 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(v28 & 0xFFFFFE00));
        if ((v35 & 0xFF00000000) == 0 || v34 != v35) {
          return 0;
        }
      }
      goto LABEL_38;
    }
  }
  uint64_t v31 = a1;
  uint64_t v32 = (unsigned int *)(AG::data::_shared_table_bytes + v28);
  if ((*v32 & 0x11) != 0x10)
  {
    v56 = a6;
    v58 = v15;
    v55 = a7;
    AG::Graph::update_attribute(v31, v28, 0);
LABEL_38:
    a6 = v56;
    uint64_t v26 = AG::data::_shared_table_bytes + *(unsigned int *)&v58[AG::data::_shared_table_bytes + 16];
    a7 = v55;
  }
LABEL_39:
  if ((*(unsigned char *)(v26 + 5 * a8 + 4) & 8) != 0) {
    *a7 |= 1u;
  }
  if (a5 & 2) != 0 && (*((unsigned char *)v32 + 7) & 0x20) != 0 && (*(unsigned char *)(*((void *)a6 - 1) + 82))
  {
    *(_DWORD *)v14 |= 8u;
    *a7 |= 2u;
  }
  unint64_t v44 = *v32;
  if (!v29)
  {
    int v45 = *(AG::swift::metadata **)(*(void *)(v31[8].n128_u64[0] + ((v44 >> 5) & 0x7FFFFF8)) + 8);
    if (v45 != a6)
    {
      v48 = a6;
      uint64_t v49 = AG::swift::metadata::name(v45, 0);
      uint64_t v50 = AG::swift::metadata::name(v48, 0);
      AG::precondition_failure((AG *)"invalid value type for attribute: %u (saw %s, expected %s)", v51, v28, v49, v50);
    }
  }
  if ((v44 & 0x10) == 0) {
    AG::precondition_failure((AG *)"attribute being read has no value: %u", v15, v28);
  }
  v46 = (void *)(AG::data::_shared_table_bytes + v32[2]);
  if ((*((unsigned char *)v32 + 7) & 2) != 0) {
    v46 = (void *)*v46;
  }
  uint64_t v47 = v29 - 1;
  if (!v29) {
    uint64_t v47 = 0;
  }
  return (char *)v46 + v47;
}

uint64_t AG::Graph::add_input(uint64_t a1, const char *a2, unsigned int a3, int a4, uint64_t a5)
{
  unsigned int v47 = a3;
  unsigned int v9 = a3;
  if ((a3 & 3) == 0)
  {
    if (a4) {
      goto LABEL_3;
    }
LABEL_6:
    if (v9 <= 3) {
      AG::precondition_failure((AG *)"reading from invalid source attribute: %u", a2, v47);
    }
    goto LABEL_7;
  }
  unsigned int v9 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v47, (const char *)0x10);
  if (!a4) {
    goto LABEL_6;
  }
LABEL_3:
  if (v9 < 4) {
    return -1;
  }
LABEL_7:
  if (v9 == a2) {
    AG::precondition_failure((AG *)"cyclic edge: %u -> %u", a2, a2, a2);
  }
  int v11 = *(_DWORD *)(a1 + 232);
  uint64_t v12 = a2;
  if (v11)
  {
    unsigned int v41 = v11 - 1;
    do
    {
      uint64_t v42 = *(void *)(*(void *)(a1 + 224) + 8 * v41);
      uint64_t v43 = v41;
      (*(void (**)(uint64_t, void, void, uint64_t))(*(void *)v42 + 232))(v42, a2, v47, a5);
      --v41;
    }
    while (v43);
  }
  uint64_t v13 = AG::data::_shared_table_bytes + a2;
  uint64_t v14 = a2 & 0xFFFFFE00;
  uint64_t v15 = *(void *)(AG::data::_shared_table_bytes + v14);
  if (v15) {
    uint64_t v15 = *(void *)(v15 + 48);
  }
  uint64_t v16 = *(void *)(AG::data::_shared_table_bytes + (v9 & 0xFFFFFE00));
  if (v16) {
    uint64_t v17 = *(void *)(v16 + 48);
  }
  else {
    uint64_t v17 = 0;
  }
  char v18 = *(unsigned char *)(v13 + 7);
  if (v15 != v17)
  {
    v18 |= 4u;
    *(unsigned char *)(v13 + 7) = v18;
  }
  unsigned int v19 = v47;
  int v20 = (_DWORD *)(v13 + 12);
  char v21 = *(unsigned char *)v13;
  char v22 = a5 & 5 | (8 * (*(unsigned char *)v13 & 1));
  if ((v18 & 8) != 0)
  {
    unint64_t v10 = (unint64_t)*v20 >> 5;
    uint64_t v29 = AG::data::_shared_table_bytes;
    if ((*v20 & 0x1F) == 0 || *v20 >> 5 >> *v20 != 0)
    {
      AG::data::vector<AG::InputEdge>::reserve_slow((unsigned int *)(v13 + 12), *(AG::data::zone **)(AG::data::_shared_table_bytes + v14), v10 + 1);
      uint64_t v29 = AG::data::_shared_table_bytes;
    }
    uint64_t v31 = v29 + *(unsigned int *)(v13 + 16) + 5 * v10;
    *(_DWORD *)uint64_t v31 = v19;
    *(unsigned char *)(v31 + 4) = v22;
    *(_DWORD *)(v13 + 12) += 32;
    *(unsigned char *)(v13 + 7) |= 8u;
  }
  else
  {
    uint64_t v23 = AG::data::_shared_table_bytes;
    unint64_t v25 = *(unsigned int *)(v13 + 12);
    uint64_t v24 = *(unsigned int *)(v13 + 16);
    uint64_t v26 = AG::data::_shared_table_bytes + v24;
    unint64_t v27 = v25 >> 5;
    if (v25 >= 0x20)
    {
      uint64_t v28 = (char *)(AG::data::_shared_table_bytes + v24);
      unint64_t v32 = v25 >> 5;
      do
      {
        unint64_t v33 = v32 >> 1;
        int v34 = (unsigned int *)&v28[5 * (v32 >> 1)];
        unsigned int v36 = *v34;
        uint64_t v35 = (char *)v34 + 5;
        v32 += ~(v32 >> 1);
        if (v36 < v47) {
          uint64_t v28 = v35;
        }
        else {
          unint64_t v32 = v33;
        }
      }
      while (v32);
    }
    else
    {
      uint64_t v28 = (char *)(v26 + 5 * (v25 >> 5));
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * (void)&v28[-v26];
    if ((v25 & 0x1F) == 0 || v27 >> v25)
    {
      AG::data::vector<AG::InputEdge>::reserve_slow((unsigned int *)(v13 + 12), *(AG::data::zone **)(AG::data::_shared_table_bytes + v14), v27 + 1);
      uint64_t v24 = *(unsigned int *)(v13 + 16);
      uint64_t v23 = AG::data::_shared_table_bytes;
    }
    uint64_t v37 = v23 + v24;
    if (v27 > v10) {
      memmove((void *)(v37 + 5 * v10 + 5), (const void *)(v37 + 5 * v10), 5 * (v27 - v10));
    }
    uint64_t v38 = v37 + 5 * v10;
    *(_DWORD *)uint64_t v38 = v19;
    *(unsigned char *)(v38 + 4) = v22;
    *v20 += 32;
  }
  AG::Graph::add_input_dependencies(a1, v12, v47);
  if ((*(unsigned char *)v13 & 0xC0) != 0) {
    AG::Graph::reset_update(a1, v12);
  }
  if (8 * (v21 & 1))
  {
    int v39 = *(_DWORD *)(a1 + 232);
    if (v39)
    {
      unsigned int v44 = v39 - 1;
      do
      {
        uint64_t v45 = v44;
        uint64_t v46 = *(void *)(*(void *)(a1 + 224) + 8 * v44);
        (*(void (**)(uint64_t, uint64_t, unint64_t, uint64_t))(*(void *)v46 + 248))(v46, v12, v10, 1);
        --v44;
      }
      while (v45);
    }
  }
  return v10;
}

void AG::Graph::add_input_dependencies(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v5 = a3;
  if ((a3 & 3) != 0) {
    a3 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v5, (const char *)4);
  }
  if ((a3 & 3) != 0)
  {
    if ((a3 & 3) == 1) {
      AG::Graph::add_output_edge<AG::Node>(a1, a3 & 0xFFFFFFFC, a2);
    }
  }
  else
  {
    AG::Graph::add_output_edge<AG::Node>(a1, a3, a2);
  }
  AG::Graph::update_main_refs(a1, a2);
}

void AG::Graph::update_main_refs(uint64_t a1, unsigned int a2)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  long long v59 = 0u;
  unint64_t v60 = 64;
  if ((a2 & 3) == 1)
  {
    uint64_t v11 = AG::data::_shared_table_bytes + (a2 & 0xFFFFFFFC);
    if (*(unsigned char *)(v11 + 8))
    {
      uint64_t v12 = *(unsigned int *)(v11 + 24);
      unint64_t v13 = (unint64_t)*(unsigned int *)(v11 + 20) >> 5;
      __dst[0] = AG::data::_shared_table_bytes + v12;
      __dst[1] = v13;
      uint64_t v14 = 1;
LABEL_24:
      *((void *)&v59 + 1) = v14;
    }
  }
  else
  {
    if ((a2 & 3) != 0) {
      return;
    }
    int v4 = (unsigned int *)(AG::data::_shared_table_bytes + a2);
    unint64_t v5 = *v4;
    uint64_t v6 = *(void *)(*(void *)(a1 + 128) + ((v5 >> 5) & 0x7FFFFF8));
    if ((*(unsigned char *)(*(void *)(*(void *)(v6 + 8) - 8) + 82) & 1) != 0 && (*(unsigned char *)(v6 + 40) & 0x20) == 0)
    {
      if ((v5 & 8) != 0)
      {
LABEL_63:
        char v56 = *((unsigned char *)v4 + 7);
        uint64_t v16 = (char *)v4 + 7;
        char v15 = v56;
        if ((v56 & 0x20) != 0) {
          goto LABEL_25;
        }
        char v18 = 32;
        goto LABEL_19;
      }
      unint64_t v7 = v4[3];
      if (v7 >= 0x20)
      {
        unint64_t v8 = (unsigned int *)(AG::data::_shared_table_bytes + v4[4]);
        uint64_t v9 = 5 * (v7 >> 5);
        do
        {
          unsigned int v57 = *v8;
          uint64_t v10 = v57;
          if ((v57 & 3) != 0) {
            uint64_t v10 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v57, (const char *)0x10);
          }
          if ((v10 & 3) == 0 && (*(unsigned char *)(AG::data::_shared_table_bytes + v10 + 7) & 0x20) != 0) {
            goto LABEL_63;
          }
          unint64_t v8 = (unsigned int *)((char *)v8 + 5);
          v9 -= 5;
        }
        while (v9);
      }
    }
    char v17 = *((unsigned char *)v4 + 7);
    uint64_t v16 = (char *)v4 + 7;
    char v15 = v17;
    if ((v17 & 0x20) != 0)
    {
      char v18 = 0;
LABEL_19:
      uint64_t v19 = a2;
      unsigned char *v16 = v15 & 0xDF | v18;
      uint64_t v20 = AG::data::_shared_table_bytes;
      unint64_t v21 = *(unsigned int *)(AG::data::_shared_table_bytes + v19 + 20);
      uint64_t v22 = *(unsigned int *)(AG::data::_shared_table_bytes + v19 + 24);
      uint64_t v23 = *((void *)&v59 + 1);
      if (v60 < *((void *)&v59 + 1) + 1)
      {
        AG::vector<AG::ConstOutputEdgeArrayRef,64ul,unsigned long>::reserve_slow(__dst, *((void *)&v59 + 1) + 1);
        uint64_t v23 = *((void *)&v59 + 1);
      }
      uint64_t v24 = (void *)v59;
      if (!(void)v59) {
        uint64_t v24 = __dst;
      }
      unint64_t v25 = &v24[2 * v23];
      *unint64_t v25 = v20 + v22;
      v25[1] = v21 >> 5;
      uint64_t v14 = *((void *)&v59 + 1) + 1;
      goto LABEL_24;
    }
  }
LABEL_25:
  uint64_t v26 = *((void *)&v59 + 1);
  if (*((void *)&v59 + 1))
  {
    while (1)
    {
      unint64_t v27 = (void *)v59;
      if (!(void)v59) {
        unint64_t v27 = __dst;
      }
      --v26;
      uint64_t v28 = &v27[2 * v26];
      uint64_t v30 = *v28;
      uint64_t v29 = v28[1];
      *((void *)&v59 + 1) = v26;
      unint64_t v31 = v29 - 1;
      if (v29 - 1 >= 0) {
        break;
      }
LABEL_59:
      if (!v26) {
        goto LABEL_60;
      }
    }
    while (1)
    {
      while (1)
      {
        uint64_t v32 = *(unsigned int *)(v30 + 4 * v31);
        if ((*(_DWORD *)(v30 + 4 * v31) & 3) != 1) {
          break;
        }
        uint64_t v40 = AG::data::_shared_table_bytes;
        uint64_t v41 = AG::data::_shared_table_bytes + (v32 & 0xFFFFFFFC);
        if ((*(unsigned char *)(v41 + 8) & 1) == 0) {
          goto LABEL_54;
        }
LABEL_47:
        uint64_t v46 = (unsigned int *)(v41 + 20);
        unsigned int v47 = (unsigned int *)(v41 + 24);
        unint64_t v48 = *v46;
        if (v48 < 0x20) {
          goto LABEL_54;
        }
        uint64_t v49 = *v47;
        uint64_t v50 = v40 + v49;
        unint64_t v51 = v48 >> 5;
        if (v31)
        {
          uint64_t v52 = *((void *)&v59 + 1);
          if (v60 < *((void *)&v59 + 1) + 1)
          {
            AG::vector<AG::ConstOutputEdgeArrayRef,64ul,unsigned long>::reserve_slow(__dst, *((void *)&v59 + 1) + 1);
            uint64_t v52 = *((void *)&v59 + 1);
          }
          v53 = (void *)v59;
          if (!(void)v59) {
            v53 = __dst;
          }
          int v54 = &v53[2 * v52];
          *int v54 = v50;
          v54[1] = v51;
          ++*((void *)&v59 + 1);
          goto LABEL_54;
        }
        unint64_t v31 = v51 - 1;
        uint64_t v30 = v40 + v49;
      }
      if ((v32 & 3) == 0)
      {
        uint64_t v33 = AG::data::_shared_table_bytes + v32;
        unint64_t v34 = *(unsigned int *)(AG::data::_shared_table_bytes + v32);
        uint64_t v35 = *(void *)(*(void *)(a1 + 128) + ((v34 >> 5) & 0x7FFFFF8));
        if ((*(unsigned char *)(*(void *)(*(void *)(v35 + 8) - 8) + 82) & 1) != 0 && (*(unsigned char *)(v35 + 40) & 0x20) == 0)
        {
          if ((v34 & 8) != 0) {
            goto LABEL_56;
          }
          unint64_t v36 = *(unsigned int *)(v33 + 12);
          if (v36 >= 0x20)
          {
            uint64_t v37 = (unsigned int *)(AG::data::_shared_table_bytes + *(unsigned int *)(v33 + 16));
            uint64_t v38 = 5 * (v36 >> 5);
            while (1)
            {
              unsigned int v57 = *v37;
              uint64_t v39 = v57;
              if ((v57 & 3) != 0) {
                uint64_t v39 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v57, (const char *)0x10);
              }
              if ((v39 & 3) == 0 && (*(unsigned char *)(AG::data::_shared_table_bytes + v39 + 7) & 0x20) != 0) {
                break;
              }
              uint64_t v37 = (unsigned int *)((char *)v37 + 5);
              v38 -= 5;
              if (!v38) {
                goto LABEL_44;
              }
            }
LABEL_56:
            char v55 = *(unsigned char *)(v33 + 7);
            uint64_t v43 = (unsigned char *)(v33 + 7);
            char v42 = v55;
            if ((v55 & 0x20) != 0) {
              goto LABEL_54;
            }
            char v45 = 32;
LABEL_46:
            *uint64_t v43 = v42 & 0xDF | v45;
            uint64_t v40 = AG::data::_shared_table_bytes;
            uint64_t v41 = AG::data::_shared_table_bytes + v32;
            goto LABEL_47;
          }
        }
LABEL_44:
        char v44 = *(unsigned char *)(v33 + 7);
        uint64_t v43 = (unsigned char *)(v33 + 7);
        char v42 = v44;
        if ((v44 & 0x20) != 0)
        {
          char v45 = 0;
          goto LABEL_46;
        }
      }
LABEL_54:
      if ((--v31 & 0x8000000000000000) != 0)
      {
        uint64_t v26 = *((void *)&v59 + 1);
        goto LABEL_59;
      }
    }
  }
LABEL_60:
  if ((void)v59) {
    free((void *)v59);
  }
}

void sub_1AF90557C(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)(v1 + 1024);
  if (v3) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned int *AG::Graph::add_output_edge<AG::Node>(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v4 = AG::data::_shared_table_bytes;
  uint64_t v5 = AG::data::_shared_table_bytes + a2;
  unsigned int v7 = *(_DWORD *)(v5 + 20);
  uint64_t result = (unsigned int *)(v5 + 20);
  unint64_t v8 = (unint64_t)v7 >> 5;
  unsigned int v9 = v8 >> v7;
  if ((v7 & 0x1F) == 0 || v9 != 0)
  {
    uint64_t result = (unsigned int *)AG::data::vector<AG::OutputEdge>::reserve_slow(result, *(AG::data::zone **)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00)), (int)v8 + 1);
    uint64_t v4 = AG::data::_shared_table_bytes;
  }
  *(_DWORD *)(v4 + *(unsigned int *)(v5 + 24) + 4 * v8) = a3;
  *(_DWORD *)(v5 + 20) += 32;
  return result;
}

void AG::Graph::reset_update(uint64_t a1, int a2)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  for (uint64_t i = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2); i; uint64_t i = v4[2])
  {
    uint64_t v4 = (void *)(i & 0xFFFFFFFFFFFFFFFELL);
    uint64_t v5 = v4 + 4;
    uint64_t v6 = v4[13];
    if (v4[12]) {
      uint64_t v5 = (void *)v4[12];
    }
    if (v6)
    {
      uint64_t v7 = 8 * v6;
      unint64_t v8 = (_DWORD *)v5 + 1;
      do
      {
        if (*(v8 - 1) == a2) {
          *v8 &= 0xFu;
        }
        v8 += 2;
        v7 -= 8;
      }
      while (v7);
    }
  }
}

uint64_t AGGraphSetOutputValue(unsigned __int8 *a1, AG::LayoutDescriptor *this)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  uint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2);
  if ((v3 & 1) != 0 || (uint64_t v4 = (uint64_t *)(v3 & 0xFFFFFFFFFFFFFFFELL), (v3 & 0xFFFFFFFFFFFFFFFELL) == 0)) {
    AG::precondition_failure((AG *)"no attribute updating", (const char *)this);
  }
  uint64_t v5 = v4 + 4;
  if (v4[12]) {
    uint64_t v5 = (void *)v4[12];
  }
  uint64_t v6 = LODWORD(v5[v4[13] - 1]);
  uint64_t v7 = AG::data::_shared_table_bytes + v6;
  unsigned int v8 = *(_DWORD *)(AG::data::_shared_table_bytes + v6);
  if ((v8 & 0xC0) == 0) {
    AG::precondition_failure((AG *)"writing attribute that is not evaluating: %u", (const char *)this, v6);
  }
  unsigned int v9 = this;
  uint64_t v11 = *v4;
  int v12 = *(_DWORD *)(*v4 + 232);
  if (v12)
  {
    unsigned int v33 = v12 - 1;
    do
    {
      uint64_t v34 = v33;
      uint64_t v35 = *(void *)(*(void *)(v11 + 224) + 8 * v33);
      (*(void (**)(uint64_t, uint64_t, unsigned __int8 *))(*(void *)v35 + 272))(v35, v6, a1);
      --v33;
    }
    while (v34);
    unsigned int v8 = *(_DWORD *)v7;
  }
  uint64_t v13 = *(void *)(*(void *)(v11 + 128) + 8 * (v8 >> 8));
  uint64_t v14 = *(AG::swift::metadata **)(v13 + 8);
  if (v14 != v9)
  {
    uint64_t v36 = AG::swift::metadata::name(v14, 0);
    uint64_t v37 = AG::swift::metadata::name(v9, 0);
    AG::precondition_failure((AG *)"invalid value type for attribute: %u (saw %s, expected %s)", v38, v6, v36, v37);
  }
  if ((v8 & 0x10) != 0)
  {
    char v15 = (AG::LayoutDescriptor *)(AG::data::_shared_table_bytes + *(unsigned int *)(v7 + 8));
    if ((*(unsigned char *)(v7 + 7) & 2) != 0) {
      char v15 = *(AG::LayoutDescriptor **)v15;
    }
    int v16 = *(_DWORD *)(v13 + 40);
    char v17 = (unint64_t *)(v16 & 3 | 0x80000100);
    char v18 = *(AG::LayoutDescriptor ***)(v13 + 48);
    if (!v18)
    {
      char v18 = (AG::LayoutDescriptor **)AG::LayoutDescriptor::fetch(v9, (const AG::swift::metadata *)(v16 & 3 | 0x80000100), 0);
      *(void *)(v13 + 48) = v18;
    }
    if (v18 == (AG::LayoutDescriptor **)1) {
      char v18 = 0;
    }
    uint64_t v19 = (uint64_t *)((char *)v9 - 8);
    uint64_t result = AG::LayoutDescriptor::compare(v18, v15, a1, *(char **)(*((void *)v9 - 1) + 64), v17);
    if ((result & 1) == 0)
    {
      if (*(_DWORD *)(v11 + 232))
      {
        AG::Graph::mark_changed(v11);
      }
      else
      {
        uint64_t v44 = (uint64_t)v15;
        uint64_t v45 = (uint64_t)a1;
        uint64_t v43 = v9;
        unint64_t v21 = *(unsigned int *)(AG::data::_shared_table_bytes + v6 + 20);
        if (v21 < 0x20)
        {
LABEL_33:
          ++*(void *)(v11 + 464);
          unsigned int v9 = v43;
          char v15 = (AG::LayoutDescriptor *)v44;
          a1 = (unsigned __int8 *)v45;
        }
        else
        {
          uint64_t v22 = 0;
          uint64_t v23 = AG::data::_shared_table_bytes + *(unsigned int *)(AG::data::_shared_table_bytes + v6 + 24);
          unint64_t v24 = v21 >> 5;
          while (1)
          {
            uint64_t v25 = *(unsigned int *)(v23 + 4 * v22);
            if ((v25 & 3) != 0) {
              break;
            }
            uint64_t v26 = AG::data::_shared_table_bytes + v25;
            unint64_t v27 = *(unsigned int *)(AG::data::_shared_table_bytes + v25 + 12);
            if (v27 >= 0x20)
            {
              uint64_t v28 = (unsigned __int8 *)(AG::data::_shared_table_bytes + *(unsigned int *)(v26 + 16) + 4);
              uint64_t v29 = 5 * (v27 >> 5);
              while (1)
              {
                int v30 = *((_DWORD *)v28 - 1);
                int v46 = v30;
                if ((v30 & 3) != 0) {
                  int v30 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v46, 0);
                }
                if (v30 == v6)
                {
                  char v31 = *v28;
                  if ((*v28 & 8) == 0)
                  {
                    if ((*(v28 - 4) & 3) == 0) {
                      goto LABEL_31;
                    }
                    unint64_t v42 = v42 & 0xFFFFFF0000000000 | *((unsigned int *)v28 - 1) | ((unint64_t)*v28 << 32);
                    if ((AG::Graph::compare_edge_values(v11, *((_DWORD *)v28 - 1), v13, v44, v45) & 1) == 0) {
                      break;
                    }
                  }
                }
                v28 += 5;
                v29 -= 5;
                if (!v29) {
                  goto LABEL_32;
                }
              }
              char v31 = *v28;
LABEL_31:
              *uint64_t v28 = v31 | 8;
            }
LABEL_32:
            if (++v22 == v24) {
              goto LABEL_33;
            }
          }
          char v15 = (AG::LayoutDescriptor *)v44;
          a1 = (unsigned __int8 *)v45;
          AG::Graph::mark_changed(v11);
          unsigned int v9 = v43;
        }
      }
      if (*v19) {
        uint64_t v32 = *v19;
      }
      else {
        uint64_t v32 = 0;
      }
      return (*(uint64_t (**)(AG::LayoutDescriptor *, unsigned __int8 *, AG::swift::metadata *))(v32 + 24))(v15, a1, v9);
    }
  }
  else
  {
    AG::Node::allocate_value((unsigned int *)v7, (AG::Graph *)v11, *(AG::data::zone **)(AG::data::_shared_table_bytes + (v6 & 0xFFFFFE00)));
    *(_DWORD *)v7 |= 0x10u;
    AG::Graph::mark_changed(v11, v6, 0, 0, 0);
    uint64_t v39 = (void *)(AG::data::_shared_table_bytes + *(unsigned int *)(v7 + 8));
    if ((*(unsigned char *)(v7 + 7) & 2) != 0) {
      uint64_t v39 = (void *)*v39;
    }
    if (*((void *)v9 - 1)) {
      uint64_t v40 = *((void *)v9 - 1);
    }
    else {
      uint64_t v40 = 0;
    }
    uint64_t v41 = *(uint64_t (**)(void *, unsigned __int8 *, AG::swift::metadata *))(v40 + 16);
    return v41(v39, a1, v9);
  }
  return result;
}

uint64_t AG::AttributeID::resolve_slow(AG::AttributeID *this, const char *a2)
{
  char v2 = (char)a2;
  unsigned int v4 = *(_DWORD *)this;
  int v5 = *(_DWORD *)this & 3;
  if (v5 == 1)
  {
    uint64_t v6 = 0;
    do
    {
      if (v6) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = (v2 & 8) == 0;
      }
      if (!v7) {
        uint64_t v6 = 1;
      }
      uint64_t v8 = AG::data::_shared_table_bytes + (v4 & 0xFFFFFFFC);
      if (*(unsigned char *)(v8 + 8))
      {
        if ((v2 & 4) != 0) {
          return v4;
        }
        if (v2)
        {
          a2 = (const char *)*(unsigned int *)(v8 + 16);
          if (a2)
          {
            uint64_t v9 = *(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00));
            if (v9) {
              AG::Graph::update_attribute(*(__n128 **)(v9 + 40), a2, 0);
            }
          }
        }
      }
      if ((v2 & 0x10) != 0)
      {
        uint64_t v10 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(*(_DWORD *)v8 & 0xFFFFFE00));
        if ((v10 & 0xFF00000000) == 0 || *(_DWORD *)(v8 + 4) != (v10 & 0x7FFFFFFF))
        {
          if ((v2 & 2) != 0) {
            AG::precondition_failure((AG *)"invalid indirect ref: %u", a2, *(unsigned int *)this);
          }
          return 2;
        }
      }
      v6 += (unint64_t)*(unsigned int *)(v8 + 8) >> 2;
      unsigned int v4 = *(_DWORD *)v8;
      int v5 = *(_DWORD *)v8 & 3;
    }
    while (v5 == 1);
    if ((v2 & 2) != 0) {
      goto LABEL_24;
    }
  }
  else if ((a2 & 2) != 0)
  {
LABEL_24:
    if (v5) {
      AG::precondition_failure((AG *)"invalid attribute id: %u", a2, *(unsigned int *)this);
    }
  }
  return v4;
}

uint64_t AG::data::table::raw_page_seed(uint64_t a1, const char *a2)
{
  unsigned int v2 = a2;
  if (*(_DWORD *)(a1 + 24) <= a2) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a2);
  }
  unsigned int v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  unsigned int v5 = (v2 >> 9) - 1;
  if (v5 >> 6 < *(_DWORD *)(a1 + 88) && ((*(void *)(*(void *)(a1 + 80) + 8 * (v5 >> 6)) >> v5) & 1) != 0)
  {
    unsigned int v6 = *(_DWORD *)(*(void *)(*(void *)a1 + v2) + 24) & 0xFFFFFF00;
    int v7 = *(_DWORD *)(*(void *)(*(void *)a1 + v2) + 24);
    uint64_t v8 = 0x100000000;
  }
  else
  {
    uint64_t v8 = 0;
    int v7 = 0;
    unsigned int v6 = 0;
  }
  os_unfair_lock_unlock(v4);
  return v8 | v6 | v7;
}

uint64_t AG::LayoutDescriptor::compare(AG::LayoutDescriptor **this, AG::LayoutDescriptor *a2, unsigned __int8 *a3, char *a4, unint64_t *a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2 == (AG::LayoutDescriptor *)a3) {
    return 1;
  }
  if (this)
  {
    *(_OWORD *)int v12 = 0u;
    uint64_t v13 = 8;
    uint64_t v5 = AG::LayoutDescriptor::Compare::operator()(v11, this, (uint64_t)a2, (uint64_t)a3, 0, (uint64_t)a4, a5);
    unsigned int v6 = v12[0];
    if (v12[0]) {
      int v7 = (void **)v12[0];
    }
    else {
      int v7 = v11;
    }
    if (v12[1])
    {
      uint64_t v8 = 0;
      do
      {
        AG::LayoutDescriptor::Compare::Enum::~Enum((AG::LayoutDescriptor::Compare::Enum *)v7);
        ++v8;
        int v7 = (void **)(v9 + 64);
      }
      while (v8 < v12[1]);
      unsigned int v6 = v12[0];
    }
    if (v6) {
      free(v6);
    }
    return v5;
  }
  return AG::LayoutDescriptor::compare_bytes_top_level(a2, a3, a4, (int)a5, a5);
}

void sub_1AF905E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t AG::LayoutDescriptor::Compare::operator()(void *a1, AG::LayoutDescriptor **a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, unsigned int a7)
{
  unsigned int v94 = a7;
  uint64_t v95 = a3;
  uint64_t v96 = a4;
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = a1[65];
  v98 = a1;
  unint64_t v99 = v7;
  if (a6 == -1) {
    unint64_t v8 = -1;
  }
  else {
    unint64_t v8 = (unint64_t)a5 + a6;
  }
  uint64_t v9 = 1;
  if (v8 <= (unint64_t)a5) {
    goto LABEL_95;
  }
  unint64_t v10 = (unint64_t)a5;
  uint64_t v11 = a2;
  int v12 = a1;
  unsigned int v89 = v94 & 0x7FFFFFFF;
  uint64_t v13 = a2;
  BOOL v93 = ((v94 >> 8) & 1) == 0;
  v90 = a1;
  while (1)
  {
    int v15 = *(unsigned __int8 *)v13;
    uint64_t v13 = (AG::LayoutDescriptor **)((char *)v13 + 1);
    int v14 = v15;
    if ((v15 - 64) >= 0x40) {
      break;
    }
    v10 += (v14 & 0x3F) + 1;
LABEL_8:
    uint64_t v11 = v13;
    if (v10 >= v8)
    {
      uint64_t v9 = 1;
      goto LABEL_95;
    }
  }
  uint64_t v9 = 1;
  switch(v14)
  {
    case 0:
      goto LABEL_95;
    case 1:
      v53 = *(AG::LayoutDescriptor **)((char *)v11 + 1);
      uint64_t v13 = (AG::LayoutDescriptor **)((char *)v11 + 17);
      unint64_t v54 = *(void *)(*((void *)v53 - 1) + 64) + v10;
      if (v54 <= v8)
      {
        uint64_t v55 = AGDispatchEquatable();
        if ((v55 & 1) == 0)
        {
LABEL_103:
          AG::LayoutDescriptor::Compare::failed(v55, v94, v95, v96, v10, *(void *)(*((void *)v53 - 1) + 64), (uint64_t)v53);
          goto LABEL_105;
        }
      }
      else
      {
        uint64_t v55 = AG::LayoutDescriptor::compare_bytes((AG::LayoutDescriptor *)(v95 + v10), (void *)(v96 + v10), (char *)(v8 - v10), 0, a5);
        if ((v55 & 1) == 0) {
          goto LABEL_103;
        }
      }
      unint64_t v10 = v54;
      goto LABEL_8;
    case 2:
      v53 = *(AG::LayoutDescriptor **)((char *)v11 + 1);
      v97 = *(AG::LayoutDescriptor **)((char *)v11 + 9);
      uint64_t v56 = *(void *)(*((void *)v53 - 1) + 64);
      unsigned int v57 = (void *)v12[64];
      if (!v57) {
        unsigned int v57 = v12;
      }
      uint64_t v55 = AG::LayoutDescriptor::compare_indirect(&v97, v57[8 * v12[65] - 8], v53, v89, (const void *)(v95 + v10), (const void *)(v96 + v10));
      *(AG::LayoutDescriptor **)((char *)v11 + 9) = v97;
      if (!v55) {
        goto LABEL_103;
      }
      uint64_t v13 = (AG::LayoutDescriptor **)((char *)v11 + 17);
      v10 += v56;
      goto LABEL_8;
    case 3:
      v58 = *v13;
      uint64_t v59 = *(void *)(*((void *)*v13 - 1) + 64);
      uint64_t v60 = AG::LayoutDescriptor::compare_existential_values(v58, (const AG::swift::existential_type_metadata *)(v95 + v10), (unsigned __int8 *)(v96 + v10), (const unsigned __int8 *)v89);
      if (v60)
      {
        v10 += v59;
        uint64_t v13 = (AG::LayoutDescriptor **)((char *)v11 + 9);
        goto LABEL_8;
      }
      AG::LayoutDescriptor::Compare::failed(v60, v94, v95, v96, v10, *(void *)(*((void *)v58 - 1) + 64), (uint64_t)v58);
LABEL_105:
      uint64_t v9 = 0;
LABEL_95:
      v81 = v98;
      unint64_t v82 = v99;
      while (1)
      {
        unint64_t v83 = v81[65];
        if (v83 <= v82) {
          break;
        }
        unint64_t v84 = v83 - 1;
        v81[65] = v84;
        v85 = (void *)v81[64];
        if (!v85) {
          v85 = v81;
        }
        AG::LayoutDescriptor::Compare::Enum::~Enum((AG::LayoutDescriptor::Compare::Enum *)&v85[8 * v84]);
      }
      return v9;
    case 4:
    case 5:
      char v17 = *(AG::LayoutDescriptor **)(v95 + v10);
      char v18 = *(const unsigned __int8 **)(v96 + v10);
      if (v17 != (AG::LayoutDescriptor *)v18)
      {
        uint64_t v19 = AG::LayoutDescriptor::compare_heap_objects(v17, v18, (const void *)v89, v14 == 5);
        if ((v19 & 1) == 0)
        {
          AG::LayoutDescriptor::Compare::failed(v19, v94, v95, v96, v10, 8, 0);
          goto LABEL_105;
        }
      }
      v10 += 8;
      goto LABEL_8;
    case 6:
      unint64_t v23 = 0;
      int v72 = 0;
      unint64_t v24 = *(char **)((char *)v11 + 1);
      uint64_t v13 = (AG::LayoutDescriptor **)((char *)v11 + 9);
      do
      {
        char v73 = *(unsigned char *)v13;
        uint64_t v13 = (AG::LayoutDescriptor **)((char *)v13 + 1);
        v23 |= (unint64_t)(v73 & 0x7F) << v72;
        v72 += 7;
      }
      while (v73 < 0);
      goto LABEL_81;
    case 7:
      unint64_t v23 = *(unsigned __int16 *)((char *)v11 + 5);
      uint64_t v13 = (AG::LayoutDescriptor **)((char *)v11 + 7);
      unint64_t v24 = &AG::LayoutDescriptor::base_address[*(int *)((char *)v11 + 1)];
LABEL_81:
      if (v23 >= v8 - v10) {
        unint64_t v21 = v8 - v10;
      }
      else {
        unint64_t v21 = v23;
      }
      if (AG::LayoutDescriptor::Compare::operator()(v12, v24, v95, v96, v10, v21, v94)) {
        goto LABEL_85;
      }
      goto LABEL_105;
    case 8:
      int v16 = 0;
      int v25 = 0;
      do
      {
        char v26 = *(unsigned char *)v13;
        uint64_t v13 = (AG::LayoutDescriptor **)((char *)v13 + 1);
        v16 |= (v26 & 0x7F) << v25;
        v25 += 7;
      }
      while (v26 < 0);
      goto LABEL_25;
    case 9:
    case 10:
    case 11:
      int v16 = v14 - 9;
LABEL_25:
      uint64_t v28 = (uint64_t)*v13++;
      uint64_t v27 = v28;
      uint64_t v30 = v28 - 8;
      uint64_t v29 = *(void *)(v28 - 8);
      if (v29) {
        uint64_t v31 = v29;
      }
      else {
        uint64_t v31 = 0;
      }
      if (*(void *)(v31 + 88)) {
        uint64_t v32 = *(uint64_t (**)(unint64_t))(v31 + 88);
      }
      else {
        uint64_t v32 = 0;
      }
      unsigned int v33 = (unsigned char *)(v96 + v10);
      uint64_t v34 = v27;
      int v35 = v32(v96 + v10);
      uint64_t v36 = v95 + v10;
      uint64_t v37 = ((uint64_t (*)(unint64_t, uint64_t))v32)(v95 + v10, v34);
      uint64_t v92 = v34;
      if (v35 != v37)
      {
        AG::LayoutDescriptor::Compare::failed(v37, v94, v95, v96, v10, *(void *)(*(void *)(v92 - 8) + 64), v92);
        goto LABEL_105;
      }
      if (v93)
      {
        size_t v38 = *(void *)(*(void *)v30 + 64);
        int v12 = v90;
        if (v38 <= 0x1000)
        {
          MEMORY[0x1F4188790](v37);
          unint64_t v41 = (v38 + 15) & 0xFFFFFFFFFFFFFFF0;
          v91 = &v88[-v41];
          bzero(&v88[-v41], v38);
          MEMORY[0x1F4188790](v42);
          uint64_t v39 = &v88[-v41];
          bzero(v39, v38);
          char v40 = 0;
        }
        else
        {
          v91 = malloc_type_malloc(v38, 0x100004077774924uLL);
          uint64_t v39 = malloc_type_malloc(v38, 0x100004077774924uLL);
          char v40 = 1;
        }
      }
      else
      {
        char v40 = 0;
        v91 = v33;
        uint64_t v39 = (unsigned char *)v36;
        int v12 = v90;
      }
      uint64_t v43 = v12[65];
      if (v12[66] < (unint64_t)(v43 + 1))
      {
        AG::vector<AG::LayoutDescriptor::Compare::Enum,8ul,unsigned long>::reserve_slow(v12, v43 + 1);
        uint64_t v43 = v12[65];
      }
      uint64_t v44 = (void *)v12[64];
      if (!v44) {
        uint64_t v44 = v12;
      }
      char v87 = v40;
      BOOL v45 = v93;
      AG::LayoutDescriptor::Compare::Enum::Enum(&v44[8 * v43], v92, v93, v35, v10, (uint64_t)v33, v36, (uint64_t)v91, (uint64_t)v39, v87);
      uint64_t v46 = v12[65];
      v12[65] = v46 + 1;
      unsigned int v47 = (void *)v12[64];
      if (!v47) {
        unsigned int v47 = v12;
      }
      unint64_t v48 = &v47[8 * v46 + 4];
      uint64_t v49 = v48[1] - v10;
      uint64_t v50 = *v48 - v10;
      uint64_t v51 = v96;
      if (v45) {
        uint64_t v51 = v50;
      }
      uint64_t v52 = v95;
      if (v45) {
        uint64_t v52 = v49;
      }
      uint64_t v95 = v52;
      uint64_t v96 = v51;
LABEL_59:
      v63 = (void *)v12[64];
      if (!v63) {
        v63 = v12;
      }
      if (v16 != LODWORD(v63[8 * v12[65] - 2]))
      {
        int v64 = 0;
        v65 = v13;
        while (1)
        {
          uint64_t v13 = v65;
          int v66 = *(unsigned __int8 *)v65;
          v65 = (AG::LayoutDescriptor **)((char *)v65 + 1);
          int v67 = v64;
          uint64_t v68 = 1;
          switch(v66)
          {
            case 0:
              goto LABEL_8;
            case 1:
            case 2:
              uint64_t v68 = 9;
              goto LABEL_69;
            case 3:
LABEL_69:
              v65 = (AG::LayoutDescriptor **)((char *)v13 + v68 + 8);
              continue;
            case 6:
              v65 = (AG::LayoutDescriptor **)((char *)v13 + 9);
              do
              {
                int v71 = *(char *)v65;
                v65 = (AG::LayoutDescriptor **)((char *)v65 + 1);
              }
              while (v71 < 0);
              continue;
            case 7:
              v65 = (AG::LayoutDescriptor **)((char *)v13 + 7);
              continue;
            case 8:
              do
              {
                int v69 = *((char *)v13 + 1);
                uint64_t v13 = (AG::LayoutDescriptor **)((char *)v13 + 1);
              }
              while (v69 < 0);
              goto LABEL_67;
            case 9:
            case 10:
            case 11:
LABEL_67:
              v65 = (AG::LayoutDescriptor **)((char *)v13 + 9);
              ++v64;
              continue;
            case 12:
              if (!v64) {
                goto LABEL_8;
              }
              do
              {
                int v70 = *(char *)v65;
                v65 = (AG::LayoutDescriptor **)((char *)v65 + 1);
              }
              while (v70 < 0);
              break;
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              if (v64) {
                continue;
              }
              goto LABEL_8;
            case 22:
              --v64;
              if (v67) {
                continue;
              }
              goto LABEL_8;
            default:
              continue;
          }
        }
      }
      goto LABEL_8;
    case 12:
      int v16 = 0;
      int v61 = 0;
      do
      {
        char v62 = *(unsigned char *)v13;
        uint64_t v13 = (AG::LayoutDescriptor **)((char *)v13 + 1);
        v16 |= (v62 & 0x7F) << v61;
        v61 += 7;
      }
      while (v62 < 0);
      goto LABEL_59;
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      int v16 = v14 - 13;
      goto LABEL_59;
    case 22:
      v74 = (void *)v12[64];
      if (!v74) {
        v74 = v12;
      }
      uint64_t v75 = v12[65] - 1;
      v76 = &v74[8 * v75];
      uint64_t v78 = *v76;
      uint64_t v77 = v76[1];
      uint64_t v79 = v96;
      if (*((_DWORD *)v76 + 13) == 1) {
        uint64_t v79 = v76[2] - v77;
      }
      uint64_t v80 = v95;
      if (*((_DWORD *)v76 + 13) == 1) {
        uint64_t v80 = v76[3] - v77;
      }
      uint64_t v95 = v80;
      uint64_t v96 = v79;
      unint64_t v10 = *(void *)(*(void *)(v78 - 8) + 64) + v77;
      v12[65] = v75;
      AG::LayoutDescriptor::Compare::Enum::~Enum((AG::LayoutDescriptor::Compare::Enum *)v76);
      goto LABEL_8;
    default:
      if ((v14 & 0x80) == 0) {
        goto LABEL_8;
      }
      uint64_t v20 = v14 & 0x7F;
      if (v8 - v10 >= v20 + 1) {
        unint64_t v21 = v20 + 1;
      }
      else {
        unint64_t v21 = v8 - v10;
      }
      v97 = 0;
      uint64_t v22 = AG::LayoutDescriptor::compare_bytes((AG::LayoutDescriptor *)(v95 + v10), (void *)(v96 + v10), (char *)v21, &v97, a5);
      if ((v22 & 1) == 0)
      {
        AG::LayoutDescriptor::Compare::failed(v22, v94, v95, v96, (uint64_t)v97 + v10, 1, 0);
        goto LABEL_105;
      }
LABEL_85:
      v10 += v21;
      goto LABEL_8;
  }
}

void sub_1AF906644(_Unwind_Exception *a1)
{
  AG::LayoutDescriptor::Compare::Frame::~Frame((AG::LayoutDescriptor::Compare::Frame *)(v1 - 104));
  _Unwind_Resume(a1);
}

AG *AG::anonymous namespace'::TypeDescriptorCache::fetch(uint64_t a1, unint64_t a2, int a3, int a4, int a5)
{
  uint64_t v10 = a3;
  unint64_t v11 = ~a2 & 0xFFFFFFFFFFFFFFFCLL;
  if (!a4) {
    unint64_t v11 = a2;
  }
  int v12 = (uint64_t *)(v11 | a3);
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  uint64_t v32 = 0;
  uint64_t v13 = util::UntypedTable::lookup((util::UntypedTable *)(a1 + 8), v12, &v32);
  if (v32)
  {
    layout = (AG *)v13;
    ++*(void *)(a1 + 288);
LABEL_25:
    os_unfair_lock_unlock((os_unfair_lock_t)a1);
    return layout;
  }
  ++*(void *)(a1 + 296);
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  {
    if (v15)
    {
    }
  }
  if ((a3 & 0x200) != 0
  {
    double v24 = AG::current_time(v15);
    layout = (AG *)AG::LayoutDescriptor::make_layout((AG::swift::metadata *)a2, v10, a4);
    double v26 = AG::current_time(layout);
    if (a3 < 0)
    {
      os_unfair_lock_lock((os_unfair_lock_t)a1);
    }
    else
    {
      double v27 = v26;
      {
        uint64_t v29 = (FILE *)*MEMORY[0x1E4F143C8];
        uint64_t v30 = (const char *)AG::swift::metadata::name((AG::swift::metadata *)a2, 0);
        double v28 = v27 - v24;
        fprintf(v29, "!! synchronous layout creation for %s: %g ms\n", v30, v28 * 1000.0);
      }
      else
      {
        double v28 = v27 - v24;
      }
      os_unfair_lock_lock((os_unfair_lock_t)a1);
      *(double *)(a1 + 312) = v28 + *(double *)(a1 + 312);
    }
    util::UntypedTable::insert((util::UntypedTable *)(a1 + 8), v12, layout);
    goto LABEL_25;
  }
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  util::UntypedTable::insert((util::UntypedTable *)(a1 + 8), v12, 0);
  uint64_t v16 = *(void *)(a1 + 224);
  if (*(void *)(a1 + 232) < (unint64_t)(v16 + 1))
  {
    AG::vector<std::pair<char const*,unsigned long>,8ul,unsigned long>::reserve_slow((void *)(a1 + 88), v16 + 1);
    uint64_t v16 = *(void *)(a1 + 224);
  }
  int v17 = v10 & 0xFF00FFFF | (a4 << 16);
  uint64_t v18 = *(void *)(a1 + 216);
  if (!v18) {
    uint64_t v18 = a1 + 88;
  }
  uint64_t v19 = v18 + 16 * v16;
  *(void *)uint64_t v19 = a2;
  *(_DWORD *)(v19 + 8) = v17;
  *(_DWORD *)(v19 + 12) = a5;
  uint64_t v20 = *(void *)(a1 + 216);
  uint64_t v21 = *(void *)(a1 + 224) + 1;
  *(void *)(a1 + 224) = v21;
  if (v20) {
    uint64_t v22 = v20;
  }
  else {
    uint64_t v22 = a1 + 88;
  }
  if (!*(unsigned char *)(a1 + 248))
  {
    *(unsigned char *)(a1 + 248) = 1;
    global_queue = dispatch_get_global_queue(-2, 0);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return 0;
}

void sub_1AF906904(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t *util::UntypedTable::lookup(util::UntypedTable *this, uint64_t *a2, void **a3)
{
  if (*((void *)this + 7))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t *))this)(a2);
    unint64_t v7 = *(uint64_t ***)(*((void *)this + 6) + 8 * (*((void *)this + 8) & v6));
    if (*((unsigned char *)this + 77))
    {
      if (v7)
      {
        while (v7[1] != a2)
        {
          unint64_t v7 = (uint64_t **)*v7;
          if (!v7) {
            goto LABEL_12;
          }
        }
        if (a3) {
          *a3 = a2;
        }
        return v7[2];
      }
    }
    else if (v7)
    {
      uint64_t v8 = v6;
      while (v7[3] != (uint64_t *)v8 || !(*((unsigned int (**)(uint64_t *, uint64_t *))this + 1))(v7[1], a2))
      {
        unint64_t v7 = (uint64_t **)*v7;
        if (!v7) {
          goto LABEL_12;
        }
      }
      if (a3) {
        *a3 = v7[1];
      }
      return v7[2];
    }
  }
LABEL_12:
  uint64_t result = 0;
  if (a3) {
    *a3 = 0;
  }
  return result;
}

unint64_t util::pointer_hash(util *this, const void *a2)
{
  unint64_t v2 = ((unint64_t)this + ~((void)this << 32)) ^ (((unint64_t)this + ~((void)this << 32)) >> 22);
  unint64_t v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  unint64_t v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  return v4 ^ (v4 >> 31);
}

uint64_t AGGraphCreateAttribute(unsigned int a1, void *a2, void *a3)
{
  uint64_t v4 = AG::Subgraph::_current_subgraph_key;
  uint64_t v5 = *(AG::Subgraph **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  if (!v5) {
    AG::precondition_failure((AG *)"no subgraph active while adding attribute", 0, a3, a2);
  }
  uint64_t v8 = (int64x2_t *)*((void *)v5 + 5);
  return AG::Graph::add_attribute(v8, v5, a1, a2, (unint64_t)a3);
}

uint64_t AGSubgraphGetCurrentGraphContext()
{
  uint64_t v0 = AG::Subgraph::_current_subgraph_key;
  uint64_t v1 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v0);
  if (v1) {
    return *(void *)(v1 + 40);
  }
  else {
    return 0;
  }
}

AG::data::zone *AG::data::vector<AG::OutputEdge>::reserve_slow(unsigned int *a1, AG::data::zone *this, unsigned int a3)
{
  unsigned int v4 = 32 - __clz(a3 - 1);
  int v5 = 4 << *a1;
  int v6 = *a1 & 0x1F;
  if (a3 <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = v4;
  }
  unsigned int v11 = a1[1];
  if (v6) {
    unsigned int v8 = v5;
  }
  else {
    unsigned int v8 = 0;
  }
  uint64_t result = AG::data::zone::realloc_bytes(this, &v11, v8, 4 << v7, 3);
  unsigned int v10 = v11;
  *a1 = *a1 & 0xFFFFFFE0 | v7;
  a1[1] = v10;
  return result;
}

AG::data::zone *AG::data::zone::realloc_bytes(AG::data::zone *this, _DWORD *a2, unsigned int a3, unsigned int a4, int a5)
{
  if (a4 > a3)
  {
    int v7 = this;
    if (*a2
      && (uint64_t v8 = AG::data::_shared_table_bytes + (*a2 & 0xFFFFFE00),
          int v9 = *a2 & 0x1FF,
          int v10 = *(_DWORD *)(v8 + 16),
          v10 == v9 + a3)
      && *(_DWORD *)(v8 + 12) - v9 >= a4)
    {
      *(_DWORD *)(v8 + 16) = a4 - a3 + v10;
    }
    else
    {
      this = (AG::data::zone *)AG::data::zone::alloc_bytes_recycle(this, a4, a5);
      int v11 = (int)this;
      uint64_t v12 = *a2;
      if (v12)
      {
        this = (AG::data::zone *)memcpy((void *)(AG::data::_shared_table_bytes + this), (const void *)(AG::data::_shared_table_bytes + v12), a3);
        uint64_t v13 = (*a2 + 3) & 0xFFFFFFFC;
        int v14 = *a2 - v13 + a3;
        if (v14 >= 8)
        {
          int v15 = (_DWORD *)(AG::data::_shared_table_bytes + v13);
          v15[1] = v14;
          *int v15 = *((_DWORD *)v7 + 5);
          *((_DWORD *)v7 + 5) = v13;
        }
      }
      *a2 = v11;
    }
  }
  return this;
}

uint64_t AG::data::zone::alloc_bytes_recycle(AG::data::zone *this, unsigned int a2, int a3)
{
  unint64_t v3 = (_DWORD *)((char *)this + 20);
  unsigned int v4 = *((_DWORD *)this + 5);
  if (v4)
  {
    uint64_t v5 = AG::data::_shared_table_bytes;
    int v6 = (_DWORD *)((char *)this + 20);
    while (1)
    {
      int v7 = v6;
      int v6 = (_DWORD *)(AG::data::_shared_table_bytes + v4);
      unsigned int v8 = v6[1];
      if (a2 <= v8)
      {
        uint64_t v9 = (v4 + a3) & ~a3;
        int v10 = v8 + v4 - v9;
        BOOL v11 = __OFSUB__(v10, a2);
        int v12 = v10 - a2;
        if (v12 < 0 == v11 && a2 - v8 <= 0xFF) {
          break;
        }
      }
      unsigned int v4 = *v6;
      if (!*v6) {
        goto LABEL_7;
      }
    }
    *int v7 = *v6;
    int v16 = v9 + a2;
    if (((v9 + a2) ^ v9) <= 0x1FF)
    {
      uint64_t v17 = (v16 + 3) & 0xFFFFFFFC;
      int v18 = v12 + v16 - v17;
      if (v18 >= 8)
      {
        uint64_t v19 = (_DWORD *)(v5 + v17);
        v19[1] = v18;
        *uint64_t v19 = *v3;
        *unint64_t v3 = v17;
      }
    }
  }
  else
  {
LABEL_7:
    uint64_t v13 = *((unsigned int *)this + 4);
    if (!v13) {
      return AG::data::zone::alloc_slow(this, a2, a3);
    }
    int v14 = (*(_DWORD *)(AG::data::_shared_table_bytes + v13 + 16) + a3) & ~a3;
    if (v14 + a2 > *(_DWORD *)(AG::data::_shared_table_bytes + v13 + 12)) {
      return AG::data::zone::alloc_slow(this, a2, a3);
    }
    *(_DWORD *)(AG::data::_shared_table_bytes + v13 + 16) = v14 + a2;
    return (v14 + v13);
  }
  return v9;
}

AG::data::zone *AG::data::vector<AG::InputEdge>::reserve_slow(unsigned int *a1, AG::data::zone *this, unsigned int a3)
{
  unsigned int v4 = 32 - __clz(a3 - 1);
  int v5 = 5 << *a1;
  int v6 = *a1 & 0x1F;
  if (a3 <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = v4;
  }
  unsigned int v11 = a1[1];
  if (v6) {
    unsigned int v8 = v5;
  }
  else {
    unsigned int v8 = 0;
  }
  uint64_t result = AG::data::zone::realloc_bytes(this, &v11, v8, 5 << v7, 0);
  unsigned int v10 = v11;
  *a1 = *a1 & 0xFFFFFFE0 | v7;
  a1[1] = v10;
  return result;
}

void AG::Subgraph::add_indirect(uint64_t a1, unsigned int a2, int a3)
{
  AG::Subgraph::insert_attribute(a1, a2 & 0xFFFFFFFE | 1, a3);
  uint64_t v5 = *(void *)(a1 + 40);
  int v6 = *(_DWORD *)(v5 + 232);
  if (v6)
  {
    unsigned int v7 = v6 - 1;
    do
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(*(void *)(v5 + 224) + 8 * v7);
      (*(void (**)(uint64_t, void))(*(void *)v9 + 288))(v9, a2);
      --v7;
    }
    while (v8);
  }
}

uint64_t AGDispatchEquatable()
{
  return sub_1AF93CD58() & 1;
}

uint64_t AG::LayoutDescriptor::compare_bytes_top_level(AG::LayoutDescriptor *this, unsigned __int8 *a2, char *a3, int a4, unint64_t *a5)
{
  uint64_t v23 = 0;
  uint64_t v8 = AG::LayoutDescriptor::compare_bytes(this, a2, a3, &v23, a5);
  uint64_t v9 = v8;
  if (a4 < 0 && (v8 & 1) == 0)
  {
    uint64_t v10 = AG::Graph::_current_update_key;
    uint64_t v11 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
    if ((v11 & 1) == 0)
    {
      int v12 = (void *)(v11 & 0xFFFFFFFFFFFFFFFELL);
      if (v12)
      {
        uint64_t v13 = *v12;
        int v14 = *(_DWORD *)(*v12 + 232);
        if (v14)
        {
          int v16 = v12 + 4;
          int v18 = (void *)v12[12];
          uint64_t v17 = v12[13];
          if (v18) {
            int v16 = v18;
          }
          uint64_t v19 = LODWORD(v16[v17 - 1]);
          unsigned int v20 = v14 - 1;
          do
          {
            uint64_t v21 = *(void *)(*(void *)(v13 + 224) + 8 * v20);
            uint64_t v22 = v20;
            (*(void (**)(uint64_t, uint64_t, AG::LayoutDescriptor *, unsigned __int8 *, uint64_t, uint64_t, void))(*(void *)v21 + 360))(v21, v19, this, a2, v23, 1, 0);
            --v20;
          }
          while (v22);
        }
      }
    }
  }
  return v9;
}

uint64_t AG::LayoutDescriptor::compare_bytes(AG::LayoutDescriptor *this, void *a2, char *a3, void *a4, unint64_t *a5)
{
  if ((unint64_t)a3 < 8 || ((a2 | this) & 7) != 0)
  {
    uint64_t v5 = this;
    if (!a3) {
      return 1;
    }
  }
  else
  {
    uint64_t v5 = this;
    while (*a2 == *(void *)v5)
    {
      ++a2;
      uint64_t v5 = (AG::LayoutDescriptor *)((char *)v5 + 8);
      a3 -= 8;
      if ((unint64_t)a3 < 8)
      {
        if (a3) {
          goto LABEL_11;
        }
        return 1;
      }
    }
    if (!a4) {
      return 0;
    }
  }
LABEL_11:
  uint64_t v6 = v5 - this;
  while (*(unsigned __int8 *)a2 == *(unsigned __int8 *)v5)
  {
    a2 = (void *)((char *)a2 + 1);
    uint64_t v5 = (AG::LayoutDescriptor *)((char *)v5 + 1);
    ++v6;
    if (!--a3) {
      return 1;
    }
  }
  if (!a4) {
    return 0;
  }
  uint64_t result = 0;
  *a4 = v6;
  return result;
}

void AG::Graph::mark_changed(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(_DWORD *)(a1 + 232))
  {
    unint64_t v7 = *(unsigned int *)(AG::data::_shared_table_bytes + a2 + 20);
    if (v7 < 0x20) {
      goto LABEL_19;
    }
    uint64_t v9 = 0;
    uint64_t v10 = AG::data::_shared_table_bytes + *(unsigned int *)(AG::data::_shared_table_bytes + a2 + 24);
    unint64_t v11 = v7 >> 5;
    while (1)
    {
      uint64_t v12 = *(unsigned int *)(v10 + 4 * v9);
      if ((v12 & 3) != 0)
      {
        AG::Graph::mark_changed(a1);
        return;
      }
      uint64_t v13 = AG::data::_shared_table_bytes + v12;
      unint64_t v14 = *(unsigned int *)(AG::data::_shared_table_bytes + v12 + 12);
      if (v14 < 0x20) {
        goto LABEL_18;
      }
      int v15 = (unsigned __int8 *)(AG::data::_shared_table_bytes + *(unsigned int *)(v13 + 16) + 4);
      uint64_t v16 = 5 * (v14 >> 5);
      while (1)
      {
        int v17 = *((_DWORD *)v15 - 1);
        int v24 = v17;
        if ((v17 & 3) != 0)
        {
          uint64_t v21 = a4;
          uint64_t v23 = a5;
          int v17 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v24, 0);
          a4 = v21;
          a5 = v23;
        }
        if (v17 != a2) {
          goto LABEL_14;
        }
        char v18 = *v15;
        if ((*v15 & 8) != 0) {
          goto LABEL_14;
        }
        if ((*(v15 - 4) & 3) == 0) {
          goto LABEL_17;
        }
        unint64_t v19 = v19 & 0xFFFFFF0000000000 | *((unsigned int *)v15 - 1) | ((unint64_t)*v15 << 32);
        uint64_t v20 = a4;
        uint64_t v22 = a5;
        if ((AG::Graph::compare_edge_values(a1, *((_DWORD *)v15 - 1), a3, a4, a5) & 1) == 0) {
          break;
        }
        a4 = v20;
        a5 = v22;
LABEL_14:
        v15 += 5;
        v16 -= 5;
        if (!v16) {
          goto LABEL_18;
        }
      }
      char v18 = *v15;
      a4 = v20;
      a5 = v22;
LABEL_17:
      *int v15 = v18 | 8;
LABEL_18:
      if (++v9 == v11)
      {
LABEL_19:
        ++*(void *)(a1 + 464);
        return;
      }
    }
  }
  AG::Graph::mark_changed(a1);
}

unsigned int *AG::Node::allocate_value(unsigned int *this, AG::Graph *a2, AG::data::zone *a3)
{
  if (!this[2])
  {
    uint64_t v5 = this;
    uint64_t v6 = *(void *)(*(void *)(*(void *)(*((void *)a2 + 16) + (((unint64_t)*this >> 5) & 0x7FFFFF8)) + 8)
                   - 8);
    size_t v7 = *(unsigned int *)(v6 + 64);
    if ((*((unsigned char *)this + 7) & 2) != 0)
    {
      unsigned int v8 = AG::data::zone::alloc_bytes_recycle(a3, 8u, 7);
      this = (unsigned int *)AG::data::zone::alloc_persistent(a3, v7);
      *(void *)(AG::data::_shared_table_bytes + v8) = this;
    }
    else
    {
      if (v7 > 0x10)
      {
        uint64_t v9 = *((unsigned int *)a3 + 4);
        if (v9)
        {
          int v10 = (*(_DWORD *)(AG::data::_shared_table_bytes + v9 + 16) + *(unsigned __int8 *)(v6 + 80)) & ~*(unsigned __int8 *)(v6 + 80);
          if ((v10 + v7) <= *(_DWORD *)(AG::data::_shared_table_bytes + v9 + 12))
          {
            *(_DWORD *)(AG::data::_shared_table_bytes + v9 + 16) = v10 + v7;
            unsigned int v8 = v10 + v9;
            goto LABEL_11;
          }
        }
        this = (unsigned int *)AG::data::zone::alloc_slow(a3, *(_DWORD *)(v6 + 64), *(unsigned __int8 *)(v6 + 80));
      }
      else
      {
        this = (unsigned int *)AG::data::zone::alloc_bytes_recycle(a3, *(_DWORD *)(v6 + 64), *(unsigned __int8 *)(v6 + 80));
      }
      unsigned int v8 = this;
    }
LABEL_11:
    v5[2] = v8;
    *((void *)a2 + 36) += v7;
  }
  return this;
}

uint64_t AG::LayoutDescriptor::Compare::failed(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a2 < 0)
  {
    uint64_t v7 = AG::Graph::_current_update_key;
    uint64_t v8 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
    if ((v8 & 1) == 0)
    {
      uint64_t v9 = (void *)(v8 & 0xFFFFFFFFFFFFFFFELL);
      if (v9)
      {
        uint64_t v10 = *v9;
        int v11 = *(_DWORD *)(*v9 + 232);
        if (v11)
        {
          int v17 = v9 + 4;
          unint64_t v19 = (void *)v9[12];
          uint64_t v18 = v9[13];
          if (v19) {
            int v17 = v19;
          }
          uint64_t v20 = LODWORD(v17[v18 - 1]);
          unsigned int v21 = v11 - 1;
          do
          {
            uint64_t v22 = v21;
            uint64_t v23 = *(void *)(*(void *)(v10 + 224) + 8 * v21);
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v23 + 360))(v23, v20, a3, a4, a5, a6, a7);
            --v21;
          }
          while (v22);
        }
      }
    }
  }
  return result;
}

void AG::LayoutDescriptor::Compare::Enum::~Enum(AG::LayoutDescriptor::Compare::Enum *this)
{
  if (*(void *)(*(void *)this - 8)) {
    uint64_t v2 = *(void *)(*(void *)this - 8);
  }
  else {
    uint64_t v2 = 0;
  }
  (*(void (**)(void, void))(v2 + 104))(*((void *)this + 5), *((unsigned int *)this + 12));
  (*(void (**)(void, void, void))(v2 + 104))(*((void *)this + 4), *((unsigned int *)this + 12), *(void *)this);
  if (*((_DWORD *)this + 13) == 1)
  {
    (*(void (**)(void, void))(v2 + 8))(*((void *)this + 5), *(void *)this);
    (*(void (**)(void, void))(v2 + 8))(*((void *)this + 4), *(void *)this);
  }
  if (*((unsigned char *)this + 56))
  {
    free(*((void **)this + 4));
    if (*((unsigned char *)this + 56)) {
      free(*((void **)this + 5));
    }
  }
}

void *AG::LayoutDescriptor::Compare::Enum::Enum(void *a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  uint64_t v10 = a2;
  uint64_t v12 = a9;
  *a1 = a2;
  a1[1] = a5;
  a1[2] = a6;
  a1[3] = a7;
  a1[4] = a8;
  a1[5] = a9;
  *((_DWORD *)a1 + 12) = a4;
  *((_DWORD *)a1 + 13) = a3;
  *((unsigned char *)a1 + 56) = a10;
  if (*(void *)(a2 - 8)) {
    uint64_t v13 = *(void *)(a2 - 8);
  }
  else {
    uint64_t v13 = 0;
  }
  if (a3 == 1)
  {
    (*(void (**)(void))(v13 + 16))();
    (*(void (**)(void, void, void))(v13 + 16))(a1[4], a1[2], *a1);
    uint64_t v12 = a1[5];
    uint64_t v10 = *a1;
  }
  (*(void (**)(uint64_t, uint64_t))(v13 + 96))(v12, v10);
  (*(void (**)(void, void))(v13 + 96))(a1[4], *a1);
  return a1;
}

uint64_t AG::Graph::compare_edge_values(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 0;
  if (a3 && (a2 & 3) == 1)
  {
    uint64_t result = 0;
    int v6 = *(unsigned __int16 *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFFFC) + 12);
    uint64_t v7 = v6 == 0xFFFF ? 0 : (char *)*(unsigned __int16 *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFFFC) + 12);
    if (v6 != 0xFFFF)
    {
      if (*(_WORD *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFFFC) + 12))
      {
        int v20 = a2;
        AG::AttributeID::resolve_slow((AG::AttributeID *)&v20, 0);
        uint64_t v12 = *(AG::LayoutDescriptor **)(a3 + 8);
        uint64_t v13 = (const unsigned __int8 *)v11;
        if (v11 || *(char **)(*((void *)v12 - 1) + 64) != v7)
        {
          unsigned int v14 = *(_DWORD *)(a3 + 40) & 3 | 0x100;
          int v15 = *(AG::LayoutDescriptor **)(a3 + 48);
          if (!v15)
          {
            unint64_t v19 = (const unsigned __int8 *)v11;
            unsigned int v18 = *(_DWORD *)(a3 + 40) & 3 | 0x100;
            int v17 = AG::LayoutDescriptor::fetch(v12, (const AG::swift::metadata *)v18, 0);
            unsigned int v14 = v18;
            uint64_t v13 = v19;
            int v15 = v17;
            *(void *)(a3 + 48) = v17;
          }
          if (v15 == (AG::LayoutDescriptor *)1) {
            uint64_t v16 = 0;
          }
          else {
            uint64_t v16 = v15;
          }
          return AG::LayoutDescriptor::compare_partial(v16, (AG::LayoutDescriptor *)&v13[a4], (unsigned __int8 *)&v13[a5], v13, v7, v14);
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

unint64_t AG::Graph::index_of_input_slow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(unsigned int *)(a2 + 12);
  unint64_t v5 = AG::data::_shared_table_bytes + *(unsigned int *)(a2 + 16);
  unint64_t v6 = v4 >> 5;
  if ((*(unsigned char *)(a2 + 7) & 8) != 0)
  {
    *(unsigned char *)(a2 + 7) &= ~8u;
    unint64_t v7 = 126 - 2 * __clz(v6);
    if (v4 >= 0x20) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    std::__introsort<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*,false>(v5, v5 + 5 * v6, v8, 1);
  }
  unint64_t result = -1;
  if (v4 >= 0x20)
  {
    unint64_t v10 = v5 + 5 * v6;
    unint64_t v11 = v5;
    do
    {
      uint64_t v12 = (unsigned int *)(v11 + 5 * (v6 >> 1));
      unsigned int v14 = *v12;
      uint64_t v13 = (char *)v12 + 5;
      BOOL v15 = v14 >= a3;
      if (v14 >= a3) {
        v6 >>= 1;
      }
      else {
        v6 += ~(v6 >> 1);
      }
      if (!v15) {
        unint64_t v11 = (unint64_t)v13;
      }
    }
    while (v6);
    if (v11 != v10)
    {
      unint64_t v16 = v11 - v5;
      while (*(_DWORD *)v11 == a3)
      {
        if ((*(unsigned char *)(v11 + 4) & BYTE4(a3)) == BYTE5(a3)) {
          return 0xCCCCCCCCCCCCCCCDLL * v16;
        }
        v16 += 5;
        v11 += 5;
        if (v11 == v10) {
          return -1;
        }
      }
    }
    return -1;
  }
  return result;
}

double AG::current_time(AG *this)
{
  uint64_t v1 = (AG *)mach_absolute_time();
  return AG::absolute_time_to_seconds(v1);
}

void *AG::data::zone::alloc_persistent(AG::data::zone *this, size_t a2)
{
  if (!a2) {
    return 0;
  }
  unint64_t v4 = malloc_type_zone_malloc((malloc_zone_t *)AG::data::table::_malloc_zone, a2, 0x331258A3uLL);
  if (!v4) {
    AG::precondition_failure((AG *)"memory allocation failure (%lu bytes)", v5, a2);
  }
  unint64_t v6 = v4;
  unsigned int v7 = *((_DWORD *)this + 2);
  unsigned int v8 = v7 + 1;
  if (*((_DWORD *)this + 3) < v7 + 1)
  {
    AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow((uint64_t)this, v8);
    unsigned int v7 = *((_DWORD *)this + 2);
    unsigned int v8 = v7 + 1;
  }
  *(void *)(*(void *)this + 8 * v7) = v6;
  *((_DWORD *)this + 2) = v8;
  return v6;
}

uint64_t AG::LayoutDescriptor::compare_indirect(AG::LayoutDescriptor **a1, uint64_t a2, AG::LayoutDescriptor *a3, int a4, const void *a5, const void *a6)
{
  v30[1] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = (uint64_t *)(a2 - 8);
  size_t v13 = *(void *)(*(void *)(a2 - 8) + 64);
  if (v13 > 0x1000)
  {
    unsigned int v14 = (uint64_t *)malloc_type_malloc(*(void *)(*(void *)(a2 - 8) + 64), 0x100004077774924uLL);
    int v17 = (uint64_t *)malloc_type_malloc(v13, 0x100004077774924uLL);
    unint64_t v16 = v17;
    if (!v14 || !v17)
    {
      free(v17);
      uint64_t v19 = 0;
LABEL_21:
      free(v14);
      return v19;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1);
    unsigned int v14 = (void *)((char *)v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v14, v13);
    MEMORY[0x1F4188790](v15);
    unint64_t v16 = v14;
    bzero(v14, v13);
  }
  memcpy(v14, a5, v13);
  memcpy(v16, a6, v13);
  if (*v12) {
    uint64_t v18 = *v12;
  }
  else {
    uint64_t v18 = 0;
  }
  int v20 = *(void (**)(uint64_t *, uint64_t))(v18 + 96);
  if (v20)
  {
    unsigned int v21 = *(void (**)(uint64_t *, uint64_t))(v18 + 96);
    v20(v14, a2);
  }
  else
  {
    unsigned int v21 = 0;
    MEMORY[0](v14, a2);
  }
  v21(v16, a2);
  uint64_t v23 = *v14;
  uint64_t v24 = *v16;
  if (*v14 == *v16)
  {
    uint64_t v19 = 1;
  }
  else
  {
    uint64_t v25 = *((void *)a3 - 1);
    uint64_t v26 = *(unsigned __int8 *)(v25 + 80);
    unint64_t v27 = a4 & 0xFFFFFEFF;
    double v28 = *a1;
    if (!*a1)
    {
      double v28 = AG::LayoutDescriptor::fetch(a3, (const AG::swift::metadata *)v27, 0);
      *a1 = v28;
      uint64_t v25 = *((void *)a3 - 1);
    }
    if (v28 == (AG::LayoutDescriptor *)1) {
      double v28 = 0;
    }
    uint64_t v19 = AG::LayoutDescriptor::compare(v28, (AG::LayoutDescriptor *)(v23 + ((v26 + 16) & ~v26)), (const unsigned __int8 *)(v24 + ((v26 + 16) & ~v26)), *(const unsigned __int8 **)(v25 + 64), v27, v22);
  }
  if (v13 > 0x1000)
  {
    free(v16);
    goto LABEL_21;
  }
  return v19;
}

void sub_1AF907BC4(_Unwind_Exception *exception_object)
{
  if (v2 > 0x1000)
  {
    free(v3);
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AG::LayoutDescriptor::compare_heap_objects(AG::LayoutDescriptor *this, const unsigned __int8 *a2, const void *a3, int a4)
{
  if (this == (AG::LayoutDescriptor *)a2) {
    return 1;
  }
  uint64_t result = 0;
  if ((uint64_t)this >= 1 && (uint64_t)a2 >= 1)
  {
    unint64_t v7 = *(void *)this;
    if (*(void *)this != *(void *)a2) {
      return 0;
    }
    int v8 = (int)a3;
    if (a4) {
      int v9 = 2;
    }
    else {
      int v9 = 1;
    }
    LODWORD(a3) = a3;
    {
      unint64_t v14 = *(void *)this;
      int v12 = v9;
      int v13 = a3;
      int v9 = v12;
      LODWORD(a3) = v13;
      unint64_t v7 = v14;
    }
    if ((unint64_t)v10 >= 2)
    {
      return AG::LayoutDescriptor::compare(v10, this, a2, (const unsigned __int8 *)0xFFFFFFFFFFFFFFFFLL, v8 & 0xFFFFFEFF, v11);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t AG::Subgraph::NodeCache::NodeCache(void)::$_1::__invoke(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
  {
    char v2 = 1;
  }
  else if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8) && (*(void *)a2 ^ *(void *)a1) <= 255)
  {
    char v2 = AGDispatchEquatable();
  }
  else
  {
    char v2 = 0;
  }
  return v2 & 1;
}

unint64_t AG::Graph::index_of_input(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a2 + 12);
  if (v3 > 0x11F) {
    return AG::Graph::index_of_input_slow(a1, a2, a3);
  }
  if (v3 < 0x20) {
    return -1;
  }
  unint64_t result = 0;
  unint64_t v5 = v3 >> 5;
  for (uint64_t i = (unsigned char *)(*(unsigned int *)(a2 + 16) + AG::data::_shared_table_bytes + 4);
        *((_DWORD *)i - 1) != a3 || (*i & BYTE4(a3)) != BYTE5(a3);
        i += 5)
  {
    if (v5 == ++result) {
      return -1;
    }
  }
  return result;
}

uint64_t sub_1AF907E90(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_retain();
  return a1;
}

uint64_t sub_1AF907EC8()
{
  return sub_1AF907EDC(*(void *)(v0 + 16), *(void *)(v0 + 24), *(void *)(v0 + 32), *(_DWORD *)(v0 + 40), *(uint64_t (**)(void))(v0 + 48));
}

uint64_t sub_1AF907EDC(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t (*a5)(void))
{
  uint64_t v10 = swift_slowAlloc();
  uint64_t v11 = a5();
  sub_1AF914010(a1, a2, a3, a4, v11, (uint64_t)v15);
  swift_release();
  long long v12 = v15[3];
  *(_OWORD *)(v10 + 32) = v15[2];
  *(_OWORD *)(v10 + 48) = v12;
  *(void *)(v10 + 64) = v16;
  long long v13 = v15[1];
  *(_OWORD *)uint64_t v10 = v15[0];
  *(_OWORD *)(v10 + 16) = v13;
  return v10;
}

BOOL AG::swift::anonymous namespace'::TypeCache::TypeCache(void)::$_1::__invoke(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL sub_1AF907FC4(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL AG::anonymous namespace'::TypeDescriptorCache::fetch(AG::swift::metadata const*,unsigned int,AG::LayoutDescriptor::HeapMode,int)::$_0::operator()()
{
  uint64_t v0 = getenv("AG_ASYNC_LAYOUTS");
  return !v0 || atoi(v0) != 0;
}

char *_ZZN2AG5Graph11intern_typeEPKNS_5swift8metadataENS_17ClosureFunctionVPIPvJEEEENK3__0clEv()
{
  unint64_t result = getenv("AG_PREFETCH_LAYOUTS");
  if (result) {
    return (char *)(atoi(result) != 0);
  }
  return result;
}

uint64_t AG::misc_log(AG *this)
{
  unint64_t v1 = 0x1E9AF0000uLL;
  {
    unint64_t v1 = 0x1E9AF0000;
    if (v3)
    {
      AG::misc_log(void)::log = (uint64_t)os_log_create("com.apple.attributegraph", "misc");
      unint64_t v1 = 0x1E9AF0000;
    }
  }
  return *(void *)(v1 + 2224);
}

uint64_t sub_1AF9080B8(uint64_t a1)
{
  char v2 = *(AG::swift::metadata **)(a1 + 16);
  uint64_t v3 = *((void *)v2 - 1);
  MEMORY[0x1F4188790](a1);
  unint64_t v5 = (char *)&v10 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  Value = AGGraphGetValue(*v1, 0, v2, v6, v7);
  (*(void (**)(char *, char *, AG::swift::metadata *))(v3 + 16))(v5, Value, v2);
  swift_getAtKeyPath();
  return (*(uint64_t (**)(char *, AG::swift::metadata *))(v3 + 8))(v5, v2);
}

uint64_t AGWeakAttributeGetAttribute(unint64_t a1)
{
  uint64_t v1 = 2;
  unsigned int v2 = a1;
  if (a1 >= 4)
  {
    unint64_t v3 = HIDWORD(a1);
    uint64_t v4 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(a1 & 0xFFFFFE00));
    if (v3 != v4 || (v4 & 0xFF00000000) == 0) {
      return 2;
    }
    else {
      return v2;
    }
  }
  return v1;
}

char *AGGraphGetInputValue(unint64_t a1, const char *a2, uint64_t a3, AG::swift::metadata *a4)
{
  uint64_t v4 = a4;
  char v5 = a3;
  unsigned int v6 = a2;
  if ((a3 & 4) != 0 || a1 == 2) {
    return AGGraphGetValue((unint64_t)a2, (const char *)a3, a4, (uint64_t)a4, a3);
  }
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v8 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v8) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  int v9 = *(__n128 **)(v8 + 40);
  char v35 = 0;
  unsigned int v36 = a2;
  uint64_t v10 = a3 & 3;
  uint64_t v11 = AG::data::_shared_table_bytes + a1;
  unint64_t v12 = *(unsigned int *)(v11 + 12);
  if (v12 > 0x11F)
  {
    int v31 = a1;
    uint64_t v33 = AG::data::_shared_table_bytes + a1;
    unint64_t v27 = v9;
    char v25 = a3;
    unsigned int v23 = a2;
    a1 = AG::Graph::index_of_input_slow((uint64_t)v9, v11, a2 | (unint64_t)(v10 << 40) | 0x700000000);
    int v9 = v27;
    uint64_t v4 = a4;
    unsigned int v6 = v23;
    char v5 = v25;
    unint64_t v13 = a1;
    LODWORD(a1) = v31;
    uint64_t v11 = v33;
  }
  else
  {
    if (v12 < 0x20)
    {
LABEL_13:
      unint64_t v13 = -1;
      return AG::Graph::input_value_ref_slow(v9, a1, (const char *)v6, 0, v5, v4, &v35, v13);
    }
    unint64_t v13 = 0;
    unint64_t v14 = v12 >> 5;
    uint64_t v15 = (unsigned char *)(*(unsigned int *)(v11 + 16) + AG::data::_shared_table_bytes + 4);
    while (*((_DWORD *)v15 - 1) != a2 || (*v15 & 7) != v10)
    {
      ++v13;
      v15 += 5;
      if (v14 == v13) {
        goto LABEL_13;
      }
    }
  }
  if ((v13 & 0x8000000000000000) != 0) {
    return AG::Graph::input_value_ref_slow(v9, a1, (const char *)v6, 0, v5, v4, &v35, v13);
  }
  uint64_t v16 = *(unsigned int *)(v11 + 16);
  uint64_t v17 = AG::data::_shared_table_bytes;
  if ((v6 & 3) != 0)
  {
    int v32 = a1;
    double v28 = v9;
    uint64_t v30 = v4;
    char v26 = v5;
    uint64_t v22 = v16;
    unint64_t v24 = v13;
    uint64_t v34 = AG::data::_shared_table_bytes;
    LODWORD(a1) = AG::AttributeID::resolve_slow((AG::AttributeID *)&v36, (const char *)3);
    uint64_t v16 = v22;
    unint64_t v13 = v24;
    int v9 = v28;
    uint64_t v4 = v30;
    char v5 = v26;
    unsigned int v6 = a1;
    LODWORD(a1) = v32;
    uint64_t v17 = v34;
  }
  else
  {
    uint64_t v18 = 0;
  }
  uint64_t v19 = AG::data::_shared_table_bytes;
  uint64_t v20 = AG::data::_shared_table_bytes + v6;
  if ((*(_DWORD *)v20 & 0x11) != 0x10)
  {
    unsigned int v6 = v36;
    return AG::Graph::input_value_ref_slow(v9, a1, (const char *)v6, 0, v5, v4, &v35, v13);
  }
  *(unsigned char *)(v17 + v16 + 5 * v13 + 4) |= 0x10u;
  unsigned int v21 = (void *)(v19 + *(unsigned int *)(v20 + 8));
  if ((*(unsigned char *)(v20 + 7) & 2) != 0) {
    unsigned int v21 = (void *)*v21;
  }
  return (char *)v21 + v18;
}

void AGSubgraphSetCurrent(void *a1)
{
  uint64_t v1 = AG::Subgraph::_current_subgraph_key;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v3 = *(void *)(StatusReg + 8 * v1);
  if (!a1)
  {
    *(void *)(StatusReg + 8 * v1) = 0;
    if (!v3) {
      return;
    }
    goto LABEL_7;
  }
  uint64_t v4 = a1[2];
  *(void *)(StatusReg + 8 * v1) = v4;
  if (v4) {
    CFRetain(a1);
  }
  if (v3)
  {
LABEL_7:
    char v5 = *(const void **)(v3 + 32);
    if (v5)
    {
      CFRelease(v5);
    }
  }
}

void AGGraphSetFlags(char *a1, const char *a2)
{
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  unsigned __int8 v2 = a2;
  unsigned int v3 = a1;
  uint64_t v4 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  AG::Subgraph::set_flags(v4, v3, v2);
}

_DWORD *sub_1AF908544@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void AGSubgraphCreate(uint64_t a1)
{
}

uint64_t type metadata accessor for External()
{
  return __swift_instantiateGenericMetadata();
}

void AGGraphMutateAttribute(char *a1, const char *a2, char a3, void (*a4)(void *), uint64_t a5)
{
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v5 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v5) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  uint64_t v7 = (const char *)a1;
  uint64_t v8 = *(void *)(v5 + 40);
  AG::Graph::attribute_modify(v8, v7, (uint64_t)a2, a4, a5, a3 & 1);
}

uint64_t AGGraphCreateIndirectAttribute2(unsigned int a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t AGSubgraphGetGraph(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", a2);
  }
  unsigned int v3 = *(char **)(v2 + 48);
  if (!v3
    || (uint64_t v4 = util::UntypedTable::lookup((util::UntypedTable *)(*(void *)(v2 + 40) + 144), (uint64_t *)v3, 0)) == 0)
  {
    AG::precondition_failure((AG *)"accessing invalidated context", v3);
  }
  return AGGraphContextGetGraph((uint64_t)v4);
}

uint64_t sub_1AF908684(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F41863F8](a1, a2, a3, 8);
}

uint64_t AGGraphGetOutputValue(AG::swift::metadata *a1, const char *a2)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  uint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2);
  if ((v3 & 1) != 0 || (uint64_t v4 = (uint64_t *)(v3 & 0xFFFFFFFFFFFFFFFELL)) == 0) {
    AG::precondition_failure((AG *)"no attribute updating", a2);
  }
  uint64_t v6 = *v4;
  uint64_t v7 = v4 + 4;
  uint64_t v9 = v4[12];
  uint64_t v8 = v4[13];
  if (v9) {
    uint64_t v7 = (uint64_t *)v9;
  }
  uint64_t v10 = (const char *)LODWORD(v7[v8 - 1]);
  return AG::Graph::output_value_ref(v6, v10, a1);
}

uint64_t AGGraphHasDeadlinePassed()
{
  uint64_t v0 = AG::Graph::_current_update_key;
  uint64_t v1 = (AG::Graph **)(*(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v0) & 0xFFFFFFFFFFFFFFFELL);
  if (v1 && *((void *)*v1 + 54) != -1) {
    return AG::Graph::passed_deadline_slow(*v1);
  }
  else {
    return 0;
  }
}

uint64_t AG::Graph::output_value_ref(uint64_t a1, const char *a2, AG::swift::metadata *a3)
{
  uint64_t v4 = (unsigned int *)(AG::data::_shared_table_bytes + a2);
  unint64_t v5 = *v4;
  if ((v5 & 0xC0) == 0) {
    AG::precondition_failure((AG *)"attribute is not evaluating: %u", a2, a2);
  }
  if ((v5 & 0x10) == 0) {
    return 0;
  }
  uint64_t v8 = *(AG::swift::metadata **)(*(void *)(*(void *)(a1 + 128) + ((v5 >> 5) & 0x7FFFFF8)) + 8);
  if (v8 != a3)
  {
    uint64_t v9 = AG::swift::metadata::name(v8, 0);
    uint64_t v10 = AG::swift::metadata::name(a3, 0);
    AG::precondition_failure((AG *)"invalid value type for attribute: %u (saw %s, expected %s)", v11, a2, v9, v10);
  }
  uint64_t result = AG::data::_shared_table_bytes + v4[2];
  if ((*((unsigned char *)v4 + 7) & 2) != 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t anonymous namespace'::create_indirect_attribute(unsigned int a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = AG::Subgraph::_current_subgraph_key;
  uint64_t v6 = *(uint64_t **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
  if (!v6) {
    AG::precondition_failure((AG *)"no subgraph active while making indirection", 0, a3, a4, a2);
  }
  return AG::Graph::add_indirect_attribute(v6[5], (AG::data::zone *)v6, a1, 0, a2, a3, 1) | 1;
}

uint64_t type metadata accessor for WeakAttribute()
{
  return __swift_instantiateGenericMetadata();
}

void AGSubgraphUpdate(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(AG::Subgraph **)(a1 + 16);
  if (v2) {
    AG::Subgraph::update(v2, a2);
  }
}

uint64_t AGGraphSetValue(char *a1, char *a2, AG::LayoutDescriptor *a3)
{
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v3 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v3) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  uint64_t v5 = (const char *)a1;
  uint64_t v6 = *(AG::Graph **)(v3 + 40);
  return AG::Graph::value_set(v6, v5, a3, (unsigned __int8 *)a2);
}

uint64_t AGTypeGetEnumTag(AG::swift::metadata *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this - 1);
  if (v2)
  {
    uint64_t v3 = *((void *)this - 1);
    if ((*(unsigned char *)(v2 + 82) & 0x20) == 0)
    {
LABEL_7:
      uint64_t v5 = AG::swift::metadata::name(this, 0);
      AG::precondition_failure((AG *)"not an enum type: %s", v6, v5);
    }
  }
  else
  {
    if ((MEMORY[0x52] & 0x20) == 0) {
      goto LABEL_7;
    }
    uint64_t v3 = 0;
  }
  return (*(unsigned int (**)(uint64_t, AG::swift::metadata *))(v3 + 88))(a2, this);
}

uint64_t *AGSubgraphAddChild2(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t result = *(uint64_t **)(a1 + 16);
  if (!result) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", (const char *)a2);
  }
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4)
  {
    return AG::Subgraph::add_child((AG::Subgraph *)result, v4, a3);
  }
  return result;
}

void *__swift_memcpy8_4(void *result, void *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t AGTypeInjectEnumTag(AG::swift::metadata *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *((void *)this - 1);
  if (v3)
  {
    uint64_t v4 = *((void *)this - 1);
    if ((*(unsigned char *)(v3 + 82) & 0x20) == 0)
    {
LABEL_9:
      uint64_t v7 = AG::swift::metadata::name(this, 0);
      AG::precondition_failure((AG *)"not an enum type: %s", v8, v7);
    }
  }
  else
  {
    if ((MEMORY[0x52] & 0x20) == 0) {
      goto LABEL_9;
    }
    uint64_t v4 = 0;
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, AG::swift::metadata *))(v4 + 104);
  return v5(a3, a2, this);
}

uint64_t AGTypeProjectEnumData(AG::swift::metadata *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this - 1);
  if (v2)
  {
    uint64_t v3 = *((void *)this - 1);
    if ((*(unsigned char *)(v2 + 82) & 0x20) == 0)
    {
LABEL_9:
      uint64_t v6 = AG::swift::metadata::name(this, 0);
      AG::precondition_failure((AG *)"not an enum type: %s", v7, v6);
    }
  }
  else
  {
    if ((MEMORY[0x52] & 0x20) == 0) {
      goto LABEL_9;
    }
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, AG::swift::metadata *))(v3 + 96);
  return v4(a2, this);
}

uint64_t AGTypeApplyFields2(AG::swift::metadata *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  v10[0] = a3;
  v10[1] = a4;
  v8[0] = &unk_1F0814378;
  v8[1] = v10;
  int v9 = a2;
  uint64_t v5 = *(void *)a1;
  if (*(void *)a1 > 0x7FFuLL) {
    uint64_t v5 = 0;
  }
  if (v5 <= 512)
  {
    if (!v5)
    {
      if (a2) {
        return AG::swift::metadata::visit_heap(a1, (AG::swift::metadata_visitor *)v8, 1);
      }
      return 0;
    }
    if (v5 != 512) {
      return v4;
    }
LABEL_11:
    if ((a2 & 5) == 0) {
      return AG::swift::metadata::visit(a1, (AG::swift::metadata_visitor *)v8);
    }
    return 0;
  }
  if ((unint64_t)(v5 - 513) < 2)
  {
    if ((a2 & 4) == 0) {
      return 0;
    }
    return AG::swift::metadata::visit(a1, (AG::swift::metadata_visitor *)v8);
  }
  if (v5 == 769) {
    goto LABEL_11;
  }
  return v4;
}

uint64_t AGTypeApplyFields2::Visitor::unknown_result(AGTypeApplyFields2::Visitor *this)
{
  return (*((unsigned __int8 *)this + 16) >> 1) & 1;
}

void *AG::vector<std::pair<char const*,unsigned long>,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 18) + (*((void *)__dst + 18) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 18) + (*((void *)__dst + 18) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 16), __dst, 8uLL, (size_t *)__dst + 18, v3);
  *((void *)__dst + 16) = result;
  return result;
}

void AG::anonymous namespace'::TypeDescriptorCache::drain_queue(AG::_anonymous_namespace_::TypeDescriptorCache *this, void *a2)
{
  double v3 = AG::current_time(this);
  os_unfair_lock_lock((os_unfair_lock_t)this);
  uint64_t v5 = *((void *)this + 28);
  if (v5)
  {
    int v6 = 0;
    do
    {
      if (*((void *)this + 27)) {
        uint64_t v7 = (char *)*((void *)this + 27);
      }
      else {
        uint64_t v7 = (char *)this + 88;
      }
      unint64_t v8 = *(void *)v7;
      int v9 = *((_DWORD *)v7 + 2);
      if (v5 >= 2)
      {
        uint64_t v10 = 0;
        uint64_t v11 = &v7[16 * v5];
        *(_OWORD *)char v25 = *(_OWORD *)v7;
        unint64_t v12 = v7;
        do
        {
          unint64_t v13 = &v12[16 * v10 + 16];
          uint64_t v14 = (2 * v10) | 1;
          uint64_t v15 = 2 * v10 + 2;
          if (v15 < v5)
          {
            int v16 = *((_DWORD *)v13 + 3);
            int v17 = *((_DWORD *)v13 + 7);
            v13 += 16 * (v16 < v17);
            if (v16 < v17) {
              uint64_t v14 = v15;
            }
          }
          *(_OWORD *)unint64_t v12 = *(_OWORD *)v13;
          unint64_t v12 = v13;
          uint64_t v10 = v14;
        }
        while (v14 <= (uint64_t)((unint64_t)(v5 - 2) >> 1));
        uint64_t v18 = v11 - 16;
        if (v13 == v11 - 16)
        {
          *(_OWORD *)unint64_t v13 = *(_OWORD *)v25;
        }
        else
        {
          *(_OWORD *)unint64_t v13 = *(_OWORD *)v18;
          *(_OWORD *)uint64_t v18 = *(_OWORD *)v25;
        }
        uint64_t v5 = *((void *)this + 28);
      }
      *((void *)this + 28) = v5 - 1;
      unint64_t v19 = ~v8 & 0xFFFFFFFFFFFFFFFCLL;
      if (!BYTE2(v9)) {
        unint64_t v19 = v8;
      }
      uint64_t v20 = (uint64_t *)(v19 | (unsigned __int16)v9);
      v25[0] = 0;
      uint64_t v4 = (AG *)util::UntypedTable::lookup((AG::_anonymous_namespace_::TypeDescriptorCache *)((char *)this + 8), v20, v25);
      if (v4) {
        BOOL v21 = 1;
      }
      else {
        BOOL v21 = v25[0] == 0;
      }
      if (!v21)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)this);
        layout = (void *)AG::LayoutDescriptor::make_layout((AG::swift::metadata *)v8, (unsigned __int16)v9, v9 << 8 >> 24);
        os_unfair_lock_lock((os_unfair_lock_t)this);
        uint64_t v4 = (AG *)util::UntypedTable::insert((AG::_anonymous_namespace_::TypeDescriptorCache *)((char *)this + 8), v20, layout);
        ++v6;
      }
      uint64_t v5 = *((void *)this + 28);
    }
    while (v5);
  }
  else
  {
    int v6 = 0;
  }
  if (*((void *)this + 29))
  {
    uint64_t v4 = (AG *)AG::details::realloc_vector<unsigned long,16ul>(*((void **)this + 27), (char *)this + 88, 8uLL, (size_t *)this + 29, 0);
    *((void *)this + 27) = v4;
  }
  *((unsigned char *)this + 248) = 0;
  double v24 = AG::current_time(v4) - v3;
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "## bg queue ran for %g ms, created %u layouts (%u extant). Totals: %g ms async, %g ms sync. %u hits, %u misses.\n", v24 * 1000.0, v6, *((void *)this + 8), *((double *)this + 38) * 1000.0, *((double *)this + 39) * 1000.0, *((void *)this + 36), *((void *)this + 37));
  *((double *)this + 38) = v24 + *((double *)this + 38);
  os_unfair_lock_unlock((os_unfair_lock_t)this);
}

void sub_1AF908EF4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

double AG::absolute_time_to_seconds(AG *this)
{
  {
    AG::absolute_time_to_seconds(unsigned long long)::time_scale = AG::absolute_time_to_seconds(unsigned long long)::$_0::operator()();
  }
  return *(double *)&AG::absolute_time_to_seconds(unsigned long long)::time_scale * (double)(unint64_t)this;
}

void sub_1AF908F7C(_Unwind_Exception *a1)
{
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::less<AG::anonymous namespace'::TypeDescriptorCache::QueueEntry> &,AG::anonymous namespace'::TypeDescriptorCache::QueueEntry*>(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a3 - 2;
  if (a3 >= 2)
  {
    unint64_t v4 = v3 >> 1;
    int v5 = *(_DWORD *)(result + 16 * (v3 >> 1) + 12);
    int v6 = *(_DWORD *)(a2 - 4);
    if (v5 < v6)
    {
      uint64_t v8 = *(void *)(a2 - 16);
      uint64_t v7 = a2 - 16;
      uint64_t v10 = v8;
      int v11 = *(_DWORD *)(v7 + 8);
      do
      {
        int v9 = (_OWORD *)v7;
        uint64_t v7 = result + 16 * v4;
        _OWORD *v9 = *(_OWORD *)v7;
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
      }
      while (*(_DWORD *)(result + 16 * v4 + 12) < v6);
      *(void *)uint64_t v7 = v10;
      *(_DWORD *)(v7 + 8) = v11;
      *(_DWORD *)(v7 + 12) = v6;
    }
  }
  return result;
}

void *AG::details::realloc_vector<unsigned long,16ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, 16 * a5);
      free(v7);
      unint64_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(16 * a5);
    size_t v9 = v8 >> 4;
    if (v8 >> 4 != *a4)
    {
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x8734B07FuLL);
      if (!v10) {
        AG::precondition_failure((AG *)"allocation failure", v11);
      }
      unint64_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 16 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

double AG::absolute_time_to_seconds(unsigned long long)::$_0::operator()()
{
  if (mach_timebase_info(&info)) {
    return NAN;
  }
  LODWORD(v0) = info.numer;
  LODWORD(v1) = info.denom;
  return (double)v0 / (double)v1 * 0.000000001;
}

uint64_t AG::LayoutDescriptor::compare_existential_values(AG::LayoutDescriptor *this, const AG::swift::existential_type_metadata *a2, unsigned __int8 *a3, const unsigned __int8 *a4)
{
  LODWORD(v4) = a4;
  uint64_t result = AG::swift::existential_type_metadata::dynamic_type(this, a2);
  if (result)
  {
    size_t v9 = (AG::LayoutDescriptor *)result;
    if (result == AG::swift::existential_type_metadata::dynamic_type(this, a3))
    {
      uint64_t v10 = (AG::LayoutDescriptor *)AG::swift::existential_type_metadata::project_value(this, a2);
      int v11 = (const unsigned __int8 *)AG::swift::existential_type_metadata::project_value(this, a3);
      if (v10 == (AG::LayoutDescriptor *)v11)
      {
        return 1;
      }
      else
      {
        unint64_t v12 = v11;
        if (v11 == a3 && v10 == a2) {
          unint64_t v4 = v4;
        }
        else {
          unint64_t v4 = v4 & 0xFFFFFEFF;
        }
        uint64_t v14 = AG::LayoutDescriptor::fetch(v9, (const AG::swift::metadata *)v4, 0);
        if (v14 == (AG::LayoutDescriptor *)1) {
          uint64_t v14 = 0;
        }
        int v16 = *(const unsigned __int8 **)(*((void *)v9 - 1) + 64);
        return AG::LayoutDescriptor::compare(v14, v10, v12, v16, v4, v15);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t AG::swift::existential_type_metadata::dynamic_type(AG::swift::existential_type_metadata *this, void *a2)
{
  int v2 = *((_DWORD *)this + 2);
  if ((v2 & 0x3F000000) != 0) {
    int v3 = 2;
  }
  else {
    int v3 = v2 >= 0;
  }
  if (!v3) {
    return a2[3];
  }
  if (v3 == 1) {
    return MEMORY[0x1F4186610](*a2);
  }
  return 0;
}

void *AG::swift::existential_type_metadata::project_value(AG::swift::existential_type_metadata *this, void *a2)
{
  int v2 = *((_DWORD *)this + 2);
  if ((v2 & 0x3F000000) != 0) {
    int v3 = 2;
  }
  else {
    int v3 = v2 >= 0;
  }
  if (v3 == 2) {
    return 0;
  }
  if (!v3)
  {
    int v4 = *(_DWORD *)(*(void *)(a2[3] - 8) + 80);
    if ((v4 & 0x20000) != 0) {
      return (void *)(*a2 + ((v4 + 16) & ~(unint64_t)v4));
    }
  }
  return a2;
}

void *AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(uint64_t *a1, unint64_t *a2)
{
  uint64_t result = AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::enter(a1, a2);
  unint64_t v5 = a2[4];
  if (v5)
  {
    unint64_t v6 = a2[3];
    unint64_t v7 = v6 + 40 * v5;
    char v8 = 1;
    do
    {
      if (v8) {
        char v9 = 8;
      }
      else {
        char v9 = 12;
      }
      if (v8) {
        int v10 = 9;
      }
      else {
        int v10 = 13;
      }
      if (v8) {
        unsigned int v11 = 11;
      }
      else {
        unsigned int v11 = 21;
      }
      unsigned int v12 = *(_DWORD *)v6 + v10;
      unint64_t v13 = (void *)*a1;
      if (v12 <= v11)
      {
        uint64_t v20 = v13[65];
        if (v13[66] < (unint64_t)(v20 + 1))
        {
          uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v20 + 1);
          uint64_t v20 = v13[65];
        }
        BOOL v21 = (void *)v13[64];
        if (!v21) {
          BOOL v21 = v13;
        }
        *((unsigned char *)v21 + v20) = v12;
        ++v13[65];
      }
      else
      {
        uint64_t v14 = v13[65];
        if (v13[66] < (unint64_t)(v14 + 1))
        {
          uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v14 + 1);
          uint64_t v14 = v13[65];
        }
        unsigned int v15 = (void *)v13[64];
        if (!v15) {
          unsigned int v15 = v13;
        }
        *((unsigned char *)v15 + v14) = v9;
        ++v13[65];
        int v16 = (void *)*a1;
        unsigned int v17 = *(_DWORD *)v6;
        uint64_t v18 = *(void *)(*a1 + 520);
        do
        {
          if (v16[66] < (unint64_t)(v18 + 1))
          {
            uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow(v16, v18 + 1);
            uint64_t v18 = v16[65];
          }
          unint64_t v19 = (void *)v16[64];
          if (!v19) {
            unint64_t v19 = v16;
          }
          *((unsigned char *)v19 + v18) = v17 & 0x7F | ((v17 > 0x7F) << 7);
          uint64_t v18 = v16[65] + 1;
          v16[65] = v18;
          BOOL v35 = v17 > 0x7F;
          v17 >>= 7;
        }
        while (v35);
      }
      if (v8)
      {
        uint64_t v22 = *a1;
        unint64_t v23 = a2[2];
        unint64_t v24 = *(void *)(*a1 + 520);
        unint64_t v25 = v24 + 8;
        if (v24 <= 0xFFFFFFFFFFFFFFF7 && *(void *)(*a1 + 528) < v25) {
          uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v24 + 8);
        }
        *(void *)(v22 + 520) = v25;
        uint64_t v27 = *(void *)(v22 + 512);
        if (!v27) {
          uint64_t v27 = v22;
        }
        *(void *)(v27 + v24) = v23;
      }
      unint64_t v28 = a1[1];
      uint64_t v49 = *a1;
      unint64_t v50 = v28;
      unsigned __int8 v51 = 0;
      uint64_t v29 = *(void *)(v6 + 24);
      if (v29)
      {
        uint64_t v30 = *(void *)(v6 + 16);
        uint64_t v31 = 56 * v29;
        do
        {
          uint64_t v32 = *(unsigned int *)(v30 + 48);
          if (v32 == -1) {
            std::__throw_bad_variant_access[abi:ne180100]();
          }
          uint64_t v52 = &v49;
          uint64_t result = (void *)((uint64_t (*)(uint64_t **, uint64_t))off_1F08144D0[v32])(&v52, v30);
          v30 += 56;
          v31 -= 56;
        }
        while (v31);
        unint64_t v33 = a1[1];
        LODWORD(v29) = v51;
        unint64_t v28 = v50;
      }
      else
      {
        unint64_t v33 = v28;
      }
      char v8 = 0;
      unint64_t v34 = *(void *)(*(void *)(a2[2] - 8) + 64) + v33;
      if (*((unsigned __int8 *)a1 + 16) | v29) {
        BOOL v35 = 1;
      }
      else {
        BOOL v35 = v28 > v34;
      }
      char v36 = v35;
      *((unsigned char *)a1 + 16) = v36;
      v6 += 40;
    }
    while (v6 != v7);
  }
  else
  {
    uint64_t v37 = *a1;
    uint64_t v38 = *(void *)(*a1 + 520);
    if (*(void *)(*a1 + 528) < (unint64_t)(v38 + 1))
    {
      uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v38 + 1);
      uint64_t v38 = *(void *)(v37 + 520);
    }
    uint64_t v39 = *(void *)(v37 + 512);
    if (!v39) {
      uint64_t v39 = v37;
    }
    *(unsigned char *)(v39 + v38) = 9;
    ++*(void *)(v37 + 520);
    uint64_t v40 = *a1;
    unint64_t v41 = a2[2];
    unint64_t v42 = *(void *)(*a1 + 520);
    unint64_t v43 = v42 + 8;
    if (v42 <= 0xFFFFFFFFFFFFFFF7 && *(void *)(*a1 + 528) < v43) {
      uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v42 + 8);
    }
    *(void *)(v40 + 520) = v43;
    uint64_t v45 = *(void *)(v40 + 512);
    if (!v45) {
      uint64_t v45 = v40;
    }
    *(void *)(v45 + v42) = v41;
  }
  uint64_t v46 = *a1;
  uint64_t v47 = *(void *)(*a1 + 520);
  if (*(void *)(*a1 + 528) < (unint64_t)(v47 + 1))
  {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v47 + 1);
    uint64_t v47 = *(void *)(v46 + 520);
  }
  uint64_t v48 = *(void *)(v46 + 512);
  if (!v48) {
    uint64_t v48 = v46;
  }
  *(unsigned char *)(v48 + v47) = 22;
  ++*(void *)(v46 + 520);
  a1[1] += a2[1];
  return result;
}

{
  void *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v19;

  uint64_t result = AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::enter(a1, a2);
  unint64_t v5 = *a1;
  unint64_t v6 = *(void *)(*a1 + 520);
  if (*(void *)(*a1 + 528) < (unint64_t)(v6 + 1))
  {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v6 + 1);
    unint64_t v6 = *(void *)(v5 + 520);
  }
  unint64_t v7 = *(void *)(v5 + 512);
  if (!v7) {
    unint64_t v7 = v5;
  }
  *(unsigned char *)(v7 + v6) = 1;
  ++*(void *)(v5 + 520);
  char v8 = *a1;
  char v9 = a2[2];
  int v10 = *(void *)(*a1 + 520);
  unsigned int v11 = v10 + 8;
  if (v10 <= 0xFFFFFFFFFFFFFFF7 && *(void *)(*a1 + 528) < v11) {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v10 + 8);
  }
  *(void *)(v8 + 520) = v11;
  unint64_t v13 = *(void *)(v8 + 512);
  if (!v13) {
    unint64_t v13 = v8;
  }
  *(void *)(v13 + v10) = v9;
  uint64_t v14 = *a1;
  unsigned int v15 = a2[3];
  int v16 = *(void *)(*a1 + 520);
  unsigned int v17 = v16 + 8;
  if (v16 <= 0xFFFFFFFFFFFFFFF7 && *(void *)(*a1 + 528) < v17) {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v16 + 8);
  }
  *(void *)(v14 + 520) = v17;
  unint64_t v19 = *(void *)(v14 + 512);
  if (!v19) {
    unint64_t v19 = v14;
  }
  *(void *)(v19 + v16) = v15;
  a1[1] += a2[1];
  return result;
}

{
  void *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v13;

  uint64_t result = AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::enter(a1, a2);
  unint64_t v5 = *a1;
  unint64_t v6 = *(void *)(*a1 + 520);
  if (*(void *)(*a1 + 528) < (unint64_t)(v6 + 1))
  {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v6 + 1);
    unint64_t v6 = *(void *)(v5 + 520);
  }
  unint64_t v7 = *(void *)(v5 + 512);
  if (!v7) {
    unint64_t v7 = v5;
  }
  *(unsigned char *)(v7 + v6) = 3;
  ++*(void *)(v5 + 520);
  char v8 = *a1;
  char v9 = a2[2];
  int v10 = *(void *)(*a1 + 520);
  unsigned int v11 = v10 + 8;
  if (v10 <= 0xFFFFFFFFFFFFFFF7 && *(void *)(*a1 + 528) < v11) {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v10 + 8);
  }
  *(void *)(v8 + 520) = v11;
  unint64_t v13 = *(void *)(v8 + 512);
  if (!v13) {
    unint64_t v13 = v8;
  }
  *(void *)(v13 + v10) = v9;
  a1[1] += a2[1];
  return result;
}

{
  void *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v18;

  uint64_t result = AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::enter(a1, a2);
  unint64_t v5 = *a1;
  unint64_t v6 = *(void *)(*a1 + 520);
  if (*(void *)(*a1 + 528) < (unint64_t)(v6 + 1))
  {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v6 + 1);
    unint64_t v6 = *(void *)(v5 + 520);
  }
  unint64_t v7 = *(void *)(v5 + 512);
  if (!v7) {
    unint64_t v7 = v5;
  }
  *(unsigned char *)(v7 + v6) = 2;
  ++*(void *)(v5 + 520);
  char v8 = *a1;
  char v9 = a2[2];
  int v10 = *(void *)(*a1 + 520);
  unsigned int v11 = v10 + 8;
  if (v10 <= 0xFFFFFFFFFFFFFFF7 && *(void *)(*a1 + 528) < v11) {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v10 + 8);
  }
  *(void *)(v8 + 520) = v11;
  unint64_t v13 = *(void *)(v8 + 512);
  if (!v13) {
    unint64_t v13 = v8;
  }
  *(void *)(v13 + v10) = v9;
  uint64_t v14 = *a1;
  unsigned int v15 = *(void *)(*a1 + 520);
  int v16 = v15 + 8;
  if (v15 <= 0xFFFFFFFFFFFFFFF7 && *(void *)(*a1 + 528) < v16) {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v15 + 8);
  }
  *(void *)(v14 + 520) = v16;
  uint64_t v18 = *(void *)(v14 + 512);
  if (!v18) {
    uint64_t v18 = v14;
  }
  *(void *)(v18 + v15) = 0;
  a1[1] += a2[1];
  return result;
}

uint64_t AG::LayoutDescriptor::Builder::visit_case(AG::LayoutDescriptor::Builder *this, AG::swift::metadata *a2, int *a3, int a4)
{
  if (*((void *)this + 3) > 7uLL) {
    return 0;
  }
  uint64_t v9 = *((void *)this + 4);
  int v10 = (char *)this + 40;
  if (v9) {
    unsigned int v11 = (uint64_t *)(v9 + 16);
  }
  else {
    unsigned int v11 = (uint64_t *)((char *)this + 40);
  }
  if (a4)
  {
    uint64_t v12 = v11[1];
  }
  else
  {
    uint64_t v13 = *(void *)(*((void *)a2 - 1) + 64);
    *(void *)&long long v61 = *((void *)this + 2);
    *((void *)&v61 + 1) = v13;
    char v62 = a2;
    uint64_t v63 = 0;
    uint64_t v64 = 0;
    uint64_t v65 = 0;
    uint64_t v14 = v11[1];
    if (v11[2] < (unint64_t)(v14 + 1))
    {
      AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)v11, v14 + 1);
      uint64_t v14 = v11[1];
    }
    uint64_t v15 = *v11 + 56 * v14;
    *(_OWORD *)uint64_t v15 = v61;
    *(void *)(v15 + 16) = a2;
    *(void *)(v15 + 24) = 0;
    *(void *)(v15 + 32) = 0;
    *(void *)(v15 + 40) = 0;
    *(_DWORD *)(v15 + 48) = 6;
    uint64_t v12 = v11[1] + 1;
    v11[1] = v12;
  }
  uint64_t v16 = *v11 + 56 * v12;
  if (*(_DWORD *)(v16 - 8) != 6) {
    std::__throw_bad_variant_access[abi:ne180100]();
  }
  unsigned int v17 = (void *)(v16 - 56);
  uint64_t v18 = *(void *)(v16 - 24);
  if (v17[5] < (unint64_t)(v18 + 1))
  {
    AG::vector<AG::LayoutDescriptor::Builder::EnumItem::Case,0ul,unsigned long>::reserve_slow((uint64_t)(v17 + 3), v18 + 1);
    uint64_t v18 = v17[4];
  }
  uint64_t v19 = v17[3] + 40 * v18;
  uint64_t v20 = *((void *)this + 2);
  *(_DWORD *)uint64_t v19 = a4;
  *(void *)(v19 + 8) = v20;
  *(void *)(v19 + 16) = 0;
  *(void *)(v19 + 24) = 0;
  *(void *)(v19 + 32) = 0;
  uint64_t v22 = v17[3];
  uint64_t v21 = v17[4];
  v17[4] = v21 + 1;
  ++*((void *)this + 3);
  *((void *)this + 4) = v22 + 40 * v21;
  int v23 = *a3;
  if ((*a3 & 1) != 0 && !*((_DWORD *)this + 2))
  {
    AG::LayoutDescriptor::Builder::add_field(this, 8);
LABEL_43:
    if (!*(void *)(*((void *)this + 4) + 24))
    {
      uint64_t v53 = v17[3];
      uint64_t v54 = v17[4] - 1;
      v17[4] = v54;
      uint64_t v55 = v53 + 40 * v54;
      v58 = *(void **)(v55 + 16);
      uint64_t v57 = v55 + 16;
      uint64_t v56 = v58;
      if (*(void *)(v57 + 8))
      {
        unint64_t v59 = 0;
        do
        {
          ++v59;
          uint64_t v56 = (void *)(std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v56)
                       + 56);
        }
        while (v59 < *(void *)(v57 + 8));
        uint64_t v56 = *(void **)v57;
      }
      if (v56) {
        free(v56);
      }
    }
    uint64_t result = 1;
    goto LABEL_51;
  }
  uint64_t v26 = a3[1];
  unint64_t v25 = a3 + 1;
  uint64_t v24 = v26;
  if (v26)
  {
    if ((_DWORD *)((char *)v25 + v24))
    {
      uint64_t v27 = AG::swift::metadata::mangled_type_name_ref(a2, (unsigned char *)v25 + v24, 0, 0);
      if (v27)
      {
        unint64_t v28 = (AG::swift::metadata *)v27;
        if (v23)
        {
          if (*(void *)(*(void *)(v27 - 8) + 64))
          {
            uint64_t v48 = (void *)*((void *)this + 4);
            uint64_t v49 = *((void *)this + 2);
            uint64_t v50 = *(void *)(*((void *)a2 - 1) + 64);
            uint64_t v51 = v48[3];
            if (v48[4] < (unint64_t)(v51 + 1))
            {
              AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)(v48 + 2), v51 + 1);
              uint64_t v51 = v48[3];
            }
            uint64_t v52 = v48[2] + 56 * v51;
            *(void *)uint64_t v52 = v49;
            *(void *)(v52 + 8) = v50;
            *(void *)(v52 + 16) = v28;
            *(_DWORD *)(v52 + 48) = 2;
            ++v48[3];
          }
        }
        else
        {
          unsigned int v29 = *((_DWORD *)this + 2);
          *((_DWORD *)this + 2) = AG::LayoutDescriptor::mode_for_type(a2, v29);
          if (AG::LayoutDescriptor::Builder::should_visit_fields(this, v28, 0))
          {
            uint64_t v30 = *((void *)this + 4);
            uint64_t v31 = v30 ? (char *)(v30 + 16) : v10;
            unint64_t v32 = *((void *)v31 + 1);
            if (v32 && (uint64_t v33 = *(void *)v31) != 0 && (v34 = v33 + 56 * v32 - 56, !*(_DWORD *)(v34 + 48)))
            {
              unint64_t v36 = *(void *)v34;
              unint64_t v35 = *(void *)(v34 + 8);
            }
            else
            {
              unint64_t v35 = 0;
              unint64_t v36 = -1;
            }
            if ((AG::swift::metadata::visit(v28, this) & 1) == 0)
            {
              v60[0] = v32;
              v60[1] = v36;
              v60[2] = v35;
              AG::LayoutDescriptor::Builder::revert((uint64_t)this, v60);
              uint64_t v37 = *((void *)this + 4);
              uint64_t v38 = *(void *)(v37 + 24);
              if (v38)
              {
                uint64_t v39 = *(void *)(v37 + 16);
                uint64_t v40 = 56 * v38;
                do
                {
                  uint64_t v39 = std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor(v39)
                      + 56;
                  v40 -= 56;
                }
                while (v40);
              }
              *(void *)(v37 + 24) = 0;
              uint64_t v41 = *(void *)(*((void *)v28 - 1) + 64);
              if (v41)
              {
                unint64_t v42 = (void *)*((void *)this + 4);
                uint64_t v43 = *((void *)this + 2);
                uint64_t v44 = v42[3];
                if (v42[4] < (unint64_t)(v44 + 1))
                {
                  AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)(v42 + 2), v44 + 1);
                  uint64_t v44 = v42[3];
                }
                uint64_t v45 = v42[2] + 56 * v44;
                *(void *)uint64_t v45 = v43;
                *(void *)(v45 + 8) = v41;
                *(_DWORD *)(v45 + 48) = 0;
                ++v42[3];
              }
            }
          }
          *((_DWORD *)this + 2) = v29;
        }
        goto LABEL_43;
      }
    }
  }
  uint64_t v46 = *v11;
  uint64_t v47 = v11[1] - 1;
  v11[1] = v47;
  std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor(v46 + 56 * v47);
  uint64_t result = 0;
LABEL_51:
  --*((void *)this + 3);
  *((void *)this + 4) = v9;
  return result;
}

void sub_1AF909A70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  *(_DWORD *)(v13 + 8) = v14;
  _Unwind_Resume(exception_object);
}

uint64_t AG::LayoutDescriptor::make_layout(AG::swift::metadata *a1, uint64_t a2, int a3)
{
  unsigned int v5 = AG::LayoutDescriptor::mode_for_type(a1, a2);
  uint64_t v24 = &unk_1F0813E38;
  unsigned int v25 = v5;
  int v26 = a3;
  long long v27 = 0u;
  *(_OWORD *)unint64_t v28 = 0u;
  long long v29 = 0u;
  if (a3 == 2)
  {
    char v15 = AG::swift::metadata::visit_heap(a1, (AG::swift::metadata_visitor *)&v24, 2);
  }
  else if (a3 == 1)
  {
    if ((unint64_t)(*(void *)a1 - 2048) <= 0xFFFFFFFFFFFFF800)
    {
      unsigned int v16 = (*(unsigned char *)(*((void *)a1 - 1) + 82) & 1) != 0 ? 2 : 3;
      if (v5 >= v16)
      {
        uint64_t v7 = AG::swift::metadata::equatable(a1);
        if (v7)
        {
          uint64_t v8 = v27;
          if (v28[0]) {
            uint64_t v9 = (void **)((char *)v28[0] + 16);
          }
          else {
            uint64_t v9 = &v28[1];
          }
          uint64_t v10 = *(void *)(*((void *)a1 - 1) + 64);
          if (v28[0]) {
            unsigned int v11 = (uint64_t *)((char *)v28[0] + 24);
          }
          else {
            unsigned int v11 = (uint64_t *)&v29;
          }
          uint64_t v12 = *v11;
          unint64_t v13 = *v11 + 1;
          unsigned int v17 = (char *)v28[0] + 32;
          if (!v28[0]) {
            unsigned int v17 = (char *)&v29 + 8;
          }
          if (*(void *)v17 >= v13) {
            goto LABEL_35;
          }
LABEL_48:
          int v23 = v9;
          AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)v9, v13);
          uint64_t v12 = *v11;
          uint64_t v9 = v23;
LABEL_35:
          uint64_t v18 = (uint64_t)*v9 + 56 * v12;
          *(void *)uint64_t v18 = v8;
          *(void *)(v18 + 8) = v10;
          *(void *)(v18 + 16) = a1;
          *(void *)(v18 + 24) = v7;
          *(_DWORD *)(v18 + 48) = 1;
          ++*v11;
LABEL_39:
          uint64_t v19 = AG::LayoutDescriptor::Builder::commit((AG::LayoutDescriptor::Builder *)&v24, a1);
          goto LABEL_41;
        }
      }
    }
    char v15 = AG::swift::metadata::visit_heap(a1, (AG::swift::metadata_visitor *)&v24, 5);
  }
  else
  {
    if (a3) {
      goto LABEL_40;
    }
    if (*(unsigned char *)(*((void *)a1 - 1) + 82)) {
      unsigned int v6 = 2;
    }
    else {
      unsigned int v6 = 3;
    }
    if (v5 >= v6)
    {
      uint64_t v7 = AG::swift::metadata::equatable(a1);
      if (v7)
      {
        uint64_t v8 = v27;
        if (v28[0]) {
          uint64_t v9 = (void **)((char *)v28[0] + 16);
        }
        else {
          uint64_t v9 = &v28[1];
        }
        uint64_t v10 = *(void *)(*((void *)a1 - 1) + 64);
        if (v28[0]) {
          unsigned int v11 = (uint64_t *)((char *)v28[0] + 24);
        }
        else {
          unsigned int v11 = (uint64_t *)&v29;
        }
        uint64_t v12 = *v11;
        unint64_t v13 = *v11 + 1;
        int v14 = (char *)v28[0] + 32;
        if (!v28[0]) {
          int v14 = (char *)&v29 + 8;
        }
        if (*(void *)v14 >= v13) {
          goto LABEL_35;
        }
        goto LABEL_48;
      }
    }
    char v15 = AG::swift::metadata::visit(a1, (AG::swift::metadata_visitor *)&v24);
  }
  if (v15) {
    goto LABEL_39;
  }
LABEL_40:
  uint64_t v19 = 0;
LABEL_41:
  uint64_t v24 = &unk_1F0813E38;
  uint64_t v20 = v28[1];
  if ((void)v29)
  {
    unint64_t v21 = 0;
    do
    {
      ++v21;
      uint64_t v20 = (void *)(std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v20)
                   + 56);
    }
    while (v21 < (unint64_t)v29);
    uint64_t v20 = v28[1];
  }
  if (v20) {
    free(v20);
  }
  return v19;
}

void sub_1AF909D5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  AG::LayoutDescriptor::Builder::~Builder((AG::LayoutDescriptor::Builder *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 48);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_1F0814498[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 48) = -1;
  return a1;
}

uint64_t AG::swift::metadata::visit(AG::swift::metadata *this, AG::swift::metadata_visitor *a2)
{
  uint64_t v4 = *(void *)this;
  if (*(void *)this > 0x7FFuLL) {
    uint64_t v4 = 0;
  }
  if (v4 > 767)
  {
    switch(v4)
    {
      case 768:
        {
          AG::swift::metadata::visit(AG::swift::metadata_visitor &)const::native_object = AG::swift::metadata::mangled_type_name_ref(this, "Bo", 1, 0);
        }
        uint64_t v10 = *(void *)a2;
        if ((AG::swift::metadata *)AG::swift::metadata::visit(AG::swift::metadata_visitor &)const::native_object != this)
        {
          unsigned int v11 = *(uint64_t (**)(AG::swift::metadata_visitor *))v10;
          goto LABEL_53;
        }
        int v26 = *(uint64_t (**)(AG::swift::metadata_visitor *, AG::swift::metadata *))(v10 + 56);
        return v26(a2, this);
      case 769:
        unint64_t v19 = *((void *)this + 1);
        if (!v19) {
          return 1;
        }
        uint64_t v20 = (char *)this + 48;
        unint64_t v21 = 1;
        break;
      case 770:
        unsigned int v16 = *(uint64_t (**)(AG::swift::metadata_visitor *, AG::swift::metadata *))(*(void *)a2 + 48);
        unsigned int v17 = a2;
        uint64_t v18 = this;
        return v16(v17, v18);
      case 771:
        unsigned int v16 = *(uint64_t (**)(AG::swift::metadata_visitor *, AG::swift::metadata *))(*(void *)a2 + 40);
        unsigned int v17 = a2;
        uint64_t v18 = this;
        return v16(v17, v18);
      default:
        goto LABEL_52;
    }
    while (1)
    {
      if (*((void *)v20 - 3))
      {
        if (!(*(unsigned int (**)(AG::swift::metadata_visitor *))(*(void *)a2 + 8))(a2)) {
          return 0;
        }
        unint64_t v19 = *((void *)this + 1);
      }
      v20 += 16;
      if (v21++ >= v19) {
        return 1;
      }
    }
  }
  if ((unint64_t)(v4 - 513) < 2)
  {
    uint64_t v12 = (_DWORD *)AG::swift::metadata::descriptor(this);
    if (v12)
    {
      if ((*v12 & 0x1Fu) - 17 <= 1)
      {
        unint64_t v13 = v12 + 4;
        uint64_t v14 = (int)v12[4];
        if (v14)
        {
          char v15 = (v14 & 3) == 1
              ? *(_DWORD **)((char *)v13 + (v14 & 0xFFFFFFFFFFFFFFFCLL))
              : (_DWORD *)((char *)v13 + v14);
          if ((v12[5] & 0xFFFFFF) != 0)
          {
            unint64_t v27 = v15[3];
            if (v27)
            {
              uint64_t v28 = 0;
              BOOL v24 = 0;
              long long v29 = v15 + 4;
              do
              {
                if (v29[1]
                  && !(*(unsigned int (**)(AG::swift::metadata_visitor *, AG::swift::metadata *, _DWORD *, uint64_t))(*(void *)a2 + 24))(a2, this, v29, v28))
                {
                  break;
                }
                BOOL v24 = ++v28 >= v27;
                v29 += 3;
              }
              while (v27 != v28);
            }
            else
            {
              return 1;
            }
            return v24;
          }
        }
      }
    }
  }
  else
  {
    if (!v4)
    {
      unsigned int v16 = *(uint64_t (**)(AG::swift::metadata_visitor *, AG::swift::metadata *))(*(void *)a2 + 32);
      unsigned int v17 = a2;
      uint64_t v18 = this;
      return v16(v17, v18);
    }
    if (v4 == 512)
    {
      unsigned int v5 = (_DWORD *)AG::swift::metadata::descriptor(this);
      if (v5)
      {
        unsigned int v6 = v5;
        if ((*v5 & 0x1Fu) - 17 <= 1)
        {
          uint64_t v7 = v5 + 4;
          uint64_t v8 = (int)v5[4];
          if (v8)
          {
            if (v5[6] && v5[5])
            {
              if ((v8 & 3) == 1) {
                uint64_t v9 = *(char **)((char *)v7 + (v8 & 0xFFFFFFFFFFFFFFFCLL));
              }
              else {
                uint64_t v9 = (char *)v7 + v8;
              }
              unint64_t v30 = 0;
              uint64_t v31 = v9 + 16;
              do
              {
                unint64_t v32 = v6[5];
                BOOL v24 = v30 >= v32;
                if (v30 >= v32) {
                  break;
                }
                char v33 = (*(uint64_t (**)(AG::swift::metadata_visitor *, AG::swift::metadata *, char *))(*(void *)a2 + 16))(a2, this, v31);
                v31 += 12;
                ++v30;
              }
              while ((v33 & 1) != 0);
              return v24;
            }
          }
        }
      }
    }
  }
LABEL_52:
  unsigned int v11 = **(uint64_t (***)(AG::swift::metadata_visitor *))a2;
LABEL_53:
  return v11(a2);
}

void sub_1AF90A300(_Unwind_Exception *a1)
{
}

uint64_t AG::swift::metadata_visitor::visit_field(uint64_t a1, AG::swift::metadata *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v6 = *(int *)(a3 + 4);
  uint64_t v7 = (unsigned char *)(v6 + a3 + 4);
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  unsigned int v16 = 0;
  unsigned int v11 = (void *)AG::swift::metadata::mangled_type_name_ref(a2, v7, 0, (int *)&v16);
  if (!v11) {
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  uint64_t v12 = *(v11 - 1);
  if (*(void *)(v12 + 64) >= a5) {
    unint64_t v13 = a5;
  }
  else {
    unint64_t v13 = *(void *)(v12 + 64);
  }
  if (*v11 == 772) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = *(void *)(v12 + 64);
  }
  return (*(uint64_t (**)(uint64_t, void *, void, uint64_t, unint64_t))(*(void *)a1 + 8))(a1, v11, v16, a4, v14);
}

uint64_t AG::LayoutDescriptor::Builder::visit_element(AG::LayoutDescriptor::Builder *this, AG::swift::metadata *a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a5)
  {
    *((void *)this + 2) += a4;
    if (a3)
    {
      AG::LayoutDescriptor::Builder::add_field(this, a5);
    }
    else
    {
      unsigned int v9 = *((_DWORD *)this + 2);
      *((_DWORD *)this + 2) = AG::LayoutDescriptor::mode_for_type(a2, v9);
      if (AG::LayoutDescriptor::Builder::should_visit_fields(this, a2, 0))
      {
        uint64_t v10 = *((void *)this + 4);
        unsigned int v11 = v10 ? (AG::LayoutDescriptor::Builder *)(v10 + 16) : (AG::LayoutDescriptor::Builder *)((char *)this + 40);
        unint64_t v12 = *((void *)v11 + 1);
        if (v12 && (uint64_t v13 = *(void *)v11) != 0 && (v14 = v13 + 56 * v12 - 56, !*(_DWORD *)(v14 + 48)))
        {
          uint64_t v16 = *(void *)v14;
          uint64_t v15 = *(void *)(v14 + 8);
        }
        else
        {
          uint64_t v15 = 0;
          uint64_t v16 = -1;
        }
        if ((AG::swift::metadata::visit(a2, this) & 1) == 0)
        {
          *(void *)&long long v23 = v16;
          *((void *)&v23 + 1) = v15;
          uint64_t v17 = *((void *)this + 4);
          if (v17) {
            uint64_t v18 = (void *)(v17 + 16);
          }
          else {
            uint64_t v18 = (void *)((char *)this + 40);
          }
          for (unint64_t i = v18[1]; i > v12; unint64_t i = v18[1])
          {
            unint64_t v20 = i - 1;
            v18[1] = v20;
            std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor(*v18 + 56 * v20);
          }
          if (i) {
            BOOL v21 = v16 == -1;
          }
          else {
            BOOL v21 = 1;
          }
          if (!v21) {
            std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>::operator=[abi:ne180100]<AG::LayoutDescriptor::Builder::DataItem&,0,AG::LayoutDescriptor::Builder::DataItem,0ul,0>(*v18 + 56 * i - 56, &v23);
          }
          AG::LayoutDescriptor::Builder::add_field(this, a5);
        }
      }
      *((_DWORD *)this + 2) = v9;
    }
    *((void *)this + 2) -= a4;
  }
  return 1;
}

void sub_1AF90A594(_Unwind_Exception *a1)
{
  *(_DWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t AG::swift::metadata::mangled_type_name_ref(AG::swift::metadata *a1, unsigned char *a2, int a3, int *a4)
{
  if (!a2) {
    return 0;
  }
  BOOL v8 = (AG::swift::class_type_descriptor *)AG::swift::metadata::descriptor(a1);
  unsigned int v9 = v8;
  if (!v8 || (*(_DWORD *)v8 & 0x80) == 0) {
    goto LABEL_9;
  }
  int v10 = *(_DWORD *)v8 & 0x1F;
  if ((v10 - 17) < 2)
  {
    unsigned int v11 = (char *)a1 + 16;
    goto LABEL_10;
  }
  if (v10 == 16) {
    unsigned int v11 = (char *)a1 + 8 * AG::swift::class_type_descriptor::immediate_members_offset(v8);
  }
  else {
LABEL_9:
  }
    unsigned int v11 = 0;
LABEL_10:
  unsigned int v13 = *a2;
  uint64_t v14 = a2;
  if (*a2)
  {
    uint64_t v14 = a2;
    do
    {
      if (v13 >= 0x20) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = 9;
      }
      if (v13 >= 0x18) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = 5;
      }
      v14 += v16;
      unsigned int v13 = *v14;
    }
    while (*v14);
  }
  unint64_t v17 = v14 - a2;
  uint64_t TypeByMangledNameInContext = swift_getTypeByMangledNameInContext();
  if (TypeByMangledNameInContext) {
    BOOL v18 = 1;
  }
  else {
    BOOL v18 = a3 == 0;
  }
  if (!v18)
  {
    memset(&v32, 0, sizeof(v32));
    if (v14 == a2)
    {
      std::string::size_type v24 = 0;
      char v23 = 0;
    }
    else
    {
      uint64_t v31 = a4;
      unint64_t v19 = a2;
      uint64_t v20 = v14 - a2;
      do
      {
        unsigned int v22 = *v19++;
        unsigned int v21 = v22;
        if (v22 == 92)
        {
          std::string::append(&v32, "\\\\"", 2uLL);
        }
        else
        {
          if (v21 - 32 > 0x5E)
          {
            std::string::push_back(&v32, 92);
            std::string::push_back(&v32, (v21 >> 6) | 0x30);
            std::string::push_back(&v32, (v21 >> 3) & 7 | 0x30);
            LOBYTE(v21) = v21 & 7 | 0x30;
          }
          std::string::push_back(&v32, v21);
        }
        --v20;
      }
      while (v20);
      char v23 = HIBYTE(v32.__r_.__value_.__r.__words[2]);
      a4 = v31;
      std::string::size_type v24 = v32.__r_.__value_.__r.__words[0];
    }
    uint64_t TypeName = swift_getTypeName();
    unint64_t v27 = &v32;
    if (v23 < 0) {
      unint64_t v27 = (std::string *)v24;
    }
    AG::non_fatal_precondition_failure((AG *)"Swift metadata failure: \"%s\", context %s (%p), args %p", v26, v27, TypeName, v9, v11);
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v32.__r_.__value_.__l.__data_);
    }
  }
  if (a4)
  {
    if (TypeByMangledNameInContext)
    {
      *a4 = 0;
      if (v17 >= 3 && a2[v17 - 2] == 88)
      {
        int v28 = (char)a2[v17 - 1];
        switch(v28)
        {
          case 'o':
            int v29 = 2;
            goto LABEL_47;
          case 'w':
            int v29 = 1;
            goto LABEL_47;
          case 'u':
            int v29 = 3;
LABEL_47:
            *a4 = v29;
            break;
        }
      }
    }
  }
  return TypeByMangledNameInContext;
}

void sub_1AF90A7F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AG::LayoutDescriptor::mode_for_type(AG::swift::metadata *a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = AG::swift::metadata::descriptor(a1);
    if (v3)
    {
      unint64_t v4 = v3;
      unint64_t v7 = *(void *)(v5 + 264);
      if (v7)
      {
        BOOL v8 = *(void **)(v5 + 256);
        unsigned int v9 = &v8[2 * v7];
        do
        {
          unint64_t v10 = v7 >> 1;
          unsigned int v11 = &v8[2 * (v7 >> 1)];
          unint64_t v13 = *v11;
          unint64_t v12 = v11 + 2;
          v7 += ~(v7 >> 1);
          if (v4 > v13) {
            BOOL v8 = v12;
          }
          else {
            unint64_t v7 = v10;
          }
        }
        while (v7);
        if (v8 != v9 && *v8 == v4) {
          a2 = *((unsigned int *)v8 + 2);
        }
      }
      os_unfair_lock_unlock(v6);
    }
  }
  return a2;
}

uint64_t AG::swift::metadata::descriptor(AG::swift::metadata *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this > 0x7FFuLL) {
    uint64_t v1 = 0;
  }
  if ((unint64_t)(v1 - 512) < 3) {
    return *((void *)this + 1);
  }
  uint64_t v2 = 0;
  if (!v1)
  {
    if ((*((unsigned char *)this + 32) & 3) != 0) {
      return *((void *)this + 8);
    }
    else {
      return 0;
    }
  }
  return v2;
}

uint64_t AG::LayoutDescriptor::Builder::should_visit_fields(AG::LayoutDescriptor::Builder *this, const AG::swift::metadata *a2, char a3)
{
  if ((a3 & 1) != 0
    || (uint64_t v5 = AG::LayoutDescriptor::fetch(a2, (const AG::swift::metadata *)(*((_DWORD *)this + 2) | 0x80000200), 1)) == 0)
  {
    if (*(unsigned char *)(*((void *)a2 - 1) + 82)) {
      unsigned int v8 = 2;
    }
    else {
      unsigned int v8 = 3;
    }
    if (*((_DWORD *)this + 2) >= v8 && (uint64_t v9 = AG::swift::metadata::equatable(a2)) != 0)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *((void *)this + 4);
      if (v11) {
        unint64_t v12 = (void *)(v11 + 16);
      }
      else {
        unint64_t v12 = (void *)((char *)this + 40);
      }
      uint64_t v13 = *((void *)this + 2);
      uint64_t v14 = *(void *)(*((void *)a2 - 1) + 64);
      uint64_t v15 = v12[1];
      if (v12[2] < (unint64_t)(v15 + 1))
      {
        char v23 = v12;
        uint64_t v24 = v9;
        AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)v12, v15 + 1);
        unint64_t v12 = v23;
        uint64_t v10 = v24;
        uint64_t v15 = v23[1];
      }
      uint64_t result = 0;
      uint64_t v16 = *v12 + 56 * v15;
      *(void *)uint64_t v16 = v13;
      *(void *)(v16 + 8) = v14;
      *(void *)(v16 + 16) = a2;
      *(void *)(v16 + 24) = v10;
      *(_DWORD *)(v16 + 48) = 1;
      ++v12[1];
    }
    else
    {
      return 1;
    }
  }
  else
  {
    uint64_t v6 = v5;
    if (v5 == (AG *)1)
    {
      AG::LayoutDescriptor::Builder::add_field(this, *(void *)(*((void *)a2 - 1) + 64));
      return 0;
    }
    else
    {
      uint64_t v17 = *((void *)this + 4);
      if (v17) {
        BOOL v18 = (void *)(v17 + 16);
      }
      else {
        BOOL v18 = (void *)((char *)this + 40);
      }
      uint64_t v19 = *((void *)this + 2);
      uint64_t v20 = *(void *)(*((void *)a2 - 1) + 64);
      uint64_t v21 = v18[1];
      if (v18[2] < (unint64_t)(v21 + 1))
      {
        unsigned int v25 = v5;
        AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)v18, v21 + 1);
        uint64_t v6 = v25;
        uint64_t v21 = v18[1];
      }
      uint64_t result = 0;
      uint64_t v22 = *v18 + 56 * v21;
      *(void *)uint64_t v22 = v19;
      *(void *)(v22 + 8) = v20;
      *(void *)(v22 + 16) = v6;
      *(_DWORD *)(v22 + 48) = 5;
      ++v18[1];
    }
  }
  return result;
}

uint64_t AGCompareValues(AG::LayoutDescriptor *a1, unsigned __int8 *a2, AG::LayoutDescriptor *this, AG::swift::metadata *a4)
{
  unsigned int v8 = (AG::LayoutDescriptor **)AG::LayoutDescriptor::fetch(this, a4, 0);
  if (v8 == (AG::LayoutDescriptor **)1) {
    unsigned int v8 = 0;
  }
  uint64_t v9 = *(char **)(*((void *)this - 1) + 64);
  return AG::LayoutDescriptor::compare(v8, a1, a2, v9, (unint64_t *)a4);
}

AG *AG::LayoutDescriptor::fetch(AG::LayoutDescriptor *this, const AG::swift::metadata *a2, int a3)
{
  int v4 = (int)a2;
}

void *AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,56ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,56ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  int v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(56 * a3);
    unint64_t v6 = v5 / 0x38;
    if (v5 / 0x38 != *a2)
    {
      unint64_t v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      int v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t AG::swift::metadata::equatable(AG::swift::metadata *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this > 0x7FFuLL) {
    uint64_t v1 = 0;
  }
  if ((unint64_t)(v1 - 512) < 3)
  {
LABEL_6:
    return swift_conformsToProtocol();
  }
  if (v1)
  {
    uint64_t result = 0;
    if (v1 != 769) {
      return result;
    }
    goto LABEL_6;
  }
  {
    AG::swift::metadata::equatable(void)const::nsobject_conformance = AG::swift::metadata::equatable(void)const::$_1::operator()();
  }
  uint64_t result = swift_conformsToProtocol();
  if (result == AG::swift::metadata::equatable(void)const::nsobject_conformance) {
    return 0;
  }
  return result;
}

void sub_1AF90AE00(_Unwind_Exception *a1)
{
}

uint64_t AG::LayoutDescriptor::Builder::commit(AG::LayoutDescriptor::Builder *this, const AG::swift::metadata *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  size_t v4 = *((void *)this + 6);
  if (*((_DWORD *)this + 3))
  {
    uint64_t v5 = *((void *)this + 5);
    if (v4 != 1) {
      goto LABEL_12;
    }
  }
  else
  {
    if (!v4) {
      return 1;
    }
    if (v4 != 1)
    {
      uint64_t v5 = *((void *)this + 5);
      goto LABEL_12;
    }
    uint64_t v5 = *((void *)this + 5);
    if (!*(_DWORD *)(v5 + 48)) {
      return 1;
    }
  }
  if (v5 && *(_DWORD *)(v5 + 48) == 5 && !*(void *)v5) {
    return *(void *)(v5 + 16);
  }
  size_t v4 = 1;
LABEL_12:
  *(_OWORD *)size = 0u;
  unint64_t v7 = 512;
  uint64_t v25 = 512;
  uint64_t v20 = __dst;
  unint64_t v21 = 0;
  BOOL v22 = 0;
  if (v4)
  {
    uint64_t v8 = 56 * v4;
    do
    {
      uint64_t v9 = *(unsigned int *)(v5 + 48);
      if (v9 == -1) {
        std::__throw_bad_variant_access[abi:ne180100]();
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v20;
      ((void (*)(std::string *, uint64_t))off_1F08144D0[v9])(&__p, v5);
      v5 += 56;
      v8 -= 56;
    }
    while (v8);
    size_t v4 = size[1];
    unint64_t v7 = v25;
  }
  if (v7 < v4 + 1)
  {
    AG::vector<unsigned char,512ul,unsigned long>::reserve_slow(__dst, v4 + 1);
    size_t v4 = size[1];
  }
  uint64_t v10 = (unsigned char *)size[0];
  if (!size[0]) {
    uint64_t v10 = __dst;
  }
  v10[v4] = 0;
  ++size[1];
  if (*((_DWORD *)this + 3))
  {
    if (v22)
    {
      uint64_t v6 = 0;
      goto LABEL_45;
    }
LABEL_27:
    os_unfair_lock_lock(&AG::LayoutDescriptor::Builder::_lock);
    size_t v12 = size[1];
    if (size[1] < 0x400)
    {
      uint64_t v13 = AG::LayoutDescriptor::Builder::_avail;
      if (AG::LayoutDescriptor::Builder::_avail >= size[1])
      {
        uint64_t v6 = AG::LayoutDescriptor::Builder::_buffer;
      }
      else
      {
        AG::LayoutDescriptor::Builder::_avail = 4096;
        uint64_t v6 = (uint64_t)malloc_type_malloc(0x1000uLL, 0xB8FB78BAuLL);
        AG::LayoutDescriptor::Builder::_buffer = v6;
        size_t v12 = size[1];
        uint64_t v13 = AG::LayoutDescriptor::Builder::_avail;
      }
      AG::LayoutDescriptor::Builder::_buffer = v6 + v12;
      AG::LayoutDescriptor::Builder::_avail = v13 - v12;
    }
    else
    {
      uint64_t v6 = (uint64_t)malloc_type_malloc(size[1], 0xC3B1F9DEuLL);
    }
    os_unfair_lock_unlock(&AG::LayoutDescriptor::Builder::_lock);
    if (size[0]) {
      uint64_t v14 = (unsigned char *)size[0];
    }
    else {
      uint64_t v14 = __dst;
    }
    uint64_t v15 = (AG::_anonymous_namespace_ *)memcpy((void *)v6, v14, size[1]);
    {
      memset(&__p, 0, sizeof(__p));
      AG::LayoutDescriptor::print(&__p, (AG::LayoutDescriptor *)v6);
      if (*((_DWORD *)this + 3))
      {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "== Unknown heap type %p ==\n%s");
      }
      else
      {
        uint64_t v16 = AG::swift::metadata::name(a2, 0);
        uint64_t v17 = (FILE *)*MEMORY[0x1E4F143C8];
        if (v16) {
          fprintf(v17, "== %s, %d bytes ==\n%s");
        }
        else {
          fprintf(v17, "== Unknown type %p ==\n%s");
        }
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    goto LABEL_45;
  }
  if (!v22)
  {
    unint64_t v11 = *(void *)(*((void *)a2 - 1) + 64);
    BOOL v22 = v21 > v11;
    if (v21 <= v11) {
      goto LABEL_27;
    }
  }
  uint64_t v6 = 1;
LABEL_45:
  if (size[0]) {
    free((void *)size[0]);
  }
  return v6;
}

void sub_1AF90B19C(_Unwind_Exception *a1)
{
  if (STACK[0x250]) {
    free((void *)STACK[0x250]);
  }
  _Unwind_Resume(a1);
}

char *AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(uint64_t *a1, uint64_t a2)
{
  AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::enter(a1, (unint64_t *)a2);
  size_t v4 = *(AG::LayoutDescriptor **)(a2 + 16);
  uint64_t result = (char *)AG::LayoutDescriptor::length(v4, v5);
  size_t v7 = (size_t)(result - 1);
  if ((unint64_t)(result - 1) > 0x1E)
  {
    int64_t v14 = v4 - (AG::LayoutDescriptor *)AG::LayoutDescriptor::base_address;
    if (v4 - (AG::LayoutDescriptor *)AG::LayoutDescriptor::base_address == (int)(v4
                                                                                - (AG::LayoutDescriptor *)AG::LayoutDescriptor::base_address)
      && *(void *)(a2 + 8) <= 0xFFFEuLL)
    {
      uint64_t v15 = *a1;
      uint64_t v16 = *(void *)(*a1 + 520);
      if (*(void *)(*a1 + 528) < (unint64_t)(v16 + 1))
      {
        uint64_t result = (char *)AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v16 + 1);
        int64_t v14 = v4 - (AG::LayoutDescriptor *)AG::LayoutDescriptor::base_address;
        uint64_t v16 = *(void *)(v15 + 520);
      }
      uint64_t v17 = *(void *)(v15 + 512);
      if (!v17) {
        uint64_t v17 = v15;
      }
      *(unsigned char *)(v17 + v16) = 7;
      ++*(void *)(v15 + 520);
      uint64_t v18 = *a1;
      unint64_t v19 = *(void *)(*a1 + 520);
      unint64_t v20 = v19 + 4;
      if (v19 <= 0xFFFFFFFFFFFFFFFBLL && *(void *)(*a1 + 528) < v20)
      {
        int v45 = v14;
        uint64_t result = (char *)AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v19 + 4);
        LODWORD(v14) = v45;
      }
      *(void *)(v18 + 520) = v20;
      uint64_t v22 = *(void *)(v18 + 512);
      if (!v22) {
        uint64_t v22 = v18;
      }
      *(_DWORD *)(v22 + v19) = v14;
      char v23 = (void *)*a1;
      __int16 v24 = *(_WORD *)(a2 + 8);
      unint64_t v25 = *(void *)(*a1 + 520);
      unint64_t v26 = v25 + 2;
      if (v25 <= 0xFFFFFFFFFFFFFFFDLL && v23[66] < v26)
      {
        __int16 v46 = *(_WORD *)(a2 + 8);
        uint64_t result = (char *)AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v25 + 2);
        __int16 v24 = v46;
      }
      v23[65] = v26;
      unint64_t v27 = (void *)v23[64];
      if (!v27) {
        unint64_t v27 = v23;
      }
      *(_WORD *)((char *)v27 + v25) = v24;
    }
    else
    {
      uint64_t v28 = *a1;
      uint64_t v29 = *(void *)(*a1 + 520);
      if (*(void *)(*a1 + 528) < (unint64_t)(v29 + 1))
      {
        uint64_t result = (char *)AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v29 + 1);
        uint64_t v29 = *(void *)(v28 + 520);
      }
      uint64_t v30 = *(void *)(v28 + 512);
      if (!v30) {
        uint64_t v30 = v28;
      }
      *(unsigned char *)(v30 + v29) = 6;
      ++*(void *)(v28 + 520);
      uint64_t v31 = *a1;
      uint64_t v32 = *(void *)(a2 + 16);
      unint64_t v33 = *(void *)(*a1 + 520);
      unint64_t v34 = v33 + 8;
      if (v33 <= 0xFFFFFFFFFFFFFFF7 && *(void *)(*a1 + 528) < v34)
      {
        unint64_t v44 = *(void *)(*a1 + 520);
        uint64_t result = (char *)AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v33 + 8);
        unint64_t v33 = v44;
      }
      *(void *)(v31 + 520) = v34;
      uint64_t v36 = *(void *)(v31 + 512);
      if (!v36) {
        uint64_t v36 = v31;
      }
      *(void *)(v36 + v33) = v32;
      uint64_t v37 = (void *)*a1;
      unint64_t v38 = *(void *)(a2 + 8);
      uint64_t v39 = *(void *)(*a1 + 520);
      do
      {
        if (v37[66] < (unint64_t)(v39 + 1))
        {
          uint64_t result = (char *)AG::vector<unsigned char,512ul,unsigned long>::reserve_slow(v37, v39 + 1);
          uint64_t v39 = v37[65];
        }
        uint64_t v40 = (void *)v37[64];
        if (!v40) {
          uint64_t v40 = v37;
        }
        *((unsigned char *)v40 + v39) = v38 & 0x7F | ((v38 > 0x7F) << 7);
        uint64_t v39 = v37[65] + 1;
        v37[65] = v39;
        BOOL v41 = v38 > 0x7F;
        v38 >>= 7;
      }
      while (v41);
    }
  }
  else
  {
    uint64_t v8 = (void *)*a1;
    size_t v9 = *(void *)(*a1 + 520);
    size_t v10 = v9 + v7;
    if (v9 >= v9 + v7)
    {
      uint64_t v11 = *a1;
    }
    else
    {
      uint64_t v11 = *a1;
      if (v8[66] < v10)
      {
        uint64_t v43 = (void *)*a1;
        size_t v12 = v9 + v7;
        size_t v13 = *(void *)(*a1 + 520);
        AG::vector<unsigned char,512ul,unsigned long>::reserve_slow(v8, v9 + v7);
        size_t v9 = v13;
        size_t v10 = v12;
        uint64_t v8 = v43;
        uint64_t v11 = *a1;
        size_t v4 = *(AG::LayoutDescriptor **)(a2 + 16);
      }
    }
    v8[65] = v10;
    uint64_t v42 = *(void *)(v11 + 512);
    if (!v42) {
      uint64_t v42 = v11;
    }
    uint64_t result = (char *)memcpy((void *)(v42 + v9), v4, v7);
  }
  a1[1] += *(void *)(a2 + 8);
  return result;
}

unsigned char *AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::enter(unsigned char *result, unint64_t *a2)
{
  uint64_t v3 = result;
  if (result[16])
  {
    result[16] = 1;
  }
  else
  {
    unint64_t v4 = *((void *)result + 1);
    BOOL v5 = *a2 >= v4;
    unint64_t v6 = *a2 - v4;
    result[16] = *a2 < v4;
    if (v5)
    {
      size_t v7 = *(void **)result;
      if (v6 >= 0x41)
      {
        uint64_t v8 = v7[65];
        do
        {
          if (v7[66] < (unint64_t)(v8 + 1))
          {
            uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow(v7, v8 + 1);
            uint64_t v8 = v7[65];
          }
          size_t v9 = (void *)v7[64];
          if (!v9) {
            size_t v9 = v7;
          }
          *((unsigned char *)v9 + v8) = 127;
          uint64_t v8 = v7[65] + 1;
          v7[65] = v8;
          v6 -= 64;
        }
        while (v6 > 0x40);
      }
      if (v6)
      {
        char v10 = (v6 - 1) | 0x40;
        uint64_t v11 = v7[65];
        if (v7[66] < (unint64_t)(v11 + 1))
        {
          uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow(v7, v11 + 1);
          uint64_t v11 = v7[65];
        }
        size_t v12 = (void *)v7[64];
        if (!v12) {
          size_t v12 = v7;
        }
        *((unsigned char *)v12 + v11) = v10;
        ++v7[65];
      }
    }
  }
  *((void *)v3 + 1) = *a2;
  return result;
}

uint64_t AG::LayoutDescriptor::length(AG::LayoutDescriptor *this, const unsigned __int8 *a2)
{
  int v2 = 0;
  uint64_t v3 = this;
  while (1)
  {
    unint64_t v4 = v3;
    int v5 = *(unsigned __int8 *)v3;
    uint64_t v3 = (AG::LayoutDescriptor *)((char *)v3 + 1);
    int v6 = v2;
    uint64_t v7 = 1;
    switch(v5)
    {
      case 0:
        return v4 - this + 1;
      case 1:
      case 2:
        uint64_t v7 = 9;
        goto LABEL_8;
      case 3:
LABEL_8:
        uint64_t v3 = (AG::LayoutDescriptor *)((char *)v4 + v7 + 8);
        continue;
      case 6:
        uint64_t v3 = (AG::LayoutDescriptor *)((char *)v4 + 9);
        do
        {
          int v9 = *(char *)v3;
          uint64_t v3 = (AG::LayoutDescriptor *)((char *)v3 + 1);
        }
        while (v9 < 0);
        continue;
      case 7:
        uint64_t v3 = (AG::LayoutDescriptor *)((char *)v4 + 7);
        continue;
      case 8:
        do
        {
          int v8 = *((char *)v4 + 1);
          unint64_t v4 = (AG::LayoutDescriptor *)((char *)v4 + 1);
        }
        while (v8 < 0);
        goto LABEL_6;
      case 9:
      case 10:
      case 11:
LABEL_6:
        uint64_t v3 = (AG::LayoutDescriptor *)((char *)v4 + 9);
        ++v2;
        continue;
      case 12:
        if (!v2) {
          return v4 - this + 1;
        }
        do
        {
          int v10 = *(char *)v3;
          uint64_t v3 = (AG::LayoutDescriptor *)((char *)v3 + 1);
        }
        while (v10 < 0);
        break;
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
        if (v2) {
          continue;
        }
        return v4 - this + 1;
      case 22:
        --v2;
        if (v6) {
          continue;
        }
        return v4 - this + 1;
      default:
        continue;
    }
  }
}

char *std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem> const&>(uint64_t **a1, uint64_t a2)
{
  return AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(*a1, a2);
}

uint64_t AG::anonymous namespace'::print_layouts(AG::_anonymous_namespace_ *this)
{
  uint64_t v1 = (unsigned int *)&unk_1EB3D3000;
  {
    uint64_t v1 = (_DWORD *)&unk_1EB3D3000;
    if (v3)
    {
      uint64_t v1 = (_DWORD *)&unk_1EB3D3000;
    }
  }
  return v1[196];
}

void *AG::LayoutDescriptor::Builder::add_field(void *this, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = this[4];
    if (v3) {
      unint64_t v4 = (void *)(v3 + 16);
    }
    else {
      unint64_t v4 = this + 5;
    }
    uint64_t v5 = v4[1];
    if (v5
      && *v4
      && !*(_DWORD *)(*v4 + 56 * v5 - 8)
      && (uint64_t v6 = *(void *)(*v4 + 56 * v5 - 48), v6 + *(void *)(*v4 + 56 * v5 - 56) == this[2]))
    {
      *(void *)(*v4 + 56 * v5 - 48) = v6 + a2;
    }
    else
    {
      uint64_t v7 = this[2];
      if (v4[2] < (unint64_t)(v5 + 1))
      {
        this = AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)v4, v5 + 1);
        uint64_t v5 = v4[1];
      }
      uint64_t v8 = *v4 + 56 * v5;
      *(void *)uint64_t v8 = v7;
      *(void *)(v8 + 8) = a2;
      *(_DWORD *)(v8 + 48) = 0;
      ++v4[1];
    }
  }
  return this;
}

uint64_t AGTypeApplyFields2::Visitor::visit_field(uint64_t a1, AG::swift::metadata *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(int *)(a3 + 4);
  if (v8) {
    int v9 = (unsigned char *)(v8 + a3 + 4);
  }
  else {
    int v9 = 0;
  }
  uint64_t v10 = AG::swift::metadata::mangled_type_name_ref(a2, v9, 1, 0);
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(int *)(a3 + 8);
    if (v12) {
      size_t v13 = (const char *)(v12 + a3 + 8);
    }
    else {
      size_t v13 = "";
    }
    return (**(uint64_t (***)(const char *, uint64_t, uint64_t))(a1 + 8))(v13, a4, v11) & 1;
  }
  else
  {
    uint64_t v15 = **(uint64_t (***)(uint64_t))a1;
    return v15(a1);
  }
}

void *std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem> const&>(uint64_t *a1, unint64_t *a2)
{
  return AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(*a1, a2);
}

void *AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(uint64_t a1, unint64_t *a2)
{
  uint64_t result = AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::enter((unsigned char *)a1, a2);
  uint64_t v5 = *(void **)a1;
  unint64_t v6 = a2[1];
  if (v6 >= 0x81)
  {
    uint64_t v7 = v5[65];
    do
    {
      if (v5[66] < (unint64_t)(v7 + 1))
      {
        uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow(v5, v7 + 1);
        uint64_t v7 = v5[65];
      }
      uint64_t v8 = (void *)v5[64];
      if (!v8) {
        uint64_t v8 = v5;
      }
      *((unsigned char *)v8 + v7) = -1;
      uint64_t v7 = v5[65] + 1;
      v5[65] = v7;
      v6 -= 128;
    }
    while (v6 > 0x80);
  }
  if (v6)
  {
    char v9 = (v6 - 1) | 0x80;
    uint64_t v10 = v5[65];
    if (v5[66] < (unint64_t)(v10 + 1))
    {
      uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow(v5, v10 + 1);
      uint64_t v10 = v5[65];
    }
    uint64_t v11 = (void *)v5[64];
    if (!v11) {
      uint64_t v11 = v5;
    }
    *((unsigned char *)v11 + v10) = v9;
    ++v5[65];
  }
  *(void *)(a1 + 8) += a2[1];
  return result;
}

uint64_t AG::swift::metadata_visitor::unknown_result(AG::swift::metadata_visitor *this)
{
  return 0;
}

void *AG::vector<AG::LayoutDescriptor::Builder::EnumItem::Case,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,40ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,40ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(40 * a3);
    unint64_t v6 = v5 / 0x28;
    if (v5 / 0x28 != *a2)
    {
      uint64_t v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      unint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem> const&>(uint64_t **a1, unint64_t *a2)
{
  return AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(*a1, a2);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN2AG16LayoutDescriptor7Builder8DataItemENSA_10EqualsItemENSA_12IndirectItemENSA_15ExistentialItemENSA_11HeapRefItemENSA_10NestedItemENSA_8EnumItemEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJSB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int v2 = *(char **)(a2 + 24);
  if (*(void *)(a2 + 32))
  {
    unint64_t v4 = 0;
    do
    {
      size_t v5 = &v2[40 * v4];
      uint64_t v8 = (void *)*((void *)v5 + 2);
      uint64_t v7 = v5 + 16;
      unint64_t v6 = v8;
      if (*((void *)v7 + 1))
      {
        unint64_t v9 = 0;
        do
        {
          ++v9;
          unint64_t v6 = (void *)(std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v6)
                      + 56);
        }
        while (v9 < *((void *)v7 + 1));
        unint64_t v6 = *(void **)v7;
      }
      if (v6) {
        free(v6);
      }
      ++v4;
    }
    while (v4 < *(void *)(a2 + 32));
    int v2 = *(char **)(a2 + 24);
  }
  if (v2)
  {
    free(v2);
  }
}

void *std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem> const&>(uint64_t **a1, unint64_t *a2)
{
  return AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(*a1, a2);
}

uint64_t AG::swift::metadata_visitor::visit_class(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

void *std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem> const&>(uint64_t **a1, uint64_t a2)
{
  return AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(*a1, a2);
}

void *AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(uint64_t *a1, uint64_t a2)
{
  uint64_t result = AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::enter(a1, (unint64_t *)a2);
  uint64_t v5 = *a1;
  int v6 = *(unsigned __int8 *)(a2 + 16);
  uint64_t v7 = *(void *)(*a1 + 520);
  if (*(void *)(*a1 + 528) < (unint64_t)(v7 + 1))
  {
    uint64_t result = AG::vector<unsigned char,512ul,unsigned long>::reserve_slow((void *)*a1, v7 + 1);
    uint64_t v7 = *(void *)(v5 + 520);
  }
  if (v6) {
    char v8 = 5;
  }
  else {
    char v8 = 4;
  }
  uint64_t v9 = *(void *)(v5 + 512);
  if (!v9) {
    uint64_t v9 = v5;
  }
  *(unsigned char *)(v9 + v7) = v8;
  ++*(void *)(v5 + 520);
  a1[1] += *(void *)(a2 + 8);
  return result;
}

uint64_t AG::LayoutDescriptor::Builder::visit_function(AG::LayoutDescriptor::Builder *this, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 10) || !*((_DWORD *)this + 2)) {
    return 0;
  }
  AG::LayoutDescriptor::Builder::add_field(this, 8);
  uint64_t v4 = *((void *)this + 4);
  if (v4) {
    uint64_t v5 = (void *)(v4 + 16);
  }
  else {
    uint64_t v5 = (void *)((char *)this + 40);
  }
  uint64_t v6 = *((void *)this + 2) + 8;
  uint64_t v7 = v5[1];
  if (v5[2] < (unint64_t)(v7 + 1))
  {
    uint64_t v9 = v5;
    uint64_t v10 = v6;
    AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)v5, v7 + 1);
    uint64_t v6 = v10;
    uint64_t v5 = v9;
    uint64_t v7 = v9[1];
  }
  uint64_t v8 = *v5 + 56 * v7;
  *(void *)uint64_t v8 = v6;
  *(void *)(v8 + 8) = 8;
  uint64_t result = 1;
  *(unsigned char *)(v8 + 16) = 1;
  *(_DWORD *)(v8 + 48) = 4;
  ++v5[1];
  return result;
}

uint64_t AG::LayoutDescriptor::Builder::revert(uint64_t result, unint64_t *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  if (v2) {
    uint64_t v3 = (void *)(v2 + 16);
  }
  else {
    uint64_t v3 = (void *)(result + 40);
  }
  uint64_t v4 = a2 + 1;
  for (unint64_t i = v3[1]; i > *a2; unint64_t i = v3[1])
  {
    unint64_t v7 = i - 1;
    v3[1] = v7;
    uint64_t result = std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor(*v3 + 56 * v7);
  }
  if (i) {
    BOOL v8 = *(void *)v4 == -1;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    uint64_t v9 = *v3 + 56 * i - 56;
    return std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>::operator=[abi:ne180100]<AG::LayoutDescriptor::Builder::DataItem&,0,AG::LayoutDescriptor::Builder::DataItem,0ul,0>(v9, v4);
  }
  return result;
}

uint64_t std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>::operator=[abi:ne180100]<AG::LayoutDescriptor::Builder::DataItem&,0,AG::LayoutDescriptor::Builder::DataItem,0ul,0>(uint64_t a1, _OWORD *a2)
{
  if (*(_DWORD *)(a1 + 48)) {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>>::__emplace[abi:ne180100]<0ul,AG::LayoutDescriptor::Builder::DataItem&>(a1, a2);
  }
  else {
    *(_OWORD *)a1 = *a2;
  }
  return a1;
}

uint64_t AG::swift::metadata::visit_heap(AG::swift::metadata *this, AG::swift::metadata_visitor *a2, char a3)
{
  uint64_t v3 = *(void *)this;
  if (*(void *)this > 0x7FFuLL) {
    uint64_t v3 = 0;
  }
  if (v3 == 1280)
  {
    if ((a3 & 4) != 0)
    {
      uint64_t v5 = *((void *)this + 2);
      if (v5) {
        return (*(uint64_t (**)(AG::swift::metadata_visitor *, uint64_t, void, unint64_t, void))(*(void *)a2 + 8))(a2, v5, 0, (*(unsigned __int8 *)(*(void *)(v5 - 8) + 80) + (unint64_t)*((unsigned int *)this + 2)) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v5 - 8) + 80), *(void *)(*(void *)(v5 - 8) + 64));
      }
    }
    return (**(uint64_t (***)(AG::swift::metadata_visitor *))a2)(a2);
  }
  if (v3 != 1024)
  {
    if (!v3 && (a3 & 1) != 0) {
      return AG::swift::metadata::visit_heap_class(this, a2);
    }
    return (**(uint64_t (***)(AG::swift::metadata_visitor *))a2)(a2);
  }
  if ((a3 & 2) == 0) {
    return (**(uint64_t (***)(AG::swift::metadata_visitor *))a2)(a2);
  }
  return AG::swift::metadata::visit_heap_locals(this, a2);
}

uint64_t AG::swift::metadata::visit_heap_locals(AG::swift::metadata *this, AG::swift::metadata_visitor *a2)
{
  uint64_t v3 = (unsigned int *)*((void *)this + 2);
  if (!v3 || v3[1] || (uint64_t v7 = *((unsigned int *)this + 2), !v7))
  {
LABEL_3:
    uint64_t v4 = **(uint64_t (***)(AG::swift::metadata_visitor *))a2;
    return v4(a2);
  }
  if (v3[2])
  {
    int v8 = 0;
    do
    {
      {
        AG::swift::metadata::visit_heap_locals(AG::swift::metadata_visitor &)const::pointer_type = AG::swift::metadata::mangled_type_name_ref(this, "Bp", 1, 0);
      }
      if (!AG::swift::metadata::visit_heap_locals(AG::swift::metadata_visitor &)const::pointer_type) {
        goto LABEL_3;
      }
      uint64_t result = (*(uint64_t (**)(AG::swift::metadata_visitor *, uint64_t, uint64_t, uint64_t, void))(*(void *)a2 + 8))(a2, AG::swift::metadata::visit_heap_locals(AG::swift::metadata_visitor &)const::pointer_type, 3, v7, *(void *)(*((void *)this - 1) + 64));
      if (!result) {
        return result;
      }
      v7 += 8;
    }
    while (++v8 < v3[2]);
  }
  if (!*v3) {
    return 1;
  }
  uint64_t v9 = v3 + 3;
  uint64_t v10 = 3;
  while (1)
  {
    unsigned int v16 = 0;
    uint64_t v11 = (int)v3[v10];
    if (v11) {
      uint64_t v12 = (char *)v9 + v11;
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = AG::swift::metadata::mangled_type_name_ref(this, v12, 0, (int *)&v16);
    if (!v13) {
      return (**(uint64_t (***)(AG::swift::metadata_visitor *))a2)(a2);
    }
    unint64_t v14 = (v7 + *(unsigned __int8 *)(*(void *)(v13 - 8) + 80)) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v13 - 8) + 80);
    uint64_t v15 = *(void *)(*(void *)(v13 - 8) + 64);
    if (((*(uint64_t (**)(AG::swift::metadata_visitor *, uint64_t, void, unint64_t, uint64_t))(*(void *)a2 + 8))(a2, v13, v16, v14, v15) & 1) == 0)break; {
    ++v10;
    }
    uint64_t v7 = v14 + v15;
    ++v9;
    if (v10 - 3 >= (unint64_t)*v3) {
      return 1;
    }
  }
  return 0;
}

void sub_1AF90C28C(_Unwind_Exception *a1)
{
}

void *std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem> const&>(uint64_t **a1, unint64_t *a2)
{
  return AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(*a1, a2);
}

uint64_t AG::LayoutDescriptor::Builder::visit_existential(AG::LayoutDescriptor::Builder *this, const AG::swift::existential_type_metadata *a2)
{
  int v2 = *((_DWORD *)this + 2);
  if (!v2 || v2 == 1 && AG::swift::existential_type_metadata::representation(a2) == 1) {
    return 0;
  }
  uint64_t v6 = *((void *)this + 4);
  if (v6) {
    uint64_t v7 = (void *)(v6 + 16);
  }
  else {
    uint64_t v7 = (void *)((char *)this + 40);
  }
  uint64_t v8 = *((void *)this + 2);
  uint64_t v9 = *(void *)(*((void *)a2 - 1) + 64);
  uint64_t v10 = v7[1];
  if (v7[2] < (unint64_t)(v10 + 1))
  {
    AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)v7, v10 + 1);
    uint64_t v10 = v7[1];
  }
  uint64_t v11 = *v7 + 56 * v10;
  *(void *)uint64_t v11 = v8;
  *(void *)(v11 + 8) = v9;
  *(void *)(v11 + 16) = a2;
  *(_DWORD *)(v11 + 48) = 3;
  ++v7[1];
  return 1;
}

void *std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem> const&>(uint64_t **a1, unint64_t *a2)
{
  return AG::LayoutDescriptor::Builder::Emitter<AG::vector<unsigned char,512ul,unsigned long>>::operator()(*a1, a2);
}

uint64_t AGTypeApplyFields2::Visitor::visit_case(uint64_t a1, AG::swift::metadata *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v8 = *(int *)(a3 + 4);
  if (v8) {
    uint64_t v9 = (unsigned char *)(v8 + a3 + 4);
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = AG::swift::metadata::mangled_type_name_ref(a2, v9, 1, 0);
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(int *)(a3 + 8);
    if (v12) {
      uint64_t v13 = (const char *)(v12 + a3 + 8);
    }
    else {
      uint64_t v13 = "";
    }
    return (**(uint64_t (***)(const char *, void, uint64_t))(a1 + 8))(v13, a4, v11) & 1;
  }
  else
  {
    uint64_t v15 = **(uint64_t (***)(uint64_t))a1;
    return v15(a1);
  }
}

char *AG::anonymous namespace'::print_layouts(void)::$_0::operator()()
{
  uint64_t result = getenv("AG_PRINT_LAYOUTS");
  if (result)
  {
    return (char *)atoi(result);
  }
  return result;
}

uint64_t AG::swift::metadata::equatable(void)const::$_1::operator()()
{
  if (!objc_getClass("NSObject") || !swift_getObjCClassMetadata()) {
    return 0;
  }
  return swift_conformsToProtocol();
}

BOOL AGSubgraphIsDirty(uint64_t a1, char a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  return v2 && ((BYTE2(*(_DWORD *)(v2 + 100)) | HIBYTE(*(_DWORD *)(v2 + 100))) & a2) != 0;
}

void AG::Graph::mark_pending(uint64_t a1, unsigned int a2, int *a3)
{
  int v6 = *a3;
  if ((*a3 & 2) == 0)
  {
    int v7 = *(_DWORD *)(a1 + 232);
    if (v7)
    {
      unsigned int v9 = v7 - 1;
      do
      {
        uint64_t v10 = v9;
        uint64_t v11 = *(void *)(*(void *)(a1 + 224) + 8 * v9);
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)v11 + 264))(v11, a2, 1);
        --v9;
      }
      while (v10);
      int v6 = *a3;
    }
    v6 |= 2u;
    *a3 = v6;
  }
  if ((v6 & 1) == 0)
  {
    int v8 = *(_DWORD *)(a1 + 232);
    if (v8)
    {
      unsigned int v12 = v8 - 1;
      do
      {
        uint64_t v13 = v12;
        uint64_t v14 = *(void *)(*(void *)(a1 + 224) + 8 * v12);
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)v14 + 256))(v14, a2, 1);
        --v12;
      }
      while (v13);
      int v6 = *a3;
    }
    *a3 = v6 | 1;
    if (*((unsigned char *)a3 + 6))
    {
      uint64_t v15 = *(AG::Subgraph **)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00));
      if (v15) {
        AG::Subgraph::add_dirty_flags(v15, *((unsigned char *)a3 + 6));
      }
    }
    AG::Graph::propagate_dirty(a1);
  }
}

AG::Subgraph *AG::Subgraph::add_dirty_flags(AG::Subgraph *this, unsigned __int8 a2)
{
  unsigned int v2 = *((_DWORD *)this + 25);
  if ((a2 & ~HIWORD(v2)) != 0)
  {
    *((_DWORD *)this + 25) = v2 & 0xFF00FFFF | ((BYTE2(v2) | a2) << 16);
    return (AG::Subgraph *)AG::Subgraph::propagate_dirty_flags(this);
  }
  return this;
}

void AG::Subgraph::apply(unint64_t a1, int a2, void (*a3)(void))
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 104))
  {
    int v5 = a2;
    if ((a2 & (*(_DWORD *)(a1 + 100) | (*(_DWORD *)(a1 + 100) >> 8))) != 0)
    {
      int v7 = *(AG::Graph **)(a1 + 40);
      unint64_t v27 = a1;
      uint64_t v28 = v7;
      char v29 = *((unsigned char *)v7 + 408);
      *((unsigned char *)v7 + 408) = 1;
      unsigned int add = atomic_fetch_add(AG::Subgraph::_last_traversal_seed, 1u);
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      uint64_t v33 = 32;
      std::stack<AG::Subgraph const*,AG::vector<AG::Subgraph const*,32ul,unsigned long>>::push[abi:ne180100](__dst, &v27);
      unsigned int v9 = add + 1;
      *(_DWORD *)(a1 + 84) = add + 1;
      for (uint64_t i = v32; v32; uint64_t i = v32)
      {
        while (1)
        {
          uint64_t v11 = v31;
          if (!v31) {
            uint64_t v11 = __dst;
          }
          uint64_t v12 = v11[--i];
          uint64_t v32 = i;
          if (!*(unsigned char *)(v12 + 104)) {
            break;
          }
          if (!i) {
            goto LABEL_37;
          }
        }
        if ((a2 & 0x1000000) != 0 || *(void *)(v12 + 48) == *(void *)(a1 + 48))
        {
          if (!a2 || (v5 & *(_DWORD *)(v12 + 100)) != 0)
          {
            unsigned int v13 = *(_DWORD *)(v12 + 16);
            if (v13)
            {
              uint64_t v14 = AG::data::_shared_table_bytes;
              do
              {
                uint64_t v15 = v13;
                uint64_t v16 = v14 + v13;
                int v17 = *(unsigned __int16 *)(v16 + 20);
                if (*(_WORD *)(v16 + 20))
                {
                  do
                  {
                    unsigned int v18 = v17 + v15;
                    int v19 = (v17 + v15) & 3;
                    if (v19)
                    {
                      if (v19 == 1)
                      {
                        int v17 = *(unsigned __int16 *)(AG::data::_shared_table_bytes + (v18 & 0xFFFFFFFC) + 14);
                        if (a2) {
                          break;
                        }
                      }
                      else if (v19 == 2)
                      {
                        break;
                      }
                    }
                    else
                    {
                      uint64_t v20 = AG::data::_shared_table_bytes + v18;
                      int v17 = *(unsigned __int16 *)(v20 + 4);
                      if (!a2) {
                        goto LABEL_26;
                      }
                      int v21 = *(unsigned __int8 *)(v20 + 6);
                      if (!v21) {
                        break;
                      }
                      if ((v21 & a2) != 0) {
LABEL_26:
                      }
                        a3();
                    }
                  }
                  while (v17);
                  uint64_t v14 = AG::data::_shared_table_bytes;
                }
                unsigned int v13 = *(_DWORD *)(v14 + v15 + 8);
              }
              while (v13);
            }
          }
          uint64_t v22 = *(unsigned int *)(v12 + 72);
          if (v22)
          {
            char v23 = *(void **)(v12 + 64);
            uint64_t v24 = 8 * v22;
            do
            {
              unint64_t v25 = *v23 & 0xFFFFFFFFFFFFFFFCLL;
              unint64_t v27 = v25;
              if ((v5 & (*(_DWORD *)(v25 + 100) | (*(_DWORD *)(v25 + 100) >> 8))) != 0 && *(_DWORD *)(v25 + 84) != v9)
              {
                std::stack<AG::Subgraph const*,AG::vector<AG::Subgraph const*,32ul,unsigned long>>::push[abi:ne180100](__dst, &v27);
                *(_DWORD *)(v27 + 84) = v9;
              }
              ++v23;
              v24 -= 8;
            }
            while (v24);
          }
        }
      }
LABEL_37:
      if (v31) {
        free(v31);
      }
      unint64_t v26 = v28;
      if (v28)
      {
        if (!v29)
        {
          *((unsigned char *)v28 + 408) = 0;
          AG::Graph::invalidate_subgraphs(v26);
        }
      }
    }
  }
}

void sub_1AF90CB04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *std::stack<AG::Subgraph const*,AG::vector<AG::Subgraph const*,32ul,unsigned long>>::push[abi:ne180100](void *__dst, void *a2)
{
  uint64_t v3 = __dst;
  uint64_t v4 = __dst[33];
  size_t v5 = v4 + 1;
  if (__dst[34] < (unint64_t)(v4 + 1))
  {
    __dst = AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>::reserve_slow(__dst, v5);
    uint64_t v4 = v3[33];
    size_t v5 = v4 + 1;
  }
  int v6 = (void *)v3[32];
  if (!v6) {
    int v6 = v3;
  }
  v6[v4] = *a2;
  v3[33] = v5;
  return __dst;
}

uint64_t AGGraphGetAttributeSubgraph(int a1, const char *a2)
{
  uint64_t result = AGGraphGetAttributeSubgraph2(a1, a2);
  if (!result) {
    AG::precondition_failure((AG *)"no subgraph", v3);
  }
  return result;
}

uint64_t AGGraphGetAttributeSubgraph2(int a1, const char *a2)
{
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  unsigned int v2 = *(AG::Subgraph **)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v2) {
    AG::precondition_failure((AG *)"internal error", a2);
  }
  return AG::Subgraph::to_cf(v2);
}

char *AGGraphGetWeakValue(unint64_t a1, char a2, AG::swift::metadata *a3)
{
  uint64_t v3 = a1;
  if (a1 < 4) {
    return 0;
  }
  unint64_t v6 = HIDWORD(a1);
  uint64_t v7 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(a1 & 0xFFFFFE00));
  if ((v7 & 0xFF00000000) == 0 || v6 != v7) {
    return 0;
  }
  if ((a2 & 4) == 0)
  {
    uint64_t v11 = AG::Graph::_current_update_key;
    uint64_t v12 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v11);
    if ((v12 & 1) == 0)
    {
      unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFFELL;
      if (v13)
      {
        char v42 = 0;
        uint64_t v14 = *(__n128 **)v13;
        unint64_t v15 = v13 + 32;
        unint64_t v17 = *(void *)(v13 + 96);
        uint64_t v16 = *(void *)(v13 + 104);
        if (v17) {
          unint64_t v15 = v17;
        }
        uint64_t v18 = *(unsigned int *)(v15 + 8 * v16 - 8);
        int v43 = v3;
        uint64_t v19 = a2 & 3;
        uint64_t v20 = AG::data::_shared_table_bytes + v18;
        unint64_t v21 = *(unsigned int *)(AG::data::_shared_table_bytes + v18 + 12);
        if (v21 > 0x11F)
        {
          unint64_t v27 = v14;
          uint64_t v37 = AG::data::_shared_table_bytes + v18;
          int v39 = v18;
          unint64_t v28 = AG::Graph::index_of_input_slow((uint64_t)v14, AG::data::_shared_table_bytes + v18, v3 | (unint64_t)(v19 << 40) | 0x700000000);
          uint64_t v20 = v37;
          LODWORD(v18) = v39;
          unint64_t v22 = v28;
          uint64_t v14 = v27;
        }
        else
        {
          if (v21 < 0x20)
          {
LABEL_18:
            unint64_t v22 = -1;
            return AG::Graph::input_value_ref_slow(v14, v18, (const char *)v3, v6, a2, a3, &v42, v22);
          }
          unint64_t v22 = 0;
          unint64_t v23 = v21 >> 5;
          uint64_t v24 = (unsigned char *)(*(unsigned int *)(v20 + 16) + AG::data::_shared_table_bytes + 4);
          while (*((_DWORD *)v24 - 1) != v3 || (*v24 & 7) != v19)
          {
            ++v22;
            v24 += 5;
            if (v23 == v22) {
              goto LABEL_18;
            }
          }
        }
        if ((v22 & 0x8000000000000000) == 0)
        {
          uint64_t v29 = *(unsigned int *)(v20 + 16);
          uint64_t v30 = AG::data::_shared_table_bytes;
          if ((v3 & 3) != 0)
          {
            unint64_t v38 = v14;
            int v40 = v18;
            unint64_t v36 = v22;
            uint64_t v3 = AG::data::_shared_table_bytes;
            int v35 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v43, (const char *)3);
            uint64_t v30 = v3;
            LODWORD(v3) = v35;
            unint64_t v22 = v36;
            uint64_t v14 = v38;
            uint64_t v31 = v18;
            LODWORD(v18) = v40;
          }
          else
          {
            uint64_t v31 = 0;
          }
          uint64_t v32 = AG::data::_shared_table_bytes;
          uint64_t v33 = AG::data::_shared_table_bytes + v3;
          if ((*(_DWORD *)v33 & 0x11) == 0x10)
          {
            *(unsigned char *)(v30 + v29 + 5 * v22 + 4) |= 0x10u;
            uint64_t v34 = (void *)(v32 + *(unsigned int *)(v33 + 8));
            if ((*(unsigned char *)(v33 + 7) & 2) != 0) {
              uint64_t v34 = (void *)*v34;
            }
            return (char *)v34 + v31;
          }
          LODWORD(v3) = v43;
        }
        return AG::Graph::input_value_ref_slow(v14, v18, (const char *)v3, v6, a2, a3, &v42, v22);
      }
    }
  }
  if (dword_1EB3D3240 <= (v3 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", v8, v3 & 0xFFFFFFFC);
  }
  uint64_t v25 = *(void *)(AG::data::_shared_table_bytes + (v3 & 0xFFFFFE00));
  if (!v25) {
    AG::precondition_failure((AG *)"no graph: %u", v8, v3);
  }
  unint64_t v26 = *(__n128 **)(v25 + 40);
  char v41 = 0;
  return AG::Graph::value_ref(v26, (const char *)v3, HIDWORD(v3), a3, &v41);
}

char *AG::Graph::value_ref(__n128 *a1, const char *a2, unsigned int a3, AG::swift::metadata *a4, unsigned char *a5)
{
  unsigned int v7 = a3;
  uint64_t v8 = (uint64_t)a2;
  int v31 = (int)a2;
  ++a1[29].n128_u32[2];
  if ((a2 & 3) != 0)
  {
    if (a3) {
      uint64_t v27 = 25;
    }
    else {
      uint64_t v27 = 11;
    }
    uint64_t v8 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v31, (const char *)v27);
    uint64_t v10 = a2;
    if (v7)
    {
LABEL_3:
      uint64_t result = 0;
      if (v8 < 4 || (v8 & 3) != 0) {
        return result;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    if (a3) {
      goto LABEL_3;
    }
  }
  uint64_t v12 = (unsigned int *)(AG::data::_shared_table_bytes + v8);
  if ((*(unsigned char *)(*(void *)(a1[8].n128_u64[0] + (((unint64_t)*v12 >> 5) & 0x7FFFFF8)) + 40) & 0x10) != 0) {
    goto LABEL_23;
  }
  uint64_t v13 = AG::Graph::_current_update_key;
  uint64_t v14 = *(__n128 **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v13);
  if (v14)
  {
    while (1)
    {
      unint64_t v15 = (__n128 **)((unint64_t)v14 & 0xFFFFFFFFFFFFFFFELL);
      if (*v15 == a1) {
        break;
      }
      uint64_t v14 = v15[2];
      if (!v14) {
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    ++a1[27].n128_u64[1];
  }
  if (v7)
  {
    uint64_t v16 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(v8 & 0xFFFFFE00));
    int v17 = v16 & 0x7FFFFFFF;
    if ((v16 & 0xFF00000000) == 0) {
      int v17 = v16;
    }
    unsigned int v7 = v17 & 0xFFFFFF00;
    int v18 = BYTE4(v16);
    int v19 = v17;
  }
  else
  {
    int v18 = 0;
    int v19 = 0;
  }
  if (AG::Graph::update_attribute(a1, v8, 0)) {
    *a5 |= 1u;
  }
  if (v18)
  {
    int v20 = v7 | v19;
    uint64_t v21 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(v8 & 0xFFFFFE00));
    if ((v21 & 0xFF00000000) == 0 || v20 != v21) {
      return 0;
    }
  }
LABEL_23:
  unint64_t v23 = *v12;
  if (!v10)
  {
    uint64_t v24 = *(AG::swift::metadata **)(*(void *)(a1[8].n128_u64[0] + ((v23 >> 5) & 0x7FFFFF8)) + 8);
    if (v24 != a4)
    {
      uint64_t v28 = AG::swift::metadata::name(v24, 0);
      uint64_t v29 = AG::swift::metadata::name(a4, 0);
      AG::precondition_failure((AG *)"invalid value type for attribute: %u (saw %s, expected %s)", v30, v8, v28, v29);
    }
  }
  if ((v23 & 0x10) == 0) {
    AG::precondition_failure((AG *)"attribute being read has no value: %u", a2, v8);
  }
  uint64_t v25 = AG::data::_shared_table_bytes + v12[2];
  if ((*((unsigned char *)v12 + 7) & 2) != 0) {
    uint64_t v25 = *(void *)v25;
  }
  unint64_t v26 = v10 - 1;
  if (!v10) {
    unint64_t v26 = 0;
  }
  return (char *)&v26[v25];
}

void AG::Subgraph::update(AG::Subgraph *this, uint64_t a2)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 5);
  if (*(unsigned char *)(v4 + 409) && !AG::Graph::thread_is_updating(*((AG::Graph **)this + 5))) {
    AG::Graph::call_update(v4);
  }
  if (*((unsigned char *)this + 104))
  {
    uint64_t v5 = *((void *)this + 5);
LABEL_6:
    AG::Graph::invalidate_subgraphs((AG::Graph *)v5);
    return;
  }
  uint64_t v5 = *((void *)this + 5);
  if (((BYTE2(*((_DWORD *)this + 25)) | HIBYTE(*((_DWORD *)this + 25))) & a2) == 0) {
    goto LABEL_6;
  }
  int v6 = *(_DWORD *)(v5 + 232);
  if (v6)
  {
    unsigned int v48 = v6 - 1;
    do
    {
      uint64_t v49 = v48;
      uint64_t v50 = *(void *)(*(void *)(v5 + 224) + 8 * v48);
      (*(void (**)(uint64_t, AG::Subgraph *, uint64_t))(*(void *)v50 + 48))(v50, this, a2);
      --v48;
    }
    while (v49);
  }
  unsigned int add = atomic_fetch_add(AG::Subgraph::_last_traversal_seed, 1u);
  long long v64 = 0u;
  unint64_t v65 = 256;
  uint64_t v60 = 0;
  unint64_t v61 = 0;
  uint64_t v62 = 32;
  uint64_t v8 = (const void *)AG::Subgraph::to_cf(this);
  unsigned int v9 = v8;
  if (v8) {
    CFRetain(v8);
  }
  CFTypeRef cf = v9;
  std::stack<util::cf_ptr<AGSubgraphStorage *>,AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>>::emplace[abi:ne180100]<util::cf_ptr<AGSubgraphStorage *>>(v59, &cf);
  if (cf) {
    CFRelease(cf);
  }
  uint64_t v53 = this;
  unsigned int v54 = add + 1;
  *((_DWORD *)this + 21) = add + 1;
  unint64_t v10 = v61;
  if (v61)
  {
    char v11 = 0;
    char v56 = ~(_BYTE)a2;
    do
    {
      uint64_t v12 = v60;
      if (!v60) {
        uint64_t v12 = v59;
      }
      uint64_t v13 = (const void *)v12[v10 - 1];
      if (v13) {
        CFTypeRef v14 = CFRetain(v13);
      }
      else {
        CFTypeRef v14 = 0;
      }
      CFTypeRef cf = v14;
      std::stack<util::cf_ptr<AGSubgraphStorage *>,AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>>::pop[abi:ne180100]((uint64_t)v59);
      CFTypeRef v55 = v14;
      uint64_t v15 = AG::Subgraph::from_cf((uint64_t)v14);
      uint64_t v16 = v15;
      if (v15)
      {
        if (!*(unsigned char *)(v15 + 104))
        {
          while (1)
          {
            int v17 = *(_DWORD *)(v16 + 100);
            if ((BYTE2(v17) & a2) == 0) {
              break;
            }
            unsigned int v18 = v17 & 0xFF00FFFF | ((BYTE2(v17) & v56) << 16);
            *(_DWORD *)(v16 + 100) = v18;
            if (!a2 || (a2 & v18) != 0)
            {
              unsigned int v19 = *(_DWORD *)(v16 + 16);
              if (v19)
              {
                uint64_t v20 = AG::data::_shared_table_bytes;
                do
                {
                  uint64_t v21 = v19;
                  uint64_t v22 = v20 + v19;
                  int v23 = *(unsigned __int16 *)(v22 + 20);
                  if (*(_WORD *)(v22 + 20))
                  {
                    do
                    {
                      unsigned int v24 = v23 + v21;
                      int v25 = (v23 + v21) & 3;
                      if (v25)
                      {
                        if (v25 == 1)
                        {
                          int v23 = *(unsigned __int16 *)(AG::data::_shared_table_bytes + (v24 & 0xFFFFFFFC) + 14);
                          if (a2) {
                            break;
                          }
                        }
                        else if (v25 == 2)
                        {
                          break;
                        }
                      }
                      else
                      {
                        uint64_t v26 = AG::data::_shared_table_bytes + v24;
                        int v23 = *(unsigned __int16 *)(v26 + 4);
                        if (!a2) {
                          goto LABEL_44;
                        }
                        if (!*(unsigned char *)(v26 + 6)) {
                          break;
                        }
                        if ((*(unsigned char *)(v26 + 6) & a2) != 0)
                        {
LABEL_44:
                          if (*(unsigned char *)v26)
                          {
                            uint64_t v27 = *((void *)&v64 + 1);
                            size_t v28 = *((void *)&v64 + 1) + 1;
                            if (v65 < *((void *)&v64 + 1) + 1)
                            {
                              AG::vector<AG::data::ptr<AG::Node>,256ul,unsigned long>::reserve_slow(__dst, v28);
                              uint64_t v27 = *((void *)&v64 + 1);
                              size_t v28 = *((void *)&v64 + 1) + 1;
                            }
                            uint64_t v29 = (unsigned char *)v64;
                            if (!(void)v64) {
                              uint64_t v29 = __dst;
                            }
                            *(_DWORD *)&v29[4 * v27] = v24;
                            *((void *)&v64 + 1) = v28;
                          }
                        }
                      }
                    }
                    while (v23);
                    uint64_t v20 = AG::data::_shared_table_bytes;
                  }
                  unsigned int v19 = *(_DWORD *)(v20 + v21 + 8);
                }
                while (v19);
              }
            }
            if (!*((void *)&v64 + 1))
            {
              if (*(unsigned char *)(v16 + 104)) {
                goto LABEL_24;
              }
              break;
            }
            if ((void)v64) {
              uint64_t v30 = (unsigned int *)v64;
            }
            else {
              uint64_t v30 = (unsigned int *)__dst;
            }
            uint64_t v31 = 4 * *((void *)&v64 + 1) - 4;
            do
            {
              unsigned int v32 = *v30;
              if ((v11 & 1) == 0 && !AG::Graph::thread_is_updating((AG::Graph *)v5)) {
                ++*(void *)(v5 + 440);
              }
              AG::Graph::update_attribute((__n128 *)v5, v32, 1);
              int v33 = *(unsigned __int8 *)(v16 + 104);
              ++v30;
              if (*(unsigned char *)(v16 + 104)) {
                BOOL v34 = 1;
              }
              else {
                BOOL v34 = v31 == 0;
              }
              v31 -= 4;
              char v11 = 1;
            }
            while (!v34);
            *((void *)&v64 + 1) = 0;
            if (v33) {
              goto LABEL_24;
            }
          }
          unsigned int v35 = *(_DWORD *)(v16 + 100);
          if ((a2 & HIBYTE(v35)) != 0)
          {
            *(_DWORD *)(v16 + 100) = v35 & 0xFFFFFF | ((HIBYTE(v35) & v56) << 24);
            uint64_t v36 = *(unsigned int *)(v16 + 72);
            if (v36)
            {
              uint64_t v37 = *(void **)(v16 + 64);
              uint64_t v38 = 8 * v36;
              do
              {
                unint64_t v39 = *v37 & 0xFFFFFFFFFFFFFFFCLL;
                if (((BYTE2(*(_DWORD *)(v39 + 100)) | HIBYTE(*(_DWORD *)(v39 + 100))) & a2) != 0
                  && *(_DWORD *)(v39 + 84) != v54)
                {
                  int v40 = (const void *)AG::Subgraph::to_cf((AG::Subgraph *)(*v37 & 0xFFFFFFFFFFFFFFFCLL));
                  char v41 = v40;
                  if (v40) {
                    CFRetain(v40);
                  }
                  CFTypeRef v57 = v41;
                  std::stack<util::cf_ptr<AGSubgraphStorage *>,AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>>::emplace[abi:ne180100]<util::cf_ptr<AGSubgraphStorage *>>(v59, &v57);
                  if (v57) {
                    CFRelease(v57);
                  }
                  *(_DWORD *)(v39 + 84) = v54;
                }
                ++v37;
                v38 -= 8;
              }
              while (v38);
            }
          }
        }
LABEL_24:
        AG::Graph::invalidate_subgraphs((AG::Graph *)v5);
      }
      if (v55) {
        CFRelease(v55);
      }
      unint64_t v10 = v61;
    }
    while (v61);
  }
  AG::Graph::invalidate_subgraphs((AG::Graph *)v5);
  uint64_t v42 = *(unsigned int *)(v5 + 232);
  if (v42)
  {
    for (uint64_t i = 8 * v42 - 8; i != -8; i -= 8)
    {
      uint64_t v52 = *(void *)(*(void *)(v5 + 224) + i);
      (*(void (**)(uint64_t, AG::Subgraph *))(*(void *)v52 + 56))(v52, v53);
    }
  }
  int v43 = v60;
  unint64_t v44 = v61;
  if (v60) {
    int v45 = v60;
  }
  else {
    int v45 = v59;
  }
  if (v61)
  {
    unint64_t v46 = 0;
    do
    {
      uint64_t v47 = (const void *)v45[v46];
      if (v47)
      {
        CFRelease(v47);
        unint64_t v44 = v61;
      }
      ++v46;
    }
    while (v46 < v44);
    int v43 = v60;
  }
  if (v43) {
    free(v43);
  }
  if ((void)v64) {
    free((void *)v64);
  }
}

void sub_1AF90D648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::stack<util::cf_ptr<AGSubgraphStorage *>,AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>>::~stack(va);
  if (STACK[0x548]) {
    free((void *)STACK[0x548]);
  }
  _Unwind_Resume(a1);
}

uint64_t AG::Graph::update_attribute(__n128 *this, unsigned int a2, uint64_t a3)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if ((a3 & 1) == 0 && this[25].n128_u8[9] && !AG::Graph::thread_is_updating((AG::Graph *)this)) {
    AG::Graph::call_update((uint64_t)this);
  }
  int v6 = (unsigned int *)(AG::data::_shared_table_bytes + a2);
  unsigned int v7 = *v6;
  if ((*v6 & 0x11) == 0x10) {
    return 0;
  }
  ++this[28].n128_u64[0];
  if ((v7 & 4) != 0) {
    ++this[28].n128_u64[1];
  }
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  unsigned int v35 = this;
  unint64_t v36 = StatusReg - 224;
  uint64_t v10 = *(void *)(StatusReg + 8 * AG::Graph::_current_update_key);
  unint64_t v11 = atomic_load(this[26].n128_u64);
  uint64_t v37 = v10;
  unint64_t v38 = v11;
  int v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 8;
  int v43 = a3;
  int v12 = a3;
  if (v10)
  {
    int v12 = *(_DWORD *)((v10 & 0xFFFFFFFFFFFFFFFELL) + 120) & 4 | a3;
    int v43 = v12;
  }
  uint64_t v13 = a2;
  this[26].n128_u64[0] = v36;
  if (!this[25].n128_u8[8])
  {
    this[25].n128_u8[8] = 1;
    int v43 = v12 | 0x10;
  }
  int v14 = a3 & 1;
  *(void *)(StatusReg + 8 * AG::Graph::_current_update_key) = (unint64_t)&v35 | (a3 >> 3) & 1;
  uint64_t v15 = this[14].n128_u32[2];
  if (v15)
  {
    for (uint64_t i = 8 * v15 - 8; i != -8; i -= 8)
    {
      uint64_t v30 = *(void *)(this[14].n128_u64[0] + i);
      (*(void (**)(uint64_t, __n128 **, void, uint64_t))(*(void *)v30 + 64))(v30, &v35, a2, a3);
    }
    uint64_t v16 = v41;
    if (v41 == v42) {
      goto LABEL_45;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  if ((*v6 & 0xC0) == 0)
  {
    *v6 += 64;
    if (v40) {
      int v17 = v40;
    }
    else {
      int v17 = v39;
    }
    unsigned int v18 = (unsigned int *)&v17[8 * v16];
    unsigned int *v18 = a2;
    v18[1] = 0;
    unsigned int v19 = v18 + 1;
    if ((*v6 & 2) != 0 || !(*v6 & 0x10 | v14)) {
      *unsigned int v19 = 1;
    }
    uint64_t v41 = v16 + 1;
    goto LABEL_23;
  }
LABEL_45:
  if (AG::Graph::UpdateStack::push_slow((uint64_t *)&v35, (const char *)a2, v6, 0, v14 == 0))
  {
LABEL_23:
    uint64_t v8 = AG::Graph::UpdateStack::update((AG::Graph::UpdateStack *)&v35);
    if (v8 == 3)
    {
      int v33 = &v35;
      unsigned int v34 = 3;
      __n128 v21 = AG::Graph::call_main_handler(this, &v33, (void (*)(const void *))AG::Graph::update_attribute(AG::data::ptr<AG::Node>,unsigned int)::$_0::__invoke);
      uint64_t v8 = v34;
      ++this[28].n128_u64[1];
    }
    goto LABEL_25;
  }
  uint64_t v8 = 1;
LABEL_25:
  uint64_t v22 = this[14].n128_u32[2];
  if (v22)
  {
    for (uint64_t j = 8 * v22 - 8; j != -8; j -= 8)
    {
      uint64_t v32 = *(void *)(this[14].n128_u64[0] + j);
      (*(void (**)(uint64_t, __n128 **, uint64_t, uint64_t, __n128))(*(void *)v32 + 72))(v32, &v35, v13, v8, v21);
    }
  }
  int v23 = (unsigned int *)v40;
  if (!v40) {
    int v23 = (unsigned int *)v39;
  }
  if (v41)
  {
    uint64_t v24 = AG::data::_shared_table_bytes;
    uint64_t v25 = 8 * v41;
    do
    {
      unsigned int v26 = *v23;
      v23 += 2;
      *(_DWORD *)(v24 + v26) -= 64;
      v25 -= 8;
    }
    while (v25);
  }
  uint64_t v27 = v35;
  if (v36 != v35[26].n128_u64[0])
  {
    AG::non_fatal_precondition_failure((AG *)"invalid graph update (access from multiple threads?)", v20, v21.n128_f64[0]);
    uint64_t v27 = v35;
  }
  v27[26].n128_u64[0] = v38;
  *(void *)(StatusReg + 8 * AG::Graph::_current_update_key) = v37;
  if ((v43 & 0x10) != 0) {
    v35[25].n128_u8[8] = 0;
  }
  if (v40) {
    free(v40);
  }
  return v8;
}

void sub_1AF90DA60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AG::Graph::UpdateStack::update(AG::Graph::UpdateStack *this)
{
  unsigned int v2 = (char *)this + 32;
  v105 = (char *)this + 32;
LABEL_2:
  while (2)
  {
    uint64_t v3 = *((void *)this + 13);
    while (1)
    {
      uint64_t v4 = (char *)*((void *)this + 12);
      if (!v4) {
        uint64_t v4 = v2;
      }
      uint64_t v5 = &v4[8 * v3];
      unsigned int v7 = *((_DWORD *)v5 - 2);
      int v6 = (unsigned int *)(v5 - 8);
      uint64_t v8 = (unsigned int *)(AG::data::_shared_table_bytes + v7);
      uint64_t v10 = v6 + 1;
      unsigned int v9 = v6[1];
      if ((*((unsigned char *)this + 120) & 4) != 0)
      {
        if ((v9 & 8) == 0 && *(void *)(*(void *)this + 432) != -1)
        {
          char v87 = (AG::Graph::UpdateStack *)AG::Graph::passed_deadline_slow(*(AG::Graph **)this);
          unsigned int v2 = v105;
          if (v87)
          {
            AG::Graph::UpdateStack::cancel(v87);
            unsigned int v2 = v105;
          }
        }
      }
      else if ((v9 & 8) == 0)
      {
        goto LABEL_7;
      }
      if ((*v10 & 8) != 0) {
        break;
      }
LABEL_7:
      unint64_t v11 = v8[3];
      uint64_t v12 = AG::data::_shared_table_bytes + v8[4];
      unsigned int v13 = *(_DWORD *)v10;
      BOOL v14 = *(_DWORD *)v10 >= 0x10u && (*(_DWORD *)v10 & 1) == 0;
      if (v14 && (*(unsigned char *)(v12 + 5 * ((v13 >> 4) - 1) + 4) & 8) != 0)
      {
        v13 |= 1u;
        *(_DWORD *)uint64_t v10 = v13;
      }
      uint64_t v15 = v11 >> 5;
      if ((v11 >> 5) > v13 >> 4)
      {
        uint64_t v16 = v13 >> 4;
        while (1)
        {
          int v17 = (unsigned int *)(v12 + 5 * v16);
          unsigned int v18 = (const char *)*v17;
          char v19 = *((unsigned char *)v17 + 4);
          if ((v18 & 3) != 0) {
            break;
          }
LABEL_17:
          if ((v19 & 8) != 0)
          {
            v13 |= 1u;
            *(_DWORD *)uint64_t v10 = v13;
          }
          uint64_t v20 = (unsigned int *)&v18[AG::data::_shared_table_bytes];
          int v21 = *(_DWORD *)&v18[AG::data::_shared_table_bytes];
          if ((v21 & 0x11) != 0x10)
          {
            if ((v19 & 1) == 0
              && !*(unsigned char *)(*(void *)(AG::data::_shared_table_bytes + (v18 & 0xFFFFFE00)) + 104))
            {
              *(_DWORD *)uint64_t v10 = (v13 & 0xF | (16 * v16)) + 16;
              uint64_t v22 = *((void *)this + 13);
              if ((v21 & 0xC0) == 0 && v22 != *((void *)this + 14))
              {
                *uint64_t v20 = v21 + 64;
                v88 = (char *)*((void *)this + 12);
                if (!v88) {
                  v88 = v2;
                }
                unsigned int v89 = &v88[8 * v22];
                *(_DWORD *)unsigned int v89 = v18;
                *((_DWORD *)v89 + 1) = (*v20 & 0x12) != 16;
                goto LABEL_130;
              }
              char v24 = AG::Graph::UpdateStack::push_slow((uint64_t *)this, v18, v20, 1, 1);
              unsigned int v2 = v105;
              if (v24) {
                goto LABEL_2;
              }
              unsigned int v13 = *(_DWORD *)v10;
            }
            v13 |= 1u;
            *(_DWORD *)uint64_t v10 = v13;
          }
LABEL_30:
          if (++v16 == v15) {
            goto LABEL_39;
          }
        }
        while (1)
        {
          if ((v18 & 3) != 1)
          {
            if ((v18 & 3) == 0) {
              goto LABEL_17;
            }
            goto LABEL_30;
          }
          uint64_t v25 = (unsigned int *)(AG::data::_shared_table_bytes + (v18 & 0xFFFFFFFC));
          unsigned int v18 = (const char *)*v25;
          if (v25[2])
          {
            unsigned int v26 = (const char *)v25[4];
            if (v26)
            {
              int v27 = *(_DWORD *)&v26[AG::data::_shared_table_bytes];
              if ((v27 & 0x11) != 0x10) {
                break;
              }
            }
          }
        }
        v90 = (unsigned int *)&v26[AG::data::_shared_table_bytes];
        *(_DWORD *)uint64_t v10 = v13 & 0xF | (16 * v16);
        uint64_t v22 = *((void *)this + 13);
        if ((v27 & 0xC0) != 0 || v22 == *((void *)this + 14))
        {
          AG::Graph::UpdateStack::push_slow((uint64_t *)this, v26, v90, 0, 0);
          unsigned int v2 = v105;
          goto LABEL_2;
        }
        unsigned int *v90 = v27 + 64;
        uint64_t v92 = (char *)*((void *)this + 12);
        if (!v92) {
          uint64_t v92 = v2;
        }
        BOOL v93 = &v92[8 * v22];
        *(_DWORD *)BOOL v93 = v26;
        *((_DWORD *)v93 + 1) = (*v90 >> 1) & 1;
LABEL_130:
        *((void *)this + 13) = v22 + 1;
        goto LABEL_2;
      }
LABEL_39:
      if (v13)
      {
        uint64_t v29 = *(void *)this;
        if (*(void *)(*(void *)this + 240) && (*(unsigned char *)v8 & 8) != 0) {
          return 3;
        }
        int v30 = *(_DWORD *)(v29 + 232);
        if (v30)
        {
          unsigned int v76 = v30 - 1;
          do
          {
            uint64_t v77 = *(void *)(*(void *)(v29 + 224) + 8 * v76);
            uint64_t v78 = v76;
            (*(void (**)(uint64_t, void))(*(void *)v77 + 80))(v77, *v6);
            --v76;
          }
          while (v78);
          uint64_t v29 = *(void *)this;
        }
        uint64_t v31 = *(void *)(v29 + 464);
        uint64_t v32 = *(void *)(*(void *)(v29 + 128) + (((unint64_t)*v8 >> 5) & 0x7FFFFF8));
        int v33 = (void *)((char *)v8 + *(unsigned int *)(v32 + 44));
        if (*((unsigned char *)v8 + 7)) {
          int v33 = (void *)*v33;
        }
        (*(void (**)(void *, void))(v32 + 16))(v33, *v6);
        unint64_t v34 = *v8;
        if ((v34 & 0x10) == 0)
        {
          if (*(void *)(*(void *)(*(void *)(v32 + 8) - 8) + 64))
          {
            uint64_t v96 = **(AG::swift::metadata ***)(*(void *)(*(void *)this + 128) + ((v34 >> 5) & 0x7FFFFF8));
            uint64_t v97 = *v6;
            uint64_t v98 = AG::swift::metadata::name(v96, 0);
            AG::precondition_failure((AG *)"attribute failed to set an initial value: %u, %s", v99, v97, v98);
          }
          AGGraphSetOutputValue(&v107, *(AG::LayoutDescriptor **)(v32 + 8));
        }
        uint64_t v35 = *(void *)this;
        uint64_t v28 = *(void *)(*(void *)this + 464) ^ v31;
        int v36 = *(_DWORD *)(*(void *)this + 232);
        if (v36)
        {
          unsigned int v79 = v36 - 1;
          do
          {
            uint64_t v80 = *(void *)(*(void *)(v35 + 224) + 8 * v79);
            uint64_t v81 = v79;
            uint64_t v82 = v28;
            (*(void (**)(uint64_t, void, BOOL))(*(void *)v80 + 88))(v80, *v6, v28 != 0);
            uint64_t v28 = v82;
            --v79;
          }
          while (v81);
        }
        uint64_t v12 = AG::data::_shared_table_bytes + v8[4];
        LODWORD(v15) = v8[3] >> 5;
        unsigned int v13 = *(_DWORD *)v10;
        unsigned int v2 = v105;
      }
      else
      {
        uint64_t v28 = 0;
      }
      uint64_t v15 = v15;
      if (v13)
      {
        if ((v13 & 0xC) == 0)
        {
          if (v15)
          {
            do
            {
              --v15;
              uint64_t v57 = v12 + 5 * v15;
              char v60 = *(unsigned char *)(v57 + 4);
              v58 = (char *)(v57 + 4);
              char v59 = v60;
              char v61 = v60;
              if ((v60 & 8) != 0)
              {
                uint64_t v62 = *(void *)this;
                int v63 = *(_DWORD *)(*(void *)this + 232);
                char v56 = v59;
                if (v63)
                {
                  uint64_t v101 = v28;
                  unsigned int v54 = v63 - 1;
                  do
                  {
                    uint64_t v55 = *(void *)(*(void *)(v62 + 224) + 8 * v54);
                    uint64_t v104 = v54;
                    (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v55 + 248))(v55, *v6, v15, 0);
                    --v54;
                  }
                  while (v104);
                  char v56 = *v58;
                  unsigned int v2 = v105;
                  uint64_t v28 = v101;
                }
                char v61 = v56 & 0xF7;
              }
              char *v58 = v61 & 0xEF;
              if ((v59 & 0x10) == 0 && (v61 & 4) == 0)
              {
                uint64_t v53 = v28;
                AG::Graph::remove_input(*(void *)this, *v6, v15);
                uint64_t v28 = v53;
                unsigned int v2 = v105;
              }
            }
            while (v15);
          }
LABEL_88:
          unsigned int v52 = *v8 - 64;
          *uint64_t v8 = v52;
LABEL_89:
          if ((*((unsigned char *)v8 + 7) & 0x40) != 0) {
            *((unsigned char *)v8 + 7) &= ~0x40u;
          }
          if (v52)
          {
            uint64_t v64 = *(void *)this;
            int v65 = *(_DWORD *)(*(void *)this + 232);
            if (v65)
            {
              uint64_t v83 = v28;
              unsigned int v84 = v65 - 1;
              do
              {
                uint64_t v85 = *(void *)(*(void *)(v64 + 224) + 8 * v84);
                uint64_t v86 = v84;
                (*(void (**)(uint64_t, void, void))(*(void *)v85 + 256))(v85, *v6, 0);
                --v84;
              }
              while (v86);
              unsigned int v52 = *v8;
              unsigned int v2 = v105;
              uint64_t v28 = v83;
            }
            v52 &= ~1u;
          }
          v52 &= (v52 >> 1) | 0xFFFFFFFB;
          *uint64_t v8 = v52;
          if ((v52 & 2) == 0) {
            goto LABEL_97;
          }
LABEL_95:
          uint64_t v66 = *(void *)this;
          int v67 = *(_DWORD *)(*(void *)this + 232);
          if (v67)
          {
            uint64_t v72 = v28;
            unsigned int v73 = v67 - 1;
            do
            {
              uint64_t v74 = *(void *)(*(void *)(v66 + 224) + 8 * v73);
              uint64_t v75 = v73;
              (*(void (**)(uint64_t, void, void))(*(void *)v74 + 264))(v74, *v6, 0);
              --v73;
            }
            while (v75);
            unsigned int v52 = *v8;
            unsigned int v2 = v105;
            uint64_t v28 = v72;
          }
          *uint64_t v8 = v52 & 0xFFFFFFFD;
          goto LABEL_97;
        }
      }
      else if ((v13 & 0xC) == 0)
      {
        goto LABEL_88;
      }
      BOOL v37 = (v13 & 8) == 0;
      if (v15)
      {
        do
        {
          --v15;
          unsigned int v106 = *(_DWORD *)(v12 + 5 * v15);
          uint64_t v38 = v106;
          if ((v106 & 3) != 0)
          {
            uint64_t v47 = v28;
            unsigned int v48 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v106, 0);
            uint64_t v28 = v47;
            unsigned int v2 = v105;
            uint64_t v38 = v48;
          }
          if (v38 & 3) != 0 || (*(unsigned char *)(AG::data::_shared_table_bytes + v38))
          {
            BOOL v37 = 0;
          }
          else if ((*(_DWORD *)v10 & 1) != 0 && (*(_DWORD *)v10 & 8) == 0)
          {
            uint64_t v39 = v12 + 5 * v15;
            char v42 = *(unsigned char *)(v39 + 4);
            uint64_t v41 = (char *)(v39 + 4);
            char v40 = v42;
            if ((v42 & 8) != 0)
            {
              uint64_t v43 = *(void *)this;
              uint64_t v44 = *(unsigned int *)(*(void *)this + 232);
              if (v44)
              {
                uint64_t v100 = v28;
                uint64_t v50 = v44 - 1;
                do
                {
                  uint64_t v51 = *(void *)(*(void *)(v43 + 224) + 8 * v50);
                  uint64_t v102 = v50;
                  uint64_t v103 = v50;
                  (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v51 + 248))(v51, *v6, v15, 0);
                  uint64_t v50 = v103 - 1;
                }
                while (v102);
                char v40 = *v41;
                unsigned int v2 = v105;
                uint64_t v28 = v100;
              }
              char *v41 = v40 & 0xF7;
            }
          }
          if ((*(_DWORD *)v10 & 9) == 1)
          {
            uint64_t v45 = v12 + 5 * v15;
            char v46 = *(unsigned char *)(v45 + 4);
            *(unsigned char *)(v45 + 4) = v46 & 0xEF;
            if ((v46 & 0x10) == 0 && (v46 & 4) == 0)
            {
              uint64_t v49 = v28;
              AG::Graph::remove_input(*(void *)this, *v6, v15);
              uint64_t v28 = v49;
              unsigned int v2 = v105;
            }
          }
        }
        while (v15);
      }
      unsigned int v52 = *v8 - 64;
      *uint64_t v8 = v52;
      if (v37) {
        goto LABEL_89;
      }
      if ((v52 & 2) != 0) {
        goto LABEL_95;
      }
LABEL_97:
      uint64_t v3 = *((void *)this + 13) - 1;
      *((void *)this + 13) = v3;
      if (!v3) {
        return v28 != 0;
      }
    }
    if ((*((unsigned char *)this + 120) & 2) != 0) {
      return 2;
    }
    unint64_t v68 = *v8;
    if ((v68 & 0x10) == 0)
    {
      uint64_t v69 = *(void *)(*(void *)(*(void *)this + 128) + ((v68 >> 5) & 0x7FFFFF8));
      int v70 = *(void (**)(uint64_t, void *))(*(void *)(v69 + 32) + 40);
      if (v70)
      {
        int v71 = (void *)((char *)v8 + *(unsigned int *)(v69 + 44));
        if (*((unsigned char *)v8 + 7)) {
          int v71 = (void *)*v71;
        }
        v70(v69, v71);
        uint64_t result = 1;
        unsigned int v2 = v105;
      }
      else
      {
        uint64_t result = 0;
      }
      uint64_t v8 = (unsigned int *)(AG::data::_shared_table_bytes + *v6);
      LODWORD(v68) = *v8;
      if ((*v8 & 0x10) != 0) {
        goto LABEL_139;
      }
      goto LABEL_7;
    }
    uint64_t result = 0;
LABEL_139:
    uint64_t v94 = *((void *)this + 13);
    *uint64_t v8 = v68 - 64;
    *((void *)this + 13) = v94 - 1;
    if (v94 != 1) {
      continue;
    }
    return result;
  }
}

void AG::Graph::invalidate_subgraphs(AG::Graph *this)
{
  if (!*((unsigned char *)this + 408) && !*((void *)this + 30))
  {
    if (*((_DWORD *)this + 92))
    {
      unsigned int v2 = 0;
      do
      {
        uint64_t v3 = *(void *)(*((void *)this + 45) + 8 * v2);
        *(unsigned char *)(v3 + 105) |= 2u;
        AG::Subgraph::cache_collect(v3);
        char v4 = *(unsigned char *)(v3 + 105);
        *(unsigned char *)(v3 + 105) = v4 & 0xFD;
        if (v4)
        {
          ++v2;
          unsigned int v6 = *((_DWORD *)this + 92);
        }
        else
        {
          uint64_t v5 = *((void *)this + 45);
          unsigned int v6 = *((_DWORD *)this + 92) - 1;
          uint64_t v7 = *(void *)(v5 + 8 * v2);
          *(void *)(v5 + 8 * v2) = *(void *)(v5 + 8 * v6);
          *(void *)(v5 + 8 * v6) = v7;
          *((_DWORD *)this + 92) = v6;
        }
      }
      while (v2 < v6);
    }
    for (int i = *((_DWORD *)this + 100); i; int i = *((_DWORD *)this + 100))
    {
      unsigned int v9 = (char *)*((void *)this + 49);
      if (!v9) {
        unsigned int v9 = (char *)this + 376;
      }
      int v10 = i - 1;
      unint64_t v11 = *(AG::Subgraph **)&v9[8 * v10];
      *((_DWORD *)this + 100) = v10;
      AG::Subgraph::invalidate_now(v11, this);
    }
  }
}

uint64_t AG::Subgraph::to_cf(AG::Subgraph *this)
{
  return *((void *)this + 4);
}

void *std::stack<util::cf_ptr<AGSubgraphStorage *>,AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>>::emplace[abi:ne180100]<util::cf_ptr<AGSubgraphStorage *>>(void *__dst, void *a2)
{
  uint64_t v3 = __dst;
  uint64_t v4 = __dst[33];
  size_t v5 = v4 + 1;
  if (__dst[34] < (unint64_t)(v4 + 1))
  {
    __dst = AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>::reserve_slow(__dst, v5);
    uint64_t v4 = v3[33];
    size_t v5 = v4 + 1;
  }
  unsigned int v6 = (void *)v3[32];
  if (!v6) {
    unsigned int v6 = v3;
  }
  v6[v4] = *a2;
  *a2 = 0;
  v3[33] = v5;
  return __dst;
}

void std::stack<util::cf_ptr<AGSubgraphStorage *>,AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>>::pop[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 256);
  uint64_t v2 = *(void *)(a1 + 264) - 1;
  *(void *)(a1 + 264) = v2;
  if (!v1) {
    uint64_t v1 = a1;
  }
  uint64_t v3 = *(const void **)(v1 + 8 * v2);
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t AG::Subgraph::from_cf(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t AG::Graph::UpdateStack::push_slow(uint64_t *a1, const char *a2, unsigned int *a3, char a4, int a5)
{
  unsigned int v9 = *a3;
  int v10 = *a3 >> 6;
  if (*a3 >> 6)
  {
    if (a4) {
      return 0;
    }
    if (a1)
    {
      unint64_t v11 = a1;
      while (1)
      {
        uint64_t v12 = (void *)((unint64_t)v11 & 0xFFFFFFFFFFFFFFFELL);
        uint64_t v13 = v12[13];
        if (v13) {
          break;
        }
        unint64_t v11 = (uint64_t *)v12[2];
        if (!v11) {
          goto LABEL_12;
        }
      }
      BOOL v14 = v12 + 4;
      uint64_t v15 = (void *)v12[12];
      if (!v15) {
        uint64_t v15 = v14;
      }
      if ((v15[v13 - 1] & 0x200000000) == 0)
      {
        AG::Graph::print_cycle(*a1, (const char *)a2);
        unsigned int v9 = *a3;
      }
    }
LABEL_12:
    if ((v9 & 0x10) != 0) {
      return 0;
    }
    uint64_t v16 = *(void (**)(void))(*(void *)(*(void *)(*(void *)(*a1 + 128) + 8 * (v9 >> 8)) + 32) + 40);
    if (v16)
    {
      int v17 = a1 + 4;
      uint64_t v18 = a1[13];
      if (a1[14] < (unint64_t)(v18 + 1))
      {
        AG::vector<AG::swift::metadata const*,8ul,unsigned long>::reserve_slow(a1 + 4, v18 + 1);
        int v17 = a1 + 4;
        uint64_t v18 = a1[13];
      }
      uint64_t v19 = a1[12];
      if (!v19) {
        uint64_t v19 = (uint64_t)v17;
      }
      uint64_t v20 = (_DWORD *)(v19 + 8 * v18);
      *uint64_t v20 = a2;
      v20[1] = 0;
      int v21 = v20 + 1;
      if ((*a3 & 2) != 0 || (*a3 & 0x10) == 0 && a5) {
        *int v21 = 1;
      }
      a1[13] = v18 + 1;
      v16();
      --a1[13];
      unsigned int v9 = *a3;
      if ((*a3 & 0x10) != 0) {
        return 0;
      }
    }
    if (v10 == 3) {
      AG::precondition_failure((AG *)"cyclic graph: %u", a2, a2);
    }
  }
  *a3 = v9 + 64;
  uint64_t v22 = a1[13];
  if (a1[14] < (unint64_t)(v22 + 1))
  {
    AG::vector<AG::swift::metadata const*,8ul,unsigned long>::reserve_slow(a1 + 4, v22 + 1);
    uint64_t v22 = a1[13];
  }
  if (a1[12]) {
    int v23 = (uint64_t *)a1[12];
  }
  else {
    int v23 = a1 + 4;
  }
  char v24 = &v23[v22];
  *(_DWORD *)char v24 = a2;
  *((_DWORD *)v24 + 1) = 0;
  uint64_t v25 = (int *)v24 + 1;
  if ((*a3 & 2) != 0 || (int v26 = 2, (*a3 & 0x10) == 0) && a5)
  {
    *uint64_t v25 = 1;
    int v26 = 3;
  }
  a1[13] = v22 + 1;
  if (v10) {
    *uint64_t v25 = v26;
  }
  return 1;
}

void *AG::vector<AG::swift::metadata const*,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 10) + (*((void *)__dst + 10) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 10) + (*((void *)__dst + 10) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 8), __dst, 8uLL, (size_t *)__dst + 10, v3);
  *((void *)__dst + 8) = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,8ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, 8 * a5);
      free(v7);
      uint64_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(8 * a5);
    size_t v9 = v8 >> 3;
    if (v8 >> 3 != *a4)
    {
      int v10 = malloc_type_realloc(v7, v8, 0x8734B07FuLL);
      if (!v10) {
        AG::precondition_failure((AG *)"allocation failure", v11);
      }
      uint64_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 8 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t AG::Subgraph::cache_collect(uint64_t this)
{
  *(unsigned char *)(this + 105) &= ~1u;
  uint64_t v1 = *(unsigned int *)(this + 92);
  if (v1)
  {
    if (!*(unsigned char *)(this + 104))
    {
      v2[0] = this;
      v2[1] = AG::data::_shared_table_bytes + v1;
      return util::UntypedTable::for_each(AG::data::_shared_table_bytes + v1 + 40, (void (*)(const void *, const void *, const void *))util::Table<AG::swift::metadata const*,AG::data::ptr<AG::Subgraph::NodeCache::Type>>::for_each<AG::Subgraph::cache_collect(void)::$_0>(AG::Subgraph::cache_collect(void)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke, v2);
    }
  }
  return this;
}

uint64_t util::UntypedTable::for_each(uint64_t this, void (*a2)(const void *, const void *, const void *), const void *a3)
{
  if (*(void *)(this + 56))
  {
    uint64_t v5 = this;
    unint64_t v6 = 0;
    int v7 = *(_DWORD *)(this + 72);
    do
    {
      for (int i = *(void **)(*(void *)(v5 + 48) + 8 * v6); i; int i = (void *)*i)
        this = ((uint64_t (*)(void, void, const void *))a2)(i[1], i[2], a3);
      ++v6;
    }
    while (!(v6 >> v7));
  }
  return this;
}

void AG::Graph::Context::call_update(AG::Graph::Context *this)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 68))
  {
    *((unsigned char *)this + 68) = 0;
    if (*((void *)this + 5))
    {
      uint64_t v2 = *(void *)this;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      uint64_t v21 = v2;
      unint64_t v22 = StatusReg - 224;
      uint64_t v4 = *(void *)(StatusReg + 8 * AG::Graph::_current_update_key);
      unint64_t v5 = atomic_load((unint64_t *)(v2 + 416));
      uint64_t v23 = v4;
      unint64_t v24 = v5;
      int v26 = 0;
      uint64_t v27 = 0;
      uint64_t v28 = 8;
      int v29 = 8;
      if (v4)
      {
        int v6 = *(_DWORD *)((v4 & 0xFFFFFFFFFFFFFFFELL) + 120) & 4;
        int v29 = v6 | 8;
        int v7 = v6 | 0x18;
      }
      else
      {
        int v7 = 24;
      }
      *(void *)(v2 + 416) = v22;
      if (!*(unsigned char *)(v2 + 408))
      {
        *(unsigned char *)(v2 + 408) = 1;
        int v29 = v7;
      }
      *(void *)(StatusReg + 8 * AG::Graph::_current_update_key) = (char *)&v21 + 1;
      uint64_t v8 = *(void *)this;
      uint64_t v9 = *(unsigned int *)(*(void *)this + 232);
      if (v9)
      {
        for (uint64_t i = 8 * v9 - 8; i != -8; i -= 8)
        {
          uint64_t v18 = *(void *)(*(void *)(v8 + 224) + i);
          (*(void (**)(uint64_t, AG::Graph::Context *))(*(void *)v18 + 96))(v18, this);
        }
      }
      (*((void (**)(void))this + 5))();
      uint64_t v11 = *(unsigned int *)(v8 + 232);
      if (v11)
      {
        for (uint64_t j = 8 * v11 - 8; j != -8; j -= 8)
        {
          uint64_t v20 = *(void *)(*(void *)(v8 + 224) + j);
          (*(void (**)(uint64_t, AG::Graph::Context *))(*(void *)v20 + 104))(v20, this);
        }
      }
      uint64_t v12 = (unsigned int *)&v25;
      if (v26) {
        uint64_t v12 = (unsigned int *)v26;
      }
      if (v27)
      {
        uint64_t v13 = AG::data::_shared_table_bytes;
        uint64_t v14 = 8 * v27;
        do
        {
          unsigned int v15 = *v12;
          v12 += 2;
          *(_DWORD *)(v13 + v15) -= 64;
          v14 -= 8;
        }
        while (v14);
      }
      uint64_t v16 = v21;
      if (v22 != *(void *)(v21 + 416))
      {
        AG::non_fatal_precondition_failure((AG *)"invalid graph update (access from multiple threads?)", v10);
        uint64_t v16 = v21;
      }
      *(void *)(v16 + 416) = v24;
      *(void *)(StatusReg + 8 * AG::Graph::_current_update_key) = v23;
      if ((v29 & 0x10) != 0) {
        *(unsigned char *)(v16 + 408) = 0;
      }
      if (v26) {
        free(v26);
      }
    }
  }
}

void sub_1AF90EB4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void util::Table<unsigned long,AG::Graph::Context *>::for_each<AG::Graph::call_update(void)::$_0>(AG::Graph::call_update(void)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke(int a1, AG::Graph::Context *this)
{
}

uint64_t util::Table<AG::swift::metadata const*,AG::data::ptr<AG::Subgraph::NodeCache::Type>>::for_each<AG::Subgraph::cache_collect(void)::$_0>(AG::Subgraph::cache_collect(void)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  size_t v3 = *(unsigned int **)(AG::data::_shared_table_bytes + a2 + 16);
  if (v3)
  {
    uint64_t v5 = *a3;
    do
    {
      if (*(unsigned char *)v3 == 0xFF) {
        break;
      }
      uint64_t v6 = *(void *)v3 + 1;
      *(void *)size_t v3 = v6;
      if ((_BYTE)v6 == 0xFF)
      {
        util::UntypedTable::remove_ptr((util::UntypedTable *)(a3[1] + 120), v3);
        int v7 = (unsigned int *)(AG::data::_shared_table_bytes + v3[3]);
        AG::Node::destroy_self(v7, *(AG::Graph **)(v5 + 40));
        AG::Node::destroy_value(v7, *(AG::Graph **)(v5 + 40));
        uint64_t result = AG::Graph::remove_all_inputs(*(void *)(v5 + 40), v3[3]);
      }
      else
      {
        *(unsigned char *)(v5 + 105) |= 1u;
      }
      size_t v3 = (unsigned int *)*((void *)v3 + 2);
    }
    while (v3);
  }
  return result;
}

void AG::Graph::remove_input(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = AG::data::_shared_table_bytes + a2;
  AG::Graph::remove_input_dependencies(a1, a2, *(_DWORD *)(AG::data::_shared_table_bytes + *(unsigned int *)(v6 + 16) + 5 * a3));
  AG::Graph::remove_input_edge(a1, a2, v6, a3);
}

uint64_t AG::Graph::call_update(uint64_t this)
{
  if (*(unsigned char *)(this + 409))
  {
    uint64_t v1 = this;
    uint64_t v2 = this + 144;
    do
    {
      *(unsigned char *)(v1 + 409) = 0;
      this = util::UntypedTable::for_each(v2, (void (*)(const void *, const void *, const void *))util::Table<unsigned long,AG::Graph::Context *>::for_each<AG::Graph::call_update(void)::$_0>(AG::Graph::call_update(void)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke, &v3);
    }
    while (*(unsigned char *)(v1 + 409));
  }
  return this;
}

void util::Table<AG::data::ptr<AG::Node>,AG::Subgraph::NodeCache::Item *>::for_each<AG::Subgraph::NodeCache::~()::$_0>(AG::Subgraph::NodeCache::~()::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    JUMPOUT(0x1B3E84B80);
  }
}

void AGGraphInvalidate(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 88))
  {
    AG::Graph::Context::~Context((AG::Graph::Context *)(a1 + 16));
    *(unsigned char *)(a1 + 88) = 1;
  }
}

void AG::Graph::Context::~Context(void **this)
{
  uint64_t v2 = *this;
  uint64_t v3 = *((unsigned int *)*this + 58);
  if (v3)
  {
    for (uint64_t i = 8 * v3 - 8; i != -8; i -= 8)
    {
      uint64_t v14 = *(void *)(v2[28] + i);
      (*(void (**)(uint64_t, void **))(*(void *)v14 + 168))(v14, this);
    }
    uint64_t v2 = *this;
  }
  if (util::UntypedTable::remove((util::UntypedTable *)(v2 + 18), this[2]) && this[7] != (void *)-1)
  {
    uint64_t v4 = *this;
    uint64_t v5 = (uint64_t)*this + 144;
    unsigned int v15 = &v16;
    uint64_t v16 = -1;
    util::UntypedTable::for_each(v5, (void (*)(const void *, const void *, const void *))util::Table<unsigned long,AG::Graph::Context *>::for_each<AG::Graph::update_deadline(void)::$_0>(AG::Graph::update_deadline(void)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke, &v15);
    v4[54] = v16;
  }
  uint64_t v6 = (unsigned __int8 *)*this;
  if (*((_DWORD *)*this + 103) != 1)
  {
    int v7 = v6[408];
    v6[408] = 1;
    uint64_t v8 = *((unsigned int *)v6 + 88);
    if (v8)
    {
      uint64_t v9 = (AG::Subgraph **)*((void *)v6 + 43);
      uint64_t v10 = 8 * v8;
      do
      {
        if (*((void **)*v9 + 6) == this[2]) {
          AG::Subgraph::invalidate_and_delete_(*v9, 1);
        }
        ++v9;
        v10 -= 8;
      }
      while (v10);
    }
    if (v6 && !v7)
    {
      v6[408] = 0;
      AG::Graph::invalidate_subgraphs((AG::Graph *)v6);
    }
  }
  uint64_t v11 = (AG::Graph *)*this;
  int v12 = *((_DWORD *)*this + 103) - 1;
  *((_DWORD *)v11 + 103) = v12;
  if (v11 && !v12)
  {
    AG::Graph::~Graph(v11);
    MEMORY[0x1B3E84B80]();
  }
  swift_release();
  swift_release();
}

void AG::Subgraph::invalidate_and_delete_(AG::Subgraph *this, int a2)
{
  if (a2) {
    *((_DWORD *)this + 6) |= 0x80000000;
  }
  if (*((unsigned __int8 *)this + 104) - 1 >= 3)
  {
    uint64_t v3 = *((void *)this + 7);
    if (v3)
    {
      unint64_t v6 = v3 & 0xFFFFFFFFFFFFFFFELL;
      if (*(void *)(v6 + 32)) {
        uint64_t v5 = *(uint64_t **)(v6 + 32);
      }
      else {
        uint64_t v5 = (uint64_t *)v6;
      }
      uint64_t v4 = &v5[*(void *)(v6 + 40)];
    }
    else
    {
      uint64_t v4 = (uint64_t *)((char *)this + 8 * (v3 != 0) + 56);
      uint64_t v5 = (uint64_t *)((char *)this + 56);
    }
    while (v5 != v4)
    {
      uint64_t v7 = *v5++;
      AG::Subgraph::remove_child(v7, this, 1);
    }
    AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::clear((void *)this + 7);
    uint64_t v8 = *((void *)this + 5);
    if (*(unsigned char *)(v8 + 408) || *(void *)(v8 + 240))
    {
      int v9 = *((unsigned __int8 *)this + 104);
      if (v9 != 1)
      {
        uint64_t v10 = v8 + 376;
        unsigned int v11 = *(_DWORD *)(v8 + 400);
        unsigned int v12 = v11 + 1;
        if (*(_DWORD *)(v8 + 404) < v11 + 1)
        {
          AG::vector<AG::Subgraph *,2ul,unsigned int>::reserve_slow((void *)(v8 + 376), v12);
          uint64_t v10 = v8 + 376;
          unsigned int v11 = *(_DWORD *)(v8 + 400);
          int v9 = *((unsigned __int8 *)this + 104);
          unsigned int v12 = v11 + 1;
        }
        if (*(void *)(v8 + 392)) {
          uint64_t v10 = *(void *)(v8 + 392);
        }
        *(void *)(v10 + 8 * v11) = this;
        *(_DWORD *)(v8 + 400) = v12;
        *((unsigned char *)this + 104) = 1;
        if (!v9)
        {
          int v13 = *(_DWORD *)(v8 + 232);
          if (v13)
          {
            unsigned int v14 = v13 - 1;
            do
            {
              uint64_t v15 = v14;
              uint64_t v16 = *(void *)(*(void *)(v8 + 224) + 8 * v14);
              (*(void (**)(uint64_t, AG::Subgraph *))(*(void *)v16 + 192))(v16, this);
              --v14;
            }
            while (v15);
          }
        }
      }
    }
    else
    {
      AG::Subgraph::invalidate_now(this, *((AG::Graph **)this + 5));
      AG::Graph::invalidate_subgraphs((AG::Graph *)v8);
    }
  }
}

uint64_t AG::Subgraph::remove_child(uint64_t this, AG::Subgraph *a2, char a3)
{
  uint64_t v4 = this;
  uint64_t v5 = (void *)((char *)a2 + 56);
  uint64_t v6 = *((void *)a2 + 7);
  if (v6)
  {
    uint64_t v8 = (void *)(v6 & 0xFFFFFFFFFFFFFFFELL);
    if (*(void *)((v6 & 0xFFFFFFFFFFFFFFFELL) + 32)) {
      uint64_t v8 = *(void **)((v6 & 0xFFFFFFFFFFFFFFFELL) + 32);
    }
    uint64_t v7 = &v8[*(void *)((v6 & 0xFFFFFFFFFFFFFFFELL) + 40)];
  }
  else
  {
    uint64_t v7 = &v5[v6 != 0];
    uint64_t v8 = (void *)((char *)a2 + 56);
  }
  while (v8 != v7)
  {
    if (*v8 == this)
    {
      if (v6)
      {
        unint64_t v14 = v6 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v15 = *(void *)(v14 + 40);
        if (*(void *)(v14 + 32)) {
          unint64_t v14 = *(void *)(v14 + 32);
        }
        uint64_t v6 = *(void *)(v14 + 8 * v15 - 8);
      }
      *uint64_t v8 = v6;
      if (*v5) {
        --*(void *)((*v5 & 0xFFFFFFFFFFFFFFFELL) + 40);
      }
      else {
        *uint64_t v5 = 0;
      }
      break;
    }
    ++v8;
  }
  if ((a3 & 1) == 0)
  {
    uint64_t v9 = *(void *)(this + 40);
    int v10 = *(_DWORD *)(v9 + 232);
    if (v10)
    {
      unsigned int v17 = v10 - 1;
      do
      {
        uint64_t v18 = v17;
        uint64_t v19 = *(void *)(*(void *)(v9 + 224) + 8 * v17);
        this = (*(uint64_t (**)(uint64_t, uint64_t, AG::Subgraph *))(*(void *)v19 + 216))(v19, v4, a2);
        --v17;
      }
      while (v18);
    }
  }
  uint64_t v11 = *(unsigned int *)(v4 + 72);
  if (v11)
  {
    uint64_t v12 = 8 * v11;
    for (uint64_t i = *(void **)(v4 + 64); (AG::Subgraph *)(*i & 0xFFFFFFFFFFFFFFFCLL) != a2; ++i)
    {
      v12 -= 8;
      if (!v12) {
        return this;
      }
    }
    unsigned int v16 = v11 - 1;
    *uint64_t i = *(void *)(*(void *)(v4 + 64) + 8 * v16);
    *(_DWORD *)(v4 + 72) = v16;
  }
  return this;
}

uint64_t util::UntypedTable::remove_ptr(util::UntypedTable *this, void *a2)
{
  if (*((void *)this + 7))
  {
    uint64_t v4 = (void *)(*((void *)this + 6) + 8 * (*((void *)this + 8) & (*(uint64_t (**)(void *))this)(a2)));
    while (1)
    {
      uint64_t v5 = v4;
      uint64_t v4 = (void *)*v4;
      if (!v4) {
        break;
      }
      if ((void *)v4[1] == a2)
      {
        *uint64_t v5 = *v4;
        uint64_t v6 = (void (*)(void))*((void *)this + 2);
        if (v6) {
          v6(v4[1]);
        }
        uint64_t v7 = (void (*)(void))*((void *)this + 3);
        if (v7) {
          v7(v4[2]);
        }
        *uint64_t v4 = *((void *)this + 5);
        *((void *)this + 5) = v4;
        --*((void *)this + 7);
        return 1;
      }
    }
  }
  return 0;
}

void *AG::vector<AG::Subgraph *,2ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 2), __dst, 2u, (_DWORD *)__dst + 7, v3);
  *((void *)__dst + 2) = result;
  return result;
}

void *AG::details::realloc_vector<unsigned int,8ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 8 * a5);
      free(v7);
      uint64_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(8 * a5);
    size_t v9 = v8 >> 3;
    if (*a4 != (v8 >> 3))
    {
      int v10 = malloc_type_realloc(v7, v8, 0x8734B07FuLL);
      if (!v10) {
        AG::precondition_failure((AG *)"allocation failure", v11);
      }
      uint64_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 8 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t util::UntypedTable::remove(util::UntypedTable *this, void *a2)
{
  if (!*((void *)this + 7)) {
    return 0;
  }
  if (*((unsigned char *)this + 77))
  {
    return util::UntypedTable::remove_ptr(this, a2);
  }
  uint64_t v5 = (*(uint64_t (**)(void *))this)(a2);
  uint64_t v6 = (void *)(*((void *)this + 6) + 8 * (*((void *)this + 8) & v5));
  uint64_t v7 = (void *)*v6;
  if (!*v6) {
    return 0;
  }
  uint64_t v8 = v5;
  while (1)
  {
    size_t v9 = v7;
    if (v7[3] == v8)
    {
      if ((*((unsigned int (**)(void, void *))this + 1))(v7[1], a2)) {
        break;
      }
    }
    uint64_t v7 = (void *)*v9;
    uint64_t v6 = v9;
    if (!*v9) {
      return 0;
    }
  }
  *uint64_t v6 = *v9;
  int v10 = (void (*)(void))*((void *)this + 2);
  if (v10) {
    v10(v9[1]);
  }
  uint64_t v11 = (void (*)(void))*((void *)this + 3);
  if (v11) {
    v11(v9[2]);
  }
  void *v9 = *((void *)this + 5);
  *((void *)this + 5) = v9;
  --*((void *)this + 7);
  return 1;
}

uint64_t AG::Graph::remove_all_inputs(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = AG::data::_shared_table_bytes + a2;
  unint64_t v5 = *(unsigned int *)(v4 + 12);
  if (v5 >= 0x20)
  {
    uint64_t v6 = (v5 >> 5) - 1;
    uint64_t v7 = (unsigned int *)(5 * (v5 >> 5) + *(unsigned int *)(v4 + 16) + AG::data::_shared_table_bytes - 5);
    do
    {
      unsigned int v8 = *v7;
      uint64_t v7 = (unsigned int *)((char *)v7 - 5);
      AG::Graph::remove_input_dependencies(a1, a2, v8);
      AG::Graph::remove_input_edge(a1, a2, v4, v6--);
    }
    while (v6 != -1);
  }
  return AG::Graph::all_inputs_removed(a1, a2);
}

unsigned int *AG::Node::destroy_value(unsigned int *this, AG::Graph *a2)
{
  unint64_t v2 = *this;
  if ((v2 & 0x10) != 0)
  {
    *this = v2 & 0xFFFFFFEF;
    if (*(void *)(*(void *)(*(void *)(*((void *)a2 + 16) + ((v2 >> 5) & 0x7FFFFF8)) + 8) - 8)) {
      uint64_t v3 = *(void *)(*(void *)(*(void *)(*((void *)a2 + 16) + ((v2 >> 5) & 0x7FFFFF8)) + 8) - 8);
    }
    else {
      uint64_t v3 = 0;
    }
    uint64_t v4 = (void *)(AG::data::_shared_table_bytes + this[2]);
    if ((*((unsigned char *)this + 7) & 2) != 0) {
      uint64_t v4 = (void *)*v4;
    }
    return (unsigned int *)(*(uint64_t (**)(void *))(v3 + 8))(v4);
  }
  return this;
}

unsigned int *AG::Node::destroy_self(unsigned int *this, AG::Graph *a2)
{
  unint64_t v2 = *this;
  if ((v2 & 0x20) != 0)
  {
    uint64_t v3 = this;
    *this = v2 & 0xFFFFFFDF;
    uint64_t v4 = *(void *)(*((void *)a2 + 16) + ((v2 >> 5) & 0x7FFFFF8));
    if ((*(unsigned char *)(v4 + 40) & 4) != 0)
    {
      unint64_t v5 = (void *)((char *)this + *(unsigned int *)(v4 + 44));
      if (*((unsigned char *)this + 7)) {
        unint64_t v5 = (void *)*v5;
      }
      (*(void (**)(uint64_t, void *))(*(void *)(v4 + 32) + 16))(v4, v5);
    }
    if (*(void *)(*(void *)v4 - 8)) {
      uint64_t v6 = *(void *)(*(void *)v4 - 8);
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(uint64_t (**)(void *))(v6 + 8);
    unsigned int v8 = (void *)((char *)v3 + *(unsigned int *)(v4 + 44));
    if (*((unsigned char *)v3 + 7)) {
      unsigned int v8 = (void *)*v8;
    }
    return (unsigned int *)v7(v8);
  }
  return this;
}

void *AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 34) + (*((void *)__dst + 34) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 34) + (*((void *)__dst + 34) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 32), __dst, 0x20uLL, (size_t *)__dst + 34, v3);
  *((void *)__dst + 32) = result;
  return result;
}

void AG::non_fatal_precondition_failure(AG *this, const char *a2, ...)
{
  va_start(va, a2);
  v5[0] = 0;
  va_copy((va_list)&v5[1], va);
  unint64_t v2 = (AG *)vasprintf(v5, (const char *)this, va);
  if (v5[0])
  {
    size_t v3 = AG::error_log(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      AG::non_fatal_precondition_failure((uint64_t *)v5, v3);
    }
    AG::Graph::trace_assertion_failure(0, (uint64_t)"precondition failure: %s", v4, v5[0]);
    free(v5[0]);
  }
}

uint64_t AGGraphGetCounter(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  size_t v3 = (AG::Graph::Context *)(a1 + 16);
  switch((int)a2)
  {
    case 0:
      uint64_t result = *(void *)(*(void *)v3 + 256);
      break;
    case 1:
      uint64_t result = *(void *)(*(void *)v3 + 440);
      break;
    case 2:
      uint64_t result = *(void *)(*(void *)v3 + 448);
      break;
    case 3:
      uint64_t result = *(void *)(*(void *)v3 + 464);
      break;
    case 4:
      uint64_t result = *(void *)(a1 + 32);
      break;
    case 5:
      uint64_t result = *(void *)(*(void *)v3 + 424);
      break;
    case 6:
      LODWORD(result) = AG::Graph::Context::thread_is_updating(v3);
      goto LABEL_12;
    case 7:
      LODWORD(result) = AG::Graph::thread_is_updating(*(AG::Graph **)v3);
LABEL_12:
      uint64_t result = result;
      break;
    case 8:
      uint64_t result = *(unsigned __int8 *)(a1 + 84);
      break;
    case 9:
      uint64_t result = *(unsigned __int8 *)(*(void *)v3 + 409);
      break;
    case 10:
      uint64_t result = *(void *)(*(void *)v3 + 456);
      break;
    case 11:
      uint64_t result = *(void *)(*(void *)v3 + 264);
      break;
    case 12:
      uint64_t result = *(void *)(*(void *)v3 + 272);
      break;
    case 13:
      uint64_t result = *(void *)(*(void *)v3 + 280);
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

BOOL AG::Graph::thread_is_updating(AG::Graph *this)
{
  uint64_t v1 = AG::Graph::_current_update_key;
  unint64_t v2 = *(AG::Graph **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v1);
  if (!v2) {
    return 0;
  }
  do
  {
    size_t v3 = (AG::Graph **)((unint64_t)v2 & 0xFFFFFFFFFFFFFFFELL);
    BOOL v4 = *v3 == this;
    if (*v3 == this) {
      break;
    }
    unint64_t v2 = v3[2];
  }
  while (v2);
  return v4;
}

uint64_t AG::Graph::Context::thread_is_updating(AG::Graph::Context *this)
{
  uint64_t v1 = AG::Graph::_current_update_key;
  uint64_t v2 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v1);
  if (!v2) {
    return 0;
  }
  while (1)
  {
    size_t v3 = (void *)(v2 & 0xFFFFFFFFFFFFFFFELL);
    if (*v3 == *(void *)this) {
      break;
    }
    uint64_t v2 = v3[2];
    if (!v2) {
      return 0;
    }
  }
  return AG::Graph::is_context_updating(*(AG::Graph **)this, *((void *)this + 2));
}

uint64_t AG::Graph::is_context_updating(AG::Graph *this, uint64_t a2)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  for (uint64_t i = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2); i; uint64_t i = v4[2])
  {
    BOOL v4 = (void *)(i & 0xFFFFFFFFFFFFFFFELL);
    uint64_t v5 = v4[13];
    uint64_t v6 = 8 * v5 - 8;
    uint64_t v7 = v5 + 1;
    while (--v7)
    {
      unsigned int v8 = (void *)v4[12];
      if (!v8) {
        unsigned int v8 = v4 + 4;
      }
      uint64_t v9 = *(void *)(AG::data::_shared_table_bytes + (*(_DWORD *)((unsigned char *)v8 + v6) & 0xFFFFFE00));
      if (v9) {
        uint64_t v9 = *(void *)(v9 + 48);
      }
      v6 -= 8;
      if (v9 == a2) {
        return 1;
      }
    }
  }
  return 0;
}

AG::Graph *AG::Graph::Graph(AG::Graph *this)
{
  uint64_t v2 = (char *)this + 16;
  util::Heap::Heap((AG::Graph *)((char *)this + 16), 0, 0, 0);
  util::UntypedTable::UntypedTable((uint64_t)this + 48, 0, 0, 0, 0, (uint64_t)v2);
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  util::UntypedTable::UntypedTable((uint64_t)this + 144, 0, 0, 0, 0, (uint64_t)v2);
  *((_OWORD *)this + 14) = 0u;
  *((void *)this + 34) = 0;
  *((void *)this + 36) = 0;
  *((unsigned char *)this + 296) = 0;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((void *)this + 49) = 0;
  *((_OWORD *)this + 15) = 0u;
  *((void *)this + 32) = 0;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((void *)this + 46) = 0;
  *((void *)this + 50) = 0x200000000;
  *((_WORD *)this + 204) = 0;
  *((_DWORD *)this + 103) = 1;
  *((void *)this + 52) = 0;
  size_t v3 = (AG::data::table *)AGMakeUniqueID();
  *((void *)this + 53) = v3;
  *((void *)this + 54) = -1;
  *((_DWORD *)this + 118) = 0;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  AG::data::table::ensure_shared(v3);
  if (this == (AG::Graph *)1)
  {
    AG::Graph::print((AG::Graph *)1);
    AG::Graph::print_attribute(1, 0);
    AG::Graph::print_stack((AG::Graph *)1);
    AG::Graph::print_data((AG::Graph *)1);
    AG::Graph::write_to_file(0, 0, 0);
  }
  if (AG::Graph::Graph(void)::make_keys != -1) {
    dispatch_once_f(&AG::Graph::Graph(void)::make_keys, 0, (dispatch_function_t)AG::Graph::Graph(void)::$_0::__invoke);
  }
  unsigned int v4 = *((_DWORD *)this + 34);
  unsigned int v5 = v4 + 1;
  if (*((_DWORD *)this + 35) < v4 + 1)
  {
    AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow((uint64_t)this + 128, v5);
    unsigned int v4 = *((_DWORD *)this + 34);
    unsigned int v5 = v4 + 1;
  }
  *(void *)(*((void *)this + 16) + 8 * v4) = 0;
  *((_DWORD *)this + 34) = v5;
  if ((atomic_load_explicit((atomic_uchar *volatile)_ZGVZN2AG5GraphC1EvEDC14profiler_flags11trace_flags16trace_subsystemsE, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(_ZGVZN2AG5GraphC1EvEDC14profiler_flags11trace_flags16trace_subsystemsE))
  {
    AG::Graph::Graph(void)::$_1::operator()();
    __cxa_atexit((void (*)(void *))std::tuple<unsigned int,unsigned int,AG::vector<char const*,0ul,unsigned long>>::~tuple, &_ZZN2AG5GraphC1EvEDC14profiler_flags11trace_flags16trace_subsystemsE, &dword_1AF901000);
    __cxa_guard_release(_ZGVZN2AG5GraphC1EvEDC14profiler_flags11trace_flags16trace_subsystemsE);
  }
  if (dword_1EB3D34D4 || (void)xmmword_1EB3D34E0) {
    AG::Graph::start_tracing((uint64_t)this, dword_1EB3D34D4);
  }
  if (_ZZN2AG5GraphC1EvEDC14profiler_flags11trace_flags16trace_subsystemsE) {
    AG::Graph::start_profiling(this, _ZZN2AG5GraphC1EvEDC14profiler_flags11trace_flags16trace_subsystemsE);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  *(void *)this = AG::Graph::_all_graphs;
  *((void *)this + 1) = 0;
  AG::Graph::_all_graphs = (uint64_t)this;
  if (*(void *)this) {
    *(void *)(*(void *)this + 8) = this;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  return this;
}

void sub_1AF90FCA4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(_ZGVZN2AG5GraphC1EvEDC14profiler_flags11trace_flags16trace_subsystemsE);
  int v10 = (void *)v5[49];
  if (v10) {
    free(v10);
  }
  uint64_t v11 = (void *)v5[45];
  if (v11) {
    free(v11);
  }
  uint64_t v12 = (void *)v5[43];
  if (v12) {
    free(v12);
  }
  uint64_t v13 = *v7;
  *uint64_t v7 = 0;
  if (v13) {
    std::default_delete<AG::Graph::KeyTable>::operator()[abi:ne180100]((uint64_t)v7, v13);
  }
  std::unique_ptr<std::unordered_map<AG::Subgraph *,AG::Graph::TreeDataElement>>::reset[abi:ne180100]((uint64_t *)(v8 + 104), 0);
  uint64_t v14 = *v6;
  *uint64_t v6 = 0;
  if (v14) {
    std::default_delete<AG::Graph::ProfileData>::operator()[abi:ne180100]((uint64_t)v6, v14);
  }
  if (*(void *)v8) {
    free(*(void **)v8);
  }
  util::UntypedTable::~UntypedTable(v4);
  AG::vector<std::unique_ptr<AG::AttributeType,AG::AttributeType::deleter>,0ul,unsigned int>::~vector(v3);
  util::UntypedTable::~UntypedTable(v2);
  util::Heap::~Heap(v1);
  _Unwind_Resume(a1);
}

uint64_t AGGraphCreateShared(uint64_t a1)
{
  AGGraphGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    AG::precondition_failure((AG *)"memory allocation failure.", v3);
  }
  uint64_t v4 = Instance;
  if (!a1) {
    operator new();
  }
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", v3);
  }
  unsigned int v5 = *(AG::Graph **)(a1 + 16);
  ++*((_DWORD *)v5 + 103);
  AG::Graph::Context::Context((AG::Graph::Context *)(Instance + 16), v5);
  int v6 = *((_DWORD *)v5 + 103) - 1;
  *((_DWORD *)v5 + 103) = v6;
  if (!v6)
  {
    AG::Graph::~Graph(v5);
    MEMORY[0x1B3E84B80]();
  }
  *(unsigned char *)(v4 + 88) = 0;
  return v4;
}

void sub_1AF90FE38(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10F0C40657E8E6BLL);
  _Unwind_Resume(a1);
}

AG::Graph::Context *AG::Graph::Context::Context(AG::Graph::Context *this, AG::Graph *a2)
{
  *(void *)this = a2;
  *((void *)this + 1) = 0;
  uint64_t v3 = (void *)AGMakeUniqueID();
  *((void *)this + 2) = v3;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = -1;
  *((_DWORD *)this + 16) = 0;
  *((unsigned char *)this + 68) = 0;
  uint64_t v4 = *(void *)this;
  *(_DWORD *)(v4 + 412) = *(_DWORD *)(*(void *)this + 412) + 1;
  util::UntypedTable::insert((util::UntypedTable *)(v4 + 144), v3, this);
  uint64_t v5 = *(void *)this;
  int v6 = *(_DWORD *)(*(void *)this + 232);
  if (v6)
  {
    unsigned int v8 = v6 - 1;
    do
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(*(void *)(v5 + 224) + 8 * v8);
      (*(void (**)(uint64_t, AG::Graph::Context *))(*(void *)v10 + 160))(v10, this);
      --v8;
    }
    while (v9);
  }
  return this;
}

unint64_t AG::Subgraph::add_observer(AG::data::zone *this, uint64_t a2, uint64_t a3)
{
  if (!*((_DWORD *)this + 20))
  {
    uint64_t v6 = *((unsigned int *)this + 4);
    if (v6
      && (uint64_t v7 = AG::data::_shared_table_bytes,
          unsigned int v8 = (*(_DWORD *)(AG::data::_shared_table_bytes + v6 + 16) + 7) & 0xFFFFFFF8,
          v8 + 24 <= *(_DWORD *)(AG::data::_shared_table_bytes + v6 + 12)))
    {
      *(_DWORD *)(AG::data::_shared_table_bytes + v6 + 16) = v8 + 24;
      unsigned int v9 = v8 + v6;
    }
    else
    {
      unsigned int v9 = AG::data::zone::alloc_slow(this, 0x18u, 7);
      uint64_t v7 = AG::data::_shared_table_bytes;
    }
    uint64_t v10 = (void *)(v7 + v9);
    *uint64_t v10 = 0;
    v10[1] = 0;
    void v10[2] = 0;
    *((_DWORD *)this + 20) = v9;
  }
  unint64_t v11 = AGMakeUniqueID();
  uint64_t v12 = (void *)(AG::data::_shared_table_bytes + *((unsigned int *)this + 20));
  swift_retain();
  uint64_t v13 = v12[1];
  if (v12[2] < (unint64_t)(v13 + 1))
  {
    AG::vector<std::pair<AG::ClosureFunctionVV<void>,unsigned long>,0ul,unsigned long>::reserve_slow((uint64_t)v12, v13 + 1);
    uint64_t v13 = v12[1];
  }
  uint64_t v14 = (void *)(*v12 + 24 * v13);
  *uint64_t v14 = a2;
  v14[1] = a3;
  v14[2] = v11;
  ++v12[1];
  return v11;
}

unint64_t AGMakeUniqueID()
{
  return atomic_fetch_add_explicit(&AGMakeUniqueID::counter, 1uLL, memory_order_relaxed);
}

void *AG::vector<std::pair<AG::ClosureFunctionVV<void>,unsigned long>,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,24ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,24ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(24 * a3);
    unint64_t v6 = v5 / 0x18;
    if (v5 / 0x18 != *a2)
    {
      uint64_t v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t AGGraphGetTypeID()
{
  {
    AGGraphGetTypeID::type = _CFRuntimeRegisterClass();
  }
  return AGGraphGetTypeID::type;
}

void sub_1AF91017C(_Unwind_Exception *a1)
{
}

const char *AG::Graph::Graph(void)::$_1::operator()()
{
  unint64_t v0 = getenv("AG_DEBUG_SERVER");
  if (v0)
  {
    uint64_t v1 = (AG::DebugServer *)strtol(v0, 0, 0);
    AG::DebugServer::start(v1);
  }
  uint64_t v17 = 0;
  long long v18 = 0uLL;
  uint64_t v2 = getenv("AG_PROFILE");
  if (v2) {
    int v3 = atoi(v2);
  }
  else {
    int v3 = 0;
  }
  uint64_t result = getenv("AG_TRACE");
  if (!result)
  {
    uint64_t v15 = 0;
    int v5 = 0;
LABEL_30:
    long long v7 = 0uLL;
    goto LABEL_31;
  }
  __s = 0;
  uint64_t result = (const char *)strtol(result, &__s, 0);
  int v5 = (int)result;
  unint64_t v6 = __s;
  long long v7 = 0uLL;
  if (!__s)
  {
    uint64_t v15 = 0;
    goto LABEL_31;
  }
  uint64_t result = (const char *)strspn(__s, ", \t\n\f\r");
  unsigned int v8 = &result[(void)v6];
  if (!result[(void)v6])
  {
    uint64_t v15 = 0;
    goto LABEL_30;
  }
  do
  {
    size_t v9 = strcspn(v8, ", \t\n\f\r");
    uint64_t v10 = malloc_type_malloc(v9 + 1, 0x6E63CC73uLL);
    memcpy(v10, v8, v9);
    *((unsigned char *)v10 + v9) = 0;
    if (!strcasecmp((const char *)v10, "enabled"))
    {
      int v13 = 1;
LABEL_24:
      v5 |= v13;
      free(v10);
      goto LABEL_25;
    }
    if (!strcasecmp((const char *)v10, "full"))
    {
      int v13 = 2;
      goto LABEL_24;
    }
    if (!strcasecmp((const char *)v10, "backtrace"))
    {
      int v13 = 4;
      goto LABEL_24;
    }
    if (!strcasecmp((const char *)v10, "prepare"))
    {
      int v13 = 8;
      goto LABEL_24;
    }
    if (!strcasecmp((const char *)v10, "custom"))
    {
      int v13 = 16;
      goto LABEL_24;
    }
    if (!strcasecmp((const char *)v10, "all"))
    {
      int v13 = 32;
      goto LABEL_24;
    }
    uint64_t v11 = v18;
    unint64_t v12 = v18 + 1;
    if (*((void *)&v18 + 1) < (unint64_t)(v18 + 1))
    {
      AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)&v17, v12);
      uint64_t v11 = v18;
      unint64_t v12 = v18 + 1;
    }
    *(void *)(v17 + 8 * v11) = v10;
    *(void *)&long long v18 = v12;
LABEL_25:
    uint64_t v14 = &v8[v9];
    uint64_t result = (const char *)strspn(v14, ", \t\n\f\r");
    unsigned int v8 = &result[(void)v14];
  }
  while (*v8);
  uint64_t v15 = v17;
  long long v7 = v18;
LABEL_31:
  _ZZN2AG5GraphC1EvEDC14profiler_flags11trace_flags16trace_subsystemsE = v3;
  dword_1EB3D34D4 = v5;
  qword_1EB3D34D8 = v15;
  xmmword_1EB3D34E0 = v7;
  return result;
}

void sub_1AF9103F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  if (a10) {
    free(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *AG::data::table::ensure_shared(AG::data::table *this)
{
  if (AG::data::table::ensure_shared(void)::once != -1) {
    dispatch_once_f(&AG::data::table::ensure_shared(void)::once, 0, (dispatch_function_t)AG::data::table::ensure_shared(void)::$_0::__invoke);
  }
  return &AG::data::_shared_table_bytes;
}

uint64_t AGGraphTraceEventEnabled(uint64_t a1, const char *a2)
{
  uint64_t v3 = AG::Graph::Context::from_cf(a1, a2);
  uint64_t v4 = *(unsigned int *)(*(void *)v3 + 232);
  if (!v4) {
    return 0;
  }
  int v5 = *(uint64_t **)(*(void *)v3 + 224);
  uint64_t v6 = 8 * v4 - 8;
  do
  {
    uint64_t v7 = *v5++;
    uint64_t result = (*(uint64_t (**)(uint64_t, const char *))(*(void *)v7 + 352))(v7, a2);
    if (result) {
      break;
    }
    uint64_t v9 = v6;
    v6 -= 8;
  }
  while (v9);
  return result;
}

void AGSubgraphCreate2(uint64_t a1, const char *a2)
{
  AG::Graph::Context::from_cf(a1, a2);
  AGSubgraphGetTypeID();
  if (_CFRuntimeCreateInstance()) {
    operator new();
  }
  AG::precondition_failure((AG *)"Memory allocation failure.", v2);
}

void sub_1AF910588(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x1022C407ABFD236);
  _Unwind_Resume(a1);
}

uint64_t AG::Graph::Context::from_cf(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  return a1 + 16;
}

unint64_t AG::Subgraph::Subgraph(unint64_t a1, uint64_t a2, int64x2_t **a3, unsigned int a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = (atomic_fetch_add_explicit(dword_1EB3D3250, 1u, memory_order_relaxed) + 1) & 0x7FFFFFFF;
  uint64_t v7 = *a3;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = v7;
  *(void *)(a1 + 48) = a3[2];
  *(_OWORD *)(a1 + 56) = 0u;
  *(unsigned char *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(unsigned char *)(a1 + 105) &= 0xFCu;
  if (a1 == 1)
  {
    AG::Subgraph::print((AG::Subgraph *)1, 0);
    uint64_t v7 = (int64x2_t *)MEMORY[0x29];
  }
  uint64_t v8 = v7[21].i64[1];
  unint64_t v9 = v7[22].u32[0];
  if (v9)
  {
    uint64_t v10 = v7[21].i64[1];
    unint64_t v11 = v7[22].u32[0];
    do
    {
      unint64_t v12 = v11 >> 1;
      int v13 = (unint64_t *)(v10 + 8 * (v11 >> 1));
      unint64_t v15 = *v13;
      uint64_t v14 = v13 + 1;
      v11 += ~(v11 >> 1);
      if (v15 < a1) {
        uint64_t v10 = (uint64_t)v14;
      }
      else {
        unint64_t v11 = v12;
      }
    }
    while (v11);
  }
  else
  {
    uint64_t v10 = v7[21].i64[1];
  }
  uint64_t v16 = v7[21].i64[1];
  if (v7[22].i32[1] < (v9 + 1))
  {
    AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow((uint64_t)&v7[21].i64[1], v9 + 1);
    uint64_t v16 = v7[21].i64[1];
    unint64_t v9 = v7[22].u32[0];
  }
  unint64_t v17 = (v10 - v8) >> 3;
  if (v9 > v17)
  {
    memmove((void *)(v16 + 8 * v17 + 8), (const void *)(v16 + 8 * v17), 8 * (v9 - v17));
    LODWORD(v9) = v7[22].i32[0];
  }
  *(void *)(v16 + 8 * v17) = a1;
  v7[22].i32[0] = v9 + 1;
  v7[17] = vaddq_s64(v7[17], vdupq_n_s64(1uLL));
  if (AGSubgraphShouldRecordTree())
  {
    if (a4 <= 3)
    {
      uint64_t v18 = AG::Graph::_current_update_key;
      uint64_t v19 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v18);
      if ((v19 & 1) == 0)
      {
        uint64_t v20 = (void *)(v19 & 0xFFFFFFFFFFFFFFFELL);
        if ((v19 & 0xFFFFFFFFFFFFFFFELL) != 0 && *v20 == *(void *)(a1 + 40))
        {
          uint64_t v21 = (unsigned int *)AG::Graph::UpdateStack::global_top((unint64_t)v20);
          if (v21) {
            a4 = *v21;
          }
        }
      }
    }
    uint64_t v22 = *(unsigned int *)(a1 + 16);
    if (v22
      && (uint64_t v23 = AG::data::_shared_table_bytes,
          unsigned int v24 = (*(_DWORD *)(AG::data::_shared_table_bytes + v22 + 16) + 7) & 0xFFFFFFF8,
          v24 + 32 <= *(_DWORD *)(AG::data::_shared_table_bytes + v22 + 12)))
    {
      *(_DWORD *)(AG::data::_shared_table_bytes + v22 + 16) = v24 + 32;
      unsigned int v25 = v24 + v22;
    }
    else
    {
      unsigned int v25 = AG::data::zone::alloc_slow((AG::data::zone *)a1, 0x20u, 7);
      uint64_t v23 = AG::data::_shared_table_bytes;
    }
    uint64_t v26 = v23 + v25;
    *(void *)uint64_t v26 = 0;
    *(_DWORD *)(v26 + 8) = a4;
    *(void *)(v26 + 20) = 0;
    *(void *)(v26 + 12) = 0;
    *(_DWORD *)(v26 + 28) = 0;
    *(_DWORD *)(a1 + 96) = v25;
  }
  uint64_t v27 = *a3;
  uint64_t v28 = v27[14].u32[2];
  if (v28)
  {
    for (uint64_t i = 8 * v28 - 8; i != -8; i -= 8)
    {
      uint64_t v31 = *(void *)(v27[14].i64[0] + i);
      (*(void (**)(uint64_t, unint64_t))(*(void *)v31 + 184))(v31, a1);
    }
  }
  return a1;
}

{
  return AG::Subgraph::Subgraph(a1, a2, a3, a4);
}

void sub_1AF91084C(_Unwind_Exception *a1)
{
  uint64_t v4 = (void *)*((void *)v1 + 8);
  if (v4) {
    free(v4);
  }
  AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::~indirect_pointer_vector(v2);
  AG::data::zone::~zone(v1);
  _Unwind_Resume(a1);
}

uint64_t AGSubgraphShouldRecordTree()
{
  if (should_record_tree_once != -1) {
    dispatch_once_f(&should_record_tree_once, 0, (dispatch_function_t)init_should_record_tree);
  }
  return should_record_tree;
}

uint64_t AGSubgraphGetTypeID()
{
  {
    AGSubgraphGetTypeID::type = _CFRuntimeRegisterClass();
  }
  return AGSubgraphGetTypeID::type;
}

void sub_1AF91093C(_Unwind_Exception *a1)
{
}

char *static Rule<>._cachedValue(options:owner:hashValue:bodyPtr:update:)(char a1, uint64_t a2, char *a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9)
{
  if ((a2 & 0x100000000) != 0) {
    unsigned int v16 = 2;
  }
  else {
    unsigned int v16 = a2;
  }
  AssociatedTypeWitness = (AG::swift::metadata *)swift_getAssociatedTypeWitness();
  uint64_t v20 = a7;
  uint64_t v21 = a8;
  uint64_t v22 = a9;
  uint64_t v23 = a5;
  uint64_t v24 = a6;
  return AGGraphReadCachedAttribute(a3, a7, a4, AssociatedTypeWitness, a1, v16, 0, (uint64_t (*)(int64x2_t *))sub_1AF9118AC, (uint64_t)v19);
}

char *AGGraphReadCachedAttribute(char *a1, uint64_t *a2, const void *a3, AG::swift::metadata *a4, char a5, unsigned int a6, unsigned char *a7, uint64_t (*a8)(int64x2_t *), uint64_t a9)
{
  char v11 = 0;
  if (a7) {
    *a7 = v11 & 1;
  }
  return result;
}

char *anonymous namespace'::read_cached_attribute(char *a1, uint64_t *a2, const void *a3, AG::swift::metadata *a4, char a5, unsigned int a6, unsigned char *a7, int a8, uint64_t (*a9)(int64x2_t *), uint64_t a10)
{
  uint64_t v13 = AG::Graph::_current_update_key;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v15 = *(void *)(StatusReg + 8 * v13);
  if (v15) {
    unint64_t v16 = 0;
  }
  else {
    unint64_t v16 = v15 & 0xFFFFFFFFFFFFFFFELL;
  }
  if (a6 >= 4)
  {
    if (dword_1EB3D3240 <= (a6 & 0xFFFFFFFC)) {
      AG::precondition_failure((AG *)"invalid data offset: %u", a1, a2, a3, a6 & 0xFFFFFFFC);
    }
    uint64_t v17 = a6 & 0xFFFFFE00;
LABEL_11:
    uint64_t v19 = (int64x2_t ***)(AG::data::_shared_table_bytes + v17);
    goto LABEL_12;
  }
  if (v16)
  {
    unint64_t v18 = v16 + 32;
    if (*(void *)(v16 + 96)) {
      unint64_t v18 = *(void *)(v16 + 96);
    }
    uint64_t v17 = *(_DWORD *)(v18 + 8 * *(void *)(v16 + 104) - 8) & 0xFFFFFE00;
    goto LABEL_11;
  }
  uint64_t v19 = (int64x2_t ***)(StatusReg + 8 * AG::Subgraph::_current_subgraph_key);
LABEL_12:
  uint64_t v20 = *v19;
  if (!*v19) {
    AG::precondition_failure((AG *)"no subgraph", a1, a2, a3);
  }
  uint64_t v21 = (__n128 *)v20[5];
  unsigned int v22 = AG::Subgraph::cache_fetch(*v19, (uint64_t)a1, a2, a3, a9);
  if (!v22) {
    return 0;
  }
  unsigned int v23 = v22;
  if (!v16)
  {
    int v33 = AG::Graph::value_ref(v21, (const char *)v22, 0, a4, a7);
    AG::Subgraph::cache_insert(v20, v23);
    return v33;
  }
  uint64_t v24 = (a5 & 1) == 0;
  unint64_t v25 = v16 + 32;
  if (*(void *)(v16 + 96)) {
    unint64_t v25 = *(void *)(v16 + 96);
  }
  uint64_t v26 = *(unsigned int *)(v25 + 8 * *(void *)(v16 + 104) - 8);
  unsigned int v47 = v22;
  uint64_t v27 = AG::data::_shared_table_bytes + v26;
  unint64_t v28 = *(unsigned int *)(AG::data::_shared_table_bytes + v26 + 12);
  if (v28 > 0x11F)
  {
    unint64_t v29 = AG::Graph::index_of_input_slow((uint64_t)v21, AG::data::_shared_table_bytes + v26, v22 | (unint64_t)(v24 << 40) | 0x700000000);
  }
  else
  {
    if (v28 < 0x20)
    {
LABEL_23:
      unint64_t v29 = -1;
      return AG::Graph::input_value_ref_slow(v21, v26, (const char *)v23, 0, v24, a4, a7, v29);
    }
    unint64_t v29 = 0;
    unint64_t v30 = v28 >> 5;
    uint64_t v31 = (unsigned char *)(*(unsigned int *)(v27 + 16) + AG::data::_shared_table_bytes + 4);
    while (*((_DWORD *)v31 - 1) != v22 || (*v31 & 7) != v24)
    {
      ++v29;
      v31 += 5;
      if (v30 == v29) {
        goto LABEL_23;
      }
    }
  }
  if ((v29 & 0x8000000000000000) != 0) {
    return AG::Graph::input_value_ref_slow(v21, v26, (const char *)v23, 0, v24, a4, a7, v29);
  }
  uint64_t v34 = *(unsigned int *)(v27 + 16);
  uint64_t v35 = AG::data::_shared_table_bytes;
  if ((v23 & 3) != 0)
  {
    unint64_t v46 = v29;
    uint64_t v44 = AG::data::_shared_table_bytes;
    unsigned int v45 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v47, (const char *)3);
    uint64_t v35 = v44;
    unint64_t v29 = v46;
    unsigned int v23 = v45;
  }
  else
  {
    uint64_t v36 = 0;
  }
  uint64_t v37 = AG::data::_shared_table_bytes;
  uint64_t v38 = AG::data::_shared_table_bytes + v23;
  if ((*(_DWORD *)v38 & 0x11) != 0x10)
  {
    unsigned int v23 = v47;
    return AG::Graph::input_value_ref_slow(v21, v26, (const char *)v23, 0, v24, a4, a7, v29);
  }
  uint64_t v39 = v35 + v34 + 5 * v29;
  char v42 = *(unsigned char *)(v39 + 4);
  char v40 = (char *)(v39 + 4);
  char v41 = v42;
  if ((v42 & 8) != 0)
  {
    *a7 |= 1u;
    char v41 = *v40;
    uint64_t v37 = AG::data::_shared_table_bytes;
  }
  *char v40 = v41 | 0x10;
  uint64_t v43 = (void *)(v37 + *(unsigned int *)(v38 + 8));
  if ((*(unsigned char *)(v38 + 7) & 2) != 0) {
    uint64_t v43 = (void *)*v43;
  }
  return (char *)v43 + v36;
}

uint64_t AG::Subgraph::cache_fetch(int64x2_t **this, uint64_t a2, uint64_t *a3, const void *a4, uint64_t (*a5)(int64x2_t *))
{
  uint64_t v10 = *((unsigned int *)this + 23);
  if (!v10)
  {
    uint64_t v11 = *((unsigned int *)this + 4);
    if (v11
      && (uint64_t v12 = AG::data::_shared_table_bytes,
          unsigned int v13 = (*(_DWORD *)(AG::data::_shared_table_bytes + v11 + 16) + 7) & 0xFFFFFFF8,
          v13 + 280 <= *(_DWORD *)(AG::data::_shared_table_bytes + v11 + 12)))
    {
      *(_DWORD *)(AG::data::_shared_table_bytes + v11 + 16) = v13 + 280;
      unsigned int v14 = v13 + v11;
    }
    else
    {
      unsigned int v14 = AG::data::zone::alloc_slow((AG::data::zone *)this, 0x118u, 7);
      uint64_t v12 = AG::data::_shared_table_bytes;
    }
    uint64_t v10 = v14;
    AG::Subgraph::NodeCache::NodeCache((AG::Subgraph::NodeCache *)(v12 + v14));
    *((_DWORD *)this + 23) = v14;
  }
  uint64_t v15 = AG::data::_shared_table_bytes + v10;
  unsigned int v16 = util::UntypedTable::lookup((util::UntypedTable *)(AG::data::_shared_table_bytes + v10 + 40), a3, 0);
  if (!v16)
  {
    uint64_t v17 = AG::swift::metadata::equatable((AG::swift::metadata *)a3);
    if (!v17)
    {
      uint64_t v37 = AG::swift::metadata::name((AG::swift::metadata *)a3, 0);
      AG::precondition_failure((AG *)"cache key must be equatable: %s", v38, v37);
    }
    uint64_t v18 = v17;
    int v19 = a5(this[5]);
    uint64_t v20 = *((unsigned int *)this + 4);
    if (v20
      && (uint64_t v21 = AG::data::_shared_table_bytes,
          unsigned int v22 = (*(_DWORD *)(AG::data::_shared_table_bytes + v20 + 16) + 7) & 0xFFFFFFF8,
          v22 + 40 <= *(_DWORD *)(AG::data::_shared_table_bytes + v20 + 12)))
    {
      *(_DWORD *)(AG::data::_shared_table_bytes + v20 + 16) = v22 + 40;
      unsigned int v16 = v22 + v20;
    }
    else
    {
      unsigned int v16 = AG::data::zone::alloc_slow((AG::data::zone *)this, 0x28u, 7);
      uint64_t v21 = AG::data::_shared_table_bytes;
    }
    uint64_t v23 = v21 + v16;
    *(void *)uint64_t v23 = a3;
    *(void *)(v23 + 8) = v18;
    *(void *)(v23 + 16) = 0;
    *(void *)(v23 + 24) = 0;
    *(_DWORD *)(v23 + 32) = v19;
    util::UntypedTable::insert((util::UntypedTable *)(v15 + 40), a3, (void *)v16);
  }
  uint64_t v39 = a2 << 8;
  unsigned int v40 = v16;
  int v41 = 0;
  char v42 = a4;
  uint64_t v24 = util::UntypedTable::lookup((util::UntypedTable *)(v15 + 120), &v39, 0);
  if (v24)
  {
    unint64_t v25 = v24;
    uint64_t v26 = *v24;
    if (*v24)
    {
      uint64_t v27 = AG::data::_shared_table_bytes + v16;
      uint64_t v28 = v24[2];
      uint64_t v29 = v24[3];
      if (v28)
      {
        *(void *)(v28 + 24) = v29;
        uint64_t v29 = v24[3];
      }
      else
      {
        *(void *)(v27 + 24) = v29;
      }
      if (v29) {
        uint64_t v27 = v29;
      }
      *(void *)(v27 + 16) = v28;
    }
  }
  else
  {
    if (!a5) {
      return 0;
    }
    uint64_t v30 = AG::data::_shared_table_bytes + v16;
    unint64_t v25 = *(void **)(v30 + 24);
    if (!v25 || (unint64_t v31 = *(unsigned __int8 *)v25, v31 < 2))
    {
      AG::Graph::add_attribute(this[5], (AG::Subgraph *)this, *(_DWORD *)(v30 + 32), a4, 0);
      operator new();
    }
    uint64_t v32 = v25[2];
    uint64_t v33 = v25[3];
    if (v32)
    {
      *(void *)(v32 + 24) = v33;
      uint64_t v33 = v25[3];
    }
    else
    {
      *(void *)(v30 + 24) = v33;
    }
    if (v33) {
      uint64_t v30 = v33;
    }
    *(void *)(v30 + 16) = v32;
    if (v31 != 255) {
      util::UntypedTable::remove_ptr((util::UntypedTable *)(v15 + 120), v25);
    }
    uint64_t v35 = *((unsigned int *)v25 + 3);
    uint64_t v36 = (AG::Node *)(AG::data::_shared_table_bytes + v35);
    AG::Graph::remove_all_inputs((uint64_t)this[5], v35);
    *(_DWORD *)v36 |= 3u;
    AG::Node::update_self(v36, (AG::Graph *)this[5], a4);
    *unint64_t v25 = *(unsigned __int8 *)v25 | (unint64_t)(a2 << 8);
    util::UntypedTable::insert((util::UntypedTable *)(v15 + 120), v25, v25);
    uint64_t v26 = *v25;
  }
  *unint64_t v25 = v26 & 0xFFFFFFFFFFFFFF00;
  return *((unsigned int *)v25 + 3);
}

uint64_t AG::data::zone::alloc_slow(AG::data::zone *this, unsigned int a2, int a3)
{
  uint64_t v6 = *((unsigned int *)this + 4);
  if (v6)
  {
    uint64_t v7 = AG::data::_shared_table_bytes + v6;
    int v8 = *(_DWORD *)(AG::data::_shared_table_bytes + v6 + 16);
    int v9 = v8 + v6;
    if (((v8 + v6) & 0xFFFFFE00) == v6)
    {
      int v10 = *(_DWORD *)(v7 + 12);
      int v11 = v10 - v8;
      uint64_t v12 = (v9 + 3) & 0xFFFFFFFC;
      int v13 = v11 + v9 - v12;
      if (v13 >= 8)
      {
        unsigned int v14 = (_DWORD *)(AG::data::_shared_table_bytes + v12);
        v14[1] = v13;
        *unsigned int v14 = *((_DWORD *)this + 5);
        *((_DWORD *)this + 5) = v12;
        int v10 = *(_DWORD *)(v7 + 12);
      }
      *(_DWORD *)(v7 + 16) = v10;
    }
  }
  if (a2 < 0x101)
  {
    unsigned int v16 = AG::data::table::alloc_page((os_unfair_lock_s *)&AG::data::_shared_table_bytes, this, 512);
    uint64_t v21 = v16;
    uint64_t v19 = AG::data::_shared_table_bytes;
    *(_DWORD *)(AG::data::_shared_table_bytes + v16 + 8) = *((_DWORD *)this + 4);
    *((_DWORD *)this + 4) = v16;
    int v15 = ~a3;
  }
  else
  {
    int v15 = ~a3;
    unsigned int v16 = AG::data::table::alloc_page((os_unfair_lock_s *)&AG::data::_shared_table_bytes, this, (a2 + ((a3 + 24) & ~a3) + 511) & 0xFFFFFE00);
    uint64_t v18 = *((unsigned int *)this + 4);
    if (v18)
    {
      uint64_t v19 = AG::data::_shared_table_bytes;
      uint64_t v20 = AG::data::_shared_table_bytes + v18;
      uint64_t v21 = v16;
      *(_DWORD *)(AG::data::_shared_table_bytes + v16 + 8) = *(_DWORD *)(v20 + 8);
      *(_DWORD *)(v20 + 8) = v16;
    }
    else
    {
      *((_DWORD *)this + 4) = v16;
      uint64_t v19 = AG::data::_shared_table_bytes;
      uint64_t v21 = v16;
    }
  }
  uint64_t v22 = v19 + v21;
  int v23 = (*(_DWORD *)(v22 + 16) + a3) & v15;
  if (v23 + a2 > *(_DWORD *)(v22 + 12)) {
    AG::precondition_failure((AG *)"internal error", v17);
  }
  *(_DWORD *)(v22 + 16) = v23 + a2;
  return v23 + v16;
}

uint64_t AG::data::table::alloc_page(os_unfair_lock_s *this, AG::data::zone *a2, int a3)
{
  uint64_t v6 = this + 4;
  os_unfair_lock_lock(this + 4);
  unsigned int v8 = a3 + 511;
  unsigned int v9 = (a3 + 511) >> 9;
  unsigned int os_unfair_lock_opaque = this[18]._os_unfair_lock_opaque;
  unsigned int v11 = os_unfair_lock_opaque << 6;
  uint32_t v12 = this[7]._os_unfair_lock_opaque + v9;
  if (v12 <= os_unfair_lock_opaque << 6 && os_unfair_lock_opaque != 0)
  {
    int v14 = 0;
    uint64_t v15 = *(void *)&this[16]._os_unfair_lock_opaque;
    uint64_t v16 = this[9]._os_unfair_lock_opaque;
    if (v9 <= 2) {
      unsigned int v17 = 2;
    }
    else {
      unsigned int v17 = (a3 + 511) >> 9;
    }
    unsigned int v18 = v17 - 1;
    do
    {
      if ((int)v16 + v14 >= os_unfair_lock_opaque) {
        unsigned int v19 = os_unfair_lock_opaque;
      }
      else {
        unsigned int v19 = 0;
      }
      uint64_t v20 = v16 + v14 - v19;
      uint64_t v21 = *(void *)(v15 + 8 * v20);
      if (v21 == -1)
      {
LABEL_21:
        uint64_t v20 = v16;
      }
      else
      {
        unint64_t v22 = ~v21;
LABEL_14:
        uint64_t v7 = __clz(__rbit64(v22));
        if (v8 >= 0x400)
        {
          unsigned int v23 = ((v20 << 6) | 1) + v7;
          unsigned int v24 = v18;
          while (os_unfair_lock_opaque != v23 >> 6)
          {
            if ((*(void *)(v15 + 8 * (v23 >> 6)) >> v23))
            {
              uint64_t v7 = 1 << v7;
              v22 &= ~v7;
              if (v22) {
                goto LABEL_14;
              }
              goto LABEL_21;
            }
            ++v23;
            if (!--v24) {
              break;
            }
          }
        }
        unsigned int v11 = (v20 << 6) | v7;
        this[9]._unsigned int os_unfair_lock_opaque = v20;
      }
      ++v14;
      uint64_t v16 = v20;
    }
    while (v14 != os_unfair_lock_opaque);
  }
  if (v8 >= 0x200)
  {
    uint64_t v37 = v6;
    int v25 = 0;
    uint64_t v26 = this + 16;
    unsigned int v36 = v9;
    if (v9 <= 1) {
      int v27 = 1;
    }
    else {
      int v27 = v9;
    }
    do
    {
      unsigned int v28 = v11 + v25;
      uint64_t v29 = (v11 + v25) >> 6;
      if (this[18]._os_unfair_lock_opaque == (v11 + v25) >> 6)
      {
        unsigned int v30 = v29 + 1;
        if (this[19]._os_unfair_lock_opaque <= v29)
        {
          AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow((uint64_t)&this[16], v30);
          uint32_t v31 = this[18]._os_unfair_lock_opaque;
          unsigned int v30 = v31 + 1;
        }
        else
        {
          uint32_t v31 = v28 >> 6;
        }
        *(void *)(*(void *)&this[16]._os_unfair_lock_opaque + 8 * v31) = 0;
        this[18]._unsigned int os_unfair_lock_opaque = v30;
        uint32_t v32 = this[22]._os_unfair_lock_opaque;
        uint64_t v7 = v32 + 1;
        if (this[23]._os_unfair_lock_opaque < v7)
        {
          AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow((uint64_t)&this[20], v7);
          uint32_t v32 = this[22]._os_unfair_lock_opaque;
          uint64_t v7 = v32 + 1;
        }
        *(void *)(*(void *)&this[20]._os_unfair_lock_opaque + 8 * v32) = 0;
        this[22]._unsigned int os_unfair_lock_opaque = v7;
      }
      else if (!*(void *)(*(void *)&v26->_os_unfair_lock_opaque + 8 * v29))
      {
        AG::data::table::make_pages_reusable((AG::data::table *)this, v11 + v25, 0);
      }
      *(void *)(*(void *)&v26->_os_unfair_lock_opaque + 8 * v29) |= 1 << v28;
      if (!v25) {
        *(void *)(*(void *)&this[20]._os_unfair_lock_opaque + 8 * v29) |= 1 << v28;
      }
      ++v25;
    }
    while (v27 != v25);
    unsigned int v9 = v36;
    uint32_t v12 = this[7]._os_unfair_lock_opaque + v36;
    uint64_t v6 = v37;
  }
  this[7]._unsigned int os_unfair_lock_opaque = v12;
  unsigned int v33 = (v11 + v9) << 9;
  while (this[5]._os_unfair_lock_opaque < v33)
    AG::data::table::grow_region((AG::data::table *)this, (const char *)v7);
  uint64_t v34 = *(void *)&this->_os_unfair_lock_opaque + (v11 << 9) + 512;
  *(_DWORD *)(v34 + 8) = 0;
  *(_DWORD *)(v34 + 12) = v8 & 0xFFFFFE00;
  *(void *)uint64_t v34 = a2;
  *(void *)(v34 + 16) = 24;
  os_unfair_lock_unlock(v6);
  return (v11 << 9) + 512;
}

void sub_1AF911484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, os_unfair_lock_t lock)
{
}

uint64_t *AG::Subgraph::add_child(AG::Subgraph *this, unint64_t a2, char a3)
{
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3 != *((void *)this + 5)) {
    AG::precondition_failure((AG *)"child subgraph must have same graph", (const char *)a2);
  }
  unsigned int v8 = (uint64_t *)(a2 + 56);
  uint64_t v7 = *(void *)(a2 + 56);
  if (v7)
  {
    unint64_t v11 = v7 & 0xFFFFFFFFFFFFFFFELL;
    int v10 = *(AG::Subgraph ***)(v11 + 32);
    if (!v10) {
      int v10 = (AG::Subgraph **)v11;
    }
    unsigned int v9 = &v10[*(void *)(v11 + 40)];
  }
  else
  {
    unsigned int v9 = (AG::Subgraph **)&v8[v7 != 0];
    int v10 = (AG::Subgraph **)(a2 + 56);
  }
  while (v10 != v9)
  {
    if (*v10 == this) {
      AG::precondition_failure((AG *)"child already attached to new parent", (const char *)a2);
    }
    ++v10;
  }
  int v12 = *(_DWORD *)(v3 + 232);
  if (v12)
  {
    unsigned int v22 = v12 - 1;
    do
    {
      uint64_t v23 = v22;
      uint64_t v24 = *(void *)(*(void *)(v3 + 224) + 8 * v22);
      (*(void (**)(uint64_t, AG::Subgraph *, unint64_t))(*(void *)v24 + 208))(v24, this, a2);
      --v22;
    }
    while (v23);
  }
  unint64_t v13 = a3 & 3 | a2;
  unsigned int v14 = *((_DWORD *)this + 18);
  unsigned int v15 = v14 + 1;
  if (*((_DWORD *)this + 19) < v14 + 1)
  {
    AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow((uint64_t)this + 64, v15);
    unsigned int v14 = *((_DWORD *)this + 18);
    unsigned int v15 = v14 + 1;
  }
  *(void *)(*((void *)this + 8) + 8 * v14) = v13;
  *((_DWORD *)this + 18) = v15;
  unsigned int v16 = *(_DWORD *)(a2 + 100);
  int v17 = v16 | (v16 >> 8);
  unsigned int v18 = *((_DWORD *)this + 25);
  if (((v16 | BYTE1(v16)) & ~(v18 >> 8)) != 0)
  {
    *((_DWORD *)this + 25) = v18 & 0xFFFF00FF | ((BYTE1(v18) | v17) << 8);
    int v25 = (BYTE1(v18) | v17 | v18);
    AG::Subgraph::foreach_ancestor<AG::Subgraph::propagate_flags(void)::$_0>((uint64_t)this, &v25);
    unsigned int v16 = *(_DWORD *)(a2 + 100);
    unsigned int v18 = *((_DWORD *)this + 25);
  }
  int v19 = BYTE2(v16) | HIBYTE(v16);
  if ((v19 & ~HIBYTE(v18)) != 0)
  {
    int v20 = v19 | HIBYTE(v18);
    *((_DWORD *)this + 25) = v18 & 0xFFFFFF | (v20 << 24);
    int v26 = v20 | BYTE2(v18);
    AG::Subgraph::foreach_ancestor<AG::Subgraph::propagate_dirty_flags(void)::$_0>((uint64_t)this, &v26);
  }
  return AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::push_back(v8, (uint64_t)this);
}

void *AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned int,8ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned int,8ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(8 * a3);
    size_t v6 = v5 >> 3;
    if (*a2 != (v5 >> 3))
    {
      uint64_t v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

AG::Subgraph::NodeCache *AG::Subgraph::NodeCache::NodeCache(AG::Subgraph::NodeCache *this)
{
  uint64_t v2 = (char *)this + 8;
  util::Heap::Heap((AG::Subgraph::NodeCache *)((char *)this + 8), 0, 0, 0);
  util::UntypedTable::UntypedTable((uint64_t)this + 40, 0, 0, 0, 0, (uint64_t)v2);
  util::UntypedTable::UntypedTable((uint64_t)this + 120, (unint64_t (*)(util *, const void *))AG::Subgraph::NodeCache::NodeCache(void)::$_0::__invoke, (BOOL (*)(util *, util *, const void *))AG::Subgraph::NodeCache::NodeCache(void)::$_1::__invoke, 0, 0, (uint64_t)v2);
  util::UntypedTable::UntypedTable((uint64_t)this + 200, 0, 0, 0, 0, (uint64_t)v2);
  return this;
}

void sub_1AF911814(_Unwind_Exception *a1)
{
  util::UntypedTable::~UntypedTable(v3);
  util::UntypedTable::~UntypedTable(v2);
  util::Heap::~Heap(v1);
  _Unwind_Resume(a1);
}

uint64_t util::UntypedTable::UntypedTable(uint64_t result, unint64_t (*a2)(util *this, const void *a2), BOOL (*a3)(util *this, util *a2, const void *a3), uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a2) {
    size_t v6 = a2;
  }
  else {
    size_t v6 = util::pointer_hash;
  }
  BOOL v7 = a3 == 0;
  if (a3) {
    unsigned int v8 = a3;
  }
  else {
    unsigned int v8 = util::pointer_compare;
  }
  *(void *)uint64_t result = v6;
  *(void *)(result + 8) = v8;
  *(void *)(result + 16) = a4;
  *(void *)(result + 24) = a5;
  *(void *)(result + 32) = a6;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_DWORD *)(result + 72) = 0;
  *(unsigned char *)(result + 76) = a6 == 0;
  if (a3 == util::pointer_compare) {
    BOOL v7 = 1;
  }
  *(unsigned char *)(result + 77) = v7;
  return result;
}

uint64_t sub_1AF9118AC(uint64_t a1)
{
  return sub_1AF9118BC(a1, *(void *)(v1 + 40), *(void *)(v1 + 48), *(uint64_t **)(v1 + 16));
}

uint64_t sub_1AF9118BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return AGGraphInternAttributeType(a1, a4, sub_1AF907EC8);
}

void *AG::Subgraph::cache_insert(void *result, unsigned int a2)
{
  if (!*((unsigned char *)result + 104))
  {
    uint64_t v2 = (unsigned int *)(AG::data::_shared_table_bytes + a2);
    if ((*((unsigned char *)v2 + 7) & 0x10) != 0)
    {
      unint64_t v3 = *v2;
      if ((v3 & 0xC0) == 0 && v2[5] <= 0x1F)
      {
        uint64_t v4 = result;
        size_t v5 = (uint64_t *)a2;
        uint64_t v6 = AG::data::_shared_table_bytes + *((unsigned int *)result + 23);
        uint64_t v7 = AG::data::_shared_table_bytes
           + util::UntypedTable::lookup((util::UntypedTable *)(v6 + 40), **(uint64_t ***)(*(void *)(result[5] + 128) + ((v3 >> 5) & 0x7FFFFF8)), 0);
        uint64_t result = util::UntypedTable::lookup((util::UntypedTable *)(v6 + 200), v5, 0);
        ++*result;
        uint64_t v8 = *(void *)(v7 + 16);
        result[2] = v8;
        result[3] = 0;
        *(void *)(v7 + 16) = result;
        if (!v8) {
          uint64_t v8 = v7;
        }
        *(void *)(v8 + 24) = result;
        char v9 = *((unsigned char *)v4 + 105);
        if ((v9 & 1) == 0)
        {
          if ((*((unsigned char *)v4 + 105) & 2) == 0)
          {
            uint64_t v10 = v4[5];
            unsigned int v11 = *(_DWORD *)(v10 + 368);
            unsigned int v12 = v11 + 1;
            if (*(_DWORD *)(v10 + 372) < v11 + 1)
            {
              uint64_t result = AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow(v10 + 360, v12);
              unsigned int v11 = *(_DWORD *)(v10 + 368);
              unsigned int v12 = v11 + 1;
            }
            *(void *)(*(void *)(v10 + 360) + 8 * v11) = v4;
            *(_DWORD *)(v10 + 368) = v12;
            char v9 = *((unsigned char *)v4 + 105);
          }
          *((unsigned char *)v4 + 105) = v9 | 1;
        }
      }
    }
  }
  return result;
}

uint64_t AG::Node::update_self(AG::Node *this, AG::Graph *a2, const void *a3)
{
  unint64_t v3 = *(unsigned int *)this;
  uint64_t v4 = *(void *)(*((void *)a2 + 16) + ((v3 >> 5) & 0x7FFFFF8));
  uint64_t v5 = *(void *)(*(void *)v4 - 8);
  if ((v3 & 0x20) != 0)
  {
    if (v5) {
      uint64_t v7 = *(void *)(*(void *)v4 - 8);
    }
    else {
      uint64_t v7 = 0;
    }
    if (*(void *)(v7 + 24)) {
      uint64_t v8 = *(uint64_t (**)(void *, const void *))(v7 + 24);
    }
    else {
      uint64_t v8 = 0;
    }
  }
  else
  {
    if (v5) {
      uint64_t v6 = *(void *)(*(void *)v4 - 8);
    }
    else {
      uint64_t v6 = 0;
    }
    if (*(void *)(v6 + 16)) {
      uint64_t v8 = *(uint64_t (**)(void *, const void *))(v6 + 16);
    }
    else {
      uint64_t v8 = 0;
    }
    *(_DWORD *)this = v3 | 0x20;
  }
  char v9 = (void *)((char *)this + *(unsigned int *)(v4 + 44));
  if (*((unsigned char *)this + 7)) {
    char v9 = (void *)*v9;
  }
  return v8(v9, a3);
}

void *AG::data::table::grow_region(AG::data::table *this, const char *a2)
{
  unsigned int v2 = *((_DWORD *)this + 5);
  uint64_t v3 = 4 * v2;
  if (v3 <= v2) {
    AG::precondition_failure((AG *)"exhausted data space", a2);
  }
  vm_address_t target_address = (vm_address_t)mmap(0, 4 * v2, 3, 4098, -1, 0);
  if (target_address == -1)
  {
    unsigned int v11 = __error();
    AG::precondition_failure((AG *)"memory allocation failure (%u bytes, %u)", v12, v3, *v11);
  }
  vm_prot_t cur_protection = 0;
  vm_prot_t v13 = 0;
  uint64_t result = (void *)vm_remap(*MEMORY[0x1E4F14960], &target_address, *((unsigned int *)this + 5), 0, 0x4000, *MEMORY[0x1E4F14960], *((void *)this + 1), 0, &cur_protection, &v13, 2u);
  if (result) {
    AG::precondition_failure((AG *)"vm_remap failure: 0x%x", v6, result);
  }
  unsigned int v7 = *((_DWORD *)this + 14);
  unsigned int v8 = v7 + 1;
  if (*((_DWORD *)this + 15) < v7 + 1)
  {
    uint64_t result = AG::vector<std::pair<unsigned char *,unsigned int>,0ul,unsigned int>::reserve_slow((uint64_t)this + 48, v8);
    unsigned int v7 = *((_DWORD *)this + 14);
    unsigned int v8 = v7 + 1;
  }
  uint64_t v9 = *((void *)this + 6) + 16 * v7;
  *(void *)uint64_t v9 = *((void *)this + 1);
  *(_DWORD *)(v9 + 8) = *((_DWORD *)this + 5);
  *((_DWORD *)this + 14) = v8;
  vm_address_t v10 = target_address;
  AGGraphVMRegionBaseAddress = target_address;
  *(void *)this = target_address - 512;
  *((void *)this + 1) = v10;
  *((_DWORD *)this + 5) = v3;
  *((_DWORD *)this + 6) = v3 + 512;
  return result;
}

uint64_t AGGraphRegisterNamedTraceEvent(const char *a1, char *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&NamedEvents::lock);
  uint64_t v4 = NamedEvents::names;
  if (!NamedEvents::names) {
    operator new();
  }
  uint64_t v5 = *(unsigned int *)(NamedEvents::names + 8);
  if (a2) {
    a2 = strdup(a2);
  }
  uint64_t v6 = strdup(a1);
  unsigned int v7 = v5 + 1;
  if (*(_DWORD *)(v4 + 12) < (v5 + 1))
  {
    AG::vector<std::pair<unsigned char *,unsigned int>,0ul,unsigned int>::reserve_slow(v4, v7);
    unsigned int v8 = *(_DWORD *)(v4 + 8);
    unsigned int v7 = v8 + 1;
  }
  else
  {
    unsigned int v8 = v5;
  }
  uint64_t v9 = (char **)(*(void *)v4 + 16 * v8);
  void *v9 = a2;
  v9[1] = v6;
  *(_DWORD *)(v4 + 8) = v7;
  os_unfair_lock_unlock((os_unfair_lock_t)&NamedEvents::lock);
  return v5;
}

void sub_1AF911DDC(_Unwind_Exception *a1)
{
}

void *AG::vector<std::pair<unsigned char *,unsigned int>,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned int,16ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned int,16ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(16 * a3);
    size_t v6 = v5 >> 4;
    if (*a2 != (v5 >> 4))
    {
      unsigned int v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void AG::Subgraph::set_flags(uint64_t a1, unsigned int a2, unsigned __int8 a3)
{
  unsigned int v3 = (unsigned char *)(AG::data::_shared_table_bytes + a2);
  if (v3[6] != a3)
  {
    int v5 = a3;
    if (a3 && v3[6])
    {
      v3[6] = a3;
    }
    else
    {
      AG::Subgraph::unlink_attribute(a1, a2);
      v3[6] = v5;
      AG::Subgraph::insert_attribute(v7, a2, 1);
    }
    int v8 = *(_DWORD *)(a1 + 100);
    if ((v5 & ~v8) != 0)
    {
      *(_DWORD *)(a1 + 100) = v8 | v5;
      int v10 = (v8 | v5 | BYTE1(v8));
      AG::Subgraph::foreach_ancestor<AG::Subgraph::propagate_flags(void)::$_0>(a1, &v10);
    }
    if (*v3)
    {
      unsigned int v9 = *(_DWORD *)(a1 + 100);
      if ((v5 & ~HIWORD(v9)) != 0)
      {
        *(_DWORD *)(a1 + 100) = v9 & 0xFF00FFFF | ((BYTE2(v9) | v5) << 16);
        int v11 = (BYTE2(v9) | v5) | HIBYTE(v9);
        AG::Subgraph::foreach_ancestor<AG::Subgraph::propagate_dirty_flags(void)::$_0>(a1, &v11);
      }
    }
  }
}

void AG::Subgraph::unlink_attribute(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00);
  int v5 = *(unsigned __int16 *)(v2 + 20);
  unsigned int v3 = (_WORD *)(v2 + 20);
  int v4 = v5;
  if (!v5) {
    goto LABEL_17;
  }
  unsigned int v6 = 2;
  do
  {
    while (1)
    {
      unsigned int v7 = v4 + (a2 & 0xFFFFFE00);
      int v8 = v4 & 3;
      if ((v4 & 3) != 0) {
        break;
      }
      if (v7 == a2) {
        goto LABEL_13;
      }
      unsigned int v9 = (unsigned __int16 *)(AG::data::_shared_table_bytes + 4 + v7);
LABEL_12:
      int v4 = *v9;
      unsigned int v6 = v7;
      if (!v4) {
        goto LABEL_13;
      }
    }
    if (v8 == 1)
    {
      if (v7 == a2) {
        break;
      }
      unsigned int v9 = (unsigned __int16 *)(AG::data::_shared_table_bytes + 14 + (v7 & 0xFFFFFFFC));
      goto LABEL_12;
    }
  }
  while (v8 != 2 && v4);
LABEL_13:
  if ((v6 & 3) == 0) {
    unsigned int v3 = (_WORD *)(AG::data::_shared_table_bytes + v6 + 4);
  }
  if ((v6 & 3) == 1) {
    unsigned int v3 = (_WORD *)(AG::data::_shared_table_bytes + (v6 & 0xFFFFFFFC) + 14);
  }
LABEL_17:
  int v10 = (_WORD *)(AG::data::_shared_table_bytes + a2 + 4);
  if ((a2 & 3) != 0) {
    int v10 = (_WORD *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFFFC) + 14);
  }
  *unsigned int v3 = *v10;
  *int v10 = 0;
}

uint64_t AG::Subgraph::foreach_ancestor<AG::Subgraph::propagate_flags(void)::$_0>(uint64_t result, _DWORD *a2)
{
  for (uint64_t i = result; ; uint64_t i = result)
  {
    uint64_t v4 = *(void *)(i + 56);
    uint64_t v5 = (v4 & 1) != 0 ? *(void *)((v4 & 0xFFFFFFFFFFFFFFFELL) + 40) : v4 != 0;
    uint64_t v6 = v5 - 1;
    if (v5 - 1 < 0) {
      break;
    }
    while (1)
    {
      uint64_t result = *(void *)(i + 56);
      if (result)
      {
        unint64_t v7 = result & 0xFFFFFFFFFFFFFFFELL;
        if (*(void *)((result & 0xFFFFFFFFFFFFFFFELL) + 32)) {
          unint64_t v7 = *(void *)((result & 0xFFFFFFFFFFFFFFFELL) + 32);
        }
        uint64_t result = *(void *)(v7 + 8 * v6);
      }
      unsigned int v8 = *(_DWORD *)(result + 100);
      if (((~(v8 >> 8) | 0xFFFFFF00) & *a2) == 0) {
        goto LABEL_13;
      }
      *(_DWORD *)(result + 100) = v8 & 0xFFFF00FF | ((BYTE1(v8) | *a2) << 8);
      if (!v6) {
        break;
      }
      uint64_t result = AG::Subgraph::foreach_ancestor<AG::Subgraph::propagate_flags(void)::$_0>();
LABEL_13:
      if (v6-- <= 0) {
        return result;
      }
    }
  }
  return result;
}

void AG::Graph::mark_changed(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  unint64_t v3 = v2;
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v9 = v8;
  unsigned int v11 = v10;
  uint64_t v38 = v1;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  util::Heap::Heap((util::Heap *)v40, v41, 0x2000, 0);
  if ((v11 & 3) == 1)
  {
    uint64_t v35 = v9;
    uint64_t v36 = v7;
    uint64_t v37 = v5;
    uint64_t v12 = AG::data::_shared_table_bytes;
    uint64_t v13 = AG::data::_shared_table_bytes + (v11 & 0xFFFFFFFC);
    goto LABEL_5;
  }
  if ((v11 & 3) == 0)
  {
    uint64_t v35 = v9;
    uint64_t v36 = v7;
    uint64_t v37 = v5;
    uint64_t v12 = AG::data::_shared_table_bytes;
    uint64_t v13 = AG::data::_shared_table_bytes + v11;
LABEL_5:
    unsigned int v14 = (unsigned int *)(v13 + 20);
    unsigned int v15 = (unsigned int *)(v13 + 24);
    unsigned int v16 = 0;
    int v17 = 0;
    uint64_t v18 = v12 + *v15;
    unint64_t v19 = (unint64_t)*v14 >> 5;
    while (1)
    {
      while (v3 >= v19)
      {
        int v20 = v16;
LABEL_34:
        if (!v20)
        {
          ++*(void *)(v38 + 464);
          goto LABEL_38;
        }
        unint64_t v3 = 0;
        unsigned int v16 = *(char **)v20;
        uint64_t v18 = *((void *)v20 + 1);
        unint64_t v19 = *((void *)v20 + 2);
        *(void *)int v20 = v17;
        int v17 = v20;
        unsigned int v11 = *((_DWORD *)v20 + 6);
      }
      int v20 = v16;
      while (1)
      {
        uint64_t v21 = *(unsigned int *)(v18 + 4 * v3);
        if ((v21 & 3) == 0)
        {
          unint64_t v26 = *(unsigned int *)(AG::data::_shared_table_bytes + v21 + 12);
          if (v26 >= 0x20)
          {
            uint64_t v27 = 0;
            unint64_t v28 = v26 >> 5;
            uint64_t v29 = (unsigned char *)(AG::data::_shared_table_bytes
                          + *(unsigned int *)(AG::data::_shared_table_bytes + v21 + 16)
                          + 4);
            while (1)
            {
              int v30 = *((_DWORD *)v29 - 1);
              int v39 = v30;
              if ((v30 & 3) != 0) {
                int v30 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v39, 4u);
              }
              if (v30 == v11 && (*v29 & 8) == 0)
              {
                if ((*(v29 - 4) & 3) == 0) {
                  break;
                }
                unint64_t v34 = v34 & 0xFFFFFF0000000000 | *((unsigned int *)v29 - 1) | ((unint64_t)*v29 << 32);
                if ((AG::Graph::compare_edge_values(v38, *((_DWORD *)v29 - 1), v35, v36, v37) & 1) == 0) {
                  break;
                }
              }
              ++v27;
              v29 += 5;
              if (v28 == v27) {
                goto LABEL_28;
              }
            }
            uint64_t v31 = *(unsigned int *)(v38 + 232);
            if (v31)
            {
              for (uint64_t i = 8 * v31 - 8; i != -8; i -= 8)
              {
                uint64_t v33 = *(void *)(*(void *)(v38 + 224) + i);
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v33 + 248))(v33, v21, v27, 1);
              }
            }
            *v29 |= 8u;
          }
          goto LABEL_28;
        }
        if ((*(_DWORD *)(v18 + 4 * v3) & 3) == 1)
        {
          unsigned int v22 = (_DWORD *)(AG::data::_shared_table_bytes + (v21 & 0xFFFFFFFC));
          if (v22[4] != v11) {
            break;
          }
        }
LABEL_28:
        if (++v3 >= v19) {
          goto LABEL_34;
        }
      }
      uint64_t v23 = AG::data::_shared_table_bytes + v22[6];
      unint64_t v24 = (unint64_t)v22[5] >> 5;
      if (v3 != v19 - 1) {
        break;
      }
      unint64_t v3 = 0;
      unint64_t v19 = (unint64_t)v22[5] >> 5;
      uint64_t v18 = AG::data::_shared_table_bytes + v22[6];
      unsigned int v16 = v20;
      unsigned int v11 = v21;
    }
    if (v17)
    {
      int v25 = *(char **)v17;
    }
    else
    {
      int v17 = util::Heap::alloc_((util::Heap *)v40, 0x20uLL);
      int v25 = 0;
    }
    *(void *)int v17 = v20;
    *((void *)v17 + 1) = v23;
    *((void *)v17 + 2) = v24;
    *((_DWORD *)v17 + 6) = v21;
    int v20 = v17;
    int v17 = v25;
    goto LABEL_28;
  }
LABEL_38:
  util::Heap::reset((util::Heap *)v40, 0, 0);
}

void sub_1AF912488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  util::InlineHeap<8192ul>::~InlineHeap((util::Heap *)va);
  _Unwind_Resume(a1);
}

void AG::Graph::propagate_dirty(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  unsigned int v3 = v2;
  uint64_t v55 = v1;
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  util::Heap::Heap((util::Heap *)v58, v59, 0x2000, 0);
  if ((v3 & 3) == 2) {
    goto LABEL_72;
  }
  uint64_t v4 = &AG::data::_shared_table_bytes;
  if ((v3 & 3) == 1)
  {
    uint64_t v8 = AG::data::_shared_table_bytes;
    uint64_t v9 = (unsigned int *)(AG::data::_shared_table_bytes + (v3 & 0xFFFFFFFC));
    unsigned int v10 = v9[5];
    uint64_t v11 = v9[6];
    unsigned int v12 = *v9;
    unsigned int v57 = v12;
    if ((v12 & 3) != 0) {
      unsigned int v12 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v57, 0);
    }
    uint64_t v6 = v8 + v11;
    LODWORD(v7) = v10 >> 5;
    if ((v12 & 3) == 0)
    {
      uint64_t v5 = (unsigned int *)(AG::data::_shared_table_bytes + v12);
      goto LABEL_9;
    }
LABEL_11:
    uint64_t v13 = 0;
    goto LABEL_12;
  }
  if ((v3 & 3) != 0)
  {
    LODWORD(v7) = 0;
    uint64_t v6 = 0;
    goto LABEL_11;
  }
  uint64_t v5 = (unsigned int *)(AG::data::_shared_table_bytes + v3);
  uint64_t v6 = AG::data::_shared_table_bytes + v5[6];
  LODWORD(v7) = v5[5] >> 5;
LABEL_9:
  uint64_t v13 = *v5;
LABEL_12:
  unsigned int v14 = 0;
  unsigned int v15 = 0;
  uint64_t v53 = (util::UntypedTable *)(v55 + 144);
  uint64_t v54 = v3 & 0xFFFFFE00;
  uint64_t v52 = v3;
  uint64_t v7 = v7;
  while (1)
  {
    unint64_t v16 = v7 - 1;
    if (v7 - 1 >= 0)
    {
      char v56 = v14;
      while (1)
      {
        uint64_t v17 = *(unsigned int *)(v6 + 4 * v16);
        if ((v17 & 3) != 0)
        {
          if ((*(_DWORD *)(v6 + 4 * v16) & 3) != 1) {
            goto LABEL_51;
          }
          uint64_t v18 = *v4;
          uint64_t v19 = *v4 + (v17 & 0xFFFFFFFC);
          int v20 = *(_DWORD *)(v19 + 8);
          if ((v20 & 1) == 0) {
            goto LABEL_51;
          }
          uint64_t v22 = v19 + 20;
          unint64_t v21 = *(unsigned int *)(v19 + 20);
          uint64_t v23 = v18 + *(unsigned int *)(v22 + 4);
          unint64_t v24 = v21 >> 5;
          if ((v20 & 2) == 0)
          {
            uint64_t v25 = v13;
            goto LABEL_28;
          }
          if (v21 >= 0x20)
          {
            uint64_t v34 = *(void *)(v18 + (v17 & 0xFFFFFE00));
            if (v34
              && (uint64_t v35 = *(uint64_t **)(v34 + 48)) != 0
              && ((uint64_t v36 = *(void *)(v18 + v54)) == 0 || v35 != *(uint64_t **)(v36 + 48))
              && (uint64_t v37 = util::UntypedTable::lookup(v53, v35, 0)) != 0
              && *((_DWORD *)v37 + 16) != *(_DWORD *)(*v37 + 472))
            {
              AG::Graph::Context::call_invalidation(v37, v52);
              uint64_t v25 = v13;
            }
            else
            {
              uint64_t v25 = v13;
            }
LABEL_29:
            if (v16)
            {
              if (v15)
              {
                uint64_t v33 = *(char **)v15;
              }
              else
              {
                unsigned int v15 = util::Heap::alloc_((util::Heap *)v58, 0x20uLL);
                uint64_t v33 = 0;
              }
              *(void *)unsigned int v15 = v56;
              *((void *)v15 + 1) = v23;
              *((void *)v15 + 2) = v24;
              char v56 = v15;
              *((_DWORD *)v15 + 6) = v25;
              unsigned int v15 = v33;
            }
            else
            {
              uint64_t v6 = v23;
              unint64_t v16 = v24;
              uint64_t v13 = v25;
            }
          }
        }
        else
        {
          unint64_t v24 = 0;
          unint64_t v26 = v4;
          uint64_t v27 = *v4;
          unint64_t v28 = (int *)(*v4 + v17);
          int v29 = *v28;
          uint64_t v23 = 0;
          if ((v13 & 4) != 0 && (v29 & 4) == 0)
          {
            v29 |= 4u;
            *unint64_t v28 = v29;
            uint64_t v23 = v27 + v28[6];
            unint64_t v24 = (unint64_t)v28[5] >> 5;
          }
          uint64_t v25 = v29 | v13;
          if (v29) {
            goto LABEL_27;
          }
          uint64_t v30 = *(unsigned int *)(v55 + 232);
          if (v30)
          {
            for (uint64_t i = 8 * v30 - 8; i != -8; i -= 8)
            {
              uint64_t v43 = *(void *)(*(void *)(v55 + 224) + i);
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v43 + 256))(v43, v17, 1);
            }
            int v29 = *v28;
            uint64_t v27 = *v26;
          }
          *unint64_t v28 = v29 | 1;
          int v31 = *((unsigned __int8 *)v28 + 6);
          if (*((unsigned char *)v28 + 6))
          {
            uint64_t v44 = *(AG::Subgraph **)(v27 + (v17 & 0xFFFFFE00));
            if (v44)
            {
              unsigned int v45 = *((_DWORD *)v44 + 25);
              if ((v31 & ~HIWORD(v45)) != 0)
              {
                *((_DWORD *)v44 + 25) = v45 & 0xFF00FFFF | ((BYTE2(v45) | v31) << 16);
                AG::Subgraph::propagate_dirty_flags(v44);
                uint64_t v27 = *v26;
              }
            }
          }
          unint64_t v32 = v28[5];
          uint64_t v23 = v27 + v28[6];
          unint64_t v24 = v32 >> 5;
          if ((*((unsigned char *)v28 + 7) & 4) == 0)
          {
LABEL_27:
            uint64_t v4 = v26;
LABEL_28:
            if (v24) {
              goto LABEL_29;
            }
            goto LABEL_51;
          }
          uint64_t v4 = v26;
          if (v32 >= 0x20)
          {
            uint64_t v38 = *(void *)(v27 + (v17 & 0xFFFFFE00));
            if (v38)
            {
              int v39 = *(uint64_t **)(v38 + 48);
              if (v39)
              {
                uint64_t v40 = *(void *)(v27 + v54);
                if (!v40 || v39 != *(uint64_t **)(v40 + 48))
                {
                  int v41 = util::UntypedTable::lookup(v53, v39, 0);
                  if (v41)
                  {
                    if (*((_DWORD *)v41 + 16) != *(_DWORD *)(*v41 + 472)) {
                      AG::Graph::Context::call_invalidation(v41, v52);
                    }
                  }
                }
              }
            }
            goto LABEL_29;
          }
        }
LABEL_51:
        if ((--v16 & 0x8000000000000000) != 0) {
          goto LABEL_62;
        }
      }
    }
    char v56 = v14;
LABEL_62:
    if (!v56) {
      break;
    }
    unsigned int v14 = *(char **)v56;
    uint64_t v6 = *((void *)v56 + 1);
    uint64_t v7 = *((void *)v56 + 2);
    *(void *)char v56 = v15;
    unsigned int v15 = v56;
    uint64_t v13 = *((unsigned int *)v56 + 6);
  }
  uint64_t v46 = AG::Graph::_current_update_key;
  uint64_t v47 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v46);
  if (v47)
  {
    while (1)
    {
      unsigned int v48 = (void *)(v47 & 0xFFFFFFFFFFFFFFFELL);
      uint64_t v49 = v48[13];
      if (v49) {
        break;
      }
LABEL_71:
      uint64_t v47 = v48[2];
      if (!v47) {
        goto LABEL_72;
      }
    }
    uint64_t v50 = v48 + 4;
    if (v48[12]) {
      uint64_t v50 = (void *)v48[12];
    }
    uint64_t v51 = (_DWORD *)&v50[v49 - 1] + 1;
    while ((*v51 & 4) == 0)
    {
      *v51 |= 4u;
      v51 -= 2;
      if (!--v49) {
        goto LABEL_71;
      }
    }
  }
LABEL_72:
  util::Heap::reset((util::Heap *)v58, 0, 0);
}

void sub_1AF91293C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  util::InlineHeap<8192ul>::~InlineHeap((util::Heap *)va);
  _Unwind_Resume(a1);
}

uint64_t util::UntypedTable::insert(util::UntypedTable *this, void *a2, void *a3)
{
  if (!*((void *)this + 6)) {
    util::UntypedTable::create_buckets(this);
  }
  uint64_t v6 = (*(uint64_t (**)(void *))this)(a2);
  uint64_t v7 = *(void **)(*((void *)this + 6) + 8 * (*((void *)this + 8) & v6));
  if (v7)
  {
    while (v7[3] != v6 || !(*((unsigned int (**)(void, void *))this + 1))(v7[1], a2))
    {
      uint64_t v7 = (void *)*v7;
      if (!v7) {
        goto LABEL_7;
      }
    }
    unsigned int v14 = (void (*)(void))*((void *)this + 2);
    if (v14) {
      v14(v7[1]);
    }
    unsigned int v15 = (void (*)(void))*((void *)this + 3);
    if (v15) {
      v15(v7[2]);
    }
    uint64_t result = 0;
    v7[1] = a2;
    v7[2] = a3;
  }
  else
  {
LABEL_7:
    if (*((void *)this + 7) + 1 > (unint64_t)(4 << *((_DWORD *)this + 18))) {
      util::UntypedTable::grow_buckets(this);
    }
    uint64_t v8 = (util::Heap *)*((void *)this + 4);
    if (!v8) {
      operator new();
    }
    uint64_t v9 = (char *)*((void *)this + 5);
    if (v9) {
      *((void *)this + 5) = *(void *)v9;
    }
    else {
      uint64_t v9 = util::Heap::alloc_(v8, 0x20uLL);
    }
    *((void *)v9 + 1) = a2;
    *((void *)v9 + 2) = a3;
    *((void *)v9 + 3) = v6;
    uint64_t v10 = *((void *)this + 7);
    uint64_t v11 = *((void *)this + 8) & v6;
    uint64_t v12 = *((void *)this + 6);
    *(void *)uint64_t v9 = *(void *)(v12 + 8 * v11);
    *(void *)(v12 + 8 * v11) = v9;
    *((void *)this + 7) = v10 + 1;
    return 1;
  }
  return result;
}

void sub_1AF912AE4(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x1030C4075AECAACLL);
  _Unwind_Resume(a1);
}

char *util::Heap::alloc_(util::Heap *this, size_t a2)
{
  size_t v4 = *((void *)this + 3);
  BOOL v5 = v4 >= a2;
  size_t v6 = v4 - a2;
  if (v5)
  {
    uint64_t result = (char *)*((void *)this + 2);
    *((void *)this + 2) = &result[a2];
    *((void *)this + 3) = v6;
  }
  else if (a2 < 0x401)
  {
    uint64_t v9 = malloc_type_malloc(*(void *)this, 0x3D2812E6uLL);
    uint64_t v10 = *(void *)this;
    *((void *)this + 2) = v9;
    *((void *)this + 3) = v10;
    uint64_t v11 = (void *)util::Heap::alloc_(this, 0x10uLL);
    uint64_t result = (char *)*((void *)this + 2);
    *uint64_t v11 = *((void *)this + 1);
    v11[1] = v9;
    *((void *)this + 1) = v11;
    *((void *)this + 2) = &result[a2];
    *((void *)this + 3) -= a2;
  }
  else
  {
    uint64_t v7 = (void *)util::Heap::alloc_(this, 0x10uLL);
    uint64_t result = (char *)malloc_type_malloc(a2, 0xD522008BuLL);
    if (result)
    {
      *uint64_t v7 = *((void *)this + 1);
      v7[1] = result;
      *((void *)this + 1) = v7;
    }
  }
  return result;
}

uint64_t AG::Subgraph::propagate_dirty_flags(AG::Subgraph *this)
{
  int v2 = BYTE2(*((_DWORD *)this + 25)) | HIBYTE(*((_DWORD *)this + 25));
  return AG::Subgraph::foreach_ancestor<AG::Subgraph::propagate_dirty_flags(void)::$_0>((uint64_t)this, &v2);
}

uint64_t AG::Subgraph::foreach_ancestor<AG::Subgraph::propagate_dirty_flags(void)::$_0>(uint64_t result, _DWORD *a2)
{
LABEL_1:
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 56);
  if (v4) {
    uint64_t v5 = *(void *)((v4 & 0xFFFFFFFFFFFFFFFELL) + 40);
  }
  else {
    uint64_t v5 = v4 != 0;
  }
  uint64_t v6 = v5 - 1;
  if (v5 - 1 >= 0)
  {
    do
    {
      uint64_t result = *(void *)(v3 + 56);
      if (result)
      {
        unint64_t v7 = result & 0xFFFFFFFFFFFFFFFELL;
        if (*(void *)((result & 0xFFFFFFFFFFFFFFFELL) + 32)) {
          unint64_t v7 = *(void *)((result & 0xFFFFFFFFFFFFFFFELL) + 32);
        }
        uint64_t result = *(void *)(v7 + 8 * v6);
      }
      unsigned int v8 = *(_DWORD *)(result + 100);
      if ((*a2 & ~HIBYTE(v8)) != 0)
      {
        *(_DWORD *)(result + 100) = v8 & 0xFFFFFF | ((*a2 | HIBYTE(v8)) << 24);
        if (!v6) {
          goto LABEL_1;
        }
        uint64_t result = AG::Subgraph::foreach_ancestor<AG::Subgraph::propagate_dirty_flags(void)::$_0>();
      }
    }
    while (v6-- > 0);
  }
  return result;
}

util::Heap *util::Heap::Heap(util::Heap *this, char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5 = 1024;
  if (a4 > 0x400) {
    uint64_t v5 = a4;
  }
  if (!a4) {
    uint64_t v5 = 0x2000;
  }
  *(void *)this = v5;
  *((void *)this + 1) = 0;
  util::Heap::reset(this, a2, a3);
  return this;
}

void util::Heap::reset(util::Heap *this, char *a2, uint64_t a3)
{
  for (uint64_t i = (void *)*((void *)this + 1); i; uint64_t i = (void *)*((void *)this + 1))
  {
    unint64_t v7 = (void *)i[1];
    *((void *)this + 1) = *i;
    free(v7);
  }
  unsigned int v8 = (char *)((unint64_t)(a2 + 7) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v9 = (char *)(a2 - v8);
  if ((a2 & 7) == 0) {
    uint64_t v9 = 0;
  }
  uint64_t v10 = &v9[a3];
  if ((a2 & 7) == 0) {
    unsigned int v8 = a2;
  }
  *((void *)this + 2) = v8;
  *((void *)this + 3) = v10;
}

uint64_t AG::Graph::value_set(AG::Graph *a1, const char *a2, AG::LayoutDescriptor *a3, unsigned __int8 *a4)
{
  uint64_t v6 = (AG::Node *)(AG::data::_shared_table_bytes + a2);
  if (*((_DWORD *)v6 + 3) >= 0x20u && (*(unsigned char *)v6 & 0x10) != 0) {
    AG::precondition_failure((AG *)"can only set initial value of computed attributes: %u", a2, a2);
  }
  uint64_t v7 = AG::Graph::_current_update_key;
  uint64_t v8 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  if ((v8 & 1) == 0)
  {
    uint64_t v9 = (AG::Graph **)(v8 & 0xFFFFFFFFFFFFFFFELL);
    if (v9)
    {
      if (*v9 == a1 && (*((_DWORD *)v6 + 5) > 0x1Fu || (*(unsigned char *)v6 & 0xC0) != 0)) {
        AG::precondition_failure((AG *)"setting value during update: %u", a2, a2);
      }
    }
  }
  uint64_t v10 = AG::Graph::value_set_internal(a1, a2, v6, a4, a3);
  if (v10) {
    AG::Graph::propagate_dirty((uint64_t)a1);
  }
  return v10;
}

uint64_t AG::Graph::value_set_internal(AG::Graph *a1, uint64_t a2, AG::Node *this, unsigned __int8 *a4, AG::LayoutDescriptor *a5)
{
  uint64_t v6 = a4;
  int v10 = *((_DWORD *)a1 + 58);
  if (v10)
  {
    unsigned int v34 = v10 - 1;
    do
    {
      uint64_t v35 = v34;
      uint64_t v36 = *(void *)(*((void *)a1 + 28) + 8 * v34);
      (*(void (**)(uint64_t, void, unsigned __int8 *))(*(void *)v36 + 272))(v36, a2, v6);
      uint64_t v6 = a4;
      --v34;
    }
    while (v35);
  }
  unint64_t v11 = *(unsigned int *)this;
  uint64_t v12 = *(void *)(*((void *)a1 + 16) + ((v11 >> 5) & 0x7FFFFF8));
  uint64_t v13 = *(AG::swift::metadata **)(v12 + 8);
  if (v13 != a5)
  {
    uint64_t v37 = AG::swift::metadata::name(v13, 0);
    uint64_t v38 = AG::swift::metadata::name(a5, 0);
    AG::precondition_failure((AG *)"invalid value type for attribute: %u (saw %s, expected %s)", v39, a2, v37, v38);
  }
  if ((v11 & 0x10) != 0)
  {
    unsigned int v14 = (AG::LayoutDescriptor *)(AG::data::_shared_table_bytes + *((unsigned int *)this + 2));
    if ((*((unsigned char *)this + 7) & 2) != 0) {
      unsigned int v14 = *(AG::LayoutDescriptor **)v14;
    }
    int v15 = *(_DWORD *)(v12 + 40);
    unint64_t v16 = (unint64_t *)(v15 & 3 | 0x80000100);
    uint64_t v17 = *(AG::LayoutDescriptor ***)(v12 + 48);
    if (!v17)
    {
      uint64_t v17 = (AG::LayoutDescriptor **)AG::LayoutDescriptor::fetch(a5, (const AG::swift::metadata *)(v15 & 3 | 0x80000100), 0);
      uint64_t v6 = a4;
      *(void *)(v12 + 48) = v17;
    }
    if (v17 == (AG::LayoutDescriptor **)1) {
      uint64_t v17 = 0;
    }
    uint64_t v18 = (uint64_t *)((char *)a5 - 8);
    if (AG::LayoutDescriptor::compare(v17, v14, v6, *(char **)(*((void *)a5 - 1) + 64), v16)) {
      return 0;
    }
    uint64_t v20 = a2;
    if (!*((_DWORD *)a1 + 58))
    {
      unsigned int v45 = a5;
      uint64_t v46 = (uint64_t)v14;
      unint64_t v21 = *(unsigned int *)(AG::data::_shared_table_bytes + a2 + 20);
      uint64_t v22 = a4;
      if (v21 < 0x20) {
        goto LABEL_30;
      }
      uint64_t v23 = 0;
      uint64_t v24 = AG::data::_shared_table_bytes + *(unsigned int *)(AG::data::_shared_table_bytes + a2 + 24);
      unint64_t v25 = v21 >> 5;
      while (1)
      {
        uint64_t v26 = *(unsigned int *)(v24 + 4 * v23);
        if ((v26 & 3) != 0)
        {
          unsigned int v14 = (AG::LayoutDescriptor *)v46;
          AG::Graph::mark_changed((uint64_t)a1);
          uint64_t v22 = a4;
          a5 = v45;
          goto LABEL_31;
        }
        uint64_t v27 = AG::data::_shared_table_bytes + v26;
        unint64_t v28 = *(unsigned int *)(AG::data::_shared_table_bytes + v26 + 12);
        if (v28 < 0x20) {
          goto LABEL_29;
        }
        int v29 = (unsigned __int8 *)(AG::data::_shared_table_bytes + *(unsigned int *)(v27 + 16) + 4);
        uint64_t v30 = 5 * (v28 >> 5);
        while (1)
        {
          int v31 = *((_DWORD *)v29 - 1);
          int v48 = v31;
          if ((v31 & 3) != 0)
          {
            uint64_t v44 = v20;
            int v31 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v48, 0);
            uint64_t v20 = v44;
            uint64_t v22 = a4;
          }
          if (v31 != a2) {
            goto LABEL_25;
          }
          char v32 = *v29;
          if ((*v29 & 8) != 0) {
            goto LABEL_25;
          }
          if ((*(v29 - 4) & 3) == 0) {
            goto LABEL_28;
          }
          uint64_t v43 = v20;
          unint64_t v42 = v42 & 0xFFFFFF0000000000 | *((unsigned int *)v29 - 1) | ((unint64_t)*v29 << 32);
          if ((AG::Graph::compare_edge_values((uint64_t)a1, *((_DWORD *)v29 - 1), v12, v46, (uint64_t)v22) & 1) == 0) {
            break;
          }
          uint64_t v22 = a4;
          uint64_t v20 = v43;
LABEL_25:
          v29 += 5;
          v30 -= 5;
          if (!v30) {
            goto LABEL_29;
          }
        }
        char v32 = *v29;
        uint64_t v22 = a4;
        uint64_t v20 = v43;
LABEL_28:
        *int v29 = v32 | 8;
LABEL_29:
        if (++v23 == v25)
        {
LABEL_30:
          ++*((void *)a1 + 58);
          a5 = v45;
          unsigned int v14 = (AG::LayoutDescriptor *)v46;
          goto LABEL_31;
        }
      }
    }
    AG::Graph::mark_changed((uint64_t)a1);
    uint64_t v22 = a4;
LABEL_31:
    if (*v18) {
      uint64_t v33 = *v18;
    }
    else {
      uint64_t v33 = 0;
    }
    (*(void (**)(AG::LayoutDescriptor *, unsigned __int8 *, AG::LayoutDescriptor *))(v33 + 24))(v14, v22, a5);
  }
  else
  {
    AG::Node::allocate_value((unsigned int *)this, a1, *(AG::data::zone **)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00)));
    *(_DWORD *)this |= 0x10u;
    AG::Graph::mark_changed((uint64_t)a1, a2, 0, 0, 0);
    uint64_t v40 = (void *)(AG::data::_shared_table_bytes + *((unsigned int *)this + 2));
    if ((*((unsigned char *)this + 7) & 2) != 0) {
      uint64_t v40 = (void *)*v40;
    }
    if (*((void *)a5 - 1)) {
      uint64_t v41 = *((void *)a5 - 1);
    }
    else {
      uint64_t v41 = 0;
    }
    (*(void (**)(void *, unsigned __int8 *, AG::LayoutDescriptor *))(v41 + 16))(v40, a4, a5);
  }
  return 1;
}

uint64_t AG::LayoutDescriptor::compare_partial(AG::LayoutDescriptor *this, AG::LayoutDescriptor *a2, unsigned __int8 *a3, const unsigned __int8 *a4, char *a5, unsigned int a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (a2 == (AG::LayoutDescriptor *)a3) {
    return 1;
  }
  uint64_t v7 = a5;
  if (this)
  {
    partial = AG::LayoutDescriptor::find_partial((char *)this, a4, (unint64_t)a5);
    if (partial)
    {
      uint64_t v12 = (AG::LayoutDescriptor **)partial;
      uint64_t v13 = v11;
      if (!v11) {
        goto LABEL_9;
      }
      if (AG::LayoutDescriptor::compare_bytes_top_level(a2, a3, v11, a6, (unint64_t *)a5))
      {
        if (v7 >= v13) {
          v7 -= (uint64_t)v13;
        }
        else {
          uint64_t v7 = 0;
        }
LABEL_9:
        *(_OWORD *)unint64_t v21 = 0u;
        uint64_t v22 = 8;
        uint64_t v14 = AG::LayoutDescriptor::Compare::operator()(v20, v12, (uint64_t)a2, (uint64_t)a3, (unint64_t *)v13, (uint64_t)v7, a6);
        int v15 = v21[0];
        if (v21[0]) {
          unint64_t v16 = (void **)v21[0];
        }
        else {
          unint64_t v16 = v20;
        }
        if (v21[1])
        {
          uint64_t v17 = 0;
          do
          {
            AG::LayoutDescriptor::Compare::Enum::~Enum((AG::LayoutDescriptor::Compare::Enum *)v16);
            ++v17;
            unint64_t v16 = (void **)(v18 + 64);
          }
          while (v17 < v21[1]);
          int v15 = v21[0];
        }
        if (v15) {
          free(v15);
        }
        return v14;
      }
      return 0;
    }
  }
  return AG::LayoutDescriptor::compare_bytes_top_level(a2, a3, v7, a6, (unint64_t *)a5);
}

void sub_1AF91340C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

char *AG::LayoutDescriptor::find_partial(char *this, const unsigned __int8 *a2, unint64_t a3)
{
  if (a2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = this + 1;
      int v6 = *this;
      if ((v6 - 64) >= 0x40)
      {
        switch(*this)
        {
          case 0:
            return 0;
          case 1:
          case 2:
            uint64_t v8 = *(void *)(this + 1);
            this += 17;
            goto LABEL_36;
          case 3:
            uint64_t v8 = *(void *)(this + 1);
            this += 9;
LABEL_36:
            v3 += *(void *)(*(void *)(v8 - 8) + 64);
            continue;
          case 4:
          case 5:
            v3 += 8;
            goto LABEL_6;
          case 6:
            uint64_t v19 = 0;
            int v20 = 0;
            unint64_t v21 = this + 9;
            do
            {
              char v22 = *v21++;
              v19 |= (unint64_t)(v22 & 0x7F) << v20;
              v20 += 7;
            }
            while (v22 < 0);
            this = *(char **)(this + 1);
            goto LABEL_41;
          case 7:
            uint64_t v19 = *(unsigned __int16 *)(this + 5);
            unint64_t v21 = this + 7;
            this = &AG::LayoutDescriptor::base_address[*(int *)(this + 1)];
LABEL_41:
            if (v19 + v3 > (unint64_t)a2 && (uint64_t v23 = &a2[-v3], v19 - (uint64_t)&a2[-v3] >= a3))
            {
              unint64_t v3 = 0;
              a2 = v23;
            }
            else
            {
              this = v21;
              v3 += v19;
            }
            continue;
          case 8:
            do
              int v9 = *v5++;
            while (v9 < 0);
            goto LABEL_12;
          case 9:
          case 10:
          case 11:
LABEL_12:
            uint64_t v10 = *(void *)v5;
            v5 += 8;
            uint64_t v4 = v10;
            goto LABEL_13;
          case 12:
            do
              int v18 = *v5++;
            while (v18 < 0);
            goto LABEL_13;
          case 13:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
LABEL_13:
            int v11 = 0;
            while (1)
            {
              this = v5;
              int v12 = *v5++;
              int v13 = v11;
              uint64_t v14 = 1;
              switch(v12)
              {
                case 0:
                  goto LABEL_7;
                case 1:
                case 2:
                  uint64_t v14 = 9;
                  goto LABEL_20;
                case 3:
LABEL_20:
                  uint64_t v5 = &this[v14 + 8];
                  continue;
                case 6:
                  uint64_t v5 = this + 9;
                  do
                    int v16 = *v5++;
                  while (v16 < 0);
                  continue;
                case 7:
                  uint64_t v5 = this + 7;
                  continue;
                case 8:
                  do
                    int v15 = *++this;
                  while (v15 < 0);
                  goto LABEL_18;
                case 9:
                case 10:
                case 11:
LABEL_18:
                  uint64_t v5 = this + 9;
                  ++v11;
                  continue;
                case 12:
                  if (!v11) {
                    goto LABEL_7;
                  }
                  do
                    int v17 = *v5++;
                  while (v17 < 0);
                  break;
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                  if (v11) {
                    continue;
                  }
                  goto LABEL_7;
                case 22:
                  --v11;
                  if (v13) {
                    continue;
                  }
                  goto LABEL_7;
                default:
                  continue;
              }
            }
          case 22:
            v3 += *(void *)(*(void *)(v4 - 8) + 64);
            ++this;
            uint64_t v4 = 0;
            continue;
          default:
            if ((v6 & 0x80) == 0) {
              goto LABEL_6;
            }
            uint64_t v7 = v6 & 0x7F;
            break;
        }
      }
      else
      {
        uint64_t v7 = v6 & 0x3F;
      }
      v3 += v7 + 1;
LABEL_6:
      ++this;
LABEL_7:
      ;
    }
    while (v3 < (unint64_t)a2);
  }
  return this;
}

uint64_t AG::Subgraph::NodeCache::NodeCache(void)::$_0::__invoke(void *a1)
{
  return *a1 >> 8;
}

void *AG::Graph::Context::call_invalidation(void *result, uint64_t a2)
{
  *((_DWORD *)result + 16) = *(_DWORD *)(*result + 472);
  if (result[3])
  {
    unint64_t v3 = result;
    uint64_t v4 = AG::Graph::_current_update_key;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    uint64_t v6 = *(void *)(StatusReg + 8 * v4);
    uint64_t v7 = v6 | 1;
    if (!v6) {
      uint64_t v7 = 0;
    }
    *(void *)(StatusReg + 8 * v4) = v7;
    uint64_t v8 = *result;
    uint64_t v9 = *(unsigned int *)(*result + 232);
    if (v9)
    {
      for (uint64_t i = 8 * v9 - 8; i != -8; i -= 8)
      {
        uint64_t v12 = *(void *)(*(void *)(v8 + 224) + i);
        (*(void (**)(uint64_t, void *, void))(*(void *)v12 + 112))(v12, v3, a2);
      }
    }
    uint64_t result = (void *)((uint64_t (*)(uint64_t))v3[3])(a2);
    uint64_t v10 = *(unsigned int *)(v8 + 232);
    if (v10)
    {
      uint64_t v13 = a2;
      for (uint64_t j = 8 * v10 - 8; j != -8; j -= 8)
      {
        uint64_t v15 = *(void *)(*(void *)(v8 + 224) + j);
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v15 + 120))(v15, v3, v13);
      }
    }
    *(void *)(StatusReg + 8 * AG::Graph::_current_update_key) = v6;
  }
  return result;
}

void sub_1AF913788(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8 * *(void *)(v2 + 536)) = v3;
  _Unwind_Resume(a1);
}

double util::UntypedTable::create_buckets(util::UntypedTable *this)
{
  if (!*((void *)this + 6))
  {
    *((_DWORD *)this + 18) = 4;
    *((void *)this + 8) = 15;
    uint64_t v2 = (util::Heap *)*((void *)this + 4);
    if (!v2) {
      operator new();
    }
    uint64_t v3 = util::Heap::alloc_(v2, 0x80uLL);
    *((void *)this + 6) = v3;
    if (!v3) {
      util::UntypedTable::create_buckets();
    }
    double result = 0.0;
    *((_OWORD *)v3 + 6) = 0u;
    *((_OWORD *)v3 + 7) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    *((_OWORD *)v3 + 5) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *(_OWORD *)uint64_t v3 = 0u;
    *((_OWORD *)v3 + 1) = 0u;
  }
  return result;
}

void sub_1AF913838(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x1030C4075AECAACLL);
  _Unwind_Resume(a1);
}

BOOL util::pointer_compare(util *this, util *a2, const void *a3)
{
  return this == a2;
}

uint64_t AG::swift::anonymous namespace'::TypeCache::TypeCache(void)::$_0::__invoke(void *a1)
{
  return (33 * *a1) ^ a1[1];
}

void util::UntypedTable::grow_buckets(util::UntypedTable *this)
{
  unsigned int v1 = *((_DWORD *)this + 18);
  if (v1 <= 0x1E)
  {
    uint64_t v3 = (void *)*((void *)this + 6);
    char v4 = v1 + 1;
    *((_DWORD *)this + 18) = v1 + 1;
    if (v1 > 3)
    {
      size_t v6 = 8 << v4;
      uint64_t v7 = malloc_type_malloc(v6, 0x2004093837F09uLL);
    }
    else
    {
      uint64_t v5 = (util::Heap *)*((void *)this + 4);
      if (!v5) {
        operator new();
      }
      size_t v6 = 8 << v4;
      uint64_t v7 = util::Heap::alloc_(v5, v6);
    }
    uint64_t v8 = v7;
    bzero(v7, v6);
    int v9 = *((_DWORD *)this + 18);
    if (v8)
    {
      unint64_t v10 = 0;
      uint64_t v11 = ~(-1 << v9);
      *((void *)this + 8) = v11;
      do
      {
        uint64_t v12 = (void *)v3[v10];
        if (v12)
        {
          do
          {
            uint64_t v13 = (void *)*v12;
            uint64_t v14 = v12[3] & v11;
            *uint64_t v12 = v8[v14];
            v8[v14] = v12;
            uint64_t v12 = v13;
          }
          while (v13);
        }
        ++v10;
      }
      while (!(v10 >> v1));
      *((void *)this + 6) = v8;
      if (v1 > 4)
      {
        free(v3);
      }
    }
    else
    {
      *((_DWORD *)this + 18) = v9 - 1;
    }
  }
}

void sub_1AF9139D0(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x1030C4075AECAACLL);
  _Unwind_Resume(a1);
}

void AG::Graph::attribute_modify(uint64_t a1, const char *a2, uint64_t a3, void (*a4)(void *), uint64_t a5, int a6)
{
  size_t v6 = (unsigned int *)(AG::data::_shared_table_bytes + a2);
  unint64_t v7 = *v6;
  if ((v7 & 0x20) == 0) {
    AG::precondition_failure((AG *)"no self data: %u", a2, a2);
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 128) + ((v7 >> 5) & 0x7FFFFF8));
  if (*(void *)v9 != a3) {
    AG::precondition_failure((AG *)"self type mismatch: %u", a2, a2);
  }
  uint64_t v12 = a2;
  int v13 = *(_DWORD *)(a1 + 232);
  if (v13)
  {
    unsigned int v16 = v13 - 1;
    do
    {
      uint64_t v17 = v16;
      uint64_t v18 = *(void *)(*(void *)(a1 + 224) + 8 * v16);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 128))(v18, v12);
      --v16;
    }
    while (v17);
  }
  uint64_t v14 = (void *)((char *)v6 + *(unsigned int *)(v9 + 44));
  if (*((unsigned char *)v6 + 7)) {
    uint64_t v14 = (void *)*v14;
  }
  a4(v14);
  int v15 = *(_DWORD *)(a1 + 232);
  if (v15)
  {
    unsigned int v19 = v15 - 1;
    do
    {
      uint64_t v20 = v19;
      uint64_t v21 = *(void *)(*(void *)(a1 + 224) + 8 * v19);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 136))(v21, v12);
      --v19;
    }
    while (v20);
  }
  if (a6)
  {
    *((unsigned char *)v6 + 7) |= 0x40u;
    AG::Graph::mark_pending(a1, v12, (int *)v6);
  }
}

uint64_t AGGraphCurrentAttributeWasModified()
{
  uint64_t result = 0;
  uint64_t v1 = AG::Graph::_current_update_key;
  uint64_t v2 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v1);
  if ((v2 & 1) == 0)
  {
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
    if (v3)
    {
      unint64_t v4 = v3 + 32;
      unint64_t v6 = *(void *)(v3 + 96);
      uint64_t v5 = *(void *)(v3 + 104);
      if (v6) {
        unint64_t v4 = v6;
      }
      uint64_t v7 = *(unsigned int *)(v4 + 8 * v5 - 8);
      if (v7) {
        return (*(unsigned __int8 *)(AG::data::_shared_table_bytes + v7 + 7) >> 6) & 1;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t AGTypeGetKind(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((unint64_t)*a1 > 0x7FF) {
    uint64_t v1 = 0;
  }
  if (v1 > 513)
  {
    switch(v1)
    {
      case 769:
        uint64_t result = 5;
        break;
      case 770:
        uint64_t result = 6;
        break;
      case 771:
        uint64_t result = 7;
        break;
      case 772:
        uint64_t result = 8;
        break;
      default:
        if (v1 != 514) {
          return 0;
        }
        uint64_t result = 4;
        break;
    }
  }
  else if (v1)
  {
    if (v1 == 512)
    {
      return 2;
    }
    else if (v1 == 513)
    {
      return 3;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 1;
  }
  return result;
}

uint64_t AGSubgraphSetIndex(uint64_t result, const char *a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (!v2) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", a2);
  }
  *(_DWORD *)(v2 + 88) = a2;
  return result;
}

uint64_t AGGraphGetFlags(uint64_t a1, const char *a2)
{
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  return *(unsigned __int8 *)(AG::data::_shared_table_bytes + a1 + 6);
}

uint64_t *AGGraphGetAttributeGraph(uint64_t a1, char *a2)
{
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v3 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v3
    || (a2 = *(char **)(v3 + 48)) == 0
    || (unint64_t v4 = util::UntypedTable::lookup((util::UntypedTable *)(*(void *)(v3 + 40) + 144), (uint64_t *)a2, 0)) == 0)
  {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  return v4 - 2;
}

void AG::precondition_failure(AG *this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  va_copy((va_list)&v5[1], va);
  uint64_t v2 = (AG *)vasprintf(v5, (const char *)this, va);
  if (v5[0])
  {
    uint64_t v3 = AG::error_log(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(char **)&uint8_t buf[4] = v5[0];
      _os_log_error_impl(&dword_1AF901000, v3, OS_LOG_TYPE_ERROR, "precondition failure: %s", buf, 0xCu);
    }
    AG::Graph::trace_assertion_failure((AG::Graph *)1, (uint64_t)"precondition failure: %s", v4, v5[0]);
    if (!qword_1E9AF0748)
    {
      *(void *)buf = 0;
      asprintf((char **)buf, "AttributeGraph precondition failure: %s.\n", v5[0]);
      qword_1E9AF0748 = *(void *)buf;
    }
    free(v5[0]);
  }
  abort();
}

uint64_t type metadata accessor for OptionalAttribute()
{
  return __swift_instantiateGenericMetadata();
}

double AGSubgraphRemoveObserver(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(AG::Subgraph **)(a1 + 16);
  if (v2) {
    *(void *)&double result = AG::Subgraph::remove_observer(v2, a2).n128_u64[0];
  }
  return result;
}

uint64_t *AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::push_back(uint64_t *result, uint64_t a2)
{
  uint64_t v3 = *result;
  if (*result)
  {
    unint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFFELL);
    uint64_t v5 = *(void *)((v3 & 0xFFFFFFFFFFFFFFFELL) + 40);
    size_t v6 = v5 + 1;
    if (v4[6] < (unint64_t)(v5 + 1))
    {
      double result = (uint64_t *)AG::vector<AG::Subgraph *,4ul,unsigned long>::reserve_slow(v4, v6);
      uint64_t v5 = v4[5];
      size_t v6 = v5 + 1;
    }
    uint64_t v7 = (void *)v4[4];
    if (!v7) {
      uint64_t v7 = v4;
    }
    v7[v5] = a2;
    v4[5] = v6;
  }
  else
  {
    if (v3) {
      operator new();
    }
    *double result = a2;
  }
  return result;
}

uint64_t AGTupleElementOffset(void *a1, const char *a2)
{
  if (*a1 == 769)
  {
    if (a1[1] > (unint64_t)a2) {
      return a1[2 * (void)a2 + 4];
    }
LABEL_7:
    AG::precondition_failure((AG *)"index out of range: %d", a2, a2);
  }
  if (a2) {
    goto LABEL_7;
  }
  return 0;
}

uint64_t sub_1AF913FC8(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1AF914010@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  int v12 = (*(uint64_t (**)(void))(a2 + 40))();
  int v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 32))(a1, a2);
  unsigned __int8 v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a1, a2);
  uint64_t result = AGRetainClosure(a5);
  uint64_t v16 = result;
  uint64_t v18 = v17;
  if (qword_1EB3D3070 != -1) {
    uint64_t result = swift_once();
  }
  uint64_t v19 = qword_1EB3D30B0;
  int v20 = v12 | a4 | v13;
  *(void *)a6 = a1;
  *(void *)(a6 + 8) = a3;
  if ((v14 & ((v20 & 4) == 0)) != 0) {
    v20 |= 4u;
  }
  *(void *)(a6 + 16) = v16;
  *(void *)(a6 + 24) = v18;
  *(void *)(a6 + 32) = v19;
  *(_DWORD *)(a6 + 40) = v20;
  *(_DWORD *)(a6 + 44) = 0;
  *(void *)(a6 + 48) = 0;
  *(void *)(a6 + 56) = a1;
  *(void *)(a6 + 64) = a2;
  return result;
}

uint64_t AGRetainClosure(uint64_t a1)
{
  return a1;
}

uint64_t sub_1AF914170()
{
  return 0;
}

uint64_t sub_1AF91417C()
{
  return 3;
}

uint64_t _s14AttributeGraph3MapV5flagsSo20AGAttributeTypeFlagsVvgZ_0()
{
  type metadata accessor for Flags(0);
  sub_1AF9142E0();
  sub_1AF91428C();
  sub_1AF93CF68();
  return v1;
}

uint64_t static External.flags.getter()
{
  type metadata accessor for Flags(0);
  sub_1AF9142E0();
  sub_1AF91428C();
  sub_1AF93CF68();
  return v1;
}

void sub_1AF914230(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v4) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }
}

void type metadata accessor for Flags(uint64_t a1)
{
}

unint64_t sub_1AF91428C()
{
  unint64_t result = qword_1EB3D30A8;
  if (!qword_1EB3D30A8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB3D30A8);
  }
  return result;
}

unint64_t sub_1AF9142E0()
{
  unint64_t result = qword_1EB3D3098;
  if (!qword_1EB3D3098)
  {
    type metadata accessor for Flags(255);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB3D3098);
  }
  return result;
}

uint64_t sub_1AF91433C()
{
  return 2;
}

void type metadata accessor for AnyWeakAttribute(uint64_t a1)
{
}

uint64_t AGGraphGetAttributeInfo(uint64_t a1, const char *a2)
{
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v2 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v2) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  uint64_t v3 = *(void *)(v2 + 40);
  uint64_t v5 = 0;
  return AG::Graph::attribute_ref(v3, a1, &v5);
}

uint64_t AG::Graph::attribute_ref(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v3 = (unsigned int *)(AG::data::_shared_table_bytes + a2);
  uint64_t result = *(void *)(*(void *)(a1 + 128) + (((unint64_t)*v3 >> 5) & 0x7FFFFF8));
  if (a3)
  {
    uint64_t v5 = (void *)((char *)v3 + *(unsigned int *)(result + 44));
    if (*((unsigned char *)v3 + 7)) {
      uint64_t v5 = (void *)*v5;
    }
    *a3 = v5;
  }
  return result;
}

unint64_t AGSubgraphAddObserver(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(AG::data::zone **)(a1 + 16);
  if (!v3) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", a2);
  }
  return AG::Subgraph::add_observer(v3, (uint64_t)a2, a3);
}

void AGTupleWithBuffer(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, char *))
{
  v9[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(*(void *)(a1 - 8) + 72);
  size_t v6 = v5 * a2;
  if ((unint64_t)(v5 * a2) > 0x1000)
  {
    uint64_t v7 = (char *)malloc_type_malloc(v5 * a2, 0x100004077774924uLL);
    if (!v7) {
      AG::precondition_failure((AG *)"memory allocation failure", v8);
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1);
    uint64_t v7 = (char *)v9 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v7, v6);
  }
  a3(a1, v7);
  if (v6 > 0x1000) {
    free(v7);
  }
}

BOOL static WeakAttribute.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

void AGSubgraphApply(uint64_t a1, int a2, void (*a3)(void))
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    AG::Subgraph::apply(v3, a2, a3);
  }
}

void AGGraphSetIndirectDependency(uint64_t a1, const char *a2)
{
  if ((a1 & 3) != 1
    || (uint64_t v2 = (const char *)(a1 & 0xFFFFFFFC),
        (uint64_t v3 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00))) == 0))
  {
    AG::precondition_failure((AG *)"invalid indirect attribute: %u", a2, a1);
  }
  uint64_t v4 = *(void *)(v3 + 40);
  AG::Graph::indirect_attribute_set_dependency(v4, v2, a2);
}

uint64_t AGGraphAnyInputsChanged(__int32 *__s, const char *__n)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  uint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2);
  if ((v3 & 1) != 0 || (uint64_t v4 = (uint64_t *)(v3 & 0xFFFFFFFFFFFFFFFELL)) == 0) {
    AG::precondition_failure((AG *)"no attribute updating", __n);
  }
  uint64_t v7 = *v4;
  uint64_t v8 = v4 + 4;
  unint64_t v10 = (void *)v4[12];
  uint64_t v9 = v4[13];
  if (v10) {
    uint64_t v8 = v10;
  }
  unsigned int v11 = v8[v9 - 1];
  return AG::Graph::any_inputs_changed(v7, v11, __s, (size_t)__n);
}

unsigned char *AGGraphSetNeedsUpdate(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  uint64_t v2 = (unsigned char *)(a1 + 16);
  return AG::Graph::Context::set_needs_update(v2);
}

void *AGTupleElementType(void *result, const char *a2)
{
  if (*result == 769)
  {
    if (result[1] > (unint64_t)a2) {
      return (void *)result[2 * (void)a2 + 3];
    }
LABEL_5:
    AG::precondition_failure((AG *)"index out of range: %d", a2, a2);
  }
  if (a2) {
    goto LABEL_5;
  }
  return result;
}

uint64_t AGTupleCount(void *a1)
{
  if (*a1 == 769) {
    return a1[1];
  }
  else {
    return 1;
  }
}

void anonymous namespace'::subgraph_type_id(void)::$_0::__invoke<void const*>(uint64_t a1)
{
  unsigned int v1 = *(AG::Subgraph **)(a1 + 16);
  if (v1)
  {
    AG::Subgraph::clear_object(*(AG::Subgraph **)(a1 + 16));
    AG::Subgraph::invalidate_and_delete_(v1, 0);
  }
}

void AG::Graph::indirect_attribute_set(uint64_t a1, const char *a2, unsigned int a3)
{
  unsigned int v3 = a3;
  unsigned int v4 = a2;
  unsigned int v19 = a3;
  if ((*(unsigned char *)(AG::data::_shared_table_bytes + a2 + 8) & 1) == 0) {
    AG::precondition_failure((AG *)"not an indirect attribute: %u", a2, a2 | 1);
  }
  if (*(void *)(*(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00)) + 40) != *(void *)(*(void *)(AG::data::_shared_table_bytes + (a3 & 0xFFFFFE00)) + 40)) {
    AG::precondition_failure((AG *)"attribute references can't cross graph namespaces", a2);
  }
  int v6 = *(_DWORD *)(a1 + 232);
  if (v6)
  {
    unsigned int v14 = v6 - 1;
    do
    {
      uint64_t v15 = v14;
      uint64_t v16 = *(void *)(*(void *)(a1 + 224) + 8 * v14);
      (*(void (**)(uint64_t, void, void))(*(void *)v16 + 296))(v16, v4, v3);
      --v14;
    }
    while (v15);
  }
  if ((v3 & 3) != 0)
  {
    unsigned int v17 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v19, (const char *)4);
    int v7 = v18;
    unsigned int v3 = v17;
  }
  else
  {
    int v7 = 0;
  }
  unsigned int v19 = v3;
  uint64_t v8 = (unsigned int *)(AG::data::_shared_table_bytes + v4);
  unsigned int v9 = *v8;
  if (v3 == *v8)
  {
    if (v7 == v8[2] >> 2) {
      return;
    }
  }
  else
  {
    AG::Graph::remove_input_dependencies(a1, v4 & 0xFFFFFFFE | 1, *v8);
    unsigned int v3 = v19;
  }
  if (v3 < 4) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = (unint64_t)(*(_DWORD *)(*(void *)(AG::data::_shared_table_bytes + (v3 & 0xFFFFFE00)) + 24) & 0x7FFFFFFF) << 32;
  }
  AG::IndirectNode::modify((uint64_t)v8, v10 | v3, v7);
  unsigned int v11 = v19;
  uint64_t v12 = *(void *)(AG::data::_shared_table_bytes + (v19 & 0xFFFFFE00));
  if (v12) {
    uint64_t v12 = *(void *)(v12 + 48);
  }
  uint64_t v13 = *(void *)(AG::data::_shared_table_bytes + (v4 & 0xFFFFFE00));
  if (v13) {
    uint64_t v13 = *(void *)(v13 + 48);
  }
  void v8[2] = v8[2] & 0xFFFFFFFD | (2 * (v12 != v13));
  if (v11 != v9) {
    AG::Graph::add_input_dependencies(a1, v4 & 0xFFFFFFFE | 1, v19);
  }
  AG::Graph::mark_changed(a1);
  AG::Graph::propagate_dirty(a1);
}

uint64_t AG::IndirectNode::modify(uint64_t result, uint64_t a2, int a3)
{
  *(void *)uint64_t result = a2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(result + 8) & 3 | (4 * a3);
  return result;
}

void AG::Subgraph::invalidate_now(AG::Subgraph *this, AG::Graph *a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)a2 + 408) = 1;
  uint64_t v80 = 0;
  size_t v81 = 0;
  unint64_t v82 = 16;
  unsigned int v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 16;
  uint64_t v74 = this;
  int v3 = *((unsigned __int8 *)this + 104);
  if (v3 != 2)
  {
    *((unsigned char *)this + 104) = 2;
    if (!v3)
    {
      uint64_t v5 = *((unsigned int *)a2 + 58);
      if (v5)
      {
        uint64_t v71 = v5 - 1;
        do
        {
          uint64_t v72 = *(void *)(*((void *)a2 + 28) + 8 * v71);
          (*(void (**)(uint64_t, AG::Subgraph *))(*(void *)v72 + 192))(v72, this);
        }
        while ((unint64_t)v71--);
      }
    }
    AG::Subgraph::clear_object(this);
    std::stack<AG::Subgraph *,AG::vector<AG::Subgraph *,16ul,unsigned long>>::push[abi:ne180100](v75, &v74);
    uint64_t v6 = v77;
    if (v77)
    {
      while (1)
      {
        int v7 = v76;
        if (!v76) {
          int v7 = v75;
        }
        uint64_t v8 = v6 - 1;
        uint64_t v9 = v7[v8];
        uint64_t v77 = v8;
        uint64_t v10 = *((unsigned int *)a2 + 58);
        if (v10)
        {
          for (uint64_t i = 8 * v10 - 8; i != -8; i -= 8)
          {
            uint64_t v46 = *(void *)(*((void *)a2 + 28) + i);
            (*(void (**)(uint64_t, uint64_t))(*(void *)v46 + 200))(v46, v9);
          }
        }
        AG::Subgraph::notify_observers(v9);
        AG::Graph::remove_subgraph(a2, (AG::Subgraph *)v9);
        *(_DWORD *)(v9 + 24) |= 0x80000000;
        size_t v11 = v81;
        size_t v12 = v81 + 1;
        if (v82 < v81 + 1)
        {
          AG::vector<AG::Subgraph *,16ul,unsigned long>::reserve_slow(__dst, v12);
          size_t v11 = v81;
          size_t v12 = v81 + 1;
        }
        uint64_t v13 = v80;
        if (!v80) {
          uint64_t v13 = __dst;
        }
        *(void *)&v13[8 * v11] = v9;
        size_t v81 = v12;
        uint64_t v14 = *(unsigned int *)(v9 + 72);
        if (v14) {
          break;
        }
LABEL_54:
        *(_DWORD *)(v9 + 72) = 0;
        uint64_t v6 = v77;
        if (!v77) {
          goto LABEL_59;
        }
      }
      uint64_t v15 = *(void **)(v9 + 64);
      uint64_t v16 = &v15[v14];
      while (1)
      {
        unint64_t v17 = *v15 & 0xFFFFFFFFFFFFFFFCLL;
        int v18 = (uint64_t *)(v17 + 56);
        uint64_t v19 = *(void *)(v17 + 56);
        if (*(void *)(v17 + 48) == *((void *)this + 6))
        {
          if (v19)
          {
            unint64_t v27 = v19 & 0xFFFFFFFFFFFFFFFELL;
            uint64_t v21 = *(uint64_t **)(v27 + 32);
            if (!v21) {
              uint64_t v21 = (uint64_t *)v27;
            }
            int v20 = &v21[*(void *)(v27 + 40)];
          }
          else
          {
            int v20 = &v18[v19 != 0];
            uint64_t v21 = (uint64_t *)(v17 + 56);
          }
          while (v21 != v20)
          {
            uint64_t v28 = *v21;
            if (*v21 != v9)
            {
              uint64_t v29 = *(unsigned int *)(v28 + 72);
              if (v29)
              {
                uint64_t v30 = 8 * v29;
                int v31 = *(void **)(v28 + 64);
                while ((*v31 & 0xFFFFFFFFFFFFFFFCLL) != v17)
                {
                  ++v31;
                  v30 -= 8;
                  if (!v30) {
                    goto LABEL_38;
                  }
                }
                unsigned int v32 = v29 - 1;
                *int v31 = *(void *)(*(void *)(v28 + 64) + 8 * v32);
                *(_DWORD *)(v28 + 72) = v32;
              }
            }
LABEL_38:
            ++v21;
          }
          AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::clear(v18);
          uint64_t v74 = (AG::Subgraph *)v17;
          int v33 = *(unsigned __int8 *)(v17 + 104);
          if (v33 != 2)
          {
            *(unsigned char *)(v17 + 104) = 2;
            if (!v33)
            {
              uint64_t v34 = *((unsigned int *)a2 + 58);
              if (v34)
              {
                uint64_t v42 = v34 - 1;
                do
                {
                  uint64_t v43 = *(void *)(*((void *)a2 + 28) + 8 * v42);
                  (*(void (**)(uint64_t, unint64_t))(*(void *)v43 + 192))(v43, v17);
                }
                while ((unint64_t)v42--);
              }
            }
            AG::Subgraph::clear_object((AG::Subgraph *)v17);
            std::stack<AG::Subgraph *,AG::vector<AG::Subgraph *,16ul,unsigned long>>::push[abi:ne180100](v75, &v74);
          }
          goto LABEL_49;
        }
        uint64_t v22 = 0;
        unint64_t v23 = 0;
        unint64_t v24 = v19 & 0xFFFFFFFFFFFFFFFELL;
        if (v19) {
          break;
        }
LABEL_18:
        if (!v23 && v19)
        {
          if (v9 != v19) {
            goto LABEL_26;
          }
          uint64_t v35 = v9;
          uint64_t v36 = (uint64_t *)(v17 + 56);
          uint64_t v37 = (uint64_t *)(v17 + 56);
          goto LABEL_45;
        }
LABEL_49:
        if (++v15 == v16) {
          goto LABEL_54;
        }
      }
      while (1)
      {
        unint64_t v25 = *(void *)(v24 + 40);
        if (v23 >= v25) {
          goto LABEL_49;
        }
        unint64_t v26 = *(void *)(v24 + 32);
        if (!v26) {
          unint64_t v26 = v19 & 0xFFFFFFFFFFFFFFFELL;
        }
        if (*(void *)(v26 + 8 * v23) == v9) {
          break;
        }
LABEL_26:
        ++v23;
        v22 -= 8;
        if ((v19 & 1) == 0) {
          goto LABEL_18;
        }
      }
      uint64_t v36 = (uint64_t *)(v26 - v22);
      unint64_t v38 = v26 + 8 * v25;
      uint64_t v39 = *(void *)(v38 - 8);
      uint64_t v37 = (uint64_t *)(v38 - 8);
      uint64_t v35 = v39;
LABEL_45:
      *uint64_t v36 = v35;
      *uint64_t v37 = v9;
      uint64_t v40 = *v18;
      if (*v18) {
        uint64_t v41 = *(void *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 40);
      }
      else {
        uint64_t v41 = v40 != 0;
      }
      AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::resize(v18, v41 - 1);
      goto LABEL_49;
    }
  }
LABEL_59:
  if (v80) {
    uint64_t v47 = v80;
  }
  else {
    uint64_t v47 = __dst;
  }
  if (!v81) {
    goto LABEL_110;
  }
  int v48 = &v47[8 * v81];
  do
  {
    unsigned int v49 = *(_DWORD *)(*(void *)v47 + 16);
    if (v49)
    {
      uint64_t v50 = AG::data::_shared_table_bytes;
      do
      {
        uint64_t v51 = v49;
        uint64_t v52 = v50 + v49;
        int v53 = *(unsigned __int16 *)(v52 + 20);
        if (*(_WORD *)(v52 + 20))
        {
          do
          {
            uint64_t v54 = (const char *)(v53 + v51);
            int v55 = ((_BYTE)v53 + (_BYTE)v51) & 3;
            if ((((_BYTE)v53 + (_BYTE)v51) & 3) != 0)
            {
              if (v55 == 1)
              {
                uint64_t v56 = v54 & 0xFFFFFFFC;
                int v53 = *(unsigned __int16 *)(AG::data::_shared_table_bytes + v56 + 14);
                AG::Graph::remove_indirect_node((uint64_t)a2, v56);
              }
              else if (v55 == 2)
              {
                int v57 = 1;
                goto LABEL_76;
              }
            }
            else
            {
              int v53 = *(unsigned __int16 *)(AG::data::_shared_table_bytes + v54 + 4);
              AG::Graph::remove_node((uint64_t)a2, v54);
            }
          }
          while (v53);
          int v57 = 0;
LABEL_76:
          uint64_t v50 = AG::data::_shared_table_bytes;
          if (v57) {
            break;
          }
        }
        unsigned int v49 = *(_DWORD *)(v50 + v51 + 8);
      }
      while (v49);
    }
    v47 += 8;
  }
  while (v47 != v48);
  if (v80) {
    v58 = v80;
  }
  else {
    v58 = __dst;
  }
  if (!v81) {
    goto LABEL_110;
  }
  char v59 = &v58[8 * v81];
  do
  {
    unsigned int v60 = *(_DWORD *)(*(void *)v58 + 16);
    if (!v60) {
      goto LABEL_101;
    }
    uint64_t v61 = AG::data::_shared_table_bytes;
    while (2)
    {
      uint64_t v62 = v60;
      uint64_t v63 = v61 + v60;
      int v64 = *(unsigned __int16 *)(v63 + 20);
      if (!*(_WORD *)(v63 + 20)) {
        goto LABEL_100;
      }
      do
      {
        while (1)
        {
          uint64_t v65 = (v64 + v62);
          int v66 = ((_BYTE)v64 + (_BYTE)v62) & 3;
          if ((((_BYTE)v64 + (_BYTE)v62) & 3) == 0) {
            break;
          }
          if (v66 != 1)
          {
            if (v66 == 2)
            {
              int v68 = 1;
              goto LABEL_99;
            }
            goto LABEL_94;
          }
          int v64 = *(unsigned __int16 *)(AG::data::_shared_table_bytes + (v65 & 0xFFFFFFFC) + 14);
          if ((v65 & 3) == 0)
          {
            AG::Node::destroy((unsigned int *)(AG::data::_shared_table_bytes + v65), a2);
            goto LABEL_96;
          }
LABEL_94:
          if (!v64) {
            goto LABEL_97;
          }
        }
        uint64_t v67 = AG::data::_shared_table_bytes + v65;
        int v64 = *(unsigned __int16 *)(v67 + 4);
        AG::Node::destroy((unsigned int *)v67, a2);
LABEL_96:
        --*((void *)a2 + 32);
      }
      while (v64);
LABEL_97:
      int v68 = 0;
LABEL_99:
      uint64_t v61 = AG::data::_shared_table_bytes;
      if (!v68)
      {
LABEL_100:
        unsigned int v60 = *(_DWORD *)(v61 + v62 + 8);
        if (!v60) {
          break;
        }
        continue;
      }
      break;
    }
LABEL_101:
    v58 += 8;
  }
  while (v58 != v59);
  if (v80) {
    uint64_t v69 = (AG::Subgraph **)v80;
  }
  else {
    uint64_t v69 = (AG::Subgraph **)__dst;
  }
  if (v81)
  {
    uint64_t v70 = 8 * v81;
    do
    {
      if (*v69)
      {
        AG::Subgraph::~Subgraph(*v69);
        MEMORY[0x1B3E84B80]();
      }
      ++v69;
      v70 -= 8;
    }
    while (v70);
  }
LABEL_110:
  *((unsigned char *)a2 + 408) = 0;
  if (v76) {
    free(v76);
  }
  if (v80) {
    free(v80);
  }
}

void sub_1AF914FF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46)
{
  if (a27) {
    free(a27);
  }
  if (a46) {
    free(a46);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AG::Graph::remove_node(uint64_t a1, const char *a2)
{
  uint64_t v2 = AG::data::_shared_table_bytes;
  uint64_t v3 = AG::data::_shared_table_bytes + a2;
  if ((*(unsigned char *)v3 & 0xC0) != 0) {
    AG::precondition_failure((AG *)"deleting updating attribute: %u\n", a2, a2);
  }
  unsigned int v5 = a2;
  unint64_t v6 = *(unsigned int *)(v3 + 12);
  if (v6 >= 0x20)
  {
    int v7 = (unsigned int *)(AG::data::_shared_table_bytes + *(unsigned int *)(v3 + 16));
    uint64_t v8 = 5 * (v6 >> 5);
    do
    {
      unsigned int v9 = *v7;
      int v7 = (unsigned int *)((char *)v7 + 5);
      AG::Graph::remove_removed_input(a1, v5, v9);
      v8 -= 5;
    }
    while (v8);
    uint64_t v2 = AG::data::_shared_table_bytes;
  }
  unint64_t v10 = *(unsigned int *)(v3 + 20);
  if (v10 >= 0x20)
  {
    size_t v11 = (unsigned int *)(v2 + *(unsigned int *)(v3 + 24));
    uint64_t v12 = 4 * (v10 >> 5);
    do
    {
      unsigned int v13 = *v11++;
      AG::Graph::remove_removed_output(a1, v5, v13);
      v12 -= 4;
    }
    while (v12);
  }
  uint64_t result = *(void *)(a1 + 304);
  if (result)
  {
    unsigned int v15 = *(_DWORD *)v3 >> 8;
    return AG::Graph::ProfileData::remove_node(result, v5, v15);
  }
  return result;
}

uint64_t AG::Graph::remove_removed_output(uint64_t a1, int a2, unsigned int a3)
{
  if (*(unsigned char *)(*(void *)(AG::data::_shared_table_bytes + (a3 & 0xFFFFFE00)) + 104) == 2) {
    return 0;
  }
  if ((a3 & 3) != 1)
  {
    if ((a3 & 3) == 0)
    {
      uint64_t v5 = AG::data::_shared_table_bytes + a3;
      unint64_t v6 = *(unsigned int *)(v5 + 12);
      if (v6 >= 0x20)
      {
        uint64_t v7 = 0;
        unsigned int v9 = (int *)(AG::data::_shared_table_bytes + *(unsigned int *)(v5 + 16));
        unint64_t v10 = v6 >> 5;
        while (1)
        {
          int v12 = *v9;
          unsigned int v9 = (int *)((char *)v9 + 5);
          int v36 = v12;
          if (AG::AttributeID::traverses(&v36, a2, 4)) {
            break;
          }
          if (v10 == ++v7) {
            return 0;
          }
        }
        AG::Graph::remove_input_edge(a1, a3, v5, v7);
        return 1;
      }
    }
    return 0;
  }
  uint64_t v13 = a3 & 0xFFFFFFFC;
  uint64_t v14 = AG::data::_shared_table_bytes + v13;
  if (*(_DWORD *)(AG::data::_shared_table_bytes + v13) == a2)
  {
    if ((*(unsigned char *)(v14 + 8) & 1) != 0
      && (unint64_t v15 = *(void *)(v14 + 28), (v15 & 0xFFFFFFFC) != 0)
      && ((unint64_t v16 = HIDWORD(v15),
           uint64_t v17 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(*(void *)(v14 + 28) & 0xFFFFFE00)), (v17 & 0xFF00000000) != 0)? (v18 = v16 == v17): (v18 = 0), v18))
    {
      unsigned int v21 = *(_DWORD *)(v14 + 28);
      uint64_t v19 = *(unsigned int *)(v14 + 32);
      int v20 = *(_DWORD *)(v14 + 36);
    }
    else
    {
      uint64_t v19 = 0;
      int v20 = 0;
      unsigned int v21 = 2;
    }
    int v22 = *(_DWORD *)(a1 + 232);
    uint64_t v23 = v21;
    if (v22)
    {
      unsigned int v30 = v22 - 1;
      do
      {
        uint64_t v31 = v30;
        uint64_t v32 = *(void *)(*(void *)(a1 + 224) + 8 * v30);
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)v32 + 296))(v32, a3 & 0xFFFFFFFC, v23);
        --v30;
      }
      while (v31);
    }
    AG::IndirectNode::modify(v14, v23 | (v19 << 32), v20);
    if (v23 >= 4)
    {
      uint64_t v24 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(v23 & 0xFFFFFE00));
      if ((v24 & 0xFF00000000) != 0 && v19 == v24) {
        AG::Graph::add_input_dependencies(a1, a3, v23);
      }
    }
  }
  else
  {
    int v26 = *(_DWORD *)(v14 + 16);
    if (v26) {
      BOOL v27 = v26 == a2;
    }
    else {
      BOOL v27 = 0;
    }
    if (!v27) {
      return 0;
    }
    int v29 = *(_DWORD *)(a1 + 232);
    if (v29)
    {
      unsigned int v33 = v29 - 1;
      do
      {
        uint64_t v34 = v33;
        uint64_t v35 = *(void *)(*(void *)(a1 + 224) + 8 * v33);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 304))(v35, v13, 2);
        --v33;
      }
      while (v34);
    }
    *(_DWORD *)(v14 + 16) = 0;
  }
  return 1;
}

void AG::Graph::remove_removed_input(uint64_t a1, int a2, unsigned int a3)
{
  while ((a3 & 3) == 1)
  {
    uint64_t v5 = a3 & 0xFFFFFFFC;
    unint64_t v6 = (unsigned int *)(AG::data::_shared_table_bytes + v5);
    if (*(unsigned char *)(AG::data::_shared_table_bytes + v5 + 8))
    {
      if (*(unsigned char *)(*(void *)(AG::data::_shared_table_bytes + (a3 & 0xFFFFFE00)) + 104) != 2)
      {
        AG::Graph::remove_output_edge<AG::MutableIndirectNode>(a1, v5, a2);
      }
      return;
    }
    uint64_t v7 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(*v6 & 0xFFFFFE00));
    if ((v7 & 0xFF00000000) == 0 || v6[1] != (v7 & 0x7FFFFFFF)) {
      return;
    }
    a3 = *v6;
  }
  if ((a3 & 3) == 0 && *(unsigned char *)(*(void *)(AG::data::_shared_table_bytes + (a3 & 0xFFFFFE00)) + 104) != 2)
  {
    AG::Graph::remove_output_edge<AG::Node>(a1, a3, a2);
  }
}

unsigned int *AG::Node::destroy(unsigned int *this, AG::Graph *a2)
{
  uint64_t v3 = (uint64_t)this;
  unint64_t v4 = *this;
  uint64_t v5 = *(void *)(*((void *)a2 + 16) + ((v4 >> 5) & 0x7FFFFF8));
  if ((v4 & 0x10) != 0)
  {
    if (*(void *)(*(void *)(v5 + 8) - 8)) {
      uint64_t v6 = *(void *)(*(void *)(v5 + 8) - 8);
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = (void *)(AG::data::_shared_table_bytes + this[2]);
    if ((*(unsigned char *)(v3 + 7) & 2) != 0) {
      uint64_t v7 = (void *)*v7;
    }
    this = (unsigned int *)(*(uint64_t (**)(void *))(v6 + 8))(v7);
  }
  if (*(_DWORD *)(v3 + 8)) {
    *((void *)a2 + 36) -= *(void *)(*(void *)(*(void *)(v5 + 8) - 8) + 64);
  }
  if ((*(unsigned char *)v3 & 0x20) != 0)
  {
    if ((*(unsigned char *)(v5 + 40) & 4) != 0)
    {
      uint64_t v8 = (void *)(v3 + *(unsigned int *)(v5 + 44));
      if (*(unsigned char *)(v3 + 7)) {
        uint64_t v8 = (void *)*v8;
      }
      (*(void (**)(uint64_t, void *))(*(void *)(v5 + 32) + 16))(v5, v8);
    }
    if (*(void *)(*(void *)v5 - 8)) {
      uint64_t v9 = *(void *)(*(void *)v5 - 8);
    }
    else {
      uint64_t v9 = 0;
    }
    unint64_t v10 = *(uint64_t (**)(void *))(v9 + 8);
    size_t v11 = (void *)(v3 + *(unsigned int *)(v5 + 44));
    if (*(unsigned char *)(v3 + 7)) {
      size_t v11 = (void *)*v11;
    }
    return (unsigned int *)v10(v11);
  }
  return this;
}

uint64_t AG::AttributeID::traverses(int *a1, int a2, char a3)
{
  while (1)
  {
    int v3 = *a1;
    if ((*a1 & 3) != 1) {
      return v3 == a2;
    }
    if ((v3 & 0xFFFFFFFC | 1) == a2) {
      break;
    }
    a1 = (int *)(AG::data::_shared_table_bytes + (v3 & 0xFFFFFFFC));
    if (a3 & 4) != 0 && (a1[2]) {
      return v3 == a2;
    }
  }
  return 1;
}

uint64_t AG::Graph::remove_input_dependencies(uint64_t a1, int a2, unsigned int a3)
{
  LODWORD(v3) = a2;
  unsigned int v6 = a3;
  if ((a3 & 3) != 0) {
    a3 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v6, 4u);
  }
  if ((a3 & 3) != 0)
  {
    uint64_t v3 = v3;
    if ((a3 & 3) == 1) {
      AG::Graph::remove_output_edge<AG::MutableIndirectNode>(a1, a3 & 0xFFFFFFFC, v3);
    }
  }
  else
  {
    uint64_t v3 = v3;
    AG::Graph::remove_output_edge<AG::Node>(a1, a3, v3);
  }
  return AG::Graph::update_main_refs(a1, v3);
}

void *AG::Graph::remove_output_edge<AG::Node>(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = AG::data::_shared_table_bytes;
  uint64_t v4 = AG::data::_shared_table_bytes + a2;
  unint64_t v5 = *(unsigned int *)(v4 + 20);
  if (v5 < 0x20) {
    goto LABEL_8;
  }
  unint64_t v6 = v5 >> 5;
  uint64_t v7 = (_DWORD *)(AG::data::_shared_table_bytes + *(unsigned int *)(v4 + 24));
  while (*v7 != a3)
  {
    ++v7;
    if (!--v6) {
      goto LABEL_7;
    }
  }
  *uint64_t v7 = *(_DWORD *)(AG::data::_shared_table_bytes + *(unsigned int *)(v4 + 24) + 4 * (v5 >> 5) - 4);
  LODWORD(v5) = *(_DWORD *)(v4 + 20) - 32;
  *(_DWORD *)(v4 + 20) = v5;
LABEL_7:
  if (v5 <= 0x1F)
  {
LABEL_8:
    if ((*(unsigned char *)(v4 + 7) & 0x10) != 0) {
      return AG::Subgraph::cache_insert(*(void **)(v3 + (a2 & 0xFFFFFE00)), a2);
    }
  }
  return result;
}

void AG::Graph::remove_input_edge(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a1 + 232);
  if (v8)
  {
    unsigned int v15 = v8 - 1;
    do
    {
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)(*(void *)(a1 + 224) + 8 * v15);
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v17 + 240))(v17, a2, a4);
      --v15;
    }
    while (v16);
  }
  unint64_t v9 = *(unsigned int *)(a3 + 12);
  if (a4 + 1 < v9 >> 5)
  {
    uint64_t v10 = AG::data::_shared_table_bytes + 5 * a4 + *(unsigned int *)(a3 + 16);
    unint64_t v11 = ~a4 + (v9 >> 5);
    uint64_t v12 = v10;
    do
    {
      int v13 = *(_DWORD *)(v12 + 5);
      v12 += 5;
      *(_DWORD *)uint64_t v10 = v13;
      *(unsigned char *)(v10 + 4) = *(unsigned char *)(v10 + 9);
      uint64_t v10 = v12;
      --v11;
    }
    while (v11);
    LODWORD(v9) = *(_DWORD *)(a3 + 12);
  }
  unsigned int v14 = v9 - 32;
  *(_DWORD *)(a3 + 12) = v14;
  if (v14 < 0x20) {
    AG::Graph::all_inputs_removed(a1, a2);
  }
  if ((*(unsigned char *)a3 & 0xC0) != 0)
  {
    AG::Graph::reset_update(a1, a2);
  }
}

void AG::Graph::remove_indirect_node(uint64_t a1, unsigned int a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = AG::data::_shared_table_bytes + a2;
  unsigned int v5 = *(_DWORD *)v4;
  if (*(unsigned char *)(v4 + 8))
  {
    unsigned int v12 = a2 & 0xFFFFFFFE | 1;
    AG::Graph::remove_removed_input(a1, v12, v5);
    unsigned int v13 = *(_DWORD *)(v4 + 16);
    if (v13) {
      AG::Graph::remove_removed_input(a1, v12, v13);
    }
    unint64_t v14 = *(unsigned int *)(v4 + 20);
    if (v14 >= 0x20)
    {
      unsigned int v15 = (unsigned int *)(AG::data::_shared_table_bytes + *(unsigned int *)(v4 + 24));
      uint64_t v16 = 4 * (v14 >> 5);
      do
      {
        unsigned int v17 = *v15++;
        AG::Graph::remove_removed_output(a1, v12, v17);
        v16 -= 4;
      }
      while (v16);
    }
  }
  else
  {
    uint64_t v6 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(v5 & 0xFFFFFE00));
    if ((v6 & 0xFF00000000) != 0 && *(_DWORD *)(v4 + 4) == (v6 & 0x7FFFFFFF))
    {
      int v8 = (unsigned int *)v4;
      while (1)
      {
        uint64_t v9 = *v8;
        if (*(unsigned char *)(*(void *)(AG::data::_shared_table_bytes + (v9 & 0xFFFFFE00)) + 104) == 2) {
          return;
        }
        if ((*v8 & 3) != 1) {
          break;
        }
        int v8 = (unsigned int *)(AG::data::_shared_table_bytes + (v9 & 0xFFFFFFFC));
        if (v8[2])
        {
          uint64_t v19 = v8 + 5;
          int v20 = v8 + 6;
LABEL_25:
          uint64_t v21 = *v20;
          unint64_t v22 = *v19;
          uint64_t v34 = 0;
          size_t v35 = 0;
          unint64_t v36 = 8;
          if (v22 >= 0x20)
          {
            uint64_t v23 = (unsigned int *)(AG::data::_shared_table_bytes + v21);
            unsigned int v24 = a2 & 0xFFFFFFFE | 1;
            uint64_t v25 = 4 * (v22 >> 5);
            do
            {
              unsigned int v26 = *v23;
              if (AG::Graph::remove_removed_output(a1, v24, *v23))
              {
                size_t v27 = v35;
                size_t v28 = v35 + 1;
                if (v36 < v35 + 1)
                {
                  AG::vector<AG::AttributeID,8ul,unsigned long>::reserve_slow(v33, v28);
                  size_t v27 = v35;
                  size_t v28 = v35 + 1;
                }
                int v29 = v34;
                if (!v34) {
                  int v29 = v33;
                }
                *(_DWORD *)&v29[4 * v27] = v26;
                size_t v35 = v28;
              }
              ++v23;
              v25 -= 4;
            }
            while (v25);
            unsigned int v30 = v34;
            if (v34) {
              uint64_t v31 = (int *)v34;
            }
            else {
              uint64_t v31 = (int *)v33;
            }
            if (v35)
            {
              uint64_t v32 = 4 * v35;
              do
              {
                AG::Graph::remove_removed_input(a1, *v31++, v24);
                v32 -= 4;
              }
              while (v32);
              unsigned int v30 = v34;
            }
            if (v30) {
              free(v30);
            }
          }
          return;
        }
        uint64_t v10 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(*(_DWORD *)v4 & 0xFFFFFE00));
        if ((v10 & 0xFF00000000) == 0 || *(_DWORD *)(v4 + 4) != (v10 & 0x7FFFFFFF)) {
          return;
        }
      }
      if ((v9 & 3) != 0) {
        return;
      }
      uint64_t v18 = AG::data::_shared_table_bytes + v9;
      uint64_t v19 = (unsigned int *)(AG::data::_shared_table_bytes + v9 + 20);
      int v20 = (unsigned int *)(v18 + 24);
      goto LABEL_25;
    }
  }
}

void sub_1AF915B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (a13) {
    free(a13);
  }
  _Unwind_Resume(exception_object);
}

void AG::Subgraph::clear_object(AG::Subgraph *this)
{
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    void v2[2] = 0;
    *((void *)this + 4) = 0;
    uint64_t v3 = AG::Subgraph::_current_subgraph_key;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    if (*(AG::Subgraph **)(StatusReg + 8 * v3) == this)
    {
      *(void *)(StatusReg + 8 * v3) = 0;
      CFRelease(v2);
    }
  }
}

uint64_t AG::Subgraph::notify_observers(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 80);
  if (v1)
  {
    uint64_t v2 = AG::data::_shared_table_bytes + v1;
    uint64_t v3 = *(void *)(AG::data::_shared_table_bytes + v1 + 8);
    if (v3)
    {
      uint64_t v4 = *(void (***)(void))v2;
      uint64_t v5 = *(void *)v2 + 24 * v3;
      do
      {
        (*v4)();
        this = swift_release();
        v4 += 3;
      }
      while (v4 != (void (**)(void))v5);
      *(void *)(v2 + 8) = 0;
    }
  }
  return this;
}

void *std::stack<AG::Subgraph *,AG::vector<AG::Subgraph *,16ul,unsigned long>>::push[abi:ne180100](void *__dst, void *a2)
{
  uint64_t v3 = __dst;
  uint64_t v4 = __dst[17];
  size_t v5 = v4 + 1;
  if (__dst[18] < (unint64_t)(v4 + 1))
  {
    __dst = AG::vector<AG::Subgraph *,16ul,unsigned long>::reserve_slow(__dst, v5);
    uint64_t v4 = v3[17];
    size_t v5 = v4 + 1;
  }
  uint64_t v6 = (void *)v3[16];
  if (!v6) {
    uint64_t v6 = v3;
  }
  v6[v4] = *a2;
  v3[17] = v5;
  return __dst;
}

void AG::Subgraph::~Subgraph(AG::Subgraph *this)
{
  if (*((_DWORD *)this + 20))
  {
    AG::Subgraph::notify_observers((uint64_t)this);
    uint64_t v2 = *(void **)(AG::data::_shared_table_bytes + *((unsigned int *)this + 20));
    if (v2) {
      free(v2);
    }
  }
  uint64_t v3 = *((unsigned int *)this + 23);
  if (v3) {
    AG::Subgraph::NodeCache::~NodeCache((AG::Subgraph::NodeCache *)(AG::data::_shared_table_bytes + v3));
  }
  uint64_t v4 = (void *)*((void *)this + 8);
  if (v4) {
    free(v4);
  }
  uint64_t v5 = *((void *)this + 7);
  if (v5)
  {
    unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFFELL;
    if ((v5 & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      uint64_t v7 = *(void **)(v6 + 32);
      if (v7) {
        free(v7);
      }
      MEMORY[0x1B3E84B80](v6, 0x1080C4034992649);
    }
  }
  AG::data::zone::clear(this);
  int v8 = *(void ***)this;
  if (*((_DWORD *)this + 2))
  {
    unint64_t v9 = 0;
    do
    {
      std::unique_ptr<void,AG::data::table::malloc_zone_deleter>::reset[abi:ne180100](v8, 0);
      ++v9;
      ++v8;
    }
    while (v9 < *((unsigned int *)this + 2));
    int v8 = *(void ***)this;
  }
  if (v8) {
    free(v8);
  }
}

void std::unique_ptr<void,AG::data::table::malloc_zone_deleter>::reset[abi:ne180100](void **a1, void *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3) {
    malloc_zone_free((malloc_zone_t *)AG::data::table::_malloc_zone, v3);
  }
}

uint64_t *AG::Graph::remove_subgraph(AG::Graph *this, AG::Subgraph *a2)
{
  uint64_t v4 = *((unsigned int *)this + 88);
  if (v4)
  {
    uint64_t v5 = (AG::Subgraph **)*((void *)this + 43);
    unint64_t v6 = v5;
    unint64_t v7 = *((unsigned int *)this + 88);
    do
    {
      unint64_t v8 = v7 >> 1;
      unint64_t v9 = (unint64_t *)&v6[v7 >> 1];
      unint64_t v11 = *v9;
      uint64_t v10 = (AG::Subgraph **)(v9 + 1);
      v7 += ~(v7 >> 1);
      if (v11 < (unint64_t)a2) {
        unint64_t v6 = v10;
      }
      else {
        unint64_t v7 = v8;
      }
    }
    while (v7);
    if (v6 != &v5[v4] && *v6 == a2)
    {
      uint64_t v12 = (char *)v6 - (char *)v5;
    }
    else
    {
      uint64_t v12 = 0;
      while (*(AG::Subgraph **)((char *)v5 + v12) != a2)
      {
        v12 += 8;
        if (8 * v4 == v12) {
          goto LABEL_16;
        }
      }
    }
    uint64_t v13 = (v4 - 1);
    *((_DWORD *)this + 88) = v13;
    if (v13 != v12 >> 3) {
      memmove(&v5[v12 >> 3], &v5[(v12 >> 3) + 1], 8 * (v13 - (v12 >> 3)));
    }
  }
LABEL_16:
  uint64_t result = (uint64_t *)*((void *)this + 41);
  if (result)
  {
    int v20 = a2;
    uint64_t result = std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::find<AG::Subgraph *>(result, &v20);
    if (result) {
      uint64_t result = (uint64_t *)std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::erase(*((void **)this + 41), result);
    }
  }
  if (*((unsigned char *)a2 + 105))
  {
    *((unsigned char *)a2 + 105) &= ~1u;
    unsigned int v15 = (AG::Subgraph **)*((void *)this + 45);
    uint64_t v16 = *((unsigned int *)this + 92);
    unsigned int v17 = v15;
    if (v16)
    {
      uint64_t v18 = 8 * v16;
      unsigned int v17 = (AG::Subgraph **)*((void *)this + 45);
      while (*v17 != a2)
      {
        ++v17;
        v18 -= 8;
        if (!v18)
        {
          unsigned int v17 = &v15[v16];
          break;
        }
      }
    }
    int v19 = v16 - 1;
    *unsigned int v17 = v15[v19];
    *((_DWORD *)this + 92) = v19;
  }
  --*((void *)this + 34);
  return result;
}

void AG::data::zone::clear(AG::data::zone *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB3D3238);
  while (1)
  {
    uint64_t v2 = *((unsigned int *)this + 4);
    if (!v2) {
      break;
    }
    *((_DWORD *)this + 4) = *(_DWORD *)(AG::data::_shared_table_bytes + v2 + 8);
    AG::data::table::dealloc_page_locked((AG::data::table *)&AG::data::_shared_table_bytes, v2);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB3D3238);
}

void sub_1AF915FCC(_Unwind_Exception *a1)
{
}

void AG::data::table::dealloc_page_locked(AG::data::table *this, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(*(void *)this + a2 + 12);
  *((_DWORD *)this + 7) -= v2 >> 9;
  if (v2 >= 0x200)
  {
    int v4 = 0;
    unsigned int v5 = v2 >> 9;
    int v6 = (a2 >> 9) - 1;
    if (v5 <= 1) {
      int v7 = 1;
    }
    else {
      int v7 = v5;
    }
    do
    {
      uint64_t v8 = (v6 + v4) >> 6;
      uint64_t v9 = 1 << (v6 + v4);
      uint64_t v10 = *((void *)this + 8);
      BOOL v11 = (*(void *)(v10 + 8 * v8) & ~v9) == 0;
      *(void *)(v10 + 8 * v8) &= ~v9;
      if (v11)
      {
        AG::data::table::make_pages_reusable(this, v6 + v4, 1);
        if (!v4) {
LABEL_10:
        }
          *(void *)(*((void *)this + 10) + 8 * v8) &= ~v9;
      }
      else if (!v4)
      {
        goto LABEL_10;
      }
      ++v4;
    }
    while (v7 != v4);
  }
}

void *AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::clear(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *result;
  if (*result)
  {
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
    if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      int v4 = *(void **)(v3 + 32);
      if (v4) {
        free(v4);
      }
      uint64_t result = (void *)MEMORY[0x1B3E84B80](v3, 0x1080C4034992649);
    }
  }
  *uint64_t v1 = 0;
  return result;
}

uint64_t sub_1AF91610C()
{
  return swift_release();
}

void AG::Subgraph::NodeCache::~NodeCache(AG::Subgraph::NodeCache *this)
{
  uint64_t v2 = (AG::Subgraph::NodeCache *)((char *)this + 200);
  util::UntypedTable::for_each((uint64_t)this + 200, (void (*)(const void *, const void *, const void *))util::Table<AG::data::ptr<AG::Node>,AG::Subgraph::NodeCache::Item *>::for_each<AG::Subgraph::NodeCache::~()::$_0>(AG::Subgraph::NodeCache::~()::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke, &v3);
  util::UntypedTable::~UntypedTable(v2);
  util::UntypedTable::~UntypedTable((AG::Subgraph::NodeCache *)((char *)this + 120));
  util::UntypedTable::~UntypedTable((AG::Subgraph::NodeCache *)((char *)this + 40));
  util::Heap::reset((AG::Subgraph::NodeCache *)((char *)this + 8), 0, 0);
}

void util::UntypedTable::~UntypedTable(util::UntypedTable *this)
{
  if ((*((void *)this + 2) || *((void *)this + 3)) && *((void *)this + 7))
  {
    unint64_t v2 = 0;
    int v3 = *((_DWORD *)this + 18);
    do
    {
      for (uint64_t i = *(void **)(*((void *)this + 6) + 8 * v2); i; uint64_t i = (void *)*i)
      {
        unsigned int v5 = (void (*)(void))*((void *)this + 2);
        if (v5) {
          v5(i[1]);
        }
        int v6 = (void (*)(void))*((void *)this + 3);
        if (v6) {
          v6(i[2]);
        }
      }
      ++v2;
    }
    while (!(v2 >> v3));
  }
  if (*((_DWORD *)this + 18) >= 5u) {
    free(*((void **)this + 6));
  }
  if (*((unsigned char *)this + 76))
  {
    uint64_t v7 = *((void *)this + 4);
    if (v7)
    {
      util::Heap::reset(*((util::Heap **)this + 4), 0, 0);
      MEMORY[0x1B3E84B80](v7, 0x1030C4075AECAACLL);
    }
  }
}

uint64_t AG::Graph::all_inputs_removed(uint64_t result, unsigned int a2)
{
  unint64_t v2 = (unsigned int *)(AG::data::_shared_table_bytes + a2);
  *((unsigned char *)v2 + 7) &= 0xF3u;
  unint64_t v3 = *v2;
  if ((v3 & 8) != 0 && (*(unsigned char *)(*(void *)(*(void *)(result + 128) + ((v3 >> 5) & 0x7FFFFF8)) + 40) & 8) == 0) {
    *unint64_t v2 = v3 & 0xFFFFFFF7;
  }
  return result;
}

uint64_t sub_1AF9162B8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 64) + 8))(a2, *(void *)(a1 + 56));
}

void AG::data::table::make_pages_reusable(AG::data::table *this, int a2, int a3)
{
  unsigned int v5 = (void *)(*((void *)this + 1) + ((a2 << 9) & 0xFFFF8000));
  if (a3) {
    int v6 = 7;
  }
  else {
    int v6 = 8;
  }
  madvise((void *)(*((void *)this + 1) + ((a2 << 9) & 0xFFFF8000)), 0x8000uLL, v6);
  uint64_t v7 = &unk_1EB3D3000;
  {
    uint64_t v7 = (unsigned char *)&unk_1EB3D3000;
    if (v10)
    {
      AG::data::table::make_pages_reusable(unsigned int,BOOL)::unmap_reusable = AG::data::table::make_pages_reusable(unsigned int,BOOL)::$_0::operator()();
      uint64_t v7 = (unsigned char *)&unk_1EB3D3000;
    }
  }
  if (v7[952])
  {
    if (a3) {
      int v8 = 0;
    }
    else {
      int v8 = 3;
    }
    mprotect(v5, 0x8000uLL, v8);
  }
  if (a3) {
    int v9 = 0x8000;
  }
  else {
    int v9 = -32768;
  }
  *((_DWORD *)this + 8) += v9;
}

void *AG::vector<AG::Subgraph *,16ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 18) + (*((void *)__dst + 18) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 18) + (*((void *)__dst + 18) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 16), __dst, 0x10uLL, (size_t *)__dst + 18, v3);
  *((void *)__dst + 16) = result;
  return result;
}

char *AG::data::table::make_pages_reusable(unsigned int,BOOL)::$_0::operator()()
{
  uint64_t result = getenv("AG_UNMAP_REUSABLE");
  if (result) {
    return (char *)(atoi(result) != 0);
  }
  return result;
}

void AG::Graph::remove_output_edge<AG::MutableIndirectNode>(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = AG::data::_shared_table_bytes + a2;
  unint64_t v4 = *(unsigned int *)(v3 + 20);
  if (v4 >= 0x20)
  {
    unint64_t v5 = v4 >> 5;
    unint64_t v6 = v5;
    for (uint64_t i = (_DWORD *)(AG::data::_shared_table_bytes + *(unsigned int *)(v3 + 24)); *i != a3; ++i)
    {
      if (!--v6) {
        return;
      }
    }
    *uint64_t i = *(_DWORD *)(AG::data::_shared_table_bytes + *(unsigned int *)(v3 + 24) + 4 * v5 - 4);
    *(_DWORD *)(v3 + 20) -= 32;
  }
}

uint64_t AG::Graph::any_inputs_changed(int a1, unsigned int a2, __int32 *__s, size_t __n)
{
  uint64_t v4 = AG::data::_shared_table_bytes + a2;
  unint64_t v5 = *(unsigned int *)(v4 + 12);
  if (v5 < 0x20) {
    return 0;
  }
  int v8 = &__s[__n];
  uint64_t v9 = 5 * (v5 >> 5);
  for (uint64_t i = (unsigned char *)(*(unsigned int *)(v4 + 16) + AG::data::_shared_table_bytes + 4); ; i += 5)
  {
    char v11 = *i;
    *i |= 0x10u;
    if ((v11 & 8) != 0)
    {
      uint64_t v12 = wmemchr(__s, *((_DWORD *)i - 1), __n);
      uint64_t v13 = v12 ? v12 : v8;
      if (__n == v13 - __s) {
        break;
      }
    }
    v9 -= 5;
    if (!v9) {
      return 0;
    }
  }
  return 1;
}

void AGGraphSetIndirectAttribute(uint64_t a1, const char *a2)
{
  if ((a1 & 3) != 1
    || (unint64_t v2 = (const char *)(a1 & 0xFFFFFFFC),
        (uint64_t v3 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00))) == 0))
  {
    AG::precondition_failure((AG *)"invalid indirect attribute: %u", a2, a1);
  }
  uint64_t v4 = *(void *)(v3 + 40);
  if (a2 == 2)
  {
    AG::Graph::indirect_attribute_reset(v4, v2, 0);
  }
  else
  {
    AG::Graph::indirect_attribute_set(v4, v2, a2);
  }
}

uint64_t AGGraphAddInput(char *a1, const char *a2, uint64_t a3)
{
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v3 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v3) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  if (dword_1EB3D3240 <= (a2 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a2 & 0xFFFFFFFC);
  }
  uint64_t v4 = *(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00));
  if (!v4 || (uint64_t v5 = *(void *)(v3 + 40), *(void *)(v4 + 40) != v5)) {
    AG::precondition_failure((AG *)"accessing attribute in a different namespace: %u", a2, a2);
  }
  return AG::Graph::add_input(v5, (const char *)a1, a2, 0, a3);
}

void type metadata accessor for AnyAttribute(uint64_t a1)
{
}

void AGGraphInvalidateValue(char *a1, const char *a2)
{
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v2 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v2) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  uint64_t v3 = (const char *)a1;
  uint64_t v4 = *(void *)(v2 + 40);
  AG::Graph::value_mark(v4, v3);
}

void AGSubgraphInvalidate(uint64_t a1)
{
  uint64_t v1 = *(AG::Subgraph **)(a1 + 16);
  if (v1) {
    AG::Subgraph::invalidate_and_delete_(v1, 0);
  }
}

unsigned char *AG::Graph::Context::set_needs_update(unsigned char *this)
{
  if (!this[68])
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)this;
    int v3 = *(_DWORD *)(*(void *)this + 232);
    if (v3)
    {
      unsigned int v4 = v3 - 1;
      do
      {
        uint64_t v5 = v4;
        uint64_t v6 = *(void *)(*(void *)(v2 + 224) + 8 * v4);
        this = (unsigned char *)(*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v6 + 176))(v6, v1);
        --v4;
      }
      while (v5);
      uint64_t v2 = *(void *)v1;
    }
    v1[68] = 1;
    *(unsigned char *)(v2 + 409) = 1;
  }
  return this;
}

AG::swift::metadata *AGTypeApplyMutableEnumData(AG::swift::metadata *this, void **a2, void (*a3)(void, AG::swift::metadata *, unint64_t))
{
  uint64_t v7 = (uint64_t *)((char *)this - 8);
  uint64_t v6 = *((void *)this - 1);
  if (v6)
  {
    uint64_t v8 = *((void *)this - 1);
    if ((*(unsigned char *)(v6 + 82) & 0x20) == 0)
    {
LABEL_25:
      uint64_t v23 = AG::swift::metadata::name(this, 0);
      AG::precondition_failure((AG *)"not an enum type: %s", v24, v23);
    }
  }
  else
  {
    if ((MEMORY[0x52] & 0x20) == 0) {
      goto LABEL_25;
    }
    uint64_t v8 = 0;
  }
  uint64_t v9 = (*(uint64_t (**)(void **, AG::swift::metadata *))(v8 + 88))(a2, this);
  uint64_t result = (AG::swift::metadata *)AG::swift::metadata::nominal_descriptor(this);
  if (result)
  {
    char v11 = (int *)((char *)result + 16);
    uint64_t v12 = *((int *)result + 4);
    if (v12
      && ((v12 & 3) != 1 ? (uint64_t v13 = (uint64_t)v11 + v12) : (uint64_t v13 = *(void *)((char *)v11 + (v12 & 0xFFFFFFFFFFFFFFFCLL))),
          v9 < (*((_DWORD *)result + 5) & 0xFFFFFFu)
       && (uint64_t v14 = v13 + 12 * v9, v17 = *(int *)(v14 + 20), v16 = v14 + 20, v15 = v17, v17)))
    {
      uint64_t result = (AG::swift::metadata *)AG::swift::metadata::mangled_type_name_ref_cached(this, (unsigned char *)(v15 + v16), 0);
      if (result)
      {
        uint64_t v18 = result;
        int v19 = (unsigned char *)(v16 - 4);
        if (*v7) {
          uint64_t v20 = *v7;
        }
        else {
          uint64_t v20 = 0;
        }
        (*(void (**)(void **, AG::swift::metadata *))(v20 + 96))(a2, this);
        unint64_t v21 = (unint64_t)a2;
        if (*v19)
        {
          AG::swift::metadata::copy_on_write_heap_object(v18, a2);
          unint64_t v21 = (unint64_t)*a2
              + ((*(unsigned __int8 *)(*((void *)v18 - 1) + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(*((void *)v18 - 1) + 80));
        }
        a3(v9, v18, v21);
        if (*v7) {
          uint64_t v22 = *v7;
        }
        else {
          uint64_t v22 = 0;
        }
        (*(void (**)(void **, uint64_t, AG::swift::metadata *))(v22 + 104))(a2, v9, this);
        return (AG::swift::metadata *)1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_DWORD *AG::swift::metadata::nominal_descriptor(AG::swift::metadata *this)
{
  uint64_t result = (_DWORD *)AG::swift::metadata::descriptor(this);
  if (result)
  {
    if ((*result & 0x1Fu) - 17 >= 2) {
      return 0;
    }
  }
  return result;
}

unsigned char *AG::swift::metadata::mangled_type_name_ref_cached(AG::swift::metadata *a1, unsigned char *a2, _DWORD *a3)
{
  int v3 = a2;
  if (a2)
  {
    {
      operator new();
    }
    *(void *)&long long v13 = a1;
    *((void *)&v13 + 1) = v3;
    uint64_t v6 = (os_unfair_lock_s *)AG::swift::metadata::mangled_type_name_ref_cached(char const*,AG::swift::metadata::ref_kind *)const::cache;
    os_unfair_lock_lock((os_unfair_lock_t)AG::swift::metadata::mangled_type_name_ref_cached(char const*,AG::swift::metadata::ref_kind *)const::cache);
    uint64_t v7 = util::UntypedTable::lookup((util::UntypedTable *)(AG::swift::metadata::mangled_type_name_ref_cached(char const*,AG::swift::metadata::ref_kind *)const::cache+ 4136), (uint64_t *)&v13, 0);
    if (v7)
    {
      if (a3) {
        *a3 = *((_DWORD *)v7 + 2);
      }
      int v3 = (unsigned char *)*v7;
      os_unfair_lock_unlock(v6);
    }
    else
    {
      os_unfair_lock_unlock(v6);
      int v12 = 0;
      int v3 = (unsigned char *)AG::swift::metadata::mangled_type_name_ref(a1, v3, 1, &v12);
      uint64_t v8 = (os_unfair_lock_s *)AG::swift::metadata::mangled_type_name_ref_cached(char const*,AG::swift::metadata::ref_kind *)const::cache;
      os_unfair_lock_lock((os_unfair_lock_t)AG::swift::metadata::mangled_type_name_ref_cached(char const*,AG::swift::metadata::ref_kind *)const::cache);
      uint64_t v9 = util::Heap::alloc_((util::Heap *)(AG::swift::metadata::mangled_type_name_ref_cached(char const*,AG::swift::metadata::ref_kind *)const::cache+ 8), 0x10uLL);
      *(_OWORD *)uint64_t v9 = v13;
      int v10 = util::Heap::alloc_((util::Heap *)(AG::swift::metadata::mangled_type_name_ref_cached(char const*,AG::swift::metadata::ref_kind *)const::cache+ 8), 0x10uLL);
      *(void *)int v10 = v3;
      *((_DWORD *)v10 + 2) = v12;
      util::UntypedTable::insert((util::UntypedTable *)(AG::swift::metadata::mangled_type_name_ref_cached(char const*,AG::swift::metadata::ref_kind *)const::cache+ 4136), v9, v10);
      os_unfair_lock_unlock(v8);
      if (a3) {
        *a3 = v12;
      }
    }
  }
  return v3;
}

void sub_1AF916C30(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10B0C40925F0199);
  _Unwind_Resume(a1);
}

AG::swift::_anonymous_namespace_::TypeCache *AG::swift::anonymous namespace'::TypeCache::TypeCache(AG::swift::_anonymous_namespace_::TypeCache *this)
{
  *(_DWORD *)this = 0;
  uint64_t v2 = (char *)this + 8;
  util::Heap::Heap((AG::swift::_anonymous_namespace_::TypeCache *)((char *)this + 8), (char *)this + 40, 4096, 0);
  return this;
}

void sub_1AF916D00(_Unwind_Exception *a1)
{
  util::Heap::reset(v1, 0, 0);
  _Unwind_Resume(a1);
}

uint64_t AGGraphSetContext(uint64_t result, const char *a2)
{
  if (*(unsigned char *)(result + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  *(void *)(result + 24) = a2;
  return result;
}

void AG::Graph::indirect_attribute_set_dependency(uint64_t a1, const char *a2, unsigned int a3)
{
  int v3 = (int)a2;
  if (a3 < 4)
  {
    uint64_t v5 = AG::data::_shared_table_bytes;
    if (*(unsigned char *)(AG::data::_shared_table_bytes + a2 + 8))
    {
      unsigned int v6 = 0;
      uint64_t v7 = a2;
      goto LABEL_8;
    }
LABEL_18:
    AG::precondition_failure((AG *)"not an indirect attribute: %u", a2, a2 | 1);
  }
  if ((a3 & 3) != 0) {
    AG::precondition_failure((AG *)"indirect dependencies must be attributes", a2);
  }
  uint64_t v5 = AG::data::_shared_table_bytes;
  if (*(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00)) != *(void *)(AG::data::_shared_table_bytes
                                                                                                 + (a3 & 0xFFFFFE00)))
    AG::precondition_failure((AG *)"indirect dependencies must share a subgraph with their attribute", a2);
  if ((*(unsigned char *)(AG::data::_shared_table_bytes + a2 + 8) & 1) == 0) {
    goto LABEL_18;
  }
  uint64_t v7 = a2;
  unsigned int v6 = a3;
LABEL_8:
  int v8 = *(_DWORD *)(a1 + 232);
  if (v8)
  {
    uint64_t v11 = a3;
    unsigned int v12 = v8 - 1;
    do
    {
      uint64_t v13 = v12;
      uint64_t v14 = *(void *)(*(void *)(a1 + 224) + 8 * v12);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14 + 304))(v14, v7, v11);
      --v12;
    }
    while (v13);
    uint64_t v5 = AG::data::_shared_table_bytes;
  }
  uint64_t v9 = v5 + v7;
  unsigned int v10 = *(_DWORD *)(v9 + 16);
  if (v6 != v10)
  {
    if (v10) {
      AG::Graph::remove_output_edge<AG::Node>(a1, v10, v3 & 0xFFFFFFFE | 1);
    }
    *(_DWORD *)(v9 + 16) = v6;
    if (v6)
    {
      AG::Graph::add_output_edge<AG::Node>(a1, v6, v3 & 0xFFFFFFFE | 1);
      if (*(unsigned char *)(AG::data::_shared_table_bytes + v6))
      {
        AG::Graph::propagate_dirty(a1);
      }
    }
  }
}

__n128 AG::Subgraph::remove_observer(AG::Subgraph *this, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)this + 20);
  if (v2)
  {
    int v3 = (void *)(AG::data::_shared_table_bytes + v2);
    uint64_t v4 = *(void *)(AG::data::_shared_table_bytes + v2 + 8);
    if (v4)
    {
      for (uint64_t i = 0; *(void *)(*v3 + i + 16) != a2; i += 24)
      {
        if (!--v4) {
          return result;
        }
      }
      swift_release();
      unsigned int v6 = (__n128 *)(*v3 + i);
      uint64_t v7 = *v3 + 24 * v3[1];
      __n128 result = *v6;
      *unsigned int v6 = *(__n128 *)(v7 - 24);
      *(__n128 *)(v7 - 24) = result;
      unint64_t v9 = v6[1].n128_u64[0];
      v6[1].n128_u64[0] = *(void *)(v7 - 8);
      *(void *)(v7 - 8) = v9;
      --v3[1];
    }
  }
  return result;
}

uint64_t AGGraphGetValueState(char *a1, const char *a2)
{
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v2 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v2) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  unsigned int v3 = a1;
  uint64_t v4 = *(void *)(v2 + 40);
  return AG::Graph::value_state(v4, v3);
}

uint64_t AG::Graph::value_state(uint64_t a1, unsigned int a2)
{
  unsigned int v5 = a2;
  if ((a2 & 3) != 0) {
    a2 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v5, (const char *)2);
  }
  if ((a2 & 3) != 0) {
    return 0;
  }
  uint64_t v3 = AG::data::_shared_table_bytes + a2;
  int v4 = *(_DWORD *)v3 & 3;
  if ((*(_DWORD *)v3 & 0xC0) != 0) {
    int v4 = *(_DWORD *)v3 & 3 | 4;
  }
  return (*(_DWORD *)v3 >> 1) & 8 | (16 * ((*(_DWORD *)v3 >> 2) & 1)) & 0xFFFFFF3F | (((*(_DWORD *)v3 >> 3) & 1) << 6) & 0xFFFFFF7F | v4 & 0xFFFFFF7F | *(unsigned char *)(v3 + 7) & 0x20 | (((*(unsigned __int8 *)(v3 + 7) >> 6) & 1) << 7);
}

uint64_t AGGraphSetUpdateCallback(uint64_t a1, const char *a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  swift_release();
  uint64_t result = swift_retain();
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 64) = a3;
  return result;
}

uint64_t AGGraphSetInvalidationCallback(uint64_t a1, const char *a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  swift_release();
  uint64_t result = swift_retain();
  *(void *)(a1 + 40) = a2;
  *(void *)(a1 + 48) = a3;
  return result;
}

void AG::Graph::value_mark(uint64_t a1, const char *a2)
{
  unsigned int v2 = a2;
  int v4 = (int *)(AG::data::_shared_table_bytes + a2);
  unint64_t v5 = *v4;
  uint64_t v6 = *(void *)(*(void *)(a1 + 128) + ((v5 >> 5) & 0x7FFFFF8));
  uint64_t v7 = AG::Graph::_current_update_key;
  uint64_t v8 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  if ((v8 & 1) == 0)
  {
    unint64_t v9 = (void *)(v8 & 0xFFFFFFFFFFFFFFFELL);
    if (v9)
    {
      if (*v9 == a1 && ((v5 & 0xC0) != 0 || v4[5] >= 0x20)) {
        AG::precondition_failure((AG *)"setting value during update: %u", a2, a2);
      }
    }
  }
  int v10 = *(_DWORD *)(a1 + 232);
  if (v10)
  {
    unsigned int v17 = v10 - 1;
    do
    {
      uint64_t v18 = v17;
      uint64_t v19 = *(void *)(*(void *)(a1 + 224) + 8 * v17);
      (*(void (**)(uint64_t, void))(*(void *)v19 + 280))(v19, v2);
      --v17;
    }
    while (v18);
  }
  if ((*(unsigned char *)(v6 + 40) & 0x10) != 0)
  {
    AG::Graph::mark_changed(a1, v2, 0, 0, 0);
  }
  else
  {
    *((unsigned char *)v4 + 7) |= 0x40u;
    int v11 = *v4;
    if ((*v4 & 1) == 0)
    {
      int v12 = *(_DWORD *)(a1 + 232);
      if (v12)
      {
        unsigned int v20 = v12 - 1;
        do
        {
          uint64_t v21 = v20;
          uint64_t v22 = *(void *)(*(void *)(a1 + 224) + 8 * v20);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v22 + 256))(v22, v2, 1);
          --v20;
        }
        while (v21);
        int v11 = *v4;
      }
      v11 |= 1u;
      *int v4 = v11;
    }
    if ((v11 & 2) == 0)
    {
      int v13 = *(_DWORD *)(a1 + 232);
      if (v13)
      {
        unsigned int v23 = v13 - 1;
        do
        {
          uint64_t v24 = v23;
          uint64_t v25 = *(void *)(*(void *)(a1 + 224) + 8 * v23);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v25 + 264))(v25, v2, 1);
          --v23;
        }
        while (v24);
        int v11 = *v4;
      }
      *int v4 = v11 | 2;
    }
    int v14 = *((unsigned __int8 *)v4 + 6);
    if (*((unsigned char *)v4 + 6))
    {
      uint64_t v15 = *(AG::Subgraph **)(AG::data::_shared_table_bytes + (v2 & 0xFFFFFE00));
      if (v15)
      {
        unsigned int v16 = *((_DWORD *)v15 + 25);
        if ((v14 & ~HIWORD(v16)) != 0)
        {
          *((_DWORD *)v15 + 25) = v16 & 0xFF00FFFF | ((BYTE2(v16) | v14) << 16);
          AG::Subgraph::propagate_dirty_flags(v15);
        }
      }
    }
  }
  AG::Graph::propagate_dirty(a1);
}

unsigned int *AG::Graph::with_update(uint64_t a1, unsigned int a2, void (*a3)(void))
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v8 = a1;
  unint64_t v9 = StatusReg - 224;
  uint64_t v10 = *(void *)(StatusReg + 8 * AG::Graph::_current_update_key);
  unint64_t v4 = atomic_load((unint64_t *)(a1 + 416));
  unint64_t v11 = v4;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 8;
  int v17 = 0;
  if (v10)
  {
    int v17 = *(_DWORD *)((v10 & 0xFFFFFFFFFFFFFFFELL) + 120) & 4;
    int v5 = v17 | 0x10;
  }
  else
  {
    int v5 = 16;
  }
  *(void *)(a1 + 416) = v9;
  if (!*(unsigned char *)(a1 + 408))
  {
    *(unsigned char *)(a1 + 408) = 1;
    int v17 = v5;
  }
  *(void *)(StatusReg + 8 * AG::Graph::_current_update_key) = &v8;
  unsigned int v12 = a2;
  int v13 = (*(_DWORD *)(AG::data::_shared_table_bytes + a2) >> 1) & 1;
  uint64_t v15 = 1;
  a3();
  return _ZZN2AG5Graph11with_updateENS_4data3ptrINS_4NodeEEENS_17ClosureFunctionVVIvJEEEEN13scoped_updateD1Ev((unsigned int *)&v8, v6);
}

void sub_1AF917514(_Unwind_Exception *a1, const char *a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _ZZN2AG5Graph11with_updateENS_4data3ptrINS_4NodeEEENS_17ClosureFunctionVVIvJEEEEN13scoped_updateD1Ev((unsigned int *)va, a2);
  _Unwind_Resume(a1);
}

unsigned int *_ZZN2AG5Graph11with_updateENS_4data3ptrINS_4NodeEEENS_17ClosureFunctionVVIvJEEEEN13scoped_updateD1Ev(unsigned int *a1, const char *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v4 = *((void *)a1 + 13);
  if (*((void *)a1 + 12)) {
    uint64_t v3 = (unsigned int *)*((void *)a1 + 12);
  }
  *((void *)a1 + 13) = v4 - 1;
  if (v4 != 1)
  {
    uint64_t v5 = AG::data::_shared_table_bytes;
    uint64_t v6 = 8 * v4 - 8;
    do
    {
      unsigned int v7 = *v3;
      v3 += 2;
      *(_DWORD *)(v5 + v7) -= 64;
      v6 -= 8;
    }
    while (v6);
  }
  uint64_t v8 = *(void *)a1;
  if (*((void *)a1 + 1) != *(void *)(*(void *)a1 + 416))
  {
    AG::non_fatal_precondition_failure((AG *)"invalid graph update (access from multiple threads?)", a2);
    uint64_t v8 = *(void *)a1;
  }
  *(void *)(v8 + 416) = *((void *)a1 + 3);
  uint64_t v9 = *((void *)a1 + 2);
  uint64_t v10 = AG::Graph::_current_update_key;
  *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10) = v9;
  if ((a1[30] & 0x10) != 0) {
    *(unsigned char *)(*(void *)a1 + 408) = 0;
  }
  unint64_t v11 = (void *)*((void *)a1 + 12);
  if (v11) {
    free(v11);
  }
  return a1;
}

unsigned int *AGGraphWithUpdate(char *a1, uint64_t (*a2)(void))
{
  if (a1 == 2)
  {
    uint64_t v3 = AG::Graph::_current_update_key;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    uint64_t v5 = *(void *)(StatusReg + 8 * v3);
    uint64_t v6 = v5 | 1;
    if (!v5) {
      uint64_t v6 = 0;
    }
    *(void *)(StatusReg + 8 * v3) = v6;
    uint64_t result = (unsigned int *)a2();
    *(void *)(StatusReg + 8 * AG::Graph::_current_update_key) = v5;
  }
  else
  {
    if ((a1 & 3) != 0) {
      AG::precondition_failure((AG *)"non-direct attribute id: %u", (const char *)a2, a2, a1);
    }
    if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
      AG::precondition_failure((AG *)"invalid data offset: %u", (const char *)a2, a2, a1 & 0xFFFFFFFC);
    }
    uint64_t v8 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
    if (!v8) {
      AG::precondition_failure((AG *)"no graph: %u", (const char *)a2, a2, a1);
    }
    unsigned int v9 = a1;
    uint64_t v10 = *(void *)(v8 + 40);
    return AG::Graph::with_update(v10, v9, (void (*)(void))a2);
  }
  return result;
}

void sub_1AF9176FC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8 * *v2) = v3;
  _Unwind_Resume(a1);
}

void anonymous namespace'::graph_type_id(void)::$_0::__invoke<void const*>(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 88)) {
    AG::Graph::Context::~Context((AG::Graph::Context *)(a1 + 16));
  }
}

uint64_t AGGraphCreate()
{
  return AGGraphCreateShared(0);
}

uint64_t AGSubgraphRemoveChild(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 16);
  if (!result) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", (const char *)a2);
  }
  uint64_t v3 = *(AG::Subgraph **)(a2 + 16);
  if (v3)
  {
    return AG::Subgraph::remove_child(result, v3, 0);
  }
  return result;
}

AG::data::table *AG::data::table::ensure_shared(void)::$_0::__invoke()
{
  return AG::data::table::table((AG::data::table *)&AG::data::_shared_table_bytes);
}

uint64_t AG::Subgraph::make_current_subgraph_key(AG::Subgraph *this)
{
  return pthread_key_create((pthread_key_t *)&AG::Subgraph::_current_subgraph_key, 0);
}

__n128 AGGraphWithMainThreadHandler(uint64_t a1, const char *a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  uint64_t v5 = *(__n128 **)(a1 + 16);
  uint64_t v6 = v5 + 15;
  __n128 v8 = v5[15];
  v5[15].n128_u64[0] = a4;
  v5[15].n128_u64[1] = a5;
  ((void (*)(void))a2)();
  __n128 result = v8;
  *uint64_t v6 = v8;
  return result;
}

void sub_1AF9177EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9)
{
  _OWORD *v9 = a9;
  _Unwind_Resume(a1);
}

uint64_t AG::Graph::Graph(void)::$_0::__invoke()
{
  unint64_t v0 = (AG::Subgraph *)pthread_key_create((pthread_key_t *)&AG::Graph::_current_update_key, 0);
  return AG::Subgraph::make_current_subgraph_key(v0);
}

const char *init_should_record_tree(void *a1)
{
  __n128 result = getenv("AG_TREE");
  if (result)
  {
    __n128 result = (const char *)atoi(result);
    BOOL v2 = result != 0;
  }
  else
  {
    BOOL v2 = 0;
  }
  should_record_tree = v2;
  return result;
}

void AG::anonymous namespace'::TypeDescriptorCache::init_shared_cache(AG::_anonymous_namespace_::TypeDescriptorCache *this, void *a2)
{
}

void sub_1AF9178FC(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10A0C406AC5BF46);
  _Unwind_Resume(a1);
}

AG::data::table *AG::data::table::table(AG::data::table *this)
{
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(void *)((char *)this + 36) = 0;
  *(void *)((char *)this + 28) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 2) = 0x10000000000000;
  BOOL v2 = (char *)mmap(0, 0x100000uLL, 3, 4098, -1, 0);
  *((void *)this + 1) = v2;
  AGGraphVMRegionBaseAddress = (uint64_t)v2;
  if (v2 == (char *)-1)
  {
    uint64_t v4 = *((unsigned int *)this + 5);
    uint64_t v5 = __error();
    AG::precondition_failure((AG *)"memory allocation failure (%u bytes, %u)", v6, v4, *v5);
  }
  *(void *)this = v2 - 512;
  *((_DWORD *)this + 6) = *((_DWORD *)this + 5) + 512;
  if (!AG::data::table::_malloc_zone)
  {
    AG::data::table::_malloc_zone = (uint64_t)malloc_create_zone(0, 0);
    malloc_set_zone_name((malloc_zone_t *)AG::data::table::_malloc_zone, "AttributeGraph graph data");
  }
  return this;
}

void sub_1AF917A0C(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void **)(v3 + 80);
  if (v5) {
    free(v5);
  }
  AG::data::table::table(v2, v1);
  _Unwind_Resume(a1);
}

void *AG::vector<AG::LayoutDescriptor::Compare::Enum,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 66) + (*((void *)__dst + 66) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 66) + (*((void *)__dst + 66) >> 1);
  }
  __n128 result = AG::details::realloc_vector<unsigned long,64ul>(*((void **)__dst + 64), __dst, 8uLL, (size_t *)__dst + 66, v3);
  *((void *)__dst + 64) = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,64ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  unsigned int v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, a5 << 6);
      free(v7);
      unsigned int v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(a5 << 6);
    size_t v9 = v8 >> 6;
    if (v8 >> 6 != *a4)
    {
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x8734B07FuLL);
      if (!v10) {
        AG::precondition_failure((AG *)"allocation failure", v11);
      }
      unsigned int v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, *a4 << 6);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t AG::Subgraph::ancestor_of(AG::Subgraph *this, const AG::Subgraph *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 32;
  while (1)
  {
    uint64_t v4 = a2;
    if (a2) {
      goto LABEL_8;
    }
    uint64_t v5 = v16;
    if (!v17) {
      break;
    }
    if (v16) {
      uint64_t v6 = v16;
    }
    else {
      uint64_t v6 = v15;
    }
    uint64_t v4 = (const AG::Subgraph *)v6[--v17];
LABEL_8:
    if (v4 == this)
    {
      uint64_t v13 = 1;
      uint64_t v5 = v16;
      if (!v16) {
        return v13;
      }
      goto LABEL_21;
    }
    uint64_t v7 = *((void *)v4 + 7);
    if (v7)
    {
      a2 = 0;
      unint64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
      if (*(void *)((v7 & 0xFFFFFFFFFFFFFFFELL) + 40))
      {
        uint64_t v9 = 0;
        if (*(void *)(v8 + 32)) {
          unint64_t v8 = *(void *)(v8 + 32);
        }
        a2 = *(const AG::Subgraph **)v8;
        uint64_t v10 = 8;
        do
        {
          unint64_t v11 = v7 & 0xFFFFFFFFFFFFFFFELL;
          uint64_t v12 = v10 + 8;
          if ((unint64_t)++v9 >= *(void *)(v11 + 40)) {
            break;
          }
          if (*(void *)(v11 + 32)) {
            unint64_t v11 = *(void *)(v11 + 32);
          }
          std::stack<AG::Subgraph const*,AG::vector<AG::Subgraph const*,32ul,unsigned long>>::push[abi:ne180100](v15, (void *)(v11 + v10));
          uint64_t v7 = *((void *)v4 + 7);
          uint64_t v10 = v12;
        }
        while ((v7 & 1) != 0);
      }
    }
    else
    {
      a2 = (const AG::Subgraph *)*((void *)v4 + 7);
    }
  }
  uint64_t v13 = 0;
  if (v16) {
LABEL_21:
  }
    free(v5);
  return v13;
}

void sub_1AF917C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41)
{
  if (a41) {
    free(a41);
  }
  _Unwind_Resume(exception_object);
}

void *AG::Encoder::encode_varint(void *this, unint64_t a2)
{
  unint64_t v2 = a2;
  size_t v3 = this;
  if (a2 > 0x7F)
  {
    unsigned __int8 v5 = 70 - __clz(a2);
    uint64_t v6 = (((v5 - ((unsigned __int16)(37 * v5) >> 8)) >> 1) + ((37 * v5) >> 8)) >> 2;
    unint64_t v4 = this[4];
  }
  else
  {
    unint64_t v4 = this[4];
    if (this[5] > v4)
    {
      *(unsigned char *)(this[3] + v4) = a2;
      ++this[4];
      return this;
    }
    uint64_t v6 = 1;
  }
  size_t v7 = v4 + v6;
  if (v4 < v4 + v6 && this[5] < v7) {
    this = AG::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)(this + 3), v7);
  }
  v3[4] = v7;
  unint64_t v8 = (unsigned char *)(v3[3] + v4);
  do
  {
    BOOL v9 = v2 > 0x7F;
    char v10 = v2 > 0x7F;
    char v11 = v2 & 0x7F;
    v2 >>= 7;
    *v8++ = v11 | (v10 << 7);
  }
  while (v9);
  return this;
}

void *AG::Encoder::encode_data(AG::Encoder *this, const void *a2, unint64_t a3)
{
  __n128 result = AG::Encoder::encode_varint(this, a3);
  if (a3)
  {
    unint64_t v7 = *((void *)this + 4);
    unint64_t v8 = v7 + a3;
    if (v7 < v7 + a3 && *((void *)this + 5) < v8) {
      AG::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this + 24, v7 + a3);
    }
    *((void *)this + 4) = v8;
    BOOL v9 = (void *)(*((void *)this + 3) + v7);
    return memcpy(v9, a2, a3);
  }
  return result;
}

void *AG::vector<AG::ConstOutputEdgeArrayRef,64ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 130) + (*((void *)__dst + 130) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 130) + (*((void *)__dst + 130) >> 1);
  }
  __n128 result = AG::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 128), __dst, 0x40uLL, (size_t *)__dst + 130, v3);
  *((void *)__dst + 128) = result;
  return result;
}

uint64_t AG::Graph::TraceRecorder::encode_keys(uint64_t this)
{
  uint64_t v1 = *(void *)(*(void *)(this + 24) + 336);
  if (v1)
  {
    uint64_t v2 = this;
    unsigned int v3 = *(_DWORD *)(v1 + 8);
    for (unint64_t i = *(unsigned int *)(this + 536); v3 > i; *(_DWORD *)(v2 + 536) = i)
    {
      this = AG::Graph::key_name(*(AG::Graph **)(v2 + 24), (const char *)i);
      if (this)
      {
        unsigned __int8 v5 = (const char *)this;
        unint64_t v6 = *(unsigned int *)(v2 + 536);
        AG::Encoder::encode_varint((void *)(v2 + 32), 0x22uLL);
        AG::Encoder::begin_length_delimited((void *)(v2 + 32));
        if (v6)
        {
          AG::Encoder::encode_varint((void *)(v2 + 32), 8uLL);
          AG::Encoder::encode_varint((void *)(v2 + 32), v6);
        }
        size_t v7 = strlen(v5);
        if (v7)
        {
          unint64_t v8 = v7;
          AG::Encoder::encode_varint((void *)(v2 + 32), 0x12uLL);
          AG::Encoder::encode_data((AG::Encoder *)(v2 + 32), v5, v8);
        }
        this = (uint64_t)AG::Encoder::end_length_delimited((AG::Encoder *)(v2 + 32));
      }
      unint64_t i = (*(_DWORD *)(v2 + 536) + 1);
    }
  }
  return this;
}

uint64_t sub_1AF917F48()
{
  return sub_1AF913FC8(&qword_1EB3D3088, type metadata accessor for Flags);
}

uint64_t sub_1AF917F90()
{
  return sub_1AF913FC8(&qword_1EB3D3080, type metadata accessor for Flags);
}

uint64_t sub_1AF917FD8()
{
  return sub_1AF913FC8(&qword_1EB3D3090, type metadata accessor for Flags);
}

uint64_t sub_1AF918020()
{
  return sub_1AF913FC8(&qword_1EB3D3078, type metadata accessor for Flags);
}

void type metadata accessor for AnyWeakAttribute.__Unnamed_struct__details(uint64_t a1)
{
}

unint64_t sub_1AF918080()
{
  unint64_t result = qword_1EB3D2EE0;
  if (!qword_1EB3D2EE0)
  {
    type metadata accessor for AnyAttribute(255);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB3D2EE0);
  }
  return result;
}

void *sub_1AF9180D8()
{
  unint64_t result = (void *)swift_slowAlloc();
  *unint64_t result = 0;
  result[1] = sub_1AF937918;
  result[2] = sub_1AF9162B8;
  result[3] = sub_1AF937924;
  result[4] = sub_1AF937994;
  result[5] = sub_1AF937A04;
  qword_1EB3D30B0 = (uint64_t)result;
  return result;
}

uint64_t AG::Graph::TraceRecorder::TraceRecorder(uint64_t a1, uint64_t a2, int a3, const char **a4, uint64_t a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1F08141A8;
  unint64_t v10 = AGMakeUniqueID();
  *(void *)a1 = &unk_1F0814008;
  *(void *)(a1 + 8) = v10;
  *(void *)(a1 + 16) = &unk_1F0814190;
  *(void *)(a1 + 24) = a2;
  AG::Encoder::Encoder(a1 + 32);
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 104) = a3;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  util::Heap::Heap((util::Heap *)(a1 + 136), (char *)(a1 + 168), 256, 0);
  *(void *)(a1 + 520) = 0;
  *(unsigned char *)(a1 + 528) = 0;
  *(void *)(a1 + 532) = 1;
  *(_OWORD *)(a1 + 544) = 0u;
  if (a5)
  {
    unint64_t v11 = *(void *)(a1 + 120);
    uint64_t v12 = 8 * a5;
    do
    {
      uint64_t v13 = strdup(*a4);
      unint64_t v14 = v11 + 1;
      if (*(void *)(a1 + 128) < v11 + 1)
      {
        AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow(a1 + 112, v14);
        unint64_t v11 = *(void *)(a1 + 120);
        unint64_t v14 = v11 + 1;
      }
      *(void *)(*(void *)(a1 + 112) + 8 * v11) = v13;
      *(void *)(a1 + 120) = v14;
      ++a4;
      unint64_t v11 = v14;
      v12 -= 8;
    }
    while (v12);
  }
  array = AGGraphCreate;
  backtrace_image_offsets(&array, &image_offsets, 1);
  uuid_copy((unsigned __int8 *)(a1 + 504), image_offsets.uuid);
  return a1;
}

void sub_1AF918348(_Unwind_Exception *a1)
{
  size_t v7 = *(void **)(v3 + 544);
  if (v7) {
    free(v7);
  }
  uint64_t v8 = *(void *)(v3 + 520);
  *(void *)(v3 + 520) = 0;
  if (v8) {
    MEMORY[0x1B3E84B80](v8, 0x1000C4077774924);
  }
  util::UntypedTable::~UntypedTable(v5);
  util::InlineHeap<256ul>::~InlineHeap(v4);
  AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::~vector(v2);
  AG::Encoder::~Encoder(v1);
  _Unwind_Resume(a1);
}

uint64_t AG::anonymous namespace'::uuid_hash(AG::_anonymous_namespace_ *this, unsigned __int8 *a2)
{
  return *(void *)this;
}

BOOL AG::anonymous namespace'::uuid_equal(AG::_anonymous_namespace_ *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  return uuid_compare((const unsigned __int8 *)this, a2) == 0;
}

util::Heap *util::InlineHeap<256ul>::~InlineHeap(util::Heap *a1)
{
  return a1;
}

uint64_t AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::~vector(uint64_t a1)
{
  uint64_t v3 = *(void **)a1;
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      unsigned __int8 v5 = (void *)v3[i];
      v3[i] = 0;
      if (v5)
      {
        free(v5);
        unint64_t v2 = *(void *)(a1 + 8);
      }
    }
    uint64_t v3 = *(void **)a1;
  }
  if (v3) {
    free(v3);
  }
  return a1;
}

void AG::Encoder::~Encoder(AG::Encoder *this)
{
  unint64_t v2 = (void *)*((void *)this + 6);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 3);
  if (v3) {
    free(v3);
  }
}

void AG::Graph::TraceRecorder::~TraceRecorder(AG::Graph::TraceRecorder *this)
{
  AG::Encoder::flush((uint64_t *)this + 4);
  unint64_t v2 = (void *)*((void *)this + 68);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = *((void *)this + 65);
  *((void *)this + 65) = 0;
  if (v3) {
    MEMORY[0x1B3E84B80](v3, 0x1000C4077774924);
  }
  util::UntypedTable::~UntypedTable((AG::Graph::TraceRecorder *)((char *)this + 424));
  util::Heap::reset((AG::Graph::TraceRecorder *)((char *)this + 136), 0, 0);
  unsigned __int8 v5 = (void *)*((void *)this + 14);
  unint64_t v4 = *((void *)this + 15);
  if (v4)
  {
    for (unint64_t i = 0; i < v4; ++i)
    {
      size_t v7 = (void *)v5[i];
      v5[i] = 0;
      if (v7)
      {
        free(v7);
        unint64_t v4 = *((void *)this + 15);
      }
    }
    unsigned __int8 v5 = (void *)*((void *)this + 14);
  }
  if (v5) {
    free(v5);
  }
  uint64_t v8 = (void *)*((void *)this + 10);
  if (v8) {
    free(v8);
  }
  BOOL v9 = (void *)*((void *)this + 7);
  if (v9) {
    free(v9);
  }
}

{
  uint64_t vars8;

  AG::Graph::TraceRecorder::~TraceRecorder(this);
  JUMPOUT(0x1B3E84B80);
}

void __clang_call_terminate(void *a1)
{
}

void AG::Graph::TraceRecorder::field_timestamp(AG::Graph::TraceRecorder *this, AG::Encoder *a2)
{
  double v3 = AG::current_time(this);
  if (v3 != 0.0)
  {
    uint64_t v4 = *(void *)&v3;
    AG::Encoder::encode_varint(a2, 0x11uLL);
    AG::Encoder::encode_fixed64(a2, v4);
  }
}

void AG::Graph::TraceRecorder::field_backtrace(AG::Graph::TraceRecorder *this, AG::Encoder *a2, uint64_t a3)
{
  kern_return_t v20;
  mach_vm_size_t v21;
  unint64_t offset;
  uint64_t v23;
  util::UntypedTable *v24;
  Dl_info v25;
  mach_port_t object_name;
  mach_msg_type_number_t infoCnt;
  int info[9];
  mach_vm_size_t size;
  mach_vm_address_t address;
  image_offset image_offsets;
  void *array[2];
  long long v33;
  long long v34;
  long long v35;
  long long v36;
  long long v37;
  long long v38;
  long long v39;
  long long v40;
  long long v41;
  long long v42;
  long long v43;
  long long v44;
  long long v45;
  long long v46;
  long long v47;
  long long v48;
  long long v49;
  long long v50;
  long long v51;
  long long v52;
  long long v53;
  long long v54;
  long long v55;
  long long v56;
  long long v57;
  long long v58;
  long long v59;
  long long v60;
  long long v61;
  long long v62;
  long long v63;
  uuid_string_t out;
  uint64_t v65;

  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 104) & 4) != 0)
  {
    uint64_t v63 = 0u;
    uint64_t v62 = 0u;
    uint64_t v61 = 0u;
    unsigned int v60 = 0u;
    char v59 = 0u;
    v58 = 0u;
    int v57 = 0u;
    uint64_t v56 = 0u;
    int v55 = 0u;
    uint64_t v54 = 0u;
    int v53 = 0u;
    uint64_t v52 = 0u;
    uint64_t v51 = 0u;
    uint64_t v50 = 0u;
    unsigned int v49 = 0u;
    int v48 = 0u;
    uint64_t v47 = 0u;
    uint64_t v46 = 0u;
    unsigned int v45 = 0u;
    uint64_t v44 = 0u;
    uint64_t v43 = 0u;
    uint64_t v42 = 0u;
    uint64_t v41 = 0u;
    uint64_t v40 = 0u;
    uint64_t v39 = 0u;
    unint64_t v38 = 0u;
    uint64_t v37 = 0u;
    unint64_t v36 = 0u;
    size_t v35 = 0u;
    uint64_t v34 = 0u;
    unsigned int v33 = 0u;
    *(_OWORD *)array = 0u;
    int v6 = backtrace(array, 64);
    backtrace_image_offsets(array, &image_offsets, v6);
    {
      AG::Graph::TraceRecorder::field_backtrace(AG::Encoder &,unsigned long)::n_stack_frames = AG::Graph::TraceRecorder::field_backtrace(AG::Encoder &,unsigned long)::$_0::operator()();
    }
    if (v6 >= 1)
    {
      int v7 = AG::Graph::TraceRecorder::field_backtrace(AG::Encoder &,unsigned long)::n_stack_frames;
      if (AG::Graph::TraceRecorder::field_backtrace(AG::Encoder &,unsigned long)::n_stack_frames >= 1)
      {
        uint64_t v8 = 0;
        p_image_offset image_offsets = &image_offsets;
        unsigned int v23 = (8 * a3) | 2;
        uint64_t v24 = (AG::Graph::TraceRecorder *)((char *)this + 424);
        unint64_t v10 = v6;
        do
        {
          if (p_image_offsets->offset
            && !uuid_is_null(p_image_offsets->uuid)
            && uuid_compare(p_image_offsets->uuid, (const unsigned __int8 *)this + 504))
          {
            AG::Encoder::encode_varint(a2, v23);
            AG::Encoder::begin_length_delimited(a2);
            *(void *)out = 0;
            unsigned int v11 = util::UntypedTable::lookup(v24, (uint64_t *)p_image_offsets, (void **)out);
            if (*(void *)out)
            {
              unint64_t v12 = v11;
            }
            else
            {
              unint64_t v12 = *((unsigned int *)this + 120);
              uint64_t v13 = util::Heap::alloc_((AG::Graph::TraceRecorder *)((char *)this + 136), 0x10uLL);
              *(_OWORD *)uint64_t v13 = *(_OWORD *)p_image_offsets->uuid;
              util::UntypedTable::insert(v24, v13, (void *)v12);
              unint64_t v14 = array[v8];
              AG::Encoder::encode_varint(a2, 0x1AuLL);
              AG::Encoder::begin_length_delimited(a2);
              memset(out, 0, sizeof(out));
              uuid_unparse((const unsigned __int8 *)v13, out);
              AG::Encoder::encode_varint(a2, 0xAuLL);
              AG::Encoder::encode_data(a2, out, 0x24uLL);
              if (dladdr(v14, &v25))
              {
                dli_fname = v25.dli_fname;
                if (v25.dli_fname)
                {
                  size_t v16 = strlen(v25.dli_fname);
                  if (v16)
                  {
                    unint64_t v17 = v16;
                    AG::Encoder::encode_varint(a2, 0x12uLL);
                    AG::Encoder::encode_data(a2, dli_fname, v17);
                  }
                }
                dli_fbase = v25.dli_fbase;
                if (v25.dli_fbase)
                {
                  AG::Encoder::encode_varint(a2, 0x18uLL);
                  AG::Encoder::encode_varint(a2, (unint64_t)dli_fbase);
                  uint64_t v19 = ~*MEMORY[0x1E4F14AF0];
                  size = 0;
                  address = v19 & (uint64_t)v25.dli_fbase;
                  object_name = 0;
                  infoCnt = 9;
                  unsigned int v20 = mach_vm_region(*MEMORY[0x1E4F14960], &address, &size, 9, info, &infoCnt, &object_name);
                  if (object_name) {
                    mach_port_deallocate(*MEMORY[0x1E4F14960], object_name);
                  }
                  if (!v20)
                  {
                    uint64_t v21 = size;
                    if (size)
                    {
                      AG::Encoder::encode_varint(a2, 0x20uLL);
                      AG::Encoder::encode_varint(a2, v21);
                    }
                  }
                }
              }
              AG::Encoder::end_length_delimited(a2);
            }
            if (v12)
            {
              AG::Encoder::encode_varint(a2, 8uLL);
              AG::Encoder::encode_varint(a2, v12);
            }
            offset = p_image_offsets->offset;
            if (offset)
            {
              AG::Encoder::encode_varint(a2, 0x10uLL);
              AG::Encoder::encode_varint(a2, offset);
            }
            AG::Encoder::end_length_delimited(a2);
            --v7;
          }
          if (++v8 >= v10) {
            break;
          }
          ++p_image_offsets;
        }
        while (v7 > 0);
      }
    }
  }
}

uint64_t AG::Graph::TraceRecorder::field_backtrace(AG::Encoder &,unsigned long)::$_0::operator()()
{
  unint64_t v0 = getenv("AG_TRACE_STACK_FRAMES");
  if (!v0) {
    return 8;
  }
  return atoi(v0);
}

void *AG::Graph::TraceRecorder::encode_stack(void *this)
{
  uint64_t v1 = AG::Graph::_current_update_key;
  uint64_t v2 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v1);
  if (v2)
  {
    double v3 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0x2AuLL);
    AG::Encoder::begin_length_delimited(v3);
    do
    {
      unint64_t v4 = v2 & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v5 = *(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 104);
      if (v5)
      {
        uint64_t v6 = 8 * v5 - 4;
        do
        {
          AG::Encoder::encode_varint(v3, 0xAuLL);
          AG::Encoder::begin_length_delimited(v3);
          unint64_t v7 = *(void *)(v4 + 96);
          if (v7) {
            unint64_t v8 = *(void *)(v4 + 96);
          }
          else {
            unint64_t v8 = v4 + 32;
          }
          unint64_t v9 = *(unsigned int *)(v8 + v6 - 4);
          if (v9)
          {
            AG::Encoder::encode_varint(v3, 8uLL);
            AG::Encoder::encode_varint(v3, v9);
            unint64_t v7 = *(void *)(v4 + 96);
          }
          if (v7) {
            unint64_t v10 = v7;
          }
          else {
            unint64_t v10 = v4 + 32;
          }
          if (*(unsigned char *)(v10 + v6))
          {
            AG::Encoder::encode_varint(v3, 0x10uLL);
            AG::Encoder::encode_varint(v3, 1uLL);
            unint64_t v7 = *(void *)(v4 + 96);
          }
          if (!v7) {
            unint64_t v7 = v4 + 32;
          }
          if ((*(unsigned char *)(v7 + v6) & 2) != 0)
          {
            AG::Encoder::encode_varint(v3, 0x18uLL);
            AG::Encoder::encode_varint(v3, 1uLL);
          }
          --v5;
          AG::Encoder::end_length_delimited(v3);
          v6 -= 8;
        }
        while (v5);
      }
      uint64_t v2 = *(void *)(v4 + 16);
    }
    while (v2);
    return AG::Encoder::end_length_delimited(v3);
  }
  return this;
}

void *AG::Graph::TraceRecorder::encode_types(void *this)
{
  unsigned int v1 = *(_DWORD *)(this[3] + 136);
  unsigned int v2 = *((_DWORD *)this + 133);
  if (v1 > v2)
  {
    double v3 = this;
    unint64_t v4 = (AG::Encoder *)(this + 4);
    do
    {
      uint64_t v5 = *(void *)(*(void *)(v3[3] + 128) + 8 * v2);
      AG::Encoder::encode_varint(v4, 0x1AuLL);
      AG::Encoder::begin_length_delimited(v4);
      if (v2)
      {
        AG::Encoder::encode_varint(v4, 8uLL);
        AG::Encoder::encode_varint(v4, v2);
      }
      uint64_t v6 = (const char *)AG::swift::metadata::name(*(AG::swift::metadata **)v5, 0);
      size_t v7 = strlen(v6);
      if (v7)
      {
        unint64_t v8 = v7;
        AG::Encoder::encode_varint(v4, 0x12uLL);
        AG::Encoder::encode_data(v4, v6, v8);
      }
      unint64_t v9 = (const char *)AG::swift::metadata::name(*(AG::swift::metadata **)(v5 + 8), 0);
      size_t v10 = strlen(v9);
      if (v10)
      {
        unint64_t v11 = v10;
        AG::Encoder::encode_varint(v4, 0x1AuLL);
        AG::Encoder::encode_data(v4, v9, v11);
      }
      unint64_t v12 = *(void *)(*(void *)(*(void *)v5 - 8) + 64);
      if (v12)
      {
        AG::Encoder::encode_varint(v4, 0x20uLL);
        AG::Encoder::encode_varint(v4, v12);
      }
      unint64_t v13 = *(void *)(*(void *)(*(void *)(v5 + 8) - 8) + 64);
      if (v13)
      {
        AG::Encoder::encode_varint(v4, 0x28uLL);
        AG::Encoder::encode_varint(v4, v13);
      }
      unint64_t v14 = *(unsigned int *)(v5 + 40);
      if (v14)
      {
        AG::Encoder::encode_varint(v4, 0x30uLL);
        AG::Encoder::encode_varint(v4, v14);
      }
      this = AG::Encoder::end_length_delimited(v4);
      unsigned int v2 = *((_DWORD *)v3 + 133) + 1;
      *((_DWORD *)v3 + 133) = v2;
    }
    while (v1 > v2);
  }
  return this;
}

void *AG::Graph::TraceRecorder::encode_snapshot(void *this)
{
  if ((this[13] & 0x10) == 0)
  {
    unsigned int v1 = this;
    AG::Graph::TraceRecorder::encode_types(this);
    AG::Graph::TraceRecorder::encode_keys((uint64_t)v1);
    AG::Encoder::encode_varint(v1 + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v1 + 4);
    AG::Encoder::encode_varint(v1 + 4, 8uLL);
    unsigned int v2 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v1 + 4, 0x11uLL);
    AG::Graph::TraceRecorder::field_timestamp(v2, (AG::Encoder *)(v1 + 4));
    AG::Encoder::end_length_delimited((AG::Encoder *)(v1 + 4));
    uint64_t v3 = v1[3];
    uint64_t v4 = *(unsigned int *)(v3 + 352);
    if (v4)
    {
      uint64_t v5 = *(void *)(v3 + 344);
      uint64_t v6 = 8 * v4;
      do
      {
        size_t v7 = *(void **)v5;
        if (!*(unsigned char *)(*(void *)v5 + 104))
        {
          AG::Encoder::encode_varint(v1 + 4, 0x12uLL);
          AG::Encoder::begin_length_delimited(v1 + 4);
          AG::Subgraph::encode(v7, (AG::Encoder *)(v1 + 4));
          AG::Encoder::end_length_delimited((AG::Encoder *)(v1 + 4));
        }
        v5 += 8;
        v6 -= 8;
      }
      while (v6);
    }
    AG::Graph::TraceRecorder::encode_stack(v1);
    AG::Encoder::encode_varint(v1 + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v1 + 4);
    AG::Encoder::encode_varint(v1 + 4, 8uLL);
    unint64_t v8 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v1 + 4, 0x12uLL);
    AG::Graph::TraceRecorder::field_timestamp(v8, (AG::Encoder *)(v1 + 4));
    return AG::Encoder::end_length_delimited((AG::Encoder *)(v1 + 4));
  }
  return this;
}

uint64_t AG::Graph::TraceRecorder::flush_encoder(const char **this, AG::Encoder *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 528))
  {
    uint64_t result = open(this[65], 9, 438);
    int v5 = result;
  }
  else
  {
    *((unsigned char *)this + 528) = 1;
    uint64_t v6 = getenv("AG_TRACE_FILE");
    if (v6) {
      size_t v7 = v6;
    }
    else {
      size_t v7 = "trace";
    }
    unint64_t v8 = "";
    unint64_t v9 = "";
    if (*v7 != 47)
    {
      size_t v10 = getenv("TMPDIR");
      if (!v10 || (unint64_t v11 = v10, !*v10)) {
        unint64_t v11 = "/tmp";
      }
      if (v11[strlen(v11) - 1] == 47) {
        unint64_t v9 = "";
      }
      else {
        unint64_t v9 = "/";
      }
      unint64_t v8 = v11;
    }
    int v12 = 1;
    while (1)
    {
      *(void *)buf = 0;
      asprintf((char **)buf, "%s%s%s-%04d.ag-trace", v8, v9, v7, v12);
      int v5 = open(*(const char **)buf, 2569, 438);
      if ((v5 & 0x80000000) == 0) {
        break;
      }
      free(*(void **)buf);
      unint64_t v13 = (AG *)__error();
      if (*(_DWORD *)v13 == 17 && v12++ != 999) {
        continue;
      }
      goto LABEL_22;
    }
    unint64_t v13 = (AG *)this[65];
    this[65] = *(const char **)buf;
    if (v13) {
      unint64_t v13 = (AG *)MEMORY[0x1B3E84B80](v13, 0x1000C4077774924);
    }
LABEL_22:
    if (this[65])
    {
      uint64_t v15 = AG::misc_log(v13);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        size_t v16 = this[65];
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v16;
        _os_log_impl(&dword_1AF901000, v15, OS_LOG_TYPE_DEFAULT, "created trace file %s", buf, 0xCu);
      }
      unint64_t v17 = (FILE *)*MEMORY[0x1E4F143C8];
      getpid();
      uint64_t result = fprintf(v17, "created trace file \"%s\" (pid %d)\n");
    }
    else
    {
      uint64_t result = fprintf((FILE *)*MEMORY[0x1E4F143C8], "failed to create trace file: %s%s%s-XXXX.ag-trace\n");
    }
  }
  if (v5 == -1) {
    return result;
  }
  size_t v18 = *((void *)a2 + 4);
  if (!v18) {
    return close(v5);
  }
  uint64_t v19 = (char *)*((void *)a2 + 3);
  while (1)
  {
    ssize_t v20 = write(v5, v19, v18);
    if (v20 < 0) {
      break;
    }
    v19 += v20;
    v18 -= v20;
LABEL_33:
    if (!v18) {
      return close(v5);
    }
  }
  if (*__error() == 4) {
    goto LABEL_33;
  }
  unlink(this[65]);
  return close(v5);
}

uint64_t non-virtual thunk to'AG::Graph::TraceRecorder::flush_encoder(const char **this, AG::Encoder *a2)
{
  return AG::Graph::TraceRecorder::flush_encoder(this - 2, a2);
}

void *AG::Graph::TraceRecorder::begin_trace(AG::Graph::TraceRecorder *this, AG::Graph *a2)
{
  unsigned int v2 = (AG::Graph::TraceRecorder *)((char *)this + 32);
  AG::Encoder::encode_varint((void *)this + 4, 0xAuLL);
  AG::Encoder::begin_length_delimited(v2);
  AG::Encoder::encode_varint(v2, 8uLL);
  uint64_t v3 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v2, 1uLL);
  AG::Graph::TraceRecorder::field_timestamp(v3, v2);
  return AG::Encoder::end_length_delimited(v2);
}

void *AG::Graph::TraceRecorder::end_trace(AG::Graph::TraceRecorder *this, AG::Graph *a2)
{
  uint64_t v3 = (AG::Graph::TraceRecorder *)((char *)this + 32);
  AG::Encoder::encode_varint((void *)this + 4, 0xAuLL);
  AG::Encoder::begin_length_delimited(v3);
  AG::Encoder::encode_varint(v3, 8uLL);
  uint64_t v4 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v3, 2uLL);
  AG::Graph::TraceRecorder::field_timestamp(v4, v3);
  AG::Encoder::end_length_delimited(v3);
  return AG::Graph::TraceRecorder::encode_snapshot(this);
}

uint64_t *AG::Graph::TraceRecorder::sync_trace(AG::Graph::TraceRecorder *this)
{
  AG::Graph::TraceRecorder::encode_snapshot(this);
  return AG::Encoder::flush((uint64_t *)this + 4);
}

void AG::Graph::TraceRecorder::log_message_v(AG::Graph::TraceRecorder *this, const char *__s1, va_list a3)
{
  int v12 = 0;
  va_list v13 = a3;
  int v6 = strcmp(__s1, "%s");
  if (v6)
  {
    vasprintf((char **)&v12, __s1, a3);
    size_t v7 = v12;
    if (!v12) {
      return;
    }
  }
  else
  {
    unint64_t v8 = (void **)v13;
    v13 += 8;
    size_t v7 = *v8;
    int v12 = v7;
    if (!v7) {
      return;
    }
  }
  AG::Encoder::encode_varint((void *)this + 4, 0xAuLL);
  AG::Encoder::begin_length_delimited((void *)this + 4);
  AG::Encoder::encode_varint((void *)this + 4, 8uLL);
  unint64_t v9 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint((void *)this + 4, 0x33uLL);
  AG::Graph::TraceRecorder::field_timestamp(v9, (AG::Graph::TraceRecorder *)((char *)this + 32));
  AG::Graph::TraceRecorder::field_backtrace(this, (AG::Graph::TraceRecorder *)((char *)this + 32), 8);
  size_t v10 = strlen((const char *)v7);
  if (v10)
  {
    unint64_t v11 = v10;
    AG::Encoder::encode_varint((void *)this + 4, 0x4AuLL);
    AG::Encoder::encode_data((AG::Graph::TraceRecorder *)((char *)this + 32), v7, v11);
  }
  AG::Encoder::end_length_delimited((AG::Graph::TraceRecorder *)((char *)this + 32));
  AG::Graph::TraceRecorder::encode_stack(this);
  if (v6) {
    free(v12);
  }
}

void *AG::Graph::TraceRecorder::begin_update(void *this, AG::Subgraph *a2, unsigned int a3)
{
  if ((this[13] & 0x10) == 0)
  {
    int v5 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    int v6 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v5, 3uLL);
    AG::Graph::TraceRecorder::field_timestamp(v6, v5);
    int v7 = *((_DWORD *)a2 + 6);
    unint64_t v8 = v7 & 0x7FFFFFFF;
    if ((v7 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, v8);
    }
    if (a3)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, a3);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return this;
}

void *AG::Graph::TraceRecorder::end_update(void *this, AG::Subgraph *a2)
{
  if ((this[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v3);
    AG::Encoder::encode_varint(v3, 8uLL);
    uint64_t v4 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v3, 4uLL);
    AG::Graph::TraceRecorder::field_timestamp(v4, v3);
    int v5 = *((_DWORD *)a2 + 6);
    unint64_t v6 = v5 & 0x7FFFFFFF;
    if ((v5 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v3, 0x18uLL);
      AG::Encoder::encode_varint(v3, v6);
    }
    return AG::Encoder::end_length_delimited(v3);
  }
  return this;
}

void *AG::Graph::TraceRecorder::begin_update(void *result, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if ((result[13] & 0x10) == 0)
  {
    unint64_t v6 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v6);
    AG::Encoder::encode_varint(v6, 8uLL);
    int v7 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v6, 5uLL);
    AG::Graph::TraceRecorder::field_timestamp(v7, v6);
    if (a3)
    {
      AG::Encoder::encode_varint(v6, 0x18uLL);
      AG::Encoder::encode_varint(v6, a3);
    }
    if (a4)
    {
      AG::Encoder::encode_varint(v6, 0x20uLL);
      AG::Encoder::encode_varint(v6, a4);
    }
    return AG::Encoder::end_length_delimited(v6);
  }
  return result;
}

void *AG::Graph::TraceRecorder::end_update(void *result, uint64_t a2, unsigned int a3, int a4)
{
  if ((result[13] & 0x10) == 0)
  {
    unint64_t v6 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v6);
    AG::Encoder::encode_varint(v6, 8uLL);
    int v7 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v6, 6uLL);
    AG::Graph::TraceRecorder::field_timestamp(v7, v6);
    if (a3)
    {
      AG::Encoder::encode_varint(v6, 0x18uLL);
      AG::Encoder::encode_varint(v6, a3);
    }
    if (a4 == 1)
    {
      AG::Encoder::encode_varint(v6, 0x20uLL);
      AG::Encoder::encode_varint(v6, 1uLL);
    }
    return AG::Encoder::end_length_delimited(v6);
  }
  return result;
}

void *AG::Graph::TraceRecorder::begin_update(void *result, unsigned int a2)
{
  if ((result[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v3);
    AG::Encoder::encode_varint(v3, 8uLL);
    uint64_t v4 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v3, 7uLL);
    AG::Graph::TraceRecorder::field_timestamp(v4, v3);
    if (a2)
    {
      AG::Encoder::encode_varint(v3, 0x18uLL);
      AG::Encoder::encode_varint(v3, a2);
    }
    return AG::Encoder::end_length_delimited(v3);
  }
  return result;
}

void *AG::Graph::TraceRecorder::end_update(void *result, unsigned int a2, int a3)
{
  if ((result[13] & 0x10) == 0)
  {
    int v5 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    unint64_t v6 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v5, 8uLL);
    AG::Graph::TraceRecorder::field_timestamp(v6, v5);
    if (a2)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, a2);
    }
    if (a3)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, 1uLL);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return result;
}

void *AG::Graph::TraceRecorder::begin_update(void *this, AG::Graph::Context *a2)
{
  if ((this[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v3);
    AG::Encoder::encode_varint(v3, 8uLL);
    uint64_t v4 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v3, 9uLL);
    AG::Graph::TraceRecorder::field_timestamp(v4, v3);
    unint64_t v5 = *((unsigned int *)a2 + 4);
    if (v5)
    {
      AG::Encoder::encode_varint(v3, 0x18uLL);
      AG::Encoder::encode_varint(v3, v5);
    }
    return AG::Encoder::end_length_delimited(v3);
  }
  return this;
}

void *AG::Graph::TraceRecorder::end_update(void *this, AG::Graph::Context *a2)
{
  if ((this[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v3);
    AG::Encoder::encode_varint(v3, 8uLL);
    uint64_t v4 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v3, 0xAuLL);
    AG::Graph::TraceRecorder::field_timestamp(v4, v3);
    unint64_t v5 = *((unsigned int *)a2 + 4);
    if (v5)
    {
      AG::Encoder::encode_varint(v3, 0x18uLL);
      AG::Encoder::encode_varint(v3, v5);
    }
    return AG::Encoder::end_length_delimited(v3);
  }
  return this;
}

void *AG::Graph::TraceRecorder::begin_invalidation(void *result, uint64_t a2, unsigned int a3)
{
  if ((result[13] & 0x12) == 2)
  {
    unint64_t v5 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    unint64_t v6 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v5, 0xBuLL);
    AG::Graph::TraceRecorder::field_timestamp(v6, v5);
    if (a3)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, a3);
    }
    unint64_t v7 = *(unsigned int *)(a2 + 16);
    if (v7)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, v7);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return result;
}

void *AG::Graph::TraceRecorder::end_invalidation(void *result, uint64_t a2, unsigned int a3)
{
  if ((result[13] & 0x12) == 2)
  {
    unint64_t v5 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    unint64_t v6 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v5, 0xCuLL);
    AG::Graph::TraceRecorder::field_timestamp(v6, v5);
    if (a3)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, a3);
    }
    unint64_t v7 = *(unsigned int *)(a2 + 16);
    if (v7)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, v7);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return result;
}

void *AG::Graph::TraceRecorder::begin_modify(void *result, unsigned int a2)
{
  if ((result[13] & 0x12) == 2)
  {
    uint64_t v3 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v3);
    AG::Encoder::encode_varint(v3, 8uLL);
    uint64_t v4 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v3, 0xDuLL);
    AG::Graph::TraceRecorder::field_timestamp(v4, v3);
    if (a2)
    {
      AG::Encoder::encode_varint(v3, 0x18uLL);
      AG::Encoder::encode_varint(v3, a2);
    }
    return AG::Encoder::end_length_delimited(v3);
  }
  return result;
}

void *AG::Graph::TraceRecorder::end_modify(void *result, int a2)
{
  if ((result[13] & 0x12) == 2)
  {
    uint64_t v3 = result;
    uint64_t v4 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 8uLL);
    unint64_t v5 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v4, 0xEuLL);
    AG::Graph::TraceRecorder::field_timestamp(v5, v4);
    if (a2 || (v3[13] & 0x10) != 0)
    {
      AG::Encoder::encode_varint(v4, 0x18uLL);
      AG::Encoder::encode_varint(v4, 1uLL);
    }
    return AG::Encoder::end_length_delimited(v4);
  }
  return result;
}

void *AG::Graph::TraceRecorder::begin_event(void *result, unsigned int a2, unsigned int a3)
{
  if ((result[13] & 0x10) == 0)
  {
    unint64_t v5 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    unint64_t v6 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v5, 0xFuLL);
    AG::Graph::TraceRecorder::field_timestamp(v6, v5);
    if (a2)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, a2);
    }
    if (a3)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, a3);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return result;
}

void *AG::Graph::TraceRecorder::end_event(void *result, unsigned int a2, unsigned int a3)
{
  if ((result[13] & 0x10) == 0)
  {
    unint64_t v5 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    unint64_t v6 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v5, 0x10uLL);
    AG::Graph::TraceRecorder::field_timestamp(v6, v5);
    if (a2)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, a2);
    }
    if (a3)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, a3);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return result;
}

void *AG::Graph::TraceRecorder::created(void *this, AG::Graph::Context *a2)
{
  if ((this[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)this;
    uint64_t v4 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 8uLL);
    AG::Encoder::encode_varint(v4, 0x20uLL);
    unint64_t v5 = *((void *)a2 + 2);
    if (v5)
    {
      AG::Encoder::encode_varint(v4, 0x18uLL);
      AG::Encoder::encode_varint(v4, v5);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v4, 8);
    return AG::Encoder::end_length_delimited(v4);
  }
  return this;
}

void *AG::Graph::TraceRecorder::destroy(void *this, AG::Graph::Context *a2)
{
  if ((this[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)this;
    uint64_t v4 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 8uLL);
    AG::Encoder::encode_varint(v4, 0x21uLL);
    unint64_t v5 = *((void *)a2 + 2);
    if (v5)
    {
      AG::Encoder::encode_varint(v4, 0x18uLL);
      AG::Encoder::encode_varint(v4, v5);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v4, 8);
    return AG::Encoder::end_length_delimited(v4);
  }
  return this;
}

void *AG::Graph::TraceRecorder::needs_update(void *this, AG::Graph::Context *a2)
{
  if ((this[13] & 0x12) == 2)
  {
    uint64_t v3 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v3);
    AG::Encoder::encode_varint(v3, 8uLL);
    AG::Encoder::encode_varint(v3, 0x22uLL);
    unint64_t v4 = *((void *)a2 + 2);
    if (v4)
    {
      AG::Encoder::encode_varint(v3, 0x18uLL);
      AG::Encoder::encode_varint(v3, v4);
    }
    return AG::Encoder::end_length_delimited(v3);
  }
  return this;
}

void *AG::Graph::TraceRecorder::created(void *this, AG::Subgraph *a2)
{
  if ((this[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)this;
    unint64_t v4 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 8uLL);
    AG::Encoder::encode_varint(v4, 0x23uLL);
    int v5 = *((_DWORD *)a2 + 6);
    unint64_t v6 = v5 & 0x7FFFFFFF;
    if ((v5 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v4, 0x18uLL);
      AG::Encoder::encode_varint(v4, v6);
    }
    unint64_t v7 = *((void *)a2 + 6);
    if (v7)
    {
      AG::Encoder::encode_varint(v4, 0x20uLL);
      AG::Encoder::encode_varint(v4, v7);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v4, 8);
    return AG::Encoder::end_length_delimited(v4);
  }
  return this;
}

void *AG::Graph::TraceRecorder::invalidate(void *this, AG::Subgraph *a2)
{
  if ((this[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)this;
    unint64_t v4 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 8uLL);
    AG::Encoder::encode_varint(v4, 0x24uLL);
    int v5 = *((_DWORD *)a2 + 6);
    unint64_t v6 = v5 & 0x7FFFFFFF;
    if ((v5 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v4, 0x18uLL);
      AG::Encoder::encode_varint(v4, v6);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v4, 8);
    AG::Encoder::end_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 0x12uLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Subgraph::encode(a2, v4);
    return AG::Encoder::end_length_delimited(v4);
  }
  return this;
}

void *AG::Graph::TraceRecorder::destroy(void *this, AG::Subgraph *a2)
{
  if ((this[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)this;
    unint64_t v4 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 8uLL);
    AG::Encoder::encode_varint(v4, 0x35uLL);
    int v5 = *((_DWORD *)a2 + 6);
    unint64_t v6 = v5 & 0x7FFFFFFF;
    if ((v5 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v4, 0x18uLL);
      AG::Encoder::encode_varint(v4, v6);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v4, 8);
    return AG::Encoder::end_length_delimited(v4);
  }
  return this;
}

void *AG::Graph::TraceRecorder::add_child(void *this, AG::Subgraph *a2, AG::Subgraph *a3)
{
  if ((this[13] & 0x10) == 0)
  {
    int v5 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    AG::Encoder::encode_varint(v5, 0x25uLL);
    int v6 = *((_DWORD *)a2 + 6);
    unint64_t v7 = v6 & 0x7FFFFFFF;
    if ((v6 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, v7);
    }
    int v8 = *((_DWORD *)a3 + 6);
    unint64_t v9 = v8 & 0x7FFFFFFF;
    if ((v8 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, v9);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return this;
}

void *AG::Graph::TraceRecorder::remove_child(void *this, AG::Subgraph *a2, AG::Subgraph *a3)
{
  if ((this[13] & 0x10) == 0)
  {
    int v5 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    AG::Encoder::encode_varint(v5, 0x26uLL);
    int v6 = *((_DWORD *)a2 + 6);
    unint64_t v7 = v6 & 0x7FFFFFFF;
    if ((v6 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, v7);
    }
    int v8 = *((_DWORD *)a3 + 6);
    unint64_t v9 = v8 & 0x7FFFFFFF;
    if ((v8 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, v9);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return this;
}

void *AG::Graph::TraceRecorder::added(void *result, unsigned int a2)
{
  if ((result[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)result;
    unint64_t v4 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 8uLL);
    AG::Encoder::encode_varint(v4, 0x27uLL);
    uint64_t v5 = a2;
    if (a2)
    {
      AG::Encoder::encode_varint(v4, 0x18uLL);
      AG::Encoder::encode_varint(v4, a2);
    }
    uint64_t v6 = AG::data::_shared_table_bytes;
    int v7 = *(_DWORD *)(*(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00)) + 24);
    unint64_t v8 = v7 & 0x7FFFFFFF;
    if ((v7 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v4, 0x20uLL);
      AG::Encoder::encode_varint(v4, v8);
      uint64_t v6 = AG::data::_shared_table_bytes;
    }
    unint64_t v9 = *(unsigned int *)(v6 + v5);
    if (v9 >= 0x100)
    {
      unint64_t v10 = v9 >> 8;
      AG::Encoder::encode_varint(v4, 0x28uLL);
      AG::Encoder::encode_varint(v4, v10);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v4, 8);
    return AG::Encoder::end_length_delimited(v4);
  }
  return result;
}

void *AG::Graph::TraceRecorder::add_edge(void *result, unsigned int a2, unsigned int a3)
{
  if ((result[13] & 0x10) == 0)
  {
    uint64_t v5 = (AG::Graph::TraceRecorder *)result;
    uint64_t v6 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v6);
    AG::Encoder::encode_varint(v6, 8uLL);
    AG::Encoder::encode_varint(v6, 0x2FuLL);
    if (a2)
    {
      AG::Encoder::encode_varint(v6, 0x18uLL);
      AG::Encoder::encode_varint(v6, a2);
    }
    if (a3)
    {
      AG::Encoder::encode_varint(v6, 0x20uLL);
      AG::Encoder::encode_varint(v6, a3);
    }
    AG::Graph::TraceRecorder::field_backtrace(v5, v6, 8);
    return AG::Encoder::end_length_delimited(v6);
  }
  return result;
}

void *AG::Graph::TraceRecorder::remove_edge(void *result, unsigned int a2, uint64_t a3)
{
  if ((result[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)result;
    unint64_t v4 = a2;
    unint64_t v5 = *(unsigned int *)(AG::data::_shared_table_bytes
                         + *(unsigned int *)(AG::data::_shared_table_bytes + a2 + 16)
                         + 5 * a3);
    uint64_t v6 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v6);
    AG::Encoder::encode_varint(v6, 8uLL);
    AG::Encoder::encode_varint(v6, 0x30uLL);
    if (v4)
    {
      AG::Encoder::encode_varint(v6, 0x18uLL);
      AG::Encoder::encode_varint(v6, v4);
    }
    if (v5)
    {
      AG::Encoder::encode_varint(v6, 0x20uLL);
      AG::Encoder::encode_varint(v6, v5);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v6, 8);
    return AG::Encoder::end_length_delimited(v6);
  }
  return result;
}

void *AG::Graph::TraceRecorder::set_edge_pending(void *result, unsigned int a2, uint64_t a3, int a4)
{
  if ((result[13] & 0x12) == 2)
  {
    unint64_t v5 = a2;
    unint64_t v6 = *(unsigned int *)(AG::data::_shared_table_bytes
                         + *(unsigned int *)(AG::data::_shared_table_bytes + a2 + 16)
                         + 5 * a3);
    int v7 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v7);
    AG::Encoder::encode_varint(v7, 8uLL);
    AG::Encoder::encode_varint(v7, 0x31uLL);
    if (v5)
    {
      AG::Encoder::encode_varint(v7, 0x18uLL);
      AG::Encoder::encode_varint(v7, v5);
    }
    if (v6)
    {
      AG::Encoder::encode_varint(v7, 0x20uLL);
      AG::Encoder::encode_varint(v7, v6);
    }
    if (a4)
    {
      AG::Encoder::encode_varint(v7, 0x28uLL);
      AG::Encoder::encode_varint(v7, 1uLL);
    }
    return AG::Encoder::end_length_delimited(v7);
  }
  return result;
}

void *AG::Graph::TraceRecorder::set_dirty(void *result, unsigned int a2, int a3)
{
  if ((result[13] & 0x12) == 2)
  {
    unint64_t v5 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    AG::Encoder::encode_varint(v5, 0x28uLL);
    if (a2)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, a2);
    }
    if (a3)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, 1uLL);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return result;
}

void *AG::Graph::TraceRecorder::set_pending(void *result, unsigned int a2, int a3)
{
  if ((result[13] & 0x12) == 2)
  {
    unint64_t v5 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    AG::Encoder::encode_varint(v5, 0x29uLL);
    if (a2)
    {
      AG::Encoder::encode_varint(v5, 0x18uLL);
      AG::Encoder::encode_varint(v5, a2);
    }
    if (a3)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, 1uLL);
    }
    return AG::Encoder::end_length_delimited(v5);
  }
  return result;
}

void *AG::Graph::TraceRecorder::set_value(void *result, unsigned int a2)
{
  if ((result[13] & 0x12) == 2)
  {
    uint64_t v3 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v3);
    AG::Encoder::encode_varint(v3, 8uLL);
    AG::Encoder::encode_varint(v3, 0x2AuLL);
    if (a2)
    {
      AG::Encoder::encode_varint(v3, 0x18uLL);
      AG::Encoder::encode_varint(v3, a2);
    }
    return AG::Encoder::end_length_delimited(v3);
  }
  return result;
}

void *AG::Graph::TraceRecorder::mark_value(void *result, unsigned int a2)
{
  if ((result[13] & 0x12) == 2)
  {
    uint64_t v3 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v3);
    AG::Encoder::encode_varint(v3, 8uLL);
    AG::Encoder::encode_varint(v3, 0x2BuLL);
    if (a2)
    {
      AG::Encoder::encode_varint(v3, 0x18uLL);
      AG::Encoder::encode_varint(v3, a2);
    }
    return AG::Encoder::end_length_delimited(v3);
  }
  return result;
}

void *AG::Graph::TraceRecorder::added(void *result, int a2)
{
  if ((result[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)result;
    unint64_t v4 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 8uLL);
    AG::Encoder::encode_varint(v4, 0x2CuLL);
    AG::Encoder::encode_varint(v4, 0x18uLL);
    AG::Encoder::encode_varint(v4, a2 & 0xFFFFFFFE | 1);
    int v5 = *(_DWORD *)(*(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00)) + 24);
    unint64_t v6 = v5 & 0x7FFFFFFF;
    if ((v5 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(v4, 0x20uLL);
      AG::Encoder::encode_varint(v4, v6);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v4, 8);
    return AG::Encoder::end_length_delimited(v4);
  }
  return result;
}

void *AG::Graph::TraceRecorder::set_source(void *result, unsigned int a2)
{
  if ((result[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)result;
    unint64_t v4 = (unsigned int *)(AG::data::_shared_table_bytes + a2);
    unint64_t v6 = *v4;
    unint64_t v5 = v4[1];
    int v7 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v7);
    AG::Encoder::encode_varint(v7, 8uLL);
    AG::Encoder::encode_varint(v7, 0x2DuLL);
    AG::Encoder::encode_varint(v7, 0x18uLL);
    AG::Encoder::encode_varint(v7, a2 & 0xFFFFFFFE | 1);
    if (v6)
    {
      AG::Encoder::encode_varint(v7, 0x20uLL);
      AG::Encoder::encode_varint(v7, v6);
    }
    if (v5)
    {
      AG::Encoder::encode_varint(v7, 0x28uLL);
      AG::Encoder::encode_varint(v7, v5);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v7, 8);
    return AG::Encoder::end_length_delimited(v7);
  }
  return result;
}

void *AG::Graph::TraceRecorder::set_dependency(void *result, unsigned int a2)
{
  if ((result[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)result;
    unint64_t v4 = *(unsigned int *)(AG::data::_shared_table_bytes + a2 + 16);
    unint64_t v5 = (AG::Encoder *)(result + 4);
    AG::Encoder::encode_varint(result + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v5);
    AG::Encoder::encode_varint(v5, 8uLL);
    AG::Encoder::encode_varint(v5, 0x2EuLL);
    AG::Encoder::encode_varint(v5, 0x18uLL);
    AG::Encoder::encode_varint(v5, a2 & 0xFFFFFFFE | 1);
    if (v4)
    {
      AG::Encoder::encode_varint(v5, 0x20uLL);
      AG::Encoder::encode_varint(v5, v4);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v5, 8);
    return AG::Encoder::end_length_delimited(v5);
  }
  return result;
}

void *AG::Graph::TraceRecorder::set_deadline(void *this, unint64_t a2)
{
  if ((this[13] & 0x10) == 0)
  {
    uint64_t v3 = (AG::Graph::TraceRecorder *)this;
    unint64_t v4 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v4);
    AG::Encoder::encode_varint(v4, 8uLL);
    unint64_t v5 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v4, 0x37uLL);
    AG::Graph::TraceRecorder::field_timestamp(v5, v4);
    if (a2)
    {
      AG::Encoder::encode_varint(v4, 0x18uLL);
      AG::Encoder::encode_varint(v4, a2);
    }
    unint64_t v6 = HIDWORD(a2);
    if (v6)
    {
      AG::Encoder::encode_varint(v4, 0x20uLL);
      AG::Encoder::encode_varint(v4, v6);
    }
    AG::Graph::TraceRecorder::field_backtrace(v3, v4, 8);
    return AG::Encoder::end_length_delimited(v4);
  }
  return this;
}

void *AG::Graph::TraceRecorder::passed_deadline(void *this)
{
  if ((this[13] & 0x10) == 0)
  {
    unsigned int v1 = (AG::Graph::TraceRecorder *)this;
    unsigned int v2 = (AG::Encoder *)(this + 4);
    AG::Encoder::encode_varint(this + 4, 0xAuLL);
    AG::Encoder::begin_length_delimited(v2);
    AG::Encoder::encode_varint(v2, 8uLL);
    uint64_t v3 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v2, 0x38uLL);
    AG::Graph::TraceRecorder::field_timestamp(v3, v2);
    AG::Graph::TraceRecorder::field_backtrace(v1, v2, 8);
    AG::Encoder::end_length_delimited(v2);
    return AG::Graph::TraceRecorder::encode_stack(v1);
  }
  return this;
}

void *AG::Graph::TraceRecorder::mark_profile(AG::Graph::TraceRecorder *this, AG::Graph *a2, unsigned int a3)
{
  unint64_t v5 = (AG::Graph::TraceRecorder *)((char *)this + 32);
  AG::Encoder::encode_varint((void *)this + 4, 0xAuLL);
  AG::Encoder::begin_length_delimited(v5);
  AG::Encoder::encode_varint(v5, 8uLL);
  unint64_t v6 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v5, 0x32uLL);
  AG::Graph::TraceRecorder::field_timestamp(v6, v5);
  if (a3)
  {
    AG::Encoder::encode_varint(v5, 0x18uLL);
    AG::Encoder::encode_varint(v5, a3);
  }
  AG::Graph::TraceRecorder::field_backtrace(this, v5, 8);
  return AG::Encoder::end_length_delimited(v5);
}

void *AG::Graph::TraceRecorder::custom_event(void *a1, uint64_t a2, const char *a3)
{
  unint64_t v5 = (AG::Encoder *)(a1 + 4);
  AG::Encoder::encode_varint(a1 + 4, 0xAuLL);
  AG::Encoder::begin_length_delimited(v5);
  AG::Encoder::encode_varint(v5, 8uLL);
  unint64_t v6 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint(v5, 0x34uLL);
  AG::Graph::TraceRecorder::field_timestamp(v6, v5);
  AG::Graph::TraceRecorder::field_backtrace((AG::Graph::TraceRecorder *)a1, v5, 8);
  size_t v7 = strlen(a3);
  if (v7)
  {
    unint64_t v8 = v7;
    AG::Encoder::encode_varint(v5, 0x4AuLL);
    AG::Encoder::encode_data(v5, a3, v8);
  }
  return AG::Encoder::end_length_delimited(v5);
}

uint64_t AG::Graph::TraceRecorder::named_event(AG::Graph::TraceRecorder *this, AG::Graph::Context *a2, uint64_t a3, unint64_t a4, unsigned int *a5, const __CFData *a6, unsigned int a7)
{
  unsigned int v11 = a3;
  uint64_t result = AG::Graph::TraceRecorder::named_event_enabled(this, a3);
  if (!result) {
    return result;
  }
  unint64_t v14 = (AG::Graph::TraceRecorder *)((char *)this + 32);
  AG::Encoder::encode_varint((void *)this + 4, 0xAuLL);
  AG::Encoder::begin_length_delimited((void *)this + 4);
  AG::Encoder::encode_varint((void *)this + 4, 8uLL);
  uint64_t v15 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint((void *)this + 4, 0x36uLL);
  if (v11)
  {
    AG::Encoder::encode_varint((void *)this + 4, 0x50uLL);
    uint64_t v15 = (AG::Graph::TraceRecorder *)AG::Encoder::encode_varint((void *)this + 4, v11);
  }
  AG::Graph::TraceRecorder::field_timestamp(v15, (AG::Graph::TraceRecorder *)((char *)this + 32));
  if ((a7 & 0x80000000) != 0)
  {
    AG::Graph::TraceRecorder::field_backtrace(this, (AG::Graph::TraceRecorder *)((char *)this + 32), 8);
    a7 &= ~0x80000000;
    if (!a7) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if (a7)
  {
LABEL_6:
    AG::Encoder::encode_varint((void *)this + 4, 0x18uLL);
    AG::Encoder::encode_varint((void *)this + 4, a7);
  }
LABEL_7:
  uint64_t v16 = 4;
  if (a4 < 4) {
    uint64_t v16 = a4;
  }
  if (v16)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 8 * v16;
    do
    {
      unsigned int v20 = *a5++;
      unint64_t v19 = v20;
      if (v20)
      {
        AG::Encoder::encode_varint(v14, v17 + 32);
        AG::Encoder::encode_varint(v14, v19);
      }
      v17 += 8;
    }
    while (v18 != v17);
  }
  if (a6)
  {
    BytePtr = CFDataGetBytePtr(a6);
    CFIndex Length = CFDataGetLength(a6);
    if (Length)
    {
      unint64_t v23 = Length;
      AG::Encoder::encode_varint(v14, 0x4AuLL);
      AG::Encoder::encode_data(v14, BytePtr, v23);
    }
  }
  return (uint64_t)AG::Encoder::end_length_delimited(v14);
}

BOOL AG::Graph::TraceRecorder::named_event_enabled(AG::Graph::TraceRecorder *this, uint64_t a2)
{
  unint64_t v4 = (_DWORD *)*((void *)this + 68);
  unint64_t v5 = *((unsigned int *)this + 138);
  unint64_t v6 = &v4[2 * v5];
  if (v5)
  {
    do
    {
      unint64_t v7 = v5 >> 1;
      unint64_t v8 = &v4[2 * (v5 >> 1)];
      unsigned int v10 = *v8;
      unint64_t v9 = v8 + 2;
      v5 += ~(v5 >> 1);
      if (v10 < a2) {
        unint64_t v4 = v9;
      }
      else {
        unint64_t v5 = v7;
      }
    }
    while (v5);
    if (v4 != v6)
    {
      if (*v4 == a2) {
        return *((unsigned char *)v4 + 4) != 0;
      }
      unint64_t v6 = v4;
    }
  }
  uint64_t TraceEventName = AGGraphGetTraceEventName(a2);
  if (!TraceEventName) {
    AG::precondition_failure((AG *)"invalid named trace event: %u", v13, a2);
  }
  unint64_t v14 = (const char *)TraceEventName;
  TraceEventSubsystem = (const char *)AGGraphGetTraceEventSubsystem(a2);
  if (!TraceEventSubsystem) {
    goto LABEL_18;
  }
  unsigned int v16 = *((_DWORD *)this + 26);
  if ((v16 & 0x20) != 0) {
    goto LABEL_18;
  }
  int v17 = (v16 >> 5) & 1;
  uint64_t v18 = *((void *)this + 15);
  if (v18)
  {
    unint64_t v19 = (const char **)*((void *)this + 14);
    uint64_t v20 = 8 * v18;
    while (strcasecmp(*v19, TraceEventSubsystem))
    {
      ++v19;
      v20 -= 8;
      if (!v20) {
        goto LABEL_19;
      }
    }
LABEL_18:
    int v17 = 1;
  }
LABEL_19:
  uint64_t v21 = *((void *)this + 68);
  unint64_t v22 = ((uint64_t)v6 - v21) >> 3;
  unsigned int v23 = *((_DWORD *)this + 138);
  if (*((_DWORD *)this + 139) < v23 + 1)
  {
    AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow((uint64_t)this + 544, v23 + 1);
    uint64_t v21 = *((void *)this + 68);
    unsigned int v23 = *((_DWORD *)this + 138);
  }
  if (v23 > v22)
  {
    memmove((void *)(v21 + 8 * v22 + 8), (const void *)(v21 + 8 * v22), 8 * (v23 - v22));
    unsigned int v23 = *((_DWORD *)this + 138);
  }
  uint64_t v24 = v21 + 8 * v22;
  *(_DWORD *)uint64_t v24 = a2;
  *(unsigned char *)(v24 + 4) = v17;
  *((_DWORD *)this + 138) = v23 + 1;
  if (!v17) {
    return 0;
  }
  uint64_t v25 = (AG::Graph::TraceRecorder *)((char *)this + 32);
  AG::Encoder::encode_varint(v25, 0x32uLL);
  AG::Encoder::begin_length_delimited(v25);
  if (a2)
  {
    AG::Encoder::encode_varint(v25, 8uLL);
    AG::Encoder::encode_varint(v25, a2);
  }
  size_t v26 = strlen(v14);
  if (v26)
  {
    unint64_t v27 = v26;
    AG::Encoder::encode_varint(v25, 0x12uLL);
    AG::Encoder::encode_data(v25, v14, v27);
  }
  if (TraceEventSubsystem)
  {
    size_t v28 = strlen(TraceEventSubsystem);
    if (v28)
    {
      unint64_t v29 = v28;
      AG::Encoder::encode_varint(v25, 0x1AuLL);
      AG::Encoder::encode_data(v25, TraceEventSubsystem, v29);
    }
  }
  AG::Encoder::end_length_delimited(v25);
  return 1;
}

uint64_t AG::Graph::start_tracing(uint64_t result, char a2)
{
  if ((a2 & 1) != 0 && !*(void *)(result + 320)) {
    operator new();
  }
  return result;
}

void sub_1AF91B570(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10F1C40EB2A2F89);
  _Unwind_Resume(a1);
}

uint64_t AG::Graph::prepare_trace(uint64_t a1, uint64_t a2)
{
  uint64_t v41 = a2;
  uint64_t result = util::UntypedTable::for_each(a1 + 144, (void (*)(const void *, const void *, const void *))util::Table<unsigned long,AG::Graph::Context *>::for_each<AG::Graph::prepare_trace(AG::Trace &)::$_0>(AG::Graph::prepare_trace(AG::Trace &)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke, &v41);
  uint64_t v36 = a1;
  uint64_t v5 = *(unsigned int *)(a1 + 352);
  if (v5)
  {
    unint64_t v6 = 0;
    while (1)
    {
      if (v6 > 3) {
        return result;
      }
      unint64_t v7 = *(void **)(v36 + 344);
      uint64_t v37 = &v7[v5];
      do
      {
        uint64_t v8 = *v7;
        unint64_t v38 = v7;
        if (v6 == 1)
        {
          uint64_t v9 = *(unsigned int *)(v8 + 72);
          if (v9)
          {
            unsigned int v10 = *(uint64_t **)(v8 + 64);
            uint64_t v11 = 8 * v9;
            do
            {
              uint64_t v12 = *v10++;
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)a2 + 208))(a2, v8, v12 & 0xFFFFFFFFFFFFFFFCLL);
              v11 -= 8;
            }
            while (v11);
          }
          goto LABEL_53;
        }
        if (!v6)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 184))(a2, v8);
          goto LABEL_53;
        }
        char v13 = 1;
        uint64_t v39 = *v7;
        do
        {
          char v40 = v13;
          unsigned int v14 = *(_DWORD *)(v8 + 16);
          if (!v14) {
            goto LABEL_52;
          }
          uint64_t v15 = AG::data::_shared_table_bytes;
          while (2)
          {
            uint64_t v16 = v14;
            uint64_t v17 = v15 + v14;
            uint64_t v18 = 20;
            if (v40) {
              uint64_t v18 = 22;
            }
            int v19 = *(unsigned __int16 *)(v17 + v18);
            if (!*(_WORD *)(v17 + v18)) {
              goto LABEL_51;
            }
            do
            {
              uint64_t v20 = (v19 + v16);
              int v21 = ((_BYTE)v19 + (_BYTE)v16) & 3;
              if ((((_BYTE)v19 + (_BYTE)v16) & 3) != 0)
              {
                if (v21 != 1)
                {
                  if (v21 == 2)
                  {
                    int v35 = 1;
                    goto LABEL_50;
                  }
                  continue;
                }
                uint64_t v22 = AG::data::_shared_table_bytes;
                unsigned int v23 = (unsigned __int16 *)(AG::data::_shared_table_bytes + (v20 & 0xFFFFFFFC) + 14);
              }
              else
              {
                uint64_t v22 = AG::data::_shared_table_bytes;
                unsigned int v23 = (unsigned __int16 *)(AG::data::_shared_table_bytes + v20 + 4);
              }
              int v19 = *v23;
              if ((v20 & 3) == 1)
              {
                uint64_t v26 = v20 & 0xFFFFFFFC;
                if (v6 == 3)
                {
                  uint64_t v33 = v22 + v26;
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a2 + 296))(a2, v26, *(unsigned int *)(v22 + v26));
                  if ((*(unsigned char *)(v33 + 8) & 1) != 0 && *(_DWORD *)(v33 + 16)) {
                    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 304))(a2, v26);
                  }
                }
                else
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 288))(a2, v26);
                }
              }
              else
              {
                if ((v20 & 3) != 0) {
                  continue;
                }
                uint64_t v24 = (int *)(v22 + v20);
                if (v6 != 3)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 224))(a2, v20);
                  int v25 = *v24;
                  if (*v24)
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 256))(a2, v20, 1);
                    int v25 = *v24;
                    if ((*v24 & 2) == 0) {
                      goto LABEL_29;
                    }
                  }
                  else if ((v25 & 2) == 0)
                  {
LABEL_29:
                    if ((v25 & 0x10) == 0) {
                      continue;
                    }
                    goto LABEL_44;
                  }
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 264))(a2, v20, 1);
                  if ((*v24 & 0x10) == 0) {
                    continue;
                  }
LABEL_44:
                  uint64_t v34 = (void *)(AG::data::_shared_table_bytes + v24[2]);
                  if ((*((unsigned char *)v24 + 7) & 2) != 0) {
                    uint64_t v34 = (void *)*v34;
                  }
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)a2 + 272))(a2, v20, v34);
                  continue;
                }
                unint64_t v27 = v24[3];
                if (v27 >= 0x20)
                {
                  uint64_t v28 = 0;
                  uint64_t v29 = v24[4];
                  unint64_t v30 = v27 >> 5;
                  uint64_t v31 = (char *)(v22 + v29 + 4);
                  do
                  {
                    char v32 = *v31;
                    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)a2 + 232))(a2, v20, *((unsigned int *)v31 - 1), *v31 & 4);
                    if ((v32 & 8) != 0) {
                      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 248))(a2, v20, v28, 1);
                    }
                    v31 += 5;
                    ++v28;
                  }
                  while (v30 != v28);
                }
              }
            }
            while (v19);
            int v35 = 0;
LABEL_50:
            uint64_t v15 = AG::data::_shared_table_bytes;
            if (!v35)
            {
LABEL_51:
              unsigned int v14 = *(_DWORD *)(v15 + v16 + 8);
              if (!v14) {
                break;
              }
              continue;
            }
            break;
          }
LABEL_52:
          char v13 = 0;
          uint64_t v8 = v39;
        }
        while ((v40 & 1) != 0);
LABEL_53:
        unint64_t v7 = v38 + 1;
      }
      while (v38 + 1 != v37);
      uint64_t v5 = *(unsigned int *)(v36 + 352);
      do
        ++v6;
      while (!*(_DWORD *)(v36 + 352));
    }
  }
  return result;
}

uint64_t ___ZN2AG5Graph13start_tracingEjNSt3__14spanIPKcLm18446744073709551615EEE_block_invoke()
{
  return atexit_b(&__block_literal_global_14);
}

void ___ZN2AG5Graph13start_tracingEjNSt3__14spanIPKcLm18446744073709551615EEE_block_invoke_2(uint64_t a1, uint64_t a2, const char *a3)
{
}

void AG::Graph::trace_assertion_failure(AG::Graph *this, uint64_t a2, const char *a3, ...)
{
  va_start(va, a3);
  int v4 = (int)this;
  BOOL v5 = os_unfair_lock_trylock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  for (uint64_t i = AG::Graph::_all_graphs; i; uint64_t i = *(void *)i)
  {
    int v7 = *(_DWORD *)(i + 232);
    if (v7)
    {
      unsigned int v9 = v7 - 1;
      do
      {
        uint64_t v10 = *(void *)(*(void *)(i + 224) + 8 * v9);
        uint64_t v11 = v9;
        (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v10 + 40))(v10, a2, (uint64_t *)va);
        --v9;
      }
      while (v11);
    }
    if (v4)
    {
      uint64_t v8 = *(void *)(i + 320);
      if (v8)
      {
        AG::Graph::remove_trace((_DWORD *)i, *(void *)(v8 + 8));
        *(void *)(i + 320) = 0;
      }
    }
  }
  if (v5) {
    os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  }
}

_DWORD *AG::Graph::stop_tracing(_DWORD *this)
{
  uint64_t v1 = *((void *)this + 40);
  if (v1)
  {
    unsigned int v2 = this;
    this = AG::Graph::remove_trace(this, *(void *)(v1 + 8));
    *((void *)v2 + 40) = 0;
  }
  return this;
}

uint64_t AG::Graph::sync_tracing(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 232);
  if (v1)
  {
    uint64_t v2 = this;
    unsigned int v3 = v1 - 1;
    do
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(*(void *)(v2 + 224) + 8 * v3);
      this = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
      --v3;
    }
    while (v4);
  }
  return this;
}

CFStringRef AG::Graph::copy_trace_path(AG::Graph *this)
{
  uint64_t v1 = *((void *)this + 40);
  if (v1 && (uint64_t v2 = *(const char **)(v1 + 520)) != 0) {
    return CFStringCreateWithCString(0, v2, 0x8000100u);
  }
  else {
    return 0;
  }
}

void AG::Graph::all_start_tracing(char a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  for (uint64_t i = &AG::Graph::_all_graphs; ; AG::Graph::start_tracing((uint64_t)i, a1))
  {
    uint64_t i = (uint64_t *)*i;
    if (!i) {
      break;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
}

void sub_1AF91BCB0(_Unwind_Exception *a1)
{
}

void AG::Graph::all_stop_tracing(AG::Graph *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  for (uint64_t i = AG::Graph::_all_graphs; i; uint64_t i = *(void *)i)
  {
    uint64_t v2 = *(void *)(i + 320);
    if (v2)
    {
      AG::Graph::remove_trace((_DWORD *)i, *(void *)(v2 + 8));
      *(void *)(i + 320) = 0;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
}

void sub_1AF91BD38(_Unwind_Exception *a1)
{
}

void AG::Graph::all_sync_tracing(AG::Graph *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  for (uint64_t i = &AG::Graph::_all_graphs; ; AG::Graph::sync_tracing((uint64_t)i))
  {
    uint64_t i = (uint64_t *)*i;
    if (!i) {
      break;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
}

void sub_1AF91BDAC(_Unwind_Exception *a1)
{
}

CFStringRef AG::Graph::all_copy_trace_path(AG::Graph *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  if (AG::Graph::_all_graphs
    && (uint64_t v1 = *(void *)(AG::Graph::_all_graphs + 320)) != 0
    && (uint64_t v2 = *(const char **)(v1 + 520)) != 0)
  {
    CFStringRef v3 = CFStringCreateWithCString(0, v2, 0x8000100u);
  }
  else
  {
    CFStringRef v3 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  return v3;
}

void sub_1AF91BE38(_Unwind_Exception *a1)
{
}

void AG::Trace::~Trace(AG::Trace *this)
{
}

uint64_t AG::Trace::named_event_enabled(AG::Trace *this)
{
  return 0;
}

void *AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,8ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,8ul>(void *a1, size_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(8 * a3);
    size_t v6 = v5 >> 3;
    if (v5 >> 3 != *a2)
    {
      int v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t util::Table<unsigned long,AG::Graph::Context *>::for_each<AG::Graph::prepare_trace(AG::Trace &)::$_0>(AG::Graph::prepare_trace(AG::Trace &)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(**(void **)a3 + 160))();
}

void AG::data::table::print(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 4;
  os_unfair_lock_lock(this + 4);
  LODWORD(v3) = this[8];
  fprintf((FILE *)*MEMORY[0x1E4F143C8], "data::table %p:\n  %.2fKB allocated, %.2fKB used, %.2fKB reusable.\n", this, (double)(this[5]._os_unfair_lock_opaque - 512) * 0.0009765625, (double)(this[7]._os_unfair_lock_opaque << 9) * 0.0009765625, (double)v3 * 0.0009765625);
  os_unfair_lock_unlock(v2);
}

uint64_t AG::data::zone::print(const void ***this)
{
  uint64_t v2 = *((unsigned int *)this + 4);
  uint64_t v3 = 0;
  if (v2)
  {
    uint64x2_t v4 = 0uLL;
    do
    {
      uint64_t v5 = AG::data::_shared_table_bytes + v2;
      ++v3;
      uint64x2_t v4 = vaddw_u32(v4, *(uint32x2_t *)(v5 + 12));
      uint64_t v2 = *(unsigned int *)(v5 + 8);
    }
    while (v2);
    float64x2_t v6 = vmulq_f64(vcvtq_f64_u64(v4), (float64x2_t)vdupq_n_s64(0x3F50000000000000uLL));
  }
  else
  {
    float64x2_t v6 = 0uLL;
  }
  uint64_t v7 = *((unsigned int *)this + 2);
  if (v7)
  {
    float64x2_t v18 = v6;
    unint64_t v8 = 0;
    unsigned int v9 = *this;
    uint64_t v10 = 8 * v7;
    do
    {
      uint64_t v11 = *v9++;
      v8 += malloc_size(v11);
      v10 -= 8;
    }
    while (v10);
    double v12 = (double)v8 * 0.0009765625;
    float64x2_t v6 = v18;
  }
  else
  {
    double v12 = 0.0;
  }
  uint64_t v13 = *((unsigned int *)this + 5);
  if (v13)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    do
    {
      ++v15;
      uint64_t v16 = AG::data::_shared_table_bytes + v13;
      uint64_t v13 = *(unsigned int *)(AG::data::_shared_table_bytes + v13);
      v14 += *(unsigned int *)(v16 + 4);
    }
    while (v13);
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v14 = 0;
  }
  return fprintf((FILE *)*MEMORY[0x1E4F143C8], "%-16p %6lu %8.2f %8.2f    %6lu %6lu     %6lu %8.2f\n", this, v3, v6.f64[0], v6.f64[1], v15, v14, *((unsigned int *)this + 2), v12);
}

uint64_t AG::data::zone::print_header(AG::data::zone *this)
{
  return fprintf((FILE *)*MEMORY[0x1E4F143C8], "Zones\n%-16s %6s %8s %8s    %6s %6s     %6s %8s\n", "zone ptr", "pages", "total", "in-use", "free", "bytes", "malloc", "total");
}

uint64_t AG::swift::context_descriptor::generic_params_info::generic_params_info(uint64_t a1, AG::swift::class_type_descriptor *this, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  if ((*(_DWORD *)this & 0x80) != 0)
  {
    int v4 = *(_DWORD *)this & 0x1F;
    if ((v4 - 19) >= 0xFFFFFFFE)
    {
      uint64_t v5 = (char *)this + 28;
      *(void *)a1 = (char *)this + 28;
      uint64_t v6 = a3 + 16;
      if (!a3) {
        uint64_t v6 = 0;
      }
    }
    else
    {
      if (v4 != 16) {
        return a1;
      }
      uint64_t v5 = (char *)this + 44;
      *(void *)a1 = (char *)this + 44;
      if (a3) {
        uint64_t v6 = a3 + 8 * AG::swift::class_type_descriptor::immediate_members_offset(this);
      }
      else {
        uint64_t v6 = 0;
      }
    }
    *(void *)(a1 + 48) = v6;
    uint64_t v7 = *((unsigned __int16 *)v5 + 4);
    if (*((_WORD *)v5 + 4))
    {
      *(void *)(a1 + 8) = v5 + 16;
      *(void *)(a1 + 16) = v7;
      if (v5[14])
      {
        unint64_t v8 = (int *)(((unint64_t)&v5[v7 + 19] & 0xFFFFFFFFFFFFFFFCLL) + 12 * *((unsigned __int16 *)v5 + 5));
        int v9 = *v8;
        *(_DWORD *)(a1 + 24) = *v8;
        *(void *)(a1 + 32) = v8 + 1;
        *(void *)(a1 + 40) = (unsigned __int16)v9;
      }
    }
  }
  return a1;
}

uint64_t AG::swift::context_descriptor::push_generic_args(AG::swift::class_type_descriptor *this, uint64_t a2, void *a3)
{
  uint64_t result = AG::swift::context_descriptor::generic_params_info::generic_params_info((uint64_t)v20, this, a2);
  uint64_t v5 = v22;
  if (v22)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v21;
    uint64_t v8 = v23;
    while (1)
    {
      int v9 = *v7;
      if (v9 < 0) {
        break;
      }
LABEL_21:
      ++v7;
      if (!--v5) {
        return result;
      }
    }
    char v10 = v9 & 0x3F;
    if ((v9 & 0x3F) == 1)
    {
      uint64_t v16 = *(void *)(v25 + 8 * v8);
      if (v16)
      {
        unint64_t v17 = v16 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v15 = *(void *)(v25 + 8 * *(unsigned __int16 *)(v24 + 8 * v6 + 4));
      }
      else
      {
        uint64_t v15 = 0;
        unint64_t v17 = 0;
      }
      uint64_t v18 = a3[25];
      if (a3[26] < (unint64_t)(v18 + 1))
      {
        uint64_t result = (uint64_t)AG::vector<AG::swift::context_descriptor::generic_arg,8ul,unsigned long>::reserve_slow(a3, v18 + 1);
        uint64_t v18 = a3[25];
      }
      ++v6;
      int v19 = (void *)a3[24];
      if (!v19) {
        int v19 = a3;
      }
      uint64_t v14 = &v19[3 * v18];
      *uint64_t v14 = v17;
    }
    else
    {
      if ((v9 & 0x3F) != 0)
      {
LABEL_20:
        ++v8;
        goto LABEL_21;
      }
      uint64_t v11 = v25;
      uint64_t v12 = a3[25];
      if (a3[26] < (unint64_t)(v12 + 1))
      {
        uint64_t result = (uint64_t)AG::vector<AG::swift::context_descriptor::generic_arg,8ul,unsigned long>::reserve_slow(a3, v12 + 1);
        uint64_t v12 = a3[25];
      }
      uint64_t v13 = (void *)a3[24];
      if (!v13) {
        uint64_t v13 = a3;
      }
      uint64_t v14 = &v13[3 * v12];
      *uint64_t v14 = v11 + 8 * v8;
      uint64_t v15 = 1;
    }
    v14[1] = v15;
    *((unsigned char *)v14 + 16) = v10;
    ++a3[25];
    goto LABEL_20;
  }
  return result;
}

uint64_t AG::swift::context_descriptor::count_generic_args(AG::swift::context_descriptor *this)
{
  AG::swift::context_descriptor::generic_params_info::generic_params_info((uint64_t)v5, this, 0);
  uint64_t v1 = v7;
  if (!v7) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v3 = v6;
  do
  {
    char v4 = *v3++;
    if ((v4 & 0xBE) == 0x80) {
      ++result;
    }
    --v1;
  }
  while (v1);
  return result;
}

uint64_t AG::swift::metadata::visit_heap_class(AG::swift::metadata *this, AG::swift::metadata_visitor *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!this) {
    goto LABEL_22;
  }
  if ((*((void *)this + 4) & 3) == 0) {
    goto LABEL_22;
  }
  uint64_t v5 = (uint64_t *)((char *)this + 64);
  uint64_t v4 = *((void *)this + 8);
  if (!v4) {
    goto LABEL_22;
  }
  uint64_t v6 = *((void *)this + 8);
  if (*(_DWORD *)(v4 + 20))
  {
    uint64_t v7 = (AG::swift::metadata *)*((void *)this + 1);
    if (v7)
    {
      if ((unint64_t)(*(void *)v7 - 2048) >= 0xFFFFFFFFFFFFF801) {
        goto LABEL_22;
      }
      if (!AG::swift::metadata::visit_heap_class(v7, a2)) {
        return 0;
      }
    }
  }
  uint64_t v8 = v6 + 16;
  uint64_t v9 = *(int *)(v6 + 16);
  if (!v9) {
    return 1;
  }
  if ((v9 & 3) != 1)
  {
    uint64_t v10 = v9 + v8;
    if (v9 + v8) {
      goto LABEL_13;
    }
    return 1;
  }
  uint64_t v10 = *(void *)((v9 & 0xFFFFFFFFFFFFFFFCLL) + v8);
  if (!v10) {
    return 1;
  }
LABEL_13:
  int v11 = *(_DWORD *)(v10 + 12);
  if (!v11) {
    return 1;
  }
  if (v11 == *(_DWORD *)(v6 + 36))
  {
    if ((*((unsigned char *)this + 40) & 2) == 0)
    {
      HIDWORD(v28) = 0;
      uint64_t v12 = class_copyIvarList(this, (unsigned int *)&v28 + 1);
      uint64_t v13 = v12;
      if (v12)
      {
        int v14 = HIDWORD(v28);
        if (HIDWORD(v28) == *(_DWORD *)(v10 + 12))
        {
          MEMORY[0x1F4188790](v12);
          uint64_t v16 = (char *)&v28 - ((v15 + 15) & 0xFFFFFFFF0);
          bzero(v16, v15);
          if (v14)
          {
            unint64_t v17 = 0;
            do
            {
              *(void *)&v16[8 * v17] = ivar_getOffset(v13[v17]);
              ++v17;
            }
            while (v17 < HIDWORD(v28));
          }
        }
        else
        {
          uint64_t v16 = 0;
        }
        free(v13);
      }
      else
      {
        uint64_t v16 = 0;
      }
LABEL_40:
      if (v16 && *(void *)v16)
      {
        unint64_t v24 = 0;
        uint64_t v25 = v10 + 16;
        do
        {
          unint64_t v26 = *(unsigned int *)(v10 + 12);
          BOOL v20 = v24 >= v26;
          if (v24 >= v26) {
            break;
          }
          char v27 = (*(uint64_t (**)(AG::swift::metadata_visitor *, AG::swift::metadata *, uint64_t))(*(void *)a2 + 16))(a2, this, v25);
          v25 += 12;
          ++v24;
        }
        while ((v27 & 1) != 0);
        return v20;
      }
      return (**(uint64_t (***)(AG::swift::metadata_visitor *))a2)(a2);
    }
    uint64_t v21 = *v5;
    if (*v5)
    {
      unsigned int v22 = *(_DWORD *)(v21 + 40);
      if (!v22) {
        return (**(uint64_t (***)(AG::swift::metadata_visitor *))a2)(a2);
      }
    }
    else
    {
      unsigned int v22 = MEMORY[0x28];
      if (!MEMORY[0x28]) {
        return (**(uint64_t (***)(AG::swift::metadata_visitor *))a2)(a2);
      }
      uint64_t v21 = 0;
    }
    if ((*(unsigned char *)(v21 + 3) & 0x20) != 0) {
      unint64_t v23 = ((unint64_t)AG::swift::class_type_descriptor::immediate_members_offset((AG::swift::class_type_descriptor *)v21) >> 3)
    }
          + v22;
    else {
      unint64_t v23 = v22;
    }
    uint64_t v16 = (char *)this + 8 * v23;
    goto LABEL_40;
  }
LABEL_22:
  uint64_t v18 = **(uint64_t (***)(AG::swift::metadata_visitor *))a2;
  return v18(a2);
}

void sub_1AF91C870(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void AG::swift::metadata::append_description(AG::swift::metadata *this, __CFString *a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  while (1)
  {
    uint64_t v4 = *(void *)this;
    if (*(void *)this > 0x7FFuLL) {
      uint64_t v4 = 0;
    }
    if (v4 != 770) {
      break;
    }
    CFStringAppendCString(a2, "(", 0x8000100u);
    if (*((_WORD *)this + 4))
    {
      uint64_t v5 = 0;
      uint64_t v6 = 8 * *((unsigned __int16 *)this + 4);
      do
      {
        uint64_t v7 = *(AG::swift::metadata **)((char *)this + v5 + 24);
        if (v5) {
          CFStringAppendCString(a2, ", ", 0x8000100u);
        }
        if (v7) {
          AG::swift::metadata::append_description(v7, a2);
        }
        else {
          CFStringAppendCString(a2, "nil", 0x8000100u);
        }
        v5 += 8;
      }
      while (v6 != v5);
    }
    CFStringAppendCString(a2, ")", 0x8000100u);
    this = (AG::swift::metadata *)*((void *)this + 2);
    CFStringAppendCString(a2, " -> ", 0x8000100u);
    if (!this)
    {
      uint64_t v8 = "nil";
LABEL_80:
      CFStringAppendCString(a2, v8, 0x8000100u);
      return;
    }
  }
  if (v4 == 769)
  {
    if (*((void *)this + 1))
    {
      CFStringAppendCString(a2, "(", 0x8000100u);
      if (*((void *)this + 1))
      {
        unint64_t v9 = 0;
        uint64_t v10 = (AG::swift::metadata **)((char *)this + 24);
        do
        {
          int v11 = *v10;
          if (v9) {
            CFStringAppendCString(a2, ", ", 0x8000100u);
          }
          if (v11) {
            AG::swift::metadata::append_description(v11, a2);
          }
          else {
            CFStringAppendCString(a2, "nil", 0x8000100u);
          }
          ++v9;
          v10 += 2;
        }
        while (v9 < *((void *)this + 1));
      }
      uint64_t v8 = ")";
    }
    else
    {
      uint64_t v8 = "Void";
    }
    goto LABEL_80;
  }
  int v48 = 0;
  size_t v49 = 0;
  unint64_t v50 = 8;
  uint64_t v12 = AG::swift::metadata::descriptor(this);
  if (!v12) {
    goto LABEL_43;
  }
  uint64_t v13 = (int *)v12;
  size_t v14 = 0;
  while (1)
  {
    if ((*v13 & 0x1Fu) - 19 >= 0xFFFFFFFE || (*v13 & 0x1F) == 0x10)
    {
      size_t v15 = v13 + 2;
      uint64_t v16 = v13[2];
      if (v16)
      {
        unint64_t v17 = (char *)v15 + v16;
        if ((int *)((char *)v15 + v16))
        {
          uint64_t v18 = AG::swift::context_descriptor::count_generic_args((AG::swift::context_descriptor *)v13);
          size_t v19 = v49;
          size_t v14 = v49 + 1;
          if (v50 < v49 + 1)
          {
            AG::vector<std::pair<char const*,unsigned long>,8ul,unsigned long>::reserve_slow(__dst, v14);
            size_t v19 = v49;
            size_t v14 = v49 + 1;
          }
          BOOL v20 = v48;
          if (!v48) {
            BOOL v20 = __dst;
          }
          uint64_t v21 = &v20[16 * v19];
          *uint64_t v21 = v17;
          v21[1] = v18;
          size_t v49 = v14;
        }
      }
    }
    uint64_t v24 = v13[1];
    unint64_t v23 = v13 + 1;
    uint64_t v22 = v24;
    if (!v24) {
      break;
    }
    if ((v22 & 3) == 1)
    {
      if (!*(void *)((char *)v23 + (v22 & 0xFFFFFFFFFFFFFFFCLL))) {
        break;
      }
      uint64_t v13 = *(int **)((char *)v23 + (v22 & 0xFFFFFFFFFFFFFFFCLL));
    }
    else
    {
      uint64_t v13 = (int *)((char *)v23 + v22);
      if (!v13) {
        break;
      }
    }
  }
  if (!v14)
  {
LABEL_43:
    uint64_t TypeName = swift_getTypeName();
    if (TypeName)
    {
      size_t v26 = v49;
      size_t v27 = v49 + 1;
      if (v50 < v49 + 1)
      {
        AG::vector<std::pair<char const*,unsigned long>,8ul,unsigned long>::reserve_slow(__dst, v27);
        size_t v26 = v49;
        size_t v27 = v49 + 1;
      }
      uint64_t v28 = v48;
      if (!v48) {
        uint64_t v28 = __dst;
      }
      uint64_t v29 = (uint64_t *)&v28[16 * v26];
      *uint64_t v29 = TypeName;
      v29[1] = 0;
      size_t v49 = v27;
    }
  }
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 8;
  unint64_t v30 = (AG::swift::class_type_descriptor *)AG::swift::metadata::descriptor(this);
  if (v30) {
    AG::swift::context_descriptor::push_generic_args(v30, (uint64_t)this, v43);
  }
  size_t v31 = v49;
  if (v49)
  {
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    while (1)
    {
      --v31;
      uint64_t v34 = v48;
      if (!v48) {
        uint64_t v34 = __dst;
      }
      int v35 = &v34[16 * v31];
      uint64_t v42 = *((void *)v35 + 1);
      CFStringAppendCString(a2, *(const char **)v35, 0x8000100u);
      if (v42 != v32)
      {
        CFStringAppendCString(a2, "<", 0x8000100u);
        size_t v41 = v31;
        uint64_t v36 = 0;
        uint64_t v37 = v42 - v32;
        do
        {
          if (v36) {
            CFStringAppendCString(a2, ", ", 0x8000100u);
          }
          unint64_t v38 = (char *)v44;
          if (!v44) {
            unint64_t v38 = (char *)v43;
          }
          uint64_t v39 = &v38[24 * v36 + 24 * v33];
          if (v39[16]) {
            CFStringAppendCString(a2, "Pack{", 0x8000100u);
          }
          if (*((void *)v39 + 1))
          {
            unint64_t v40 = 0;
            do
            {
              if (v40) {
                CFStringAppendCString(a2, ", ", 0x8000100u);
              }
              AG::swift::metadata::append_description(*(AG::swift::metadata **)(*(void *)v39 + 8 * v40++), a2);
            }
            while (v40 < *((void *)v39 + 1));
          }
          if (v39[16]) {
            CFStringAppendCString(a2, "}", 0x8000100u);
          }
          ++v36;
        }
        while (v36 != v37);
        CFStringAppendCString(a2, ">", 0x8000100u);
        size_t v31 = v41;
        v33 += v37;
      }
      if (!v31) {
        break;
      }
      CFStringAppendCString(a2, ".", 0x8000100u);
      uint64_t v32 = v42;
    }
  }
  if (v44) {
    free(v44);
  }
  if (v48) {
    free(v48);
  }
}

void sub_1AF91CE3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54)
{
  if (a54) {
    free(a54);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *AG::swift::metadata::signature(AG::swift::metadata *this)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  {
    operator new();
  }
  uint64_t v2 = AG::swift::metadata::signature(void)const::cache;
  os_unfair_lock_lock((os_unfair_lock_t)AG::swift::metadata::signature(void)const::cache);
  uint64_t v3 = *(util::UntypedTable **)(v2 + 8);
  __dst[0] = 0;
  uint64_t v4 = (unsigned __int8 *)util::UntypedTable::lookup(v3, (uint64_t *)this, __dst);
  uint64_t v5 = __dst[0];
  os_unfair_lock_unlock((os_unfair_lock_t)v2);
  if (!v5)
  {
    uint64_t v45 = 0;
    unint64_t v46 = 8;
    size_t v41 = 0;
    unint64_t v40 = 0;
    unint64_t v42 = 8;
    uint64_t v37 = 0;
    uint64_t v36 = 0;
    uint64_t v38 = 8;
    uint64_t v6 = 1;
    uint64_t v44 = 0;
    uint64_t v29 = this;
    v43[0] = this;
    do
    {
      uint64_t v7 = v44;
      if (!v44) {
        uint64_t v7 = v43;
      }
      uint64_t v8 = (AG::swift::metadata *)v7[--v6];
      uint64_t v45 = v6;
      uint64_t v37 = 0;
      unint64_t v9 = (AG::swift::class_type_descriptor *)AG::swift::metadata::descriptor(v8);
      if (v9)
      {
        uint64_t v10 = v9;
        AG::swift::context_descriptor::push_generic_args(v9, (uint64_t)v8, v35);
        size_t v11 = v41;
        size_t v12 = v41 + 1;
        if (v42 < v41 + 1)
        {
          AG::vector<AG::swift::metadata const*,8ul,unsigned long>::reserve_slow(v39, v12);
          size_t v11 = v41;
          size_t v12 = v41 + 1;
        }
        uint64_t v13 = v40;
        if (!v40) {
          uint64_t v13 = v39;
        }
        *(void *)&v13[8 * v11] = v10;
        size_t v41 = v12;
        if (v36) {
          size_t v14 = (char *)v36;
        }
        else {
          size_t v14 = (char *)v35;
        }
        if (v37)
        {
          size_t v15 = &v14[24 * v37];
          do
          {
            uint64_t v16 = *((void *)v14 + 1);
            if (v16)
            {
              unint64_t v17 = *(uint64_t **)v14;
              size_t v18 = v45;
              uint64_t v19 = 8 * v16;
              do
              {
                uint64_t v20 = *v17;
                size_t v21 = v18 + 1;
                if (v46 < v18 + 1)
                {
                  AG::vector<AG::swift::metadata const*,8ul,unsigned long>::reserve_slow(v43, v21);
                  size_t v18 = v45;
                  size_t v21 = v45 + 1;
                }
                uint64_t v22 = v44;
                if (!v44) {
                  uint64_t v22 = v43;
                }
                v22[v18] = v20;
                uint64_t v45 = v21;
                ++v17;
                size_t v18 = v21;
                v19 -= 8;
              }
              while (v19);
            }
            v14 += 24;
          }
          while (v14 != v15);
        }
        uint64_t v6 = v45;
      }
    }
    while (v6);
    if (v41)
    {
      CC_SHA1_Init(&c);
      unint64_t v23 = v29;
      CC_SHA1_Update(&c, "AGTypeSignature", 0xFu);
      uint64_t v32 = 0;
      size_t v33 = 0;
      uint64_t v34 = 8;
      size_t v24 = v41;
      if (v41 > 8) {
        AG::vector<dyld_image_uuid_offset,8ul,unsigned long>::reserve_slow(__dst, v41);
      }
      size_t v33 = v24;
      _dyld_images_for_addresses();
      if (v32) {
        uint64_t v25 = (char *)v32;
      }
      else {
        uint64_t v25 = (char *)__dst;
      }
      if (v33)
      {
        size_t v26 = &v25[32 * v33];
        do
        {
          CC_SHA1_Update(&c, v25, 0x10u);
          size_t v27 = v25 + 16;
          CC_SHA1_Update(&c, v27, 8u);
          uint64_t v25 = v27 + 16;
        }
        while (v25 != v26);
      }
      uint64_t v4 = (unsigned __int8 *)malloc_type_malloc(0x14uLL, 0x862E07FFuLL);
      CC_SHA1_Final(v4, &c);
      if (v32) {
        free(v32);
      }
    }
    else
    {
      uint64_t v4 = 0;
      unint64_t v23 = v29;
    }
    os_unfair_lock_lock((os_unfair_lock_t)v2);
    util::UntypedTable::insert(*(util::UntypedTable **)(v2 + 8), v23, v4);
    os_unfair_lock_unlock((os_unfair_lock_t)v2);
    if (v36) {
      free(v36);
    }
    if (v40) {
      free(v40);
    }
    if (v44) {
      free(v44);
    }
  }
  return v4;
}

void sub_1AF91D21C(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x1020C40D5A9D86FLL);
  _Unwind_Resume(a1);
}

void AG::swift::anonymous namespace'::TypeSignatureCache::TypeSignatureCache(AG::swift::_anonymous_namespace_::TypeSignatureCache *this)
{
  *(_DWORD *)this = 0;
  operator new();
}

void sub_1AF91D324(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10A0C405E99A6A3);
  _Unwind_Resume(a1);
}

uint64_t AG::swift::metadata::copy_on_write_heap_object(AG::swift::metadata *this, void **a2)
{
  uint64_t result = swift_isUniquelyReferencedNonObjC();
  if ((result & 1) == 0)
  {
    uint64_t v5 = (uint64_t)*a2;
    unint64_t v6 = (*(unsigned __int8 *)(*((void *)this - 1) + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(*((void *)this - 1) + 80);
    uint64_t v7 = (char *)swift_allocObject();
    if (*((void *)this - 1)) {
      uint64_t v8 = *((void *)this - 1);
    }
    else {
      uint64_t v8 = 0;
    }
    (*(void (**)(char *, unint64_t, AG::swift::metadata *))(v8 + 16))(&v7[v6], v5 + v6, this);
    uint64_t result = swift_release();
    *a2 = v7;
  }
  return result;
}

uint64_t AG::swift::class_type_descriptor::immediate_members_offset(AG::swift::class_type_descriptor *this)
{
  if ((*(_DWORD *)this & 0x20000000) != 0)
  {
    uint64_t v4 = *((int *)this + 6);
    uint64_t v2 = (char *)this + 24;
    uint64_t v3 = v4;
    if ((v4 & 7) == 1) {
      uint64_t v5 = *(char **)&v2[v3 & 0xFFFFFFFFFFFFFFF8];
    }
    else {
      uint64_t v5 = &v2[v3];
    }
    return *(void *)v5 >> 3;
  }
  else if ((*(_DWORD *)this & 0x10000000) != 0)
  {
    return -(uint64_t)*((unsigned int *)this + 6);
  }
  else
  {
    return (*((_DWORD *)this + 7) - *((_DWORD *)this + 8));
  }
}

uint64_t AG::swift::existential_type_metadata::representation(AG::swift::existential_type_metadata *this)
{
  int v1 = *((_DWORD *)this + 2);
  if ((v1 & 0x3F000000) != 0) {
    return 2;
  }
  else {
    return v1 >= 0;
  }
}

uint64_t AG::swift::metadata_visitor::visit_element(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t AG::swift::metadata_visitor::visit_case(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t AG::swift::metadata_visitor::visit_existential(AG::swift::metadata_visitor *this, const AG::swift::existential_type_metadata *a2)
{
  return (**(uint64_t (***)(AG::swift::metadata_visitor *))this)(this);
}

uint64_t AG::swift::metadata_visitor::visit_function(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t AG::swift::metadata_visitor::visit_native_object(AG::swift::metadata_visitor *this, const AG::swift::metadata *a2)
{
  return (**(uint64_t (***)(AG::swift::metadata_visitor *))this)(this);
}

void *AG::vector<dyld_image_uuid_offset,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 34) + (*((void *)__dst + 34) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 34) + (*((void *)__dst + 34) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,32ul>(*((void **)__dst + 32), __dst, 8uLL, (size_t *)__dst + 34, v3);
  *((void *)__dst + 32) = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,32ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, 32 * a5);
      free(v7);
      size_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(32 * a5);
    size_t v9 = v8 >> 5;
    if (v8 >> 5 != *a4)
    {
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x8734B07FuLL);
      if (!v10) {
        AG::precondition_failure((AG *)"allocation failure", v11);
      }
      size_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 32 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void *AG::vector<AG::swift::context_descriptor::generic_arg,8ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  if (*((void *)__dst + 26) + (*((void *)__dst + 26) >> 1) <= a2) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = *((void *)__dst + 26) + (*((void *)__dst + 26) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,24ul>(*((void **)__dst + 24), __dst, 8uLL, (unint64_t *)__dst + 26, v3);
  *((void *)__dst + 24) = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,24ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      unint64_t v9 = a3;
      memcpy(__dst, __src, 24 * a5);
      free(v7);
      size_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(24 * a5);
    unint64_t v9 = v8 / 0x18;
    if (v8 / 0x18 != *a4)
    {
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x8734B07FuLL);
      if (!v10) {
        AG::precondition_failure((AG *)"allocation failure", v11);
      }
      size_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 24 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t AGNewTupleType(uint64_t a1, uint64_t a2)
{
  if (a1 == 1) {
    return *(void *)a2;
  }
  uint64_t result = swift_getTupleTypeMetadata();
  if (v3) {
    AG::precondition_failure((AG *)"invalid tuple type.", v3);
  }
  return result;
}

uint64_t AGTupleSize(uint64_t a1)
{
  return *(void *)(*(void *)(a1 - 8) + 64);
}

uint64_t AGTupleElementSize(void *a1, const char *a2)
{
  if (*a1 != 769)
  {
    if (!a2) {
      return *(void *)(*(a1 - 1) + 64);
    }
LABEL_6:
    AG::precondition_failure((AG *)"index out of range: %d", a2, a2);
  }
  if (a1[1] <= (unint64_t)a2) {
    goto LABEL_6;
  }
  a1 = (void *)a1[2 * (void)a2 + 3];
  return *(void *)(*(a1 - 1) + 64);
}

uint64_t AGTupleElementOffsetChecked(void *a1, const char *a2, void *a3)
{
  if (*a1 == 769)
  {
    if (a1[1] > (unint64_t)a2)
    {
      unint64_t v3 = &a1[2 * (void)a2];
      if ((void *)v3[3] == a3) {
        return v3[4];
      }
LABEL_10:
      AG::precondition_failure((AG *)"element type mismatch", a2);
    }
LABEL_9:
    AG::precondition_failure((AG *)"index out of range: %d", a2, a2);
  }
  if (a2) {
    goto LABEL_9;
  }
  if (a1 != a3) {
    goto LABEL_10;
  }
  return 0;
}

uint64_t AGTupleSetElement(AG::swift::metadata *a1, char *a2, unint64_t a3, const char *a4, AG::swift::metadata *a5, uint64_t a6)
{
  if (*(void *)a1 == 769)
  {
    if (*((void *)a1 + 1) > a3)
    {
      unint64_t v6 = (void *)((char *)a1 + 16 * a3);
      a1 = (AG::swift::metadata *)v6[3];
      a2 += v6[4];
      goto LABEL_5;
    }
LABEL_9:
    AG::precondition_failure((AG *)"index out of range: %d", a2, a3);
  }
  if (a3) {
    goto LABEL_9;
  }
LABEL_5:
  if (a1 != a5) {
    AG::precondition_failure((AG *)"element type mismatch", a2);
  }
  return update(a2, a4, a5, a6);
}

uint64_t update(void *a1, const char *a2, const AG::swift::metadata *a3, uint64_t a4)
{
  if (*((void *)a3 - 1)) {
    uint64_t v4 = (void *)*((void *)a3 - 1);
  }
  else {
    uint64_t v4 = 0;
  }
  switch((int)a4)
  {
    case 0:
      uint64_t v5 = (uint64_t (*)(void *, const char *))v4[3];
      break;
    case 1:
      uint64_t v5 = (uint64_t (*)(void *, const char *))v4[2];
      break;
    case 2:
      uint64_t v5 = (uint64_t (*)(void *, const char *))v4[5];
      break;
    case 3:
      uint64_t v5 = (uint64_t (*)(void *, const char *))v4[4];
      break;
    default:
      AG::precondition_failure((AG *)"unknown copy options: %d", a2, a4);
  }
  return v5(a1, a2);
}

uint64_t AGTupleGetElement(AG::swift::metadata *a1, const char *a2, unint64_t a3, void *a4, AG::swift::metadata *a5, uint64_t a6)
{
  if (*(void *)a1 == 769)
  {
    if (*((void *)a1 + 1) > a3)
    {
      unint64_t v6 = (void *)((char *)a1 + 16 * a3);
      a1 = (AG::swift::metadata *)v6[3];
      a2 += v6[4];
      goto LABEL_5;
    }
LABEL_9:
    AG::precondition_failure((AG *)"index out of range: %d", a2, a3);
  }
  if (a3) {
    goto LABEL_9;
  }
LABEL_5:
  if (a1 != a5) {
    AG::precondition_failure((AG *)"element type mismatch", a2);
  }
  return update(a4, a2, a5, a6);
}

uint64_t AGTupleDestroy(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 - 8)) {
    uint64_t v2 = *(void *)(a1 - 8);
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(a2, a1);
}

uint64_t AGTupleDestroyElement(void *a1, const char *a2, unint64_t a3)
{
  unint64_t v3 = a1;
  if (*a1 != 769)
  {
    if (!a3)
    {
      if (*(a1 - 1)) {
        uint64_t v6 = *(a1 - 1);
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t v7 = *(uint64_t (**)(const char *, void *))(v6 + 8);
      size_t v8 = a2;
      goto LABEL_12;
    }
LABEL_15:
    AG::precondition_failure((AG *)"index out of range: %d", a2, a3);
  }
  if (a1[1] <= a3) {
    goto LABEL_15;
  }
  uint64_t v4 = &a1[2 * a3];
  unint64_t v3 = (void *)v4[3];
  if (*(v3 - 1)) {
    uint64_t v5 = *(void *)(v4[3] - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(const char *, void *))(v5 + 8);
  size_t v8 = &a2[v4[4]];
LABEL_12:
  return v7(v8, v3);
}

util::Heap *util::InlineHeap<8192ul>::~InlineHeap(util::Heap *a1)
{
  return a1;
}

unint64_t AG::Graph::UpdateStack::global_top(unint64_t this)
{
  if (this)
  {
    while (1)
    {
      unint64_t v1 = this & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v2 = *(void *)((this & 0xFFFFFFFFFFFFFFFELL) + 104);
      if (v2) {
        break;
      }
      this = *(void *)(v1 + 16);
      if (!this) {
        return this;
      }
    }
    unint64_t v3 = v1 + 32;
    unint64_t v4 = *(void *)(v1 + 96);
    if (!v4) {
      unint64_t v4 = v3;
    }
    return v4 + 8 * v2 - 8;
  }
  return this;
}

void AG::Graph::UpdateStack::cancel(AG::Graph::UpdateStack *this)
{
  uint64_t v1 = AG::Graph::_current_update_key;
  uint64_t v2 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v1);
  if (v2)
  {
    while (1)
    {
      unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v4 = *(void *)(v3 + 104);
      if (v4) {
        break;
      }
LABEL_8:
      if ((*(unsigned char *)(v3 + 120) & 2) == 0)
      {
        uint64_t v2 = *(void *)(v3 + 16);
        if (v2) {
          continue;
        }
      }
      return;
    }
    unint64_t v5 = v3 + 32;
    if (*(void *)(v3 + 96)) {
      unint64_t v5 = *(void *)(v3 + 96);
    }
    uint64_t v6 = (_DWORD *)(v5 + 8 * v4 - 4);
    while ((*v6 & 8) == 0)
    {
      *v6 |= 8u;
      v6 -= 2;
      if (!--v4) {
        goto LABEL_8;
      }
    }
  }
}

void AG::Graph::UpdateStack::~UpdateStack(AG::Graph::UpdateStack *this, const char *a2)
{
  unint64_t v3 = (unsigned int *)((char *)this + 32);
  uint64_t v4 = *((void *)this + 13);
  if (*((void *)this + 12)) {
    unint64_t v3 = (unsigned int *)*((void *)this + 12);
  }
  if (v4)
  {
    uint64_t v5 = AG::data::_shared_table_bytes;
    uint64_t v6 = 8 * v4;
    do
    {
      unsigned int v7 = *v3;
      v3 += 2;
      *(_DWORD *)(v5 + v7) -= 64;
      v6 -= 8;
    }
    while (v6);
  }
  uint64_t v8 = *(void *)this;
  if (*((void *)this + 1) != *(void *)(*(void *)this + 416))
  {
    AG::non_fatal_precondition_failure((AG *)"invalid graph update (access from multiple threads?)", a2);
    uint64_t v8 = *(void *)this;
  }
  *(void *)(v8 + 416) = *((void *)this + 3);
  uint64_t v9 = *((void *)this + 2);
  uint64_t v10 = AG::Graph::_current_update_key;
  *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10) = v9;
  if ((*((unsigned char *)this + 120) & 0x10) != 0) {
    *(unsigned char *)(*(void *)this + 408) = 0;
  }
  size_t v11 = (void *)*((void *)this + 12);
  if (v11) {
    free(v11);
  }
}

void *AG::Graph::collect_stack(uint64_t a1, void *a2)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  for (uint64_t i = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2); i; uint64_t i = *(void *)(v5 + 16))
  {
    unint64_t v5 = i & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v6 = *(void *)((i & 0xFFFFFFFFFFFFFFFELL) + 104);
    if (v6)
    {
      unint64_t v7 = a2[1];
      uint64_t v8 = 8 * v6 - 8;
      do
      {
        if (*(void *)(v5 + 96)) {
          unint64_t v9 = *(void *)(v5 + 96);
        }
        else {
          unint64_t v9 = v5 + 32;
        }
        unint64_t v10 = v7 + 1;
        if (a2[2] < v7 + 1)
        {
          uint64_t result = AG::vector<AG::data::ptr<AG::Node>,0ul,unsigned long>::reserve_slow((uint64_t)a2, v10);
          unint64_t v7 = a2[1];
          unint64_t v10 = v7 + 1;
        }
        *(_DWORD *)(*a2 + 4 * v7) = *(_DWORD *)(v9 + v8);
        a2[1] = v10;
        v8 -= 8;
        unint64_t v7 = v10;
        --v6;
      }
      while (v6);
    }
  }
  return result;
}

uint64_t AG::Graph::UpdateStack::cancelled(uint64_t this)
{
  if (this)
  {
    while (1)
    {
      unint64_t v1 = this & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v2 = *(void *)((this & 0xFFFFFFFFFFFFFFFELL) + 104);
      if (v2) {
        break;
      }
      this = *(void *)(v1 + 16);
      if (!this) {
        return this;
      }
    }
    unint64_t v3 = v1 + 32;
    unint64_t v4 = *(void *)(v1 + 96);
    if (!v4) {
      unint64_t v4 = v3;
    }
    return (*(unsigned __int8 *)(v4 + 8 * v2 - 4) >> 3) & 1;
  }
  return this;
}

void AG::Graph::print_stack(AG::Graph *this)
{
  uint64_t v1 = AG::Graph::_current_update_key;
  uint64_t v2 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v1);
  if (v2)
  {
    int v3 = -1;
    uint64_t v4 = v2;
    do
    {
      ++v3;
      uint64_t v4 = *(void *)((v4 & 0xFFFFFFFFFFFFFFFELL) + 16);
    }
    while (v4);
    unint64_t v5 = (FILE **)MEMORY[0x1E4F143C8];
    do
    {
      unint64_t v20 = v2 & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v6 = *(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 104);
      if (v6)
      {
        uint64_t v7 = 8 * v6;
        do
        {
          --v6;
          unint64_t v8 = *(void *)(v20 + 96);
          if (!v8) {
            unint64_t v8 = v20 + 32;
          }
          unint64_t v9 = v8 + v7;
          uint64_t v11 = *(unsigned int *)(v9 - 8);
          unsigned int v10 = *(_DWORD *)(v9 - 4);
          size_t v12 = *v5;
          int v13 = *(_DWORD *)(AG::data::_shared_table_bytes + v11);
          int v14 = v13 >> 6;
          unsigned int v15 = v10 >> 4;
          if (v10) {
            uint64_t v16 = "P";
          }
          else {
            uint64_t v16 = "";
          }
          if ((v10 & 8) != 0) {
            unint64_t v17 = "C";
          }
          else {
            unint64_t v17 = "";
          }
          if (v13) {
            size_t v18 = "D";
          }
          else {
            size_t v18 = "";
          }
          if ((v13 & 0x10) != 0) {
            uint64_t v19 = "V";
          }
          else {
            uint64_t v19 = "";
          }
          fprintf(v12, "frame %d.%d: attribute %u; count=%d, index=%d/%d %s%s%s%s\n",
            v3,
            v6,
            v11,
            v14,
            v15,
            *(_DWORD *)(AG::data::_shared_table_bytes + v11 + 12) >> 5,
            v16,
            v17,
            v18,
            v19);
          unint64_t v5 = (FILE **)MEMORY[0x1E4F143C8];
          v7 -= 8;
        }
        while (v6);
      }
      uint64_t v2 = *(void *)(v20 + 16);
      --v3;
    }
    while (v2);
  }
}

uint64_t AG::Graph::update_attribute(AG::data::ptr<AG::Node>,unsigned int)::$_0::__invoke(uint64_t a1)
{
  uint64_t v2 = *(AG::Graph::UpdateStack **)a1;
  uint64_t v3 = AG::Graph::_current_update_key;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v5 = *(void *)(StatusReg + 8 * v3);
  *(void *)(StatusReg + 8 * v3) = v2;
  uint64_t result = AG::Graph::UpdateStack::update(*(AG::Graph::UpdateStack **)a1);
  *(_DWORD *)(a1 + 8) = result;
  *(void *)(StatusReg + 8 * AG::Graph::_current_update_key) = v5;
  return result;
}

void sub_1AF91E0DC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8 * *v2) = v3;
  _Unwind_Resume(a1);
}

void *AG::vector<AG::data::ptr<AG::Node>,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,4ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,4ul>(void *a1, size_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(4 * a3);
    size_t v6 = v5 >> 2;
    if (v5 >> 2 != *a2)
    {
      uint64_t v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *AG::Graph::ProfileTrace::begin_update(void *result, unint64_t a2)
{
  if (*(unsigned char *)(*(void *)a2 + 296))
  {
    uint64_t v3 = result;
    uint64_t v4 = mach_absolute_time();
    unint64_t v5 = a2;
    size_t v6 = &v5;
    uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)(v3 + 2), &v5, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6);
    result[4] = 0;
    result[5] = 0;
    result[3] = v4;
  }
  return result;
}

uint64_t *AG::Graph::ProfileTrace::end_update(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = (void *)(a1 + 16);
  unint64_t v8 = a2;
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>((void *)(a1 + 16), &v8);
  if (result)
  {
    uint64_t v5 = result[3];
    uint64_t result = (uint64_t *)std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::erase(v3, result);
    if (v5)
    {
      unint64_t v6 = *(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFELL;
      if (v6)
      {
        if (*(unsigned char *)(*(void *)v6 + 296))
        {
          unint64_t v8 = v6;
          uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>(v3, &v8);
          if (result)
          {
            uint64_t v7 = result;
            if (*(unsigned char *)(*(void *)v6 + 296)) {
              uint64_t result = (uint64_t *)mach_absolute_time();
            }
            else {
              uint64_t result = 0;
            }
            v7[4] += (uint64_t)result - v5;
          }
        }
      }
    }
  }
  return result;
}

uint64_t AG::Graph::ProfileTrace::begin_update(uint64_t a1)
{
  uint64_t v1 = AG::Graph::_current_update_key;
  uint64_t v2 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v1);
  if (v2) {
    unint64_t v3 = 0;
  }
  else {
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
  }
  unint64_t v6 = v3;
  uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>((void *)(a1 + 16), &v6);
  if (result)
  {
    uint64_t v5 = result;
    if (*(unsigned char *)(*(void *)v3 + 296)) {
      uint64_t result = mach_absolute_time();
    }
    else {
      uint64_t result = 0;
    }
    *(void *)(v5 + 40) = result;
  }
  return result;
}

char *AG::Graph::ProfileTrace::end_update(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v5 = AG::Graph::_current_update_key;
  uint64_t v6 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
  if (v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = (char **)(v6 & 0xFFFFFFFFFFFFFFFELL);
  }
  size_t v18 = v7;
  uint64_t result = (char *)std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>((void *)(a1 + 16), (unint64_t *)&v18);
  if (result)
  {
    unint64_t v9 = result;
    uint64_t v10 = *((void *)result + 5);
    if (v10)
    {
      uint64_t v11 = *v7;
      if (v11[296])
      {
        uint64_t v12 = mach_absolute_time();
        uint64_t v10 = *((void *)v9 + 5);
      }
      else
      {
        uint64_t v12 = 0;
      }
      uint64_t v13 = v12 - v10;
      uint64_t v14 = *((void *)v9 + 4);
      BOOL v15 = v13 >= v14;
      unint64_t v16 = v13 - v14;
      if (v15) {
        unint64_t v17 = v16;
      }
      else {
        unint64_t v17 = 0;
      }
      *((void *)v9 + 4) = 0;
      return AG::Graph::add_profile_update(v11, a2, v17, a3);
    }
  }
  return result;
}

char *AG::Graph::add_profile_update(char *result, unsigned int a2, unint64_t a3, int a4)
{
  if (result[296])
  {
    uint64_t v4 = *((void *)result + 38);
    if (!v4) {
      operator new();
    }
    if (a3 >= *(void *)v4) {
      uint64_t v5 = a3 - *(void *)v4;
    }
    else {
      uint64_t v5 = 0;
    }
    uint64_t result = AG::Graph::ProfileData::Category::add_update((void *)(v4 + 8), a2, v5, a4);
    *(unsigned char *)(v4 + 184) = 1;
  }
  return result;
}

void sub_1AF91E4BC(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10A0C40A5AAE56ELL);
  _Unwind_Resume(a1);
}

int64x2_t *AG::Graph::ProfileData::Item::operator+=(int64x2_t *a1, int64x2_t *a2)
{
  int64x2_t v3 = vaddq_s64(a1[1], a2[1]);
  *a1 = vaddq_s64(*a1, *a2);
  a1[1] = v3;
  uint64_t v4 = a2[2].i64[1];
  if (v4)
  {
    uint64_t v5 = a2[2].i64[0];
    uint64_t v6 = v5 + 48 * v4;
    unint64_t v8 = (int64x2_t *)a1[2].i64[0];
    unint64_t v7 = a1[2].u64[1];
    unint64_t v9 = v8;
    do
    {
      uint64_t v10 = &v8[3 * v7];
      if (v9 == v10) {
        goto LABEL_10;
      }
      unint64_t v11 = *(void *)(v5 + 8);
      while (1)
      {
        unint64_t v12 = v9->u64[1];
        if (v12 >= v11) {
          break;
        }
        v9 += 3;
        if (v9 == v10)
        {
          unint64_t v9 = &v8[3 * v7];
          goto LABEL_10;
        }
      }
      if (v12 != v11)
      {
LABEL_10:
        uint64_t v14 = (uint64_t)v8;
        if (a1[3].i64[0] < v7 + 1)
        {
          AG::vector<AG::Graph::ProfileData::Mark,0ul,unsigned long>::reserve_slow((uint64_t)a1[2].i64, v7 + 1);
          uint64_t v14 = a1[2].i64[0];
          unint64_t v7 = a1[2].u64[1];
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (v9 - v8);
        BOOL v16 = v7 > v15;
        unint64_t v17 = v7 - v15;
        if (v16) {
          memmove((void *)(v14 + 48 * v15 + 48), (const void *)(v14 + 48 * v15), 48 * v17);
        }
        uint64_t v18 = 3 * v15;
        uint64_t v19 = (_OWORD *)(v14 + 48 * v15);
        long long v20 = *(_OWORD *)v5;
        long long v21 = *(_OWORD *)(v5 + 32);
        v19[1] = *(_OWORD *)(v5 + 16);
        v19[2] = v21;
        *uint64_t v19 = v20;
        unint64_t v8 = (int64x2_t *)a1[2].i64[0];
        unint64_t v7 = a1[2].i64[1] + 1;
        a1[2].i64[1] = v7;
        unint64_t v9 = &v8[v18 + 3];
      }
      else
      {
        int64x2_t v13 = vaddq_s64(v9[2], *(int64x2_t *)(v5 + 32));
        v9[1] = vaddq_s64(v9[1], *(int64x2_t *)(v5 + 16));
        void v9[2] = v13;
      }
      v5 += 48;
    }
    while (v5 != v6);
  }
  return a1;
}

double AG::Graph::ProfileData::Item::mark(AG::Graph::ProfileData::Item *this, int a2, uint64_t a3)
{
  if (*(void *)this)
  {
    uint64_t v6 = *((void *)this + 5);
    if (*((void *)this + 6) < (unint64_t)(v6 + 1))
    {
      AG::vector<AG::Graph::ProfileData::Mark,0ul,unsigned long>::reserve_slow((uint64_t)this + 32, v6 + 1);
      uint64_t v6 = *((void *)this + 5);
    }
    uint64_t v7 = *((void *)this + 4) + 48 * v6;
    long long v9 = *(_OWORD *)this;
    long long v8 = *((_OWORD *)this + 1);
    *(_DWORD *)uint64_t v7 = a2;
    *(void *)(v7 + 8) = a3;
    *(_OWORD *)(v7 + 16) = v9;
    *(_OWORD *)(v7 + 32) = v8;
    ++*((void *)this + 5);
    double result = 0.0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
  }
  return result;
}

char *AG::Graph::ProfileData::Category::add_update(void *a1, unsigned int a2, uint64_t a3, int a4)
{
  unsigned int v7 = a2;
  ++*a1;
  a1[2] += a3;
  if (a4)
  {
    ++a1[1];
    a1[3] += a3;
  }
  long long v8 = &v7;
  double result = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node> const&>,std::tuple<>>((uint64_t)(a1 + 7), &v7, (uint64_t)&std::piecewise_construct, &v8);
  ++*((void *)result + 3);
  *((void *)result + 5) += a3;
  if (a4)
  {
    ++*((void *)result + 4);
    *((void *)result + 6) += a3;
  }
  return result;
}

AG::Graph::ProfileData *AG::Graph::ProfileData::ProfileData(AG::Graph::ProfileData *this, const AG::Graph *a2)
{
  *(_OWORD *)((char *)this + 8) = 0u;
  *((void *)this + 11) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 24) = 1065353216;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 1065353216;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 44) = 1065353216;
  *((unsigned char *)this + 184) = 0;
  *(void *)this = 0;
  uint64_t v3 = mach_absolute_time();
  uint64_t v4 = 16;
  do
  {
    uint64_t v5 = mach_absolute_time();
    uint64_t v6 = v5 - v3 + *(void *)this;
    *(void *)this = v6;
    uint64_t v3 = v5;
    --v4;
  }
  while (v4);
  *(void *)this = v6 >> 4;
  return this;
}

void sub_1AF91E838(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>>>::~__hash_table(v2);
  AG::Graph::ProfileData::Category::~Category(v1);
  _Unwind_Resume(a1);
}

void AG::Graph::ProfileData::Category::~Category(AG::Graph::ProfileData::Category *this)
{
  std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::~__hash_table((uint64_t)this + 96);
  std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::~__hash_table((uint64_t)this + 56);
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2) {
    free(v2);
  }
}

void AG::Graph::ProfileData::Category::mark(AG::Graph::ProfileData::Category *this, int a2, uint64_t a3)
{
  AG::Graph::ProfileData::Item::mark(this, a2, a3);
  for (uint64_t i = (void *)*((void *)this + 9); i; uint64_t i = (void *)*i)
    AG::Graph::ProfileData::Item::mark((AG::Graph::ProfileData::Item *)(i + 3), a2, a3);
  for (uint64_t j = (void *)*((void *)this + 14); j; uint64_t j = (void *)*j)
    AG::Graph::ProfileData::Item::mark((AG::Graph::ProfileData::Item *)(j + 3), a2, a3);
}

uint64_t AG::Graph::ProfileData::remove_node(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v13 = a2;
  unsigned int v14 = a3;
  uint64_t v4 = (void *)(a1 + 64);
  uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>((void *)(a1 + 64), &v13);
  if (result)
  {
    uint64_t v6 = (uint64_t *)result;
    unsigned int v7 = (int64x2_t *)(result + 24);
    unint64_t v15 = &v14;
    long long v8 = std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a1 + 104, &v14, (uint64_t)&std::piecewise_construct, &v15);
    AG::Graph::ProfileData::Item::operator+=((int64x2_t *)(v8 + 24), v7);
    uint64_t result = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::erase(v4, v6);
  }
  for (uint64_t i = *(void **)(a1 + 160); i; uint64_t i = (void *)*i)
  {
    uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(i + 10, &v13);
    if (result)
    {
      uint64_t v10 = (uint64_t *)result;
      unint64_t v11 = (int64x2_t *)(result + 24);
      unint64_t v15 = &v14;
      unint64_t v12 = std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)(i + 15), &v14, (uint64_t)&std::piecewise_construct, &v15);
      AG::Graph::ProfileData::Item::operator+=((int64x2_t *)(v12 + 24), v11);
      uint64_t result = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::erase(i + 10, v10);
    }
  }
  return result;
}

void AG::Graph::start_profiling(AG::Graph *this, char a2)
{
  int v3 = a2 & 1;
  *((unsigned char *)this + 296) = a2 & 1;
  if ((a2 & 2) != 0)
  {
    if (NSClassFromString(&cfstr_Uiapplication.isa))
    {
      uint64_t v4 = [MEMORY[0x1E4F28EB8] defaultCenter];
      uint64_t v5 = objc_opt_class();
      [v4 addObserver:v5 selector:sel_background_ name:@"UIApplicationDidEnterBackgroundNotification" object:0];
      [v4 addObserver:v5 selector:sel_foreground_ name:@"UIApplicationWillEnterForegroundNotification" object:0];
    }
    CFRunLoopRef Main = CFRunLoopGetMain();
    if (Main)
    {
      unsigned int v7 = Main;
      long long v8 = CFRunLoopObserverCreate(0, 0xA0uLL, 1u, 2500000, (CFRunLoopObserverCallBack)AG::Graph::start_profiling::$_0::__invoke<__CFRunLoopObserver *,unsigned long,void *>, 0);
      if (v8) {
        CFRunLoopAddObserver(v7, v8, (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
      }
    }
    int v3 = *((unsigned __int8 *)this + 296);
  }
  if (v3)
  {
    if (!*((void *)this + 39)) {
      operator new();
    }
  }
}

void sub_1AF91EBB8(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10A1C404A7C5E8ELL);
  _Unwind_Resume(a1);
}

_DWORD *AG::Graph::stop_profiling(_DWORD *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 39);
  if (v2)
  {
    this = AG::Graph::remove_trace(this, *(void *)(v2 + 8));
    *((void *)v1 + 39) = 0;
  }
  *((unsigned char *)v1 + 296) = 0;
  return this;
}

void AG::Graph::reset_profile(AG::Graph *this)
{
  uint64_t v1 = *((void *)this + 38);
  *((void *)this + 38) = 0;
  if (v1) {
    std::default_delete<AG::Graph::ProfileData>::operator()[abi:ne180100]((uint64_t)this + 304, v1);
  }
}

void AG::Graph::mark_profile(AG::Graph *this, uint64_t a2, uint64_t a3)
{
  int v6 = *((_DWORD *)this + 58);
  if (v6)
  {
    unsigned int v10 = v6 - 1;
    do
    {
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)(*((void *)this + 28) + 8 * v10);
      (*(void (**)(uint64_t, AG::Graph *, uint64_t))(*(void *)v12 + 328))(v12, this, a2);
      --v10;
    }
    while (v11);
  }
  uint64_t v7 = *((void *)this + 38);
  if (v7 && *(unsigned char *)(v7 + 184))
  {
    if (!a3)
    {
      a3 = mach_absolute_time();
      uint64_t v7 = *((void *)this + 38);
    }
    AG::Graph::ProfileData::Category::mark((AG::Graph::ProfileData::Category *)(v7 + 8), a2, a3);
    uint64_t v8 = *((void *)this + 38);
    long long v9 = *(void **)(v8 + 160);
    if (v9)
    {
      do
      {
        AG::Graph::ProfileData::Category::mark((AG::Graph::ProfileData::Category *)(v9 + 3), a2, a3);
        long long v9 = (void *)*v9;
      }
      while (v9);
      uint64_t v8 = *((void *)this + 38);
    }
    *(unsigned char *)(v8 + 184) = 0;
  }
}

void AG::Graph::all_start_profiling(AG::Graph *this)
{
  char v1 = (char)this;
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  for (uint64_t i = (AG::Graph *)&AG::Graph::_all_graphs; ; AG::Graph::start_profiling(i, v1))
  {
    uint64_t i = *(AG::Graph **)i;
    if (!i) {
      break;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
}

void sub_1AF91ED98(_Unwind_Exception *a1)
{
}

void AG::Graph::all_stop_profiling(AG::Graph *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  for (uint64_t i = AG::Graph::_all_graphs; i; uint64_t i = *(void *)i)
  {
    uint64_t v2 = *(void *)(i + 312);
    if (v2)
    {
      AG::Graph::remove_trace((_DWORD *)i, *(void *)(v2 + 8));
      *(void *)(i + 312) = 0;
    }
    *(unsigned char *)(i + 296) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
}

void sub_1AF91EE24(_Unwind_Exception *a1)
{
}

void AG::Graph::all_reset_profile(AG::Graph *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  char v1 = (void *)AG::Graph::_all_graphs;
  if (AG::Graph::_all_graphs)
  {
    do
    {
      uint64_t v2 = v1[38];
      v1[38] = 0;
      if (v2) {
        std::default_delete<AG::Graph::ProfileData>::operator()[abi:ne180100]((uint64_t)(v1 + 38), v2);
      }
      char v1 = (void *)*v1;
    }
    while (v1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
}

void AG::Graph::all_mark_profile(AG::Graph *this, const char *a2)
{
  uint64_t v3 = mach_absolute_time();
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  for (uint64_t i = (AG::Graph *)&AG::Graph::_all_graphs; ; AG::Graph::mark_profile(i, (uint64_t)v5, v3))
  {
    uint64_t i = *(AG::Graph **)i;
    if (!i) {
      break;
    }
    uint64_t v5 = AG::Graph::intern_key(i, (char *)this);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
}

void sub_1AF91EF2C(_Unwind_Exception *a1)
{
}

uint64_t AG::Graph::begin_profile_event(AG::Graph *this, unsigned int a2, char *a3)
{
  int v4 = *((_DWORD *)this + 58);
  if (v4)
  {
    uint64_t v7 = a2;
    unsigned int v8 = v4 - 1;
    do
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(*((void *)this + 28) + 8 * v8);
      uint64_t v11 = AG::Graph::intern_key(this, a3);
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v10 + 144))(v10, v7, v11);
      --v8;
    }
    while (v9);
  }
  if (!*((unsigned char *)this + 296)) {
    return 0;
  }
  return mach_absolute_time();
}

void *AG::Graph::end_profile_event(uint64_t a1, unsigned int a2, char *a3, uint64_t a4, int a5)
{
  uint64_t result = AG::Graph::intern_key((AG::Graph *)a1, a3);
  uint64_t v10 = result;
  if (*(unsigned char *)(a1 + 296))
  {
    if (!*(void *)(a1 + 304)) {
      operator new();
    }
    uint64_t v11 = mach_absolute_time();
    uint64_t v12 = *(void *)(a1 + 304);
    unsigned int v19 = v10;
    if (v11 - a4 >= *(void *)v12) {
      uint64_t v13 = v11 - a4 - *(void *)v12;
    }
    else {
      uint64_t v13 = 0;
    }
    long long v20 = &v19;
    unsigned int v14 = std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v12 + 144, &v19, (uint64_t)&std::piecewise_construct, &v20);
    uint64_t result = AG::Graph::ProfileData::Category::add_update(v14 + 3, a2, v13, a5);
    *(unsigned char *)(v12 + 184) = 1;
  }
  int v15 = *(_DWORD *)(a1 + 232);
  if (v15)
  {
    unsigned int v16 = v15 - 1;
    do
    {
      uint64_t v17 = v16;
      uint64_t v18 = *(void *)(*(void *)(a1 + 224) + 8 * v16);
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t, void, void *))(*(void *)v18 + 152))(v18, a2, v10);
      --v16;
    }
    while (v17);
  }
  return result;
}

void sub_1AF91F160(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10A0C40A5AAE56ELL);
  _Unwind_Resume(a1);
}

void AG::Graph::ProfileTrace::~ProfileTrace(AG::Graph::ProfileTrace *this)
{
  *(void *)this = &unk_1F0813E88;
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)this + 16);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0813E88;
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)this + 16);
  JUMPOUT(0x1B3E84B80);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      int v4 = (void *)v2[7];
      if (v4) {
        free(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  int v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

char *std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = *((void *)v11 + 1);
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v13 = (void *)(a1 + 16);
  uint64_t v11 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((void *)v11 + 9) = 0;
  *(_OWORD *)(v11 + 56) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  long long v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *(void *)uint64_t v11 = *v21;
LABEL_38:
    *long long v21 = v11;
    goto LABEL_39;
  }
  *(void *)uint64_t v11 = *v13;
  *uint64_t v13 = v11;
  *(void *)(v20 + 8 * v4) = v13;
  if (*(void *)v11)
  {
    unint64_t v22 = *(void *)(*(void *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    long long v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1AF91F5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      uint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *uint64_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    uint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v3 = (void *)__p[7];
    if (v3) {
      free(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  std::string __p = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

void *std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::remove@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  uint64_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    uint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *uint64_t v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void AG::Graph::start_profiling(unsigned int)::$_0::__invoke<__CFRunLoopObserver *,unsigned long,void *>(uint64_t a1, const char *a2)
{
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (*((_DWORD *)i + 4) == v7) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t v13 = a1 + 16;
  float v14 = (char *)operator new(0xA0uLL);
  v24[0] = v14;
  v24[1] = a1 + 16;
  *(void *)float v14 = 0;
  *((void *)v14 + 1) = v7;
  *((_DWORD *)v14 + 4) = **a4;
  *(_OWORD *)(v14 + 104) = 0u;
  *((void *)v14 + 19) = 0;
  *(_OWORD *)(v14 + 136) = 0u;
  *(_OWORD *)(v14 + 120) = 0u;
  *(_OWORD *)(v14 + 88) = 0u;
  *(_OWORD *)(v14 + 72) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 24) = 0u;
  *((_DWORD *)v14 + 28) = 1065353216;
  *((_DWORD *)v14 + 38) = 1065353216;
  char v25 = 1;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  long long v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *(void *)v24[0] = *v21;
    *long long v21 = v24[0];
  }
  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24[0];
    *(void *)(*(void *)a1 + 8 * v4) = v13;
    if (*(void *)v24[0])
    {
      unint64_t v22 = *(void *)(*(void *)v24[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v22 >= v8) {
          v22 %= v8;
        }
      }
      else
      {
        v22 &= v8 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v22) = v24[0];
    }
  }
  uint64_t i = (uint64_t *)v24[0];
  v24[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,void *>>>>::reset[abi:ne180100]((uint64_t)v24, 0);
  return i;
}

void sub_1AF91FCC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<unsigned int const,AG::Graph::ProfileData::Category>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<unsigned int const,AG::Graph::ProfileData::Category>,0>(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::~__hash_table(a1 + 104);
  std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::~__hash_table(a1 + 64);
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    free(v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      int8x8_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x30uLL);
  *uint64_t i = 0;
  i[1] = v7;
  uint64_t v13 = **a4;
  i[4] = 0;
  i[5] = 0;
  i[2] = v13;
  i[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  long long v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *uint64_t i = *v21;
LABEL_38:
    *long long v21 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    long long v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1AF91FFE4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  uint64_t v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  std::string __p = 0;
  if (v3) {
    operator delete(v3);
  }
  return v2;
}

void *AG::vector<AG::Graph::ProfileData::Mark,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,48ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,48ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint8x8_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(48 * a3);
    unint64_t v6 = v5 / 0x30;
    if (v5 / 0x30 != *a2)
    {
      unint64_t v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      uint8x8_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

char *std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node> const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      unint64_t v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = *((void *)v11 + 1);
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          unint64_t v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v13 = (void *)(a1 + 16);
  unint64_t v11 = (char *)operator new(0x50uLL);
  *(void *)unint64_t v11 = 0;
  *((void *)v11 + 1) = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((void *)v11 + 9) = 0;
  *(_OWORD *)(v11 + 56) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  long long v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *(void *)unint64_t v11 = *v21;
LABEL_38:
    *long long v21 = v11;
    goto LABEL_39;
  }
  *(void *)unint64_t v11 = *v13;
  *uint64_t v13 = v11;
  *(void *)(v20 + 8 * v4) = v13;
  if (*(void *)v11)
  {
    unint64_t v22 = *(void *)(*(void *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    long long v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1AF920418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<unsigned int const,AG::Graph::ProfileData::Category>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::default_delete<AG::Graph::ProfileData>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Category>>>::~__hash_table(a2 + 144);
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::~__hash_table(a2 + 104);
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::~__hash_table(a2 + 64);
    uint64_t v3 = *(void **)(a2 + 40);
    if (v3) {
      free(v3);
    }
    JUMPOUT(0x1B3E84B80);
  }
}

uint64_t AGReleaseClosure()
{
  return swift_release();
}

uint64_t AGTypeApplyFields(AG::swift::metadata *a1, uint64_t a2, uint64_t a3)
{
  v4[0] = &unk_1F0814328;
  v4[1] = a2;
  v4[2] = a3;
  return AG::swift::metadata::visit(a1, (AG::swift::metadata_visitor *)v4);
}

uint64_t AGTypeApplyEnumData(AG::swift::metadata *this, void *a2, void (*a3)(void, uint64_t, unint64_t))
{
  unint64_t v7 = (uint64_t *)((char *)this - 8);
  uint64_t v6 = *((void *)this - 1);
  if (v6)
  {
    uint64_t v8 = *((void *)this - 1);
    if ((*(unsigned char *)(v6 + 82) & 0x20) == 0)
    {
LABEL_25:
      uint64_t v23 = AG::swift::metadata::name(this, 0);
      AG::precondition_failure((AG *)"not an enum type: %s", v24, v23);
    }
  }
  else
  {
    if ((MEMORY[0x52] & 0x20) == 0) {
      goto LABEL_25;
    }
    uint64_t v8 = 0;
  }
  uint64_t v9 = (*(uint64_t (**)(void *, AG::swift::metadata *))(v8 + 88))(a2, this);
  uint64_t result = (uint64_t)AG::swift::metadata::nominal_descriptor(this);
  if (result)
  {
    uint64_t v11 = result + 16;
    uint64_t v12 = *(int *)(result + 16);
    if (v12
      && ((v12 & 3) != 1 ? (uint64_t v13 = v12 + v11) : (uint64_t v13 = *(void *)((v12 & 0xFFFFFFFFFFFFFFFCLL) + v11)),
          v9 < (*(_DWORD *)(result + 20) & 0xFFFFFFu)
       && (uint64_t v14 = v13 + 12 * v9, v17 = *(int *)(v14 + 20), v16 = v14 + 20, v15 = v17, v17)))
    {
      uint64_t result = (uint64_t)AG::swift::metadata::mangled_type_name_ref_cached(this, (unsigned char *)(v15 + v16), 0);
      if (result)
      {
        uint64_t v18 = result;
        size_t v19 = (unsigned char *)(v16 - 4);
        if (*v7) {
          uint64_t v20 = *v7;
        }
        else {
          uint64_t v20 = 0;
        }
        (*(void (**)(void *, AG::swift::metadata *))(v20 + 96))(a2, this);
        unint64_t v21 = (unint64_t)a2;
        if (*v19) {
          unint64_t v21 = *a2
        }
              + ((*(unsigned __int8 *)(*(void *)(v18 - 8) + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v18 - 8) + 80));
        a3(v9, v18, v21);
        if (*v7) {
          uint64_t v22 = *v7;
        }
        else {
          uint64_t v22 = 0;
        }
        (*(void (**)(void *, uint64_t, AG::swift::metadata *))(v22 + 104))(a2, v9, this);
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

__CFString *AGTypeDescription(AG::swift::metadata *a1)
{
  Mutable = CFStringCreateMutable(0, 0);
  AG::swift::metadata::append_description(a1, Mutable);
  return Mutable;
}

unsigned __int8 *AGTypeGetSignature@<X0>(AG::swift::metadata *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = AG::swift::metadata::signature(a1);
  if (result)
  {
    *(_OWORD *)a2 = *(_OWORD *)result;
    *(_DWORD *)(a2 + 16) = *((_DWORD *)result + 4);
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
  }
  return result;
}

_DWORD *AGTypeNominalDescriptorName(AG::swift::metadata *a1)
{
  uint64_t result = AG::swift::metadata::nominal_descriptor(a1);
  if (result)
  {
    uint64_t v2 = (int)result[2];
    if (v2) {
      return (_DWORD *)((char *)result + v2 + 8);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t AGTypeApplyFields::Visitor::unknown_result(AGTypeApplyFields::Visitor *this)
{
  return 1;
}

uint64_t AGTypeApplyFields::Visitor::visit_field(uint64_t a1, AG::swift::metadata *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(int *)(a3 + 4);
  if (v8) {
    uint64_t v9 = (unsigned char *)(v8 + a3 + 4);
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = AG::swift::metadata::mangled_type_name_ref(a2, v9, 1, 0);
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(int *)(a3 + 8);
    if (v12) {
      uint64_t v13 = (const char *)(v12 + a3 + 8);
    }
    else {
      uint64_t v13 = "";
    }
    (*(void (**)(const char *, uint64_t, uint64_t))(a1 + 8))(v13, a4, v11);
  }
  return 1;
}

uint64_t util::string_hash(util *this, const void *a2)
{
  char v2 = *(unsigned char *)this;
  if (!*(unsigned char *)this) {
    return 0;
  }
  uint64_t result = 0;
  size_t v5 = (unsigned __int8 *)this + 1;
  do
  {
    uint64_t result = 33 * result + v2;
    int v6 = *v5++;
    char v2 = v6;
  }
  while (v6);
  return result;
}

uint64_t *AG::Graph::Context::set_deadline(uint64_t *this, uint64_t a2)
{
  if (this[7] != a2)
  {
    uint64_t v3 = this;
    this[7] = a2;
    uint64_t v4 = *this;
    int v5 = *(_DWORD *)(*this + 232);
    if (v5)
    {
      unsigned int v6 = v5 - 1;
      do
      {
        uint64_t v7 = v6;
        uint64_t v8 = *(void *)(*(void *)(v4 + 224) + 8 * v6);
        (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 312))(v8, a2);
        --v6;
      }
      while (v7);
      uint64_t v4 = *v3;
    }
    uint64_t v9 = &v10;
    uint64_t v10 = -1;
    this = (uint64_t *)util::UntypedTable::for_each(v4 + 144, (void (*)(const void *, const void *, const void *))util::Table<unsigned long,AG::Graph::Context *>::for_each<AG::Graph::update_deadline(void)::$_0>(AG::Graph::update_deadline(void)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke, &v9);
    *(void *)(v4 + 432) = v10;
  }
  return this;
}

uint64_t std::tuple<unsigned int,unsigned int,AG::vector<char const*,0ul,unsigned long>>::~tuple(uint64_t a1)
{
  char v2 = *(void **)(a1 + 8);
  if (v2) {
    free(v2);
  }
  return a1;
}

uint64_t AG::vector<std::unique_ptr<AG::AttributeType,AG::AttributeType::deleter>,0ul,unsigned int>::~vector(uint64_t a1)
{
  char v2 = *(uint64_t **)a1;
  if (*(_DWORD *)(a1 + 8))
  {
    unint64_t v3 = 0;
    do
    {
      std::unique_ptr<AG::AttributeType,AG::AttributeType::deleter>::reset[abi:ne180100](v2, 0);
      ++v3;
      ++v2;
    }
    while (v3 < *(unsigned int *)(a1 + 8));
    char v2 = *(uint64_t **)a1;
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

void util::Heap::~Heap(util::Heap *this)
{
}

void AG::Graph::~Graph(AG::Graph *this)
{
  uint64_t v2 = *((unsigned int *)this + 58);
  if (v2)
  {
    unint64_t v3 = (void *)*((void *)this + 28);
    uint64_t v4 = 8 * v2;
    do
    {
      int v5 = (void (***)(void))*v3;
      (*(void (**)(void, AG::Graph *))(*(void *)*v3 + 24))(*v3, this);
      (**v5)(v5);
      ++v3;
      v4 -= 8;
    }
    while (v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  uint64_t v6 = *((void *)this + 1);
  uint64_t v7 = &AG::Graph::_all_graphs;
  if (v6) {
    uint64_t v7 = (uint64_t *)*((void *)this + 1);
  }
  *uint64_t v7 = *(void *)this;
  if (*(void *)this) {
    *(void *)(*(void *)this + 8) = v6;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  uint64_t v8 = *((unsigned int *)this + 88);
  if (v8)
  {
    uint64_t v9 = (AG::Subgraph **)*((void *)this + 43);
    uint64_t v10 = 8 * v8;
    do
    {
      AG::Subgraph::graph_destroyed(*v9++);
      v10 -= 8;
    }
    while (v10);
  }
  uint64_t v11 = (void *)*((void *)this + 49);
  if (v11) {
    free(v11);
  }
  uint64_t v12 = (void *)*((void *)this + 45);
  if (v12) {
    free(v12);
  }
  uint64_t v13 = (void *)*((void *)this + 43);
  if (v13) {
    free(v13);
  }
  uint64_t v14 = *((void *)this + 42);
  *((void *)this + 42) = 0;
  if (v14) {
    std::default_delete<AG::Graph::KeyTable>::operator()[abi:ne180100]((uint64_t)this + 336, v14);
  }
  std::unique_ptr<std::unordered_map<AG::Subgraph *,AG::Graph::TreeDataElement>>::reset[abi:ne180100]((uint64_t *)this + 41, 0);
  uint64_t v15 = *((void *)this + 38);
  *((void *)this + 38) = 0;
  if (v15) {
    std::default_delete<AG::Graph::ProfileData>::operator()[abi:ne180100]((uint64_t)this + 304, v15);
  }
  uint64_t v16 = (void *)*((void *)this + 28);
  if (v16) {
    free(v16);
  }
  util::UntypedTable::~UntypedTable((AG::Graph *)((char *)this + 144));
  uint64_t v17 = (uint64_t *)*((void *)this + 16);
  if (*((_DWORD *)this + 34))
  {
    unint64_t v18 = 0;
    do
    {
      std::unique_ptr<AG::AttributeType,AG::AttributeType::deleter>::reset[abi:ne180100](v17, 0);
      ++v18;
      ++v17;
    }
    while (v18 < *((unsigned int *)this + 34));
    uint64_t v17 = (uint64_t *)*((void *)this + 16);
  }
  if (v17) {
    free(v17);
  }
  util::UntypedTable::~UntypedTable((AG::Graph *)((char *)this + 48));
  util::Heap::reset((AG::Graph *)((char *)this + 16), 0, 0);
}

uint64_t AG::Graph::main_context(AG::Graph *this)
{
  uint64_t v4 = 0;
  v2[0] = &v4;
  v2[1] = &v3;
  uint64_t v3 = -1;
  util::UntypedTable::for_each((uint64_t)this + 144, (void (*)(const void *, const void *, const void *))util::Table<unsigned long,AG::Graph::Context *>::for_each<AG::Graph::main_context(void)::$_0>(AG::Graph::main_context(void)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke, v2);
  return v4;
}

void *AG::Graph::add_trace(void *this, AG::Trace *a2)
{
  if (a2)
  {
    uint64_t v3 = (uint64_t)this;
    this = (void *)(*(uint64_t (**)(AG::Trace *, void *))(*(void *)a2 + 16))(a2, this);
    unsigned int v4 = *(_DWORD *)(v3 + 232);
    unsigned int v5 = v4 + 1;
    if (*(_DWORD *)(v3 + 236) < v4 + 1)
    {
      this = AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow(v3 + 224, v5);
      unsigned int v4 = *(_DWORD *)(v3 + 232);
      unsigned int v5 = v4 + 1;
    }
    *(void *)(*(void *)(v3 + 224) + 8 * v4) = a2;
    *(_DWORD *)(v3 + 232) = v5;
  }
  return this;
}

_DWORD *AG::Graph::remove_trace(_DWORD *this, uint64_t a2)
{
  unsigned int v2 = this[58];
  if (v2)
  {
    unsigned int v4 = this;
    unsigned int v5 = 0;
    do
    {
      this = (_DWORD *)(*((void *)v4 + 28) + 8 * v5);
      uint64_t v6 = *(void *)this;
      if (*(void *)(*(void *)this + 8) == a2)
      {
        uint64_t v7 = v2 - 1;
        v4[58] = v7;
        if (v5 != v7) {
          memmove(this, this + 2, 8 * (v7 - v5));
        }
        (*(void (**)(uint64_t, _DWORD *))(*(void *)v6 + 24))(v6, v4);
        this = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
        unsigned int v2 = v4[58];
      }
      else
      {
        ++v5;
      }
    }
    while (v5 < v2);
  }
  return this;
}

__n128 AG::Graph::call_main_handler(__n128 *this, const void *a2, void (*a3)(const void *))
{
  unint64_t v3 = this[26].n128_u64[0];
  uint64_t v8 = (AG::Graph *)this;
  unint64_t v9 = v3;
  uint64_t v10 = a2;
  uint64_t v11 = a3;
  this[26].n128_u64[0] = 0;
  unsigned int v5 = this + 15;
  __n128 v7 = this[15];
  unsigned int v4 = (void (*)(uint64_t (*)(), AG::Graph **))this[15].n128_u64[0];
  this[15].n128_u64[0] = 0;
  this[15].n128_u64[1] = 0;
  v4(AG::Graph::call_main_handler(void const*,void (*)(void const*))::MainTrampoline::thunk, &v8);
  __n128 result = v7;
  *unsigned int v5 = v7;
  *((void *)v8 + 52) = v9;
  return result;
}

void sub_1AF920EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9, uint64_t a10, uint64_t a11)
{
  *uint64_t v11 = a9;
  *(void *)(a10 + 416) = a11;
  _Unwind_Resume(a1);
}

uint64_t AG::Graph::call_main_handler(void const*,void (*)(void const*))::MainTrampoline::thunk()
{
  return (*(uint64_t (**)(void))(v0 + 24))(*(void *)(v0 + 16));
}

uint64_t AG::Graph::passed_deadline_slow(AG::Graph *this)
{
  if (*((void *)this + 54))
  {
    if (mach_absolute_time() < *((void *)this + 54)) {
      return 0;
    }
    int v3 = *((_DWORD *)this + 58);
    if (v3)
    {
      unsigned int v4 = v3 - 1;
      do
      {
        uint64_t v5 = v4;
        uint64_t v6 = *(void *)(*((void *)this + 28) + 8 * v4);
        (*(void (**)(uint64_t))(*(void *)v6 + 320))(v6);
        --v4;
      }
      while (v5);
    }
    *((void *)this + 54) = 0;
  }
  return 1;
}

uint64_t AG::Graph::indirect_attribute_reset(uint64_t a1, const char *a2, char a3)
{
  unsigned int v3 = a2;
  uint64_t v4 = AG::data::_shared_table_bytes + a2;
  if ((*(unsigned char *)(v4 + 8) & 1) == 0) {
    AG::precondition_failure((AG *)"not an indirect attribute: %u", a2, a2 | 1);
  }
  uint64_t v7 = *(void *)v4;
  unint64_t v8 = *(void *)(v4 + 28);
  if ((v8 & 0xFFFFFFFC) != 0
    && ((unint64_t v9 = HIDWORD(v8),
         v10 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(*(void *)(v4 + 28) & 0xFFFFFE00)), (v10 & 0xFF00000000) != 0)? (BOOL v11 = v9 == v10): (BOOL v11 = 0), v11))
  {
    unsigned int v15 = *(_DWORD *)(v4 + 28);
    uint64_t v13 = *(unsigned int *)(v4 + 32);
    int v14 = *(_DWORD *)(v4 + 36);
  }
  else
  {
    uint64_t result = 0;
    if (a3) {
      return result;
    }
    uint64_t v13 = 0;
    int v14 = 0;
    unsigned int v15 = 2;
  }
  unsigned int v16 = 2;
  if (v7 >= 4)
  {
    uint64_t v17 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(v7 & 0xFFFFFE00));
    if (HIDWORD(v7) != v17 || (v17 & 0xFF00000000) == 0) {
      unsigned int v16 = 2;
    }
    else {
      unsigned int v16 = v7;
    }
  }
  unsigned int v19 = 2;
  if (v15 >= 4)
  {
    uint64_t v20 = AG::data::table::raw_page_seed((uint64_t)&AG::data::_shared_table_bytes, (const char *)(v15 & 0xFFFFFE00));
    if (v13 != v20 || (v20 & 0xFF00000000) == 0) {
      unsigned int v19 = 2;
    }
    else {
      unsigned int v19 = v15;
    }
  }
  int v22 = *(_DWORD *)(a1 + 232);
  if (v22)
  {
    unsigned int v26 = v22 - 1;
    do
    {
      uint64_t v28 = v26;
      uint64_t v27 = *(void *)(*(void *)(a1 + 224) + 8 * v26);
      (*(void (**)(uint64_t, void, void))(*(void *)v27 + 296))(v27, v3, v19);
      --v26;
    }
    while (v28);
  }
  if (v16 != v19) {
    AG::Graph::remove_input_dependencies(a1, v3 & 0xFFFFFFFE | 1, v16);
  }
  AG::IndirectNode::modify(v4, v15 | (unint64_t)(v13 << 32), v14);
  if (v19 >= 4)
  {
    uint64_t v23 = *(void *)(AG::data::_shared_table_bytes + (v19 & 0xFFFFFE00));
    if (v23) {
      uint64_t v23 = *(void *)(v23 + 48);
    }
    uint64_t v24 = *(void *)(AG::data::_shared_table_bytes + (v3 & 0xFFFFFE00));
    if (v24) {
      uint64_t v24 = *(void *)(v24 + 48);
    }
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(v4 + 8) & 0xFFFFFFFD | (2 * (v23 != v24));
  }
  unsigned int v25 = v3 & 0xFFFFFFFE | 1;
  if (v16 != v19) {
    AG::Graph::add_input_dependencies(a1, v25, v19);
  }
  AG::Graph::mark_changed(a1);
  AG::Graph::propagate_dirty(a1);
  return 1;
}

uint64_t AG::Graph::indirect_attribute_dependency(uint64_t a1, const char *a2)
{
  uint64_t v2 = AG::data::_shared_table_bytes + a2;
  if ((*(unsigned char *)(v2 + 8) & 1) == 0) {
    AG::precondition_failure((AG *)"not an indirect attribute: %u", a2, a2 | 1);
  }
  return *(unsigned int *)(v2 + 16);
}

uint64_t AG::Graph::value_exists(uint64_t a1, unsigned int a2)
{
  return (*(unsigned __int8 *)(AG::data::_shared_table_bytes + a2) >> 4) & 1;
}

uint64_t AG::Graph::value_mark_all(uint64_t this, const char *a2)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  unint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2);
  if (v3 >= 2 && (v3 & 1) == 0) {
    AG::precondition_failure((AG *)"invalidating all values during update", a2);
  }
  uint64_t v5 = this;
  uint64_t v6 = *(unsigned int *)(this + 352);
  if (v6)
  {
    uint64_t v7 = *(AG::Subgraph ***)(this + 344);
    unint64_t v8 = &v7[v6];
    do
    {
      unint64_t v9 = *v7;
      unsigned int v10 = *((_DWORD *)*v7 + 4);
      if (v10)
      {
        uint64_t v11 = AG::data::_shared_table_bytes;
        do
        {
          uint64_t v12 = v10;
          uint64_t v13 = v11 + v10;
          int v14 = *(unsigned __int16 *)(v13 + 20);
          if (*(_WORD *)(v13 + 20))
          {
            do
            {
              uint64_t v15 = (v14 + v12);
              int v16 = ((_BYTE)v14 + (_BYTE)v12) & 3;
              if ((((_BYTE)v14 + (_BYTE)v12) & 3) != 0)
              {
                if (v16 == 1)
                {
                  int v14 = *(unsigned __int16 *)(v11 + (v15 & 0xFFFFFFFC) + 14);
                  if ((v15 & 3) == 0)
                  {
                    uint64_t v24 = v11 + v15;
                    unint64_t v25 = *(unsigned int *)(v11 + v15);
                    if ((*(unsigned char *)(*(void *)(*(void *)(v5 + 128) + ((v25 >> 5) & 0x7FFFFF8)) + 40) & 0x10) == 0)
                    {
                      *(_DWORD *)uint64_t v24 = v25 | 3;
                      int v26 = *(unsigned __int8 *)(v24 + 6);
                      unsigned int v27 = *((_DWORD *)v9 + 25);
                      if ((v26 & ~HIWORD(v27)) != 0)
                      {
                        *((_DWORD *)v9 + 25) = v27 & 0xFF00FFFF | ((BYTE2(v27) | v26) << 16);
                        this = AG::Subgraph::propagate_dirty_flags(v9);
                        uint64_t v11 = AG::data::_shared_table_bytes;
                      }
                    }
                    unint64_t v28 = *(unsigned int *)(v24 + 12);
                    if (v28 >= 0x20)
                    {
                      uint64_t v29 = 5 * (v28 >> 5);
                      uint64_t v30 = *(unsigned int *)(v24 + 16) + 4;
                      do
                      {
                        *(unsigned char *)(v11 + v30) |= 8u;
                        v30 += 5;
                        v29 -= 5;
                      }
                      while (v29);
                    }
                  }
                }
                else if (v16 == 2)
                {
                  break;
                }
              }
              else
              {
                uint64_t v17 = (unsigned int *)(v11 + v15);
                int v14 = *((unsigned __int16 *)v17 + 2);
                unint64_t v18 = *v17;
                if ((*(unsigned char *)(*(void *)(*(void *)(v5 + 128) + ((v18 >> 5) & 0x7FFFFF8)) + 40) & 0x10) == 0)
                {
                  *uint64_t v17 = v18 | 3;
                  int v19 = *((unsigned __int8 *)v17 + 6);
                  unsigned int v20 = *((_DWORD *)v9 + 25);
                  if ((v19 & ~HIWORD(v20)) != 0)
                  {
                    *((_DWORD *)v9 + 25) = v20 & 0xFF00FFFF | ((BYTE2(v20) | v19) << 16);
                    this = AG::Subgraph::propagate_dirty_flags(v9);
                    uint64_t v11 = AG::data::_shared_table_bytes;
                  }
                }
                unint64_t v21 = v17[3];
                if (v21 >= 0x20)
                {
                  uint64_t v22 = 5 * (v21 >> 5);
                  uint64_t v23 = v17[4] + 4;
                  do
                  {
                    *(unsigned char *)(v11 + v23) |= 8u;
                    v23 += 5;
                    v22 -= 5;
                  }
                  while (v22);
                }
              }
            }
            while (v14);
          }
          unsigned int v10 = *(_DWORD *)(v11 + v12 + 8);
        }
        while (v10);
      }
      ++v7;
    }
    while (v7 != v8);
  }
  return this;
}

unint64_t AG::Graph::input_value_add(uint64_t a1, const char *a2, unsigned int a3, char a4)
{
  if (dword_1EB3D3240 <= (a3 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a3 & 0xFFFFFFFC);
  }
  uint64_t v5 = a4 & 1;
  uint64_t v6 = (const char *)a2;
  uint64_t v7 = AG::data::_shared_table_bytes + a2;
  unint64_t v9 = *(unsigned int *)(v7 + 12);
  if (v9 <= 0x11F)
  {
    if (v9 >= 0x20)
    {
      unint64_t result = 0;
      unint64_t v11 = v9 >> 5;
      uint64_t v12 = (unsigned char *)(*(unsigned int *)(v7 + 16) + AG::data::_shared_table_bytes + 4);
      while (*((_DWORD *)v12 - 1) != a3 || (*v12 & 5) != v5)
      {
        ++result;
        v12 += 5;
        if (v11 == result) {
          goto LABEL_8;
        }
      }
LABEL_9:
      if ((result & 0x8000000000000000) != 0) {
        return result;
      }
      goto LABEL_10;
    }
LABEL_8:
    unint64_t result = AG::Graph::add_input(a1, v6, a3, 0, v5);
    goto LABEL_9;
  }
  unint64_t result = AG::Graph::index_of_input_slow(a1, v7, a3 | (unint64_t)(v5 << 40) | 0x500000000);
  if ((result & 0x8000000000000000) != 0) {
    goto LABEL_8;
  }
LABEL_10:
  uint64_t v13 = AG::data::_shared_table_bytes + 5 * result + *(unsigned int *)&v6[AG::data::_shared_table_bytes + 16];
  *(unsigned char *)(v13 + 4) |= 0x10u;
  return result;
}

uint64_t *AG::Graph::intern_key(AG::Graph *this, char *a2)
{
  unint64_t v3 = (uint64_t *)((char *)this + 336);
  uint64_t v4 = *((void *)this + 42);
  if (!v4) {
    operator new();
  }
  int v14 = 0;
  uint64_t v5 = util::UntypedTable::lookup((util::UntypedTable *)(v4 + 16), (uint64_t *)a2, &v14);
  if (v14) {
    return v5;
  }
  uint64_t v7 = strdup(a2);
  if (!v7) {
    AG::precondition_failure((AG *)"memory allocation failure", v8);
  }
  unint64_t v9 = v7;
  uint64_t v10 = *v3;
  uint64_t v6 = (void *)*(unsigned int *)(*v3 + 8);
  unsigned int v11 = v6 + 1;
  if (*(_DWORD *)(*v3 + 12) < (v6 + 1))
  {
    AG::vector<std::pair<unsigned int,BOOL>,0ul,unsigned int>::reserve_slow(*v3, v11);
    unsigned int v12 = *(_DWORD *)(v10 + 8);
    unsigned int v11 = v12 + 1;
  }
  else
  {
    unsigned int v12 = *(_DWORD *)(*v3 + 8);
  }
  *(void *)(*(void *)v10 + 8 * v12) = v9;
  *(_DWORD *)(v10 + 8) = v11;
  util::UntypedTable::insert((util::UntypedTable *)(*v3 + 16), v9, v6);
  return (uint64_t *)v6;
}

void sub_1AF9216E0(_Unwind_Exception *a1)
{
  unint64_t v3 = *(void **)v1;
  unint64_t v4 = *(unsigned int *)(v1 + 8);
  if (v4)
  {
    for (unint64_t i = 0; i < v4; ++i)
    {
      uint64_t v6 = (void *)v3[i];
      v3[i] = 0;
      if (v6)
      {
        free(v6);
        unint64_t v4 = *(unsigned int *)(v1 + 8);
      }
    }
    unint64_t v3 = *(void **)v1;
  }
  if (v3) {
    free(v3);
  }
  MEMORY[0x1B3E84B80](v1, 0x10A0C40627C3B6DLL);
  _Unwind_Resume(a1);
}

uint64_t AG::Graph::key_name(AG::Graph *this, const char *a2)
{
  uint64_t v2 = *((void *)this + 42);
  if (!v2 || *(_DWORD *)(v2 + 8) <= a2) {
    AG::precondition_failure((AG *)"invalid string key id: %u", a2, a2);
  }
  return *(void *)(*(void *)v2 + 8 * a2);
}

uint64_t AG::Graph::TreeDataElement::sort_nodes(uint64_t this)
{
  if (!*(unsigned char *)(this + 24))
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)this;
    unint64_t v3 = *(void *)(v1 + 8);
    unint64_t v4 = 126 - 2 * __clz(v3);
    if (v3) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    this = std::__introsort<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *,false>(v2, (unsigned int *)(v2 + 8 * v3), v5, 1);
    *(unsigned char *)(v1 + 24) = 1;
  }
  return this;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*,false>(unint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = a2 - v10;
          uint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * (a2 - v10);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return result;
              case 2:
                unsigned int v44 = *(_DWORD *)(a2 - 5);
                unint64_t v43 = a2 - 5;
                if (v44 < *(_DWORD *)v10)
                {
                  char v115 = *(unsigned char *)(v10 + 4);
                  unsigned int v109 = *(_DWORD *)v10;
                  int v45 = *(_DWORD *)v43;
                  *(unsigned char *)(v10 + 4) = *(unsigned char *)(v43 + 4);
                  *(_DWORD *)unint64_t v10 = v45;
                  *(unsigned char *)(v43 + 4) = v115;
                  *(_DWORD *)unint64_t v43 = v109;
                }
                break;
              case 3:
                unint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>((unsigned int *)v10, (unsigned int *)(v10 + 5), (unsigned int *)(a2 - 5));
                break;
              case 4:
                unint64_t result = (unint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(v10, v10 + 5, v10 + 10, a2 - 5);
                break;
              case 5:
                unint64_t v46 = (unsigned int *)(v10 + 5);
                uint64_t v47 = (unsigned int *)(v10 + 10);
                int v48 = (unsigned int *)(v10 + 15);
                unint64_t result = (unint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(v10, v10 + 5, v10 + 10, v10 + 15);
                unsigned int v50 = *(_DWORD *)(a2 - 5);
                unint64_t v49 = a2 - 5;
                if (v50 < *(_DWORD *)(v10 + 15))
                {
                  unsigned int v51 = *v48;
                  char v52 = *(unsigned char *)(v10 + 19);
                  char v53 = *(unsigned char *)(v49 + 4);
                  unsigned int *v48 = *(_DWORD *)v49;
                  *(unsigned char *)(v10 + 19) = v53;
                  *(unsigned char *)(v49 + 4) = v52;
                  *(_DWORD *)unint64_t v49 = v51;
                  if (*v48 < *v47)
                  {
                    char v54 = *(unsigned char *)(v10 + 14);
                    unsigned int v55 = *v47;
                    *uint64_t v47 = *v48;
                    *(unsigned char *)(v10 + 14) = *(unsigned char *)(v10 + 19);
                    unsigned int *v48 = v55;
                    *(unsigned char *)(v10 + 19) = v54;
                    if (*v47 < *v46)
                    {
                      char v56 = *(unsigned char *)(v10 + 9);
                      unsigned int v57 = *v46;
                      unsigned int *v46 = *v47;
                      *(unsigned char *)(v10 + 9) = *(unsigned char *)(v10 + 14);
                      *uint64_t v47 = v57;
                      *(unsigned char *)(v10 + 14) = v56;
                      if (*(_DWORD *)(v10 + 5) < *(_DWORD *)v10)
                      {
                        char v116 = *(unsigned char *)(v10 + 4);
                        unsigned int v110 = *(_DWORD *)v10;
                        *(_DWORD *)unint64_t v10 = *v46;
                        *(unsigned char *)(v10 + 4) = *(unsigned char *)(v10 + 9);
                        unsigned int *v46 = v110;
                        *(unsigned char *)(v10 + 9) = v116;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 119)
          {
            unint64_t v58 = v10 + 5;
            BOOL v60 = v10 == a2 || v58 == a2;
            if (a4)
            {
              if (!v60)
              {
                uint64_t v61 = 0;
                unint64_t v62 = v10;
                do
                {
                  unint64_t v63 = v58;
                  unsigned int v64 = *(_DWORD *)(v62 + 5);
                  if (v64 < *(_DWORD *)v62)
                  {
                    char v65 = *(unsigned char *)(v62 + 9);
                    uint64_t v66 = v61;
                    while (1)
                    {
                      uint64_t v67 = v10 + v66;
                      *(_DWORD *)(v67 + 5) = *(_DWORD *)(v10 + v66);
                      *(unsigned char *)(v67 + 9) = *(unsigned char *)(v10 + v66 + 4);
                      if (!v66) {
                        break;
                      }
                      v66 -= 5;
                      if (v64 >= *(_DWORD *)(v67 - 5))
                      {
                        uint64_t v68 = v10 + v66 + 5;
                        goto LABEL_82;
                      }
                    }
                    uint64_t v68 = v10;
LABEL_82:
                    *(_DWORD *)uint64_t v68 = v64;
                    *(unsigned char *)(v68 + 4) = v65;
                  }
                  unint64_t v58 = v63 + 5;
                  v61 += 5;
                  unint64_t v62 = v63;
                }
                while (v63 + 5 != a2);
              }
            }
            else if (!v60)
            {
              do
              {
                unint64_t v100 = v58;
                unsigned int v101 = *(_DWORD *)(v9 + 5);
                if (v101 < *(_DWORD *)v9)
                {
                  char v102 = *(unsigned char *)(v9 + 9);
                  unint64_t v103 = v100;
                  do
                  {
                    unint64_t v104 = v103;
                    int v105 = *(_DWORD *)(v103 - 5);
                    v103 -= 5;
                    *(_DWORD *)unint64_t v104 = v105;
                    *(unsigned char *)(v104 + 4) = *(unsigned char *)(v104 - 1);
                  }
                  while (v101 < *(_DWORD *)(v104 - 10));
                  *(_DWORD *)unint64_t v103 = v101;
                  *(unsigned char *)(v103 + 4) = v102;
                }
                unint64_t v58 = v100 + 5;
                unint64_t v9 = v100;
              }
              while (v100 + 5 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v69 = (unint64_t)(v12 - 2) >> 1;
              int64_t v70 = v69;
              do
              {
                int64_t v71 = v70;
                if (v69 >= v70)
                {
                  uint64_t v72 = (2 * v70) | 1;
                  unsigned int v73 = (unsigned int *)(v10 + 5 * v72);
                  if (2 * v71 + 2 < v12)
                  {
                    unsigned int v75 = *(unsigned int *)((char *)v73 + 5);
                    BOOL v74 = *v73 >= v75;
                    if (*v73 > v75) {
                      unsigned int v75 = *v73;
                    }
                    if (!v74)
                    {
                      unsigned int v73 = (unsigned int *)((char *)v73 + 5);
                      uint64_t v72 = 2 * v71 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v75 = *v73;
                  }
                  unsigned int v76 = (unsigned int *)(v10 + 5 * v71);
                  unsigned int v77 = *v76;
                  if (v75 >= *v76)
                  {
                    char v78 = *((unsigned char *)v76 + 4);
                    do
                    {
                      unsigned int v79 = v76;
                      unsigned int v76 = v73;
                      unsigned int v80 = *v73;
                      unint64_t result = *((unsigned __int8 *)v76 + 4);
                      *((unsigned char *)v79 + 4) = result;
                      *unsigned int v79 = v80;
                      if (v69 < v72) {
                        break;
                      }
                      uint64_t v81 = (2 * v72) | 1;
                      unsigned int v73 = (unsigned int *)(v10 + 5 * v81);
                      uint64_t v72 = 2 * v72 + 2;
                      if (v72 < v12)
                      {
                        LODWORD(result) = *v73;
                        unsigned int v82 = *(unsigned int *)((char *)v73 + 5);
                        unint64_t result = *v73 <= v82 ? v82 : result;
                        if (*v73 >= v82) {
                          uint64_t v72 = v81;
                        }
                        else {
                          unsigned int v73 = (unsigned int *)((char *)v73 + 5);
                        }
                      }
                      else
                      {
                        unint64_t result = *v73;
                        uint64_t v72 = v81;
                      }
                    }
                    while (result >= v77);
                    unsigned int *v76 = v77;
                    *((unsigned char *)v76 + 4) = v78;
                  }
                }
                int64_t v70 = v71 - 1;
              }
              while (v71);
              int64_t v83 = v11 / 5uLL;
              do
              {
                uint64_t v84 = 0;
                char v117 = *(unsigned char *)(v10 + 4);
                unsigned int v111 = *(_DWORD *)v10;
                unint64_t v85 = v10;
                do
                {
                  uint64_t v86 = 5 * v84 + v85 + 5;
                  uint64_t v87 = (2 * v84) | 1;
                  uint64_t v88 = 2 * v84 + 2;
                  if (v88 < v83 && *(_DWORD *)v86 < *(_DWORD *)(v86 + 5))
                  {
                    v86 += 5;
                    uint64_t v87 = v88;
                  }
                  unsigned int v89 = *(_DWORD *)v86;
                  *(unsigned char *)(v85 + 4) = *(unsigned char *)(v86 + 4);
                  *(_DWORD *)unint64_t v85 = v89;
                  unint64_t v85 = v86;
                  uint64_t v84 = v87;
                }
                while (v87 <= (uint64_t)((unint64_t)(v83 - 2) >> 1));
                a2 -= 5;
                if (v86 == a2)
                {
                  *(unsigned char *)(v86 + 4) = v117;
                  *(_DWORD *)uint64_t v86 = v111;
                }
                else
                {
                  int v90 = *(_DWORD *)a2;
                  *(unsigned char *)(v86 + 4) = *(unsigned char *)(a2 + 4);
                  *(_DWORD *)uint64_t v86 = v90;
                  *(unsigned char *)(a2 + 4) = v117;
                  *(_DWORD *)a2 = v111;
                  uint64_t v91 = v86 - v10 + 5;
                  if (v91 >= 6)
                  {
                    unint64_t v92 = (v91 / 5uLL - 2) >> 1;
                    BOOL v93 = (unsigned int *)(v10 + 5 * v92);
                    unsigned int v94 = *(_DWORD *)v86;
                    if (*v93 < *(_DWORD *)v86)
                    {
                      char v95 = *(unsigned char *)(v86 + 4);
                      do
                      {
                        uint64_t v96 = v86;
                        uint64_t v86 = (uint64_t)v93;
                        unsigned int v97 = *v93;
                        *(unsigned char *)(v96 + 4) = *(unsigned char *)(v86 + 4);
                        *(_DWORD *)uint64_t v96 = v97;
                        if (!v92) {
                          break;
                        }
                        unint64_t v98 = v92 - 1;
                        unint64_t v92 = (v92 - 1) >> 1;
                        BOOL v93 = (unsigned int *)(v10 + 4 * v92 + (v98 >> 1));
                      }
                      while (*v93 < v94);
                      *(_DWORD *)uint64_t v86 = v94;
                      *(unsigned char *)(v86 + 4) = v95;
                    }
                  }
                }
              }
              while (v83-- > 2);
            }
            return result;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          uint64_t v14 = 5 * ((unint64_t)v12 >> 1);
          unint64_t v15 = v10 + v14;
          if ((unint64_t)v11 >= 0x281)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>((unsigned int *)v9, (unsigned int *)(v9 + v14), (unsigned int *)(a2 - 5));
            uint64_t v16 = 5 * v13;
            uint64_t v17 = (unsigned int *)(5 * v13 + v9 - 5);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>((unsigned int *)(v9 + 5), v17, (unsigned int *)(a2 - 10));
            unint64_t v18 = (unsigned int *)(v9 + 5 + v16);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>((unsigned int *)(v9 + 10), v18, (unsigned int *)(a2 - 15));
            unint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(v17, (unsigned int *)v15, v18);
            char v112 = *(unsigned char *)(v9 + 4);
            unsigned int v106 = *(_DWORD *)v9;
            char v19 = *(unsigned char *)(v15 + 4);
            *(_DWORD *)unint64_t v9 = *(_DWORD *)v15;
            *(unsigned char *)(v9 + 4) = v19;
            *(unsigned char *)(v15 + 4) = v112;
            *(_DWORD *)unint64_t v15 = v106;
          }
          else
          {
            unint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>((unsigned int *)(v9 + v14), (unsigned int *)v9, (unsigned int *)(a2 - 5));
          }
          --a3;
          unsigned int v20 = *(_DWORD *)v9;
          if ((a4 & 1) != 0 || *(_DWORD *)(v9 - 5) < v20) {
            break;
          }
          if (v20 >= *(_DWORD *)(a2 - 5))
          {
            unint64_t v35 = v9 + 5;
            do
            {
              unint64_t v10 = v35;
              if (v35 >= a2) {
                break;
              }
              v35 += 5;
            }
            while (v20 >= *(_DWORD *)v10);
          }
          else
          {
            unint64_t v10 = v9;
            do
            {
              unsigned int v34 = *(_DWORD *)(v10 + 5);
              v10 += 5;
            }
            while (v20 >= v34);
          }
          unint64_t v36 = a2;
          if (v10 < a2)
          {
            unint64_t v36 = a2;
            do
            {
              unsigned int v37 = *(_DWORD *)(v36 - 5);
              v36 -= 5;
            }
            while (v20 < v37);
          }
          char v38 = *(unsigned char *)(v9 + 4);
          while (v10 < v36)
          {
            char v114 = *(unsigned char *)(v10 + 4);
            unsigned int v108 = *(_DWORD *)v10;
            int v39 = *(_DWORD *)v36;
            *(unsigned char *)(v10 + 4) = *(unsigned char *)(v36 + 4);
            *(_DWORD *)unint64_t v10 = v39;
            *(unsigned char *)(v36 + 4) = v114;
            *(_DWORD *)unint64_t v36 = v108;
            do
            {
              unsigned int v40 = *(_DWORD *)(v10 + 5);
              v10 += 5;
            }
            while (v20 >= v40);
            do
            {
              unsigned int v41 = *(_DWORD *)(v36 - 5);
              v36 -= 5;
            }
            while (v20 < v41);
          }
          BOOL v4 = v10 - 5 >= v9;
          BOOL v5 = v10 - 5 == v9;
          if (v10 - 5 != v9)
          {
            int v42 = *(_DWORD *)(v10 - 5);
            *(unsigned char *)(v9 + 4) = *(unsigned char *)(v10 - 1);
            *(_DWORD *)unint64_t v9 = v42;
          }
          a4 = 0;
          *(_DWORD *)(v10 - 5) = v20;
          *(unsigned char *)(v10 - 1) = v38;
        }
        uint64_t v21 = 0;
        char v22 = *(unsigned char *)(v9 + 4);
        do
        {
          unsigned int v23 = *(_DWORD *)(v9 + v21 + 5);
          v21 += 5;
        }
        while (v23 < v20);
        unint64_t v24 = v9 + v21;
        unint64_t v25 = a2;
        if (v21 == 5)
        {
          unint64_t v25 = a2;
          do
          {
            if (v24 >= v25) {
              break;
            }
            unsigned int v27 = *(_DWORD *)(v25 - 5);
            v25 -= 5;
          }
          while (v27 >= v20);
        }
        else
        {
          do
          {
            unsigned int v26 = *(_DWORD *)(v25 - 5);
            v25 -= 5;
          }
          while (v26 >= v20);
        }
        unint64_t v10 = v9 + v21;
        if (v24 < v25)
        {
          unint64_t v28 = v25;
          do
          {
            char v113 = *(unsigned char *)(v10 + 4);
            unsigned int v107 = *(_DWORD *)v10;
            int v29 = *(_DWORD *)v28;
            *(unsigned char *)(v10 + 4) = *(unsigned char *)(v28 + 4);
            *(_DWORD *)unint64_t v10 = v29;
            *(unsigned char *)(v28 + 4) = v113;
            *(_DWORD *)unint64_t v28 = v107;
            do
            {
              unsigned int v30 = *(_DWORD *)(v10 + 5);
              v10 += 5;
            }
            while (v30 < v20);
            do
            {
              unsigned int v31 = *(_DWORD *)(v28 - 5);
              v28 -= 5;
            }
            while (v31 >= v20);
          }
          while (v10 < v28);
        }
        if (v10 - 5 != v9)
        {
          int v32 = *(_DWORD *)(v10 - 5);
          *(unsigned char *)(v9 + 4) = *(unsigned char *)(v10 - 1);
          *(_DWORD *)unint64_t v9 = v32;
        }
        *(_DWORD *)(v10 - 5) = v20;
        *(unsigned char *)(v10 - 1) = v22;
        if (v24 >= v25) {
          break;
        }
LABEL_31:
        unint64_t result = std::__introsort<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*,false>(v9, v10 - 5, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v33 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(v9, v10 - 5);
      unint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(v10, a2);
      if (result) {
        break;
      }
      if (!v33) {
        goto LABEL_31;
      }
    }
    a2 = v10 - 5;
    if (!v33) {
      continue;
    }
    return result;
  }
}

unsigned int *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  if (*a2 >= *result)
  {
    if (v4 < v3)
    {
      char v8 = *((unsigned char *)a2 + 4);
      unsigned int v9 = *a2;
      char v10 = *((unsigned char *)a3 + 4);
      *a2 = *a3;
      *((unsigned char *)a2 + 4) = v10;
      *a3 = v9;
      *((unsigned char *)a3 + 4) = v8;
      if (*a2 < *result)
      {
        char v11 = *((unsigned char *)result + 4);
        unsigned int v12 = *result;
        char v13 = *((unsigned char *)a2 + 4);
        *unint64_t result = *a2;
        *((unsigned char *)result + 4) = v13;
        *a2 = v12;
        *((unsigned char *)a2 + 4) = v11;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      char v14 = *((unsigned char *)result + 4);
      unsigned int v15 = *result;
      char v16 = *((unsigned char *)a2 + 4);
      *unint64_t result = *a2;
      *((unsigned char *)result + 4) = v16;
      *a2 = v15;
      *((unsigned char *)a2 + 4) = v14;
      if (*a3 >= v15) {
        return result;
      }
      char v5 = *((unsigned char *)a2 + 4);
      unsigned int v6 = *a2;
      char v17 = *((unsigned char *)a3 + 4);
      *a2 = *a3;
      *((unsigned char *)a2 + 4) = v17;
    }
    else
    {
      char v5 = *((unsigned char *)result + 4);
      unsigned int v6 = *result;
      char v7 = *((unsigned char *)a3 + 4);
      *unint64_t result = *a3;
      *((unsigned char *)result + 4) = v7;
    }
    *a3 = v6;
    *((unsigned char *)a3 + 4) = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * (a2 - a1);
  BOOL result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unsigned int v6 = (unsigned int *)(a2 - 5);
      if (*(_DWORD *)(a2 - 5) < *(_DWORD *)a1)
      {
        char v7 = *(unsigned char *)(a1 + 4);
        unsigned int v8 = *(_DWORD *)a1;
        char v9 = *(unsigned char *)(a2 - 1);
        *(_DWORD *)a1 = *v6;
        *(unsigned char *)(a1 + 4) = v9;
        *unsigned int v6 = v8;
        *(unsigned char *)(a2 - 1) = v7;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>((unsigned int *)a1, (unsigned int *)(a1 + 5), (unsigned int *)(a2 - 5));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(a1, a1 + 5, a1 + 10, a2 - 5);
      return 1;
    case 5uLL:
      char v19 = (unsigned int *)(a1 + 5);
      unsigned int v20 = (unsigned int *)(a1 + 10);
      uint64_t v21 = (unsigned int *)(a1 + 15);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(a1, a1 + 5, a1 + 10, a1 + 15);
      unsigned int v23 = *(_DWORD *)(a2 - 5);
      uint64_t v22 = a2 - 5;
      if (v23 < *(_DWORD *)(a1 + 15))
      {
        char v24 = *(unsigned char *)(a1 + 19);
        unsigned int v25 = *v21;
        char v26 = *(unsigned char *)(v22 + 4);
        *uint64_t v21 = *(_DWORD *)v22;
        *(unsigned char *)(a1 + 19) = v26;
        *(_DWORD *)uint64_t v22 = v25;
        *(unsigned char *)(v22 + 4) = v24;
        if (*v21 < *v20)
        {
          char v27 = *(unsigned char *)(a1 + 14);
          unsigned int v28 = *v20;
          *unsigned int v20 = *v21;
          *(unsigned char *)(a1 + 14) = *(unsigned char *)(a1 + 19);
          *uint64_t v21 = v28;
          *(unsigned char *)(a1 + 19) = v27;
          if (*v20 < *v19)
          {
            char v29 = *(unsigned char *)(a1 + 9);
            unsigned int v30 = *v19;
            *char v19 = *v20;
            *(unsigned char *)(a1 + 9) = *(unsigned char *)(a1 + 14);
            *unsigned int v20 = v30;
            *(unsigned char *)(a1 + 14) = v29;
            if (*(_DWORD *)(a1 + 5) < *(_DWORD *)a1)
            {
              char v31 = *(unsigned char *)(a1 + 4);
              unsigned int v32 = *(_DWORD *)a1;
              *(_DWORD *)a1 = *v19;
              *(unsigned char *)(a1 + 4) = *(unsigned char *)(a1 + 9);
              *char v19 = v32;
              *(unsigned char *)(a1 + 9) = v31;
            }
          }
        }
      }
      return 1;
    default:
      char v10 = (_DWORD *)(a1 + 10);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>((unsigned int *)a1, (unsigned int *)(a1 + 5), (unsigned int *)(a1 + 10));
      uint64_t v11 = a1 + 15;
      if (a1 + 15 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    unsigned int v14 = *(_DWORD *)v11;
    if (*(_DWORD *)v11 < *v10)
    {
      char v15 = *(unsigned char *)(v11 + 4);
      uint64_t v16 = v12;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        *(_DWORD *)(v17 + 15) = *(_DWORD *)(a1 + v16 + 10);
        *(unsigned char *)(v17 + 19) = *(unsigned char *)(a1 + v16 + 14);
        if (v16 == -10) {
          break;
        }
        v16 -= 5;
        if (v14 >= *(_DWORD *)(v17 + 5))
        {
          uint64_t v18 = a1 + v16 + 15;
          goto LABEL_13;
        }
      }
      uint64_t v18 = a1;
LABEL_13:
      *(_DWORD *)uint64_t v18 = v14;
      *(unsigned char *)(v18 + 4) = v15;
      if (++v13 == 8) {
        return v11 + 5 == a2;
      }
    }
    char v10 = (_DWORD *)v11;
    v12 += 5;
    v11 += 5;
    if (v11 == a2) {
      return 1;
    }
  }
}

unsigned int *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::index_of_input_slow(AG::Node &,AG::InputEdge::Comparator)::$_0 &,AG::InputEdge*>((unsigned int *)a1, (unsigned int *)a2, (unsigned int *)a3);
  if (*(_DWORD *)a4 < *(_DWORD *)a3)
  {
    char v9 = *(unsigned char *)(a3 + 4);
    unsigned int v10 = *(_DWORD *)a3;
    char v11 = *(unsigned char *)(a4 + 4);
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(unsigned char *)(a3 + 4) = v11;
    *(_DWORD *)a4 = v10;
    *(unsigned char *)(a4 + 4) = v9;
    if (*(_DWORD *)a3 < *(_DWORD *)a2)
    {
      char v12 = *(unsigned char *)(a2 + 4);
      unsigned int v13 = *(_DWORD *)a2;
      char v14 = *(unsigned char *)(a3 + 4);
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(unsigned char *)(a2 + 4) = v14;
      *(_DWORD *)a3 = v13;
      *(unsigned char *)(a3 + 4) = v12;
      if (*(_DWORD *)a2 < *(_DWORD *)a1)
      {
        char v15 = *(unsigned char *)(a1 + 4);
        unsigned int v16 = *(_DWORD *)a1;
        char v17 = *(unsigned char *)(a2 + 4);
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(unsigned char *)(a1 + 4) = v17;
        *(_DWORD *)a2 = v16;
        *(unsigned char *)(a2 + 4) = v15;
      }
    }
  }
  return result;
}

BOOL AG::Graph::KeyTable::KeyTable(util::Heap &)::{lambda(char const*,char const*)#1}::__invoke(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *,false>(uint64_t result, unsigned int *a2, uint64_t a3, char a4)
{
  char v9 = (unsigned int *)result;
  while (2)
  {
    unsigned int v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          char v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = ((char *)a2 - (char *)v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unsigned int v39 = *(a2 - 2);
                unsigned int v40 = *v10;
                if (v39 < *v10)
                {
                  *unsigned int v10 = v39;
                  *(a2 - 2) = v40;
                  unsigned int v41 = v10[1];
                  v10[1] = *(a2 - 1);
                  *(a2 - 1) = v41;
                }
                break;
              case 3uLL:
                BOOL result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(v10, v10 + 2, a2 - 2);
                break;
              case 4uLL:
                BOOL result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(v10, v10 + 2, v10 + 4, a2 - 2);
                break;
              case 5uLL:
                BOOL result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(v10, v10 + 2, v10 + 4, v10 + 6);
                unsigned int v42 = *(a2 - 2);
                unsigned int v43 = v10[6];
                if (v42 < v43)
                {
                  v10[6] = v42;
                  *(a2 - 2) = v43;
                  unsigned int v44 = v10[7];
                  v10[7] = *(a2 - 1);
                  *(a2 - 1) = v44;
                  unsigned int v45 = v10[6];
                  unsigned int v46 = v10[4];
                  if (v45 < v46)
                  {
                    unsigned int v47 = v10[5];
                    unsigned int v48 = v10[7];
                    v10[4] = v45;
                    v10[5] = v48;
                    v10[6] = v46;
                    v10[7] = v47;
                    unsigned int v49 = v10[2];
                    if (v45 < v49)
                    {
                      unsigned int v50 = v10[3];
                      void v10[2] = v45;
                      v10[3] = v48;
                      v10[4] = v49;
                      v10[5] = v50;
                      unsigned int v51 = *v10;
                      if (v45 < *v10)
                      {
                        unsigned int v52 = v10[1];
                        *unsigned int v10 = v45;
                        v10[1] = v48;
                        void v10[2] = v51;
                        v10[3] = v52;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            char v53 = v10 + 2;
            BOOL v55 = v10 == a2 || v53 == a2;
            if (a4)
            {
              if (!v55)
              {
                uint64_t v56 = 0;
                unsigned int v57 = v10;
                do
                {
                  unsigned int v58 = v57[2];
                  unsigned int v59 = *v57;
                  unsigned int v57 = v53;
                  if (v58 < v59)
                  {
                    unsigned int v61 = *v53;
                    unsigned int v60 = v53[1];
                    uint64_t v62 = v56;
                    while (1)
                    {
                      unint64_t v63 = (char *)v10 + v62;
                      int v64 = *(unsigned int *)((char *)v10 + v62 + 4);
                      *((_DWORD *)v63 + 2) = v59;
                      *((_DWORD *)v63 + 3) = v64;
                      if (!v62) {
                        break;
                      }
                      unsigned int v59 = *((_DWORD *)v63 - 2);
                      v62 -= 8;
                      if (v59 <= v61)
                      {
                        char v65 = (unsigned int *)((char *)v10 + v62 + 8);
                        goto LABEL_84;
                      }
                    }
                    char v65 = v10;
LABEL_84:
                    *char v65 = v61;
                    v65[1] = v60;
                  }
                  char v53 = v57 + 2;
                  v56 += 8;
                }
                while (v57 + 2 != a2);
              }
            }
            else if (!v55)
            {
              BOOL v93 = v10 + 3;
              do
              {
                unsigned int v94 = v9[2];
                unsigned int v95 = *v9;
                char v9 = v53;
                if (v94 < v95)
                {
                  uint64_t v96 = *(void *)v53;
                  unsigned int v97 = v93;
                  do
                  {
                    unint64_t v98 = v97;
                    *(v97 - 1) = v95;
                    unsigned int v99 = *(v97 - 2);
                    v97 -= 2;
                    unsigned int *v98 = v99;
                    unsigned int v95 = *(v98 - 5);
                  }
                  while (v95 > v96);
                  *(void *)(v97 - 1) = v96;
                }
                char v53 = v9 + 2;
                v93 += 2;
              }
              while (v9 + 2 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  int64_t v70 = &v10[2 * v69];
                  if (2 * v68 + 2 < (uint64_t)v12)
                  {
                    unsigned int v72 = *v70;
                    unsigned int v71 = v70[2];
                    if (*v70 <= v71) {
                      unsigned int v72 = v70[2];
                    }
                    if (*v70 < v71)
                    {
                      v70 += 2;
                      uint64_t v69 = 2 * v68 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v72 = *v70;
                  }
                  unsigned int v73 = &v10[2 * v68];
                  if (v72 >= *v73)
                  {
                    unsigned int v74 = *v73;
                    unsigned int v75 = v73[1];
                    do
                    {
                      BOOL result = (uint64_t)v73;
                      unsigned int v73 = v70;
                      *(_DWORD *)BOOL result = v72;
                      *(_DWORD *)(result + 4) = v70[1];
                      if (v66 < v69) {
                        break;
                      }
                      BOOL result = (2 * v69) | 1;
                      int64_t v70 = &v10[2 * result];
                      uint64_t v69 = 2 * v69 + 2;
                      if (v69 < (uint64_t)v12)
                      {
                        unsigned int v72 = *v70;
                        unsigned int v76 = v70[2];
                        if (*v70 <= v76) {
                          unsigned int v72 = v70[2];
                        }
                        if (*v70 >= v76) {
                          uint64_t v69 = result;
                        }
                        else {
                          v70 += 2;
                        }
                      }
                      else
                      {
                        unsigned int v72 = *v70;
                        uint64_t v69 = result;
                      }
                    }
                    while (v72 >= v74);
                    *unsigned int v73 = v74;
                    v73[1] = v75;
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              uint64_t v77 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v78 = 0;
                uint64_t v79 = *(void *)v10;
                unsigned int v80 = v10;
                do
                {
                  uint64_t v81 = &v80[2 * v78 + 2];
                  uint64_t v82 = (2 * v78) | 1;
                  uint64_t v78 = 2 * v78 + 2;
                  if (v78 < v77)
                  {
                    unsigned int v84 = *v81;
                    unsigned int v83 = v81[2];
                    if (*v81 <= v83) {
                      unsigned int v84 = v81[2];
                    }
                    if (*v81 >= v83) {
                      uint64_t v78 = v82;
                    }
                    else {
                      v81 += 2;
                    }
                  }
                  else
                  {
                    unsigned int v84 = *v81;
                    uint64_t v78 = v82;
                  }
                  *unsigned int v80 = v84;
                  v80[1] = v81[1];
                  unsigned int v80 = v81;
                }
                while (v78 <= (uint64_t)((unint64_t)(v77 - 2) >> 1));
                if (v81 == a2 - 2)
                {
                  *(void *)uint64_t v81 = v79;
                }
                else
                {
                  unsigned int *v81 = *(a2 - 2);
                  v81[1] = *(a2 - 1);
                  *((void *)a2 - 1) = v79;
                  uint64_t v85 = (char *)v81 - (char *)v10 + 8;
                  if (v85 >= 9)
                  {
                    unint64_t v86 = (((unint64_t)v85 >> 3) - 2) >> 1;
                    uint64_t v87 = &v10[2 * v86];
                    unsigned int v88 = *v87;
                    if (*v87 < *v81)
                    {
                      unsigned int v89 = *v81;
                      unsigned int v90 = v81[1];
                      do
                      {
                        uint64_t v91 = v81;
                        uint64_t v81 = v87;
                        unsigned int *v91 = v88;
                        v91[1] = v87[1];
                        if (!v86) {
                          break;
                        }
                        unint64_t v86 = (v86 - 1) >> 1;
                        uint64_t v87 = &v10[2 * v86];
                        unsigned int v88 = *v87;
                      }
                      while (*v87 < v89);
                      unsigned int *v81 = v89;
                      v81[1] = v90;
                    }
                  }
                }
                a2 -= 2;
              }
              while (v77-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          char v14 = &v10[2 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(v9, &v9[2 * (v12 >> 1)], a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(v9 + 2, v14 - 2, a2 - 4);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(v9 + 4, &v9[2 * v13 + 2], a2 - 6);
            BOOL result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(v14 - 2, v14, &v9[2 * v13 + 2]);
            uint64_t v15 = *(void *)v9;
            *(void *)char v9 = *(void *)v14;
            *(void *)char v14 = v15;
          }
          else
          {
            BOOL result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(&v9[2 * (v12 >> 1)], v9, a2 - 2);
          }
          --a3;
          if ((a4 & 1) != 0 || *(v9 - 2) < *v9) {
            break;
          }
          uint64_t v29 = *(void *)v9;
          if (*(a2 - 2) <= *(void *)v9)
          {
            char v31 = v9 + 2;
            do
            {
              unsigned int v10 = v31;
              if (v31 >= a2) {
                break;
              }
              v31 += 2;
            }
            while (*v10 <= v29);
          }
          else
          {
            unsigned int v10 = v9;
            do
            {
              unsigned int v30 = v10[2];
              v10 += 2;
            }
            while (v30 <= v29);
          }
          unsigned int v32 = a2;
          if (v10 < a2)
          {
            unsigned int v32 = a2;
            do
            {
              unsigned int v33 = *(v32 - 2);
              v32 -= 2;
            }
            while (v33 > v29);
          }
          if (v10 < v32)
          {
            unsigned int v34 = *v10;
            unsigned int v35 = *v32;
            do
            {
              *unsigned int v10 = v35;
              unsigned int *v32 = v34;
              unsigned int v36 = v10[1];
              v10[1] = v32[1];
              v32[1] = v36;
              do
              {
                unsigned int v37 = v10[2];
                v10 += 2;
                unsigned int v34 = v37;
              }
              while (v37 <= v29);
              do
              {
                unsigned int v38 = *(v32 - 2);
                v32 -= 2;
                unsigned int v35 = v38;
              }
              while (v38 > v29);
            }
            while (v10 < v32);
          }
          BOOL v4 = v10 - 2 >= v9;
          BOOL v5 = v10 - 2 == v9;
          if (v10 - 2 != v9)
          {
            unsigned int *v9 = *(v10 - 2);
            v9[1] = *(v10 - 1);
          }
          a4 = 0;
          *((void *)v10 - 1) = v29;
        }
        uint64_t v16 = 0;
        uint64_t v17 = *(void *)v9;
        do
        {
          unsigned int v18 = v9[v16 + 2];
          v16 += 2;
        }
        while (v18 < v17);
        char v19 = &v9[v16];
        unsigned int v20 = a2;
        if (v16 == 2)
        {
          unsigned int v20 = a2;
          do
          {
            if (v19 >= v20) {
              break;
            }
            unsigned int v22 = *(v20 - 2);
            v20 -= 2;
          }
          while (v22 >= v17);
        }
        else
        {
          do
          {
            unsigned int v21 = *(v20 - 2);
            v20 -= 2;
          }
          while (v21 >= v17);
        }
        if (v19 >= v20)
        {
          unsigned int v10 = &v9[v16];
        }
        else
        {
          unsigned int v23 = *v20;
          unsigned int v10 = &v9[v16];
          char v24 = v20;
          do
          {
            *unsigned int v10 = v23;
            *char v24 = v18;
            unsigned int v25 = v10[1];
            v10[1] = v24[1];
            v24[1] = v25;
            do
            {
              unsigned int v26 = v10[2];
              v10 += 2;
              unsigned int v18 = v26;
            }
            while (v26 < v17);
            do
            {
              unsigned int v27 = *(v24 - 2);
              v24 -= 2;
              unsigned int v23 = v27;
            }
            while (v27 >= v17);
          }
          while (v10 < v24);
        }
        if (v10 - 2 != v9)
        {
          unsigned int *v9 = *(v10 - 2);
          v9[1] = *(v10 - 1);
        }
        *((void *)v10 - 1) = v17;
        if (v19 >= v20) {
          break;
        }
LABEL_33:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *,false>(v9, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(v9, v10 - 2);
      BOOL result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(v10, a2);
      if (result) {
        break;
      }
      if (!v28) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 2;
    if (!v28) {
      continue;
    }
    return result;
  }
}

unsigned int *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *result;
  unsigned int v5 = *a3;
  if (*a2 < *result)
  {
    if (v5 >= v3)
    {
      *BOOL result = v3;
      *a2 = v4;
      unsigned int v10 = result[1];
      result[1] = a2[1];
      a2[1] = v10;
      unsigned int v11 = *a2;
      if (*a3 >= *a2) {
        return result;
      }
      *a2 = *a3;
      *a3 = v11;
      unsigned int v6 = a3 + 1;
      BOOL result = a2 + 1;
    }
    else
    {
      *result++ = v5;
      *a3 = v4;
      unsigned int v6 = a3 + 1;
    }
    char v7 = v6;
    goto LABEL_10;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    char v7 = a2 + 1;
    unsigned int v8 = a2[1];
    a2[1] = a3[1];
    a3[1] = v8;
    unsigned int v9 = *result;
    if (*a2 < *result)
    {
      *result++ = *a2;
      *a2 = v9;
LABEL_10:
      unsigned int v12 = *result;
      *BOOL result = *v7;
      *char v7 = v12;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 2);
      unsigned int v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        unsigned int v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(a1, a1 + 2, a1 + 4, a1 + 6);
      unsigned int v20 = *(a2 - 2);
      unsigned int v21 = a1[6];
      if (v20 < v21)
      {
        a1[6] = v20;
        *(a2 - 2) = v21;
        unsigned int v22 = a1[7];
        a1[7] = *(a2 - 1);
        *(a2 - 1) = v22;
        unsigned int v23 = a1[6];
        unsigned int v24 = a1[4];
        if (v23 < v24)
        {
          unsigned int v25 = a1[5];
          unsigned int v26 = a1[7];
          a1[4] = v23;
          a1[5] = v26;
          a1[6] = v24;
          a1[7] = v25;
          unsigned int v27 = a1[2];
          if (v23 < v27)
          {
            unsigned int v28 = a1[3];
            a1[2] = v23;
            a1[3] = v26;
            a1[4] = v27;
            a1[5] = v28;
            unsigned int v29 = *a1;
            if (v23 < *a1)
            {
              unsigned int v30 = a1[1];
              *a1 = v23;
              a1[1] = v26;
              a1[2] = v29;
              a1[3] = v30;
            }
          }
        }
      }
      return 1;
    default:
      unsigned int v9 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(a1, a1 + 2, a1 + 4);
      unsigned int v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    unsigned int v13 = *v9;
    if (*v10 < *v9)
    {
      unsigned int v15 = *v10;
      unsigned int v14 = v10[1];
      uint64_t v16 = v11;
      while (1)
      {
        uint64_t v17 = (unsigned int *)((char *)a1 + v16);
        int v18 = *(unsigned int *)((char *)a1 + v16 + 20);
        v17[6] = v13;
        v17[7] = v18;
        if (v16 == -16) {
          break;
        }
        unsigned int v13 = v17[2];
        v16 -= 8;
        if (v13 <= v15)
        {
          char v19 = (unsigned int *)((char *)a1 + v16 + 24);
          goto LABEL_13;
        }
      }
      char v19 = a1;
LABEL_13:
      *char v19 = v15;
      v19[1] = v14;
      if (++v12 == 8) {
        return v10 + 2 == a2;
      }
    }
    unsigned int v9 = v10;
    v11 += 8;
    v10 += 2;
    if (v10 == a2) {
      return 1;
    }
  }
}

unsigned int *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Graph::TreeDataElement::sort_nodes(void)::$_0 &,std::pair<AG::data::ptr<AG::Graph::TreeElement>,AG::data::ptr<AG::Node>> *>(a1, a2, a3);
  unsigned int v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    unsigned int v10 = a3[1];
    a3[1] = a4[1];
    a4[1] = v10;
    unsigned int v11 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v11;
      unsigned int v12 = a2[1];
      a2[1] = a3[1];
      a3[1] = v12;
      unsigned int v13 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v13;
        unsigned int v14 = a1[1];
        a1[1] = a2[1];
        a2[1] = v14;
      }
    }
  }
  return result;
}

uint64_t std::unique_ptr<AG::AttributeType,AG::AttributeType::deleter>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)(result + 32) + 8);
    if (v4) {
      return v4();
    }
  }
  return result;
}

uint64_t std::unique_ptr<std::unordered_map<AG::Subgraph *,AG::Graph::TreeDataElement>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::~__hash_table(result);
    JUMPOUT(0x1B3E84B80);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      unsigned int v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[3];
      if (v4) {
        free(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

unint64_t util::Table<unsigned long,AG::Graph::Context *>::for_each<AG::Graph::main_context(void)::$_0>(AG::Graph::main_context(void)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke(unint64_t result, uint64_t a2, void **a3)
{
  unsigned int v3 = a3[1];
  if (*v3 > result)
  {
    *unsigned int v3 = result;
    **a3 = a2;
  }
  return result;
}

void util::Table<unsigned long,AG::Graph::Context *>::for_each<AG::Graph::update_deadline(void)::$_0>(AG::Graph::update_deadline(void)::$_0 const&)const::{lambda(void const*,void const*,void const*)#1}::__invoke(uint64_t a1, uint64_t a2, unint64_t **a3)
{
  unint64_t v3 = *(void *)(a2 + 56);
  if (v3 >= **a3) {
    unint64_t v3 = **a3;
  }
  **a3 = v3;
}

void *AG::vector<AG::AttributeID,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 6) + (*((void *)__dst + 6) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 6) + (*((void *)__dst + 6) >> 1);
  }
  uint64_t result = AG::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 4), __dst, 8uLL, (size_t *)__dst + 6, v3);
  *((void *)__dst + 4) = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,4ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  unsigned int v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, 4 * a5);
      free(v7);
      unsigned int v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(4 * a5);
    size_t v9 = v8 >> 2;
    if (v8 >> 2 != *a4)
    {
      unsigned int v10 = malloc_type_realloc(v7, v8, 0x8734B07FuLL);
      if (!v10) {
        AG::precondition_failure((AG *)"allocation failure", v11);
      }
      unsigned int v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 4 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void std::default_delete<AG::Graph::KeyTable>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    util::UntypedTable::~UntypedTable((util::UntypedTable *)(a2 + 16));
    size_t v3 = *(void **)a2;
    unint64_t v4 = *(unsigned int *)(a2 + 8);
    if (v4)
    {
      for (unint64_t i = 0; i < v4; ++i)
      {
        unsigned int v6 = (void *)v3[i];
        v3[i] = 0;
        if (v6)
        {
          free(v6);
          unint64_t v4 = *(unsigned int *)(a2 + 8);
        }
      }
      size_t v3 = *(void **)a2;
    }
    if (v3) {
      free(v3);
    }
    JUMPOUT(0x1B3E84B80);
  }
}

uint64_t AG::DebugServer::start(AG::DebugServer *this)
{
  uint64_t v1 = AG::DebugServer::_shared_server;
  if ((this & 1) != 0 && !AG::DebugServer::_shared_server)
  {
    if (os_variant_has_internal_diagnostics()) {
      operator new();
    }
    return AG::DebugServer::_shared_server;
  }
  return v1;
}

void sub_1AF92335C(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10A0C40F9356B9ALL);
  _Unwind_Resume(a1);
}

uint64_t AG::DebugServer::stop(AG::DebugServer *this)
{
  uint64_t result = AG::DebugServer::_shared_server;
  if (AG::DebugServer::_shared_server)
  {
    AG::DebugServer::~DebugServer((id *)AG::DebugServer::_shared_server);
    uint64_t result = MEMORY[0x1B3E84B80]();
    AG::DebugServer::_shared_server = 0;
  }
  return result;
}

AG::DebugServer *AG::DebugServer::DebugServer(AG::DebugServer *this, char a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  *(void *)this = 0xFFFFFFFFLL;
  *((_WORD *)this + 4) = 0;
  uint32_t v4 = arc4random();
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 3) = v4;
  *((_OWORD *)this + 2) = 0u;
  int v5 = socket(2, 1, 0);
  *(_DWORD *)this = v5;
  if (v5 < 0)
  {
    perror("AGDebugServer: socket");
    return this;
  }
  fcntl(v5, 2, 1);
  int v18 = 1;
  setsockopt(*(_DWORD *)this, 0xFFFF, 4130, &v18, 4u);
  v26.sa_family = 2;
  *(_WORD *)v26.sa_data = 0;
  if ((a2 & 2) != 0) {
    int v6 = 0;
  }
  else {
    int v6 = 16777343;
  }
  *(_DWORD *)&v26.sa_data[2] = v6;
  if (bind(*(_DWORD *)this, &v26, 0x10u))
  {
    perror("AGDebugServer: bind");
    AG::DebugServer::shutdown(this);
    return this;
  }
  socklen_t v17 = 16;
  if (getsockname(*(_DWORD *)this, &v26, &v17))
  {
    unsigned int v10 = "AGDebugServer: getsockname";
LABEL_27:
    perror(v10);
    AG::DebugServer::shutdown(this);
    return this;
  }
  *((_DWORD *)this + 1) = bswap32(*(unsigned int *)&v26.sa_data[2]);
  *((_WORD *)this + 4) = bswap32(*(unsigned __int16 *)v26.sa_data) >> 16;
  if ((a2 & 2) != 0)
  {
    v25[0] = 0;
    if (!getifaddrs(v25))
    {
      if (v25[0])
      {
        unsigned int v7 = v25[0];
        while (1)
        {
          ifa_addr = v7->ifa_addr;
          if (ifa_addr)
          {
            if (ifa_addr->sa_family == 2)
            {
              unsigned int v9 = *(_DWORD *)&ifa_addr->sa_data[2];
              if (v9 != 16777343) {
                break;
              }
            }
          }
          unsigned int v7 = v7->ifa_next;
          if (!v7) {
            goto LABEL_20;
          }
        }
        *((_DWORD *)this + 1) = bswap32(v9);
      }
LABEL_20:
      MEMORY[0x1B3E84E30]();
    }
  }
  if (listen(*(_DWORD *)this, 5))
  {
    unsigned int v10 = "AGDebugServer: listen";
    goto LABEL_27;
  }
  unsigned int v11 = dispatch_source_create(MEMORY[0x1E4F14478], *(int *)this, 0, MEMORY[0x1E4F14428]);

  *((void *)this + 2) = v11;
  dispatch_set_context(v11, this);
  dispatch_source_set_event_handler_f(*((dispatch_source_t *)this + 2), (dispatch_function_t)AG::DebugServer::accept_handler);
  dispatch_resume(*((dispatch_object_t *)this + 2));
  *(_DWORD *)&v26.sa_data[2] = bswap32(*((_DWORD *)this + 1));
  unsigned int v12 = (AG *)inet_ntop(2, &v26.sa_data[2], (char *)v25, 0x20u);
  unsigned int v13 = AG::misc_log(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = *((unsigned __int16 *)this + 4);
    int v15 = *((_DWORD *)this + 3);
    *(_DWORD *)buf = 136315650;
    unsigned int v20 = v25;
    __int16 v21 = 1024;
    int v22 = v14;
    __int16 v23 = 1024;
    int v24 = v15;
    _os_log_impl(&dword_1AF901000, v13, OS_LOG_TYPE_DEFAULT, "debug server graph://%s:%d/?token=%u", buf, 0x18u);
  }
  fprintf((FILE *)*MEMORY[0x1E4F143C8], "debug server graph://%s:%d/?token=%u\n", (const char *)v25, *((unsigned __int16 *)this + 4), *((_DWORD *)this + 3));
  return this;
}

void sub_1AF9236CC(_Unwind_Exception *a1)
{
  AG::vector<std::unique_ptr<AG::DebugServer::Connection>,0ul,unsigned long>::~vector(v1 + 24);
  util::objc_ptr<NSObject  {objcproto18OS_dispatch_source}*>::~objc_ptr(v2);
  _Unwind_Resume(a1);
}

uint64_t AG::DebugServer::shutdown(AG::DebugServer *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    dispatch_source_set_event_handler_f(v2, 0);
    dispatch_set_context(*((dispatch_object_t *)this + 2), 0);

    *((void *)this + 2) = 0;
  }
  uint64_t result = *(unsigned int *)this;
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = close(result);
    *(_DWORD *)this = -1;
  }
  return result;
}

void AG::DebugServer::accept_handler(AG::DebugServer *this, void *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  socklen_t v3 = 16;
  if ((accept(*(_DWORD *)this, &v4, &v3) & 0x80000000) == 0)
  {
    fcntl(*(_DWORD *)this, 2, 1);
    operator new();
  }
  perror("AGDebugServer: accept");
}

void sub_1AF923854(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10A0C408A00E5F2);
  _Unwind_Resume(a1);
}

uint64_t AG::vector<std::unique_ptr<AG::DebugServer::Connection>,0ul,unsigned long>::~vector(uint64_t a1)
{
  uint64_t v2 = *(AG::DebugServer::Connection ***)a1;
  if (*(void *)(a1 + 8))
  {
    unint64_t v3 = 0;
    do
    {
      std::unique_ptr<AG::DebugServer::Connection>::reset[abi:ne180100](v2, 0);
      ++v3;
      ++v2;
    }
    while (v3 < *(void *)(a1 + 8));
    uint64_t v2 = *(AG::DebugServer::Connection ***)a1;
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

id *util::objc_ptr<NSObject  {objcproto18OS_dispatch_source}*>::~objc_ptr(id *a1)
{
  return a1;
}

void AG::DebugServer::~DebugServer(id *this)
{
  AG::DebugServer::shutdown((AG::DebugServer *)this);
  uint64_t v2 = (AG::DebugServer::Connection **)this[3];
  if (this[4])
  {
    unint64_t v3 = 0;
    do
    {
      std::unique_ptr<AG::DebugServer::Connection>::reset[abi:ne180100](v2, 0);
      ++v3;
      ++v2;
    }
    while (v3 < (unint64_t)this[4]);
    uint64_t v2 = (AG::DebugServer::Connection **)this[3];
  }
  if (v2) {
    free(v2);
  }
}

CFURLRef AG::DebugServer::copy_url(AG::DebugServer *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)this & 0x80000000) != 0) {
    return 0;
  }
  unsigned int v4 = bswap32(*((_DWORD *)this + 1));
  inet_ntop(2, &v4, v6, 0x20u);
  snprintf_l(__s, 0x100uLL, 0, "graph://%s:%d/?token=%u", v6, *((unsigned __int16 *)this + 4), *((_DWORD *)this + 3));
  CFIndex v2 = strlen(__s);
  return CFURLCreateWithBytes(0, (const UInt8 *)__s, v2, 0x8000100u, 0);
}

void AG::DebugServer::run(AG::DebugServer *this, int a2)
{
  char v3 = 0;
  __darwin_time_t v4 = a2;
LABEL_2:
  while ((v3 & 1) == 0 || *((void *)this + 4))
  {
    memset(&v20, 0, sizeof(v20));
    int v5 = *(_DWORD *)this;
    if (__darwin_check_fd_set_overflow(*(_DWORD *)this, &v20, 0)) {
      *(__int32_t *)((char *)v20.fds_bits + (((unint64_t)v5 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v5;
    }
    int v6 = *(_DWORD *)this;
    uint64_t v7 = *((void *)this + 4);
    if (v7)
    {
      size_t v8 = (uint64_t *)*((void *)this + 3);
      uint64_t v9 = 8 * v7;
      do
      {
        int v10 = *(_DWORD *)(*v8 + 8);
        if (__darwin_check_fd_set_overflow(v10, &v20, 0)) {
          *(__int32_t *)((char *)v20.fds_bits + (((unint64_t)v10 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v10;
        }
        uint64_t v11 = *v8++;
        int v12 = *(_DWORD *)(v11 + 8);
        if (v6 <= v12) {
          int v6 = v12;
        }
        v9 -= 8;
      }
      while (v9);
    }
    v19.tv_seCC_SHA1_CTX c = v4;
    v19.tv_useCC_SHA1_CTX c = 0;
    if (select(v6 + 1, 0, &v20, 0, &v19) <= 0)
    {
      if (*__error() != 35)
      {
        perror("AGDebugServer: select");
        return;
      }
    }
    else
    {
      int v13 = *(_DWORD *)this;
      if (__darwin_check_fd_set_overflow(*(_DWORD *)this, &v20, 0)
        && ((*(unsigned int *)((char *)v20.fds_bits + (((unint64_t)v13 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v13) & 1) != 0)
      {
        AG::DebugServer::accept_handler(this, v14);
        char v3 = 1;
      }
      if (*((void *)this + 4))
      {
        uint64_t v15 = 0;
        do
        {
          while (1)
          {
            int v16 = *(_DWORD *)(*(void *)(*((void *)this + 3) + 8 * v15) + 8);
            if (__darwin_check_fd_set_overflow(v16, &v20, 0))
            {
              if ((*(unsigned int *)((char *)v20.fds_bits + (((unint64_t)v16 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v16)) {
                break;
              }
            }
            if ((unint64_t)++v15 >= *((void *)this + 4)) {
              goto LABEL_2;
            }
          }
          int v17 = *(_DWORD *)(*(void *)(*((void *)this + 3) + 8 * v15) + 8);
          if (__darwin_check_fd_set_overflow(v17, &v20, 0)) {
            *(__int32_t *)((char *)v20.fds_bits + (((unint64_t)v17 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v17);
          }
          AG::DebugServer::Connection::handler(*(AG::DebugServer::Connection **)(*((void *)this + 3) + 8 * v15), v18);
          uint64_t v15 = 0;
        }
        while (*((void *)this + 4));
      }
    }
  }
}

void AG::DebugServer::Connection::handler(AG::DebugServer::Connection *this, void *a2)
{
  CFIndex v2 = (unsigned int *)this;
  int capacity_4 = 0;
  if (v13 != *(_DWORD *)(*(void *)v2 + 12)) {
    goto LABEL_12;
  }
  CFIndex v3 = capacity;
  CFDataRef Mutable = CFDataCreateMutable(0, capacity);
  int v5 = Mutable;
  theData[1] = Mutable;
  if (!Mutable) {
    goto LABEL_12;
  }
  CFDataSetLength(Mutable, v3);
  int v6 = (AG::_anonymous_namespace_ *)v2[2];
  MutableBytePtr = CFDataGetMutableBytePtr(v5);
  {
    AG::DebugServer::receive((uint64_t)v5, theData);
    CFDataRef v8 = theData[0];
    if (theData[0])
    {
      unint64_t Length = CFDataGetLength(theData[0]);
      unsigned int capacity = Length;
      if (!HIDWORD(Length)
      {
        int v10 = (AG::_anonymous_namespace_ *)v2[2];
        BytePtr = CFDataGetBytePtr(v8);
          CFIndex v2 = 0;
      }
      CFRelease(v8);
    }
  }
  CFRelease(v5);
  if (v2) {
LABEL_12:
  }
    AG::DebugServer::close_connection(*(AG::DebugServer::Connection **)v2, (AG::DebugServer::Connection *)v2);
}

void sub_1AF923DE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  util::cf_ptr<__CFData *>::~cf_ptr((const void **)va);
  AG::DebugServer::close_connection(*v2, (AG::DebugServer::Connection *)v2);
  _Unwind_Resume(a1);
}

AG::DebugServer::Connection *AG::DebugServer::close_connection(AG::DebugServer::Connection *this, AG::DebugServer::Connection *a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    CFIndex v3 = (AG::DebugServer::Connection **)*((void *)this + 3);
    uint64_t v4 = *((void *)this + 4);
    for (unint64_t i = v3; *i != a2; ++i)
    {
      if (!--v4) {
        return this;
      }
    }
    uint64_t v6 = v2 - 1;
    *unint64_t i = v3[v6];
    v3[v6] = a2;
    *((void *)this + 4) = v6;
    return std::unique_ptr<AG::DebugServer::Connection>::reset[abi:ne180100]((AG::DebugServer::Connection **)(*((void *)this + 3) + 8 * v6), 0);
  }
  return this;
}

void AG::DebugServer::receive(uint64_t a1@<X3>, void *a2@<X8>)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1B3E85040]();
  uint64_t v5 = [MEMORY[0x1E4F28D90] JSONObjectWithData:a1 options:0 error:0];
  if (!v5) {
    goto LABEL_14;
  }
  uint64_t v6 = (void *)v5;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_14;
  }
  uint64_t v7 = (void *)[v6 objectForKeyedSubscript:@"command"];
  if (![v7 isEqual:@"graph/description"])
  {
    if ([v7 isEqual:@"profiler/start"])
    {
      int v13 = (void *)[v6 objectForKeyedSubscript:@"flags"];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        uint64_t v14 = [v13 unsignedIntValue] | 1;
      }
      else {
        uint64_t v14 = 1;
      }
      AG::Graph::all_start_profiling((AG::Graph *)v14);
    }
    else
    {
      uint64_t v15 = (AG::Graph *)[v7 isEqual:@"profiler/stop"];
      if (v15)
      {
        AG::Graph::all_stop_profiling(v15);
      }
      else
      {
        int v16 = (AG::Graph *)[v7 isEqual:@"profiler/reset"];
        if (v16)
        {
          AG::Graph::all_reset_profile(v16);
        }
        else if ([v7 isEqual:@"profiler/mark"])
        {
          int v17 = (void *)[v6 objectForKeyedSubscript:@"name"];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            int v18 = (AG::Graph *)[v17 UTF8String];
            AG::Graph::all_mark_profile(v18, v19);
          }
        }
        else if ([v7 isEqual:@"tracing/start"])
        {
          fd_set v20 = (void *)[v6 objectForKeyedSubscript:@"flags"];
          objc_opt_class();
          if (objc_opt_isKindOfClass()) {
            char v21 = [v20 unsignedIntValue] | 1;
          }
          else {
            char v21 = 1;
          }
          unsigned int v36 = 0;
          unint64_t v37 = 0;
          unint64_t v38 = 0;
          __int16 v23 = (void *)[v6 objectForKeyedSubscript:@"subsystems"];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            long long v34 = 0u;
            long long v35 = 0u;
            long long v32 = 0u;
            long long v33 = 0u;
            uint64_t v24 = [v23 countByEnumeratingWithState:&v32 objects:v39 count:16];
            if (v24)
            {
              uint64_t v25 = *(void *)v33;
              do
              {
                uint64_t v26 = 0;
                do
                {
                  if (*(void *)v33 != v25) {
                    objc_enumerationMutation(v23);
                  }
                  uint64_t v27 = *(void **)(*((void *)&v32 + 1) + 8 * v26);
                  objc_opt_class();
                  if (objc_opt_isKindOfClass())
                  {
                    uint64_t v28 = [v27 UTF8String];
                    unint64_t v29 = v37;
                    unint64_t v30 = v37 + 1;
                    if (v38 < v37 + 1)
                    {
                      AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)&v36, v30);
                      unint64_t v29 = v37;
                      unint64_t v30 = v37 + 1;
                    }
                    *((void *)v36 + v29) = v28;
                    unint64_t v37 = v30;
                  }
                  ++v26;
                }
                while (v24 != v26);
                uint64_t v24 = [v23 countByEnumeratingWithState:&v32 objects:v39 count:16];
              }
              while (v24);
            }
          }
          AG::Graph::all_start_tracing(v21);
          if (v36) {
            free(v36);
          }
        }
        else
        {
          int v22 = (AG::Graph *)[v7 isEqual:@"tracing/stop"];
          if (v22)
          {
            AG::Graph::all_stop_tracing(v22);
          }
          else
          {
            char v31 = (AG::Graph *)[v7 isEqual:@"tracing/sync"];
            if (v31) {
              AG::Graph::all_sync_tracing(v31);
            }
          }
        }
      }
    }
    goto LABEL_14;
  }
  CFDataRef v8 = (NSDictionary *)[MEMORY[0x1E4F1CA60] dictionaryWithDictionary:v6];
  [(NSDictionary *)v8 setObject:@"graph/dict" forKeyedSubscript:@"format"];
  id v10 = AG::Graph::description(0, v8, v9);
  if (!v10)
  {
LABEL_14:
    int v12 = 0;
    goto LABEL_15;
  }
  uint64_t v11 = (const void *)[MEMORY[0x1E4F28D90] dataWithJSONObject:v10 options:0 error:0];
  int v12 = v11;
  if (v11) {
    CFRetain(v11);
  }
LABEL_15:
  *a2 = v12;
}

void sub_1AF924280(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17) {
    free(a17);
  }
  _Unwind_Resume(exception_object);
}

AG::DebugServer::Connection *AG::DebugServer::Connection::Connection(AG::DebugServer::Connection *this, AG::DebugServer *a2, int a3)
{
  *(void *)this = a2;
  *((_DWORD *)this + 2) = a3;
  *((void *)this + 2) = 0;
  uint64_t v4 = (id *)((char *)this + 16);
  uint64_t v5 = dispatch_source_create(MEMORY[0x1E4F14478], a3, 0, MEMORY[0x1E4F14428]);

  *((void *)this + 2) = v5;
  dispatch_set_context(v5, this);
  dispatch_source_set_event_handler_f(*((dispatch_source_t *)this + 2), (dispatch_function_t)AG::DebugServer::Connection::handler);
  dispatch_resume(*((dispatch_object_t *)this + 2));
  return this;
}

void sub_1AF924348(_Unwind_Exception *a1)
{
  util::objc_ptr<NSObject  {objcproto18OS_dispatch_source}*>::~objc_ptr(v1);
  _Unwind_Resume(a1);
}

void AG::DebugServer::Connection::~Connection(AG::DebugServer::Connection *this)
{
}

BOOL AG::anonymous namespace'::blocking_read(AG::_anonymous_namespace_ *this, uint64_t a2, unint64_t a3)
{
  if (!a3) {
    return 1;
  }
  int v5 = (int)this;
  unint64_t v6 = 0;
  do
  {
    ssize_t v7 = read(v5, (void *)(a2 + v6), a3 - v6);
    BOOL v8 = v7 != 0;
    if (!v7) {
      break;
    }
    if (v7 < 1)
    {
      if (*__error() != 4)
      {
        if (*__error() == 35 || *__error() == 35) {
        perror("AGDebugServer: read");
        }
        return 0;
      }
    }
    else
    {
      v6 += v7;
    }
  }
  while (v6 < a3);
  return v8;
}

BOOL AG::anonymous namespace'::blocking_write(AG::_anonymous_namespace_ *this, uint64_t a2, unint64_t a3)
{
  if (!a3) {
    return 1;
  }
  int v5 = (int)this;
  unint64_t v6 = 0;
  do
  {
    ssize_t v7 = write(v5, (const void *)(a2 + v6), a3 - v6);
    BOOL v8 = v7 != 0;
    if (!v7) {
      break;
    }
    if (v7 < 1)
    {
      if (*__error() != 4)
      {
        if (*__error() == 35 || *__error() == 35) {
        perror("AGDebugServer: write");
        }
        return 0;
      }
    }
    else
    {
      v6 += v7;
    }
  }
  while (v6 < a3);
  return v8;
}

const void **util::cf_ptr<__CFData const*>::~cf_ptr(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **util::cf_ptr<__CFData *>::~cf_ptr(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

AG::DebugServer::Connection *std::unique_ptr<AG::DebugServer::Connection>::reset[abi:ne180100](AG::DebugServer::Connection **a1, AG::DebugServer::Connection *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    AG::DebugServer::Connection::~Connection(result);
    JUMPOUT(0x1B3E84B80);
  }
  return result;
}

__n128 AG::Encoder::Encoder(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(unsigned char *)(a1 + 16) = 0;
  __n128 result = 0uLL;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  if (!a2)
  {
    if (a3) {
      AG::precondition_failure((AG *)"need a delegate if flush interval is non-zero", 0);
    }
  }
  return result;
}

void sub_1AF924658(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(void **)(v1 + 48);
  if (v4) {
    free(v4);
  }
  if (*v2) {
    free(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *AG::Encoder::flush(uint64_t *this)
{
  if (this[4])
  {
    uint64_t v1 = this;
    this = (uint64_t *)*this;
    if (this)
    {
      this = (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t *))*this)(this, v1);
      v1[4] = 0;
    }
  }
  return this;
}

void *AG::Encoder::encode_fixed64(void *this, uint64_t a2)
{
  uint64_t v3 = (uint64_t)this;
  unint64_t v4 = this[4];
  unint64_t v5 = v4 + 8;
  if (v4 <= 0xFFFFFFFFFFFFFFF7 && this[5] < v5) {
    this = AG::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)(this + 3), v4 + 8);
  }
  *(void *)(v3 + 32) = v5;
  *(void *)(*(void *)(v3 + 24) + v4) = a2;
  return this;
}

void *AG::Encoder::begin_length_delimited(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[4];
  unint64_t v3 = v2 + 1;
  if (v2 != -1 && this[5] < v3) {
    this = AG::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)(this + 3), v2 + 1);
  }
  v1[4] = v3;
  uint64_t v4 = v1[7];
  if (v1[8] < (unint64_t)(v4 + 1))
  {
    this = AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)(v1 + 6), v4 + 1);
    uint64_t v4 = v1[7];
  }
  *(void *)(v1[6] + 8 * v4) = v2;
  ++v1[7];
  return this;
}

void *AG::Encoder::end_length_delimited(AG::Encoder *this)
{
  uint64_t v2 = *((void *)this + 7) - 1;
  uint64_t v3 = *(void *)(*((void *)this + 6) + 8 * v2);
  *((void *)this + 7) = v2;
  __n128 result = (void *)((char *)this + 24);
  size_t v5 = *((void *)this + 4);
  uint64_t v6 = v3 + 1;
  unint64_t v7 = v5 - (v3 + 1);
  if (v7 > 0x7F)
  {
    char v9 = __clz(v7);
    uint64_t v10 = (((70 - v9 - ((unsigned __int16)(37 * (70 - v9)) >> 8)) >> 1)
         + ((37 * (70 - v9)) >> 8)) >> 2;
    size_t v11 = v5 + v10 - 1;
    if (v5 < v11 && *((void *)this + 5) < v11)
    {
      uint64_t v17 = v5 + v10 - 1;
      uint64_t v16 = v10;
      AG::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)result, v11);
      uint64_t v10 = v16;
      uint64_t v6 = v3 + 1;
      size_t v11 = v17;
    }
    *((void *)this + 4) = v11;
    __n128 result = memmove((void *)(*((void *)this + 3) + v3 + v10), (const void *)(*((void *)this + 3) + v6), v7);
    int v12 = (unsigned char *)(*((void *)this + 3) + v3);
    do
    {
      BOOL v13 = v7 > 0x7F;
      char v14 = v7 > 0x7F;
      char v15 = v7 & 0x7F;
      v7 >>= 7;
      *v12++ = v15 | (v14 << 7);
    }
    while (v13);
  }
  else
  {
    *(unsigned char *)(*result + v3) = v7;
  }
  if (!*((void *)this + 7))
  {
    unint64_t v8 = *((void *)this + 1);
    if (v8)
    {
      if (*((void *)this + 4) >= v8)
      {
        __n128 result = *(void **)this;
        if (*(void *)this)
        {
          __n128 result = (void *)(*(uint64_t (**)(void *, AG::Encoder *))*result)(result, this);
          *((void *)this + 4) = 0;
        }
      }
    }
  }
  return result;
}

void *AG::vector<unsigned char,0ul,unsigned long>::reserve_slow(uint64_t a1, size_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  __n128 result = AG::details::realloc_vector<unsigned long,1ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,1ul>(void *a1, size_t *a2, size_t size)
{
  uint64_t v4 = a1;
  if (size)
  {
    size_t v5 = malloc_good_size(size);
    if (v5 != *a2)
    {
      size_t v6 = v5;
      unint64_t v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

size_t AG::Subgraph::print(AG::Subgraph *this, uint64_t a2)
{
  v25[1] = *MEMORY[0x1E4F143B8];
  v25[0] = a2;
  size_t v3 = 2 * (int)a2;
  MEMORY[0x1F4188790](this);
  size_t v5 = (char *)v25 - v4;
  bzero((char *)v25 - v4, v6);
  memset(v5, 32, v3);
  v5[v3] = 0;
  unint64_t v7 = (FILE **)MEMORY[0x1E4F143C8];
  fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s+ %p: %u in %lu [", v5, this, *((_DWORD *)this + 6) & 0x7FFFFFFF, *((void *)this + 6));
  unsigned int v8 = *((_DWORD *)this + 4);
  if (v8)
  {
    int v9 = 1;
    uint64_t v10 = AG::data::_shared_table_bytes;
    do
    {
      uint64_t v11 = v8;
      uint64_t v12 = v10 + v8;
      int v13 = *(unsigned __int16 *)(v12 + 20);
      if (*(_WORD *)(v12 + 20))
      {
        do
        {
          while (1)
          {
            unsigned int v14 = v13 + v11;
            int v15 = (v13 + v11) & 3;
            if (v15) {
              break;
            }
            uint64_t v16 = AG::data::_shared_table_bytes + v14;
            int v13 = *(unsigned __int16 *)(v16 + 4);
            int v17 = *(unsigned __int8 *)(v16 + 6);
            if (v9) {
              int v18 = "";
            }
            else {
              int v18 = " ";
            }
            fprintf(*v7, "%s%u", v18, v14);
            if (v17) {
              fprintf(*v7, "(%u)", v17);
            }
            int v9 = 0;
            if (!v13) {
              goto LABEL_17;
            }
          }
          if (v15 == 1)
          {
            int v13 = *(unsigned __int16 *)(AG::data::_shared_table_bytes + (v14 & 0xFFFFFFFC) + 14);
          }
          else if (v15 == 2)
          {
            break;
          }
        }
        while (v13);
LABEL_17:
        uint64_t v10 = AG::data::_shared_table_bytes;
      }
      unsigned int v8 = *(_DWORD *)(v10 + v11 + 8);
    }
    while (v8);
  }
  size_t result = fwrite("]\n", 2uLL, 1uLL, *v7);
  uint64_t v20 = *((unsigned int *)this + 18);
  if (v20)
  {
    char v21 = (uint64_t *)*((void *)this + 8);
    int v22 = LODWORD(v25[0]) + 1;
    uint64_t v23 = 8 * v20;
    do
    {
      uint64_t v24 = *v21++;
      size_t result = AG::Subgraph::print((AG::Subgraph *)(v24 & 0xFFFFFFFFFFFFFFFCLL), v22);
      v23 -= 8;
    }
    while (v23);
  }
  return result;
}

uint64_t *AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::~indirect_pointer_vector(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
    if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      uint64_t v4 = *(void **)(v3 + 32);
      if (v4) {
        free(v4);
      }
      MEMORY[0x1B3E84B80](v3, 0x1080C4034992649);
    }
  }
  return a1;
}

void AG::data::zone::~zone(AG::data::zone *this)
{
  AG::data::zone::clear(this);
  uint64_t v2 = *(void ***)this;
  if (*((_DWORD *)this + 2))
  {
    unint64_t v3 = 0;
    do
    {
      std::unique_ptr<void,AG::data::table::malloc_zone_deleter>::reset[abi:ne180100](v2, 0);
      ++v3;
      ++v2;
    }
    while (v3 < *((unsigned int *)this + 2));
    uint64_t v2 = *(void ***)this;
  }
  if (v2) {
    free(v2);
  }
}

void AG::Subgraph::graph_destroyed(AG::Subgraph *this)
{
  int v2 = *((unsigned __int8 *)this + 104);
  *((unsigned char *)this + 104) = 3;
  if (!v2)
  {
    uint64_t v3 = *((void *)this + 5);
    int v4 = *(_DWORD *)(v3 + 232);
    if (v4)
    {
      unsigned int v14 = v4 - 1;
      do
      {
        uint64_t v15 = v14;
        uint64_t v16 = *(void *)(*(void *)(v3 + 224) + 8 * v14);
        (*(void (**)(uint64_t, AG::Subgraph *))(*(void *)v16 + 192))(v16, this);
        --v14;
      }
      while (v15);
    }
  }
  AG::Subgraph::notify_observers((uint64_t)this);
  unsigned int v5 = *((_DWORD *)this + 4);
  if (!v5) {
    goto LABEL_20;
  }
  uint64_t v6 = AG::data::_shared_table_bytes;
  while (2)
  {
    uint64_t v7 = v5;
    uint64_t v8 = v6 + v5;
    int v9 = *(unsigned __int16 *)(v8 + 20);
    if (!*(_WORD *)(v8 + 20)) {
      goto LABEL_19;
    }
    do
    {
      while (1)
      {
        uint64_t v10 = (v9 + v7);
        int v11 = ((_BYTE)v9 + (_BYTE)v7) & 3;
        if ((((_BYTE)v9 + (_BYTE)v7) & 3) == 0)
        {
          uint64_t v12 = AG::data::_shared_table_bytes + v10;
          int v9 = *(unsigned __int16 *)(v12 + 4);
          goto LABEL_15;
        }
        if (v11 != 1)
        {
          if (v11 == 2)
          {
            int v13 = 1;
            goto LABEL_18;
          }
          goto LABEL_12;
        }
        int v9 = *(unsigned __int16 *)(AG::data::_shared_table_bytes + (v10 & 0xFFFFFFFC) + 14);
        if ((v10 & 3) == 0) {
          break;
        }
LABEL_12:
        if (!v9) {
          goto LABEL_16;
        }
      }
      uint64_t v12 = AG::data::_shared_table_bytes + v10;
LABEL_15:
      AG::Node::destroy((unsigned int *)v12, *((AG::Graph **)this + 5));
    }
    while (v9);
LABEL_16:
    int v13 = 0;
LABEL_18:
    uint64_t v6 = AG::data::_shared_table_bytes;
    if (!v13)
    {
LABEL_19:
      unsigned int v5 = *(_DWORD *)(v6 + v7 + 8);
      if (!v5) {
        break;
      }
      continue;
    }
    break;
  }
LABEL_20:
  AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::clear((void *)this + 7);
  *((_DWORD *)this + 18) = 0;
  AG::data::zone::clear(this);
}

uint64_t *AG::indirect_pointer_vector<AG::Subgraph,unsigned long>::resize(uint64_t *result, size_t a2)
{
  uint64_t v3 = *result;
  if (*result)
  {
    int v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFFELL);
    if (*(void *)((v3 & 0xFFFFFFFFFFFFFFFELL) + 40) < a2 && v4[6] < a2) {
      size_t result = (uint64_t *)AG::vector<AG::Subgraph *,4ul,unsigned long>::reserve_slow(v4, a2);
    }
    v4[5] = a2;
  }
  else if (a2 == 1)
  {
    if (!v3) {
      *size_t result = 2;
    }
  }
  else
  {
    if (a2) {
      operator new();
    }
    *size_t result = 0;
  }
  return result;
}

const void **util::cf_ptr<AGSubgraphStorage *>::~cf_ptr(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *std::stack<util::cf_ptr<AGSubgraphStorage *>,AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>>::~stack(void *a1)
{
  int v2 = (void *)a1[32];
  unint64_t v3 = a1[33];
  if (v2) {
    int v4 = v2;
  }
  else {
    int v4 = a1;
  }
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      uint64_t v6 = (const void *)v4[i];
      if (v6)
      {
        CFRelease(v6);
        unint64_t v3 = a1[33];
      }
    }
    int v2 = (void *)a1[32];
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

void AG::Graph::without_invalidating::~without_invalidating(AG::Graph **this)
{
  int v2 = *this;
  if (v2)
  {
    if (!*((unsigned char *)this + 8))
    {
      *((unsigned char *)v2 + 408) = 0;
      AG::Graph::invalidate_subgraphs(v2);
    }
  }
}

uint64_t AG::Subgraph::set_tree_owner(uint64_t result, const char *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 96);
  if (v2)
  {
    uint64_t v3 = AG::data::_shared_table_bytes + v2;
    if (*(_DWORD *)(v3 + 16)) {
      AG::precondition_failure((AG *)"setting owner of non-root tree", a2);
    }
    *(_DWORD *)(v3 + 8) = a2;
  }
  return result;
}

uint64_t AG::Subgraph::begin_tree(unsigned int *a1, int a2, uint64_t a3, int a4)
{
  uint64_t v8 = a1[24];
  uint64_t v9 = a1[4];
  if (v9
    && (uint64_t v10 = AG::data::_shared_table_bytes,
        unsigned int v11 = (*(_DWORD *)(AG::data::_shared_table_bytes + v9 + 16) + 7) & 0xFFFFFFF8,
        v11 + 32 <= *(_DWORD *)(AG::data::_shared_table_bytes + v9 + 12)))
  {
    *(_DWORD *)(AG::data::_shared_table_bytes + v9 + 16) = v11 + 32;
    uint64_t result = v11 + v9;
  }
  else
  {
    uint64_t result = AG::data::zone::alloc_slow((AG::data::zone *)a1, 0x20u, 7);
    uint64_t v10 = AG::data::_shared_table_bytes;
  }
  uint64_t v13 = v10 + result;
  *(void *)uint64_t v13 = a3;
  *(_DWORD *)(v13 + 8) = a2;
  *(_DWORD *)(v13 + 12) = a4;
  *(void *)(v13 + 16) = 0;
  *(void *)(v13 + 24) = 0;
  a1[24] = result;
  uint64_t v14 = AG::data::_shared_table_bytes;
  uint64_t v15 = AG::data::_shared_table_bytes + result;
  *(_DWORD *)(v15 + 16) = v8;
  if (v8)
  {
    uint64_t v16 = v14 + v8;
    *(_DWORD *)(v15 + 24) = *(_DWORD *)(v16 + 20);
    *(_DWORD *)(v16 + 2dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = a1[24];
  }
  return result;
}

uint64_t AG::Subgraph::add_tree_value(uint64_t result, int a2, uint64_t a3, char *a4, int a5)
{
  uint64_t v5 = *(unsigned int *)(result + 96);
  if (v5)
  {
    uint64_t v9 = (unsigned int *)result;
    unsigned int v10 = AG::Graph::intern_key(*(AG::Graph **)(result + 40), a4);
    uint64_t v11 = AG::data::_shared_table_bytes;
    uint64_t v12 = AG::data::_shared_table_bytes + v5;
    uint64_t v13 = v9[4];
    if (v13
      && (unsigned int v14 = (*(_DWORD *)(AG::data::_shared_table_bytes + v13 + 16) + 7) & 0xFFFFFFF8,
          v14 + 24 <= *(_DWORD *)(AG::data::_shared_table_bytes + v13 + 12)))
    {
      *(_DWORD *)(AG::data::_shared_table_bytes + v13 + 16) = v14 + 24;
      uint64_t result = v14 + v13;
    }
    else
    {
      uint64_t result = AG::data::zone::alloc_slow((AG::data::zone *)v9, 0x18u, 7);
      uint64_t v11 = AG::data::_shared_table_bytes;
    }
    int v15 = *(_DWORD *)(v12 + 28);
    uint64_t v16 = v11 + result;
    *(void *)uint64_t v16 = a3;
    *(_DWORD *)(v16 + 8) = a2;
    *(_DWORD *)(v16 + 12) = v10;
    *(_DWORD *)(v16 + 16) = a5;
    *(_DWORD *)(v16 + 2dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v15;
    *(_DWORD *)(v12 + 28) = result;
  }
  return result;
}

uint64_t AG::Subgraph::end_tree(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 96);
  if (v1)
  {
    int v2 = *(_DWORD *)(AG::data::_shared_table_bytes + v1 + 16);
    if (v2) {
      *(_DWORD *)(result + 96) = v2;
    }
  }
  return result;
}

uint64_t AG::Subgraph::tree_subgraph_child(uint64_t a1, unsigned int a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void **)(*(void *)(a1 + 40) + 328);
  if (!v3) {
    return 0;
  }
  v42[0] = a1;
  uint64_t v5 = std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::find<AG::Subgraph *>(v3, v42);
  uint64_t v6 = v5;
  if (!v5) {
    return 0;
  }
  AG::Graph::TreeDataElement::sort_nodes((uint64_t)(v5 + 3));
  unint64_t v7 = v6[4];
  if (!v7) {
    return 0;
  }
  uint64_t v8 = (_DWORD *)v6[3];
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    uint64_t v11 = &v8[2 * (v7 >> 1)];
    unsigned int v13 = *v11;
    uint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < a2) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 == v9) {
    return 0;
  }
  unsigned int v43 = 0;
  size_t v44 = 0;
  unint64_t v45 = 32;
  uint64_t v14 = *(void *)(a1 + 40);
  uint64_t v15 = *(unsigned int *)(v14 + 352);
  if (v15)
  {
    uint64_t v16 = *(uint64_t **)(v14 + 344);
    int v17 = &v16[v15];
    do
    {
      uint64_t v18 = *v16;
      if (!*(unsigned char *)(*v16 + 104))
      {
        uint64_t v19 = *(unsigned int *)(v18 + 96);
        if (v19)
        {
          uint64_t v20 = AG::data::_shared_table_bytes + v19;
          unsigned int v23 = *(_DWORD *)(v20 + 8);
          int v22 = (AG::AttributeID *)(v20 + 8);
          int v21 = v23;
          if (v23 >= 4)
          {
            if ((v21 & 3) != 0) {
              int v21 = AG::AttributeID::resolve_slow(v22, 0);
            }
            if ((v21 & 3) == 0)
            {
              uint64_t v24 = v6[3] + 8 * v6[4];
              uint64_t v25 = v8;
              if (v8 != (_DWORD *)v24)
              {
                while (*v25 == a2)
                {
                  if (v25[1] == v21)
                  {
                    size_t v26 = v44;
                    size_t v27 = v44 + 1;
                    if (v45 < v44 + 1)
                    {
                      AG::vector<util::cf_ptr<AGSubgraphStorage *>,32ul,unsigned long>::reserve_slow(v42, v27);
                      size_t v26 = v44;
                      size_t v27 = v44 + 1;
                    }
                    uint64_t v28 = v43;
                    if (!v43) {
                      uint64_t v28 = v42;
                    }
                    v28[v26] = v18;
                    size_t v44 = v27;
                    break;
                  }
                  v25 += 2;
                  if (v25 == (_DWORD *)v24) {
                    break;
                  }
                }
              }
            }
          }
        }
      }
      ++v16;
    }
    while (v16 != v17);
    long long v32 = v43;
    unint64_t v31 = v44;
  }
  else
  {
    unint64_t v31 = 0;
    long long v32 = 0;
  }
  if (v32) {
    long long v33 = v32;
  }
  else {
    long long v33 = v42;
  }
  unint64_t v34 = 126 - 2 * __clz(v31);
  if (v31) {
    uint64_t v35 = v34;
  }
  else {
    uint64_t v35 = 0;
  }
  std::__introsort<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**,false>((uint64_t)v33, &v33[v31], v35, 1);
  unsigned int v36 = v43;
  if (v43) {
    unint64_t v37 = v43;
  }
  else {
    unint64_t v37 = v42;
  }
  if (!v44)
  {
    uint64_t v29 = 0;
    if (!v43) {
      return v29;
    }
LABEL_48:
    free(v36);
    return v29;
  }
  int v38 = 0;
  uint64_t v39 = AG::data::_shared_table_bytes + 24;
  uint64_t v40 = 8 * v44;
  do
  {
    uint64_t v41 = *v37++;
    uint64_t v29 = *(unsigned int *)(v41 + 96);
    *(_DWORD *)(v39 + v29) = v38;
    int v38 = v29;
    v40 -= 8;
  }
  while (v40);
  if (v36) {
    goto LABEL_48;
  }
  return v29;
}

void sub_1AF925458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41)
{
  if (a41) {
    free(a41);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AG::Subgraph::tree_node_at_index(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v4 = *(void **)(*(void *)(a1 + 40) + 328);
  if (v4)
  {
    uint64_t v19 = a1;
    unint64_t v7 = std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::find<AG::Subgraph *>(v4, &v19);
    if (v7)
    {
      uint64_t v8 = v7;
      AG::Graph::TreeDataElement::sort_nodes((uint64_t)(v7 + 3));
      unint64_t v9 = v8[4];
      if (v9)
      {
        unint64_t v10 = (_DWORD *)v8[3];
        uint64_t v11 = &v10[2 * v9];
        do
        {
          unint64_t v12 = v9 >> 1;
          unsigned int v13 = &v10[2 * (v9 >> 1)];
          unsigned int v15 = *v13;
          uint64_t v14 = v13 + 2;
          v9 += ~(v9 >> 1);
          if (v15 < a2) {
            unint64_t v10 = v14;
          }
          else {
            unint64_t v9 = v12;
          }
        }
        while (v9);
        if (v10 != v11)
        {
          uint64_t v16 = &v10[2 * a3];
          uint64_t v17 = a3 + 1;
          while (*v10 == a2)
          {
            if (!--v17) {
              return v16[1];
            }
            v10 += 2;
            if (v10 == v11) {
              return 2;
            }
          }
        }
      }
    }
  }
  return 2;
}

void *AG::Subgraph::encode(void *this, AG::Encoder *a2)
{
  uint64_t v3 = (uint64_t)this;
  int v4 = *((_DWORD *)this + 6);
  unint64_t v5 = v4 & 0x7FFFFFFF;
  if ((v4 & 0x7FFFFFFF) != 0)
  {
    AG::Encoder::encode_varint(a2, 8uLL);
    this = AG::Encoder::encode_varint(a2, v5);
  }
  unint64_t v6 = *(void *)(v3 + 48);
  if (v6)
  {
    AG::Encoder::encode_varint(a2, 0x10uLL);
    this = AG::Encoder::encode_varint(a2, v6);
  }
  unint64_t v8 = v3 + 56;
  uint64_t v7 = *(void *)(v3 + 56);
  if (v7)
  {
    unint64_t v10 = v7 & 0xFFFFFFFFFFFFFFFELL;
    if (*(void *)(v10 + 32)) {
      unint64_t v8 = *(void *)(v10 + 32);
    }
    else {
      unint64_t v8 = v10;
    }
    unint64_t v9 = v8 + 8 * *(void *)(v10 + 40);
  }
  else
  {
    unint64_t v9 = v8 + 8 * (v7 != 0);
  }
  while (v8 != v9)
  {
    int v11 = *(_DWORD *)(*(void *)v8 + 24);
    unint64_t v12 = v11 & 0x7FFFFFFF;
    if ((v11 & 0x7FFFFFFF) != 0)
    {
      AG::Encoder::encode_varint(a2, 0x18uLL);
      this = AG::Encoder::encode_varint(a2, v12);
    }
    v8 += 8;
  }
  uint64_t v13 = *(unsigned int *)(v3 + 72);
  if (v13)
  {
    uint64_t v14 = *(void **)(v3 + 64);
    uint64_t v15 = 8 * v13;
    do
    {
      int v16 = *(_DWORD *)((*v14 & 0xFFFFFFFFFFFFFFFCLL) + 24);
      unint64_t v17 = v16 & 0x7FFFFFFF;
      if ((v16 & 0x7FFFFFFF) != 0)
      {
        AG::Encoder::encode_varint(a2, 0x20uLL);
        this = AG::Encoder::encode_varint(a2, v17);
      }
      ++v14;
      v15 -= 8;
    }
    while (v15);
  }
  if (*(unsigned char *)(v3 + 104))
  {
    AG::Encoder::encode_varint(a2, 0x28uLL);
    this = AG::Encoder::encode_varint(a2, 1uLL);
  }
  for (unsigned int i = *(_DWORD *)(v3 + 16); i; unsigned int i = *(_DWORD *)(AG::data::_shared_table_bytes + v19 + 8))
  {
    uint64_t v19 = i;
    char v20 = 1;
    do
    {
      char v21 = v20;
      uint64_t v22 = AG::data::_shared_table_bytes + v19;
      if (v21) {
        uint64_t v23 = 20;
      }
      else {
        uint64_t v23 = 22;
      }
      int v24 = *(unsigned __int16 *)(v22 + v23);
      if (*(_WORD *)(v22 + v23))
      {
        while (1)
        {
          unint64_t v25 = (v24 + v19);
          int v26 = ((_BYTE)v24 + (_BYTE)v19) & 3;
          if ((((_BYTE)v24 + (_BYTE)v19) & 3) == 0) {
            break;
          }
          if (v26 == 1)
          {
            size_t v27 = (unsigned __int16 *)(AG::data::_shared_table_bytes + (v25 & 0xFFFFFFFC) + 14);
LABEL_35:
            int v24 = *v27;
            AG::Encoder::encode_varint(a2, 0x32uLL);
            AG::Encoder::begin_length_delimited(a2);
            if (!v25) {
              goto LABEL_38;
            }
            AG::Encoder::encode_varint(a2, 8uLL);
            AG::Encoder::encode_varint(a2, v25);
            if ((v25 & 3) == 1)
            {
              AG::Encoder::encode_varint(a2, 0x1AuLL);
              AG::Encoder::begin_length_delimited(a2);
              AG::Graph::encode_indirect_node(*(void *)(v3 + 40), a2, (unsigned int *)(AG::data::_shared_table_bytes + (v25 & 0xFFFFFFFC)));
              goto LABEL_40;
            }
            if ((v25 & 3) == 0)
            {
LABEL_38:
              AG::Encoder::encode_varint(a2, 0x12uLL);
              AG::Encoder::begin_length_delimited(a2);
              AG::Graph::encode_node(*(const __CFString **)(v3 + 40), a2, (const AG::Node *)(AG::data::_shared_table_bytes + v25), 0);
LABEL_40:
              AG::Encoder::end_length_delimited(a2);
            }
            this = AG::Encoder::end_length_delimited(a2);
            if (!v24) {
              goto LABEL_42;
            }
          }
          else if (v26 == 2 || !v24)
          {
            goto LABEL_42;
          }
        }
        size_t v27 = (unsigned __int16 *)(AG::data::_shared_table_bytes + v25 + 4);
        goto LABEL_35;
      }
LABEL_42:
      char v20 = 0;
    }
    while ((v21 & 1) != 0);
  }
  if (*(_DWORD *)(v3 + 96))
  {
    AG::Encoder::encode_varint(a2, 0x3AuLL);
    AG::Encoder::begin_length_delimited(a2);
    AG::Graph::encode_tree(*(void *)(v3 + 40), a2, *(_DWORD *)(v3 + 96));
    return AG::Encoder::end_length_delimited(a2);
  }
  return this;
}

uint64_t std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::remove(a1, a2, (uint64_t)&__p);
  uint64_t v3 = __p;
  std::string __p = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = (void *)__p[3];
    if (v3) {
      free(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (uint64_t *)result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v40 = *(a2 - 1);
                uint64_t v41 = *v10;
                if (*(_DWORD *)(v40 + 88) > *(_DWORD *)(*v10 + 88))
                {
                  *unint64_t v10 = v40;
                  *(a2 - 1) = v41;
                }
                break;
              case 3uLL:
                uint64_t result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(v10, v10 + 1, a2 - 1);
                break;
              case 4uLL:
                uint64_t result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(v10, v10 + 1, v10 + 2, a2 - 1);
                break;
              case 5uLL:
                unsigned int v42 = v10 + 1;
                unsigned int v43 = v10 + 2;
                size_t v44 = v10 + 3;
                uint64_t result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(v10, v10 + 1, v10 + 2, v10 + 3);
                uint64_t v45 = *(a2 - 1);
                uint64_t v46 = v10[3];
                if (*(_DWORD *)(v45 + 88) > *(_DWORD *)(v46 + 88))
                {
                  *size_t v44 = v45;
                  *(a2 - 1) = v46;
                  uint64_t v47 = *v44;
                  uint64_t v48 = *v43;
                  unsigned int v49 = *(_DWORD *)(*v44 + 88);
                  if (v49 > *(_DWORD *)(*v43 + 88))
                  {
                    *unsigned int v43 = v47;
                    *size_t v44 = v48;
                    uint64_t v50 = *v42;
                    if (v49 > *(_DWORD *)(*v42 + 88))
                    {
                      v10[1] = v47;
                      void v10[2] = v50;
                      uint64_t v51 = *v10;
                      if (v49 > *(_DWORD *)(*v10 + 88))
                      {
                        *unint64_t v10 = v47;
                        v10[1] = v51;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            unsigned int v52 = v10 + 1;
            BOOL v54 = v10 == a2 || v52 == a2;
            if (a4)
            {
              if (!v54)
              {
                uint64_t v55 = 0;
                uint64_t v56 = v10;
                do
                {
                  uint64_t v58 = *v56;
                  uint64_t v57 = v56[1];
                  uint64_t v56 = v52;
                  unsigned int v59 = *(_DWORD *)(v57 + 88);
                  if (v59 > *(_DWORD *)(v58 + 88))
                  {
                    uint64_t v60 = v55;
                    while (1)
                    {
                      *(uint64_t *)((char *)v10 + v60 + 8) = v58;
                      if (!v60) {
                        break;
                      }
                      uint64_t v58 = *(uint64_t *)((char *)v10 + v60 - 8);
                      v60 -= 8;
                      if (v59 <= *(_DWORD *)(v58 + 88))
                      {
                        unsigned int v61 = (uint64_t *)((char *)v10 + v60 + 8);
                        goto LABEL_85;
                      }
                    }
                    unsigned int v61 = v10;
LABEL_85:
                    *unsigned int v61 = v57;
                  }
                  unsigned int v52 = v56 + 1;
                  v55 += 8;
                }
                while (v56 + 1 != a2);
              }
            }
            else if (!v54)
            {
              do
              {
                uint64_t v92 = *v9;
                uint64_t v91 = v9[1];
                unint64_t v9 = v52;
                unsigned int v93 = *(_DWORD *)(v91 + 88);
                if (v93 > *(_DWORD *)(v92 + 88))
                {
                  do
                  {
                    uint64_t *v52 = v92;
                    uint64_t v92 = *(v52 - 2);
                    --v52;
                  }
                  while (v93 > *(_DWORD *)(v92 + 88));
                  uint64_t *v52 = v91;
                }
                unsigned int v52 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v62 = (v12 - 2) >> 1;
              int64_t v63 = v62;
              do
              {
                int64_t v64 = v63;
                if (v62 >= v63)
                {
                  uint64_t v65 = (2 * v63) | 1;
                  int64_t v66 = &v10[v65];
                  uint64_t v67 = *v66;
                  if (2 * v64 + 2 < (uint64_t)v12)
                  {
                    uint64_t result = *(unsigned int *)(v67 + 88);
                    if (result > *(_DWORD *)(v66[1] + 88))
                    {
                      uint64_t v67 = v66[1];
                      ++v66;
                      uint64_t v65 = 2 * v64 + 2;
                    }
                  }
                  int64_t v68 = &v10[v64];
                  uint64_t v69 = *v68;
                  unsigned int v70 = *(_DWORD *)(*v68 + 88);
                  if (*(_DWORD *)(v67 + 88) <= v70)
                  {
                    do
                    {
                      unsigned int v71 = v66;
                      *int64_t v68 = v67;
                      if (v62 < v65) {
                        break;
                      }
                      uint64_t result = (2 * v65) | 1;
                      int64_t v66 = &v10[result];
                      uint64_t v72 = 2 * v65 + 2;
                      uint64_t v67 = *v66;
                      if (v72 < (uint64_t)v12 && *(_DWORD *)(v67 + 88) > *(_DWORD *)(v66[1] + 88))
                      {
                        uint64_t v67 = v66[1];
                        ++v66;
                        uint64_t result = v72;
                      }
                      int64_t v68 = v71;
                      uint64_t v65 = result;
                    }
                    while (*(_DWORD *)(v67 + 88) <= v70);
                    *unsigned int v71 = v69;
                  }
                }
                int64_t v63 = v64 - 1;
              }
              while (v64);
              uint64_t v73 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v74 = 0;
                uint64_t v75 = *v10;
                unsigned int v76 = v10;
                do
                {
                  uint64_t v77 = &v76[v74];
                  uint64_t v80 = v77[1];
                  uint64_t v78 = v77 + 1;
                  uint64_t v79 = v80;
                  uint64_t v81 = (2 * v74) | 1;
                  uint64_t v82 = 2 * v74 + 2;
                  if (v82 < v73)
                  {
                    uint64_t result = *(unsigned int *)(v79 + 88);
                    if (result > *(_DWORD *)(v78[1] + 88))
                    {
                      uint64_t v79 = v78[1];
                      ++v78;
                      uint64_t v81 = v82;
                    }
                  }
                  uint64_t *v76 = v79;
                  unsigned int v76 = v78;
                  uint64_t v74 = v81;
                }
                while (v81 <= (uint64_t)((unint64_t)(v73 - 2) >> 1));
                if (v78 == --a2)
                {
                  *uint64_t v78 = v75;
                }
                else
                {
                  *uint64_t v78 = *a2;
                  *a2 = v75;
                  uint64_t v83 = (char *)v78 - (char *)v10 + 8;
                  if (v83 >= 9)
                  {
                    unint64_t v84 = (((unint64_t)v83 >> 3) - 2) >> 1;
                    uint64_t v85 = &v10[v84];
                    uint64_t v86 = *v85;
                    uint64_t v87 = *v78;
                    unsigned int v88 = *(_DWORD *)(*v78 + 88);
                    if (*(_DWORD *)(*v85 + 88) > v88)
                    {
                      do
                      {
                        unsigned int v89 = v85;
                        *uint64_t v78 = v86;
                        if (!v84) {
                          break;
                        }
                        unint64_t v84 = (v84 - 1) >> 1;
                        uint64_t v85 = &v10[v84];
                        uint64_t v86 = *v85;
                        uint64_t v78 = v89;
                      }
                      while (*(_DWORD *)(*v85 + 88) > v88);
                      *unsigned int v89 = v87;
                    }
                  }
                }
              }
              while (v73-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = &v10[v12 >> 1];
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(v9, &v9[v12 >> 1], a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(v9 + 1, v14 - 1, a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(v9 + 2, &v9[v13 + 1], a2 - 3);
            uint64_t result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(v14 - 1, v14, &v9[v13 + 1]);
            uint64_t v15 = *v9;
            uint64_t *v9 = *v14;
            *uint64_t v14 = v15;
          }
          else
          {
            uint64_t result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(&v9[v12 >> 1], v9, a2 - 1);
          }
          --a3;
          uint64_t v16 = *v9;
          if (a4) {
            break;
          }
          unsigned int v17 = *(_DWORD *)(v16 + 88);
          if (*(_DWORD *)(*(v9 - 1) + 88) > v17) {
            goto LABEL_13;
          }
          if (v17 <= *(_DWORD *)(*(a2 - 1) + 88))
          {
            long long v32 = v9 + 1;
            do
            {
              unint64_t v10 = v32;
              if (v32 >= a2) {
                break;
              }
              ++v32;
            }
            while (v17 <= *(_DWORD *)(*v10 + 88));
          }
          else
          {
            unint64_t v10 = v9;
            do
            {
              uint64_t v31 = v10[1];
              ++v10;
            }
            while (v17 <= *(_DWORD *)(v31 + 88));
          }
          long long v33 = a2;
          if (v10 < a2)
          {
            long long v33 = a2;
            do
              uint64_t v34 = *--v33;
            while (v17 > *(_DWORD *)(v34 + 88));
          }
          if (v10 < v33)
          {
            uint64_t v35 = *v10;
            uint64_t v36 = *v33;
            do
            {
              *unint64_t v10 = v36;
              *long long v33 = v35;
              do
              {
                uint64_t v37 = v10[1];
                ++v10;
                uint64_t v35 = v37;
              }
              while (v17 <= *(_DWORD *)(v37 + 88));
              do
              {
                uint64_t v38 = *--v33;
                uint64_t v36 = v38;
              }
              while (v17 > *(_DWORD *)(v38 + 88));
            }
            while (v10 < v33);
          }
          uint64_t v39 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            uint64_t *v9 = *v39;
          }
          a4 = 0;
          *uint64_t v39 = v16;
        }
        unsigned int v17 = *(_DWORD *)(v16 + 88);
LABEL_13:
        uint64_t v18 = 0;
        do
          uint64_t v19 = v9[++v18];
        while (*(_DWORD *)(v19 + 88) > v17);
        char v20 = &v9[v18];
        char v21 = a2;
        if (v18 == 1)
        {
          char v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *--v21;
          }
          while (*(_DWORD *)(v23 + 88) <= v17);
        }
        else
        {
          do
            uint64_t v22 = *--v21;
          while (*(_DWORD *)(v22 + 88) <= v17);
        }
        if (v20 >= v21)
        {
          uint64_t v29 = v20 - 1;
        }
        else
        {
          uint64_t v24 = *v21;
          unint64_t v25 = &v9[v18];
          int v26 = v21;
          do
          {
            *unint64_t v25 = v24;
            *int v26 = v19;
            do
            {
              uint64_t v27 = v25[1];
              ++v25;
              uint64_t v19 = v27;
            }
            while (*(_DWORD *)(v27 + 88) > v17);
            do
            {
              uint64_t v28 = *--v26;
              uint64_t v24 = v28;
            }
            while (*(_DWORD *)(v28 + 88) <= v17);
          }
          while (v25 < v26);
          uint64_t v29 = v25 - 1;
        }
        if (v29 != v9) {
          uint64_t *v9 = *v29;
        }
        *uint64_t v29 = v16;
        if (v20 >= v21) {
          break;
        }
LABEL_34:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**,false>(v9, v29, a3, a4 & 1);
        a4 = 0;
        unint64_t v10 = v29 + 1;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(v9, v29);
      unint64_t v10 = v29 + 1;
      uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(v29 + 1, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_34;
      }
    }
    a2 = v29;
    if (!v30) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  unsigned int v5 = *(_DWORD *)(*a2 + 88);
  unsigned int v6 = *(_DWORD *)(*result + 88);
  uint64_t v7 = *a3;
  unsigned int v8 = *(_DWORD *)(*a3 + 88);
  if (v5 <= v6)
  {
    if (v8 > v5)
    {
      *a2 = v7;
      *a3 = v3;
      uint64_t v9 = *result;
      if (*(_DWORD *)(*a2 + 88) > *(_DWORD *)(*result + 88))
      {
        *uint64_t result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 <= v5)
    {
      *uint64_t result = v3;
      *a2 = v4;
      if (*(_DWORD *)(*a3 + 88) <= v6) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *uint64_t result = v7;
    }
    *a3 = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      if (*(_DWORD *)(v6 + 88) > *(_DWORD *)(*a1 + 88))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      uint64_t v18 = a1 + 1;
      uint64_t v19 = a1 + 2;
      char v20 = a1 + 3;
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(a1, a1 + 1, a1 + 2, a1 + 3);
      uint64_t v21 = *(a2 - 1);
      uint64_t v22 = a1[3];
      if (*(_DWORD *)(v21 + 88) > *(_DWORD *)(v22 + 88))
      {
        *char v20 = v21;
        *(a2 - 1) = v22;
        uint64_t v23 = *v20;
        uint64_t v24 = *v19;
        unsigned int v25 = *(_DWORD *)(*v20 + 88);
        if (v25 > *(_DWORD *)(*v19 + 88))
        {
          *uint64_t v19 = v23;
          *char v20 = v24;
          uint64_t v26 = *v18;
          if (v25 > *(_DWORD *)(*v18 + 88))
          {
            a1[1] = v23;
            a1[2] = v26;
            uint64_t v27 = *a1;
            if (v25 > *(_DWORD *)(*a1 + 88))
            {
              *a1 = v23;
              a1[1] = v27;
            }
          }
        }
      }
      return 1;
    default:
      unsigned int v8 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(a1, a1 + 1, a1 + 2);
      uint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = *v8;
    unsigned int v14 = *(_DWORD *)(*v9 + 88);
    if (v14 > *(_DWORD *)(*v8 + 88))
    {
      uint64_t v15 = v11;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15) = v13;
        uint64_t v16 = v15 - 8;
        if (v15 == 8) {
          break;
        }
        uint64_t v13 = *(uint64_t *)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 <= *(_DWORD *)(v13 + 88))
        {
          unsigned int v17 = (uint64_t *)((char *)a1 + v16);
          goto LABEL_13;
        }
      }
      unsigned int v17 = a1;
LABEL_13:
      *unsigned int v17 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    unsigned int v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

uint64_t *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AG::Subgraph::tree_subgraph_child(AG::data::ptr<AG::Graph::TreeElement>)::$_1 &,AG::Subgraph**>(a1, a2, a3);
  uint64_t v9 = *a3;
  if (*(_DWORD *)(*a4 + 88) > *(_DWORD *)(*a3 + 88))
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v10 = *a2;
    if (*(_DWORD *)(*a3 + 88) > *(_DWORD *)(*a2 + 88))
    {
      *a2 = *a3;
      *a3 = v10;
      uint64_t v11 = *a1;
      if (*(_DWORD *)(*a2 + 88) > *(_DWORD *)(*a1 + 88))
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::find<AG::Subgraph *>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  unsigned int v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  BOOL result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      BOOL result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *AG::vector<AG::Subgraph *,4ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 6) + (*((void *)__dst + 6) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 6) + (*((void *)__dst + 6) >> 1);
  }
  BOOL result = AG::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 4), __dst, 4uLL, (size_t *)__dst + 6, v3);
  *((void *)__dst + 4) = result;
  return result;
}

char *std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::__emplace_unique_key_args<AG::Subgraph *,std::piecewise_construct_t const&,std::tuple<AG::Subgraph *&&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      uint64_t v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = *((void *)v13 + 1);
          if (v14 == v9)
          {
            if (*((void *)v13 + 2) == *a2) {
              return v13;
            }
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10) {
                v14 %= v10;
              }
            }
            else
            {
              v14 &= v10 - 1;
            }
            if (v14 != v4) {
              break;
            }
          }
          uint64_t v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  uint64_t v15 = (void *)(a1 + 16);
  uint64_t v13 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v13 = 0;
  *((void *)v13 + 1) = v9;
  *((void *)v13 + 2) = **a4;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = 0u;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)uint64_t v13 = *v23;
LABEL_38:
    *uint64_t v23 = v13;
    goto LABEL_39;
  }
  *(void *)uint64_t v13 = *v15;
  *uint64_t v15 = v13;
  *(void *)(v22 + 8 * v4) = v15;
  if (*(void *)v13)
  {
    unint64_t v24 = *(void *)(*(void *)v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v24 >= v10) {
        v24 %= v10;
      }
    }
    else
    {
      v24 &= v10 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v13;
}

void sub_1AF926704(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void *AG::vector<AG::data::ptr<AG::Node>,256ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 130) + (*((void *)__dst + 130) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 130) + (*((void *)__dst + 130) >> 1);
  }
  BOOL result = AG::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 128), __dst, 0x100uLL, (size_t *)__dst + 130, v3);
  *((void *)__dst + 128) = result;
  return result;
}

void AG::LayoutDescriptor::Compare::Frame::~Frame(AG::LayoutDescriptor::Compare::Frame *this)
{
  uint64_t v1 = *(void *)this;
  unint64_t v2 = *((void *)this + 1);
  while (1)
  {
    unint64_t v3 = *(void *)(v1 + 520);
    if (v3 <= v2) {
      break;
    }
    unint64_t v4 = v3 - 1;
    *(void *)(v1 + 52dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v4;
    uint64_t v5 = *(void *)(v1 + 512);
    if (!v5) {
      uint64_t v5 = v1;
    }
    AG::LayoutDescriptor::Compare::Enum::~Enum((AG::LayoutDescriptor::Compare::Enum *)(v5 + (v4 << 6)));
  }
}

void AG::LayoutDescriptor::Compare::~Compare(AG::LayoutDescriptor::Compare *this)
{
  uint64_t v1 = this;
  unint64_t v2 = (void *)*((void *)this + 64);
  if (v2) {
    this = (AG::LayoutDescriptor::Compare *)*((void *)this + 64);
  }
  if (*((void *)v1 + 65))
  {
    unint64_t v3 = 0;
    do
    {
      AG::LayoutDescriptor::Compare::Enum::~Enum(this);
      ++v3;
      this = (AG::LayoutDescriptor::Compare *)(v4 + 64);
    }
    while (v3 < *((void *)v1 + 65));
    unint64_t v2 = (void *)*((void *)v1 + 64);
  }
  if (v2) {
    free(v2);
  }
}

std::string *AG::LayoutDescriptor::print(std::string *a1, AG::LayoutDescriptor *this)
{
  unint64_t v2 = this;
  long long v33 = a1;
  int v4 = AG::LayoutDescriptor::length(this, (const unsigned __int8 *)this);
  AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(layout #:length %d #:address %p", v4, v2);
  int v5 = 3;
  while (1)
  {
    uint8x8_t v6 = (AG::swift::metadata **)((char *)v2 + 1);
    int v7 = *(unsigned __int8 *)v2;
    if ((v7 - 64) >= 0x40)
    {
      switch(*(unsigned char *)v2)
      {
        case 0:
          return AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, ")\n");
        case 1:
          unint64_t v9 = *(AG::swift::metadata **)((char *)v2 + 1);
          unint64_t v2 = (AG::LayoutDescriptor *)((char *)v2 + 17);
          std::string::push_back(a1, 10);
          std::string::append(a1, 2 * v5, 32);
          uint64_t v10 = *(void *)(*((void *)v9 - 1) + 64);
          uint64_t v11 = (const char *)AG::swift::metadata::name(v9, 0);
          AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(== #:size %d #:type %s)", v10, v11);
          continue;
        case 2:
          uint64_t v12 = *(AG::swift::metadata **)((char *)v2 + 1);
          unint64_t v2 = (AG::LayoutDescriptor *)((char *)v2 + 17);
          std::string::push_back(a1, 10);
          std::string::append(a1, 2 * v5, 32);
          uint64_t v13 = *(void *)(*((void *)v12 - 1) + 64);
          unint64_t v14 = (const char *)AG::swift::metadata::name(v12, 0);
          AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(indirect #:size %d #:type %s)", v13, v14);
          continue;
        case 3:
          uint64_t v15 = *(AG::swift::metadata **)((char *)v2 + 1);
          unint64_t v2 = (AG::LayoutDescriptor *)((char *)v2 + 9);
          std::string::push_back(a1, 10);
          std::string::append(a1, 2 * v5, 32);
          uint64_t v16 = *(void *)(*((void *)v15 - 1) + 64);
          float v17 = (const char *)AG::swift::metadata::name(v15, 0);
          AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(existential #:size %d #:type %s)", v16, v17);
          continue;
        case 4:
        case 5:
          std::string::push_back(a1, 10);
          std::string::append(a1, 2 * v5, 32);
          AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(%s)");
          break;
        case 6:
          uint64_t v18 = 0;
          int v19 = 0;
          unint64_t v20 = *(char **)((char *)v2 + 1);
          unint64_t v2 = (AG::LayoutDescriptor *)((char *)v2 + 9);
          do
          {
            char v21 = *(unsigned char *)v2;
            unint64_t v2 = (AG::LayoutDescriptor *)((char *)v2 + 1);
            v18 |= (unint64_t)(v21 & 0x7F) << v19;
            v19 += 7;
          }
          while (v21 < 0);
          goto LABEL_18;
        case 7:
          uint64_t v22 = *(int *)((char *)v2 + 1);
          LODWORD(v18) = *(unsigned __int16 *)((char *)v2 + 5);
          unint64_t v2 = (AG::LayoutDescriptor *)((char *)v2 + 7);
          unint64_t v20 = &AG::LayoutDescriptor::base_address[v22];
LABEL_18:
          std::string::push_back(a1, 10);
          std::string::append(a1, 2 * v5, 32);
          uint64_t v23 = "";
          if (v7 == 7) {
            uint64_t v23 = "*";
          }
          AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(nested%s #:size %d #:layout %p)", v23, v18, v20);
          continue;
        case 8:
          int v8 = 0;
          int v24 = 0;
          do
          {
            char v25 = *(unsigned char *)v6;
            uint8x8_t v6 = (AG::swift::metadata **)((char *)v6 + 1);
            v8 |= (v25 & 0x7F) << v24;
            v24 += 7;
          }
          while (v25 < 0);
          goto LABEL_23;
        case 9:
        case 0xA:
        case 0xB:
          int v8 = v7 - 9;
LABEL_23:
          uint64_t v26 = *v6;
          std::string::push_back(a1, 10);
          std::string::append(a1, 2 * v5, 32);
          uint64_t v27 = *(void *)(*((void *)v26 - 1) + 64);
          uint64_t v28 = (const char *)AG::swift::metadata::name(v26, 0);
          AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(enum #:size %d #:type %s", v27, v28);
          std::string::push_back(a1, 10);
          std::string::append(a1, 2 * v5 + 4, 32);
          AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(case %d", v8);
          v5 += 4;
          unint64_t v2 = (AG::LayoutDescriptor *)(v6 + 1);
          continue;
        case 0xC:
          int v29 = 0;
          int v30 = 0;
          do
          {
            char v31 = *(unsigned char *)v6;
            uint8x8_t v6 = (AG::swift::metadata **)((char *)v6 + 1);
            v29 |= (v31 & 0x7F) << v30;
            v30 += 7;
          }
          while (v31 < 0);
          goto LABEL_6;
        case 0xD:
        case 0xE:
        case 0xF:
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x15:
LABEL_6:
          std::string::append(a1, 1uLL, 41);
          std::string::push_back(a1, 10);
          std::string::append(a1, 2 * v5 - 4, 32);
          AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(case %d");
          break;
        case 0x16:
          v5 -= 4;
          std::string::append(a1, 2uLL, 41);
          unint64_t v2 = (AG::LayoutDescriptor *)((char *)v2 + 1);
          continue;
        default:
          unint64_t v2 = (AG::LayoutDescriptor *)((char *)v2 + 1);
          if ((v7 & 0x80) == 0) {
            continue;
          }
          std::string::push_back(a1, 10);
          std::string::append(a1, 2 * v5, 32);
          AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(read %u)");
          break;
      }
    }
    else
    {
      std::string::push_back(a1, 10);
      std::string::append(a1, 2 * v5, 32);
      AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(&v33, "(skip %u)");
    }
    unint64_t v2 = (AG::LayoutDescriptor *)v6;
  }
}

std::string *AG::LayoutDescriptor::print(std::string &,unsigned char const*)::$_1::operator()(std::string **a1, char *__format, ...)
{
  va_start(va, __format);
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  vsnprintf(__str, 0x100uLL, __format, va);
  size_t v3 = strlen(__str);
  return std::string::append(*a1, __str, v3);
}

void AG::LayoutDescriptor::Builder::EnumItem::~EnumItem(AG::LayoutDescriptor::Builder::EnumItem *this)
{
  unint64_t v2 = (char *)*((void *)this + 3);
  if (*((void *)this + 4))
  {
    unint64_t v3 = 0;
    do
    {
      int v4 = &v2[40 * v3];
      int v7 = (void *)*((void *)v4 + 2);
      uint64_t v6 = v4 + 16;
      int v5 = v7;
      if (*((void *)v6 + 1))
      {
        unint64_t v8 = 0;
        do
        {
          ++v8;
          int v5 = (void *)(std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v5)
                      + 56);
        }
        while (v8 < *((void *)v6 + 1));
        int v5 = *(void **)v6;
      }
      if (v5) {
        free(v5);
      }
      ++v3;
    }
    while (v3 < *((void *)this + 4));
    unint64_t v2 = (char *)*((void *)this + 3);
  }
  if (v2) {
    free(v2);
  }
}

BOOL AG::LayoutDescriptor::Builder::visit_native_object(AG::LayoutDescriptor::Builder *this, const AG::swift::metadata *a2)
{
  int v2 = *((_DWORD *)this + 3);
  if (v2 == 2)
  {
    uint64_t v3 = *((void *)this + 4);
    if (v3) {
      int v4 = (void *)(v3 + 16);
    }
    else {
      int v4 = (void *)((char *)this + 40);
    }
    uint64_t v5 = *((void *)this + 2);
    uint64_t v6 = v4[1];
    if (v4[2] < (unint64_t)(v6 + 1))
    {
      AG::vector<std::variant<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,0ul,unsigned long>::reserve_slow((uint64_t)v4, v6 + 1);
      uint64_t v6 = v4[1];
    }
    uint64_t v7 = *v4 + 56 * v6;
    *(void *)uint64_t v7 = v5;
    *(void *)(v7 + 8) = 8;
    *(unsigned char *)(v7 + 16) = 0;
    *(_DWORD *)(v7 + 48) = 4;
    ++v4[1];
  }
  return v2 == 2;
}

void AG::LayoutDescriptor::Builder::~Builder(AG::LayoutDescriptor::Builder *this)
{
  *(void *)this = &unk_1F0813E38;
  int v2 = (void *)*((void *)this + 5);
  if (*((void *)this + 6))
  {
    unint64_t v3 = 0;
    do
    {
      ++v3;
      int v2 = (void *)(std::__variant_detail::__dtor<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v2)
                  + 56);
    }
    while (v3 < *((void *)this + 6));
    int v2 = (void *)*((void *)this + 5);
  }
  if (v2) {
    free(v2);
  }
}

void AG::LayoutDescriptor::add_type_descriptor_override(unint64_t a1, int a2)
{
  if (!a1) {
    return;
  }
  uint64_t v7 = v4[32];
  unint64_t v6 = v4[33];
  uint64_t v8 = v7;
  unint64_t v9 = (void *)(v7 + 16 * v6);
  if (!v6) {
    goto LABEL_13;
  }
  uint64_t v10 = (void *)v4[32];
  unint64_t v11 = v4[33];
  do
  {
    unint64_t v12 = v11 >> 1;
    uint64_t v13 = &v10[2 * (v11 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v11 += ~(v11 >> 1);
    if (v15 < a1) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v11 = v12;
    }
  }
  while (v11);
  if (v10 == v9) {
    goto LABEL_13;
  }
  if (*v10 != a1)
  {
    unint64_t v9 = v10;
LABEL_13:
    if (v4[34] < v6 + 1)
    {
      AG::vector<std::pair<void const*,AGComparisonMode>,0ul,unsigned long>::reserve_slow((uint64_t)(v4 + 32), v6 + 1);
      uint64_t v8 = v4[32];
      unint64_t v6 = v4[33];
    }
    unint64_t v16 = ((uint64_t)v9 - v7) >> 4;
    if (v6 > v16)
    {
      memmove((void *)(v8 + 16 * v16 + 16), (const void *)(v8 + 16 * v16), 16 * (v6 - v16));
      unint64_t v6 = v4[33];
    }
    uint64_t v17 = v8 + 16 * v16;
    *(void *)uint64_t v17 = a1;
    *(_DWORD *)(v17 + 8) = a2;
    v4[33] = v6 + 1;
    goto LABEL_18;
  }
  *((_DWORD *)v10 + 2) = a2;
LABEL_18:
  os_unfair_lock_unlock(v5);
}

void sub_1AF9272B4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<AG::LayoutDescriptor::Builder::DataItem,AG::LayoutDescriptor::Builder::EqualsItem,AG::LayoutDescriptor::Builder::IndirectItem,AG::LayoutDescriptor::Builder::ExistentialItem,AG::LayoutDescriptor::Builder::HeapRefItem,AG::LayoutDescriptor::Builder::NestedItem,AG::LayoutDescriptor::Builder::EnumItem>>::__emplace[abi:ne180100]<0ul,AG::LayoutDescriptor::Builder::DataItem&>(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 48);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1F0814498[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 48) = -1;
  *(_OWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 48) = 0;
  return a1;
}

void std::__throw_bad_variant_access[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA4F0] + 16;
}

void *AG::vector<unsigned char,512ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 66) + (*((void *)__dst + 66) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 66) + (*((void *)__dst + 66) >> 1);
  }
  BOOL result = AG::details::realloc_vector<unsigned long,1ul>(*((void **)__dst + 64), __dst, 0x200uLL, (size_t *)__dst + 66, v3);
  *((void *)__dst + 64) = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,1ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t __n)
{
  uint64_t v7 = __src;
  if (__n <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, __n);
      free(v7);
      unint64_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(__n);
    if (v8 != *a4)
    {
      size_t v9 = v8;
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x8734B07FuLL);
      if (!v10) {
        AG::precondition_failure((AG *)"allocation failure", v11);
      }
      unint64_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void *AG::vector<std::pair<void const*,AGComparisonMode>,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  BOOL result = AG::details::realloc_vector<unsigned long,16ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *AG::details::realloc_vector<unsigned long,16ul>(void *a1, size_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(16 * a3);
    size_t v6 = v5 >> 4;
    if (v5 >> 4 != *a2)
    {
      uint64_t v7 = malloc_type_realloc(v4, v5, 0xF3138078uLL);
      if (!v7) {
        AG::precondition_failure((AG *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t AG::Graph::breadth_first_search(uint64_t a1, unsigned int a2, char a3, uint64_t (*a4)(uint64_t))
{
  unsigned int v37 = a2;
  memset(v35, 0, sizeof(v35));
  int v36 = 1065353216;
  long long v34 = 0u;
  memset(v33, 0, sizeof(v33));
  if ((a2 & 3) != 0) {
    a2 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v37, (const char *)4);
  }
  unsigned int v37 = a2;
  if (a2 >= 4)
  {
    std::__hash_table<AG::AttributeID,std::hash<AG::AttributeID>,std::equal_to<AG::AttributeID>,std::allocator<AG::AttributeID>>::__emplace_unique_key_args<AG::AttributeID,AG::AttributeID const&>((uint64_t)v35, &v37, &v37);
    std::deque<AG::AttributeID>::push_back(v33, &v37);
    uint64_t v6 = *((void *)&v34 + 1);
    if (*((void *)&v34 + 1))
    {
      while (1)
      {
        uint64_t v7 = *(unsigned int *)(*(void *)(*((void *)&v33[0] + 1)
                                         + (((unint64_t)v34 >> 7) & 0x1FFFFFFFFFFFFF8))
                             + 4 * (v34 & 0x3FF));
        *(void *)&long long v34 = v34 + 1;
        *((void *)&v34 + 1) = v6 - 1;
        if ((unint64_t)v34 >= 0x800)
        {
          operator delete(**((void ***)&v33[0] + 1));
          *((void *)&v33[0] + 1) += 8;
          *(void *)&long long v34 = v34 - 1024;
        }
        int v8 = v7 & 3;
        if (v7 & 3) == 0 && (a4(v7))
        {
          uint64_t v31 = 1;
          goto LABEL_66;
        }
        if ((a3 & 1) == 0) {
          goto LABEL_10;
        }
        if (v8 != 2) {
          break;
        }
LABEL_53:
        uint64_t v6 = *((void *)&v34 + 1);
        if (!*((void *)&v34 + 1)) {
          goto LABEL_65;
        }
      }
      if (v8 == 1)
      {
        unsigned int v28 = *(_DWORD *)(AG::data::_shared_table_bytes + (v7 & 0xFFFFFFFC));
        unsigned int v38 = v28;
        if ((v28 & 3) != 0) {
          unsigned int v28 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v38, (const char *)4);
        }
        unsigned int v38 = v28;
        if (!std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v35, &v38))
        {
          if ((a3 & 4) != 0) {
            goto LABEL_64;
          }
          uint64_t v29 = *(void *)(AG::data::_shared_table_bytes + (v7 & 0xFFFFFE00));
          if (v29) {
            uint64_t v29 = *(void *)(v29 + 48);
          }
          uint64_t v30 = *(void *)(AG::data::_shared_table_bytes + (v38 & 0xFFFFFE00));
          if (v30) {
            uint64_t v30 = *(void *)(v30 + 48);
          }
          if (v29 == v30)
          {
LABEL_64:
            std::__hash_table<AG::AttributeID,std::hash<AG::AttributeID>,std::equal_to<AG::AttributeID>,std::allocator<AG::AttributeID>>::__emplace_unique_key_args<AG::AttributeID,AG::AttributeID const&>((uint64_t)v35, &v38, &v38);
            std::deque<AG::AttributeID>::push_back(v33, &v38);
          }
        }
      }
      else if ((v7 & 3) == 0)
      {
        unint64_t v15 = *(unsigned int *)(AG::data::_shared_table_bytes + v7 + 12);
        if (v15 >= 0x20)
        {
          unint64_t v16 = (unsigned int *)(AG::data::_shared_table_bytes
                               + *(unsigned int *)(AG::data::_shared_table_bytes + v7 + 16));
          uint64_t v17 = 5 * (v15 >> 5);
          do
          {
            unsigned int v18 = *v16;
            unsigned int v38 = v18;
            if ((v18 & 3) != 0) {
              unsigned int v18 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v38, (const char *)4);
            }
            unsigned int v38 = v18;
            if (!std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v35, &v38))
            {
              if ((a3 & 4) != 0) {
                goto LABEL_39;
              }
              uint64_t v19 = *(void *)(AG::data::_shared_table_bytes + (v7 & 0xFFFFFE00));
              if (v19) {
                uint64_t v19 = *(void *)(v19 + 48);
              }
              uint64_t v20 = *(void *)(AG::data::_shared_table_bytes + (v38 & 0xFFFFFE00));
              if (v20) {
                uint64_t v20 = *(void *)(v20 + 48);
              }
              if (v19 == v20)
              {
LABEL_39:
                std::__hash_table<AG::AttributeID,std::hash<AG::AttributeID>,std::equal_to<AG::AttributeID>,std::allocator<AG::AttributeID>>::__emplace_unique_key_args<AG::AttributeID,AG::AttributeID const&>((uint64_t)v35, &v38, &v38);
                std::deque<AG::AttributeID>::push_back(v33, &v38);
              }
            }
            unint64_t v16 = (unsigned int *)((char *)v16 + 5);
            v17 -= 5;
          }
          while (v17);
        }
      }
LABEL_10:
      if ((a3 & 2) != 0)
      {
        if (v8 == 1)
        {
          uint64_t v21 = AG::data::_shared_table_bytes + (v7 & 0xFFFFFFFC);
          unint64_t v22 = *(unsigned int *)(v21 + 20);
          if (v22 >= 0x20)
          {
            uint64_t v23 = (unsigned int *)(AG::data::_shared_table_bytes + *(unsigned int *)(v21 + 24));
            uint64_t v24 = v7 & 0xFFFFFE00;
            uint64_t v25 = 4 * (v22 >> 5);
            do
            {
              unsigned int v38 = *v23;
              if (!std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v35, &v38))
              {
                if ((a3 & 4) != 0) {
                  goto LABEL_51;
                }
                uint64_t v26 = *(void *)(AG::data::_shared_table_bytes + (v38 & 0xFFFFFE00));
                if (v26) {
                  uint64_t v26 = *(void *)(v26 + 48);
                }
                uint64_t v27 = *(void *)(AG::data::_shared_table_bytes + v24);
                if (v27) {
                  uint64_t v27 = *(void *)(v27 + 48);
                }
                if (v26 == v27)
                {
LABEL_51:
                  std::__hash_table<AG::AttributeID,std::hash<AG::AttributeID>,std::equal_to<AG::AttributeID>,std::allocator<AG::AttributeID>>::__emplace_unique_key_args<AG::AttributeID,AG::AttributeID const&>((uint64_t)v35, &v38, &v38);
                  std::deque<AG::AttributeID>::push_back(v33, &v38);
                }
              }
              ++v23;
              v25 -= 4;
            }
            while (v25);
          }
        }
        else if ((v7 & 3) == 0)
        {
          unint64_t v9 = *(unsigned int *)(AG::data::_shared_table_bytes + v7 + 20);
          if (v9 >= 0x20)
          {
            uint64_t v10 = (unsigned int *)(AG::data::_shared_table_bytes
                                 + *(unsigned int *)(AG::data::_shared_table_bytes + v7 + 24));
            uint64_t v11 = v7 & 0xFFFFFE00;
            uint64_t v12 = 4 * (v9 >> 5);
            do
            {
              unsigned int v38 = *v10;
              if (!std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v35, &v38))
              {
                if ((a3 & 4) != 0) {
                  goto LABEL_22;
                }
                uint64_t v13 = *(void *)(AG::data::_shared_table_bytes + (v38 & 0xFFFFFE00));
                if (v13) {
                  uint64_t v13 = *(void *)(v13 + 48);
                }
                uint64_t v14 = *(void *)(AG::data::_shared_table_bytes + v11);
                if (v14) {
                  uint64_t v14 = *(void *)(v14 + 48);
                }
                if (v13 == v14)
                {
LABEL_22:
                  std::__hash_table<AG::AttributeID,std::hash<AG::AttributeID>,std::equal_to<AG::AttributeID>,std::allocator<AG::AttributeID>>::__emplace_unique_key_args<AG::AttributeID,AG::AttributeID const&>((uint64_t)v35, &v38, &v38);
                  std::deque<AG::AttributeID>::push_back(v33, &v38);
                }
              }
              ++v10;
              v12 -= 4;
            }
            while (v12);
          }
        }
      }
      goto LABEL_53;
    }
  }
LABEL_65:
  uint64_t v31 = 0;
LABEL_66:
  std::deque<AG::AttributeID>::~deque[abi:ne180100](v33);
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)v35);
  return v31;
}

void sub_1AF927960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t std::deque<AG::AttributeID>::~deque[abi:ne180100](void *a1)
{
  int v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      int v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 512;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 1024;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<AG::AttributeID *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<AG::AttributeID *>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

void *std::__hash_table<AG::AttributeID,std::hash<AG::AttributeID>,std::equal_to<AG::AttributeID>,std::allocator<AG::AttributeID>>::__emplace_unique_key_args<AG::AttributeID,AG::AttributeID const&>(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x18uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *uint64_t v10 = *v19;
LABEL_38:
    *uint64_t v19 = v10;
    goto LABEL_39;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1AF927C98(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<AG::AttributeID>::push_back(void *a1, _DWORD *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 7) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<AG::AttributeID>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(_DWORD *)(*(void *)(v5 + ((v8 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v8 & 0x3FF)) = *a2;
  a1[5] = v7 + 1;
}

void std::deque<AG::AttributeID>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x400;
  unint64_t v4 = v2 - 1024;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      long long v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AG::AttributeID *>>(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      unsigned int v37 = &v34[8 * v36];
      unsigned int v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      unint64_t v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<AG::AttributeID *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<AG::AttributeID *>::push_front((uint64_t)a1, &v54);
    size_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    unint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      long long v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AG::AttributeID *>>((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      unsigned int v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      unsigned int v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<AG::AttributeID *>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  char v53 = operator new(0x1000uLL);
  std::__split_buffer<AG::AttributeID *>::push_back(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<AG::AttributeID *>::push_front((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1AF928000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::__split_buffer<AG::AttributeID *>::push_back(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    uint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v18 = 1;
      }
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AG::AttributeID *>>(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      uint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        uint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      uint64_t v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        uint64_t v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        uint64_t v6 = (char *)a1[1];
      }
      uint64_t v17 = &v6[8 * v13];
      uint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)uint64_t v6 = *a2;
  a1[2] += 8;
}

{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        int64_t v16 = 1;
      }
      else {
        int64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AG::AttributeID *>>(a1[4], v16);
      uint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      uint64_t v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        BOOL v10 = v9;
      }
      else {
        BOOL v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      uint64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }
      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<AG::AttributeID *>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AG::AttributeID *>>(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

{
  char *v4;
  char *v5;
  unsigned char *v6;
  unsigned char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = (v7 - v4) >> 2;
      }
      unint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AG::AttributeID *>>(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      int64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        int64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<AG::AttributeID *>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

const __CFString *AG::Graph::encode_node(const __CFString *this, AG::Encoder *a2, const AG::Node *a3, int a4)
{
  CFStringRef v7 = this;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(unsigned int *)a3;
  if (v8 >= 0x100)
  {
    unint64_t v9 = v8 >> 8;
    AG::Encoder::encode_varint(a2, 8uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, v9);
  }
  if (a4)
  {
    this = *(const __CFString **)((char *)v7[4].isa + (((unint64_t)*(unsigned int *)a3 >> 5) & 0x7FFFFF8));
    uint64_t v10 = (uint64_t (*)(void))*((void *)this[1].isa + 4);
    if (v10)
    {
      this = (const __CFString *)v10();
      if (this)
      {
        CFStringRef v11 = this;
        v32.length = CFStringGetLength(this);
        CFIndex usedBufLen = 0;
        v32.location = 0;
        this = (const __CFString *)CFStringGetBytes(v11, v32, 0x8000100u, 0x3Fu, 1u, buffer, 1024, &usedBufLen);
        CFIndex v12 = usedBufLen;
        if (usedBufLen)
        {
          AG::Encoder::encode_varint(a2, 0x12uLL);
          this = (const __CFString *)AG::Encoder::encode_data(a2, buffer, v12);
        }
      }
    }
  }
  uint64_t v13 = AG::data::_shared_table_bytes;
  unint64_t v14 = *((unsigned int *)a3 + 3);
  if (v14 >= 0x20)
  {
    uint64_t v15 = 5 * (v14 >> 5);
    int64_t v16 = (char *)(*((unsigned int *)a3 + 4) + AG::data::_shared_table_bytes + 4);
    while (1)
    {
      AG::Encoder::encode_varint(a2, 0x1AuLL);
      AG::Encoder::begin_length_delimited(a2);
      unint64_t v17 = *((unsigned int *)v16 - 1);
      if (v17)
      {
        AG::Encoder::encode_varint(a2, 8uLL);
        AG::Encoder::encode_varint(a2, v17);
      }
      char v18 = *v16;
      if (*v16)
      {
        AG::Encoder::encode_varint(a2, 0x10uLL);
        AG::Encoder::encode_varint(a2, 1uLL);
        char v18 = *v16;
        if ((*v16 & 4) == 0)
        {
LABEL_14:
          if ((v18 & 8) != 0) {
            goto LABEL_21;
          }
          goto LABEL_15;
        }
      }
      else if ((*v16 & 4) == 0)
      {
        goto LABEL_14;
      }
      AG::Encoder::encode_varint(a2, 0x18uLL);
      AG::Encoder::encode_varint(a2, 1uLL);
      char v18 = *v16;
      if ((*v16 & 8) != 0)
      {
LABEL_21:
        AG::Encoder::encode_varint(a2, 0x20uLL);
        AG::Encoder::encode_varint(a2, 1uLL);
        if ((*v16 & 0x10) == 0) {
          goto LABEL_17;
        }
LABEL_16:
        AG::Encoder::encode_varint(a2, 0x30uLL);
        AG::Encoder::encode_varint(a2, 1uLL);
        goto LABEL_17;
      }
LABEL_15:
      if ((v18 & 0x10) != 0) {
        goto LABEL_16;
      }
LABEL_17:
      this = (const __CFString *)AG::Encoder::end_length_delimited(a2);
      v16 += 5;
      v15 -= 5;
      if (!v15)
      {
        uint64_t v13 = AG::data::_shared_table_bytes;
        break;
      }
    }
  }
  unint64_t v19 = *((unsigned int *)a3 + 5);
  if (v19 >= 0x20)
  {
    uint64_t v20 = (unsigned int *)(v13 + *((unsigned int *)a3 + 6));
    uint64_t v21 = 4 * (v19 >> 5);
    do
    {
      unint64_t v22 = *v20;
      AG::Encoder::encode_varint(a2, 0x22uLL);
      AG::Encoder::begin_length_delimited(a2);
      if (v22)
      {
        AG::Encoder::encode_varint(a2, 8uLL);
        AG::Encoder::encode_varint(a2, v22);
      }
      this = (const __CFString *)AG::Encoder::end_length_delimited(a2);
      ++v20;
      v21 -= 4;
    }
    while (v21);
  }
  int v23 = *(_DWORD *)a3;
  if (*(_DWORD *)a3)
  {
    AG::Encoder::encode_varint(a2, 0x28uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, 1uLL);
    int v23 = *(_DWORD *)a3;
  }
  if ((v23 & 2) != 0)
  {
    AG::Encoder::encode_varint(a2, 0x30uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, 1uLL);
    int v23 = *(_DWORD *)a3;
  }
  unint64_t v24 = v23 >> 6;
  if (v23 >> 6)
  {
    AG::Encoder::encode_varint(a2, 0x38uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, v24);
  }
  unint64_t v25 = *((unsigned __int8 *)a3 + 6);
  if (*((unsigned char *)a3 + 6))
  {
    AG::Encoder::encode_varint(a2, 0x40uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, v25);
  }
  int v26 = *(_DWORD *)a3;
  if ((*(_DWORD *)a3 & 4) != 0)
  {
    AG::Encoder::encode_varint(a2, 0x48uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, 1uLL);
    int v26 = *(_DWORD *)a3;
  }
  if ((v26 & 8) != 0)
  {
    AG::Encoder::encode_varint(a2, 0x50uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, 1uLL);
  }
  if ((*((unsigned char *)a3 + 7) & 0x20) != 0)
  {
    AG::Encoder::encode_varint(a2, 0x58uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, 1uLL);
  }
  int v27 = *(_DWORD *)a3;
  if ((*(_DWORD *)a3 & 0x10) != 0)
  {
    AG::Encoder::encode_varint(a2, 0x60uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, 1uLL);
    int v27 = *(_DWORD *)a3;
  }
  if ((v27 & 0x20) != 0)
  {
    AG::Encoder::encode_varint(a2, 0x68uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, 1uLL);
  }
  char v28 = *((unsigned char *)a3 + 7);
  if ((v28 & 0x10) != 0)
  {
    AG::Encoder::encode_varint(a2, 0x70uLL);
    this = (const __CFString *)AG::Encoder::encode_varint(a2, 1uLL);
    char v28 = *((unsigned char *)a3 + 7);
  }
  if ((v28 & 0x40) != 0)
  {
    AG::Encoder::encode_varint(a2, 0x78uLL);
    return (const __CFString *)AG::Encoder::encode_varint(a2, 1uLL);
  }
  return this;
}

void *AG::Graph::encode_indirect_node(int a1, AG::Encoder *this, unsigned int *a3)
{
  unint64_t v5 = *a3;
  if (v5)
  {
    AG::Encoder::encode_varint(this, 8uLL);
    BOOL result = AG::Encoder::encode_varint(this, v5);
  }
  unint64_t v7 = a3[1];
  if (v7)
  {
    AG::Encoder::encode_varint(this, 0x10uLL);
    BOOL result = AG::Encoder::encode_varint(this, v7);
  }
  unint64_t v8 = a3[2];
  if (v8 >= 4)
  {
    unint64_t v9 = v8 >> 2;
    AG::Encoder::encode_varint(this, 0x18uLL);
    BOOL result = AG::Encoder::encode_varint(this, v9);
  }
  int v10 = *((unsigned __int16 *)a3 + 6);
  if (v10 == 0xFFFF) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = *((unsigned __int16 *)a3 + 6);
  }
  if (v10 != 0xFFFF && v11 != 0)
  {
    AG::Encoder::encode_varint(this, 0x20uLL);
    BOOL result = AG::Encoder::encode_varint(this, v11);
  }
  if (a3[2])
  {
    unint64_t v13 = a3[4];
    if (v13)
    {
      AG::Encoder::encode_varint(this, 0x28uLL);
      BOOL result = AG::Encoder::encode_varint(this, v13);
    }
    unint64_t v14 = a3[5];
    if (v14 >= 0x20)
    {
      uint64_t v15 = (unsigned int *)(AG::data::_shared_table_bytes + a3[6]);
      uint64_t v16 = 4 * (v14 >> 5);
      do
      {
        unint64_t v17 = *v15;
        AG::Encoder::encode_varint(this, 0x32uLL);
        AG::Encoder::begin_length_delimited(this);
        if (v17)
        {
          AG::Encoder::encode_varint(this, 8uLL);
          AG::Encoder::encode_varint(this, v17);
        }
        BOOL result = AG::Encoder::end_length_delimited(this);
        ++v15;
        v16 -= 4;
      }
      while (v16);
    }
  }
  return result;
}

void *AG::Graph::encode_tree(uint64_t a1, AG::Encoder *a2, unsigned int a3)
{
  uint64_t v6 = (unsigned int *)(AG::data::_shared_table_bytes + a3);
  unint64_t v7 = v6[2];
  if (v7 >= 4)
  {
    AG::Encoder::encode_varint(a2, 0x10uLL);
    AG::Encoder::encode_varint(a2, v7);
  }
  unint64_t v8 = v6[3];
  if (v8)
  {
    AG::Encoder::encode_varint(a2, 0x18uLL);
    AG::Encoder::encode_varint(a2, v8);
  }
  for (uint64_t i = v6[5]; i; uint64_t i = *(unsigned int *)(AG::data::_shared_table_bytes + i + 24))
  {
    AG::Encoder::encode_varint(a2, 0x22uLL);
    AG::Encoder::begin_length_delimited(a2);
    AG::Graph::encode_tree(a1, a2, i);
    AG::Encoder::end_length_delimited(a2);
  }
  for (uint64_t j = v6[7]; j; uint64_t j = v11[5])
  {
    unint64_t v11 = (unsigned int *)(AG::data::_shared_table_bytes + j);
    AG::Encoder::encode_varint(a2, 0x2AuLL);
    AG::Encoder::begin_length_delimited(a2);
    unint64_t v12 = v11[2];
    if (v12 >= 4)
    {
      AG::Encoder::encode_varint(a2, 0x10uLL);
      AG::Encoder::encode_varint(a2, v12);
    }
    unint64_t v13 = v11[3];
    if (v13)
    {
      AG::Encoder::encode_varint(a2, 0x18uLL);
      AG::Encoder::encode_varint(a2, v13);
    }
    unint64_t v14 = v11[4];
    if (v14)
    {
      AG::Encoder::encode_varint(a2, 0x20uLL);
      AG::Encoder::encode_varint(a2, v14);
    }
    AG::Encoder::end_length_delimited(a2);
  }
  BOOL result = *(void **)(a1 + 328);
  if (result)
  {
    uint64_t v26 = *(void *)(AG::data::_shared_table_bytes + (a3 & 0xFFFFFE00));
    BOOL result = std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::find<AG::Subgraph *>(result, &v26);
    if (result)
    {
      uint64_t v16 = result;
      BOOL result = (void *)AG::Graph::TreeDataElement::sort_nodes((uint64_t)(result + 3));
      unint64_t v17 = (_DWORD *)v16[3];
      unint64_t v18 = v16[4];
      if (v18)
      {
        do
        {
          unint64_t v19 = v18 >> 1;
          uint64_t v20 = &v17[2 * (v18 >> 1)];
          unsigned int v22 = *v20;
          uint64_t v21 = v20 + 2;
          v18 += ~(v18 >> 1);
          if (v22 < a3) {
            unint64_t v17 = v21;
          }
          else {
            unint64_t v18 = v19;
          }
        }
        while (v18);
        if (!v17) {
          return result;
        }
      }
      else if (!v17)
      {
        return result;
      }
      if (*v17 == a3)
      {
        int v23 = v17 + 2;
        do
        {
          unint64_t v24 = *(v23 - 1);
          if (v24)
          {
            AG::Encoder::encode_varint(a2, 0x30uLL);
            BOOL result = AG::Encoder::encode_varint(a2, v24);
          }
          int v25 = *v23;
          v23 += 2;
        }
        while (v25 == a3);
      }
    }
  }
  return result;
}

uint64_t AGSubgraphGetChildCount(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", a2);
  }
  return *(unsigned int *)(v2 + 72);
}

uint64_t AGSubgraphGetChild(uint64_t a1, const char *a2, _DWORD *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", a2);
  }
  if (*(unsigned int *)(v3 + 72) <= (unint64_t)a2) {
    AG::precondition_failure((AG *)"invalid child index: %u", a2, a2);
  }
  uint64_t v4 = *(void *)(*(void *)(v3 + 64) + 8 * a2);
  if (a3) {
    *a3 = v4 & 3;
  }
  return *(void *)((v4 & 0xFFFFFFFFFFFFFFFCLL) + 32);
}

uint64_t AGSubgraphGetIndex(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", a2);
  }
  return *(unsigned int *)(v2 + 88);
}

uint64_t AGSubgraphGetParentCount(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 56);
  if (v2) {
    return *(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 40);
  }
  else {
    return v2 != 0;
  }
}

uint64_t AGSubgraphGetParent(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", a2);
  }
  uint64_t v3 = *(void *)(v2 + 56);
  if (v3)
  {
    unint64_t v4 = v3 & 0xFFFFFFFFFFFFFFFELL;
    if (*(void *)(v4 + 40) <= (unint64_t)a2) {
      goto LABEL_12;
    }
    if (*(void *)(v4 + 32)) {
      unint64_t v4 = *(void *)(v4 + 32);
    }
    uint64_t v3 = *(void *)(v4 + 8 * (void)a2);
  }
  else if (a2 || !v3)
  {
LABEL_12:
    AG::precondition_failure((AG *)"invalid parent index: %u", a2, a2);
  }
  return *(void *)(v3 + 32);
}

uint64_t AGSubgraphIsAncestor(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(AG::Subgraph **)(a1 + 16);
  uint64_t v3 = *(const AG::Subgraph **)(a2 + 16);
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 0;
  }
  else {
    return AG::Subgraph::ancestor_of(v2, v3);
  }
}

BOOL AGSubgraphIntersects(uint64_t a1, char a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  return v2 && (a2 & (*(unsigned char *)(v2 + 100) | BYTE1(*(_DWORD *)(v2 + 100)))) != 0;
}

void AGSubgraphSetShouldRecordTree()
{
  if (should_record_tree_once != -1) {
    dispatch_once_f(&should_record_tree_once, 0, (dispatch_function_t)init_should_record_tree);
  }
  should_record_tree = 1;
}

uint64_t AGSubgraphSetTreeOwner(uint64_t a1, char *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    AG::precondition_failure((AG *)"accessing invalidated subgraph", a2);
  }
  return AG::Subgraph::set_tree_owner(v2, (const char *)a2);
}

uint64_t AGSubgraphBeginTreeElement(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = AG::Subgraph::_current_subgraph_key;
  BOOL v4 = *(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v3);
  if (v4) {
    return AG::Subgraph::begin_tree(v4, result, a2, a3);
  }
  return result;
}

uint64_t AGSubgraphAddTreeValue(uint64_t result, uint64_t a2, char *a3, int a4)
{
  uint64_t v4 = AG::Subgraph::_current_subgraph_key;
  uint64_t v5 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  if (v5) {
    return AG::Subgraph::add_tree_value(v5, result, a2, a3, a4);
  }
  return result;
}

uint64_t AGSubgraphEndTreeElement()
{
  uint64_t v0 = AG::Subgraph::_current_subgraph_key;
  uint64_t v1 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v0);
  if (v1) {
    return AG::Subgraph::end_tree(v1);
  }
  return result;
}

uint64_t AGSubgraphGetTreeRoot(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return 0;
  }
  uint64_t result = *(unsigned int *)(v1 + 96);
  if (!result) {
    return 0;
  }
  return result;
}

uint64_t AGTreeElementGetParent(unsigned int a1)
{
  return *(unsigned int *)(AG::data::_shared_table_bytes + a1 + 16);
}

uint64_t AGTreeElementGetType(unsigned int a1)
{
  return *(void *)(AG::data::_shared_table_bytes + a1);
}

uint64_t AGTreeElementGetValue(unsigned int a1)
{
  return *(unsigned int *)(AG::data::_shared_table_bytes + a1 + 8);
}

uint64_t AGTreeElementGetFlags(unsigned int a1)
{
  return *(unsigned int *)(AG::data::_shared_table_bytes + a1 + 12);
}

uint64_t AGTreeElementMakeChildIterator@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(unsigned int *)(AG::data::_shared_table_bytes + result + 20);
  *a2 = result;
  a2[1] = v2;
  a2[2] = 0;
  return result;
}

uint64_t AGTreeElementGetNextChild(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 8);
  if (result) {
    goto LABEL_2;
  }
  if (!*(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = 1;
    LODWORD(result) = AG::Subgraph::tree_subgraph_child(*(void *)(AG::data::_shared_table_bytes + (*(void *)a1 & 0xFFFFFE00)), *(void *)a1);
    if (result)
    {
      uint64_t result = result;
LABEL_2:
      *(void *)(a1 + 8) = *(unsigned int *)(AG::data::_shared_table_bytes + result + 24);
      return result;
    }
  }
  return 0;
}

uint64_t AGTreeElementMakeValueIterator(uint64_t result)
{
  return result;
}

uint64_t AGTreeElementGetNextValue(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 8);
  if (result) {
    *(void *)(a1 + 8) = *(unsigned int *)(AG::data::_shared_table_bytes + result + 20);
  }
  return result;
}

uint64_t AGTreeElementGetNextNode(void *a1)
{
  uint64_t result = AG::Subgraph::tree_node_at_index(*(void *)(AG::data::_shared_table_bytes + (*a1 & 0xFFFFFE00)), *a1, a1[1]);
  if (result <= 3) {
    return 2;
  }
  ++a1[1];
  return result;
}

uint64_t AGTreeValueGetType(unsigned int a1)
{
  return *(void *)(AG::data::_shared_table_bytes + a1);
}

uint64_t AGTreeValueGetValue(unsigned int a1)
{
  return *(unsigned int *)(AG::data::_shared_table_bytes + a1 + 8);
}

uint64_t AGTreeValueGetKey(unsigned int a1)
{
  return AG::Graph::key_name(*(AG::Graph **)(*(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00)) + 40), (const char *)*(unsigned int *)(AG::data::_shared_table_bytes + a1 + 12));
}

uint64_t AGTreeValueGetFlags(unsigned int a1)
{
  return *(unsigned int *)(AG::data::_shared_table_bytes + a1 + 16);
}

void *AG::Graph::ProfileData::json_data(uint64_t a1, void *a2)
{
  if (*a2)
  {
    uint64_t v3 = objc_msgSend(NSNumber, "numberWithUnsignedLong:");
    uint64_t v4 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
    [v4 setObject:v3 forKeyedSubscript:@"update_count"];
  }
  else
  {
    uint64_t v4 = 0;
  }
  if (a2[1])
  {
    uint64_t v5 = objc_msgSend(NSNumber, "numberWithUnsignedLong:");
    if (!v4) {
      uint64_t v4 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
    }
    [v4 setObject:v5 forKeyedSubscript:@"change_count"];
  }
  uint64_t v6 = (AG *)a2[2];
  if (v6)
  {
    uint64_t v7 = [NSNumber numberWithDouble:AG::absolute_time_to_seconds(v6)];
    if (!v4) {
      uint64_t v4 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
    }
    [v4 setObject:v7 forKeyedSubscript:@"update_total"];
  }
  unint64_t v8 = (AG *)a2[3];
  if (v8)
  {
    uint64_t v9 = [NSNumber numberWithDouble:AG::absolute_time_to_seconds(v8)];
    if (!v4) {
      uint64_t v4 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
    }
    [v4 setObject:v9 forKeyedSubscript:@"changed_total"];
  }
  return v4;
}

void *AG::Graph::ProfileData::json_data(uint64_t a1, void *a2, AG::Graph *a3)
{
  uint64_t v5 = AG::Graph::ProfileData::json_data(a1, a2);
  uint64_t v6 = v5;
  if (a2[5])
  {
    unint64_t v14 = v5;
    uint64_t v7 = (void *)[MEMORY[0x1E4F1CA48] array];
    unint64_t v8 = v7;
    uint64_t v9 = a2[5];
    if (v9)
    {
      uint64_t v10 = 48 * v9;
      unint64_t v11 = (void *)(a2[4] + 16);
      do
      {
        uint64_t v7 = AG::Graph::ProfileData::json_data((uint64_t)v7, v11);
        if (v7)
        {
          unint64_t v12 = v7;
          objc_msgSend(v7, "setObject:forKeyedSubscript:", objc_msgSend(NSString, "stringWithUTF8String:", AG::Graph::key_name(a3, (const char *)*((unsigned int *)v11 - 4))), @"name");
          objc_msgSend(v12, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithDouble:", AG::absolute_time_to_seconds((AG *)*(v11 - 1))), @"timestamp");
          uint64_t v7 = (void *)[v8 addObject:v12];
        }
        v11 += 6;
        v10 -= 48;
      }
      while (v10);
    }
    uint64_t v6 = v14;
    if (!v14) {
      uint64_t v6 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
    }
    [v6 setObject:v8 forKeyedSubscript:@"marks"];
  }
  return v6;
}

id AG::Graph::description(AG::Graph *this, NSDictionary *a2, NSDictionary *a3)
{
  id v5 = [(NSDictionary *)a2 objectForKeyedSubscript:@"format"];
  uint64_t v6 = (void *)MEMORY[0x1B3E85040]();
  if ([v5 isEqualToString:@"graph/dict"])
  {
    unint64_t v8 = AG::Graph::description_graph(this, (const AG::Graph *)a2, v7);
LABEL_6:
    id v10 = v8;
    goto LABEL_7;
  }
  int v9 = [v5 isEqualToString:@"graph/dot"];
  if (this && v9)
  {
    unint64_t v8 = AG::Graph::description_graph_dot(this, a2);
    goto LABEL_6;
  }
  if ([v5 hasPrefix:@"stack/"])
  {
    if (this
      || (uint64_t v12 = AG::Graph::_current_update_key,
          (uint64_t v13 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12)) != 0)
      && (this = *(AG::Graph **)(v13 & 0xFFFFFFFFFFFFFFFELL)) != 0)
    {
      if ([v5 isEqualToString:@"stack/text"])
      {
        unint64_t v8 = AG::Graph::description_stack(this, a2);
        goto LABEL_6;
      }
      unint64_t v14 = (AG::Graph *)[v5 isEqualToString:@"stack/nodes"];
      if (v14)
      {
        unint64_t v8 = AG::Graph::description_stack_nodes(v14, a2);
        goto LABEL_6;
      }
      if ([v5 isEqualToString:@"stack/frame"])
      {
        unint64_t v8 = AG::Graph::description_stack_frame(this, a2);
        goto LABEL_6;
      }
    }
  }
  id v10 = 0;
LABEL_7:
  return v10;
}

void *AG::Graph::description_graph(AG::Graph *this, const AG::Graph *a2, NSDictionary *a3)
{
  uint64_t v250 = *MEMORY[0x1E4F143B8];
  id v5 = (void *)[(AG::Graph *)a2 objectForKeyedSubscript:@"include-values"];
  if (v5) {
    int v221 = [v5 BOOLValue];
  }
  else {
    int v221 = 0;
  }
  uint64_t v6 = (void *)[(AG::Graph *)a2 objectForKeyedSubscript:@"truncation-limit"];
  if (v6) {
    uint64_t v220 = [v6 unsignedLongValue];
  }
  else {
    uint64_t v220 = 1024;
  }
  unint64_t v7 = 0x1E4F1C000uLL;
  v219 = (void *)[MEMORY[0x1E4F1CA48] array];
  memset(v241, 0, sizeof(v241));
  int v242 = 1065353216;
  v238 = 0;
  unint64_t v239 = 0;
  unint64_t v240 = 0;
  if (this)
  {
    v236[0] = *((void **)this + 53);
    if (!std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>(v241, (unint64_t *)v236))
    {
      uint64_t v8 = [v219 count];
      objc_msgSend(v219, "addObject:", objc_msgSend(MEMORY[0x1E4F1CA98], "null"));
      *(void *)&long long v230 = *((void *)this + 53);
      v236[0] = &v230;
      std::__hash_table<std::__hash_value_type<unsigned long,unsigned long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v241, (unint64_t *)&v230, (uint64_t)&std::piecewise_construct, v236)[3] = v8;
      unint64_t v9 = v239;
      unint64_t v10 = v239 + 1;
      if (v240 < v239 + 1)
      {
        AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)&v238, v10);
        unint64_t v9 = v239;
        unint64_t v10 = v239 + 1;
      }
      v238[v9] = this;
      unint64_t v239 = v10;
    }
  }
  unint64_t v11 = (void *)[(AG::Graph *)a2 objectForKeyedSubscript:@"graph_ids"];
  if (v11)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
      for (uint64_t i = AG::Graph::_all_graphs; i; uint64_t i = *(void *)i)
      {
        if (objc_msgSend(v11, "containsObject:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", *(void *)(i + 424))))
        {
          v236[0] = *(void **)(i + 424);
          if (!std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>(v241, (unint64_t *)v236))
          {
            uint64_t v13 = [v219 count];
            objc_msgSend(v219, "addObject:", objc_msgSend(MEMORY[0x1E4F1CA98], "null"));
            *(void *)&long long v230 = *(void *)(i + 424);
            v236[0] = &v230;
            std::__hash_table<std::__hash_value_type<unsigned long,unsigned long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v241, (unint64_t *)&v230, (uint64_t)&std::piecewise_construct, v236)[3] = v13;
            unint64_t v14 = v239;
            unint64_t v15 = v239 + 1;
            if (v240 < v239 + 1)
            {
              AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)&v238, v15);
              unint64_t v14 = v239;
              unint64_t v15 = v239 + 1;
            }
            v238[v14] = i;
            unint64_t v239 = v15;
          }
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
    }
  }
  uint64_t v16 = (void *)[(AG::Graph *)a2 objectForKeyedSubscript:@"all_graphs"];
  if (v16 && [v16 BOOLValue])
  {
    os_unfair_lock_lock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
    unint64_t v17 = (AG::Graph *)AG::Graph::_all_graphs;
    if (AG::Graph::_all_graphs)
    {
      do
      {
        if (v17 != this)
        {
          v236[0] = *((void **)v17 + 53);
          if (!std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>(v241, (unint64_t *)v236))
          {
            uint64_t v18 = [v219 count];
            objc_msgSend(v219, "addObject:", objc_msgSend(MEMORY[0x1E4F1CA98], "null"));
            *(void *)&long long v230 = *((void *)v17 + 53);
            v236[0] = &v230;
            std::__hash_table<std::__hash_value_type<unsigned long,unsigned long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v241, (unint64_t *)&v230, (uint64_t)&std::piecewise_construct, v236)[3] = v18;
            unint64_t v19 = v239;
            unint64_t v20 = v239 + 1;
            if (v240 < v239 + 1)
            {
              AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)&v238, v20);
              unint64_t v19 = v239;
              unint64_t v20 = v239 + 1;
            }
            v238[v19] = v17;
            unint64_t v239 = v20;
          }
        }
        unint64_t v17 = *(AG::Graph **)v17;
      }
      while (v17);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&AG::Graph::_all_graphs_lock);
  }
  unint64_t v21 = v239;
  if (v239)
  {
    unint64_t v22 = 0x1E4F29000uLL;
    do
    {
      unint64_t v23 = v21 - 1;
      uint64_t v24 = v238[v23];
      unint64_t v239 = v23;
      v222 = (void *)[*(id *)(v7 + 2632) array];
      v223 = (void *)[*(id *)(v7 + 2632) array];
      memset(v236, 0, sizeof(v236));
      int v237 = 1065353216;
      v233 = 0;
      unint64_t v234 = 0;
      unint64_t v235 = 0;
      long long v230 = 0u;
      long long v231 = 0u;
      int v232 = 1065353216;
      v224 = (AG::Graph *)v24;
      uint64_t v25 = *(unsigned int *)(v24 + 352);
      if (!v25) {
        goto LABEL_120;
      }
      uint64_t v26 = *(void *)(v24 + 344);
      uint64_t v215 = v26 + 8 * v25;
      do
      {
        unsigned int v27 = *(_DWORD *)(*(void *)v26 + 16);
        if (!v27) {
          goto LABEL_84;
        }
        uint64_t v28 = AG::data::_shared_table_bytes;
        do
        {
          uint64_t v29 = v27;
          uint64_t v30 = v28 + v27;
          int v31 = *(unsigned __int16 *)(v30 + 20);
          if (!*(_WORD *)(v30 + 20)) {
            goto LABEL_83;
          }
          do
          {
            uint64_t v32 = (v31 + v29);
            int v33 = ((_BYTE)v31 + (_BYTE)v29) & 3;
            if ((((_BYTE)v31 + (_BYTE)v29) & 3) == 0)
            {
              uint64_t v34 = AG::data::_shared_table_bytes;
              uint64_t v35 = (unsigned __int16 *)(AG::data::_shared_table_bytes + v32 + 4);
LABEL_45:
              int v31 = *v35;
              if ((v32 & 3) == 0)
              {
                LODWORD(v244) = v32;
                uint64_t v36 = *((void *)&v231 + 1);
                *(void *)&long long v227 = &v244;
                unsigned int v37 = (unsigned int *)(v34 + v32);
                std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node> const&>,std::tuple<>>((uint64_t)&v230, (unsigned int *)&v244, (uint64_t)&std::piecewise_construct, (_DWORD **)&v227)[3] = v36;
                LODWORD(v247) = *(_DWORD *)(v34 + v32) >> 8;
                unsigned int v38 = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v236, (unsigned int *)&v247);
                if (v38)
                {
                  uint64_t v39 = v38[3];
                }
                else
                {
                  unint64_t v40 = v234;
                  *(void *)&long long v227 = v234;
                  unint64_t v41 = v234 + 1;
                  if (v235 < v234 + 1)
                  {
                    AG::vector<AG::data::ptr<AG::Node>,0ul,unsigned long>::reserve_slow((uint64_t)&v233, v41);
                    unint64_t v40 = v234;
                    unint64_t v41 = v234 + 1;
                  }
                  *((_DWORD *)v233 + v4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v247;
                  unint64_t v234 = v41;
                  std::__hash_table<std::__hash_value_type<unsigned int,unsigned long>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned long>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned long>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned long>>>::__emplace_unique_key_args<unsigned int,unsigned int &,unsigned long &>((uint64_t)v236, (unsigned int *)&v247, &v247, &v227);
                  uint64_t v39 = v227;
                }
                uint64_t v42 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
                objc_msgSend(v42, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", v39), @"type");
                objc_msgSend(v42, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v244), @"id");
                unint64_t v43 = *v37;
                uint64_t v44 = *((void *)v224 + 16);
                uint64_t v45 = (v43 >> 5) & 0x7FFFFF8;
                uint64_t v46 = *(void *)(v44 + v45);
                if ((v43 & 0x20) != 0)
                {
                  uint64_t v47 = *(uint64_t (**)(void, void *))(*(void *)(v46 + 32) + 24);
                  if (v47)
                  {
                    uint64_t v48 = (void *)((char *)v37 + *(unsigned int *)(v46 + 44));
                    if (*((unsigned char *)v37 + 7)) {
                      uint64_t v48 = (void *)*v48;
                    }
                    uint64_t v49 = (_anonymous_namespace_ *)v47(*(void *)(v44 + v45), v48);
                    if (v49) {
                  }
                    }
                }
                if (v221)
                {
                  if ((*(unsigned char *)v37 & 0x10) != 0)
                  {
                    uint64_t v50 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v46 + 32) + 32);
                    if (v50)
                    {
                      uint64_t v51 = (void *)(AG::data::_shared_table_bytes + v37[2]);
                      if ((*((unsigned char *)v37 + 7) & 2) != 0) {
                        uint64_t v51 = (void *)*v51;
                      }
                      uint64_t v52 = (_anonymous_namespace_ *)v50(v46, v51);
                      if (v52) {
                    }
                      }
                  }
                }
                int v53 = *v37 & 3;
                if ((*v37 & 0xC0) != 0) {
                  int v53 = *v37 & 3 | 4;
                }
                if ((*v37 >> 1) & 8 | (16 * ((*v37 >> 2) & 1)) & 0xFFFFFF3F | (((*v37 >> 3) & 1) << 6) & 0xFFFFFF7F | v53 & 0xFFFFFF7F | *((unsigned char *)v37 + 7) & 0x20 | (((*((unsigned __int8 *)v37 + 7) >> 6) & 1) << 7)) {
                  objc_msgSend(v42, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:"), @"flags");
                }
                long long v54 = (void *)*((void *)v224 + 38);
                if (v54)
                {
                  long long v55 = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v54 + 8, (unsigned int *)&v244);
                  if (v55)
                  {
                    uint64_t v56 = AG::Graph::ProfileData::json_data((uint64_t)v55, v55 + 3, v224);
                    if (v56) {
                      [v42 setObject:v56 forKeyedSubscript:@"profile"];
                    }
                  }
                  if (v54[21])
                  {
                    uint64_t v57 = objc_msgSend(MEMORY[0x1E4F1CA60], "dictionary", v56);
                    for (uint64_t j = (uint64_t **)v54[20]; j; uint64_t j = (uint64_t **)*j)
                    {
                      unsigned int v59 = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(j + 10, (unsigned int *)&v244);
                      if (v59)
                      {
                        uint64_t v60 = AG::Graph::ProfileData::json_data((uint64_t)v59, v59 + 3, v224);
                        if (v60) {
                          objc_msgSend(v57, "setObject:forKeyedSubscript:", v60, objc_msgSend(*(id *)(v22 + 24), "stringWithUTF8String:", AG::Graph::key_name(v224, (const char *)*((unsigned int *)j + 4))));
                        }
                      }
                    }
                    if ([v57 count]) {
                      [v42 setObject:v57 forKeyedSubscript:@"events"];
                    }
                  }
                }
                [v222 addObject:v42];
              }
              continue;
            }
            if (v33 == 1)
            {
              uint64_t v34 = AG::data::_shared_table_bytes;
              uint64_t v35 = (unsigned __int16 *)(AG::data::_shared_table_bytes + (v32 & 0xFFFFFFFC) + 14);
              goto LABEL_45;
            }
            if (v33 == 2) {
              break;
            }
          }
          while (v31);
          uint64_t v28 = AG::data::_shared_table_bytes;
LABEL_83:
          unsigned int v27 = *(_DWORD *)(v28 + v29 + 8);
        }
        while (v27);
LABEL_84:
        v26 += 8;
      }
      while (v26 != v215);
      uint64_t v61 = *((unsigned int *)v224 + 88);
      if (v61)
      {
        uint64_t v62 = *((void *)v224 + 43);
        uint64_t v212 = v62 + 8 * v61;
        do
        {
          uint64_t v216 = v62;
          unsigned int v63 = *(_DWORD *)(*(void *)v62 + 16);
          if (!v63) {
            goto LABEL_119;
          }
          uint64_t v64 = AG::data::_shared_table_bytes;
          do
          {
            uint64_t v65 = v63;
            uint64_t v66 = v64 + v63;
            int v67 = *(unsigned __int16 *)(v66 + 20);
            if (!*(_WORD *)(v66 + 20)) {
              goto LABEL_118;
            }
            do
            {
              while (1)
              {
                uint64_t v68 = (v67 + v65);
                int v69 = ((_BYTE)v67 + (_BYTE)v65) & 3;
                if ((((_BYTE)v67 + (_BYTE)v65) & 3) != 0)
                {
                  if (v69 != 1)
                  {
                    if (v69 == 2) {
                      goto LABEL_117;
                    }
                    goto LABEL_97;
                  }
                  uint64_t v70 = AG::data::_shared_table_bytes;
                  unsigned int v71 = (unsigned __int16 *)(AG::data::_shared_table_bytes + (v68 & 0xFFFFFFFC) + 14);
                }
                else
                {
                  uint64_t v70 = AG::data::_shared_table_bytes;
                  unsigned int v71 = (unsigned __int16 *)(AG::data::_shared_table_bytes + v68 + 4);
                }
                int v67 = *v71;
                if ((v68 & 3) == 0) {
                  break;
                }
LABEL_97:
                if (!v67) {
                  goto LABEL_117;
                }
              }
              LODWORD(v247) = v68;
              uint64_t v72 = v70 + v68;
              unint64_t v73 = *(unsigned int *)(v70 + v68 + 12);
              if (v73 >= 0x20)
              {
                uint64_t v74 = v70 + *(unsigned int *)(v72 + 16);
                uint64_t v75 = v74 + 5 * (v73 >> 5);
                do
                {
                  int v76 = *(_DWORD *)v74;
                  char v77 = *(unsigned char *)(v74 + 4);
                  uint64_t v78 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
                  LODWORD(v227) = v76;
                  int v79 = v76 & 3;
                  if ((v76 & 3) != 0)
                  {
                    int v76 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v227, 0);
                    uint64_t v80 = v82;
                  }
                  else
                  {
                    uint64_t v80 = 0;
                  }
                  if ((v76 & 3) == 0)
                  {
                    LODWORD(v244) = v76;
                    *(void *)&long long v227 = &v244;
                    objc_msgSend(v78, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node>&&>,std::tuple<>>((uint64_t)&v230, (unsigned int *)&v244, (uint64_t)&std::piecewise_construct, (_DWORD **)&v227)[3]), @"src");
                    *(void *)&long long v227 = &v247;
                    objc_msgSend(v78, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node> const&>,std::tuple<>>((uint64_t)&v230, (unsigned int *)&v247, (uint64_t)&std::piecewise_construct, (_DWORD **)&v227)[3]), @"dst");
                    if (v79 == 1)
                    {
                      if (v80) {
                        objc_msgSend(v78, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", v80), @"offset");
                      }
                      int v81 = 1;
                    }
                    else
                    {
                      int v81 = 0;
                    }
                    if (v81 | v77 & 0x1C | (32 * (v77 & 1))) {
                      objc_msgSend(v78, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:"), @"flags");
                    }
                    [v223 addObject:v78];
                  }
                  v74 += 5;
                }
                while (v74 != v75);
              }
              unint64_t v7 = 0x1E4F1C000;
              unint64_t v22 = 0x1E4F29000;
            }
            while (v67);
LABEL_117:
            uint64_t v64 = AG::data::_shared_table_bytes;
LABEL_118:
            unsigned int v63 = *(_DWORD *)(v64 + v65 + 8);
          }
          while (v63);
LABEL_119:
          uint64_t v62 = v216 + 8;
        }
        while (v216 + 8 != v212);
      }
LABEL_120:
      uint64_t v83 = *((void *)v224 + 38);
      if (v83 && *((_DWORD *)v224 + 34) >= 2u)
      {
        unint64_t v84 = 1;
        do
        {
          LODWORD(v244) = v84;
          if (!std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v236, (unsigned int *)&v244))
          {
            if (std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>((void *)(v83 + 104), (unsigned int *)&v244))
            {
              LODWORD(v247) = v244;
              if (!std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v236, (unsigned int *)&v247))
              {
                unint64_t v85 = v234;
                *(void *)&long long v227 = v234;
                unint64_t v86 = v234 + 1;
                if (v235 < v234 + 1)
                {
                  AG::vector<AG::data::ptr<AG::Node>,0ul,unsigned long>::reserve_slow((uint64_t)&v233, v86);
                  unint64_t v85 = v234;
                  unint64_t v86 = v234 + 1;
                }
                *((_DWORD *)v233 + v85) = v247;
                unint64_t v234 = v86;
                std::__hash_table<std::__hash_value_type<unsigned int,unsigned long>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned long>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned long>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned long>>>::__emplace_unique_key_args<unsigned int,unsigned int &,unsigned long &>((uint64_t)v236, (unsigned int *)&v247, &v247, &v227);
              }
            }
            else
            {
              for (k = *(void **)(v83 + 160); k; k = (void *)*k)
              {
                if (std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(k + 15, (unsigned int *)&v244))
                {
                  LODWORD(v247) = v244;
                  if (!std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v236, (unsigned int *)&v247))
                  {
                    unint64_t v88 = v234;
                    *(void *)&long long v227 = v234;
                    unint64_t v89 = v234 + 1;
                    if (v235 < v234 + 1)
                    {
                      AG::vector<AG::data::ptr<AG::Node>,0ul,unsigned long>::reserve_slow((uint64_t)&v233, v89);
                      unint64_t v88 = v234;
                      unint64_t v89 = v234 + 1;
                    }
                    *((_DWORD *)v233 + v88) = v247;
                    unint64_t v234 = v89;
                    std::__hash_table<std::__hash_value_type<unsigned int,unsigned long>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned long>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned long>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned long>>>::__emplace_unique_key_args<unsigned int,unsigned int &,unsigned long &>((uint64_t)v236, (unsigned int *)&v247, &v247, &v227);
                  }
                }
              }
            }
          }
          ++v84;
        }
        while (v84 < *((unsigned int *)v224 + 34));
      }
      v211 = (void *)[*(id *)(v7 + 2632) array];
      if (v234)
      {
        for (unint64_t m = 0; m < v234; ++m)
        {
          uint64_t v91 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
          LODWORD(v227) = 0;
          LODWORD(v227) = *((_DWORD *)v233 + m);
          uint64_t v92 = *(void *)(*((void *)v224 + 16) + 8 * v227);
          objc_msgSend(v91, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:"), @"id");
          unsigned int v93 = (_anonymous_namespace_ *)objc_msgSend(*(id *)(v22 + 24), "stringWithUTF8String:", AG::swift::metadata::name(*(AG::swift::metadata **)v92, 0));
          unsigned int v94 = (_anonymous_namespace_ *)objc_msgSend(*(id *)(v22 + 24), "stringWithUTF8String:", AG::swift::metadata::name(*(AG::swift::metadata **)(v92 + 8), 0));
          objc_msgSend(v91, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", *(void *)(*(void *)(*(void *)(v92 + 8) - 8) + 64)+ *(void *)(*(void *)(*(void *)v92 - 8) + 64)), @"size");
          objc_msgSend(v91, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v92 + 40)), @"flags");
          unsigned int v95 = (void *)*((void *)v224 + 38);
          if (v95)
          {
            uint64_t v96 = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(v95 + 13, (unsigned int *)&v227);
            if (v96)
            {
              unsigned int v97 = AG::Graph::ProfileData::json_data((uint64_t)v96, v96 + 3, v224);
              if (v97) {
                [v91 setObject:v97 forKeyedSubscript:@"profile"];
              }
            }
            if (v95[21])
            {
              unint64_t v98 = objc_msgSend(MEMORY[0x1E4F1CA60], "dictionary", v97);
              for (n = (uint64_t **)v95[20]; n; n = (uint64_t **)*n)
              {
                unint64_t v100 = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(n + 15, (unsigned int *)&v227);
                if (v100)
                {
                  unsigned int v101 = AG::Graph::ProfileData::json_data((uint64_t)v100, v100 + 3, v224);
                  if (v101) {
                    objc_msgSend(v98, "setObject:forKeyedSubscript:", v101, objc_msgSend(*(id *)(v22 + 24), "stringWithUTF8String:", AG::Graph::key_name(v224, (const char *)*((unsigned int *)n + 4))));
                  }
                }
              }
              if ([v98 count]) {
                [v91 setObject:v98 forKeyedSubscript:@"events"];
              }
            }
          }
          [v211 addObject:v91];
        }
      }
      v210 = (void *)[*(id *)(v7 + 2632) array];
      long long v227 = 0u;
      long long v228 = 0u;
      int v229 = 1065353216;
      char v102 = v224;
      uint64_t v103 = *((unsigned int *)v224 + 88);
      if (v103)
      {
        unint64_t v104 = (__CFString **)*((void *)v224 + 43);
        uint64_t v105 = 8 * v103;
        do
        {
          v244 = 0;
          v244 = *v104;
          uint64_t v106 = *((void *)&v228 + 1);
          v247 = &v244;
          std::__hash_table<std::__hash_value_type<AG::Subgraph const*,unsigned long>,std::__unordered_map_hasher<AG::Subgraph const*,std::__hash_value_type<AG::Subgraph const*,unsigned long>,std::hash<AG::Subgraph const*>,std::equal_to<AG::Subgraph const*>,true>,std::__unordered_map_equal<AG::Subgraph const*,std::__hash_value_type<AG::Subgraph const*,unsigned long>,std::equal_to<AG::Subgraph const*>,std::hash<AG::Subgraph const*>,true>,std::allocator<std::__hash_value_type<AG::Subgraph const*,unsigned long>>>::__emplace_unique_key_args<AG::Subgraph const*,std::piecewise_construct_t const&,std::tuple<AG::Subgraph const* const&>,std::tuple<>>((uint64_t)&v227, &v244, (uint64_t)&std::piecewise_construct, &v247)[3] = v106;
          ++v104;
          v105 -= 8;
        }
        while (v105);
        char v102 = v224;
        uint64_t v107 = *((unsigned int *)v224 + 88);
        if (v107)
        {
          unsigned int v108 = (void *)*((void *)v224 + 43);
          v209 = &v108[v107];
          do
          {
            uint64_t v109 = *v108;
            unsigned int v110 = objc_msgSend(MEMORY[0x1E4F1CA60], "dictionary", v209);
            objc_msgSend(v110, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", *(_DWORD *)(v109 + 24) & 0x7FFFFFFF), @"id");
            objc_msgSend(v110, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", *(void *)(v109 + 48)), @"context_id");
            if (*(unsigned char *)(v109 + 104)) {
              [v110 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:@"invalid"];
            }
            v213 = v108;
            unsigned int v111 = (void *)[*(id *)(v7 + 2632) array];
            v217 = v110;
            char v112 = (void *)(v109 + 56);
            uint64_t v113 = *(void *)(v109 + 56);
            if (v113)
            {
              unint64_t v115 = v113 & 0xFFFFFFFFFFFFFFFELL;
              if (*(void *)(v115 + 32)) {
                char v112 = *(void **)(v115 + 32);
              }
              else {
                char v112 = (void *)v115;
              }
              char v114 = &v112[*(void *)(v115 + 40)];
            }
            else
            {
              char v114 = &v112[v113 != 0];
            }
            while (v112 != v114)
            {
              char v116 = (void *)*v112;
              v225[0] = *(void **)v112;
              char v117 = std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::find<AG::Subgraph *>(&v227, v225);
              if (v117)
              {
                uint64_t v118 = [NSNumber numberWithUnsignedLong:v117[3]];
              }
              else
              {
                v244 = @"graph";
                v119 = NSNumber;
                uint64_t v120 = v116[5];
                v225[0] = *(void **)(v120 + 424);
                v121 = std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>(v241, (unint64_t *)v225);
                if (v121)
                {
                  uint64_t v122 = v121[3];
                }
                else
                {
                  uint64_t v122 = [v219 count];
                  objc_msgSend(v219, "addObject:", objc_msgSend(MEMORY[0x1E4F1CA98], "null"));
                  unint64_t v243 = *(void *)(v120 + 424);
                  v225[0] = &v243;
                  std::__hash_table<std::__hash_value_type<unsigned long,unsigned long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v241, &v243, (uint64_t)&std::piecewise_construct, v225)[3] = v122;
                  unint64_t v123 = v239;
                  unint64_t v124 = v239 + 1;
                  if (v240 < v239 + 1)
                  {
                    AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)&v238, v124);
                    unint64_t v123 = v239;
                    unint64_t v124 = v239 + 1;
                  }
                  v238[v123] = v120;
                  unint64_t v239 = v124;
                }
                v247 = (__CFString **)[v119 numberWithUnsignedLong:v122];
                unint64_t v245 = (unint64_t)@"subgraph_id";
                uint64_t v248 = [NSNumber numberWithUnsignedInt:v116[3] & 0x7FFFFFFF];
                uint64_t v118 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v247 forKeys:&v244 count:2];
              }
              [v111 addObject:v118];
              ++v112;
            }
            if ([v111 count] && v111) {
              [v217 setObject:v111 forKeyedSubscript:@"parents"];
            }
            v125 = (void *)[*(id *)(v7 + 2632) array];
            uint64_t v126 = *(unsigned int *)(v109 + 72);
            if (v126)
            {
              v127 = *(void **)(v109 + 64);
              uint64_t v128 = 8 * v126;
              do
              {
                unint64_t v129 = *v127 & 0xFFFFFFFFFFFFFFFCLL;
                v225[0] = (void *)v129;
                v130 = std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::find<AG::Subgraph *>(&v227, v225);
                if (v130)
                {
                  uint64_t v131 = [NSNumber numberWithUnsignedLong:v130[3]];
                }
                else
                {
                  v244 = @"graph";
                  v132 = NSNumber;
                  uint64_t v133 = *(void *)(v129 + 40);
                  v225[0] = *(void **)(v133 + 424);
                  v134 = std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::find<unsigned long>(v241, (unint64_t *)v225);
                  if (v134)
                  {
                    uint64_t v135 = v134[3];
                  }
                  else
                  {
                    uint64_t v135 = [v219 count];
                    objc_msgSend(v219, "addObject:", objc_msgSend(MEMORY[0x1E4F1CA98], "null"));
                    unint64_t v243 = *(void *)(v133 + 424);
                    v225[0] = &v243;
                    std::__hash_table<std::__hash_value_type<unsigned long,unsigned long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v241, &v243, (uint64_t)&std::piecewise_construct, v225)[3] = v135;
                    unint64_t v136 = v239;
                    unint64_t v137 = v239 + 1;
                    if (v240 < v239 + 1)
                    {
                      AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)&v238, v137);
                      unint64_t v136 = v239;
                      unint64_t v137 = v239 + 1;
                    }
                    v238[v136] = v133;
                    unint64_t v239 = v137;
                  }
                  v247 = (__CFString **)[v132 numberWithUnsignedLong:v135];
                  unint64_t v245 = (unint64_t)@"subgraph_id";
                  uint64_t v248 = [NSNumber numberWithUnsignedInt:*(_DWORD *)(v129 + 24) & 0x7FFFFFFF];
                  uint64_t v131 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v247 forKeys:&v244 count:2];
                }
                [v125 addObject:v131];
                ++v127;
                v128 -= 8;
              }
              while (v128);
            }
            if ([v125 count] && v125) {
              [v217 setObject:v125 forKeyedSubscript:@"children"];
            }
            v138 = (void *)[*(id *)(v7 + 2632) array];
            unsigned int v139 = *(_DWORD *)(v109 + 16);
            if (!v139) {
              goto LABEL_211;
            }
            uint64_t v140 = AG::data::_shared_table_bytes;
            do
            {
              uint64_t v141 = v139;
              uint64_t v142 = v140 + v139;
              int v143 = *(unsigned __int16 *)(v142 + 20);
              if (!*(_WORD *)(v142 + 20)) {
                goto LABEL_210;
              }
              do
              {
                uint64_t v144 = (v143 + v141);
                int v145 = ((_BYTE)v143 + (_BYTE)v141) & 3;
                if ((((_BYTE)v143 + (_BYTE)v141) & 3) == 0)
                {
                  uint64_t v146 = AG::data::_shared_table_bytes;
                  v147 = (unsigned __int16 *)(AG::data::_shared_table_bytes + v144 + 4);
                  goto LABEL_203;
                }
                if (v145 == 1)
                {
                  uint64_t v146 = AG::data::_shared_table_bytes;
                  v147 = (unsigned __int16 *)(AG::data::_shared_table_bytes + (v144 & 0xFFFFFFFC) + 14);
LABEL_203:
                  int v143 = *v147;
                  if ((v144 & 3) == 0)
                  {
                    uint64_t v148 = *(unsigned __int8 *)(v146 + v144 + 6);
                    LODWORD(v244) = v144;
                    if (std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(&v230, (unsigned int *)&v244))
                    {
                      v247 = &v244;
                      uint64_t v149 = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node> const&>,std::tuple<>>((uint64_t)&v230, (unsigned int *)&v244, (uint64_t)&std::piecewise_construct, (_DWORD **)&v247)[3];
                      objc_msgSend(v138, "addObject:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", v149));
                      if (v148)
                      {
                        v150 = objc_msgSend((id)objc_msgSend(v222, "objectAtIndexedSubscript:", v149), "mutableCopy");
                        objc_msgSend(v150, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedChar:", v148), @"subgraph_flags");
                        [v222 setObject:v150 atIndexedSubscript:v149];
                      }
                    }
                  }
                  continue;
                }
                if (v145 == 2) {
                  break;
                }
              }
              while (v143);
              uint64_t v140 = AG::data::_shared_table_bytes;
LABEL_210:
              unsigned int v139 = *(_DWORD *)(v140 + v141 + 8);
            }
            while (v139);
LABEL_211:
            if ([v138 count]) {
              [v217 setObject:v138 forKeyedSubscript:@"nodes"];
            }
            [v210 addObject:v217];
            unsigned int v108 = v213 + 1;
            char v102 = v224;
          }
          while (v213 + 1 != v209);
        }
      }
      std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)&v227);
      if (*((void *)v102 + 41))
      {
        v218 = (void *)[*(id *)(v7 + 2632) array];
        long long v227 = 0u;
        long long v228 = 0u;
        int v229 = 1065353216;
        v247 = 0;
        uint64_t v248 = 0;
        unint64_t v249 = 0;
        v244 = 0;
        unint64_t v245 = 0;
        unint64_t v246 = 0;
        uint64_t v151 = *((unsigned int *)v102 + 88);
        if (v151)
        {
          v152 = (unint64_t *)*((void *)v102 + 43);
          v153 = &v152[v151];
          do
          {
            unint64_t v243 = 0;
            unint64_t v243 = *v152;
            uint64_t v154 = *(unsigned int *)(v243 + 96);
            unint64_t v155 = v248;
            if (v154)
            {
              *(_DWORD *)(AG::data::_shared_table_bytes + v154 + 24) = 0;
              unint64_t v156 = v155 + 1;
              if (v249 < v155 + 1)
              {
                AG::vector<AG::data::ptr<AG::Node>,0ul,unsigned long>::reserve_slow((uint64_t)&v247, v156);
                unint64_t v155 = v248;
                unint64_t v156 = v248 + 1;
              }
              *((_DWORD *)v247 + v155) = v154;
              uint64_t v248 = v156;
              unint64_t v155 = v156;
            }
            while (v155)
            {
              uint64_t v157 = v155 - 1;
              unsigned int v226 = *((_DWORD *)v247 + v157);
              uint64_t v248 = v157;
              if (std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(&v227, &v226))
              {
                unint64_t v155 = v248;
              }
              else
              {
                v225[0] = (void *)v226;
                v225[1] = (void *)v245;
                std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Graph::TreeElement>,std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::hash<AG::data::ptr<AG::Graph::TreeElement>>,std::equal_to<AG::data::ptr<AG::Graph::TreeElement>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Graph::TreeElement>,std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::equal_to<AG::data::ptr<AG::Graph::TreeElement>>,std::hash<AG::data::ptr<AG::Graph::TreeElement>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Graph::TreeElement>,std::pair<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>>((uint64_t)&v227, (unsigned int *)v225, (uint64_t)v225);
                unint64_t v158 = v245;
                unint64_t v159 = v245 + 1;
                if (v246 < v245 + 1)
                {
                  AG::vector<AG::data::ptr<AG::Node>,0ul,unsigned long>::reserve_slow((uint64_t)&v244, v159);
                  unint64_t v158 = v245;
                  unint64_t v159 = v245 + 1;
                }
                *((_DWORD *)&v244->isa + v158) = v226;
                unint64_t v245 = v159;
                uint64_t v160 = AG::data::_shared_table_bytes + v226;
                int v161 = *(_DWORD *)(v160 + 20);
                unint64_t v155 = v248;
                if (v161)
                {
                  unint64_t v162 = v248 + 1;
                  if (v249 < v248 + 1)
                  {
                    AG::vector<AG::data::ptr<AG::Node>,0ul,unsigned long>::reserve_slow((uint64_t)&v247, v162);
                    unint64_t v155 = v248;
                    int v161 = *(_DWORD *)(v160 + 20);
                    unint64_t v162 = v248 + 1;
                  }
                  *((_DWORD *)v247 + v155) = v161;
                  uint64_t v248 = v162;
                  unint64_t v155 = v162;
                }
                int v163 = *(_DWORD *)(v160 + 24);
                if (v163)
                {
                  unint64_t v164 = v155 + 1;
                  if (v249 < v155 + 1)
                  {
                    AG::vector<AG::data::ptr<AG::Node>,0ul,unsigned long>::reserve_slow((uint64_t)&v247, v164);
                    unint64_t v155 = v248;
                    int v163 = *(_DWORD *)(v160 + 24);
                    unint64_t v164 = v248 + 1;
                  }
                  *((_DWORD *)v247 + v155) = v163;
                  uint64_t v248 = v164;
                  unint64_t v155 = v164;
                }
              }
            }
            uint64_t v165 = *((void *)v224 + 41);
            v225[0] = &v243;
            v166 = std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::__emplace_unique_key_args<AG::Subgraph *,std::piecewise_construct_t const&,std::tuple<AG::Subgraph * const&>,std::tuple<>>(v165, &v243, (uint64_t)&std::piecewise_construct, v225);
            AG::Graph::TreeDataElement::sort_nodes((uint64_t)(v166 + 24));
            ++v152;
          }
          while (v152 != v153);
          v167 = v244;
          v214 = (unsigned int *)v244 + v245;
          if (v245)
          {
            while (1)
            {
              uint64_t isa_low = LODWORD(v167->isa);
              uint64_t v169 = AG::data::_shared_table_bytes;
              v170 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
              uint64_t v171 = v169 + isa_low;
              unsigned int v172 = *(_DWORD *)(v169 + isa_low + 8);
              uint64_t v173 = *(void *)(v169 + isa_low);
              if (v172 < 4 || v173 == 0)
              {
                if (v172 < 4 || v173 != 0)
                {
                  if (*(_DWORD *)(v171 + 16)) {
                    goto LABEL_256;
                  }
LABEL_247:
                  [v170 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:@"root"];
                  goto LABEL_256;
                }
                LODWORD(v243) = *(_DWORD *)(v169 + isa_low + 8);
                v225[0] = &v243;
                objc_msgSend(v170, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node>&&>,std::tuple<>>((uint64_t)&v230, (unsigned int *)&v243, (uint64_t)&std::piecewise_construct, (_DWORD **)v225)[3]), @"creator");
              }
              else
              {
                if ((v172 & 3) != 0)
                {
                  unsigned int v172 = AG::AttributeID::resolve_slow((AG::AttributeID *)(v169 + isa_low + 8), 8u);
                  uint64_t v176 = v199;
                }
                else
                {
                  uint64_t v176 = 0;
                }
                if ((v172 & 3) == 0)
                {
                  LODWORD(v243) = v172;
                  v225[0] = &v243;
                  objc_msgSend(v170, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node>&&>,std::tuple<>>((uint64_t)&v230, (unsigned int *)&v243, (uint64_t)&std::piecewise_construct, (_DWORD **)v225)[3]), @"node");
                  if (v176) {
                    objc_msgSend(v170, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", v176 - 1), @"offset");
                  }
                }
                v177 = (_anonymous_namespace_ *)objc_msgSend(*(id *)(v22 + 24), "stringWithUTF8String:", AG::swift::metadata::name(*(AG::swift::metadata **)v171, 0));
                if (!*(_DWORD *)(v171 + 16)) {
                  goto LABEL_247;
                }
              }
LABEL_256:
              if (*(_DWORD *)(v171 + 12)) {
                objc_msgSend(v170, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:"), @"flags");
              }
              if (*(_DWORD *)(v171 + 20))
              {
                v178 = (void *)[*(id *)(v7 + 2632) array];
                for (iuint64_t i = *(_DWORD *)(v171 + 20);
                      ;
                      iuint64_t i = *(_DWORD *)(AG::data::_shared_table_bytes + v243 + 24))
                {
                  LODWORD(v243) = ii;
                  if (!ii) {
                    break;
                  }
                  v225[0] = &v243;
                  objc_msgSend(v178, "addObject:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Graph::TreeElement>,std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::hash<AG::data::ptr<AG::Graph::TreeElement>>,std::equal_to<AG::data::ptr<AG::Graph::TreeElement>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Graph::TreeElement>,std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::equal_to<AG::data::ptr<AG::Graph::TreeElement>>,std::hash<AG::data::ptr<AG::Graph::TreeElement>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Graph::TreeElement>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Graph::TreeElement> const&>,std::tuple<>>((uint64_t)&v227, (unsigned int *)&v243, (uint64_t)&std::piecewise_construct, (_DWORD **)v225)[3]));
                }
                [v170 setObject:v178 forKeyedSubscript:@"children"];
              }
              unint64_t v243 = 0;
              unint64_t v243 = *(void *)(AG::data::_shared_table_bytes + (isa_low & 0xFFFFFE00));
              uint64_t v180 = *((void *)v224 + 41);
              v225[0] = &v243;
              v181 = std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::__emplace_unique_key_args<AG::Subgraph *,std::piecewise_construct_t const&,std::tuple<AG::Subgraph * const&>,std::tuple<>>(v180, &v243, (uint64_t)&std::piecewise_construct, v225);
              v183 = (_DWORD *)*((void *)v181 + 3);
              unint64_t v182 = *((void *)v181 + 4);
              if (v182)
              {
                do
                {
                  unint64_t v184 = v182 >> 1;
                  v185 = &v183[2 * (v182 >> 1)];
                  unsigned int v187 = *v185;
                  v186 = v185 + 2;
                  v182 += ~(v182 >> 1);
                  if (v187 < isa_low) {
                    v183 = v186;
                  }
                  else {
                    unint64_t v182 = v184;
                  }
                }
                while (v182);
                if (v183)
                {
LABEL_271:
                  if (*v183 == isa_low)
                  {
                    v188 = (void *)[*(id *)(v7 + 2632) array];
                    if (*v183 == isa_low)
                    {
                      v189 = v183 + 1;
                      do
                      {
                        v225[0] = v189;
                        objc_msgSend(v188, "addObject:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node> const&>,std::tuple<>>((uint64_t)&v230, v189, (uint64_t)&std::piecewise_construct, (_DWORD **)v225)[3]));
                        int v190 = v189[1];
                        v189 += 2;
                      }
                      while (v190 == isa_low);
                    }
                    [v170 setObject:v188 forKeyedSubscript:@"nodes"];
                  }
                }
              }
              else if (v183)
              {
                goto LABEL_271;
              }
              uint64_t v191 = *(unsigned int *)(v171 + 28);
              if (v191)
              {
                v192 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
                v193 = v167;
                do
                {
                  uint64_t v194 = AG::data::_shared_table_bytes + v191;
                  unsigned int v195 = *(_DWORD *)(AG::data::_shared_table_bytes + v191 + 8);
                  if ((v195 & 3) != 0)
                  {
                    unsigned int v195 = AG::AttributeID::resolve_slow((AG::AttributeID *)(AG::data::_shared_table_bytes + v191 + 8), 0);
                    uint64_t v196 = v198;
                  }
                  else
                  {
                    uint64_t v196 = 0;
                  }
                  if ((v195 & 3) == 0)
                  {
                    v197 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
                    unsigned int v226 = v195;
                    v225[0] = &v226;
                    objc_msgSend(v197, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node>&&>,std::tuple<>>((uint64_t)&v230, &v226, (uint64_t)&std::piecewise_construct, (_DWORD **)v225)[3]), @"node");
                    if (v196) {
                      objc_msgSend(v197, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", v196), @"offset");
                    }
                    objc_msgSend(v192, "setObject:forKeyedSubscript:", v197, objc_msgSend(*(id *)(v22 + 24), "stringWithUTF8String:", AG::Graph::key_name(v224, (const char *)*(unsigned int *)(v194 + 12))));
                  }
                  uint64_t v191 = *(unsigned int *)(v194 + 20);
                }
                while (v191);
                [v170 setObject:v192 forKeyedSubscript:@"values"];
                v167 = v193;
              }
              [v218 addObject:v170];
              v167 = (__CFString *)((char *)v167 + 4);
              if (v167 == (__CFString *)v214)
              {
                v167 = v244;
                break;
              }
            }
          }
          char v102 = v224;
          if (v167) {
            free(v167);
          }
        }
        if (v247) {
          free(v247);
        }
        std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)&v227);
      }
      else
      {
        v218 = 0;
      }
      v200 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
      objc_msgSend(v200, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", *((void *)v102 + 53)), @"id");
      [v200 setObject:v211 forKeyedSubscript:@"types"];
      [v200 setObject:v222 forKeyedSubscript:@"nodes"];
      [v200 setObject:v223 forKeyedSubscript:@"edges"];
      [v200 setObject:v210 forKeyedSubscript:@"subgraphs"];
      if (v218) {
        [v200 setObject:v218 forKeyedSubscript:@"trees"];
      }
      uint64_t v201 = objc_msgSend(v200, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", *((void *)v102 + 55)), @"transaction_count");
      v202 = (void *)*((void *)v102 + 38);
      if (v202)
      {
        v203 = AG::Graph::ProfileData::json_data(v201, v202 + 1, v102);
        if (v203) {
          [v200 addEntriesFromDictionary:v203];
        }
        if (v202[21])
        {
          v204 = objc_msgSend(MEMORY[0x1E4F1CA60], "dictionary", v203);
          v205 = v204;
          for (juint64_t j = (uint64_t **)v202[20]; jj; juint64_t j = (uint64_t **)*jj)
          {
            v204 = AG::Graph::ProfileData::json_data((uint64_t)v204, jj + 3, v224);
            if (v204) {
              v204 = objc_msgSend(v205, "setObject:forKeyedSubscript:", v204, objc_msgSend(*(id *)(v22 + 24), "stringWithUTF8String:", AG::Graph::key_name(v224, (const char *)*((unsigned int *)jj + 4))));
            }
          }
          if ([v205 count]) {
            [v200 setObject:v205 forKeyedSubscript:@"events"];
          }
        }
      }
      else
      {
        objc_msgSend(v200, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", *((void *)v102 + 56)), @"update_count");
        objc_msgSend(v200, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", *((void *)v224 + 58)), @"change_count");
      }
      v247 = (__CFString **)*((void *)v224 + 53);
      *(void *)&long long v227 = &v247;
      objc_msgSend(v219, "setObject:atIndexedSubscript:", v200, std::__hash_table<std::__hash_value_type<unsigned long,unsigned long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>((uint64_t)v241, (unint64_t *)&v247, (uint64_t)&std::piecewise_construct, (void **)&v227)[3]);
      std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)&v230);
      if (v233) {
        free(v233);
      }
      std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)v236);
      unint64_t v21 = v239;
    }
    while (v239);
  }
  v207 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
  [v207 setObject:&unk_1F0815610 forKeyedSubscript:@"version"];
  [v207 setObject:v219 forKeyedSubscript:@"graphs"];
  if (v238) {
    free(v238);
  }
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)v241);
  return v207;
}

void sub_1AF92B310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,char a37)
{
  uint64_t v39 = *(void **)(v37 - 152);
  if (v39) {
    free(v39);
  }
  unint64_t v40 = *(void **)(v37 - 128);
  if (v40) {
    free(v40);
  }
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)&a23);
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)&a29);
  if (a34) {
    free(a34);
  }
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)&a37);
  unint64_t v41 = *(void **)(v37 - 232);
  if (v41) {
    free(v41);
  }
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table(v37 - 208);
  _Unwind_Resume(a1);
}

void *AG::Graph::description_graph_dot(AG::Graph *this, NSDictionary *a2)
{
  id v4 = [(NSDictionary *)a2 objectForKeyedSubscript:@"include-values"];
  if (v4) {
    int v68 = [v4 BOOLValue];
  }
  else {
    int v68 = 0;
  }
  id v5 = [(NSDictionary *)a2 objectForKeyedSubscript:@"attribute-ids"];
  if (v5)
  {
    id v6 = v5;
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0;
    }
  }
  else
  {
    unint64_t v7 = 0;
  }
  id v8 = [(NSDictionary *)a2 objectForKeyedSubscript:@"truncation-limit"];
  if (v8) {
    uint64_t v66 = [v8 unsignedLongValue];
  }
  else {
    uint64_t v66 = 40;
  }
  unint64_t v9 = (void *)[MEMORY[0x1E4F28E78] string];
  [v9 appendString:@"digraph {\n"];
  long long v70 = 0u;
  long long v71 = 0u;
  int v72 = 1065353216;
  uint64_t v10 = *((unsigned int *)this + 88);
  if (!v10) {
    goto LABEL_105;
  }
  uint64_t v11 = *((void *)this + 43);
  uint64_t v64 = v11 + 8 * v10;
  int v67 = this;
  do
  {
    uint64_t v65 = v11;
    unsigned int v12 = *(_DWORD *)(*(void *)v11 + 16);
    if (!v12) {
      goto LABEL_95;
    }
    uint64_t v13 = AG::data::_shared_table_bytes;
    do
    {
      uint64_t v14 = v12;
      uint64_t v15 = v13 + v12;
      int v16 = *(unsigned __int16 *)(v15 + 20);
      if (!*(_WORD *)(v15 + 20)) {
        goto LABEL_94;
      }
      uint64_t v69 = v14;
      do
      {
        while (1)
        {
          uint64_t v17 = (v16 + v14);
          int v18 = ((_BYTE)v16 + (_BYTE)v14) & 3;
          if ((((_BYTE)v16 + (_BYTE)v14) & 3) != 0)
          {
            if (v18 != 1)
            {
              if (v18 == 2) {
                goto LABEL_93;
              }
              goto LABEL_25;
            }
            uint64_t v19 = AG::data::_shared_table_bytes;
            unint64_t v20 = (unsigned __int16 *)(AG::data::_shared_table_bytes + (v17 & 0xFFFFFFFC) + 14);
          }
          else
          {
            uint64_t v19 = AG::data::_shared_table_bytes;
            unint64_t v20 = (unsigned __int16 *)(AG::data::_shared_table_bytes + v17 + 4);
          }
          int v16 = *v20;
          if ((v17 & 3) == 0) {
            break;
          }
LABEL_25:
          if (!v16) {
            goto LABEL_93;
          }
        }
        v75[0] = v17;
        if (!v7 || [v7 containsIndex:v17])
        {
          objc_msgSend(v9, "appendFormat:", @"  _%d[label=\"%d", v17, v17);
          unint64_t v21 = (unsigned int *)(v19 + v17);
          unint64_t v22 = *v21;
          uint64_t v23 = *((void *)v67 + 16);
          uint64_t v24 = (v22 >> 5) & 0x7FFFFF8;
          uint64_t v25 = *(void *)(v23 + v24);
          if ((v22 & 0x20) != 0)
          {
            uint64_t v26 = *(uint64_t (**)(void, void *))(*(void *)(v25 + 32) + 24);
            if (v26)
            {
              unsigned int v27 = (void *)((char *)v21 + *(unsigned int *)(v25 + 44));
              if (*((unsigned char *)v21 + 7)) {
                unsigned int v27 = (void *)*v27;
              }
              uint64_t v28 = (_anonymous_namespace_ *)v26(*(void *)(v23 + v24), v27);
              if (v28)
              {
                [v9 appendString:@": "];
              }
            }
          }
          if (v68)
          {
            if ((*(unsigned char *)v21 & 0x10) != 0)
            {
              uint64_t v29 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v25 + 32) + 32);
              if (v29)
              {
                uint64_t v30 = (void *)(AG::data::_shared_table_bytes + v21[2]);
                if ((*((unsigned char *)v21 + 7) & 2) != 0) {
                  uint64_t v30 = (void *)*v30;
                }
                int v31 = (_anonymous_namespace_ *)v29(v25, v30);
                if (v31)
                {
                  [v9 appendString:@"  "];
                }
              }
            }
          }
          uint64_t v32 = *((void *)v67 + 38);
          double v33 = 0.0;
          if (v32)
          {
            uint64_t v34 = std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>((void *)(v32 + 64), v75);
            if (v34)
            {
              unint64_t v35 = v34[3];
              if (v35)
              {
                double v36 = (double)v35;
                double v37 = (double)(unint64_t)v34[5];
                unint64_t v38 = *(void *)(*((void *)v67 + 38) + 24);
                double v39 = AG::absolute_time_to_seconds((AG *)(v37 / (double)v35));
                double v33 = v37 / (double)v38 * 100.0;
                [v9 appendFormat:@"\\n%.2g%%: %g  %.2fs", *(void *)&v33, *(void *)&v36, v39 * 1000000.0];
              }
            }
          }
          [v9 appendString:@"\""];
          int v40 = *v21;
          unint64_t v41 = @" fillcolor=cyan";
          if ((*v21 & 0xC0) != 0
            || (unint64_t v41 = @" fillcolor=orangered", v33 > 10.0)
            || (unint64_t v41 = @" fillcolor=orange", v33 > 5.0)
            || (unint64_t v41 = @" fillcolor=yellow", v33 > 1.0))
          {
            [v9 appendString:v41];
            int v40 = *v21;
            int v42 = 1;
          }
          else
          {
            int v42 = 0;
          }
          unint64_t v43 = @" style=\"dashed%s\"";
          if ((v40 & 0x10) != 0 && (unint64_t v43 = @" style=\"bold%s\"", v21[3] >= 0x20) && v21[5] > 0x1F)
          {
            if (v42) {
              [v9 appendFormat:@" style=filled"];
            }
          }
          else
          {
            uint64_t v44 = "";
            if (v42) {
              uint64_t v44 = ",filled";
            }
            objc_msgSend(v9, "appendFormat:", v43, v44);
          }
          if (*(unsigned char *)v21) {
            [v9 appendString:@" color=red"];
          }
          [v9 appendString:@"];\n"];
          unint64_t v45 = v21[3];
          if (v45 >= 0x20)
          {
            uint64_t v46 = AG::data::_shared_table_bytes + v21[4];
            uint64_t v47 = v46 + 5 * (v45 >> 5);
            do
            {
              char v49 = *(unsigned char *)(v46 + 4);
              unsigned int v74 = *(_DWORD *)v46;
              unsigned int v48 = v74;
              unsigned int v50 = v74;
              unsigned int v51 = v74 & 3;
              if ((v74 & 3) != 0) {
                unsigned int v50 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v74, 0);
              }
              if ((v50 & 3) == 0 && (!v7 || [v7 containsIndex:v50]))
              {
                unsigned int v74 = v48;
                if (v51)
                {
                  unsigned int v55 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v74, 4u);
                  uint64_t v52 = v56;
                  unsigned int v48 = v55;
                }
                else
                {
                  uint64_t v52 = 0;
                }
                objc_msgSend(v9, "appendFormat:", @"  _%d -> _%d[", v48 & 0xFFFFFFFC, v75[0]);
                while ((v48 & 3) == 1)
                {
                  unsigned int v74 = v48 & 0xFFFFFFFC;
                  if (!std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,AG::Graph::ProfileData::Item>>>::find<AG::data::ptr<AG::Node>>(&v70, &v74))std::__hash_table<AG::data::ptr<AG::IndirectNode>,std::hash<AG::data::ptr<AG::IndirectNode>>,std::equal_to<AG::data::ptr<AG::IndirectNode>>,std::allocator<AG::data::ptr<AG::IndirectNode>>>::__emplace_unique_key_args<AG::data::ptr<AG::IndirectNode>,AG::data::ptr<AG::IndirectNode> const&>((uint64_t)&v70, &v74, &v74); {
                  int v73 = *(_DWORD *)(AG::data::_shared_table_bytes + v74);
                  }
                  if ((v73 & 3) == 0) {
                    break;
                  }
                  unsigned int v48 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v73, 4u);
                }
                if ((v49 & 8) != 0) {
                  [v9 appendString:@" color=red"];
                }
                uint64_t v53 = *(void *)(AG::data::_shared_table_bytes + (v50 & 0xFFFFFE00));
                if (v53) {
                  uint64_t v53 = *(void *)(v53 + 48);
                }
                uint64_t v54 = *(void *)(AG::data::_shared_table_bytes + (v75[0] & 0xFFFFFE00));
                if (v54) {
                  uint64_t v54 = *(void *)(v54 + 48);
                }
                if (v53 != v54) {
                  [v9 appendString:@" penwidth=2"];
                }
                if (v51 == 1) {
                  objc_msgSend(v9, "appendFormat:", @" label=\"@%d\"", v52);
                }
                [v9 appendString:@"];\n"];
              }
              v46 += 5;
            }
            while (v46 != v47);
          }
        }
        uint64_t v14 = v69;
      }
      while (v16);
LABEL_93:
      uint64_t v13 = AG::data::_shared_table_bytes;
LABEL_94:
      unsigned int v12 = *(_DWORD *)(v13 + v14 + 8);
    }
    while (v12);
LABEL_95:
    uint64_t v11 = v65 + 8;
  }
  while (v65 + 8 != v64);
  for (uint64_t i = (uint64_t **)v71; i; uint64_t i = (uint64_t **)*i)
  {
    uint64_t v58 = *((unsigned int *)i + 4);
    uint64_t v59 = AG::data::_shared_table_bytes;
    objc_msgSend(v9, "appendFormat:", @"  _%d[label=\"%d\" shape=box];\n", v58, v58);
    uint64_t v60 = v59 + v58;
    unsigned int v61 = *(_DWORD *)v60;
    v75[0] = v61;
    if ((v61 & 3) != 0) {
      unsigned int v61 = AG::AttributeID::resolve_slow((AG::AttributeID *)v75, 4u);
    }
    else {
      uint64_t v62 = 0;
    }
    objc_msgSend(v9, "appendFormat:", @"  _%d -> _%d[label=\"@%d\"];\n", v61 & 0xFFFFFFFC, v58, v62);
    if ((*(unsigned char *)(v60 + 8) & 1) != 0 && *(_DWORD *)(v60 + 16)) {
      objc_msgSend(v9, "appendFormat:", @"  _%d -> _%d[color=blue];\n", *(unsigned int *)(v60 + 16), v58);
    }
  }
LABEL_105:
  [v9 appendString:@"}\n"];
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)&v70);
  return v9;
}

void sub_1AF92BBAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::__hash_table<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,AG::Graph::ProfileTrace::UpdateData>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void *AG::Graph::description_stack(AG::Graph *this, NSDictionary *a2)
{
  uint64_t v3 = (void *)[MEMORY[0x1E4F28E78] string];
  id v4 = [(NSDictionary *)a2 objectForKeyedSubscript:@"max-frames"];
  if (v4) {
    uint64_t v5 = [v4 unsignedIntValue];
  }
  else {
    uint64_t v5 = -1;
  }
  unint64_t v35 = v5;
  uint64_t v6 = AG::Graph::_current_update_key;
  uint64_t v7 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  if (v7)
  {
    unint64_t v8 = 0;
    unint64_t v9 = &AG::data::_shared_table_bytes;
    uint64_t v10 = @"    %u";
    uint64_t v11 = @"\n";
    do
    {
      unint64_t v12 = v7 & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v36 = v12 + 32;
      unint64_t v37 = v12;
      uint64_t v13 = *(void *)(v12 + 104);
      while (v13)
      {
        uint64_t v14 = v13 - 1;
        unint64_t v15 = *(void *)(v37 + 96);
        if (!v15) {
          unint64_t v15 = v36;
        }
        uint64_t v38 = v14;
        uint64_t v16 = *(unsigned int *)(v15 + 8 * v14);
        uint64_t v17 = (unsigned int *)(*v9 + v16);
        int v18 = *(AG::swift::metadata ***)(*((void *)this + 16) + (((unint64_t)*v17 >> 5) & 0x7FFFFF8));
        uint64_t v19 = AG::swift::metadata::name(*v18, 0);
        objc_msgSend(v3, "appendFormat:", @"  #%d: %u %s -> %s\n", v8, v16, v19, AG::swift::metadata::name(v18[1], 0));
        if (v8 || v17[3] < 0x20) {
          goto LABEL_14;
        }
        [v3 appendString:@"  -- inputs:\n"];
        unint64_t v20 = v17[3];
        if (v20 >= 0x20)
        {
          unint64_t v21 = (unsigned int *)(*v9 + v17[4]);
          unint64_t v22 = (unsigned int *)((char *)v21 + 5 * (v20 >> 5));
          do
          {
            uint64_t v23 = *v21;
            char v24 = *((unsigned char *)v21 + 4);
            int v40 = v23;
            if ((v23 & 3) != 0)
            {
              uint64_t v31 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v40, 8u);
              LODWORD(v23) = v31;
              uint64_t v33 = v32;
              objc_msgSend(v3, "appendFormat:", v10, v31);
              if (v33) {
                objc_msgSend(v3, "appendFormat:", @"[@%d]", (v33 - 1));
              }
            }
            else
            {
              objc_msgSend(v3, "appendFormat:", v10, v23);
            }
            if ((v23 & 3) != 0)
            {
              if ((v24 & 8) == 0) {
                goto LABEL_21;
              }
            }
            else
            {
              uint64_t v25 = v11;
              uint64_t v26 = v10;
              unsigned int v27 = v9;
              uint64_t v28 = *(AG::swift::metadata ***)(*((void *)this + 16)
                                             + (((unint64_t)*(unsigned int *)(*v9 + v23) >> 5) & 0x7FFFFF8));
              uint64_t v29 = AG::swift::metadata::name(*v28, 0);
              uint64_t v30 = v28[1];
              unint64_t v9 = v27;
              uint64_t v10 = v26;
              uint64_t v11 = v25;
              objc_msgSend(v3, "appendFormat:", @" %s -> %s", v29, AG::swift::metadata::name(v30, 0));
              if ((v24 & 8) == 0)
              {
LABEL_21:
                if ((v24 & 4) != 0) {
                  goto LABEL_28;
                }
                goto LABEL_22;
              }
            }
            [v3 appendString:@", changed"];
            if ((v24 & 4) != 0)
            {
LABEL_28:
              [v3 appendString:@", always-enabled"];
              if ((v24 & 1) == 0) {
                goto LABEL_24;
              }
LABEL_23:
              [v3 appendString:@", unprefetched"];
              goto LABEL_24;
            }
LABEL_22:
            if (v24) {
              goto LABEL_23;
            }
LABEL_24:
            [v3 appendString:v11];
            unint64_t v21 = (unsigned int *)((char *)v21 + 5);
          }
          while (v21 != v22);
        }
        [v3 appendString:@"  --\n"];
LABEL_14:
        ++v8;
        uint64_t v13 = v38;
        if (v8 >= v35) {
          return v3;
        }
      }
      uint64_t v7 = *(void *)(v37 + 16);
    }
    while (v7);
  }
  return v3;
}

void *AG::Graph::description_stack_nodes(AG::Graph *this, NSDictionary *a2)
{
  uint64_t v3 = (void *)[MEMORY[0x1E4F1CA48] array];
  id v4 = [(NSDictionary *)a2 objectForKeyedSubscript:@"max-frames"];
  if (v4) {
    unint64_t v5 = [v4 unsignedIntValue];
  }
  else {
    unint64_t v5 = -1;
  }
  uint64_t v6 = AG::Graph::_current_update_key;
  uint64_t v7 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  if (v7)
  {
    unint64_t v8 = 0;
    do
    {
      unint64_t v9 = v7 & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFFELL) + 32;
      uint64_t v11 = *(void *)((v7 & 0xFFFFFFFFFFFFFFFELL) + 104);
      uint64_t v12 = 8 * v11 - 8;
      while (v11)
      {
        --v11;
        unint64_t v13 = *(void *)(v9 + 96);
        if (!v13) {
          unint64_t v13 = v10;
        }
        objc_msgSend(v3, "addObject:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v13 + v12)));
        ++v8;
        v12 -= 8;
        if (v8 >= v5) {
          return v3;
        }
      }
      uint64_t v7 = *(void *)(v9 + 16);
    }
    while (v7);
  }
  return v3;
}

void *AG::Graph::description_stack_frame(AG::Graph *this, NSDictionary *a2)
{
  id v4 = [(NSDictionary *)a2 objectForKeyedSubscript:@"frame_index"];
  if (v4) {
    uint64_t v5 = [v4 unsignedIntValue];
  }
  else {
    uint64_t v5 = -1;
  }
  id v6 = [(NSDictionary *)a2 objectForKeyedSubscript:@"frame_node"];
  if (v6) {
    LODWORD(v6) = [v6 unsignedIntValue];
  }
  uint64_t v7 = AG::Graph::_current_update_key;
  uint64_t v8 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  if (!v8) {
    return (void *)MEMORY[0x1E4F1CC08];
  }
  unint64_t v9 = (void *)MEMORY[0x1E4F1CC08];
  while (1)
  {
    unint64_t v10 = (void *)(v8 & 0xFFFFFFFFFFFFFFFELL);
    uint64_t v11 = v10[13];
    if (v11) {
      break;
    }
LABEL_15:
    uint64_t v8 = v10[2];
    if (!v8) {
      return v9;
    }
  }
  uint64_t v12 = 0;
  unint64_t v13 = v10 + 4;
  if (v10[12]) {
    unint64_t v13 = (void *)v10[12];
  }
  uint64_t v14 = (unsigned int *)&v13[v11 - 1];
  while (v5 != v12)
  {
    if (*v14 == v6)
    {
      uint64_t v5 = v12;
      break;
    }
    ++v12;
    v14 -= 2;
    if (v11 == v12) {
      goto LABEL_15;
    }
  }
  unint64_t v15 = 0x1E4F1C000uLL;
  unint64_t v9 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", v5), @"index");
  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", *v14), @"node-id");
  uint64_t v16 = AG::data::_shared_table_bytes + *v14;
  AGSetTypeForKey(v9, @"self-type");
  AGSetTypeForKey(v9, @"value-type");
  if (*(_DWORD *)(v16 + 12) >= 0x20u)
  {
    uint64_t v17 = objc_msgSend(MEMORY[0x1E4F1CA48], "array", this);
    unint64_t v18 = *(unsigned int *)(v16 + 12);
    if (v18 < 0x20)
    {
LABEL_21:
      [v9 setObject:v17 forKeyedSubscript:@"inputs"];
      return v9;
    }
    unint64_t v20 = (unsigned int *)(AG::data::_shared_table_bytes + *(unsigned int *)(v16 + 16));
    unint64_t v21 = (unsigned int *)((char *)v20 + 5 * (v18 >> 5));
    while (1)
    {
      uint64_t v22 = *v20;
      char v23 = *((unsigned char *)v20 + 4);
      unint64_t v24 = v15;
      uint64_t v25 = (void *)[*(id *)(v15 + 2656) dictionary];
      objc_msgSend(v25, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v22), @"id");
      int v28 = v22;
      if ((v22 & 3) != 0)
      {
        uint64_t v22 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v28, 8u);
        uint64_t v26 = v27;
      }
      else
      {
        uint64_t v26 = 0;
      }
      objc_msgSend(v25, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v22), @"node");
      if (v26) {
        objc_msgSend(v25, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLong:", v26 - 1), @"offset");
      }
      if ((v22 & 3) == 0)
      {
        AGSetTypeForKey(v25, @"self-type");
        AGSetTypeForKey(v25, @"value-type");
      }
      unint64_t v15 = v24;
      if ((v23 & 8) != 0)
      {
        [v25 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:@"changed"];
        if ((v23 & 4) != 0)
        {
LABEL_37:
          [v25 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:@"always-enabled"];
          if ((v23 & 1) == 0) {
            goto LABEL_34;
          }
LABEL_33:
          [v25 setObject:MEMORY[0x1E4F1CC28] forKeyedSubscript:@"prefetched"];
          goto LABEL_34;
        }
      }
      else if ((v23 & 4) != 0)
      {
        goto LABEL_37;
      }
      if (v23) {
        goto LABEL_33;
      }
LABEL_34:
      [v17 addObject:v25];
      unint64_t v20 = (unsigned int *)((char *)v20 + 5);
      if (v20 == v21) {
        goto LABEL_21;
      }
    }
  }
  return v9;
}

void AG::Graph::print(AG::Graph *this)
{
  uint64_t v2 = (void *)MEMORY[0x1B3E85040]();
  uint64_t v3 = AG::Graph::description_graph_dot(this, 0);
  if (v3)
  {
    id v4 = (const char *)[v3 UTF8String];
    fputs(v4, (FILE *)*MEMORY[0x1E4F143C8]);
  }
}

void AG::Graph::print_cycle(uint64_t a1, const char *a2)
{
  v21[2] = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 232);
  if (v4)
  {
    unsigned int v13 = v4 - 1;
    do
    {
      uint64_t v14 = v13;
      AG::Trace::log_message(*(AG::Trace **)(*(void *)(a1 + 224) + 8 * v13--), "cycle detected through attribute: %u", a2);
    }
    while (v14);
  }
  {
    if (v15)
    {
    }
  }
  if (AG::Graph::print_cycle(AG::data::ptr<AG::Node>)const::verbosity >= 1)
  {
    uint64_t v5 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "=== AttributeGraph: cycle detected through attribute %u ===\n", a2);
    if (AG::Graph::print_cycle(AG::data::ptr<AG::Node>)const::verbosity >= 2)
    {
      if (AG::Graph::print_cycle(AG::data::ptr<AG::Node>)const::verbosity != 2)
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        AG::Graph::collect_stack(a1, &v17);
        id v6 = (void *)[MEMORY[0x1E4F28E60] indexSet];
        if (v18)
        {
          uint64_t v7 = (unsigned int *)v17;
          uint64_t v8 = 4 * v18;
          do
          {
            [v6 addIndex:*v7++];
            v8 -= 4;
          }
          while (v8);
        }
        unint64_t v9 = (void *)MEMORY[0x1B3E85040]();
        v20[0] = @"format";
        v20[1] = @"attribute-ids";
        v21[0] = @"graph/dot";
        v21[1] = v6;
        unint64_t v10 = (NSDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v21 forKeys:v20 count:2];
        id v12 = AG::Graph::description((AG::Graph *)a1, v10, v11);
        if (v12) {
          fputs((const char *)[v12 UTF8String], *v5);
        }
        fwrite("=== Evaluation stack ===\n", 0x19uLL, 1uLL, *v5);
        if (v17) {
          free(v17);
        }
      }
      AG::Graph::print_stack((AG::Graph *)a1);
      fwrite("===\n", 4uLL, 1uLL, *v5);
      if (AG::Graph::print_cycle(AG::data::ptr<AG::Node>)const::verbosity >= 4
        && os_variant_has_internal_diagnostics())
      {
        AGGraphArchiveJSON((AG::Graph *)"cycle.ag-json");
      }
    }
  }
  {
    if (v16)
    {
    }
  }
  if (AG::Graph::print_cycle(AG::data::ptr<AG::Node>)const::traps) {
    AG::precondition_failure((AG *)"cyclic graph: %u", a2, a2);
  }
}

void sub_1AF92C658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11)
{
  if (a11) {
    free(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AG::Trace::log_message(AG::Trace *this, const char *a2, ...)
{
  va_start(va, a2);
  return (*(uint64_t (**)(AG::Trace *, const char *, uint64_t *))(*(void *)this + 40))(this, a2, (uint64_t *)va);
}

uint64_t AG::anonymous namespace'::cycle_verbosity(AG::_anonymous_namespace_ *this)
{
  uint64_t v1 = getenv("AG_PRINT_CYCLES");
  if (!v1) {
    return 1;
  }
  return atoi(v1);
}

char *AG::anonymous namespace'::trap_cycles(AG::_anonymous_namespace_ *this)
{
  uint64_t result = getenv("AG_TRAP_CYCLES");
  if (result) {
    return (char *)(atoi(result) != 0);
  }
  return result;
}

uint64_t AG::Graph::description(uint64_t a1, uint64_t a2)
{
  int v4 = (void *)[MEMORY[0x1E4F1CA48] array];
  uint64_t v5 = (unsigned int *)(AG::data::_shared_table_bytes + a2);
  uint64_t v6 = *(void *)(*(void *)(a1 + 128) + (((unint64_t)*v5 >> 5) & 0x7FFFFF8));
  [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"identifier = %u", a2)];
  [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"type = %u", *v5 >> 8)];
  [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"self_size = %d", *(void *)(*(void *)(*(void *)v6 - 8) + 64))];
  [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"value_size = %d", *(void *)(*(void *)(*(void *)(v6 + 8) - 8) + 64))];
  if ((*(unsigned char *)(*(void *)(*(void *)v6 - 8) + 82) & 1) == 0) {
    [v4 addObject:@"pod_self = true"];
  }
  if ((*(unsigned char *)(*(void *)(*(void *)(v6 + 8) - 8) + 82) & 1) == 0) {
    [v4 addObject:@"pod_value = true"];
  }
  if ((*(unsigned char *)(*(void *)(*(void *)v6 - 8) + 82) & 0x10) == 0) {
    [v4 addObject:@"bitwise_takable_self = true"];
  }
  if ((*(unsigned char *)(*(void *)(*(void *)(v6 + 8) - 8) + 82) & 0x10) == 0) {
    [v4 addObject:@"bitwise_takable_value = true"];
  }
  [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"input_count = %d", v5[3] >> 5)];
  [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"output_count = %d", v5[5] >> 5)];
  [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"dirty = %d", *v5 & 1)];
  [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"updating = %d", (*v5 & 0xC0) != 0)];
  uint64_t v7 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v6 + 32) + 24);
  if (v7 && (*(unsigned char *)v5 & 0x20) != 0)
  {
    uint64_t v8 = (void *)((char *)v5 + *(unsigned int *)(v6 + 44));
    if (*((unsigned char *)v5 + 7)) {
      uint64_t v8 = (void *)*v8;
    }
    uint64_t v9 = v7(v6, v8);
    if (v9) {
      [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"self = %@", v9)];
    }
  }
  if ((*(unsigned char *)v5 & 0x10) != 0)
  {
    unint64_t v10 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v6 + 32) + 32);
    if (v10)
    {
      uint64_t v11 = (void *)(AG::data::_shared_table_bytes + v5[2]);
      if ((*((unsigned char *)v5 + 7) & 2) != 0) {
        uint64_t v11 = (void *)*v11;
      }
      uint64_t v12 = v10(v6, v11);
      if (v12) {
        [v4 addObject:objc_msgSend(NSString, "stringWithFormat:", @"value = %@", v12)];
      }
    }
  }
  return [v4 componentsJoinedByString:@", "];
}

void AG::Graph::print_attribute(uint64_t a1, unsigned int a2)
{
  int v4 = (void *)MEMORY[0x1B3E85040]();
  uint64_t v5 = (void *)AG::Graph::description(a1, a2);
  if (v5) {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", (const char *)[v5 UTF8String]);
  }
}

void AG::Graph::write_to_file(AG::Graph *this, const AG::Graph *a2, const char *a3)
{
  char v3 = (char)a3;
  v23[3] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (void *)MEMORY[0x1B3E85040]();
  v23[0] = @"graph/dict";
  v22[0] = @"format";
  v22[1] = @"include-values";
  v23[1] = [NSNumber numberWithBool:(v3 & 1) == 0];
  v22[2] = @"all_graphs";
  v23[2] = [NSNumber numberWithBool:this == 0];
  uint64_t v7 = (NSDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v23 forKeys:v22 count:3];
  id v9 = AG::Graph::description(this, v7, v8);
  if (v9)
  {
    if (a2) {
      unint64_t v10 = (const char *)a2;
    }
    else {
      unint64_t v10 = "graph.ag-gzon";
    }
    uint64_t v11 = (void *)[MEMORY[0x1E4F28D90] dataWithJSONObject:v9 options:0 error:0];
    uint64_t v12 = (NSString *)[NSString stringWithUTF8String:v10];
    if (*v10 != 47) {
      uint64_t v12 = [(NSString *)NSTemporaryDirectory() stringByAppendingPathComponent:v12];
    }
    id v21 = 0;
    if ([[(NSString *)v12 pathExtension] isEqualToString:@"ag-gzon"])
    {
      gzFile v13 = gzopen([(NSString *)v12 fileSystemRepresentation], "wb");
      if (v13)
      {
        uint64_t v14 = v13;
        unint64_t v15 = (char *)[v11 bytes];
        uint64_t v16 = [v11 length];
        if (v16)
        {
          uint64_t v17 = v16;
          while (1)
          {
            int v18 = gzwrite(v14, v15, v17);
            if (v18 <= 0) {
              break;
            }
            v15 += v18;
            v17 -= v18;
            if (!v17) {
              goto LABEL_13;
            }
          }
          gzclose(v14);
          goto LABEL_17;
        }
LABEL_13:
        gzclose(v14);
      }
    }
    else if (![v11 writeToFile:v12 options:0 error:&v21])
    {
LABEL_17:
      unint64_t v20 = (FILE *)*MEMORY[0x1E4F143C8];
      [(NSString *)v12 UTF8String];
      objc_msgSend((id)objc_msgSend(v21, "description"), "UTF8String");
      fprintf(v20, "Unable to write to \"%s\": %s\n");
      goto LABEL_18;
    }
    uint64_t v19 = (FILE *)*MEMORY[0x1E4F143C8];
    [(NSString *)v12 UTF8String];
    fprintf(v19, "Wrote graph data to \"%s\".\n");
  }
LABEL_18:
}

uint64_t AG::Graph::print_data(AG::Graph *this)
{
  AG::data::table::print((os_unfair_lock_s *)&AG::data::_shared_table_bytes);
  uint64_t result = AG::data::zone::print_header(v2);
  uint64_t v4 = *((unsigned int *)this + 88);
  if (v4)
  {
    uint64_t v5 = (const void ****)*((void *)this + 43);
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = *v5++;
      uint64_t result = AG::data::zone::print(v7);
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,unsigned long>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned long>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned long>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned long>>>::__emplace_unique_key_args<unsigned int,unsigned int &,unsigned long &>(uint64_t a1, unsigned int *a2, _DWORD *a3, void *a4)
{
  unint64_t v8 = *a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v9 <= v8) {
        unint64_t v4 = v8 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & v8;
    }
    uint64_t v11 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (*v11)
      {
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (*((_DWORD *)v12 + 4) == v8) {
              return v12;
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9) {
                v13 %= v9;
              }
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v4) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
  uint64_t v12 = operator new(0x20uLL);
  *uint64_t v12 = 0;
  v12[1] = v8;
  *((_DWORD *)v12 + 4) = *a3;
  v12[3] = *a4;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v19);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8) {
        unint64_t v4 = v8 % v9;
      }
      else {
        unint64_t v4 = v8;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & v8;
    }
  }
  uint64_t v20 = *(void *)a1;
  id v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *uint64_t v12 = *v21;
LABEL_38:
    *id v21 = v12;
    goto LABEL_39;
  }
  *uint64_t v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v20 + 8 * v4) = a1 + 16;
  if (*v12)
  {
    unint64_t v22 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }
    else
    {
      v22 &= v9 - 1;
    }
    id v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v12;
}

void sub_1AF92D03C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::escaped_string(_anonymous_namespace_ *this, NSString *a2)
{
  char v3 = this;
  if ([(_anonymous_namespace_ *)this length] > (unint64_t)a2) {
    char v3 = (_anonymous_namespace_ *)objc_msgSend((id)-[_anonymous_namespace_ substringToIndex:](v3, "substringToIndex:", a2), "stringByAppendingString:", @"");
  }
  return [(_anonymous_namespace_ *)v3 stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
}

void *std::__hash_table<std::__hash_value_type<unsigned long,unsigned long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long &&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint8x8_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *uint64_t i = *v20;
LABEL_38:
    *uint64_t v20 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v21 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1AF92D2CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node> const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint8x8_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v11 = operator new(0x20uLL);
  *uint64_t v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *uint64_t v11 = *v20;
LABEL_38:
    *uint64_t v20 = v11;
    goto LABEL_39;
  }
  *uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1AF92D4F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::hash<AG::data::ptr<AG::Node>>,std::equal_to<AG::data::ptr<AG::Node>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Node>,std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>,std::equal_to<AG::data::ptr<AG::Node>>,std::hash<AG::data::ptr<AG::Node>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Node>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Node>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Node>&&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint8x8_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v11 = operator new(0x20uLL);
  *uint64_t v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *uint64_t v11 = *v20;
LABEL_38:
    *uint64_t v20 = v11;
    goto LABEL_39;
  }
  *uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1AF92D71C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<AG::Subgraph const*,unsigned long>,std::__unordered_map_hasher<AG::Subgraph const*,std::__hash_value_type<AG::Subgraph const*,unsigned long>,std::hash<AG::Subgraph const*>,std::equal_to<AG::Subgraph const*>,true>,std::__unordered_map_equal<AG::Subgraph const*,std::__hash_value_type<AG::Subgraph const*,unsigned long>,std::equal_to<AG::Subgraph const*>,std::hash<AG::Subgraph const*>,true>,std::allocator<std::__hash_value_type<AG::Subgraph const*,unsigned long>>>::__emplace_unique_key_args<AG::Subgraph const*,std::piecewise_construct_t const&,std::tuple<AG::Subgraph const* const&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    unint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v9;
  i[2] = **a4;
  i[3] = 0;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v10 || (float)(v16 * (float)v10) < v15)
  {
    BOOL v17 = 1;
    if (v10 >= 3) {
      BOOL v17 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v10);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v20);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v21 = *(void *)a1;
  unint64_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *uint64_t i = *v22;
LABEL_38:
    *unint64_t v22 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v23 = *(void *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v23 >= v10) {
        v23 %= v10;
      }
    }
    else
    {
      v23 &= v10 - 1;
    }
    unint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1AF92D974(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Graph::TreeElement>,std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::hash<AG::data::ptr<AG::Graph::TreeElement>>,std::equal_to<AG::data::ptr<AG::Graph::TreeElement>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Graph::TreeElement>,std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::equal_to<AG::data::ptr<AG::Graph::TreeElement>>,std::hash<AG::data::ptr<AG::Graph::TreeElement>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Graph::TreeElement>,std::pair<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x20uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *(_DWORD *)a3;
  v10[3] = *(void *)(a3 + 8);
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *unint64_t v10 = *v19;
LABEL_38:
    *unint64_t v19 = v10;
    goto LABEL_39;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1AF92DB9C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::__unordered_map_hasher<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::hash<AG::Subgraph *>,std::equal_to<AG::Subgraph *>,true>,std::__unordered_map_equal<AG::Subgraph *,std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,std::equal_to<AG::Subgraph *>,std::hash<AG::Subgraph *>,true>,std::allocator<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>>>::__emplace_unique_key_args<AG::Subgraph *,std::piecewise_construct_t const&,std::tuple<AG::Subgraph * const&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    float v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      float v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = *((void *)v13 + 1);
          if (v14 == v9)
          {
            if (*((void *)v13 + 2) == *a2) {
              return v13;
            }
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10) {
                v14 %= v10;
              }
            }
            else
            {
              v14 &= v10 - 1;
            }
            if (v14 != v4) {
              break;
            }
          }
          float v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  unint64_t v15 = (void *)(a1 + 16);
  float v13 = (char *)operator new(0x38uLL);
  *(void *)float v13 = 0;
  *((void *)v13 + 1) = v9;
  *((void *)v13 + 2) = **a4;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = 0u;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v22 = *(void *)a1;
  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)float v13 = *v23;
LABEL_38:
    *unint64_t v23 = v13;
    goto LABEL_39;
  }
  *(void *)float v13 = *v15;
  *unint64_t v15 = v13;
  *(void *)(v22 + 8 * v4) = v15;
  if (*(void *)v13)
  {
    unint64_t v24 = *(void *)(*(void *)v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v24 >= v10) {
        v24 %= v10;
      }
    }
    else
    {
      v24 &= v10 - 1;
    }
    unint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v13;
}

void sub_1AF92DE24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<AG::Subgraph *,AG::Graph::TreeDataElement>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::__unordered_map_hasher<AG::data::ptr<AG::Graph::TreeElement>,std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::hash<AG::data::ptr<AG::Graph::TreeElement>>,std::equal_to<AG::data::ptr<AG::Graph::TreeElement>>,true>,std::__unordered_map_equal<AG::data::ptr<AG::Graph::TreeElement>,std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>,std::equal_to<AG::data::ptr<AG::Graph::TreeElement>>,std::hash<AG::data::ptr<AG::Graph::TreeElement>>,true>,std::allocator<std::__hash_value_type<AG::data::ptr<AG::Graph::TreeElement>,unsigned long>>>::__emplace_unique_key_args<AG::data::ptr<AG::Graph::TreeElement>,std::piecewise_construct_t const&,std::tuple<AG::data::ptr<AG::Graph::TreeElement> const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v11 = operator new(0x20uLL);
  *uint64_t v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  unint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *uint64_t v11 = *v20;
LABEL_38:
    *unint64_t v20 = v11;
    goto LABEL_39;
  }
  *uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    unint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1AF92E054(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<AG::data::ptr<AG::IndirectNode>,std::hash<AG::data::ptr<AG::IndirectNode>>,std::equal_to<AG::data::ptr<AG::IndirectNode>>,std::allocator<AG::data::ptr<AG::IndirectNode>>>::__emplace_unique_key_args<AG::data::ptr<AG::IndirectNode>,AG::data::ptr<AG::IndirectNode> const&>(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,AG::Graph::ProfileData::Item>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *unint64_t v10 = *v19;
LABEL_38:
    *uint64_t v19 = v10;
    goto LABEL_39;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1AF92E274(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t AG::Graph::Context::to_cf(AG::Graph::Context *this)
{
  return (uint64_t)this - 16;
}

uint64_t AGGraphGetGraphContext(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  return *(void *)(a1 + 16);
}

uint64_t AGGraphBeginDeferringSubgraphInvalidation(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = *(unsigned __int8 *)(v2 + 408);
  *(unsigned char *)(v2 + 408) = 1;
  return result;
}

void AGGraphEndDeferringSubgraphInvalidation(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  if (!a2)
  {
    uint64_t v2 = *(AG::Graph **)(a1 + 16);
    if (v2)
    {
      *((unsigned char *)v2 + 408) = 0;
      AG::Graph::invalidate_subgraphs(v2);
    }
  }
}

uint64_t AGGraphWithoutUpdate(uint64_t (*a1)(void))
{
  uint64_t v1 = AG::Graph::_current_update_key;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v3 = *(void *)(StatusReg + 8 * v1);
  uint64_t v4 = v3 | 1;
  if (!v3) {
    uint64_t v4 = 0;
  }
  *(void *)(StatusReg + 8 * v1) = v4;
  uint64_t result = a1();
  *(void *)(StatusReg + 8 * AG::Graph::_current_update_key) = v3;
  return result;
}

void sub_1AF92E3C8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8 * *v2) = v3;
  _Unwind_Resume(a1);
}

uint64_t AGGraphGetDeadline(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  return *(void *)(a1 + 72);
}

uint64_t *AGGraphSetDeadline(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  uint64_t v2 = (uint64_t *)(a1 + 16);
  return AG::Graph::Context::set_deadline(v2, (uint64_t)a2);
}

char *AGGraphReadCachedAttributeIfExists(char *a1, uint64_t *a2, const void *a3, AG::swift::metadata *a4, char a5, unsigned int a6, unsigned char *a7, int a8)
{
  char v10 = 0;
  if (a7) {
    *a7 = v10 & 1;
  }
  return result;
}

uint64_t AGGraphCreateOffsetAttribute(uint64_t a1, const char *a2)
{
}

uint64_t AGGraphGetIndirectAttribute(uint64_t result)
{
  if ((result & 3) == 1) {
    return *(unsigned int *)(AG::data::_shared_table_bytes + (result & 0xFFFFFFFC));
  }
  return result;
}

uint64_t AGGraphResetIndirectAttribute(uint64_t a1, const char *a2, const char *a3)
{
  if ((a1 & 3) != 1
    || (a3 = a2,
        a2 = (const char *)(a1 & 0xFFFFFFFC),
        (uint64_t v3 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00))) == 0))
  {
    AG::precondition_failure((AG *)"invalid indirect attribute: %u", a2, a3, a1);
  }
  uint64_t v4 = *(void *)(v3 + 40);
  return AG::Graph::indirect_attribute_reset(v4, a2, (char)a3);
}

uint64_t AGGraphGetIndirectDependency(uint64_t a1, const char *a2)
{
  if ((a1 & 3) != 1
    || (a2 = (const char *)(a1 & 0xFFFFFFFC),
        (uint64_t v2 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00))) == 0))
  {
    AG::precondition_failure((AG *)"invalid indirect attribute: %u", a2, a1);
  }
  uint64_t v3 = *(void *)(v2 + 40);
  return AG::Graph::indirect_attribute_dependency(v3, a2);
}

uint64_t AGGraphVerifyType(uint64_t result, AG::swift::metadata *this)
{
  if (dword_1EB3D3240 <= (result & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", (const char *)this, result & 0xFFFFFFFC);
  }
  uint64_t v2 = *(void *)(AG::data::_shared_table_bytes + (result & 0xFFFFFE00));
  if (!v2) {
    AG::precondition_failure((AG *)"no graph: %u", (const char *)this, result);
  }
  if ((result & 3) == 0)
  {
    uint64_t v3 = *(void *)(v2 + 40);
    if (*(AG::swift::metadata **)(*(void *)(*(void *)(v3 + 128)
                                             + (((unint64_t)*(unsigned int *)(AG::data::_shared_table_bytes
                                                                                   + result) >> 5) & 0x7FFFFF8))
                                 + 8) != this)
    {
      uint64_t v4 = result;
      uint64_t v5 = result;
      uint64_t v6 = AG::swift::metadata::name(this, 0);
      uint64_t v7 = AG::swift::metadata::name(*(AG::swift::metadata **)(*(void *)(*(void *)(v3 + 128)+ (((unint64_t)*(unsigned int *)(AG::data::_shared_table_bytes+ v4) >> 5) & 0x7FFFFF8))+ 8), 0);
      AG::precondition_failure((AG *)"type check failed: %u, expected %s, got %s", v8, v5, v6, v7);
    }
  }
  return result;
}

uint64_t AGGraphInvalidateAllValues(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 88)) {
    AG::precondition_failure((AG *)"invalidated graph", a2);
  }
  uint64_t v2 = *(void *)(a1 + 16);
  return AG::Graph::value_mark_all(v2, a2);
}

uint64_t AGGraphHasValue(char *a1, const char *a2)
{
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v2 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v2) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  unsigned int v3 = a1;
  uint64_t v4 = *(void *)(v2 + 40);
  return AG::Graph::value_exists(v4, v3);
}

unint64_t AGGraphRegisterDependency(unsigned int a1, const char *a2)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  uint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2);
  if ((v3 & 1) != 0 || (uint64_t v4 = (uint64_t *)(v3 & 0xFFFFFFFFFFFFFFFELL), (v3 & 0xFFFFFFFFFFFFFFFELL) == 0)) {
    AG::precondition_failure((AG *)"no attribute updating", a2);
  }
  char v5 = (char)a2;
  uint64_t v6 = *v4;
  uint64_t v7 = v4 + 4;
  uint64_t v9 = v4[12];
  uint64_t v8 = v4[13];
  if (v9) {
    uint64_t v7 = (uint64_t *)v9;
  }
  char v10 = (const char *)LODWORD(v7[v8 - 1]);
  return AG::Graph::input_value_add(v6, v10, a1, v5);
}

uint64_t AGGraphUpdateValue(char *a1, const char *a2)
{
  if ((a1 & 3) != 0) {
    AG::precondition_failure((AG *)"non-direct attribute id: %u", a2, a1);
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v2 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v2) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  unsigned int v3 = a1;
  uint64_t v4 = *(__n128 **)(v2 + 40);
  return AG::Graph::update_attribute(v4, v3, 0);
}

uint64_t AGGraphPrefetchValue(uint64_t a1, const char *a2)
{
  int v7 = a1;
  unsigned int v3 = a1;
  if ((a1 & 3) != 0) {
    unsigned int v3 = AG::AttributeID::resolve_slow((AG::AttributeID *)&v7, (const char *)2);
  }
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v4 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v4) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  char v5 = *(__n128 **)(v4 + 40);
  if (v5[27].n128_u64[0] == -1) {
    return AG::Graph::update_attribute(v5, v3, 6);
  }
  uint64_t result = AG::Graph::passed_deadline_slow((AG::Graph *)v5);
  if ((result & 1) == 0) {
    return AG::Graph::update_attribute(v5, v3, 6);
  }
  return result;
}

void AGGraphCancelUpdate(uint64_t a1, const char *a2)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  unsigned int v3 = (AG::Graph::UpdateStack *)(*(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2) & 0xFFFFFFFFFFFFFFFELL);
  if (!v3) {
    AG::precondition_failure((AG *)"no attribute updating", a2);
  }
  AG::Graph::UpdateStack::cancel(v3);
}

uint64_t AGGraphCancelUpdateIfNeeded(uint64_t a1, const char *a2)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  uint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2);
  uint64_t v4 = (AG::Graph **)(v3 & 0xFFFFFFFFFFFFFFFELL);
  if ((v3 & 0xFFFFFFFFFFFFFFFELL) == 0) {
    AG::precondition_failure((AG *)"no attribute updating", a2);
  }
  if (AG::Graph::UpdateStack::cancelled(v3 & 0xFFFFFFFFFFFFFFFELL)) {
    return 1;
  }
  if (*((void *)*v4 + 54) == -1) {
    return 0;
  }
  uint64_t result = AG::Graph::passed_deadline_slow(*v4);
  if (result)
  {
    AG::Graph::UpdateStack::cancel((AG::Graph::UpdateStack *)v4);
    return 1;
  }
  return result;
}

uint64_t AGGraphUpdateWasCancelled(uint64_t a1, const char *a2)
{
  uint64_t v2 = AG::Graph::_current_update_key;
  uint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v2);
  if ((v3 & 1) != 0 || (v3 & 0xFFFFFFFFFFFFFFFELL) == 0) {
    AG::precondition_failure((AG *)"no attribute updating", a2);
  }
  return AG::Graph::UpdateStack::cancelled(v3 & 0xFFFFFFFFFFFFFFFELL);
}

uint64_t AGGraphSearch(uint64_t a1, const char *a2, uint64_t (*a3)(uint64_t))
{
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v3 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v3) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  return AG::Graph::breadth_first_search(*(void *)(v3 + 40), a1, (char)a2, a3);
}

void AGGraphStartProfiling(uint64_t a1, const char *a2)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 88)) {
      AG::precondition_failure((AG *)"invalidated graph", a2);
    }
    uint64_t v2 = *(AG::Graph **)(a1 + 16);
    AG::Graph::start_profiling(v2, 1);
  }
  else
  {
    AG::Graph::all_start_profiling((AG::Graph *)1);
  }
}

void AGGraphStopProfiling(uint64_t a1, const char *a2)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 88)) {
      AG::precondition_failure((AG *)"invalidated graph", a2);
    }
    uint64_t v2 = *(_DWORD **)(a1 + 16);
    AG::Graph::stop_profiling(v2);
  }
  else
  {
    AG::Graph::all_stop_profiling(0);
  }
}

uint64_t AGGraphIsProfilingEnabled(uint64_t a1, const char *a2)
{
  if (dword_1EB3D3240 <= (a1 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, a1 & 0xFFFFFFFC);
  }
  uint64_t v2 = *(void *)(AG::data::_shared_table_bytes + (a1 & 0xFFFFFE00));
  if (!v2) {
    AG::precondition_failure((AG *)"no graph: %u", a2, a1);
  }
  return *(unsigned __int8 *)(*(void *)(v2 + 40) + 296);
}

void AGGraphResetProfile(uint64_t a1, const char *a2)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 88)) {
      AG::precondition_failure((AG *)"invalidated graph", a2);
    }
    uint64_t v2 = *(AG::Graph **)(a1 + 16);
    AG::Graph::reset_profile(v2);
  }
  else
  {
    AG::Graph::all_reset_profile(0);
  }
}

void AGGraphMarkProfile(uint64_t a1, AG::Graph *this)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 88)) {
      AG::precondition_failure((AG *)"invalidated graph", (const char *)this);
    }
    uint64_t v2 = *(AG::Graph **)(a1 + 16);
    uint64_t v3 = AG::Graph::intern_key(v2, (char *)this);
    AG::Graph::mark_profile(v2, (uint64_t)v3, 0);
  }
  else
  {
    AG::Graph::all_mark_profile(this, (const char *)this);
  }
}

uint64_t AGGraphBeginProfileEvent(uint64_t a1, char *a2)
{
  uint64_t v3 = a1;
  int v6 = a1;
  if ((a1 & 3) != 0) {
    LODWORD(a1) = AG::AttributeID::resolve_slow((AG::AttributeID *)&v6, (const char *)2);
  }
  if (dword_1EB3D3240 <= (v3 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, v3 & 0xFFFFFFFC);
  }
  uint64_t v4 = *(void *)(AG::data::_shared_table_bytes + (v3 & 0xFFFFFE00));
  if (!v4) {
    AG::precondition_failure((AG *)"no graph: %u", a2, v3);
  }
  return AG::Graph::begin_profile_event(*(AG::Graph **)(v4 + 40), a1, a2);
}

void *AGGraphEndProfileEvent(uint64_t a1, char *a2, uint64_t a3, int a4)
{
  uint64_t v7 = a1;
  int v10 = a1;
  if ((a1 & 3) != 0) {
    LODWORD(a1) = AG::AttributeID::resolve_slow((AG::AttributeID *)&v10, (const char *)2);
  }
  if (dword_1EB3D3240 <= (v7 & 0xFFFFFFFC)) {
    AG::precondition_failure((AG *)"invalid data offset: %u", a2, v7 & 0xFFFFFFFC);
  }
  uint64_t v8 = *(void *)(AG::data::_shared_table_bytes + (v7 & 0xFFFFFE00));
  if (!v8) {
    AG::precondition_failure((AG *)"no graph: %u", a2, v7);
  }
  return AG::Graph::end_profile_event(*(void *)(v8 + 40), a1, a2, a3, a4);
}

void AGGraphStartTracing(uint64_t a1, const char *a2)
{
}

void AGGraphStartTracing2(uint64_t a1, const char *a2, CFArrayRef theArray)
{
  char v3 = (char)a2;
  float v12 = 0;
  float v13 = 0;
  unint64_t v14 = 0;
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, i);
        CFTypeID v9 = CFGetTypeID(ValueAtIndex);
        if (v9 == CFStringGetTypeID())
        {
          uint64_t v10 = [ValueAtIndex UTF8String];
          unint64_t v11 = v13;
          a2 = v13 + 1;
          if (v14 < (unint64_t)(v13 + 1))
          {
            AG::vector<std::unique_ptr<char const,util::free_deleter>,0ul,unsigned long>::reserve_slow((uint64_t)&v12, (unint64_t)a2);
            unint64_t v11 = v13;
            a2 = v13 + 1;
          }
          *((void *)v12 + (void)v11) = v10;
          float v13 = a2;
        }
      }
    }
  }
  if (a1)
  {
    if (*(unsigned char *)(a1 + 88)) {
      AG::precondition_failure((AG *)"invalidated graph", a2);
    }
    AG::Graph::start_tracing(*(void *)(a1 + 16), v3);
  }
  else
  {
    AG::Graph::all_start_tracing(v3);
  }
  if (v12) {
    free(v12);
  }
}

void sub_1AF92EF54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  if (a10) {
    free(a10);
  }
  _Unwind_Resume(exception_object);
}

void AGGraphStopTracing(uint64_t a1, const char *a2)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 88)) {
      AG::precondition_failure((AG *)"invalidated graph", a2);
    }
    uint64_t v2 = *(_DWORD **)(a1 + 16);
    AG::Graph::stop_tracing(v2);
  }
  else
  {
    AG::Graph::all_stop_tracing(0);
  }
}

void AGGraphSyncTracing(uint64_t a1, const char *a2)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 88)) {
      AG::precondition_failure((AG *)"invalidated graph", a2);
    }
    uint64_t v2 = *(void *)(a1 + 16);
    AG::Graph::sync_tracing(v2);
  }
  else
  {
    AG::Graph::all_sync_tracing(0);
  }
}

CFStringRef AGGraphCopyTracePath(uint64_t a1, const char *a2)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 88)) {
      AG::precondition_failure((AG *)"invalidated graph", a2);
    }
    uint64_t v2 = *(AG::Graph **)(a1 + 16);
    return AG::Graph::copy_trace_path(v2);
  }
  else
  {
    return AG::Graph::all_copy_trace_path(0);
  }
}

id AGGraphDescription(uint64_t a1, void *a2)
{
  char v5 = a2;
  if (a1)
  {
    if (*(unsigned char *)(a1 + 88)) {
      AG::precondition_failure((AG *)"invalidated graph", v3);
    }
    uint64_t v6 = AG::Graph::description(*(AG::Graph **)(a1 + 16), v5, v4);
  }
  else
  {
    uint64_t v6 = AG::Graph::description(0, v5, v4);
  }
  uint64_t v7 = (void *)v6;

  return v7;
}

void sub_1AF92F108(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void AGGraphArchiveJSON(AG::Graph *a1)
{
}

void AGGraphArchiveJSON2(AG::Graph *a1, char *a2)
{
}

uint64_t AG::error_log(AG *this)
{
  unint64_t v1 = 0x1E9AF0000uLL;
  {
    unint64_t v1 = 0x1E9AF0000;
    if (v3)
    {
      AG::error_log(void)::log = (uint64_t)os_log_create("com.apple.attributegraph", "error");
      unint64_t v1 = 0x1E9AF0000;
    }
  }
  return *(void *)(v1 + 2392);
}

uint64_t AGGraphPrepareTrace(uint64_t a1, const char *a2, uint64_t a3)
{
  char v5 = (uint64_t *)AG::Graph::Context::from_cf(a1, a2);
  v7[0] = &unk_1F0813CB8;
  v7[1] = AGMakeUniqueID();
  v7[2] = a2;
  v7[3] = a3;
  return AG::Graph::prepare_trace(*v5, (uint64_t)v7);
}

BOOL AGGraphIsTracingActive(uint64_t a1, const char *a2)
{
  return *(_DWORD *)(*(void *)AG::Graph::Context::from_cf(a1, a2) + 232) != 0;
}

void AGGraphSetTrace(uint64_t a1, const char *a2)
{
  uint64_t v2 = (_DWORD **)AG::Graph::Context::from_cf(a1, a2);
  AG::Graph::remove_trace(*v2, 0);
  operator new();
}

void sub_1AF92F318(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10E1C404BDB33FELL);
  _Unwind_Resume(a1);
}

_DWORD *AGGraphResetTrace(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(_DWORD **)AG::Graph::Context::from_cf(a1, a2);
  return AG::Graph::remove_trace(v2, 0);
}

void AGGraphAddTrace(uint64_t a1, const char *a2)
{
}

void sub_1AF92F40C(_Unwind_Exception *a1)
{
  MEMORY[0x1B3E84B80](v1, 0x10E1C404BDB33FELL);
  _Unwind_Resume(a1);
}

_DWORD *AGGraphRemoveTrace(uint64_t a1, const char *a2)
{
  int v3 = *(_DWORD **)AG::Graph::Context::from_cf(a1, a2);
  return AG::Graph::remove_trace(v3, (uint64_t)a2);
}

uint64_t AGGraphAddTraceEvent(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = AG::Graph::Context::from_cf(a1, a2);
  uint64_t v8 = *(void *)result;
  int v9 = *(_DWORD *)(*(void *)result + 232);
  if (v9)
  {
    uint64_t v10 = result;
    unsigned int v11 = v9 - 1;
    do
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(*(void *)(v8 + 224) + 8 * v11);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(void *)v13 + 336))(v13, v10, a2, a3, a4);
      --v11;
    }
    while (v12);
  }
  return result;
}

uint64_t AGGraphGetTraceEventSubsystem(unsigned int a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&NamedEvents::lock);
  if (NamedEvents::names && *(_DWORD *)(NamedEvents::names + 8) > a1) {
    uint64_t v2 = *(void *)(*(void *)NamedEvents::names + 16 * a1);
  }
  else {
    uint64_t v2 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&NamedEvents::lock);
  return v2;
}

uint64_t AGGraphGetTraceEventName(unsigned int a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&NamedEvents::lock);
  if (NamedEvents::names && *(_DWORD *)(NamedEvents::names + 8) > a1) {
    uint64_t v2 = *(void *)(*(void *)NamedEvents::names + 16 * a1 + 8);
  }
  else {
    uint64_t v2 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&NamedEvents::lock);
  return v2;
}

uint64_t AGGraphAddNamedTraceEvent(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result = AG::Graph::Context::from_cf(a1, a2);
  uint64_t v12 = *(void *)result;
  int v13 = *(_DWORD *)(*(void *)result + 232);
  if (v13)
  {
    uint64_t v14 = result;
    unsigned int v15 = v13 - 1;
    do
    {
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)(*(void *)(v12 + 224) + 8 * v15);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 344))(v17, v14, a2, a3, a4, a5, a6);
      --v15;
    }
    while (v16);
  }
  return result;
}

uint64_t AGComparisonStateGetFieldRange(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t AGComparisonStateGetDestination(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t AGComparisonStateGetSource(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t AGComparisonStateGetFieldType(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void ExternalTrace::~ExternalTrace(ExternalTrace *this)
{
}

uint64_t ExternalTrace::begin_trace(ExternalTrace *this, AG::Graph *a2)
{
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 8);
  int v3 = (AG::Graph::Context *)AG::Graph::main_context(a2);
  uint64_t result = AG::Graph::Context::to_cf(v3);
  if (v7)
  {
    uint64_t v5 = result;
    uint64_t v6 = *((void *)this + 3);
    return v7(v6, v5);
  }
  return result;
}

uint64_t ExternalTrace::end_trace(ExternalTrace *this, AG::Graph *a2)
{
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 16);
  int v3 = (AG::Graph::Context *)AG::Graph::main_context(a2);
  uint64_t result = AG::Graph::Context::to_cf(v3);
  if (v7)
  {
    uint64_t v5 = result;
    uint64_t v6 = *((void *)this + 3);
    return v7(v6, v5);
  }
  return result;
}

uint64_t ExternalTrace::begin_update(ExternalTrace *this, AG::Subgraph *a2, uint64_t a3)
{
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*((void *)this + 2) + 24);
  uint64_t result = AG::Subgraph::to_cf(a2);
  if (v8)
  {
    uint64_t v6 = result;
    uint64_t v7 = *((void *)this + 3);
    return v8(v7, v6, a3);
  }
  return result;
}

uint64_t ExternalTrace::end_update(ExternalTrace *this, AG::Subgraph *a2)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 32);
  uint64_t result = AG::Subgraph::to_cf(a2);
  if (v6)
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)this + 3);
    return v6(v5, v4);
  }
  return result;
}

uint64_t ExternalTrace::begin_update(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3 = *(uint64_t (**)(void, uint64_t))(*(void *)(result + 16) + 40);
  if (v3) {
    return v3(*(void *)(result + 24), a3);
  }
  return result;
}

uint64_t ExternalTrace::end_update(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(uint64_t (**)(void, uint64_t, BOOL))(*(void *)(result + 16) + 48);
  if (v4) {
    return v4(*(void *)(result + 24), a3, a4 == 1);
  }
  return result;
}

uint64_t ExternalTrace::begin_update(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 56);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::end_update(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 64);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::begin_update(ExternalTrace *this, AG::Graph::Context *a2)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 72);
  uint64_t result = AG::Graph::Context::to_cf(a2);
  if (v6)
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)this + 3);
    return v6(v5, v4);
  }
  return result;
}

uint64_t ExternalTrace::end_update(ExternalTrace *this, AG::Graph::Context *a2)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 80);
  uint64_t result = AG::Graph::Context::to_cf(a2);
  if (v6)
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)this + 3);
    return v6(v5, v4);
  }
  return result;
}

uint64_t ExternalTrace::begin_invalidation(uint64_t a1, AG::Graph::Context *a2, uint64_t a3)
{
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 16) + 88);
  uint64_t result = AG::Graph::Context::to_cf(a2);
  if (v8)
  {
    uint64_t v6 = result;
    uint64_t v7 = *(void *)(a1 + 24);
    return v8(v7, v6, a3);
  }
  return result;
}

uint64_t ExternalTrace::end_invalidation(uint64_t a1, AG::Graph::Context *a2, uint64_t a3)
{
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 16) + 96);
  uint64_t result = AG::Graph::Context::to_cf(a2);
  if (v8)
  {
    uint64_t v6 = result;
    uint64_t v7 = *(void *)(a1 + 24);
    return v8(v7, v6, a3);
  }
  return result;
}

uint64_t ExternalTrace::begin_modify(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 104);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::end_modify(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 112);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::begin_event(uint64_t result, uint64_t a2, const char *a3)
{
  if (*(void *)(*(void *)(result + 16) + 120))
  {
    uint64_t v4 = *(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00));
    if (v4)
    {
      uint64_t v5 = result;
      uint64_t result = AG::Graph::key_name(*(AG::Graph **)(v4 + 40), a3);
      uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 16) + 120);
      if (v6)
      {
        uint64_t v7 = result;
        uint64_t v8 = *(void *)(v5 + 24);
        return v6(v8, a2, v7);
      }
    }
  }
  return result;
}

uint64_t ExternalTrace::end_event(uint64_t result, uint64_t a2, const char *a3)
{
  if (*(void *)(*(void *)(result + 16) + 128))
  {
    uint64_t v4 = *(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00));
    if (v4)
    {
      uint64_t v5 = result;
      uint64_t result = AG::Graph::key_name(*(AG::Graph **)(v4 + 40), a3);
      uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 16) + 128);
      if (v6)
      {
        uint64_t v7 = result;
        uint64_t v8 = *(void *)(v5 + 24);
        return v6(v8, a2, v7);
      }
    }
  }
  return result;
}

uint64_t ExternalTrace::created(ExternalTrace *this, AG::Graph::Context *a2)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 136);
  uint64_t result = AG::Graph::Context::to_cf(a2);
  if (v6)
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)this + 3);
    return v6(v5, v4);
  }
  return result;
}

uint64_t ExternalTrace::destroy(ExternalTrace *this, AG::Graph::Context *a2)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 144);
  uint64_t result = AG::Graph::Context::to_cf(a2);
  if (v6)
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)this + 3);
    return v6(v5, v4);
  }
  return result;
}

uint64_t ExternalTrace::needs_update(ExternalTrace *this, AG::Graph::Context *a2)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 152);
  uint64_t result = AG::Graph::Context::to_cf(a2);
  if (v6)
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)this + 3);
    return v6(v5, v4);
  }
  return result;
}

uint64_t ExternalTrace::created(ExternalTrace *this, AG::Subgraph *a2)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 160);
  uint64_t result = AG::Subgraph::to_cf(a2);
  if (v6)
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)this + 3);
    return v6(v5, v4);
  }
  return result;
}

uint64_t ExternalTrace::invalidate(ExternalTrace *this, AG::Subgraph *a2)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*((void *)this + 2) + 168);
  uint64_t result = AG::Subgraph::to_cf(a2);
  if (v6)
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)this + 3);
    return v6(v5, v4);
  }
  return result;
}

uint64_t ExternalTrace::add_child(ExternalTrace *this, AG::Subgraph *a2, AG::Subgraph *a3)
{
  int v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*((void *)this + 2) + 176);
  uint64_t v5 = AG::Subgraph::to_cf(a2);
  uint64_t result = AG::Subgraph::to_cf(a3);
  if (v9)
  {
    uint64_t v7 = result;
    uint64_t v8 = *((void *)this + 3);
    return v9(v8, v5, v7);
  }
  return result;
}

uint64_t ExternalTrace::remove_child(ExternalTrace *this, AG::Subgraph *a2, AG::Subgraph *a3)
{
  int v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*((void *)this + 2) + 184);
  uint64_t v5 = AG::Subgraph::to_cf(a2);
  uint64_t result = AG::Subgraph::to_cf(a3);
  if (v9)
  {
    uint64_t v7 = result;
    uint64_t v8 = *((void *)this + 3);
    return v9(v8, v5, v7);
  }
  return result;
}

uint64_t ExternalTrace::added(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 192);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::add_edge(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 200);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::remove_edge(uint64_t result, int a2)
{
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(result + 16) + 208);
  if (v2)
  {
    if (*(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00))) {
      return v2(*(void *)(result + 24));
    }
  }
  return result;
}

uint64_t ExternalTrace::set_edge_pending(uint64_t result, int a2)
{
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(result + 16) + 216);
  if (v2)
  {
    if (*(void *)(AG::data::_shared_table_bytes + (a2 & 0xFFFFFE00))) {
      return v2(*(void *)(result + 24));
    }
  }
  return result;
}

uint64_t ExternalTrace::set_dirty(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 224);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::set_pending(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 232);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::set_value(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 240);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::mark_value(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 248);
  if (v1) {
    return v1(*(void *)(result + 24));
  }
  return result;
}

uint64_t ExternalTrace::added(uint64_t result, int a2)
{
  uint64_t v2 = *(uint64_t (**)(void, void))(*(void *)(result + 16) + 256);
  if (v2) {
    return v2(*(void *)(result + 24), a2 | 1u);
  }
  return result;
}

uint64_t ExternalTrace::set_source(uint64_t result, int a2)
{
  uint64_t v2 = *(uint64_t (**)(void, void))(*(void *)(result + 16) + 264);
  if (v2) {
    return v2(*(void *)(result + 24), a2 | 1u);
  }
  return result;
}

uint64_t ExternalTrace::set_dependency(uint64_t result, int a2)
{
  uint64_t v2 = *(uint64_t (**)(void, void))(*(void *)(result + 16) + 272);
  if (v2) {
    return v2(*(void *)(result + 24), a2 | 1u);
  }
  return result;
}

uint64_t ExternalTrace::set_deadline(uint64_t this)
{
  uint64_t v1 = *(void **)(this + 16);
  if (*v1 >= 3uLL)
  {
    uint64_t v2 = (uint64_t (*)(void))v1[39];
    if (v2) {
      return v2(*(void *)(this + 24));
    }
  }
  return this;
}

uint64_t ExternalTrace::passed_deadline(uint64_t this)
{
  uint64_t v1 = *(void **)(this + 16);
  if (*v1 >= 3uLL)
  {
    uint64_t v2 = (uint64_t (*)(void))v1[40];
    if (v2) {
      return v2(*(void *)(this + 24));
    }
  }
  return this;
}

uint64_t ExternalTrace::mark_profile(uint64_t this, AG::Graph *a2, const char *a3)
{
  if (*(void *)(*(void *)(this + 16) + 280))
  {
    uint64_t v3 = this;
    this = AG::Graph::key_name(a2, a3);
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v3 + 16) + 280);
    if (v4)
    {
      uint64_t v5 = this;
      uint64_t v6 = *(void *)(v3 + 24);
      return v4(v6, v5);
    }
  }
  return this;
}

uint64_t ExternalTrace::custom_event(uint64_t result, AG::Graph::Context *this, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void **)(result + 16);
  if (*v5)
  {
    uint64_t v9 = result;
    uint64_t v12 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v5[36];
    uint64_t result = AG::Graph::Context::to_cf(this);
    if (v12)
    {
      uint64_t v10 = result;
      uint64_t v11 = *(void *)(v9 + 24);
      return v12(v11, v10, a3, a4, a5);
    }
  }
  return result;
}

uint64_t ExternalTrace::named_event(uint64_t this, AG::Graph::Context *a2, uint64_t a3, uint64_t a4, const unsigned int *a5, const __CFData *a6, uint64_t a7)
{
  uint64_t v7 = *(void **)(this + 16);
  if (*v7 >= 2uLL)
  {
    uint64_t v13 = this;
    uint64_t v16 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, const unsigned int *, const __CFData *, uint64_t))v7[37];
    this = AG::Graph::Context::to_cf(a2);
    if (v16)
    {
      uint64_t v14 = this;
      uint64_t v15 = *(void *)(v13 + 24);
      return v16(v15, v14, a3, a4, a5, a6, a7);
    }
  }
  return this;
}

uint64_t ExternalTrace::named_event_enabled(ExternalTrace *this)
{
  uint64_t v1 = (void *)*((void *)this + 2);
  if (*v1 < 2uLL) {
    return 0;
  }
  uint64_t v2 = (uint64_t (*)(void))v1[38];
  if (v2) {
    return v2(*((void *)this + 3));
  }
  else {
    return v1[37] != 0;
  }
}

uint64_t ExternalTrace::compare_failed(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void **)(result + 16);
  if (*v7 >= 4uLL)
  {
    v9[0] = a3;
    v9[1] = a4;
    void v9[2] = a5;
    v9[3] = a6;
    v9[4] = a7;
    uint64_t v8 = (uint64_t (*)(void, uint64_t, void *))v7[41];
    if (v8) {
      return v8(*(void *)(result + 24), a2, v9);
    }
  }
  return result;
}

CFURLRef AGDebugServerCopyURL()
{
  CFURLRef result = (CFURLRef)AG::DebugServer::_shared_server;
  if (AG::DebugServer::_shared_server) {
    return AG::DebugServer::copy_url((AG::DebugServer *)AG::DebugServer::_shared_server);
  }
  return result;
}

void AGDebugServerRun(int a1)
{
  if (AG::DebugServer::_shared_server) {
    AG::DebugServer::run((AG::DebugServer *)AG::DebugServer::_shared_server, a1);
  }
}

unint64_t AGWeakAttribute.init(_:)(uint64_t a1)
{
  if ((a1 & 0x100000000) != 0) {
    LODWORD(a1) = 2;
  }
  return AGCreateWeakAttribute(a1);
}

uint64_t AGWeakAttribute.unsafeCast<A>(to:)(uint64_t a1, uint64_t a2)
{
  return a2;
}

unint64_t AGWeakAttribute.attribute.getter(unint64_t a1)
{
  unsigned int Attribute = AGWeakAttributeGetAttribute(a1);
  if (Attribute == 2) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = Attribute;
  }
  return v2 | ((unint64_t)(Attribute == 2) << 32);
}

uint64_t sub_1AF9303E4@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = AGWeakAttributeGetAttribute(*a1);
  if (result == 2) {
    int v4 = 0;
  }
  else {
    int v4 = result;
  }
  *(_DWORD *)a2 = v4;
  *(unsigned char *)(a2 + 4) = result == 2;
  return result;
}

unint64_t sub_1AF93042C(uint64_t a1, unint64_t *a2)
{
  if (*(unsigned char *)(a1 + 4)) {
    uint64_t v3 = (unsigned int *)&AGAttributeNil;
  }
  else {
    uint64_t v3 = (unsigned int *)a1;
  }
  unint64_t result = AGCreateWeakAttribute(*v3);
  *a2 = result;
  return result;
}

unint64_t AGWeakAttribute.attribute.setter(uint64_t a1)
{
  if ((a1 & 0x100000000) != 0) {
    LODWORD(a1) = 2;
  }
  unint64_t result = AGCreateWeakAttribute(a1);
  *uint64_t v1 = result;
  return result;
}

uint64_t (*AGWeakAttribute.attribute.modify(uint64_t a1))()
{
  *(void *)a1 = v1;
  int Attribute = AGWeakAttributeGetAttribute(*v1);
  *(_DWORD *)(a1 + 16) = 2;
  if (Attribute == 2) {
    int v4 = 0;
  }
  else {
    int v4 = Attribute;
  }
  *(_DWORD *)(a1 + 8) = v4;
  *(unsigned char *)(a1 + 12) = Attribute == 2;
  return sub_1AF930508;
}

BOOL static AGWeakAttribute.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t AGWeakAttribute.hash(into:)()
{
  return sub_1AF93CEF8();
}

uint64_t AGWeakAttribute.description.getter(unint64_t a1)
{
  if (AGWeakAttributeGetAttribute(a1) == 2) {
    return 7104878;
  }
  else {
    return AGAttribute.description.getter();
  }
}

uint64_t AGWeakAttribute.hashValue.getter()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF9305F0()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF93064C()
{
  return sub_1AF93CEF8();
}

uint64_t sub_1AF930688()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF9306E0()
{
  return AGWeakAttribute.description.getter(*v0);
}

uint64_t WeakAttribute.base.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*WeakAttribute.base.modify())()
{
  return nullsub_1;
}

uint64_t WeakAttribute.init()()
{
  return 0;
}

unint64_t WeakAttribute.init(_:)(uint64_t a1)
{
  if ((a1 & 0x100000000) != 0) {
    LODWORD(a1) = 2;
  }
  return AGCreateWeakAttribute(a1);
}

unint64_t WeakAttribute.attribute.getter(unint64_t a1)
{
  unsigned int Attribute = AGWeakAttributeGetAttribute(a1);
  if (Attribute == 2) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = Attribute;
  }
  return v2 | ((unint64_t)(Attribute == 2) << 32);
}

uint64_t (*WeakAttribute.attribute.modify(uint64_t a1))()
{
  *(void *)a1 = v1;
  int Attribute = AGWeakAttributeGetAttribute(*v1);
  *(_DWORD *)(a1 + 16) = 2;
  if (Attribute == 2) {
    int v4 = 0;
  }
  else {
    int v4 = Attribute;
  }
  *(_DWORD *)(a1 + 8) = v4;
  *(unsigned char *)(a1 + 12) = Attribute == 2;
  return sub_1AF930508;
}

uint64_t WeakAttribute.value.getter@<X0>(unint64_t a1@<X0>, AG::swift::metadata *a2@<X1>, uint64_t a3@<X8>)
{
  WeakValue = AGGraphGetWeakValue(a1, 0, a2);
  if (WeakValue)
  {
    uint64_t v10 = *((void *)a2 - 1);
    (*(void (**)(uint64_t, char *, AG::swift::metadata *))(v10 + 16))(a3, WeakValue, a2);
    uint64_t v6 = v10;
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v6 = *((void *)a2 - 1);
    uint64_t v7 = 1;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, AG::swift::metadata *))(v6 + 56);
  return v8(a3, v7, 1, a2);
}

uint64_t WeakAttribute.changedValue(options:)@<X0>(char a1@<W0>, unint64_t a2@<X1>, AG::swift::metadata *a3@<X2>, uint64_t a4@<X8>)
{
  WeakValue = AGGraphGetWeakValue(a2, a1, a3);
  if (WeakValue)
  {
    uint64_t v8 = WeakValue;
    char v9 = v7;
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    uint64_t v11 = *(int *)(TupleTypeMetadata2 + 48);
    (*(void (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a3 - 1) + 16))(a4, v8, a3);
    *(unsigned char *)(a4 + v11) = v9 & 1;
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(TupleTypeMetadata2 - 8) + 56);
    uint64_t v13 = a4;
    uint64_t v14 = 0;
    uint64_t v15 = TupleTypeMetadata2;
  }
  else
  {
    uint64_t v16 = swift_getTupleTypeMetadata2();
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56);
    uint64_t v15 = v16;
    uint64_t v13 = a4;
    uint64_t v14 = 1;
  }
  return v12(v13, v14, 1, v15);
}

uint64_t WeakAttribute.wrappedValue.getter@<X0>(unint64_t a1@<X0>, AG::swift::metadata *a2@<X1>, uint64_t a3@<X8>)
{
  WeakValue = AGGraphGetWeakValue(a1, 0, a2);
  if (WeakValue)
  {
    uint64_t v10 = *((void *)a2 - 1);
    (*(void (**)(uint64_t, char *, AG::swift::metadata *))(v10 + 16))(a3, WeakValue, a2);
    uint64_t v6 = v10;
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v6 = *((void *)a2 - 1);
    uint64_t v7 = 1;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, AG::swift::metadata *))(v6 + 56);
  return v8(a3, v7, 1, a2);
}

unint64_t WeakAttribute.projectedValue.getter(unint64_t a1)
{
  unsigned int Attribute = AGWeakAttributeGetAttribute(a1);
  if (Attribute == 2) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = Attribute;
  }
  return v2 | ((unint64_t)(Attribute == 2) << 32);
}

unint64_t _s14AttributeGraph04WeakA0V9attributeAA0A0VyxGSgvs_0(uint64_t a1)
{
  if ((a1 & 0x100000000) != 0) {
    LODWORD(a1) = 2;
  }
  unint64_t result = AGCreateWeakAttribute(a1);
  *uint64_t v1 = result;
  return result;
}

uint64_t (*WeakAttribute.projectedValue.modify(uint64_t a1))()
{
  *(void *)a1 = v1;
  int Attribute = AGWeakAttributeGetAttribute(*v1);
  *(_DWORD *)(a1 + 16) = 2;
  if (Attribute == 2) {
    int v4 = 0;
  }
  else {
    int v4 = Attribute;
  }
  *(_DWORD *)(a1 + 8) = v4;
  *(unsigned char *)(a1 + 12) = Attribute == 2;
  return sub_1AF930508;
}

unint64_t sub_1AF930C20(uint64_t a1)
{
  uint64_t v1 = (unsigned int *)(a1 + 8);
  uint64_t v2 = *(unint64_t **)a1;
  if (*(unsigned char *)(a1 + 12)) {
    uint64_t v1 = (unsigned int *)(a1 + 16);
  }
  unint64_t result = AGCreateWeakAttribute(*v1);
  *uint64_t v2 = result;
  return result;
}

unint64_t WeakAttribute.subscript.getter(void *a1, unint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  uint64_t Attribute = AGWeakAttributeGetAttribute(a2);
  if (Attribute == 2)
  {
    unsigned int OffsetAttribute2 = 0;
  }
  else
  {
    uint64_t v6 = (const char *)sub_1AF93CE08();
    if (v7)
    {
      int v15 = Attribute;
      uint64_t v16 = a1;
      MEMORY[0x1F4188790](v6);
      v11[2] = *(void *)(v3 + *MEMORY[0x1E4FBC5F0] + 8);
      uint64_t v12 = type metadata accessor for Focus();
      uint64_t WitnessTable = swift_getWitnessTable();
      uint64_t v8 = type metadata accessor for Attribute();
      swift_retain();
      sub_1AF930F5C((uint64_t)&v15, (uint64_t)sub_1AF931890, (uint64_t)v11, v12, MEMORY[0x1E4FBC248], v8, MEMORY[0x1E4FBC278], v9);
      swift_release();
      unsigned int OffsetAttribute2 = v14;
    }
    else
    {
      unsigned int OffsetAttribute2 = AGGraphCreateOffsetAttribute2(Attribute, v6, *(void *)(*(void *)(*(void *)(*MEMORY[0x1E4FBC5F0] + v3 + 8) - 8) + 64));
    }
  }
  return OffsetAttribute2 | ((unint64_t)(Attribute == 2) << 32);
}

uint64_t WeakAttribute.hash(into:)()
{
  return sub_1AF93CEF8();
}

uint64_t WeakAttribute.hashValue.getter()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF930EF4()
{
  return WeakAttribute.hashValue.getter();
}

uint64_t sub_1AF930EFC()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF930F48()
{
  return WeakAttribute.description.getter(*v0);
}

BOOL sub_1AF930F50(uint64_t *a1, uint64_t *a2)
{
  return static WeakAttribute.== infix(_:_:)(*a1, *a2);
}

uint64_t sub_1AF930F5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a5 - 8);
  uint64_t v12 = MEMORY[0x1F4188790]();
  unsigned int v14 = (char *)&v17 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t result = v15(v12, v14);
  if (v8) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v11 + 32))(a8, v14, a5);
  }
  return result;
}

uint64_t sub_1AF931038()
{
  return MEMORY[0x1F40E6EA8](*v0);
}

uint64_t sub_1AF931040(uint64_t a1, uint64_t a2)
{
  int v6 = 0;
  char v7 = 1;
  uint64_t result = MEMORY[0x1B3E848E0](a1, &v6);
  int v4 = v6;
  char v5 = v7;
  if (v7) {
    int v4 = 0;
  }
  *(_DWORD *)a2 = v4;
  *(unsigned char *)(a2 + 4) = v5;
  return result;
}

uint64_t sub_1AF931094(uint64_t a1, uint64_t a2)
{
  char v3 = sub_1AF93CF38();
  *(_DWORD *)a2 = 0;
  *(unsigned char *)(a2 + 4) = 1;
  return v3 & 1;
}

uint64_t sub_1AF9310EC@<X0>(_DWORD *a1@<X8>)
{
  uint64_t result = sub_1AF93CF48();
  *a1 = result;
  return result;
}

BOOL sub_1AF931114(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

_DWORD *sub_1AF931128@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 & *result;
  return result;
}

_DWORD *sub_1AF93113C@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 ^ *result;
  return result;
}

_DWORD *sub_1AF931150(_DWORD *result)
{
  *v1 |= *result;
  return result;
}

_DWORD *sub_1AF931164(_DWORD *result)
{
  *v1 &= *result;
  return result;
}

_DWORD *sub_1AF931178(_DWORD *result)
{
  *v1 ^= *result;
  return result;
}

uint64_t sub_1AF93118C(uint64_t a1, uint64_t a2)
{
  return sub_1AF9312F8(a1, a2, MEMORY[0x1E4F27EB8]);
}

uint64_t sub_1AF9311A4(uint64_t a1, id *a2)
{
  uint64_t result = sub_1AF93CD78();
  *a2 = 0;
  return result;
}

uint64_t sub_1AF93121C(uint64_t a1, id *a2)
{
  char v3 = sub_1AF93CD88();
  *a2 = 0;
  return v3 & 1;
}

uint64_t sub_1AF93129C@<X0>(uint64_t *a1@<X8>)
{
  sub_1AF93CD98();
  uint64_t v2 = sub_1AF93CD68();
  uint64_t result = swift_bridgeObjectRelease();
  *a1 = v2;
  return result;
}

uint64_t sub_1AF9312E0(uint64_t a1, uint64_t a2)
{
  return sub_1AF9312F8(a1, a2, MEMORY[0x1E4FBB198]);
}

uint64_t sub_1AF9312F8(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t))
{
  uint64_t v4 = sub_1AF93CD98();
  uint64_t v5 = a3(v4);
  swift_bridgeObjectRelease();
  return v5;
}

uint64_t sub_1AF93133C()
{
  sub_1AF93CD98();
  sub_1AF93CDB8();
  return swift_bridgeObjectRelease();
}

uint64_t sub_1AF931390()
{
  sub_1AF93CD98();
  sub_1AF93CED8();
  sub_1AF93CDB8();
  uint64_t v0 = sub_1AF93CF08();
  swift_bridgeObjectRelease();
  return v0;
}

BOOL sub_1AF931404(void *a1, void *a2)
{
  return *a1 == *a2;
}

_DWORD *sub_1AF931418@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *result;
  *(unsigned char *)(a2 + 4) = 0;
  return result;
}

void sub_1AF931428(_DWORD *a1@<X8>)
{
  *a1 = *v1;
}

uint64_t sub_1AF931434()
{
  return sub_1AF93CE58();
}

void sub_1AF9314F0(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

_DWORD *sub_1AF9314F8@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 | *result;
  return result;
}

BOOL sub_1AF93150C(_DWORD *a1, int *a2)
{
  int v3 = *a2;
  int v4 = *v2 & *a2;
  if (v4 != *a2) {
    *v2 |= v3;
  }
  *a1 = v3;
  return v4 != v3;
}

_DWORD *sub_1AF93153C@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *v2 & *result;
  if (v3) {
    *v2 &= ~*result;
  }
  *(_DWORD *)a2 = v3;
  *(unsigned char *)(a2 + 4) = v3 == 0;
  return result;
}

int *sub_1AF931568@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  *v2 |= *result;
  int v5 = v4 & v3;
  *(_DWORD *)a2 = v5;
  *(unsigned char *)(a2 + 4) = v5 == 0;
  return result;
}

_DWORD *sub_1AF93158C@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 & ~*result;
  return result;
}

BOOL sub_1AF9315A0(_DWORD *a1)
{
  return (*v1 & ~*a1) == 0;
}

BOOL sub_1AF9315B4(_DWORD *a1)
{
  return (*v1 & *a1) == 0;
}

BOOL sub_1AF9315C8(_DWORD *a1)
{
  return (*a1 & ~*v1) == 0;
}

BOOL sub_1AF9315DC()
{
  return *v0 == 0;
}

uint64_t sub_1AF9315EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1F4184B08](a1, a4, a2, a5, a3);
}

_DWORD *sub_1AF931604(_DWORD *result)
{
  *v1 &= ~*result;
  return result;
}

uint64_t sub_1AF931618()
{
  return sub_1AF93CD18();
}

uint64_t sub_1AF931664()
{
  return sub_1AF93CD08();
}

uint64_t sub_1AF9316BC()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF931724()
{
  uint64_t v0 = sub_1AF93CD98();
  uint64_t v2 = v1;
  if (v0 == sub_1AF93CD98() && v2 == v3) {
    char v5 = 1;
  }
  else {
    char v5 = sub_1AF93CE88();
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v5 & 1;
}

void *sub_1AF9317B0@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void sub_1AF9317BC(void *a1@<X8>)
{
  *a1 = *v1;
}

uint64_t sub_1AF9317C8()
{
  return sub_1AF93CE58();
}

uint64_t sub_1AF931890@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  return sub_1AF932524(a1, *(void *)(v2 + 16), *(uint64_t **)(v2 + 24), *(void *)(v2 + 32), a2);
}

uint64_t sub_1AF9318B4()
{
  return sub_1AF913FC8(&qword_1E9AF0570, type metadata accessor for AnyWeakAttribute);
}

uint64_t sub_1AF9318FC()
{
  return swift_getWitnessTable();
}

uint64_t sub_1AF931918()
{
  return 8;
}

void *sub_1AF931924(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1AF931930()
{
  return 8;
}

uint64_t sub_1AF93193C(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_1AF93195C(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)uint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 8) = v3;
  return result;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t sub_1AF931990(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_1AF9319B0(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)__n128 result = (a2 - 1);
    *(void *)(result + 8) = 0;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 16) = v3;
  return result;
}

void type metadata accessor for Nodes(uint64_t a1)
{
}

void *__swift_memcpy8_8(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void type metadata accessor for TreeValue(uint64_t a1)
{
}

void type metadata accessor for Values(uint64_t a1)
{
}

void type metadata accessor for TreeElement(uint64_t a1)
{
}

__n128 __swift_memcpy24_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

uint64_t sub_1AF931A50(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 24)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_1AF931A70(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 24) = v3;
  return result;
}

void type metadata accessor for Children(uint64_t a1)
{
}

__n128 __swift_memcpy20_1(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u32[0] = a2[1].n128_u32[0];
  *a1 = result;
  return result;
}

uint64_t sub_1AF931AC4(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 20)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_1AF931AE4(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_DWORD *)(result + 16) = 0;
    *(void *)__n128 result = (a2 - 1);
    *(void *)(result + 8) = 0;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 2dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v3;
  return result;
}

void type metadata accessor for Signature(uint64_t a1)
{
}

uint64_t sub_1AF931B24(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 != 1 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)a1) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t sub_1AF931B68(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)__n128 result = a2 - 2;
    if (a3 >= 2) {
      *(unsigned char *)(result + 8) = 1;
    }
  }
  else
  {
    if (a3 >= 2) {
      *(unsigned char *)(result + 8) = 0;
    }
    if (a2) {
      *(void *)__n128 result = 0;
    }
  }
  return result;
}

void type metadata accessor for Metadata(uint64_t a1)
{
}

void type metadata accessor for Graph(uint64_t a1)
{
}

void type metadata accessor for AGDescriptionOption(uint64_t a1)
{
}

uint64_t sub_1AF931BE0@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  int v3 = sub_1AF93207C(a1);
  uint64_t result = swift_bridgeObjectRelease();
  *a2 = v3;
  return result;
}

uint64_t sub_1AF931C20@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = sub_1AF93CD68();
  uint64_t result = swift_bridgeObjectRelease();
  *a1 = v2;
  return result;
}

uint64_t sub_1AF931C68@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = sub_1AF93CD98();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t sub_1AF931C94()
{
  sub_1AF913FC8((unint64_t *)&qword_1E9AF0628, type metadata accessor for AGDescriptionOption);
  sub_1AF913FC8(&qword_1E9AF0630, type metadata accessor for AGDescriptionOption);
  return sub_1AF93CE58();
}

uint64_t sub_1AF931D50()
{
  return sub_1AF913FC8(&qword_1E9AF05B8, type metadata accessor for AGDescriptionOption);
}

uint64_t sub_1AF931D98()
{
  return sub_1AF913FC8(&qword_1E9AF05C0, type metadata accessor for AGDescriptionOption);
}

uint64_t sub_1AF931DE0()
{
  return sub_1AF913FC8(&qword_1E9AF05C8, type metadata accessor for AnyAttribute);
}

uint64_t sub_1AF931E28()
{
  return sub_1AF913FC8(&qword_1E9AF05D0, type metadata accessor for AnyAttribute);
}

uint64_t sub_1AF931E70()
{
  return sub_1AF913FC8(&qword_1E9AF05D8, type metadata accessor for Graph);
}

uint64_t sub_1AF931EB8()
{
  return sub_1AF913FC8(&qword_1E9AF05E0, type metadata accessor for Graph);
}

uint64_t sub_1AF931F00()
{
  return sub_1AF913FC8(&qword_1E9AF05E8, type metadata accessor for Metadata);
}

uint64_t sub_1AF931F48()
{
  return sub_1AF913FC8(&qword_1E9AF05F0, type metadata accessor for Metadata);
}

uint64_t sub_1AF931F90()
{
  return sub_1AF913FC8(&qword_1E9AF05F8, type metadata accessor for AGDescriptionOption);
}

unint64_t sub_1AF931FD8()
{
  unint64_t result = qword_1E9AF0610;
  if (!qword_1E9AF0610)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1EB3D2E30);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9AF0610);
  }
  return result;
}

uint64_t __swift_instantiateConcreteTypeFromMangledNameAbstract(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContextInMetadataState2();
    *a1 = result;
  }
  return result;
}

uint64_t sub_1AF93207C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = result;
  LODWORD(result) = 0;
  uint64_t v3 = (int *)(v2 + 32);
  do
  {
    int v5 = *v3++;
    int v4 = v5;
    if ((v5 & ~result) == 0) {
      int v4 = 0;
    }
    uint64_t result = v4 | result;
    --v1;
  }
  while (v1);
  return result;
}

void type metadata accessor for _Metadata(uint64_t a1)
{
}

__n128 __swift_memcpy48_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v3;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t sub_1AF9320DC(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7FFFFFFF && *(unsigned char *)(a1 + 48)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  return (v4 + 1);
}

uint64_t sub_1AF932138(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(void *)(result + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = 0;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 48) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 48) = 0;
    }
    if (a2) {
      *(void *)(result + 8) = a2;
    }
  }
  return result;
}

void type metadata accessor for _AttributeVTable(uint64_t a1)
{
}

uint64_t sub_1AF9321AC(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 != 1 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)a1) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t sub_1AF9321F0(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)__n128 result = a2 - 2;
    *(void *)(result + 8) = 0;
    if (a3 >= 2) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if (a3 >= 2) {
      *(unsigned char *)(result + 16) = 0;
    }
    if (a2) {
      *(void *)__n128 result = 0;
    }
  }
  return result;
}

void type metadata accessor for _AGClosureStorage(uint64_t a1)
{
}

uint64_t sub_1AF932240(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a1 = *a2;
  uint64_t v3 = v2 + 16;
  swift_retain();
  return v3;
}

__n128 __swift_memcpy56_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t sub_1AF932290(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 != 1 && *(unsigned char *)(a1 + 56)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)a1) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t sub_1AF9322D4(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(_OWORD *)(result + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 - 2;
    if (a3 >= 2) {
      *(unsigned char *)(result + 56) = 1;
    }
  }
  else
  {
    if (a3 >= 2) {
      *(unsigned char *)(result + 56) = 0;
    }
    if (a2) {
      *(void *)__n128 result = 0;
    }
  }
  return result;
}

void type metadata accessor for _AttributeType(uint64_t a1)
{
}

uint64_t sub_1AF932370@<X0>(uint64_t a1@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  int v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 56);
  return v3(a1, 1, 1, AssociatedTypeWitness);
}

uint64_t static Rule.initialValue.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  int v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 56);
  return v3(a1, 1, 1, AssociatedTypeWitness);
}

uint64_t Attribute.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v9[2] = a2;
  v9[3] = a3;
  v9[4] = a4;
  uint64_t v6 = type metadata accessor for Attribute();
  sub_1AF930F5C(a1, (uint64_t)sub_1AF9325B8, (uint64_t)v9, a3, MEMORY[0x1E4FBC248], v6, MEMORY[0x1E4FBC278], v7);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a1, a3);
  return v10;
}

{
  uint64_t v6;
  uint64_t v7;
  void v9[7];
  unsigned int v10;

  void v9[2] = a2;
  v9[3] = a3;
  v9[4] = a4;
  uint64_t v6 = type metadata accessor for Attribute();
  sub_1AF930F5C(a1, (uint64_t)sub_1AF933AF0, (uint64_t)v9, a3, MEMORY[0x1E4FBC248], v6, MEMORY[0x1E4FBC278], v7);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a1, a3);
  return v10;
}

uint64_t sub_1AF932524@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, _DWORD *a5@<X8>)
{
  v11[2] = a2;
  void v11[3] = a3;
  v11[4] = a4;
  uint64_t v9 = sub_1AF914170();
  uint64_t result = Attribute.init<A>(body:value:flags:update:)(a1, 0, v9, (uint64_t)sub_1AF933880, (uint64_t)v11, a2, a3);
  *a5 = result;
  return result;
}

uint64_t sub_1AF9325B8@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v5 = v2[2];
  uint64_t v6 = (uint64_t *)v2[3];
  uint64_t v7 = v2[4];
  void v10[2] = v5;
  v10[3] = v6;
  v10[4] = v7;
  uint64_t v8 = sub_1AF914170();
  uint64_t result = Attribute.init<A>(body:value:flags:update:)(a1, 0, v8, (uint64_t)sub_1AF933880, (uint64_t)v10, v5, v6);
  *a2 = result;
  return result;
}

uint64_t static Rule._update(_:attribute:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = &v16[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = &v16[-v12];
  (*(void (**)(unsigned char *, uint64_t, uint64_t))(v7 + 16))(v9, a1, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  (*(void (**)(unsigned char *, uint64_t))(v7 + 8))(v9, a3);
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  sub_1AF932ECC((uint64_t)v13, (uint64_t)sub_1AF932FA8, (uint64_t)v17, AssociatedTypeWitness, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v14);
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

uint64_t Attribute.init<A>(_:initialValue:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v12[2] = a3;
  v12[3] = a4;
  v12[4] = a5;
  v12[5] = a2;
  uint64_t v9 = type metadata accessor for Attribute();
  sub_1AF930F5C(a1, (uint64_t)sub_1AF932FC0, (uint64_t)v12, a4, MEMORY[0x1E4FBC248], v9, MEMORY[0x1E4FBC278], v10);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a4 - 8) + 8))(a1, a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a2, a3);
  return v13;
}

{
  uint64_t v9;
  uint64_t v10;
  void v12[7];
  unsigned int v13;

  v12[2] = a3;
  v12[3] = a4;
  v12[4] = a5;
  v12[5] = a2;
  uint64_t v9 = type metadata accessor for Attribute();
  sub_1AF930F5C(a1, (uint64_t)sub_1AF933D48, (uint64_t)v12, a4, MEMORY[0x1E4FBC248], v9, MEMORY[0x1E4FBC278], v10);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a4 - 8) + 8))(a1, a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a2, a3);
  return v13;
}

uint64_t sub_1AF932964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v10[2] = a3;
  v10[3] = a4;
  v10[4] = a5;
  v10[5] = a1;
  uint64_t v7 = type metadata accessor for Attribute();
  return sub_1AF930F5C(a2, (uint64_t)sub_1AF933748, (uint64_t)v10, a3, MEMORY[0x1E4FBC248], v7, MEMORY[0x1E4FBC278], v8);
}

uint64_t sub_1AF9329F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *(void *)(a5 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = &v21[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1F4188790](v12);
  uint64_t v18 = &v21[-((v17 + 15) & 0xFFFFFFFFFFFFFFF0)];
  (*(void (**)(unsigned char *))(v11 + 16))(v14);
  (*(void (**)(uint64_t, uint64_t))(a6 + 32))(a5, a6);
  (*(void (**)(unsigned char *, uint64_t))(v11 + 8))(v14, a5);
  uint64_t v23 = a5;
  uint64_t v24 = a6;
  sub_1AF932ECC((uint64_t)v18, a7, (uint64_t)v22, a4, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v19);
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v16 + 8))(v18, a4);
}

uint64_t Rule.attribute.getter()
{
  uint64_t result = AGGraphGetCurrentAttribute();
  if (result == 2) {
    __break(1u);
  }
  return result;
}

uint64_t Rule.context.getter()
{
  uint64_t result = AGGraphGetCurrentAttribute();
  if (result == 2) {
    __break(1u);
  }
  return result;
}

uint64_t static Rule._updateDefault(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v6 = sub_1AF93CDE8();
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v10 = (char *)v17 - v9;
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)v17 - v12;
  (*(void (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v11 + 48))(v10, 1, AssociatedTypeWitness) == 1) {
    return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v10, v6);
  }
  uint64_t v15 = (*(uint64_t (**)(char *, char *, uint64_t))(v11 + 32))(v13, v10, AssociatedTypeWitness);
  MEMORY[0x1F4188790](v15);
  v17[-2] = a2;
  v17[-1] = a3;
  sub_1AF932ECC((uint64_t)v13, (uint64_t)sub_1AF932FA8, (uint64_t)&v17[-4], AssociatedTypeWitness, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v16);
  return (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

uint64_t sub_1AF932ECC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a5 - 8);
  uint64_t v12 = MEMORY[0x1F4188790]();
  uint64_t v14 = (char *)&v17 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t result = v15(v12, v14);
  if (v8) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v11 + 32))(a8, v14, a5);
  }
  return result;
}

uint64_t sub_1AF932FA8(unsigned __int8 *a1)
{
  return sub_1AF9338EC(a1);
}

uint64_t sub_1AF932FC0(uint64_t a1)
{
  return sub_1AF932964(a1, v1[5], v1[2], v1[3], v1[4]);
}

uint64_t Rule<>.cachedValue(options:owner:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v10[2] = a3;
  v10[3] = a4;
  v10[4] = a5;
  int v11 = a1;
  int v12 = a2;
  char v13 = BYTE4(a2) & 1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  return sub_1AF930F5C(v5, (uint64_t)sub_1AF933638, (uint64_t)v10, a3, MEMORY[0x1E4FBC248], AssociatedTypeWitness, MEMORY[0x1E4FBC278], v8);
}

uint64_t sub_1AF93308C@<X0>(const void *a1@<X0>, char a2@<W1>, unint64_t a3@<X2>, uint64_t *a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X8>)
{
  uint64_t v14 = (char *)sub_1AF93CD38();
  uint64_t v19 = a4;
  uint64_t v20 = a5;
  uint64_t v21 = a6;
  uint64_t v15 = static Rule<>._cachedValue(options:owner:hashValue:bodyPtr:update:)(a2, a3 | ((HIDWORD(a3) & 1) << 32), v14, a1, (uint64_t)sub_1AF9336D0, (uint64_t)v18, a4, a5, a6);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16))(a7, v15, AssociatedTypeWitness);
}

uint64_t sub_1AF9331A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = &v17[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v14 = &v17[-v13];
  (*(void (**)(unsigned char *, uint64_t, uint64_t))(v8 + 16))(v10, a1, a4);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a4, a5);
  (*(void (**)(unsigned char *, uint64_t))(v8 + 8))(v10, a4);
  uint64_t v19 = a4;
  uint64_t v20 = a5;
  sub_1AF932ECC((uint64_t)v14, (uint64_t)sub_1AF932FA8, (uint64_t)v18, AssociatedTypeWitness, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v15);
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
}

uint64_t Rule<>.cachedValueIfExists(options:owner:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v10[2] = a3;
  v10[3] = a4;
  v10[4] = a5;
  int v11 = a1;
  int v12 = a2;
  char v13 = BYTE4(a2) & 1;
  swift_getAssociatedTypeWitness();
  uint64_t v7 = sub_1AF93CDE8();
  return sub_1AF930F5C(v5, (uint64_t)sub_1AF93367C, (uint64_t)v10, a3, MEMORY[0x1E4FBC248], v7, MEMORY[0x1E4FBC278], v8);
}

uint64_t sub_1AF93347C@<X0>(const void *a1@<X0>, char a2@<W2>, uint64_t a3@<X3>, uint64_t *a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v10 = (char *)sub_1AF93CD38();
  if ((a3 & 0x100000000) != 0) {
    LODWORD(a3) = 2;
  }
  uint64_t AssociatedTypeWitness = (AG::swift::metadata *)swift_getAssociatedTypeWitness();
  CachedAttributeIfExists = AGGraphReadCachedAttributeIfExists(v10, a4, a1, AssociatedTypeWitness, a2, a3, 0, v12);
  uint64_t v14 = *((void *)AssociatedTypeWitness - 1);
  if (CachedAttributeIfExists)
  {
    (*(void (**)(uint64_t, char *, AG::swift::metadata *))(v14 + 16))(a5, CachedAttributeIfExists, AssociatedTypeWitness);
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v15 = 1;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, AG::swift::metadata *))(v14 + 56))(a5, v15, 1, AssociatedTypeWitness);
}

uint64_t sub_1AF933600@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 24) - 8) + 56))(a2, 1, 1);
}

uint64_t sub_1AF933638@<X0>(const void *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1AF93308C(a1, *(_DWORD *)(v2 + 40), *(unsigned int *)(v2 + 44) | ((unint64_t)*(unsigned __int8 *)(v2 + 48) << 32), *(uint64_t **)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32), a2);
}

uint64_t sub_1AF93367C@<X0>(const void *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1AF93347C(a1, *(_DWORD *)(v2 + 48), *(unsigned int *)(v2 + 52) | ((unint64_t)*(unsigned __int8 *)(v2 + 56) << 32), *(uint64_t **)(v2 + 16), a2);
}

uint64_t dispatch thunk of static Rule.initialValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t (*sub_1AF9336D0())(uint64_t a1, uint64_t a2)
{
  uint64_t v1 = *(void *)(v0 + 32);
  uint64_t v2 = swift_allocObject();
  long long v3 = *(_OWORD *)(v0 + 16);
  *(_OWORD *)(v2 + 16) = v3;
  *(void *)(v2 + 32) = v1;
  *(void *)(v2 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v3;
  return sub_1AF93373C;
}

uint64_t sub_1AF93372C()
{
  return MEMORY[0x1F4186498](v0, 48, 7);
}

uint64_t sub_1AF93373C(uint64_t a1, uint64_t a2)
{
  return sub_1AF9331A4(a1, a2, v2[5], v2[2], v2[3]);
}

uint64_t sub_1AF933748@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v5 = v2[2];
  uint64_t v6 = (uint64_t *)v2[3];
  uint64_t v8 = v2[4];
  uint64_t v7 = (void *)v2[5];
  v11[2] = v5;
  void v11[3] = v6;
  v11[4] = v8;
  uint64_t v9 = sub_1AF914170();
  uint64_t result = Attribute.init<A>(body:value:flags:update:)(v7, a1, v9, (uint64_t)sub_1AF9337E0, (uint64_t)v11, v5, v6);
  *a2 = result;
  return result;
}

uint64_t (*sub_1AF9337E0())(uint64_t a1, uint64_t a2)
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = swift_allocObject();
  *(void *)(v2 + 16) = v1;
  long long v3 = *(_OWORD *)(v0 + 24);
  *(_OWORD *)(v2 + 24) = v3;
  *(void *)(v2 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v3;
  return sub_1AF93384C;
}

uint64_t sub_1AF93383C()
{
  return MEMORY[0x1F4186498](v0, 48, 7);
}

uint64_t sub_1AF93384C(uint64_t a1, uint64_t a2)
{
  return sub_1AF9329F4(a1, a2, v2[5], v2[2], v2[3], v2[4], (uint64_t)sub_1AF932FA8);
}

uint64_t (*sub_1AF933880())(uint64_t a1, uint64_t a2)
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = swift_allocObject();
  *(void *)(v2 + 16) = v1;
  long long v3 = *(_OWORD *)(v0 + 24);
  *(_OWORD *)(v2 + 24) = v3;
  *(void *)(v2 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v3;
  return sub_1AF93384C;
}

uint64_t sub_1AF9338DC()
{
  return MEMORY[0x1F4186498](v0, 48, 7);
}

uint64_t sub_1AF9338EC(unsigned __int8 *a1)
{
  uint64_t AssociatedTypeWitness = (AG::LayoutDescriptor *)swift_getAssociatedTypeWitness();
  return AGGraphSetOutputValue(a1, AssociatedTypeWitness);
}

uint64_t sub_1AF93393C@<X0>(uint64_t a1@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  long long v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 56);
  return v3(a1, 1, 1, AssociatedTypeWitness);
}

uint64_t static StatefulRule.initialValue.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  long long v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 56);
  return v3(a1, 1, 1, AssociatedTypeWitness);
}

uint64_t sub_1AF933AF0@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v5 = v2[2];
  uint64_t v6 = (uint64_t *)v2[3];
  uint64_t v7 = v2[4];
  void v10[2] = v5;
  v10[3] = v6;
  v10[4] = v7;
  uint64_t v8 = sub_1AF914170();
  uint64_t result = Attribute.init<A>(body:value:flags:update:)(a1, 0, v8, (uint64_t)sub_1AF93491C, (uint64_t)v10, v5, v6);
  *a2 = result;
  return result;
}

uint64_t static StatefulRule._update(_:attribute:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
}

uint64_t sub_1AF933CB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v10[2] = a3;
  v10[3] = a4;
  v10[4] = a5;
  void v10[5] = a1;
  uint64_t v7 = type metadata accessor for Attribute();
  return sub_1AF930F5C(a2, (uint64_t)sub_1AF934814, (uint64_t)v10, a3, MEMORY[0x1E4FBC248], v7, MEMORY[0x1E4FBC278], v8);
}

uint64_t sub_1AF933D48(uint64_t a1)
{
  return sub_1AF933CB8(a1, v1[5], v1[2], v1[3], v1[4]);
}

uint64_t StatefulRule.attribute.getter()
{
  uint64_t result = AGGraphGetCurrentAttribute();
  if (result == 2) {
    __break(1u);
  }
  return result;
}

BOOL StatefulRule.hasValue.getter()
{
  uint64_t AssociatedTypeWitness = (AG::swift::metadata *)swift_getAssociatedTypeWitness();
  return AGGraphGetOutputValue(AssociatedTypeWitness, v1) != 0;
}

uint64_t StatefulRule.value.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t AssociatedTypeWitness = (AG::swift::metadata *)swift_getAssociatedTypeWitness();
  uint64_t result = AGGraphGetOutputValue(AssociatedTypeWitness, v3);
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, AG::swift::metadata *))(*((void *)AssociatedTypeWitness - 1)
                                                                           + 16);
    return v5(a1, result, AssociatedTypeWitness);
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t sub_1AF933E5C@<X0>(uint64_t a1@<X8>)
{
  uint64_t AssociatedTypeWitness = (AG::swift::metadata *)swift_getAssociatedTypeWitness();
  uint64_t result = AGGraphGetOutputValue(AssociatedTypeWitness, v3);
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, AG::swift::metadata *))(*((void *)AssociatedTypeWitness - 1)
                                                                           + 16);
    return v5(a1, result, AssociatedTypeWitness);
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t StatefulRule.value.unsafeAddressor()
{
  uint64_t AssociatedTypeWitness = (AG::swift::metadata *)swift_getAssociatedTypeWitness();
  uint64_t result = AGGraphGetOutputValue(AssociatedTypeWitness, v1);
  if (!result) {
    __break(1u);
  }
  return result;
}

uint64_t sub_1AF933F24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a4 + a3 - 16);
  uint64_t v6 = *(void *)(a4 + a3 - 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  double v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  int v11 = &v14[-v10];
  (*(void (**)(unsigned char *, uint64_t, uint64_t, double))(v8 + 16))(&v14[-v10], a1, AssociatedTypeWitness, v9);
  uint64_t v16 = v5;
  uint64_t v17 = v6;
  sub_1AF930F5C((uint64_t)v11, (uint64_t)sub_1AF934724, (uint64_t)v15, AssociatedTypeWitness, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v12);
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v8 + 8))(v11, AssociatedTypeWitness);
}

uint64_t StatefulRule.value.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[2] = a2;
  v7[3] = a3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  sub_1AF930F5C(a1, (uint64_t)sub_1AF934724, (uint64_t)v7, AssociatedTypeWitness, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v5);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8))(a1, AssociatedTypeWitness);
}

void (*StatefulRule.value.modify(void *a1, uint64_t a2, uint64_t a3))(void **a1, char a2)
{
  uint64_t v6 = malloc(0x40uLL);
  *a1 = v6;
  *uint64_t v6 = a2;
  v6[1] = a3;
  uint64_t AssociatedTypeWitness = (AG::swift::metadata *)swift_getAssociatedTypeWitness();
  v6[2] = AssociatedTypeWitness;
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = v8;
  v6[3] = v8;
  size_t v10 = *(void *)(v8 + 64);
  v6[4] = malloc(v10);
  int v11 = malloc(v10);
  v6[5] = v11;
  uint64_t OutputValue = AGGraphGetOutputValue(AssociatedTypeWitness, v12);
  if (!OutputValue) {
    __break(1u);
  }
  uint64_t v14 = *(void (**)(void *, uint64_t, AG::swift::metadata *))(v9 + 16);
  v6[6] = v14;
  v6[7] = (v9 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  v14(v11, OutputValue, AssociatedTypeWitness);
  return sub_1AF9342C4;
}

void sub_1AF9342C4(void **a1, char a2)
{
  uint64_t v2 = *a1;
  if (a2)
  {
    long long v3 = (uint64_t (*)(void *, void *, uint64_t))v2[6];
    uint64_t v5 = (void *)v2[4];
    long long v4 = (void *)v2[5];
    uint64_t v6 = v2[2];
    uint64_t v7 = v2[3];
    long long v17 = *(_OWORD *)v2;
    uint64_t v8 = v3(v5, v4, v6);
    MEMORY[0x1F4188790](v8);
    long long v16 = v17;
    sub_1AF930F5C((uint64_t)v5, (uint64_t)sub_1AF934724, (uint64_t)v15, v6, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v9);
    size_t v10 = *(void (**)(void *, uint64_t))(v7 + 8);
    v10(v5, v6);
    v10(v4, v6);
  }
  else
  {
    uint64_t v5 = (void *)v2[4];
    long long v4 = (void *)v2[5];
    uint64_t v11 = v2[2];
    uint64_t v12 = v2[3];
    *(double *)&long long v13 = MEMORY[0x1F4188790](a1);
    long long v16 = v13;
    sub_1AF930F5C((uint64_t)v4, (uint64_t)sub_1AF934724, (uint64_t)v15, v11, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v14);
    (*(void (**)(void *, uint64_t))(v12 + 8))(v4, v11);
  }
  free(v4);
  free(v5);
  free(v2);
}

uint64_t StatefulRule.context.getter()
{
  uint64_t result = AGGraphGetCurrentAttribute();
  if (result == 2) {
    __break(1u);
  }
  return result;
}

uint64_t static StatefulRule._updateDefault(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v6 = sub_1AF93CDE8();
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v6);
  uint64_t v9 = (char *)v18 - v8;
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  double v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)v18 - v13;
  (*(void (**)(uint64_t, uint64_t, double))(a3 + 24))(a2, a3, v12);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v10 + 48))(v9, 1, AssociatedTypeWitness) == 1) {
    return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, v6);
  }
  uint64_t v16 = (*(uint64_t (**)(char *, char *, uint64_t))(v10 + 32))(v14, v9, AssociatedTypeWitness);
  MEMORY[0x1F4188790](v16);
  v18[-2] = a2;
  v18[-1] = a3;
  sub_1AF932ECC((uint64_t)v14, (uint64_t)sub_1AF934724, (uint64_t)&v18[-4], AssociatedTypeWitness, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v17);
  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v14, AssociatedTypeWitness);
}

uint64_t sub_1AF934724(unsigned __int8 *a1)
{
  return sub_1AF9347C4(a1);
}

uint64_t sub_1AF934740(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1AF933F24(a1, a2, a3, a4);
}

uint64_t sub_1AF934798()
{
  return 16;
}

__n128 sub_1AF9347A4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t dispatch thunk of static StatefulRule.initialValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t sub_1AF9347C4(unsigned __int8 *a1)
{
  uint64_t AssociatedTypeWitness = (AG::LayoutDescriptor *)swift_getAssociatedTypeWitness();
  return AGGraphSetOutputValue(a1, AssociatedTypeWitness);
}

uint64_t sub_1AF934814@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v5 = v2[2];
  uint64_t v6 = (uint64_t *)v2[3];
  uint64_t v8 = v2[4];
  uint64_t v7 = (void *)v2[5];
  v11[2] = v5;
  void v11[3] = v6;
  v11[4] = v8;
  uint64_t v9 = sub_1AF914170();
  uint64_t result = Attribute.init<A>(body:value:flags:update:)(v7, a1, v9, (uint64_t)sub_1AF9348AC, (uint64_t)v11, v5, v6);
  *a2 = result;
  return result;
}

uint64_t (*sub_1AF9348AC())()
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = swift_allocObject();
  *(void *)(v2 + 16) = v1;
  long long v3 = *(_OWORD *)(v0 + 24);
  *(_OWORD *)(v2 + 24) = v3;
  *(void *)(v2 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v3;
  return sub_1AF934918;
}

uint64_t sub_1AF934908()
{
  return MEMORY[0x1F4186498](v0, 48, 7);
}

uint64_t (*sub_1AF93491C())()
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = swift_allocObject();
  *(void *)(v2 + 16) = v1;
  long long v3 = *(_OWORD *)(v0 + 24);
  *(_OWORD *)(v2 + 24) = v3;
  *(void *)(v2 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v3;
  return sub_1AF934918;
}

uint64_t sub_1AF934978()
{
  return MEMORY[0x1F4186498](v0, 48, 7);
}

uint64_t sub_1AF934988()
{
  return (*(uint64_t (**)(void))(*(void *)(v0 + 32) + 32))(*(void *)(v0 + 24));
}

BOOL static AGAttribute.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

uint64_t AGAttribute.description.getter()
{
  return 35;
}

uint64_t AGAttribute.unsafeCast<A>(to:)(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t Attribute.subscript.getter(void *a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  uint64_t v5 = (const char *)sub_1AF93CE08();
  if (v6)
  {
    int v15 = a2;
    uint64_t v16 = a1;
    MEMORY[0x1F4188790](v5);
    v11[2] = *(void *)(v4 + *MEMORY[0x1E4FBC5F0] + 8);
    uint64_t v12 = type metadata accessor for Focus();
    uint64_t WitnessTable = swift_getWitnessTable();
    uint64_t v9 = type metadata accessor for Attribute();
    swift_retain();
    sub_1AF930F5C((uint64_t)&v15, (uint64_t)sub_1AF931890, (uint64_t)v11, v12, MEMORY[0x1E4FBC248], v9, MEMORY[0x1E4FBC278], v10);
    swift_release();
    return v14;
  }
  else
  {
    unint64_t v7 = *(void *)(*(void *)(*(void *)(*MEMORY[0x1E4FBC5F0] + v4 + 8) - 8) + 64);
    return AGGraphCreateOffsetAttribute2(a2, v5, v7);
  }
}

{
  uint64_t v4;
  const char *v5;
  char v6;
  unint64_t v7;
  uint64_t v9;
  uint64_t v10;
  void v11[3];
  uint64_t v12;
  uint64_t WitnessTable;
  unsigned int v14;
  int v15;
  void *v16;
  uint64_t v17;
  uint64_t vars8;

  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  uint64_t v5 = (const char *)sub_1AF93CE08();
  if (v6)
  {
    int v15 = a2;
    uint64_t v16 = a1;
    MEMORY[0x1F4188790](v5);
    v11[2] = *(void *)(v4 + *MEMORY[0x1E4FBC5F0] + 8);
    uint64_t v12 = type metadata accessor for Focus();
    uint64_t WitnessTable = swift_getWitnessTable();
    uint64_t v9 = type metadata accessor for Attribute();
    swift_retain();
    sub_1AF930F5C((uint64_t)&v15, (uint64_t)sub_1AF936510, (uint64_t)v11, v12, MEMORY[0x1E4FBC248], v9, MEMORY[0x1E4FBC278], v10);
    swift_release();
    return v14;
  }
  else
  {
    unint64_t v7 = *(void *)(*(void *)(*(void *)(*MEMORY[0x1E4FBC5F0] + v4 + 8) - 8) + 64);
    return AGGraphCreateOffsetAttribute2(a2, v5, v7);
  }
}

unint64_t static AGAttribute.current.getter()
{
  Currentuint64_t Attribute = AGGraphGetCurrentAttribute();
  if (CurrentAttribute == 2) {
    uint64_t v1 = 0;
  }
  else {
    uint64_t v1 = CurrentAttribute;
  }
  return v1 | ((unint64_t)(CurrentAttribute == 2) << 32);
}

uint64_t AGAttribute.unsafeOffset(at:)(const char *a1, uint64_t a2)
{
  return AGGraphCreateOffsetAttribute(a2, a1);
}

void AGAttribute.setFlags(_:mask:)(int a1, const char *a2, char *a3)
{
  uint64_t v4 = (const char *)(AGGraphGetFlags((uint64_t)a3, a2) & ~a2 | a2 & a1);
  AGGraphSetFlags(a3, v4);
}

uint64_t AGAttribute.addInput(_:options:token:)(const char *a1, uint64_t a2, int a3, char *a4)
{
  return AGGraphAddInput(a4, a1, a2);
}

uint64_t AGAttribute.visitBody<A>(_:)(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t AttributeInfo = AGGraphGetAttributeInfo((uint64_t)a2, a2);
  return sub_1AF936540(a1, v8, *(void *)(AttributeInfo + 56), a3, *(void *)(AttributeInfo + 64), a4);
}

void AGAttribute.mutateBody<A>(as:invalidating:_:)(int a1, char a2, uint64_t a3, uint64_t a4, char *a5, const char *a6)
{
  v6[2] = a6;
  v6[3] = a3;
  v6[4] = a4;
  AGGraphMutateAttribute(a5, a6, a2, (void (*)(void *))sub_1AF93603C, (uint64_t)v6);
}

uint64_t AGAttribute.breadthFirstSearch(options:_:)(const char *a1, uint64_t (*a2)(uint64_t), uint64_t a3, uint64_t a4)
{
  return AGGraphSearch(a4, a1, a2);
}

unint64_t AGAttribute.indirectDependency.getter(uint64_t a1, const char *a2)
{
  unsigned int IndirectDependency = AGGraphGetIndirectDependency(a1, a2);
  if (IndirectDependency == 2) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = IndirectDependency;
  }
  return v3 | ((unint64_t)(IndirectDependency == 2) << 32);
}

void AGAttribute.indirectDependency.setter(uint64_t a1, uint64_t a2)
{
  if ((a1 & 0x100000000) != 0) {
    uint64_t v3 = 2;
  }
  else {
    uint64_t v3 = a1;
  }
  AGGraphSetIndirectDependency(a2, (const char *)v3);
}

void (*AGAttribute.indirectDependency.modify(uint64_t a1, const char *a2))(unsigned int *a1)
{
  *(_DWORD *)(a1 + 8) = a2;
  int IndirectDependency = AGGraphGetIndirectDependency((uint64_t)a2, a2);
  *(_DWORD *)(a1 + 12) = 2;
  if (IndirectDependency == 2) {
    int v4 = 0;
  }
  else {
    int v4 = IndirectDependency;
  }
  *(_DWORD *)a1 = v4;
  *(unsigned char *)(a1 + 4) = IndirectDependency == 2;
  return sub_1AF934E80;
}

void sub_1AF934E80(unsigned int *a1)
{
  uint64_t v1 = a1 + 3;
  if (!*((unsigned char *)a1 + 4)) {
    uint64_t v1 = a1;
  }
  AGGraphSetIndirectDependency(a1[2], (const char *)*v1);
}

uint64_t AGAttribute._bodyType.getter(uint64_t a1, const char *a2)
{
  return *(void *)AGGraphGetAttributeInfo(a1, a2);
}

uint64_t AGAttribute._bodyPointer.getter(uint64_t a1, const char *a2)
{
  AGGraphGetAttributeInfo(a1, a2);
  return v2;
}

uint64_t AGAttribute.valueType.getter(uint64_t a1, const char *a2)
{
  return *(void *)(AGGraphGetAttributeInfo(a1, a2) + 8);
}

uint64_t AGAttribute.hash(into:)()
{
  return sub_1AF93CEF8();
}

uint64_t sub_1AF934F1C()
{
  return MEMORY[0x1F4185F80](*v0);
}

uint64_t sub_1AF934F24()
{
  return sub_1AF93CEF8();
}

void sub_1AF934F50()
{
}

uint64_t sub_1AF934F5C()
{
  return AGAttribute.description.getter();
}

uint64_t Attribute.identifier.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*Attribute.identifier.modify())()
{
  return nullsub_1;
}

uint64_t *Attribute.graph.getter(uint64_t a1, char *a2)
{
  AttributeGraph = AGGraphGetAttributeGraph(a1, a2);
  return AttributeGraph;
}

uint64_t Attribute.unsafeCast<A>(to:)(uint64_t a1, uint64_t a2)
{
  return a2;
}

void Attribute.flags.setter(const char *a1, char *a2)
{
}

void (*Attribute.flags.modify(_DWORD *a1, const char *a2))(unsigned int *a1)
{
  a1[1] = a2;
  *a1 = AGGraphGetFlags((uint64_t)a2, a2);
  return sub_1AF93502C;
}

void sub_1AF93502C(unsigned int *a1)
{
}

void Attribute.setFlags(_:mask:)(int a1, const char *a2, char *a3)
{
  int v4 = (const char *)(AGGraphGetFlags((uint64_t)a3, a2) & ~a2 | a2 & a1);
  AGGraphSetFlags(a3, v4);
}

uint64_t Attribute.value.setter(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1AF93555C(a1, a2, a3, (uint64_t)sub_1AF936064, a5, a6, a7, a8);
}

uint64_t Attribute.setValue(_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void v9[2] = a3;
  int v10 = a2;
  sub_1AF930F5C(a1, (uint64_t)sub_1AF936064, (uint64_t)v9, a3, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], a8);
  return v11;
}

void (*Attribute.value.modify(void *a1, unint64_t a2, AG::swift::metadata *a3))(void **a1, char a2)
{
  char v6 = malloc(0x38uLL);
  *a1 = v6;
  v6[12] = a2;
  uint64_t v7 = *((void *)a3 - 1);
  uint64_t v8 = v7;
  *(void *)char v6 = a3;
  *((void *)v6 + 1) = v7;
  size_t v9 = *(void *)(v7 + 64);
  *((void *)v6 + 2) = malloc(v9);
  int v10 = malloc(v9);
  *((void *)v6 + 3) = v10;
  Value = AGGraphGetValue(a2, 0, a3, v11, v12);
  unsigned int v14 = *(void (**)(void *, char *, AG::swift::metadata *))(v8 + 16);
  *((void *)v6 + 4) = v14;
  *((void *)v6 + 5) = (v8 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  v14(v10, Value, a3);
  return sub_1AF935258;
}

void sub_1AF935258(void **a1, char a2)
{
}

uint64_t Attribute.valueAndFlags(options:)(uint64_t a1, const char *a2, unint64_t a3, AG::swift::metadata *a4, uint64_t a5)
{
  Value = AGGraphGetValue(a3, a2, a4, (uint64_t)a4, a5);
  uint64_t v9 = v8;
  (*(void (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a4 - 1) + 16))(a1, Value, a4);
  return v9;
}

uint64_t Attribute.changedValue(options:)(uint64_t a1, const char *a2, unint64_t a3, AG::swift::metadata *a4, uint64_t a5)
{
  Value = AGGraphGetValue(a3, a2, a4, (uint64_t)a4, a5);
  char v9 = v8;
  (*(void (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a4 - 1) + 16))(a1, Value, a4);
  return v9 & 1;
}

uint64_t _s14AttributeGraph0A0V5valuexvg_0@<X0>(unint64_t a1@<X0>, AG::swift::metadata *a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  Value = AGGraphGetValue(a1, 0, a2, a3, a4);
  char v8 = *(uint64_t (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a2 - 1) + 16);
  return v8(a5, Value, a2);
}

char *Attribute.wrappedValue.unsafeAddressor(unint64_t a1, AG::swift::metadata *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AGGraphGetValue(a1, 0, a2, a4, a5);
}

uint64_t sub_1AF9353F4(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a4 + a3 - 8);
  uint64_t v8 = *(void *)(v7 - 8);
  double v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = &v15[-v10];
  (*(void (**)(unsigned char *, double))(v8 + 16))(&v15[-v10], v9);
  int v12 = *a2;
  uint64_t v17 = v7;
  int v18 = v12;
  sub_1AF930F5C((uint64_t)v11, a5, (uint64_t)v16, v7, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], v13);
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v8 + 8))(v11, v7);
}

uint64_t Attribute.wrappedValue.setter(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1AF93555C(a1, a2, a3, (uint64_t)sub_1AF936064, a5, a6, a7, a8);
}

uint64_t sub_1AF93555C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v11[2] = a3;
  int v12 = a2;
  sub_1AF930F5C(a1, a4, (uint64_t)v11, a3, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], a8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a1, a3);
}

void (*Attribute.wrappedValue.modify(void *a1, unint64_t a2, AG::swift::metadata *a3))(void **a1, char a2)
{
  char v6 = malloc(0x38uLL);
  *a1 = v6;
  v6[12] = a2;
  uint64_t v7 = *((void *)a3 - 1);
  uint64_t v8 = v7;
  *(void *)char v6 = a3;
  *((void *)v6 + 1) = v7;
  size_t v9 = *(void *)(v7 + 64);
  *((void *)v6 + 2) = malloc(v9);
  uint64_t v10 = malloc(v9);
  *((void *)v6 + 3) = v10;
  Value = AGGraphGetValue(a2, 0, a3, v11, v12);
  unsigned int v14 = *(void (**)(void *, char *, AG::swift::metadata *))(v8 + 16);
  *((void *)v6 + 4) = v14;
  *((void *)v6 + 5) = (v8 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  v14(v10, Value, a3);
  return sub_1AF935258;
}

void sub_1AF935730(void **a1, char a2, uint64_t a3, uint64_t a4)
{
  int v4 = (uint64_t *)*a1;
  if (a2)
  {
    uint64_t v7 = (void *)v4[2];
    char v6 = (void *)v4[3];
    uint64_t v8 = *v4;
    uint64_t v9 = v4[1];
    int v10 = *((_DWORD *)v4 + 12);
    uint64_t v11 = ((uint64_t (*)(void *, void *, uint64_t))v4[4])(v7, v6, *v4);
    MEMORY[0x1F4188790](v11);
    uint64_t v20 = v8;
    int v21 = v10;
    sub_1AF930F5C((uint64_t)v7, a4, (uint64_t)v19, v8, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], v12);
    uint64_t v13 = *(void (**)(void *, uint64_t))(v9 + 8);
    v13(v7, v8);
    v13(v6, v8);
  }
  else
  {
    uint64_t v7 = (void *)v4[2];
    char v6 = (void *)v4[3];
    uint64_t v14 = *v4;
    uint64_t v15 = v4[1];
    MEMORY[0x1F4188790](a1);
    uint64_t v20 = v14;
    int v21 = v16;
    sub_1AF930F5C((uint64_t)v6, v17, (uint64_t)v19, v14, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], v18);
    (*(void (**)(void *, uint64_t))(v15 + 8))(v6, v14);
  }
  free(v6);
  free(v7);
  free(v4);
}

uint64_t Attribute.projectedValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*Attribute.projectedValue.modify(uint64_t a1))(uint64_t result)
{
  *(void *)a1 = v1;
  *(_DWORD *)(a1 + 8) = *v1;
  return sub_1AF93590C;
}

uint64_t sub_1AF93590C(uint64_t result)
{
  **(_DWORD **)uint64_t result = *(_DWORD *)(result + 8);
  return result;
}

uint64_t Attribute.unsafeOffset<A>(at:as:)(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AGGraphCreateOffsetAttribute2(a3, a1, *(void *)(*(void *)(a5 - 8) + 64));
}

uint64_t Attribute.applying<A>(offset:)(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AGGraphCreateOffsetAttribute2(a2, a1, *(void *)(*(void *)(a4 - 8) + 64));
}

uint64_t Attribute.subscript.getter(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v6 = *(void *)(*(void *)(a5 - 8) + 64);
  if (v6) {
    uint64_t v7 = (const char *)a1(1);
  }
  else {
    uint64_t v7 = 0;
  }
  return AGGraphCreateOffsetAttribute2(a3, v7, v6);
}

uint64_t Attribute.addInput<A>(_:options:token:)(const char *a1, uint64_t a2, int a3, char *a4)
{
  return AGGraphAddInput(a4, a1, a2);
}

uint64_t _sSo11AGAttributea14AttributeGraphE8addInput_7options5tokenyAC0B0VyxG_So14AGInputOptionsVSitlF_0(const char *a1, uint64_t a2, int a3, char *a4)
{
  return AGGraphAddInput(a4, a1, a2);
}

uint64_t sub_1AF935C04@<X0>(char *a1@<X1>, char *a2@<X0>, AG::LayoutDescriptor *a3@<X2>, unsigned char *a4@<X8>)
{
  uint64_t result = AGGraphSetValue(a1, a2, a3);
  *a4 = result;
  return result;
}

uint64_t Attribute.hasValue.getter(char *a1, const char *a2)
{
  return AGGraphHasValue(a1, a2);
}

id Attribute.subgraph.getter(int a1, const char *a2)
{
  AttributeSubgraph = (void *)AGGraphGetAttributeSubgraph(a1, a2);
  return AttributeSubgraph;
}

uint64_t Attribute.visitBody<A>(_:)(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t AttributeInfo = AGGraphGetAttributeInfo((uint64_t)a2, a2);
  return sub_1AF936540(a1, v9, *(void *)(AttributeInfo + 56), a4, *(void *)(AttributeInfo + 64), a5);
}

uint64_t Attribute.breadthFirstSearch(options:_:)(const char *a1, uint64_t (*a2)(uint64_t), uint64_t a3, uint64_t a4)
{
  return AGGraphSearch(a4, a1, a2);
}

void Attribute.mutateBody<A>(as:invalidating:_:)(int a1, char a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, const char *a7)
{
  v7[2] = a7;
  v7[3] = a3;
  void v7[4] = a4;
  AGGraphMutateAttribute(a5, a7, a2, (void (*)(void *))sub_1AF936534, (uint64_t)v7);
}

BOOL static Attribute.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

uint64_t Attribute.hash(into:)()
{
  return sub_1AF93CEF8();
}

uint64_t Attribute.hashValue.getter()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF935DC4()
{
  return Attribute.hashValue.getter();
}

uint64_t sub_1AF935DCC()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF935E0C()
{
  return Attribute.description.getter(*v0);
}

uint64_t Attribute.init(value:)(uint64_t a1, uint64_t a2)
{
  v7[2] = a2;
  uint64_t v4 = type metadata accessor for Attribute();
  sub_1AF930F5C(a1, (uint64_t)sub_1AF93607C, (uint64_t)v7, a2, MEMORY[0x1E4FBC248], v4, MEMORY[0x1E4FBC278], v5);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  return v8;
}

uint64_t sub_1AF935EC8(uint64_t a1, uint64_t a2)
{
  v6[5] = *MEMORY[0x1E4F143B8];
  v6[2] = a2;
  v6[3] = a1;
  uint64_t v2 = type metadata accessor for External();
  uint64_t v3 = type metadata accessor for Attribute();
  return sub_1AF930F5C(v3, (uint64_t)sub_1AF93641C, (uint64_t)v6, v2, MEMORY[0x1E4FBC248], v3, MEMORY[0x1E4FBC278], v4);
}

uint64_t Attribute.init(type:)(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a2;
  uint64_t v2 = type metadata accessor for External();
  uint64_t v3 = type metadata accessor for Attribute();
  sub_1AF930F5C(v3, (uint64_t)sub_1AF93609C, (uint64_t)v7, v2, MEMORY[0x1E4FBC248], v3, MEMORY[0x1E4FBC278], v4);
  return v6;
}

uint64_t sub_1AF93603C()
{
  return (*(uint64_t (**)(void))(v0 + 24))();
}

uint64_t sub_1AF936064@<X0>(char *a1@<X0>, unsigned char *a2@<X8>)
{
  return sub_1AF936380(a1, a2);
}

uint64_t sub_1AF93607C(uint64_t a1)
{
  return sub_1AF935EC8(a1, *(void *)(v1 + 16));
}

uint64_t sub_1AF93609C@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v8 = *(void *)(v2 + 16);
  uint64_t v5 = (uint64_t *)type metadata accessor for External();
  uint64_t result = Attribute.init<A>(body:value:flags:update:)(a1, 0, 16, (uint64_t)sub_1AF9363BC, (uint64_t)&v7, v8, v5);
  *a2 = result;
  return result;
}

uint64_t sub_1AF936128()
{
  return swift_getWitnessTable();
}

uint64_t sub_1AF936144@<X0>(unsigned int *a1@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = AGGraphGetIndirectDependency(*a1, a2);
  if (result == 2) {
    int v5 = 0;
  }
  else {
    int v5 = result;
  }
  *(_DWORD *)a3 = v5;
  *(unsigned char *)(a3 + 4) = result == 2;
  return result;
}

void sub_1AF93618C(uint64_t a1, unsigned int *a2)
{
  if (*(unsigned char *)(a1 + 4)) {
    uint64_t v2 = &AGAttributeNil;
  }
  else {
    uint64_t v2 = (int *)a1;
  }
  AGGraphSetIndirectDependency(*a2, (const char *)*v2);
}

uint64_t sub_1AF9361B0@<X0>(unsigned int *a1@<X0>, const char *a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t result = AGGraphGetFlags(*a1, a2);
  *a3 = result;
  return result;
}

void sub_1AF9361DC(unsigned int *a1, unsigned int *a2)
{
}

uint64_t sub_1AF9361EC()
{
  return 8;
}

void *sub_1AF9361F8(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1AF936208(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  return sub_1AF9353F4(a1, a2, a3, a4, (uint64_t)sub_1AF936064);
}

uint64_t sub_1AF936268()
{
  return 8;
}

uint64_t keypath_get_12Tm@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v7 = *(AG::swift::metadata **)(a3 + a2 - 8);
  Value = AGGraphGetValue(*a1, 0, v7, a4, a5);
  uint64_t v9 = *(uint64_t (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)v7 - 1) + 16);
  return v9(a6, Value, v7);
}

uint64_t sub_1AF9362F0(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  return sub_1AF9353F4(a1, a2, a3, a4, (uint64_t)sub_1AF936064);
}

uint64_t sub_1AF936350()
{
  return 8;
}

_DWORD *sub_1AF93635C@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

_DWORD *sub_1AF936368(_DWORD *result, _DWORD *a2)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1AF936374()
{
  return 8;
}

uint64_t sub_1AF936380@<X0>(char *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t result = AGGraphSetValue((char *)*(unsigned int *)(v2 + 24), a1, *(AG::LayoutDescriptor **)(v2 + 16));
  *a2 = result;
  return result;
}

uint64_t (*sub_1AF9363BC())()
{
  uint64_t v1 = *(void *)(v0 + 16);
  *(void *)(swift_allocObject() + 16) = v1;
  return nullsub_1;
}

uint64_t sub_1AF93640C()
{
  return MEMORY[0x1F4186498](v0, 24, 7);
}

uint64_t sub_1AF93641C@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v6 = *(void *)(v2 + 16);
  int v5 = *(void **)(v2 + 24);
  void v9[2] = v6;
  uint64_t v7 = (uint64_t *)type metadata accessor for External();
  uint64_t result = Attribute.init<A>(body:value:flags:update:)(a1, v5, 16, (uint64_t)sub_1AF9364B0, (uint64_t)v9, v6, v7);
  *a2 = result;
  return result;
}

uint64_t (*sub_1AF9364B0())()
{
  uint64_t v1 = *(void *)(v0 + 16);
  *(void *)(swift_allocObject() + 16) = v1;
  return nullsub_1;
}

uint64_t sub_1AF936500()
{
  return MEMORY[0x1F4186498](v0, 24, 7);
}

uint64_t sub_1AF936510@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  return sub_1AF931890(a1, a2);
}

uint64_t sub_1AF936540(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 8))(a2, a3, a5, a4, a6);
}

uint64_t static _AttributeBody._hasDestroySelf.getter()
{
  return 0;
}

uint64_t static _AttributeBody.comparisonMode.getter()
{
  return 2;
}

uint64_t sub_1AF936598()
{
  return 8;
}

uint64_t static _AttributeBody.flags.getter()
{
  return 8;
}

uint64_t static ObservedAttribute._destroySelf(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 16))(a2, a3);
}

uint64_t static ObservedAttribute._hasDestroySelf.getter()
{
  return 1;
}

uint64_t dispatch thunk of static _AttributeBody._destroySelf(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of static _AttributeBody._hasDestroySelf.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of static _AttributeBody._updateDefault(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of static _AttributeBody.comparisonMode.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of static _AttributeBody.flags.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of ObservedAttribute.destroy()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of AttributeBodyVisitor.visit<A>(body:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 8))();
}

uint64_t static AGGraphRef.withoutUpdate<A>(_:)(void (*a1)(void))
{
  uint64_t v2 = AGGraphClearUpdate();
  a1();
  return AGGraphSetUpdate(v2);
}

void AGGraphRef.withoutSubgraphInvalidation<A>(_:)(void (*a1)(void), const char *a2)
{
  uint64_t v4 = (const char *)AGGraphBeginDeferringSubgraphInvalidation(v2, a2);
  a1();
  AGGraphEndDeferringSubgraphInvalidation(v2, v4);
}

uint64_t *AGGraphRef.withDeadline<A>(_:_:)(const char *a1, const char *a2)
{
  Deadline = (const char *)AGGraphGetDeadline(v2, a2);
  uint64_t v6 = AGGraphSetDeadline(v2, a1);
  ((void (*)(uint64_t *))a2)(v6);
  return AGGraphSetDeadline(v2, Deadline);
}

uint64_t AGGraphRef.onInvalidation(_:)(const char *a1, uint64_t a2)
{
  return AGGraphSetInvalidationCallback(v2, a1, a2);
}

uint64_t AGGraphRef.onUpdate(_:)(const char *a1, uint64_t a2)
{
  return AGGraphSetUpdateCallback(v2, a1, a2);
}

double AGGraphRef.withMainThreadHandler(_:do:)(unint64_t a1, unint64_t a2, const char *a3, uint64_t a4)
{
  *(void *)&double result = AGGraphWithMainThreadHandler(v4, a3, a4, a1, a2).n128_u64[0];
  return result;
}

void static AGGraphRef.startProfiling()(uint64_t a1, const char *a2)
{
}

void static AGGraphRef.stopProfiling()(uint64_t a1, const char *a2)
{
}

void static AGGraphRef.resetProfile()(uint64_t a1, const char *a2)
{
}

void static AGGraphRef.markProfile(name:)(AG::Graph *this)
{
}

uint64_t AGGraphRef.addTraceEvent<A>(_:context:)(const char *a1, uint64_t a2, uint64_t a3)
{
  return AGGraphAddTraceEvent(v3, a1, a2, a3);
}

uint64_t AGGraphRef.addTraceEvent<A>(_:value:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void v9[2] = a3;
  void v9[4] = a1;
  return sub_1AF930F5C(a2, (uint64_t)sub_1AF9368A0, (uint64_t)v9, a3, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], a8);
}

uint64_t sub_1AF9368A0(uint64_t a1)
{
  return AGGraphAddTraceEvent(*(void *)(v1 + 24), *(const char **)(v1 + 32), a1, *(void *)(v1 + 16));
}

uint64_t sub_1AF9368D4(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *a2;
  uint64_t WitnessTable = swift_getWitnessTable();
  return MEMORY[0x1F4186958](v4, v5, a3, WitnessTable);
}

Swift::Void __swiftcall AGGraphRef.print(includeValues:)(Swift::Bool includeValues)
{
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0648);
  uint64_t v2 = swift_allocObject();
  *(_OWORD *)(v2 + 16) = xmmword_1AF93F910;
  Swift::String v3 = AGGraphRef.graphvizDescription(includeValues:)(includeValues);
  *(void *)(v2 + 56) = MEMORY[0x1E4FBB1A0];
  *(Swift::String *)(v2 + 32) = v3;
  sub_1AF93CEA8();
  swift_bridgeObjectRelease();
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2();
    *a1 = result;
  }
  return result;
}

Swift::String __swiftcall AGGraphRef.graphvizDescription(includeValues:)(Swift::Bool includeValues)
{
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0650);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1AF93F920;
  uint64_t v4 = MEMORY[0x1E4FBB1A0];
  *(void *)(inited + 32) = @"format";
  *(void *)(inited + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = 0x6F642F6870617267;
  *(void *)(inited + 48) = 0xE900000000000074;
  *(void *)(inited + 64) = v4;
  *(void *)(inited + 72) = @"include-values";
  *(void *)(inited + 104) = MEMORY[0x1E4FBB390];
  *(unsigned char *)(inited + 8dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = includeValues;
  uint64_t v5 = @"format";
  uint64_t v6 = @"include-values";
  sub_1AF936C28(inited);
  type metadata accessor for AGDescriptionOption(0);
  sub_1AF936D44();
  uint64_t v7 = (void *)sub_1AF93CD28();
  swift_bridgeObjectRelease();
  id v8 = AGGraphDescription(v1, v7);

  if (v8)
  {
    sub_1AF93CDF8();
    swift_unknownObjectRelease();
  }
  else
  {
    memset(v14, 0, sizeof(v14));
  }
  sub_1AF936D9C((uint64_t)v14, (uint64_t)v15);
  if (!v16)
  {
    sub_1AF936E04((uint64_t)v15);
    goto LABEL_8;
  }
  if (!swift_dynamicCast())
  {
LABEL_8:
    uint64_t v9 = 0;
    int v10 = (void *)0xE000000000000000;
    goto LABEL_9;
  }
  uint64_t v9 = v12;
  int v10 = v13;
LABEL_9:
  result._object = v10;
  result._countAndFlagsBits = v9;
  return result;
}

uint64_t static AGGraphRef.printStack(maxFrames:)(uint64_t a1)
{
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0648);
  uint64_t v2 = swift_allocObject();
  *(_OWORD *)(v2 + 16) = xmmword_1AF93F910;
  uint64_t v3 = _sSo10AGGraphRefa14AttributeGraphE16stackDescription9maxFramesSSSi_tFZ_0(a1);
  *(void *)(v2 + 56) = MEMORY[0x1E4FBB1A0];
  *(void *)(v2 + 32) = v3;
  *(void *)(v2 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v4;
  sub_1AF93CEA8();
  return swift_bridgeObjectRelease();
}

unint64_t sub_1AF936C28(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v3 = (void *)MEMORY[0x1E4FBC868];
    goto LABEL_9;
  }
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0668);
  uint64_t v2 = sub_1AF93CE48();
  uint64_t v3 = (void *)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v3;
  }
  uint64_t v5 = v2 + 64;
  uint64_t v6 = a1 + 32;
  swift_retain();
  while (1)
  {
    sub_1AF9378A0(v6, (uint64_t)&v13);
    uint64_t v7 = v13;
    unint64_t result = sub_1AF937410(v13);
    if (v9) {
      break;
    }
    *(void *)(v5 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
    *(void *)(v3[6] + 8 * result) = v7;
    unint64_t result = (unint64_t)sub_1AF937908(&v14, (_OWORD *)(v3[7] + 32 * result));
    uint64_t v10 = v3[2];
    BOOL v11 = __OFADD__(v10, 1);
    uint64_t v12 = v10 + 1;
    if (v11) {
      goto LABEL_11;
    }
    v3[2] = v12;
    v6 += 40;
    if (!--v4)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1AF936D44()
{
  unint64_t result = qword_1E9AF0628;
  if (!qword_1E9AF0628)
  {
    type metadata accessor for AGDescriptionOption(255);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9AF0628);
  }
  return result;
}

uint64_t sub_1AF936D9C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0658);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t sub_1AF936E04(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0658);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

Swift::Void __swiftcall AGGraphRef.archiveJSON(name:)(Swift::String_optional name)
{
  uint64_t v2 = v1;
  object = name.value._object;
  uint64_t countAndFlagsBits = name.value._countAndFlagsBits;
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = sub_1AF93CCC8();
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  id v8 = (char *)v35 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0650);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1AF93F920;
  uint64_t v10 = MEMORY[0x1E4FBB1A0];
  *(void *)(inited + 32) = @"format";
  *(void *)(inited + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = 0x69642F6870617267;
  *(void *)(inited + 48) = 0xEA00000000007463;
  *(void *)(inited + 64) = v10;
  *(void *)(inited + 72) = @"include-values";
  *(void *)(inited + 104) = MEMORY[0x1E4FBB390];
  *(unsigned char *)(inited + 8dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = 1;
  BOOL v11 = @"format";
  uint64_t v12 = @"include-values";
  sub_1AF936C28(inited);
  type metadata accessor for AGDescriptionOption(0);
  sub_1AF936D44();
  uint64_t v13 = (void *)sub_1AF93CD28();
  swift_bridgeObjectRelease();
  id v14 = AGGraphDescription(v2, v13);

  if (v14)
  {
    sub_1AF93CDF8();
    swift_unknownObjectRelease();
  }
  else
  {
    memset(v35, 0, sizeof(v35));
  }
  sub_1AF936D9C((uint64_t)v35, (uint64_t)&v36);
  if (v38)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0660);
    if (swift_dynamicCast())
    {
      uint64_t v15 = 0x6870617267;
      if (object)
      {
        uint64_t v15 = countAndFlagsBits;
        unint64_t v16 = (unint64_t)object;
      }
      else
      {
        unint64_t v16 = 0xE500000000000000;
      }
      id v36 = (id)v15;
      unint64_t v37 = v16;
      swift_bridgeObjectRetain();
      sub_1AF93CDC8();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      uint64_t v17 = NSTemporaryDirectory();
      if (v17)
      {
        uint64_t v18 = v17;
        uint64_t v19 = (void *)sub_1AF93CD68();
        swift_bridgeObjectRelease();
        uint64_t v20 = [(NSString *)v18 stringByAppendingPathComponent:v19];

        sub_1AF93CD98();
        int v21 = self;
        uint64_t v22 = MEMORY[0x1E4FBB1A0];
        uint64_t v23 = (void *)sub_1AF93CD28();
        swift_bridgeObjectRelease();
        id v36 = 0;
        id v24 = objc_msgSend(v21, sel_dataWithJSONObject_options_error_, v23, 0, &v36);

        id v25 = v36;
        if (v24)
        {
          uint64_t v26 = sub_1AF93CCD8();
          unint64_t v28 = v27;

          sub_1AF93CCB8();
          sub_1AF93CCE8();
          __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0648);
          uint64_t v31 = swift_allocObject();
          *(_OWORD *)(v31 + 16) = xmmword_1AF93F910;
          id v36 = 0;
          unint64_t v37 = 0xE000000000000000;
          sub_1AF93CE28();
          swift_bridgeObjectRelease();
          id v36 = (id)0xD000000000000015;
          unint64_t v37 = 0x80000001AF941630;
          sub_1AF93CDC8();
          swift_bridgeObjectRelease();
          sub_1AF93CDC8();
          id v32 = v36;
          unint64_t v33 = v37;
          *(void *)(v31 + 56) = v22;
          *(void *)(v31 + 32) = v32;
          *(void *)(v31 + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = v33;
          sub_1AF93CEA8();
          sub_1AF93779C(v26, v28);
          swift_bridgeObjectRelease();
          (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
        }
        else
        {
          uint64_t v29 = v25;
          swift_bridgeObjectRelease();
          uint64_t v30 = sub_1AF93CCA8();

          swift_willThrow();
          MEMORY[0x1B3E85390](v30);
        }
      }
      else
      {
        __break(1u);
      }
    }
  }
  else
  {
    sub_1AF936E04((uint64_t)&v36);
  }
}

uint64_t sub_1AF937358(uint64_t a1)
{
  return _s14AttributeGraph8ExternalV11descriptionSSvg_0(*(AG::swift::metadata **)(a1 + 16));
}

uint64_t Focus.description.getter(uint64_t a1, uint64_t a2, uint64_t a3, AG::swift::metadata *a4)
{
  return sub_1AF937838(a3, a4, 547520738);
}

uint64_t sub_1AF93738C(uint64_t a1)
{
  return sub_1AF937838(*(void *)(a1 + 16), *(AG::swift::metadata **)(a1 + 24), 547520738);
}

uint64_t Map.description.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, AG::swift::metadata *a5)
{
  return sub_1AF937838(a4, a5, 2145230);
}

uint64_t sub_1AF9373E4(uint64_t a1)
{
  return sub_1AF937838(*(void *)(a1 + 16), *(AG::swift::metadata **)(a1 + 24), 2145230);
}

unint64_t sub_1AF937410(uint64_t a1)
{
  sub_1AF93CD98();
  sub_1AF93CED8();
  sub_1AF93CDB8();
  uint64_t v2 = sub_1AF93CF08();
  swift_bridgeObjectRelease();
  return sub_1AF9374A4(a1, v2);
}

unint64_t sub_1AF9374A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2 + 64;
  uint64_t v4 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t v5 = a2 & ~v4;
  if ((*(void *)(v2 + 64 + ((v5 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v5))
  {
    uint64_t v6 = sub_1AF93CD98();
    uint64_t v8 = v7;
    if (v6 == sub_1AF93CD98() && v8 == v9)
    {
LABEL_16:
      swift_bridgeObjectRelease_n();
      return v5;
    }
    char v11 = sub_1AF93CE88();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    if ((v11 & 1) == 0)
    {
      uint64_t v12 = ~v4;
      unint64_t v5 = (v5 + 1) & v12;
      if ((*(void *)(v3 + ((v5 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v5))
      {
        while (1)
        {
          uint64_t v13 = sub_1AF93CD98();
          uint64_t v15 = v14;
          if (v13 == sub_1AF93CD98() && v15 == v16) {
            break;
          }
          char v18 = sub_1AF93CE88();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          if ((v18 & 1) == 0)
          {
            unint64_t v5 = (v5 + 1) & v12;
            if ((*(void *)(v3 + ((v5 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v5)) {
              continue;
            }
          }
          return v5;
        }
        goto LABEL_16;
      }
    }
  }
  return v5;
}

uint64_t _sSo10AGGraphRefa14AttributeGraphE16stackDescription9maxFramesSSSi_tFZ_0(uint64_t a1)
{
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0650);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1AF93F920;
  uint64_t v3 = MEMORY[0x1E4FBB1A0];
  *(void *)(inited + 32) = @"format";
  *(void *)(inited + 4dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = 0x65742F6B63617473;
  *(void *)(inited + 48) = 0xEA00000000007478;
  *(void *)(inited + 64) = v3;
  *(void *)(inited + 72) = @"max-frames";
  *(void *)(inited + 104) = MEMORY[0x1E4FBB550];
  *(void *)(inited + 8dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = a1;
  uint64_t v4 = @"format";
  unint64_t v5 = @"max-frames";
  sub_1AF936C28(inited);
  type metadata accessor for AGDescriptionOption(0);
  sub_1AF936D44();
  uint64_t v6 = (void *)sub_1AF93CD28();
  swift_bridgeObjectRelease();
  id v7 = AGGraphDescription(0, v6);

  if (v7)
  {
    sub_1AF93CDF8();
    swift_unknownObjectRelease();
  }
  else
  {
    memset(v10, 0, sizeof(v10));
  }
  sub_1AF936D9C((uint64_t)v10, (uint64_t)v11);
  if (v12)
  {
    if (swift_dynamicCast()) {
      return v9;
    }
  }
  else
  {
    sub_1AF936E04((uint64_t)v11);
  }
  return 0;
}

uint64_t sub_1AF93779C(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_release();
  }
  return swift_release();
}

uint64_t _s14AttributeGraph8ExternalV11descriptionSSvg_0(AG::swift::metadata *a1)
{
  uint64_t v1 = AGTypeDescription(a1);
  uint64_t v2 = sub_1AF93CD98();

  return v2;
}

uint64_t sub_1AF937838(uint64_t a1, AG::swift::metadata *a2, uint64_t a3)
{
  uint64_t v3 = AGTypeDescription(a2);
  sub_1AF93CD98();

  sub_1AF93CDC8();
  swift_bridgeObjectRelease();
  return a3;
}

uint64_t sub_1AF9378A0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0670);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

_OWORD *sub_1AF937908(_OWORD *a1, _OWORD *a2)
{
  long long v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

void sub_1AF937918()
{
}

id sub_1AF937924(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = sub_1AF937AF0(*a1, a2, (AG::swift::metadata *)*a1);
  if (v3)
  {
    v6[0] = v2;
    v6[1] = v3;
    uint64_t v4 = (void *)sub_1AF93CE78();
    sub_1AF937C40((uint64_t)v6);
  }
  else
  {
    uint64_t v4 = 0;
  }
  return v4;
}

id sub_1AF937994(uint64_t a1)
{
  uint64_t v1 = sub_1AF937A40(*(void *)(a1 + 8));
  if (v2)
  {
    v5[0] = v1;
    v5[1] = v2;
    uint64_t v3 = (void *)sub_1AF93CE78();
    sub_1AF937C40((uint64_t)v5);
  }
  else
  {
    uint64_t v3 = 0;
  }
  return v3;
}

uint64_t sub_1AF937A04(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 64) + 24))(a2, *(void *)(a1 + 56));
}

uint64_t sub_1AF937A40(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *))(v2 + 16))((char *)&v4 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0));
  return sub_1AF93CDA8();
}

uint64_t sub_1AF937AF0(uint64_t a1, uint64_t a2, AG::swift::metadata *a3)
{
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *))(v5 + 16))((char *)v9 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0));
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0678);
  if (swift_dynamicCast())
  {
    sub_1AF937CF4(v9, (uint64_t)v11);
    __swift_project_boxed_opaque_existential_1(v11, v11[3]);
    uint64_t v6 = sub_1AF93CE68();
    __swift_destroy_boxed_opaque_existential_1((uint64_t)v11);
  }
  else
  {
    uint64_t v10 = 0;
    memset(v9, 0, sizeof(v9));
    sub_1AF937C94((uint64_t)v9);
    id v7 = AGTypeDescription(a3);
    uint64_t v6 = sub_1AF93CD98();
  }
  return v6;
}

uint64_t sub_1AF937C40(uint64_t a1)
{
  return a1;
}

uint64_t sub_1AF937C94(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF0680);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_1AF937CF4(long long *a1, uint64_t a2)
{
  long long v2 = *a1;
  long long v3 = a1[1];
  *(void *)(a2 + 32) = *((void *)a1 + 4);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

void *__swift_project_boxed_opaque_existential_1(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80)));
  return result;
}

uint64_t __swift_destroy_boxed_opaque_existential_1(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 24) - 8);
  if ((*(unsigned char *)(v1 + 82) & 2) != 0) {
    return swift_release();
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t AGTupleType.init(_:)(uint64_t a1)
{
  uint64_t v1 = AGNewTupleType(*(void *)(a1 + 16), a1 + 32);
  swift_bridgeObjectRelease();
  return v1;
}

BOOL AGTupleType.isEmpty.getter(void *a1)
{
  return AGTupleCount(a1) == 0;
}

uint64_t AGTupleType.indices.getter(void *a1)
{
  uint64_t result = AGTupleCount(a1);
  if ((result & 0x8000000000000000) == 0) {
    return 0;
  }
  __break(1u);
  return result;
}

void *AGTupleType.type(at:)(const char *a1, void *a2)
{
  return AGTupleElementType(a2, a1);
}

uint64_t AGTupleType.offset<A>(at:as:)(const char *a1, uint64_t a2, void *a3, void *a4)
{
  return AGTupleElementOffsetChecked(a3, a1, a4);
}

uint64_t AGTupleType.setElement<A>(in:at:from:options:)(char *a1, unint64_t a2, const char *a3, uint64_t a4, AG::swift::metadata *a5, AG::swift::metadata *a6)
{
  return AGTupleSetElement(a5, a1, a2, a3, a6, a4);
}

uint64_t AGTupleType.getElement<A>(in:at:to:options:)(const char *a1, unint64_t a2, void *a3, uint64_t a4, AG::swift::metadata *a5, AG::swift::metadata *a6)
{
  return AGTupleGetElement(a5, a1, a2, a3, a6, a4);
}

BOOL AGUnsafeTuple.isEmpty.getter(void *a1)
{
  return AGTupleCount(a1) == 0;
}

uint64_t AGUnsafeTuple.address<A>(as:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 == a2) {
    return a3;
  }
  __break(1u);
  return result;
}

uint64_t AGUnsafeTuple.subscript.unsafeAddressor(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3 == result) {
    return a2;
  }
  __break(1u);
  return result;
}

uint64_t AGUnsafeTuple.subscript.unsafeAddressor(const char *a1, void *a2, uint64_t a3, void *a4)
{
  return a3 + AGTupleElementOffsetChecked(a2, a1, a4);
}

uint64_t AGUnsafeMutableTuple.init(with:)(uint64_t a1)
{
  return a1;
}

uint64_t AGUnsafeMutableTuple.initialize<A>(at:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v9[2] = a5;
  void v9[3] = a3;
  void v9[4] = a4;
  void v9[5] = a1;
  return sub_1AF930F5C(a2, (uint64_t)sub_1AF937FCC, (uint64_t)v9, a5, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], a8);
}

uint64_t sub_1AF937FCC(const char *a1)
{
  return AGTupleSetElement(*(AG::swift::metadata **)(v1 + 24), *(char **)(v1 + 32), *(void *)(v1 + 40), a1, *(AG::swift::metadata **)(v1 + 16), 1);
}

Swift::Void __swiftcall AGUnsafeMutableTuple.deinitialize(at:)(Swift::Int at)
{
  AGTupleDestroyElement(v1, v2, at);
}

Swift::Void __swiftcall AGUnsafeMutableTuple.deallocate(initialized:)(Swift::Bool initialized)
{
  if (initialized) {
    AGTupleDestroy(v1, v2);
  }
  JUMPOUT(0x1B3E854D0);
}

uint64_t _sSo13AGUnsafeTuplea14AttributeGraphE7indicesSnySiGvg_0(void *a1)
{
  uint64_t result = AGTupleCount(a1);
  if ((result & 0x8000000000000000) == 0) {
    return 0;
  }
  __break(1u);
  return result;
}

uint64_t _sSo13AGUnsafeTuplea14AttributeGraphE7address2of2asSPyxGSi_xmtlF_0(const char *a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  return a4 + AGTupleElementOffsetChecked(a3, a1, a5);
}

uint64_t _sSo13AGUnsafeTuplea14AttributeGraphExycluig_0@<X0>(uint64_t result@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (a2 == result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a2 - 8) + 16))(a3);
  }
  __break(1u);
  return result;
}

uint64_t AGUnsafeMutableTuple.subscript.setter(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 == a2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 40))(a3, result, a4);
  }
  __break(1u);
  return result;
}

uint64_t (*AGUnsafeMutableTuple.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  if (a4 == a2) {
    return nullsub_1;
  }
  __break(1u);
  return result;
}

uint64_t _sSo13AGUnsafeTuplea14AttributeGraphEyxSicluig_0@<X0>(const char *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = a3 + AGTupleElementOffsetChecked(a2, a1, a4);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, void *))(*(a4 - 1) + 16);
  return v8(a5, v7, a4);
}

uint64_t AGUnsafeMutableTuple.subscript.setter(uint64_t a1, const char *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v7 = a4 + AGTupleElementOffsetChecked(a3, a2, a5);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, void *))(*(a5 - 1) + 40);
  return v8(v7, a1, a5);
}

uint64_t (*AGUnsafeMutableTuple.subscript.modify(uint64_t a1, const char *a2, void *a3, uint64_t a4, void *a5))()
{
  return nullsub_1;
}

void *sub_1AF9382C8@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *(void *)(a3 + a2 - 8);
  if (v4 == *result) {
    return (void *)(*(uint64_t (**)(uint64_t, void))(*(void *)(v4 - 8) + 16))(a4, result[1]);
  }
  __break(1u);
  return result;
}

uint64_t sub_1AF938310(uint64_t result, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 8);
  if (v4 == *a2) {
    return (*(uint64_t (**)(void, uint64_t))(*(void *)(v4 - 8) + 24))(a2[1], result);
  }
  __break(1u);
  return result;
}

uint64_t sub_1AF93835C()
{
  return 8;
}

void *sub_1AF938368(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1AF938374@<X0>(uint64_t a1@<X0>, const char **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = *(const char **)((char *)a2 + a3 - 8);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = v6 + AGTupleElementOffsetChecked(*(void **)a1, *a2, v5);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, void *))(*(v5 - 1) + 16);
  return v8(a4, v7, v5);
}

uint64_t sub_1AF9383F8(uint64_t a1, uint64_t a2, const char **a3, uint64_t a4)
{
  uint64_t v5 = *(const char **)((char *)a3 + a4 - 8);
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = v6 + AGTupleElementOffsetChecked(*(void **)a2, *a3, v5);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, void *))(*(v5 - 1) + 24);
  return v8(v7, a1, v5);
}

uint64_t sub_1AF93847C()
{
  return 8;
}

uint64_t AGTypeID.description.getter(AG::swift::metadata *a1)
{
  uint64_t v1 = AGTypeDescription(a1);
  uint64_t v2 = sub_1AF93CD98();

  return v2;
}

uint64_t AGTypeID.forEachField(options:do:)(int a1, uint64_t a2, uint64_t a3, AG::swift::metadata *a4)
{
  return AGTypeApplyFields2(a4, a1, a2, a3);
}

uint64_t sub_1AF938510()
{
  uint64_t v1 = *v0;
  type metadata accessor for _Metadata(0);
  return MEMORY[0x1F4183828](v1, v2);
}

uint64_t sub_1AF938550()
{
  return sub_1AF93CEE8();
}

uint64_t sub_1AF93857C(uint64_t a1)
{
  return MEMORY[0x1F4185EA0](a1, *v1);
}

uint64_t sub_1AF938584()
{
  uint64_t v1 = AGTypeDescription(*v0);
  uint64_t v2 = sub_1AF93CD98();

  return v2;
}

BOOL static AGTypeSignature.== infix(_:_:)(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  return a1 == a4 && a2 == a5 && a3 == (unint64_t)a6;
}

BOOL sub_1AF938724(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2
      && *(void *)(a1 + 8) == *(void *)(a2 + 8)
      && *(_DWORD *)(a1 + 16) == (unint64_t)*(unsigned int *)(a2 + 16);
}

uint64_t compareValues<A>(_:_:mode:)(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v9[2] = a4;
  void v9[3] = a2;
  int v10 = a3;
  sub_1AF930F5C(a1, (uint64_t)sub_1AF938878, (uint64_t)v9, a4, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], a8);
  return v11;
}

uint64_t compareValues<A>(_:_:options:)(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v9[2] = a4;
  void v9[3] = a2;
  int v10 = a3;
  sub_1AF930F5C(a1, (uint64_t)sub_1AF938878, (uint64_t)v9, a4, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], a8);
  return v11;
}

uint64_t sub_1AF938878(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1AF938890(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1AF938890(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(v8 + 24);
  int v10 = *(_DWORD *)(v8 + 32);
  uint64_t v13 = *(void *)(v8 + 16);
  uint64_t v14 = a1;
  int v15 = v10;
  return sub_1AF930F5C(v9, (uint64_t)sub_1AF938A0C, (uint64_t)&v12, v13, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], a8);
}

uint64_t withUnsafePointerToEnumCase<A>(of:do:)(void *a1, void (*a2)(void, uint64_t, unint64_t), int a3, AG::swift::metadata *this)
{
  return AGTypeApplyEnumData(this, a1, a2);
}

AG::swift::metadata *withUnsafeMutablePointerToEnumCase<A>(of:do:)(void **a1, void (*a2)(void, AG::swift::metadata *, unint64_t), int a3, AG::swift::metadata *this)
{
  return AGTypeApplyMutableEnumData(this, a1, a2);
}

uint64_t AGSetTypeForKey(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1EB3D2E48);
  objc_msgSend(v3, sel_setObject_forKeyedSubscript_, sub_1AF93CE98(), v4);

  return swift_unknownObjectRelease();
}

unint64_t sub_1AF9389B4()
{
  unint64_t result = qword_1EB3D2E50;
  if (!qword_1EB3D2E50)
  {
    type metadata accessor for Metadata(255);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB3D2E50);
  }
  return result;
}

uint64_t sub_1AF938A0C@<X0>(unsigned __int8 *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t result = AGCompareValues(*(AG::LayoutDescriptor **)(v2 + 24), a1, *(AG::LayoutDescriptor **)(v2 + 16), (AG::swift::metadata *)(*(_DWORD *)(v2 + 32) | 0x100u));
  *a2 = result;
  return result;
}

uint64_t IndirectAttribute.init(source:)(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AGGraphCreateIndirectAttribute2(a1, *(void *)(*(void *)(a2 - 8) + 64), a3, a4);
}

void IndirectAttribute.source.setter(const char *a1, uint64_t a2)
{
}

void (*IndirectAttribute.source.modify(_DWORD *a1, uint64_t a2))(unsigned int *a1)
{
  a1[1] = a2;
  *a1 = AGGraphGetIndirectAttribute(a2);
  return sub_1AF938AC8;
}

void sub_1AF938AC8(unsigned int *a1)
{
}

Swift::Void __swiftcall IndirectAttribute.resetSource()()
{
  AGGraphResetIndirectAttribute(v0, 0, v1);
}

unint64_t IndirectAttribute.dependency.getter(uint64_t a1, const char *a2)
{
  unsigned int IndirectDependency = AGGraphGetIndirectDependency(a1, a2);
  if (IndirectDependency == 2) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = IndirectDependency;
  }
  return v3 | ((unint64_t)(IndirectDependency == 2) << 32);
}

void IndirectAttribute.dependency.setter(uint64_t a1, uint64_t a2)
{
  if ((a1 & 0x100000000) != 0) {
    uint64_t v3 = 2;
  }
  else {
    uint64_t v3 = a1;
  }
  AGGraphSetIndirectDependency(a2, (const char *)v3);
}

void (*IndirectAttribute.dependency.modify(uint64_t a1, const char *a2))(unsigned int *a1)
{
  *(_DWORD *)(a1 + 8) = a2;
  int IndirectDependency = AGGraphGetIndirectDependency((uint64_t)a2, a2);
  *(_DWORD *)(a1 + 12) = 2;
  if (IndirectDependency == 2) {
    int v4 = 0;
  }
  else {
    int v4 = IndirectDependency;
  }
  *(_DWORD *)a1 = v4;
  *(unsigned char *)(a1 + 4) = IndirectDependency == 2;
  return sub_1AF934E80;
}

uint64_t IndirectAttribute.value.setter(uint64_t a1, int a2, uint64_t a3)
{
  return sub_1AF93901C(a1, a2, a3, (uint64_t)sub_1AF939728);
}

void (*IndirectAttribute.value.modify(void *a1, unint64_t a2, AG::swift::metadata *a3))(uint64_t **a1, char a2)
{
  uint64_t v6 = malloc(0x40uLL);
  *a1 = v6;
  v6[14] = a2;
  uint64_t v7 = *((void *)a3 - 1);
  uint64_t v8 = v7;
  *(void *)uint64_t v6 = a3;
  *((void *)v6 + 1) = v7;
  size_t v9 = *(void *)(v7 + 64);
  *((void *)v6 + 2) = malloc(v9);
  *((void *)v6 + 3) = malloc(v9);
  int v10 = malloc(v9);
  *((void *)v6 + 4) = v10;
  Value = AGGraphGetValue(a2, 0, a3, v11, v12);
  uint64_t v14 = *(void (**)(void *, char *, AG::swift::metadata *))(v8 + 16);
  *((void *)v6 + 5) = v14;
  *((void *)v6 + 6) = (v8 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  v14(v10, Value, a3);
  return sub_1AF938D60;
}

void sub_1AF938D60(uint64_t **a1, char a2)
{
}

uint64_t IndirectAttribute.changedValue(options:)(uint64_t a1, const char *a2, unint64_t a3, AG::swift::metadata *a4, uint64_t a5)
{
  Value = AGGraphGetValue(a3, a2, a4, (uint64_t)a4, a5);
  char v9 = v8;
  (*(void (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a4 - 1) + 16))(a1, Value, a4);
  return v9 & 1;
}

uint64_t sub_1AF938E08(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a4 + a3 - 8);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](a1);
  int v10 = &v19[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)];
  double v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = &v19[-v13];
  int v15 = *(void (**)(unsigned char *, double))(v8 + 16);
  v15(&v19[-v13], v12);
  LODWORD(a2) = *a2;
  ((void (*)(unsigned char *, unsigned char *, uint64_t))v15)(v10, v14, v7);
  uint64_t v21 = v7;
  int v22 = (int)a2;
  sub_1AF930F5C((uint64_t)v10, a5, (uint64_t)v20, v7, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], v16);
  uint64_t v17 = *(void (**)(unsigned char *, uint64_t))(v8 + 8);
  v17(v10, v7);
  return ((uint64_t (*)(unsigned char *, uint64_t))v17)(v14, v7);
}

uint64_t IndirectAttribute.wrappedValue.setter(uint64_t a1, int a2, uint64_t a3)
{
  return sub_1AF93901C(a1, a2, a3, (uint64_t)sub_1AF93992C);
}

uint64_t sub_1AF93901C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a3 - 8);
  double v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = &v16[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0)];
  (*(void (**)(char *, uint64_t, double))(v8 + 16))(v11, a1, v9);
  uint64_t v17 = a3;
  int v18 = a2;
  sub_1AF930F5C((uint64_t)v11, a4, (uint64_t)v16, a3, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], v12);
  uint64_t v13 = *(void (**)(char *, uint64_t))(v8 + 8);
  v13(v11, a3);
  return ((uint64_t (*)(uint64_t, uint64_t))v13)(a1, a3);
}

void (*IndirectAttribute.wrappedValue.modify(void *a1, unint64_t a2, AG::swift::metadata *a3))(uint64_t **a1, char a2)
{
  uint64_t v6 = malloc(0x40uLL);
  *a1 = v6;
  v6[14] = a2;
  uint64_t v7 = *((void *)a3 - 1);
  uint64_t v8 = v7;
  *(void *)uint64_t v6 = a3;
  *((void *)v6 + 1) = v7;
  size_t v9 = *(void *)(v7 + 64);
  *((void *)v6 + 2) = malloc(v9);
  *((void *)v6 + 3) = malloc(v9);
  uint64_t v10 = malloc(v9);
  *((void *)v6 + 4) = v10;
  Value = AGGraphGetValue(a2, 0, a3, v11, v12);
  uint64_t v14 = *(void (**)(void *, char *, AG::swift::metadata *))(v8 + 16);
  *((void *)v6 + 5) = v14;
  *((void *)v6 + 6) = (v8 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  v14(v10, Value, a3);
  return sub_1AF938D60;
}

void sub_1AF9392C0(uint64_t **a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *a1;
  uint64_t v8 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))(*a1)[5])((*a1)[3], v7[4], *v7);
  if (a2)
  {
    uint64_t v10 = (void *)v7[3];
    size_t v9 = (void *)v7[4];
    uint64_t v12 = v7[1];
    uint64_t v11 = (void *)v7[2];
    uint64_t v13 = *v7;
    int v14 = *((_DWORD *)v7 + 14);
    uint64_t v15 = ((uint64_t (*)(void *, void *, uint64_t))v7[5])(v11, v10, *v7);
    MEMORY[0x1F4188790](v15);
    uint64_t v24 = v13;
    int v25 = v14;
    sub_1AF930F5C((uint64_t)v11, a4, (uint64_t)v23, v13, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], v16);
    uint64_t v17 = *(void (**)(void *, uint64_t))(v12 + 8);
    v17(v11, v13);
    v17(v10, v13);
    v17(v9, v13);
  }
  else
  {
    uint64_t v10 = (void *)v7[3];
    size_t v9 = (void *)v7[4];
    uint64_t v18 = v7[1];
    uint64_t v11 = (void *)v7[2];
    uint64_t v19 = *v7;
    MEMORY[0x1F4188790](v8);
    uint64_t v24 = v19;
    int v25 = v20;
    sub_1AF930F5C((uint64_t)v10, a3, (uint64_t)v23, v19, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBB390], MEMORY[0x1E4FBC278], v21);
    int v22 = *(void (**)(void *, uint64_t))(v18 + 8);
    v22(v10, v19);
    v22(v9, v19);
  }
  free(v9);
  free(v10);
  free(v11);
  free(v7);
}

uint64_t IndirectAttribute.subscript.getter(void *a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  uint64_t v5 = (const char *)sub_1AF93CE08();
  if (v6)
  {
    int v15 = a2;
    uint64_t v16 = a1;
    MEMORY[0x1F4188790](v5);
    v11[2] = *(void *)(v4 + *MEMORY[0x1E4FBC5F0] + 8);
    uint64_t v12 = type metadata accessor for Focus();
    uint64_t WitnessTable = swift_getWitnessTable();
    uint64_t v9 = type metadata accessor for Attribute();
    swift_retain();
    sub_1AF930F5C((uint64_t)&v15, (uint64_t)sub_1AF931890, (uint64_t)v11, v12, MEMORY[0x1E4FBC248], v9, MEMORY[0x1E4FBC278], v10);
    swift_release();
    return v14;
  }
  else
  {
    unint64_t v7 = *(void *)(*(void *)(*(void *)(*MEMORY[0x1E4FBC5F0] + v4 + 8) - 8) + 64);
    return AGGraphCreateOffsetAttribute2(a2, v5, v7);
  }
}

BOOL static IndirectAttribute.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

uint64_t IndirectAttribute.hash(into:)()
{
  return sub_1AF93CEF8();
}

uint64_t IndirectAttribute.hashValue.getter()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF939720()
{
  return IndirectAttribute.hashValue.getter();
}

uint64_t sub_1AF939728@<X0>(char *a1@<X0>, unsigned char *a2@<X8>)
{
  return sub_1AF935C04((char *)*(unsigned int *)(v2 + 24), a1, *(AG::LayoutDescriptor **)(v2 + 16), a2);
}

uint64_t sub_1AF93974C()
{
  return swift_getWitnessTable();
}

uint64_t sub_1AF939768@<X0>(unsigned int *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t result = AGGraphGetIndirectAttribute(*a1);
  *a2 = result;
  return result;
}

void sub_1AF939794(unsigned int *a1, unsigned int *a2)
{
}

uint64_t sub_1AF9397A4()
{
  return 8;
}

void *sub_1AF9397B0(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1AF9397BC@<X0>(unsigned int *a1@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = AGGraphGetIndirectDependency(*a1, a2);
  if (result == 2) {
    int v5 = 0;
  }
  else {
    int v5 = result;
  }
  *(_DWORD *)a3 = v5;
  *(unsigned char *)(a3 + 4) = result == 2;
  return result;
}

void sub_1AF939804(uint64_t a1, unsigned int *a2)
{
  if (*(unsigned char *)(a1 + 4)) {
    uint64_t v2 = &AGAttributeNil;
  }
  else {
    uint64_t v2 = (int *)a1;
  }
  AGGraphSetIndirectDependency(*a2, (const char *)*v2);
}

uint64_t sub_1AF939828()
{
  return 8;
}

uint64_t sub_1AF939838(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  return sub_1AF938E08(a1, a2, a3, a4, (uint64_t)sub_1AF93992C);
}

uint64_t sub_1AF939898()
{
  return 8;
}

uint64_t sub_1AF9398A8(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  return sub_1AF938E08(a1, a2, a3, a4, (uint64_t)sub_1AF93992C);
}

uint64_t sub_1AF939908()
{
  return 8;
}

uint64_t type metadata accessor for IndirectAttribute()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t sub_1AF93992C@<X0>(char *a1@<X0>, unsigned char *a2@<X8>)
{
  return sub_1AF939728(a1, a2);
}

unint64_t AGSubgraphRef.addObserver(_:)(const char *a1, uint64_t a2)
{
  return AGSubgraphAddObserver(v2, a1, a2);
}

uint64_t AGSubgraphRef.apply<A>(_:)(void (*a1)(void))
{
  uint64_t v3 = AGGraphClearUpdate();
  uint64_t v4 = (id)AGSubgraphGetCurrent();
  AGSubgraphSetCurrent(v1);
  a1();
  AGSubgraphSetCurrent(v4);

  return AGGraphSetUpdate(v3);
}

void AGSubgraphRef.forEach(_:_:)(int a1, void (*a2)(void))
{
  AGSubgraphApply(v2, a1, a2);
}

uint64_t static AGSubgraphRef.beginTreeElement<A>(value:flags:)(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result = AGSubgraphShouldRecordTree();
  if (result)
  {
    return AGSubgraphBeginTreeElement(a1, a3, a2);
  }
  return result;
}

uint64_t static AGSubgraphRef.addTreeValue<A>(_:forKey:flags:)(uint64_t a1, char *a2, int a3, uint64_t a4)
{
  uint64_t result = AGSubgraphShouldRecordTree();
  if (result)
  {
    return AGSubgraphAddTreeValue(a1, a4, a2, a3);
  }
  return result;
}

uint64_t static AGSubgraphRef.endTreeElement<A>(value:)()
{
  uint64_t result = AGSubgraphShouldRecordTree();
  if (result)
  {
    return AGSubgraphEndTreeElement();
  }
  return result;
}

unint64_t AGTreeElement.value.getter(unsigned int a1)
{
  unsigned int Value = AGTreeElementGetValue(a1);
  if (Value == 2) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = Value;
  }
  return v2 | ((unint64_t)(Value == 2) << 32);
}

__n128 sub_1AF939B5C@<Q0>(__n128 *a1@<X8>)
{
  unint64_t v2 = v1[1].n128_u64[0];
  __n128 result = *v1;
  *a1 = *v1;
  a1[1].n128_u64[0] = v2;
  return result;
}

uint64_t sub_1AF939B70()
{
  return 0;
}

uint64_t sub_1AF939B78()
{
  return sub_1AF93A0B4(*v0, v0[1], v0[2]);
}

void *sub_1AF939B84(void *a1, uint64_t a2, uint64_t a3)
{
  return sub_1AF939B90(a1, a2, a3, *v3, v3[1], v3[2]);
}

void *sub_1AF939B90(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  char v6 = result;
  uint64_t v11 = a4;
  uint64_t v12 = a5;
  uint64_t v13 = a6;
  if (!a2)
  {
    uint64_t v7 = 0;
    goto LABEL_11;
  }
  uint64_t v7 = a3;
  if (!a3)
  {
LABEL_11:
    *char v6 = a4;
    v6[1] = a5;
    void v6[2] = a6;
    return (void *)v7;
  }
  if ((a3 & 0x8000000000000000) == 0)
  {
    uint64_t NextChild = AGTreeElementGetNextChild((uint64_t)&v11);
    uint64_t v10 = 0;
    if (NextChild)
    {
      while (1)
      {
        *(void *)(a2 + 8 * v1dispatch_set_context(*((dispatch_object_t *)this + 2), 0) = NextChild;
        if (v7 - 1 == v10) {
          break;
        }
        uint64_t NextChild = AGTreeElementGetNextChild((uint64_t)&v11);
        ++v10;
        if (!NextChild) {
          goto LABEL_7;
        }
      }
      a4 = v11;
      a5 = v12;
    }
    else
    {
LABEL_7:
      a4 = v11;
      a5 = v12;
      uint64_t v7 = v10;
    }
    a6 = v13;
    goto LABEL_11;
  }
  __break(1u);
  return result;
}

void *sub_1AF939C40(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5 = result;
  uint64_t v10 = a4;
  uint64_t v11 = a5;
  if (!a2)
  {
    uint64_t v6 = 0;
    goto LABEL_10;
  }
  uint64_t v6 = a3;
  if (!a3)
  {
LABEL_10:
    *int v5 = a4;
    v5[1] = a5;
    return (void *)v6;
  }
  if ((a3 & 0x8000000000000000) == 0)
  {
    Nextunsigned int Value = AGTreeElementGetNextValue((uint64_t)&v10);
    uint64_t v9 = 0;
    if (NextValue)
    {
      while (1)
      {
        *(void *)(a2 + 8 * v9) = NextValue;
        if (v6 - 1 == v9) {
          break;
        }
        Nextunsigned int Value = AGTreeElementGetNextValue((uint64_t)&v10);
        ++v9;
        if (!NextValue) {
          goto LABEL_7;
        }
      }
      a4 = v10;
      a5 = v11;
    }
    else
    {
LABEL_7:
      a4 = v10;
      a5 = v11;
      uint64_t v6 = v9;
    }
    goto LABEL_10;
  }
  __break(1u);
  return result;
}

uint64_t sub_1AF939CE4()
{
  return sub_1AF93CDD8();
}

uint64_t sub_1AF939D08@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = AGTreeElementGetNextChild(v1);
  *a1 = result;
  return result;
}

uint64_t sub_1AF939D34()
{
  return sub_1AF93A21C(*v0, v0[1]);
}

void *sub_1AF939D3C(void *a1, uint64_t a2, uint64_t a3)
{
  return sub_1AF939C40(a1, a2, a3, *v3, v3[1]);
}

uint64_t sub_1AF939D44@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = AGTreeElementGetNextValue(v1);
  *a1 = result;
  return result;
}

unint64_t AGTreeElementNodeIterator.next()()
{
  unsigned int NextNode = AGTreeElementGetNextNode(v0);
  if (NextNode == 2) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = NextNode;
  }
  return v2 | ((unint64_t)(NextNode == 2) << 32);
}

__n128 sub_1AF939DB8@<Q0>(__n128 *a1@<X8>)
{
  __n128 result = *v1;
  *a1 = *v1;
  return result;
}

uint64_t sub_1AF939DC4()
{
  return sub_1AF939F3C(*v0, v0[1]);
}

uint64_t sub_1AF939DCC(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  return sub_1AF93A380(a1, a2, a3, *v3, v3[1]);
}

uint64_t sub_1AF939DD4@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = AGTreeElementGetNextNode(v1);
  if (result == 2) {
    int v4 = 0;
  }
  else {
    int v4 = result;
  }
  *(_DWORD *)a1 = v4;
  *(unsigned char *)(a1 + 4) = result == 2;
  return result;
}

uint64_t sub_1AF939E1C()
{
  return sub_1AF939EF4(&qword_1E9AF0688, type metadata accessor for Children);
}

uint64_t sub_1AF939E64()
{
  return sub_1AF939EF4(&qword_1E9AF0690, type metadata accessor for Values);
}

uint64_t sub_1AF939EAC()
{
  return sub_1AF939EF4(&qword_1E9AF0698, type metadata accessor for Nodes);
}

uint64_t sub_1AF939EF4(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1AF939F3C(uint64_t a1, uint64_t a2)
{
  v21[0] = a1;
  v21[1] = a2;
  uint64_t result = AGTreeElementGetNextNode(v21);
  uint64_t v3 = (void *)MEMORY[0x1E4FBC860];
  if (result == 2)
  {
    uint64_t v4 = 0;
LABEL_22:
    unint64_t v18 = v3[3];
    if (v18 < 2) {
      return (uint64_t)v3;
    }
    unint64_t v19 = v18 >> 1;
    BOOL v17 = __OFSUB__(v19, v4);
    uint64_t v20 = v19 - v4;
    if (!v17)
    {
      v3[2] = v20;
      return (uint64_t)v3;
    }
  }
  else
  {
    int v5 = result;
    uint64_t v4 = 0;
    uint64_t v6 = (_DWORD *)(MEMORY[0x1E4FBC860] + 32);
    while (1)
    {
      if (!v4)
      {
        unint64_t v7 = v3[3];
        if ((uint64_t)((v7 >> 1) + 0x4000000000000000) < 0) {
          goto LABEL_27;
        }
        int64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
        if (v8 <= 1) {
          uint64_t v9 = 1;
        }
        else {
          uint64_t v9 = v8;
        }
        __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF06A0);
        uint64_t v10 = (void *)swift_allocObject();
        int64_t v11 = _swift_stdlib_malloc_size(v10);
        uint64_t v12 = v11 - 32;
        if (v11 < 32) {
          uint64_t v12 = v11 - 29;
        }
        uint64_t v13 = v12 >> 2;
        _OWORD v10[2] = v9;
        v10[3] = 2 * (v12 >> 2);
        unint64_t v14 = (unint64_t)(v10 + 4);
        uint64_t v15 = v3[3] >> 1;
        if (v3[2])
        {
          if (v10 != v3 || v14 >= (unint64_t)v3 + 4 * v15 + 32) {
            memmove(v10 + 4, v3 + 4, 4 * v15);
          }
          v3[2] = 0;
        }
        uint64_t v6 = (_DWORD *)(v14 + 4 * v15);
        uint64_t v4 = (v13 & 0x7FFFFFFFFFFFFFFFLL) - v15;
        uint64_t result = swift_release();
        uint64_t v3 = v10;
      }
      BOOL v17 = __OFSUB__(v4--, 1);
      if (v17) {
        break;
      }
      *v6++ = v5;
      uint64_t result = AGTreeElementGetNextNode(v21);
      int v5 = result;
      if (result == 2) {
        goto LABEL_22;
      }
    }
    __break(1u);
LABEL_27:
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t sub_1AF93A0B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v22[0] = a1;
  v22[1] = a2;
  v22[2] = a3;
  uint64_t result = AGTreeElementGetNextChild((uint64_t)v22);
  uint64_t v4 = (void *)MEMORY[0x1E4FBC860];
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    unint64_t v7 = (uint64_t *)(MEMORY[0x1E4FBC860] + 32);
    while (1)
    {
      if (!v6)
      {
        unint64_t v8 = v4[3];
        if ((uint64_t)((v8 >> 1) + 0x4000000000000000) < 0) {
          goto LABEL_28;
        }
        int64_t v9 = v8 & 0xFFFFFFFFFFFFFFFELL;
        if (v9 <= 1) {
          uint64_t v10 = 1;
        }
        else {
          uint64_t v10 = v9;
        }
        __swift_instantiateConcreteTypeFromMangledName(qword_1E9AF06B0);
        int64_t v11 = (void *)swift_allocObject();
        int64_t v12 = _swift_stdlib_malloc_size(v11);
        uint64_t v13 = v12 - 32;
        if (v12 < 32) {
          uint64_t v13 = v12 - 25;
        }
        uint64_t v14 = v13 >> 3;
        v11[2] = v10;
        void v11[3] = 2 * (v13 >> 3);
        unint64_t v15 = (unint64_t)(v11 + 4);
        uint64_t v16 = v4[3] >> 1;
        if (v4[2])
        {
          if (v11 != v4 || v15 >= (unint64_t)&v4[v16 + 4]) {
            memmove(v11 + 4, v4 + 4, 8 * v16);
          }
          v4[2] = 0;
        }
        unint64_t v7 = (uint64_t *)(v15 + 8 * v16);
        uint64_t v6 = (v14 & 0x7FFFFFFFFFFFFFFFLL) - v16;
        uint64_t result = swift_release();
        uint64_t v4 = v11;
      }
      BOOL v18 = __OFSUB__(v6--, 1);
      if (v18) {
        break;
      }
      *v7++ = v5;
      uint64_t result = AGTreeElementGetNextChild((uint64_t)v22);
      uint64_t v5 = result;
      if (!result) {
        goto LABEL_23;
      }
    }
    __break(1u);
LABEL_28:
    __break(1u);
    goto LABEL_29;
  }
  uint64_t v6 = 0;
LABEL_23:
  unint64_t v19 = v4[3];
  if (v19 < 2) {
    return (uint64_t)v4;
  }
  unint64_t v20 = v19 >> 1;
  BOOL v18 = __OFSUB__(v20, v6);
  uint64_t v21 = v20 - v6;
  if (!v18)
  {
    v4[2] = v21;
    return (uint64_t)v4;
  }
LABEL_29:
  __break(1u);
  return result;
}

uint64_t sub_1AF93A21C(uint64_t a1, uint64_t a2)
{
  v21[0] = a1;
  v21[1] = a2;
  uint64_t result = AGTreeElementGetNextValue((uint64_t)v21);
  uint64_t v3 = (void *)MEMORY[0x1E4FBC860];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    uint64_t v6 = (uint64_t *)(MEMORY[0x1E4FBC860] + 32);
    while (1)
    {
      if (!v5)
      {
        unint64_t v7 = v3[3];
        if ((uint64_t)((v7 >> 1) + 0x4000000000000000) < 0) {
          goto LABEL_28;
        }
        int64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
        if (v8 <= 1) {
          uint64_t v9 = 1;
        }
        else {
          uint64_t v9 = v8;
        }
        __swift_instantiateConcreteTypeFromMangledName(&qword_1E9AF06A8);
        uint64_t v10 = (void *)swift_allocObject();
        int64_t v11 = _swift_stdlib_malloc_size(v10);
        uint64_t v12 = v11 - 32;
        if (v11 < 32) {
          uint64_t v12 = v11 - 25;
        }
        uint64_t v13 = v12 >> 3;
        _OWORD v10[2] = v9;
        v10[3] = 2 * (v12 >> 3);
        unint64_t v14 = (unint64_t)(v10 + 4);
        uint64_t v15 = v3[3] >> 1;
        if (v3[2])
        {
          if (v10 != v3 || v14 >= (unint64_t)&v3[v15 + 4]) {
            memmove(v10 + 4, v3 + 4, 8 * v15);
          }
          v3[2] = 0;
        }
        uint64_t v6 = (uint64_t *)(v14 + 8 * v15);
        uint64_t v5 = (v13 & 0x7FFFFFFFFFFFFFFFLL) - v15;
        uint64_t result = swift_release();
        uint64_t v3 = v10;
      }
      BOOL v17 = __OFSUB__(v5--, 1);
      if (v17) {
        break;
      }
      *v6++ = v4;
      uint64_t result = AGTreeElementGetNextValue((uint64_t)v21);
      uint64_t v4 = result;
      if (!result) {
        goto LABEL_23;
      }
    }
    __break(1u);
LABEL_28:
    __break(1u);
    goto LABEL_29;
  }
  uint64_t v5 = 0;
LABEL_23:
  unint64_t v18 = v3[3];
  if (v18 < 2) {
    return (uint64_t)v3;
  }
  unint64_t v19 = v18 >> 1;
  BOOL v17 = __OFSUB__(v19, v5);
  uint64_t v20 = v19 - v5;
  if (!v17)
  {
    v3[2] = v20;
    return (uint64_t)v3;
  }
LABEL_29:
  __break(1u);
  return result;
}

uint64_t sub_1AF93A380(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (void *)result;
  uint64_t v9 = a4;
  uint64_t v10 = a5;
  if (!a2)
  {
    uint64_t v6 = 0;
LABEL_14:
    *uint64_t v5 = a4;
    v5[1] = a5;
    return v6;
  }
  uint64_t v6 = a3;
  if (!a3)
  {
LABEL_13:
    a4 = v9;
    a5 = v10;
    goto LABEL_14;
  }
  if ((a3 & 0x8000000000000000) == 0)
  {
    uint64_t result = AGTreeElementGetNextNode(&v9);
    if (result == 2)
    {
      uint64_t v8 = 0;
LABEL_6:
      a4 = v9;
      a5 = v10;
      uint64_t v6 = v8;
      goto LABEL_14;
    }
    *a2 = result;
    if (v6 != 1)
    {
      uint64_t v8 = 1;
      while (v6 != v8)
      {
        uint64_t result = AGTreeElementGetNextNode(&v9);
        if (result == 2) {
          goto LABEL_6;
        }
        a2[v8++] = result;
        if (v6 == v8) {
          goto LABEL_13;
        }
      }
      __break(1u);
      goto LABEL_16;
    }
    goto LABEL_13;
  }
LABEL_16:
  __break(1u);
  return result;
}

uint64_t sub_1AF93A460@<X0>(void (*a1)(char *, char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X6>, uint64_t a6@<X8>)
{
  uint64_t v25 = a5;
  uint64_t v26 = a2;
  uint64_t v28 = a4;
  unint64_t v27 = a1;
  uint64_t v24 = *(void *)(a3 - 8);
  uint64_t v10 = ((uint64_t (*)(void))MEMORY[0x1F4188790])();
  uint64_t v12 = (char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = *(void *)(v13 + 16);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1F4188790](v10);
  unint64_t v18 = (char *)&v24 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v24 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t))(v21 + 16))(v20, v6);
  uint64_t v22 = 1;
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v15 + 48))(v20, 1, v14) != 1)
  {
    (*(void (**)(char *, char *, uint64_t))(v15 + 32))(v18, v20, v14);
    v27(v18, v12);
    (*(void (**)(char *, uint64_t))(v15 + 8))(v18, v14);
    if (v7) {
      return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v24 + 32))(v25, v12, a3);
    }
    uint64_t v22 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v28 - 8) + 56))(a6, v22, 1);
}

uint64_t AnyRuleContext.attribute.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*AnyRuleContext.attribute.modify())()
{
  return nullsub_1;
}

uint64_t AnyRuleContext.unsafeCast<A>(to:)(uint64_t a1, uint64_t a2)
{
  return a2;
}

char *AnyRuleContext.subscript.unsafeAddressor(const char *a1, unint64_t a2, AG::swift::metadata *a3)
{
  return AGGraphGetInputValue(a2, a1, 0, a3);
}

uint64_t AnyRuleContext.subscript.getter@<X0>(const char *a1@<X0>, unint64_t a2@<X1>, AG::swift::metadata *a3@<X2>, uint64_t a4@<X8>)
{
  Inputunsigned int Value = AGGraphGetInputValue(a2, a1, 0, a3);
  uint64_t v7 = *(uint64_t (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a3 - 1) + 16);
  return v7(a4, InputValue, a3);
}

uint64_t AnyRuleContext.subscript.getter@<X0>(unint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  int Attribute = AGWeakAttributeGetAttribute(a1);
  if (Attribute == 2) {
    int v8 = 0;
  }
  else {
    int v8 = Attribute;
  }
  int v13 = v8;
  BOOL v14 = Attribute == 2;
  v11[2] = a3;
  int v12 = a2;
  type metadata accessor for Attribute();
  sub_1AF93CDE8();
  return sub_1AF93A460((void (*)(char *, char *))sub_1AF93B3BC, (uint64_t)v11, MEMORY[0x1E4FBC248], a3, v9, a4);
}

uint64_t AnyRuleContext.subscript.getter@<X0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  long long v9[2] = a3;
  if (a1 == 2) {
    int v6 = 0;
  }
  else {
    int v6 = a1;
  }
  int v11 = v6;
  BOOL v12 = a1 == 2;
  int v10 = a2;
  type metadata accessor for Attribute();
  sub_1AF93CDE8();
  return sub_1AF93A460((void (*)(char *, char *))sub_1AF93B3BC, (uint64_t)v9, MEMORY[0x1E4FBC248], a3, v7, a4);
}

uint64_t AnyRuleContext.changedValue<A>(of:options:)(uint64_t a1, const char *a2, uint64_t a3, unint64_t a4, AG::swift::metadata *a5)
{
  Inputunsigned int Value = AGGraphGetInputValue(a4, a2, a3, a5);
  char v9 = v8;
  (*(void (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a5 - 1) + 16))(a1, InputValue, a5);
  return v9 & 1;
}

uint64_t AnyRuleContext.valueAndFlags<A>(of:options:)(uint64_t a1, const char *a2, uint64_t a3, unint64_t a4, AG::swift::metadata *a5)
{
  Inputunsigned int Value = AGGraphGetInputValue(a4, a2, a3, a5);
  uint64_t v9 = v8;
  (*(void (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a5 - 1) + 16))(a1, InputValue, a5);
  return v9;
}

unsigned int *AnyRuleContext.update(body:)(uint64_t (*a1)(void), int a2, char *a3)
{
  return AGGraphWithUpdate(a3, a1);
}

BOOL static AnyRuleContext.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

uint64_t RuleContext.attribute.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*RuleContext.attribute.modify())()
{
  return nullsub_1;
}

BOOL RuleContext.hasValue.getter(uint64_t a1, AG::swift::metadata *a2)
{
  return AGGraphGetOutputValue(a2, (const char *)a2) != 0;
}

uint64_t RuleContext.value.getter@<X0>(AG::swift::metadata *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t result = AGGraphGetOutputValue(a1, (const char *)a1);
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, AG::swift::metadata *))(*((void *)a1 - 1) + 16);
    return v5(a2, result, a1);
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t sub_1AF93AB2C@<X0>(const char *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(AG::swift::metadata **)&a1[a2 - 8];
  uint64_t result = AGGraphGetOutputValue(v4, a1);
  if (result)
  {
    int v6 = *(uint64_t (**)(uint64_t, uint64_t, AG::swift::metadata *))(*((void *)v4 - 1) + 16);
    return v6(a3, result, v4);
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t RuleContext.value.unsafeAddressor(uint64_t a1, AG::swift::metadata *a2)
{
  uint64_t result = AGGraphGetOutputValue(a2, (const char *)a2);
  if (!result) {
    __break(1u);
  }
  return result;
}

uint64_t sub_1AF93ABC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a4 + a3 - 8);
  uint64_t v5 = *(void *)(v4 - 8);
  double v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = &v11[-v7];
  (*(void (**)(unsigned char *, double))(v5 + 16))(&v11[-v7], v6);
  uint64_t v13 = v4;
  sub_1AF930F5C((uint64_t)v8, (uint64_t)sub_1AF93B5B4, (uint64_t)v12, v4, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v9);
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v5 + 8))(v8, v4);
}

uint64_t RuleContext.value.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v11[2] = a3;
  sub_1AF930F5C(a1, (uint64_t)sub_1AF93B454, (uint64_t)v11, a3, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], a8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a1, a3);
}

void (*RuleContext.value.modify(void *a1, uint64_t a2, AG::swift::metadata *a3))(void **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  uint64_t v6 = *((void *)a3 - 1);
  uint64_t v7 = v6;
  *uint64_t v5 = a3;
  v5[1] = v6;
  size_t v8 = *(void *)(v6 + 64);
  void v5[2] = malloc(v8);
  uint64_t v9 = malloc(v8);
  v5[3] = v9;
  uint64_t OutputValue = AGGraphGetOutputValue(a3, v10);
  if (!OutputValue) {
    __break(1u);
  }
  BOOL v12 = *(void (**)(void *, uint64_t, AG::swift::metadata *))(v7 + 16);
  v5[4] = v12;
  v5[5] = (v7 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  v12(v9, OutputValue, a3);
  return sub_1AF93AEE8;
}

void sub_1AF93AEE8(void **a1, char a2)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (a2)
  {
    uint64_t v4 = (void *)v2[2];
    uint64_t v3 = (void *)v2[3];
    uint64_t v5 = *v2;
    uint64_t v6 = v2[1];
    uint64_t v7 = ((uint64_t (*)(void *, void *, uint64_t))v2[4])(v4, v3, *v2);
    MEMORY[0x1F4188790](v7);
    uint64_t v14 = v5;
    sub_1AF930F5C((uint64_t)v4, (uint64_t)sub_1AF93B5B4, (uint64_t)v13, v5, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v8);
    uint64_t v9 = *(void (**)(void *, uint64_t))(v6 + 8);
    v9(v4, v5);
    v9(v3, v5);
  }
  else
  {
    uint64_t v4 = (void *)v2[2];
    uint64_t v3 = (void *)v2[3];
    uint64_t v10 = *v2;
    uint64_t v11 = v2[1];
    MEMORY[0x1F4188790](a1);
    uint64_t v14 = v10;
    sub_1AF930F5C((uint64_t)v3, (uint64_t)sub_1AF93B5B4, (uint64_t)v13, v10, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC278], v12);
    (*(void (**)(void *, uint64_t))(v11 + 8))(v3, v10);
  }
  free(v3);
  free(v4);
  free(v2);
}

char *RuleContext.subscript.unsafeAddressor(const char *a1, unint64_t a2, uint64_t a3, AG::swift::metadata *a4)
{
  return AGGraphGetInputValue(a2, a1, 0, a4);
}

uint64_t RuleContext.subscript.getter@<X0>(const char *a1@<X0>, unint64_t a2@<X1>, AG::swift::metadata *a3@<X3>, uint64_t a4@<X8>)
{
  Inputunsigned int Value = AGGraphGetInputValue(a2, a1, 0, a3);
  uint64_t v7 = *(uint64_t (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a3 - 1) + 16);
  return v7(a4, InputValue, a3);
}

uint64_t RuleContext.subscript.getter@<X0>(unint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  int Attribute = AGWeakAttributeGetAttribute(a1);
  if (Attribute == 2) {
    int v10 = 0;
  }
  else {
    int v10 = Attribute;
  }
  int v15 = v10;
  BOOL v16 = Attribute == 2;
  v13[2] = a3;
  v13[3] = a4;
  int v14 = a2;
  type metadata accessor for Attribute();
  sub_1AF93CDE8();
  return sub_1AF93A460((void (*)(char *, char *))sub_1AF93B480, (uint64_t)v13, MEMORY[0x1E4FBC248], a4, v11, a5);
}

uint64_t RuleContext.subscript.getter@<X0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (a1 == 2) {
    int v7 = 0;
  }
  else {
    int v7 = a1;
  }
  int v12 = v7;
  BOOL v13 = a1 == 2;
  _OWORD v10[2] = a3;
  v10[3] = a4;
  int v11 = a2;
  type metadata accessor for Attribute();
  sub_1AF93CDE8();
  return sub_1AF93A460((void (*)(char *, char *))sub_1AF93B480, (uint64_t)v10, MEMORY[0x1E4FBC248], a4, v8, a5);
}

uint64_t RuleContext.valueAndFlags<A>(of:options:)(uint64_t a1, const char *a2, uint64_t a3, unint64_t a4, uint64_t a5, AG::swift::metadata *a6)
{
  Inputunsigned int Value = AGGraphGetInputValue(a4, a2, a3, a6);
  uint64_t v10 = v9;
  (*(void (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a6 - 1) + 16))(a1, InputValue, a6);
  return v10;
}

uint64_t RuleContext.changedValue<A>(of:options:)(uint64_t a1, const char *a2, uint64_t a3, unint64_t a4, uint64_t a5, AG::swift::metadata *a6)
{
  Inputunsigned int Value = AGGraphGetInputValue(a4, a2, a3, a6);
  char v10 = v9;
  (*(void (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a6 - 1) + 16))(a1, InputValue, a6);
  return v10 & 1;
}

unsigned int *RuleContext.update(body:)(uint64_t (*a1)(void), int a2, char *a3)
{
  return AGGraphWithUpdate(a3, a1);
}

BOOL static RuleContext.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

BOOL sub_1AF93B3B0(int *a1, int *a2)
{
  return static RuleContext.== infix(_:_:)(*a1, *a2);
}

uint64_t sub_1AF93B3BC@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1AF93B3D4(a1, a2);
}

uint64_t sub_1AF93B3D4@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(AG::swift::metadata **)(v2 + 16);
  Inputunsigned int Value = AGGraphGetInputValue(*(unsigned int *)(v2 + 24), (const char *)*a1, 0, v4);
  return (*(uint64_t (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)v4 - 1) + 16))(a2, InputValue, v4);
}

uint64_t sub_1AF93B454(unsigned __int8 *a1)
{
  return AGGraphSetOutputValue(a1, *(AG::LayoutDescriptor **)(v1 + 16));
}

uint64_t sub_1AF93B480@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1AF93B498(a1, a2);
}

uint64_t sub_1AF93B498@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(AG::swift::metadata **)(v2 + 24);
  Inputunsigned int Value = AGGraphGetInputValue(*(unsigned int *)(v2 + 32), (const char *)*a1, 0, v4);
  return (*(uint64_t (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)v4 - 1) + 16))(a2, InputValue, v4);
}

uint64_t sub_1AF93B51C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1AF93ABC8(a1, a2, a3, a4);
}

uint64_t sub_1AF93B574()
{
  return 8;
}

void *sub_1AF93B580(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

ValueMetadata *type metadata accessor for AnyRuleContext()
{
  return &type metadata for AnyRuleContext;
}

uint64_t type metadata accessor for RuleContext()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t sub_1AF93B5B4(unsigned __int8 *a1)
{
  return sub_1AF93B454(a1);
}

uint64_t static External.comparisonMode.getter()
{
  return 3;
}

uint64_t Focus.root.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*Focus.root.modify())()
{
  return nullsub_1;
}

uint64_t Focus.keyPath.getter()
{
  return swift_retain();
}

uint64_t Focus.keyPath.setter(uint64_t a1)
{
  uint64_t result = swift_release();
  *(void *)(v1 + 8) = a1;
  return result;
}

uint64_t (*Focus.keyPath.modify())()
{
  return nullsub_1;
}

uint64_t Focus.value.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  unsigned int Value = AGGraphGetValue(v7, 0, v8, v9, v10);
  (*(void (**)(char *, char *, uint64_t))(v4 + 16))(v6, Value, a3);
  swift_getAtKeyPath();
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, a3);
}

uint64_t Map.arg.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*Map.arg.modify())()
{
  return nullsub_1;
}

uint64_t Map.body.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t Map.value.getter(uint64_t a1, void (*a2)(char *), uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  unsigned int Value = AGGraphGetValue(v9, 0, v10, (uint64_t)v10, v11);
  (*(void (**)(char *, char *, uint64_t))(v6 + 16))(v8, Value, a4);
  a2(v8);
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, a4);
}

uint64_t sub_1AF93B8BC(uint64_t a1)
{
  uint64_t v2 = *(AG::swift::metadata **)(a1 + 16);
  uint64_t v3 = *((void *)v2 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v5 = (char *)&v11 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = (void (*)(char *))*((void *)v1 + 1);
  unsigned int Value = AGGraphGetValue(*v1, 0, v2, v7, v8);
  (*(void (**)(char *, char *, AG::swift::metadata *))(v3 + 16))(v5, Value, v2);
  v6(v5);
  return (*(uint64_t (**)(char *, AG::swift::metadata *))(v3 + 8))(v5, v2);
}

uint64_t sub_1AF93B9BC(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_retain();
  swift_release();
  return a1;
}

uint64_t sub_1AF93BA00(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_release();
  return a1;
}

uint64_t sub_1AF93BA3C(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t sub_1AF93BA84(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)uint64_t result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t sub_1AF93BAC4()
{
  return swift_release();
}

uint64_t sub_1AF93BACC(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v3;
  swift_retain();
  return a1;
}

uint64_t sub_1AF93BB04(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v3;
  swift_retain();
  swift_release();
  return a1;
}

uint64_t sub_1AF93BB48(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_release();
  return a1;
}

uint64_t sub_1AF93BB84(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 24)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t sub_1AF93BBCC(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)uint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 24) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 24) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t type metadata accessor for Map()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t static PointerOffset.offset(_:)(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(*(void *)(a4 - 8) + 64)) {
    return a1(1);
  }
  else {
    return 0;
  }
}

uint64_t PointerOffset.byteOffset.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*PointerOffset.byteOffset.modify())()
{
  return nullsub_1;
}

uint64_t static PointerOffset.invalidScenePointer()()
{
  return 1;
}

uint64_t static PointerOffset.of(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void v8[2] = a2;
  v8[3] = a3;
  uint64_t v5 = type metadata accessor for PointerOffset();
  sub_1AF932ECC(a1, (uint64_t)sub_1AF93BD30, (uint64_t)v8, a3, MEMORY[0x1E4FBC248], v5, MEMORY[0x1E4FBC278], v6);
  return v8[5];
}

uint64_t sub_1AF93BD30@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result - 1;
  return result;
}

uint64_t static PointerOffset.+ infix<A>(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = __OFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t PointerOffset<>.init()()
{
  return 0;
}

uint64_t static UnsafePointer.+ infix<A>(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 + a2;
}

uint64_t UnsafePointer.subscript.unsafeAddressor(uint64_t a1, uint64_t a2)
{
  return a2 + a1;
}

uint64_t _sSP14AttributeGraphE6offsetqd__AA13PointerOffsetVyxqd__G_tcluig_0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a4, a2 + a1, a3);
}

uint64_t UnsafeMutablePointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 40))(a3 + a2, a1, a5);
}

uint64_t (*UnsafeMutablePointer.subscript.modify())()
{
  return nullsub_1;
}

uint64_t sub_1AF93BDF8@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(*(void *)((char *)a2 + a3 - 8) - 8) + 16))(a4, *a1 + *a2);
}

uint64_t sub_1AF93BE38(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)(*(void *)((char *)a3 + a4 - 8) - 8) + 24))(*a2 + *a3, a1, *(void *)((char *)a3 + a4 - 8));
}

uint64_t sub_1AF93BE80()
{
  return 16;
}

__n128 sub_1AF93BE8C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

unint64_t AnyOptionalAttribute.attribute.getter(unsigned int a1)
{
  if (a1 == 2) {
    uint64_t v1 = 0;
  }
  else {
    uint64_t v1 = a1;
  }
  return v1 | ((unint64_t)(a1 == 2) << 32);
}

uint64_t AnyOptionalAttribute.init(_:)(uint64_t result)
{
  if ((result & 0x100000000) != 0) {
    return 2;
  }
  else {
    return result;
  }
}

unint64_t OptionalAttribute.attribute.getter(unsigned int a1)
{
  if (a1 == 2) {
    uint64_t v1 = 0;
  }
  else {
    uint64_t v1 = a1;
  }
  return v1 | ((unint64_t)(a1 == 2) << 32);
}

uint64_t AnyOptionalAttribute.identifier.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*AnyOptionalAttribute.identifier.modify())()
{
  return nullsub_1;
}

uint64_t AnyOptionalAttribute.init()()
{
  return 2;
}

uint64_t AnyOptionalAttribute.unsafeCast<A>(to:)(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t AnyOptionalAttribute.attribute.setter(uint64_t result)
{
  if ((result & 0x100000000) != 0) {
    int v2 = 2;
  }
  else {
    int v2 = result;
  }
  *uint64_t v1 = v2;
  return result;
}

uint64_t (*AnyOptionalAttribute.attribute.modify(uint64_t a1))()
{
  *(void *)a1 = v1;
  int v2 = *v1;
  *(_DWORD *)(a1 + 16) = 2;
  BOOL v3 = v2 == 2;
  if (v2 == 2) {
    int v2 = 0;
  }
  *(_DWORD *)(a1 + 8) = v2;
  char v4 = v3;
  *(unsigned char *)(a1 + 12) = v4;
  return sub_1AF93BFDC;
}

uint64_t AnyOptionalAttribute.map<A>(_:)@<X0>(void (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  if (a2 == 2)
  {
    uint64_t v6 = 1;
  }
  else
  {
    a1(a2);
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56);
  return v7(a4, v6, 1, a3);
}

BOOL static AnyOptionalAttribute.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

uint64_t AnyOptionalAttribute.hash(into:)()
{
  return sub_1AF93CEF8();
}

uint64_t AnyOptionalAttribute.description.getter(int a1)
{
  if (a1 == 2) {
    return 7104878;
  }
  else {
    return AGAttribute.description.getter();
  }
}

uint64_t AnyOptionalAttribute.hashValue.getter()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF93C140()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF93C188()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF93C1CC()
{
  return AnyOptionalAttribute.description.getter(*v0);
}

uint64_t OptionalAttribute.base.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*OptionalAttribute.base.modify())()
{
  return nullsub_1;
}

uint64_t OptionalAttribute.init()()
{
  return 2;
}

uint64_t OptionalAttribute.init(_:)(uint64_t result)
{
  if ((result & 0x100000000) != 0) {
    return 2;
  }
  else {
    return result;
  }
}

uint64_t OptionalAttribute.attribute.setter(uint64_t result)
{
  if ((result & 0x100000000) != 0) {
    int v2 = 2;
  }
  else {
    int v2 = result;
  }
  *uint64_t v1 = v2;
  return result;
}

uint64_t (*OptionalAttribute.attribute.modify(uint64_t a1))()
{
  *(void *)a1 = v1;
  int v2 = *v1;
  *(_DWORD *)(a1 + 16) = 2;
  BOOL v3 = v2 == 2;
  if (v2 == 2) {
    int v2 = 0;
  }
  *(_DWORD *)(a1 + 8) = v2;
  char v4 = v3;
  *(unsigned char *)(a1 + 12) = v4;
  return sub_1AF93BFDC;
}

uint64_t sub_1AF93C294(uint64_t result)
{
  uint64_t v1 = (_DWORD *)(result + 8);
  if (*(unsigned char *)(result + 12)) {
    uint64_t v1 = (_DWORD *)(result + 16);
  }
  **(_DWORD **)__n128 result = *v1;
  return result;
}

uint64_t OptionalAttribute.value.getter@<X0>(unint64_t a1@<X0>, AG::swift::metadata *a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a1 == 2)
  {
    uint64_t v7 = *((void *)a2 - 1);
    uint64_t v8 = 1;
  }
  else
  {
    unsigned int Value = AGGraphGetValue(a1, 0, a2, a3, a4);
    uint64_t v12 = *((void *)a2 - 1);
    (*(void (**)(uint64_t, char *, AG::swift::metadata *))(v12 + 16))(a5, Value, a2);
    uint64_t v7 = v12;
    uint64_t v8 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, AG::swift::metadata *))(v7 + 56);
  return v10(a5, v8, 1, a2);
}

uint64_t OptionalAttribute.changedValue(options:)@<X0>(const char *a1@<X0>, unint64_t a2@<X1>, AG::swift::metadata *a3@<X2>, uint64_t a4@<X8>)
{
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
  uint64_t v11 = TupleTypeMetadata2;
  if (a2 == 2)
  {
    uint64_t v12 = 1;
  }
  else
  {
    uint64_t v13 = *(int *)(TupleTypeMetadata2 + 48);
    unsigned int Value = AGGraphGetValue(a2, a1, a3, v9, v10);
    char v16 = v15;
    (*(void (**)(uint64_t, char *, AG::swift::metadata *))(*((void *)a3 - 1) + 16))(a4, Value, a3);
    uint64_t v12 = 0;
    *(unsigned char *)(a4 + v13) = v16 & 1;
  }
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56);
  return v17(a4, v12, 1, v11);
}

uint64_t OptionalAttribute.map<A>(_:)@<X0>(void (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X4>, uint64_t a4@<X8>)
{
  if (a2 == 2)
  {
    uint64_t v6 = 1;
  }
  else
  {
    a1(a2);
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56);
  return v7(a4, v6, 1, a3);
}

uint64_t OptionalAttribute.wrappedValue.getter@<X0>(unint64_t a1@<X0>, AG::swift::metadata *a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a1 == 2)
  {
    uint64_t v7 = *((void *)a2 - 1);
    uint64_t v8 = 1;
  }
  else
  {
    unsigned int Value = AGGraphGetValue(a1, 0, a2, a3, a4);
    uint64_t v12 = *((void *)a2 - 1);
    (*(void (**)(uint64_t, char *, AG::swift::metadata *))(v12 + 16))(a5, Value, a2);
    uint64_t v7 = v12;
    uint64_t v8 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, AG::swift::metadata *))(v7 + 56);
  return v10(a5, v8, 1, a2);
}

unint64_t OptionalAttribute.projectedValue.getter(unsigned int a1)
{
  if (a1 == 2) {
    uint64_t v1 = 0;
  }
  else {
    uint64_t v1 = a1;
  }
  return v1 | ((unint64_t)(a1 == 2) << 32);
}

uint64_t OptionalAttribute.projectedValue.setter(uint64_t result)
{
  if ((result & 0x100000000) != 0) {
    int v2 = 2;
  }
  else {
    int v2 = result;
  }
  *uint64_t v1 = v2;
  return result;
}

uint64_t (*OptionalAttribute.projectedValue.modify(uint64_t a1))(uint64_t result)
{
  *(void *)a1 = v1;
  int v2 = *v1;
  *(_DWORD *)(a1 + 16) = 2;
  BOOL v3 = v2 == 2;
  if (v2 == 2) {
    int v2 = 0;
  }
  *(_DWORD *)(a1 + 8) = v2;
  char v4 = v3;
  *(unsigned char *)(a1 + 12) = v4;
  return sub_1AF93C294;
}

unint64_t OptionalAttribute.subscript.getter(void *a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a2 == 2)
  {
    unsigned int OffsetAttribute2 = 0;
  }
  else
  {
    uint64_t v5 = *a1;
    uint64_t v6 = (const char *)sub_1AF93CE08();
    if (v7)
    {
      int v15 = a2;
      char v16 = a1;
      MEMORY[0x1F4188790](v6);
      v11[2] = *(void *)(v5 + *MEMORY[0x1E4FBC5F0] + 8);
      uint64_t v12 = type metadata accessor for Focus();
      uint64_t WitnessTable = swift_getWitnessTable();
      uint64_t v8 = type metadata accessor for Attribute();
      swift_retain();
      sub_1AF930F5C((uint64_t)&v15, (uint64_t)sub_1AF931890, (uint64_t)v11, v12, MEMORY[0x1E4FBC248], v8, MEMORY[0x1E4FBC278], v9);
      swift_release();
      unsigned int OffsetAttribute2 = v14;
    }
    else
    {
      unsigned int OffsetAttribute2 = AGGraphCreateOffsetAttribute2(a2, v6, *(void *)(*(void *)(*(void *)(*MEMORY[0x1E4FBC5F0] + v5 + 8) - 8) + 64));
    }
  }
  return OffsetAttribute2 | ((unint64_t)(a2 == 2) << 32);
}

BOOL static OptionalAttribute.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

uint64_t OptionalAttribute.hash(into:)()
{
  return sub_1AF93CEF8();
}

uint64_t OptionalAttribute.description.getter(uint64_t a1)
{
  if (a1 == 2) {
    return 7104878;
  }
  else {
    return Attribute.description.getter(a1);
  }
}

uint64_t OptionalAttribute.hashValue.getter()
{
  return sub_1AF93CF08();
}

uint64_t sub_1AF93C9DC()
{
  return OptionalAttribute.hashValue.getter();
}

uint64_t sub_1AF93C9E4()
{
  return OptionalAttribute.description.getter(*v0);
}

unint64_t sub_1AF93C9F8()
{
  unint64_t result = qword_1E9AF0738;
  if (!qword_1E9AF0738)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9AF0738);
  }
  return result;
}

uint64_t sub_1AF93CA4C()
{
  return swift_getWitnessTable();
}

int *sub_1AF93CA68@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v2 = *result;
  BOOL v3 = *result == 2;
  if (*result == 2) {
    int v2 = 0;
  }
  *(_DWORD *)a2 = v2;
  *(unsigned char *)(a2 + 4) = v3;
  return result;
}

uint64_t sub_1AF93CA90(uint64_t result, int *a2)
{
  if (*(unsigned char *)(result + 4)) {
    int v2 = &AGAttributeNil;
  }
  else {
    int v2 = (int *)result;
  }
  *a2 = *v2;
  return result;
}

int *sub_1AF93CAB0@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v2 = *result;
  BOOL v3 = *result == 2;
  if (*result == 2) {
    int v2 = 0;
  }
  *(_DWORD *)a2 = v2;
  *(unsigned char *)(a2 + 4) = v3;
  return result;
}

uint64_t sub_1AF93CAD8(uint64_t result, int *a2)
{
  if (*(unsigned char *)(result + 4)) {
    int v2 = &AGAttributeNil;
  }
  else {
    int v2 = (int *)result;
  }
  *a2 = *v2;
  return result;
}

uint64_t sub_1AF93CAF8()
{
  return 8;
}

void *sub_1AF93CB04(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1AF93CB10(uint64_t result, int *a2)
{
  if (*(unsigned char *)(result + 4)) {
    int v2 = &AGAttributeNil;
  }
  else {
    int v2 = (int *)result;
  }
  *a2 = *v2;
  return result;
}

uint64_t sub_1AF93CB30()
{
  return 8;
}

ValueMetadata *type metadata accessor for AnyOptionalAttribute()
{
  return &type metadata for AnyOptionalAttribute;
}

void AG::data::table::table(void **a1, void **a2)
{
  BOOL v3 = *a1;
  if (v3) {
    free(v3);
  }
  char v4 = *a2;
  if (*a2)
  {
    free(v4);
  }
}

void util::UntypedTable::create_buckets()
{
}

void AG::anonymous namespace'::blocking_read()
{
  __assert_rtn("blocking_read", "ag-debug-server.mm", 42, "errno != EAGAIN && errno != EWOULDBLOCK");
}

void AG::anonymous namespace'::blocking_write()
{
  __assert_rtn("blocking_write", "ag-debug-server.mm", 66, "errno != EAGAIN && errno != EWOULDBLOCK");
}

void AG::non_fatal_precondition_failure(uint64_t *a1, NSObject *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  int v3 = 136315138;
  uint64_t v4 = v2;
  _os_log_fault_impl(&dword_1AF901000, a2, OS_LOG_TYPE_FAULT, "precondition failure: %s", (uint8_t *)&v3, 0xCu);
}

uint64_t sub_1AF93CCA8()
{
  return MEMORY[0x1F40E4550]();
}

uint64_t sub_1AF93CCB8()
{
  return MEMORY[0x1F40E4938]();
}

uint64_t sub_1AF93CCC8()
{
  return MEMORY[0x1F40E4B80]();
}

uint64_t sub_1AF93CCD8()
{
  return MEMORY[0x1F40E4DA8]();
}

uint64_t sub_1AF93CCE8()
{
  return MEMORY[0x1F40E4E10]();
}

uint64_t sub_1AF93CD08()
{
  return MEMORY[0x1F4186968]();
}

uint64_t sub_1AF93CD18()
{
  return MEMORY[0x1F4186978]();
}

uint64_t sub_1AF93CD28()
{
  return MEMORY[0x1F40E6000]();
}

uint64_t sub_1AF93CD38()
{
  return MEMORY[0x1F41835D0]();
}

uint64_t sub_1AF93CD58()
{
  return MEMORY[0x1F4183838]();
}

uint64_t sub_1AF93CD68()
{
  return MEMORY[0x1F40E6190]();
}

uint64_t sub_1AF93CD78()
{
  return MEMORY[0x1F40E61B8]();
}

uint64_t sub_1AF93CD88()
{
  return MEMORY[0x1F40E61C8]();
}

uint64_t sub_1AF93CD98()
{
  return MEMORY[0x1F40E61D8]();
}

uint64_t sub_1AF93CDA8()
{
  return MEMORY[0x1F4183880]();
}

uint64_t sub_1AF93CDB8()
{
  return MEMORY[0x1F41839B0]();
}

uint64_t sub_1AF93CDC8()
{
  return MEMORY[0x1F4183A38]();
}

uint64_t sub_1AF93CDD8()
{
  return MEMORY[0x1F4183C18]();
}

uint64_t sub_1AF93CDE8()
{
  return MEMORY[0x1F4184640]();
}

uint64_t sub_1AF93CDF8()
{
  return MEMORY[0x1F4184978]();
}

uint64_t sub_1AF93CE08()
{
  return MEMORY[0x1F41849A0]();
}

uint64_t sub_1AF93CE28()
{
  return MEMORY[0x1F4184CE8]();
}

uint64_t sub_1AF93CE38()
{
  return MEMORY[0x1F41852A0]();
}

uint64_t sub_1AF93CE48()
{
  return MEMORY[0x1F4185380]();
}

uint64_t sub_1AF93CE58()
{
  return MEMORY[0x1F4185450]();
}

uint64_t sub_1AF93CE68()
{
  return MEMORY[0x1F4185758]();
}

uint64_t sub_1AF93CE78()
{
  return MEMORY[0x1F4185A30]();
}

uint64_t sub_1AF93CE88()
{
  return MEMORY[0x1F4185A40]();
}

uint64_t sub_1AF93CE98()
{
  return MEMORY[0x1F4185D68]();
}

uint64_t sub_1AF93CEA8()
{
  return MEMORY[0x1F4185E90]();
}

uint64_t sub_1AF93CEB8()
{
  return MEMORY[0x1F4185E98]();
}

uint64_t sub_1AF93CED8()
{
  return MEMORY[0x1F4185EB0]();
}

uint64_t sub_1AF93CEE8()
{
  return MEMORY[0x1F4185EC8]();
}

uint64_t sub_1AF93CEF8()
{
  return MEMORY[0x1F4185EE0]();
}

uint64_t sub_1AF93CF08()
{
  return MEMORY[0x1F4185EF8]();
}

uint64_t sub_1AF93CF28()
{
  return MEMORY[0x1F40E6EB0]();
}

uint64_t sub_1AF93CF38()
{
  return MEMORY[0x1F40E6EB8]();
}

uint64_t sub_1AF93CF48()
{
  return MEMORY[0x1F40E6EC0]();
}

uint64_t sub_1AF93CF68()
{
  return MEMORY[0x1F4186310]();
}

uint64_t sub_1AF93CF78()
{
  return MEMORY[0x1F4186318]();
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x1F40C9738](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x1F40C9740](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C9748](c, data, *(void *)&len);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7808](allocator, capacity);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1F40D7858](theData);
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B8]();
}

CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context)
{
  return (CFRunLoopObserverRef)MEMORY[0x1F40D80D8](allocator, activities, repeats, order, callout, context);
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1F40D8500](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D8888](allocator, URLBytes, length, *(void *)&encoding, baseURL);
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1F40E7010](aClassName);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x1F40E72C8]();
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

std::string *__cdecl std::string::append(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  return (std::string *)MEMORY[0x1F417E5D0](this, __n, __c);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1F40C9B60](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x1F40C9B68](*(void *)&a1, a2, *(void *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

uint64_t _dyld_images_for_addresses()
{
  return MEMORY[0x1F40C9E68]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1F40CA200](*(void *)&a1, a2, a3);
}

uint32_t arc4random(void)
{
  return MEMORY[0x1F40CA3A8]();
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1F40CA440](a1, a2);
}

int atexit_b(void *a1)
{
  return MEMORY[0x1F40CA490](a1);
}

int atoi(const char *a1)
{
  return MEMORY[0x1F40CA4A8](a1);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1F40CA4F8](a1, *(void *)&a2);
}

void backtrace_image_offsets(void *const *array, image_offset *image_offsets, int size)
{
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1F40CA530](*(void *)&a1, a2, *(void *)&a3);
}

void bzero(void *a1, size_t a2)
{
}

Ivar *__cdecl class_copyIvarList(Class cls, unsigned int *outCount)
{
  return (Ivar *)MEMORY[0x1F41814E8](cls, outCount);
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1F40CBDA0](a1, a2);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1F40CC058](*(void *)&a1, *(void *)&a2);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1F40CC1F0](a1, a2);
}

void free(void *a1)
{
}

void freeifaddrs(ifaddrs *a1)
{
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

int getifaddrs(ifaddrs **a1)
{
  return MEMORY[0x1F40CC410](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1F40CC558](*(void *)&a1, a2, a3);
}

int gzclose(gzFile file)
{
  return MEMORY[0x1F4182C20](file);
}

gzFile gzopen(const char *a1, const char *a2)
{
  return (gzFile)MEMORY[0x1F4182C60](a1, a2);
}

int gzwrite(gzFile file, voidpc buf, unsigned int len)
{
  return MEMORY[0x1F4182CA0](file, buf, *(void *)&len);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x1F40CC678](*(void *)&a1, a2, a3, *(void *)&a4);
}

ptrdiff_t ivar_getOffset(Ivar v)
{
  return MEMORY[0x1F41815C0](v);
}

int listen(int a1, int a2)
{
  return MEMORY[0x1F40CC840](*(void *)&a1, *(void *)&a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1F40CC9B8](*(void *)&task, *(void *)&name);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

kern_return_t mach_vm_region(vm_map_read_t target_task, mach_vm_address_t *address, mach_vm_size_t *size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t *infoCnt, mach_port_t *object_name)
{
  return MEMORY[0x1F40CCAA8](*(void *)&target_task, address, size, *(void *)&flavor, info, infoCnt, object_name);
}

int madvise(void *a1, size_t a2, int a3)
{
  return MEMORY[0x1F40CCB08](a1, a2, *(void *)&a3);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x1F40CCB10](__size);
}

malloc_zone_t *__cdecl malloc_create_zone(vm_size_t start_size, unsigned int flags)
{
  return (malloc_zone_t *)MEMORY[0x1F40CCB20](start_size, *(void *)&flags);
}

size_t malloc_good_size(size_t size)
{
  return MEMORY[0x1F40CCB58](size);
}

void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
{
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1F40CCB80](ptr);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

void *__cdecl malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBC0](zone, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int mprotect(void *a1, size_t a2, int a3)
{
  return MEMORY[0x1F40CCE58](a1, a2, *(void *)&a3);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_enumerationMutation(id obj)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F4181798](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t self
{
  return MEMORY[0x1F41817D0]();
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C8](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x1F40CD5F0](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1F40CD650]();
}

void perror(const char *a1)
{
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1F40CDA40](a1, a2);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1F40CDC50](*(void *)&a1, a2, a3);
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return MEMORY[0x1F40CDED8](*(void *)&a1, a2, a3, a4, a5);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x1F40CDFC0](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, *(void *)&a5);
}

int snprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  return MEMORY[0x1F40CE088](a1, a2, a3, a4);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x1F40CE090](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1F40CE138](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1F40CE170](__s, __charset);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

size_t strspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1F40CE250](__s, __charset);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2A0](__str, __endptr, *(void *)&__base);
}

uint64_t swift_allocObject()
{
  return MEMORY[0x1F41863E8]();
}

uint64_t swift_bridgeObjectRelease()
{
  return MEMORY[0x1F4186440]();
}

uint64_t swift_bridgeObjectRelease_n()
{
  return MEMORY[0x1F4186448]();
}

uint64_t swift_bridgeObjectRetain()
{
  return MEMORY[0x1F4186450]();
}

uint64_t swift_conformsToProtocol()
{
  return MEMORY[0x1F4186470]();
}

uint64_t swift_dynamicCast()
{
  return MEMORY[0x1F41864B8]();
}

uint64_t swift_errorRelease()
{
  return MEMORY[0x1F4186528]();
}

uint64_t swift_getAssociatedTypeWitness()
{
  return MEMORY[0x1F4186540]();
}

uint64_t swift_getAtKeyPath()
{
  return MEMORY[0x1F4186550]();
}

uint64_t swift_getForeignTypeMetadata()
{
  return MEMORY[0x1F41865A8]();
}

uint64_t swift_getGenericMetadata()
{
  return MEMORY[0x1F41865E0]();
}

uint64_t swift_getObjCClassMetadata()
{
  return MEMORY[0x1F4186608]();
}

uint64_t swift_getTupleTypeMetadata()
{
  return MEMORY[0x1F4186648]();
}

uint64_t swift_getTupleTypeMetadata2()
{
  return MEMORY[0x1F4186650]();
}

uint64_t swift_getTypeByMangledNameInContext()
{
  return MEMORY[0x1F4186660]();
}

uint64_t swift_getTypeByMangledNameInContext2()
{
  return MEMORY[0x1F4186668]();
}

uint64_t swift_getTypeByMangledNameInContextInMetadataState2()
{
  return MEMORY[0x1F4186670]();
}

uint64_t swift_getTypeName()
{
  return MEMORY[0x1F4186678]();
}

uint64_t swift_getWitnessTable()
{
  return MEMORY[0x1F4186680]();
}

uint64_t swift_initStackObject()
{
  return MEMORY[0x1F41866A8]();
}

uint64_t swift_isUniquelyReferencedNonObjC()
{
  return MEMORY[0x1F41866E0]();
}

uint64_t swift_once()
{
  return MEMORY[0x1F4186728]();
}

uint64_t swift_release()
{
  return MEMORY[0x1F4186758]();
}

uint64_t swift_retain()
{
  return MEMORY[0x1F4186770]();
}

uint64_t swift_slowAlloc()
{
  return MEMORY[0x1F4186798]();
}

uint64_t swift_slowDealloc()
{
  return MEMORY[0x1F41867A0]();
}

uint64_t swift_unknownObjectRelease()
{
  return MEMORY[0x1F41867E0]();
}

uint64_t swift_willThrow()
{
  return MEMORY[0x1F41868E0]();
}

int unlink(const char *a1)
{
  return MEMORY[0x1F40CE5E0](a1);
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x1F40CE630](uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

int uuid_is_null(const uuid_t uu)
{
  return MEMORY[0x1F40CE658](uu);
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x1F40CE680](a1, a2, a3);
}

kern_return_t vm_remap(vm_map_t target_task, vm_address_t *target_address, vm_size_t size, vm_address_t mask, int flags, vm_map_t src_task, vm_address_t src_address, BOOLean_t copy, vm_prot_t *cur_protection, vm_prot_t *max_protection, vm_inherit_t inheritance)
{
  return MEMORY[0x1F40CE700](*(void *)&target_task, target_address, size, mask, *(void *)&flags, *(void *)&src_task, src_address, *(void *)&copy);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1F40CE790](__str, __size, __format, a4);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x1F40CE8B0](__s, *(void *)&__c, __n);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}