char *TtTrkRpnNode::TtTrkRpnNode(char *a1, void *a2)
{
  _OWORD *v4;

  v4 = a1 + 536;
  bzero(a1, 0x218uLL);
  *a2 = 0x721CC00000001;
  *v4 = 0u;
  return a1;
}

uint64_t TtTrkRpnNode::releaseBuffers(TtTrkRpnNode *this)
{
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    MEMORY[0x1A62562A0](v2, 0x1000C80451B5BE8);
  }
  uint64_t v3 = *((void *)this + 56);
  if (v3) {
    MEMORY[0x1A62562A0](v3, 0x1000C80451B5BE8);
  }
  uint64_t v4 = *((void *)this + 57);
  if (v4) {
    MEMORY[0x1A62562A0](v4, 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 58);
  if (v5) {
    MEMORY[0x1A62562A0](v5, 0x1000C8052888210);
  }
  uint64_t v6 = *((void *)this + 59);
  if (v6) {
    MEMORY[0x1A62562A0](v6, 0x1000C8052888210);
  }
  uint64_t v7 = *((void *)this + 60);
  if (v7) {
    MEMORY[0x1A62562A0](v7, 0x1000C8052888210);
  }
  uint64_t v8 = *((void *)this + 67);
  if (v8) {
    MEMORY[0x1A62562A0](v8, 0x1000C8052888210);
  }
  uint64_t result = *((void *)this + 68);
  if (result)
  {
    JUMPOUT(0x1A62562A0);
  }
  return result;
}

void TtTrkRpnNode::~TtTrkRpnNode(TtTrkRpnNode *this)
{
}

uint64_t TtTrkRpnNode::init(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  if (*a3 == 1)
  {
    if (a3[1] - 467393 <= 0xB && ((1 << (*((unsigned char *)a3 + 4) + 63)) & 0xB01) != 0)
    {
      TtTrkRpnNode::releaseBuffers((TtTrkRpnNode *)a1);
      *(void *)(a1 + 20) = 0x800000013;
      *(void *)(a1 + 28) = 0x4100000000000001;
      *(_DWORD *)(a1 + 52) = 5;
      *(_OWORD *)(a1 + 56) = xmmword_1A410A010;
      *(_OWORD *)(a1 + 132) = xmmword_1A410A020;
      *(void *)(a1 + 260) = 0x1400000013;
      *(_DWORD *)(a1 + 268) = 10;
      *(_OWORD *)(a1 + 148) = xmmword_1A410A030;
      *(_OWORD *)(a1 + 164) = xmmword_1A410A040;
      *(_DWORD *)(a1 + 336) = 6;
      *(_OWORD *)(a1 + 244) = xmmword_1A410A050;
      *(_OWORD *)(a1 + 72) = xmmword_1A410A060;
      *(_OWORD *)(a1 + 116) = xmmword_1A410A070;
      *(_OWORD *)(a1 + 88) = xmmword_1A410A080;
      *(void *)(a1 + 104) = 0x3E4CCCCD3BB60B61;
      *(_DWORD *)(a1 + 112) = 1069547520;
      a3[1] = 467393;
      *((_WORD *)a3 + 928) = 0;
      *(_OWORD *)(a3 + 459) = 0u;
      *(_WORD *)((char *)a3 + 1861) = 0;
      *(_OWORD *)(a3 + 393) = 0u;
      *(_OWORD *)(a3 + 397) = 0u;
      *(_OWORD *)(a3 + 401) = 0u;
      *(_OWORD *)(a3 + 405) = 0u;
      *(_OWORD *)(a3 + 409) = 0u;
      *(_OWORD *)(a3 + 413) = 0u;
      *(_OWORD *)(a3 + 417) = 0u;
      *(_OWORD *)(a3 + 421) = 0u;
      *(_OWORD *)(a3 + 425) = 0u;
      *(_OWORD *)(a3 + 429) = 0u;
      *(_OWORD *)(a3 + 433) = 0u;
      *(_OWORD *)(a3 + 437) = 0u;
      *(_OWORD *)(a3 + 441) = 0u;
      *(_OWORD *)(a3 + 445) = 0u;
      *(_OWORD *)(a3 + 449) = 0u;
      int v6 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 20);
      a3[455] = 1065353216;
      int v7 = v6 * *(_DWORD *)(a1 + 28);
      a3[463] = 0;
      *(_DWORD *)(a1 + 436) = v7 * *(_DWORD *)(a1 + 52);
      operator new[]();
    }
    return 4294967292;
  }
  else
  {
    uint64_t v8 = rtcv::LoggerDevNull::instance((rtcv::LoggerDevNull *)a1);
    v9 = (FILE *)rtcv::LoggerDevNull::devNull((rtcv::LoggerDevNull *)v8);
    v10 = (rtcv::Logger *)fprintf(v9, "Incorrect trk node state version (%u vs %u)\n", *a3, 1);
    v11 = rtcv::Logger::instance(v10);
    int v17 = 1;
    rtcv::Logger::log<(rtcv::Logger::Severity)3,unsigned int &,int>((uint64_t)v11, (uint64_t)"Incorrect trk node state version (%u vs %u)\n", a3, (uint64_t)&v17, v12, v13, v14, v15);
    return 4294967289;
  }
}

void rtcv::Logger::log<(rtcv::Logger::Severity)3,unsigned int &,int>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned __int8 *)(a1 + 192) >= 3u)
  {
    uint64_t v8 = *(uint64_t **)(a1 + 72);
    v9 = *(uint64_t **)(a1 + 80);
    while (v8 != v9)
    {
      uint64_t v12 = *v8;
      v8 += 2;
      rtcv::Logger::Target::log(v12, 3, a2, a4, a5, a6, a7, a8, *a3);
    }
  }
}

uint64_t TtTrkRpnNode::PopulateAnchorBoxes(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 52);
  if (v1)
  {
    uint64_t v2 = 0;
    int v3 = 0;
    unsigned int v5 = *(_DWORD *)(this + 20);
    int v4 = *(_DWORD *)(this + 24);
    unsigned int v6 = v5 >> 1;
    uint64_t v7 = *(unsigned int *)(this + 28);
    do
    {
      if (v7)
      {
        uint64_t v8 = 0;
        float v9 = *(float *)(this + 4 * v2 + 56);
        v10.f32[0] = (float)(int)sqrtf((float)(v4 * v4) / v9);
        v10.f32[1] = (float)(int)(float)(v9 * v10.f32[0]);
        do
        {
          if (v5)
          {
            int v11 = 0;
            uint64_t v12 = *(void *)(this + 440);
            float32x2_t v13 = vcvt_f32_s32(vcvt_s32_f32(vmul_n_f32(v10, *(float *)(this + 4 * v8 + 32))));
            do
            {
              int v14 = 0;
              int v15 = -(v4 * v6);
              do
              {
                v16 = (float32x2_t *)(v12 + 16 * (v3 + v14));
                v16->f32[0] = (float)v15;
                v16->f32[1] = (float)(int)((v11 - v6) * v4);
                v16[1] = v13;
                ++v14;
                v15 += v4;
              }
              while (v5 != v14);
              ++v11;
              v3 += v14;
            }
            while (v11 != v5);
          }
          ++v8;
        }
        while (v8 != v7);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return this;
}

void TtTrkRpnNode::PopulatePenaltyMatrix(TtTrkRpnNode *this)
{
}

uint64_t TtTrkRpnNode::restart(rtcv::LoggerDevNull *a1, unsigned int *a2)
{
  if (*a2 == 1)
  {
    if (a2[1] - 467393 <= 9 && ((1 << (*((unsigned char *)a2 + 4) + 63)) & 0x301) != 0)
    {
      uint64_t result = 0;
      a2[455] = 1065353216;
      *(_OWORD *)(a2 + 459) = 0u;
      *(_WORD *)((char *)a2 + 1861) = 0;
      *((_WORD *)a2 + 928) = 0;
      a2[463] = 0;
      *(_OWORD *)(a2 + 393) = 0u;
      *(_OWORD *)(a2 + 397) = 0u;
      *(_OWORD *)(a2 + 401) = 0u;
      *(_OWORD *)(a2 + 405) = 0u;
      *(_OWORD *)(a2 + 409) = 0u;
      *(_OWORD *)(a2 + 413) = 0u;
      *(_OWORD *)(a2 + 417) = 0u;
      *(_OWORD *)(a2 + 421) = 0u;
      *(_OWORD *)(a2 + 425) = 0u;
      *(_OWORD *)(a2 + 429) = 0u;
      *(_OWORD *)(a2 + 433) = 0u;
      *(_OWORD *)(a2 + 437) = 0u;
      *(_OWORD *)(a2 + 441) = 0u;
      *(_OWORD *)(a2 + 445) = 0u;
      *(_OWORD *)(a2 + 449) = 0u;
      return result;
    }
  }
  else
  {
    unsigned int v5 = rtcv::LoggerDevNull::instance(a1);
    unsigned int v6 = (FILE *)rtcv::LoggerDevNull::devNull((rtcv::LoggerDevNull *)v5);
    uint64_t v7 = (rtcv::Logger *)fprintf(v6, "Incorrect trk node state version (%u vs %u)\n", *a2, 1);
    uint64_t v8 = rtcv::Logger::instance(v7);
    int v13 = 1;
    rtcv::Logger::log<(rtcv::Logger::Severity)3,unsigned int &,int>((uint64_t)v8, (uint64_t)"Incorrect trk node state version (%u vs %u)\n", a2, (uint64_t)&v13, v9, v10, v11, v12);
  }
  return 4294967289;
}

uint64_t TtTrkRpnNode::exemplarPreProcess(uint64_t a1, uint64_t a2, long long *a3, int *a4, _DWORD *a5, uint64_t a6)
{
  v11.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  if (*a5 != 1)
  {
    v19 = rtcv::LoggerDevNull::instance((rtcv::LoggerDevNull *)v11.__d_.__rep_);
    v20 = (FILE *)rtcv::LoggerDevNull::devNull((rtcv::LoggerDevNull *)v19);
    v21 = (rtcv::Logger *)fprintf(v20, "Incorrect trk node state version (%u vs %u)\n", *a5, 1);
    v22 = rtcv::Logger::instance(v21);
    int v27 = 1;
    rtcv::Logger::log<(rtcv::Logger::Severity)3,unsigned int &,int>((uint64_t)v22, (uint64_t)"Incorrect trk node state version (%u vs %u)\n", a5, (uint64_t)&v27, v23, v24, v25, v26);
    return 4294967289;
  }
  if (a5[1] != 467393) {
    return 4294967289;
  }
  int v12 = *a4;
  if (*a4)
  {
    long long v13 = *a3;
    *(_OWORD *)(a5 + 6) = a3[1];
    *(_OWORD *)(a5 + 2) = v13;
    long long v14 = a3[2];
    long long v15 = a3[3];
    long long v16 = a3[4];
    *((void *)a5 + 11) = *((void *)a3 + 10);
    *(_OWORD *)(a5 + 18) = v16;
    *(_OWORD *)(a5 + 14) = v15;
    *(_OWORD *)(a5 + 10) = v14;
    LOBYTE(v12) = 1;
    *(unsigned char *)(a6 + 81) = 1;
    *(void *)&long long v16 = *((void *)a5 + 3);
    float v17 = vaddv_f32(*(float32x2_t *)&v16);
    *(float *)&long long v14 = roundf(sqrtf((float)(*(float *)&v16 + (float)(*(float *)(a1 + 88) * v17))* (float)(*((float *)&v16 + 1) + (float)(*(float *)(a1 + 88) * v17))));
    *((float32x2_t *)a5 + 12) = vmla_n_f32(vmla_f32(*(float32x2_t *)(a5 + 4), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)&v16), (float32x2_t)0xBF000000BF000000, *(float *)&v14);
    a5[26] = v14;
    a5[27] = v14;
  }
  uint64_t result = 0;
  *((unsigned char *)a5 + 1856) = v12;
  a5[1] = 467402;
  return result;
}

uint64_t TtTrkRpnNode::instancePreProcess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float32x2_t *a5, uint64_t a6)
{
  v9.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  if (a5->i32[0] != 1)
  {
    v18 = rtcv::LoggerDevNull::instance((rtcv::LoggerDevNull *)v9.__d_.__rep_);
    v19 = (FILE *)rtcv::LoggerDevNull::devNull((rtcv::LoggerDevNull *)v18);
    v20 = (rtcv::Logger *)fprintf(v19, "Incorrect trk node state version (%u vs %u)\n", a5->i32[0], 1);
    v21 = rtcv::Logger::instance(v20);
    int v26 = 1;
    rtcv::Logger::log<(rtcv::Logger::Severity)3,unsigned int &,int>((uint64_t)v21, (uint64_t)"Incorrect trk node state version (%u vs %u)\n", (unsigned int *)a5, (uint64_t)&v26, v22, v23, v24, v25);
    return 4294967289;
  }
  if (a5->i32[1] != 467393) {
    return 4294967289;
  }
  char v10 = a5[232].i8[0];
  if (v10)
  {
    char v10 = 1;
    *(unsigned char *)(a6 + 80) = 1;
    unsigned int v11 = *(_DWORD *)(a1 + 144);
    float32x2_t v12 = a5[3];
    float v13 = vaddv_f32(v12);
    float v14 = a5[227].f32[1]
        * sqrtf((float)(v12.f32[0] + (float)(*(float *)(a1 + 88) * v13))* (float)(v12.f32[1] + (float)(*(float *)(a1 + 88) * v13)));
    float v15 = (float)v11 / v14;
    float v16 = v14 + (float)((float)((float)((float)(*(_DWORD *)(a1 + 132) - v11) * 0.5) / v15) * 2.0);
    a5[14] = vmla_n_f32(vmla_f32(a5[2], (float32x2_t)0x3F0000003F000000, v12), (float32x2_t)0xBF000000BF000000, v16);
    a5[15].f32[0] = v16;
    a5[15].f32[1] = v16;
    a5[228].f32[0] = v15;
    a5[3] = vmul_n_f32(v12, v15);
  }
  uint64_t result = 0;
  a5[232].i8[1] = v10;
  a5->i32[1] = 467401;
  return result;
}

uint64_t TtTrkRpnNode::exemplarPostProcess(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int *a5)
{
  unsigned int v27 = a3;
  v7.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  if (*a5 != 1)
  {
    v18 = rtcv::LoggerDevNull::instance((rtcv::LoggerDevNull *)v7.__d_.__rep_);
    v19 = (FILE *)rtcv::LoggerDevNull::devNull((rtcv::LoggerDevNull *)v18);
    v20 = (rtcv::Logger *)fprintf(v19, "Incorrect trk node state version (%u vs %u)\n", *a5, 1);
    v21 = rtcv::Logger::instance(v20);
    int v26 = 1;
    rtcv::Logger::log<(rtcv::Logger::Severity)3,unsigned int &,int>((uint64_t)v21, (uint64_t)"Incorrect trk node state version (%u vs %u)\n", a5, (uint64_t)&v26, v22, v23, v24, v25);
    return 4294967289;
  }
  if (a5[1] != 467402) {
    return 4294967289;
  }
  if (a3 < 3)
  {
    uint64_t result = 0;
    a5[1] = 467393;
  }
  else
  {
    uint64_t v8 = rtcv::LoggerDevNull::instance((rtcv::LoggerDevNull *)v7.__d_.__rep_);
    std::chrono::steady_clock::time_point v9 = (FILE *)rtcv::LoggerDevNull::devNull((rtcv::LoggerDevNull *)v8);
    char v10 = (rtcv::Logger *)fprintf(v9, "Numbers of net outputs (%d) more than limit!\n", a3);
    unsigned int v11 = rtcv::Logger::instance(v10);
    rtcv::Logger::log<(rtcv::Logger::Severity)3,rtcv::SimResizePixelFormat &>((uint64_t)v11, (uint64_t)"Numbers of net outputs (%d) more than limit!\n", &v27, v12, v13, v14, v15, v16);
    return 4294967292;
  }
  return result;
}

uint64_t TtTrkRpnNode::instancePostProcess(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4, unsigned int *a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  unsigned int v147 = a3;
  v13.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  if (*a5 != 1)
  {
    v89 = rtcv::LoggerDevNull::instance((rtcv::LoggerDevNull *)v13.__d_.__rep_);
    v90 = (FILE *)rtcv::LoggerDevNull::devNull((rtcv::LoggerDevNull *)v89);
    v91 = (rtcv::Logger *)fprintf(v90, "Incorrect trk node state version (%u vs %u)\n", *a5, 1);
    v92 = rtcv::Logger::instance(v91);
    LODWORD(v150[0]) = 1;
    rtcv::Logger::log<(rtcv::Logger::Severity)3,unsigned int &,int>((uint64_t)v92, (uint64_t)"Incorrect trk node state version (%u vs %u)\n", a5, (uint64_t)v150, v93, v94, v95, v96);
    return 4294967289;
  }
  if (a5[1] != 467401) {
    return 4294967289;
  }
  if (a3 != 2)
  {
    v98 = rtcv::LoggerDevNull::instance((rtcv::LoggerDevNull *)v13.__d_.__rep_);
    v99 = (FILE *)rtcv::LoggerDevNull::devNull((rtcv::LoggerDevNull *)v98);
    v100 = (rtcv::Logger *)fprintf(v99, "Numbers of net outputs (%d) isn't correct!\n", a3);
    v101 = rtcv::Logger::instance(v100);
    rtcv::Logger::log<(rtcv::Logger::Severity)3,rtcv::SimResizePixelFormat &>((uint64_t)v101, (uint64_t)"Numbers of net outputs (%d) isn't correct!\n", &v147, v102, v103, v104, v105, v106);
    return 4294967292;
  }
  if (!*((unsigned char *)a5 + 1857)) {
    goto LABEL_77;
  }
  uint64_t v14 = 0;
  char v15 = 1;
  do
  {
    char v16 = v15;
    float v17 = (uint64_t *)(a2 + 24 * v14);
    if (*((_DWORD *)v17 + 5) == 7)
    {
      uint64_t v18 = a1 + 24 * v14;
      v19 = (uint64_t *)(v18 + 488);
      v20 = (_DWORD *)(a2 + 24 * v14);
      int v21 = v20[2];
      if (v21)
      {
        int v22 = 0;
        uint64_t v23 = *v19;
        uint64_t v24 = *v17;
        uint64_t v25 = v20[3];
        uint64_t v26 = v20[4];
        uint64_t v27 = *(unsigned int *)(v18 + 504);
        while (!v25)
        {
LABEL_26:
          v24 += v26;
          v23 += v27;
          if (++v22 == v21) {
            goto LABEL_27;
          }
        }
        uint64_t v28 = 0;
        while (1)
        {
          unsigned int v29 = *(__int16 *)(v24 + 2 * v28);
          unsigned int v30 = v29 & 0x80000000;
          int v31 = (v29 >> 10) & 0x1F;
          int v32 = *(unsigned __int16 *)(v24 + 2 * v28) << 13;
          unsigned int v33 = v32 & 0x7FE000;
          if (v31 == 31)
          {
            if (v33) {
              int v36 = 2143289344;
            }
            else {
              int v36 = 2139095040;
            }
            int v35 = v30 | v32 | v36;
          }
          else
          {
            if (!v31)
            {
              if (!v33)
              {
                if (v30) {
                  float v37 = -0.0;
                }
                else {
                  float v37 = 0.0;
                }
                goto LABEL_21;
              }
              unsigned int v34 = __clz(v33);
              int v31 = 9 - v34;
              unsigned int v33 = (v32 << (v34 - 8)) & 0x7FE000;
            }
            int v35 = ((v33 | (v31 << 23)) + 939524096) | v30;
          }
          float v37 = *(float *)&v35;
LABEL_21:
          *(float *)(v23 + 4 * v28++) = v37;
          if (v25 == v28) {
            goto LABEL_26;
          }
        }
      }
LABEL_27:
      v38 = &v150[3 * v14];
      *(_OWORD *)v38 = *(_OWORD *)v19;
      unint64_t v39 = v19[2];
    }
    else
    {
      v38 = &v150[3 * v14];
      *(_OWORD *)v38 = *(_OWORD *)v17;
      unint64_t v39 = v17[2];
    }
    v38[2] = v39;
    char v15 = 0;
    uint64_t v14 = 1;
  }
  while ((v16 & 1) != 0);
  v132 = a7;
  uint64_t v133 = a6;
  uint64_t v134 = (uint64_t)a5;
  if (!*(_DWORD *)(a1 + 436)) {
    goto LABEL_52;
  }
  unsigned int v40 = 0;
  unsigned int v41 = *(_DWORD *)(a1 + 20);
  int v42 = *(_DWORD *)(a1 + 52) * v41 * *(_DWORD *)(a1 + 28);
  v43 = (const float *)v151;
  float32x4_t v44 = vld1q_dup_f32(v43);
  uint64x2_t v135 = (uint64x2_t)vdupq_n_s64(v150[0]);
  int32x4_t v136 = (int32x4_t)v44;
  unsigned int v138 = *(_DWORD *)(a1 + 436);
  uint64_t v139 = v41;
  do
  {
    int v45 = v40 / v41;
    LODWORD(__src[0]) = v40 / v41;
    for (uint64_t i = 4; i != 16; i += 4)
    {
      v45 += v42;
      *(_DWORD *)((char *)__src + i) = v45;
    }
    uint32x4_t v47 = (uint32x4_t)vmulq_s32(v136, *(int32x4_t *)__src);
    int64x2_t v48 = (int64x2_t)vaddw_high_u32(v135, v47);
    int64x2_t v49 = (int64x2_t)vaddw_u32(v135, *(uint32x2_t *)v47.i8);
    uint64_t v50 = *(void *)(a1 + 440);
    uint64_t v51 = *(void *)(a1 + 448);
    uint64_t v52 = v139;
    unsigned int v53 = v40;
    do
    {
      int64x2_t v140 = v49;
      int64x2_t v141 = v48;
      v54 = (float *)(v50 + 16 * v53);
      float v55 = v54[2];
      v56 = (float *)(v51 + 16 * v53);
      float *v56 = *v54 + (float)(*(float *)v49.i64[0] * v55);
      float v57 = v54[3];
      v56[1] = v54[1] + (float)(*(float *)v49.i64[1] * v57);
      v56[2] = v55 * expf(*(float *)v48.i64[0]);
      v56[3] = v57 * expf(*(float *)v141.i64[1]);
      int64x2_t v58 = vdupq_n_s64(4uLL);
      int64x2_t v49 = vaddq_s64(v140, v58);
      int64x2_t v48 = vaddq_s64(v141, v58);
      ++v53;
      --v52;
    }
    while (v52);
    unsigned int v41 = v139;
    v40 += v139;
    unsigned int v59 = v138;
  }
  while (v40 < v138);
  unsigned int v60 = 0;
  uint64_t v61 = v151[1];
  int v62 = v152;
  LODWORD(v63) = *(_DWORD *)(a1 + 20);
  do
  {
    if (v63)
    {
      unint64_t v64 = 0;
      int v65 = *(_DWORD *)(a1 + 52) * v63;
      unsigned int v66 = v60 / v63;
      v67 = (float *)(v61 + v62 * (v66 + v65 * *(_DWORD *)(a1 + 28)));
      v68 = (float *)(v61 + v62 * v66);
      do
      {
        float v69 = *v68++;
        float v70 = v69;
        float v71 = *v67++;
        *(float *)(*(void *)(a1 + 456) + 4 * (v60 + v64++)) = bmSoftmax2(v70, v71);
        unint64_t v63 = *(unsigned int *)(a1 + 20);
      }
      while (v64 < v63);
      unsigned int v59 = *(_DWORD *)(a1 + 436);
    }
    v60 += v63;
  }
  while (v60 < v59);
  if (v59)
  {
    uint64_t v72 = 0;
    unsigned int v73 = 0;
    uint64_t v74 = *(void *)(a1 + 456);
    uint64_t v75 = *(void *)(a1 + 464);
    uint64_t v76 = *(void *)(a1 + 472);
    uint64_t v77 = *(void *)(a1 + 480);
    uint64_t v78 = v59;
    uint64_t v142 = *(void *)(a1 + 448);
    v79 = (float *)(v142 + 12);
    float v80 = -3.4028e38;
    do
    {
      float v81 = *(v79 - 1);
      float v82 = *(float *)(v134 + 24);
      float v83 = *(float *)(v134 + 28);
      float v84 = sqrtf((float)(v81 + (float)((float)(v81 + *v79) * 0.5)) * (float)(*v79 + (float)((float)(v81 + *v79) * 0.5)))
          / sqrtf((float)(v82 + (float)((float)(v82 + v83) * 0.5)) * (float)(v83 + (float)((float)(v82 + v83) * 0.5)));
      float v85 = expf(-(float)((float)((float)(fmaxf((float)(v82 / v83) / (float)(v81 / *v79), 1.0 / (float)((float)(v82 / v83) / (float)(v81 / *v79)))* fmaxf(v84, 1.0 / v84))+ -1.0)* *(float *)(a1 + 76)));
      *(float *)(v76 + 4 * v72) = v85;
      float v86 = *(float *)(v74 + 4 * v72) * v85;
      *(float *)(v75 + 4 * v72) = v86;
      float v87 = (float)(*(float *)(a1 + 80) * *(float *)(v77 + 4 * v72)) + (float)(v86 * (float)(1.0 - *(float *)(a1 + 80)));
      *(float *)(v75 + 4 * v72) = v87;
      if (v87 > v80)
      {
        unsigned int v73 = v72;
        float v80 = v87;
      }
      ++v72;
      v79 += 4;
    }
    while (v78 != v72);
    uint64_t v88 = v142;
  }
  else
  {
LABEL_52:
    unsigned int v73 = 0;
    uint64_t v76 = *(void *)(a1 + 472);
    uint64_t v88 = *(void *)(a1 + 448);
    uint64_t v74 = *(void *)(a1 + 456);
  }
  a5 = (unsigned int *)v134;
  float v107 = *(float *)(v134 + 1824);
  float v108 = *(float *)(v134 + 24) / v107;
  float v109 = *(float *)(v134 + 28) / v107;
  v110 = (float *)(v88 + 16 * v73);
  float v111 = (float)(*(float *)(v76 + 4 * v73) * *(float *)(v74 + 4 * v73)) * *(float *)(a1 + 84);
  float v112 = (float)(*(float *)(v134 + 20) + (float)(v109 * 0.5)) + (float)(v110[1] / v107);
  float v113 = (float)((float)(v110[2] / v107) * v111) + (float)(v108 * (float)(1.0 - v111));
  float v114 = (float)((float)(v110[3] / v107) * v111) + (float)(v109 * (float)(1.0 - v111));
  float v115 = bmClamp((float)(*(float *)(v134 + 16) + (float)(v108 * 0.5)) + (float)(*v110 / v107), 0.0, (float)*a4);
  float v116 = bmClamp(v112, 0.0, (float)a4[1]);
  float v117 = bmClamp(v113, 10.0, (float)*a4);
  float v118 = bmClamp(v114, 10.0, (float)a4[1]);
  *(float *)(v134 + 16) = v115 - (float)(v117 * 0.5);
  *(float *)(v134 + 20) = v116 - (float)(v118 * 0.5);
  *(float *)(v134 + 24) = v117;
  *(float *)(v134 + 28) = v118;
  long long v146 = *(_OWORD *)(v133 + 8);
  *(_OWORD *)(v133 + 8) = *(_OWORD *)(v134 + 16);
  _DWORD *v132 = 1;
  uint64_t v119 = *(void *)(a1 + 456);
  float v120 = *(float *)(v119 + 4 * v73);
  *(_DWORD *)(v133 + 24) = (float)(v120 * 1000.0);
  int v121 = *(_DWORD *)(a1 + 20);
  __src[0] = (void *)(v119 + 4 * v73 / (v121 * v121) * v121 * v121);
  LODWORD(v149) = 4 * v121;
  HIDWORD(v149) = 6;
  LODWORD(__src[1]) = v121;
  HIDWORD(__src[1]) = v121;
  ttTrkScoreNormalize((uint64_t *)__src);
  uint64_t v145 = 0;
  int v144 = 0;
  ttTrkScoreFindMaxScore((uint64_t *)__src, (float *)&v145 + 1, &v145, &v144);
  if (!*(unsigned char *)(v134 + 1861))
  {
    *(unsigned char *)(v134 + 1861) = 1;
    memcpy((void *)(v134 + 128), __src[0], (LODWORD(__src[1]) * v149));
    *(_DWORD *)(v134 + 1828) = v145;
    *(_DWORD *)(v134 + 1832) = v144;
  }
  v143[1] = (uint64_t)__src[1];
  v143[2] = v149;
  v143[0] = v134 + 128;
  float v122 = -1.0;
  if (*(float *)(a1 + 96) < 1.0 && *(float *)(a1 + 100) > 0.0) {
    float v122 = ttTrkComputeKL(v143, (uint64_t *)__src, *(_DWORD *)(v134 + 1828), *(_DWORD *)(v134 + 1832), v145, v144);
  }
  if (*(unsigned char *)(v134 + 1862))
  {
    long long v123 = v146;
    *(_OWORD *)(v134 + 16) = v146;
    *(_OWORD *)(v133 + 8) = v123;
    unsigned int v124 = *(_DWORD *)(v134 + 1852);
    if (v124 < *(_DWORD *)(a1 + 128))
    {
      unsigned int v125 = v124 + 1;
      *(_DWORD *)(v134 + 1852) = v125;
      if (*(float *)(v134 + 1812) < v120) {
        unsigned int v126 = *(_DWORD *)(v134 + 1848) + 1;
      }
      else {
        unsigned int v126 = 0;
      }
      *(_DWORD *)(v134 + 1848) = v126;
      if (v126 >= *(_DWORD *)(a1 + 116))
      {
        *(unsigned char *)(v134 + 1862) = 0;
        *(_DWORD *)(v134 + 1852) = 0;
        *(_DWORD *)(v134 + 1820) = 1065353216;
        *(void *)(v134 + 1840) = 0;
        *(_DWORD *)(v134 + 1836) = 0;
        *(_OWORD *)(v134 + 1572) = 0u;
        *(_OWORD *)(v134 + 1588) = 0u;
        *(_OWORD *)(v134 + 1604) = 0u;
        *(_OWORD *)(v134 + 1620) = 0u;
        *(_OWORD *)(v134 + 1636) = 0u;
        *(_OWORD *)(v134 + 1652) = 0u;
        *(_OWORD *)(v134 + 1668) = 0u;
        *(_OWORD *)(v134 + 1684) = 0u;
        *(_OWORD *)(v134 + 1700) = 0u;
        *(_OWORD *)(v134 + 1716) = 0u;
        *(_OWORD *)(v134 + 1732) = 0u;
        *(_OWORD *)(v134 + 1748) = 0u;
        *(_OWORD *)(v134 + 1764) = 0u;
        *(_OWORD *)(v134 + 1780) = 0u;
        *(_OWORD *)(v134 + 1796) = 0u;
      }
      else
      {
        *(float *)(v134 + 1820) = (float)(*(float *)(a1 + 104) * (float)v125) + 1.0;
      }
      goto LABEL_73;
    }
    *(_WORD *)(v134 + 1856) = 0;
    *(_DWORD *)(v134 + 1820) = 1065353216;
    *(_OWORD *)(v134 + 1836) = 0u;
    *(_WORD *)(v134 + 1861) = 0;
    *(_DWORD *)(v134 + 1852) = 0;
    *(_OWORD *)(v134 + 1572) = 0u;
    *(_OWORD *)(v134 + 1588) = 0u;
    *(_OWORD *)(v134 + 1604) = 0u;
    *(_OWORD *)(v134 + 1620) = 0u;
    *(_OWORD *)(v134 + 1636) = 0u;
    *(_OWORD *)(v134 + 1652) = 0u;
    *(_OWORD *)(v134 + 1668) = 0u;
    *(_OWORD *)(v134 + 1684) = 0u;
    *(_OWORD *)(v134 + 1700) = 0u;
    *(_OWORD *)(v134 + 1716) = 0u;
    *(_OWORD *)(v134 + 1732) = 0u;
    *(_OWORD *)(v134 + 1748) = 0u;
    *(_OWORD *)(v134 + 1764) = 0u;
    *(_OWORD *)(v134 + 1780) = 0u;
    *(_OWORD *)(v134 + 1796) = 0u;
    _DWORD *v132 = 0;
LABEL_75:
    int v131 = 1;
  }
  else
  {
    if (TtTrkRpnNode::checkToTerminate(a1, v134, v120, v122))
    {
      *(unsigned char *)(v134 + 1862) = 1;
      TtTrkRpnNode::terminate(a1, v134, v127);
    }
    else
    {
      uint64_t v128 = *(unsigned int *)(v134 + 1836);
      uint64_t v129 = v134 + 4 * v128;
      *(float *)(v129 + 1572) = v120;
      *(float *)(v129 + 1692) = v122;
      if ((v128 + 1) < *(_DWORD *)(a1 + 124)) {
        int v130 = v128 + 1;
      }
      else {
        int v130 = 0;
      }
      *(_DWORD *)(v134 + 1836) = v130;
    }
LABEL_73:
    if (!*(unsigned char *)(v134 + 1862)) {
      goto LABEL_75;
    }
    int v131 = 2;
  }
  *(_DWORD *)(v133 + 84) = v131;
LABEL_77:
  uint64_t result = 0;
  a5[1] = 467393;
  return result;
}

BOOL TtTrkRpnNode::checkToTerminate(uint64_t a1, uint64_t a2, float a3, float a4)
{
  float v4 = *(float *)(a1 + 96);
  if (*(float *)(a1 + 92) > a3) {
    unsigned int v5 = *(_DWORD *)(a2 + 1840) + 1;
  }
  else {
    unsigned int v5 = 0;
  }
  *(_DWORD *)(a2 + 1840) = v5;
  if (v4 >= a4 || *(float *)(a1 + 100) <= a3)
  {
    unsigned int v6 = 0;
    *(_DWORD *)(a2 + 1844) = 0;
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(a2 + 1844) + 1;
    *(_DWORD *)(a2 + 1844) = v6;
  }
  unsigned int v7 = *(_DWORD *)(a1 + 120);
  return v5 >= v7 || v6 >= v7;
}

float TtTrkRpnNode::terminate(uint64_t a1, uint64_t a2, float result)
{
  *(_DWORD *)(a2 + 1848) = 0;
  uint64_t v3 = *(unsigned int *)(a1 + 124);
  if (v3)
  {
    unsigned int v4 = 0;
    unsigned int v5 = (float *)(a2 + 1572);
    float v6 = 0.0;
    uint64_t v7 = *(unsigned int *)(a1 + 124);
    do
    {
      float v8 = *v5++;
      float v9 = v8;
      BOOL v10 = v8 <= 0.0;
      if (v8 <= 0.0) {
        float v9 = -0.0;
      }
      float v6 = v6 + v9;
      if (!v10) {
        ++v4;
      }
      --v7;
    }
    while (v7);
    if (v4) {
      *(float *)(a2 + 1812) = v6 / (float)v4;
    }
    unsigned int v11 = 0;
    uint64_t v12 = (float *)(a2 + 1692);
    uint64_t result = 0.0;
    do
    {
      float v13 = *v12++;
      float v14 = v13;
      BOOL v15 = v13 <= 0.0;
      if (v13 <= 0.0) {
        float v14 = -0.0;
      }
      uint64_t result = result + v14;
      if (!v15) {
        ++v11;
      }
      --v3;
    }
    while (v3);
    if (v11)
    {
      uint64_t result = result / (float)v11;
      *(float *)(a2 + 1816) = result;
    }
  }
  return result;
}

uint64_t TtTrkRpnNode::getParams(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  if (*a2 != 1)
  {
    uint64_t v26 = rtcv::LoggerDevNull::instance((rtcv::LoggerDevNull *)a1);
    uint64_t v27 = (FILE *)rtcv::LoggerDevNull::devNull((rtcv::LoggerDevNull *)v26);
    uint64_t v28 = (rtcv::Logger *)fprintf(v27, "Incorrect trk node state version (%u vs %u)\n", *a2, 1);
    unsigned int v29 = rtcv::Logger::instance(v28);
    int v35 = 1;
    rtcv::Logger::log<(rtcv::Logger::Severity)3,unsigned int &,int>((uint64_t)v29, (uint64_t)"Incorrect trk node state version (%u vs %u)\n", a2, (uint64_t)&v35, v30, v31, v32, v33);
    return 4294967289;
  }
  unsigned int v4 = a2[1];
  if (v4 != 467402 && v4 != 467393) {
    return 4294967289;
  }
  uint64_t v6 = 0;
  unsigned int v7 = (*(_DWORD *)(a1 + 152) * *(_DWORD *)(a1 + 144) + 63) & 0xFFFFFFC0;
  unsigned int v8 = (*(_DWORD *)(a1 + 140) * *(_DWORD *)(a1 + 132) + 63) & 0xFFFFFFC0;
  *(_OWORD *)(a3 + 196) = 0u;
  *(_OWORD *)(a3 + 184) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 136) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)a3 = 0x100000001;
  int v9 = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a3 + 12) = v9;
  uint64_t v10 = *(void *)(a1 + 136);
  *(void *)(a3 + 16) = v10;
  int v11 = *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a3 + 24) = v10 * v8;
  *(_DWORD *)(a3 + 28) = v11;
  uint64_t v12 = *(void *)(a1 + 148);
  *(void *)(a3 + 32) = v12;
  *(_DWORD *)(a3 + 40) = v12 * v7;
  unsigned int v13 = *(_DWORD *)(a1 + 336);
  char v14 = 1;
  do
  {
    char v15 = v14;
    char v16 = (_DWORD *)(a1 + 4 * v6);
    float v17 = (_DWORD *)(a3 + 4 * v6);
    v17[11] = v16[62];
    v17[13] = v16[64];
    v17[15] = v16[66];
    if (v13 > 7) {
      int v18 = 0;
    }
    else {
      int v18 = dword_1A410A090[v13];
    }
    char v14 = 0;
    v17[17] = v18 * v16[62] * v16[64] * v16[66];
    uint64_t v6 = 1;
  }
  while ((v15 & 1) != 0);
  uint64_t v19 = 0;
  *(_DWORD *)(a3 + 76) = v13;
  char v20 = 1;
  do
  {
    char v21 = v20;
    int v22 = (_DWORD *)(a1 + 4 * v19);
    uint64_t v23 = (_DWORD *)(a3 + 4 * v19);
    v23[20] = v22[39];
    v23[22] = v22[41];
    v23[24] = v22[43];
    if (v13 > 7) {
      int v24 = 0;
    }
    else {
      int v24 = dword_1A410A090[v13];
    }
    char v20 = 0;
    v23[26] = v24 * v22[39] * v22[41] * v22[43];
    uint64_t v19 = 1;
  }
  while ((v21 & 1) != 0);
  uint64_t v25 = 0;
  *(_DWORD *)(a3 + 112) = *(_DWORD *)(a1 + 244);
  return v25;
}

uint64_t TtTrkRpnNode::setUpNetBuffers(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  if (!*(void *)a1) {
    return 4294967292;
  }
  uint64_t v3 = *(void *)(a1 + 12);
  v4.i64[0] = v3;
  v4.i64[1] = *(void *)(a1 + 32);
  uint64_t v5 = 4294967292;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqzq_s64(v4), (int32x4_t)vceqzq_s64(*(int64x2_t *)(a1 + 48))))) & 1) == 0
    && *(void *)(a1 + 24))
  {
    if (*(_DWORD *)(a1 + 8) < a2[6] || *(_DWORD *)(a1 + 20) < a2[10]) {
      return 4294967292;
    }
    uint64_t v7 = 0;
    *(void *)a3 = *(void *)a1;
    int v8 = a2[5] * a2[3];
    *(_DWORD *)(a3 + 8) = a2[4];
    *(_DWORD *)(a3 + 12) = v8;
    char v9 = 1;
    *(_DWORD *)(a3 + 16) = (v8 + 63) & 0xFFFFFFC0;
    *(_DWORD *)(a3 + 20) = 1;
    *(void *)(a3 + 24) = v3;
    int v10 = a2[9] * a2[7];
    *(_DWORD *)(a3 + 32) = a2[8];
    *(_DWORD *)(a3 + 36) = v10;
    *(_DWORD *)(a3 + 40) = (v10 + 63) & 0xFFFFFFC0;
    *(_DWORD *)(a3 + 44) = 1;
    unsigned int v11 = a2[28];
    do
    {
      char v12 = v9;
      uint64_t v13 = a3 + 24 * v7;
      *(void *)(v13 + 48) = *(void *)(a1 + 8 * v7 + 24);
      char v14 = &a2[v7];
      int v15 = v14[20];
      *(_DWORD *)(v13 + 60) = v15;
      *(_DWORD *)(v13 + 56) = v14[24] * v14[22];
      *(_DWORD *)(v13 + 68) = v11;
      if (v11 > 7) {
        int v16 = 0;
      }
      else {
        int v16 = dword_1A410A090[v11];
      }
      char v9 = 0;
      *(_DWORD *)(a3 + 24 * v7 + 64) = v16 * v15;
      uint64_t v7 = 1;
    }
    while ((v12 & 1) != 0);
    uint64_t v17 = 0;
    unsigned int v18 = a2[19];
    char v19 = 1;
    do
    {
      char v20 = v19;
      uint64_t v21 = a3 + 24 * v17;
      *(void *)(v21 + 96) = *(void *)(a1 + 8 * v17 + 48);
      int v22 = &a2[v17];
      int v23 = v22[11];
      *(_DWORD *)(v21 + 108) = v23;
      *(_DWORD *)(v21 + 104) = v22[15] * v22[13];
      *(_DWORD *)(v21 + 116) = v18;
      if (v18 > 7) {
        int v24 = 0;
      }
      else {
        int v24 = dword_1A410A090[v18];
      }
      char v19 = 0;
      *(_DWORD *)(a3 + 24 * v17 + 112) = v24 * v23;
      uint64_t v17 = 1;
    }
    while ((v20 & 1) != 0);
    return 0;
  }
  return v5;
}

uint64_t *ttTrkScoreFindMaxScore(uint64_t *result, float *a2, _DWORD *a3, _DWORD *a4)
{
  int v4 = *((_DWORD *)result + 2);
  uint64_t v5 = *((unsigned int *)result + 3);
  *a2 = -3.4028e38;
  *a3 = 0;
  *a4 = 0;
  if (v4)
  {
    int v6 = 0;
    uint64_t v7 = *result;
    float v8 = -3.4028e38;
    do
    {
      if (v5)
      {
        uint64_t v9 = 0;
        uint64_t v10 = v7 + (*((_DWORD *)result + 4) * v6);
        do
        {
          float v11 = *(float *)(v10 + 4 * v9);
          if (v11 > v8)
          {
            *a2 = v11;
            *a3 = v9;
            float v8 = v11;
            *a4 = v6;
          }
          ++v9;
        }
        while (v5 != v9);
      }
      ++v6;
    }
    while (v6 != v4);
  }
  return result;
}

uint64_t *ttTrkScoreNormalize(uint64_t *result)
{
  uint64_t v1 = *((unsigned int *)result + 2);
  if (v1)
  {
    unsigned int v2 = 0;
    uint64_t v3 = 0;
    float v4 = 0.0;
    uint64_t v5 = *((unsigned int *)result + 3);
    do
    {
      if (v5)
      {
        int v6 = (float *)(*result + v2);
        uint64_t v7 = *((unsigned int *)result + 3);
        do
        {
          float v8 = *v6++;
          float v4 = v4 + v8;
          --v7;
        }
        while (v7);
      }
      ++v3;
      v2 += *((_DWORD *)result + 4);
    }
    while (v3 != v1);
    if (v4 > 0.0000001)
    {
      unsigned int v9 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = *result;
      int v12 = *((_DWORD *)result + 4);
      do
      {
        if (v5)
        {
          uint64_t v13 = (float *)(v11 + v9);
          uint64_t v14 = v5;
          do
          {
            *uint64_t v13 = *v13 / v4;
            ++v13;
            --v14;
          }
          while (v14);
        }
        ++v10;
        v9 += v12;
      }
      while (v10 != v1);
    }
  }
  return result;
}

float ttTrkComputeKL(uint64_t *a1, uint64_t *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((_DWORD *)a2 + 2);
  int v7 = *((_DWORD *)a2 + 3);
  int v8 = *((_DWORD *)a1 + 2);
  int v9 = *((_DWORD *)a1 + 3);
  int v10 = *((_DWORD *)a1 + 4);
  uint64_t v27 = *a2;
  uint64_t v28 = *a1;
  int v11 = *((_DWORD *)a2 + 4);
  int v25 = v11 * (a6 - 9);
  int v26 = v10 * (a4 - 9);
  float v12 = 0.0;
  int v13 = -9;
  int v32 = a4;
  int v33 = a6;
  int v31 = v8;
  do
  {
    unsigned int v14 = v13 + a5;
    int v34 = v13;
    unsigned int v15 = v13 + a3;
    uint64_t v16 = v28 + 4 * (v13 + a3);
    int v17 = -9;
    unsigned int v18 = v25;
    unsigned int v19 = v26;
    uint64_t v20 = v27 + 4 * v14;
    do
    {
      if ((v14 & 0x80000000) == 0
        && (int)v14 < v7
        && ((a6 + v17) & 0x80000000) == 0
        && a6 + v17 < v6
        && (v15 & 0x80000000) == 0
        && (int)v15 < v9
        && ((a4 + v17) & 0x80000000) == 0
        && a4 + v17 < v8)
      {
        float v21 = *(float *)(v20 + v18);
        if (v21 >= 0.000001)
        {
          float v22 = *(float *)(v16 + v19);
          if (v22 >= 0.000001)
          {
            float v23 = logf(v22 / v21);
            uint64_t v20 = v27 + 4 * v14;
            uint64_t v16 = v28 + 4 * v15;
            int v8 = v31;
            a4 = v32;
            a6 = v33;
            float v12 = v12 + (float)(v22 * v23);
          }
        }
      }
      ++v17;
      v19 += v10;
      v18 += v11;
    }
    while (v17 != 10);
    int v13 = v34 + 1;
  }
  while (v34 != 9);
  return fmaxf(v12, 0.0);
}

void **GeomTransformShared_constructor()
{
  v0 = (void **)malloc_type_calloc(1uLL, 0x10uLL, 0x1010040FDD9F14CuLL);
  uint64_t v1 = v0;
  if (!v0 || (v0[1] = (void *)2048, unsigned int v2 = malloc_type_calloc(1uLL, 0x800uLL, 0x3E0556BCuLL), (*v1 = v2) == 0))
  {
    GeomTransformShared_destructor(v1);
    return 0;
  }
  return v1;
}

void GeomTransformShared_destructor(void **a1)
{
  if (a1)
  {
    unsigned int v2 = *a1;
    if (v2) {
      free(v2);
    }
    *a1 = 0;
    a1[1] = 0;
    free(a1);
  }
}

void *GeomTransform_constructor(unsigned int a1, uint64_t a2)
{
  float v4 = (char *)malloc_type_malloc(0x50uLL, 0x1080040FC92EF5CuLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *(_OWORD *)(v4 + 4) = xmmword_1A410A0C0;
    *(_OWORD *)(v4 + 20) = xmmword_1A410A0C0;
    *(_OWORD *)(v4 + 36) = xmmword_1A410A0C0;
    *(_OWORD *)(v4 + 52) = xmmword_1A410A0C0;
    *(_DWORD *)float v4 = a1;
    if (a1 > 2)
    {
      syslog(3, "GeomTransform_constructor: unknown transform model (%d)", a1);
      free(v5);
      return 0;
    }
    else
    {
      *((void *)v4 + 9) = a2;
    }
  }
  return v5;
}

double GeomTransform_eye(uint64_t a1)
{
  *(void *)&double result = 1065353216;
  *(_OWORD *)(a1 + 4) = xmmword_1A410A0C0;
  *(_OWORD *)(a1 + 20) = xmmword_1A410A0C0;
  *(_OWORD *)(a1 + 36) = xmmword_1A410A0C0;
  *(_OWORD *)(a1 + 52) = xmmword_1A410A0C0;
  return result;
}

void GeomTransform_destructor(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t GeomTransform_minSupportPoints(_DWORD *a1)
{
  if (*a1 < 3u) {
    return (*a1 + 2);
  }
  syslog(3, "GeomTransform_minSupportPoints: unknown transform model (%d), reset to RIGID", *a1);
  return 2;
}

uint64_t GeomTransform_changeCoordinateSystem(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v3 = *(_OWORD *)(a1 + 20);
  v15[0] = *(_OWORD *)(a1 + 4);
  v15[1] = v3;
  int v16 = 1065353216;
  long long v4 = *(_OWORD *)(a2 + 20);
  v13[0] = *(_OWORD *)(a2 + 4);
  v13[1] = v4;
  int v14 = 1065353216;
  long long v5 = *(_OWORD *)(a2 + 52);
  v11[0] = *(_OWORD *)(a2 + 36);
  v11[1] = v5;
  int v12 = 1065353216;
  mul3x3Matrix((uint64_t)v17, (uint64_t)v15, (uint64_t)v11, 0);
  float32x4_t v7 = mul3x3Matrix((uint64_t)v17, (uint64_t)v13, (uint64_t)v17, 0);
  uint64_t v6 = 0;
  v7.f32[0] = v18;
  if (fabsf(v18) < 1.0e-10)
  {
    syslog(3, "GeomTransform_changeCoordinateSystem failed");
    uint64_t v6 = 0xFFFFFFFFLL;
    v7.f32[0] = v18;
  }
  uint64_t v8 = 0;
  float32x4_t v9 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
  do
  {
    v19[v8] = (__int128)vdivq_f32(*(float32x4_t *)&v17[v8 * 16], v9);
    ++v8;
  }
  while (v8 != 2);
  GeomTransform_setParams(a1, v19);
  return v6;
}

double GeomTransform_setParams(uint64_t a1, long long *a2)
{
  uint64_t v3 = 0;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  do
  {
    *(_DWORD *)(a1 + 4 + v3) = *(_DWORD *)((char *)a2 + v3);
    v3 += 4;
  }
  while (v3 != 32);
  long long v4 = a2[1];
  long long v8 = *a2;
  long long v9 = v4;
  float v10 = 1.0;
  invMatrix((__CLPK_real *)&v8, 3);
  for (uint64_t i = 0; i != 32; i += 4)
    *(float *)((char *)&v8 + i) = *(float *)((char *)&v8 + i) / v10;
  double result = *(double *)&v8;
  long long v7 = v9;
  *(_OWORD *)(a1 + 36) = v8;
  *(_OWORD *)(a1 + 52) = v7;
  return result;
}

float GeomTransform_deepCopy(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  float result = *(float *)(a2 + 64);
  *(float *)(a1 + 64) = result;
  return result;
}

void GeomTransform_setModel(uint64_t a1, int a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  long long v2 = xmmword_1A410A104;
  long long v3 = unk_1A410A114;
  switch(a2)
  {
    case 2:
      *(_DWORD *)a1 = 2;
      return;
    case 1:
      *(_DWORD *)a1 = 1;
      long long v2 = *(_OWORD *)(a1 + 4);
      *(void *)&long long v3 = *(void *)(a1 + 20);
      goto LABEL_7;
    case 0:
      *(_DWORD *)a1 = 0;
      LODWORD(v2) = *(_DWORD *)(a1 + 4);
      *(void *)((char *)&v2 + 4) = *(void *)(a1 + 8);
      *((float *)&v2 + 3) = -*((float *)&v2 + 1);
      LODWORD(v3) = v2;
      DWORD1(v3) = *(_DWORD *)(a1 + 24);
LABEL_7:
      GeomTransform_setParams(a1, &v2);
      return;
  }
  syslog(3, "GeomTransform_setModel: unknown new model (%d) use the old model (%d)", a2, *(_DWORD *)a1);
}

float *GeomTransform_dirs(float *result, float *a2, float *a3, float *a4, float *a5, unsigned int a6)
{
  if (a6)
  {
    uint64_t v6 = a6;
    do
    {
      float v7 = *a4++;
      float v8 = v7;
      float v9 = *a5++;
      float v10 = (float)((float)(v9 * result[8]) + (float)(result[7] * v8)) + 1.0;
      *a2 = result[3] + (float)((float)(v9 * result[2]) + (float)(result[1] * v8));
      *a3 = result[6] + (float)((float)(v9 * result[5]) + (float)(result[4] * v8));
      *a2 = *a2 / v10;
      ++a2;
      *a3 = *a3 / v10;
      ++a3;
      --v6;
    }
    while (v6);
  }
  return result;
}

float *GeomTransform_invs(float *result, float *a2, float *a3, float *a4, float *a5, unsigned int a6)
{
  if (a6)
  {
    uint64_t v6 = a6;
    do
    {
      float v7 = *a4++;
      float v8 = v7;
      float v9 = *a5++;
      float v10 = (float)((float)(v9 * result[16]) + (float)(result[15] * v8)) + 1.0;
      *a2 = result[11] + (float)((float)(v9 * result[10]) + (float)(result[9] * v8));
      *a3 = result[14] + (float)((float)(v9 * result[13]) + (float)(result[12] * v8));
      *a2 = *a2 / v10;
      ++a2;
      *a3 = *a3 / v10;
      ++a3;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t GeomTransform_estimate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6, int a7)
{
  uint64_t v197 = *MEMORY[0x1E4F143B8];
  int v14 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == 2)
  {
    float v105 = 0.0;
    float v106 = 1.0;
    float v103 = 1.0;
    float v104 = 0.0;
    uint64_t v102 = 0;
    int v16 = *(__CLPK_real ***)(a1 + 72);
    if (v16) {
      int v17 = *v16;
    }
    else {
      int v17 = (__CLPK_real *)malloc_type_calloc(1uLL, 0x800uLL, 0x933688B6uLL);
    }
    normalizePoints(&v106, &v105, &v104, a4, a5, a6, a7);
    normalizePoints(&v103, (float *)&v102 + 1, (float *)&v102, a2, a3, a6, a7);
    uint64_t v19 = *a6;
    *(float *)&long long v20 = v105 + (float)(v106 * *(float *)(a4 + 4 * v19));
    float v21 = v104 + (float)(v106 * *(float *)(a5 + 4 * v19));
    float v22 = *((float *)&v102 + 1) + (float)(v103 * *(float *)(a2 + 4 * v19));
    float v23 = *(float *)&v102 + (float)(v103 * *(float *)(a3 + 4 * v19));
    float v24 = *(float *)&v20 * *(float *)&v20;
    *(float *)&long long v25 = *(float *)&v20 * v21;
    __CLPK_real __a = *(float *)&v20 * *(float *)&v20;
    float v124 = *(float *)&v20 * v21;
    float v26 = v21 * v21;
    float v132 = v21 * v21;
    float v133 = v21;
    float v27 = -(float)(*(float *)&v20 * *(float *)&v20);
    float v28 = v27 * v22;
    int v125 = v20;
    float v128 = v27 * v22;
    float v29 = (float)-(float)(v21 * *(float *)&v20) * v22;
    float v30 = -(float)(*(float *)&v20 * v22);
    float v31 = v27 * v23;
    float v32 = -(float)(*(float *)&v20 * v21);
    float v33 = v32 * v23;
    float v34 = -(float)(*(float *)&v20 * v23);
    float v35 = (float)(v23 * (float)((float)(*(float *)&v20 * *(float *)&v20) * v23))
        + (float)((float)((float)(*(float *)&v20 * *(float *)&v20) * v22) * v22);
    float v36 = v32 * v22;
    float v37 = -(float)(v21 * v21);
    float v38 = v37 * v22;
    float v136 = v29;
    float v137 = v37 * v22;
    float v39 = -(float)(v21 * v22);
    float v152 = v31;
    float v153 = v33;
    float v40 = v37 * v23;
    float v168 = v34;
    float v169 = -(float)(v21 * v23);
    float v41 = (float)(v22 * (float)((float)(v21 * v21) * v22)) + (float)((float)((float)(v21 * v21) * v23) * v23);
    float v186 = v41;
    float v129 = v36;
    float v130 = v30;
    float v144 = v30;
    float v138 = v39;
    float v42 = -v22;
    float v145 = v39;
    float v146 = -v22;
    float v160 = v33;
    float v154 = v34;
    float v161 = v37 * v23;
    float v162 = v169;
    float v43 = *(float *)&v102;
    float v44 = -v23;
    float v177 = v35;
    float v170 = -v23;
    v45.f32[0] = *(float *)&v20 * v21;
    v45.i32[1] = v20;
    float32x2_t v46 = vmla_n_f32(vmul_n_f32(vmul_n_f32(v45, v23), v23), vmul_n_f32(v45, v22), v22);
    float32x2_t v178 = v46;
    float v47 = (float)(v23 * (float)(v21 * v23)) + (float)((float)(v21 * v22) * v22);
    float v187 = v47;
    float v48 = (float)(v23 * v23) + (float)(v22 * v22);
    float v196 = v48;
    if (a7 < 2)
    {
      float v58 = -(float)(v21 * v23);
      float v82 = v34;
      float v81 = v33;
      float v57 = -(float)(v21 * v22);
      float v56 = -(float)(*(float *)&v20 * v22);
    }
    else
    {
      float v49 = *((float *)&v102 + 1);
      uint64_t v50 = a7 - 1;
      uint64_t v51 = a6 + 1;
      float v89 = v37 * v23;
      float v52 = v33;
      float v53 = -(float)(*(float *)&v20 * v23);
      float v54 = -(float)(*(float *)&v20 * v22);
      float32x2_t v55 = v46;
      float v56 = v54;
      float v57 = -(float)(v21 * v22);
      float v58 = -(float)(v21 * v23);
      float v59 = v53;
      float v60 = v58;
      float v61 = v41;
      do
      {
        float v86 = v44;
        float v62 = v43;
        float v88 = v58;
        unsigned int v63 = *v51++;
        float v64 = v42;
        float v65 = v39;
        float v66 = v26;
        float32_t v67 = v105 + (float)(v106 * *(float *)(a4 + 4 * v63));
        float v68 = v104 + (float)(v106 * *(float *)(a5 + 4 * v63));
        float v69 = v49 + (float)(v103 * *(float *)(a2 + 4 * v63));
        float v70 = v62 + (float)(v103 * *(float *)(a3 + 4 * v63));
        float v87 = v24 + (float)(v67 * v67);
        *(float *)&long long v25 = *(float *)&v25 + (float)(v67 * v68);
        *(float *)&long long v20 = *(float *)&v20 + v67;
        float v71 = -(float)(v67 * v67);
        long long v72 = v20;
        long long v73 = v25;
        float v74 = v28 + (float)(v71 * v69);
        float v54 = v54 - (float)(v67 * v69);
        float v29 = v29 + (float)((float)-(float)(v68 * v67) * v69);
        float v31 = v31 + (float)(v71 * v70);
        float v75 = -(float)(v67 * v68);
        float v52 = v52 + (float)(v75 * v70);
        float v59 = v59 - (float)(v67 * v70);
        float v35 = v35
            + (float)((float)(v70 * (float)((float)(v67 * v67) * v70)) + (float)((float)((float)(v67 * v67) * v69) * v69));
        float v76 = -(float)(v68 * v68);
        float v36 = v36 + (float)(v75 * v69);
        float v38 = v38 + (float)(v76 * v69);
        float v33 = v33 + (float)(v75 * v70);
        float v89 = v89 + (float)(v76 * v70);
        v77.f32[0] = v67 * v68;
        v77.f32[1] = v67;
        float v56 = v56 - (float)(v67 * v69);
        float v53 = v53 - (float)(v67 * v70);
        float v78 = v66;
        float v79 = v65;
        float v80 = v64;
        float v26 = v78 + (float)(v68 * v68);
        float v21 = v21 + v68;
        float v39 = v79 - (float)(v68 * v69);
        float v60 = v60 - (float)(v68 * v70);
        float v57 = v57 - (float)(v68 * v69);
        float v58 = v88 - (float)(v68 * v70);
        float v61 = v61
            + (float)((float)(v69 * (float)((float)(v68 * v68) * v69)) + (float)((float)((float)(v68 * v68) * v70) * v70));
        float v47 = v47 + (float)((float)(v70 * (float)(v68 * v70)) + (float)((float)(v68 * v69) * v69));
        float32x2_t v55 = vadd_f32(v55, vmla_n_f32(vmul_n_f32(vmul_n_f32(v77, v70), v70), vmul_n_f32(v77, v69), v69));
        float v28 = v74;
        long long v25 = v73;
        long long v20 = v72;
        float v49 = *((float *)&v102 + 1);
        float v43 = *(float *)&v102;
        float v42 = v80 - v69;
        float v44 = v86 - v70;
        float v48 = v48 + (float)((float)(v70 * v70) + (float)(v69 * v69));
        float v24 = v87;
        --v50;
      }
      while (v50);
      __CLPK_real __a = v87;
      float v124 = *(float *)&v25;
      float v132 = v26;
      float v133 = v21;
      int v125 = v20;
      float v128 = v28;
      float v136 = v29;
      float v137 = v38;
      float v152 = v31;
      float v81 = v33;
      float v153 = v33;
      float v168 = v59;
      float v169 = v60;
      float v186 = v61;
      float v129 = v36;
      float v130 = v56;
      float v30 = v54;
      float v144 = v54;
      float v138 = v57;
      float v145 = v39;
      float v146 = v42;
      float v33 = v52;
      float v160 = v52;
      float v82 = v53;
      float v154 = v53;
      float v40 = v89;
      float v161 = v89;
      float v162 = v58;
      float v177 = v35;
      float v170 = v44;
      float32x2_t v178 = v55;
      float v187 = v47;
      float v196 = v48;
    }
    int v131 = v25;
    float v188 = v56;
    int v139 = v20;
    float v140 = v21;
    uint64_t v147 = 0;
    uint64_t v155 = 0;
    uint64_t v163 = 0;
    float v180 = v38;
    float v189 = v57;
    float v141 = (float)a7;
    int v156 = 0;
    int v164 = 0;
    float v172 = v29;
    float v173 = v30;
    float v181 = v39;
    float v190 = v42;
    float v182 = v81;
    float v191 = v82;
    uint64_t v126 = 0;
    uint64_t v134 = 0;
    uint64_t v142 = 0;
    float v149 = v24;
    int v150 = v25;
    int v157 = v25;
    float v158 = v26;
    int v165 = v20;
    float v166 = v21;
    float v174 = v31;
    float v175 = v33;
    float v183 = v40;
    float v192 = v58;
    int v127 = 0;
    int v135 = 0;
    int v148 = 0;
    int v143 = 0;
    int v151 = v20;
    float v159 = v21;
    float v171 = v28;
    float v167 = (float)a7;
    float v179 = v36;
    float v176 = v168;
    float v184 = v169;
    float v193 = v170;
    __int32 v194 = v178.i32[1];
    __int32 v185 = v178.i32[0];
    float v195 = v187;
    qmemcpy(__uplo, "LIV", sizeof(__uplo));
    __CLPK_integer __lda = 9;
    __CLPK_integer __n = 9;
    __CLPK_real __vu = 1.0;
    __CLPK_real __vl = 1.0;
    __CLPK_integer v95 = 1;
    __CLPK_integer __il = 1;
    __CLPK_integer v93 = 1;
    __CLPK_real __abstol = 2.0e-10;
    __CLPK_integer __lwork = 512;
    __CLPK_integer __ldz = 9;
    __CLPK_integer v90 = 0;
    ssyevx_(&__uplo[2], &__uplo[1], __uplo, &__n, &__a, &__lda, &__vl, &__vu, &__il, &v95, &__abstol, &v93, __w, &v113, &__ldz, v17, &__lwork, v112, __ifail,
      &v90);
    __CLPK_integer v83 = v90;
    if (v90)
    {
      if (v90 < 1
        || (syslog(3, "HomographyTransform_estimate:The %ld-th eigenvector failed to converge", -(uint64_t)v90),
            printf("HomographyTransform_estimate:The %ld-th eigenvector failed to converge\n", -(uint64_t)v90),
            __CLPK_integer v83 = v90,
            v90 < 0))
      {
        syslog(3, "HomographyTransform_estimate: the %ld-th argument is wrong in ssyevx_ call", -v83);
        printf("HomographyTransform_estimate: the %ld-th argument is wrong in ssyevx_ call\n");
      }
    }
    else
    {
      *(float *)&long long v108 = (float)(v113 - (float)(v119 * *((float *)&v102 + 1))) * (float)(v106 / v103);
      *((float *)&v108 + 1) = (float)(v114 - (float)(v120 * *((float *)&v102 + 1))) * (float)(v106 / v103);
      *((float *)&v108 + 2) = (float)((float)(v115
                                            + (float)((float)((float)((float)(v119
                                                                            * (float)-(float)(v105
                                                                                            * *((float *)&v102 + 1)))
                                                                    + (float)(v105 * v113))
                                                            + (float)(v104 * v114))
                                                    + (float)((float)-(float)(v104 * *((float *)&v102 + 1)) * v120)))
                                    - (float)(*((float *)&v102 + 1) * v121))
                            / v103;
      *((float *)&v108 + 3) = (float)(v116 - (float)(v119 * *(float *)&v102)) * (float)(v106 / v103);
      *(float *)&long long v109 = (float)(v117 - (float)(v120 * *(float *)&v102)) * (float)(v106 / v103);
      *((float *)&v109 + 1) = (float)((float)(v118
                                            + (float)((float)((float)((float)(v119
                                                                            * (float)-(float)(v105 * *(float *)&v102))
                                                                    + (float)(v105 * v116))
                                                            + (float)(v104 * v117))
                                                    + (float)((float)-(float)(v104 * *(float *)&v102) * v120)))
                                    - (float)(*(float *)&v102 * v121))
                            / v103;
      *((float *)&v109 + 2) = v119 * v106;
      *((float *)&v109 + 3) = v120 * v106;
      float v110 = v121 + (float)((float)(v120 * v104) + (float)(v105 * v119));
      if (fabs(v110) >= 1.0e-10)
      {
        for (uint64_t i = 0; i != 32; i += 4)
          *(float *)((char *)&v108 + i) = *(float *)((char *)&v108 + i) / v110;
        v107[0] = v108;
        v107[1] = v109;
        GeomTransform_setParams(a1, v107);
        char v84 = 1;
        if (v16)
        {
LABEL_24:
          if (v84) {
            return 0;
          }
LABEL_25:
          AffineTransform_estimate(a1, a2, a3, a4, a5, a6, a7);
          return 0;
        }
LABEL_23:
        free(v17);
        goto LABEL_24;
      }
      syslog(3, "HomographyTransform_estimate: the 9-th parameter is too small pp[8]=%f \n", v110);
      printf("HomographyTransform_estimate: the 9-th parameter is too small pp[8]=%f \n");
    }
    char v84 = 0;
    if (v16) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  if (v14 == 1) {
    goto LABEL_25;
  }
  if (v14)
  {
    uint64_t v18 = RigidTransform_estimate(a1, a2, a3, a4, a5, a6, a7);
    syslog(3, "GeomTransform_estimate: unknown transform model (%d) use RIGID", *(_DWORD *)a1);
    return v18;
  }
  else
  {
    return RigidTransform_estimate(a1, a2, a3, a4, a5, a6, a7);
  }
}

uint64_t RigidTransform_estimate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6, int a7)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *a6;
  float v9 = *(float *)(a4 + 4 * v8);
  float v10 = *(float *)(a5 + 4 * v8);
  float v11 = *(float *)(a2 + 4 * v8);
  float v12 = *(float *)(a3 + 4 * v8);
  float v13 = (float)(v10 * v10) + (float)(v9 * v9);
  float v14 = (float)(v10 * v12) + (float)(v11 * v9);
  float v15 = (float)(v9 * v12) - (float)(v11 * v10);
  if (a7 >= 2)
  {
    int v16 = a6 + 1;
    uint64_t v17 = a7 - 1;
    do
    {
      unsigned int v18 = *v16++;
      float v19 = *(float *)(a4 + 4 * v18);
      float v20 = *(float *)(a5 + 4 * v18);
      float v21 = *(float *)(a2 + 4 * v18);
      float v22 = *(float *)(a3 + 4 * v18);
      float v13 = (float)((float)(v20 * v20) + (float)(v19 * v19)) + v13;
      float v9 = v19 + v9;
      float v10 = v20 + v10;
      float v14 = (float)((float)(v20 * v22) + (float)(v21 * v19)) + v14;
      float v15 = (float)((float)(v19 * v22) - (float)(v21 * v20)) + v15;
      float v11 = v21 + v11;
      float v12 = v22 + v12;
      --v17;
    }
    while (v17);
  }
  __a[0] = v13;
  __b[0] = v14;
  __b[1] = v15;
  __b[2] = v11;
  __b[3] = v12;
  __a[4] = 0.0;
  __a[1] = 0.0;
  __a[12] = v10;
  __a[13] = v9;
  __a[5] = v13;
  __a[6] = -v10;
  __a[9] = -v10;
  __a[10] = (float)a7;
  __a[14] = 0.0;
  __a[2] = v9;
  __a[3] = v10;
  __a[7] = v9;
  __a[8] = v9;
  __a[11] = 0.0;
  __a[15] = (float)a7;
  __CLPK_integer __nrhs = 1;
  __CLPK_integer __n = 4;
  __CLPK_integer __ldb = 4;
  __CLPK_integer __lda = 4;
  __CLPK_integer __info = 0;
  sposv_("L", &__n, &__nrhs, __a, &__lda, __b, &__ldb, &__info);
  __CLPK_integer v23 = __info;
  if (__info)
  {
    if (__info < 1
      || (syslog(6, "RigidTransform_estimate: not symmetric positive definite matrix"), __CLPK_integer v23 = __info, __info < 0))
    {
      syslog(6, "RigidTransform_estimate: the %ld-th argument is wrong in sposv_ call", -v23);
    }
    *(_OWORD *)__b = xmmword_1A410A0C0;
    uint64_t v24 = 0xFFFFFFFFLL;
    float v25 = 1.0;
  }
  else
  {
    uint64_t v24 = 0;
    float v25 = __b[0];
  }
  if (v25 >= 0.95)
  {
    float v26 = __b[1];
  }
  else
  {
    *(void *)__b = 1065353216;
    float v25 = 1.0;
    float v26 = 0.0;
  }
  *(float *)&long long v33 = v25;
  *((float *)&v33 + 1) = -v26;
  *((void *)&v33 + 1) = __PAIR64__(LODWORD(v26), LODWORD(__b[2]));
  float v34 = v25;
  __CLPK_real v35 = __b[3];
  uint64_t v36 = 0;
  GeomTransform_setParams(a1, &v33);
  return v24;
}

double AffineTransform_estimate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6, int a7)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *a6;
  float v9 = *(float *)(a4 + 4 * v8);
  float v10 = *(float *)(a5 + 4 * v8);
  float v11 = *(float *)(a2 + 4 * v8);
  float v12 = *(float *)(a3 + 4 * v8);
  float v13 = v9 * v9;
  float v14 = v9 * v10;
  float v15 = v10 * v10;
  float v16 = v9 * v11;
  float v17 = v10 * v11;
  float v18 = v9 * v12;
  float v19 = v10 * v12;
  if (a7 >= 2)
  {
    float v20 = a6 + 1;
    uint64_t v21 = a7 - 1;
    do
    {
      unsigned int v22 = *v20++;
      float v23 = *(float *)(a4 + 4 * v22);
      float v24 = *(float *)(a5 + 4 * v22);
      float v25 = *(float *)(a2 + 4 * v22);
      float v26 = *(float *)(a3 + 4 * v22);
      float v13 = v13 + (float)(v23 * v23);
      float v14 = v14 + (float)(v23 * v24);
      float v15 = v15 + (float)(v24 * v24);
      float v9 = v23 + v9;
      float v10 = v24 + v10;
      float v16 = v16 + (float)(v23 * v25);
      float v17 = v17 + (float)(v24 * v25);
      float v11 = v25 + v11;
      float v18 = v18 + (float)(v23 * v26);
      float v19 = v19 + (float)(v24 * v26);
      float v12 = v26 + v12;
      --v21;
    }
    while (v21);
  }
  __a[0] = v13;
  __a[1] = v14;
  __a[2] = v9;
  float v43 = v15;
  float v44 = v10;
  __b[0] = v16;
  __b[1] = v17;
  __b[2] = v11;
  __b[3] = v18;
  unint64_t v38 = __PAIR64__(LODWORD(v12), LODWORD(v19));
  float v42 = v14;
  float v47 = v9;
  float v48 = v10;
  uint64_t v57 = 0;
  uint64_t v62 = 0;
  float v49 = (float)a7;
  uint64_t v53 = 0;
  int v58 = 0;
  int v63 = 0;
  uint64_t v40 = 0;
  uint64_t v45 = 0;
  float v54 = v13;
  float v55 = v14;
  float v59 = v14;
  float v60 = v15;
  float v64 = v9;
  float v65 = v10;
  int v41 = 0;
  int v46 = 0;
  int v50 = 0;
  uint64_t v51 = 0;
  int v52 = 0;
  float v56 = v9;
  float v61 = v10;
  float v66 = (float)a7;
  __CLPK_integer __nrhs = 1;
  __CLPK_integer __n = 6;
  __CLPK_integer __ldb = 6;
  __CLPK_integer __lda = 6;
  __CLPK_integer __info = 0;
  sposv_("L", &__n, &__nrhs, __a, &__lda, __b, &__ldb, &__info);
  __CLPK_integer v27 = __info;
  if (__info)
  {
    if (__info < 1
      || (syslog(3, "AffineTransform_estimate: not symmetric positive definite matrix"), __CLPK_integer v27 = __info, __info < 0))
    {
      syslog(3, "AffineTransform_estimate: the %ld-th argument is wrong in sposv_ call", -v27);
    }
  }
  long long v34 = *(_OWORD *)__b;
  unint64_t v35 = v38;
  uint64_t v36 = 0;
  return GeomTransform_setParams(a1, &v34);
}

float GeomTransform_adjustToUnitySize(float *a1, float *a2, unint64_t a3, unint64_t a4, int a5)
{
  uint64_t v5 = 0;
  float v6 = (float)a3;
  float v7 = (float)a4;
  if (a3 <= a4) {
    unint64_t v8 = a4;
  }
  else {
    unint64_t v8 = a3;
  }
  float v9 = v6 / (float)v8;
  float v10 = v7 / (float)v8;
  float v11 = v7 / v6;
  float v12 = v6 / v7;
  *a1 = *a2 + (float)(v9 * a2[6]);
  float v13 = (float)(v10 * a2[7]) + (float)((float)(v7 / v6) * a2[1]);
  float v14 = -(float)v8;
  float v15 = v14 / v6;
  uint64_t v16 = 1;
  if (a5) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = 3;
  }
  uint64_t v18 = 2;
  if (a5) {
    uint64_t v19 = 2;
  }
  else {
    uint64_t v19 = 6;
  }
  if (a5) {
    uint64_t v16 = 3;
  }
  a1[v17] = v13;
  a1[v19] = (float)((float)((float)((float)((float)(*a2 + (float)(v9 * a2[6])) + (float)(v11 * a2[1]))
                                  + (float)(v10 * a2[7]))
                          + (float)(v15 * a2[2]))
                  + -1.0)
          * -0.5;
  a1[v16] = (float)(v9 * a2[6]) + (float)(v12 * a2[3]);
  a1[4] = a2[4] + (float)(v10 * a2[7]);
  uint64_t v20 = 5;
  if (a5) {
    uint64_t v21 = 5;
  }
  else {
    uint64_t v21 = 7;
  }
  if (a5) {
    uint64_t v18 = 6;
  }
  a1[v21] = (float)((float)((float)((float)(a2[4] + (float)((float)(v9 * a2[6]) + (float)(v12 * a2[3])))
                                  + (float)(v10 * a2[7]))
                          + (float)((float)(v14 / v7) * a2[5]))
                  + -1.0)
          * -0.5;
  if (a5) {
    uint64_t v20 = 7;
  }
  a1[v18] = (float)(v9 + v9) * a2[6];
  a1[v20] = (float)(v10 + v10) * a2[7];
  a1[8] = (float)((float)-(float)(v10 * a2[7]) - (float)(v9 * a2[6])) + 1.0;
  do
  {
    float result = a1[v5] / a1[8];
    a1[v5++] = result;
  }
  while (v5 != 9);
  return result;
}

float GeomTransform_adjustfromUnitySize(uint64_t a1, _DWORD *a2, unint64_t a3, unint64_t a4, int a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a3 <= a4) {
    unint64_t v6 = a4;
  }
  else {
    unint64_t v6 = a3;
  }
  v34[0] = (float)((float)a3 + (float)a3) / (float)v6;
  v34[1] = 0.0;
  v34[2] = (float)-(float)a3 / (float)v6;
  v34[3] = 0.0;
  v34[4] = (float)((float)a4 + (float)a4) / (float)v6;
  v34[5] = (float)-(float)a4 / (float)v6;
  v34[6] = 0.0;
  v34[7] = 0.0;
  v34[8] = 1.0;
  float v29 = (float)v6 / (float)(2 * a3);
  uint64_t v30 = 0x3F00000000000000;
  int v31 = 0;
  float v32 = (float)v6 / (float)(2 * a4);
  long long v33 = xmmword_1A410A0D0;
  if (a5) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = 3;
  }
  int v8 = a2[v7];
  if (a5) {
    uint64_t v9 = 2;
  }
  else {
    uint64_t v9 = 6;
  }
  if (a5) {
    uint64_t v10 = 3;
  }
  else {
    uint64_t v10 = 1;
  }
  v35[0] = *a2;
  v35[1] = v8;
  if (a5) {
    uint64_t v11 = 5;
  }
  else {
    uint64_t v11 = 7;
  }
  if (a5) {
    uint64_t v12 = 7;
  }
  else {
    uint64_t v12 = 5;
  }
  int v13 = a2[v12];
  int v14 = a2[8];
  if (a5) {
    uint64_t v15 = 6;
  }
  else {
    uint64_t v15 = 2;
  }
  int v16 = a2[v15];
  int v17 = a2[v11];
  int v18 = a2[4];
  int v19 = a2[v10];
  v35[2] = a2[v9];
  v35[3] = v19;
  v35[4] = v18;
  v35[5] = v17;
  v35[6] = v16;
  v35[7] = v13;
  v35[8] = v14;
  mul3x3Matrix((uint64_t)v36, (uint64_t)v35, (uint64_t)&v29, 0);
  mul3x3Matrix((uint64_t)v36, (uint64_t)v34, (uint64_t)v36, 0);
  if (fabsf(v37) < 1.0e-10) {
    syslog(3, "GeomTransform_changeCoordinateSystem failed");
  }
  for (uint64_t i = 0; i != 9; ++i)
    *(float *)&v36[i] = *(float *)&v36[i] / v37;
  int v21 = v36[v7];
  int v22 = v36[v9];
  int v23 = v36[v10];
  int v24 = v36[v11];
  int v25 = v36[4];
  int v26 = v36[v15];
  int v27 = v36[v12];
  *(_DWORD *)a1 = v36[0];
  *(_DWORD *)(a1 + 4) = v21;
  float result = v37;
  *(_DWORD *)(a1 + 8) = v22;
  *(_DWORD *)(a1 + 12) = v23;
  *(_DWORD *)(a1 + 16) = v25;
  *(_DWORD *)(a1 + 20) = v24;
  *(_DWORD *)(a1 + 24) = v26;
  *(_DWORD *)(a1 + 28) = v27;
  *(float *)(a1 + 32) = result;
  return result;
}

float GeomTransform_fromUnityToImageSize(_DWORD *a1, uint64_t a2, unint64_t a3, unint64_t a4, int a5)
{
  float v5 = (float)a3;
  float v6 = (float)a4;
  *a1 = *(_DWORD *)a2;
  uint64_t v7 = 1;
  if (a5) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = 3;
  }
  uint64_t v9 = 2;
  if (a5) {
    uint64_t v10 = 2;
  }
  else {
    uint64_t v10 = 6;
  }
  if (a5) {
    uint64_t v7 = 3;
  }
  uint64_t v11 = 5;
  if (a5) {
    uint64_t v12 = 5;
  }
  else {
    uint64_t v12 = 7;
  }
  if (a5)
  {
    uint64_t v9 = 6;
    uint64_t v11 = 7;
  }
  *(float *)&a1[v8] = (float)((float)a3 / (float)a4) * *(float *)(a2 + 4);
  *(float *)&a1[v10] = *(float *)(a2 + 8) * v5;
  *(float *)&a1[v7] = (float)((float)a4 / (float)a3) * *(float *)(a2 + 12);
  a1[4] = *(_DWORD *)(a2 + 16);
  *(float *)&a1[v12] = *(float *)(a2 + 20) * v6;
  *(float *)&a1[v9] = *(float *)(a2 + 24) / v5;
  float result = *(float *)(a2 + 28) / v6;
  *(float *)&a1[v11] = result;
  a1[8] = 1065353216;
  return result;
}

float GeomTransform_get3x3Matrix(uint64_t a1, float *a2, unint64_t a3, unint64_t a4, int a5)
{
  return GeomTransform_adjustToUnitySize(a2, (float *)(a1 + 4), a3, a4, a5);
}

uint64_t GeomTransform_numTestsToDo(_DWORD *a1, int a2, int a3)
{
  int v3 = *a1;
  if (*a1 == 2)
  {
    int v4 = ((a3 - a2) << 10) / a3;
    float v5 = (unsigned __int16 *)&KNumSamplesToTest_Homography;
  }
  else if (v3 == 1)
  {
    int v4 = ((a3 - a2) << 10) / a3;
    float v5 = (unsigned __int16 *)&KNumSamplesToTest_Affine;
  }
  else
  {
    if (v3)
    {
      uint64_t v6 = KKNumSamplesToTest_Rigid[((a3 - a2) << 10) / a3];
      syslog(3, "GeomTransform_numTestsToDo: unknown transform model (%d) use RIGID", *a1);
      return v6;
    }
    int v4 = ((a3 - a2) << 10) / a3;
    float v5 = KKNumSamplesToTest_Rigid;
  }
  return v5[v4];
}

float normalizePoints(float *a1, float *a2, float *a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6, int a7)
{
  if (a7 <= 0)
  {
    float v13 = (float)a7;
    float v15 = 0.0;
    float v16 = 0.0 / (float)a7;
    float v14 = v16;
  }
  else
  {
    uint64_t v7 = a7;
    float v8 = 0.0;
    uint64_t v9 = a7;
    uint64_t v10 = a6;
    float v11 = 0.0;
    do
    {
      unsigned int v12 = *v10++;
      float v11 = v11 + *(float *)(a4 + 4 * v12);
      float v8 = v8 + *(float *)(a5 + 4 * v12);
      --v9;
    }
    while (v9);
    float v13 = (float)a7;
    float v14 = v11 / (float)a7;
    float v15 = 0.0;
    float v16 = v8 / (float)a7;
    do
    {
      unsigned int v17 = *a6++;
      float v18 = *(float *)(a4 + 4 * v17) - v14;
      float v19 = *(float *)(a5 + 4 * v17) - v16;
      float v15 = v15 + sqrtf((float)(v19 * v19) + (float)(v18 * v18));
      --v7;
    }
    while (v7);
  }
  float v20 = (float)(v13 * 1.4142) / v15;
  float v21 = -(float)(v20 * v14);
  *a1 = v20;
  float result = -(float)(v20 * v16);
  *a2 = v21;
  *a3 = result;
  return result;
}

_DWORD *IPDetector_constructor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = malloc_type_calloc(1uLL, 0x48uLL, 0x10B0040E37476F1uLL);
  uint64_t v7 = v6;
  if (!v6) {
    goto LABEL_17;
  }
  v6[10] = 3;
  *(void *)uint64_t v6 = a1;
  *((void *)v6 + 1) = a2;
  *((void *)v6 + 2) = a3;
  float v8 = malloc_type_calloc(1uLL, a3 * a2, 0x100004077774924uLL);
  *((void *)v7 + 3) = v8;
  if (!v8)
  {
    syslog(3, "IPDetector_constructor: Cannot allocate mFltImage ");
LABEL_17:
    IPDetector_destructor(v7);
    return 0;
  }
  uint64_t v10 = *((void *)v7 + 1);
  uint64_t v9 = *((void *)v7 + 2);
  unsigned int v11 = boxFilter_uint8_init(v9, *v7, v10, v7[10]);
  if ((v11 & 0x80000000) != 0)
  {
    syslog(3, "IPDetector_constructor: Cannot allocate box filter");
    goto LABEL_17;
  }
  if (2 * v9 * v10 <= (unint64_t)v11) {
    size_t v12 = v11;
  }
  else {
    size_t v12 = 2 * v9 * v10;
  }
  float v13 = malloc_type_calloc(1uLL, v12, 0x1A6468A2uLL);
  *((void *)v7 + 4) = v13;
  if (!v13)
  {
    syslog(3, "IPDetector_constructor: Cannot allocate mTmpBuffer ");
    goto LABEL_17;
  }
  bzero(v13, v12);
  float v14 = malloc_type_calloc(1uLL, 0x960uLL, 0x1000040274DC3F3uLL);
  *((void *)v7 + 6) = v14;
  if (!v14)
  {
    float v19 = "IPDetector_constructor: Cannot allocate mCornerVec ";
LABEL_16:
    syslog(3, v19);
    goto LABEL_17;
  }
  bzero(v14, 0x960uLL);
  size_t v15 = 2 * a1;
  *((void *)v7 + 7) = malloc_type_calloc(1uLL, v15, 0x1000040BDFB0063uLL);
  size_t v16 = 2 * a2;
  unsigned int v17 = malloc_type_calloc(1uLL, v16, 0x1000040BDFB0063uLL);
  *((void *)v7 + 8) = v17;
  float v18 = (void *)*((void *)v7 + 7);
  float v19 = "IPDetector_constructor: Cannot allocate mBX, mBY ";
  if (!v18 || !v17) {
    goto LABEL_16;
  }
  bzero(v18, v15);
  bzero(*((void **)v7 + 8), v16);
  return v7;
}

void IPDetector_destructor(void *a1)
{
  if (a1)
  {
    long long v2 = (void *)a1[8];
    if (v2)
    {
      free(v2);
      a1[8] = 0;
    }
    int v3 = (void *)a1[7];
    if (v3)
    {
      free(v3);
      a1[7] = 0;
    }
    int v4 = (void *)a1[6];
    if (v4)
    {
      free(v4);
      a1[6] = 0;
    }
    float v5 = (void *)a1[4];
    if (v5)
    {
      free(v5);
      a1[4] = 0;
    }
    uint64_t v6 = (void *)a1[3];
    if (v6) {
      free(v6);
    }
    free(a1);
  }
}

uint64_t IPDetector_execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9, uint64_t a10, NSObject *a11)
{
  unsigned __int16 v11 = 0;
  if (a8 >= 0x18 && a9 >= 0x18)
  {
    if (IPDetector_response(a1, a6, a7, a8, a9, a10, a11) == -1) {
      return 0;
    }
    IPDetector_cornerDetect(a1, a8 - 23, a9 - 23, a10, 11, a11);
    if (!a5)
    {
      return 0;
    }
    else
    {
      unsigned __int16 v11 = 0;
      uint64_t v19 = a5;
      float v20 = (_WORD *)(*(void *)(a1 + 48) + 2);
      do
      {
        __int16 v21 = v20[1];
        if (v21)
        {
          LOWORD(v18) = *(v20 - 1);
          float v22 = (float)LODWORD(v18);
          *(float *)(a2 + 4 * v11) = v22;
          LOWORD(v22) = *v20;
          float v18 = (float)LODWORD(v22);
          *(float *)(a3 + 4 * v11) = v18;
          *(_WORD *)(a4 + 2 * v11++) = v21;
        }
        v20 += 3;
        --v19;
      }
      while (v19);
    }
  }
  return v11;
}

uint64_t IPDetector_response(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4, uint64_t a5, uint64_t a6, NSObject *a7)
{
  uint64_t v12 = a3 + a3 * a6;
  float v13 = (void *)(*(void *)(a1 + 24) + v12);
  if (boxFilter_uint8(v13, (void *)(a2 + v12), a6, a4, a5, *(_DWORD *)(a1 + 40), *(void **)(a1 + 32)) == -1)
  {
    syslog(3, "IPDetector_response: box filter failed");
    return 0xFFFFFFFFLL;
  }
  else
  {
    *(void *)&v23[4] = 0;
    int v24 = &v23[4];
    uint64_t v25 = 0x2000000000;
    uint64_t v26 = *(void *)(a1 + 32);
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 0x40000000;
    long long v19[2] = __IPDetector_response_block_invoke;
    v19[3] = &unk_1E5B1A948;
    v19[5] = v13;
    v19[6] = a6;
    v19[4] = &v23[4];
    int v20 = 3 * a6;
    int v21 = 2 * a6;
    int v22 = a4 >> 3;
    *(void *)int v23 = a4 & 7;
    if (a7)
    {
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __IPDetector_response_block_invoke_2;
      block[3] = &unk_1E5B1A970;
      block[4] = v19;
      int v18 = (int)a5 >> 1;
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 0x40000000;
      _OWORD v15[2] = __IPDetector_response_block_invoke_3;
      v15[3] = &unk_1E5B1A998;
      int v16 = (int)a5 >> 1;
      v15[4] = v19;
      v15[5] = a5;
      dispatch_async(a7, v15);
      dispatch_async(a7, block);
      dispatch_barrier_sync(a7, &__block_literal_global);
    }
    else
    {
      __IPDetector_response_block_invoke((uint64_t)v19, 0, a5);
    }
    _Block_object_dispose(&v23[4], 8);
    return 0;
  }
}

void IPDetector_cornerDetect(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, NSObject *a6)
{
  bzero(*(void **)(a1 + 48), 0x960uLL);
  unint64_t v12 = a3 / 0x14;
  unint64_t v13 = 20 * (a3 / 0x14);
  if (a3 >= 0x14)
  {
    unint64_t v14 = 0;
    uint64_t v15 = *(void *)(a1 + 64);
    do
    {
      *(_WORD *)(v15 + 2 * v14) = v14 / v12;
      ++v14;
    }
    while (v13 > (unsigned __int16)v14);
  }
  if (a2 >= 0x14)
  {
    unint64_t v16 = 0;
    uint64_t v17 = *(void *)(a1 + 56);
    do
    {
      *(_WORD *)(v17 + 2 * v16) = v16 / (a2 / 0x14);
      ++v16;
    }
    while (20 * (a2 / 0x14) > (unsigned __int16)v16);
  }
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 0x40000000;
  v22[2] = __IPDetector_cornerDetect_block_invoke;
  v22[3] = &__block_descriptor_tmp_11;
  v22[4] = a1;
  v22[5] = a5;
  v22[6] = a4;
  v22[7] = 20 * (a2 / 0x14);
  if (a6)
  {
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 0x40000000;
    v20[2] = __IPDetector_cornerDetect_block_invoke_2;
    v20[3] = &unk_1E5B1AA00;
    v20[4] = v22;
    int v21 = 10 * v12;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __IPDetector_cornerDetect_block_invoke_3;
    block[3] = &unk_1E5B1AA28;
    int v19 = 10 * v12;
    block[4] = v22;
    void block[5] = 20 * (a3 / 0x14);
    dispatch_async(a6, block);
    dispatch_async(a6, v20);
    dispatch_barrier_sync(a6, &__block_literal_global_16);
  }
  else
  {
    __IPDetector_cornerDetect_block_invoke((uint64_t)v22, 0, v13);
  }
}

uint64_t IPDetector_selectCorners(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, unsigned __int16 *a6, unsigned __int16 *a7, unsigned int a8, unint64_t a9, unint64_t a10, unint64_t a11, unint64_t a12, unint64_t a13, unint64_t a14)
{
  if (a11 < 0x18 || a12 < 0x18) {
    return 0;
  }
  unint64_t v21 = a11 - 23;
  bzero(*(void **)(a1 + 48), 0x960uLL);
  if (a11 - 23 < a13 || a12 - 23 < a14) {
    return 0;
  }
  if (a8)
  {
    unint64_t v23 = (a12 - 23) / a14;
    float v22 = (float)a11 / (float)a9;
    uint64_t v24 = a8;
    do
    {
      unsigned int v25 = *a5++;
      unsigned int v26 = llroundf(v22 * (float)v25);
      unsigned int v28 = *a6++;
      unsigned int v27 = v28;
      signed int v29 = v26 - 11;
      if (((v26 - 11) & 0x80000000) == 0 && v29 < (int)(v21 / a13 * a13))
      {
        unsigned int v30 = llroundf((float)((float)a12 / (float)a10) * (float)v27);
        int v31 = v30 - 11;
        if (((v30 - 11) & 0x80000000) == 0 && v31 < (int)v23 * (int)a14)
        {
          unsigned int v32 = *a7;
          int v33 = v29 / (int)(v21 / a13) + v31 / (int)v23 * a13;
          uint64_t v34 = *(void *)(a1 + 48);
          uint64_t v35 = v34 + 6 * v33;
          unsigned int v37 = *(unsigned __int16 *)(v35 + 4);
          uint64_t v36 = (_WORD *)(v35 + 4);
          if (v37 < v32)
          {
            *uint64_t v36 = v32;
            uint64_t v38 = (_WORD *)(v34 + 6 * v33);
            _WORD *v38 = v26;
            v38[1] = v30;
          }
        }
      }
      ++a7;
      --v24;
    }
    while (v24);
  }
  uint64_t v39 = (unsigned __int16)(a14 * a13);
  if ((_WORD)a14 * (_WORD)a13)
  {
    unsigned __int16 v40 = 0;
    int v41 = (_WORD *)(*(void *)(a1 + 48) + 2);
    do
    {
      __int16 v42 = v41[1];
      if (v42)
      {
        LOWORD(v22) = *(v41 - 1);
        float v43 = (float)LODWORD(v22);
        *(float *)(a2 + 4 * v40) = v43;
        LOWORD(v43) = *v41;
        float v22 = (float)LODWORD(v43);
        *(float *)(a3 + 4 * v40) = v22;
        *(_WORD *)(a4 + 2 * v40++) = v42;
      }
      v41 += 3;
      --v39;
    }
    while (v39);
  }
  else
  {
    return 0;
  }
  return v40;
}

uint64_t IPDetector_distributeCorners(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float *a5, float *a6, unsigned __int16 *a7, unsigned int a8, unint64_t a9, unint64_t a10, unint64_t a11, unint64_t a12, unint64_t a13, unint64_t a14)
{
  if (a11 < 0x18 || a12 < 0x18) {
    return 0;
  }
  bzero(*(void **)(a1 + 48), 0x960uLL);
  if (a8)
  {
    float v22 = (float)a11 / (float)a9;
    unint64_t v23 = (a12 - 23) / a14;
    unint64_t v24 = (a11 - 23) / a13;
    uint64_t v25 = a8;
    do
    {
      unsigned int v26 = llroundf(v22 * *a5);
      int v27 = v26 - 11;
      if (((v26 - 11) & 0x80000000) == 0 && v27 < (int)v24 * (int)a13)
      {
        unsigned int v28 = llroundf((float)((float)a12 / (float)a10) * *a6);
        int v29 = v28 - 11;
        if (((v28 - 11) & 0x80000000) == 0 && v29 < (int)v23 * (int)a14)
        {
          unsigned int v30 = *a7;
          int v31 = v27 / (int)v24 + v29 / (int)v23 * a13;
          uint64_t v32 = *(void *)(a1 + 48);
          uint64_t v33 = v32 + 6 * v31;
          unsigned int v35 = *(unsigned __int16 *)(v33 + 4);
          uint64_t v34 = (_WORD *)(v33 + 4);
          if (v35 < v30)
          {
            *uint64_t v34 = v30;
            uint64_t v36 = (_WORD *)(v32 + 6 * v31);
            *uint64_t v36 = v26;
            v36[1] = v28;
          }
        }
      }
      ++a7;
      ++a6;
      ++a5;
      --v25;
    }
    while (v25);
  }
  uint64_t v37 = (unsigned __int16)(a14 * a13);
  if ((_WORD)a14 * (_WORD)a13)
  {
    unsigned __int16 v38 = 0;
    uint64_t v39 = (_WORD *)(*(void *)(a1 + 48) + 2);
    do
    {
      __int16 v40 = v39[1];
      if (v40)
      {
        LOWORD(v22) = *(v39 - 1);
        float v41 = (float)LODWORD(v22);
        *(float *)(a2 + 4 * v38) = v41;
        LOWORD(v41) = *v39;
        float v22 = (float)LODWORD(v41);
        *(float *)(a3 + 4 * v38) = v22;
        *(_WORD *)(a4 + 2 * v38++) = v40;
      }
      v39 += 3;
      --v37;
    }
    while (v37);
  }
  else
  {
    return 0;
  }
  return v38;
}

vImage_Error boxFilter_uint8_init(unsigned int a1, unsigned int a2, unsigned int a3, uint32_t kernel_height)
{
  char v7 = 0;
  src.data = &v7;
  src.height = a3;
  src.width = a2;
  src.rowBytes = a1;
  dest.data = &v7;
  dest.height = a3;
  dest.width = a2;
  dest.rowBytes = a1;
  vImage_Error result = vImageBoxConvolve_Planar8(&src, &dest, 0, 0, 0, kernel_height, kernel_height, 0, 0x82u);
  if ((result & 0x80000000) != 0)
  {
    syslog(3, "boxFilter_uint8_init: box filter failed when request minimum size err=%d\n", result);
    return 0xFFFFFFFFLL;
  }
  return result;
}

vImage_Error boxFilter_uint8(void *a1, void *a2, unsigned int a3, unsigned int a4, unsigned int a5, uint32_t kernel_width, void *tempBuffer)
{
  src.data = a2;
  src.height = a5;
  src.width = a4;
  src.rowBytes = a3;
  dest.data = a1;
  dest.height = a5;
  dest.width = a4;
  dest.rowBytes = a3;
  vImage_Error result = vImageBoxConvolve_Planar8(&src, &dest, tempBuffer, 0, 0, kernel_width, kernel_width, 0, 2u);
  if (result)
  {
    syslog(3, "boxFilter_uint8: box filter failed err=%d\n", result);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t invMatrix(__CLPK_real *a1, __CLPK_integer a2)
{
  if (a2 != 3)
  {
    __CLPK_integer __lda = a2;
    int v18 = (__CLPK_integer *)malloc_type_malloc(4 * a2 + 4, 0x100004052888210uLL);
    __CLPK_integer __lwork = a2 * a2;
    int v19 = (__CLPK_real *)malloc_type_malloc(4 * (a2 * a2), 0x100004052888210uLL);
    __CLPK_integer __info = 0;
    sgetrf_(&__lda, &__lda, a1, &__lda, v18, &__info);
    if (__info)
    {
      syslog(3, " invMatrix failed INFO1 = %ld\n");
    }
    else
    {
      sgetri_(&__lda, a1, &__lda, v18, v19, &__lwork, &__info);
      if (!__info)
      {
        uint64_t v16 = 0;
        goto LABEL_12;
      }
      syslog(3, " invMatrix failed INFO2 = %ld\n");
    }
    uint64_t v16 = 0xFFFFFFFFLL;
LABEL_12:
    free(v18);
    free(v19);
    return v16;
  }
  float v3 = *a1;
  float v4 = a1[1];
  float v6 = a1[2];
  float v5 = a1[3];
  float v7 = a1[4];
  float v8 = a1[5];
  float v9 = a1[6];
  float v10 = a1[7];
  float v11 = a1[8];
  float v12 = (float)(v11 * v7) - (float)(v10 * v8);
  float v13 = (float)(v11 * v4) - (float)(v10 * v6);
  float v14 = (float)(v8 * v4) - (float)(v7 * v6);
  float v15 = (float)((float)(*a1 * v12) - (float)(v5 * v13)) + (float)(v9 * v14);
  if (v15 == 0.0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v20 = 0;
  *a1 = v12;
  a1[1] = -v13;
  a1[2] = v14;
  a1[3] = -(float)((float)(v11 * v5) - (float)(v9 * v8));
  a1[4] = (float)(v11 * v3) - (float)(v9 * v6);
  a1[5] = -(float)((float)(v6 * (float)-v5) + (float)(v8 * v3));
  a1[6] = (float)(v10 * v5) - (float)(v9 * v7);
  a1[7] = -(float)((float)(v10 * v3) - (float)(v9 * v4));
  a1[8] = (float)(v4 * (float)-v5) + (float)(v7 * v3);
  do
  {
    a1[v20] = a1[v20] / v15;
    ++v20;
  }
  while (v20 != 9);
  return 0;
}

float32x4_t mul3x3Matrix(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)a3;
  unsigned int v5 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)float v22 = *(_DWORD *)a2;
  if (a4)
  {
    *(void *)&v22[4] = *(void *)(a2 + 4);
    *(void *)&v22[12] = *(void *)(a2 + 12);
    *(_OWORD *)&v22[20] = *(_OWORD *)(a2 + 20);
    float v13 = *(float *)a3;
    uint64_t v15 = *(void *)(a3 + 4);
    float32x2_t v17 = *(float32x2_t *)(a3 + 12);
    float32x4_t v19 = *(float32x4_t *)(a3 + 20);
    float32x4_t v6 = (float32x4_t)vextq_s8(*(int8x16_t *)&v22[20], *(int8x16_t *)&v22[20], 4uLL);
    float32x4_t v7 = vmulq_n_f32(*(float32x4_t *)v22, v4);
    float32x4_t v8 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(*(float32x4_t *)v22, *(float32x4_t *)v17.f32, 3), *(float32x4_t *)&v22[12], v19, 2), v6, v19, 3);
    *(float32x4_t *)unint64_t v23 = vmlaq_laneq_f32(vmlaq_lane_f32(v7, *(float32x4_t *)&v22[12], *(float32x2_t *)&v13, 1), v6, *(float32x4_t *)&v13, 2);
    *(float32x4_t *)&unsigned char v23[12] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_laneq_f32(*(float32x4_t *)v22, *(float32x4_t *)&v13, 3), *(float32x4_t *)&v22[12], v17, 1), v6, *(float32x4_t *)v17.f32, 2);
    *(void *)&v23[24] = v8.i64[0];
    float32x4_t result = *(float32x4_t *)v23;
    *(_OWORD *)a1 = *(_OWORD *)v23;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)&v23[16];
    *(_DWORD *)(a1 + 32) = v8.i32[2];
  }
  else
  {
    *(_DWORD *)&v22[4] = *(_DWORD *)(a2 + 12);
    *(_DWORD *)&void v22[8] = *(_DWORD *)(a2 + 24);
    *(_DWORD *)&v22[12] = *(_DWORD *)(a2 + 4);
    *(_DWORD *)&v22[16] = *(_DWORD *)(a2 + 16);
    *(_DWORD *)&v22[20] = *(_DWORD *)(a2 + 28);
    *(_DWORD *)&v22[24] = *(_DWORD *)(a2 + 8);
    *(_DWORD *)&v22[28] = *(_DWORD *)(a2 + 20);
    *(_DWORD *)&v22[32] = *(_DWORD *)(a2 + 32);
    float32x2_t v14 = (float32x2_t)__PAIR64__(*(_DWORD *)(a3 + 12), LODWORD(v4));
    int v16 = *(_DWORD *)(a3 + 24);
    v18.i64[0] = __PAIR64__(v5, *(_DWORD *)(a3 + 4));
    v18.i32[2] = *(_DWORD *)(a3 + 28);
    v18.i32[3] = *(_DWORD *)(a3 + 8);
    int v20 = *(_DWORD *)(a3 + 20);
    int v21 = *(_DWORD *)(a3 + 32);
    float32x4_t v10 = (float32x4_t)vextq_s8(*(int8x16_t *)&v22[20], *(int8x16_t *)&v22[20], 4uLL);
    float32x4_t v11 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)v22, v14.f32[0]), *(float32x4_t *)&v22[12], v14, 1), v10, *(float32x4_t *)v14.f32, 2);
    float32x4_t v12 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_laneq_f32(*(float32x4_t *)v22, *(float32x4_t *)v14.f32, 3), *(float32x4_t *)&v22[12], (float32x2_t)__PAIR64__(v5, *(_DWORD *)(a3 + 4)), 1), v10, v18, 2);
    float32x4_t result = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(*(float32x4_t *)v22, v18, 3), *(float32x4_t *)&v22[12], *(float32x4_t *)((char *)&v18 + 8), 2), v10, *(float32x4_t *)((char *)&v18 + 8), 3);
    *(_DWORD *)a1 = v11.i32[0];
    *(_DWORD *)(a1 + 4) = v12.i32[0];
    *(_DWORD *)(a1 + 8) = result.i32[0];
    *(_DWORD *)(a1 + 12) = v11.i32[1];
    *(_DWORD *)(a1 + 16) = v12.i32[1];
    *(_DWORD *)(a1 + 20) = result.i32[1];
    *(_DWORD *)(a1 + 24) = v11.i32[2];
    *(_DWORD *)(a1 + 28) = v12.i32[2];
    *(_DWORD *)(a1 + 32) = result.i32[2];
  }
  return result;
}

void *DigestShared_constructor(uint64_t a1, uint64_t a2)
{
  float v4 = malloc_type_calloc(1uLL, 0x20uLL, 0x1010040F32E1FD2uLL);
  unsigned int v5 = v4;
  if (!v4
    || ((*float v4 = a1,
         v4[1] = a2,
         v4[2] = malloc_type_calloc(1uLL, 8 * a1, 0x100004000313F17uLL),
         float32x4_t v6 = malloc_type_calloc(1uLL, 8 * v5[1], 0x100004000313F17uLL),
         v5[3] = v6,
         v5[2])
      ? (BOOL v7 = v6 == 0)
      : (BOOL v7 = 1),
        v7))
  {
    DigestShared_destructor(v5);
    return 0;
  }
  return v5;
}

void DigestShared_destructor(void *a1)
{
  if (a1)
  {
    long long v2 = (void *)a1[2];
    if (v2) {
      free(v2);
    }
    float v3 = (void *)a1[3];
    if (v3) {
      free(v3);
    }
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }
}

void *Digest_constructor(size_t a1, unint64_t a2, uint64_t a3)
{
  if (a3 && (float32x4_t v6 = malloc_type_calloc(1uLL, 0x38uLL, 0x1090040653827A0uLL)) != 0)
  {
    BOOL v7 = v6;
    v6[6] = 0;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *(_OWORD *)float32x4_t v6 = 0u;
    if (!Digest_init(v6, a1, a2))
    {
      v7[6] = a3;
      return v7;
    }
    Digest_purgeResources((uint64_t)v7);
    free(v7);
  }
  else
  {
    Digest_purgeResources(0);
  }
  return 0;
}

uint64_t Digest_init(size_t *a1, size_t a2, unint64_t a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*a1 == a2 && a1[1] == a3) {
    return 0;
  }
  Digest_purgeResources((uint64_t)a1);
  *a1 = a2;
  a1[1] = a3;
  a1[2] = (unint64_t)(float)((float)a2 * 0.25);
  a1[3] = (unint64_t)(float)((float)a3 * 0.25);
  a1[4] = (size_t)malloc_type_calloc(1uLL, a2, 0x100004077774924uLL);
  BOOL v7 = malloc_type_calloc(1uLL, a1[1], 0x100004077774924uLL);
  a1[5] = (size_t)v7;
  if (a1[4]) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  int v9 = v8;
  return (v9 << 31 >> 31);
}

void Digest_destructor(void *a1)
{
  Digest_purgeResources((uint64_t)a1);
  if (a1)
  {
    free(a1);
  }
}

double Digest_purgeResources(uint64_t a1)
{
  if (a1)
  {
    long long v2 = *(void **)(a1 + 32);
    if (v2) {
      free(v2);
    }
    float v3 = *(void **)(a1 + 40);
    if (v3) {
      free(v3);
    }
    *(void *)(a1 + 48) = 0;
    double result = 0.0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
  }
  return result;
}

float Norm_constructor(unint64_t a1, unint64_t a2)
{
  float v4 = (float *)malloc_type_malloc(0x20uLL, 0x1000040E0EAB150uLL);
  if (v4)
  {
    float v6 = (float)a2;
    float v7 = (float)a1;
    if (a1 <= a2) {
      unint64_t v8 = a2;
    }
    else {
      unint64_t v8 = a1;
    }
    float v9 = 2.0 / (float)v8;
    *float v4 = v9;
    v4[1] = v9;
    v4[2] = (float)-v7 / (float)v8;
    v4[3] = (float)-v6 / (float)v8;
    v4[4] = 1.0 / v9;
    v4[5] = 1.0 / v9;
    float result = v6 * 0.5;
    v4[6] = v7 * 0.5;
    v4[7] = result;
  }
  return result;
}

float Norm_dir(float *a1, float *a2, float *a3, float a4, float a5)
{
  *a2 = a1[2] + (float)(*a1 * a4);
  float result = a1[3] + (float)(a1[1] * a5);
  *a3 = result;
  return result;
}

float Norm_dirs(float *a1, float *a2, float *a3, float *a4, float *a5, unsigned int a6)
{
  if (a6)
  {
    uint64_t v6 = a6;
    do
    {
      float v7 = *a4++;
      float v8 = v7;
      float v9 = *a5++;
      float result = a1[2] + (float)(*a1 * v8);
      float v11 = a1[3] + (float)(a1[1] * v9);
      *a2++ = result;
      *a3++ = v11;
      --v6;
    }
    while (v6);
  }
  return result;
}

float *Norm_invs(float *result, float *a2, float *a3, float *a4, float *a5, unsigned int a6)
{
  if (a6)
  {
    uint64_t v6 = a6;
    do
    {
      float v7 = *a4++;
      float v8 = v7;
      float v9 = *a5++;
      float v10 = (float)(result[7] + (float)(result[5] * v9)) + 0.5;
      *a2++ = (float)(result[6] + (float)(result[4] * v8)) + 0.5;
      *a3++ = v10;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t *ImageRegistrationCreateContext()
{
  v0 = (uint64_t *)malloc_type_calloc(1uLL, 0x48uLL, 0x10A0040E880AA40uLL);
  if (!v0)
  {
    NSLog(&cfstr_SCallocFailed.isa, "ImageRegistrationCreateContext");
    goto LABEL_11;
  }
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 14, 0, 0);
  v0[7] = (uint64_t)Mutable;
  if (!Mutable)
  {
    NSLog(&cfstr_SCfdictionaryc.isa, "ImageRegistrationCreateContext");
    goto LABEL_11;
  }
  CFMutableArrayRef v3 = CFArrayCreateMutable(v1, 7, 0);
  v0[8] = (uint64_t)v3;
  if (!v3)
  {
    NSLog(&cfstr_SCfarraycreate.isa, "ImageRegistrationCreateContext");
    goto LABEL_11;
  }
  float v4 = RegistrationEngine_constructor();
  uint64_t *v0 = (uint64_t)v4;
  if (!v4)
  {
    NSLog(&cfstr_SRegistratione.isa, "ImageRegistrationCreateContext");
    goto LABEL_11;
  }
  unsigned int v5 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E4F14430], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v6 = dispatch_queue_create("imageRegQueue", v5);
  v0[1] = (uint64_t)v6;
  if (!v6)
  {
    NSLog(&cfstr_SDispatchQueue.isa, "ImageRegistrationCreateContext");
LABEL_11:
    ImageRegistrationDestroyContext(v0);
    return 0;
  }
  return v0;
}

void ImageRegistrationDestroyContext(uint64_t *a1)
{
  if (a1)
  {
    long long v2 = a1[1];
    if (v2) {
      dispatch_release(v2);
    }
    CFMutableArrayRef v3 = (const void *)a1[7];
    if (v3) {
      CFRelease(v3);
    }
    float v4 = (const void *)a1[8];
    if (v4) {
      CFRelease(v4);
    }
    RegistrationEngine_destructor(*a1);
    free(a1);
  }
}

uint64_t ImageRegister(unsigned __int16 ***a1, __CVBuffer *a2, __CVBuffer **a3, unsigned int a4, uint64_t a5, int a6, _DWORD *a7, void **a8, _WORD *a9, unsigned __int16 *a10, unsigned __int16 *a11, unsigned __int16 *a12, unsigned __int16 a13, unint64_t a14, unint64_t a15, const void **a16, int a17)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  __int16 v62 = 0;
  if (!a1 || !a3)
  {
    NSLog(&cfstr_SNullInputPara.isa, "ImageRegister");
    return 0xFFFFFFFFLL;
  }
  float32x4_t v18 = (long long *)a7;
  if (*((unsigned char *)a1 + 16))
  {
    if (a4)
    {
      uint64_t v21 = a4;
      float v22 = a7 + 8;
      do
      {
        *((_OWORD *)v22 - 2) = xmmword_1A410A0C0;
        *((_OWORD *)v22 - 1) = xmmword_1A410A0C0;
        _DWORD *v22 = 1065353216;
        v22 += 9;
        --v21;
      }
      while (v21);
    }
    return 0;
  }
  if (!a4)
  {
    NSLog(&cfstr_SNeedAtLeastOn.isa, "ImageRegister");
    return 0xFFFFFFFFLL;
  }
  unsigned int v28 = a16;
  if (CFArrayGetCount((CFArrayRef)a1[8]))
  {
    NSLog(&cfstr_SCfarraygetcou.isa, "ImageRegister");
    CFArrayRemoveAllValues((CFMutableArrayRef)a1[8]);
  }
  if (a16)
  {
    uint64_t v29 = a17;
    if (a17 >= 1)
    {
      do
      {
        unsigned int v30 = *v28++;
        CFArrayAppendValue((CFMutableArrayRef)a1[8], v30);
        --v29;
      }
      while (v29);
    }
  }
  int v31 = *a3;
  CVPixelBufferRef pixelBuffer = a2;
  CVPixelBufferRef v64 = v31;
  if (!a2 || !v31)
  {
    NSLog(&cfstr_SCouldNotLocat.isa, "ImageRegister");
    return 0xFFFFFFFFLL;
  }
  size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(a2, 0);
  size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a2, 0);
  size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a2, 0);
  if (a1[3] == (unsigned __int16 **)WidthOfPlane
    && a1[4] == (unsigned __int16 **)HeightOfPlane
    && a1[5] == (unsigned __int16 **)BytesPerRowOfPlane)
  {
    goto LABEL_37;
  }
  a1[3] = (unsigned __int16 **)WidthOfPlane;
  a1[4] = (unsigned __int16 **)HeightOfPlane;
  *((float *)a1 + 12) = (float)HeightOfPlane / (float)WidthOfPlane;
  a1[5] = (unsigned __int16 **)BytesPerRowOfPlane;
  unint64_t v35 = WidthOfPlane >= HeightOfPlane ? HeightOfPlane : WidthOfPlane;
  if (v35 < 0x7E)
  {
    unsigned int v36 = 0;
  }
  else
  {
    unsigned int v36 = 0;
    do
    {
      ++v36;
      BOOL v37 = v35 > 0xFB;
      v35 >>= 1;
    }
    while (v37);
  }
  int v38 = v36 >= 7 ? 7 : v36;
  *((unsigned char *)a1 + 16) = v36 < 2;
  if (!RegistrationEngine_init((uint64_t)*a1, WidthOfPlane, HeightOfPlane, v38 != 0, v38, WidthOfPlane, HeightOfPlane, 0, 0))
  {
LABEL_37:
    uint64_t TemplateImage = CVPixelBufferLockBaseAddress(a2, 0);
    if (!TemplateImage)
    {
      BaseAddressOfPlane = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(a2, 0);
      size_t v40 = CVPixelBufferGetBytesPerRowOfPlane(a2, 0);
      uint64_t TemplateImage = RegistrationEngine_loadTemplateImage((uint64_t)*a1, BaseAddressOfPlane, v40, a1[1]);
      if (TemplateImage) {
        goto LABEL_39;
      }
      if (a13)
      {
        uint64_t TemplateImage = RegistrationEngine_loadCorners((uint64_t)*a1, a10, a11, a12, a13, a14, a15);
        if (TemplateImage) {
          goto LABEL_39;
        }
      }
      uint64_t TemplateImage = RegistrationEngine_detectCorners((unint64_t *)*a1, a1[1]);
      if (TemplateImage) {
        goto LABEL_39;
      }
      CVPixelBufferUnlockBaseAddress(a2, 0);
      LOBYTE(v62) = 0;
      uint64_t v41 = (uint64_t)*a1;
      __int16 v42 = **a1;
      uint64_t v43 = *((unsigned __int16 *)*a1 + *v42 + 20128);
      if (a8)
      {
        *a9 = v43;
        memcpy(*a8, (const void *)(v41 + 1600 * *v42 + 256), 4 * v43);
        size_t v58 = 4 * v43;
        memcpy((char *)*a8 + 1600, &(*a1)[200 * ***a1 + 2032], 4 * v43);
        if (v43)
        {
          float v44 = (float *)((char *)*a8 + 3200);
          uint64_t v45 = &(*a1)[100 * ***a1 + 4032];
          do
          {
            unsigned int v46 = *(unsigned __int16 *)v45;
            uint64_t v45 = (unsigned __int16 **)((char *)v45 + 2);
            *v44++ = (float)v46;
            --v43;
          }
          while (v43);
        }
      }
      else
      {
        size_t v58 = 4 * v43;
      }
      uint64_t v47 = 0;
      uint64_t v48 = a4 <= 1 ? 1 : a4;
      uint64_t v60 = v48;
      uint64_t v61 = (int)(a4 - 1);
      uint64_t v57 = a3 + 1;
      float v59 = a8 + 1;
      while (1)
      {
        if (v47 < v61) {
          *(&pixelBuffer + (v47 & 1)) = v57[v47];
        }
        uint64_t v49 = v47 + 1;
        uint64_t v50 = (v47 + 1) & 1;
        uint64_t v51 = *(&pixelBuffer + v50);
        uint64_t InputImage = CVPixelBufferLockBaseAddress(v51, 0);
        if (InputImage) {
          break;
        }
        *(unsigned char *)((unint64_t)&v62 | v50) = 1;
        uint64_t v53 = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(v51, 0);
        size_t v54 = CVPixelBufferGetBytesPerRowOfPlane(v51, 0);
        uint64_t InputImage = RegistrationEngine_loadInputImage((uint64_t)*a1, v53, v54, a1[1]);
        if (InputImage) {
          break;
        }
        if (a6)
        {
          size_t v55 = CVPixelBufferGetWidthOfPlane(v51, 0);
          size_t v56 = CVPixelBufferGetHeightOfPlane(v51, 0);
          GeomTransform_adjustfromUnitySize((uint64_t)v18, v18, v55, v56, 1);
        }
        uint64_t InputImage = RegistrationEngine_execute(*a1, a6, v18);
        if (InputImage) {
          break;
        }
        CVPixelBufferUnlockBaseAddress(v51, 0);
        *(unsigned char *)((unint64_t)&v62 | v50) = 0;
        GeomTransform_get3x3Matrix((uint64_t)(*a1)[3], (float *)v18, (unint64_t)a1[3], (unint64_t)a1[4], 1);
        if (a8)
        {
          memcpy(v59[v47], (char *)*a1 + 44276, v58);
          memcpy((char *)v59[v47] + 1600, (char *)*a1 + 45876, v58);
          memcpy((char *)v59[v47] + 3200, (char *)*a1 + 54676, v58);
        }
        float32x4_t v18 = (long long *)((char *)v18 + 36);
        ++v47;
        if (v60 == v49)
        {
          uint64_t TemplateImage = 0;
          goto LABEL_68;
        }
      }
      uint64_t TemplateImage = InputImage;
LABEL_68:
      if ((_BYTE)v62) {
LABEL_39:
      }
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
    }
  }
  else
  {
    uint64_t TemplateImage = 0xFFFFFFFFLL;
  }
  if (HIBYTE(v62)) {
    CVPixelBufferUnlockBaseAddress(v64, 0);
  }
  CFDictionaryRemoveAllValues((CFMutableDictionaryRef)a1[7]);
  CFArrayRemoveAllValues((CFMutableArrayRef)a1[8]);
  return TemplateImage;
}

unint64_t *RansacEngine_constructor(unint64_t a1, uint64_t a2)
{
  float v4 = (unint64_t *)malloc_type_calloc(0x68uLL, 1uLL, 0xDC30CF9BuLL);
  unsigned int v5 = v4;
  if (!v4) {
    goto LABEL_15;
  }
  *float v4 = a1;
  v4[1] = (unint64_t)malloc_type_calloc(8 * a1, 1uLL, 0x271E4151uLL);
  v5[2] = (unint64_t)malloc_type_calloc(8 * *v5, 1uLL, 0xBB73F235uLL);
  v5[4] = (unint64_t)malloc_type_calloc(4 * a1, 1uLL, 0xA2616716uLL);
  v5[5] = (unint64_t)malloc_type_calloc(4 * a1, 1uLL, 0xFFEB1C7uLL);
  v5[6] = (unint64_t)malloc_type_calloc(4 * a1, 1uLL, 0xF4676D45uLL);
  size_t v6 = 2 * a1;
  v5[7] = (unint64_t)malloc_type_calloc(v6, 1uLL, 0x86CA49A9uLL);
  float v7 = GeomTransform_constructor(0, a2);
  v5[9] = (unint64_t)v7;
  if (!v5[1]) {
    goto LABEL_15;
  }
  if (v5[2]
    && v5[4]
    && v5[5]
    && v5[6]
    && v5[7]
    && v7
    && (v5[11] = (unint64_t)malloc_type_calloc(v6, 1uLL, 0xD8F0A2D5uLL),
        float v8 = GeomTransform_constructor(2u, a2),
        v5[10] = (unint64_t)v8,
        v5[11])
    && v8)
  {
    *((_DWORD *)v5 + 6) = 0;
    if (*v5)
    {
      unint64_t v9 = 0;
      unint64_t v10 = v5[1];
      do
      {
        *(void *)(v10 + 8 * v9) = v9;
        ++v9;
      }
      while (v9 < *v5);
    }
  }
  else
  {
LABEL_15:
    RansacEngine_destructor(v5);
    return 0;
  }
  return v5;
}

void RansacEngine_destructor(void *a1)
{
  if (a1)
  {
    long long v2 = (void *)a1[1];
    if (v2)
    {
      free(v2);
      a1[1] = 0;
    }
    CFMutableArrayRef v3 = (void *)a1[2];
    if (v3)
    {
      free(v3);
      a1[2] = 0;
    }
    float v4 = (void *)a1[4];
    if (v4)
    {
      free(v4);
      a1[4] = 0;
    }
    unsigned int v5 = (void *)a1[5];
    if (v5)
    {
      free(v5);
      a1[5] = 0;
    }
    size_t v6 = (void *)a1[6];
    if (v6)
    {
      free(v6);
      a1[6] = 0;
    }
    float v7 = (void *)a1[7];
    if (v7)
    {
      free(v7);
      a1[7] = 0;
    }
    float v8 = (void *)a1[9];
    if (v8)
    {
      GeomTransform_destructor(v8);
      a1[9] = 0;
    }
    unint64_t v9 = (void *)a1[11];
    if (v9)
    {
      free(v9);
      a1[11] = 0;
    }
    unint64_t v10 = (void *)a1[10];
    if (v10) {
      GeomTransform_destructor(v10);
    }
    free(a1);
  }
}

void RansacEngine_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
  bzero(*(void **)(a1 + 8), 8 * *(void *)a1);
  bzero(*(void **)(a1 + 16), 8 * *(void *)a1);
  bzero(*(void **)(a1 + 32), 4 * *(void *)a1);
  bzero(*(void **)(a1 + 40), 4 * *(void *)a1);
  bzero(*(void **)(a1 + 48), 4 * *(void *)a1);
  bzero(*(void **)(a1 + 56), 2 * *(void *)a1);
  long long v2 = *(void **)(a1 + 88);
  size_t v3 = 2 * *(void *)a1;

  bzero(v2, v3);
}

void RansacEngine_findInliers(uint64_t a1, float *a2, uint64_t a3, unsigned __int16 *a4, float *a5, float *a6, const float *a7, const float *a8, float a9, int a10, int a11)
{
  GeomTransform_dirs(a2, *(float **)(a1 + 32), *(float **)(a1 + 40), a5, a6, (unsigned __int16)a10);
  vDSP_vpythg(a7, 1, a8, 1, *(const float **)(a1 + 32), 1, *(const float **)(a1 + 40), 1, *(float **)(a1 + 48), 1, a10);
  if (a11 < 1)
  {
    unsigned __int16 v18 = 0;
  }
  else
  {
    unsigned __int16 v17 = 0;
    unsigned __int16 v18 = 0;
    uint64_t v19 = *(void *)(a1 + 8);
    uint64_t v20 = *(void *)(a1 + 48);
    do
    {
      uint64_t v21 = *(void *)(v19 + 8 * v17);
      if (*(float *)(v20 + 4 * v21) < a9) {
        *(_WORD *)(a3 + 2 * v18++) = v21;
      }
      ++v17;
    }
    while (a11 > v17);
  }
  *a4 = v18;
}

uint64_t RansacEngine_execute(uint64_t a1, uint64_t a2, void *a3, float *a4, float *a5, const float *a6, const float *a7, const float *__C, float a9, vDSP_Length __N)
{
  uint64_t v18 = (unsigned __int16)__N;
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v19 = *(vDSP_Length **)(a1 + 8);
  if (*(void *)a1)
  {
    vDSP_Length v20 = 0;
    do
    {
      v19[v20] = v20;
      ++v20;
    }
    while (v20 < *(void *)a1);
  }
  vDSP_vsorti(__C, v19, 0, (unsigned __int16)__N, -1);
  if ((__int16)__N < 1) {
    return 0;
  }
  while (__C[*(void *)(*(void *)(a1 + 8) + 8 * (v18 - 1))] <= 0.3)
  {
    if (v18-- <= 1) {
      return 0;
    }
  }
  if ((unsigned __int16)v18 < 5u) {
    return 0;
  }
  uint64_t v46 = a2;
  uint64_t v49 = a4;
  uint64_t v50 = a7;
  GeomTransform_setModel(*(void *)(a1 + 72), 0);
  GeomTransform_setModel(*(void *)(a1 + 80), 2);
  uint64_t v22 = 0;
  uint64_t v23 = *(void *)(a1 + 16);
  do
  {
    *(void *)(v23 + 8 * v22) = v22;
    ++v22;
  }
  while (v18 != v22);
  int v47 = 0;
  unsigned __int16 v24 = 0;
  unsigned int v25 = 0;
  int v26 = 0;
  uint64_t v51 = (unsigned __int16 *)(a1 + 64);
  int v53 = 1000;
  do
  {
    int v27 = *(vDSP_Length **)(a1 + 16);
    if (v26 > (int)v18 - 4)
    {
      vDSP_Length v28 = 0;
      do
      {
        v27[v28] = v28;
        ++v28;
      }
      while (v18 != v28);
      int v29 = *(_DWORD *)(a1 + 24);
      if (v29 > 999 - (int)v18)
      {
        int v29 = 0;
        *(_DWORD *)(a1 + 24) = 0;
      }
      vDSP_vsorti(&kRandNumbers[v29], v27, 0, v18, -1);
      int v26 = 0;
      ++*(_DWORD *)(a1 + 24);
      int v27 = *(vDSP_Length **)(a1 + 16);
    }
    uint64_t v30 = 0;
    uint64_t v31 = *(void *)(a1 + 8);
    int v54 = v26;
    uint64_t v32 = &v27[v26];
    do
    {
      v55[v30] = *(void *)(v31 + 8 * v32[v30]);
      ++v30;
    }
    while (v30 != 4);
    uint64_t v33 = *(_DWORD **)(a1 + 72);
    int v34 = GeomTransform_minSupportPoints(v33);
    GeomTransform_estimate((uint64_t)v33, (uint64_t)a6, (uint64_t)v50, (uint64_t)v49, (uint64_t)a5, v55, v34);
    RansacEngine_findInliers(a1, *(float **)(a1 + 72), *(void *)(a1 + 56), v51, v49, a5, a6, v50, a9, (unsigned __int16)__N, v18);
    unint64_t v35 = *(_DWORD **)(a1 + 80);
    int v52 = **(_DWORD **)(a1 + 72);
    int v36 = GeomTransform_minSupportPoints(v35);
    GeomTransform_estimate((uint64_t)v35, (uint64_t)a6, (uint64_t)v50, (uint64_t)v49, (uint64_t)a5, v55, v36);
    RansacEngine_findInliers(a1, *(float **)(a1 + 80), *(void *)(a1 + 88), (unsigned __int16 *)(a1 + 96), v49, a5, a6, v50, a9, (unsigned __int16)__N, v18);
    uint64_t v37 = *(unsigned __int16 *)(a1 + 96);
    unsigned int v38 = *(unsigned __int16 *)(a1 + 64);
    if (v37 <= v38)
    {
      int v39 = v52;
    }
    else
    {
      memcpy(*(void **)(a1 + 56), *(const void **)(a1 + 88), 2 * v37);
      unsigned int v38 = *(unsigned __int16 *)(a1 + 96);
      *(_WORD *)(a1 + 64) = v38;
      int v39 = **(_DWORD **)(a1 + 80);
    }
    if (v38 > v24)
    {
      memcpy(a3, *(const void **)(a1 + 56), 2 * v38);
      int v53 = GeomTransform_numTestsToDo(*(_DWORD **)(a1 + 72), v38, (unsigned __int16)v18);
      unsigned __int16 v24 = v38;
      int v47 = v39;
    }
    if ((int)(v25 + 1) >= v53) {
      break;
    }
    int v26 = v54 + 1;
  }
  while (v25++ < 0x3E7);
  GeomTransform_setModel(*(void *)(a1 + 72), v47);
  GeomTransform_setModel(v46, v47);
  if (v24 < 4u) {
    return 0;
  }
  if (GeomTransform_estimate(*(void *)(a1 + 72), (uint64_t)a6, (uint64_t)v50, (uint64_t)v49, (uint64_t)a5, (unsigned __int16 *)a3, v24) == -1)
  {
LABEL_35:
    syslog(3, "GeomTransform_estimate failed");
    return 0;
  }
  GeomTransform_deepCopy(v46, *(void *)(a1 + 72));
  RansacEngine_findInliers(a1, *(float **)(a1 + 72), *(void *)(a1 + 56), v51, v49, a5, a6, v50, a9, (unsigned __int16)__N, v18);
  unsigned int v41 = *(unsigned __int16 *)(a1 + 64);
  if (v41 > v24)
  {
    while (1)
    {
      unsigned __int16 v42 = v41;
      int v43 = (unsigned __int16)v41;
      memcpy(a3, *(const void **)(a1 + 56), 2 * (unsigned __int16)v41);
      GeomTransform_deepCopy(v46, *(void *)(a1 + 72));
      int v44 = v43;
      unsigned __int16 v24 = v42;
      if (GeomTransform_estimate(*(void *)(a1 + 72), (uint64_t)a6, (uint64_t)v50, (uint64_t)v49, (uint64_t)a5, (unsigned __int16 *)a3, v44) == -1)break; {
      RansacEngine_findInliers(a1, *(float **)(a1 + 72), *(void *)(a1 + 56), v51, v49, a5, a6, v50, a9, (unsigned __int16)__N, v18);
      }
      unsigned int v41 = *(unsigned __int16 *)(a1 + 64);
      if (v41 <= v42) {
        return v24;
      }
    }
    goto LABEL_35;
  }
  return v24;
}

unsigned __int16 *Pyramid_constructor(unint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4)
{
  float v8 = (unsigned __int16 *)malloc_type_calloc(0x330uLL, 1uLL, 0x47324CA0uLL);
  unint64_t v9 = v8;
  if (!v8)
  {
LABEL_26:
    Pyramid_destructor((char *)v9);
    return 0;
  }
  *float v8 = a3;
  if (a4 >= 9) {
    unsigned int v10 = 9;
  }
  else {
    unsigned int v10 = a4;
  }
  v8[1] = v10;
  v8[2] = v10 - a3 + 1;
  v8[4] = 26;
  v8[3] = a3;
  *((void *)v8 + 42) = a1;
  *((void *)v8 + 52) = a2;
  if (v10)
  {
    float v11 = (unint64_t *)(v8 + 212);
    uint64_t v12 = a4;
    if (a4 >= 9uLL) {
      uint64_t v12 = 9;
    }
    do
    {
      a1 >>= 1;
      *(v11 - 10) = a1;
      a2 >>= 1;
      *v11++ = a2;
      --v12;
    }
    while (v12);
  }
  unint64_t v13 = 0;
  uint64_t v14 = a4;
  if (a4 >= 9uLL) {
    uint64_t v14 = 9;
  }
  uint64_t v15 = 8 * v14 + 8;
  do
  {
    int v16 = &v8[v13 / 2];
    *((void *)v16 + 32) = *(void *)&v8[v13 / 2 + 208] + 52;
    *((void *)v16 + 22) = *(void *)&v8[v13 / 2 + 168] + 52;
    v13 += 8;
  }
  while (v15 != v13);
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  if (v10 >= a3)
  {
    do
    {
      unsigned __int16 v17 = &v9[4 * (unsigned __int16)a3];
      uint64_t v19 = *((void *)v17 + 22);
      uint64_t v18 = v17 + 88;
      vDSP_Length v20 = malloc_type_calloc(v18[10] * v19, 1uLL, 0x8B2076A2uLL);
      *(v18 - 20) = v20;
      bzero(v20, v18[10] * *v18);
      uint64_t v21 = *(v18 - 20);
      if (!v21) {
        goto LABEL_26;
      }
      *(void *)&v9[4 * (unsigned __int16)a3 + 48] = v21 + v9[4] + *v18 * v9[4];
      LOWORD(a3) = a3 + 1;
      unsigned int v10 = v9[1];
    }
    while (v10 >= (unsigned __int16)a3);
  }
  uint64_t v22 = v10;
  uint64_t v23 = &v9[4 * v10];
  unint64_t v24 = *((void *)v23 + 52);
  unint64_t v25 = v24 >> 1;
  *((void *)v23 + 62) = v24 >> 1;
  *((void *)v23 + 72) = v24 - (v24 >> 1);
  if (v10)
  {
    unint64_t v26 = v10 + 1;
    int v27 = &v9[4 * v22 + 204];
    do
    {
      uint64_t v28 = *(void *)v27 - 2 * v25;
      v25 *= 2;
      *((void *)v27 + 10) = v25;
      *((void *)v27 + 20) = v28;
      --v26;
      v27 -= 4;
    }
    while (v26 > 1);
  }
  uint64_t v29 = *v9;
  if (*v9)
  {
    uint64_t v30 = v9 + 328;
    uint64_t v31 = *v9;
    do
    {
      *uint64_t v30 = 0;
      v30[10] = 0;
      ++v30;
      --v31;
    }
    while (v31);
  }
  if (v29 <= v22)
  {
    uint64_t v32 = v22 - v29 + 1;
    uint64_t v33 = &v9[4 * v29];
    do
    {
      *((void *)v33 + 82) = 0;
      *((void *)v33 + 92) = (*((void *)v33 + 62) + 26) * *((void *)v33 + 22);
      v33 += 4;
      --v32;
    }
    while (v32);
  }
  return v9;
}

void Pyramid_destructor(char *a1)
{
  if (a1)
  {
    for (uint64_t i = 16; i != 96; i += 8)
    {
      size_t v3 = *(void **)&a1[i];
      if (v3)
      {
        free(v3);
        *(void *)&a1[i] = 0;
      }
    }
    free(a1);
  }
}

uint64_t Pyramid_loadImage(unsigned __int16 *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, NSObject *a8)
{
  uint64_t v8 = *((void *)a1 + 42);
  uint64_t v9 = *((void *)a1 + 52);
  if (v8 == a4 && v9 == a5)
  {
    LODWORD(v17) = *a1;
    if (v17 >= 2)
    {
      uint64_t v18 = 0;
      do
      {
        ++v18;
        uint64_t v19 = &a1[4 * v18];
        filterSubsampling1channel(a2, *((void *)v19 + 42), *((void *)v19 + 52), a3, 0, 0, (uint64_t)a2, a3, a6, a7);
        if (v18 == a1[3])
        {
          int v20 = *((_DWORD *)v19 + 104);
          if (v20 >= 1)
          {
            size_t v21 = *((void *)v19 + 42);
            uint64_t v22 = *((void *)v19 + 22);
            uint64_t v23 = (char *)(*(void *)&a1[4 * v18 + 8] + a1[4] + a1[4] * v22);
            unint64_t v24 = a2;
            do
            {
              memcpy(v23, v24, v21);
              v23 += v22;
              v24 += a3;
              --v20;
            }
            while (v20);
          }
        }
        a6 = 0;
        uint64_t v17 = *a1;
        a7 = 0;
      }
      while (v18 < v17 - 1);
      a7 = 0;
    }
    if (!v17 || !a1[3])
    {
      int v25 = *((_DWORD *)a1 + 104);
      if (v25 >= 1)
      {
        size_t v26 = *((void *)a1 + 42);
        uint64_t v27 = *((void *)a1 + 22);
        uint64_t v28 = (char *)(*((void *)a1 + 2) + a1[4] + a1[4] * v27);
        uint64_t v29 = &a2[a7 * a3 + a6];
        do
        {
          memcpy(v28, v29, v26);
          v28 += v27;
          v29 += a3;
          --v25;
        }
        while (v25);
      }
    }
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 0x40000000;
    v35[2] = __Pyramid_loadImage_block_invoke;
    v35[3] = &__block_descriptor_tmp_0;
    v35[4] = a1;
    v35[5] = a2;
    v35[6] = a3;
    int v36 = a6;
    int v37 = a7;
    if (a8)
    {
      uint64_t v30 = *a1;
      if (*a1)
      {
        uint64_t v31 = a1 + 248;
        do
        {
          v31[30] = *v31 * a3;
          ++v31;
          --v30;
        }
        while (v30);
      }
      v34[0] = MEMORY[0x1E4F143A8];
      v34[1] = 0x40000000;
      v34[2] = __Pyramid_loadImage_block_invoke_2;
      v34[3] = &unk_1E5B1AA90;
      v34[4] = v35;
      v34[5] = a1;
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __Pyramid_loadImage_block_invoke_3;
      block[3] = &unk_1E5B1AAB8;
      block[4] = v35;
      void block[5] = a1;
      dispatch_async(a8, block);
      dispatch_async(a8, v34);
      dispatch_barrier_sync(a8, &__block_literal_global_0);
    }
    else
    {
      __Pyramid_loadImage_block_invoke((unsigned __int8 *)v35, (uint64_t)(a1 + 208), (uint64_t)(a1 + 328), a1[4], a1[4]);
    }
    return 0;
  }
  else
  {
    syslog(3, "Pyramid_loadImage: incompatible size in pyramid (%lu!=%lu) or (%lu!=%lu)", a4, v8, a5, v9);
    return 0xFFFFFFFFLL;
  }
}

unsigned __int8 *filterSubsampling1channel(unsigned __int8 *result, unint64_t a2, int a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, int a9, int a10)
{
  if (a3 >= 1)
  {
    int v10 = 0;
    uint64_t v11 = 2 * a8;
    uint64_t v12 = a2 >> 3;
    unint64_t v13 = (uint8x8_t *)&result[a6 * a4 + a5];
    uint64_t v14 = a10 * a8;
    uint64_t v15 = (unsigned __int8 *)(a7 + v14 + a9);
    uint64_t v16 = a7 + a8 + v14;
    uint64_t v17 = (unsigned __int8 *)(a7 + v14);
    if (a2 >> 3 <= 1) {
      uint64_t v12 = 1;
    }
    while (1)
    {
      float result = v17;
      uint64_t v18 = v16;
      uint64_t v19 = v12;
      int v20 = v13;
      if (a2 >= 8) {
        break;
      }
      size_t v21 = &v15[a8];
      int v20 = v13;
      uint64_t v22 = v15;
      if ((a2 & 7) != 0) {
        goto LABEL_9;
      }
LABEL_11:
      unint64_t v13 = (uint8x8_t *)((char *)v13 + a4);
      v15 += v11;
      ++v10;
      v16 += v11;
      v17 += v11;
      if (v10 == a3) {
        return result;
      }
    }
    do
    {
      uint64_t v23 = (const char *)(v18 + a9);
      unint64_t v24 = (const char *)&result[a9];
      int8x8x2_t v32 = vld2_s8(v24);
      int8x8x2_t v33 = vld2_s8(v23);
      *v20++ = vqmovn_u16(vrshrq_n_u16(vaddw_u8(vaddw_u8(vaddl_u8((uint8x8_t)v32.val[0], (uint8x8_t)v32.val[1]), (uint8x8_t)v33.val[1]), (uint8x8_t)v33.val[0]), 2uLL));
      v18 += 16;
      result += 16;
      --v19;
    }
    while (v19);
    size_t v21 = (unsigned __int8 *)(v18 + a9);
    uint64_t v22 = &result[a9];
    if ((a2 & 7) == 0) {
      goto LABEL_11;
    }
LABEL_9:
    float result = v21 + 1;
    int v25 = v22 + 1;
    int v26 = a2 & 7;
    do
    {
      int v27 = *(v25 - 1);
      int v29 = *v25;
      v25 += 2;
      int v28 = v29;
      int v30 = *(result - 1);
      int v31 = *result;
      result += 2;
      v20->i8[0] = (v27 + v28 + v30 + v31 + 2) >> 2;
      int v20 = (uint8x8_t *)((char *)v20 + 1);
      --v26;
    }
    while (v26);
    goto LABEL_11;
  }
  return result;
}

void *RegistrationEngine_constructor()
{
  v0 = malloc_type_calloc(1uLL, 0xDF20uLL, 0x10A004046220CB8uLL);
  if (!v0) {
    goto LABEL_9;
  }
  CFAllocatorRef v1 = GeomTransformShared_constructor();
  v0[2] = v1;
  long long v2 = GeomTransform_constructor(2u, (uint64_t)v1);
  v0[3] = v2;
  if (!v2) {
    goto LABEL_9;
  }
  v0[4] = GeomTransform_constructor(0, v0[2]);
  size_t v3 = GeomTransform_constructor(0, v0[2]);
  v0[5] = v3;
  if (!v0[4]) {
    goto LABEL_9;
  }
  if (v3
    && (float v4 = GeomTransform_constructor(0, v0[2]), (v0[6] = v4) != 0)
    && (FeatureMatcher_constructor(), (v0[7136] = v5) != 0)
    && (size_t v6 = RansacEngine_constructor(0x190uLL, v0[2]), (v0[7137] = v6) != 0))
  {
    *((unsigned char *)v0 + 57112) = 0;
  }
  else
  {
LABEL_9:
    RegistrationEngine_destructor((uint64_t)v0);
    return 0;
  }
  return v0;
}

void RegistrationEngine_destructor(uint64_t a1)
{
  RegistrationEngine_purgeResources(a1);
  if (a1)
  {
    *(unsigned char *)(a1 + 57112) = 0;
    RansacEngine_destructor(*(void **)(a1 + 57096));
    GeomTransform_destructor(*(void **)(a1 + 57088));
    GeomTransform_destructor(*(void **)(a1 + 40));
    GeomTransform_destructor(*(void **)(a1 + 24));
    GeomTransform_destructor(*(void **)(a1 + 32));
    GeomTransform_destructor(*(void **)(a1 + 48));
    GeomTransformShared_destructor(*(void ***)(a1 + 16));
    bzero((void *)a1, 0xDF20uLL);
    free((void *)a1);
  }
}

void RegistrationEngine_purgeResources(uint64_t a1)
{
  if (a1)
  {
    long long v2 = (void *)(a1 + 57080);
    *(unsigned char *)(a1 + 57112) = 0;
    IPDetector_destructor(*(void **)(a1 + 57080));
    *long long v2 = 0;
    Pyramid_destructor(*(char **)a1);
    *(void *)a1 = 0;
    Pyramid_destructor(*(char **)(a1 + 8));
    *(void *)(a1 + 8) = 0;
    Digest_destructor(*(void **)(a1 + 184));
    *(void *)(a1 + 184) = 0;
    Digest_destructor(*(void **)(a1 + 192));
    *(void *)(a1 + 192) = 0;
    DigestShared_destructor(*(void **)(a1 + 176));
    uint64_t v3 = 0;
    *(void *)(a1 + 176) = 0;
    uint64_t v4 = a1 + 56;
    do
    {
      GeomTransform_destructor(*(void **)(v4 + v3));
      *(void *)(v4 + v3) = 0;
      v3 += 8;
    }
    while (v3 != 80);
  }
}

uint64_t RegistrationEngine_init(uint64_t a1, unint64_t a2, unint64_t a3, int a4, int a5, unint64_t a6, unint64_t a7, unint64_t a8, unint64_t a9)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v16 = (void *)a1;
  *(unsigned char *)(a1 + 57112) = 0;
  if (*(void *)(a1 + 200) == a2
    && *(void *)(a1 + 208) == a3
    && *(_DWORD *)(a1 + 248) == a4
    && *(_DWORD *)(a1 + 252) == a5
    && *(void *)(a1 + 216) == a6
    && *(void *)(a1 + 224) == a7
    && *(void *)(a1 + 232) == a8
    && *(void *)(a1 + 240) == a9
    && *(void *)(a1 + 57080)
    && *(void *)a1
    && *(void *)(a1 + 8)
    && *(void *)(a1 + 176)
    && *(void *)(a1 + 184)
    && *(void *)(a1 + 192)
    && *(void *)(a1 + 56))
  {
    uint64_t v17 = 0;
    while (v17 != 9)
    {
      if (!*(void *)(a1 + 64 + 8 * v17++))
      {
        if ((unint64_t)(v17 - 1) > 8) {
          return 0;
        }
        goto LABEL_21;
      }
    }
    return 0;
  }
LABEL_21:
  int v36 = (void *)(a1 + 57080);
  RegistrationEngine_purgeResources(a1);
  v16[25] = a2;
  v16[26] = a3;
  v16[29] = a8;
  v16[30] = a9;
  v16[27] = a6;
  v16[28] = a7;
  uint64_t v19 = Pyramid_constructor(a6, a7, (unsigned __int16)a4, (unsigned __int16)a5);
  void *v16 = v19;
  if (v19)
  {
    int v20 = Pyramid_constructor(v16[27], v16[28], (unsigned __int16)a4, (unsigned __int16)a5);
    v16[1] = v20;
    if (v20)
    {
      unint64_t v35 = a8;
      uint64_t v21 = 42;
      for (uint64_t i = 136; i != 176; i += 4)
      {
        Norm_constructor(*(void *)(*v16 + v21 * 8), *(void *)(*v16 + v21 * 8 + 80));
        v16[v21 - 35] = v23;
        if (!v23)
        {
          uint64_t v33 = 4294967293;
          goto LABEL_47;
        }
        unint64_t v24 = v23;
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        Norm_dir(v23, (float *)&v38 + 1, (float *)&v38, 0.0, 0.0);
        Norm_dir(v24, (float *)&v37 + 1, (float *)&v37, 1.0, 1.0);
        float v25 = *((float *)&v37 + 1) - *((float *)&v38 + 1);
        if ((float)(*((float *)&v37 + 1) - *((float *)&v38 + 1)) <= (float)(*(float *)&v37 - *(float *)&v38)) {
          float v25 = *(float *)&v37 - *(float *)&v38;
        }
        *(float *)((char *)v16 + i) = v25;
        ++v21;
      }
      int v26 = IPDetector_constructor(*(void *)(*v16 + 8 * a4 + 336), *(void *)(*v16 + 8 * a4 + 256), *(void *)(*v16 + 8 * a4 + 176));
      *int v36 = v26;
      if (v26)
      {
        int v27 = DigestShared_constructor(*(void *)(*v16 + 8 * a4 + 336), *(void *)(*v16 + 8 * a4 + 416));
        v16[22] = v27;
        if (v27)
        {
          uint64_t v28 = a5 - 2;
          int v29 = Digest_constructor(*(void *)(*v16 + 8 * v28 + 336), *(void *)(*v16 + 8 * v28 + 416), (uint64_t)v27);
          v16[23] = v29;
          if (v29)
          {
            int v30 = Digest_constructor(*(void *)(*v16 + 8 * v28 + 336), *(void *)(*v16 + 8 * v28 + 416), v16[22]);
            v16[24] = v30;
            if (v30)
            {
              if (a6 <= a7) {
                unint64_t v31 = a7;
              }
              else {
                unint64_t v31 = a6;
              }
              if (a2 <= a3) {
                unint64_t v32 = a3;
              }
              else {
                unint64_t v32 = a2;
              }
              *(float *)&long long v39 = (float)v31 / (float)v32;
              DWORD1(v39) = 0x80000000;
              *((float *)&v39 + 2) = (float)((float)((float)a6 + (float)((float)v35 * 2.0)) - (float)a2) / (float)v32;
              HIDWORD(v39) = 0;
              float v40 = *(float *)&v39;
              float v41 = (float)((float)((float)a7 + (float)((float)a9 * 2.0)) - (float)a3) / (float)v32;
              uint64_t v42 = 0;
              GeomTransform_setParams(v16[6], &v39);
              uint64_t v16 = 0;
              uint64_t v33 = 0;
            }
            else
            {
              uint64_t v33 = 4294967289;
            }
          }
          else
          {
            uint64_t v33 = 4294967290;
          }
        }
        else
        {
          uint64_t v33 = 4294967291;
        }
      }
      else
      {
        uint64_t v33 = 4294967292;
      }
    }
    else
    {
      uint64_t v33 = 4294967294;
    }
  }
  else
  {
    uint64_t v33 = 0xFFFFFFFFLL;
  }
LABEL_47:
  RegistrationEngine_purgeResources((uint64_t)v16);
  return v33;
}

uint64_t RegistrationEngine_loadCorners(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned int a5, unint64_t a6, unint64_t a7)
{
  float v7 = (char *)(a1 + 57112);
  uint64_t v8 = a1 + 40256;
  unsigned int v9 = IPDetector_selectCorners(*(void *)(a1 + 57080), a1 + 256, a1 + 16256, a1 + 32256, a2, a3, a4, a5, a6, a7, *(void *)(a1 + 216), *(void *)(a1 + 224), 0x14uLL, 0x14uLL);
  unsigned int v10 = v9;
  if (v9 > 5)
  {
    uint64_t result = 0;
    *(_WORD *)uint64_t v8 = v10;
    *(void *)(v8 + 16848) = v10;
    char v11 = 1;
  }
  else
  {
    printf("WARNING: insufficient number of external corners provided (only %hu corners provided but minumum is %d)\n", v9, 6);
    char v11 = 0;
    uint64_t result = 0xFFFFFFFFLL;
  }
  *float v7 = v11;
  return result;
}

uint64_t RegistrationEngine_loadTemplateImage(uint64_t a1, unsigned __int8 *a2, uint64_t a3, NSObject *a4)
{
  return Pyramid_loadImage(*(unsigned __int16 **)a1, a2, a3, *(void *)(a1 + 216), *(void *)(a1 + 224), *(void *)(a1 + 232), *(void *)(a1 + 240), a4);
}

uint64_t RegistrationEngine_loadInputImage(uint64_t a1, unsigned __int8 *a2, uint64_t a3, NSObject *a4)
{
  return Pyramid_loadImage(*(unsigned __int16 **)(a1 + 8), a2, a3, *(void *)(a1 + 216), *(void *)(a1 + 224), *(void *)(a1 + 232), *(void *)(a1 + 240), a4);
}

uint64_t RegistrationEngine_detectCorners(unint64_t *a1, NSObject *a2)
{
  unint64_t v2 = *a1;
  unsigned int v3 = *(unsigned __int16 *)(*a1 + 2);
  int v4 = *(unsigned __int16 *)*a1;
  if (v3 >= v4)
  {
    size_t v6 = a1 + 7135;
    uint64_t v16 = (float *)(a1 + 2032);
    uint64_t v17 = (float *)(a1 + 32);
    uint64_t v15 = (unsigned __int16 *)(a1 + 4032);
    do
    {
      float v7 = &a1[200 * v3];
      unint64_t v8 = v2 + 8 * v3;
      unsigned int v9 = &a1[100 * v3];
      if ((int)v3 <= 1 && *((unsigned char *)v6 + 32))
      {
        uint64_t v10 = v3;
        unint64_t v14 = vcvtas_u32_f32((float)(1.0 / powf(1.25, (float)(int)(v3 - v4))) * 20.0);
        __int16 v11 = IPDetector_distributeCorners(*v6, (uint64_t)(v7 + 32), (uint64_t)(v7 + 2032), (uint64_t)(v9 + 4032), v17, v16, v15, *((unsigned __int16 *)v6 + 12), a1[27], a1[28], *(void *)(v8 + 336), *(void *)(v8 + 416), v14, v14);
      }
      else
      {
        uint64_t v10 = v3;
        __int16 v11 = IPDetector_execute(*v6, (uint64_t)(v7 + 32), (uint64_t)(v7 + 2032), (uint64_t)(v9 + 4032), 0x190u, *(void *)(v8 + 16), 26, *(void *)(v8 + 336), *(void *)(v8 + 416), *(void *)(v8 + 176), a2);
      }
      *((_WORD *)a1 + v10 + 20128) = v11;
      unint64_t v2 = *a1;
      int v4 = *(unsigned __int16 *)*a1;
    }
    while ((int)v3-- > v4);
  }
  return 0;
}

uint64_t RegistrationEngine_oneLevel(uint64_t a1, int a2)
{
  int v4 = (float *)(a1 + 40276);
  uint64_t v5 = a1 + 1600 * a2;
  memcpy((void *)(a1 + 40276), (const void *)(v5 + 256), 0x640uLL);
  memcpy((void *)(a1 + 41876), (const void *)(v5 + 16256), 0x640uLL);
  memcpy((void *)(a1 + 43476), (const void *)(a1 + 800 * a2 + 32256), 0x320uLL);
  uint64_t v6 = *(unsigned __int16 *)(a1 + 2 * a2 + 40256);
  unsigned int v7 = kRegistrationMinNumInliers[a2];
  if (v6 < v7) {
    return 0;
  }
  uint64_t v8 = a1 + 8 * a2;
  Norm_dirs(*(float **)(v8 + 56), (float *)(a1 + 48276), (float *)(a1 + 49876), v4, (float *)(a1 + 41876), v6);
  GeomTransform_invs(*(float **)(a1 + 32), (float *)(a1 + 51476), (float *)(a1 + 53076), (float *)(a1 + 48276), (float *)(a1 + 49876), v6);
  uint64_t v21 = (float *)(a1 + 53076);
  Norm_invs(*(float **)(v8 + 56), (float *)(a1 + 44276), (float *)(a1 + 45876), (float *)(a1 + 51476), (float *)(a1 + 53076), v6);
  uint64_t v22 = (float *)(a1 + 51476);
  if (v6)
  {
    uint64_t v9 = 0;
    int v10 = 0;
    do
    {
      float v11 = *(float *)(a1 + 44276 + 4 * v9);
      if (v11 >= 10.0 && v11 < (float)(unint64_t)(*(void *)(*(void *)a1 + 8 * a2 + 336) - 10))
      {
        float v12 = *(float *)(a1 + 45876 + 4 * v9);
        if (v12 >= 10.0 && v12 < (float)(unint64_t)(*(void *)(*(void *)a1 + 8 * a2 + 416) - 10))
        {
          uint64_t v13 = a1 + 2 * v10++;
          *(_WORD *)(v13 + 47476) = v9;
        }
      }
      ++v9;
    }
    while (v6 != v9);
    if (v10 >= 1)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v4;
      do
      {
        uint64_t v16 = *(unsigned __int16 *)(a1 + 47476 + 2 * v14);
        if (v14 != v16)
        {
          uint64_t v17 = (float *)(a1 + 4 * v16);
          v15[1000] = v17[11069];
          v15[2800] = v17[12869];
          v15[1400] = v17[11469];
          v15[3200] = v17[13269];
          *uint64_t v15 = v17[10069];
          v15[2000] = v17[12069];
          v15[400] = v17[10469];
          v15[2400] = v17[12469];
        }
        ++v14;
        ++v15;
      }
      while (v10 != v14);
    }
  }
  else
  {
    LOWORD(v10) = 0;
  }
  if (v7 > (unsigned __int16)v10) {
    return 0;
  }
  uint64_t v19 = *(void *)(a1 + 8) + 8 * a2;
  FeatureMatcher_execute(*(void *)(a1 + 57088), v4, (float *)(a1 + 41876), (float *)(a1 + 44276), (float *)(a1 + 45876), (float *)(a1 + 54676), (unsigned __int16)v10, *(void *)(*(void *)a1 + 8 * a2 + 96), *(void *)(*(void *)a1 + 8 * a2 + 176), *(void *)(v19 + 96), *(void *)(v19 + 176), 2u);
  Norm_dirs(*(float **)(v8 + 56), v22, v21, (float *)(a1 + 44276), (float *)(a1 + 45876), (unsigned __int16)v10);
  GeomTransform_deepCopy(*(void *)(a1 + 40), *(void *)(a1 + 32));
  LOWORD(__N) = v10;
  uint64_t result = RansacEngine_execute(*(void *)(a1 + 57096), *(void *)(a1 + 32), (void *)(a1 + 56276), v22, v21, (const float *)(a1 + 48276), (const float *)(a1 + 49876), (const float *)(a1 + 54676), *(float *)(a1 + 4 * a2 + 136), __N);
  *(_WORD *)(a1 + 57076) = result;
  if (result <= v7)
  {
    GeomTransform_deepCopy(*(void *)(a1 + 32), *(void *)(a1 + 40));
    return *(unsigned __int16 *)(a1 + 57076);
  }
  return result;
}

uint64_t RegistrationEngine_execute(unsigned __int16 **a1, int a2, long long *a3)
{
  int v4 = (unsigned __int16 *)a1 + 28538;
  *((_WORD *)a1 + 28538) = 0;
  if (a2)
  {
    GeomTransform_setParams((uint64_t)a1[3], a3);
    GeomTransform_setParams((uint64_t)a1[4], (long long *)(a1[3] + 18));
  }
  else
  {
    GeomTransform_eye((uint64_t)a1[4]);
    GeomTransform_eye((uint64_t)a1[3]);
  }
  RansacEngine_init(*(void *)(v4 + 10));
  int v5 = (*a1)[1];
  if (v5 >= **a1)
  {
    do
      RegistrationEngine_oneLevel((uint64_t)a1, v5);
    while (v5-- > **a1);
  }
  unsigned int v7 = *v4;
  if (v7 > 5)
  {
    uint64_t v8 = GeomTransform_estimate((uint64_t)a1[3], (uint64_t)a1 + 51476, (uint64_t)a1 + 53076, (uint64_t)a1 + 48276, (uint64_t)a1 + 49876, (unsigned __int16 *)a1 + 28138, v7);
  }
  else
  {
    syslog(4, "Registration could not detect more that %d inlier corners at the highest resolution.\n", *v4);
    uint64_t v8 = 0;
  }
  GeomTransform_changeCoordinateSystem((uint64_t)a1[4], (uint64_t)a1[6]);
  return v8;
}

int64x2_t FeatureMatcher_constructor()
{
  v0 = (int64x2_t *)malloc_type_calloc(0x2F0uLL, 1uLL, 0x80635CF7uLL);
  if (v0)
  {
    int64x2_t result = vdupq_n_s64(0xBuLL);
    int64x2_t *v0 = result;
    v0[1] = vdupq_n_s64(0x17uLL);
    v0[2].i64[0] = 529;
  }
  return result;
}

uint64_t FeatureMatcher_BestMatchByOptimizedNCC(uint64_t a1, float *a2, float *a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9, float a10, unsigned __int16 a11)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  if (a11 != 2) {
    FeatureMatcher_BestMatchByOptimizedNCC_cold_2();
  }
  float v11 = a4;
  float v12 = a2;
  uint32x4_t v14 = 0uLL;
  memset(v96, 0, sizeof(v96));
  memset(v95, 0, sizeof(v95));
  memset(v94, 0, sizeof(v94));
  uint64_t v15 = (int)*a3;
  uint64_t v16 = (int)*a4;
  uint64_t v17 = *(void *)(a1 + 24);
  if (v17)
  {
    uint64_t v18 = 0;
    uint64_t v19 = *(void *)(a1 + 8);
    uint64_t v20 = v16 - v19;
    uint64_t v21 = a7 + (v16 - v19) * a8 + v15 - *(void *)a1;
    uint64_t v22 = (uint8x8_t *)(a5 + ((int)a10 - v19) * a6 - *(void *)a1 + (int)a9);
    unint64_t v23 = *(void *)(a1 + 16) - 8;
    int v24 = -a11;
    uint64_t v25 = *(void *)(a1 + 16) & 7;
    int v26 = (void *)(a7 + a8 * (v20 - 2) + v15 - *(void *)a1 - a11);
    int v27 = v26 + 1;
    uint16x8_t v28 = 0uLL;
    do
    {
      if (!v23) {
        goto LABEL_49;
      }
      unint64_t v29 = 0;
      int v30 = v27;
      unint64_t v31 = v26;
      unint64_t v32 = v22;
      uint64_t v33 = v21;
      do
      {
        LODWORD(v34) = 0;
        unint64_t v35 = v30;
        uint8x8_t v36 = *v32;
        uint16x8_t v28 = vaddw_u8(v28, *v32);
        uint16x8_t v37 = vmull_u8(v36, v36);
        uint32x4_t v14 = vaddw_high_u16(vaddw_u16(v14, *(uint16x4_t *)v37.i8), v37);
        uint64_t v38 = v31;
        int v39 = -2;
        do
        {
          uint64_t v34 = (int)v34;
          uint64_t v40 = (2 * a11) | 1;
          float v41 = v38;
          do
          {
            uint8x8_t v42 = *(uint8x8_t *)v41;
            float v41 = (void *)((char *)v41 + 1);
            v96[v34] = vaddw_u8((uint16x8_t)v96[v34], v42);
            uint16x8_t v43 = vmull_u8(v42, v42);
            v95[v34] = vaddw_high_u16(vaddw_u16((uint32x4_t)v95[v34], *(uint16x4_t *)v43.i8), v43);
            uint16x8_t v44 = vmull_u8(v36, v42);
            v94[v34] = vaddw_high_u16(vaddw_u16((uint32x4_t)v94[v34], *(uint16x4_t *)v44.i8), v44);
            ++v34;
            --v40;
          }
          while (v40);
          uint64_t v38 = (void *)((char *)v38 + a8);
          BOOL v45 = v39++ == 2;
        }
        while (!v45);
        v29 += 8;
        ++v32;
        v33 += 8;
        ++v31;
        int v30 = v35 + 1;
      }
      while (v29 < v23);
      if (v25 != 7) {
LABEL_49:
      }
        FeatureMatcher_BestMatchByOptimizedNCC_cold_1();
      LODWORD(v46) = 0;
      uint8x8_t v47 = *v32;
      v47.i8[7] = 0;
      uint16x8_t v28 = vaddw_u8(v28, v47);
      uint16x8_t v48 = vmull_u8(v47, v47);
      uint32x4_t v14 = vaddw_high_u16(vaddw_u16(v14, *(uint16x4_t *)v48.i8), v48);
      int v49 = -2;
      do
      {
        uint64_t v46 = (int)v46;
        uint64_t v50 = (2 * a11) | 1;
        uint64_t v51 = v35;
        do
        {
          uint8x8_t v52 = *(uint8x8_t *)v51;
          uint64_t v51 = (void *)((char *)v51 + 1);
          uint8x8_t v53 = v52;
          v53.i8[7] = 0;
          v96[v46] = vaddw_u8((uint16x8_t)v96[v46], v53);
          uint16x8_t v54 = vmull_u8(v53, v53);
          v95[v46] = vaddw_high_u16(vaddw_u16((uint32x4_t)v95[v46], *(uint16x4_t *)v54.i8), v54);
          uint16x8_t v55 = vmull_u8(v47, v53);
          v94[v46] = vaddw_high_u16(vaddw_u16((uint32x4_t)v94[v46], *(uint16x4_t *)v55.i8), v55);
          ++v46;
          --v50;
        }
        while (v50);
        unint64_t v35 = (void *)((char *)v35 + a8);
        BOOL v45 = v49++ == 2;
      }
      while (!v45);
      ++v18;
      uint64_t v22 = (uint8x8_t *)((char *)v22 + a6);
      v21 += a8;
      int v26 = (void *)((char *)v26 + a8);
      int v27 = (void *)((char *)v27 + a8);
    }
    while (v18 != v17);
    float v12 = a2;
    float v11 = a4;
  }
  else
  {
    int v24 = -2;
    uint16x8_t v28 = 0uLL;
  }
  float v56 = (float)(unint64_t)vaddvq_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(v28)));
  float v57 = (float)*(unint64_t *)(a1 + 32);
  float v58 = (float)(unint64_t)vaddvq_s64((int64x2_t)vpaddlq_u32(v14)) - (float)((float)(v56 * v56) / v57);
  memset_pattern16((void *)(a1 + 40), &unk_1A410B960, 0x2A4uLL);
  memset_pattern16((void *)(a1 + 716), &unk_1A410B960, 0x24uLL);
  int v59 = 0;
  int v60 = 3 - v24;
  __int16 v61 = v24;
  __int16 v62 = 14 * v24;
  float v63 = -1.0;
  unsigned __int16 v64 = v16;
  unsigned __int16 v65 = v15;
  do
  {
    uint64_t v66 = 0;
    int v67 = v59;
    float v68 = &v96[v59];
    float v69 = &v95[v59];
    float v70 = &v94[v59];
    do
    {
      float v71 = (float)(unint64_t)vaddvq_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16((uint16x8_t)v68[v66])));
      float v72 = v58
          * (float)((float)(unint64_t)vaddvq_s64((int64x2_t)vpaddlq_u32((uint32x4_t)v69[v66]))
                  - (float)((float)(v71 * v71) / v57));
      float v73 = 0.0;
      if (v72 > 0.0) {
        float v73 = (float)((float)(unint64_t)vaddvq_s64((int64x2_t)vpaddlq_u32((uint32x4_t)v70[v66]))
      }
                    - (float)((float)(v56 * v71) / v57))
            / sqrtf(v72);
      if ((unsigned __int16)(v62 + v66 + 84) <= 0xA8u) {
        *(float *)(a1 + 4 * (unsigned __int16)(v62 + v66 + 84) + 40) = v73;
      }
      if (v73 > v63)
      {
        float v63 = v73;
        unsigned __int16 v65 = v61 + v66 + v15;
        unsigned __int16 v64 = v24 + v16;
      }
      ++v66;
    }
    while (v60 != v66);
    int v59 = v67 + v66;
    v62 += 13;
    BOOL v45 = v24++ == 2;
  }
  while (!v45);
  uint64_t v74 = 0;
  uint64_t v75 = a1 + 716;
  while (2)
  {
    uint64_t v76 = 0;
    __int16 v77 = v65 - v15 + 70 + 13 * (v64 - v16 + v74);
    do
    {
      if ((unsigned __int16)(v77 + v76) >= 0xA9u)
      {
        *(_DWORD *)(v75 + 4 * v76) = -1027080192;
LABEL_46:
        float v85 = 0.0;
        float v84 = 0.0;
        float v89 = a3;
        goto LABEL_47;
      }
      float v78 = *(float *)(a1 + 4 * (unsigned __int16)(v77 + v76) + 40);
      *(float *)(v75 + 4 * v76) = v78;
      if (v78 == -100.0) {
        goto LABEL_46;
      }
      ++v76;
    }
    while (v76 != 3);
    ++v74;
    v75 += 12;
    if (v74 != 3) {
      continue;
    }
    break;
  }
  float v63 = *(float *)(a1 + 732);
  float v79 = *(float *)(a1 + 728);
  float v80 = *(float *)(a1 + 736);
  float v81 = *(float *)(a1 + 720);
  float v82 = *(float *)(a1 + 744);
  float v83 = (float)((float)(v79 + v80) * 0.5) - v63;
  float v84 = 0.0;
  float v85 = 0.0;
  float v86 = v63;
  if (v83 < 0.0)
  {
    float v87 = (float)(v80 - v79) * 0.5;
    float v85 = (float)-v87 / (float)(v83 + v83);
    float v86 = v63 + (float)((float)(v87 * v87) / (float)(v83 * -4.0));
  }
  float v88 = (float)((float)(v81 + v82) * 0.5) - v63;
  float v89 = a3;
  if (v88 < 0.0)
  {
    float v90 = (float)(v82 - v81) * 0.5;
    float v84 = (float)-v90 / (float)(v88 + v88);
    float v63 = v63 + (float)((float)(v90 * v90) / (float)(v88 * -4.0));
  }
  if (v86 > v63) {
    float v63 = v86;
  }
LABEL_47:
  float *v89 = v85 + (float)v65;
  float *v11 = v84 + (float)v64;
  *float v12 = v63;
  return 0;
}

uint64_t FeatureMatcher_execute(uint64_t a1, float *a2, float *a3, float *a4, float *a5, float *a6, unsigned int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, unsigned __int16 a12)
{
  if (a7)
  {
    uint64_t v19 = a7;
    do
    {
      float v20 = *a2++;
      float v21 = v20;
      float v22 = *a3++;
      FeatureMatcher_BestMatchByOptimizedNCC(a1, a6++, a4++, a5++, a8, a9, a10, a11, v21, v22, a12);
      --v19;
    }
    while (v19);
  }
  return 0;
}

void FeatureMatcher_BestMatchByOptimizedNCC_cold_1()
{
  __assert_rtn("FeatureMatcher_BestMatchByOptimizedNCC", "FeatureMatcher.c", 494, "aFeatureMatcher->mBlkWidth % 8 == 7");
}

void FeatureMatcher_BestMatchByOptimizedNCC_cold_2()
{
  __assert_rtn("FeatureMatcher_BestMatchByOptimizedNCC", "FeatureMatcher.c", 433, "aSearchRangeV2 == kRegistrationMinSearchRangeV2");
}

void sub_1A3E405D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E407DC(_Unwind_Exception *a1)
{
  unsigned int v7 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3E40920(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E40A04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E40A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E40B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E40C64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E40CEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E40DD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E40F2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4100C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E41098(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E41224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *vision::mod::ImageDescriptorBufferJoint::getRepresentative(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 72);
  if (v4 != 1)
  {
    if (v4)
    {
      uint64_t v6 = malloc_type_realloc(*(void **)(a1 + 112), 4 * v4, 0x100004052888210uLL);
      *(void *)(a1 + 112) = v6;
      if (v6)
      {
        *(void *)operator new(8uLL) = a3;
        if (malloc_type_malloc(4 * *(void *)(a1 + 96), 0xA7429496uLL)) {
          operator new();
        }
        exception = __cxa_allocate_exception(8uLL);
        void *exception = 3707;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
      uint64_t v9 = __cxa_allocate_exception(8uLL);
      uint64_t v10 = 3707;
    }
    else
    {
      syslog(5, "ERROR: Cannot compute the representative of an empty buffer");
      uint64_t v9 = __cxa_allocate_exception(8uLL);
      uint64_t v10 = 3710;
    }
    void *v9 = v10;
    __cxa_throw(v9, MEMORY[0x1E4FBA3E0], 0);
  }
  unsigned int v7 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (!v7) {
    return 0;
  }
}

void sub_1A3E41554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  MEMORY[0x1A62562C0](v9, 0x10B1C408C23EE85);
  operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorBufferJoint::ImageDescriptorBufferJoint(uint64_t a1, void **a2, void *a3, uint64_t a4, void *a5, unint64_t a6, uint64_t a7, char a8)
{
  uint64_t v12 = vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract(a1, a2, a3, a6, a7, a8);
  *(void *)uint64_t v12 = &unk_1EF752808;
  *(_DWORD *)(v12 + 104) = 3;
  *(_OWORD *)(v12 + 144) = 0u;
  uint64_t v13 = (void *)(v12 + 144);
  uint32x4_t v14 = (void **)(v12 + 120);
  *(_OWORD *)(v12 + 112) = 0u;
  *(_OWORD *)(v12 + 128) = 0u;
  *(void *)(v12 + 160) = 0;
  *(void *)(v12 + 96) = a6 >> 2;
  if (v12 + 120 != a4)
  {
    uint64_t v15 = *(void *)(a4 + 8);
    if (v15)
    {
      std::vector<BOOL>::__vallocate[abi:ne180100]((void *)(v12 + 120), v15);
      memmove(*v14, *(const void **)a4, (((unint64_t)(*(void *)(a4 + 8) - 1) >> 3) & 0x1FFFFFFFFFFFFFF8) + 8);
      uint64_t v16 = *(void *)(a4 + 8);
    }
    else
    {
      uint64_t v16 = 0;
    }
    *(void *)(a1 + 128) = v16;
  }
  if (v13 != a5)
  {
    uint64_t v17 = (char *)*a5;
    uint64_t v18 = (char *)a5[1];
    int64_t v19 = (int64_t)&v18[-*a5];
    unint64_t v20 = v19 >> 4;
    uint64_t v21 = *(void *)(a1 + 160);
    float v22 = *(char **)(a1 + 144);
    if (v19 >> 4 <= (unint64_t)((v21 - (uint64_t)v22) >> 4))
    {
      uint64_t v25 = (void **)(a1 + 152);
      int v26 = *(unsigned char **)(a1 + 152);
      unint64_t v27 = (v26 - v22) >> 4;
      if (v27 < v20)
      {
        uint16x8_t v28 = &v17[16 * v27];
        if (v26 != v22)
        {
          memmove(*(void **)(a1 + 144), v17, v26 - v22);
          float v22 = (char *)*v25;
        }
        int64_t v19 = v18 - v28;
        if (v18 == v28) {
          goto LABEL_25;
        }
        unint64_t v29 = v22;
        int v30 = v28;
        goto LABEL_24;
      }
    }
    else
    {
      if (v22)
      {
        *(void *)(a1 + 152) = v22;
        operator delete(v22);
        uint64_t v21 = 0;
        *uint64_t v13 = 0;
        v13[1] = 0;
        _OWORD v13[2] = 0;
      }
      if (v19 < 0) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v23 = v21 >> 3;
      if (v21 >> 3 <= v20) {
        uint64_t v23 = v19 >> 4;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v23;
      }
      std::vector<vision::mod::DescriptorItemSideInfo>::__vallocate[abi:ne180100](v13, v24);
      uint64_t v25 = (void **)(a1 + 152);
      float v22 = *(char **)(a1 + 152);
    }
    if (v18 == v17)
    {
LABEL_25:
      *uint64_t v25 = &v22[v19];
      return a1;
    }
    unint64_t v29 = v22;
    int v30 = v17;
LABEL_24:
    memmove(v29, v30, v19);
    goto LABEL_25;
  }
  return a1;
}

void sub_1A3E41768(_Unwind_Exception *a1)
{
  int v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 152) = v5;
    operator delete(v5);
  }
  if (*v2) {
    operator delete(*v2);
  }
  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract((void **)v1);
  _Unwind_Resume(a1);
}

unint64_t vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(vision::mod::ImageDescriptorBufferAbstract *this, unint64_t a2)
{
  if (*((void *)this + 9) <= a2)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3692;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  return *((void *)this + 7) + *((void *)this + 8) * a2;
}

void vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(void **this)
{
  *this = &unk_1EF752B68;
  if (*((unsigned char *)this + 88))
  {
    free(this[7]);
    this[7] = 0;
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(this[5]);
  unint64_t v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }
}

void std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]()
{
}

char *std::vector<vision::mod::DescriptorItemSideInfo>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  int64x2_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(unint64_t a1)
{
  if (a1 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a1);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E5B19CC0, MEMORY[0x1E4FBA1C8]);
}

void sub_1A3E41958(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  int64x2_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void *std::vector<BOOL>::__vallocate[abi:ne180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  int64x2_t result = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void vision::mod::ImageDescriptorBufferJoint::setToReferenceToKthDescriptor(vision::mod::ImageDescriptorBufferJoint *this, vision::mod::ImageDescriptorBufferAbstract *a2, unint64_t a3)
{
  vision::mod::ImageDescriptorBufferAbstract::setToReferenceToKthDescriptor(this, a2, a3);
  uint64_t v6 = (a3 >> 2) & 0x1FFFFFFFFFFFFFF8;
  char v22 = (*(void *)(*((void *)this + 15) + v6) >> (2 * (a3 & 0x1Fu))) & 1;
  std::vector<BOOL>::push_back((uint64_t *)a2 + 15, &v22);
  char v21 = (*(void *)(*((void *)this + 15) + v6) >> ((2 * (a3 & 0x1F)) | 1)) & 1;
  std::vector<BOOL>::push_back((uint64_t *)a2 + 15, &v21);
  unsigned int v7 = (_OWORD *)(*((void *)this + 18) + 16 * a3);
  uint64_t v9 = (_OWORD *)*((void *)a2 + 19);
  unint64_t v8 = *((void *)a2 + 20);
  if ((unint64_t)v9 >= v8)
  {
    uint64_t v11 = *((void *)a2 + 18);
    uint64_t v12 = ((uint64_t)v9 - v11) >> 4;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v14 = v8 - v11;
    if (v14 >> 3 > v13) {
      unint64_t v13 = v14 >> 3;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v15);
    }
    else {
      uint64_t v16 = 0;
    }
    uint64_t v17 = (_OWORD *)(v15 + 16 * v12);
    unint64_t v18 = v15 + 16 * v16;
    *uint64_t v17 = *v7;
    uint64_t v10 = v17 + 1;
    unint64_t v20 = (char *)*((void *)a2 + 18);
    int64_t v19 = (char *)*((void *)a2 + 19);
    if (v19 != v20)
    {
      do
      {
        *--uint64_t v17 = *((_OWORD *)v19 - 1);
        v19 -= 16;
      }
      while (v19 != v20);
      int64_t v19 = (char *)*((void *)a2 + 18);
    }
    *((void *)a2 + 18) = v17;
    *((void *)a2 + 19) = v10;
    *((void *)a2 + 20) = v18;
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    _OWORD *v9 = *v7;
    uint64_t v10 = v9 + 1;
  }
  *((void *)a2 + 19) = v10;
}

int64x2_t vision::mod::ImageDescriptorBufferAbstract::setToReferenceToKthDescriptor(vision::mod::ImageDescriptorBufferAbstract *this, vision::mod::ImageDescriptorBufferAbstract *a2, unint64_t a3)
{
  *((void *)a2 + 2) = *((void *)a2 + 1);
  uint64_t v6 = (void *)((char *)a2 + 40);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((void **)a2 + 5));
  *((void *)a2 + 4) = v6;
  *uint64_t v6 = 0;
  *((void *)a2 + 6) = 0;
  uint64_t v7 = *((void *)this + 1);
  if (v7 != *((void *)this + 2))
  {
    uint64_t v9 = (char *)*((void *)a2 + 2);
    unint64_t v8 = *((void *)a2 + 3);
    if ((unint64_t)v9 >= v8)
    {
      uint64_t v11 = (char *)*((void *)a2 + 1);
      uint64_t v12 = (v9 - v11) >> 3;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v14 = v8 - (void)v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      BOOL v15 = (unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v15) {
        unint64_t v16 = v13;
      }
      if (v16)
      {
        unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v16);
        uint64_t v11 = (char *)*((void *)a2 + 1);
        uint64_t v9 = (char *)*((void *)a2 + 2);
      }
      else
      {
        uint64_t v17 = 0;
      }
      unint64_t v18 = (void *)(v16 + 8 * v12);
      unint64_t v19 = v16 + 8 * v17;
      void *v18 = *(void *)(v7 + 8 * a3);
      uint64_t v10 = v18 + 1;
      while (v9 != v11)
      {
        uint64_t v20 = *((void *)v9 - 1);
        v9 -= 8;
        *--unint64_t v18 = v20;
      }
      *((void *)a2 + 1) = v18;
      *((void *)a2 + 2) = v10;
      *((void *)a2 + 3) = v19;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *(void *)uint64_t v9 = *(void *)(v7 + 8 * a3);
      uint64_t v10 = v9 + 8;
    }
    *((void *)a2 + 2) = v10;
    *((_DWORD *)std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)a2 + 4, *(void *)(*((void *)this + 1) + 8 * a3), (void *)(*((void *)this + 1) + 8 * a3))+ 10) = 0;
  }
  unint64_t DataForKthDescriptor = vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, a3);
  *((unsigned char *)a2 + 88) = 0;
  uint64_t v22 = *((void *)this + 8);
  *((void *)a2 + 7) = DataForKthDescriptor;
  *((void *)a2 + 8) = v22;
  int64x2_t result = vdupq_n_s64(1uLL);
  *(int64x2_t *)((char *)a2 + 72) = result;
  return result;
}

void std::vector<BOOL>::push_back(uint64_t *a1, unsigned char *a2)
{
  unint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  if (v4 == v5 << 6)
  {
    if ((uint64_t)(v4 + 1) < 0) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64) {
      unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    }
    if (v4 <= 0x3FFFFFFFFFFFFFFELL) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    }
    std::vector<BOOL>::reserve((uint64_t)a1, v7);
    unint64_t v4 = a1[1];
  }
  a1[1] = v4 + 1;
  uint64_t v8 = *a1;
  unint64_t v9 = v4 >> 6;
  uint64_t v10 = 1 << v4;
  if (*a2) {
    uint64_t v11 = *(void *)(v8 + 8 * v9) | v10;
  }
  else {
    uint64_t v11 = *(void *)(v8 + 8 * v9) & ~v10;
  }
  *(void *)(v8 + 8 * v9) = v11;
}

void std::vector<BOOL>::reserve(uint64_t a1, unint64_t a2)
{
  if (a2 <= *(void *)(a1 + 16) << 6) {
    return;
  }
  if ((a2 & 0x8000000000000000) != 0) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v19 = 0;
  long long v20 = 0uLL;
  std::vector<BOOL>::__vallocate[abi:ne180100](&v19, a2);
  unsigned int v3 = *(void **)a1;
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = v20;
  unint64_t v6 = v20 + v4;
  *(void *)&long long v20 = v20 + v4;
  if (!v5)
  {
    unint64_t v7 = v6 - 1;
    goto LABEL_7;
  }
  unint64_t v7 = v6 - 1;
  if (((v6 - 1) ^ (v5 - 1)) > 0x3F)
  {
LABEL_7:
    uint64_t v8 = v19;
    unint64_t v9 = v7 >> 6;
    if (v6 >= 0x41) {
      unint64_t v10 = v9;
    }
    else {
      unint64_t v10 = 0;
    }
    *(void *)(v19 + 8 * v10) = 0;
    goto LABEL_11;
  }
  uint64_t v8 = v19;
LABEL_11:
  int v11 = v4 & 0x3F;
  if (v4 > 0x3F || (v4 & 0x3F) != 0)
  {
    int v12 = 0;
    unint64_t v13 = &v3[v4 >> 6];
    int v14 = v5 & 0x3F;
    BOOL v15 = (uint64_t *)(v8 + 8 * (v5 >> 6));
    do
    {
      uint64_t v16 = 1 << v14;
      if ((*v3 >> v12)) {
        uint64_t v17 = *v15 | v16;
      }
      else {
        uint64_t v17 = *v15 & ~v16;
      }
      *BOOL v15 = v17;
      v3 += v12 == 63;
      if (v12 == 63) {
        int v12 = 0;
      }
      else {
        ++v12;
      }
      v15 += v14 == 63;
      if (v14 == 63) {
        int v14 = 0;
      }
      else {
        ++v14;
      }
    }
    while (v3 != v13 || v12 != v11);
  }
  unint64_t v18 = *(void **)a1;
  *(void *)a1 = v8;
  *(_OWORD *)(a1 + 8) = v20;
  if (v18) {
    operator delete(v18);
  }
}

void sub_1A3E41E6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, void *a3)
{
  unint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = a1 + 1;
LABEL_9:
    unint64_t v9 = operator new(0x30uLL);
    v9[4] = *a3;
    *((_DWORD *)v9 + 10) = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  unint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  int64x2_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t vision::mod::ImageDescriptorBufferJoint::getDescriptorLengthInBytes(vision::mod::ImageDescriptorBufferJoint *this)
{
  return 4 * *((void *)this + 12);
}

uint64_t vision::mod::ImageDescriptorBufferJoint::computeSelfDistances@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  int v2 = *(_DWORD *)(this + 72);
  if (v2 > 1)
  {
    std::vector<float>::vector(a2, (uint64_t)((v2 - 1) * v2 + ((v2 - 1) * v2 < 0)) >> 1);
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3711;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return this;
}

void sub_1A3E4200C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  int v11 = *(void **)a10;
  if (*(void *)a10)
  {
    *(void *)(a10 + 8) = v11;
    operator delete(v11);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<float>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_1A3E4208C(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  int64x2_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(unint64_t a1)
{
  if (a1 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a1);
}

void vision::mod::ImageDescriptorBufferJoint::computeDistanceFrom(vision::mod::ImageDescriptorBufferJoint *this, const vision::mod::ImageDescriptorBufferAbstract *lpsrc)
{
  if (*((void *)this + 9) == 1 && *((void *)lpsrc + 9) == 1)
  {
    uint64_t v6 = vision::mod::ImageDescriptorBufferJoint::computeDistanceBetweenDescriptors(this, this, v5, &v7);
    exception = __cxa_allocate_exception(8uLL);
    void *exception = v6;
  }
  else
  {
    syslog(5, "ERROR: Invalid number of descriptors, should be 1");
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3708;
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

uint64_t vision::mod::ImageDescriptorBufferJoint::computeDistanceBetweenDescriptors(vision::mod::ImageDescriptorBufferJoint *this, const vision::mod::ImageDescriptorBufferJoint *a2, const vision::mod::ImageDescriptorBufferJoint *a3, float *a4)
{
  uint64_t v4 = -3;
  if (a2 && a3)
  {
    *a4 = 0.0;
    uint64_t v8 = (const float *)*((void *)a2 + 7);
    unint64_t v9 = (const float *)*((void *)a3 + 7);
    std::vector<BOOL>::vector(&v17, (uint64_t)a2 + 120);
    std::vector<BOOL>::vector(&__p, (uint64_t)a3 + 120);
    int v10 = *((_DWORD *)this + 26);
    if (v10 == 3)
    {
      vDSP_Length v11 = (unint64_t)(*(uint64_t (**)(vision::mod::ImageDescriptorBufferJoint *))(*(void *)this + 104))(this) >> 3;
      uint64_t __C = 0;
      vDSP_dotpr(v8, 1, v9, 1, (float *)&__C + 1, v11);
      vDSP_dotpr(&v8[v11], 1, &v9[v11], 1, (float *)&__C, v11);
      float v12 = (float)(*((float *)&__C + 1) * -0.5) + 0.5;
      if ((*(unsigned char *)v17 & 2) != 0 && (*(unsigned char *)__p & 2) != 0) {
        float v12 = (float)((float)((float)(*(float *)&__C * -0.5) + 0.5) * 0.3) + (float)(v12 * 0.7);
      }
      uint64_t v4 = 0;
      *a4 = v12;
    }
    else
    {
      if (v10 == 4)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = 3711;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
      syslog(5, "ERROR: Unknown distance function");
      uint64_t v4 = -10;
    }
    if (__p) {
      operator delete(__p);
    }
    if (v17) {
      operator delete(v17);
    }
  }
  return (v4 + 128) | 0xE00;
}

void sub_1A3E4238C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<BOOL>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    return a1;
  }
  std::vector<BOOL>::__vallocate[abi:ne180100](a1, v4);
  unint64_t v5 = *(void **)a2;
  unint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = a1[1];
  unint64_t v8 = v7 + v6;
  a1[1] = v7 + v6;
  if (v7)
  {
    unint64_t v9 = v8 - 1;
    if (((v8 - 1) ^ (v7 - 1)) < 0x40) {
      goto LABEL_10;
    }
  }
  else
  {
    unint64_t v9 = v8 - 1;
  }
  unint64_t v10 = v9 >> 6;
  if (v8 >= 0x41) {
    unint64_t v11 = v10;
  }
  else {
    unint64_t v11 = 0;
  }
  *(void *)(*a1 + 8 * v11) = 0;
LABEL_10:
  int v12 = v6 & 0x3F;
  if (v6 > 0x3F || (v6 & 0x3F) != 0)
  {
    int v13 = 0;
    int v14 = 0;
    BOOL v15 = &v5[v6 >> 6];
    int v16 = v7 & 0x3F;
    uint64_t v17 = (uint64_t *)(*a1 + 8 * (v7 >> 6));
    do
    {
      uint64_t v18 = 1 << v16;
      if ((*v5 >> v14)) {
        uint64_t v19 = *v17 | v18;
      }
      else {
        uint64_t v19 = *v17 & ~v18;
      }
      *uint64_t v17 = v19;
      ++v14;
      v5 += v13 == 63;
      if (v13 == 63) {
        int v14 = 0;
      }
      v17 += v16 == 63;
      if (v16 == 63) {
        int v16 = 0;
      }
      else {
        ++v16;
      }
      int v13 = v14;
    }
    while (v5 != v15 || v12 != v14);
  }
  return a1;
}

void vision::mod::ImageDescriptorBufferJoint::computeDistancesFrom(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  exception = __cxa_allocate_exception(8uLL);
  void *exception = 3711;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

uint64_t vision::mod::ImageDescriptorBufferJoint::print@<X0>(vision::mod::ImageDescriptorBufferJoint *this@<X0>, void *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v18);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v19, (uint64_t)"Descriptor count = ", 19);
  uint64_t v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  unint64_t v5 = std::locale::use_facet(&v23, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v23);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v19, (uint64_t)"Descriptor length = ", 20);
  unint64_t v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" (", 2);
  (*(void (**)(vision::mod::ImageDescriptorBufferJoint *))(*(void *)this + 104))(this);
  unint64_t v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)" bytes", 6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)")", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(void *)(*v7 - 24)));
  unint64_t v8 = std::locale::use_facet(&v23, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v23);
  std::ostream::put();
  std::ostream::flush();
  if (*((int *)this + 18) >= 1)
  {
    int64_t v9 = 0;
    unint64_t v10 = (std::locale::id *)MEMORY[0x1E4FBA258];
    do
    {
      unint64_t v11 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" = [", 4);
      if (*((int *)this + 24) >= 2)
      {
        uint64_t v12 = 0;
        do
        {
          vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, v9);
          int v13 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)", ", 2);
          ++v12;
        }
        while (v12 < *((_DWORD *)this + 24) - 1);
      }
      vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, v9);
      int v14 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"]", 1);
      std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
      BOOL v15 = std::locale::use_facet(&v23, v10);
      ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
      std::locale::~locale(&v23);
      std::ostream::put();
      std::ostream::flush();
      ++v9;
    }
    while (v9 < *((int *)this + 18));
  }
  std::ostream::flush();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a2, (uint64_t)v20);
  v18[0] = *MEMORY[0x1E4FBA408];
  uint64_t v16 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v18 + *(void *)(v18[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v19 = v16;
  v20[0] = MEMORY[0x1E4FBA470] + 16;
  if (v21 < 0) {
    operator delete((void *)v20[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A6256200](&v22);
}

void sub_1A3E42978(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::locale::~locale((std::locale *)(v2 - 96));
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  unint64_t v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  unint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x1E4FBA488] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1A3E42C60(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x1A6256200](v1);
  _Unwind_Resume(a1);
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1A6256090](v20, a1);
  if (v20[0])
  {
    uint64_t v6 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *((void *)v6 + 5);
    int v8 = *((_DWORD *)v6 + 2);
    int v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    uint64_t v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v12 = a2 + a3;
    }
    else {
      uint64_t v12 = a2;
    }
    if (!v7) {
      goto LABEL_23;
    }
    uint64_t v13 = *((void *)v6 + 3);
    BOOL v14 = v13 <= a3;
    uint64_t v15 = v13 - a3;
    int64_t v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_23;
    }
    if (v16 >= 1)
    {
      std::string::basic_string[abi:ne180100](&__b, v16, (char)v9);
      uint64_t v17 = v22 >= 0 ? &__b : (std::locale *)__b.__locale_;
      uint64_t v18 = (*(uint64_t (**)(uint64_t, std::locale *, int64_t))(*(void *)v7 + 96))(v7, v17, v16);
      if (v22 < 0) {
        operator delete(__b.__locale_);
      }
      if (v18 != v16) {
        goto LABEL_23;
      }
    }
    if (v11 - v12 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v12, v11 - v12) == v11 - v12)
    {
      *((void *)v6 + 3) = 0;
    }
    else
    {
LABEL_23:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1A62560A0](v20);
  return a1;
}

void sub_1A3E42EC8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1A62560A0](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1A3E42EA4);
}

void sub_1A3E42F34(_Unwind_Exception *a1)
{
}

void *std::stringbuf::str[abi:ne180100]<std::allocator<char>>(void *__dst, uint64_t a2)
{
  uint64_t v2 = __dst;
  int v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0x10) != 0)
  {
    unint64_t v5 = *(void *)(a2 + 88);
    unint64_t v6 = *(void *)(a2 + 48);
    if (v5 < v6)
    {
      *(void *)(a2 + 88) = v6;
      unint64_t v5 = v6;
    }
    uint64_t v7 = (const void **)(a2 + 40);
  }
  else
  {
    if ((v3 & 8) == 0)
    {
      size_t v4 = 0;
      *((unsigned char *)__dst + 23) = 0;
      goto LABEL_16;
    }
    uint64_t v7 = (const void **)(a2 + 16);
    unint64_t v5 = *(void *)(a2 + 32);
  }
  int v8 = *v7;
  size_t v4 = v5 - (void)*v7;
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v4 >= 0x17)
  {
    uint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v9 = v4 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v11 = operator new(v9 + 1);
    v2[1] = v4;
    v2[2] = v10 | 0x8000000000000000;
    *uint64_t v2 = v11;
    uint64_t v2 = v11;
  }
  else
  {
    *((unsigned char *)__dst + 23) = v4;
    if (!v4) {
      goto LABEL_16;
    }
  }
  __dst = memmove(v2, v8, v4);
LABEL_16:
  *((unsigned char *)v2 + v4) = 0;
  return __dst;
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA408];
  uint64_t v3 = *MEMORY[0x1E4FBA408];
  *(void *)a1 = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1A6256200](a1 + 128);
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void __clang_call_terminate(void *a1)
{
}

void *std::string::basic_string[abi:ne180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    unint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *std::locale __b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    unint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

uint64_t vision::mod::ImageDescriptorBufferAbstract::createDeepCopy(vision::mod::ImageDescriptorBufferAbstract *this)
{
  uint64_t v2 = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)this + 16))(this);
  *(unsigned char *)(v2 + 88) = 1;
  *(_OWORD *)(v2 + 64) = *((_OWORD *)this + 4);
  uint64_t v3 = malloc_type_malloc(*((void *)this + 8) * *((void *)this + 9), 0xDCCE5A1EuLL);
  *(void *)(v2 + 56) = v3;
  uint64_t v4 = *((void *)this + 9);
  *(void *)(v2 + 80) = v4;
  memcpy(v3, *((const void **)this + 7), *((void *)this + 8) * v4);
  unint64_t v5 = (void *)*((void *)this + 1);
  unint64_t v6 = (void *)*((void *)this + 2);
  if (v5 != v6)
  {
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<long long const*>,std::__wrap_iter<long long const*>,std::back_insert_iterator<std::vector<long long>>,0>(v5, v6, v2 + 8);
    std::map<long long,int>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<long long,int>,std::__tree_node<std::__value_type<long long,int>,void *> *,long>>>((uint64_t *)(v2 + 32), *((void **)this + 4), (void *)this + 5);
  }
  return v2;
}

void std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<long long const*>,std::__wrap_iter<long long const*>,std::back_insert_iterator<std::vector<long long>>,0>(void *a1, void *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    unint64_t v5 = a1;
    unint64_t v6 = *(void **)(a3 + 8);
    do
    {
      unint64_t v7 = *(void *)(a3 + 16);
      if ((unint64_t)v6 >= v7)
      {
        uint64_t v9 = *(void **)a3;
        uint64_t v10 = ((uint64_t)v6 - *(void *)a3) >> 3;
        unint64_t v11 = v10 + 1;
        if ((unint64_t)(v10 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v12 = v7 - (void)v9;
        if (v12 >> 2 > v11) {
          unint64_t v11 = v12 >> 2;
        }
        if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v13 = v11;
        }
        if (v13)
        {
          unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v13);
          uint64_t v9 = *(void **)a3;
          unint64_t v6 = *(void **)(a3 + 8);
        }
        else
        {
          uint64_t v14 = 0;
        }
        uint64_t v15 = (void *)(v13 + 8 * v10);
        *uint64_t v15 = *v5;
        size_t v8 = v15 + 1;
        while (v6 != v9)
        {
          uint64_t v16 = *--v6;
          *--uint64_t v15 = v16;
        }
        *(void *)a3 = v15;
        *(void *)(a3 + 8) = v8;
        *(void *)(a3 + 16) = v13 + 8 * v14;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *unint64_t v6 = *v5;
        size_t v8 = v6 + 1;
      }
      *(void *)(a3 + 8) = v8;
      ++v5;
      unint64_t v6 = v8;
    }
    while (v5 != a2);
  }
}

uint64_t *std::map<long long,int>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<long long,int>,std::__tree_node<std::__value_type<long long,int>,void *> *,long>>>(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    unint64_t v5 = result;
    unint64_t v6 = result + 1;
    do
    {
      unint64_t v7 = v4 + 4;
      size_t v8 = (uint64_t *)v5[1];
      uint64_t v9 = v6;
      if ((uint64_t *)*v5 == v6) {
        goto LABEL_9;
      }
      uint64_t v10 = (uint64_t *)v5[1];
      unint64_t v11 = v6;
      if (v8)
      {
        do
        {
          uint64_t v9 = v10;
          uint64_t v10 = (uint64_t *)v10[1];
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v9 = (uint64_t *)v11[2];
          BOOL v12 = *v9 == (void)v11;
          unint64_t v11 = v9;
        }
        while (v12);
      }
      uint64_t v13 = *v7;
      if (v9[4] < *v7)
      {
LABEL_9:
        if (v8) {
          uint64_t v14 = (uint64_t **)v9;
        }
        else {
          uint64_t v14 = (uint64_t **)v6;
        }
        if (v8) {
          uint64_t v15 = (uint64_t **)(v9 + 1);
        }
        else {
          uint64_t v15 = (uint64_t **)v6;
        }
      }
      else
      {
        uint64_t v14 = (uint64_t **)v6;
        uint64_t v15 = (uint64_t **)v6;
        if (v8)
        {
          uint64_t v15 = (uint64_t **)v6;
          while (1)
          {
            while (1)
            {
              uint64_t v14 = (uint64_t **)v8;
              uint64_t v19 = v8[4];
              if (v13 >= v19) {
                break;
              }
              size_t v8 = *v14;
              uint64_t v15 = v14;
              if (!*v14) {
                goto LABEL_16;
              }
            }
            if (v19 >= v13) {
              break;
            }
            uint64_t v15 = v14 + 1;
            size_t v8 = v14[1];
            if (!v8) {
              goto LABEL_16;
            }
          }
        }
      }
      if (!*v15)
      {
LABEL_16:
        uint64_t v16 = (uint64_t *)operator new(0x30uLL);
        *((_OWORD *)v16 + 2) = *(_OWORD *)v7;
        int64x2_t result = std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)v5, (uint64_t)v14, v15, v16);
      }
      uint64_t v17 = (void *)v4[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v4[2];
          BOOL v12 = *v18 == (void)v4;
          uint64_t v4 = v18;
        }
        while (!v12);
      }
      uint64_t v4 = v18;
    }
    while (v18 != a3);
  }
  return result;
}

void vision::mod::ImageDescriptorBufferJoint::createEmptyCopy(vision::mod::ImageDescriptorBufferJoint *this)
{
}

void vision::mod::ImageDescriptorBufferJoint::~ImageDescriptorBufferJoint(void **this)
{
  vision::mod::ImageDescriptorBufferJoint::~ImageDescriptorBufferJoint(this);

  JUMPOUT(0x1A62562C0);
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *this = &unk_1EF752808;
  free(this[14]);
  uint64_t v2 = this[18];
  if (v2)
  {
    this[19] = v2;
    operator delete(v2);
  }
  uint64_t v3 = this[15];
  if (v3) {
    operator delete(v3);
  }

  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(this);
}

void vision::mod::ImageDescriptorBufferJoint::resizeForDescriptorsCount(void **this, unint64_t a2, char a3)
{
  vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount((vision::mod::ImageDescriptorBufferAbstract *)this, a2, a3);
  std::vector<BOOL>::resize((uint64_t)(this + 15), 2 * a2, 0);
  unint64_t v5 = this[18];
  unint64_t v6 = this[19];
  unint64_t v7 = (v6 - v5) >> 4;
  if (a2 <= v7)
  {
    if (a2 >= v7) {
      return;
    }
    long long v20 = &v5[16 * a2];
    goto LABEL_19;
  }
  unint64_t v8 = a2 - v7;
  uint64_t v9 = this[20];
  if (a2 - v7 <= (v9 - v6) >> 4)
  {
    bzero(this[19], 16 * v8);
    long long v20 = &v6[16 * v8];
LABEL_19:
    this[19] = v20;
    return;
  }
  if (a2 >> 60) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v10 = v9 - v5;
  uint64_t v11 = v10 >> 3;
  if (v10 >> 3 <= a2) {
    uint64_t v11 = a2;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v12 = v11;
  }
  uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v12);
  uint64_t v14 = &v13[16 * v7];
  uint64_t v16 = &v13[16 * v15];
  bzero(v14, 16 * v8);
  uint64_t v17 = &v14[16 * v8];
  uint64_t v19 = (char *)this[18];
  uint64_t v18 = (char *)this[19];
  if (v18 != v19)
  {
    do
    {
      *((_OWORD *)v14 - 1) = *((_OWORD *)v18 - 1);
      v14 -= 16;
      v18 -= 16;
    }
    while (v18 != v19);
    uint64_t v18 = (char *)this[18];
  }
  this[18] = v14;
  this[19] = v17;
  this[20] = v16;
  if (v18)
  {
    operator delete(v18);
  }
}

void std::vector<BOOL>::resize(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = a2 - v5;
  if (a2 <= v5)
  {
    *(void *)(a1 + 8) = a2;
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 16);
    unint64_t v9 = v8 << 6;
    if (v8 << 6 < v6 || v5 > (v8 << 6) - v6)
    {
      __dst = 0;
      long long v20 = 0uLL;
      if ((a2 & 0x8000000000000000) != 0) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v11 = v8 << 7;
      if (v11 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0)) {
        unint64_t v11 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0;
      }
      if (v9 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v12 = v11;
      }
      else {
        unint64_t v12 = 0x7FFFFFFFFFFFFFFFLL;
      }
      std::vector<BOOL>::reserve((uint64_t)&__dst, v12);
      uint64_t v13 = *(void **)a1;
      uint64_t v14 = *(void *)(a1 + 8);
      *(void *)&long long v20 = v14 + v6;
      uint64_t v15 = (char *)__dst;
      if (v14 < 1)
      {
        LODWORD(v18) = 0;
        uint64_t v17 = (char *)__dst;
      }
      else
      {
        uint64_t v16 = v14 >> 6;
        if ((unint64_t)(v14 + 63) >= 0x7F) {
          memmove(__dst, v13, 8 * v16);
        }
        uint64_t v18 = v14 - (v16 << 6);
        uint64_t v17 = &v15[8 * v16];
        if (v18 < 1) {
          LODWORD(v18) = 0;
        }
        else {
          *(void *)uint64_t v17 = *(void *)v17 & ~(0xFFFFFFFFFFFFFFFFLL >> -(char)v18) | *((void *)v13 + v16) & (0xFFFFFFFFFFFFFFFFLL >> -(char)v18);
        }
        uint64_t v13 = *(void **)a1;
      }
      *(void *)a1 = v15;
      *(_OWORD *)(a1 + 8) = v20;
      if (v13) {
        operator delete(v13);
      }
    }
    else
    {
      uint64_t v17 = (char *)(*(void *)a1 + 8 * (v5 >> 6));
      uint64_t v18 = *(void *)(a1 + 8) & 0x3FLL;
      *(void *)(a1 + 8) = a2;
    }
    if (a2 != v5)
    {
      if (a3)
      {
        __dst = v17;
        LODWORD(v20) = v18;
        std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(&__dst, v6);
      }
      else
      {
        __dst = v17;
        LODWORD(v20) = v18;
        std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>((uint64_t)&__dst, v6);
      }
    }
  }
}

void sub_1A3E4396C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(void *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  int v4 = *((_DWORD *)result + 2);
  unint64_t v5 = (void *)*result;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4);
    unint64_t v2 = a2 - v6;
    *int64x2_t result = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    int64x2_t result = memset(v5, 255, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    uint64_t v8 = &v5[v7];
    *uint64_t v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }
  return result;
}

void std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 8);
  unint64_t v5 = *(void **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    unint64_t v2 = a2 - v6;
    *(void *)a1 = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    bzero(v5, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    uint64_t v8 = &v5[v7];
    *(void *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

void thinBin(long long *a1)
{
  unint64_t v2 = (long long *)malloc_type_malloc(0x10000uLL, 0x7ACDE883uLL);
  long long v3 = a1[3];
  long long v5 = *a1;
  long long v4 = a1[1];
  v2[2] = a1[2];
  v2[3] = v3;
  *unint64_t v2 = v5;
  v2[1] = v4;
  long long v6 = a1[7];
  long long v8 = a1[4];
  long long v7 = a1[5];
  v2[6] = a1[6];
  v2[7] = v6;
  v2[4] = v8;
  v2[5] = v7;
  long long v9 = a1[11];
  long long v11 = a1[8];
  long long v10 = a1[9];
  v2[10] = a1[10];
  v2[11] = v9;
  v2[8] = v11;
  v2[9] = v10;
  long long v12 = a1[15];
  long long v14 = a1[12];
  long long v13 = a1[13];
  v2[14] = a1[14];
  v2[15] = v12;
  v2[12] = v14;
  v2[13] = v13;
  uint64_t v15 = v2 + 16;
  uint64_t v16 = a1 + 16;
  int v17 = 1;
  uint64_t v18 = v2 + 16;
  uint64_t v19 = a1 + 16;
  do
  {
    uint64_t v20 = 0;
    *(unsigned char *)uint64_t v18 = *(unsigned char *)v19;
    int v21 = (8 * (*((unsigned char *)v19 - 255) & 1)) & 0xC8 | (16 * (*((unsigned char *)v19 + 1) & 1)) & 0xD8 | (32
                                                                                              * (*((unsigned char *)v19 + 257) & 1)) | *(unsigned char *)(v19 - 16) & 1 | (2 * (*(unsigned char *)v19 & 1)) & 0xFB | (4 * (v19[16] & 1));
    do
    {
      unsigned int v22 = ((*((unsigned char *)v19 + v20 + 2) & 1) << 7) | ((*((unsigned char *)v19 + v20 - 254) & 1) << 6) | ((*((unsigned char *)v19
                                                                                                  + v20
                                                                                                  + 258) & 1) << 8) | v21;
      *((unsigned char *)v18 + v20 + 1) = qdthin1[v22];
      int v21 = v22 >> 3;
      ++v20;
    }
    while (v20 != 254);
    std::locale v23 = (char *)v18 + v20;
    unint64_t v24 = (char *)v19 + v20;
    uint64_t v18 = (_OWORD *)((char *)v18 + v20 + 2);
    v23[1] = v24[1];
    uint64_t v19 = v24 + 2;
    ++v17;
  }
  while (v17 != 255);
  long long v25 = *v19;
  long long v26 = v19[1];
  long long v27 = v19[3];
  void v18[2] = v19[2];
  v18[3] = v27;
  _OWORD *v18 = v25;
  v18[1] = v26;
  long long v28 = v19[4];
  long long v29 = v19[5];
  long long v30 = v19[7];
  v18[6] = v19[6];
  v18[7] = v30;
  v18[4] = v28;
  v18[5] = v29;
  long long v31 = v19[8];
  long long v32 = v19[9];
  long long v33 = v19[11];
  v18[10] = v19[10];
  v18[11] = v33;
  v18[8] = v31;
  v18[9] = v32;
  long long v34 = v19[12];
  long long v35 = v19[13];
  long long v36 = v19[15];
  v18[14] = v19[14];
  v18[15] = v36;
  v18[12] = v34;
  v18[13] = v35;
  long long v37 = *v2;
  long long v38 = v2[1];
  long long v39 = v2[3];
  a1[2] = v2[2];
  a1[3] = v39;
  *a1 = v37;
  a1[1] = v38;
  long long v40 = v2[4];
  long long v41 = v2[5];
  long long v42 = v2[7];
  a1[6] = v2[6];
  a1[7] = v42;
  a1[4] = v40;
  a1[5] = v41;
  long long v43 = v2[8];
  long long v44 = v2[9];
  long long v45 = v2[11];
  a1[10] = v2[10];
  a1[11] = v45;
  a1[8] = v43;
  a1[9] = v44;
  long long v46 = v2[12];
  long long v47 = v2[13];
  long long v48 = v2[15];
  a1[14] = v2[14];
  a1[15] = v48;
  a1[12] = v46;
  a1[13] = v47;
  for (int i = 1; i != 255; ++i)
  {
    uint64_t v50 = 0;
    *(unsigned char *)uint64_t v16 = *(unsigned char *)v15;
    int v51 = (32 * (*((unsigned char *)v15 - 255) & 1)) | (16 * (*((unsigned char *)v15 + 1) & 1)) | (8 * (*((unsigned char *)v15 + 257) & 1)) | (4 * (*(unsigned char *)(v15 - 16) & 1)) | (2 * (*(unsigned char *)v15 & 1)) | v15[16] & 1;
    do
    {
      unsigned int v52 = ((*((unsigned char *)v15 + v50 + 2) & 1) << 7) | ((*((unsigned char *)v15 + v50 - 254) & 1) << 8) | ((*((unsigned char *)v15
                                                                                                  + v50
                                                                                                  + 258) & 1) << 6) | v51;
      *((unsigned char *)v16 + v50 + 1) = qdthin2[v52];
      int v51 = v52 >> 3;
      ++v50;
    }
    while (v50 != 254);
    uint8x8_t v53 = (char *)v16 + v50;
    uint16x8_t v54 = (char *)v15 + v50;
    uint64_t v16 = (_OWORD *)((char *)v16 + v50 + 2);
    v53[1] = v54[1];
    uint64_t v15 = v54 + 2;
  }
  long long v55 = *v15;
  long long v56 = v15[1];
  long long v57 = v15[3];
  v16[2] = v15[2];
  v16[3] = v57;
  _OWORD *v16 = v55;
  v16[1] = v56;
  long long v58 = v15[4];
  long long v59 = v15[5];
  long long v60 = v15[7];
  v16[6] = v15[6];
  v16[7] = v60;
  v16[4] = v58;
  v16[5] = v59;
  long long v61 = v15[8];
  long long v62 = v15[9];
  long long v63 = v15[11];
  v16[10] = v15[10];
  v16[11] = v63;
  v16[8] = v61;
  v16[9] = v62;
  long long v64 = v15[12];
  long long v65 = v15[13];
  long long v66 = v15[15];
  v16[14] = v15[14];
  v16[15] = v66;
  v16[12] = v64;
  v16[13] = v65;

  free(v2);
}

uint64_t trimChain(uint64_t result, int a2, int a3, signed int a4)
{
  if a4 <= 6 && ((0x55u >> a4))
  {
    int v4 = 0;
    long long v5 = (unsigned char *)(result + (a2 + (a3 << 8)));
    uint64_t v6 = qword_1A41255A8[a4];
    uint64_t v7 = qword_1A41255E0[a4];
    uint64_t v8 = qword_1A4125618[a4];
    int v9 = 256;
    while (1)
    {
      int64x2_t result = v5[v6] & 1;
      int v10 = v5[v8] & 1;
      if ((v5[v7] & 1) + result + v10 != 1) {
        break;
      }
      if (v5[v6])
      {
        *long long v5 = 3;
        if (v4 == -1) {
          return result;
        }
        int v4 = -1;
        v5 += v6;
      }
      else
      {
        *long long v5 = 3;
        if (v10)
        {
          if (v4 == 1) {
            return result;
          }
          int v4 = 1;
          v5 += v8;
        }
        else
        {
          int v4 = 0;
          v5 += v7;
        }
      }
      if (!--v9) {
        return result;
      }
    }
    *long long v5 = 3;
  }
  return result;
}

void sub_1A3E43F90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E44078(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E443F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E446D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

#error "1A3E44C38: call analysis failed (funcsize=57)"

void sub_1A3E44DA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E44F6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E45044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E45090(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E450F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4513C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E451D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E45AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  _Unwind_Resume(a1);
}

void sub_1A3E45E54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E45EEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E45FA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E464CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E466D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E46990(_Unwind_Exception *a1)
{
  uint64_t v7 = v5;

  _Unwind_Resume(a1);
}

void sub_1A3E46C14(_Unwind_Exception *a1)
{
  int v4 = v2;

  _Unwind_Resume(a1);
}

void sub_1A3E46E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3E47190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4745C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4750C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E475D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3E476C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E47794(_Unwind_Exception *a1)
{
  long long v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A3E478B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E47A10(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3E47AFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E47BC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E47D6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E48030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4838C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3E48604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3E48864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A3E49258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, void *a19, void *a20,uint64_t a21,void *a22)
{
  _Block_object_dispose(&STACK[0x220], 8);
  if (STACK[0x240]) {
    operator delete((void *)STACK[0x240]);
  }
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32((void **)&STACK[0x258]);
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  }

  _Unwind_Resume(a1);
}

void vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32(void **this)
{
  *this = &unk_1EF752918;
  free(this[14]);

  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(this);
}

{
  uint64_t vars8;

  *this = &unk_1EF752918;
  free(this[14]);
  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(this);

  JUMPOUT(0x1A62562C0);
}

__n128 __Block_byref_object_copy__280(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 56) = 0;
  uint64_t v4 = a1 + 56;
  *(void *)(a1 + 48) = &unk_1EF752B68;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>((void *)(a1 + 56), *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3);
  std::map<long long,int>::map[abi:ne180100]((uint64_t *)(v4 + 24), a2 + 80);
  long long v5 = *(_OWORD *)(a2 + 104);
  long long v6 = *(_OWORD *)(a2 + 120);
  *(unsigned char *)(a1 + 136) = *(unsigned char *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v6;
  *(_OWORD *)(a1 + 104) = v5;
  *(void *)(a1 + 48) = &unk_1EF752918;
  __n128 result = *(__n128 *)(a2 + 144);
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(__n128 *)(a1 + 144) = result;
  return result;
}

void sub_1A3E495CC(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 64) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void __Block_byref_object_dispose__281(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  *(void *)(a1 + 48) = &unk_1EF752918;
  free(*(void **)(a1 + 160));

  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(v1);
}

void sub_1A3E496D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    __n128 result = std::vector<long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3E49754(_Unwind_Exception *exception_object)
{
  long long v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_ea8_48c39_ZTSNSt3__16vectorIxNS_9allocatorIxEEEE(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void *__copy_helper_block_ea8_48c39_ZTSNSt3__16vectorIxNS_9allocatorIxEEEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  unint64_t v2 = (void *)(a1 + 48);
  v2[2] = 0;
  return std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v2, *(const void **)(a2 + 48), *(void *)(a2 + 56), (uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 3);
}

uint64_t *std::map<long long,int>::map[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::map<long long,int>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<long long,int>,std::__tree_node<std::__value_type<long long,int>,void *> *,long>>>(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1A3E497E4(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

void sub_1A3E49C5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  _Block_object_dispose(&a48, 8);
  a30 = a13;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a30);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__273(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__274(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

__n128 __Block_byref_object_copy__224(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__225(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void *std::vector<std::vector<long long>>::__construct_one_at_end[abi:ne180100]<std::vector<long long> const&>(uint64_t a1, uint64_t a2)
{
  long long v3 = *(void **)(a1 + 8);
  *long long v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  __n128 result = std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v3, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  *(void *)(a1 + 8) = v3 + 3;
  return result;
}

void sub_1A3E49E5C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  uint64_t v20 = a1 + 2;
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  size_t v8 = &v7[24 * v2];
  int v17 = v7;
  v18.i64[0] = (uint64_t)v8;
  v18.i64[1] = (uint64_t)v8;
  uint64_t v19 = &v7[24 * v6];
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)size_t v8 = 0;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v8, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  uint64_t v9 = v18.i64[0];
  uint64_t v10 = v18.i64[1] + 24;
  v18.i64[1] += 24;
  long long v12 = (void *)*a1;
  long long v11 = (void *)a1[1];
  if (v11 == (void *)*a1)
  {
    int64x2_t v14 = vdupq_n_s64((unint64_t)v11);
  }
  else
  {
    do
    {
      *(void *)(v9 - 24) = 0;
      *(void *)(v9 - 16) = 0;
      v9 -= 24;
      *(void *)(v9 + 16) = 0;
      long long v13 = *(_OWORD *)(v11 - 3);
      v11 -= 3;
      *(_OWORD *)uint64_t v9 = v13;
      *(void *)(v9 + 16) = v11[2];
      void *v11 = 0;
      v11[1] = 0;
      _OWORD v11[2] = 0;
    }
    while (v11 != v12);
    int64x2_t v14 = *(int64x2_t *)a1;
    uint64_t v10 = v18.i64[1];
  }
  *a1 = v9;
  a1[1] = v10;
  int64x2_t v18 = v14;
  uint64_t v15 = (char *)a1[2];
  a1[2] = (uint64_t)v19;
  uint64_t v19 = v15;
  int v17 = (char *)v14.i64[0];
  std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)&v17);
  return v10;
}

void sub_1A3E49FC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  unint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<long long>>::__clear[abi:ne180100]((uint64_t *)v2);
    unint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::vector<long long>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      unint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      long long v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

uint64_t std::__split_buffer<std::vector<long long>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1A3E4A3D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4A584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4A90C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40)
{
  _Block_object_dispose(&a33, 8);
  if (__p)
  {
    a40 = (uint64_t)__p;
    operator delete(__p);
  }

  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*(void **)(v40 - 240));
  _Unwind_Resume(a1);
}

void *std::vector<long long>::vector(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<long long>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1A3E4AA44(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3E4AABC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*a1);
    std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(a1[1]);
    uint64_t v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

void sub_1A3E4AC98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__243(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__244(uint64_t a1)
{
}

void sub_1A3E4AE90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13)
{
}

void sub_1A3E4B2C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose((const void *)(v33 - 176), 8);
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*(void **)(v33 - 120));

  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy_(void *result, void *a2)
{
  result[6] = a2[6];
  uint64_t v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  uint64_t v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    *uint64_t v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_1A3E4B588(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4B630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
}

void sub_1A3E4B694(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  __n128 result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

void sub_1A3E4B8FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  long long v13 = v12;

  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  std::__list_imp<long long>::clear(v10);

  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__227(void *result, void *a2)
{
  result[6] = result + 6;
  result[7] = result + 6;
  result[8] = 0;
  uint64_t v2 = a2[8];
  if (v2)
  {
    uint64_t v4 = a2[6];
    uint64_t v3 = (uint64_t *)a2[7];
    uint64_t v5 = *v3;
    *(void *)(v5 + 8) = *(void *)(v4 + 8);
    **(void **)(v4 + 8) = v5;
    uint64_t v6 = result[6];
    *(void *)(v6 + 8) = v3;
    *uint64_t v3 = v6;
    result[6] = v4;
    *(void *)(v4 + 8) = result + 6;
    result[8] = v2;
    a2[8] = 0;
  }
  return result;
}

void *__Block_byref_object_dispose__228(uint64_t a1)
{
  return std::__list_imp<long long>::clear((void *)(a1 + 48));
}

void *std::__list_imp<long long>::clear(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    __n128 result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        __n128 result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void sub_1A3E4BC10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  _Block_object_dispose(&a16, 8);
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3E4BDBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__221(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__222(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void sub_1A3E4CE9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24)
{
  _Block_object_dispose(&STACK[0x488], 8);
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy((void *)STACK[0x4C0]);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__214(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__215(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_1A3E4D5D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4D9A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  uint64_t v20 = *(std::__shared_weak_count **)(v18 - 56);
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }

  _Unwind_Resume(a1);
}

void sub_1A3E4DB34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4DD4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16)
{
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(a10);
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(a13);
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(a16);
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*(void **)(v16 - 32));
  _Unwind_Resume(a1);
}

void sub_1A3E4E0D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4E4AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }

  _Unwind_Resume(a1);
}

void _addFileNameInStdStringPathToArray(uint64_t *a1, void *a2)
{
  id v3 = a2;
  if (*((char *)a1 + 23) < 0)
  {
    if (!a1[1]) {
      goto LABEL_9;
    }
    a1 = (uint64_t *)*a1;
  }
  else if (!*((unsigned char *)a1 + 23))
  {
    goto LABEL_9;
  }
  id v6 = v3;
  uint64_t v4 = [NSString stringWithUTF8String:a1];
  uint64_t v5 = [v4 lastPathComponent];

  if ([v5 length]) {
    [v6 addObject:v5];
  }

  id v3 = v6;
LABEL_9:
}

void sub_1A3E4E5F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4E8C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28)
{
  _Block_object_dispose(&a21, 8);
  if (__p)
  {
    a28 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__256(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__257(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_1A3E4EBAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32((void **)va);
  _Unwind_Resume(a1);
}

float *std::__minmax_element_impl[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>,std::__identity,std::__less<void,void>>(float *result, float *a2)
{
  uint64_t v2 = result;
  if (result != a2 && result + 1 != a2)
  {
    float v5 = *result;
    float v4 = result[1];
    if (v4 < *result) {
      ++result;
    }
    id v6 = v4 >= *v2 ? v2 + 1 : v2;
    uint64_t v7 = v2 + 2;
    if (v2 + 2 != a2)
    {
      if (v4 >= v5) {
        float v4 = *v2;
      }
      for (int i = v2 + 3; ; i += 2)
      {
        uint64_t v9 = v7;
        if (i == a2) {
          break;
        }
        float v11 = *(i - 1);
        float v10 = *i;
        if (*i >= v11)
        {
          long long v12 = v2 + 3;
          if (v11 < v4)
          {
            float v4 = *(i - 1);
            __n128 result = i - 1;
          }
          if (v10 >= *v6) {
            id v6 = v12;
          }
        }
        else
        {
          float v4 = *result;
          if (v10 < *result)
          {
            float v4 = *i;
            __n128 result = i;
          }
          if (v11 >= *v6) {
            id v6 = i - 1;
          }
        }
        v7 += 2;
        long long v13 = i + 1;
        uint64_t v2 = v9;
        if (v13 == a2) {
          return result;
        }
      }
      if (*(i - 1) < *result) {
        return i - 1;
      }
    }
  }
  return result;
}

void sub_1A3E4EE08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void std::vector<long long>::resize(char **a1, unint64_t a2)
{
  id v3 = *a1;
  float v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    uint64_t v19 = &v3[8 * a2];
    goto LABEL_15;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 3)
  {
    bzero(a1[1], 8 * v6);
    uint64_t v19 = &v4[8 * v6];
LABEL_15:
    a1[1] = v19;
    return;
  }
  if (a2 >> 61) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 2;
  if (v8 >> 2 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  float v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v10);
  long long v12 = *a1;
  long long v13 = a1[1];
  int64x2_t v14 = &v11[8 * v5];
  uint64_t v16 = &v11[8 * v15];
  bzero(v14, 8 * v6);
  uint64_t v17 = &v14[8 * v6];
  while (v13 != v12)
  {
    uint64_t v18 = *((void *)v13 - 1);
    v13 -= 8;
    *((void *)v14 - 1) = v18;
    v14 -= 8;
  }
  *a1 = v14;
  a1[1] = v17;
  a1[2] = v16;
  if (v12)
  {
    operator delete(v12);
  }
}

void sub_1A3E4F094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorBufferJoint::setAvailableFlagsForKthDescriptor(uint64_t this, int a2, int a3, int a4)
{
  if (a2 < 0 || *(_DWORD *)(this + 72) <= a2)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3692;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t v4 = *(void *)(this + 120);
  unint64_t v5 = (unint64_t)(2 * a2) >> 6;
  uint64_t v6 = 1 << ((2 * a2) & 0x3E);
  if (a3) {
    uint64_t v7 = *(void *)(v4 + 8 * v5) | v6;
  }
  else {
    uint64_t v7 = *(void *)(v4 + 8 * v5) & ~v6;
  }
  *(void *)(v4 + 8 * v5) = v7;
  unint64_t v8 = (unint64_t)((2 * a2) | 1) >> 6;
  uint64_t v9 = 1 << ((2 * a2) | 1u);
  if (a4) {
    uint64_t v10 = *(void *)(v4 + 8 * v8) | v9;
  }
  else {
    uint64_t v10 = *(void *)(v4 + 8 * v8) & ~v9;
  }
  *(void *)(v4 + 8 * v8) = v10;
  return this;
}

__n128 vision::mod::ImageDescriptorBufferJoint::setSideInfoForKthDescriptor(uint64_t a1, int a2, __n128 *a3)
{
  if (a2 < 0 || *(_DWORD *)(a1 + 72) <= a2)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3692;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  __n128 result = *a3;
  *(__n128 *)(*(void *)(a1 + 144) + 16 * a2) = *a3;
  return result;
}

void sub_1A3E4F2DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4F498(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E4F6D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E50468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (__p) {
    operator delete(__p);
  }
  if (a69) {
    operator delete(a69);
  }
  float v71 = (void *)STACK[0x250];
  if (STACK[0x250])
  {
    STACK[0x258] = (unint64_t)v71;
    operator delete(v71);
  }

  float v72 = (void *)STACK[0x2F8];
  if (STACK[0x2F8])
  {
    STACK[0x300] = (unint64_t)v72;
    operator delete(v72);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__364(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__365(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

double std::vector<std::pair<long long,long long>>::__insert_with_size[abi:ne180100]<std::__wrap_iter<std::pair<long long,long long>*>,std::__wrap_iter<std::pair<long long,long long>*>>(long long **a1, uint64_t a2, long long *a3, long long *a4, uint64_t a5)
{
  if (a5 < 1) {
    return *(double *)&v24;
  }
  uint64_t v6 = a3;
  unint64_t v8 = *a1;
  unint64_t v9 = (unint64_t)a1[1];
  uint64_t v10 = a2 - (void)*a1;
  uint64_t v11 = v10 >> 4;
  long long v12 = (long long *)((char *)*a1 + (v10 & 0xFFFFFFFFFFFFFFF0));
  long long v13 = a1[2];
  if (a5 <= (uint64_t)((uint64_t)v13 - v9) >> 4)
  {
    uint64_t v19 = (uint64_t)(v9 - (void)v12) >> 4;
    if (v19 >= a5)
    {
      uint64_t v20 = &a3[a5];
      unsigned int v22 = a1[1];
    }
    else
    {
      uint64_t v20 = &a3[v19];
      if (v20 == a4)
      {
        unsigned int v22 = a1[1];
      }
      else
      {
        int v21 = v20;
        unsigned int v22 = a1[1];
        do
        {
          long long v23 = *v21++;
          *(void *)&long long v24 = v23;
          *v22++ = v23;
        }
        while (v21 != a4);
      }
      a1[1] = v22;
      if ((uint64_t)(v9 - (void)v12) < 1) {
        return *(double *)&v24;
      }
    }
    long long v37 = &v12[a5];
    long long v38 = &v22[-a5];
    long long v39 = v22;
    if ((unint64_t)v38 < v9)
    {
      long long v39 = v22;
      do
      {
        long long v40 = *v38++;
        *(void *)&long long v24 = v40;
        *v39++ = v40;
      }
      while ((unint64_t)v38 < v9);
    }
    a1[1] = v39;
    if (v22 != v37)
    {
      uint64_t v41 = 16 * (v22 - v37);
      long long v42 = (void *)v22 - 1;
      uint64_t v43 = (uint64_t)&v8[v11 - 1] + 8;
      do
      {
        *(v42 - 1) = *(void *)(v43 + v41 - 8);
        *long long v42 = *(void *)(v43 + v41);
        v42 -= 2;
        v41 -= 16;
      }
      while (v41);
    }
    if (v20 != a3)
    {
      do
      {
        long long v44 = *v6++;
        *(void *)&long long v24 = v44;
        *v12++ = v44;
      }
      while (v6 != v20);
    }
  }
  else
  {
    unint64_t v14 = a5 + ((uint64_t)(v9 - (void)v8) >> 4);
    if (v14 >> 60) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (char *)v13 - (char *)v8;
    uint64_t v16 = v15 >> 3;
    if (v15 >> 3 <= v14) {
      uint64_t v16 = v14;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v16;
    }
    if (v17) {
      unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v17);
    }
    else {
      uint64_t v18 = 0;
    }
    long long v25 = (_OWORD *)(v17 + 16 * v11);
    long long v26 = &v25[a5];
    uint64_t v27 = 16 * a5;
    long long v28 = v25;
    do
    {
      long long v29 = *v6++;
      *(void *)&long long v24 = v29;
      *v28++ = v29;
      v27 -= 16;
    }
    while (v27);
    long long v30 = *a1;
    if (*a1 == v12)
    {
      unint64_t v32 = v17 + 16 * v11;
    }
    else
    {
      long long v31 = v12;
      do
      {
        unint64_t v32 = (unint64_t)(v25 - 1);
        long long v24 = *(v31 - 1);
        *(v25 - 1) = v24;
        --v31;
        --v25;
      }
      while (v31 != v30);
    }
    unint64_t v33 = v17 + 16 * v18;
    for (int i = a1[1]; v12 != i; ++v26)
    {
      long long v35 = *v12++;
      *(void *)&long long v24 = v35;
      *long long v26 = v35;
    }
    long long v36 = *a1;
    *a1 = (long long *)v32;
    a1[1] = v26;
    a1[2] = (long long *)v33;
    if (v36)
    {
      operator delete(v36);
    }
  }
  return *(double *)&v24;
}

void sub_1A3E50BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_56c39_ZTSNSt3__16vectorIxNS_9allocatorIxEEEE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

void *__copy_helper_block_ea8_56c39_ZTSNSt3__16vectorIxNS_9allocatorIxEEEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  uint64_t v2 = (void *)(a1 + 56);
  v2[2] = 0;
  return std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v2, *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3);
}

void sub_1A3E50D50(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1A3E51124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  long long v24 = *(std::__shared_weak_count **)(v22 - 72);
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  }
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }

  _Unwind_Resume(a1);
}

void sub_1A3E51880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E51A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3E51B80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E51C8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E51D48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E51FAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  _Unwind_Resume(a1);
}

void *std::vector<unsigned char>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    unint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1A3E52070(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void sub_1A3E551C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  if (a47 < 0) {
    operator delete(__p);
  }

  if (a53 < 0) {
    operator delete(a48);
  }

  _Unwind_Resume(a1);
}

_OWORD *std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, void *a2, _OWORD **a3)
{
  unint64_t v5 = (void **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>((uint64_t)a1, &v11, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    uint64_t v6 = operator new(0x40uLL);
    unint64_t v8 = *a3;
    uint64_t v9 = *((void *)*a3 + 2);
    v6[2] = **a3;
    *((void *)v6 + 6) = v9;
    *unint64_t v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    *((_DWORD *)v6 + 14) = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, v11, v7, (uint64_t *)v6);
  }
  return v6;
}

void *std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>(uint64_t a1, void *a2, void *a3)
{
  unint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        unint64_t v8 = v4 + 4;
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v4 + 4) & 0x80) == 0) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        unint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0) {
        break;
      }
      unint64_t v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void sub_1A3E576EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,void *a27,uint64_t a28,void *a29,void *a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,std::__shared_weak_count *a52)
{
  if (a52) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a52);
  }

  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(*((void *)a1 + 1));
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void sub_1A3E57C70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E57F7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E58154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E58294(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E5844C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E585F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E58850(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E58B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose((const void *)(v30 - 128), 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__421(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__422(uint64_t a1)
{
}

void sub_1A3E58E7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E58FD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E590D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E59400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose((const void *)(v30 - 128), 8);

  _Unwind_Resume(a1);
}

void sub_1A3E59998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);

  _Block_object_dispose((const void *)(v36 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1A3E59BD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E59D14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E59DC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E59F04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E5A058(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E5A194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void apple::vision::fgbg::ConnectedComponentResult::ConnectedComponentResult(apple::vision::fgbg::ConnectedComponentResult *this, uint64_t a2, uint64_t a3, int a4, char a5, char a6)
{
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = a2;
  *((void *)this + 14) = a3;
  *((_DWORD *)this + 30) = a4;
  *((void *)this + 16) = 0;
  *((unsigned char *)this + 136) = a5;
  *((unsigned char *)this + 137) = a6;
  operator new[]();
}

void sub_1A3E5A2A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v10 + 10);
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&a10);
  long long v12 = (void *)v10[7];
  if (v12)
  {
    v10[8] = (uint64_t)v12;
    operator delete(v12);
  }
  long long v13 = (void *)v10[4];
  if (v13)
  {
    v10[5] = (uint64_t)v13;
    operator delete(v13);
  }
  unint64_t v14 = (void *)v10[1];
  if (v14)
  {
    v10[2] = (uint64_t)v14;
    operator delete(v14);
  }
  uint64_t v15 = *v10;
  uint64_t *v10 = 0;
  if (v15) {
    MEMORY[0x1A62562A0](v15, 0x1000C8000313F17);
  }
  _Unwind_Resume(a1);
}

uint64_t apple::vision::fgbg::connectComponentLabel(apple::vision::fgbg *this, float *a2, unint64_t a3, float64x2_t **a4, apple::vision::fgbg::ConnectedComponentResult *a5)
{
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  if (a3)
  {
    unint64_t v9 = 0;
    int v10 = 0;
    do
    {
      if (a2)
      {
        unint64_t v11 = 0;
        int v12 = v9 * a2;
        unint64_t v36 = v9;
        uint64_t v37 = v9;
        int v35 = v9 * a2;
        do
        {
          if (*((float *)this + v12 + (int)v11) >= 0.5
            && (!*(void *)&(*a4)->f64[v11 + (void)a4[13] * v9] || v10 == 0))
          {
            uint64_t v14 = *((void *)&v41 + 1);
            uint64_t v15 = (((void)v42 - *((void *)&v41 + 1)) << 6) - 1;
            if ((void)v42 == *((void *)&v41 + 1)) {
              uint64_t v15 = 0;
            }
            unint64_t v16 = v43;
            if (v15 == (void)v43)
            {
              std::deque<std::pair<int,int>>::__add_back_capacity(&v41);
              uint64_t v14 = *((void *)&v41 + 1);
              unint64_t v16 = *((void *)&v43 + 1) + v43;
            }
            ++v10;
            *(void *)(*(void *)(v14 + ((v16 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v16 & 0x1FF)) = v37 | (v11 << 32);
            ++*((void *)&v43 + 1);
            unint64_t v40 = v10;
            apple::vision::fgbg::ConnectedComponentResult::setLabel((apple::vision::fgbg::ConnectedComponentResult *)a4, v9, v11, v10);
            uint64_t v17 = *((void *)&v43 + 1);
            if (*((void *)&v43 + 1))
            {
              unint64_t v38 = v11;
              int v39 = v10;
              do
              {
                uint64_t v18 = (int *)(*(void *)(*((void *)&v41 + 1) + (((unint64_t)v43 >> 6) & 0x3FFFFFFFFFFFFF8))
                            + 8 * (v43 & 0x1FF));
                int v19 = *v18;
                int v20 = v18[1];
                *(void *)&long long v43 = v43 + 1;
                *((void *)&v43 + 1) = v17 - 1;
                if ((unint64_t)v43 > 0x3FF)
                {
                  operator delete(**((void ***)&v41 + 1));
                  *((void *)&v41 + 1) += 8;
                  *(void *)&long long v43 = v43 - 512;
                }
                for (uint64_t i = 0; i != 8; ++i)
                {
                  unint64_t v22 = dword_1A410C8B8[i] + (uint64_t)v19;
                  if ((v22 & 0x80000000) == 0 && v22 < a3)
                  {
                    unint64_t v23 = dword_1A410C8D8[i] + (uint64_t)v20;
                    if ((v23 & 0x80000000) == 0
                      && v23 < (unint64_t)a2
                      && *((float *)this + (int)v23 + (int)v22 * (int)a2) >= 0.5
                      && !*(void *)&(*a4)->f64[v23 + (void)a4[13] * v22])
                    {
                      uint64_t v24 = *((void *)&v41 + 1);
                      if ((void)v42 == *((void *)&v41 + 1)) {
                        uint64_t v25 = 0;
                      }
                      else {
                        uint64_t v25 = (((void)v42 - *((void *)&v41 + 1)) << 6) - 1;
                      }
                      uint64_t v26 = *((void *)&v43 + 1);
                      unint64_t v27 = *((void *)&v43 + 1) + v43;
                      if (v25 == *((void *)&v43 + 1) + (void)v43)
                      {
                        std::deque<std::pair<int,int>>::__add_back_capacity(&v41);
                        uint64_t v26 = *((void *)&v43 + 1);
                        uint64_t v24 = *((void *)&v41 + 1);
                        unint64_t v27 = v43 + *((void *)&v43 + 1);
                      }
                      long long v28 = (_DWORD *)(*(void *)(v24 + ((v27 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v27 & 0x1FF));
                      *long long v28 = v22;
                      v28[1] = v23;
                      *((void *)&v43 + 1) = v26 + 1;
                      apple::vision::fgbg::ConnectedComponentResult::setLabel((apple::vision::fgbg::ConnectedComponentResult *)a4, v22, v23, v40);
                    }
                  }
                }
                uint64_t v17 = *((void *)&v43 + 1);
              }
              while (*((void *)&v43 + 1));
              int v12 = v35;
              unint64_t v9 = v36;
              unint64_t v11 = v38;
              int v10 = v39;
            }
          }
          ++v11;
        }
        while ((float *)v11 != a2);
      }
      ++v9;
    }
    while (v9 != a3);
  }
  if (*((unsigned char *)a4 + 137))
  {
    long long v29 = (unint64_t *)a4[1];
    uint64_t v30 = (char *)a4[2] - (char *)v29;
    if (v30)
    {
      unint64_t v31 = v30 >> 3;
      unint64_t v32 = a4[7];
      if (v31 <= 1) {
        unint64_t v31 = 1;
      }
      do
      {
        unint64_t v33 = *v29++;
        *unint64_t v32 = vdivq_f64(*v32, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v33), 0));
        ++v32;
        --v31;
      }
      while (v31);
    }
  }
  return std::deque<std::pair<int,int>>::~deque[abi:ne180100]((uint64_t)&v41);
}

void sub_1A3E5A60C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::deque<std::pair<int,int>>::~deque[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void apple::vision::fgbg::ConnectedComponentResult::setLabel(apple::vision::fgbg::ConnectedComponentResult *this, unint64_t a2, unint64_t a3, unint64_t a4)
{
  *(void *)(*(void *)this + 8 * (a3 + *((void *)this + 13) * a2)) = a4;
  unint64_t v8 = a4 - *((int *)this + 30);
  unint64_t v9 = (void *)*((void *)this + 1);
  int v10 = (unsigned char *)*((void *)this + 2);
  unint64_t v11 = (v10 - (unsigned char *)v9) >> 3;
  if (v11 > v8)
  {
    ++v9[v8];
    goto LABEL_24;
  }
  unint64_t v12 = a4 - v11;
  if (a4 > v11)
  {
    uint64_t v13 = *((void *)this + 3);
    if (v12 > (v13 - (uint64_t)v10) >> 3)
    {
      if (a4 >> 61) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v14 = v13 - (void)v9;
      uint64_t v15 = v14 >> 2;
      if (v14 >> 2 <= a4) {
        uint64_t v15 = a4;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v15;
      }
      if (v16)
      {
        unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v16);
        unint64_t v9 = (void *)*((void *)this + 1);
        int v10 = (unsigned char *)*((void *)this + 2);
      }
      else
      {
        uint64_t v17 = 0;
      }
      int v19 = (char *)(v16 + 8 * v11);
      unint64_t v20 = v16 + 8 * v17;
      bzero(v19, 8 * v12);
      int v21 = &v19[8 * v12];
      while (v10 != (unsigned char *)v9)
      {
        uint64_t v22 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v19 - 1) = v22;
        v19 -= 8;
      }
      *((void *)this + 1) = v19;
      *((void *)this + 2) = v21;
      *((void *)this + 3) = v20;
      if (v9) {
        operator delete(v9);
      }
      goto LABEL_23;
    }
    bzero(*((void **)this + 2), 8 * v12);
    uint64_t v18 = &v10[8 * v12];
    goto LABEL_16;
  }
  if (a4 < v11)
  {
    uint64_t v18 = (char *)&v9[a4];
LABEL_16:
    *((void *)this + 2) = v18;
  }
LABEL_23:
  *(void *)(*((void *)this + 1) + 8 * v8) = 1;
LABEL_24:
  uint64_t v23 = *((void *)this + 10);
  uint64_t v24 = *((void *)this + 11);
  unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 3);
  if (v25 <= v8)
  {
    unint64_t v26 = a4 - v25;
    if (a4 <= v25)
    {
      if (a4 < v25)
      {
        uint64_t v35 = v23 + 24 * a4;
        if (v24 != v35)
        {
          uint64_t v36 = *((void *)this + 11);
          do
          {
            unint64_t v38 = *(void **)(v36 - 24);
            v36 -= 24;
            uint64_t v37 = v38;
            if (v38)
            {
              *(void *)(v24 - 16) = v37;
              operator delete(v37);
            }
            uint64_t v24 = v36;
          }
          while (v36 != v35);
        }
        *((void *)this + 11) = v35;
      }
    }
    else
    {
      uint64_t v27 = *((void *)this + 12);
      if (0xAAAAAAAAAAAAAAABLL * ((v27 - v24) >> 3) >= v26)
      {
        size_t v39 = 24 * ((24 * v26 - 24) / 0x18) + 24;
        bzero(*((void **)this + 11), v39);
        *((void *)this + 11) = v24 + v39;
      }
      else
      {
        if (a4 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        v95[4] = (char *)this + 96;
        unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((v27 - v23) >> 3);
        uint64_t v29 = 2 * v28;
        if (2 * v28 <= a4) {
          uint64_t v29 = a4;
        }
        if (v28 >= 0x555555555555555) {
          unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v30 = v29;
        }
        unint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v30);
        unint64_t v32 = &v31[24 * v25];
        v95[0] = v31;
        v95[1] = v32;
        v95[3] = &v31[24 * v33];
        size_t v34 = 24 * ((24 * v26 - 24) / 0x18) + 24;
        bzero(v32, v34);
        v95[2] = &v32[v34];
        std::vector<std::vector<CGPoint>>::__swap_out_circular_buffer((void *)this + 10, v95);
        std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)v95);
      }
    }
    uint64_t v23 = *((void *)this + 10);
  }
  uint64_t v40 = v23 + 24 * v8;
  double v41 = (double)a3;
  double v42 = (double)a2;
  long long v44 = (double **)(v40 + 8);
  long long v43 = *(double **)(v40 + 8);
  unint64_t v45 = *(void *)(v40 + 16);
  if ((unint64_t)v43 >= v45)
  {
    long long v47 = *(double **)v40;
    uint64_t v48 = ((uint64_t)v43 - *(void *)v40) >> 4;
    unint64_t v49 = v48 + 1;
    if ((unint64_t)(v48 + 1) >> 60) {
      goto LABEL_110;
    }
    uint64_t v50 = v45 - (void)v47;
    if (v50 >> 3 > v49) {
      unint64_t v49 = v50 >> 3;
    }
    BOOL v51 = (unint64_t)v50 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v52 = 0xFFFFFFFFFFFFFFFLL;
    if (!v51) {
      unint64_t v52 = v49;
    }
    if (v52)
    {
      unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v52);
      long long v43 = *v44;
      long long v47 = *(double **)v40;
    }
    else
    {
      uint64_t v53 = 0;
    }
    uint16x8_t v54 = (double *)(v52 + 16 * v48);
    unint64_t v55 = v52 + 16 * v53;
    double *v54 = v41;
    v54[1] = v42;
    long long v46 = v54 + 2;
    if (v43 != v47)
    {
      do
      {
        *((_OWORD *)v54 - 1) = *((_OWORD *)v43 - 1);
        v54 -= 2;
        v43 -= 2;
      }
      while (v43 != v47);
      long long v47 = *(double **)v40;
    }
    *(void *)uint64_t v40 = v54;
    *long long v44 = v46;
    *(void *)(v40 + 16) = v55;
    if (v47) {
      operator delete(v47);
    }
  }
  else
  {
    double *v43 = v41;
    v43[1] = v42;
    long long v46 = v43 + 2;
  }
  *long long v44 = v46;
  ++*((void *)this + 16);
  if (*((unsigned char *)this + 136))
  {
    long long v57 = (unsigned char *)*((void *)this + 4);
    long long v56 = (char *)*((void *)this + 5);
    unint64_t v58 = (v56 - v57) >> 5;
    if (v58 > v8)
    {
      long long v59 = (unint64_t *)&v57[32 * v8];
      unint64_t v60 = v59[2];
      unint64_t v61 = v59[3];
      if (v60 >= a3) {
        unint64_t v60 = a3;
      }
      if (v61 <= a3) {
        unint64_t v61 = a3;
      }
      v59[2] = v60;
      v59[3] = v61;
      unint64_t v62 = *v59;
      unint64_t v63 = v59[1];
      if (*v59 >= a2) {
        unint64_t v62 = a2;
      }
      if (v63 <= a2) {
        unint64_t v63 = a2;
      }
      *long long v59 = v62;
      v59[1] = v63;
      goto LABEL_88;
    }
    unint64_t v64 = a4 - v58;
    if (a4 <= v58)
    {
      if (a4 >= v58)
      {
LABEL_87:
        uint64_t v75 = (int64x2_t *)(*((void *)this + 4) + 32 * v8);
        *uint64_t v75 = vdupq_n_s64(a2);
        v75[1] = vdupq_n_s64(a3);
        goto LABEL_88;
      }
      uint64_t v74 = &v57[32 * a4];
    }
    else
    {
      uint64_t v65 = *((void *)this + 6);
      if (v64 > (v65 - (uint64_t)v56) >> 5)
      {
        if (a4 >> 59) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v66 = v65 - (void)v57;
        uint64_t v67 = v66 >> 4;
        if (v66 >> 4 <= a4) {
          uint64_t v67 = a4;
        }
        if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v68 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v68 = v67;
        }
        if (v68 >> 59) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        float v69 = (char *)operator new(32 * v68);
        float v70 = &v69[32 * v58];
        float v71 = &v69[32 * v68];
        bzero(v70, 32 * v64);
        float v72 = &v70[32 * v64];
        if (v56 != v57)
        {
          do
          {
            long long v73 = *((_OWORD *)v56 - 1);
            *((_OWORD *)v70 - 2) = *((_OWORD *)v56 - 2);
            *((_OWORD *)v70 - 1) = v73;
            v70 -= 32;
            v56 -= 32;
          }
          while (v56 != v57);
          long long v56 = (char *)*((void *)this + 4);
        }
        *((void *)this + 4) = v70;
        *((void *)this + 5) = v72;
        *((void *)this + 6) = v71;
        if (v56) {
          operator delete(v56);
        }
        goto LABEL_87;
      }
      bzero(*((void **)this + 5), 32 * v64);
      uint64_t v74 = &v56[32 * v64];
    }
    *((void *)this + 5) = v74;
    goto LABEL_87;
  }
LABEL_88:
  if (!*((unsigned char *)this + 137)) {
    return;
  }
  uint64_t v76 = *((void *)this + 7);
  uint64_t v77 = *((void *)this + 8);
  unint64_t v78 = (v77 - v76) >> 4;
  if (v78 > v8)
  {
    float v79 = (double *)(v76 + 16 * v8);
    double v80 = v79[1] + v42;
    double *v79 = *v79 + v41;
    v79[1] = v80;
    return;
  }
  unint64_t v81 = a4 - v78;
  if (a4 > v78)
  {
    uint64_t v82 = *((void *)this + 9);
    if (v81 > (v82 - v77) >> 4)
    {
      if (!(a4 >> 60))
      {
        uint64_t v83 = v82 - v76;
        uint64_t v84 = v83 >> 3;
        if (v83 >> 3 <= a4) {
          uint64_t v84 = a4;
        }
        if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v85 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v85 = v84;
        }
        float v86 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v85);
        float v87 = &v86[16 * v78];
        float v89 = &v86[16 * v88];
        bzero(v87, 16 * v81);
        float v90 = &v87[16 * v81];
        v92 = (char *)*((void *)this + 7);
        v91 = (char *)*((void *)this + 8);
        if (v91 != v92)
        {
          do
          {
            *((_OWORD *)v87 - 1) = *((_OWORD *)v91 - 1);
            v87 -= 16;
            v91 -= 16;
          }
          while (v91 != v92);
          v91 = (char *)*((void *)this + 7);
        }
        *((void *)this + 7) = v87;
        *((void *)this + 8) = v90;
        *((void *)this + 9) = v89;
        if (v91) {
          operator delete(v91);
        }
        goto LABEL_108;
      }
LABEL_110:
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    bzero(*((void **)this + 8), 16 * v81);
    uint64_t v93 = v77 + 16 * v81;
    goto LABEL_107;
  }
  if (a4 < v78)
  {
    uint64_t v93 = v76 + 16 * a4;
LABEL_107:
    *((void *)this + 8) = v93;
  }
LABEL_108:
  uint64_t v94 = (double *)(*((void *)this + 7) + 16 * v8);
  *uint64_t v94 = v41;
  v94[1] = v42;
}

uint64_t std::deque<std::pair<int,int>>::~deque[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  id v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      id v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::deque<std::pair<int,int>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    a1[4] = v4;
    unint64_t v5 = (void *)a1[1];
    uint64_t v6 = (char *)a1[2];
    uint64_t v9 = *v5;
    uint64_t v7 = (char *)(v5 + 1);
    uint64_t v8 = v9;
    a1[1] = v7;
    if (v6 != (char *)a1[3]) {
      goto LABEL_41;
    }
    uint64_t v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v40 = 1;
      }
      else {
        unint64_t v40 = (uint64_t)&v6[-*a1] >> 2;
      }
      double v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v40);
      double v42 = &v41[8 * (v40 >> 2)];
      long long v44 = &v41[8 * v43];
      unint64_t v45 = (uint64_t *)a1[1];
      uint64_t v6 = v42;
      uint64_t v46 = a1[2] - (void)v45;
      if (v46)
      {
        uint64_t v6 = &v42[v46 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v47 = 8 * (v46 >> 3);
        uint64_t v48 = &v41[8 * (v40 >> 2)];
        do
        {
          uint64_t v49 = *v45++;
          *(void *)uint64_t v48 = v49;
          v48 += 8;
          v47 -= 8;
        }
        while (v47);
      }
      goto LABEL_29;
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    BOOL v12 = v10 >> 3 < -1;
    uint64_t v13 = (v10 >> 3) + 2;
    if (v12) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = v11 + 1;
    }
    uint64_t v15 = -(v14 >> 1);
    uint64_t v16 = v14 >> 1;
    uint64_t v17 = &v7[-8 * v16];
    int64_t v18 = v6 - v7;
    if (v6 != v7)
    {
      memmove(&v7[-8 * v16], v7, v6 - v7);
      uint64_t v7 = (char *)a1[1];
    }
    uint64_t v6 = &v17[v18];
    a1[1] = &v7[8 * v15];
    a1[2] = &v17[v18];
    goto LABEL_41;
  }
  unint64_t v20 = (char *)a1[2];
  int v19 = (char *)a1[3];
  int v21 = (char *)*a1;
  uint64_t v22 = (char *)a1[1];
  unint64_t v23 = (v20 - v22) >> 3;
  uint64_t v24 = (uint64_t)&v19[-*a1];
  if (v23 < v24 >> 3)
  {
    unint64_t v25 = operator new(0x1000uLL);
    unint64_t v26 = v25;
    if (v19 != v20)
    {
      *(void *)unint64_t v20 = v25;
LABEL_42:
      a1[2] += 8;
      return;
    }
    if (v22 == v21)
    {
      if (v20 == v22) {
        unint64_t v51 = 1;
      }
      else {
        unint64_t v51 = (v19 - v22) >> 2;
      }
      uint64_t v52 = 2 * v51;
      uint64_t v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v51);
      uint64_t v22 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
      unint64_t v55 = (uint64_t *)a1[1];
      long long v56 = v22;
      uint64_t v57 = a1[2] - (void)v55;
      if (v57)
      {
        long long v56 = &v22[v57 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v58 = 8 * (v57 >> 3);
        long long v59 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
        do
        {
          uint64_t v60 = *v55++;
          *(void *)long long v59 = v60;
          v59 += 8;
          v58 -= 8;
        }
        while (v58);
      }
      unint64_t v61 = (char *)*a1;
      *a1 = v53;
      a1[1] = v22;
      a1[2] = v56;
      a1[3] = &v53[8 * v54];
      if (v61)
      {
        operator delete(v61);
        uint64_t v22 = (char *)a1[1];
      }
    }
    *((void *)v22 - 1) = v26;
    uint64_t v7 = (char *)a1[1];
    uint64_t v6 = (char *)a1[2];
    a1[1] = v7 - 8;
    uint64_t v8 = *((void *)v7 - 1);
    a1[1] = v7;
    if (v6 != (char *)a1[3])
    {
LABEL_41:
      *(void *)uint64_t v6 = v8;
      goto LABEL_42;
    }
    uint64_t v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v85 = 1;
      }
      else {
        unint64_t v85 = (uint64_t)&v6[-*a1] >> 2;
      }
      double v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v85);
      double v42 = &v41[8 * (v85 >> 2)];
      long long v44 = &v41[8 * v86];
      float v87 = (uint64_t *)a1[1];
      uint64_t v6 = v42;
      uint64_t v88 = a1[2] - (void)v87;
      if (v88)
      {
        uint64_t v6 = &v42[v88 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v89 = 8 * (v88 >> 3);
        float v90 = &v41[8 * (v85 >> 2)];
        do
        {
          uint64_t v91 = *v87++;
          *(void *)float v90 = v91;
          v90 += 8;
          v89 -= 8;
        }
        while (v89);
      }
LABEL_29:
      uint64_t v50 = (char *)*a1;
      *a1 = v41;
      a1[1] = v42;
      a1[2] = v6;
      a1[3] = v44;
      if (v50)
      {
        operator delete(v50);
        uint64_t v6 = (char *)a1[2];
      }
      goto LABEL_41;
    }
    goto LABEL_5;
  }
  uint64_t v27 = v24 >> 2;
  if (v19 == v21) {
    unint64_t v28 = 1;
  }
  else {
    unint64_t v28 = v27;
  }
  uint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v28);
  uint64_t v31 = v30;
  unint64_t v32 = &v29[8 * v23];
  *(void *)&long long v33 = v29;
  *((void *)&v33 + 1) = v32;
  long long v95 = v33;
  size_t v34 = operator new(0x1000uLL);
  *(void *)&long long v35 = v32;
  *((void *)&v35 + 1) = &v29[8 * v31];
  if (v23 == v31)
  {
    uint64_t v36 = 8 * v23;
    *(void *)&long long v37 = v95;
    if (v20 - v22 >= 1)
    {
      uint64_t v38 = v36 >> 3;
      if (v38 >= -1) {
        unint64_t v39 = v38 + 1;
      }
      else {
        unint64_t v39 = v38 + 2;
      }
      v32 -= 8 * (v39 >> 1);
      *(void *)&long long v35 = v32;
      *((void *)&v37 + 1) = v32;
      goto LABEL_50;
    }
    uint64_t v62 = v36 >> 2;
    if (v20 == v22) {
      unint64_t v63 = 1;
    }
    else {
      unint64_t v63 = v62;
    }
    unint64_t v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v63);
    unint64_t v32 = &v64[8 * (v63 >> 2)];
    *(void *)&long long v37 = v64;
    *((void *)&v37 + 1) = v32;
    *(void *)&long long v35 = v32;
    *((void *)&v35 + 1) = &v64[8 * v65];
    if (!v29) {
      goto LABEL_50;
    }
    long long v92 = v35;
    long long v95 = v37;
    operator delete(v29);
    long long v35 = v92;
  }
  long long v37 = v95;
LABEL_50:
  *(void *)unint64_t v32 = v34;
  *(void *)&long long v35 = v35 + 8;
  for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
  {
    uint64_t v67 = (void *)*((void *)&v37 + 1);
    if (*((void *)&v37 + 1) == (void)v37)
    {
      float v69 = (unsigned char *)v35;
      if ((unint64_t)v35 >= *((void *)&v35 + 1))
      {
        if (*((void *)&v35 + 1) == *((void *)&v37 + 1)) {
          unint64_t v74 = 1;
        }
        else {
          unint64_t v74 = (uint64_t)(*((void *)&v35 + 1) - *((void *)&v37 + 1)) >> 2;
        }
        uint64_t v75 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v74);
        unint64_t v68 = &v75[(2 * v74 + 6) & 0xFFFFFFFFFFFFFFF8];
        uint64_t v77 = v68;
        uint64_t v78 = v69 - (unsigned char *)v67;
        if (v69 != (unsigned char *)v67)
        {
          uint64_t v77 = &v68[v78 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v79 = 8 * (v78 >> 3);
          double v80 = v68;
          unint64_t v81 = v67;
          do
          {
            uint64_t v82 = *v81++;
            *(void *)double v80 = v82;
            v80 += 8;
            v79 -= 8;
          }
          while (v79);
        }
        *(void *)&long long v37 = v75;
        *((void *)&v37 + 1) = v68;
        *(void *)&long long v35 = v77;
        *((void *)&v35 + 1) = &v75[8 * v76];
        if (v67)
        {
          long long v93 = v35;
          long long v97 = v37;
          operator delete(v67);
          long long v35 = v93;
          long long v37 = v97;
        }
      }
      else
      {
        uint64_t v70 = (uint64_t)(*((void *)&v35 + 1) - v35) >> 3;
        if (v70 >= -1) {
          uint64_t v71 = v70 + 1;
        }
        else {
          uint64_t v71 = v70 + 2;
        }
        uint64_t v72 = v71 >> 1;
        uint64_t v73 = v35 + 8 * (v71 >> 1);
        unint64_t v68 = (char *)(v73 - (v35 - *((void *)&v37 + 1)));
        if ((void)v35 == *((void *)&v37 + 1))
        {
          float v69 = (unsigned char *)*((void *)&v37 + 1);
        }
        else
        {
          uint64_t v94 = *((void *)&v35 + 1);
          uint64_t v96 = v37;
          memmove((void *)(v73 - (v35 - *((void *)&v37 + 1))), *((const void **)&v37 + 1), v35 - *((void *)&v37 + 1));
          *((void *)&v35 + 1) = v94;
          *(void *)&long long v37 = v96;
        }
        *((void *)&v37 + 1) = v68;
        *(void *)&long long v35 = &v69[8 * v72];
      }
    }
    else
    {
      unint64_t v68 = (char *)*((void *)&v37 + 1);
    }
    uint64_t v83 = *(void *)(i - 8);
    *((void *)v68 - 1) = v83;
    *((void *)&v37 + 1) -= 8;
  }
  uint64_t v84 = (char *)*a1;
  *(_OWORD *)a1 = v37;
  *((_OWORD *)a1 + 1) = v35;
  if (v84)
  {
    operator delete(v84);
  }
}

void sub_1A3E5B198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11)
{
  operator delete(v11);
  if ((void)a11) {
    operator delete((void *)a11);
  }
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<CGPoint>>::__swap_out_circular_buffer(void *result, void *a2)
{
  BOOL v3 = (void *)*result;
  unint64_t v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0;
    *(void *)(v4 - 16) = 0;
    v4 -= 24;
    *(void *)(v4 + 16) = 0;
    long long v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(v4 + 16) = v2[2];
    *unint64_t v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *__n128 result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t vision::mod::ImageProcessing_Preprocessor::ImageProcessing_Preprocessor(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a1 + 16) = 1;
  *(unsigned char *)(a1 + 18) = 0;
  *(void *)(a1 + 20) = 0x437F000000000000;
  *(_DWORD *)(a1 + 28) = 32;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v4 = (void *)(a1 + 40);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  long long v5 = operator new(0xAuLL);
  uint64_t v6 = 0;
  *uint64_t v4 = v5;
  v5[4] = 2567;
  *(void *)(a1 + 48) = v5 + 5;
  *(void *)(a1 + 56) = v5 + 5;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 72) = 0;
  uint64_t v7 = (uint64_t **)(a1 + 72);
  *(void *)long long v5 = 0x908060504030201;
  *(void *)(a1 + 64) = a1 + 72;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = a1 + 96;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = 0;
  char v8 = *(unsigned char *)(a2 + 16);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  *(unsigned char *)(a1 + 32) = v8;
  do
  {
    uint64_t v9 = *v7;
    uint64_t v10 = (uint64_t **)(a1 + 72);
    uint64_t v11 = (uint64_t **)(a1 + 72);
    if (*v7)
    {
      unsigned int v12 = *((unsigned __int8 *)v5 + v6);
      while (1)
      {
        while (1)
        {
          uint64_t v11 = (uint64_t **)v9;
          unsigned int v13 = *((unsigned __int8 *)v9 + 32);
          if (v12 >= v13) {
            break;
          }
          uint64_t v9 = *v11;
          uint64_t v10 = v11;
          if (!*v11) {
            goto LABEL_10;
          }
        }
        if (v13 >= v12) {
          break;
        }
        uint64_t v9 = v11[1];
        if (!v9)
        {
          uint64_t v10 = v11 + 1;
          goto LABEL_10;
        }
      }
      uint64_t v14 = (char *)v11;
    }
    else
    {
LABEL_10:
      uint64_t v14 = (char *)operator new(0x50uLL);
      v14[32] = *((unsigned char *)v5 + v6);
      *(_OWORD *)(v14 + 40) = 0u;
      *(_OWORD *)(v14 + 56) = 0u;
      *((void *)v14 + 9) = 0;
      *(void *)uint64_t v14 = 0;
      *((void *)v14 + 1) = 0;
      *((void *)v14 + 2) = v11;
      unsigned char *v10 = (uint64_t *)v14;
      uint64_t v15 = **(void **)(a1 + 64);
      uint64_t v16 = (uint64_t *)v14;
      if (v15)
      {
        *(void *)(a1 + 64) = v15;
        uint64_t v16 = *v10;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 72), v16);
      ++*(void *)(a1 + 80);
    }
    *(void *)(v14 + 69) = 0;
    *(_OWORD *)(v14 + 56) = 0u;
    *(_OWORD *)(v14 + 40) = 0u;
    ++v6;
  }
  while (v6 != 10);
  *(int32x4_t *)a1 = vdupq_n_s32(0x7FC00000u);
  *(_OWORD *)(a1 + 128) = xmmword_1A410C0F0;
  *(void *)(a1 + 144) = 0;
  return a1;
}

void sub_1A3E5BC2C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::__map_value_compare<vision::mod::ImagePreprocessor_BufferName,std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::less<vision::mod::ImagePreprocessor_BufferName>,true>,std::allocator<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>>>::destroy(*v4);
  std::__tree<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::__map_value_compare<vision::mod::ImagePreprocessor_BufferName,std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::less<vision::mod::ImagePreprocessor_BufferName>,true>,std::allocator<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>>>::destroy(*v3);
  uint64_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 48) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<vision::mod::ImageProcessing_Preprocessor>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *__n128 result = a2;
  if (v2)
  {
    free(*(void **)(v2 + 112));
    std::__tree<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::__map_value_compare<vision::mod::ImagePreprocessor_BufferName,std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::less<vision::mod::ImagePreprocessor_BufferName>,true>,std::allocator<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>>>::destroy(*(void **)(v2 + 96));
    std::__tree<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::__map_value_compare<vision::mod::ImagePreprocessor_BufferName,std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::less<vision::mod::ImagePreprocessor_BufferName>,true>,std::allocator<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>>>::destroy(*(void **)(v2 + 72));
    BOOL v3 = *(void **)(v2 + 40);
    if (v3)
    {
      *(void *)(v2 + 48) = v3;
      operator delete(v3);
    }
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

void std::__tree<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::__map_value_compare<vision::mod::ImagePreprocessor_BufferName,std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::less<vision::mod::ImagePreprocessor_BufferName>,true>,std::allocator<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::__map_value_compare<vision::mod::ImagePreprocessor_BufferName,std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::less<vision::mod::ImagePreprocessor_BufferName>,true>,std::allocator<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>>>::destroy(*a1);
    std::__tree<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::__map_value_compare<vision::mod::ImagePreprocessor_BufferName,std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>,std::less<vision::mod::ImagePreprocessor_BufferName>,true>,std::allocator<std::__value_type<vision::mod::ImagePreprocessor_BufferName,vision::mod::ImageProcessing_ImageBuffer>>>::destroy(a1[1]);
    if (!*((unsigned char *)a1 + 76)) {
      free((void *)a1[5]);
    }
    operator delete(a1);
  }
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  long long v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    char v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    long long v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

void std::__shared_ptr_emplace<vision::mod::ConcreteFaceQualityPredictor>::__on_zero_shared(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 556))
  {
    if (espresso_plan_destroy())
    {
      syslog(5, "[Error] Failed to destroy the existing FaceQual espresso plan ");
LABEL_6:
      syslog(5, "[Error] Failed to destroy Face Quality object");
      goto LABEL_7;
    }
    *(void *)(a1 + 184) = 0;
    if (espresso_context_destroy())
    {
      syslog(5, "[Error] Failed to destroy the existing FaceQual context ");
      goto LABEL_6;
    }
    *(void *)(a1 + 176) = 0;
  }
LABEL_7:
  std::unique_ptr<vision::mod::ImageProcessing_Preprocessor>::reset[abi:ne180100]((uint64_t *)(a1 + 168), 0);
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
}

void std::__shared_ptr_emplace<vision::mod::ConcreteFaceQualityPredictor>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7538F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ConcreteFaceQualityPredictor>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7538F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void vision::mod::ImageDescriptorBufferAbstract::getRepresentative()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = 3711;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

float vision::mod::ImageDescriptorBufferAbstract::computeDistanceFrom(vision::mod::ImageDescriptorBufferAbstract *this, const vision::mod::ImageDescriptorBufferAbstract *a2)
{
  if (*((void *)this + 9) != 1 || *((void *)a2 + 9) != 1)
  {
    syslog(5, "ERROR: Incorrect count of descriptors in one of the buffers, expected exactly 1\n");
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3708;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  (*(void (**)(void **__return_ptr))(*(void *)this + 80))(__p);
  float v3 = *(float *)__p[0];
  __p[1] = __p[0];
  operator delete(__p[0]);
  return v3;
}

uint64_t vision::mod::ImageDescriptorBufferAbstract::print@<X0>(vision::mod::ImageDescriptorBufferAbstract *this@<X0>, void *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v10);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)"Descriptor count = ", 19);
  uint64_t v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  long long v5 = std::locale::use_facet(&v15, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v15);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)"Descriptor length = ", 20);
  (*(void (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)this + 104))(this);
  std::string::size_type v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" bytes", 6);
  std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24)));
  std::string::size_type v7 = std::locale::use_facet(&v15, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10);
  std::locale::~locale(&v15);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a2, (uint64_t)v12);
  v10[0] = *MEMORY[0x1E4FBA408];
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v11 = v8;
  v12[0] = MEMORY[0x1E4FBA470] + 16;
  if (v13 < 0) {
    operator delete((void *)v12[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A6256200](&v14);
}

void sub_1A3E5C358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 56));
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorBufferAbstract::deleteDescriptorsWithIds(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*(void *)(a1 + 8) == *(void *)(a1 + 16))
  {
    syslog(5, "ERROR: Can't delete descriptors with given ids - ids information is not present\n");
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3708;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  __p = 0;
  uint64_t v43 = 0;
  unint64_t v44 = 0;
  uint64_t v6 = *a2;
  if ((int)((unint64_t)(a2[1] - *a2) >> 3) >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      unint64_t v39 = *(void **)(v6 + 8 * v7);
      uint64_t v8 = std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 32), (uint64_t)v39, &v39);
      uint64_t v9 = v8;
      uint64_t v10 = v43;
      if ((unint64_t)v43 >= v44)
      {
        unsigned int v12 = (char *)__p;
        uint64_t v13 = (v43 - (unsigned char *)__p) >> 2;
        unint64_t v14 = v13 + 1;
        if ((unint64_t)(v13 + 1) >> 62) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = v44 - (void)__p;
        if ((uint64_t)(v44 - (void)__p) >> 1 > v14) {
          unint64_t v14 = v15 >> 1;
        }
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v14;
        }
        if (v16)
        {
          unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v16);
          unsigned int v12 = (char *)__p;
          uint64_t v10 = v43;
        }
        else
        {
          uint64_t v17 = 0;
        }
        int64_t v18 = (char *)(v16 + 4 * v13);
        *(_DWORD *)int64_t v18 = *((_DWORD *)v9 + 10);
        uint64_t v11 = v18 + 4;
        while (v10 != v12)
        {
          int v19 = *((_DWORD *)v10 - 1);
          v10 -= 4;
          *((_DWORD *)v18 - 1) = v19;
          v18 -= 4;
        }
        __p = v18;
        unint64_t v44 = v16 + 4 * v17;
        if (v12) {
          operator delete(v12);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v43 = *((_DWORD *)v8 + 10);
        uint64_t v11 = v10 + 4;
      }
      uint64_t v43 = v11;
      ++v7;
      uint64_t v6 = *a2;
    }
    while (v7 < (int)((unint64_t)(a2[1] - *a2) >> 3));
  }
  unint64_t v39 = 0;
  unint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v20 = (*(uint64_t (**)(uint64_t, void **, void **))(*(void *)a1 + 56))(a1, &__p, &v39);
  if ((v20 & 0x80) != 0)
  {
    int v21 = (char *)v39;
    if (a3 && (uint64_t v22 = v40, (int)((unint64_t)(v40 - (unsigned char *)v39) >> 2) >= 1))
    {
      uint64_t v23 = 0;
      uint64_t v20 = 3712;
      do
      {
        uint64_t v24 = *(int *)&v21[4 * v23];
        uint64_t v25 = *(void *)(a1 + 8);
        if ((int)v24 < (int)((unint64_t)(*(void *)(a1 + 16) - v25) >> 3))
        {
          uint64_t v27 = *(void **)(a3 + 8);
          unint64_t v26 = *(void *)(a3 + 16);
          if ((unint64_t)v27 >= v26)
          {
            uint64_t v29 = *(void **)a3;
            uint64_t v30 = ((uint64_t)v27 - *(void *)a3) >> 3;
            unint64_t v31 = v30 + 1;
            if ((unint64_t)(v30 + 1) >> 61) {
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v32 = v26 - (void)v29;
            if (v32 >> 2 > v31) {
              unint64_t v31 = v32 >> 2;
            }
            if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v33 = v31;
            }
            if (v33)
            {
              unint64_t v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v33);
              uint64_t v29 = *(void **)a3;
              uint64_t v27 = *(void **)(a3 + 8);
            }
            else
            {
              uint64_t v34 = 0;
            }
            long long v35 = (void *)(v33 + 8 * v30);
            *long long v35 = *(void *)(v25 + 8 * v24);
            unint64_t v28 = v35 + 1;
            while (v27 != v29)
            {
              uint64_t v36 = *--v27;
              *--long long v35 = v36;
            }
            *(void *)a3 = v35;
            *(void *)(a3 + 8) = v28;
            *(void *)(a3 + 16) = v33 + 8 * v34;
            if (v29) {
              operator delete(v29);
            }
          }
          else
          {
            *uint64_t v27 = *(void *)(v25 + 8 * v24);
            unint64_t v28 = v27 + 1;
          }
          *(void *)(a3 + 8) = v28;
          int v21 = (char *)v39;
          uint64_t v22 = v40;
        }
        ++v23;
      }
      while (v23 < (int)((unint64_t)(v22 - v21) >> 2));
    }
    else
    {
      uint64_t v20 = 3712;
    }
  }
  else
  {
    int v21 = (char *)v39;
  }
  if (v21)
  {
    unint64_t v40 = v21;
    operator delete(v21);
  }
  if (__p)
  {
    uint64_t v43 = (char *)__p;
    operator delete(__p);
  }
  return v20;
}

void sub_1A3E5C68C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageDescriptorBufferAbstract::deleteDescriptorsAtIndexes(uint64_t a1, int **a2, uint64_t a3)
{
  long long v5 = *a2;
  uint64_t v6 = a2[1];
  if (*a2 == v6)
  {
    uint64_t v7 = 0;
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      if ((unint64_t)v8 >= v9)
      {
        uint64_t v11 = v8 - v7;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 62) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        if ((uint64_t)(v9 - (void)v7) >> 1 > v12) {
          unint64_t v12 = (uint64_t)(v9 - (void)v7) >> 1;
        }
        if (v9 - (unint64_t)v7 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v13 = v12;
        }
        if (v13) {
          unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v13);
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v15 = (int *)(v13 + 4 * v11);
        *uint64_t v15 = *v5;
        uint64_t v10 = v15 + 1;
        while (v8 != v7)
        {
          int v16 = *--v8;
          *--uint64_t v15 = v16;
        }
        unint64_t v9 = v13 + 4 * v14;
        if (v7) {
          operator delete(v7);
        }
        uint64_t v7 = v15;
      }
      else
      {
        *uint64_t v8 = *v5;
        uint64_t v10 = v8 + 1;
      }
      ++v5;
      uint64_t v8 = v10;
    }
    while (v5 != v6);
  }
  unint64_t v17 = 126 - 2 * __clz(v10 - v7);
  uint64_t v18 = (char *)v10 - (char *)v7;
  if (v10 == v7) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = v17;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v7, v10, v19, 1);
  if ((int)((unint64_t)v18 >> 2) >= 1)
  {
    unint64_t v20 = 0;
    uint64_t v21 = (int)(v18 >> 2);
    if (v21 <= 1) {
      uint64_t v21 = 1;
    }
    uint64_t v22 = 4 * v21;
    do
    {
      uint64_t v23 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 48))(a1, v7[v20 / 4], a3);
      if ((v23 & 0x80) == 0) {
        goto LABEL_33;
      }
      v20 += 4;
    }
    while (v22 != v20);
  }
  uint64_t v23 = 3712;
  if (v7) {
LABEL_33:
  }
    operator delete(v7);
  return v23;
}

void sub_1A3E5C884(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

int *std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(int *result, int *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = a2 - 1;
    uint64_t v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v11;
          uint64_t v12 = (char *)a2 - (char *)v11;
          unint64_t v13 = a2 - v11;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                int v40 = *v11;
                if (*v10 > *v11)
                {
                  int *v11 = *v10;
                  int *v10 = v40;
                }
                break;
              case 3uLL:
                int v41 = v11[1];
                if (v41 <= *v10) {
                  int v42 = *v10;
                }
                else {
                  int v42 = v11[1];
                }
                if (v41 >= *v10) {
                  int v41 = *v10;
                }
                int *v10 = v41;
                v11[1] = v42;
                int v43 = *v10;
                if (*v10 <= *v11) {
                  int v44 = *v11;
                }
                else {
                  int v44 = *v10;
                }
                if (v43 >= *v11) {
                  int v43 = *v11;
                }
                int *v10 = v43;
                int v46 = *v11;
                int v45 = v11[1];
                if (v44 <= v45) {
                  int v46 = v11[1];
                }
                if (v44 < v45) {
                  int v45 = v44;
                }
                int *v11 = v46;
                v11[1] = v45;
                break;
              case 4uLL:
                int v48 = v11[1];
                int v47 = v11[2];
                if (*v11 <= v47) {
                  int v49 = v11[2];
                }
                else {
                  int v49 = *v11;
                }
                if (*v11 < v47) {
                  int v47 = *v11;
                }
                _OWORD v11[2] = v47;
                int *v11 = v49;
                int v50 = *v10;
                if (v48 <= *v10) {
                  int v51 = *v10;
                }
                else {
                  int v51 = v48;
                }
                if (v48 < v50) {
                  int v50 = v48;
                }
                int *v10 = v50;
                int v52 = *v11;
                if (*v11 <= v51) {
                  int v53 = v51;
                }
                else {
                  int v53 = *v11;
                }
                if (v52 >= v51) {
                  int v52 = v51;
                }
                int *v11 = v53;
                v11[1] = v52;
                int v54 = v11[2];
                if (v54 <= *v10) {
                  int v55 = *v10;
                }
                else {
                  int v55 = v11[2];
                }
                if (v54 >= *v10) {
                  int v54 = *v10;
                }
                int *v10 = v54;
                int v56 = v11[1];
                if (v56 <= v55) {
                  int v57 = v55;
                }
                else {
                  int v57 = v11[1];
                }
                if (v56 >= v55) {
                  int v56 = v55;
                }
                v11[1] = v57;
                _OWORD v11[2] = v56;
                break;
              case 5uLL:
                int v58 = *v11;
                int v59 = v11[1];
                if (*v11 <= v59) {
                  int v60 = v11[1];
                }
                else {
                  int v60 = *v11;
                }
                if (v58 >= v59) {
                  int v58 = v11[1];
                }
                int *v11 = v60;
                v11[1] = v58;
                int v61 = v11[3];
                if (v61 <= *v10) {
                  int v62 = *v10;
                }
                else {
                  int v62 = v11[3];
                }
                if (v61 >= *v10) {
                  int v61 = *v10;
                }
                int *v10 = v61;
                v11[3] = v62;
                int v63 = *v10;
                int v64 = v11[2];
                if (*v10 <= v64) {
                  int v65 = v11[2];
                }
                else {
                  int v65 = *v10;
                }
                if (v63 >= v64) {
                  int v63 = v11[2];
                }
                int *v10 = v63;
                int v67 = v11[2];
                int v66 = v11[3];
                int v68 = v11[1];
                if (v65 <= v66) {
                  int v67 = v11[3];
                }
                if (v65 < v66) {
                  int v66 = v65;
                }
                _OWORD v11[2] = v67;
                v11[3] = v66;
                int v69 = *v10;
                if (v68 <= *v10) {
                  int v70 = *v10;
                }
                else {
                  int v70 = v68;
                }
                if (v68 < v69) {
                  int v69 = v68;
                }
                int *v10 = v69;
                int v71 = *v11;
                int v73 = v11[2];
                int v72 = v11[3];
                if (v72 <= *v11) {
                  int v74 = *v11;
                }
                else {
                  int v74 = v11[3];
                }
                if (v72 >= v71) {
                  int v72 = *v11;
                }
                if (v74 <= v73) {
                  int v71 = v11[2];
                }
                if (v74 < v73) {
                  int v73 = v74;
                }
                if (v72 <= v70) {
                  int v75 = v70;
                }
                else {
                  int v75 = v72;
                }
                if (v72 >= v70) {
                  int v72 = v70;
                }
                if (v75 <= v73) {
                  int v70 = v73;
                }
                int *v11 = v71;
                v11[1] = v70;
                if (v75 >= v73) {
                  int v76 = v73;
                }
                else {
                  int v76 = v75;
                }
                _OWORD v11[2] = v76;
                v11[3] = v72;
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 95)
          {
            uint64_t v77 = v11 + 1;
            BOOL v79 = v11 == a2 || v77 == a2;
            if (a4)
            {
              if (!v79)
              {
                uint64_t v80 = 4;
                unint64_t v81 = v11;
                do
                {
                  int v83 = *v81;
                  int v82 = v81[1];
                  unint64_t v81 = v77;
                  if (v82 > v83)
                  {
                    uint64_t v84 = v80;
                    do
                    {
                      *(int *)((char *)v11 + v84) = v83;
                      uint64_t v85 = v84 - 4;
                      if (v84 == 4)
                      {
                        uint64_t v86 = v11;
                        goto LABEL_155;
                      }
                      int v83 = *(int *)((char *)v11 + v84 - 8);
                      v84 -= 4;
                    }
                    while (v82 > v83);
                    uint64_t v86 = (int *)((char *)v11 + v85);
LABEL_155:
                    *uint64_t v86 = v82;
                  }
                  uint64_t v77 = v81 + 1;
                  v80 += 4;
                }
                while (v81 + 1 != a2);
              }
            }
            else if (!v79)
            {
              do
              {
                int v112 = *v9;
                int v111 = v9[1];
                unint64_t v9 = v77;
                if (v111 > v112)
                {
                  do
                  {
                    *uint64_t v77 = v112;
                    int v112 = *(v77 - 2);
                    --v77;
                  }
                  while (v111 > v112);
                  *uint64_t v77 = v111;
                }
                uint64_t v77 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v87 = (v13 - 2) >> 1;
              int64_t v88 = v87;
              do
              {
                int64_t v89 = v88;
                if (v87 >= v88)
                {
                  uint64_t v90 = (2 * v88) | 1;
                  uint64_t v91 = &v11[v90];
                  if (2 * v89 + 2 < (uint64_t)v13)
                  {
                    int v93 = v91[1];
                    BOOL v92 = *v91 <= v93;
                    if (*v91 < v93) {
                      int v93 = *v91;
                    }
                    if (!v92)
                    {
                      ++v91;
                      uint64_t v90 = 2 * v89 + 2;
                    }
                  }
                  else
                  {
                    int v93 = *v91;
                  }
                  uint64_t v94 = &v11[v89];
                  int v95 = *v94;
                  if (v93 <= *v94)
                  {
                    do
                    {
                      *uint64_t v94 = v93;
                      uint64_t v94 = v91;
                      if (v87 < v90) {
                        break;
                      }
                      uint64_t v96 = (2 * v90) | 1;
                      uint64_t v91 = &v11[v96];
                      uint64_t v90 = 2 * v90 + 2;
                      if (v90 < (uint64_t)v13)
                      {
                        int v93 = *v91;
                        __n128 result = v91 + 1;
                        int v97 = v91[1];
                        if (*v91 >= v97) {
                          int v93 = v91[1];
                        }
                        if (*v91 <= v97) {
                          uint64_t v90 = v96;
                        }
                        else {
                          ++v91;
                        }
                      }
                      else
                      {
                        int v93 = *v91;
                        uint64_t v90 = v96;
                      }
                    }
                    while (v93 <= v95);
                    *uint64_t v94 = v95;
                  }
                }
                int64_t v88 = v89 - 1;
              }
              while (v89);
              uint64_t v98 = (unint64_t)v12 >> 2;
              do
              {
                uint64_t v99 = 0;
                int v100 = *v11;
                v101 = v11;
                do
                {
                  uint64_t v102 = &v101[v99 + 1];
                  uint64_t v103 = (2 * v99) | 1;
                  uint64_t v99 = 2 * v99 + 2;
                  if (v99 < v98)
                  {
                    int v105 = *v102;
                    int v104 = v102[1];
                    if (*v102 >= v104) {
                      int v105 = v102[1];
                    }
                    if (*v102 <= v104) {
                      uint64_t v99 = v103;
                    }
                    else {
                      ++v102;
                    }
                  }
                  else
                  {
                    int v105 = *v102;
                    uint64_t v99 = v103;
                  }
                  int *v101 = v105;
                  v101 = v102;
                }
                while (v99 <= (uint64_t)((unint64_t)(v98 - 2) >> 1));
                if (v102 == --a2)
                {
                  *uint64_t v102 = v100;
                }
                else
                {
                  *uint64_t v102 = *a2;
                  *a2 = v100;
                  uint64_t v106 = (char *)v102 - (char *)v11 + 4;
                  if (v106 >= 5)
                  {
                    unint64_t v107 = (((unint64_t)v106 >> 2) - 2) >> 1;
                    long long v108 = &v11[v107];
                    int v109 = *v108;
                    int v110 = *v102;
                    if (*v108 > *v102)
                    {
                      do
                      {
                        *uint64_t v102 = v109;
                        uint64_t v102 = v108;
                        if (!v107) {
                          break;
                        }
                        unint64_t v107 = (v107 - 1) >> 1;
                        long long v108 = &v11[v107];
                        int v109 = *v108;
                      }
                      while (*v108 > v110);
                      *uint64_t v102 = v110;
                    }
                  }
                }
                BOOL v92 = v98-- <= 2;
              }
              while (!v92);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          uint64_t v15 = &v11[v13 >> 1];
          if ((unint64_t)v12 >= 0x201)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v9, &v9[v13 >> 1], a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v9 + 1, v15 - 1, a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v9 + 2, &v9[v14 + 1], a2 - 3);
            __n128 result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v15 - 1, v15, &v9[v14 + 1]);
            int v16 = *v9;
            int *v9 = *v15;
            *uint64_t v15 = v16;
          }
          else
          {
            __n128 result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(&v9[v13 >> 1], v9, a2 - 1);
          }
          --a3;
          int v17 = *v9;
          uint64_t v18 = v9;
          if (a4) {
            break;
          }
          uint64_t v18 = v9;
          if (*(v9 - 1) > v17) {
            break;
          }
          if (v17 <= *v10)
          {
            uint64_t v32 = v9 + 1;
            do
            {
              uint64_t v11 = v32;
              if (v32 >= a2) {
                break;
              }
              ++v32;
            }
            while (v17 <= *v11);
          }
          else
          {
            uint64_t v11 = v9;
            do
            {
              int v31 = v11[1];
              ++v11;
            }
            while (v17 <= v31);
          }
          unint64_t v33 = a2;
          if (v11 < a2)
          {
            unint64_t v33 = a2;
            do
              int v34 = *--v33;
            while (v17 > v34);
          }
          if (v11 < v33)
          {
            int v35 = *v11;
            int v36 = *v33;
            do
            {
              int *v11 = v36;
              *unint64_t v33 = v35;
              do
              {
                int v37 = v11[1];
                ++v11;
                int v35 = v37;
              }
              while (v17 <= v37);
              do
              {
                int v38 = *--v33;
                int v36 = v38;
              }
              while (v17 > v38);
            }
            while (v11 < v33);
          }
          unint64_t v39 = v11 - 1;
          BOOL v4 = v11 - 1 >= v9;
          BOOL v5 = v11 - 1 == v9;
          if (v11 - 1 != v9) {
            int *v9 = *v39;
          }
          a4 = 0;
          *unint64_t v39 = v17;
        }
        do
        {
          uint64_t v19 = v18;
          int v21 = v18[1];
          ++v18;
          int v20 = v21;
        }
        while (v21 > v17);
        uint64_t v22 = a2;
        if (v19 == v9)
        {
          uint64_t v22 = a2;
          do
          {
            if (v18 >= v22) {
              break;
            }
            int v24 = *--v22;
          }
          while (v24 <= v17);
        }
        else
        {
          do
            int v23 = *--v22;
          while (v23 <= v17);
        }
        if (v18 < v22)
        {
          int v25 = *v22;
          unint64_t v26 = v18;
          uint64_t v27 = v22;
          do
          {
            *unint64_t v26 = v25;
            *uint64_t v27 = v20;
            do
            {
              uint64_t v19 = v26;
              int v28 = v26[1];
              ++v26;
              int v20 = v28;
            }
            while (v28 > v17);
            do
            {
              int v29 = *--v27;
              int v25 = v29;
            }
            while (v29 <= v17);
          }
          while (v26 < v27);
        }
        if (v19 != v9) {
          int *v9 = *v19;
        }
        int *v19 = v17;
        if (v18 >= v22) {
          break;
        }
LABEL_30:
        __n128 result = (int *)std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v9, v19, a3, a4 & 1);
        a4 = 0;
        uint64_t v11 = v19 + 1;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v9, v19);
      uint64_t v11 = v19 + 1;
      __n128 result = (int *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v19 + 1, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_30;
      }
    }
    a2 = v19;
    if (!v30) {
      continue;
    }
    return result;
  }
}

int *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(int *result, int *a2, int *a3)
{
  int v3 = *a2;
  int v4 = *result;
  int v5 = *a3;
  if (*a2 <= *result)
  {
    if (v5 > v3)
    {
      *a2 = v5;
      *a3 = v3;
      int v6 = *result;
      if (*a2 > *result)
      {
        *__n128 result = *a2;
        *a2 = v6;
      }
    }
  }
  else
  {
    if (v5 <= v3)
    {
      *__n128 result = v3;
      *a2 = v4;
      if (*a3 <= v4) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *__n128 result = v5;
    }
    *a3 = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(_DWORD *a1, int *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      int v3 = *(a2 - 1);
      int v4 = *a1;
      if (v3 > *a1)
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      int v20 = a1[1];
      int v21 = *(a2 - 1);
      if (v20 <= v21) {
        int v22 = *(a2 - 1);
      }
      else {
        int v22 = a1[1];
      }
      if (v20 >= v21) {
        int v20 = *(a2 - 1);
      }
      *(a2 - 1) = v20;
      a1[1] = v22;
      int v23 = *(a2 - 1);
      if (v23 <= *a1) {
        int v24 = *a1;
      }
      else {
        int v24 = *(a2 - 1);
      }
      if (v23 >= *a1) {
        int v23 = *a1;
      }
      *(a2 - 1) = v23;
      int v26 = *a1;
      int v25 = a1[1];
      if (v24 <= v25) {
        int v26 = a1[1];
      }
      if (v24 < v25) {
        int v25 = v24;
      }
      *a1 = v26;
      a1[1] = v25;
      return 1;
    case 4:
      int v48 = a1[1];
      int v47 = a1[2];
      if (*a1 <= v47) {
        int v49 = a1[2];
      }
      else {
        int v49 = *a1;
      }
      if (*a1 < v47) {
        int v47 = *a1;
      }
      a1[2] = v47;
      *a1 = v49;
      int v50 = *(a2 - 1);
      if (v48 <= v50) {
        int v51 = *(a2 - 1);
      }
      else {
        int v51 = v48;
      }
      if (v48 < v50) {
        int v50 = v48;
      }
      *(a2 - 1) = v50;
      int v52 = *a1;
      if (*a1 <= v51) {
        int v53 = v51;
      }
      else {
        int v53 = *a1;
      }
      if (v52 >= v51) {
        int v52 = v51;
      }
      *a1 = v53;
      a1[1] = v52;
      int v54 = a1[2];
      int v55 = *(a2 - 1);
      if (v54 <= v55) {
        int v56 = *(a2 - 1);
      }
      else {
        int v56 = a1[2];
      }
      if (v54 >= v55) {
        int v54 = *(a2 - 1);
      }
      *(a2 - 1) = v54;
      int v57 = a1[1];
      if (v57 <= v56) {
        int v58 = v56;
      }
      else {
        int v58 = a1[1];
      }
      if (v57 >= v56) {
        int v57 = v56;
      }
      a1[1] = v58;
      a1[2] = v57;
      return 1;
    case 5:
      int v27 = *a1;
      int v28 = a1[1];
      if (*a1 <= v28) {
        int v29 = a1[1];
      }
      else {
        int v29 = *a1;
      }
      if (v27 >= v28) {
        int v27 = a1[1];
      }
      *a1 = v29;
      a1[1] = v27;
      int v30 = a1[3];
      int v31 = *(a2 - 1);
      if (v30 <= v31) {
        int v32 = *(a2 - 1);
      }
      else {
        int v32 = a1[3];
      }
      if (v30 >= v31) {
        int v30 = *(a2 - 1);
      }
      *(a2 - 1) = v30;
      a1[3] = v32;
      int v33 = *(a2 - 1);
      int v34 = a1[2];
      if (v33 <= v34) {
        int v35 = a1[2];
      }
      else {
        int v35 = *(a2 - 1);
      }
      if (v33 >= v34) {
        int v33 = a1[2];
      }
      *(a2 - 1) = v33;
      int v37 = a1[2];
      int v36 = a1[3];
      int v38 = a1[1];
      if (v35 <= v36) {
        int v37 = a1[3];
      }
      if (v35 < v36) {
        int v36 = v35;
      }
      a1[2] = v37;
      a1[3] = v36;
      int v39 = *(a2 - 1);
      if (v38 <= v39) {
        int v40 = *(a2 - 1);
      }
      else {
        int v40 = v38;
      }
      if (v38 < v39) {
        int v39 = v38;
      }
      *(a2 - 1) = v39;
      int v41 = *a1;
      int v43 = a1[2];
      int v42 = a1[3];
      if (v42 <= *a1) {
        int v44 = *a1;
      }
      else {
        int v44 = a1[3];
      }
      if (v42 >= v41) {
        int v42 = *a1;
      }
      if (v44 <= v43) {
        int v41 = a1[2];
      }
      if (v44 < v43) {
        int v43 = v44;
      }
      if (v42 <= v40) {
        int v45 = v40;
      }
      else {
        int v45 = v42;
      }
      if (v42 >= v40) {
        int v42 = v40;
      }
      if (v45 <= v43) {
        int v40 = v43;
      }
      *a1 = v41;
      a1[1] = v40;
      if (v45 >= v43) {
        int v46 = v43;
      }
      else {
        int v46 = v45;
      }
      a1[2] = v46;
      a1[3] = v42;
      return 1;
    default:
      int v6 = a1 + 2;
      int v5 = a1[2];
      int v8 = *a1;
      int v7 = a1[1];
      if (v7 <= v5) {
        int v9 = a1[2];
      }
      else {
        int v9 = a1[1];
      }
      if (v7 < v5) {
        int v5 = a1[1];
      }
      if (v5 <= v8) {
        int v10 = *a1;
      }
      else {
        int v10 = v5;
      }
      if (v5 >= v8) {
        int v5 = *a1;
      }
      *int v6 = v5;
      if (v10 <= v9) {
        int v11 = v9;
      }
      else {
        int v11 = v8;
      }
      if (v10 >= v9) {
        int v10 = v9;
      }
      *a1 = v11;
      a1[1] = v10;
      uint64_t v12 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v13 = 0;
      uint64_t v14 = 12;
      break;
  }
  while (1)
  {
    int v15 = *v12;
    int v16 = *v6;
    if (*v12 > v16)
    {
      uint64_t v17 = v14;
      while (1)
      {
        *(_DWORD *)((char *)a1 + v17) = v16;
        uint64_t v18 = v17 - 4;
        if (v17 == 4) {
          break;
        }
        int v16 = *(_DWORD *)((char *)a1 + v17 - 8);
        v17 -= 4;
        if (v15 <= v16)
        {
          uint64_t v19 = (_DWORD *)((char *)a1 + v18);
          goto LABEL_27;
        }
      }
      uint64_t v19 = a1;
LABEL_27:
      _DWORD *v19 = v15;
      if (++v13 == 8) {
        return v12 + 1 == a2;
      }
    }
    int v6 = v12;
    v14 += 4;
    if (++v12 == a2) {
      return 1;
    }
  }
}

uint64_t vision::mod::ImageDescriptorBufferAbstract::deleteDescriptorAtIndex(vision::mod::ImageDescriptorBufferAbstract *this, int a2, uint64_t a3)
{
  uint64_t v4 = *((int *)this + 18);
  uint64_t v5 = v4 - 1;
  if ((int)v4 <= a2)
  {
    syslog(5, "ERROR: Can't delete descriptor with given index: %d (highest descriptor index in the buffer is %d)\n", a2, v4 - 1);
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3708;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if ((int)v5 > a2)
  {
    unint64_t DataForKthDescriptor = (void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, a2);
    int v9 = (const void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, (int)v5);
    memcpy(DataForKthDescriptor, v9, *((void *)this + 8));
    uint64_t v10 = *((void *)this + 1);
    if (v10 != *((void *)this + 2))
    {
      uint64_t v11 = *(void *)(v10 + 8 * a2);
      uint64_t v30 = *(void *)(v10 + 8 * (int)v5);
      uint64_t v12 = v30;
      uint64_t v31 = v11;
      *((_DWORD *)std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)this + 4, v11, &v31)+ 10) = v5;
      *((_DWORD *)std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)this + 4, v12, &v30)+ 10) = a2;
      uint64_t v13 = *((void *)this + 1);
      *(void *)(v13 + 8 * a2) = v12;
      *(void *)(v13 + 8 * (int)v5) = v11;
    }
    if (a3)
    {
      int v15 = *(int **)(a3 + 8);
      unint64_t v14 = *(void *)(a3 + 16);
      if ((unint64_t)v15 >= v14)
      {
        uint64_t v17 = *(int **)a3;
        uint64_t v18 = ((uint64_t)v15 - *(void *)a3) >> 2;
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 62) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v20 = v14 - (void)v17;
        if (v20 >> 1 > v19) {
          unint64_t v19 = v20 >> 1;
        }
        BOOL v21 = (unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL;
        unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v21) {
          unint64_t v22 = v19;
        }
        if (v22)
        {
          unint64_t v22 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v22);
          uint64_t v17 = *(int **)a3;
          int v15 = *(int **)(a3 + 8);
        }
        else
        {
          uint64_t v23 = 0;
        }
        int v24 = (int *)(v22 + 4 * v18);
        unint64_t v25 = v22 + 4 * v23;
        *int v24 = a2;
        int v16 = v24 + 1;
        while (v15 != v17)
        {
          int v26 = *--v15;
          *--int v24 = v26;
        }
        *(void *)a3 = v24;
        *(void *)(a3 + 8) = v16;
        *(void *)(a3 + 16) = v25;
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *int v15 = a2;
        int v16 = v15 + 1;
      }
      *(void *)(a3 + 8) = v16;
    }
  }
  uint64_t v27 = *((void *)this + 1);
  if (v27 != *((void *)this + 2))
  {
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__erase_unique<long long>((uint64_t **)this + 4, *(void *)(v27 + 8 * v5));
    *((void *)this + 2) -= 8;
  }
  --*((void *)this + 9);
  return 3712;
}

void std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__erase_unique<long long>(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 1);
  int v3 = a1[1];
  if (v3)
  {
    uint64_t v5 = v4;
    int v6 = v3;
    do
    {
      uint64_t v7 = v6[4];
      BOOL v8 = v7 < a2;
      if (v7 >= a2) {
        int v9 = (uint64_t **)v6;
      }
      else {
        int v9 = (uint64_t **)(v6 + 1);
      }
      if (!v8) {
        uint64_t v5 = v6;
      }
      int v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && v5[4] <= a2)
    {
      uint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v5;
        do
        {
          uint64_t v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if (*a1 == v5) {
        *a1 = v11;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v3, v5);
      operator delete(v5);
    }
  }
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      int v3 = a2;
      goto LABEL_7;
    }
    do
    {
      int v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  int v6 = (uint64_t **)v3[2];
  uint64_t v7 = *v6;
  if (*v6 == v3)
  {
    *int v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      uint64_t v7 = 0;
      __n128 result = (uint64_t *)v2;
    }
    else
    {
      uint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *int v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      __n128 result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 != v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v18 = v7[1];
      *(void *)uint64_t v12 = v18;
      if (v18) {
        *(void *)(v18 + 16) = v12;
      }
      v7[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(void *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12) {
        __n128 result = v7;
      }
      uint64_t v7 = *(uint64_t **)v12;
    }
    unint64_t v19 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v19 + 24)) {
      goto LABEL_68;
    }
    uint64_t v20 = (uint64_t *)v7[1];
    if (v20 && !*((unsigned char *)v20 + 24))
    {
      if (v19 && !*((unsigned char *)v19 + 24))
      {
LABEL_68:
        uint64_t v20 = v7;
      }
      else
      {
        *((unsigned char *)v20 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v26 = *v20;
        v7[1] = *v20;
        if (v26) {
          *(void *)(v26 + 16) = v7;
        }
        v20[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
        uint64_t *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        unint64_t v19 = v7;
      }
      uint64_t v23 = v20[2];
      *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v19 + 24) = 1;
      int v24 = *(uint64_t **)v23;
      uint64_t v27 = *(void *)(*(void *)v23 + 8);
      *(void *)uint64_t v23 = v27;
      if (v27) {
        *(void *)(v27 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
LABEL_49:
    uint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    BOOL v13 = *(uint64_t **)(v12 + 8);
    uint64_t v14 = *v13;
    *(void *)(v12 + 8) = *v13;
    if (v14) {
      *(void *)(v14 + 16) = v12;
    }
    _OWORD v13[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
    *BOOL v13 = v12;
    *(void *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7) {
      __n128 result = v7;
    }
    uint64_t v7 = *(uint64_t **)(*v7 + 8);
  }
  int v15 = (void *)*v7;
  if (!*v7 || *((unsigned char *)v15 + 24))
  {
    int v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_59;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  int v16 = (uint64_t *)v7[1];
  if (v16 && !*((unsigned char *)v16 + 24))
  {
LABEL_59:
    int v15 = v7;
  }
  else
  {
    *((unsigned char *)v15 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v22 = v15[1];
    *uint64_t v7 = v22;
    if (v22) {
      *(void *)(v22 + 16) = v7;
    }
    _OWORD v15[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    int v16 = v7;
  }
  uint64_t v23 = v15[2];
  *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v16 + 24) = 1;
  int v24 = *(uint64_t **)(v23 + 8);
  uint64_t v25 = *v24;
  *(void *)(v23 + 8) = *v24;
  if (v25) {
    *(void *)(v25 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  *int v24 = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t vision::mod::ImageDescriptorBufferAbstract::appendDescriptors(vision::mod::ImageDescriptorBufferAbstract *this, const vision::mod::ImageDescriptorBufferAbstract *a2)
{
  if (!*((void *)a2 + 9)) {
    return 3712;
  }
  uint64_t v4 = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)this + 104))(this);
  if (v4 != (*(uint64_t (**)(const vision::mod::ImageDescriptorBufferAbstract *))(*(void *)a2 + 104))(a2))
  {
    syslog(5, "ERROR: Descriptors lenghts don't match\n");
    return 3708;
  }
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = *((void *)this + 2);
  if (v5 != v6)
  {
    uint64_t v7 = *((void *)a2 + 1);
    uint64_t v8 = *((void *)a2 + 2);
    if (v7 == v8 && *((void *)a2 + 9) != 0) {
      goto LABEL_14;
    }
    uint64_t v10 = (v6 - v5) >> 3;
    if (v10 != *((void *)this + 9))
    {
      syslog(5, "ERROR: Descriptor ids values count does not match the descriptors count in the base buffer\n");
      return 3708;
    }
    goto LABEL_16;
  }
  uint64_t v10 = *((void *)this + 9);
  uint64_t v7 = *((void *)a2 + 1);
  uint64_t v8 = *((void *)a2 + 2);
  if (!v10)
  {
LABEL_16:
    uint64_t v12 = (void **)((char *)a2 + 8);
    BOOL v13 = (char *)a2 + 16;
    uint64_t v14 = *((void *)a2 + 9);
    if (v7 != v8 && v14 != (v8 - v7) >> 3)
    {
      syslog(5, "ERROR: Descriptor ids values count does not match the descriptors count in the appended buffer\n");
      return 3708;
    }
    goto LABEL_20;
  }
  if (v7 != v8)
  {
LABEL_14:
    syslog(5, "ERROR: Both descriptor buffers have to either contain descriptor ids values or not\n");
    return 3708;
  }
  uint64_t v12 = (void **)((char *)a2 + 8);
  BOOL v13 = (char *)a2 + 16;
  uint64_t v14 = *((void *)a2 + 9);
LABEL_20:
  if (*((void *)this + 6) && *((void *)a2 + 6) && (int)v14 >= 1)
  {
    uint64_t v15 = 0;
    while (1)
    {
      if (*((void *)this + 5))
      {
        uint64_t v16 = *(void *)(v7 + 8 * v15);
        uint64_t v17 = (void *)((char *)this + 40);
        uint64_t v18 = (void *)*((void *)this + 5);
        do
        {
          uint64_t v19 = v18[4];
          BOOL v20 = v19 < v16;
          if (v19 >= v16) {
            BOOL v21 = v18;
          }
          else {
            BOOL v21 = v18 + 1;
          }
          if (!v20) {
            uint64_t v17 = v18;
          }
          uint64_t v18 = (void *)*v21;
        }
        while (*v21);
        if (v17 != (void *)((char *)this + 40) && v16 >= v17[4]) {
          break;
        }
      }
      if (++v15 == v14) {
        goto LABEL_35;
      }
    }
    syslog(5, "ERROR: One of the descriptor ids from the appended descriptor buffer already exists in the base descriptor buffer (id: %lld).\n");
    return 3708;
  }
LABEL_35:
  int v29 = (void **)v13;
  vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(this, (int)v14 + (int)v10, 1);
  int v30 = v14;
  if ((int)v14 >= 1)
  {
    unint64_t v22 = 0;
    do
    {
      unint64_t DataForKthDescriptor = (void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, (int)v10 + v22);
      int v24 = (const void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, v22);
      size_t v25 = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)this + 104))(this);
      memcpy(DataForKthDescriptor, v24, v25);
      ++v22;
    }
    while (v30 != v22);
  }
  if (*v12 == *v29) {
    return 3712;
  }
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<long long const*>,std::__wrap_iter<long long const*>,std::back_insert_iterator<std::vector<long long>>,0>(*v12, *v29, (uint64_t)this + 8);
  if (v30 < 1) {
    return 3712;
  }
  uint64_t v26 = 0;
  uint64_t v27 = (uint64_t **)((char *)this + 32);
  uint64_t v11 = 3712;
  do
  {
    *((_DWORD *)std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v27, (*v12)[v26], &(*v12)[v26])+ 10) = v10;
    ++v26;
    LODWORD(v10) = v10 + 1;
  }
  while (v30 != v26);
  return v11;
}

void *vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(vision::mod::ImageDescriptorBufferAbstract *this, unint64_t a2, char a3)
{
  if (!(*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)this + 104))(this))
  {
    syslog(5, "ERROR: the resizeForDescriptorsCount method is probably called without ever initializing the descriptor buffer");
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v13 = 3710;
    goto LABEL_21;
  }
  if (*((void *)this + 10) < a2
    || (__n128 result = (void *)(*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)this
                                                                                                 + 104))(this),
        (unint64_t)result > *((void *)this + 8)))
  {
    unint64_t v7 = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)this + 104))(this);
    unint64_t v8 = *((void *)this + 8);
    if (v7 <= v8)
    {
      uint64_t v9 = (void *)*((void *)this + 7);
      if (v9 && (a3 & 1) != 0)
      {
        if (!*((unsigned char *)this + 88))
        {
          uint64_t v11 = malloc_type_malloc(v8 * a2, 0x5E85D5D3uLL);
          *((void *)this + 7) = v11;
          if (v11)
          {
            __n128 result = memcpy(v11, v9, *((void *)this + 9) * *((void *)this + 8));
            goto LABEL_15;
          }
          goto LABEL_20;
        }
        __n128 result = malloc_type_realloc(*((void **)this + 7), v8 * a2, 0xCA55EE79uLL);
LABEL_14:
        *((void *)this + 7) = result;
        if (result)
        {
LABEL_15:
          *((void *)this + 9) = a2;
          *((void *)this + 10) = a2;
          *((unsigned char *)this + 88) = 1;
          return result;
        }
LABEL_20:
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v13 = 3707;
LABEL_21:
        void *exception = v13;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
    }
    else
    {
      *((void *)this + 8) = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)this + 104))(this);
      uint64_t v9 = (void *)*((void *)this + 7);
    }
    if (v9)
    {
      if (*((unsigned char *)this + 88)) {
        free(v9);
      }
    }
    uint64_t v10 = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)this + 104))(this);
    *((void *)this + 8) = v10;
    __n128 result = malloc_type_malloc(v10 * a2, 0x7F8ABCBBuLL);
    goto LABEL_14;
  }
  *((void *)this + 9) = a2;
  return result;
}

uint64_t vision::mod::ImageDescriptorBufferAbstract::createDeepCopyOfSubset(vision::mod::ImageDescriptorBufferAbstract *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8) - *(void *)a2;
  size_t v5 = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)a1 + 104))(a1);
  uint64_t v6 = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)a1 + 16))(a1);
  *(unsigned char *)(v6 + 88) = 1;
  *(void *)(v6 + 64) = *((void *)a1 + 8);
  *(void *)(v6 + 72) = v4 >> 3;
  *(void *)(v6 + 56) = malloc_type_malloc(*((void *)a1 + 8) * (v4 >> 3), 0x87EFF8CDuLL);
  *(void *)(v6 + 80) = v4 >> 3;
  if (v6 + 8 != a2) {
    std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>((char *)(v6 + 8), *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  }
  if ((int)((unint64_t)v4 >> 3) >= 1)
  {
    uint64_t v7 = 0;
    unint64_t v8 = (void *)((char *)a1 + 40);
    uint64_t v9 = *(char **)(v6 + 56);
    uint64_t v10 = ((unint64_t)v4 >> 3);
    while (1)
    {
      uint64_t v11 = (void *)*v8;
      if (!*v8) {
        break;
      }
      uint64_t v12 = *(void *)(*(void *)a2 + 8 * v7);
      uint64_t v13 = (void *)((char *)a1 + 40);
      do
      {
        uint64_t v14 = v11[4];
        BOOL v15 = v14 < v12;
        if (v14 >= v12) {
          uint64_t v16 = v11;
        }
        else {
          uint64_t v16 = v11 + 1;
        }
        if (!v15) {
          uint64_t v13 = v11;
        }
        uint64_t v11 = (void *)*v16;
      }
      while (*v16);
      if (v13 == v8 || v12 < v13[4]) {
        break;
      }
      unint64_t DataForKthDescriptor = (const void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a1, *((int *)v13 + 10));
      memcpy(v9, DataForKthDescriptor, v5);
      *((_DWORD *)std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(v6 + 32), *(void *)(*(void *)a2 + 8 * v7), (void *)(*(void *)a2 + 8 * v7))+ 10) = v7;
      ++v7;
      v9 += *((void *)a1 + 8);
      if (v7 == v10) {
        return v6;
      }
    }
    if (v6)
    {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
      return 0;
    }
  }
  return v6;
}

char *std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<long long>::__vallocate[abi:ne180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

void vision::mod::ImageDescriptorBufferAbstract::createEmptyCopy(vision::mod::ImageDescriptorBufferAbstract *this)
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = 3711;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

uint64_t vision::mod::ImageDescriptorBufferAbstract::initBufferWithData(vision::mod::ImageDescriptorBufferAbstract *this, void *a2, uint64_t a3, uint64_t a4, char a5)
{
  if (!a2) {
    return 3709;
  }
  uint64_t v10 = (char *)this + 40;
  uint64_t v9 = (void *)*((void *)this + 5);
  *((void *)v10 - 3) = *((void *)v10 - 4);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v9);
  *((void *)v10 - 1) = v10;
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = a2;
  *((void *)v10 + 3) = a3;
  *((void *)v10 + 4) = a4;
  *((void *)v10 + 5) = a4;
  uint64_t result = 3712;
  v10[48] = a5;
  return result;
}

vision::mod::ImageDescriptorBufferAbstract *vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract(vision::mod::ImageDescriptorBufferAbstract *this, void *a2, uint64_t a3, uint64_t a4, char a5)
{
  *((void *)this + 1) = 0;
  *(void *)this = &unk_1EF752B68;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((unsigned char *)this + 88) = a5;
  uint64_t inited = vision::mod::ImageDescriptorBufferAbstract::initBufferWithData(this, a2, a3, a4, a5);
  if ((inited & 0x80) == 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = inited;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  return this;
}

void sub_1A3E5E270(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*v3);
  size_t v5 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract(uint64_t a1, void **a2, void *a3, uint64_t a4, uint64_t a5, char a6)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = a1 + 8;
  *(void *)a1 = &unk_1EF752B68;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v9 = a1 + 40;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = a1 + 40;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(unsigned char *)(a1 + 88) = a6;
  uint64_t inited = vision::mod::ImageDescriptorBufferAbstract::initBufferWithData((vision::mod::ImageDescriptorBufferAbstract *)a1, a3, a4, a5, a6);
  if ((inited & 0x80) == 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = inited;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if (*(void *)(a1 + 72) == a2[1] - *a2)
  {
    *(void *)(a1 + 16) = *(void *)(a1 + 8);
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(void **)(a1 + 40));
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 32) = v9;
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<long long const*>,std::__wrap_iter<long long const*>,std::back_insert_iterator<std::vector<long long>>,0>(*a2, a2[1], v8);
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(&v23, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v26 = (uint64_t *)&v27;
    unint64_t v11 = v23;
    if ((int)((unint64_t)(v24 - (void)v23) >> 3) >= 1)
    {
      uint64_t v12 = 0;
      if ((int)((v24 - (uint64_t)v23) >> 3) <= 1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = (int)((v24 - (uint64_t)v23) >> 3);
      }
      uint64_t v14 = (uint64_t *)v23;
      do
      {
        *((_DWORD *)std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v26, *v14, v14)+ 10) = v12++;
        ++v14;
      }
      while (v13 != v12);
    }
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(void **)(a1 + 40));
    unint64_t v15 = v27;
    *(void *)(a1 + 32) = v26;
    *(void *)(a1 + 40) = v15;
    uint64_t v16 = v28;
    *(void *)(a1 + 48) = v28;
    if (v16)
    {
      _OWORD v15[2] = v9;
      uint64_t v26 = (uint64_t *)&v27;
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v15 = 0;
    }
    else
    {
      *(void *)(a1 + 32) = v9;
    }
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v15);
    if (v11) {
      operator delete(v11);
    }
    size_t v17 = &CVML_status_ok;
  }
  else
  {
    syslog(5, "ERROR: the number of descriptor ids should match the number of descriptors in the buffer");
    size_t v17 = &CVML_status_invalidParameter;
  }
  uint64_t v18 = *v17 + 128;
  if ((v18 & 0x80) == 0)
  {
    uint64_t v21 = v18 | 0xE00;
    unint64_t v22 = __cxa_allocate_exception(8uLL);
    void *v22 = v21;
    __cxa_throw(v22, MEMORY[0x1E4FBA3E0], 0);
  }
  return a1;
}

void sub_1A3E5E4A8(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*v3);
  size_t v5 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

vision::mod::ImageDescriptorBufferAbstract *vision::mod::ImageDescriptorBufferAbstract::setDescriptorIdForKthDescriptor(vision::mod::ImageDescriptorBufferAbstract *this, int a2, uint64_t a3)
{
  uint64_t v10 = a3;
  uint64_t v3 = *((void *)this + 1);
  if (v3 == *((void *)this + 2))
  {
    syslog(5, "ERROR: Can't set descriptor id - ids vector is empty\n");
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3708;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t v7 = (uint64_t **)((char *)this + 32);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__erase_unique<long long>((uint64_t **)this + 4, *(void *)(v3 + 8 * a2));
  *(void *)(*((void *)this + 1) + 8 * a2) = a3;
  *((_DWORD *)std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v7, a3, &v10)+ 10) = a2;
  return this;
}

uint64_t vision::mod::ObjectTrackerCorrelation::free(void **this)
{
  this[4] = 0;
  return 6784;
}

uint64_t vision::mod::ObjectTrackerCorrelation::init(vision::mod::ObjectTrackerCorrelation *this)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x28uLL, 0x20040769AC3DAuLL);
  if (v2)
  {
    uint64_t v3 = malloc_type_calloc(1uLL, 0x10uLL, 0x10000407D226C2BuLL);
    v2[1] = v3;
    if (v3)
    {
      uint64_t v4 = malloc_type_calloc(1uLL, 0x860uLL, 0x1080040EFF975D0uLL);
      *uint64_t v2 = v4;
      if (v4)
      {
        uint64_t v5 = 2048;
        while (1)
        {
          uint64_t v6 = malloc_type_malloc(0x8000uLL, 0x74D116ECuLL);
          *(void *)(*v2 + v5) = v6;
          if (!v6) {
            break;
          }
          uint64_t v7 = malloc_type_malloc(0x8000uLL, 0x2F550853uLL);
          *(void *)(*v2 + v5 + 8) = v7;
          if (!v7) {
            break;
          }
          v5 += 16;
          if (v5 == 2112)
          {
            uint64_t v8 = malloc_type_malloc(0x8000uLL, 0x2629E526uLL);
            *(void *)(*v2 + 2112) = v8;
            if (v8)
            {
              uint64_t v9 = malloc_type_malloc(0x8000uLL, 0xEE41DED4uLL);
              uint64_t v10 = (void *)*v2;
              *(void *)(*v2 + 2120) = v9;
              if (v9)
              {
                bzero(v10, 0x400uLL);
                bzero((void *)(*v2 + 1024), 0x400uLL);
                unint64_t v11 = malloc_type_calloc(1uLL, 0x3D160uLL, 0x10A004026F24330uLL);
                v2[2] = v11;
                if (v11)
                {
                  bzero(v11, 0x4000uLL);
                  bzero((void *)(v2[2] + 0x4000), 0x4000uLL);
                  bzero((void *)(v2[2] + 0x8000), 0x4000uLL);
                  bzero((void *)(v2[2] + 49152), 0x4000uLL);
                  bzero((void *)(v2[2] + 0x10000), 0x4000uLL);
                  bzero((void *)(v2[2] + 81920), 0x4000uLL);
                  bzero((void *)(v2[2] + 98304), 0x4000uLL);
                  bzero((void *)(v2[2] + 246072), 0x400uLL);
                  bzero((void *)(v2[2] + 247096), 0x400uLL);
                  bzero((void *)(v2[2] + 248120), 0x400uLL);
                  bzero((void *)(v2[2] + 249144), 0x400uLL);
                  uint64_t v12 = 0;
                  char v13 = 1;
                  while (1)
                  {
                    char v14 = v13;
                    unint64_t v15 = malloc_type_malloc(0x8000uLL, 0x8B3C3602uLL);
                    *(void *)(v2[2] + 16 * v12 + 245992) = v15;
                    if (!v15) {
                      break;
                    }
                    uint64_t v16 = malloc_type_malloc(0x8000uLL, 0xEBAA786BuLL);
                    *(void *)(v2[2] + 16 * v12 + 246000) = v16;
                    if (!v16) {
                      break;
                    }
                    char v13 = 0;
                    uint64_t v12 = 1;
                    if ((v14 & 1) == 0)
                    {
                      uint64_t v17 = 4;
                      uint64_t v18 = 245936;
                      while (1)
                      {
                        uint64_t v19 = malloc_type_malloc(0x8000uLL, 0xF64943F3uLL);
                        *(void *)(v2[2] + v18 - 8) = v19;
                        if (!v19) {
                          goto LABEL_41;
                        }
                        BOOL v20 = malloc_type_malloc(0x8000uLL, 0xA0BFFFF5uLL);
                        *(void *)(v2[2] + v18) = v20;
                        if (!v20) {
                          goto LABEL_41;
                        }
                        v18 += 16;
                        if (!--v17)
                        {
                          uint64_t v21 = 246032;
                          uint64_t v22 = 3;
                          while (1)
                          {
                            uint64_t v23 = malloc_type_calloc(0x40uLL, 4uLL, 0x100004052888210uLL);
                            *(void *)(v2[2] + v21 - 8) = v23;
                            if (!v23) {
                              goto LABEL_41;
                            }
                            uint64_t v24 = malloc_type_calloc(0x40uLL, 4uLL, 0x100004052888210uLL);
                            uint64_t v25 = v2[2];
                            *(void *)(v25 + v21) = v24;
                            if (!v24) {
                              goto LABEL_41;
                            }
                            v21 += 16;
                            if (!--v22)
                            {
                              *(_DWORD *)(v25 + 250184) = 0;
                              *(void *)(v2[2] + 250200) = vDSP_create_fftsetup(7uLL, 0);
                              v2[3] = tplTrackerResampler_alloc(128, 128);
                              uint64_t v26 = malloc_type_calloc(1uLL, 0x10070uLL, 0x10C0040E2B89275uLL);
                              v2[4] = v26;
                              if (v26)
                              {
                                uint64_t v27 = v26;
                                unint64_t v28 = -10;
                                int v29 = v26;
                                do
                                {
                                  if (v28 >= 0xFFFFFFFFFFFFFFF6)
                                  {
                                    float v46 = expf((float)(((int)v28 + 1) * ((int)v28 + 1)) / -30.0);
                                    *(float *)&uint64_t v30 = expf((float)((int)v28 * (int)v28) / -30.0);
                                    *((float *)&v30 + 1) = v46;
                                    *int v29 = v30;
                                  }
                                  ++v29;
                                  v28 += 2;
                                }
                                while (v28);
                                unint64_t v31 = 0;
                                *((_DWORD *)v27 + 10) = 1065353216;
                                int v32 = (void *)((char *)v27 + 44);
                                do
                                {
                                  unint64_t v33 = v31 + 2;
                                  if (v31 <= 9)
                                  {
                                    float v34 = (float)(((int)v31 + 1) * ((int)v31 + 1)) / -26.0;
                                    float v47 = expf((float)((int)v33 * (int)v33) / -26.0);
                                    *(float *)&uint64_t v35 = expf(v34);
                                    *((float *)&v35 + 1) = v47;
                                    *int v32 = v35;
                                  }
                                  ++v32;
                                  unint64_t v31 = v33;
                                }
                                while (v33 != 10);
                                uint64_t v36 = 0;
                                int64x2_t v37 = (int64x2_t)xmmword_1A4104940;
                                uint64x2_t v38 = (uint64x2_t)vdupq_n_s64(0x4001uLL);
                                int64x2_t v39 = vdupq_n_s64(2uLL);
                                do
                                {
                                  v40.i32[0] = v36 * 2;
                                  v40.i32[1] = v36 * 2 + 1;
                                  float32x2_t v41 = vsqrt_f32(vcvt_f32_s32(v40));
                                  if (vmovn_s64((int64x2_t)vcgtq_u64(v38, (uint64x2_t)v37)).u8[0]) {
                                    HIDWORD(v27[v36 + 10]) = v41.i32[0];
                                  }
                                  if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x4001uLL), *(uint64x2_t *)&v37)).i32[1])LODWORD(v27[v36 + 11]) = v41.i32[1]; {
                                  ++v36;
                                  }
                                  int64x2_t v37 = vaddq_s64(v37, v39);
                                }
                                while (v36 != 8193);
                                int v42 = malloc_type_malloc(0x8000uLL, 0x46BCD33EuLL);
                                *(void *)(v2[4] + 65632) = v42;
                                if (v42)
                                {
                                  int v43 = malloc_type_malloc(0x8000uLL, 0x7EA5B9DCuLL);
                                  int v44 = (void *)(v2[4] + 65624);
                                  *(void *)(v2[4] + 65640) = v43;
                                  if (v43)
                                  {
                                    *int v44 = &cosineWindow;
                                    goto LABEL_42;
                                  }
                                }
                              }
                              goto LABEL_41;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            break;
          }
        }
      }
    }
  }
LABEL_41:
  ctrTrackerInitialization_freeContext(v2);
  uint64_t v2 = 0;
LABEL_42:
  *((void *)this + 4) = v2;
  if (v2) {
    return 6784;
  }
  else {
    return 6751;
  }
}

uint64_t vision::mod::ObjectTrackerCorrelation::update(uint64_t a1, CVPixelBufferRef pixelBuffer, int32x2_t **a3)
{
  uint64_t v3 = *(uint64_t **)(a1 + 32);
  if (!v3) {
    return 6751;
  }
  uint64_t v4 = *a3;
  if ((char *)a3[1] - (char *)*a3 != 80) {
    return 6780;
  }
  float32x2_t v5 = (float32x2_t)v4[3];
  float64x2_t v6 = vcvtq_f64_f32(v5);
  float64x2_t v7 = vcvtq_f64_f32(vadd_f32(v5, (float32x2_t)vrev64_s32(v4[4])));
  __int32 v9 = v4[7].i32[1];
  uint64_t result = ctrTrackerComputation_updateHistory(pixelBuffer, v3, *(unsigned char *)(a1 + 104), (float *)&v9, v6, v7);
  if (result == 128) {
    return 6784;
  }
  return result;
}

uint64_t vision::mod::ObjectTrackerCorrelation::track(uint64_t a1, __CVBuffer *a2, uint64_t *a3)
{
  uint64_t v129 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(const DSPSplitComplex ***)(a1 + 32);
  if (!v3) {
    return 6751;
  }
  float64x2_t v7 = (float64x2_t *)(a1 + 40);
  float64x2_t v8 = *(float64x2_t *)(a1 + 40);
  float v123 = 0.0;
  float64x2_t v9 = *(float64x2_t *)(a1 + 72);
  float64x2_t v10 = vsubq_f64(v9, v8);
  __asm { FMOV            V3.2D, #0.5 }
  float64x2_t v16 = vmulq_f64(vaddq_f64(v9, v8), _Q3);
  float64x2_t v17 = vmulq_f64(vmulq_f64(v10, (float64x2_t)vdupq_n_s64(0x40047AE140000000uLL)), _Q3);
  *(float64x2_t *)__p = vsubq_f64(v16, v17);
  int v125 = __p[0];
  float64x2_t v117 = _Q3;
  float64x2_t v118 = vaddq_f64(v16, v17);
  int8x16_t v126 = vextq_s8((int8x16_t)v118, (int8x16_t)v118, 8uLL);
  int8x16_t v127 = v126;
  *(_OWORD *)__Setup = *(_OWORD *)__p;
  float v128 = __p[1];
  uint64_t v18 = v3[2];
  uint64_t updated = tplTrackerResampler_setImage((uint64_t)v3[3], a2, (double *)__p);
  uint64_t v20 = updated;
  float v21 = 0.0;
  if (updated != 128) {
    goto LABEL_61;
  }
  p_imagp = (int *)&v18[15635].imagp;
  float64x2_t v23 = vsubq_f64(v118, *(float64x2_t *)__Setup);
  float64_t v24 = v23.f64[0] / 127.0;
  *(float *)v23.f64 = v23.f64[1] / 127.0;
  float v25 = v24;
  tplTrackerResampler_resample((uint64_t)v3[3], (double *)__p, 0x80u, 128, (uint64_t)v3[2], &v3[2][1024], &v3[2][2048], p_imagp, *(float *)v23.f64, v25);
  if (*p_imagp > 0 || p_imagp[1] > 0 || p_imagp[2] < 127 || p_imagp[3] <= 126) {
    ctrTrackerComputation_repairNonValidRegion((uint64_t)v3[2], (uint64_t)&v3[2][1024], (uint64_t)&v3[2][2048], p_imagp);
  }
  ctrTrackerComputation_YCbCr2nRGB((uint64_t)v3[2], (uint64_t)&v3[2][1024], (uint64_t)&v3[2][2048], (uint64_t)&v3[2][3072], (uint64_t)&v3[2][4096], (uint64_t)&v3[2][5120]);
  ctrTrackerComputation_normedGradient((uint64_t)&v3[2][3072], (uint64_t)&v3[2][4096], (uint64_t)&v3[2][5120], (uint64_t)&v3[2][6144]);
  uint64_t v26 = v3[2];
  uint64_t v27 = ctrTrackerAlgorithm_computeFFTx((uint64_t)&v26[3072], (uint64_t)&v26[4096], (uint64_t)&v26[5120], (uint64_t)&v26[6144], (uint64_t)v3[4][4101].imagp, (DSPComplex *)&v26[7178].imagp, (DSPSplitComplex *)&v26[15370].imagp, (OpaqueFFTSetup *)v26[15637].imagp);
  uint64_t v20 = v27;
  if (v27 != 128
    || (unint64_t v28 = v3[2],
        uint64_t v27 = ctrTrackerAlgorithm_GaussianCorrelation((uint64_t)&v28[15370].imagp, (uint64_t)&(*v3)[128], (DSPSplitComplex *)&v28[15374].imagp, (const DSPSplitComplex *)((char *)v28 + 246024), (DSPComplex *)&v28[7178].imagp, (char *)&v28[11274].imagp, (OpaqueFFTSetup *)v28[15637].imagp), v20 = v27, v27 != 128))
  {
    uint64_t updated = v27;
LABEL_61:
    int v56 = 0;
    goto LABEL_62;
  }
  int v29 = v3[2];
  uint64_t v30 = &v29[15374].imagp;
  unint64_t v31 = *v3;
  __Setupa = (OpaqueFFTSetup *)v29[15637].imagp;
  vDSP_zvcmul((const DSPSplitComplex *)((char *)v29 + 245992), 1, *v3 + 132, 1, (const DSPSplitComplex *)((char *)v29 + 246008), 1, 0x2000uLL);
  uint64_t v32 = 0;
  imagp = v29[15375].imagp;
  realp = v29[15376].realp;
  do
  {
    imagp[v32] = imagp[v32] * 0.5;
    realp[v32] = realp[v32] * 0.5;
    ++v32;
  }
  while (v32 != 0x2000);
  unint64_t v35 = 0;
  uint64_t v36 = v31[132].realp;
  int64x2_t v37 = *v30;
  float *imagp = (float)(*v36 * **v30) * 0.5;
  uint64x2_t v38 = v31[132].imagp;
  int64x2_t v39 = v29[15375].realp;
  float *realp = (float)(*v38 * *v39) * 0.5;
  imagp[64] = (float)(v36[64] * v37[64]) * 0.5;
  float v40 = v38[64] * v39[64];
  float32x2_t v41 = v36 + 192;
  int v42 = v38 + 192;
  realp[64] = v40 * 0.5;
  int v43 = v37 + 192;
  int v44 = v39 + 192;
  int v45 = imagp + 192;
  float v46 = realp + 192;
  do
  {
    float v47 = *(v41 - 64);
    float v48 = *(v42 - 64);
    float v49 = *v41;
    float v50 = *v42;
    float v51 = *(v43 - 64);
    float v52 = *(v44 - 64);
    float v53 = *v43;
    float v54 = *v44;
    *(v45 - 64) = (float)((float)(v47 * v51) - (float)(*v41 * *v43)) * 0.5;
    *(v46 - 64) = (float)((float)(v48 * v52) - (float)(v50 * v54)) * 0.5;
    *int v45 = (float)((float)(v49 * v51) + (float)(v47 * v53)) * 0.5;
    v35 += 2;
    v41 += 128;
    v42 += 128;
    v43 += 128;
    *float v46 = (float)((float)(v50 * v52) + (float)(v48 * v54)) * 0.5;
    v44 += 128;
    v45 += 128;
    v46 += 128;
  }
  while (v35 < 0x7E);
  vDSP_fft2d_zrip(__Setupa, (const DSPSplitComplex *)((char *)v29 + 246008), 1, 0, 7uLL, 7uLL, -1);
  vDSP_ztoc((const DSPSplitComplex *)((char *)v29 + 246008), 1, (DSPComplex *)&v29[11274].imagp, 2, 0x2000uLL);
  int v55 = (int *)malloc_type_malloc(0xCuLL, 0x10000403E1C8BA9uLL);
  if (!v55) {
    return 6779;
  }
  int v56 = v55;
  uint64_t v57 = 0;
  int v58 = 0;
  int v59 = (DSPSplitComplex *)v3[1];
  uint64_t v60 = (uint64_t)&v3[2][11274].imagp;
  float v61 = 0.0;
  do
  {
    if (*(float *)(v60 + 4 * v57) > v61)
    {
      int v58 = v57;
      float v61 = *(float *)(v60 + 4 * v57);
    }
    ++v57;
  }
  while (v57 != 0x4000);
  unint64_t v62 = 0;
  *(float *)int v55 = v61;
  if (v58 >= 0) {
    int v63 = v58;
  }
  else {
    int v63 = v58 + 127;
  }
  int v64 = v58 - (v63 & 0xFFFFFF80);
  v55[1] = v63 >> 7;
  v55[2] = v64;
  if (v58 >= 8832) {
    int v65 = -128;
  }
  else {
    int v65 = 0;
  }
  int v66 = v65 + (v63 >> 7) - 5;
  if (v58 >= 7552) {
    int v67 = -128;
  }
  else {
    int v67 = 0;
  }
  int v68 = v67 + (v63 >> 7) + 5;
  if (v64 >= 69) {
    int v69 = -128;
  }
  else {
    int v69 = 0;
  }
  int v70 = v64 + v69 - 5;
  if (v64 >= 59) {
    int v71 = -128;
  }
  else {
    int v71 = 0;
  }
  int v72 = v64 + v71 + 5;
  float v73 = 0.0;
  float v74 = 0.0;
  do
  {
    unint64_t v75 = 0;
    if (v62 >= 0x40) {
      int v76 = -128;
    }
    else {
      int v76 = 0;
    }
    int v77 = v76 + v62;
    BOOL v79 = v77 < v66 || v77 > v68;
    do
    {
      if (v79
        || (v75 >= 0x40 ? (int v80 = -128) : (int v80 = 0), (v81 = v75 + v80, v81 >= v70) ? (v82 = v81 <= v72) : (v82 = 0), !v82))
      {
        float v83 = *(float *)(v60 + 4 * v75);
        float v74 = v74 + v83;
        float v73 = v73 + (float)(v83 * v83);
      }
      ++v75;
    }
    while (v75 != 128);
    ++v62;
    v60 += 512;
  }
  while (v62 != 128);
  float v84 = v74 / 16263.0;
  float v85 = sqrtf((float)(v73 / 16263.0) - (float)(v84 * v84));
  if (v85 == 0.0)
  {
    float v86 = 0.0;
    if (!LOBYTE(v59->imagp))
    {
LABEL_75:
      HIDWORD(v59->imagp) = 1098907648;
      float v21 = v86 * 0.0625;
      *(float *)&v59->realp = v86 * 0.0625;
      LOBYTE(v59->imagp) = 1;
      goto LABEL_76;
    }
  }
  else
  {
    float v86 = (float)(v61 - v84) / v85;
    if (!LOBYTE(v59->imagp))
    {
      if (v86 >= 8.0)
      {
        *((float *)&v59->imagp + 1) = v86;
        LODWORD(v59->realp) = 1065353216;
        LOBYTE(v59->imagp) = 1;
        float v87 = 1.0;
LABEL_78:
        HIDWORD(v59->realp) = 0;
        *(unsigned char *)(a1 + 104) = 1;
        float v123 = v87;
        float v21 = v87;
        goto LABEL_79;
      }
      goto LABEL_75;
    }
  }
  float v21 = v86 / *((float *)&v59->imagp + 1);
  *(float *)&v59->realp = v21;
  float v87 = 1.0;
  if (v21 > 1.0)
  {
    LODWORD(v59->realp) = 1065353216;
    goto LABEL_78;
  }
LABEL_76:
  if (v21 > 0.2)
  {
    float v87 = v21;
    goto LABEL_78;
  }
  int realp_high = HIDWORD(v59->realp);
  HIDWORD(v59->realp) = realp_high + 1;
  *(unsigned char *)(a1 + 104) = 0;
  float v123 = v21;
  if (realp_high >= 30) {
    *(unsigned char *)(a1 + 105) = 1;
  }
LABEL_79:
  size_t Width = CVPixelBufferGetWidth(a2);
  size_t Height = CVPixelBufferGetHeight(a2);
  double v97 = *(double *)(a1 + 40);
  double v98 = *(double *)(a1 + 48);
  double v99 = 0.0;
  if (v97 >= 0.0) {
    double v100 = *(double *)(a1 + 40);
  }
  else {
    double v100 = 0.0;
  }
  double v101 = (double)Width;
  float v102 = v100;
  double v103 = *(double *)(a1 + 72);
  double v104 = *(double *)(a1 + 80);
  if (v103 < (double)Width) {
    double v101 = *(double *)(a1 + 72);
  }
  float v105 = v101;
  if (v98 >= 0.0) {
    double v99 = *(double *)(a1 + 48);
  }
  float v106 = v99;
  double v107 = (double)Height;
  if (v104 < (double)Height) {
    double v107 = *(double *)(a1 + 80);
  }
  float v108 = v107;
  if ((v103 - v97) * 0.5 * (v104 - v98) >= (float)((float)(v105 - v102) * (float)(v108 - v106)))
  {
    if (*(unsigned char *)(a1 + 104)) {
      ctrTrackerComputation_updateLocation((uint64_t)&v3[2][11274].imagp, (uint64_t)v7, v56[1], v56[2], *(double *)&(*v3)[133].realp, *(double *)&(*v3)[133].imagp);
    }
    goto LABEL_94;
  }
  ctrTrackerComputation_updateLocation((uint64_t)&v3[2][11274].imagp, (uint64_t)v7, v56[1], v56[2], *(double *)&(*v3)[133].realp, *(double *)&(*v3)[133].imagp);
  if (*(unsigned char *)(a1 + 104))
  {
    float64x2_t v109 = *(float64x2_t *)(a1 + 72);
    float64x2_t v110 = *(float64x2_t *)(a1 + 40);
    float64x2_t v111 = vsubq_f64(v109, v110);
    float64x2_t v112 = vmulq_f64(vaddq_f64(v109, v110), v117);
    float64x2_t v113 = vmulq_f64(vmulq_f64(v111, (float64x2_t)vdupq_n_s64(0x3FF3333340000000uLL)), v117);
    *(float64x2_t *)__p = vsubq_f64(v112, v113);
    int v125 = __p[0];
    float64x2_t v119 = vaddq_f64(v112, v113);
    *(_OWORD *)__Setupb = *(_OWORD *)__p;
    int8x16_t v126 = vextq_s8((int8x16_t)v119, (int8x16_t)v119, 8uLL);
    int8x16_t v127 = v126;
    float v128 = __p[1];
    uint64_t updated = tplTrackerResampler_setImage((uint64_t)v3[3], a2, (double *)__p);
    uint64_t v20 = updated;
    if (updated == 128)
    {
      float64x2_t v114 = vsubq_f64(v119, *(float64x2_t *)__Setupb);
      float64_t v115 = v114.f64[0] / 127.0;
      *(float *)v114.f64 = v114.f64[1] / 127.0;
      *(float *)&float64_t v115 = v115;
      tplTrackerResampler_resample((uint64_t)v3[3], (double *)__p, 0x80u, 128, (uint64_t)v3[2], &v3[2][1024], &v3[2][2048], p_imagp, *(float *)v114.f64, *(float *)&v115);
      ctrTrackerComputation_YCbCr2nRGB((uint64_t)v3[2], (uint64_t)&v3[2][1024], (uint64_t)&v3[2][2048], (uint64_t)&v3[2][3072], (uint64_t)&v3[2][4096], (uint64_t)&v3[2][5120]);
      ctrTrackerComputation_sizeAdaption((uint64_t)v3[2], (float64x2_t *)*v3, (float *)v3[4], (uint64_t)&v3[4][5].realp + 4, v7);
      goto LABEL_94;
    }
LABEL_62:
    free(v56);
    if (v20 != 128) {
      return updated;
    }
    goto LABEL_63;
  }
LABEL_94:
  free(v56);
LABEL_63:
  uint64_t updated = ctrTrackerComputation_updateHistory(a2, *(uint64_t **)(a1 + 32), *(unsigned char *)(a1 + 104), &v123, *(float64x2_t *)(a1 + 40), *(float64x2_t *)(a1 + 72));
  if (updated == 128)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "unknown");
    double v88 = *(double *)(a1 + 88) - *(double *)(a1 + 40);
    double v89 = *(double *)(a1 + 56);
    double v90 = *(double *)(a1 + 64) - *(double *)(a1 + 48);
    v127.i32[3] = 0;
    LOBYTE(v128) = 0;
    HIDWORD(v128) = 0;
    v127.i64[0] = 0;
    v127.i16[4] = 0;
    *(float *)&double v88 = v88;
    *(float *)&double v90 = v90;
    v126.i64[1] = __PAIR64__(LODWORD(v88), LODWORD(v90));
    *(float *)&double v88 = v89;
    v126.i64[0] = LODWORD(v88) | 0x7FC0000000000000;
    *(float *)&__int32 v91 = (float)CVPixelBufferGetHeight(a2) - *(double *)(a1 + 64);
    v126.i32[1] = v91;
    *((float *)&v128 + 1) = v21;
    unint64_t v92 = a3[1];
    if (v92 >= a3[2])
    {
      uint64_t v93 = std::vector<vision::mod::DetectedObject>::__push_back_slow_path<vision::mod::DetectedObject const&>(a3, (uint64_t)__p);
    }
    else
    {
      vision::mod::DetectedObject::DetectedObject(a3[1], (uint64_t)__p);
      uint64_t v93 = v92 + 80;
      a3[1] = v92 + 80;
    }
    a3[1] = v93;
    if (SHIBYTE(v125) < 0) {
      operator delete(__p[0]);
    }
    return 6784;
  }
  return updated;
}

void sub_1A3E5F4F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  *(void *)(v22 + 8) = v23;
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::DetectedObject::DetectedObject(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = std::string::basic_string[abi:ne180100]<0>((void *)a1, "unknown");
  v4[3] = vdup_n_s32(0x7FC00000u);
  float32x2_t v5 = v4 + 3;
  *((_DWORD *)v4 + 13) = 0;
  *((unsigned char *)v4 + 56) = 0;
  *((_DWORD *)v4 + 15) = 0;
  v4[4] = 0;
  v4[5] = 0;
  *((_WORD *)v4 + 24) = 0;
  *((_OWORD *)v4 + 4) = *(_OWORD *)(a2 + 64);
  std::string::operator=((std::string *)v4, (const std::string *)a2);
  *float32x2_t v5 = *(_OWORD *)(a2 + 24);
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  return a1;
}

void sub_1A3E5F5C8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<vision::mod::DetectedObject>::__push_back_slow_path<vision::mod::DetectedObject const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x333333333333333) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  float64x2_t v6 = a1 + 2;
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 4) > v3) {
    unint64_t v3 = 0x999999999999999ALL * ((a1[2] - *a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 4) >= 0x199999999999999) {
    unint64_t v7 = 0x333333333333333;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v19 = v6;
  if (v7) {
    unint64_t v7 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DetectedObject>>(v7);
  }
  else {
    uint64_t v8 = 0;
  }
  unint64_t v17 = v7;
  *(void *)uint64_t v18 = v7 + 80 * v2;
  *(void *)&v18[16] = v7 + 80 * v8;
  vision::mod::DetectedObject::DetectedObject(*(uint64_t *)v18, a2);
  uint64_t v9 = *(void *)v18;
  *(void *)&v18[8] = *(void *)v18 + 80;
  uint64_t v11 = *a1;
  uint64_t v10 = a1[1];
  *(void *)&long long v23 = *(void *)v18;
  *((void *)&v23 + 1) = *(void *)v18;
  long long v22 = v23;
  v20[0] = v6;
  v20[1] = &v22;
  v20[2] = &v23;
  char v21 = 0;
  while (v10 != v11)
  {
    v10 -= 80;
    vision::mod::DetectedObject::DetectedObject(v9 - 80, v10);
    uint64_t v9 = *((void *)&v23 + 1) - 80;
    *((void *)&v23 + 1) -= 80;
  }
  char v21 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vision::mod::DetectedObject>,std::reverse_iterator<vision::mod::DetectedObject*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v20);
  uint64_t v12 = a1[2];
  long long v13 = *(_OWORD *)&v18[8];
  uint64_t v16 = *(void *)&v18[8];
  long long v14 = *(_OWORD *)a1;
  *a1 = v9;
  *(_OWORD *)uint64_t v18 = v14;
  *(_OWORD *)(a1 + 1) = v13;
  *(void *)&v18[16] = v12;
  unint64_t v17 = v14;
  std::__split_buffer<vision::mod::DetectedObject>::~__split_buffer((uint64_t)&v17);
  return v16;
}

void sub_1A3E5F750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<vision::mod::DetectedObject>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DetectedObject>>(unint64_t a1)
{
  if (a1 >= 0x333333333333334) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(80 * a1);
}

uint64_t std::__split_buffer<vision::mod::DetectedObject>::~__split_buffer(uint64_t a1)
{
  unint64_t v3 = *(void ***)(a1 + 8);
  unint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 10;
      *(void *)(a1 + 16) = v2 - 10;
      if (*((char *)v2 - 57) < 0)
      {
        operator delete(*v4);
        uint64_t v4 = *(void ***)(a1 + 16);
      }
      unint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vision::mod::DetectedObject>,std::reverse_iterator<vision::mod::DetectedObject*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 16) + 8);
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 8);
    while (v3 != v4)
    {
      if (*(char *)(v3 + 23) < 0) {
        operator delete(*(void **)v3);
      }
      v3 += 80;
    }
  }
  return a1;
}

uint64_t vision::mod::ObjectTrackerCorrelation::setTargetObjects(uint64_t a1, __CVBuffer *a2, uint64_t *a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3) {
    return 6751;
  }
  for (uint64_t i = 2048; i != 2112; i += 16)
  {
    bzero(*(void **)(*(void *)v3 + i), 0x8000uLL);
    bzero(*(void **)(*(void *)v3 + i + 8), 0x8000uLL);
  }
  bzero(*(void **)(*(void *)v3 + 2112), 0x8000uLL);
  bzero(*(void **)(*(void *)v3 + 2120), 0x8000uLL);
  bzero(*(void **)v3, 0x400uLL);
  bzero((void *)(*(void *)v3 + 1024), 0x400uLL);
  bzero(*(void **)(v3 + 16), 0x4000uLL);
  bzero((void *)(*(void *)(v3 + 16) + 0x4000), 0x4000uLL);
  bzero((void *)(*(void *)(v3 + 16) + 0x8000), 0x4000uLL);
  bzero((void *)(*(void *)(v3 + 16) + 49152), 0x4000uLL);
  bzero((void *)(*(void *)(v3 + 16) + 0x10000), 0x4000uLL);
  bzero((void *)(*(void *)(v3 + 16) + 81920), 0x4000uLL);
  bzero((void *)(*(void *)(v3 + 16) + 98304), 0x4000uLL);
  bzero((void *)(*(void *)(v3 + 16) + 246072), 0x400uLL);
  bzero((void *)(*(void *)(v3 + 16) + 247096), 0x400uLL);
  bzero((void *)(*(void *)(v3 + 16) + 248120), 0x400uLL);
  bzero((void *)(*(void *)(v3 + 16) + 249144), 0x400uLL);
  uint64_t v8 = *(void *)(v3 + 16) + 250184;
  *(unsigned char *)(v8 + 8) = 0;
  *(void *)uint64_t v8 = 0;
  bzero(*(void **)(*(void *)(v3 + 16) + 245992), 0x8000uLL);
  bzero(*(void **)(*(void *)(v3 + 16) + 246000), 0x8000uLL);
  bzero(*(void **)(*(void *)(v3 + 16) + 246008), 0x8000uLL);
  bzero(*(void **)(*(void *)(v3 + 16) + 246016), 0x8000uLL);
  uint64_t v9 = 4;
  uint64_t v10 = 245936;
  do
  {
    bzero(*(void **)(*(void *)(v3 + 16) + v10 - 8), 0x8000uLL);
    bzero(*(void **)(*(void *)(v3 + 16) + v10), 0x8000uLL);
    v10 += 16;
    --v9;
  }
  while (v9);
  uint64_t v11 = 246032;
  uint64_t v12 = 3;
  do
  {
    long long v13 = *(_OWORD **)(*(void *)(v3 + 16) + v11 - 8);
    v13[14] = 0uLL;
    v13[15] = 0uLL;
    v13[12] = 0uLL;
    v13[13] = 0uLL;
    v13[10] = 0uLL;
    v13[11] = 0uLL;
    v13[8] = 0uLL;
    v13[9] = 0uLL;
    v13[6] = 0uLL;
    v13[7] = 0uLL;
    v13[4] = 0uLL;
    v13[5] = 0uLL;
    _OWORD v13[2] = 0uLL;
    v13[3] = 0uLL;
    *long long v13 = 0uLL;
    v13[1] = 0uLL;
    long long v14 = *(_OWORD **)(*(void *)(v3 + 16) + v11);
    v14[14] = 0uLL;
    v14[15] = 0uLL;
    v14[12] = 0uLL;
    v14[13] = 0uLL;
    v14[10] = 0uLL;
    v14[11] = 0uLL;
    v14[8] = 0uLL;
    v14[9] = 0uLL;
    v14[6] = 0uLL;
    v14[7] = 0uLL;
    v14[4] = 0uLL;
    v14[5] = 0uLL;
    v14[2] = 0uLL;
    v14[3] = 0uLL;
    *long long v14 = 0uLL;
    v14[1] = 0uLL;
    v11 += 16;
    --v12;
  }
  while (v12);
  bzero(*(void **)(*(void *)(v3 + 32) + 65632), 0x8000uLL);
  bzero(*(void **)(*(void *)(v3 + 32) + 65640), 0x8000uLL);
  uint64_t v15 = *a3;
  if (a3[1] - *a3 != 80) {
    return 6780;
  }
  v16.i32[0] = *(_DWORD *)(v15 + 24);
  v17.f32[0] = v16.f32[0] + *(float *)(v15 + 36);
  v16.f32[1] = *(float *)(v15 + 28) + *(float *)(v15 + 32);
  float64x2_t v18 = vcvtq_f64_f32(v16);
  v17.i32[1] = *(_DWORD *)(v15 + 28);
  *(float64x2_t *)(a1 + 56) = v18;
  float64x2_t v19 = vcvtq_f64_f32(v17);
  v20.f64[0] = v19.f64[0];
  v20.f64[1] = v18.f64[1];
  float64x2_t v21 = vaddq_f64(v19, v18);
  v18.f64[1] = v19.f64[1];
  *(float64x2_t *)(a1 + 40) = v18;
  *(float64x2_t *)(a1 + 72) = v20;
  *(float64x2_t *)(a1 + 88) = v19;
  long long v22 = *(uint64_t **)(a1 + 32);
  __asm { FMOV            V1.2D, #0.5 }
  float64x2_t v28 = vmulq_f64(v21, _Q1);
  float64x2_t v29 = vmulq_f64(vmulq_f64(vsubq_f64(v20, v18), (float64x2_t)vdupq_n_s64(0x40047AE140000000uLL)), _Q1);
  float64x2_t v50 = vsubq_f64(v28, v29);
  float64_t v51 = v50.f64[0];
  int8x16_t v30 = (int8x16_t)vaddq_f64(v28, v29);
  *(int8x16_t *)float v52 = vextq_s8(v30, v30, 8uLL);
  *(_OWORD *)&v52[16] = *(_OWORD *)v52;
  float64_t v53 = v50.f64[1];
  *(float64x2_t *)(*v22 + 2128) = vdivq_f64(vsubq_f64(*(float64x2_t *)&v52[8], v50), (float64x2_t)vdupq_n_s64(0x405FC00000000000uLL));
  unint64_t v31 = (int *)v22[2];
  uint64_t result = tplTrackerResampler_setImage(v22[3], a2, v50.f64);
  if (result == 128)
  {
    float v33 = *(double *)(*v22 + 2136);
    float v34 = *(double *)(*v22 + 2128);
    tplTrackerResampler_resample(v22[3], v50.f64, 0x80u, 128, v22[2], (unsigned char *)(v22[2] + 0x4000), (unsigned char *)(v22[2] + 0x8000), v31 + 62542, v33, v34);
    if (v31[62542] > 0 || v31[62543] > 0 || v31[62544] < 127 || v31[62545] <= 126) {
      ctrTrackerComputation_repairNonValidRegion(v22[2], v22[2] + 0x4000, v22[2] + 0x8000, v31 + 62542);
    }
    ctrTrackerComputation_YCbCr2nRGB(v22[2], v22[2] + 0x4000, v22[2] + 0x8000, v22[2] + 49152, v22[2] + 0x10000, v22[2] + 81920);
    ctrTrackerComputation_normedGradient(v22[2] + 49152, v22[2] + 0x10000, v22[2] + 81920, v22[2] + 98304);
    uint64_t v35 = v22[2];
    uint64_t result = ctrTrackerAlgorithm_computeFFTx(v35 + 49152, v35 + 0x10000, v35 + 81920, v35 + 98304, *(void *)(v22[4] + 65624), (DSPComplex *)(v35 + 114856), (DSPSplitComplex *)(*v22 + 2048), *(OpaqueFFTSetup **)(v35 + 250200));
    if (result == 128)
    {
      uint64_t result = ctrTrackerAlgorithm_GaussianCorrelation(*v22 + 2048, *v22 + 2048, (DSPSplitComplex *)(v22[2] + 245992), (const DSPSplitComplex *)(v22[2] + 246024), (DSPComplex *)(v22[2] + 114856), (char *)(v22[2] + 180392), *(OpaqueFFTSetup **)(v22[2] + 250200));
      if (result == 128)
      {
        uint64_t v36 = v22[2];
        int64x2_t v37 = (const DSPComplex *)(v36 + 114856);
        float v48 = (const DSPSplitComplex *)v22[4];
        __Setup = *(OpaqueFFTSetup **)(v36 + 250200);
        bzero((void *)(v36 + 114856), 0x10000uLL);
        uint64_t v38 = 0;
        uint64_t v39 = 0;
        uint64_t v40 = v36 + 115368;
        uint64_t v41 = v36 + 180392;
        uint64_t v42 = v36 + 114856;
        while (1)
        {
          uint64_t v43 = 0;
          uint64_t v44 = v38;
          do
          {
            float v45 = (float)(v39 * v39 + v43 * v43) * -0.5 / 25.0;
            float v46 = expf(v45);
            *(float *)(v42 + 4 * v43) = v46;
            if (v39)
            {
              *(float *)(v41 + 4 * v43) = v46;
              if (!v43) {
                goto LABEL_25;
              }
              *(float *)(v40 + 4 * v44) = v46;
              uint64_t v47 = 0x4000 - (v39 << 7) - v43 + 128;
            }
            else
            {
              if (!v43) {
                goto LABEL_25;
              }
              uint64_t v47 = v44 + 128;
            }
            *(&v37->real + v47) = v46;
LABEL_25:
            ++v43;
            --v44;
          }
          while (v43 != 64);
          ++v39;
          v38 += 128;
          v41 -= 512;
          v42 += 512;
          if (v39 == 64)
          {
            vDSP_ctoz(v37, 2, v48 + 4102, 1, 0x2000uLL);
            vDSP_fft2d_zrip(__Setup, v48 + 4102, 1, 0, 7uLL, 7uLL, 1);
            uint64_t result = ctrTrackerAlgorithm_packedDivision((float **)(v22[2] + 245992), (float **)(v22[4] + 65632), (float **)(*v22 + 2112));
            if (result == 128)
            {
              *(void *)v22[1] = 0;
              ctrTrackerComputation_colorHistogram(v22[2] + 49152, v22[2] + 0x10000, v22[2] + 81920, (char *)*v22, (char *)(*v22 + 1024));
              uint64_t result = 6784;
            }
            break;
          }
        }
      }
    }
  }
  if (result == 128) {
    return 6784;
  }
  return result;
}

void vision::mod::ObjectTrackerCorrelation::~ObjectTrackerCorrelation(void **this)
{
  vision::mod::ObjectTrackerCorrelation::~ObjectTrackerCorrelation(this);

  JUMPOUT(0x1A62562C0);
}

{
  std::__shared_weak_count *v2;

  *this = &unk_1EF752798;
  ctrTrackerInitialization_freeContext(this[4]);
  this[4] = 0;
  *this = &unk_1EF7525F8;
  unint64_t v2 = (std::__shared_weak_count *)this[3];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

void sub_1A3E603A0()
{
}

void sub_1A3E603B8(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<simd_float3x3,float>>>(unint64_t a1)
{
  if (a1 >> 58) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(a1 << 6);
}

void sub_1A3E604C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNHomographyTrackerState;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3E60600(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A3E606D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E60898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3E60C04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E60C14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  if (v10) {
    operator delete(v10);
  }

  JUMPOUT(0x1A3E60C80);
}

void sub_1A3E60C1C()
{
  if (v0) {
    operator delete(v0);
  }
  JUMPOUT(0x1A3E60C60);
}

void sub_1A3E60C28(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exc_buf);
}

void sub_1A3E60C4C()
{
}

void sub_1A3E60C6C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1A3E60D78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t apple::vision::GreedyClusteringParamsWrapperRevision5::getGrowBiggestClustersFlag(apple::vision::GreedyClusteringParamsWrapperRevision5 *this)
{
  return 0;
}

uint64_t apple::vision::GreedyClusteringParamsWrapperRevision5::getConfidenceBasedScalingFlag(apple::vision::GreedyClusteringParamsWrapperRevision5 *this)
{
  return 0;
}

float apple::vision::GreedyClusteringParamsWrapperRevision5::thresholdScaleForDescriptor(apple::vision::GreedyClusteringParamsWrapperRevision5 *this, float *a2)
{
  return 0.6;
}

void *apple::vision::GreedyClusteringParamsWrapper::createClusteringHacksWrapper(void *result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  *uint64_t result = 0;
  result[1] = 0;
  if ((a2 & 0xFFFFFFFD) == 0xDECAF001)
  {
    uint64_t v9 = result;
    if (a3 == 1 || a3 == -557125630)
    {
      uint64_t v10 = (char *)operator new(0x58uLL);
      *(_OWORD *)(v10 + 8) = 0u;
      *(void *)uint64_t v10 = &unk_1EF753460;
      uint64_t v11 = (apple::vision::GreedyClusteringParamsWrapper *)(v10 + 24);
      *((void *)v10 + 3) = &unk_1EF752160;
      *((_OWORD *)v10 + 2) = 0u;
      uint64_t v12 = (float *)(v10 + 32);
      *((_DWORD *)v10 + 12) = a2;
      *((_DWORD *)v10 + 13) = a3;
      *((void *)v10 + 7) = a4;
      *((void *)v10 + 8) = a5;
      BOOL isTorsoAvailable = apple::vision::GreedyClusteringParamsWrapper::isTorsoAvailable((apple::vision::GreedyClusteringParamsWrapper *)(v10 + 24));
      float v14 = 0.18;
      if (!isTorsoAvailable) {
        float v14 = 0.325;
      }
      *uint64_t v12 = v14;
      BOOL v15 = apple::vision::GreedyClusteringParamsWrapper::isTorsoAvailable(v11);
      float v16 = 0.165;
      if (!v15) {
        float v16 = 0.173;
      }
      *((float *)v10 + 9) = v16;
      *((void *)v10 + 5) = 0x23E3851ECLL;
      *((void *)v10 + 3) = &unk_1EF752188;
      *((void *)v10 + 9) = 0;
      *((void *)v10 + 10) = 0;
      BOOL v17 = apple::vision::GreedyClusteringParamsWrapper::isTorsoAvailable(v11);
      float v18 = 0.3;
      if (!v17) {
        float v18 = 0.325;
      }
      *uint64_t v12 = v18;
      uint64_t result = (void *)apple::vision::GreedyClusteringParamsWrapper::isTorsoAvailable(v11);
      float v19 = 0.295;
      if (!result) {
        float v19 = 0.173;
      }
      *((float *)v10 + 9) = v19;
      *((_DWORD *)v10 + 10) = 1050253722;
      *((void *)v10 + 3) = &unk_1EF7521B0;
      *(void *)&long long v20 = v10 + 24;
      *((void *)&v20 + 1) = v10;
      _OWORD *v9 = v20;
    }
  }
  return result;
}

void sub_1A3E60F74(_Unwind_Exception *a1)
{
  shared_owners = (std::__shared_weak_count *)v1[3].__shared_owners_;
  if (shared_owners) {
    std::__shared_weak_count::__release_shared[abi:nn180100](shared_owners);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

BOOL apple::vision::GreedyClusteringParamsWrapper::isTorsoAvailable(apple::vision::GreedyClusteringParamsWrapper *this)
{
  uint64_t v2 = (const char *)[@"VNClusteringAlgorithm_GreedyWithTorso" UTF8String];
  size_t v3 = strlen(v2);
  size_t v4 = *((void *)this + 5);
  if (v3 >= v4) {
    size_t v5 = *((void *)this + 5);
  }
  else {
    size_t v5 = v3;
  }
  return !memcmp(*((const void **)this + 4), v2, v5) && v4 == v3;
}

void std::__shared_ptr_emplace<apple::vision::GreedyClusteringParamsWrapperRevision5Concrete>::__on_zero_shared(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_1EF752188;
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 80);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void std::__shared_ptr_emplace<apple::vision::GreedyClusteringParamsWrapperRevision5Concrete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753460;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<apple::vision::GreedyClusteringParamsWrapperRevision5Concrete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753460;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A3E612B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E617E8(_Unwind_Exception *a1)
{
  uint64_t v8 = v7;

  _Unwind_Resume(a1);
}

void sub_1A3E618A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E618F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E619A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61A2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61A98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61B8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61C7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61D6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61E3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61F2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E61FF4(_Unwind_Exception *a1)
{
}

void sub_1A3E620C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CVBuffer *VNCropAndScalePixelBufferToPixelBuffers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, double a7, double a8, double a9, double a10)
{
  v35[1] = *MEMORY[0x1E4F143B8];
  if (a1 && a2 && a3)
  {
    long long v20 = (void *)MEMORY[0x1A6257080]();
    float64x2_t v21 = [VNImageBuffer alloc];
    float v34 = @"VNImageBufferOption_DoNotCacheRepresentations";
    v35[0] = MEMORY[0x1E4F1CC38];
    long long v22 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v35 forKeys:&v34 count:1];
    long long v23 = objc_alloc_init(VNSession);
    float64_t v24 = [(VNImageBuffer *)v21 initWithCVPixelBuffer:a1 orientation:1 options:v22 session:v23];

    if (v24)
    {
      if (a9 <= 1.0 && a10 <= 1.0)
      {
        unint64_t v25 = [(VNImageBuffer *)v24 width];
        unint64_t v26 = [(VNImageBuffer *)v24 height];
        a7 = a7 * (double)v25;
        a9 = a9 * (double)v25;
        a8 = a8 * (double)v26;
        a10 = a10 * (double)v26;
      }
      if (a5)
      {
        id v33 = 0;
        -[VNImageBuffer augmentedCroppedBuffersWithWidth:height:format:cropRect:options:augmentationOptions:error:](v24, "augmentedCroppedBuffersWithWidth:height:format:cropRect:options:augmentationOptions:error:", a2, a3, a4, 0, a5, &v33, a7, a8, a9, a10);
        uint64_t v27 = (__CVBuffer *)objc_claimAutoreleasedReturnValue();
        id v28 = v33;
      }
      else
      {
        id v31 = 0;
        uint64_t v27 = -[VNImageBuffer croppedBufferWithWidth:height:format:cropRect:options:error:](v24, "croppedBufferWithWidth:height:format:cropRect:options:error:", a2, a3, a4, 0, &v31, a7, a8, a9, a10);
        id v28 = v31;
        values = v27;
        if (v27)
        {
          uint64_t v27 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
          CVPixelBufferRelease((CVPixelBufferRef)values);
        }
      }
      if (!a6 || !v28) {
        goto LABEL_22;
      }
      id v29 = v28;
      id v28 = v29;
    }
    else
    {
      if (!a6)
      {
        uint64_t v27 = 0;
        id v28 = 0;
        goto LABEL_22;
      }
      id v29 = +[VNError errorWithCode:-1 message:@"The image is invalid"];
      uint64_t v27 = 0;
      id v28 = 0;
    }
    *a6 = v29;
LABEL_22:

    return v27;
  }
  uint64_t v27 = 0;
  if (a6) {
    *a6 = _createInvalidArgumentError(0);
  }
  return v27;
}

void sub_1A3E623A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _createInvalidArgumentError(NSString *a1)
{
  uint64_t v1 = a1;
  if (v1) {
    uint64_t v2 = (__CFString *)v1;
  }
  else {
    uint64_t v2 = @"Invalid argument";
  }
  uint64_t v3 = +[VNError errorWithCode:-1 message:v2];

  return v3;
}

void sub_1A3E6243C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _VNScenePrintsFromPixelBuffers(__CVBuffer *a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4, __CFError **a5)
{
  if (a1)
  {
    uint64_t v10 = (void *)MEMORY[0x1A6257080]();
    id v33 = 0;
    id v34 = 0;
    BOOL ConfiguredSceneprintRequest = _getConfiguredSceneprintRequest(a2, a4, &v34, &v33, (uint64_t *)a5);
    uint64_t v12 = (VNCreateSceneprintRequest *)v34;
    id v13 = v33;
    float v14 = v13;
    id v15 = 0;
    if (ConfiguredSceneprintRequest)
    {
      float v16 = [v13 pixelsWideRange];
      unint64_t v17 = [v16 idealDimension];

      float v18 = [v14 pixelsHighRange];
      unint64_t v19 = [v18 idealDimension];

      size_t Width = CVPixelBufferGetWidth(a1);
      size_t Height = CVPixelBufferGetHeight(a1);
      float v22 = (double)v17 / (double)Width;
      float v23 = (double)v19 / (double)Height;
      BOOL v24 = v22 < v23;
      double v25 = 1.0 / v22 * (double)v19;
      double v26 = 1.0 / v23 * (double)v17;
      if (v24) {
        double v27 = (double)Height;
      }
      else {
        double v27 = v25;
      }
      if (v24) {
        double v28 = v26;
      }
      else {
        double v28 = (double)Width;
      }
      if (v24) {
        double v29 = 0.0;
      }
      else {
        double v29 = ((double)Height - v25) * 0.5 + 0.0;
      }
      if (v24) {
        double v30 = ((double)Width - v26) * 0.5 + 0.0;
      }
      else {
        double v30 = 0.0;
      }
      id v31 = (NSArray *)VNCropAndScalePixelBufferToPixelBuffers((uint64_t)a1, (unint64_t)(double)v17, (unint64_t)(double)v19, [v14 idealImageFormat], (uint64_t)a3, a5, v30, v29, v28, v27);
      if (v31) {
        id v15 = _performSceneprintRequestOnAugmentedBuffers(v12, v31, a5);
      }
      else {
        id v15 = 0;
      }
    }
  }
  else
  {
    id v15 = 0;
    if (a5) {
      *a5 = (__CFError *)_createInvalidArgumentError(&cfstr_NoInputBuffer.isa);
    }
  }
  return v15;
}

void sub_1A3E62650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL _getConfiguredSceneprintRequest(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t *a5)
{
  uint64_t v10 = objc_alloc_init(VNCreateSceneprintRequest);
  [(VNRequest *)v10 setUsesCPUOnly:a2];
  if ((int)a1 >= 1) {
    uint64_t v11 = a1;
  }
  else {
    uint64_t v11 = -(int)a1 + 3737841664;
  }
  id v21 = 0;
  BOOL v12 = [(VNRequest *)v10 setRevision:v11 error:&v21];
  id v13 = (NSError *)v21;
  if (v12)
  {
    float v14 = [(VNCreateSceneprintRequest *)v10 supportedImageSizeSet];
    uint64_t v15 = [v14 count];
    BOOL v16 = v15 != 0;
    if (v15)
    {
      *a3 = v10;
      *a4 = [v14 firstObject];
    }
    else if (a5)
    {
      unint64_t v17 = NSString;
      float v18 = [(VNRequest *)v10 specifier];
      unint64_t v19 = [v17 stringWithFormat:@"could not obtain a supported image size for %@", v18];
      *a5 = +[VNError errorWithCode:-1 message:v19];
    }
  }
  else
  {
    BOOL v16 = 0;
    if (a5) {
      *a5 = _createInvalidRequestRevisionError(a1, v13);
    }
  }

  return v16;
}

void sub_1A3E62814(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _performSceneprintRequestOnAugmentedBuffers(VNCreateSceneprintRequest *a1, NSArray *a2, __CFError **a3)
{
  v29[1] = *MEMORY[0x1E4F143B8];
  BOOL v24 = a1;
  double v27 = a2;
  uint64_t v4 = [(NSArray *)v27 count];
  float v23 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:v4];
  if (v23)
  {
    v29[0] = v24;
    double v26 = [MEMORY[0x1E4F1C978] arrayWithObjects:v29 count:1];
    if (v4)
    {
      uint64_t v5 = 0;
      while (1)
      {
        float64x2_t v6 = (void *)MEMORY[0x1A6257080]();
        uint64_t v7 = [(NSArray *)v27 objectAtIndex:v5];
        uint64_t v8 = [VNImageRequestHandler alloc];
        uint64_t v9 = [(VNImageRequestHandler *)v8 initWithCVPixelBuffer:v7 options:MEMORY[0x1E4F1CC08]];
        id v28 = 0;
        BOOL v10 = [(VNImageRequestHandler *)v9 performRequests:v26 error:&v28];
        id v11 = v28;
        BOOL v12 = v11;
        if (v10)
        {
          id v13 = [(VNRequest *)v24 results];
          float v14 = [v13 firstObject];
          uint64_t v15 = [v14 sceneprints];
          BOOL v16 = [v15 firstObject];

          if (v16)
          {
            unint64_t v17 = [v16 descriptorData];
            [v23 addObject:v17];
          }
        }
        else if (a3)
        {
          *a3 = (__CFError *)v11;
        }

        if (!v10) {
          break;
        }
        if (v4 == ++v5) {
          goto LABEL_12;
        }
      }
      id v18 = 0;
    }
    else
    {
LABEL_12:
      id v18 = v23;
    }
  }
  else
  {
    if (a3)
    {
      unint64_t v19 = NSString;
      long long v20 = [NSNumber numberWithUnsignedInteger:v4];
      id v21 = [v19 stringWithFormat:@"unable to allocate results array for %@ elements", v20];
      *a3 = +[VNError errorWithCode:-1 message:v21];
    }
    id v18 = 0;
  }

  return v18;
}

void sub_1A3E62AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t _createInvalidRequestRevisionError(uint64_t a1, NSError *a2)
{
  uint64_t v3 = a2;
  uint64_t v4 = objc_msgSend([NSString alloc], "initWithFormat:", @"Invalid requestRevision %d requested", a1);
  uint64_t v5 = +[VNError errorWithCode:-1 message:v4 underlyingError:v3];

  return v5;
}

void sub_1A3E62C20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNScenePrintsFromPixelBuffersUsesCPUOnly(__CVBuffer *a1, uint64_t a2, const __CFDictionary *a3, __CFError **a4)
{
  return _VNScenePrintsFromPixelBuffers(a1, a2, a3, 1, a4);
}

id VNScenePrintsFromPixelBuffers(__CVBuffer *a1, uint64_t a2, const __CFDictionary *a3, __CFError **a4)
{
  return _VNScenePrintsFromPixelBuffers(a1, a2, a3, 0, a4);
}

__CVBuffer *VNCropAndScaleFromURLToPixelBuffers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, double a7, double a8, double a9, double a10)
{
  v35[1] = *MEMORY[0x1E4F143B8];
  if (a1 && a2 && a3)
  {
    long long v20 = (void *)MEMORY[0x1A6257080]();
    id v21 = [VNImageBuffer alloc];
    id v34 = @"VNImageBufferOption_DoNotCacheRepresentations";
    v35[0] = MEMORY[0x1E4F1CC38];
    float v22 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v35 forKeys:&v34 count:1];
    float v23 = objc_alloc_init(VNSession);
    BOOL v24 = [(VNImageBuffer *)v21 initWithURL:a1 orientation:0 options:v22 session:v23];

    if (v24 && [(VNImageBuffer *)v24 width] && [(VNImageBuffer *)v24 height])
    {
      if (a9 <= 1.0 && a10 <= 1.0)
      {
        unint64_t v25 = [(VNImageBuffer *)v24 width];
        unint64_t v26 = [(VNImageBuffer *)v24 height];
        a7 = a7 * (double)v25;
        a9 = a9 * (double)v25;
        a8 = a8 * (double)v26;
        a10 = a10 * (double)v26;
      }
      if (a5)
      {
        id v33 = 0;
        -[VNImageBuffer augmentedCroppedBuffersWithWidth:height:format:cropRect:options:augmentationOptions:error:](v24, "augmentedCroppedBuffersWithWidth:height:format:cropRect:options:augmentationOptions:error:", a2, a3, a4, 0, a5, &v33, a7, a8, a9, a10);
        double v27 = (__CVBuffer *)objc_claimAutoreleasedReturnValue();
        id v28 = v33;
      }
      else
      {
        id v31 = 0;
        double v27 = -[VNImageBuffer croppedBufferWithWidth:height:format:cropRect:options:error:](v24, "croppedBufferWithWidth:height:format:cropRect:options:error:", a2, a3, a4, 0, &v31, a7, a8, a9, a10);
        id v28 = v31;
        values = v27;
        if (v27)
        {
          double v27 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
          CVPixelBufferRelease((CVPixelBufferRef)values);
        }
      }
      if (!a6 || !v28) {
        goto LABEL_24;
      }
      id v29 = v28;
      id v28 = v29;
    }
    else
    {
      if (!a6)
      {
        double v27 = 0;
        id v28 = 0;
LABEL_24:

        return v27;
      }
      id v29 = +[VNError errorWithCode:-1 message:@"The image is invalid"];
      double v27 = 0;
      id v28 = 0;
    }
    *a6 = v29;
    goto LABEL_24;
  }
  double v27 = 0;
  if (a6) {
    *a6 = _createInvalidArgumentError(0);
  }
  return v27;
}

void sub_1A3E62F30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _VNScenePrintsFromURL(const __CFURL *a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4, __CFError **a5)
{
  v39[1] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    BOOL v10 = (void *)MEMORY[0x1A6257080]();
    id v36 = 0;
    id v37 = 0;
    LODWORD(a4) = _getConfiguredSceneprintRequest(a2, a4, &v37, &v36, (uint64_t *)a5);
    uint64_t v35 = (VNCreateSceneprintRequest *)v37;
    id v11 = v36;
    BOOL v12 = v11;
    if (a4)
    {
      id v13 = [v11 pixelsWideRange];
      unint64_t v14 = [v13 idealDimension];

      uint64_t v15 = [v12 pixelsHighRange];
      unint64_t v16 = [v15 idealDimension];

      unint64_t v17 = [VNImageBuffer alloc];
      uint64_t v38 = @"VNImageBufferOption_DoNotCacheRepresentations";
      v39[0] = MEMORY[0x1E4F1CC38];
      id v18 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v39 forKeys:&v38 count:1];
      unint64_t v19 = objc_alloc_init(VNSession);
      long long v20 = [(VNImageBuffer *)v17 initWithURL:a1 orientation:0 options:v18 session:v19];

      if (v20)
      {
        unint64_t v21 = [(VNImageBuffer *)v20 width];
        unint64_t v22 = [(VNImageBuffer *)v20 height];
        float v23 = (double)v14 / (double)v21;
        float v24 = (double)v16 / (double)v22;
        BOOL v25 = v23 < v24;
        double v26 = 1.0 / v23 * (double)v16;
        double v27 = 1.0 / v24 * (double)v14;
        if (v25) {
          double v28 = (double)v22;
        }
        else {
          double v28 = v26;
        }
        if (v25) {
          double v29 = v27;
        }
        else {
          double v29 = (double)v21;
        }
        if (v25) {
          double v30 = 0.0;
        }
        else {
          double v30 = ((double)v22 - v26) * 0.5 + 0.0;
        }
        if (v25) {
          double v31 = ((double)v21 - v27) * 0.5 + 0.0;
        }
        else {
          double v31 = 0.0;
        }
        uint64_t v32 = (NSArray *)VNCropAndScaleFromURLToPixelBuffers((uint64_t)a1, (unint64_t)(double)v14, (unint64_t)(double)v16, objc_msgSend(v12, "idealImageFormat", v35), (uint64_t)a3, a5, v31, v30, v29, v28);
        if (v32) {
          id v33 = _performSceneprintRequestOnAugmentedBuffers(v35, v32, a5);
        }
        else {
          id v33 = 0;
        }
      }
      else if (a5)
      {
        +[VNError errorWithCode:-1, @"The image is invalid", v35 message];
        id v33 = 0;
        *a5 = (__CFError *)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        id v33 = 0;
      }
    }
    else
    {
      id v33 = 0;
    }
  }
  else
  {
    id v33 = 0;
    if (a5) {
      *a5 = (__CFError *)_createInvalidArgumentError(&cfstr_InvalidUrl.isa);
    }
  }
  return v33;
}

void sub_1A3E63264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

id VNScenePrintsFromURLUsesCPUOnly(const __CFURL *a1, uint64_t a2, const __CFDictionary *a3, __CFError **a4)
{
  if ((int)a2 >= 1) {
    a2 = a2;
  }
  else {
    a2 = -(int)a2 + 3737841664;
  }
  return _VNScenePrintsFromURL(a1, a2, a3, 1, a4);
}

id VNScenePrintsFromURL(const __CFURL *a1, uint64_t a2, const __CFDictionary *a3, __CFError **a4)
{
  if ((int)a2 >= 1) {
    a2 = a2;
  }
  else {
    a2 = -(int)a2 + 3737841664;
  }
  return _VNScenePrintsFromURL(a1, a2, a3, 0, a4);
}

uint64_t VNElementCountForScenePrintRequestRevision(int a1)
{
  if (a1 >= 1) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = -a1 + 3737841664;
  }
  if (v1 != 1)
  {
    uint64_t v3 = objc_alloc_init(VNCreateSceneprintRequest);
    if (![(VNRequest *)v3 setRevision:v1 error:0]) {
      goto LABEL_11;
    }
    if ((unint64_t)(v1 - 3737841671) < 2) {
      goto LABEL_10;
    }
    if (v1 == 2)
    {
      uint64_t v2 = 2048;
      goto LABEL_12;
    }
    if (v1 == 3) {
LABEL_10:
    }
      uint64_t v2 = 768;
    else {
LABEL_11:
    }
      uint64_t v2 = 0;
LABEL_12:

    return v2;
  }
  return 2048;
}

void sub_1A3E633CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t VNLengthInBytesForScenePrintRequestRevision(int a1)
{
  if (a1 >= 1) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = -a1 + 3737841664;
  }
  if (v1 != 1)
  {
    uint64_t v3 = objc_alloc_init(VNCreateSceneprintRequest);
    if (![(VNRequest *)v3 setRevision:v1 error:0]) {
      goto LABEL_11;
    }
    if ((unint64_t)(v1 - 3737841671) < 2) {
      goto LABEL_10;
    }
    if (v1 == 2)
    {
      uint64_t v2 = 0x2000;
      goto LABEL_12;
    }
    if (v1 == 3) {
LABEL_10:
    }
      uint64_t v2 = 3072;
    else {
LABEL_11:
    }
      uint64_t v2 = 0;
LABEL_12:

    return v2;
  }
  return 0x2000;
}

void sub_1A3E63484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFMutableArrayRef VNSceneprintSupportedRevisions()
{
  v0 = (objc_class *)objc_opt_class();

  return _createSupportedRevisionsArrayForRequestClass(v0);
}

CFMutableArrayRef _createSupportedRevisionsArrayForRequestClass(objc_class *a1)
{
  uint64_t v2 = (void *)MEMORY[0x1A6257080]();
  uint64_t v3 = [(objc_class *)a1 supportedRevisions];
  CFIndex v4 = [v3 count];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef v6 = Mutable;
  if (Mutable)
  {
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    v8[2] = ___ZL45_createSupportedRevisionsArrayForRequestClassP10objc_class_block_invoke;
    v8[3] = &__block_descriptor_40_e12_v24__0Q8_B16l;
    v8[4] = Mutable;
    [v3 enumerateIndexesUsingBlock:v8];
  }

  return v6;
}

void sub_1A3E63598(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL45_createSupportedRevisionsArrayForRequestClassP10objc_class_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(__CFArray **)(a1 + 32);
  uint64_t v3 = (const void *)[NSNumber numberWithUnsignedInteger:a2];

  CFArrayAppendValue(v2, v3);
}

CFMutableArrayRef VNDetectionPrintSupportedRevisions()
{
  v0 = (objc_class *)objc_opt_class();

  return _createSupportedRevisionsArrayForRequestClass(v0);
}

id VNDetectionPrintShapes(unsigned int a1, uint64_t *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if ((int)a1 >= 1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = -a1 + 3737841664;
  }
  id v29 = 0;
  long long v20 = +[VNDetectionprint knownTensorKeysForRequestRevision:v2 error:&v29];
  uint64_t v3 = (NSError *)v29;
  if (v20)
  {
    uint64_t v4 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA60]), "initWithCapacity:", objc_msgSend(v20, "count"));
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    id obj = v20;
    float v23 = (void *)v4;
    uint64_t v5 = [obj countByEnumeratingWithState:&v25 objects:v31 count:16];
    if (v5)
    {
      uint64_t v22 = *(void *)v26;
      while (2)
      {
        uint64_t v6 = 0;
        uint64_t v7 = v3;
        do
        {
          if (*(void *)v26 != v22) {
            objc_enumerationMutation(obj);
          }
          uint64_t v8 = *(void *)(*((void *)&v25 + 1) + 8 * v6);
          float v24 = v7;
          uint64_t v9 = +[VNDetectionprint tensorShapeForKey:v8 error:&v24];
          uint64_t v3 = v24;

          if (!v9)
          {
            if (a2) {
              *a2 = _createInvalidRequestRevisionError(a1, v3);
            }

            id v16 = 0;
            uint64_t v15 = v23;
            goto LABEL_20;
          }
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            id v10 = v9;
            id v11 = objc_msgSend(NSNumber, "numberWithUnsignedLong:", objc_msgSend(v10, "channels"));
            v30[0] = v11;
            BOOL v12 = objc_msgSend(NSNumber, "numberWithUnsignedLong:", objc_msgSend(v10, "height"));
            v30[1] = v12;
            id v13 = objc_msgSend(NSNumber, "numberWithUnsignedLong:", objc_msgSend(v10, "width"));
            v30[2] = v13;
            unint64_t v14 = [MEMORY[0x1E4F1C978] arrayWithObjects:v30 count:3];
            [v23 setObject:v14 forKeyedSubscript:v8];
          }
          else
          {
            id v10 = [v9 sizesAsNSNumberArray];
            [v23 setObject:v10 forKeyedSubscript:v8];
          }

          ++v6;
          uint64_t v7 = v3;
        }
        while (v5 != v6);
        uint64_t v5 = [obj countByEnumeratingWithState:&v25 objects:v31 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }

    uint64_t v15 = v23;
    id v16 = v23;
LABEL_20:
  }
  else
  {
    id v16 = 0;
    if (a2) {
      *a2 = _createInvalidRequestRevisionError(a1, v3);
    }
  }

  return v16;
}

void sub_1A3E6395C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

id VNDetectionPrintsFromPixelBuffers(__CVBuffer *a1, uint64_t a2, const __CFDictionary *a3, __CFError **a4)
{
  return _VNDetectionPrintsFromPixelBuffers(a1, a2, a3, 0, a4);
}

id _VNDetectionPrintsFromPixelBuffers(__CVBuffer *a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4, __CFError **a5)
{
  v65[1] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    id v9 = VNDetectionPrintShapes(a2, (uint64_t *)a5);
    float64x2_t v50 = v9;
    if (!v9)
    {
      id v38 = 0;
LABEL_48:

      return v38;
    }
    float v49 = [v9 allKeys];
    uint64_t v44 = [v49 count];
    id v10 = objc_alloc_init(VNCreateDetectionprintRequest);
    if ((int)a2 >= 1) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = -(int)a2 + 3737841664;
    }
    id v63 = 0;
    uint64_t v54 = v10;
    BOOL v12 = [(VNRequest *)v10 setRevision:v11 error:&v63];
    float64_t v51 = (NSError *)v63;
    if (!v12)
    {
      id v38 = 0;
      if (a5) {
        *a5 = (__CFError *)_createInvalidRequestRevisionError(a2, v51);
      }
      goto LABEL_47;
    }
    [(VNRequest *)v54 setUsesCPUOnly:a4];
    id v13 = [(VNImageBasedRequest *)v54 supportedImageSizeSet];
    float v45 = [v13 firstObject];

    if (v45)
    {
      unint64_t v14 = [v45 pixelsWideRange];
      uint64_t v15 = [v14 idealDimension];

      id v16 = [v45 pixelsHighRange];
      uint64_t v17 = [v16 idealDimension];

      uint64_t v18 = [v45 idealImageFormat];
      size_t Width = CVPixelBufferGetWidth(a1);
      size_t Height = CVPixelBufferGetHeight(a1);
      unint64_t v21 = VNCropAndScalePixelBufferToPixelBuffers((uint64_t)a1, v15, v17, v18, (uint64_t)a3, a5, 0.0, 0.0, (double)Width, (double)Height);
      float v48 = v21;
      if (v21)
      {
        uint64_t v47 = [(__CVBuffer *)v21 count];
        uint64_t v41 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:v47];
        v65[0] = v54;
        float v46 = [MEMORY[0x1E4F1C978] arrayWithObjects:v65 count:1];
        if (v47)
        {
          uint64_t v56 = 0;
          while (1)
          {
            context = (void *)MEMORY[0x1A6257080]();
            uint64_t v22 = [(__CVBuffer *)v48 objectAtIndex:v56];
            float v23 = [VNImageRequestHandler alloc];
            float v24 = [(VNImageRequestHandler *)v23 initWithCVPixelBuffer:v22 options:MEMORY[0x1E4F1CC08]];
            id v62 = 0;
            float v52 = v24;
            LOBYTE(v22) = [(VNImageRequestHandler *)v24 performRequests:v46 error:&v62];
            id v25 = v62;
            id v26 = v25;
            if (v22)
            {
              uint64_t v42 = [(VNRequest *)v54 results];
              uint64_t v43 = [v42 firstObject];
              long long v27 = [v43 detectionprint];
              long long v28 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:v44];
              long long v60 = 0u;
              long long v61 = 0u;
              long long v58 = 0u;
              long long v59 = 0u;
              id v29 = v49;
              uint64_t v30 = [v29 countByEnumeratingWithState:&v58 objects:v64 count:16];
              if (v30)
              {
                uint64_t v31 = *(void *)v59;
                while (2)
                {
                  uint64_t v32 = 0;
                  id v33 = v26;
                  do
                  {
                    if (*(void *)v59 != v31) {
                      objc_enumerationMutation(v29);
                    }
                    uint64_t v34 = *(void *)(*((void *)&v58 + 1) + 8 * v32);
                    id v57 = v33;
                    uint64_t v35 = [v27 tensorForKey:v34 error:&v57];
                    id v26 = v57;

                    if (!v35)
                    {
                      if (a5) {
                        *a5 = (__CFError *)CFRetain(v26);
                      }

                      int v37 = 1;
                      goto LABEL_27;
                    }
                    id v36 = [v35 descriptorData];
                    [v28 setObject:v36 forKeyedSubscript:v34];

                    ++v32;
                    id v33 = v26;
                  }
                  while (v30 != v32);
                  uint64_t v30 = [v29 countByEnumeratingWithState:&v58 objects:v64 count:16];
                  if (v30) {
                    continue;
                  }
                  break;
                }
              }

              [v41 addObject:v28];
              int v37 = 0;
LABEL_27:
            }
            else
            {
              if (a5) {
                *a5 = (__CFError *)CFRetain(v25);
              }
              int v37 = 1;
            }

            if (v37) {
              break;
            }
            if (++v56 == v47) {
              goto LABEL_30;
            }
          }
          id v38 = 0;
        }
        else
        {
LABEL_30:
          id v38 = v41;
        }
      }
      else
      {
        id v38 = 0;
      }
    }
    else
    {
      if (a5)
      {
        uint64_t v39 = 0;
        +[VNError errorWithCode:-1 message:@"no supported image size available"];
        id v38 = 0;
        *a5 = (__CFError *)objc_claimAutoreleasedReturnValue();
LABEL_46:

LABEL_47:
        goto LABEL_48;
      }
      id v38 = 0;
    }
    uint64_t v39 = v45;
    goto LABEL_46;
  }
  id v38 = 0;
  if (a5) {
    *a5 = (__CFError *)_createInvalidArgumentError(&cfstr_NoInputBuffer.isa);
  }
  return v38;
}

void sub_1A3E63F50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,void *a23)
{
  _Unwind_Resume(a1);
}

id VNDetectionPrintsFromPixelBuffersUsesCPUOnly(__CVBuffer *a1, uint64_t a2, const __CFDictionary *a3, __CFError **a4)
{
  return _VNDetectionPrintsFromPixelBuffers(a1, a2, a3, 1, a4);
}

void sub_1A3E64204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E643CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E644D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E64984()
{
}

uint64_t __Block_byref_object_copy__867(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__868(uint64_t a1)
{
}

void sub_1A3E64CAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E64DF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E65064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  vision::mod::ImageAnalyzer_Options::~ImageAnalyzer_Options((vision::mod::ImageAnalyzer_Options *)va);

  _Unwind_Resume(a1);
}

vision::mod::ImageAnalyzer_Options *vision::mod::ImageAnalyzer_Options::ImageAnalyzer_Options(vision::mod::ImageAnalyzer_Options *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(_OWORD *)((char *)this + 24) = xmmword_1A410C110;
  *((_DWORD *)this + 10) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_WORD *)this + 192) = 0;
  *((void *)this + 49) = 0;
  *((void *)this + 50) = 0;
  *((_DWORD *)this + 104) = 0;
  *((void *)this + 51) = 0;
  *((void *)this + 53) = 0;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0x12B00000200;
  *((void *)this + 56) = 0x3D4CCCCD3EE66666;
  *((_DWORD *)this + 114) = 0;
  *((_WORD *)this + 230) = 1;
  *((void *)this + 59) = 0;
  *((void *)this + 60) = 0;
  *((void *)this + 58) = 0;
  uint64_t v2 = operator new(0x10uLL);
  *((void *)this + 58) = v2;
  *v2++ = xmmword_1A410C120;
  *((void *)this + 59) = v2;
  *((void *)this + 60) = v2;
  *((void *)this + 71) = 0;
  *((void *)this + 73) = 0;
  *((void *)this + 72) = 0;
  *((void *)this + 69) = 0;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *((void *)this + 70) = (char *)this + 568;
  *((void *)this + 74) = 0x12000000200;
  return this;
}

void sub_1A3E651CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v10 + 336);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a10);
  if (*(char *)(v10 + 335) < 0) {
    operator delete(*(void **)(v10 + 312));
  }
  if (*(char *)(v10 + 311) < 0) {
    operator delete(*(void **)(v10 + 288));
  }
  if (*(char *)(v10 + 287) < 0) {
    operator delete(*(void **)(v10 + 264));
  }
  if (*(char *)(v10 + 263) < 0) {
    operator delete(*(void **)(v10 + 240));
  }
  if (*(char *)(v10 + 239) < 0) {
    operator delete(*(void **)(v10 + 216));
  }
  if (*(char *)(v10 + 215) < 0) {
    operator delete(*(void **)(v10 + 192));
  }
  if (*(char *)(v10 + 191) < 0) {
    operator delete(*(void **)(v10 + 168));
  }
  if (*(char *)(v10 + 167) < 0) {
    operator delete(*(void **)(v10 + 144));
  }
  if (*(char *)(v10 + 143) < 0) {
    operator delete(*(void **)(v10 + 120));
  }
  if (*(char *)(v10 + 119) < 0) {
    operator delete(*(void **)(v10 + 96));
  }
  if (*(char *)(v10 + 95) < 0) {
    operator delete(*(void **)(v10 + 72));
  }
  if (*(char *)(v10 + 71) < 0) {
    operator delete(*v11);
  }
  if (*(char *)(v10 + 23) < 0) {
    operator delete(*(void **)v10);
  }
  _Unwind_Resume(a1);
}

void vision::mod::ImageAnalyzer_Options::~ImageAnalyzer_Options(vision::mod::ImageAnalyzer_Options *this)
{
  std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(*((char **)this + 71));
  uint64_t v2 = (void **)*((void *)this + 67);
  if (v2)
  {
    uint64_t v3 = (void **)*((void *)this + 68);
    uint64_t v4 = (void *)*((void *)this + 67);
    if (v3 != v2)
    {
      do
      {
        v3 -= 3;
        id v9 = v3;
        std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v9);
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 67);
    }
    *((void *)this + 68) = v2;
    operator delete(v4);
  }
  id v9 = (void **)((char *)this + 512);
  std::vector<std::vector<std::string>>::__destroy_vector::operator()[abi:ne180100](&v9);
  uint64_t v5 = (void **)*((void *)this + 61);
  if (v5)
  {
    uint64_t v6 = (void **)*((void *)this + 62);
    uint64_t v7 = (void *)*((void *)this + 61);
    if (v6 != v5)
    {
      do
      {
        v6 -= 3;
        id v9 = v6;
        std::vector<std::vector<std::string>>::__destroy_vector::operator()[abi:ne180100](&v9);
      }
      while (v6 != v5);
      uint64_t v7 = (void *)*((void *)this + 61);
    }
    *((void *)this + 62) = v5;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 58);
  if (v8)
  {
    *((void *)this + 59) = v8;
    operator delete(v8);
  }
  if (*((char *)this + 415) < 0) {
    operator delete(*((void **)this + 49));
  }
  if (*((char *)this + 383) < 0) {
    operator delete(*((void **)this + 45));
  }
  id v9 = (void **)((char *)this + 336);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v9);
  if (*((char *)this + 335) < 0) {
    operator delete(*((void **)this + 39));
  }
  if (*((char *)this + 311) < 0) {
    operator delete(*((void **)this + 36));
  }
  if (*((char *)this + 287) < 0) {
    operator delete(*((void **)this + 33));
  }
  if (*((char *)this + 263) < 0) {
    operator delete(*((void **)this + 30));
  }
  if (*((char *)this + 239) < 0) {
    operator delete(*((void **)this + 27));
  }
  if (*((char *)this + 215) < 0) {
    operator delete(*((void **)this + 24));
  }
  if (*((char *)this + 191) < 0) {
    operator delete(*((void **)this + 21));
  }
  if (*((char *)this + 167) < 0) {
    operator delete(*((void **)this + 18));
  }
  if (*((char *)this + 143) < 0) {
    operator delete(*((void **)this + 15));
  }
  if (*((char *)this + 119) < 0) {
    operator delete(*((void **)this + 12));
  }
  if (*((char *)this + 95) < 0) {
    operator delete(*((void **)this + 9));
  }
  if (*((char *)this + 71) < 0) {
    operator delete(*((void **)this + 6));
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
}

void std::vector<std::vector<std::string>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void sub_1A3E65850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1A3E65A08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::clear(a1);
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  uint64_t v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    *uint64_t v7 = 0;
    v7[1] = 0;
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node(*(void ***)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

BOOL _isAcceptableRecognizedObjectIdentifier(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = a2;
  BOOL v5 = ([v3 hasPrefix:@"CVML_UNKNOWN_"] & 1) == 0 && (!v4 || (v4[2](v4, v3) & 1) == 0);

  return v5;
}

void sub_1A3E65B88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node(void **__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      uint64_t v2 = (void **)*v1;
      if (*((char *)v1 + 39) < 0) {
        operator delete(v1[2]);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node(*(void ***)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void sub_1A3E65E50()
{
}

uint64_t *vision::mod::ImageAnalyzer::getLabelsList(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>((void *)(a1 + 864), a2);
  if (!v2) {
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  }
  return v2 + 3;
}

uint64_t *vision::mod::ImageAnalyzer::getDisallowedLabels(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 912);
  if (!v2) {
    goto LABEL_17;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  BOOL v5 = *(uint64_t ***)(*(void *)(a1 + 904) + 8 * v4);
  if (!v5 || (uint64_t v6 = *v5) == 0) {
LABEL_17:
  }
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  while (1)
  {
    unint64_t v7 = v6[1];
    if (v7 == a2) {
      break;
    }
    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= v2) {
        v7 %= v2;
      }
    }
    else
    {
      v7 &= v2 - 1;
    }
    if (v7 != v4) {
      goto LABEL_17;
    }
LABEL_16:
    uint64_t v6 = (uint64_t *)*v6;
    if (!v6) {
      goto LABEL_17;
    }
  }
  if (*((_DWORD *)v6 + 4) != a2) {
    goto LABEL_16;
  }
  return v6 + 3;
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(void *a1, unsigned __int8 *a2)
{
  unint64_t v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  uint64_t v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (uint64_t i = *v10; i; uint64_t i = *(unsigned __int8 **)i)
  {
    unint64_t v12 = *((void *)i + 1);
    if (v6 == v12)
    {
      if (std::equal_to<std::string>::operator()[abi:ne180100](i + 16, a2)) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

unint64_t std::__string_hash<char>::operator()[abi:ne180100](uint64_t a1)
{
  int v1 = *(char *)(a1 + 23);
  unint64_t v2 = *(void *)(a1 + 8);
  BOOL v3 = v1 < 0;
  if (v1 >= 0) {
    unint64_t v4 = (uint64_t *)a1;
  }
  else {
    unint64_t v4 = *(uint64_t **)a1;
  }
  if (!v3) {
    unint64_t v2 = *(unsigned __int8 *)(a1 + 23);
  }
  if (v2 > 0x20)
  {
    if (v2 > 0x40)
    {
      unint64_t v34 = 0x9DDFEA08EB382D69;
      uint64_t v44 = *(uint64_t *)((char *)v4 + v2 - 48);
      uint64_t v43 = *(uint64_t *)((char *)v4 + v2 - 40);
      uint64_t v45 = *(uint64_t *)((char *)v4 + v2 - 24);
      uint64_t v47 = *(uint64_t *)((char *)v4 + v2 - 64);
      uint64_t v46 = *(uint64_t *)((char *)v4 + v2 - 56);
      uint64_t v48 = *(uint64_t *)((char *)v4 + v2 - 16);
      uint64_t v49 = *(uint64_t *)((char *)v4 + v2 - 8);
      unint64_t v50 = v46 + v48;
      unint64_t v51 = 0x9DDFEA08EB382D69
          * (v45 ^ ((0x9DDFEA08EB382D69 * (v45 ^ (v44 + v2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v45 ^ (v44 + v2))));
      unint64_t v52 = 0x9DDFEA08EB382D69 * (v51 ^ (v51 >> 47));
      unint64_t v53 = v47 + v2 + v46 + v44;
      uint64_t v54 = v53 + v43;
      unint64_t v55 = __ROR8__(v53, 44) + v47 + v2 + __ROR8__(v43 + v47 + v2 - 0x622015F714C7D297 * (v51 ^ (v51 >> 47)), 21);
      uint64_t v56 = v46 + v48 + *(uint64_t *)((char *)v4 + v2 - 32) - 0x4B6D499041670D8DLL;
      uint64_t v57 = v56 + v45 + v48;
      uint64_t v58 = __ROR8__(v57, 44);
      uint64_t v59 = v57 + v49;
      uint64_t v60 = v58 + v56 + __ROR8__(v56 + v43 + v49, 21);
      uint64_t v62 = *v4;
      long long v61 = v4 + 4;
      unint64_t v63 = v62 - 0x4B6D499041670D8DLL * v43;
      uint64_t v64 = -(uint64_t)((v2 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        uint64_t v65 = *(v61 - 3);
        uint64_t v66 = v63 + v54 + v50 + v65;
        uint64_t v67 = v61[2];
        uint64_t v68 = v61[3];
        uint64_t v69 = v61[1];
        unint64_t v50 = v69 + v54 - 0x4B6D499041670D8DLL * __ROR8__(v50 + v55 + v67, 42);
        uint64_t v70 = v52 + v59;
        uint64_t v71 = *(v61 - 2);
        uint64_t v72 = *(v61 - 1);
        uint64_t v73 = *(v61 - 4) - 0x4B6D499041670D8DLL * v55;
        uint64_t v74 = v73 + v59 + v72;
        uint64_t v75 = v73 + v65 + v71;
        uint64_t v54 = v75 + v72;
        uint64_t v76 = __ROR8__(v75, 44) + v73;
        unint64_t v77 = (0xB492B66FBE98F273 * __ROR8__(v66, 37)) ^ v60;
        unint64_t v63 = 0xB492B66FBE98F273 * __ROR8__(v70, 33);
        unint64_t v55 = v76 + __ROR8__(v74 + v77, 21);
        unint64_t v78 = v63 + v60 + *v61;
        uint64_t v59 = v78 + v69 + v67 + v68;
        uint64_t v60 = __ROR8__(v78 + v69 + v67, 44) + v78 + __ROR8__(v50 + v71 + v78 + v68, 21);
        v61 += 8;
        unint64_t v52 = v77;
        v64 += 64;
      }
      while (v64);
      unint64_t v79 = 0x9DDFEA08EB382D69
          * (v59 ^ ((0x9DDFEA08EB382D69 * (v59 ^ v54)) >> 47) ^ (0x9DDFEA08EB382D69 * (v59 ^ v54)));
      unint64_t v80 = v63
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v60 ^ ((0x9DDFEA08EB382D69 * (v60 ^ v55)) >> 47) ^ (0x9DDFEA08EB382D69 * (v60 ^ v55)))) ^ ((0x9DDFEA08EB382D69 * (v60 ^ ((0x9DDFEA08EB382D69 * (v60 ^ v55)) >> 47) ^ (0x9DDFEA08EB382D69 * (v60 ^ v55)))) >> 47));
      unint64_t v81 = 0x9DDFEA08EB382D69
          * (v80 ^ (v77 - 0x4B6D499041670D8DLL * (v50 ^ (v50 >> 47)) - 0x622015F714C7D297 * (v79 ^ (v79 >> 47))));
      unint64_t v35 = 0x9DDFEA08EB382D69 * (v80 ^ (v81 >> 47) ^ v81);
    }
    else
    {
      unint64_t v9 = (char *)v4 + v2;
      uint64_t v10 = *(uint64_t *)((char *)v4 + v2 - 16);
      uint64_t v11 = *(uint64_t *)((char *)v4 + v2 - 8);
      uint64_t v12 = v4[1];
      uint64_t v13 = *v4 - 0x3C5A37A36834CED9 * (v10 + v2);
      id v16 = v4 + 2;
      uint64_t v14 = v4[2];
      uint64_t v15 = v16[1];
      uint64_t v17 = __ROR8__(v13 + v15, 52);
      uint64_t v18 = __ROR8__(v13, 37);
      uint64_t v19 = v13 + v12;
      uint64_t v20 = __ROR8__(v19, 7);
      uint64_t v21 = v19 + v14;
      uint64_t v22 = v20 + v18;
      uint64_t v23 = *((void *)v9 - 4) + v14;
      uint64_t v24 = v11 + v15;
      uint64_t v25 = __ROR8__(v24 + v23, 52);
      uint64_t v26 = v22 + v17;
      uint64_t v27 = __ROR8__(v23, 37);
      uint64_t v28 = *((void *)v9 - 3) + v23;
      uint64_t v29 = __ROR8__(v28, 7);
      uint64_t v30 = v26 + __ROR8__(v21, 31);
      uint64_t v31 = v28 + v10;
      uint64_t v32 = v31 + v24;
      uint64_t v33 = v21 + v15 + v27 + v29 + v25 + __ROR8__(v31, 31);
      unint64_t v34 = 0x9AE16A3B2F90404FLL;
      unint64_t v35 = v30
          - 0x3C5A37A36834CED9
          * ((0xC3A5C85C97CB3127 * (v32 + v30) - 0x651E95C4D06FBFB1 * v33) ^ ((0xC3A5C85C97CB3127 * (v32 + v30)
                                                                                 - 0x651E95C4D06FBFB1 * v33) >> 47));
    }
    return (v35 ^ (v35 >> 47)) * v34;
  }
  else
  {
    if (v2 > 0x10)
    {
      uint64_t v36 = v4[1];
      unint64_t v37 = 0xB492B66FBE98F273 * *v4;
      unint64_t v38 = 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)v4 + v2 - 8);
      uint64_t v39 = __ROR8__(v38, 30) + __ROR8__(v37 - v36, 43);
      unint64_t v40 = v37 + v2 + __ROR8__(v36 ^ 0xC949D7C7509E6557, 20) - v38;
      unint64_t v41 = 0x9DDFEA08EB382D69 * (v40 ^ (v39 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)v4 + v2 - 16)));
      unint64_t v42 = v40 ^ (v41 >> 47) ^ v41;
      return 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v42) ^ ((0x9DDFEA08EB382D69 * v42) >> 47));
    }
    if (v2 >= 9)
    {
      uint64_t v5 = *v4;
      uint64_t v6 = *(uint64_t *)((char *)v4 + v2 - 8);
      uint64_t v7 = __ROR8__(v6 + v2, v2);
      return (0x9DDFEA08EB382D69
            * ((0x9DDFEA08EB382D69
              * (v7 ^ ((0x9DDFEA08EB382D69 * (v7 ^ v5)) >> 47) ^ (0x9DDFEA08EB382D69 * (v7 ^ v5)))) ^ ((0x9DDFEA08EB382D69 * (v7 ^ ((0x9DDFEA08EB382D69 * (v7 ^ v5)) >> 47) ^ (0x9DDFEA08EB382D69 * (v7 ^ v5)))) >> 47))) ^ v6;
    }
    if (v2 >= 4)
    {
      int v82 = *(_DWORD *)v4;
      uint64_t v83 = *(unsigned int *)((char *)v4 + v2 - 4);
      unint64_t v84 = 0x9DDFEA08EB382D69 * ((v2 + (8 * v82)) ^ v83);
      unint64_t v42 = v83 ^ (v84 >> 47) ^ v84;
      return 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v42) ^ ((0x9DDFEA08EB382D69 * v42) >> 47));
    }
    unint64_t result = 0x9AE16A3B2F90404FLL;
    if (v2)
    {
      unint64_t v85 = (0xC949D7C7509E6557 * (v2 + 4 * *((unsigned __int8 *)v4 + v2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                     * (*(unsigned __int8 *)v4 | ((unint64_t)*((unsigned __int8 *)v4 + (v2 >> 1)) << 8)));
      return 0x9AE16A3B2F90404FLL * (v85 ^ (v85 >> 47));
    }
  }
  return result;
}

BOOL std::equal_to<std::string>::operator()[abi:ne180100](unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

uint64_t *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  int v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (unint64_t result = *v5; result; unint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void sub_1A3E66818(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  std::string::size_type v4 = strlen(__s);

  return std::string::__assign_external(this, __s, v4);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = this->__r_.__value_.__r.__words[2];
    unint64_t v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    unint64_t v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    unint64_t v7 = this;
    if (__n > 0x16)
    {
      std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      unint64_t v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((unsigned char *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0) {
    this->__r_.__value_.__l.__size_ = __n;
  }
  else {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

void sub_1A3E6749C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A3E675D8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A3E67758(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A3E678A4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A3E67970(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A3E67B54(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A3E67C0C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t calculateChecksumMD5(char *a1, unint64_t a2, unsigned __int8 *a3)
{
  memset(&v8, 0, sizeof(v8));
  CC_MD5_Init(&v8);
  for (; a2; a2 -= v6)
  {
    if (a2 >= 0x4000) {
      uint64_t v6 = 0x4000;
    }
    else {
      uint64_t v6 = a2;
    }
    CC_MD5_Update(&v8, a1, v6);
    a1 += v6;
  }
  return CC_MD5_Final(a3, &v8);
}

uint64_t calculateChecksumMD5ForFile(const char *a1, unsigned __int8 *a2)
{
  std::string::size_type v4 = malloc_type_malloc(0x4000uLL, 0x12BF400uLL);
  if (!v4) {
    return 0;
  }
  int v5 = v4;
  int v6 = open(a1, 0);
  if (v6 == -1)
  {
    free(v5);
    return 0;
  }
  int v7 = v6;
  unint64_t v8 = lseek(v6, 0, 2);
  lseek(v7, 0, 0);
  memset(&c, 0, sizeof(c));
  CC_MD5_Init(&c);
  if (v8)
  {
    while (1)
    {
      uint64_t v9 = v8 >= 0x4000 ? 0x4000 : v8;
      if (read(v7, v5, 0x4000uLL) != v9) {
        break;
      }
      CC_MD5_Update(&c, v5, v9);
      v8 -= v9;
      if (!v8) {
        goto LABEL_9;
      }
    }
    VNValidatedLog(4, @"  calculateChecksumMD5ForFile: error reading %zu bytes from file", v10, v11, v12, v13, v14, v15, v9);
    close(v7);
    CC_MD5_Final(a2, &c);
    uint64_t v16 = 0;
  }
  else
  {
LABEL_9:
    CC_MD5_Final(a2, &c);
    close(v7);
    uint64_t v16 = 1;
  }
  free(v5);
  return v16;
}

uint64_t verifyChecksumMD5ForFile(const char *a1, void *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t result = calculateChecksumMD5ForFile(a1, (unsigned __int8 *)&v5);
  if (result) {
    return v5 == *a2 && v6 == a2[1];
  }
  return result;
}

void sub_1A3E682B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E68354(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E685FC(_Unwind_Exception *a1)
{
  uint64_t v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A3E687F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E68A74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A3E68BD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>>>::~__hash_table(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint8x8_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,vision::mod::ModelValues::ValueInfo>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  std::string::size_type v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,vision::mod::ModelValues::ValueInfo>,0>(uint64_t a1)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint8x8_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t std::__shared_ptr_pointer<float  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), 0x80000001A4125042)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if ((a2 & a1) < 0 != __OFSUB__(a1, a2)) {
    return strcmp((const char *)(a1 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(a2 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

uint64_t std::__shared_ptr_pointer<float  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1A62562A0);
  }
  return result;
}

void std::__shared_ptr_pointer<float  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A3E6936C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69508(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E695DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6969C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69794(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6982C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6993C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69B3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69BE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69D0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69DA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69E78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69F08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E69F8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A010(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A0C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A1B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A350(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

objc_object *_prettyPrintedValue(objc_object *a1)
{
  int v1 = a1;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v2 = [NSString stringWithFormat:@"\"%@\"", v1];

    int v1 = (objc_object *)v2;
  }

  return v1;
}

void sub_1A3E6A3F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A55C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A6B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A75C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A93C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6A9F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6AAE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6AB7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6AC5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6AD14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6ADE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6AF08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6B00C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6B128(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6B200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6B294(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6B3E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6B4E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6B5B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6BAE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,void *a21,void *a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Block_object_dispose(&a34, 8);
  *(void *)(v39 - 128) = a10;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)(v39 - 128));

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__49(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__50(uint64_t a1)
{
  int v1 = (void **)(a1 + 48);
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void sub_1A3E6C424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void **a46)
{
  a46 = (void **)&a38;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&a46);
  _Unwind_Resume(a1);
}

void std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<vision::mod::DetectedObject>::__clear[abi:ne180100]((uint64_t *)v2);
    uint8x8_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<vision::mod::DetectedObject>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 80)
  {
    if (*(char *)(i - 57) < 0) {
      operator delete(*(void **)(i - 80));
    }
  }
  a1[1] = v2;
}

void sub_1A3E6C7D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E6CD04(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  uint64_t v21 = va_arg(va1, void);
  uint64_t v22 = va_arg(va1, void);
  uint64_t v23 = va_arg(va1, void);
  uint64_t v24 = va_arg(va1, void);

  _Block_object_dispose(va, 8);
  vision::mod::ObjectDetector_DCNFaceDetector_v2_Options::~ObjectDetector_DCNFaceDetector_v2_Options((void **)va1);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__1548(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = 0;
  *(void *)(a1 + 56) = v2;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  long long v3 = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(a1 + 80) = v3;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 80) = 0;
  __n128 result = *(__n128 *)(a2 + 104);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(__n128 *)(a1 + 104) = result;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  return result;
}

void __Block_byref_object_dispose__1549(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  uint64_t v2 = *(void **)(a1 + 56);
}

void sub_1A3E6D178(_Unwind_Exception *a1)
{
  long long v3 = v1;
  if (*(char *)(v2 + 95) < 0) {
    operator delete(*v3);
  }

  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v2);
  operator delete(v5);
  _Unwind_Resume(a1);
}

void vision::mod::ObjectDetector_DCNFaceDetector_v2_Options::~ObjectDetector_DCNFaceDetector_v2_Options(void **this)
{
  if (*((char *)this + 79) < 0) {
    operator delete(this[7]);
  }
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
}

uint64_t std::__shared_ptr_emplace<vision::mod::ObjectDetector_DCNFaceDetector_v2>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::ObjectDetector_DCNFaceDetector_v2>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753B98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ObjectDetector_DCNFaceDetector_v2>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753B98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void vision::mod::formCompoundID(std::string *this, const char *a2, char *a3)
{
  std::string::basic_string[abi:ne180100]<0>(&v14, ":");
  std::string::size_type v6 = strlen(a2);
  uint64_t v7 = std::string::insert(&v14, 0, a2, v6);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, a3);
  if ((v13 & 0x80u) == 0) {
    uint64_t v9 = __p;
  }
  else {
    uint64_t v9 = (void **)__p[0];
  }
  if ((v13 & 0x80u) == 0) {
    std::string::size_type v10 = v13;
  }
  else {
    std::string::size_type v10 = (std::string::size_type)__p[1];
  }
  uint64_t v11 = std::string::append(&v15, (const std::string::value_type *)v9, v10);
  *this = *v11;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if ((char)v13 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
}

void sub_1A3E6D3D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__find_impl[abi:ne180100]<std::string const*,std::string const*,std::string,std::__identity>(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    char v5 = *((unsigned char *)a3 + 23);
    if (v5 >= 0) {
      std::string::size_type v6 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    }
    else {
      std::string::size_type v6 = a3[1];
    }
    if (v5 >= 0) {
      uint64_t v7 = (unsigned __int8 *)a3;
    }
    else {
      uint64_t v7 = *a3;
    }
    do
    {
      uint64_t v8 = *(unsigned __int8 *)(v3 + 23);
      if ((v8 & 0x80u) == 0) {
        uint64_t v9 = (unsigned __int8 *)*(unsigned __int8 *)(v3 + 23);
      }
      else {
        uint64_t v9 = *(unsigned __int8 **)(v3 + 8);
      }
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v3, v7, *(void *)(v3 + 8))) {
            return v3;
          }
        }
        else
        {
          if (!*(unsigned char *)(v3 + 23)) {
            return v3;
          }
          uint64_t v10 = 0;
          while (*(unsigned __int8 *)(v3 + v10) == v7[v10])
          {
            if (v8 == ++v10) {
              return v3;
            }
          }
        }
      }
      v3 += 24;
    }
    while (v3 != a2);
    return a2;
  }
  return v3;
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
}

uint64_t vision::mod::readParametersNoMapping(uint64_t a1)
{
  if (a1) {
    return 8576;
  }
  else {
    return 8573;
  }
}

uint64_t vision::mod::computeNoMapping(int a1, uint64_t a2, char *a3)
{
  if (a3 != (char *)a2) {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a3, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  }
  return 8576;
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](v7, v11);
    unsigned __int8 v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  std::string v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

uint64_t vision::mod::readParameters1DAffineMapping(FILE *a1, const char *a2, uint64_t a3)
{
  memset(&v18, 0, sizeof(v18));
  if (!a1)
  {
    uint64_t v11 = 8573;
    goto LABEL_21;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "a");
  p_p = &__p;
  std::string::size_type v6 = std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)&p_p);
  uint64_t v8 = (void *)v6 + 7;
  uint64_t v7 = (void *)*((void *)v6 + 7);
  if (v7)
  {
    *((void *)v6 + 8) = v7;
    operator delete(v7);
    *uint64_t v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
  }
  *uint64_t v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  vision::mod::formCompoundID(&__p, a2, "a");
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  std::string v18 = __p;
  std::string::basic_string[abi:ne180100]<0>(&__p, "a");
  p_p = &__p;
  uint64_t v9 = (char **)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)&p_p);
  uint64_t v10 = vision::mod::loadFloat32Vector(a1, &v18, v9 + 7);
  uint64_t v11 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v11 & 0x80) == 0) {
      goto LABEL_21;
    }
  }
  else if ((v10 & 0x80) == 0)
  {
    goto LABEL_21;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "b");
  p_p = &__p;
  uint64_t v12 = std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)&p_p);
  std::string v14 = (void *)v12 + 7;
  unsigned __int8 v13 = (void *)*((void *)v12 + 7);
  if (v13)
  {
    *((void *)v12 + 8) = v13;
    operator delete(v13);
    *std::string v14 = 0;
    v14[1] = 0;
    v14[2] = 0;
  }
  *std::string v14 = 0;
  v14[1] = 0;
  v14[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  vision::mod::formCompoundID(&__p, a2, "b");
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  std::string v18 = __p;
  std::string::basic_string[abi:ne180100]<0>(&__p, "b");
  p_p = &__p;
  unint64_t v15 = (char **)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)&p_p);
  uint64_t v11 = vision::mod::loadFloat32Vector(a1, &v18, v15 + 7);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_21:
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  return v11;
}

void sub_1A3E6D878(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

_OWORD *std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, void *a2, _OWORD **a3)
{
  char v5 = (void **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>(a1, &v14, a2);
  std::string::size_type v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    std::string::size_type v6 = operator new(0x50uLL);
    uint64_t v8 = *a3;
    uint64_t v9 = *((void *)*a3 + 2);
    v6[2] = **a3;
    *((void *)v6 + 6) = v9;
    *uint64_t v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    *((void *)v6 + 8) = 0;
    *((void *)v6 + 9) = 0;
    *((void *)v6 + 7) = 0;
    uint64_t v10 = v14;
    *(void *)std::string::size_type v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v10;
    *uint64_t v7 = v6;
    uint64_t v11 = **(void **)a1;
    uint64_t v12 = (uint64_t *)v6;
    if (v11)
    {
      *(void *)a1 = v11;
      uint64_t v12 = (uint64_t *)*v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

uint64_t vision::mod::loadFloat32Vector(FILE *a1, unsigned char *a2, char **a3)
{
  if (fseek(a1, 0, 0)) {
    return 8565;
  }
  __int16 v15 = 0;
  unint64_t v12 = 0;
  if ((char)a2[23] >= 0) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = *(unsigned char **)a2;
  }
  uint64_t v6 = BinSerializer_fgetBlobInfo(a1, v8, &v16, &v15, &v14, &v13, &v12);
  if ((v6 & 0x80) != 0)
  {
    if (v15 != 3) {
      return 8565;
    }
    std::vector<float>::resize(a3, v12);
    uint64_t v10 = (float *)*a3;
    if ((char)a2[23] >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(unsigned char **)a2;
    }
    if (BinSerializer_freadInFloat(a1, v9, 0, &v10, &v11) != 128) {
      return 8565;
    }
  }
  return v6;
}

void std::vector<float>::resize(char **a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  std::string::size_type v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 2;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    uint64_t v19 = &v3[4 * a2];
    goto LABEL_15;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 2)
  {
    bzero(a1[1], 4 * v6);
    uint64_t v19 = &v4[4 * v6];
LABEL_15:
    a1[1] = v19;
    return;
  }
  if (a2 >> 62) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 1;
  if (v8 >> 1 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v10 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  size_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v10);
  unint64_t v12 = *a1;
  uint64_t v13 = a1[1];
  uint64_t v14 = &v11[4 * v5];
  uint64_t v16 = &v11[4 * v15];
  bzero(v14, 4 * v6);
  size_t v17 = &v14[4 * v6];
  while (v13 != v12)
  {
    int v18 = *((_DWORD *)v13 - 1);
    v13 -= 4;
    *((_DWORD *)v14 - 1) = v18;
    v14 -= 4;
  }
  *a1 = v14;
  a1[1] = v17;
  a1[2] = v16;
  if (v12)
  {
    operator delete(v12);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<float>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t vision::mod::compute1DAffineMapping(uint64_t a1, uint64_t a2, char **a3)
{
  std::string::basic_string[abi:ne180100]<0>(&v21, "a");
  if ((void *)(a1 + 8) == std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::find<std::string>(a1, &v21))
  {
    BOOL v6 = 1;
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, "b");
    BOOL v6 = a1 + 8 == (void)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::find<std::string>(a1, &__p);
    if (SHIBYTE(v20) < 0) {
      operator delete(__p);
    }
  }
  if (SHIBYTE(v23) < 0)
  {
    operator delete(v21);
    if (v6) {
      goto LABEL_7;
    }
  }
  else if (v6)
  {
LABEL_7:
    uint64_t v7 = -2;
    return (v7 + 128) | 0x2100;
  }
  uint64_t v9 = *(const float **)a2;
  uint64_t v8 = *(void *)(a2 + 8);
  std::string::basic_string[abi:ne180100]<0>(&__p, "a");
  uint64_t v10 = std::map<std::string,std::vector<float>>::at(a1, &__p);
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v21, *(const void **)v10, *(void *)(v10 + 8), (uint64_t)(*(void *)(v10 + 8) - *(void *)v10) >> 2);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p);
  }
  std::string::basic_string[abi:ne180100]<0>(v16, "b");
  uint64_t v11 = std::map<std::string,std::vector<float>>::at(a1, v16);
  std::string __p = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)v11, *(void *)(v11 + 8), (uint64_t)(*(void *)(v11 + 8) - *(void *)v11) >> 2);
  unint64_t __N = (v8 - (uint64_t)v9) >> 2;
  if (v17 < 0) {
    operator delete(v16[0]);
  }
  uint64_t v13 = (float *)v21;
  uint64_t v14 = (float *)__p;
  if (__N != (v22 - (uint64_t)v21) >> 2 || __N != (v19 - (uint64_t)__p) >> 2)
  {
    uint64_t v7 = -4;
    if (!__p) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  std::vector<float>::resize(a3, __N);
  vDSP_vma(*(const float **)a2, 1, v13, 1, v14, 1, (float *)*a3, 1, __N);
  uint64_t v7 = 0;
  if (v14) {
LABEL_18:
  }
    operator delete(v14);
LABEL_19:
  if (v13) {
    operator delete(v13);
  }
  return (v7 + 128) | 0x2100;
}

void sub_1A3E6DDC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (v28) {
    operator delete(v28);
  }
  if (v27) {
    operator delete(v27);
  }
  _Unwind_Resume(exception_object);
}

void *std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::find<std::string>(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  unint64_t v5 = (void *)(a1 + 8);
  do
  {
    char v6 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v3 + 4, a2);
    if (v6 >= 0) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (v6 >= 0) {
      unint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || (std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) != 0)
  {
    return v2;
  }
  return v5;
}

uint64_t std::map<std::string,std::vector<float>>::at(uint64_t a1, void *a2)
{
  uint64_t v2 = *std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>(a1, &v4, a2);
  if (!v2) {
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  }
  return v2 + 56;
}

void *std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    char v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3E6DF5C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::readParameters1DLogisticMapping(FILE *a1, const char *a2, uint64_t a3)
{
  memset(&v23, 0, sizeof(v23));
  if (!a1) {
    return 8573;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "a");
  v20[0] = &__p;
  char v6 = std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)v20);
  size_t v8 = (void *)v6 + 7;
  uint64_t v7 = (void *)*((void *)v6 + 7);
  if (v7)
  {
    *((void *)v6 + 8) = v7;
    operator delete(v7);
    *size_t v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
  }
  *size_t v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  vision::mod::formCompoundID(&__p, a2, "a");
  std::string v23 = __p;
  int v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  uint64_t v10 = (void *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v11 = &v23;
  }
  else {
    uint64_t v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v11);
  std::string::basic_string[abi:ne180100]<0>(v20, "a");
  uint64_t v24 = v20;
  unint64_t v12 = (char **)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, v20, (_OWORD **)&v24);
  uint64_t v13 = vision::mod::loadFloat32Vector(a1, &__p, v12 + 7);
  if (v21 < 0) {
    operator delete(v20[0]);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v13 & 0x80) == 0) {
      goto LABEL_28;
    }
LABEL_16:
    std::string::basic_string[abi:ne180100]<0>(&__p, "b");
    v20[0] = &__p;
    uint64_t v14 = std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)v20);
    uint64_t v16 = (void *)v14 + 7;
    uint64_t v15 = (void *)*((void *)v14 + 7);
    if (v15)
    {
      *((void *)v14 + 8) = v15;
      operator delete(v15);
      void *v16 = 0;
      v16[1] = 0;
      v16[2] = 0;
    }
    void *v16 = 0;
    v16[1] = 0;
    v16[2] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    vision::mod::formCompoundID(&__p, a2, "b");
    if (v9 < 0) {
      operator delete(v10);
    }
    std::string v23 = __p;
    uint64_t v10 = (void *)__p.__r_.__value_.__r.__words[0];
    int v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v17 = &v23;
    }
    else {
      char v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v17);
    std::string::basic_string[abi:ne180100]<0>(v20, "b");
    uint64_t v24 = v20;
    int v18 = (char **)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, v20, (_OWORD **)&v24);
    uint64_t v13 = vision::mod::loadFloat32Vector(a1, &__p, v18 + 7);
    if (v21 < 0) {
      operator delete(v20[0]);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v9 & 0x80000000) == 0) {
        return v13;
      }
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  if ((v13 & 0x80) != 0) {
    goto LABEL_16;
  }
LABEL_28:
  if (v9 < 0) {
LABEL_29:
  }
    operator delete(v10);
  return v13;
}

void sub_1A3E6E1F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (v21 < 0) {
    operator delete(v20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::compute1DLogisticMapping(uint64_t a1, uint64_t a2, char **a3)
{
  std::string::basic_string[abi:ne180100]<0>(v19, "a");
  if ((void *)(a1 + 8) == std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::find<std::string>(a1, v19))
  {
    BOOL v6 = 1;
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "b");
    BOOL v6 = a1 + 8 == (void)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::find<std::string>(a1, __p);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
  }
  if (v20 < 0)
  {
    operator delete(v19[0]);
    if (v6) {
      return 8574;
    }
  }
  else if (v6)
  {
    return 8574;
  }
  uint64_t v7 = vision::mod::compute1DAffineMapping(a1, a2, a3);
  if ((v7 & 0x80) != 0)
  {
    int v9 = a3;
    size_t v8 = *a3;
    uint64_t v10 = v9[1] - v8;
    if (v10)
    {
      unint64_t v11 = v10 >> 2;
      if (v11 <= 1) {
        uint64_t v12 = 1;
      }
      else {
        uint64_t v12 = v11;
      }
      do
      {
        float v13 = *(float *)v8;
        if (*(float *)v8 >= 0.0)
        {
          float v14 = expf(-v13);
          float v15 = 1.0;
        }
        else
        {
          float v14 = expf(v13);
          float v15 = v14;
        }
        *(float *)size_t v8 = v15 / (float)(v14 + 1.0);
        v8 += 4;
        --v12;
      }
      while (v12);
    }
  }
  return v7;
}

void sub_1A3E6E3A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::readParameters1DPairwiseAffineMapping(FILE *a1, const char *a2, uint64_t a3)
{
  memset(&v33, 0, sizeof(v33));
  if (!a1) {
    return 8573;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "a1");
  v30[0] = &__p;
  BOOL v6 = std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)v30);
  size_t v8 = (void *)v6 + 7;
  uint64_t v7 = (void *)*((void *)v6 + 7);
  if (v7)
  {
    *((void *)v6 + 8) = v7;
    operator delete(v7);
    *size_t v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
  }
  *size_t v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  vision::mod::formCompoundID(&__p, a2, "a1");
  std::string v33 = __p;
  int v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  uint64_t v10 = (void *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v11 = &v33;
  }
  else {
    unint64_t v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v11);
  std::string::basic_string[abi:ne180100]<0>(v30, "a1");
  unint64_t v34 = v30;
  uint64_t v12 = (char **)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, v30, (_OWORD **)&v34);
  uint64_t v13 = vision::mod::loadFloat32Vector(a1, &__p, v12 + 7);
  if (v31 < 0) {
    operator delete(v30[0]);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v13 & 0x80) == 0) {
      goto LABEL_59;
    }
  }
  else if ((v13 & 0x80) == 0)
  {
    goto LABEL_59;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "a2");
  v30[0] = &__p;
  float v14 = std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)v30);
  uint64_t v16 = (void *)v14 + 7;
  float v15 = (void *)*((void *)v14 + 7);
  if (v15)
  {
    *((void *)v14 + 8) = v15;
    operator delete(v15);
    void *v16 = 0;
    v16[1] = 0;
    v16[2] = 0;
  }
  void *v16 = 0;
  v16[1] = 0;
  v16[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  vision::mod::formCompoundID(&__p, a2, "a2");
  if (v9 < 0) {
    operator delete(v10);
  }
  std::string v33 = __p;
  uint64_t v10 = (void *)__p.__r_.__value_.__r.__words[0];
  int v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v17 = &v33;
  }
  else {
    char v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v17);
  std::string::basic_string[abi:ne180100]<0>(v30, "a2");
  unint64_t v34 = v30;
  char v18 = (char **)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, v30, (_OWORD **)&v34);
  uint64_t v13 = vision::mod::loadFloat32Vector(a1, &__p, v18 + 7);
  if (v31 < 0) {
    operator delete(v30[0]);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v13 & 0x80) == 0) {
      goto LABEL_59;
    }
  }
  else if ((v13 & 0x80) == 0)
  {
    goto LABEL_59;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "b1");
  v30[0] = &__p;
  uint64_t v19 = std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)v30);
  int v21 = (void *)v19 + 7;
  char v20 = (void *)*((void *)v19 + 7);
  if (v20)
  {
    *((void *)v19 + 8) = v20;
    operator delete(v20);
    void *v21 = 0;
    v21[1] = 0;
    v21[2] = 0;
  }
  void *v21 = 0;
  v21[1] = 0;
  v21[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  vision::mod::formCompoundID(&__p, a2, "b1");
  if (v9 < 0) {
    operator delete(v10);
  }
  std::string v33 = __p;
  uint64_t v10 = (void *)__p.__r_.__value_.__r.__words[0];
  int v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v22 = &v33;
  }
  else {
    uint64_t v22 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v22);
  std::string::basic_string[abi:ne180100]<0>(v30, "b1");
  unint64_t v34 = v30;
  std::string v23 = (char **)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, v30, (_OWORD **)&v34);
  uint64_t v13 = vision::mod::loadFloat32Vector(a1, &__p, v23 + 7);
  if (v31 < 0) {
    operator delete(v30[0]);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v13 & 0x80) == 0) {
      goto LABEL_59;
    }
LABEL_46:
    std::string::basic_string[abi:ne180100]<0>(&__p, "b2");
    v30[0] = &__p;
    uint64_t v24 = std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, &__p, (_OWORD **)v30);
    uint64_t v26 = (void *)v24 + 7;
    uint64_t v25 = (void *)*((void *)v24 + 7);
    if (v25)
    {
      *((void *)v24 + 8) = v25;
      operator delete(v25);
      *uint64_t v26 = 0;
      v26[1] = 0;
      v26[2] = 0;
    }
    *uint64_t v26 = 0;
    v26[1] = 0;
    v26[2] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    vision::mod::formCompoundID(&__p, a2, "b2");
    if (v9 < 0) {
      operator delete(v10);
    }
    std::string v33 = __p;
    uint64_t v10 = (void *)__p.__r_.__value_.__r.__words[0];
    int v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v27 = &v33;
    }
    else {
      uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v27);
    std::string::basic_string[abi:ne180100]<0>(v30, "b2");
    unint64_t v34 = v30;
    uint64_t v28 = (char **)std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, v30, (_OWORD **)&v34);
    uint64_t v13 = vision::mod::loadFloat32Vector(a1, &__p, v28 + 7);
    if (v31 < 0) {
      operator delete(v30[0]);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    goto LABEL_59;
  }
  if ((v13 & 0x80) != 0) {
    goto LABEL_46;
  }
LABEL_59:
  if (v9 < 0) {
    operator delete(v10);
  }
  return v13;
}

void sub_1A3E6E850(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (v21 < 0) {
    operator delete(v20);
  }
  _Unwind_Resume(exception_object);
}

unint64_t vision::mod::getOutputSize1DPairwiseAffineMapping(unint64_t this)
{
  return this >> 1;
}

uint64_t vision::mod::compute1DPairwiseAffineMapping(uint64_t a1, _DWORD *a2, char **a3)
{
  if (((a2[2] - *a2) & 4) != 0) {
    return 8572;
  }
  std::string::basic_string[abi:ne180100]<0>(&v37, "a1");
  BOOL v6 = (void *)(a1 + 8);
  if ((void *)(a1 + 8) == std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::find<std::string>(a1, &v37))
  {
    BOOL v7 = 1;
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&v34, "b1");
    if (v6 == std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::find<std::string>(a1, &v34))
    {
      BOOL v7 = 1;
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(&v31, "a2");
      if (v6 == std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::find<std::string>(a1, &v31))
      {
        BOOL v7 = 1;
      }
      else
      {
        std::string::basic_string[abi:ne180100]<0>(&__p, "b2");
        BOOL v7 = v6 == std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::find<std::string>(a1, &__p);
        if (SHIBYTE(v30) < 0) {
          operator delete(__p);
        }
      }
      if (SHIBYTE(v33) < 0) {
        operator delete(v31);
      }
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(v34);
    }
  }
  if (SHIBYTE(v39) < 0)
  {
    operator delete(v37);
    if (v7) {
      return 8574;
    }
  }
  else if (v7)
  {
    return 8574;
  }
  uint64_t v10 = *(void *)a2;
  uint64_t v9 = *((void *)a2 + 1);
  std::string::basic_string[abi:ne180100]<0>(&v34, "a1");
  uint64_t v11 = std::map<std::string,std::vector<float>>::at(a1, &v34);
  unint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v37, *(const void **)v11, *(void *)(v11 + 8), (uint64_t)(*(void *)(v11 + 8) - *(void *)v11) >> 2);
  if (SHIBYTE(v36) < 0) {
    operator delete(v34);
  }
  std::string::basic_string[abi:ne180100]<0>(&v31, "b1");
  uint64_t v12 = std::map<std::string,std::vector<float>>::at(a1, &v31);
  unint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v34, *(const void **)v12, *(void *)(v12 + 8), (uint64_t)(*(void *)(v12 + 8) - *(void *)v12) >> 2);
  if (SHIBYTE(v33) < 0) {
    operator delete(v31);
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "a2");
  uint64_t v13 = std::map<std::string,std::vector<float>>::at(a1, &__p);
  char v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v31, *(const void **)v13, *(void *)(v13 + 8), (uint64_t)(*(void *)(v13 + 8) - *(void *)v13) >> 2);
  if (SHIBYTE(v30) < 0) {
    operator delete(__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__D, "b2");
  uint64_t v14 = std::map<std::string,std::vector<float>>::at(a1, __D);
  std::string __p = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)v14, *(void *)(v14 + 8), (uint64_t)(*(void *)(v14 + 8) - *(void *)v14) >> 2);
  unint64_t __N = (unint64_t)((v9 - v10) >> 2) >> 1;
  if (v27 < 0) {
    operator delete(__D[0]);
  }
  uint64_t v16 = (float *)v37;
  if (__N == (v38 - (uint64_t)v37) >> 2
    && (char v17 = (const float *)v34, __N == (v35 - (uint64_t)v34) >> 2)
    && (char v18 = (const float *)v31, __N == (v32 - (uint64_t)v31) >> 2)
    && (uint64_t v19 = (const float *)__p, __N == (v29 - (uint64_t)__p) >> 2))
  {
    std::vector<float>::resize(a3, __N);
    std::vector<float>::vector(__D, __N);
    std::vector<float>::vector(v25, __N);
    char v20 = *(const float **)a2;
    int v21 = __D[0];
    uint64_t v22 = (float *)v25[0];
    std::string v23 = *a3;
    vDSP_vma(v20, 2, v16, 1, v17, 1, __D[0], 1, __N);
    vDSP_vma(v20 + 1, 2, v18, 1, v19, 1, v22, 1, __N);
    vDSP_vadd(v21, 1, v22, 1, (float *)v23, 1, __N);
    if (v25[0])
    {
      v25[1] = v25[0];
      operator delete(v25[0]);
    }
    if (__D[0])
    {
      __D[1] = __D[0];
      operator delete(__D[0]);
    }
    uint64_t v8 = 8576;
  }
  else
  {
    uint64_t v8 = 8572;
  }
  if (__p) {
    operator delete(__p);
  }
  if (v31) {
    operator delete(v31);
  }
  if (v34) {
    operator delete(v34);
  }
  if (v16) {
    operator delete(v16);
  }
  return v8;
}

void sub_1A3E6ECDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (__p)
  {
    operator delete(__p);
    if (!v38)
    {
LABEL_3:
      if (!v37)
      {
LABEL_8:
        if (a32) {
          operator delete(a32);
        }
        unint64_t v41 = *(void **)(v39 - 104);
        if (v41) {
          operator delete(v41);
        }
        _Unwind_Resume(exception_object);
      }
LABEL_7:
      operator delete(v37);
      goto LABEL_8;
    }
  }
  else if (!v38)
  {
    goto LABEL_3;
  }
  operator delete(v38);
  if (!v37) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void sub_1A3E6EE00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    JUMPOUT(0x1A3E6EDF4);
  }
  JUMPOUT(0x1A3E6EDF8);
}

uint64_t *std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(uint64_t a1, unint64_t a2, int a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  unint64_t v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (__n128 result = *v5; result; __n128 result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }
      else
      {
        v7 &= a2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(float *a1, int a2, int a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = operator new(0x18uLL);
  *uint64_t v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = a3;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v19 = operator new(8 * *(void *)&prime);
          char v20 = *(void **)a1;
          *(void *)a1 = v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          uint64_t v22 = (void *)*((void *)a1 + 2);
          if (v22)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v23) = a1 + 4;
            uint64_t v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v29))
                  {
                    *(void *)(*(void *)a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  void *v22 = *v28;
                  *uint64_t v28 = **(void **)(*(void *)a1 + 8 * v29);
                  **(void **)(*(void *)a1 + 8 * v29) = v28;
                  uint64_t v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                uint64_t v22 = v28;
                uint64_t v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v30 = *(void **)a1;
  char v31 = *(void **)(*(void *)a1 + 8 * v3);
  if (v31)
  {
    *uint64_t v12 = *v31;
LABEL_72:
    *char v31 = v12;
    goto LABEL_73;
  }
  *uint64_t v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v30[v3] = a1 + 4;
  if (*v12)
  {
    unint64_t v32 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    char v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
}

void sub_1A3E6F290(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n, const std::vector<int>::value_type *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    std::vector<int>::pointer end = this->__end_;
    unint64_t v7 = &end[__n];
    std::vector<int>::size_type v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_1A3E6F30C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(float *a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      int8x8_t prime = (int8x8_t)v16;
    }
    else {
      int8x8_t prime = (int8x8_t)v15;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          char v18 = operator new(8 * *(void *)&prime);
          uint64_t v19 = *(void **)a1;
          *(void *)a1 = v18;
          if (v19) {
            operator delete(v19);
          }
          uint64_t v20 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v20++) = 0;
          while (*(void *)&prime != v20);
          uint64_t v21 = (void *)*((void *)a1 + 2);
          if (v21)
          {
            unint64_t v22 = v21[1];
            uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(void *)&prime) {
                v22 %= *(void *)&prime;
              }
            }
            else
            {
              v22 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
            uint64_t v27 = (void *)*v21;
            if (*v21)
            {
              do
              {
                unint64_t v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(void *)&prime) {
                    v28 %= *(void *)&prime;
                  }
                }
                else
                {
                  v28 &= *(void *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v28))
                  {
                    *(void *)(*(void *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  void *v21 = *v27;
                  *uint64_t v27 = **(void **)(*(void *)a1 + 8 * v28);
                  **(void **)(*(void *)a1 + 8 * v28) = v27;
                  uint64_t v27 = v21;
                }
                unint64_t v28 = v22;
LABEL_55:
                uint64_t v21 = v27;
                uint64_t v27 = (void *)*v27;
                unint64_t v22 = v28;
              }
              while (v27);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  unint64_t v29 = *(void **)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * v3);
  if (v30)
  {
    void *v10 = *v30;
LABEL_72:
    *uint64_t v30 = v10;
    goto LABEL_73;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v3] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7) {
        v31 %= v7;
      }
    }
    else
    {
      v31 &= v7 - 1;
    }
    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A3E6F700(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<int,std::pair<int,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(float *a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x20uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *(void *)((char *)v10 + 20) = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      int8x8_t prime = (int8x8_t)v16;
    }
    else {
      int8x8_t prime = (int8x8_t)v15;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          char v18 = operator new(8 * *(void *)&prime);
          uint64_t v19 = *(void **)a1;
          *(void *)a1 = v18;
          if (v19) {
            operator delete(v19);
          }
          uint64_t v20 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v20++) = 0;
          while (*(void *)&prime != v20);
          uint64_t v21 = (void *)*((void *)a1 + 2);
          if (v21)
          {
            unint64_t v22 = v21[1];
            uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(void *)&prime) {
                v22 %= *(void *)&prime;
              }
            }
            else
            {
              v22 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
            uint64_t v27 = (void *)*v21;
            if (*v21)
            {
              do
              {
                unint64_t v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(void *)&prime) {
                    v28 %= *(void *)&prime;
                  }
                }
                else
                {
                  v28 &= *(void *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v28))
                  {
                    *(void *)(*(void *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  void *v21 = *v27;
                  *uint64_t v27 = **(void **)(*(void *)a1 + 8 * v28);
                  **(void **)(*(void *)a1 + 8 * v28) = v27;
                  uint64_t v27 = v21;
                }
                unint64_t v28 = v22;
LABEL_55:
                uint64_t v21 = v27;
                uint64_t v27 = (void *)*v27;
                unint64_t v22 = v28;
              }
              while (v27);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  unint64_t v29 = *(void **)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * v3);
  if (v30)
  {
    void *v10 = *v30;
LABEL_72:
    *uint64_t v30 = v10;
    goto LABEL_73;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v3] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7) {
        v31 %= v7;
      }
    }
    else
    {
      v31 &= v7 - 1;
    }
    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A3E6FAF0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(float *a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      int8x8_t prime = (int8x8_t)v16;
    }
    else {
      int8x8_t prime = (int8x8_t)v15;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          char v18 = operator new(8 * *(void *)&prime);
          uint64_t v19 = *(void **)a1;
          *(void *)a1 = v18;
          if (v19) {
            operator delete(v19);
          }
          uint64_t v20 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v20++) = 0;
          while (*(void *)&prime != v20);
          uint64_t v21 = (void *)*((void *)a1 + 2);
          if (v21)
          {
            unint64_t v22 = v21[1];
            uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(void *)&prime) {
                v22 %= *(void *)&prime;
              }
            }
            else
            {
              v22 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
            uint64_t v27 = (void *)*v21;
            if (*v21)
            {
              do
              {
                unint64_t v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(void *)&prime) {
                    v28 %= *(void *)&prime;
                  }
                }
                else
                {
                  v28 &= *(void *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v28))
                  {
                    *(void *)(*(void *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  void *v21 = *v27;
                  *uint64_t v27 = **(void **)(*(void *)a1 + 8 * v28);
                  **(void **)(*(void *)a1 + 8 * v28) = v27;
                  uint64_t v27 = v21;
                }
                unint64_t v28 = v22;
LABEL_55:
                uint64_t v21 = v27;
                uint64_t v27 = (void *)*v27;
                unint64_t v22 = v28;
              }
              while (v27);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  unint64_t v29 = *(void **)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * v3);
  if (v30)
  {
    void *v10 = *v30;
LABEL_72:
    *uint64_t v30 = v10;
    goto LABEL_73;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v3] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7) {
        v31 %= v7;
      }
    }
    else
    {
      v31 &= v7 - 1;
    }
    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A3E6FF28(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<int,std::unordered_set<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  float v12 = (void *)(a1 + 16);
  float v13 = (char *)operator new(0x40uLL);
  v35[0] = v13;
  v35[1] = a1 + 16;
  *(void *)float v13 = 0;
  *((void *)v13 + 1) = v6;
  *((_DWORD *)v13 + 4) = *a3;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *((_DWORD *)v13 + 14) = 1065353216;
  char v36 = 1;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      int8x8_t prime = (int8x8_t)v18;
    }
    else {
      int8x8_t prime = (int8x8_t)v17;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (*(void *)&prime <= v26) {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *(void *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v20 = operator new(8 * *(void *)&prime);
          uint64_t v21 = *(void **)a1;
          *(void *)a1 = v20;
          if (v21) {
            operator delete(v21);
          }
          uint64_t v22 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v22++) = 0;
          while (*(void *)&prime != v22);
          uint8x8_t v23 = (void *)*v12;
          if (*v12)
          {
            unint64_t v24 = v23[1];
            uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(void *)&prime) {
                v24 %= *(void *)&prime;
              }
            }
            else
            {
              v24 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v24) = v12;
            unint64_t v29 = (void *)*v23;
            if (*v23)
            {
              do
              {
                unint64_t v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(void *)&prime) {
                    v30 %= *(void *)&prime;
                  }
                }
                else
                {
                  v30 &= *(void *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v30))
                  {
                    *(void *)(*(void *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *uint8x8_t v23 = *v29;
                  *unint64_t v29 = **(void **)(*(void *)a1 + 8 * v30);
                  **(void **)(*(void *)a1 + 8 * v30) = v29;
                  unint64_t v29 = v23;
                }
                unint64_t v30 = v24;
LABEL_55:
                uint8x8_t v23 = v29;
                unint64_t v29 = (void *)*v29;
                unint64_t v24 = v30;
              }
              while (v29);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        unint64_t v34 = *(void **)a1;
        *(void *)a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  unint64_t v31 = *(void **)(*(void *)a1 + 8 * v3);
  uint64_t i = (uint64_t *)v35[0];
  if (v31)
  {
    *(void *)v35[0] = *v31;
LABEL_72:
    *unint64_t v31 = i;
    goto LABEL_73;
  }
  *(void *)v35[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(*(void *)a1 + 8 * v3) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    unint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  v35[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>>>>::reset[abi:ne180100]((uint64_t)v35);
  return i;
}

void sub_1A3E70350(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>(void *a1, int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  unint64_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (__n128 result = *v5; result; __n128 result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<int,std::unordered_set<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_set<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_set<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_set<int>>>>::~__hash_table(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint8x8_t v3 = (void *)*v2;
      std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)v1 + 24);
    }
    operator delete(v1);
  }
}

char *__assign_helper_atomic_property_(char *result, uint64_t a2)
{
  if (result != (char *)a2) {
    return std::vector<CGPoint>::__assign_with_size[abi:ne180100]<CGPoint*,CGPoint*>(result, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  }
  return result;
}

char *std::vector<CGPoint>::__assign_with_size[abi:ne180100]<CGPoint*,CGPoint*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *unint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<vision::mod::DescriptorItemSideInfo>::__vallocate[abi:ne180100](v7, v11);
    float v13 = (char *)v7[1];
    float v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  float v12 = (void **)(result + 8);
  float v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  BOOL v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *float v12 = &v9[v17];
  return result;
}

void *__copy_helper_atomic_property_(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
}

void *std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    __n128 result = std::vector<vision::mod::DescriptorItemSideInfo>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3E7070C(_Unwind_Exception *exception_object)
{
  uint8x8_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3E7098C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E70A28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E70B58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E70BF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E70D8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E70F50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E70FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E71008(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E71134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E713AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E71580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E718A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E719F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E71BD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E71CD8(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3E7203C(_Unwind_Exception *a1)
{
  unint64_t v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A3E72548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,void *a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,id a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,id a54)
{
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose(&a43, 8);

  _Block_object_dispose(&a49, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__1981(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1982(uint64_t a1)
{
}

NSError *_vnErrorForError(NSError *a1, VNRequest *a2)
{
  uint8x8_t v3 = a1;
  unint64_t v4 = a2;
  unint64_t v5 = [(NSError *)v3 domain];
  if ([v5 isEqualToString:*MEMORY[0x1E4FAF088]])
  {
    uint64_t v6 = [(NSError *)v3 code];
    if (v6 == -4)
    {
      uint64_t v7 = +[VNError errorForUnsupportedRevision:[(VNRequest *)v4 revision] ofRequest:v4];
    }
    else if (v6 == -3)
    {
      uint64_t v7 = +[VNError errorForCancellationOfRequest:v4];
    }
    else
    {
      if (v6 == -2) {
        +[VNError errorWithCode:2 message:@"VNRecognizeTextRequest error - invalid orientation"];
      }
      else {
      uint64_t v7 = +[VNError errorWithCode:11 message:@"VNRecognizeTextRequest produced an internal error" underlyingError:v3];
      }
    }
  }
  else
  {
    uint64_t v7 = v3;
  }
  size_t v8 = v7;

  return v8;
}

void sub_1A3E72818(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E72A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E72B38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E72F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1A3E73170(_Unwind_Exception *a1)
{
  uint64_t v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A3E73228(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E73588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(__CVBuffer **this)
{
  unint64_t v2 = *this;
  if (v2)
  {
    CVPixelBufferRelease(v2);
    *this = 0;
  }
}

uint64_t __Block_byref_object_copy__2064(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2065(uint64_t a1)
{
}

void sub_1A3E738B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E73A0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E73B14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E73D54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E73FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3E741AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E743A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

float apple::vision::libraries::autotrace::BitString::writeBit(apple::vision::libraries::autotrace::BitString *this, int a2)
{
  unint64_t v4 = *((int *)this + 7);
  unint64_t v6 = *(void *)this;
  unint64_t v5 = (unsigned char *)*((void *)this + 1);
  uint64_t v7 = &v5[-*(void *)this];
  if ((unint64_t)v7 <= v4)
  {
    unint64_t v8 = *((void *)this + 2);
    if ((unint64_t)v5 >= v8)
    {
      unint64_t v10 = (unint64_t)(v7 + 1);
      if ((uint64_t)(v7 + 1) < 0) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v11 = v8 - v6;
      if (2 * v11 > v10) {
        unint64_t v10 = 2 * v11;
      }
      if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v12 = v10;
      }
      if (v12) {
        float v13 = operator new(v12);
      }
      else {
        float v13 = 0;
      }
      float v14 = &v13[v12];
      v7[(void)v13] = 0;
      uint64_t v9 = (uint64_t)&v7[(void)v13 + 1];
      if (v5 == (unsigned char *)v6)
      {
        float v13 = &v7[(void)v13];
      }
      else
      {
        unint64_t v15 = &v5[~v6];
        do
        {
          char v16 = *--v5;
          (v15--)[(void)v13] = v16;
        }
        while (v5 != (unsigned char *)v6);
        unint64_t v5 = *(unsigned char **)this;
      }
      *(void *)this = v13;
      *((void *)this + 1) = v9;
      *((void *)this + 2) = v14;
      if (v5) {
        operator delete(v5);
      }
    }
    else
    {
      *unint64_t v5 = 0;
      uint64_t v9 = (uint64_t)(v5 + 1);
    }
    *((void *)this + 1) = v9;
    unint64_t v6 = *(void *)this;
    unint64_t v4 = *((int *)this + 7);
  }
  int v17 = 1 << *((_DWORD *)this + 8);
  char v18 = *(unsigned char *)(v6 + v4);
  char v19 = v18 & ~(_BYTE)v17;
  char v20 = v18 | v17;
  if (a2 != 1) {
    char v20 = v19;
  }
  *(unsigned char *)(v6 + v4) = v20;
  ++*((_DWORD *)this + 6);
  int32x2_t v21 = vadd_s32(*(int32x2_t *)((char *)this + 32), (int32x2_t)0x100000001);
  *((int32x2_t *)this + 4) = v21;
  if (v21.i32[0] == 8) {
    *(void *)((char *)this + 28) = (*((_DWORD *)this + 7) + 1);
  }
  return *(float *)v21.i32;
}

void sub_1A3E748C4(_Unwind_Exception *a1)
{
  uint64_t v7 = v6;

  _Unwind_Resume(a1);
}

void sub_1A3E74A1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E74DB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t ctrTrackerComputation_updateHistory(CVPixelBufferRef pixelBuffer, uint64_t *a2, char a3, float *a4, float64x2_t a5, float64x2_t a6)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 6784;
  }
  float64x2_t v8 = vsubq_f64(a6, a5);
  float64x2_t v9 = vaddq_f64(a6, a5);
  __asm { FMOV            V1.2D, #0.5 }
  float64x2_t v15 = vmulq_f64(v9, _Q1);
  float64x2_t v16 = vmulq_f64(vmulq_f64(v8, (float64x2_t)vdupq_n_s64(0x40047AE140000000uLL)), _Q1);
  float64x2_t v48 = vsubq_f64(v15, v16);
  float64x2_t v49 = v48;
  float64_t v50 = v48.f64[0];
  float64x2_t v47 = vaddq_f64(v15, v16);
  int8x16_t v51 = vextq_s8((int8x16_t)v47, (int8x16_t)v47, 8uLL);
  int8x16_t v52 = v51;
  float64_t v53 = v48.f64[1];
  uint64_t v17 = a2[2];
  uint64_t result = tplTrackerResampler_setImage(a2[3], pixelBuffer, v49.f64);
  if (result == 128)
  {
    char v19 = (int *)(v17 + 250168);
    float64x2_t v20 = vsubq_f64(v47, v48);
    float64_t v21 = v20.f64[0] / 127.0;
    *(float *)v20.f64 = v20.f64[1] / 127.0;
    float v22 = v21;
    tplTrackerResampler_resample(a2[3], v49.f64, 0x80u, 128, a2[2], (unsigned char *)(a2[2] + 0x4000), (unsigned char *)(a2[2] + 0x8000), v19, *(float *)v20.f64, v22);
    if (*v19 > 0 || v19[1] > 0 || v19[2] < 127 || v19[3] <= 126) {
      ctrTrackerComputation_repairNonValidRegion(a2[2], a2[2] + 0x4000, a2[2] + 0x8000, v19);
    }
    ctrTrackerComputation_YCbCr2nRGB(a2[2], a2[2] + 0x4000, a2[2] + 0x8000, a2[2] + 49152, a2[2] + 0x10000, a2[2] + 81920);
    ctrTrackerComputation_normedGradient(a2[2] + 49152, a2[2] + 0x10000, a2[2] + 81920, a2[2] + 98304);
    uint64_t v23 = a2[2];
    uint64_t result = ctrTrackerAlgorithm_computeFFTx(v23 + 49152, v23 + 0x10000, v23 + 81920, v23 + 98304, *(void *)(a2[4] + 65624), (DSPComplex *)(v23 + 114856), (DSPSplitComplex *)(v23 + 245928), *(OpaqueFFTSetup **)(v23 + 250200));
    if (result == 128)
    {
      uint64_t v24 = a2[2];
      uint64_t result = ctrTrackerAlgorithm_GaussianCorrelation(v24 + 245928, v24 + 245928, (DSPSplitComplex *)(v24 + 245992), (const DSPSplitComplex *)(v24 + 246024), (DSPComplex *)(v24 + 114856), (char *)(v24 + 180392), *(OpaqueFFTSetup **)(v24 + 250200));
      if (result == 128)
      {
        uint64_t result = ctrTrackerAlgorithm_packedDivision((float **)(a2[2] + 245992), (float **)(a2[4] + 65632), (float **)(a2[2] + 246008));
        if (result == 128)
        {
          uint64_t v25 = 0;
          uint64_t v26 = a2[2];
          uint64_t v27 = *a2;
          float v28 = *a4 * 0.08;
          float v29 = 1.0 - v28;
          uint64_t v30 = *(void *)(*a2 + 2112);
          uint64_t v31 = *(void *)(*a2 + 2120);
          uint64_t v32 = *(void *)(v26 + 246008);
          uint64_t v33 = *(void *)(v26 + 246016);
          do
          {
            *(float *)(v30 + v25) = (float)(*(float *)(v32 + v25) * v28) + (float)(v29 * *(float *)(v30 + v25));
            *(float *)(v31 + v25) = (float)(*(float *)(v33 + v25) * v28) + (float)(v29 * *(float *)(v31 + v25));
            v25 += 4;
          }
          while (v25 != 0x8000);
          for (uint64_t i = 0; i != 4; ++i)
          {
            uint64_t v35 = 0;
            uint64_t v36 = v27 + 16 * i;
            float v37 = *a4 * 0.08;
            float v38 = 1.0 - v37;
            uint64_t v39 = *(void *)(v36 + 2048);
            uint64_t v40 = *(void *)(v36 + 2056);
            uint64_t v41 = *(void *)(v26 + 16 * i + 245928);
            uint64_t v42 = *(void *)(v26 + 16 * i + 245936);
            do
            {
              *(float *)(v39 + v35) = (float)(*(float *)(v41 + v35) * v37) + (float)(v38 * *(float *)(v39 + v35));
              *(float *)(v40 + v35) = (float)(*(float *)(v42 + v35) * v37) + (float)(v38 * *(float *)(v40 + v35));
              v35 += 4;
            }
            while (v35 != 0x8000);
          }
          ctrTrackerComputation_colorHistogram(v26 + 49152, v26 + 0x10000, v26 + 81920, (char *)(v26 + 248120), (char *)(v26 + 249144));
          uint64_t v43 = *a2;
          uint64_t v44 = (float *)(a2[2] + 248120);
          uint64_t v45 = -1024;
          uint64_t result = 6784;
          do
          {
            uint64_t v46 = v43 + v45;
            *(float *)(v46 + 1024) = (float)(*v44 * 0.05) + (float)(*(float *)(v43 + v45 + 1024) * 0.95);
            *(float *)(v46 + 2048) = (float)(v44[256] * 0.05) + (float)(*(float *)(v43 + v45 + 2048) * 0.95);
            ++v44;
            v45 += 4;
          }
          while (v45);
        }
      }
    }
  }
  return result;
}

uint64_t FastRegistration_allocateSignatureBuffersForImageDimension(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    *(void *)(a1 + 64) = 0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(void *)(a1 + 40) = a2;
    *(void *)(a1 + 8) = a3;
    int v4 = (4 * a2 + 31) & 0xFFFFFFE0;
    int v5 = (4 * a3 + 31) & 0xFFFFFFE0;
    int v6 = (4 * a2 + 35) & 0xFFFFFFE0;
    int v7 = (4 * a3 + 35) & 0xFFFFFFE0;
    float64x2_t v8 = (char *)malloc_type_calloc(1uLL, v5 + v4 + 2 * (v7 + v6), 0x955E7161uLL);
    if (v8)
    {
      float64x2_t v9 = &v8[v4];
      *(void *)a1 = v9;
      unint64_t v10 = &v9[v5];
      unint64_t v11 = &v10[v7];
      *(void *)(a1 + 16) = v10;
      *(void *)(a1 + 24) = v11;
      *(void *)(a1 + 32) = v8;
      size_t v12 = &v11[v7];
      *(void *)(a1 + 48) = v12;
      *(void *)(a1 + 56) = &v12[v6];
      *(void *)(a1 + 64) = v8;
      float v13 = &CVML_status_ok;
    }
    else
    {
      float v13 = &CVML_status_memoryAllocationError;
    }
  }
  else
  {
    float v13 = &CVML_status_invalidParameter;
  }
  return (*v13 + 128) | 0x1200;
}

void sub_1A3E75424(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E754E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E755E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7566C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E757CC(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2198(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2199(uint64_t a1)
{
}

void sub_1A3E758CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E75968(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E75B70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  apple::vision::fgbg::ConnectedComponentResult::~ConnectedComponentResult(v12);

  _Unwind_Resume(a1);
}

void apple::vision::fgbg::ConnectedComponentResult::~ConnectedComponentResult(apple::vision::fgbg::ConnectedComponentResult *this)
{
  int v6 = (void **)((char *)this + 80);
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v6);
  unint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }
  uint8x8_t v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  int v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void *)this;
  *(void *)this = 0;
  if (v5) {
    MEMORY[0x1A62562A0](v5, 0x1000C8000313F17);
  }
}

void sub_1A3E75F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16)
{
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<CGPoint>>::__construct_one_at_end[abi:ne180100]<std::vector<CGPoint> const&>(uint64_t a1, uint64_t a2)
{
  uint8x8_t v3 = *(void **)(a1 + 8);
  *uint8x8_t v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  uint64_t result = std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>(v3, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  *(void *)(a1 + 8) = v3 + 3;
  return result;
}

void sub_1A3E75FEC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<CGPoint>>::__push_back_slow_path<std::vector<CGPoint> const&>(void *a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  int v6 = a1 + 2;
  if (0x5555555555555556 * ((uint64_t)(a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((uint64_t)(a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[2] - *a1) >> 3) >= 0x555555555555555) {
    unint64_t v7 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v7 = v3;
  }
  float64x2_t v15 = v6;
  if (v7) {
    unint64_t v7 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v7);
  }
  else {
    uint64_t v8 = 0;
  }
  float64x2_t v9 = (void *)(v7 + 24 * v2);
  v12[0] = v7;
  v12[1] = v9;
  float v13 = v9;
  unint64_t v14 = v7 + 24 * v8;
  void *v9 = 0;
  v9[1] = 0;
  v9[2] = 0;
  std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>(v9, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  v13 += 3;
  std::vector<std::vector<CGPoint>>::__swap_out_circular_buffer(a1, v12);
  uint64_t v10 = a1[1];
  std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)v12);
  return v10;
}

void sub_1A3E760F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A3E762F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7659C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  apple::vision::fgbg::ConnectedComponentResult::~ConnectedComponentResult(v11);
  _Unwind_Resume(a1);
}

void sub_1A3E769B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3E76CC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E76E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E77630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29)
{
  _Unwind_Resume(a1);
}

void std::vector<std::vector<CGPoint>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<long long>>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void ___ZL33_categoryCocoNameForCategoryIndexi_block_invoke()
{
  v0 = (void *)_categoryCocoNameForCategoryIndex(int)::categoryNames;
  _categoryCocoNameForCategoryIndex(int)::categoryNames = (uint64_t)&unk_1EF7A7C70;
}

void ___ZL36_categoryMiyoshiNameForCategoryIndexi_block_invoke()
{
  v0 = (void *)_categoryMiyoshiNameForCategoryIndex(int)::categoryNames;
  _categoryMiyoshiNameForCategoryIndex(int)::categoryNames = (uint64_t)&unk_1EF7A7C58;
}

void sub_1A3E77C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  apple::vision::fgbg::ConnectedComponentResult::~ConnectedComponentResult((apple::vision::fgbg::ConnectedComponentResult *)va);
  _Unwind_Resume(a1);
}

void sub_1A3E77D9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  apple::vision::fgbg::ConnectedComponentResult::~ConnectedComponentResult(v11);
  _Unwind_Resume(a1);
}

void sub_1A3E77EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E77F44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7804C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78258(_Unwind_Exception *a1)
{
  int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3E78330(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78698(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E787F4(_Unwind_Exception *a1)
{
}

void sub_1A3E78990(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78A80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78AF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78BA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78C00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78C4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78CBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78D28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78EC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E78F90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E79150(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E79360(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7940C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E79558(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E795E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E79698(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::image_quality::BlurMeasure::computeEdgeBasedBlurScoreForPlanar8Image(vision::mod::image_quality::BlurMeasure *this, vImage_Buffer *a2, float *a3, float a4, int *a5, int *a6, void **a7)
{
  uint64_t v12 = *(void *)this;
  int v13 = *((_DWORD *)this + 4);
  int v14 = *((_DWORD *)this + 2);
  float64x2_t v15 = (int *)*((unsigned int *)this + 6);
  *(void *)&v25[4] = v12;
  int v24 = v14;
  *(_DWORD *)uint64_t v25 = v13;
  LODWORD(a2->data) = 1065353216;
  if (a6)
  {
    float64x2_t v20 = *(vision::mod::image_quality::BlurMeasure **)a6;
    int v21 = 0;
    int v22 = 0;
    float v19 = (float)v14;
    float v18 = (float)v13;
    return vision::mod::image_quality::BlurMeasure::computeEdgeBasedBlurForImageRegionUsingBlurSignature(v20, (float *)a2, *(_Geometry2D_rect2D_ *)&v21, a3, a4, a5, v17);
  }
  else
  {
    if ((result & 0x80) != 0)
    {
      return 2688;
    }
  }
  return result;
}

uint64_t anonymous namespace'::applyInsetFactorToData(_anonymous_namespace_ *this, unsigned __int8 **a2, int *a3, int *a4, int a5, float a6)
{
  int v6 = *a3;
  if (a6 > 0.0)
  {
    int v7 = (int)(float)((float)*(int *)a2 * a6);
    float v8 = (float)v6 * a6;
    *(_DWORD *)a2 -= 2 * v7;
    int v6 = *a3 - 2 * (int)v8;
    *a3 = v6;
    *(void *)this += v7 * a5 + (int)v8 * (int)a4;
  }
  if (*(int *)a2 >= 32 && v6 > 31) {
    return 2688;
  }
  syslog(5, "Both width and height have to be >= 32 after applying the inset factor. Given w/h: %d/%d", *(_DWORD *)a2, v6);
  return 2684;
}

uint64_t anonymous namespace'::computeBlockwiseBlurStatsOnData(uint64_t result, int a2, int a3, int a4, float *a5, int *a6, int *a7, void *a8)
{
  int v13 = a2;
  uint64_t v163 = result;
  v180[124] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = (a2 / 32);
  uint64_t v15 = (a3 / 32);
  if (a8)
  {
    uint64_t v17 = malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
    *uint64_t v17 = v13;
    v17[1] = a3;
    v17[2] = v14;
    v17[3] = v15;
    uint64_t result = (uint64_t)malloc_type_calloc((int)v15 * (int)v14, 0xCuLL, 0x10000403E1C8BA9uLL);
    *((void *)v17 + 2) = result;
    float v18 = v17;
    *a8 = v17;
  }
  else
  {
    float v18 = 0;
  }
  if (a3 < 32) {
    goto LABEL_24;
  }
  float v152 = a6;
  float v153 = a7;
  float v154 = a5;
  int v19 = 0;
  int v20 = 0;
  int v164 = 32 * a4;
  uint64_t v171 = v14;
  uint64_t v162 = (int)v14;
  uint64_t v21 = 3 * a4;
  uint64_t v22 = 5 * a4;
  int v23 = a4;
  uint64_t v24 = 8 * a4;
  uint64_t v161 = v163 - v23 + 8 * v23;
  uint64_t v160 = v163 + 6 * v23;
  int v25 = 0;
  uint64_t v159 = v163 + v22;
  uint64_t v157 = v163 + v21;
  uint64_t v158 = v163 + 4 * v23;
  uint64_t v26 = 0;
  uint64_t v156 = v163 + 2 * v23;
  uint64_t v155 = v163 + v23;
  int v166 = v13;
  uint64_t v165 = v15;
  float v170 = v18;
  do
  {
    int v168 = v25;
    uint64_t v167 = v26;
    if (v13 >= 32)
    {
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      uint64_t v29 = v161 + v25;
      uint64_t v30 = v160 + v25;
      uint64_t v31 = v159 + v25;
      uint64_t v32 = v158 + v25;
      uint64_t v33 = v157 + v25;
      uint64_t v34 = v156 + v25;
      uint64_t v35 = v155 + v25;
      uint64_t v169 = v26 * v162;
      uint64_t v36 = v163 + v25;
      do
      {
        int v173 = v19;
        int v174 = v20;
        unsigned int v37 = 0;
        int v176 = 0;
        uint64_t v175 = 0;
        float v38 = (int32x4_t *)v177;
        uint64_t v172 = v27;
        uint64_t v39 = v27;
        do
        {
          char v40 = 1;
          uint64_t v41 = v39;
          uint64_t v42 = v38;
          do
          {
            uint8x16_t v43 = *(uint8x16_t *)(v36 + v41);
            uint8x16_t v44 = *(uint8x16_t *)(v35 + v41);
            int16x8_t v45 = (int16x8_t)vaddl_u8(*(uint8x8_t *)v44.i8, *(uint8x8_t *)v43.i8);
            uint8x16_t v46 = *(uint8x16_t *)(v34 + v41);
            int16x8_t v47 = (int16x8_t)vaddl_high_u8(v44, v43);
            uint8x16_t v48 = *(uint8x16_t *)(v33 + v41);
            int16x8_t v49 = (int16x8_t)vaddl_u8(*(uint8x8_t *)v48.i8, *(uint8x8_t *)v46.i8);
            uint8x16_t v50 = *(uint8x16_t *)(v32 + v41);
            int16x8_t v51 = (int16x8_t)vaddl_high_u8(v48, v46);
            uint8x16_t v52 = *(uint8x16_t *)(v31 + v41);
            int16x8_t v53 = (int16x8_t)vaddl_u8(*(uint8x8_t *)v52.i8, *(uint8x8_t *)v50.i8);
            uint8x16_t v54 = *(uint8x16_t *)(v30 + v41);
            int16x8_t v55 = (int16x8_t)vaddl_high_u8(v52, v50);
            uint8x16_t v56 = *(uint8x16_t *)(v29 + v41);
            int16x8_t v57 = (int16x8_t)vaddl_u8(*(uint8x8_t *)v56.i8, *(uint8x8_t *)v54.i8);
            int16x8_t v58 = (int16x8_t)vaddl_high_u8(v56, v54);
            int16x8_t v59 = (int16x8_t)vsubl_u8(*(uint8x8_t *)v43.i8, *(uint8x8_t *)v44.i8);
            int16x8_t v60 = (int16x8_t)vsubl_high_u8(v43, v44);
            int16x8_t v61 = (int16x8_t)vsubl_u8(*(uint8x8_t *)v46.i8, *(uint8x8_t *)v48.i8);
            int16x8_t v62 = (int16x8_t)vsubl_high_u8(v46, v48);
            int16x8_t v63 = (int16x8_t)vsubl_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v52.i8);
            int16x8_t v64 = (int16x8_t)vsubl_high_u8(v50, v52);
            int16x8_t v65 = (int16x8_t)vsubl_u8(*(uint8x8_t *)v54.i8, *(uint8x8_t *)v56.i8);
            int16x8_t v66 = (int16x8_t)vsubl_high_u8(v54, v56);
            int16x8_t v67 = vaddq_s16(v49, v45);
            int16x8_t v68 = vaddq_s16(v51, v47);
            int16x8_t v69 = vaddq_s16(v57, v53);
            int16x8_t v70 = vaddq_s16(v58, v55);
            int16x8_t v71 = vsubq_s16(v45, v49);
            int16x8_t v72 = vsubq_s16(v47, v51);
            int16x8_t v73 = vsubq_s16(v53, v57);
            int16x8_t v74 = vsubq_s16(v55, v58);
            int16x8_t v75 = vaddq_s16(v69, v67);
            int16x8_t v76 = vaddq_s16(v70, v68);
            int16x8_t v77 = vsubq_s16(v67, v69);
            int16x8_t v78 = vsubq_s16(v68, v70);
            int16x8_t v79 = vuzp1q_s16(v75, v77);
            int16x8_t v80 = vuzp1q_s16(v71, v73);
            int16x8_t v81 = vuzp2q_s16(v71, v73);
            int16x8_t v82 = vuzp1q_s16(v59, v61);
            int16x8_t v83 = vuzp2q_s16(v59, v61);
            int16x8_t v84 = vuzp2q_s16(v75, v77);
            int16x8_t v85 = vuzp1q_s16(v63, v65);
            int16x8_t v86 = vuzp2q_s16(v63, v65);
            int16x8_t v87 = vaddq_s16(v80, v81);
            int16x8_t v88 = vaddq_s16(v82, v83);
            int16x8_t v89 = vaddq_s16(v85, v86);
            int16x8_t v90 = vaddq_s16(v79, v84);
            int8x16_t v91 = (int8x16_t)vsubq_s16(v79, v84);
            int8x16_t v92 = (int8x16_t)vsubq_s16(v80, v81);
            int8x16_t v93 = (int8x16_t)vsubq_s16(v82, v83);
            int8x16_t v94 = (int8x16_t)vsubq_s16(v85, v86);
            int16x8_t v95 = vuzp1q_s16(v90, v87);
            int16x8_t v96 = vuzp2q_s16(v90, v87);
            int16x8_t v97 = vuzp1q_s16(v88, v89);
            int16x8_t v98 = vuzp2q_s16(v88, v89);
            int16x8_t v99 = vaddq_s16(v95, v96);
            int16x8_t v100 = vaddq_s16(v97, v98);
            int32x4_t v101 = (int32x4_t)vsubq_s16(v97, v98);
            int32x4_t v102 = (int32x4_t)vsubq_s16(v95, v96);
            int16x8_t v103 = vuzp1q_s16(v99, v100);
            int16x8_t v104 = vuzp2q_s16(v99, v100);
            int16x8_t v105 = vaddq_s16(v103, v104);
            int16x8_t v106 = vsubq_s16(v103, v104);
            int32x4_t v107 = (int32x4_t)vzip1q_s16(v105, v106);
            int32x4_t v108 = (int32x4_t)vzip2q_s16(v105, v106);
            int8x16_t v109 = (int8x16_t)vzip1q_s32(v107, v102);
            int8x16_t v110 = (int8x16_t)vzip2q_s32(v107, v102);
            int8x16_t v111 = (int8x16_t)vzip1q_s32(v108, v101);
            int8x16_t v112 = (int8x16_t)vzip2q_s32(v108, v101);
            v102.i64[0] = vextq_s8(v109, v109, 8uLL).u64[0];
            v108.i64[0] = v109.i64[0];
            v101.i64[0] = vextq_s8(v110, v110, 8uLL).u64[0];
            int16x8_t v113 = vuzp1q_s16(v76, v78);
            int16x8_t v114 = vuzp2q_s16(v76, v78);
            int16x8_t v115 = vuzp1q_s16(v72, v74);
            v76.i64[0] = vextq_s8(v111, v111, 8uLL).u64[0];
            int16x8_t v116 = vuzp2q_s16(v72, v74);
            int16x8_t v117 = vuzp1q_s16(v60, v62);
            int16x8_t v118 = vuzp2q_s16(v60, v62);
            int16x8_t v119 = vuzp1q_s16(v64, v66);
            int16x8_t v120 = vuzp2q_s16(v64, v66);
            v62.i64[0] = v111.i64[0];
            int16x8_t v121 = vaddq_s16(v113, v114);
            int16x8_t v122 = vaddq_s16(v115, v116);
            int16x8_t v123 = vaddq_s16(v117, v118);
            int16x8_t v124 = vaddq_s16(v119, v120);
            int8x16_t v125 = (int8x16_t)vsubq_s16(v113, v114);
            v60.i64[0] = vextq_s8(v112, v112, 8uLL).u64[0];
            int8x16_t v126 = (int8x16_t)vsubq_s16(v115, v116);
            int8x16_t v127 = (int8x16_t)vsubq_s16(v117, v118);
            int16x8_t v128 = vuzp1q_s16(v121, v122);
            int16x8_t v129 = vuzp2q_s16(v121, v122);
            int16x8_t v130 = vuzp1q_s16(v123, v124);
            v116.i64[0] = v112.i64[0];
            int16x8_t v131 = vuzp2q_s16(v123, v124);
            int16x8_t v132 = vaddq_s16(v128, v129);
            int16x8_t v133 = vaddq_s16(v130, v131);
            int32x4_t v134 = (int32x4_t)vsubq_s16(v128, v129);
            v108.i64[1] = v91.i64[0];
            int16x8_t v135 = vuzp1q_s16(v132, v133);
            int16x8_t v136 = vuzp2q_s16(v132, v133);
            int16x8_t v137 = vaddq_s16(v135, v136);
            int16x8_t v138 = vsubq_s16(v135, v136);
            v110.i64[1] = v92.i64[0];
            int32x4_t v139 = (int32x4_t)vzip1q_s16(v137, v138);
            int8x16_t v140 = (int8x16_t)vzip1q_s32(v139, v134);
            v123.i64[0] = vextq_s8(v140, v140, 8uLL).u64[0];
            v62.i64[1] = v93.i64[0];
            int8x16_t v141 = (int8x16_t)vzip2q_s32(v139, v134);
            v139.i64[0] = vextq_s8(v141, v141, 8uLL).u64[0];
            v102.i64[1] = vextq_s8(v91, v91, 8uLL).u64[0];
            v91.i64[0] = vextq_s8(v92, v92, 8uLL).u64[0];
            v92.i64[0] = vextq_s8(v93, v93, 8uLL).u64[0];
            v116.i64[1] = v94.i64[0];
            v101.i64[1] = v91.i64[0];
            int32x4_t v142 = (int32x4_t)vsubq_s16(v130, v131);
            int32x4_t v143 = (int32x4_t)vzip2q_s16(v137, v138);
            int8x16_t v144 = (int8x16_t)vzip1q_s32(v143, v142);
            v138.i64[0] = vextq_s8(v144, v144, 8uLL).u64[0];
            v76.i64[1] = v92.i64[0];
            int8x16_t v145 = (int8x16_t)vzip2q_s32(v143, v142);
            v92.i64[0] = vextq_s8(v145, v145, 8uLL).u64[0];
            v60.i64[1] = vextq_s8(v94, v94, 8uLL).u64[0];
            v140.i64[1] = v125.i64[0];
            *uint64_t v42 = v108;
            v42[1] = (int32x4_t)v140;
            v123.i64[1] = vextq_s8(v125, v125, 8uLL).u64[0];
            v141.i64[1] = v126.i64[0];
            v42[8] = (int32x4_t)v110;
            v42[9] = (int32x4_t)v141;
            int8x16_t v146 = (int8x16_t)vsubq_s16(v119, v120);
            v144.i64[1] = v127.i64[0];
            v42[16] = (int32x4_t)v62;
            v42[17] = (int32x4_t)v144;
            v139.i64[1] = vextq_s8(v126, v126, 8uLL).u64[0];
            v145.i64[1] = v146.i64[0];
            v42[4] = v102;
            v42[5] = (int32x4_t)v123;
            v42[24] = (int32x4_t)v116;
            v42[25] = (int32x4_t)v145;
            v138.i64[1] = vextq_s8(v127, v127, 8uLL).u64[0];
            v42[12] = v101;
            v42[13] = v139;
            v92.i64[1] = vextq_s8(v146, v146, 8uLL).u64[0];
            v42[20] = (int32x4_t)v76;
            v42[21] = (int32x4_t)v138;
            char v147 = v40;
            v42[28] = (int32x4_t)v60;
            v42[29] = (int32x4_t)v92;
            v41 += 16;
            v42 += 2;
            char v40 = 0;
          }
          while ((v147 & 1) != 0);
          v38 += 32;
          v39 += v24;
          BOOL v148 = v37 >= 0x18;
          v37 += 8;
        }
        while (!v148);
        if (v170)
        {
          uint64_t v149 = *((void *)v170 + 2) + 12 * (v28 + v169);
          uint64_t v150 = v175;
          *(_DWORD *)(v149 + 8) = v176;
          *(void *)uint64_t v149 = v150;
        }
        int v20 = v175 + v174;
        int v19 = HIDWORD(v175) + v173;
        ++v28;
        uint64_t v27 = v172 + 32;
      }
      while (v28 != v171);
    }
    uint64_t v26 = v167 + 1;
    int v25 = v168 + v164;
    int v13 = v166;
  }
  while (v167 + 1 != v165);
  a7 = v153;
  a5 = v154;
  a6 = v152;
  if (v20 < 1)
  {
LABEL_24:
    if (a6) {
      *a6 = 0;
    }
    if (a7) {
      *a7 = 0;
    }
    float v151 = 1.0;
    if (a5) {
      goto LABEL_29;
    }
  }
  else
  {
    if (v152) {
      *float v152 = v19;
    }
    if (v153) {
      *float v153 = v20;
    }
    if (v154)
    {
      float v151 = (float)v19 / (float)v20;
LABEL_29:
      *a5 = v151;
    }
  }
  return result;
}

uint64_t vision::mod::image_quality::BlurMeasure::computeEdgeBasedBlurForImageRegionUsingBlurSignature(vision::mod::image_quality::BlurMeasure *this, float *a2, _Geometry2D_rect2D_ a3, float *a4, float a5, int *a6, int *a7)
{
  if (a5 > 0.0)
  {
    int v7 = (int)(float)(a3.size.width * a5);
    float v8 = a3.size.height * a5;
    a3.origin.int x = a3.origin.x + (float)v7;
    a3.origin.int y = a3.origin.y + (float)(int)v8;
    a3.size.width = a3.size.width - (float)(2 * v7);
    a3.size.height = a3.size.height - (float)(2 * (int)v8);
  }
  if (a3.size.width < 32.0 || a3.size.height < 32.0)
  {
    syslog(5, "Both width and height have to be >= 32 after applying the inset factor. Given w/h: %d/%d", (int)a3.size.width, (int)a3.size.height);
    return 2684;
  }
  else
  {
    int x = (int)a3.origin.x;
    int y = (int)a3.origin.y;
    uint64_t v13 = *((int *)this + 2);
    int v14 = 32 * v13 - 1;
    if (v14 >= (int)(float)(a3.size.width + a3.origin.x)) {
      int v14 = (int)(float)(a3.size.width + a3.origin.x);
    }
    int v15 = 32 * *((_DWORD *)this + 3) - 1;
    if (v15 >= (int)(float)(a3.size.height + a3.origin.y)) {
      int v15 = (int)(float)(a3.size.height + a3.origin.y);
    }
    if (x >= 0) {
      int v16 = (int)a3.origin.x;
    }
    else {
      int v16 = x + 31;
    }
    int v17 = y / 32;
    if (v14 >= 0) {
      int v18 = v14;
    }
    else {
      int v18 = v14 + 31;
    }
    if (v15 >= 0) {
      int v19 = v15;
    }
    else {
      int v19 = v15 + 31;
    }
    double v20 = 0.0;
    double v21 = 0.0;
    if (v17 <= v19 >> 5)
    {
      int v22 = v16 >> 5;
      double v23 = 1.0 - (double)(int)(x - (v16 & 0xFFFFFFE0)) * 0.03125;
      int v24 = v18 >> 5;
      double v25 = (double)(int)(v14 - (v18 & 0xFFFFFFE0) + 1) * 0.03125;
      double v26 = (double)(int)(v15 - (v19 & 0xFFFFFFE0) + 1) * 0.03125;
      double v27 = (double)(y % 32) * -0.03125 + 1.0;
      uint64_t v28 = v17;
      uint64_t v29 = v19 >> 5;
      uint64_t v30 = (v19 >> 5) + 1;
      if (v16 >> 5 <= (uint64_t)(v18 >> 5)) {
        uint64_t v31 = v24;
      }
      else {
        uint64_t v31 = v22;
      }
      uint64_t v32 = v31 - v22 + 1;
      uint64_t v33 = 12 * (v22 + (int)v13 * (uint64_t)v17) + 4;
      uint64_t v34 = 12 * v13;
      double v21 = 0.0;
      double v20 = 0.0;
      do
      {
        if (v28 == v29) {
          double v27 = v26;
        }
        if (v22 <= v24)
        {
          uint64_t v35 = (int *)(*((void *)this + 2) + v33);
          uint64_t v36 = v24 - (uint64_t)v22;
          uint64_t v37 = v32;
          double v38 = v23;
          do
          {
            if (!v36) {
              double v38 = v25;
            }
            double v20 = v20 + v38 * (double)*v35 * v27;
            double v21 = v21 + v38 * (double)*(v35 - 1) * v27;
            --v36;
            v35 += 3;
            double v38 = 1.0;
            --v37;
          }
          while (v37);
        }
        ++v28;
        v33 += v34;
        double v27 = 1.0;
      }
      while (v28 != v30);
    }
    double v39 = round(v20);
    if (a4) {
      *(_DWORD *)a4 = (int)v39;
    }
    double v40 = round(v21);
    if (a6) {
      *a6 = (int)v40;
    }
    float v41 = 1.0;
    if (v40 > 0.0) {
      float v41 = v39 / v40;
    }
    *a2 = v41;
    return 2688;
  }
}

uint64_t anonymous namespace'::updateBlurStatsOne16x16(_anonymous_namespace_ *a1, _DWORD *a2)
{
  BOOL v9 = v4 > 1225 || v5 > 1225 || (int)result > 1225;
  if (a2)
  {
    if (v9 && v4 < v5 && v5 != result)
    {
      ++*a2;
      if (v4 < 1225 || v5 < 1225 || (int)result <= 1224) {
        ++a2[1];
      }
    }
  }
  return result;
}

uint64_t anonymous namespace'::computeEdgeVal(_anonymous_namespace_ *this, __int16 *a2)
{
  if (v5 > v4) {
    int v4 = v5;
  }
  if (v6 > v4) {
    int v4 = v6;
  }
  if ((int)result <= v4) {
    return v4;
  }
  else {
    return result;
  }
}

uint64_t anonymous namespace'::computeEdgeValOne8x8(_anonymous_namespace_ *this, __int16 *a2)
{
  int v2 = 0;
  unint64_t v3 = (char *)this + 2 * a2;
  float v5 = 0.0;
  do
  {
    int v6 = (int)a2;
    int v7 = this;
    float v8 = (__int16 *)v3;
    do
    {
      uint64_t v4 = (32 * a2);
      int v9 = *((__int16 *)v7 + v4) * *((__int16 *)v7 + v4) + v8[v4] * v8[v4] + *v8 * *v8;
      if (v5 < (float)v9) {
        float v5 = (float)v9;
      }
      ++v8;
      int v7 = (_anonymous_namespace_ *)((char *)v7 + 2);
      --v6;
    }
    while (v6);
    ++v2;
    v3 += 64;
    this = (_anonymous_namespace_ *)((char *)this + 64);
  }
  while (v2 != a2);
  return (int)v5;
}

uint64_t anonymous namespace'::computeBlurScoreOnImageSubblocks(_anonymous_namespace_ *this, unsigned __int8 *a2, int a3, int *a4, unsigned int a5, int a6, float a7, vImage_Buffer *a8, float *a9, int *a10, int *a11)
{
  int v14 = (int)a4;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  *(void *)&v45[4] = this;
  int v44 = a3;
  *(_DWORD *)int16x8_t v45 = a2;
  LODWORD(a8->data) = 1065353216;
  if ((result & 0x80) != 0)
  {
    if (*(int *)v45 >= a6) {
      int v18 = a6;
    }
    else {
      int v18 = *(_DWORD *)v45;
    }
    int v39 = v18;
    if (v18 >= 0) {
      int v19 = v18;
    }
    else {
      int v19 = v18 + 31;
    }
    if (v44 >= a6) {
      int v20 = a6;
    }
    else {
      int v20 = v44;
    }
    float v41 = v46;
    int64x2_t v21 = vdupq_n_s64(0x20uLL);
    int64x2_t v42 = v21;
    if (a5 == 1) {
      int v22 = v14;
    }
    else {
      int v22 = 32;
    }
    uint64_t v43 = v22;
    float v23 = 1.0;
    if (v20 < 32)
    {
      uint64_t result = 2688;
LABEL_30:
      *(float *)&a8->data = v23;
    }
    else
    {
      uint64_t v24 = 0;
      int v25 = 0;
      int v26 = 0;
      uint64_t v27 = (v19 >> 5);
      uint64_t v28 = *(_DWORD *)v45 / (int)v27;
      uint64_t v38 = v20 >> 5;
      int v37 = v44 / (int)v38 * v14;
      uint64_t result = 2688;
      while (v39 < 32)
      {
LABEL_26:
        if (++v24 == v38)
        {
          if (v25 >= 1) {
            float v23 = (float)v26 / (float)v25;
          }
          goto LABEL_30;
        }
      }
      uint64_t v29 = 0;
      uint64_t v30 = *(void *)&v45[4] + (v37 * v24);
      while (1)
      {
        if (a5 == 1)
        {
          float v41 = (unsigned char *)(v30 + v29 * v28);
        }
        else
        {
          int v31 = 0;
          uint64_t v32 = v30 + v28 * a5 * v29;
          uint64_t v33 = v46;
          do
          {
            for (uint64_t i = 0; i != 128; i += 4)
            {
              v21.i8[0] = *(unsigned char *)(v32 + i);
              LOBYTE(v17) = *(unsigned char *)(v32 + i + 1);
              *(double *)&unint64_t v35 = (double)*(unint64_t *)&v17 * 0.7154;
              double v36 = *(double *)&v35 + (double)v21.u64[0] * 0.2125;
              LOBYTE(v35) = *(unsigned char *)(v32 + i + 2);
              double v17 = (double)v35;
              *(double *)v21.i64 = v36 + v17 * 0.0721;
              *v33++ = (int)*(double *)v21.i64;
            }
            v32 += v14;
            ++v31;
          }
          while (v31 != 32);
        }
        uint64_t v40 = 0;
        uint64_t result = vision::mod::image_quality::BlurMeasure::computeEdgeBasedBlurScoreForPlanar8Image((vision::mod::image_quality::BlurMeasure *)&v41, a8, (float *)&v40 + 1, 0.0, (int *)&v40, 0, v16);
        if ((result & 0x80) == 0) {
          break;
        }
        v25 += v40;
        v26 += HIDWORD(v40);
        if (++v29 == v27) {
          goto LABEL_26;
        }
      }
    }
  }
  return result;
}

void vision::mod::TorsoprintGenerator::~TorsoprintGenerator(vision::mod::TorsoprintGenerator *this)
{
  vision::mod::TorsoprintGenerator::~TorsoprintGenerator(this);

  JUMPOUT(0x1A62562C0);
}

{
  void *v2;
  std::__shared_weak_count *v3;

  *(void *)this = &unk_1EF752408;
  if (*((unsigned char *)this + 52))
  {
    espresso_plan_destroy();
    *((void *)this + 8) = 0;
    espresso_context_destroy();
    *((void *)this + 7) = 0;
  }
  std::unique_ptr<vision::mod::ImageProcessing_Preprocessor>::reset[abi:ne180100]((uint64_t *)this + 78, 0);
  int v2 = (void *)*((void *)this + 74);
  if (v2)
  {
    *((void *)this + 75) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

uint64_t vision::mod::ImageDescriptorAugmenterFlip::augmentImage(uint64_t a1, uint64_t a2, int a3, const vImage_Buffer ***a4)
{
  if (*(void *)a2) {
    BOOL v4 = *(void *)(a2 + 16) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4 || *(void *)(a2 + 8) == 0 || *(void *)(a2 + 24) < 2uLL) {
    return 3708;
  }
  unint64_t v11 = (uint64_t *)*a4;
  uint64_t v10 = a4[1];
  if (*(void *)(a1 + 8) != v10 - *a4) {
    return 3700;
  }
  if (a3)
  {
    uint64_t v14 = 1;
  }
  else if ((a3 & 0x3E) != 0)
  {
    uint64_t v14 = 4;
  }
  else
  {
    if ((a3 & 0x3C0) == 0)
    {
      syslog(5, "ERROR: Invalid image type");
      return 4211;
    }
    uint64_t v14 = 16;
  }
  if (v11 == (uint64_t *)v10)
  {
LABEL_22:
    uint64_t result = ImageProcessing_copyVImageBufferData((char **)a2, v14, (char **)*v10);
    if ((result & 0x80) == 0) {
      return result;
    }
    int v15 = *(_DWORD *)(a1 + 48);
    if ((~v15 & 3) != 0)
    {
      if ((v15 & 1) == 0)
      {
        if ((v15 & 2) != 0)
        {
          int v18 = **a4;
          int v19 = (vImage_Buffer *)(*a4)[1];
          return vision::mod::ImageDescriptorAugmenterFlip::flipLR(v18, a3, v19);
        }
        return result;
      }
      int v16 = **a4;
      double v17 = (vImage_Buffer *)(*a4)[1];
    }
    else
    {
      uint64_t result = vision::mod::ImageDescriptorAugmenterFlip::flipLR(**a4, a3, (vImage_Buffer *)(*a4)[1]);
      if ((result & 0x80) == 0) {
        return result;
      }
      uint64_t result = vision::mod::ImageDescriptorAugmenterFlip::flipUD(**a4, a3, (vImage_Buffer *)(*a4)[2]);
      if ((result & 0x80) == 0) {
        return result;
      }
      int v16 = (*a4)[1];
      double v17 = (vImage_Buffer *)(*a4)[3];
    }
    return vision::mod::ImageDescriptorAugmenterFlip::flipUD(v16, a3, v17);
  }
  while (1)
  {
    uint64_t result = ImageProcessing_reallocVImageBuffer(*v11, *(void *)(a2 + 16), *(void *)(a2 + 8), v14);
    if ((result & 0x80) == 0) {
      return result;
    }
    if (++v11 == (uint64_t *)v10)
    {
      uint64_t v10 = *a4;
      goto LABEL_22;
    }
  }
}

uint64_t vision::mod::ImageDescriptorAugmenterFlip::flipLR(const vImage_Buffer *a1, int a2, vImage_Buffer *dest)
{
  if (a2 == 4 || a2 == 2)
  {
    vImage_Error v3 = vImageHorizontalReflect_ARGB8888(a1, dest, 0);
  }
  else
  {
    if (a2 != 1) {
      return 3711;
    }
    vImage_Error v3 = vImageHorizontalReflect_Planar8(a1, dest, 0);
  }
  if (v3) {
    return 3706;
  }
  else {
    return 3712;
  }
}

uint64_t vision::mod::ImageDescriptorAugmenterFlip::flipUD(const vImage_Buffer *a1, int a2, vImage_Buffer *dest)
{
  if (a2 == 4 || a2 == 2)
  {
    vImage_Error v3 = vImageVerticalReflect_ARGB8888(a1, dest, 0);
  }
  else
  {
    if (a2 != 1) {
      return 3711;
    }
    vImage_Error v3 = vImageVerticalReflect_Planar8(a1, dest, 0);
  }
  if (v3) {
    return 3706;
  }
  else {
    return 3712;
  }
}

void vision::mod::ImageDescriptorAugmenterAbstract::~ImageDescriptorAugmenterAbstract(vision::mod::ImageDescriptorAugmenterAbstract *this)
{
  *(void *)this = &unk_1EF752CB0;
  int v2 = (void **)*((void *)this + 2);
  vImage_Error v3 = (void **)*((void *)this + 3);
  if (!((unint64_t)(v3 - v2) % *((void *)this + 1)))
  {
    if (v2 == v3)
    {
      int v2 = (void **)*((void *)this + 3);
    }
    else
    {
      do
      {
        BOOL v4 = (void **)*v2;
        if (*v2)
        {
          free(*v4);
          *(_OWORD *)BOOL v4 = 0u;
          *((_OWORD *)v4 + 1) = 0u;
          float v5 = *v2;
        }
        else
        {
          float v5 = 0;
        }
        free(v5);
        *v2++ = 0;
      }
      while (v2 != v3);
      int v2 = (void **)*((void *)this + 2);
    }
    *((void *)this + 3) = v2;
    *((void *)this + 5) = 0;
  }
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
}

uint64_t vision::mod::ImageDescriptorAugmenterFlip::combine(vision::mod::ImageDescriptorAugmenterFlip *this, const vision::mod::ImageDescriptorBufferAbstract *lpsrc, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  unint64_t v8 = *((void *)lpsrc + 9);
  unint64_t v9 = *((void *)this + 1);
  if (v8 != v8 / v9 * v9) {
    return 3700;
  }
  uint64_t v10 = v7;
  vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(a3, v8 / v9, 0);
  uint64_t v11 = 3708;
  if (v6 && v10)
  {
    if (*((void *)v10 + 9))
    {
      unint64_t v12 = 0;
      uint64_t v11 = 3712;
      do
      {
        unint64_t DataForKthDescriptor = (void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(v10, v12);
        uint64_t v14 = (const void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(v6, *((void *)this + 1) * v12);
        size_t v15 = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)v10 + 104))(v10);
        memcpy(DataForKthDescriptor, v14, v15);
        unint64_t v16 = *((void *)this + 1);
        if (v16 >= 2)
        {
          for (unint64_t i = 1; i < v16; ++i)
          {
            int v18 = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(v6, i + v12 * v16);
            vDSP_vadd(v18, 1, (const float *)DataForKthDescriptor, 1, (float *)DataForKthDescriptor, 1, *((void *)v10 + 12));
            unint64_t v16 = *((void *)this + 1);
          }
        }
        float __B = (float)v16;
        vDSP_vsdiv((const float *)DataForKthDescriptor, 1, &__B, (float *)DataForKthDescriptor, 1, *((void *)v10 + 12));
        ++v12;
      }
      while (v12 < *((void *)v10 + 9));
    }
    else
    {
      return 3712;
    }
  }
  return v11;
}

void vision::mod::ImageDescriptorAugmenterFlip::~ImageDescriptorAugmenterFlip(vision::mod::ImageDescriptorAugmenterFlip *this)
{
  vision::mod::ImageDescriptorAugmenterAbstract::~ImageDescriptorAugmenterAbstract(this);

  JUMPOUT(0x1A62562C0);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageDescriptorAugmenterFlip>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptorAugmenterFlip>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753930;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptorAugmenterFlip>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753930;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t vision::mod::ImageDescriptorAugmenterNoOp::combine(vision::mod::ImageDescriptorAugmenterNoOp *this, const vision::mod::ImageDescriptorBufferAbstract *lpsrc, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  unint64_t v8 = *((void *)lpsrc + 9);
  unint64_t v9 = *((void *)this + 1);
  if (v8 != v8 / v9 * v9) {
    return 3700;
  }
  uint64_t v10 = v7;
  vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(a3, v8 / v9, 0);
  uint64_t v11 = 3708;
  if (v6 && v10)
  {
    if (*((void *)v10 + 9))
    {
      unint64_t v12 = 0;
      uint64_t v11 = 3712;
      do
      {
        unint64_t DataForKthDescriptor = (void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(v10, v12);
        uint64_t v14 = (const void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(v6, *((void *)this + 1) * v12);
        size_t v15 = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferAbstract *))(*(void *)v10 + 104))(v10);
        memcpy(DataForKthDescriptor, v14, v15);
        ++v12;
      }
      while (*((void *)v10 + 9) > v12);
    }
    else
    {
      return 3712;
    }
  }
  return v11;
}

uint64_t vision::mod::ImageDescriptorAugmenterNoOp::augmentImage(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4)
{
  if (*(void *)a2) {
    BOOL v4 = *(void *)(a2 + 16) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4 || *(void *)(a2 + 8) == 0 || *(void *)(a2 + 24) < 2uLL) {
    return 3708;
  }
  uint64_t v10 = *(uint64_t **)a4;
  unint64_t v9 = *(char ****)(a4 + 8);
  if (*(void *)(a1 + 8) != ((uint64_t)v9 - *(void *)a4) >> 3) {
    return 3700;
  }
  if (a3)
  {
    uint64_t v12 = 1;
  }
  else if ((a3 & 0x3E) != 0)
  {
    uint64_t v12 = 4;
  }
  else
  {
    if ((a3 & 0x3C0) == 0)
    {
      syslog(5, "ERROR: Invalid image type");
      return 4211;
    }
    uint64_t v12 = 16;
  }
  if (v10 == (uint64_t *)v9)
  {
LABEL_23:
    uint64_t v13 = *v9;
    return ImageProcessing_copyVImageBufferData((char **)a2, v12, v13);
  }
  else
  {
    while (1)
    {
      uint64_t result = ImageProcessing_reallocVImageBuffer(*v10, *(void *)(a2 + 16), *(void *)(a2 + 8), v12);
      if ((result & 0x80) == 0) {
        break;
      }
      if (++v10 == (uint64_t *)v9)
      {
        unint64_t v9 = *(char ****)a4;
        goto LABEL_23;
      }
    }
  }
  return result;
}

void vision::mod::ImageDescriptorAugmenterNoOp::~ImageDescriptorAugmenterNoOp(vision::mod::ImageDescriptorAugmenterNoOp *this)
{
  vision::mod::ImageDescriptorAugmenterAbstract::~ImageDescriptorAugmenterAbstract(this);

  JUMPOUT(0x1A62562C0);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageDescriptorAugmenterNoOp>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptorAugmenterNoOp>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753968;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptorAugmenterNoOp>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753968;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void vision::mod::TorsoprintGeneratorConcrete::~TorsoprintGeneratorConcrete(vision::mod::TorsoprintGeneratorConcrete *this)
{
  vision::mod::TorsoprintGenerator::~TorsoprintGenerator(this);

  JUMPOUT(0x1A62562C0);
}

void *std::vector<float>::vector(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    int v6 = (_DWORD *)a1[1];
    int v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1A3E7B098(_Unwind_Exception *exception_object)
{
  vImage_Error v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_emplace<vision::mod::TorsoprintGeneratorConcrete>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::TorsoprintGeneratorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7538C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::TorsoprintGeneratorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7538C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageDescriptorBufferFloat32>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptorBufferFloat32>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7539A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptorBufferFloat32>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7539A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t vision::mod::ImageDescriptorAugmenterAbstract::augment(void *a1, _OWORD *a2, unsigned int a3)
{
  int v6 = operator new(0x20uLL);
  long long v7 = a2[1];
  *int v6 = *a2;
  v6[1] = v7;
  uint64_t v8 = vision::mod::ImageDescriptorAugmenterAbstract::augment(a1, (uint64_t)v6, (uint64_t)(v6 + 2), a3);
  operator delete(v6);
  return v8;
}

void sub_1A3E7B254(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageDescriptorAugmenterAbstract::getAugmentedImages(vision::mod::ImageDescriptorAugmenterAbstract *this, uint64_t a2)
{
  if (!*(void *)(a2 + 40))
  {
    syslog(5, "ERROR: It appears that you are requesting the list of augmented images without having created them");
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3700;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  BOOL v4 = 0;
  unint64_t v5 = 0;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  do
  {
    int v6 = *(_OWORD **)(*(void *)(a2 + 16) + 8 * v5);
    unint64_t v7 = *((void *)this + 2);
    if ((unint64_t)v4 >= v7)
    {
      unint64_t v9 = *(_OWORD **)this;
      uint64_t v10 = ((uint64_t)v4 - *(void *)this) >> 5;
      unint64_t v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 59) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v12 = v7 - (void)v9;
      if (v12 >> 4 > v11) {
        unint64_t v11 = v12 >> 4;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v11;
      }
      if (v13) {
        unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(v13);
      }
      else {
        uint64_t v14 = 0;
      }
      long long v15 = v6[1];
      unint64_t v16 = (_OWORD *)(v13 + 32 * v10);
      _OWORD *v16 = *v6;
      v16[1] = v15;
      if (v4 == v9)
      {
        unint64_t v19 = v13 + 32 * v10;
      }
      else
      {
        unint64_t v17 = v13 + 32 * v10;
        do
        {
          long long v18 = *(v4 - 1);
          unint64_t v19 = v17 - 32;
          *(_OWORD *)(v17 - 32) = *(v4 - 2);
          *(_OWORD *)(v17 - 16) = v18;
          v4 -= 2;
          v17 -= 32;
        }
        while (v4 != v9);
      }
      BOOL v4 = v16 + 2;
      *(void *)this = v19;
      *((void *)this + 1) = v16 + 2;
      *((void *)this + 2) = v13 + 32 * v14;
      if (v9) {
        operator delete(v9);
      }
    }
    else
    {
      long long v8 = v6[1];
      *BOOL v4 = *v6;
      v4[1] = v8;
      v4 += 2;
    }
    *((void *)this + 1) = v4;
    ++v5;
  }
  while (v5 < *(void *)(a2 + 40));
}

void sub_1A3E7B3D4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

void std::shared_ptr<vision::mod::ImageDescriptorBufferAbstract>::shared_ptr[abi:ne180100]<vision::mod::ImageDescriptorBufferAbstract,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1A3E7B45C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<vision::mod::ImageDescriptorBufferAbstract *,std::shared_ptr<vision::mod::ImageDescriptorBufferAbstract>::__shared_ptr_default_delete<vision::mod::ImageDescriptorBufferAbstract,vision::mod::ImageDescriptorBufferAbstract>,std::allocator<vision::mod::ImageDescriptorBufferAbstract>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN6vision3mod29ImageDescriptorBufferAbstractEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::__shared_ptr_pointer<vision::mod::ImageDescriptorBufferAbstract *,std::shared_ptr<vision::mod::ImageDescriptorBufferAbstract>::__shared_ptr_default_delete<vision::mod::ImageDescriptorBufferAbstract,vision::mod::ImageDescriptorBufferAbstract>,std::allocator<vision::mod::ImageDescriptorBufferAbstract>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<vision::mod::ImageDescriptorBufferAbstract *,std::shared_ptr<vision::mod::ImageDescriptorBufferAbstract>::__shared_ptr_default_delete<vision::mod::ImageDescriptorBufferAbstract,vision::mod::ImageDescriptorBufferAbstract>,std::allocator<vision::mod::ImageDescriptorBufferAbstract>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(unint64_t a1)
{
  if (a1 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a1);
}

uint64_t vision::mod::ImageDescriptorAugmenterAbstract::augment(void *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  a1[5] = 0;
  if (a2 == a3)
  {
    uint64_t v7 = 0;
    uint64_t v38 = 3712;
  }
  else
  {
    uint64_t v5 = a2;
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = v6 + 1;
      unint64_t v8 = a1[1];
      for (uint64_t i = a1[3] - a1[2]; v8 * v7 > i >> 3; uint64_t i = (uint64_t)v14 - a1[2])
      {
        uint64_t v10 = malloc_type_malloc(0x20uLL, 0x1080040ABB4582EuLL);
        if (!v10)
        {
          exception = __cxa_allocate_exception(8uLL);
          void *exception = 3707;
          __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
        }
        unint64_t v11 = v10;
        _OWORD *v10 = 0u;
        v10[1] = 0u;
        unint64_t v13 = (void *)a1[3];
        unint64_t v12 = a1[4];
        if ((unint64_t)v13 >= v12)
        {
          uint64_t v15 = a1[2];
          uint64_t v16 = ((uint64_t)v13 - v15) >> 3;
          if ((unint64_t)(v16 + 1) >> 61) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v17 = v12 - v15;
          uint64_t v18 = v17 >> 2;
          if (v17 >> 2 <= (unint64_t)(v16 + 1)) {
            uint64_t v18 = v16 + 1;
          }
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v18;
          }
          if (v19) {
            unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v19);
          }
          else {
            uint64_t v20 = 0;
          }
          int64x2_t v21 = (void *)(v19 + 8 * v16);
          void *v21 = v11;
          uint64_t v14 = v21 + 1;
          float v23 = (char *)a1[2];
          int v22 = (char *)a1[3];
          if (v22 != v23)
          {
            do
            {
              uint64_t v24 = *((void *)v22 - 1);
              v22 -= 8;
              *--int64x2_t v21 = v24;
            }
            while (v22 != v23);
            int v22 = (char *)a1[2];
          }
          a1[2] = v21;
          a1[3] = v14;
          a1[4] = v19 + 8 * v20;
          if (v22) {
            operator delete(v22);
          }
        }
        else
        {
          *unint64_t v13 = v10;
          uint64_t v14 = v13 + 1;
        }
        a1[3] = v14;
        unint64_t v8 = a1[1];
      }
      uint64_t v43 = v5;
      std::string __p = 0;
      int16x8_t v45 = 0;
      unint64_t v46 = 0;
      if (v8)
      {
        int v25 = 0;
        int v26 = 0;
        unint64_t v27 = 0;
        for (unint64_t j = 0; j < v8; ++j)
        {
          unint64_t v29 = j + v8 * v6;
          uint64_t v30 = a1[2];
          if ((unint64_t)v25 >= v27)
          {
            uint64_t v32 = v25 - v26;
            unint64_t v33 = v32 + 1;
            if ((unint64_t)(v32 + 1) >> 61) {
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            }
            if ((uint64_t)(v27 - (void)v26) >> 2 > v33) {
              unint64_t v33 = (uint64_t)(v27 - (void)v26) >> 2;
            }
            if (v27 - (unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v33;
            }
            if (v34) {
              unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v34);
            }
            else {
              uint64_t v35 = 0;
            }
            double v36 = (void *)(v34 + 8 * v32);
            *double v36 = *(void *)(v30 + 8 * v29);
            int v31 = v36 + 1;
            if (v25 != v26)
            {
              do
              {
                uint64_t v37 = *--v25;
                *--double v36 = v37;
              }
              while (v25 != v26);
              int v25 = v26;
            }
            int v26 = v36;
            unint64_t v27 = v34 + 8 * v35;
            std::string __p = v36;
            unint64_t v46 = v27;
            if (v25) {
              operator delete(v25);
            }
          }
          else
          {
            *int v25 = *(void *)(v30 + 8 * v29);
            int v31 = v25 + 1;
          }
          int16x8_t v45 = v31;
          unint64_t v8 = a1[1];
          int v25 = v31;
        }
      }
      uint64_t v38 = (*(uint64_t (**)(void *, uint64_t, void, void **))(*a1 + 16))(a1, v43, a4, &__p);
      if (__p)
      {
        int16x8_t v45 = __p;
        operator delete(__p);
      }
      if ((v38 & 0x80) == 0) {
        break;
      }
      uint64_t v5 = v43 + 32;
      ++v6;
      if (v43 + 32 == a3) {
        goto LABEL_49;
      }
    }
    uint64_t v7 = v6;
  }
LABEL_49:
  a1[5] = a1[1] * v7;
  return v38;
}

void sub_1A3E7B864(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tplTrackerResampler_lumaDownscale4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  if (a6 >= 4)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 4 * a2;
    uint64_t v9 = result + a3 + a2 * a4;
    uint64_t v10 = v9 + 3 * a2;
    uint64_t v11 = v9 + 2 * a2;
    uint64_t v12 = v9 + a2;
    if (a5 >> 2 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = a5 >> 2;
    }
    do
    {
      if (a5 >= 4)
      {
        uint64_t v14 = 0;
        do
        {
          v15.i32[0] = *(_DWORD *)(v11 + 4 * v14);
          v15.i32[1] = *(_DWORD *)(v10 + 4 * v14);
          uint16x8_t v16 = vmovl_u8(v15);
          v17.i32[0] = *(_DWORD *)(v9 + 4 * v14);
          v17.i32[1] = *(_DWORD *)(v12 + 4 * v14);
          uint16x8_t v18 = vmovl_u8(v17);
          uint64_t result = (vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v18.i8, *(uint16x4_t *)v16.i8), (int32x4_t)vaddl_high_u16(v18, v16)))+ 8) >> 4;
          *(unsigned char *)(a7 + v14++) = result;
        }
        while (v13 != v14);
      }
      v9 += v8;
      v12 += v8;
      v11 += v8;
      v10 += v8;
      a7 += a5 >> 2;
      ++v7;
    }
    while (v7 != a6 >> 2);
  }
  return result;
}

uint64_t tplTrackerResampler_chromaDownscale4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a6 >= 4)
  {
    uint64_t v8 = 0;
    unint64_t v15 = a6 >> 2;
    uint64_t v9 = 2 * a3;
    unint64_t v16 = a5 >> 2;
    uint64_t v17 = 4 * a2;
    if (a5 >> 2 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = a5 >> 2;
    }
    uint64_t v22 = result + a2 * a4 + 3;
    uint64_t v21 = v22 + a2;
    uint64_t v19 = result + a2 * (a4 + 3) + 3;
    uint64_t v20 = result + a2 * (a4 + 2) + 3;
    do
    {
      uint64_t v18 = v8;
      if (a5 >= 4)
      {
        uint64_t result = 0;
        uint64_t v11 = v19;
        uint64_t v12 = v20;
        uint64_t v13 = v21;
        uint64_t v14 = v22;
        do
        {
          *(unsigned char *)(a7 + result) = (*(unsigned __int8 *)(v14 + v9 - 3)
                                   + *(unsigned __int8 *)(v14 + v9 - 1)
                                   + *(unsigned __int8 *)(v14 + v9 + 1)
                                   + *(unsigned __int8 *)(v14 + v9 + 3)
                                   + *(unsigned __int8 *)(v13 + v9 - 3)
                                   + *(unsigned __int8 *)(v13 + v9 - 1)
                                   + *(unsigned __int8 *)(v13 + v9 + 1)
                                   + *(unsigned __int8 *)(v13 + v9 + 3)
                                   + *(unsigned __int8 *)(v12 + v9 - 3)
                                   + *(unsigned __int8 *)(v12 + v9 - 1)
                                   + *(unsigned __int8 *)(v12 + v9 + 1)
                                   + *(unsigned __int8 *)(v12 + v9 + 3)
                                   + *(unsigned __int8 *)(v11 + v9 - 3)
                                   + *(unsigned __int8 *)(v11 + v9 - 1)
                                   + *(unsigned __int8 *)(v11 + v9 + 1)
                                   + *(unsigned __int8 *)(v11 + v9 + 3)
                                   + 8) >> 4;
          *(unsigned char *)(a8 + result++) = (*(unsigned __int8 *)(v14 + v9 - 2)
                                     + *(unsigned __int8 *)(v14 + v9)
                                     + *(unsigned __int8 *)(v14 + v9 + 2)
                                     + *(unsigned __int8 *)(v14 + v9 + 4)
                                     + *(unsigned __int8 *)(v13 + v9 - 2)
                                     + *(unsigned __int8 *)(v13 + v9)
                                     + *(unsigned __int8 *)(v13 + v9 + 2)
                                     + *(unsigned __int8 *)(v13 + v9 + 4)
                                     + *(unsigned __int8 *)(v12 + v9 - 2)
                                     + *(unsigned __int8 *)(v12 + v9)
                                     + *(unsigned __int8 *)(v12 + v9 + 2)
                                     + *(unsigned __int8 *)(v12 + v9 + 4)
                                     + *(unsigned __int8 *)(v11 + v9 - 2)
                                     + *(unsigned __int8 *)(v11 + v9)
                                     + *(unsigned __int8 *)(v11 + v9 + 2)
                                     + *(unsigned __int8 *)(v11 + v9 + 4)
                                     + 8) >> 4;
          v14 += 8;
          v13 += 8;
          v12 += 8;
          v11 += 8;
        }
        while (v10 != result);
      }
      a7 += v16;
      a8 += v16;
      ++v8;
      v22 += v17;
      v21 += v17;
      v20 += v17;
      v19 += v17;
    }
    while (v18 + 1 != v15);
  }
  return result;
}

unsigned __int8 *tplTracker_YCbCr2RGB(unsigned __int8 *result, unsigned __int8 *a2, unsigned __int8 *a3, int a4, unsigned char *a5, unsigned char *a6, unsigned char *a7)
{
  if (a4 >= 1)
  {
    uint64_t v7 = a4;
    do
    {
      int v9 = *a2++;
      int v8 = v9;
      int v11 = *result++;
      int v10 = v11;
      int v12 = v8 - 128;
      int v13 = *a3++;
      int v14 = v13 - 128;
      int v15 = 101 * (v13 - 128) + (v10 << 6);
      if (v15 <= 16351) {
        unsigned int v16 = ((v15 + 32) >> 6) & ~((v15 + 32) >> 31);
      }
      else {
        unsigned int v16 = 255;
      }
      int v17 = -12 * v12 + (v10 << 6) - 30 * v14;
      int v18 = 119 * v12 + (v10 << 6);
      if (v17 <= 16351) {
        unsigned int v19 = ((v17 + 32) >> 6) & ~((v17 + 32) >> 31);
      }
      else {
        unsigned int v19 = 255;
      }
      if (v18 <= 16351) {
        unsigned int v20 = ((v18 + 32) >> 6) & ~((v18 + 32) >> 31);
      }
      else {
        unsigned int v20 = 255;
      }
      if (v19 <= v20) {
        unsigned int v21 = v20;
      }
      else {
        unsigned int v21 = v19;
      }
      if (v16 > v21) {
        unsigned int v21 = v16;
      }
      int v22 = ctrTrackerComputation_YCbCr2nRGB_kIlluminationInvariantLookupTable[v21];
      unsigned int v23 = v16 * v22;
      unsigned int v24 = v23 >> 4;
      unsigned int v25 = (v23 + 16) >> 5;
      unsigned int v26 = v19 * v22;
      if (v24 > 0x1FE) {
        LOBYTE(v25) = -1;
      }
      unsigned int v27 = v26 >> 4;
      unsigned int v28 = (v26 + 16) >> 5;
      *a5++ = v25;
      if (v27 > 0x1FE) {
        LOBYTE(v28) = -1;
      }
      unsigned int v29 = v20 * v22;
      unsigned int v30 = v29 >> 4;
      *a6++ = v28;
      unsigned int v31 = (v29 + 16) >> 5;
      if (v30 > 0x1FE) {
        LOBYTE(v31) = -1;
      }
      *a7++ = v31;
      --v7;
    }
    while (v7);
  }
  return result;
}

void tplTracker_computeNormedGradient(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int *a6, uint64_t a7)
{
  int v7 = a6[1];
  if (*a6 >= a5) {
    int v8 = a5 - 1;
  }
  else {
    int v8 = *a6 & ~(*a6 >> 31);
  }
  int v9 = a6[2];
  int v10 = a6[3];
  if (v9 >= a5) {
    int v11 = a5 - 1;
  }
  else {
    int v11 = v9 & ~(v9 >> 31);
  }
  int v12 = a4 - 1;
  int v13 = v7 & ~(v7 >> 31);
  if (v7 >= a4) {
    int v13 = a4 - 1;
  }
  int v56 = v13;
  if (v10 < a4) {
    int v12 = v10 & ~(v10 >> 31);
  }
  int v55 = v12;
  if (a4 >= 1)
  {
    uint64_t v18 = 0;
    size_t v19 = a5;
    uint64_t v20 = v12;
    uint64_t v21 = v13;
    uint64_t v57 = a4;
    int v54 = a5;
    uint64_t v53 = a5;
    do
    {
      if (v18 < v21 || v18 > v20)
      {
        if (a5 >= 1)
        {
          bzero((void *)(a7 + (int)v18 * a5), v19);
          uint64_t v21 = v56;
          uint64_t v20 = v55;
          a5 = v54;
        }
      }
      else if (a5 >= 1)
      {
        uint64_t v22 = 0;
        if (v18 < v20) {
          int v23 = v18 + 1;
        }
        else {
          int v23 = v55;
        }
        if ((int)v18 - 1 <= v56) {
          int v24 = v56;
        }
        else {
          int v24 = v18 - 1;
        }
        char v25 = v23 - v24 != 2;
        uint64_t v26 = v18 * v53;
        int v27 = v23 * a5;
        uint64_t v28 = v24 * a5;
        uint64_t v29 = v27;
        do
        {
          if (v22 < v8 || v22 > v11)
          {
            *(unsigned char *)(a7 + v22 + v26) = 0;
            ++v22;
          }
          else
          {
            if ((int)v22 - 1 <= v8) {
              int v30 = v8;
            }
            else {
              int v30 = v22 - 1;
            }
            BOOL v31 = v22 < v11;
            uint64_t v32 = v22 + v28;
            uint64_t v33 = v22 + v29;
            uint64_t v34 = v22 + v26;
            ++v22;
            if (v31) {
              int v35 = v22;
            }
            else {
              int v35 = v11;
            }
            char v36 = v35 - v30 != 2;
            uint64_t v37 = v26 + v30;
            uint64_t v38 = v26 + v35;
            int v39 = (*(unsigned __int8 *)(a1 + v38) - *(unsigned __int8 *)(a1 + v37)) << v36;
            int v40 = (*(unsigned __int8 *)(a1 + v33) - *(unsigned __int8 *)(a1 + v32)) << v25;
            int v41 = (*(unsigned __int8 *)(a2 + v38) - *(unsigned __int8 *)(a2 + v37)) << v36;
            int v42 = (*(unsigned __int8 *)(a2 + v33) - *(unsigned __int8 *)(a2 + v32)) << v25;
            int v43 = (*(unsigned __int8 *)(a3 + v38) - *(unsigned __int8 *)(a3 + v37)) << v36;
            int v44 = (*(unsigned __int8 *)(a3 + v33) - *(unsigned __int8 *)(a3 + v32)) << v25;
            if (v39 >= 0) {
              int v45 = v39;
            }
            else {
              int v45 = -v39;
            }
            if (v40 >= 0) {
              int v46 = v40;
            }
            else {
              int v46 = -v40;
            }
            unsigned int v47 = v46 + v45;
            if (v41 >= 0) {
              int v48 = v41;
            }
            else {
              int v48 = -v41;
            }
            if (v42 >= 0) {
              int v49 = v42;
            }
            else {
              int v49 = -v42;
            }
            unsigned int v50 = v49 + v48;
            if (v43 < 0) {
              int v43 = -v43;
            }
            if (v44 < 0) {
              int v44 = -v44;
            }
            unsigned int v51 = v44 + v43;
            if (v47 <= v50) {
              unsigned int v52 = v50;
            }
            else {
              unsigned int v52 = v47;
            }
            if (v52 > v51) {
              unsigned int v51 = v52;
            }
            if (v51 >= 0xFF) {
              LOBYTE(v51) = -1;
            }
            *(unsigned char *)(a7 + v34) = v51;
          }
        }
        while (v22 != v19);
      }
      ++v18;
    }
    while (v18 != v57);
  }
}

float tplTracker_computeTemplateAvgColor(_DWORD *a1, float result)
{
  int v2 = (float *)(a1 + 10516);
  int v3 = a1[11258];
  if (v3 > 4)
  {
    int v6 = a1[11256];
    if (v6 <= 6) {
      int v4 = 6;
    }
    else {
      int v4 = a1[11256];
    }
    if (v6 <= 18) {
      int v6 = 18;
    }
    if (v3 <= 0x10) {
      int v5 = v3 + 1;
    }
    else {
      int v5 = v6;
    }
  }
  else
  {
    int v4 = v3 + 1;
    int v5 = v3 + 1;
  }
  int v7 = a1[11259];
  if (v7 > 4)
  {
    int v10 = a1[11257];
    if (v10 <= 6) {
      int v8 = 6;
    }
    else {
      int v8 = a1[11257];
    }
    if (v10 <= 18) {
      int v10 = 18;
    }
    if (v7 <= 0x10) {
      int v9 = v7 + 1;
    }
    else {
      int v9 = v10;
    }
  }
  else
  {
    int v8 = v7 + 1;
    int v9 = v7 + 1;
  }
  int v11 = (v9 - v8) * (v5 - v4);
  if (v11 >= 1)
  {
    float v12 = (float)v11;
    if (v9 <= v8)
    {
      unsigned int v15 = 0;
      unsigned int v14 = 0;
      unsigned int v13 = 0;
    }
    else
    {
      unsigned int v13 = 0;
      unsigned int v14 = 0;
      unsigned int v15 = 0;
      uint64_t v16 = (uint64_t)&a1[6 * v8 + 17740];
      uint64_t v17 = (uint64_t)&a1[6 * v8 + 16444];
      uint64_t v18 = (uint64_t)&a1[6 * v8 + 15148];
      do
      {
        uint64_t v19 = v18;
        uint64_t v20 = v17;
        uint64_t v21 = v16;
        uint64_t v22 = v5;
        if (v5 > v4)
        {
          do
          {
            v15 += *(unsigned __int8 *)(v19 + v4);
            v14 += *(unsigned __int8 *)(v20 + v4);
            v13 += *(unsigned __int8 *)(v21 + v4);
            --v22;
            ++v21;
            ++v20;
            ++v19;
          }
          while (v4 != v22);
        }
        v18 += 24;
        v17 += 24;
        v16 += 24;
        ++v8;
      }
      while (v8 != v9);
    }
    *int v2 = (float)v15 / v12;
    v2[1] = (float)v14 / v12;
    uint64_t result = (float)v13 / v12;
    v2[2] = result;
  }
  return result;
}

uint64_t tplTracker_computeTemplateStats(uint64_t result)
{
  unsigned int v1 = 0;
  unsigned int v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = result + 8;
  do
  {
    for (uint64_t i = 0; i != 24; ++i)
    {
      int v6 = *(unsigned char *)(v4 + i) & 0xF0;
      v1 += v6;
      v2 += v6 * v6;
    }
    v4 += 24;
    ++v3;
  }
  while (v3 != 24);
  float v7 = (float)v1 / 576.0;
  float v8 = (float)((float)v2 / 576.0) - (float)(v7 * v7);
  if (v8 < 0.0) {
    float v8 = 0.0;
  }
  *(float *)(result + 42056) = v7;
  *(float *)(result + 42060) = sqrtf(v8);
  return result;
}

uint64_t tplTracker_computeTemplateFFT(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = a1 + 216824;
  uint64_t v4 = a1 + 8;
  uint64_t v5 = a1 + 216828;
  int v6 = (char *)(a1 + 216824);
  do
  {
    uint64_t v7 = 0;
    uint64_t v8 = v5;
    do
    {
      *(void *)(v8 - 4) = *(unsigned char *)(v4 + v7++) & 0xF0;
      v8 += 8;
    }
    while (v7 != 24);
    int v9 = (_OWORD *)(a1 + 576 * v2 + 217016);
    v9[22] = 0uLL;
    v9[23] = 0uLL;
    v9[20] = 0uLL;
    v9[21] = 0uLL;
    v9[18] = 0uLL;
    v9[19] = 0uLL;
    v9[16] = 0uLL;
    v9[17] = 0uLL;
    v9[14] = 0uLL;
    v9[15] = 0uLL;
    v9[12] = 0uLL;
    v9[13] = 0uLL;
    v9[10] = 0uLL;
    v9[11] = 0uLL;
    v9[8] = 0uLL;
    v9[9] = 0uLL;
    v9[6] = 0uLL;
    v9[7] = 0uLL;
    v9[4] = 0uLL;
    v9[5] = 0uLL;
    v9[2] = 0uLL;
    v9[3] = 0uLL;
    v4 += 24;
    v6 += 576;
    ++v2;
    v5 += 576;
    _OWORD *v9 = 0uLL;
    v9[1] = 0uLL;
  }
  while (v2 != 24);
  bzero(v6, 0x6C00uLL);

  return tplTracker_IFFT_2D(v3, (char *)(a1 + 258296), (void *)(a1 + 584), v10);
}

uint64_t tplTracker_findPeakXY(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, uint64_t a8, float *a9)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (a2 <= a4) {
    int v11 = a2 - 1;
  }
  else {
    int v11 = a4;
  }
  if (a3 <= a5) {
    int v12 = a3 - 1;
  }
  else {
    int v12 = a5;
  }
  if (a2 <= a6) {
    int v13 = a2 - 1;
  }
  else {
    int v13 = a6;
  }
  if (a3 <= a7) {
    int v14 = a3 - 1;
  }
  else {
    int v14 = a7;
  }
  int v15 = v14 - v12 + 1;
  MEMORY[0x1F4188790](a1);
  uint64_t v17 = (char *)&v34 - v16;
  MEMORY[0x1F4188790](v18);
  int v23 = (char *)&v34 - v22;
  uint64_t result = 6780;
  if (v13 - v11 <= 47 && v21 <= 47)
  {
    uint64_t v37 = a9;
    uint64_t v38 = v19;
    uint64_t v36 = v20;
    bzero(v17, 4 * v20);
    uint64_t v35 = v15;
    bzero(v23, 4 * v15);
    if (v14 >= v12)
    {
      uint64_t v25 = 0;
      uint64_t v26 = a1 + 4 * v12 * a2;
      do
      {
        if (v13 >= v11)
        {
          float v27 = *(float *)&v23[4 * v25];
          uint64_t v28 = (float *)v17;
          uint64_t v29 = (v13 - v11 + 1);
          uint64_t v30 = 4 * v11;
          do
          {
            float v31 = *(float *)(v26 + v30);
            *uint64_t v28 = v31 + *v28;
            ++v28;
            float v27 = v31 + v27;
            v30 += 4;
            --v29;
          }
          while (v29);
          *(float *)&v23[4 * v25] = v27;
        }
        ++v25;
        v26 += 4 * a2;
      }
      while (v25 != v14 - v12 + 1);
    }
    float Peak = tplTracker_findPeak((uint64_t)v17, v36);
    float *v38 = Peak + (float)v11;
    float v33 = tplTracker_findPeak((uint64_t)v23, v35);
    *uint64_t v37 = v33 + (float)v12;
    return 6784;
  }
  return result;
}

float tplTracker_findPeak(uint64_t a1, uint64_t a2)
{
  switch(a2)
  {
    case 5:
      uint64_t v8 = 0;
      float v3 = 0.0;
      float v4 = 0.0;
      do
      {
        float v9 = *(float *)(a1 + v8 * 4);
        float v4 = v4 + (float)(*(float *)&dword_1A410E938[v8] * v9);
        float v3 = v3 + (float)(*(float *)&dword_1A410E94C[v8++] * v9);
      }
      while (v8 != 5);
      if (v3 <= -0.005)
      {
        float result = 0.0;
        if (v4 > 0.0 != v3 < 0.0) {
          return result;
        }
        float v7 = v3 * -8.0;
        float result = 4.0;
        goto LABEL_33;
      }
      break;
    case 6:
      uint64_t v10 = 0;
      float v3 = 0.0;
      float v4 = 0.0;
      do
      {
        float v11 = *(float *)(a1 + v10 * 4);
        float v4 = v4 + (float)(*(float *)&dword_1A410CD54[v10] * v11);
        float v3 = v3 + (float)(*(float *)&dword_1A410CD6C[v10++] * v11);
      }
      while (v10 != 6);
      if (v3 <= -0.005)
      {
        float result = 0.0;
        if (v4 > 0.0 != v3 < 0.0) {
          return result;
        }
        float v7 = v3 * -10.0;
        float result = 5.0;
        goto LABEL_33;
      }
      break;
    case 7:
      uint64_t v2 = 0;
      float v3 = 0.0;
      float v4 = 0.0;
      do
      {
        float v5 = *(float *)(a1 + v2 * 4);
        float v4 = v4 + (float)(*(float *)&dword_1A410CD84[v2] * v5);
        float v3 = v3 + (float)(*(float *)&dword_1A410CDA0[v2++] * v5);
      }
      while (v2 != 7);
      if (v3 <= -0.005)
      {
        float result = 0.0;
        if (v4 > 0.0 != v3 < 0.0) {
          return result;
        }
        float v7 = v3 * -12.0;
        float result = 6.0;
LABEL_33:
        if (v4 <= v7) {
          return v4 / (float)(v3 * -2.0);
        }
        return result;
      }
      break;
  }
  float result = (float)(unint64_t)(a2 - 1) * 0.5;
  if (a2)
  {
    uint64_t v12 = 0;
    float v13 = 0.0;
    float v14 = 3.4028e38;
    do
    {
      float v15 = *(float *)(a1 + 4 * v12);
      if (v15 < v14) {
        float v14 = *(float *)(a1 + 4 * v12);
      }
      if (v15 > v13)
      {
        float result = (float)(int)v12;
        float v13 = *(float *)(a1 + 4 * v12);
      }
      ++v12;
    }
    while (a2 != v12);
    uint64_t v16 = 0;
    float v17 = 0.0;
    float v18 = 0.0;
    do
    {
      float v19 = (float)(*(float *)(a1 + 4 * v16) - v14) * (float)(*(float *)(a1 + 4 * v16) - v14);
      float v17 = v17 + v19;
      float v18 = v18 + (float)((float)(int)v16++ * v19);
    }
    while (a2 != v16);
  }
  else
  {
    float v18 = 0.0;
    float v17 = 0.0;
  }
  if (v17 > 0.0) {
    return v18 / v17;
  }
  return result;
}

uint64_t tplTracker_mergeSpans(uint64_t a1, uint64_t a2, int a3)
{
  if ((int)a2 >= a3) {
    return 6784;
  }
  unsigned int v3 = 0;
  uint64_t v4 = a1 + 162432;
  int v5 = -1;
  int v6 = -1;
  while (1)
  {
    signed int v7 = *(_DWORD *)(v4 + 36 * (int)a2);
    if (v7 > (int)v3)
    {
      uint64_t v8 = a2;
      LODWORD(a2) = -1;
      goto LABEL_67;
    }
    if ((int)a2 < a3 && v7 == v3) {
      break;
    }
    uint64_t v8 = a2;
LABEL_67:
    if (v3 <= 0x2F)
    {
      ++v3;
      int v5 = v6;
      int v6 = a2;
      a2 = v8;
      if ((int)v8 < a3) {
        continue;
      }
    }
    return 6784;
  }
  uint64_t v8 = (int)a2;
  BOOL v10 = v5 != -1 && v5 < a3;
  BOOL v12 = v6 != -1 && v6 < a3;
  while (1)
  {
    uint64_t v13 = *(unsigned int *)(v4 + 36 * v8 + 12);
    do
    {
      uint64_t v14 = v13;
      uint64_t v13 = *(unsigned int *)(v4 + 36 * (int)v13 + 12);
    }
    while (v14 != v13);
    if (v10)
    {
      float v15 = (_DWORD *)(v4 + 36 * (int)v8);
      uint64_t v16 = v15 + 2;
      float v17 = v15 + 1;
      float v18 = v15 + 3;
      uint64_t v19 = v5;
      uint64_t v20 = v14;
      do
      {
        if (*(_DWORD *)(v4 + 36 * v19) != v3 - 2 || *(_DWORD *)(v4 + 36 * v19 + 4) > *v16 + 2) {
          break;
        }
        if (*(_DWORD *)(v4 + 36 * v19 + 8) >= *v17 - 2)
        {
          uint64_t v21 = v4 + 36 * v19;
          unsigned int v24 = *(_DWORD *)(v21 + 12);
          int v23 = (_DWORD *)(v21 + 12);
          uint64_t v22 = v24;
          do
          {
            uint64_t v25 = v22;
            uint64_t v26 = v4 + 36 * (int)v22;
            unsigned int v28 = *(_DWORD *)(v26 + 12);
            float v27 = (_DWORD *)(v26 + 12);
            uint64_t v22 = v28;
          }
          while (v25 != v28);
          if (v25 != v20)
          {
            int v29 = v25;
            if ((int)v20 <= (int)v25)
            {
              *float v27 = v20;
              *int v23 = v20;
              uint64_t v25 = v20;
              int v30 = v20;
            }
            else
            {
              int v30 = v25;
              int v29 = v20;
              *(_DWORD *)(v4 + 36 * (int)v20 + 12) = v25;
              _DWORD *v18 = v25;
            }
            float v31 = (_DWORD *)(v4 + 36 * v30);
            uint64_t v32 = (_DWORD *)(v4 + 36 * v29);
            int v33 = v31[4];
            int v34 = v31[5];
            if (v33 >= v32[4]) {
              int v33 = v32[4];
            }
            if (v34 <= v32[5]) {
              int v34 = v32[5];
            }
            v31[4] = v33;
            v31[5] = v34;
            int v35 = v31[6];
            int v36 = v31[7];
            if (v35 >= v32[6]) {
              int v35 = v32[6];
            }
            if (v36 <= v32[7]) {
              int v36 = v32[7];
            }
            v31[6] = v35;
            v31[7] = v36;
            v31[8] += v32[8];
            uint64_t v20 = v25;
          }
        }
        ++v19;
      }
      while (v19 != a3);
    }
    if (v12)
    {
      uint64_t v37 = (_DWORD *)(v4 + 36 * (int)v8);
      uint64_t v38 = v37 + 2;
      uint64_t v39 = v37 + 1;
      int v40 = v37 + 3;
      uint64_t v41 = v6;
      do
      {
        if (*(_DWORD *)(v4 + 36 * v41) != v3 - 1 || *(_DWORD *)(v4 + 36 * v41 + 4) > *v38 + 2) {
          break;
        }
        if (*(_DWORD *)(v4 + 36 * v41 + 8) >= *v39 - 2)
        {
          uint64_t v42 = v4 + 36 * v41;
          unsigned int v45 = *(_DWORD *)(v42 + 12);
          int v44 = (_DWORD *)(v42 + 12);
          uint64_t v43 = v45;
          do
          {
            uint64_t v46 = v43;
            uint64_t v47 = v4 + 36 * (int)v43;
            unsigned int v49 = *(_DWORD *)(v47 + 12);
            int v48 = (_DWORD *)(v47 + 12);
            uint64_t v43 = v49;
          }
          while (v46 != v49);
          if (v46 != v14)
          {
            int v50 = v46;
            if ((int)v14 <= (int)v46)
            {
              *int v48 = v14;
              *int v44 = v14;
              uint64_t v46 = v14;
              int v51 = v14;
            }
            else
            {
              int v51 = v46;
              int v50 = v14;
              *(_DWORD *)(v4 + 36 * (int)v14 + 12) = v46;
              *int v40 = v46;
            }
            unsigned int v52 = (_DWORD *)(v4 + 36 * v51);
            uint64_t v53 = (_DWORD *)(v4 + 36 * v50);
            int v54 = v52[4];
            int v55 = v52[5];
            if (v54 >= v53[4]) {
              int v54 = v53[4];
            }
            if (v55 <= v53[5]) {
              int v55 = v53[5];
            }
            v52[4] = v54;
            v52[5] = v55;
            int v56 = v52[6];
            int v57 = v52[7];
            if (v56 >= v53[6]) {
              int v56 = v53[6];
            }
            if (v57 <= v53[7]) {
              int v57 = v53[7];
            }
            v52[6] = v56;
            v52[7] = v57;
            v52[8] += v53[8];
            uint64_t v14 = v46;
          }
        }
        ++v41;
      }
      while (v41 != a3);
    }
    if (++v8 == a3) {
      return 6784;
    }
    if (*(_DWORD *)(v4 + 36 * v8) != v3) {
      goto LABEL_67;
    }
  }
}

uint64_t calculateIntegralImage(unsigned __int8 *a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  uint64_t result = 6780;
  if (a1 && a6 && a3 * a2 < 0x10000)
  {
    if (a2 >= 1)
    {
      int v8 = 0;
      float v9 = a1;
      BOOL v10 = a6;
      uint64_t v11 = a2;
      do
      {
        int v12 = *v9++;
        v8 += v12;
        *v10++ = v8;
        --v11;
      }
      while (v11);
    }
    if (a3 <= 1)
    {
      return 6784;
    }
    else
    {
      uint64_t v13 = 4 * a5;
      uint64_t v14 = &a1[a4];
      int v15 = 1;
      uint64_t result = 6784;
      uint64_t v16 = &a6[(unint64_t)v13 / 4];
      do
      {
        if (a2 >= 1)
        {
          uint64_t v17 = 0;
          int v18 = 0;
          do
          {
            v18 += v14[v17];
            v16[v17] = v18 + a6[v17];
            ++v17;
          }
          while (a2 != v17);
        }
        ++v15;
        uint64_t v16 = (_DWORD *)((char *)v16 + v13);
        a6 = (_DWORD *)((char *)a6 + v13);
        v14 += a4;
      }
      while (v15 != a3);
    }
  }
  return result;
}

void sub_1A3E7CAF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7CB94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7CC40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7CD88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7D124(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3E7D028);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3E7D914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  __cxa_free_exception(v26);
  _Unwind_Resume(a1);
}

void *std::vector<unsigned long>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<long long>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1A3E7D9D0(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<unsigned char>::vector(void *a1, size_t a2, unsigned char *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    size_t v5 = a2;
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    int v6 = (unsigned char *)a1[1];
    signed int v7 = &v6[v5];
    do
    {
      *v6++ = *a3;
      --v5;
    }
    while (v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_1A3E7DA50(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3E7DB68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7DC7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7DE2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7E01C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelIOStringForTag(uint64_t a1)
{
  uint64_t v2 = ((int)a1 >> 24);
  uint64_t v3 = MEMORY[0x1E4F14390];
  if ((a1 & 0x80000000) != 0)
  {
    if (!__maskrune((int)a1 >> 24, 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  if (((a1 << 6) & 0x80000000) != 0)
  {
    if (!__maskrune((int)(a1 << 6) >> 24, 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(v3 + 4 * ((int)(a1 << 6) >> 24) + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  if (((a1 << 16) & 0x80000000) != 0)
  {
    if (!__maskrune((__int16)a1 >> 8, 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(v3 + 4 * ((__int16)a1 >> 8) + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  if ((a1 & 0x80) != 0)
  {
    if (__maskrune((char)a1, 0x40000uLL)) {
      goto LABEL_15;
    }
  }
  else if ((*(_DWORD *)(v3 + 4 * (char)a1 + 60) & 0x40000) != 0)
  {
LABEL_15:
    objc_msgSend(NSString, "stringWithFormat:", @"'%c%c%c%c'", v2, ((int)(a1 << 6) >> 24), ((__int16)a1 >> 8), (char)a1);
    goto LABEL_18;
  }
LABEL_17:
  objc_msgSend(NSString, "stringWithFormat:", @"0x%08X", a1, v6, v7, v8);
  uint64_t v4 = LABEL_18:;

  return v4;
}

BOOL VNPersonsModelIOWriteTagToOutputStream(int a1, void *a2, CC_MD5_CTX *a3, void *a4)
{
  int data = a1;
  id v6 = a2;
  uint64_t v7 = [v6 write:&data maxLength:4];
  if (v7 == 4)
  {
    CC_MD5_Update(a3, &data, 4u);
  }
  else if (a4)
  {
    uint64_t v8 = [v6 streamError];
    VNPersonsModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"failed to write to data stream", v8);
    *a4 = (id)objc_claimAutoreleasedReturnValue();
  }
  return v7 == 4;
}

uint64_t VNPersonsModelIOWriteTaggedBufferToOutputStream(uint64_t a1, const void *a2, CC_LONG a3, void *a4, CC_MD5_CTX *a5, uint64_t a6)
{
  id v11 = a4;
  if (!a2)
  {
    if (!a6) {
      goto LABEL_11;
    }
    int v12 = NSString;
    uint64_t v13 = VNPersonsModelIOStringForTag(a1);
    uint64_t v14 = [v12 stringWithFormat:@"tag %@ did not provide any data", v13];
    VNPersonsModelErrorForIOError(v14);
    *(void *)a6 = (id)objc_claimAutoreleasedReturnValue();

    goto LABEL_10;
  }
  if (!VNPersonsModelIOWriteTagToOutputStream(a1, v11, a5, (void *)a6)
    || !VNPersonsModelIOWriteTagToOutputStream(a3, v11, a5, (void *)a6))
  {
    goto LABEL_10;
  }
  if (a3)
  {
    if ([v11 write:a2 maxLength:a3] == a3)
    {
      CC_MD5_Update(a5, a2, a3);
      goto LABEL_7;
    }
    if (!a6) {
      goto LABEL_11;
    }
    uint64_t v16 = [v11 streamError];
    VNPersonsModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"failed to write to data stream", v16);
    *(void *)a6 = (id)objc_claimAutoreleasedReturnValue();

LABEL_10:
    a6 = 0;
    goto LABEL_11;
  }
LABEL_7:
  a6 = 1;
LABEL_11:

  return a6;
}

void *VNPersonsModelIOWriteTaggedDataToOutputStream(uint64_t a1, void *a2, void *a3, CC_MD5_CTX *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  unint64_t v11 = [v9 length];
  if (HIDWORD(v11))
  {
    if (a5)
    {
      int v12 = NSString;
      uint64_t v13 = VNPersonsModelIOStringForTag(a1);
      uint64_t v14 = [v12 stringWithFormat:@"tag %@ has a data overflow to %lu bytes", v13, v11];
      VNPersonsModelErrorForIOError(v14);
      *a5 = (id)objc_claimAutoreleasedReturnValue();

      a5 = 0;
    }
  }
  else
  {
    a5 = (void *)VNPersonsModelIOWriteTaggedBufferToOutputStream(a1, (const void *)[v9 bytes], v11, v10, a4, (uint64_t)a5);
  }

  return a5;
}

void *VNPersonsModelIOWriteTaggedObjectToOutputStream(uint64_t a1, uint64_t a2, void *a3, CC_MD5_CTX *a4, void *a5)
{
  id v9 = a3;
  id v10 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:a2 requiringSecureCoding:1 error:a5];
  if (v10) {
    unint64_t v11 = VNPersonsModelIOWriteTaggedDataToOutputStream(a1, v10, v9, a4, a5);
  }
  else {
    unint64_t v11 = 0;
  }

  return v11;
}

BOOL VNPersonsModelIOReadTagFromInputStream(void *a1, const void *a2, CC_MD5_CTX *a3, void *a4)
{
  id v7 = a1;
  uint64_t v8 = [v7 read:a2 maxLength:4];
  if (v8 == 4)
  {
    CC_MD5_Update(a3, a2, 4u);
  }
  else if (a4)
  {
    id v9 = [v7 streamError];
    VNPersonsModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"unexpected end of data stream", v9);
    *a4 = (id)objc_claimAutoreleasedReturnValue();
  }
  return v8 == 4;
}

BOOL VNPersonsModelIOReadBufferFromInputStream(void *a1, CC_LONG a2, const void *a3, CC_MD5_CTX *a4, void *a5)
{
  id v9 = a1;
  uint64_t v10 = a2;
  uint64_t v11 = [v9 read:a3 maxLength:a2];
  if (v11 == a2)
  {
    CC_MD5_Update(a4, a3, a2);
  }
  else if (a5)
  {
    int v12 = [v9 streamError];
    VNPersonsModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"unexpected end of data stream", v12);
    *a5 = (id)objc_claimAutoreleasedReturnValue();
  }
  return v11 == v10;
}

id VNPersonsModelIOReadNSDataFromInputStream(void *a1, CC_MD5_CTX *a2, void *a3)
{
  id v5 = a1;
  CC_LONG v11 = 0;
  if (!VNPersonsModelIOReadTagFromInputStream(v5, &v11, a2, a3))
  {
    id v9 = 0;
    goto LABEL_10;
  }
  id v6 = objc_alloc(MEMORY[0x1E4F1CA58]);
  id v7 = (id) [v6 initWithLength:v11];
  uint64_t v8 = (const void *)[v7 mutableBytes];
  if (!v8)
  {
    if (a3)
    {
      +[VNError errorForMemoryAllocationFailure];
      id v9 = 0;
      *a3 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_9;
    }
LABEL_8:
    id v9 = 0;
    goto LABEL_9;
  }
  if (!VNPersonsModelIOReadBufferFromInputStream(v5, v11, v8, a2, a3)) {
    goto LABEL_8;
  }
  id v9 = v7;
LABEL_9:

LABEL_10:

  return v9;
}

uint64_t VNPersonsModelIOReadPastUnknownTagData(void *a1, CC_MD5_CTX *a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  unsigned int v12 = 0;
  uint64_t v6 = 0;
  if (VNPersonsModelIOReadTagFromInputStream(v5, &v12, a2, a3))
  {
    unint64_t v7 = v12;
    id v8 = v5;
    if (v7)
    {
      while (1)
      {
        uint64_t v9 = v7 >= 0x100 ? 256 : v7;
        if ([v8 read:data maxLength:v9] != v9) {
          break;
        }
        CC_MD5_Update(a2, data, v9);
        v7 -= v9;
        if (!v7) {
          goto LABEL_8;
        }
      }
      if (a3)
      {
        uint64_t v10 = [v8 streamError];
        VNPersonsModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"unexpected end of data stream", v10);
        *a3 = (id)objc_claimAutoreleasedReturnValue();
      }
      uint64_t v6 = 0;
    }
    else
    {
LABEL_8:
      uint64_t v6 = 1;
    }
  }
  return v6;
}

void sub_1A3E7EDC0(void *a1)
{
}

void sub_1A3E7EDCC(_Unwind_Exception *a1)
{
}

void sub_1A3E7FC18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7FD68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E7FEB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E80364(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E805A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierEspresso::classifyImage_Planar8(uint64_t a1@<X8>)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  exception = __cxa_allocate_exception(8uLL);
  void *exception = 3967;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

void sub_1A3E80600(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierEspresso::classifyImage_BGRA8888(uint64_t a1@<X8>)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  exception = __cxa_allocate_exception(8uLL);
  void *exception = 3967;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

void sub_1A3E8065C(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierEspresso::classifyImage_RGBA8888(uint64_t a1@<X8>)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  exception = __cxa_allocate_exception(8uLL);
  void *exception = 3967;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

void sub_1A3E806B8(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierEspresso::classifyDescriptorHandler(vision::mod::ImageClassifierEspresso *this@<X0>, const vision::mod::ImageDescriptorBufferAbstract *a2@<X1>, uint64_t a3@<X8>)
{
  id v11 = [MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:*((void *)a2 + 7) length:(*(uint64_t (**)(const vision::mod::ImageDescriptorBufferAbstract *))(*(void *)a2 + 104))(a2) freeWhenDone:0];
  espresso_vision_classify_descriptor_handler_nsdata();
  id v5 = objc_claimAutoreleasedReturnValue();
  uint64_t v6 = (int *)[v5 bytes];
  unint64_t v7 = [v5 length];
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  if (v7 >= 4)
  {
    uint64_t v8 = 0;
    unint64_t v9 = v7 >> 2;
    do
    {
      int v10 = *v6;
      unsigned int v12 = (unsigned __int8 *)(*((void *)this + 1) + v8);
      *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, v12, (long long **)&v12)+ 10) = v10;
      v8 += 24;
      ++v6;
      --v9;
    }
    while (v9);
  }
}

void sub_1A3E807F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, long long **a3)
{
  unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    unsigned int v12 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      uint64_t v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = *((void *)v13 + 1);
          if (v14 == v8)
          {
            if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v13 + 16, a2)) {
              return v13;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3) {
              break;
            }
          }
          uint64_t v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  uint64_t v13 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v13 = 0;
  *((void *)v13 + 1) = v8;
  int v15 = (std::string *)(v13 + 16);
  uint64_t v16 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v15, *(const std::string::value_type **)v16, *((void *)v16 + 1));
  }
  else
  {
    long long v17 = *v16;
    *((void *)v13 + 4) = *((void *)v16 + 2);
    *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v17;
  }
  *((_DWORD *)v13 + 10) = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    BOOL v20 = 1;
    if (v9 >= 3) {
      BOOL v20 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v9);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v23);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v24 = *(void *)a1;
  uint64_t v25 = *(void **)(*(void *)a1 + 8 * v3);
  if (v25)
  {
    *(void *)uint64_t v13 = *v25;
LABEL_41:
    *uint64_t v25 = v13;
    goto LABEL_42;
  }
  *(void *)uint64_t v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13;
  *(void *)(v24 + 8 * v3) = a1 + 16;
  if (*(void *)v13)
  {
    unint64_t v26 = *(void *)(*(void *)v13 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v26 >= v9) {
        v26 %= v9;
      }
    }
    else
    {
      v26 &= v9 - 1;
    }
    uint64_t v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_41;
  }
LABEL_42:
  ++*(void *)(a1 + 24);
  return v13;
}

void sub_1A3E80A64(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,float>,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      uint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  id v5 = operator new(8 * prime);
  uint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  unint64_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    unint64_t v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *unint64_t v8 = *v14;
          *unint64_t v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          unint64_t v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        unint64_t v8 = v14;
        unint64_t v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,float>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 39) < 0) {
      operator delete(__p[2]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t vision::mod::ImageClassifierEspresso::setPriority(vision::mod::ImageClassifierEspresso *this)
{
  uint64_t v1 = *(void **)(*((void *)this + 15) + 16);
  if (v1)
  {
    uint64_t v2 = [v1 ctx];
    int updated = espresso_vision_util_update_metal_priority();

    int8x8_t v4 = &CVML_status_invalidParameter;
    if (updated) {
      int8x8_t v4 = &CVML_status_ok;
    }
  }
  else
  {
    int8x8_t v4 = &CVML_status_internalError;
  }
  return (*v4 + 128) | 0xF00;
}

void sub_1A3E80D6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageClassifierEspresso::wipeLayersMemory(vision::mod::ImageClassifierEspresso *this)
{
  uint64_t v2 = *((void *)this + 15);
  unint64_t v3 = *(void **)(v2 + 16);
  if (v3)
  {
    objc_msgSend(v3, "wipe_layers_blobs");
    uint64_t v2 = *((void *)this + 15);
  }
  if (*(void *)v2)
  {
    if (v4)
    {
      id v5 = *(std::__shared_weak_count **)(v2 + 8);
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(void *))(*(void *)v4 + 112))(v4);
      if (v5) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v5);
      }
    }
  }
  return 3968;
}

void sub_1A3E80E44(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageClassifierEspresso::setDescriptorProcessor(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 120);
  if (!v2)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3965;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (std::__shared_weak_count *)v2[1];
  *uint64_t v2 = v5;
  v2[1] = v4;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  return a1;
}

uint64_t vision::mod::ImageClassifierEspresso::getDescriptorProcessor@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(uint64_t **)(this + 120);
  uint64_t v4 = *v2;
  uint64_t v3 = v2[1];
  *a2 = v4;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void vision::mod::ImageClassifierAbstract::classifyDescriptorBatch(vision::mod::ImageClassifierAbstract *this@<X0>, const vision::mod::ImageDescriptorBufferAbstract *a2@<X1>, int a3@<W2>, char a4@<W3>, char **a5@<X8>)
{
  unint64_t v10 = *((void *)a2 + 9);
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  uint64_t v41 = a5;
  LOBYTE(v42) = 0;
  if (v10)
  {
    if (v10 >= 0x666666666666667) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unordered_map<std::string,float>>>(v10);
    *a5 = v11;
    a5[1] = v11;
    a5[2] = &v11[40 * v12];
    uint64_t v13 = &v11[40 * v10];
    do
    {
      *(_OWORD *)unint64_t v11 = 0uLL;
      *((_OWORD *)v11 + 1) = 0uLL;
      *((_DWORD *)v11 + 8) = 1065353216;
      v11 += 40;
    }
    while (v11 != v13);
    a5[1] = v13;
  }
  (*(void (**)(char ***__return_ptr, vision::mod::ImageClassifierAbstract *))(*(void *)this + 24))(&v41, this);
  (*((void (**)(uint64_t *__return_ptr))*v41 + 8))(&v29);
  if (v42) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v42);
  }
  if (*((void *)a2 + 9))
  {
    unint64_t v14 = 0;
    if (__p == (void **)((char *)this + 32)) {
      char v15 = 1;
    }
    else {
      char v15 = a4;
    }
    do
    {
      (*(void (**)(const vision::mod::ImageDescriptorBufferAbstract *, uint64_t, unint64_t))(*(void *)a2 + 112))(a2, v29, v14);
      (*(void (**)(char ***__return_ptr, vision::mod::ImageClassifierAbstract *, uint64_t))(*(void *)this + 56))(&v41, this, v29);
      *(_OWORD *)uint64_t v38 = 0u;
      *(_OWORD *)uint64_t v39 = 0u;
      int v40 = 1065353216;
      if (a3)
      {
        vision::mod::ImageClassifierAbstract::ImageClassifier_filterdisallowedListedLabels((uint64_t)__p, (uint64_t)this, (uint64_t)&v41);
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__move_assign((uint64_t)v38, (uint64_t *)__p);
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v36[0]);
        uint64_t v16 = __p[0];
        __p[0] = 0;
        if (v16) {
          operator delete(v16);
        }
      }
      else
      {
        int v40 = v44;
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,float>,void *> *>>(v38, v43);
      }
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)int v36 = 0u;
      int v37 = 1065353216;
      if ((v15 & 1) == 0)
      {
        int v37 = *((_DWORD *)this + 16);
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,float>,void *> *>>(__p, *((uint64_t **)this + 6));
      }
      long long v33 = 0uLL;
      uint64_t v34 = 0;
      int v17 = *((_DWORD *)this + 24);
      if (v17 == 1)
      {
        ImageClassifier_getLabelsAuto((uint64_t *)&v31, (void **)v39[0], __p, *((float *)this + 26), 0.1);
      }
      else
      {
        if (v17)
        {
          exception = __cxa_allocate_exception(8uLL);
          void *exception = 3955;
          __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
        }
        ImageClassifier_getLabels((uint64_t *)&v31, (void **)v39[0], __p, *((int *)this + 27), *((float *)this + 25));
      }
      std::vector<std::pair<std::string,float>>::__vdeallocate((uint64_t *)&v33);
      long long v33 = v31;
      uint64_t v34 = v32;
      uint64_t v32 = 0;
      long long v31 = 0uLL;
      v45[0] = &v31;
      std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)v45);
      *(_OWORD *)unint64_t v26 = 0u;
      *(_OWORD *)float v27 = 0u;
      int v28 = 1065353216;
      uint64_t v19 = *((void *)&v33 + 1);
      for (uint64_t i = v33; i != v19; i += 32)
      {
        int v20 = *(_DWORD *)(i + 24);
        v45[0] = (long long *)i;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v26, (unsigned __int8 *)i, v45)+ 10) = v20;
      }
      *(void *)&long long v31 = &v33;
      std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v31);
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v36[0]);
      unint64_t v21 = __p[0];
      __p[0] = 0;
      if (v21) {
        operator delete(v21);
      }
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v39[0]);
      unint64_t v22 = v38[0];
      v38[0] = 0;
      if (v22) {
        operator delete(v22);
      }
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v43);
      size_t v23 = v41;
      uint64_t v41 = 0;
      if (v23) {
        operator delete(v23);
      }
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__move_assign((uint64_t)&(*a5)[40 * v14], (uint64_t *)v26);
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v27[0]);
      uint64_t v24 = v26[0];
      v26[0] = 0;
      if (v24) {
        operator delete(v24);
      }
      ++v14;
    }
    while (*((void *)a2 + 9) > v14);
  }
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v30);
  }
}

void sub_1A3E812A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void **a31)
{
  long long v33 = *(std::__shared_weak_count **)(v31 - 144);
  if (v33) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v33);
  }
  std::vector<std::unordered_map<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&a31);
  _Unwind_Resume(a1);
}

void std::vector<std::unordered_map<std::string,float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v4 - 40);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void vision::mod::ImageClassifierAbstract::ImageClassifier_filterdisallowedListedLabels(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (*(void *)(a2 + 80) == *(void *)(a2 + 72))
  {
    if (a1 != a3)
    {
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a3 + 32);
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,float>,void *> *>>((void *)a1, *(uint64_t **)(a3 + 16));
    }
  }
  else
  {
    for (uint64_t i = *(unsigned __int8 **)(a3 + 16); i; uint64_t i = *(unsigned __int8 **)i)
    {
      uint64_t v6 = *(void *)(a2 + 80);
      if (std::__find_impl[abi:ne180100]<std::string const*,std::string const*,std::string,std::__identity>(*(void *)(a2 + 72), v6, (unsigned __int8 **)i + 2) == v6)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,float> const&>(a1, i + 16, (uint64_t)(i + 16)); {
    }
      }
  }
}

void sub_1A3E8147C(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,float>,void *> *>>(void *a1, uint64_t *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = a1[1];
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
      *(void *)(*a1 + 8 * i) = 0;
    uint64_t v6 = a1[2];
    a1[2] = 0;
    a1[3] = 0;
    if (v6) {
      BOOL v7 = a2 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7)
    {
      unint64_t v8 = (void **)v6;
    }
    else
    {
      do
      {
        std::string::operator=((std::string *)(v6 + 16), (const std::string *)(v2 + 2));
        *(_DWORD *)(v6 + 40) = *((_DWORD *)v2 + 10);
        unint64_t v8 = *(void ***)v6;
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__node_insert_multi((uint64_t)a1, v6);
        uint64_t v2 = (uint64_t *)*v2;
        if (v8) {
          BOOL v9 = v2 == 0;
        }
        else {
          BOOL v9 = 1;
        }
        uint64_t v6 = (uint64_t)v8;
      }
      while (!v9);
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node(v8);
  }
  for (; v2; uint64_t v2 = (uint64_t *)*v2)
  {
    unint64_t v10 = (char *)operator new(0x30uLL);
    uint64_t v11 = (uint64_t)v10;
    uint64_t v12 = v10 + 16;
    *(void *)unint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    if (*((char *)v2 + 39) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)(v10 + 16), (const std::string::value_type *)v2[2], v2[3]);
    }
    else
    {
      long long v13 = *((_OWORD *)v2 + 1);
      *((void *)v10 + 4) = v2[4];
      *uint64_t v12 = v13;
    }
    *(_DWORD *)(v11 + 40) = *((_DWORD *)v2 + 10);
    *(void *)(v11 + 8) = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)v12);
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__node_insert_multi((uint64_t)a1, v11);
  }
}

void sub_1A3E815A8(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,float>,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

void std::vector<std::pair<std::string,float>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::pair<std::string,float>>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::pair<std::string,float>>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::pair<std::string,float>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 32)
  {
    if (*(char *)(i - 9) < 0) {
      operator delete(*(void **)(i - 32));
    }
  }
  a1[1] = v2;
}

void std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__node_insert_multi(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)a2;
  uint64_t v4 = (unsigned __int8 *)(a2 + 16);
  unint64_t v43 = std::__string_hash<char>::operator()[abi:ne180100](a2 + 16);
  v2[1] = v43;
  unint64_t v5 = *(void *)(a1 + 8);
  float v6 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v7 = *(float *)(a1 + 32);
  if (!v5 || (float)(v7 * (float)v5) < v6)
  {
    BOOL v8 = 1;
    if (v5 >= 3) {
      BOOL v8 = (v5 & (v5 - 1)) != 0;
    }
    unint64_t v9 = v8 | (2 * v5);
    unint64_t v10 = vcvtps_u32_f32(v6 / v7);
    if (v9 <= v10) {
      int8x8_t prime = (int8x8_t)v10;
    }
    else {
      int8x8_t prime = (int8x8_t)v9;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v5 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v5) {
      goto LABEL_99;
    }
    if (*(void *)&prime >= v5) {
      goto LABEL_60;
    }
    unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v5 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v5), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
    {
      unint64_t v19 = std::__next_prime(v19);
    }
    else
    {
      uint64_t v21 = 1 << -(char)__clz(v19 - 1);
      if (v19 >= 2) {
        unint64_t v19 = v21;
      }
    }
    if (*(void *)&prime <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    if (*(void *)&prime >= v5)
    {
      unint64_t v5 = *(void *)(a1 + 8);
      goto LABEL_60;
    }
    if (prime)
    {
LABEL_99:
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v12 = operator new(8 * *(void *)&prime);
      long long v13 = *(void **)a1;
      *(void *)a1 = v12;
      if (v13) {
        operator delete(v13);
      }
      uint64_t v41 = v4;
      uint64_t v14 = 0;
      *(int8x8_t *)(a1 + 8) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v14++) = 0;
      while (*(void *)&prime != v14);
      char v15 = *(uint64_t **)(a1 + 16);
      if (v15)
      {
        unint64_t v16 = v15[1];
        uint8x8_t v17 = (uint8x8_t)vcnt_s8(prime);
        v17.i16[0] = vaddlv_u8(v17);
        unint64_t v18 = v17.u32[0];
        int v40 = v2;
        if (v17.u32[0] > 1uLL)
        {
          if (v16 >= *(void *)&prime) {
            v16 %= *(void *)&prime;
          }
        }
        else
        {
          v16 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)a1 + 8 * v16) = a1 + 16;
        uint64_t v22 = *v15;
        if (*v15)
        {
          unint64_t v42 = v17.u32[0];
          do
          {
            unint64_t v23 = *(void *)(v22 + 8);
            if (v18 > 1)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            if (v23 == v16)
            {
              char v15 = (uint64_t *)v22;
            }
            else if (*(void *)(*(void *)a1 + 8 * v23))
            {
              uint64_t v24 = *(void **)v22;
              if (*(void *)v22)
              {
                uint64_t v25 = (void *)v22;
                while (1)
                {
                  unint64_t v26 = v24;
                  if (!std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)(v22 + 16), (unsigned __int8 *)v24 + 16))break; {
                  uint64_t v24 = (void *)*v26;
                  }
                  uint64_t v25 = v26;
                  if (!*v26) {
                    goto LABEL_47;
                  }
                }
                uint64_t v24 = v26;
                unint64_t v26 = v25;
LABEL_47:
                unint64_t v18 = v42;
              }
              else
              {
                unint64_t v26 = (void *)v22;
              }
              *char v15 = (uint64_t)v24;
              *unint64_t v26 = **(void **)(*(void *)a1 + 8 * v23);
              **(void **)(*(void *)a1 + 8 * v23) = v22;
            }
            else
            {
              *(void *)(*(void *)a1 + 8 * v23) = v15;
              char v15 = (uint64_t *)v22;
              unint64_t v16 = v23;
            }
            uint64_t v22 = *v15;
          }
          while (*v15);
        }
        unint64_t v5 = (unint64_t)prime;
        uint64_t v2 = v40;
        uint64_t v4 = v41;
      }
      else
      {
        unint64_t v5 = (unint64_t)prime;
        uint64_t v4 = v41;
      }
    }
    else
    {
      float v27 = *(void **)a1;
      *(void *)a1 = 0;
      if (v27) {
        operator delete(v27);
      }
      unint64_t v5 = 0;
      *(void *)(a1 + 8) = 0;
    }
  }
LABEL_60:
  uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
  v28.i16[0] = vaddlv_u8(v28);
  unint64_t v29 = v28.u32[0];
  if (v28.u32[0] > 1uLL)
  {
    unint64_t v30 = v43;
    if (v5 <= v43) {
      unint64_t v30 = v43 % v5;
    }
  }
  else
  {
    unint64_t v30 = (v5 - 1) & v43;
  }
  uint64_t v31 = *(unsigned __int8 **)(*(void *)a1 + 8 * v30);
  if (v31)
  {
    uint64_t v32 = *(unsigned __int8 **)v31;
    if (*(void *)v31)
    {
      int v33 = 0;
      do
      {
        uint64_t v34 = v32;
        unint64_t v35 = *((void *)v32 + 1);
        if (v29 > 1)
        {
          unint64_t v36 = v35;
          if (v35 >= v5) {
            unint64_t v36 = v35 % v5;
          }
        }
        else
        {
          unint64_t v36 = v35 & (v5 - 1);
        }
        if (v36 != v30) {
          break;
        }
        BOOL v37 = v35 == v43 && std::equal_to<std::string>::operator()[abi:ne180100](v34 + 16, v4);
        if (v33 & !v37) {
          break;
        }
        v33 |= v37;
        uint64_t v32 = *(unsigned __int8 **)v34;
        uint64_t v31 = v34;
      }
      while (*(void *)v34);
    }
  }
  unint64_t v38 = v2[1];
  if (v29 > 1)
  {
    if (v38 >= v5) {
      v38 %= v5;
    }
  }
  else
  {
    v38 &= v5 - 1;
  }
  if (!v31)
  {
    *uint64_t v2 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v2;
    *(void *)(*(void *)a1 + 8 * v38) = a1 + 16;
    if (!*v2) {
      goto LABEL_95;
    }
    unint64_t v39 = *(void *)(*v2 + 8);
    if (v29 > 1)
    {
      if (v39 >= v5) {
        v39 %= v5;
      }
    }
    else
    {
      v39 &= v5 - 1;
    }
LABEL_94:
    *(void *)(*(void *)a1 + 8 * v39) = v2;
    goto LABEL_95;
  }
  *uint64_t v2 = *(void *)v31;
  *(void *)uint64_t v31 = v2;
  if (*v2)
  {
    unint64_t v39 = *(void *)(*v2 + 8);
    if (v29 > 1)
    {
      if (v39 >= v5) {
        v39 %= v5;
      }
    }
    else
    {
      v39 &= v5 - 1;
    }
    if (v39 != v38) {
      goto LABEL_94;
    }
  }
LABEL_95:
  ++*(void *)(a1 + 24);
}

void std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,float> const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    uint64_t v12 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v8)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](i + 16, a2)) {
            return;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  char v15 = (char *)operator new(0x30uLL);
  *(void *)char v15 = 0;
  *((void *)v15 + 1) = v8;
  unint64_t v16 = (std::string *)(v15 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v16, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v16->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v15 + 4) = *(void *)(a3 + 16);
  }
  *((_DWORD *)v15 + 10) = *(_DWORD *)(a3 + 24);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v22);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *(void *)char v15 = *v24;
LABEL_41:
    *uint64_t v24 = v15;
    goto LABEL_42;
  }
  *(void *)char v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v15;
  *(void *)(v23 + 8 * v3) = a1 + 16;
  if (*(void *)v15)
  {
    unint64_t v25 = *(void *)(*(void *)v15 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v25 >= v9) {
        v25 %= v9;
      }
    }
    else
    {
      v25 &= v9 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_41;
  }
LABEL_42:
  ++*(void *)(a1 + 24);
}

void sub_1A3E81DA8(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,float>,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unordered_map<std::string,float>>>(unint64_t a1)
{
  if (a1 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(40 * a1);
}

void vision::mod::ImageClassifierEspresso::~ImageClassifierEspresso(vision::mod::ImageClassifierEspresso *this)
{
  *(void *)this = &unk_1EF752700;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  vision::mod::ImageClassifierAbstract::~ImageClassifierAbstract(this);

  JUMPOUT(0x1A62562C0);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF752700;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  vision::mod::ImageClassifierAbstract::~ImageClassifierAbstract(this);
}

void vision::mod::ImageClassifierAbstract::~ImageClassifierAbstract(vision::mod::ImageClassifierAbstract *this)
{
  *(void *)this = &unk_1EF7526B0;
  uint64_t v2 = (void **)((char *)this + 8);
  unint64_t v3 = (void **)((char *)this + 72);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)this + 32);
  unint64_t v3 = v2;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
}

uint64_t vision::mod::ImageClassifierAbstract::setPriority(vision::mod::ImageClassifierAbstract *this)
{
  return 3967;
}

uint64_t vision::mod::ImageClassifierAbstract::wipeLayersMemory(vision::mod::ImageClassifierAbstract *this)
{
  return 3967;
}

void vision::mod::ImageClassifierAbstract::initLabels(vision::mod::ImageClassifierAbstract *this, const char *a2)
{
  int16x8_t v59 = 0;
  int16x8_t v60 = 0;
  int16x8_t v61 = 0;
  ImageClassifier_readLinesFromFile(&v71, a2);
  begin = v71.__begin_;
  std::vector<std::string>::pointer end = v71.__end_;
  if (v71.__begin_ != v71.__end_)
  {
    while (1)
    {
      ImageClassifier_splitAndTrim((uint64_t)&v69, begin);
      uint64_t v6 = (uint64_t)v69 + 24;
      if ((long long *)((char *)v69 + 24) == v70)
      {
        unint64_t v7 = 0;
        int16x8_t v66 = 0;
        uint64_t v67 = 0;
        uint64_t v68 = 0;
      }
      else
      {
        unint64_t v7 = 0;
        do
        {
          if (!ImageClassifier_isBooleanFlag(v6)) {
            break;
          }
          ++v7;
          v6 += 24;
        }
        while ((long long *)v6 != v70);
        int16x8_t v66 = 0;
        uint64_t v67 = 0;
        uint64_t v68 = 0;
        if (v7)
        {
          uint64_t v8 = 24;
          unint64_t v2 = v7;
          do
          {
            v62.__r_.__value_.__s.__data_[0] = ImageClassifier_stringToBool((uint64_t)v69 + v8);
            std::vector<BOOL>::push_back((uint64_t *)&v66, &v62);
            v8 += 24;
            --v2;
          }
          while (v2);
        }
      }
      unint64_t v9 = v69;
      float v10 = 0.1;
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v70 - (char *)v69) >> 3) >= v7 + 2)
      {
        float v10 = std::stof((const std::string *)v69 + v7 + 1, 0);
        unint64_t v9 = v69;
      }
      if (*((char *)v9 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v62, *(const std::string::value_type **)v9, *((void *)v9 + 1));
      }
      else
      {
        long long v11 = *v9;
        v62.__r_.__value_.__r.__words[2] = *((void *)v9 + 2);
        *(_OWORD *)&v62.__r_.__value_.__l.__data_ = v11;
      }
      std::vector<BOOL>::vector(&__p, (uint64_t)&v66);
      float v65 = v10;
      uint64_t v12 = v60;
      if (v60 >= v61) {
        break;
      }
      long long v13 = *(_OWORD *)&v62.__r_.__value_.__l.__data_;
      *((void *)v60 + 2) = *((void *)&v62.__r_.__value_.__l + 2);
      *(_OWORD *)uint64_t v12 = v13;
      memset(&v62, 0, sizeof(v62));
      *((void *)v12 + 3) = __p;
      *((_OWORD *)v12 + 2) = v64;
      std::string __p = 0;
      long long v64 = 0uLL;
      *((float *)v12 + 12) = v65;
      int16x8_t v60 = v12 + 56;
LABEL_38:
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v62.__r_.__value_.__l.__data_);
      }
      if (v66) {
        operator delete(v66);
      }
      v62.__r_.__value_.__r.__words[0] = (std::string::size_type)&v69;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v62);
      if (++begin == end) {
        goto LABEL_46;
      }
    }
    unint64_t v14 = v59;
    unint64_t v15 = 0x6DB6DB6DB6DB6DB7 * ((v60 - v59) >> 3) + 1;
    if (v15 > 0x492492492492492) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    if (0xDB6DB6DB6DB6DB6ELL * ((v61 - v59) >> 3) > v15) {
      unint64_t v15 = 0xDB6DB6DB6DB6DB6ELL * ((v61 - v59) >> 3);
    }
    if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v61 - v59) >> 3)) >= 0x249249249249249) {
      unint64_t v16 = 0x492492492492492;
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16)
    {
      if (v16 > 0x492492492492492) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float v17 = (char *)operator new(56 * v16);
    }
    else
    {
      float v17 = 0;
    }
    float v18 = &v17[8 * ((v60 - v59) >> 3)];
    *(_OWORD *)float v18 = *(_OWORD *)&v62.__r_.__value_.__l.__data_;
    std::string::size_type v19 = v62.__r_.__value_.__r.__words[2];
    unint64_t v20 = __p;
    memset(&v62, 0, sizeof(v62));
    *((void *)v18 + 2) = v19;
    *((void *)v18 + 3) = v20;
    *((_OWORD *)v18 + 2) = v64;
    long long v64 = 0uLL;
    std::string __p = 0;
    unint64_t v2 = (unint64_t)(v18 + 56);
    *((float *)v18 + 12) = v10;
    if (v12 == v14)
    {
      int16x8_t v59 = v18;
      int16x8_t v60 = v18 + 56;
      int16x8_t v61 = &v17[56 * v16];
      if (!v12)
      {
LABEL_36:
        int16x8_t v60 = (char *)v2;
        if (__p) {
          operator delete(__p);
        }
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v21 = 0;
      do
      {
        size_t v22 = &v18[v21];
        uint64_t v23 = &v12[v21];
        long long v24 = *(_OWORD *)&v12[v21 - 56];
        *((void *)v22 - 5) = *(void *)&v12[v21 - 40];
        *(_OWORD *)(v22 - 56) = v24;
        *((void *)v23 - 6) = 0;
        *((void *)v23 - 5) = 0;
        *((void *)v23 - 7) = 0;
        *((void *)v22 - 4) = *(void *)&v12[v21 - 32];
        *((void *)v22 - 3) = *(void *)&v12[v21 - 24];
        *((void *)v22 - 2) = *(void *)&v12[v21 - 16];
        *((void *)v23 - 4) = 0;
        *((void *)v23 - 3) = 0;
        *((void *)v23 - 2) = 0;
        *((_DWORD *)v22 - 2) = *(_DWORD *)&v12[v21 - 8];
        v21 -= 56;
      }
      while (&v12[v21] != v14);
      unint64_t v25 = v59;
      uint64_t v12 = v60;
      int16x8_t v59 = &v18[v21];
      int16x8_t v60 = v18 + 56;
      int16x8_t v61 = &v17[56 * v16];
      if (v12 != v25)
      {
        do
        {
          v12 -= 56;
          std::__destroy_at[abi:ne180100]<std::tuple<std::string,std::vector<BOOL>,float>,0>((uint64_t)v12);
        }
        while (v12 != v25);
        uint64_t v12 = v25;
      }
      if (!v12) {
        goto LABEL_36;
      }
    }
    operator delete(v12);
    goto LABEL_36;
  }
LABEL_46:
  v62.__r_.__value_.__r.__words[0] = (std::string::size_type)&v71;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v62);
  memset(&v62, 0, sizeof(v62));
  unint64_t v26 = v59;
  float v27 = v60;
  if (v59 != v60)
  {
    std::vector<std::string>::pointer v28 = 0;
    do
    {
      if ((unint64_t)v28 >= v62.__r_.__value_.__r.__words[2])
      {
        std::vector<std::string>::pointer v28 = std::vector<std::string>::__push_back_slow_path<std::string const&>((std::vector<std::string> *)&v62, (long long *)v26);
      }
      else
      {
        if (v26[23] < 0)
        {
          std::string::__init_copy_ctor_external(v28, *(const std::string::value_type **)v26, *((void *)v26 + 1));
        }
        else
        {
          long long v29 = *(_OWORD *)v26;
          v28->__r_.__value_.__r.__words[2] = *((void *)v26 + 2);
          *(_OWORD *)&v28->__r_.__value_.__l.__data_ = v29;
        }
        ++v28;
      }
      v62.__r_.__value_.__l.__size_ = (std::string::size_type)v28;
      v26 += 56;
    }
    while (v26 != v27);
  }
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)((char *)this + 8));
  *(std::string *)((char *)this + 8) = v62;
  memset(&v62, 0, sizeof(v62));
  v71.__begin_ = &v62;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v71);
  memset(&v62, 0, sizeof(v62));
  unint64_t v30 = v59;
  uint64_t v31 = v60;
  if (v59 != v60)
  {
    std::vector<std::string>::pointer v32 = 0;
    do
    {
      if (*((void *)v30 + 4) && (**((unsigned char **)v30 + 3) & 1) == 0)
      {
        if ((unint64_t)v32 >= v62.__r_.__value_.__r.__words[2])
        {
          std::vector<std::string>::pointer v32 = std::vector<std::string>::__push_back_slow_path<std::string const&>((std::vector<std::string> *)&v62, (long long *)v30);
        }
        else
        {
          if (v30[23] < 0)
          {
            std::string::__init_copy_ctor_external(v32, *(const std::string::value_type **)v30, *((void *)v30 + 1));
          }
          else
          {
            long long v33 = *(_OWORD *)v30;
            v32->__r_.__value_.__r.__words[2] = *((void *)v30 + 2);
            *(_OWORD *)&v32->__r_.__value_.__l.__data_ = v33;
          }
          ++v32;
        }
        v62.__r_.__value_.__l.__size_ = (std::string::size_type)v32;
      }
      v30 += 56;
    }
    while (v30 != v31);
  }
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)this + 3);
  *((std::string *)this + 3) = v62;
  memset(&v62, 0, sizeof(v62));
  v71.__begin_ = &v62;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v71);
  uint64_t v34 = (uint64_t *)((char *)this + 32);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::clear((uint64_t)this + 32);
  unint64_t v35 = v59;
  unint64_t v36 = v60;
  if (v59 == v60) {
    goto LABEL_118;
  }
  int16x8_t v58 = (void *)((char *)this + 48);
  do
  {
    if (v35[23] < 0) {
      std::string::__init_copy_ctor_external(&v62, *(const std::string::value_type **)v35, *((void *)v35 + 1));
    }
    else {
      std::string v62 = *(std::string *)v35;
    }
    int v37 = *((_DWORD *)v35 + 12);
    LODWORD(__p) = v37;
    unint64_t v38 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)&v62);
    unint64_t v39 = v38;
    unint64_t v40 = *((void *)this + 5);
    if (!v40) {
      goto LABEL_88;
    }
    uint8x8_t v41 = (uint8x8_t)vcnt_s8((int8x8_t)v40);
    v41.i16[0] = vaddlv_u8(v41);
    unint64_t v42 = v41.u32[0];
    if (v41.u32[0] > 1uLL)
    {
      unint64_t v2 = v38;
      if (v38 >= v40) {
        unint64_t v2 = v38 % v40;
      }
    }
    else
    {
      unint64_t v2 = (v40 - 1) & v38;
    }
    unint64_t v43 = *(unsigned __int8 ***)(*v34 + 8 * v2);
    if (!v43 || (int v44 = *v43) == 0)
    {
LABEL_88:
      uint64_t v46 = (char *)operator new(0x30uLL);
      *(void *)uint64_t v46 = 0;
      *((void *)v46 + 1) = v39;
      uint64_t v47 = (std::string *)(v46 + 16);
      char v48 = HIBYTE(v62.__r_.__value_.__r.__words[2]);
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(v47, v62.__r_.__value_.__l.__data_, v62.__r_.__value_.__l.__size_);
      }
      else
      {
        *(_OWORD *)&v47->__r_.__value_.__l.__data_ = *(_OWORD *)&v62.__r_.__value_.__l.__data_;
        *((void *)v46 + 4) = *((void *)&v62.__r_.__value_.__l + 2);
      }
      *((_DWORD *)v46 + 10) = v37;
      float v49 = (float)(unint64_t)(*((void *)this + 7) + 1);
      float v50 = *((float *)this + 16);
      if (!v40 || (float)(v50 * (float)v40) < v49)
      {
        BOOL v51 = (v40 & (v40 - 1)) != 0;
        if (v40 < 3) {
          BOOL v51 = 1;
        }
        unint64_t v52 = v51 | (2 * v40);
        unint64_t v53 = vcvtps_u32_f32(v49 / v50);
        if (v52 <= v53) {
          size_t v54 = v53;
        }
        else {
          size_t v54 = v52;
        }
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>((uint64_t)this + 32, v54);
        unint64_t v40 = *((void *)this + 5);
        if ((v40 & (v40 - 1)) != 0)
        {
          if (v39 >= v40) {
            unint64_t v2 = v39 % v40;
          }
          else {
            unint64_t v2 = v39;
          }
        }
        else
        {
          unint64_t v2 = (v40 - 1) & v39;
        }
      }
      uint64_t v55 = *v34;
      int v56 = *(void **)(*v34 + 8 * v2);
      if (v56)
      {
        *(void *)uint64_t v46 = *v56;
      }
      else
      {
        *(void *)uint64_t v46 = *v58;
        *int16x8_t v58 = v46;
        *(void *)(v55 + 8 * v2) = v58;
        if (!*(void *)v46) {
          goto LABEL_112;
        }
        unint64_t v57 = *(void *)(*(void *)v46 + 8);
        if ((v40 & (v40 - 1)) != 0)
        {
          if (v57 >= v40) {
            v57 %= v40;
          }
        }
        else
        {
          v57 &= v40 - 1;
        }
        int v56 = (void *)(*v34 + 8 * v57);
      }
      void *v56 = v46;
LABEL_112:
      ++*((void *)this + 7);
      if (v48 < 0) {
        goto LABEL_113;
      }
      goto LABEL_114;
    }
    while (1)
    {
      unint64_t v45 = *((void *)v44 + 1);
      if (v45 == v39) {
        break;
      }
      if (v42 > 1)
      {
        if (v45 >= v40) {
          v45 %= v40;
        }
      }
      else
      {
        v45 &= v40 - 1;
      }
      if (v45 != v2) {
        goto LABEL_88;
      }
LABEL_87:
      int v44 = *(unsigned __int8 **)v44;
      if (!v44) {
        goto LABEL_88;
      }
    }
    if (!std::equal_to<std::string>::operator()[abi:ne180100](v44 + 16, (unsigned __int8 *)&v62)) {
      goto LABEL_87;
    }
    if ((*((unsigned char *)&v62.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_113:
    }
      operator delete(v62.__r_.__value_.__l.__data_);
LABEL_114:
    v35 += 56;
  }
  while (v35 != v36);
LABEL_118:
  v62.__r_.__value_.__r.__words[0] = (std::string::size_type)&v59;
  std::vector<std::tuple<std::string,std::vector<BOOL>,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v62);
}

void sub_1A3E82714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,char a27)
{
  a13 = &a10;
  std::vector<std::tuple<std::string,std::vector<BOOL>,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  _Unwind_Resume(a1);
}

void vision::mod::ImageDescriptorProcessorEspresso::Options::~Options(id *this)
{
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierEspresso::private_t>::__on_zero_shared(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierEspresso::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753770;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierEspresso::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753770;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::vector<std::tuple<std::string,std::vector<BOOL>,float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        std::__destroy_at[abi:ne180100]<std::tuple<std::string,std::vector<BOOL>,float>,0>(v4);
      }
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<std::tuple<std::string,std::vector<BOOL>,float>,0>(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 24);
  if (v2) {
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

void sub_1A3E82D90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E830A4(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A3E8302CLL);
}

void sub_1A3E83214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E83298(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E833AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E83474(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E83554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E837A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E83974(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E83A60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8467C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E84794(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8489C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E849B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E84A58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E84AF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E84BDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E84CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E84DB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E84E9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E84F70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E85058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8513C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8526C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8539C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _stringOrDataCodingClassesSet(void)
{
  if (_stringOrDataCodingClassesSet(void)::onceToken != -1) {
    dispatch_once(&_stringOrDataCodingClassesSet(void)::onceToken, &__block_literal_global_158);
  }
  v0 = (void *)_stringOrDataCodingClassesSet(void)::classesSet;

  return v0;
}

id missingRequiredCodingKeyError(NSString *a1)
{
  uint64_t v1 = a1;
  unint64_t v2 = (void *)[[NSString alloc] initWithFormat:@"Missing the required key '%@'", v1];
  unint64_t v3 = +[VNError errorForDataUnavailableWithLocalizedDescription:v2];

  return v3;
}

void sub_1A3E854B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id unknownDataForCodingKeyError(NSString *a1)
{
  uint64_t v1 = a1;
  unint64_t v2 = (void *)[[NSString alloc] initWithFormat:@"Unknown data encoded for '%@'", v1];
  unint64_t v3 = +[VNError errorForOperationFailedErrorWithLocalizedDescription:v2];

  return v3;
}

void sub_1A3E85558(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL29_stringOrDataCodingClassesSetv_block_invoke()
{
  id v0 = objc_alloc(MEMORY[0x1E4F1CAD0]);
  uint64_t v1 = objc_opt_class();
  _stringOrDataCodingClassesSet(void)::classesSet = objc_msgSend(v0, "initWithObjects:", v1, objc_opt_class(), 0);

  return MEMORY[0x1F41817F8]();
}

void sub_1A3E85798(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E858C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A3E859F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E85B58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E85CE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL _scanNFloats(NSScanner *a1, unint64_t a2, float *a3)
{
  unint64_t v5 = a1;
  BOOL v6 = 0;
  uint64_t v7 = 0;
  do
  {
    if (![(NSScanner *)v5 scanFloat:a3]) {
      break;
    }
    BOOL v6 = ++v7 >= a2;
    ++a3;
  }
  while (a2 != v7);

  return v6;
}

void sub_1A3E85D7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E85EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__48(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  long long v4 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 96) = v4;
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void sub_1A3E860E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8623C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E863C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E86518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__3128(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v3;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

void sub_1A3E866D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E868A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E86974(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E86B1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E86C38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void AnnealContours(uint64_t a1, _DWORD *a2, int a3)
{
  uint64_t v5 = *(unsigned int *)(a1 + 4);
  BOOL v6 = malloc_type_malloc(4 * a3, 0x100004052888210uLL);
  int v7 = a2[19];
  v12[0] = a2[2];
  v12[1] = v7;
  unsigned int v8 = a2[4];
  unint64_t v14 = v6;
  uint64_t v13 = v8;
  if ((int)v5 >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 2 * v5;
    do
    {
      long long v11 = (unsigned char *)(*(void *)(a1 + 16) + 40 * *(__int16 *)(*(void *)(a1 + 8) + v9));
      if (*v11) {
        AnnealContour((uint64_t)v11, (uint64_t)v12);
      }
      v9 += 2;
    }
    while (v10 != v9);
  }
  if (v6)
  {
    free(v6);
  }
}

uint64_t AnnealContour(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  int v4 = *(unsigned __int8 *)(a1 + 8);
  int v30 = 0;
  uint64_t v29 = 0;
  int v28 = 0;
  uint64_t v27 = 0;
  float v25 = 1000000.0;
  float v26 = 1000000.0;
  if (v4) {
    int v5 = 2;
  }
  else {
    int v5 = 1;
  }
  if (*(_DWORD *)(a1 + 12) <= v5) {
    return result;
  }
  long long v24 = 0;
  uint64_t result = 0;
  do
  {
    int v23 = result;
    if (v4)
    {
      uint64_t v8 = *(void *)(a1 + 24);
      uint64_t v7 = *(void *)(a1 + 32);
    }
    else
    {
      uint64_t v7 = *(void *)(a1 + 24);
      uint64_t v8 = *(void *)v7;
      if (!*(void *)v7) {
        return result;
      }
    }
    int v9 = 0;
    uint64_t v10 = 0;
    long long v11 = *(uint64_t **)v8;
    int v12 = 1;
    do
    {
      if (v7 == v8) {
        __assert_rtn("AnnealContour", "ContourUtilities.c", 229, "sPtrPrev != sPtr");
      }
      if ((uint64_t *)v8 == v11) {
        __assert_rtn("AnnealContour", "ContourUtilities.c", 230, "sPtr != sPtrNext");
      }
      int v13 = annealTest(v7, v8, a2, (float *)&v29, &v26);
      int v14 = v13;
      if (v11)
      {
        int v15 = annealTest(v8, (uint64_t)v11, a2, (float *)&v27, &v25);
        if (v14)
        {
          if (v15)
          {
            ++v9;
            if (v26 < v25)
            {
              unint64_t v16 = (uint64_t *)annealSegments(a1, v7, (uint64_t *)v8);
              *(void *)(v7 + 20) = v29;
              *(_DWORD *)(v7 + 28) = v30;
              *(float *)(v7 + 16) = v26;
              if (!v16) {
                goto LABEL_17;
              }
              goto LABEL_20;
            }
            uint64_t v7 = annealSegments(a1, v8, v11);
            *(void *)(v8 + 20) = v27;
            *(_DWORD *)(v8 + 28) = v28;
            *(float *)(v8 + 16) = v25;
            if (!v7) {
              goto LABEL_32;
            }
LABEL_24:
            uint64_t v8 = *(void *)v7;
            if (*(void *)v7) {
              goto LABEL_42;
            }
          }
          else
          {
LABEL_19:
            unint64_t v16 = (uint64_t *)annealSegments(a1, v7, (uint64_t *)v8);
            *(void *)(v7 + 20) = v29;
            *(_DWORD *)(v7 + 28) = v30;
            *(float *)(v7 + 16) = v26;
            ++v9;
            if (v16)
            {
LABEL_20:
              uint64_t v8 = *v16;
              if (*v16) {
                long long v11 = *(uint64_t **)v8;
              }
              else {
                long long v11 = 0;
              }
              uint64_t v7 = (uint64_t)v16;
              goto LABEL_43;
            }
LABEL_17:
            uint64_t v7 = 0;
LABEL_32:
            uint64_t v8 = 0;
          }
        }
        else
        {
          if (v15)
          {
            uint64_t v7 = annealSegments(a1, v8, v11);
            *(void *)(v8 + 20) = v27;
            *(_DWORD *)(v8 + 28) = v28;
            *(float *)(v8 + 16) = v25;
            ++v9;
            if (!v7) {
              goto LABEL_32;
            }
            goto LABEL_24;
          }
          BOOL v19 = v10 == 0;
          if (!v10) {
            uint64_t v10 = v8;
          }
          unint64_t v20 = v24;
          if (v19) {
            unint64_t v20 = (void *)v7;
          }
          long long v24 = v20;
          uint64_t v8 = *v11;
          if (*v11)
          {
            uint64_t v7 = (uint64_t)v11;
LABEL_42:
            long long v11 = *(uint64_t **)v8;
            goto LABEL_43;
          }
          uint64_t v7 = (uint64_t)v11;
        }
        long long v11 = 0;
        goto LABEL_43;
      }
      if (v13) {
        goto LABEL_19;
      }
      long long v11 = 0;
      BOOL v17 = v10 == 0;
      if (!v10) {
        uint64_t v10 = v8;
      }
      float v18 = v24;
      if (v17) {
        float v18 = (void *)v7;
      }
      long long v24 = v18;
      uint64_t v7 = 0;
      uint64_t v8 = 0;
LABEL_43:
      ++v12;
      uint64_t v21 = *(void **)(a1 + 32);
      if (v4 && (void *)v8 == v21 && *(int *)(a1 + 12) >= 3)
      {
        long long v11 = *(uint64_t **)(a1 + 24);
        int v12 = -1;
      }
    }
    while (v8 && v12);
    uint64_t result = (v9 + v23);
  }
  while (v9);
  if (v4)
  {
    uint64_t v22 = *(void *)(a1 + 24);
    if (v10 != v22)
    {
      if (!v10) {
        __assert_rtn("AnnealContour", "ContourUtilities.c", 332, "rPtr != NULL");
      }
      void *v21 = v22;
      *long long v24 = 0;
      *(void *)(a1 + 24) = v10;
      *(void *)(a1 + 32) = v24;
    }
  }
  return result;
}

uint64_t annealTest(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float *a5)
{
  int v5 = *(__int16 **)(a2 + 40);
  int v6 = *v5;
  int v7 = v5[1];
  float v8 = *(float *)(a1 + 20);
  float v9 = *(float *)(a1 + 24);
  float v10 = *(float *)(a2 + 20);
  float v11 = *(float *)(a2 + 24);
  float v12 = fabsf(*(float *)(a1 + 28) + (float)((float)(v9 * (float)v7) + (float)(v8 * (float)v6)));
  float v13 = fabsf(*(float *)(a2 + 28) + (float)((float)(v11 * (float)v7) + (float)(v10 * (float)v6)));
  if (v12 <= v13) {
    float v12 = v13;
  }
  float v14 = *(float *)a3 * *(float *)(a3 + 8);
  if (v12 > v14) {
    return 0;
  }
  uint64_t v17 = *(int *)(a2 + 12);
  float v18 = *(__int16 **)(a1 + 40);
  int v19 = *v18;
  int v20 = v18[1];
  uint64_t v21 = &v5[2 * (int)v17 - 2];
  int v22 = *v21;
  int v23 = v21[1];
  float v24 = (float)(v19 - v6);
  float v25 = (float)(v20 - v7);
  float v26 = (float)(v22 - v6);
  float v27 = (float)(v23 - v7);
  if ((__PAIR64__((float)((float)(v9 * v24) - (float)(v8 * v25)) > 0.0, (float)(v9 * v24) - (float)(v8 * v25))
      - COERCE_UNSIGNED_INT(0.0)) >> 32 != (__PAIR64__((float)((float)(v9 * v26) - (float)(v8 * v27)) < 0.0, 0.0)
                                          - COERCE_UNSIGNED_INT((float)(v9 * v26) - (float)(v8 * v27))) >> 32
    || (__PAIR64__((float)((float)(v11 * v26) - (float)(v10 * v27)) > 0.0, (float)(v11 * v26) - (float)(v10 * v27))
      - COERCE_UNSIGNED_INT(0.0)) >> 32 != (__PAIR64__((float)((float)(v11 * v24) - (float)(v10 * v25)) < 0.0, 0.0)
                                          - COERCE_UNSIGNED_INT((float)(v11 * v24) - (float)(v10 * v25))) >> 32)
  {
    return 0;
  }
  uint64_t v31 = *(char **)(a3 + 16);
  int v32 = *(_DWORD *)(a1 + 12);
  uint64_t v33 = (v17 - 1 + v32);
  int v34 = v22 - v19;
  int v35 = v23 - v20;
  if (v35 >= 0) {
    unsigned int v36 = v35;
  }
  else {
    unsigned int v36 = -v35;
  }
  if (v34 >= 0) {
    unsigned int v37 = v34;
  }
  else {
    unsigned int v37 = -v34;
  }
  BOOL v38 = v36 > v37;
  BOOL v39 = v36 > v37;
  if (v38) {
    unsigned int v40 = v35;
  }
  else {
    unsigned int v40 = v34;
  }
  if (!v38) {
    int v34 = v35;
  }
  uint64_t v41 = v34 & 0x10000 | v39 | (v40 >> 31 << 8);
  int v42 = v32 - 1;
  memcpy(v31, v18, 4 * (v32 - 1));
  memcpy(&v31[4 * v42], *(const void **)(a2 + 40), 4 * v17);
  unint64_t v43 = *(__int16 **)(a3 + 16);
  applyCoordTransform(v41, (uint64_t)v43, v33);
  unint64_t v44 = straightLineLSQ(v43, v33);
  if (v14 < v45
    && fabsf((float)(*(float *)(a1 + 24) * *(float *)(a2 + 20)) - (float)(*(float *)(a1 + 20) * *(float *)(a2 + 24))) > (float)(*(float *)(a3 + 4) * *(float *)(a3 + 8)))
  {
    return 0;
  }
  if (a5) {
    *a5 = v45;
  }
  if (a4)
  {
    float v47 = Lsq2Leq(v44);
    if (v41 >= 0x10000)
    {
      float v49 = -v49;
      float v47 = -v47;
    }
    if ((v41 & 0x100) != 0)
    {
      float v49 = -v49;
      float v48 = -v48;
    }
    if (v41) {
      float v50 = v47;
    }
    else {
      float v50 = v48;
    }
    if (v41) {
      float v47 = v48;
    }
    *a4 = v47;
    a4[1] = v50;
    a4[2] = v49;
  }
  return v33;
}

uint64_t annealSegments(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if ((uint64_t *)a2 == a3) {
    __assert_rtn("annealSegments", "ContourUtilities.c", 129, "sPrevPtr != sPtr");
  }
  uint64_t v6 = *(int *)(a2 + 12);
  uint64_t v7 = *((int *)a3 + 3);
  int v8 = v6 - 1 + v7;
  if (*(void *)(a2 + 40) + 4 * v6 - 4 != a3[5])
  {
    float v9 = (char *)malloc_type_malloc(4 * v8, 0x100004052888210uLL);
    memcpy(v9, *(const void **)(a2 + 40), 4 * ((int)v6 - 1));
    memcpy(&v9[4 * v6 - 4], (const void *)a3[5], 4 * v7);
    if (!*(_WORD *)(a2 + 32))
    {
      float v10 = *(void **)(a2 + 40);
      if (v10) {
        free(v10);
      }
    }
    *(void *)(a2 + 40) = v9;
    *(_WORD *)(a2 + 32) = 0;
  }
  *(_DWORD *)(a2 + 12) = v8;
  *((unsigned char *)a3 + 8) = 0;
  if (!*((_WORD *)a3 + 16))
  {
    float v11 = (void *)a3[5];
    if (v11) {
      free(v11);
    }
    a3[5] = 0;
  }
  uint64_t result = *a3;
  if (*(void *)a2) {
    *(void *)a2 = result;
  }
  --*(_DWORD *)(a1 + 12);
  if (*(uint64_t **)(a1 + 24) == a3)
  {
    if (!result) {
      __assert_rtn("annealSegments", "ContourUtilities.c", 168, "newCurr != NULL");
    }
    *(void *)(a1 + 24) = result;
  }
  else if (*(uint64_t **)(a1 + 32) == a3)
  {
    *(void *)(a1 + 32) = a2;
  }
  return result;
}

uint64_t createBridgeSegment(int *a1, int a2, int a3, int a4)
{
  uint64_t v7 = allocSegments(a1, 1);
  uint64_t v8 = v7;
  *(void *)uint64_t v7 = 0;
  *(_DWORD *)(v7 + 32) = a2;
  if ((__int16)a4 - (__int16)a3 >= 0) {
    unsigned int v9 = (__int16)a4 - (__int16)a3;
  }
  else {
    unsigned int v9 = (__int16)a3 - (__int16)a4;
  }
  if ((a4 >> 16) - (a3 >> 16) >= 0) {
    unsigned int v10 = (a4 >> 16) - (a3 >> 16);
  }
  else {
    unsigned int v10 = (a3 >> 16) - (a4 >> 16);
  }
  if (v9 <= v10) {
    unsigned int v11 = v10;
  }
  else {
    unsigned int v11 = v9;
  }
  int v12 = v11 + 1;
  *(_DWORD *)(v7 + 12) = v11 + 1;
  float v13 = malloc_type_malloc(4 * (v11 + 1), 0x100004052888210uLL);
  *(void *)(v8 + 40) = v13;
  if (BresenhamCoords(a3, a4, (uint64_t)v13) != v12) {
    __assert_rtn("createBridgeSegment", "ContourUtilities.c", 557, "mPnts == nPnts");
  }
  if (v10 <= v9) {
    unsigned int v14 = (__int16)a4 - (__int16)a3;
  }
  else {
    unsigned int v14 = (a4 >> 16) - (a3 >> 16);
  }
  if (v10 <= v9) {
    int v15 = (a4 >> 16) - (a3 >> 16);
  }
  else {
    int v15 = (__int16)a4 - (__int16)a3;
  }
  unsigned int v16 = v15 & 0x10000 | (v10 > v9) | (v14 >> 31 << 8);
  applyCoordTransform(v16, *(void *)(v8 + 40), v12);
  unint64_t v17 = straightLineLSQ(*(__int16 **)(v8 + 40), v12);
  *(_DWORD *)(v8 + 16) = v18;
  *(float *)(v8 + 20) = Lsq2Leq(v17);
  *(_DWORD *)(v8 + 24) = v19;
  *(_DWORD *)(v8 + 28) = v20;
  revertSegmentCoordinateSystem(v8, v12, v16);
  return v8;
}

void calculateContourPartialAreaAndPerimeter(uint64_t a1, float *a2, float *a3, float *a4, float *a5, float *a6, float *a7)
{
  uint64_t v7 = *(uint64_t **)(a1 + 24);
  int v8 = *(_DWORD *)(a1 + 12);
  unsigned int v9 = (signed __int16 *)v7[5];
  int v61 = v8;
  if (v8 < 2)
  {
    uint64_t v31 = a3;
    int v32 = a2;
    __int16 v35 = 0;
    __int16 v65 = 0;
    int v24 = 0;
    int v25 = 0;
    float v18 = 0.0;
    float v16 = 0.0;
    int v33 = v9[1];
    int v22 = v33;
    int v34 = *v9;
    int v20 = v34;
    float v14 = 0.0;
  }
  else
  {
    int v10 = 0;
    int v11 = 0;
    __int16 v12 = 0;
    int v13 = 0;
    float v14 = 0.0;
    int v52 = *v9;
    int v53 = v9[1];
    signed __int16 v15 = *v9;
    float v16 = 0.0;
    __int16 v17 = v9[1];
    float v18 = 0.0;
    unsigned int v19 = 1;
    do
    {
      uint64_t v7 = (uint64_t *)*v7;
      unsigned int v9 = (signed __int16 *)v7[5];
      int v20 = *v9;
      signed __int16 v21 = *v9;
      int v22 = v9[1];
      __int16 v23 = v9[1];
      int v24 = v20 - v15;
      int v25 = v22 - v17;
      if (v19 < 2)
      {
        int v13 = (unsigned __int16)*v9;
        __int16 v12 = v9[1];
      }
      else
      {
        int v63 = v13;
        int v64 = v9[1];
        float v26 = v7;
        int v27 = v20 - v15;
        int v28 = v22 - v17;
        int v29 = *v9;
        __int16 v62 = v9[1];
        float v30 = atan2f((float)(v25 * v11 - v24 * v10), (float)(v24 * v11 + v25 * v10));
        __int16 v23 = v62;
        int v13 = v63;
        int v22 = v64;
        int v20 = v29;
        int v25 = v28;
        int v24 = v27;
        uint64_t v7 = v26;
        int v8 = v61;
        float v14 = v14 + v30;
      }
      float v18 = v18 + sqrtf((float)(v24 * v24 + v25 * v25));
      ++v19;
      int v10 = v25;
      float v16 = v16 + (float)(v22 * v15 - v20 * v17);
      int v11 = v24;
      __int16 v17 = v23;
      signed __int16 v15 = v21;
    }
    while (v8 != v19);
    uint64_t v31 = a3;
    int v32 = a2;
    int v34 = v52;
    int v33 = v53;
    __int16 v65 = v12;
    __int16 v35 = v13;
  }
  unsigned int v36 = &v9[2 * *((int *)v7 + 3)];
  int v37 = *(v36 - 2);
  int v38 = *(v36 - 1);
  int v39 = v37 - v20;
  int v40 = v38 - v22;
  float v41 = v16 + (float)(v20 * v38 - v22 * v37);
  float v42 = atan2f((float)(v40 * v24 - v39 * v25), (float)(v39 * v24 + v40 * v25));
  *uint64_t v31 = v18 + sqrtf((float)(v39 * v39 + v40 * v40));
  *int v32 = v41;
  *a4 = v14 + v42;
  if (v61 == 1) {
    __int16 v35 = v37;
  }
  __int16 v43 = v65;
  if (v61 == 1) {
    __int16 v43 = v38;
  }
  __int16 v66 = v43;
  int v44 = v34 - v37;
  int v45 = v33;
  int v46 = v33 - v38;
  float v47 = sqrtf((float)(v44 * v44 + v46 * v46));
  float v48 = (float)(v45 * v37 - v34 * v38);
  float v49 = 0.0;
  float v50 = atan2f((float)(v46 * v39 - v40 * v44), (float)(v39 * v44 + v40 * v46)) + 0.0;
  float v51 = v50 + atan2f((float)((v66 - v45) * v44 - (v35 - v34) * v46), (float)((v35 - v34) * v44 + (v66 - v45) * v46));
  if (*(unsigned char *)(a1 + 8))
  {
    *a3 = v47 + *a3;
    *a2 = *a2 + v48;
    *a4 = v51 + *a4;
    float v48 = 0.0;
    float v51 = 0.0;
  }
  else
  {
    float v49 = v47;
  }
  *a6 = v49;
  *a5 = v48;
  *a7 = v51;
}

uint64_t reverseContour(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 24);
  if (v2)
  {
    uint64_t v3 = 0;
    int v4 = 0;
    uint64_t v5 = 65534;
    uint64_t v6 = *(void **)(result + 24);
    do
    {
      uint64_t v7 = v4;
      int v4 = v6;
      uint64_t v6 = (void *)*v6;
      *int v4 = v7;
      uint64_t v8 = *((__int16 *)v4 + 16);
      if (v8 <= 0)
      {
        int v9 = *((_DWORD *)v4 + 3);
        if (v9 >= 2)
        {
          int v10 = (int *)v4[5];
          unsigned int v11 = v9 >> 1;
          __int16 v12 = &v10[v9 - 1];
          do
          {
            int v13 = *v12;
            *v12-- = *v10;
            *v10++ = v13;
            --v11;
          }
          while (v11);
        }
      }
      else
      {
        if (*((unsigned __int16 *)v4 + 16) == (unsigned __int16)v5)
        {
          if (!v3) {
            __assert_rtn("reverseContour", "ContourUtilities.c", 1753, "currCPtr != NULL");
          }
        }
        else
        {
          uint64_t v14 = *(void *)(a2 + 16);
          uint64_t v3 = v14 + 40 * v8;
          int v15 = *(_DWORD *)(v3 + 4);
          if (v15 >= 2)
          {
            float v16 = *(int **)(v14 + 40 * v8 + 16);
            unsigned int v17 = v15 >> 1;
            float v18 = &v16[v15 - 1];
            do
            {
              int v19 = *v18;
              *v18-- = *v16;
              *v16++ = v19;
              --v17;
            }
            while (v17);
          }
          uint64_t v5 = v8;
        }
        v4[5] = *(void *)(v3 + 16)
              + 4 * (*(int *)(v3 + 4) - (*((int *)v4 + 3) + ((v4[5] - *(void *)(v3 + 16)) >> 2)));
        uint64_t v8 = v5;
      }
      uint64_t v5 = v8;
    }
    while (v6);
  }
  else
  {
    int v4 = 0;
  }
  *(void *)(result + 24) = v4;
  *(void *)(result + 32) = v2;
  return result;
}

void MergeContours(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v11 = *(unsigned int *)(a1 + 4);
  unsigned int v12 = llroundf(*(float *)(a2 + 104));
  int v13 = malloc_type_malloc(4 * v12 * v12, 0x100004052888210uLL);
  int v27 = malloc_type_malloc(4 * v12 * v12, 0x100004052888210uLL);
  uint64_t v14 = malloc_type_malloc(8 * v12 * v12, 0x100004000313F17uLL);
  int v15 = malloc_type_malloc(4 * v12 * v12, 0x100004052888210uLL);
  float v16 = malloc_type_malloc(4 * a3, 0x100004052888210uLL);
  unsigned int v17 = v13;
  float v18 = malloc_type_malloc(2 * v12 * v12, 0x1000040BDFB0063uLL);
  v34[0] = (unsigned __int16)v12;
  BYTE2(v34[0]) = *(unsigned char *)(a2 + 112);
  v34[1] = a5;
  v34[2] = a6;
  v34[3] = v13;
  v34[4] = v27;
  int v29 = v14;
  uint64_t v31 = v16;
  v34[5] = v14;
  void v34[6] = v15;
  int v33 = v18;
  v34[7] = v18;
  v34[8] = v16;
  int v19 = *(_DWORD *)(a2 + 76);
  int v20 = *(_DWORD *)(a2 + 80);
  int v35 = *(_DWORD *)(a2 + 8);
  int v36 = v19;
  int v21 = *(_DWORD *)(a2 + 92);
  int v37 = *(_DWORD *)(a2 + 88);
  int v38 = v20;
  int v39 = *(_DWORD *)(a2 + 108);
  int v40 = v21;
  uint64_t v41 = a1;
  uint64_t v42 = a4;
  if ((int)v11 >= 1)
  {
    for (uint64_t i = 0; i != v11; ++i)
    {
      uint64_t v23 = *(void *)(a1 + 16);
      int v24 = (unsigned char *)(v23 + 40 * *(__int16 *)(*(void *)(a1 + 8) + 2 * i));
      if (*v24)
      {
        int v25 = 0;
        float v26 = (unsigned char *)(v23 + 40 * *(__int16 *)(*(void *)(a1 + 8) + 2 * i) + 8);
        do
        {
          if (!*v26)
          {
            int v25 = mergeContourEnd((uint64_t)v24, (__int16 *)v34, 1, a7);
            if (!v25) {
              int v25 = mergeContourEnd((uint64_t)v24, (__int16 *)v34, 0, a7);
            }
          }
        }
        while (v25 > 0);
      }
    }
  }
  if (v17) {
    free(v17);
  }
  if (v29) {
    free(v29);
  }
  if (v15) {
    free(v15);
  }
  if (v31) {
    free(v31);
  }
  if (v33) {
    free(v33);
  }
  if (v27)
  {
    free(v27);
  }
}

uint64_t mergeContourEnd(uint64_t a1, __int16 *a2, int a3, int a4)
{
  uint64_t v6 = *(void *)(a1 + 24);
  v230 = (void *)(a1 + 24);
  int v7 = *(__int16 *)(v6 + 34);
  if (a3)
  {
    uint64_t v8 = *(__int16 **)(v6 + 40);
    int v9 = (unsigned __int16 *)&v8[2 * *(int *)(v6 + 12) - 2];
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v9 = *(unsigned __int16 **)(v6 + 40);
    uint64_t v8 = (__int16 *)&v9[2 * *(int *)(v6 + 12) - 2];
  }
  float v231 = *((float *)a2 + 18);
  float v229 = *((float *)a2 + 19);
  float v227 = *((float *)a2 + 21);
  int v10 = (unsigned __int16)*v8;
  int v11 = v8[1];
  int v232 = (__int16)*v9;
  int v233 = (__int16)v9[1];
  signed int v12 = vcvtms_s32_f32(sqrtf((float)((v11 - v233) * (v11 - v233) + ((__int16)v10 - v232) * ((__int16)v10 - v232))));
  __int16 v13 = v12 - 1;
  if (*a2 < v12) {
    __int16 v13 = *a2;
  }
  uint64_t v14 = (void *)*((void *)a2 + 2);
  uint64_t v15 = v14[2];
  if (v15 - 1 >= (unint64_t)(v13 + (__int16)v10)) {
    int v16 = v13 + (__int16)v10;
  }
  else {
    int v16 = v15 - 1;
  }
  unint64_t v17 = v14[1] - 1;
  if (v17 >= v11 + v13) {
    unint64_t v17 = v11 + v13;
  }
  unint64_t v265 = *(void *)(*((void *)a2 + 12) + 16);
  uint64_t v261 = v265 + 40 * v7 + 24;
  uint64_t v263 = *((void *)a2 + 7);
  float v18 = *(unsigned __int16 **)(*(void *)v261 + 40);
  uint64_t v250 = v265 + 40 * v7;
  uint64_t v249 = v250 + 32;
  uint64_t v19 = *(void *)(*(void *)v249 + 40) + 4 * *(int *)(*(void *)v249 + 12);
  int v20 = *(unsigned __int16 *)(v19 - 4);
  int v21 = *(unsigned __int16 *)(v19 - 2);
  if (v10 == *v18 && v18[1] == (unsigned __int16)v11)
  {
    int v248 = 1;
  }
  else
  {
    if (v10 != v20 || v21 != (unsigned __int16)v11) {
      __assert_rtn("mergeEndpointSearch4", "ContourUtilities.c", 1265, "code1 != -1");
    }
    int v248 = 0;
  }
  unint64_t v22 = (v17 << 48) | ((unint64_t)((v11 - v13) & ~((v11 - v13) >> 31)) << 32);
  int v23 = (__int16)((v11 - v13) & ~(unsigned __int16)((v11 - v13) >> 31));
  unint64_t v24 = HIDWORD(v22);
  if (v23 >= SHIDWORD(v22) >> 16) {
    return 0;
  }
  uint64_t v234 = v6;
  unint64_t v25 = 0;
  int v228 = (unsigned __int16)v7;
  int v224 = (unsigned __int16)v7;
  int v26 = ((__int16)v10 - v13) & ~(((__int16)v10 - v13) >> 31);
  uint64_t v251 = *((void *)a2 + 4);
  uint64_t v244 = *((void *)a2 + 6);
  v245 = (const float *)*((void *)a2 + 3);
  v246 = (vDSP_Length *)*((void *)a2 + 5);
  float v235 = *((float *)a2 + 22);
  unint64_t v27 = ((__int16)v26 - (__int16)v10);
  int v241 = (v26 | (v16 << 16)) >> 16;
  int v242 = (__int16)v26;
  int v28 = v241 - (__int16)v10;
  int v240 = ((int)v24 >> 16) - v11;
  int v29 = v23 - v11;
  int v223 = v10;
  int v237 = ((__int16)v26 + v10 - (__int16)v10) << 16;
  int v238 = v11;
  int v226 = (__int16)v10;
  uint64_t v239 = 2 * (int)v15;
  float v30 = 1.0;
  uint64_t v31 = *v14 + 2 * v23 * (int)v15 + 2 * (__int16)v26;
  __int16 v243 = (v10 - v13) & ~(unsigned __int16)(((__int16)v10 - v13) >> 31);
  v266 = a2;
  int v267 = a4;
  unint64_t v260 = v27;
  LODWORD(v259) = v28;
  do
  {
    if (v242 < v241)
    {
      uint64_t v32 = 0;
      __int16 v275 = v238 + v29;
      int v247 = v29 * v29;
      int v33 = v237;
      int v270 = v29;
      uint64_t v268 = v31;
      do
      {
        int v34 = *(__int16 *)(v31 + 2 * v32);
        if (v34 > 0) {
          int v35 = 1;
        }
        else {
          int v35 = a4;
        }
        if (!((v27 + v32) | v29)) {
          goto LABEL_62;
        }
        if (!*(_WORD *)(v31 + 2 * v32) || v35 == 0) {
          goto LABEL_62;
        }
        if (v34 < 0) {
          int v34 = -v34;
        }
        *(_WORD *)(v263 + 2 * (int)v25) = v34;
        uint64_t v37 = v265 + 40 * (__int16)v34;
        uint64_t v39 = *(void *)(v37 + 24);
        uint64_t v38 = *(void *)(v37 + 32);
        int v40 = *(__int16 **)(v39 + 40);
        int v41 = *v40;
        uint64_t v42 = *(__int16 **)(v38 + 40);
        __int16 v43 = &v42[2 * *(int *)(v38 + 12)];
        unint64_t v278 = v27 + v32;
        unint64_t v279 = v25;
        int v273 = *(v43 - 2);
        int v271 = *(v43 - 1);
        if (v33 >> 16 == v41 && v40[1] == v275)
        {
          int v44 = 1;
        }
        else
        {
          if (v33 >> 16 != *(v43 - 2) || v275 != *(v43 - 1)) {
            __assert_rtn("mergeEndpointSearch4", "ContourUtilities.c", 1316, "code2 != -1");
          }
          int v44 = 0;
        }
        uint64_t v285 = 0;
        *(void *)v286 = 0;
        uint64_t v283 = 0;
        uint64_t v284 = 0;
        uint64_t v282 = 0;
        float v281 = 0.0;
        float v45 = *((float *)a2 + 18);
        int v46 = *(unsigned __int16 *)(v39 + 34);
        uint64_t v47 = *(void *)v261;
        int v48 = *(unsigned __int16 *)(*(void *)v261 + 34);
        calculateContourPartialAreaAndPerimeter(v37, &v286[1], (float *)&v284 + 1, (float *)&v282 + 1, (float *)&v285 + 1, (float *)&v283 + 1, &v281);
        float v49 = *((float *)&v284 + 1);
        float v50 = v286[1];
        float v51 = *((float *)&v282 + 1);
        float v52 = *((float *)&v284 + 1) + *((float *)&v283 + 1);
        float v53 = v286[1] + *((float *)&v285 + 1);
        if (v46 == v48)
        {
          a2 = v266;
          a4 = v267;
          int v54 = v278;
          unint64_t v25 = v279;
          unint64_t v27 = v260;
          int v28 = v259;
          int v29 = v270;
          uint64_t v31 = v268;
          if (v53 < (float)(v45 * v52) || roundf(fabsf(*((float *)&v282 + 1) + v281) / 6.2832) != v30) {
            goto LABEL_62;
          }
          float v55 = 1000.0;
        }
        else
        {
          int v56 = v40[1];
          unint64_t v57 = &v40[2 * *(int *)(v39 + 12)];
          int v58 = *(v57 - 2);
          LODWORD(v255) = *(v57 - 1);
          int v59 = *v42;
          int v60 = v42[1];
          calculateContourPartialAreaAndPerimeter(v250, v286, (float *)&v284, (float *)&v282, (float *)&v285, (float *)&v283, &v280);
          LODWORD(v258) = v59;
          LODWORD(v257) = v60;
          LODWORD(v256) = v58;
          if (v248 == v44)
          {
            float v61 = v50 - v286[0];
            float v252 = -(float)(v286[0] + *(float *)&v285);
            *(float *)&unint64_t v253 = v51 - *(float *)&v282;
            __int16 v62 = *(__int16 **)(v47 + 40);
            int v63 = &v62[2 * *(int *)(v47 + 12) - 2];
            int v64 = *(__int16 **)(*(void *)v249 + 40);
            __int16 v65 = &v64[2 * *(int *)(*(void *)v249 + 12) - 2];
          }
          else
          {
            float v61 = v50 + v286[0];
            float v252 = v286[0] + *(float *)&v285;
            *(float *)&unint64_t v253 = v51 + *(float *)&v282;
            __int16 v65 = *(__int16 **)(v47 + 40);
            int v64 = &v65[2 * *(int *)(v47 + 12) - 2];
            int v63 = *(__int16 **)(*(void *)v249 + 40);
            __int16 v62 = &v63[2 * *(int *)(*(void *)v249 + 12) - 2];
          }
          float v66 = v49 + *(float *)&v284;
          float v67 = *(float *)&v284 + *(float *)&v283;
          int v68 = v64[1];
          int v69 = *v64;
          int v70 = v62[1];
          int v71 = *v62;
          int v72 = v65[1];
          int v73 = *v65;
          int v74 = v41 - v71;
          int v75 = v56 - v70;
          float v76 = v66 + sqrtf((float)(v75 * v75 + v74 * v74));
          float v77 = v61 + (float)(v71 * v56 - v70 * v41);
          LODWORD(v254) = atan2f((float)((v71 - *v63) * v75 - v74 * (v70 - v63[1])), (float)((v70 - v63[1]) * v75 + (v71 - *v63) * v74));
          float v78 = atan2f((float)(v74 * ((int)v255 - v56) - v75 * ((int)v256 - v41)), (float)(v75 * ((int)v255 - v56) + v74 * ((int)v256 - v41)));
          int v79 = v73 - v273;
          int v80 = v72 - v271;
          float v81 = v76 + sqrtf((float)(v80 * v80 + v79 * v79));
          float v82 = atan2f((float)(v80 * (v273 - (int)v258) - v79 * (v271 - (int)v257)), (float)(v80 * (v271 - (int)v257) + v79 * (v273 - (int)v258)));
          float v83 = atan2f((float)(v79 * (v68 - v72) - (v69 - v73) * v80), (float)(v80 * (v68 - v72) + v79 * (v69 - v73)));
          float v84 = fabsf(v53);
          float v85 = fabsf(v252);
          float v86 = fabsf(v77 + (float)(v72 * v273 - v73 * v271));
          float v55 = 1.0;
          if (v86 < (float)(v45 * v81) && v84 < (float)(v45 * v52) && v85 < (float)(v45 * v67))
          {
            a2 = v266;
            a4 = v267;
            int v54 = v278;
            unint64_t v25 = v279;
            unint64_t v27 = v260;
            int v28 = v259;
            int v29 = v270;
            float v30 = 1.0;
            uint64_t v31 = v268;
            float v89 = *(float *)&v253;
          }
          else
          {
            if (v84 <= v85) {
              float v84 = v85;
            }
            a2 = v266;
            a4 = v267;
            int v54 = v278;
            unint64_t v25 = v279;
            unint64_t v27 = v260;
            int v28 = v259;
            int v29 = v270;
            float v30 = 1.0;
            uint64_t v31 = v268;
            float v89 = *(float *)&v253;
            if (v84 != 0.0)
            {
              if (v52 <= v67) {
                float v90 = v67;
              }
              else {
                float v90 = v52;
              }
              float v55 = (float)((float)(v86 / v84) * *((float *)v266 + 20)) / (float)(v81 / v90);
            }
          }
          if ((float)(roundf(fabsf((float)((float)((float)((float)((float)(v89 + *(float *)&v254) + v78) + v82) + v83) * 180.0)/ 3.1416))/ 360.0) != v30|| v55 < v30)
          {
            goto LABEL_62;
          }
        }
        int8x16_t v91 = (_WORD *)(v244 + 4 * (int)v25);
        _WORD *v91 = v243 + v32;
        v91[1] = v275;
        v245[(int)v25] = (float)(v247 + v54 * v54);
        v246[(int)v25] = (int)v25;
        *(float *)(v251 + 4 * (int)v25) = v55;
        unint64_t v25 = (v25 + 1);
LABEL_62:
        ++v32;
        v33 += 0x10000;
      }
      while ((int)v27 + (int)v32 < v28);
    }
    ++v29;
    v31 += v239;
  }
  while (v29 < v240);
  if (!v25) {
    return 0;
  }
  vDSP_vsorti(v245, v246, 0, (int)v25, 1);
  if ((int)v25 < 1) {
    return 0;
  }
  uint64_t v92 = 0;
  uint64_t v93 = v25;
  int8x16_t v94 = (float *)v234;
  while (v245[v246[v92]] <= v235)
  {
    if (v25 == ++v92) {
      goto LABEL_71;
    }
  }
  LODWORD(v25) = v92;
LABEL_71:
  if (v25 >= 2)
  {
    unsigned int v95 = v25 - 1;
    int v96 = 1;
    do
    {
      if ((int)v25 > v96)
      {
        vDSP_Length v97 = *v246;
        uint64_t v98 = v95;
        int16x8_t v99 = v246 + 1;
        do
        {
          if (*(float *)(v251 + 4 * (int)v97) >= *(float *)(v251 + ((uint64_t)(*v99 << 32) >> 30)))
          {
            vDSP_Length v97 = *v99;
          }
          else
          {
            *(v99 - 1) = *v99;
            vDSP_Length *v99 = v97;
          }
          ++v99;
          --v98;
        }
        while (v98);
      }
      ++v96;
      --v95;
    }
    while (v96 != v25);
  }
  uint64_t v100 = 0;
  float v101 = (float)v226;
  float v102 = (float)v238;
  uint64_t v264 = a1 + 32;
  uint64_t v272 = v93;
  while (2)
  {
    uint64_t v103 = *(void *)(*((void *)a2 + 5) + 8 * v100);
    uint64_t v104 = *(__int16 *)(*((void *)a2 + 7) + 2 * (int)v103);
    uint64_t v105 = *(void *)(*((void *)a2 + 12) + 16);
    int16x8_t v106 = (unsigned char *)(v105 + 40 * v104);
    if (!*v106) {
      __assert_rtn("mergeContourEnd", "ContourUtilities.c", 1467, "cPtr2->active");
    }
    uint64_t v107 = (int)v103;
    int32x4_t v108 = (unsigned __int16 *)(*((void *)a2 + 6) + 4 * (int)v103);
    int v109 = *v108;
    int v110 = (__int16)v109;
    int v111 = (__int16)v108[1];
    uint64_t v112 = v105 + 40 * (int)v104;
    uint64_t v115 = *(void *)(v112 + 24);
    int16x8_t v114 = (void *)(v112 + 24);
    uint64_t v113 = v115;
    int16x8_t v116 = *(unsigned __int16 **)(v115 + 40);
    if (*v116 == v109 && v116[1] == (unsigned __int16)v111)
    {
      int16x8_t v117 = (int *)&v116[2 * *(int *)(v113 + 12) - 2];
      uint64_t v118 = *(void *)(v105 + 40 * (int)v104 + 32);
      uint64_t v119 = *(void *)(v118 + 40);
      int v120 = *(_DWORD *)(v118 + 12);
      int16x8_t v121 = (int *)(v119 + 4 * (v120 - 1));
      int v122 = 1;
    }
    else
    {
      uint64_t v113 = *(void *)(v105 + 40 * (int)v104 + 32);
      uint64_t v119 = *(void *)(v113 + 40);
      int v120 = *(_DWORD *)(v113 + 12);
      if (*(unsigned __int16 *)(v119 + 4 * (v120 - 1)) != (unsigned __int16)v110
        || *(unsigned __int16 *)(v119 + 4 * (v120 - 1) + 2) != (unsigned __int16)v111)
      {
        __assert_rtn("mergeContourEnd", "ContourUtilities.c", 1482, "PCOORD_EQUAL(sPtr2->pary[sPtr2->nPnts-1], pc3)");
      }
      int v122 = 0;
      int16x8_t v117 = *(int **)(v113 + 40);
      int16x8_t v121 = (int *)v116;
    }
    int v123 = *v117;
    int v124 = *v121;
    if (a4 && *(float *)(*((void *)a2 + 3) + 4 * v107) > 8.0)
    {
      float v125 = v94[5];
      float v126 = v94[6];
      float v127 = v94[7];
      float v128 = *(float *)(v113 + 20);
      float v129 = *(float *)(v113 + 24);
      float v130 = *(float *)(v113 + 28);
      float v131 = v126 * (float)v111;
      float v132 = v127 + (float)(v131 + (float)(v125 * (float)v110));
      float v133 = fabsf(v132);
      float v134 = v130 + (float)((float)(v129 * v102) + (float)(v128 * v101));
      float v135 = fabsf(v134);
      if (v133 <= v135) {
        float v133 = v135;
      }
      if (v133 <= (float)(v231 + v231))
      {
        int v136 = (__PAIR64__((float)((float)(v126 * (float)(v232 - v226)) - (float)(v125 * (float)(v233 - v238))) > 0.0, (float)(v126 * (float)(v232 - v226)) - (float)(v125 * (float)(v233 - v238)))- COERCE_UNSIGNED_INT(0.0)) >> 32;
        int v137 = (__int16)v123;
        int v138 = *v117;
        int v139 = v123 >> 16;
        float v140 = (float)(v129 * (float)(v137 - v110)) - (float)(v128 * (float)(v139 - v111));
        BOOL v141 = v140 > 0.0;
        BOOL v142 = v140 < 0.0;
        float v143 = (float)(v126 * (float)(v110 - v226)) - (float)(v125 * (float)(v111 - v238));
        BOOL v276 = v143 > 0.0;
        BOOL v144 = v143 < 0.0;
        float v145 = (float)(v129 * (float)(v226 - v110)) - (float)(v128 * (float)(v238 - v111));
        BOOL v146 = v145 > 0.0;
        BOOL v147 = v145 < 0.0;
        *(float *)&unsigned int v148 = (float)(v126 * (float)(v137 - v226)) - (float)(v125 * (float)(v139 - v238));
        int v123 = v138;
        if (v136 == (__PAIR64__(*(float *)&v148 < 0.0, 0.0) - v148) >> 32)
        {
          int v149 = v141 - v142;
          *(float *)&unsigned int v150 = (float)((float)(v233 - v111) * (float)-v128) + (float)(v129 * (float)(v232 - v110));
          if (v149 == (__PAIR64__(*(float *)&v150 < 0.0, 0.0) - v150) >> 32
            && (v223 == (unsigned __int16)v110 && v238 == v111 || v136 == v144 - v276 && v149 == v147 - v146))
          {
            char v151 = 0;
            goto LABEL_110;
          }
        }
      }
      if (fabsf((float)(v125 * v129) - (float)(v126 * v128)) < v227
        || (v232 == v110 ? (BOOL v152 = v233 == v111) : (BOOL v152 = 0),
            !v152
         && ((int v154 = (__PAIR64__(v132 > 0.0, LODWORD(v132)) - COERCE_UNSIGNED_INT(0.0)) >> 32,
              *(float *)&unsigned int v153 = v127
                              + (float)((float)(v126 * (float)(v123 >> 16)) + (float)(v125 * (float)(__int16)v123)),
              (__PAIR64__(*(float *)&v153 > 0.0, v153) - COERCE_UNSIGNED_INT(0.0)) >> 32 != v154)
          && v154 != (__PAIR64__((float)(v127 + (float)((float)(v126 * v102) + (float)(v125 * v101))) > 0.0, v127 + (float)((float)(v126 * v102) + (float)(v125 * v101)))- COERCE_UNSIGNED_INT(0.0)) >> 32|| (*(float *)&unsigned int v155 = v130 + (float)((float)(v129 * (float)v233) + (float)(v128 * (float)v232)), v156 = (__PAIR64__(v134 > 0.0, LODWORD(v134)) - COERCE_UNSIGNED_INT(0.0)) >> 32, (__PAIR64__(*(float *)&v155 > 0.0, v155) - COERCE_UNSIGNED_INT(0.0)) >> 32 != v156)&& v156 != (__PAIR64__((float)(v127 + (float)(v131 + (float)(v128 * (float)v110))) > 0.0, v127 + (float)(v131 + (float)(v128 * (float)v110)))- COERCE_UNSIGNED_INT(0.0)) >> 32)))
      {
LABEL_153:
        if (++v100 == v93) {
          return 0;
        }
        continue;
      }
    }
    break;
  }
  char v151 = 1;
LABEL_110:
  uint64_t v157 = (unsigned __int16 *)(v119 + 4 * (v120 - 1));
  int v269 = v124;
  int v274 = v123;
  if (a3)
  {
    if (v122 == a3) {
      uint64_t v157 = v116;
    }
    int16x8_t v116 = *(unsigned __int16 **)(*v230 + 40);
  }
  else
  {
    if (!v122) {
      int16x8_t v116 = v157;
    }
    uint64_t v157 = (unsigned __int16 *)(*(void *)(*(void *)v264 + 40) + 4 * *(int *)(*(void *)v264 + 12) - 4);
  }
  uint64_t v158 = *(unsigned int *)v116;
  uint64_t v277 = *(unsigned int *)v157;
  unint64_t v278 = v278 & 0xFFFFFFFF00000000 | v277;
  unint64_t v279 = v279 & 0xFFFFFFFF00000000 | v158;
  if (!checkBridgeCrossing((uint64_t)a2, v277, *(_DWORD *)v116))
  {
    int8x16_t v94 = (float *)v234;
    uint64_t v93 = v272;
    goto LABEL_153;
  }
  uint64_t v159 = a3 | (2 * v122);
  if ((v151 & 1) != 0
    || fabsf((float)(*(float *)(v234 + 24) * *(float *)(v113 + 20)) - (float)(*(float *)(v234 + 20)
                                                                            * *(float *)(v113 + 24))) <= v229)
  {
    int v160 = v158;
    uint64_t BridgeSegment = createBridgeSegment(*((int **)a2 + 13), v224 << 16, v277, v158);
    __int16 v199 = v228;
    if (v228 != (unsigned __int16)v104) {
      goto LABEL_165;
    }
    goto LABEL_159;
  }
  int v160 = v158;
  if (v228 == (unsigned __int16)v104)
  {
    uint64_t BridgeSegment = createBridgeSegment(*((int **)a2 + 13), v224 << 16, v277, v158);
LABEL_159:
    *(unsigned char *)(a1 + 8) = 1;
    ++*(_DWORD *)(a1 + 12);
    **(void **)(a1 + 32) = BridgeSegment;
    *(void *)uint64_t BridgeSegment = 0;
    *(void *)(a1 + 32) = BridgeSegment;
    if ((v159 - 3) <= 0xFFFFFFFD) {
      __assert_rtn("mergeContourEnd", "ContourUtilities.c", 1633, "(code == 1) || (code == 2)");
    }
    uint64_t v200 = *(unsigned int *)(BridgeSegment + 12);
    if ((int)v200 >= 1)
    {
      v201 = (uint64_t *)*((void *)a2 + 1);
      uint64_t v202 = *v201;
      uint64_t v203 = v201[3] << 32;
      v204 = (__int16 *)(*(void *)(BridgeSegment + 40) + 2);
      do
      {
        *(unsigned char *)(v202 + *(v204 - 1) + ((v203 * *v204) >> 32)) = 1;
        v204 += 2;
        --v200;
      }
      while (v200);
    }
    __int16 v205 = 0;
    v206 = (uint64_t *)*((void *)a2 + 2);
    uint64_t v207 = *v206;
    uint64_t v208 = *v206 + 2 * (__int16)v277;
    uint64_t v209 = v206[3];
    *(_WORD *)(v208 + v209 * ((uint64_t)(int)v277 >> 16)) = 0;
    uint64_t result = 0xFFFFFFFFLL;
    __int16 v210 = v160;
    goto LABEL_177;
  }
  int8x16_t v94 = (float *)v234;
  uint64_t v262 = v159;
  switch(v159)
  {
    case 1:
      memcpy(*((void **)a2 + 8), *(const void **)(v113 + 40), 4 * *(int *)(v113 + 12) - 4);
      uint64_t v171 = *((void *)a2 + 8) + 4 * *(int *)(v113 + 12) - 4;
      int v172 = v277;
      int v173 = v158;
      unint64_t v257 = v257 & 0xFFFFFFFF00000000 | v277;
      unint64_t v258 = v258 & 0xFFFFFFFF00000000 | v158;
      goto LABEL_135;
    case 2:
      memcpy(*((void **)a2 + 8), *(const void **)(v234 + 40), 4 * *(int *)(v234 + 12) - 4);
      uint64_t v174 = *((void *)a2 + 8) + 4 * *(int *)(v234 + 12) - 4;
      unint64_t v259 = v259 & 0xFFFFFFFF00000000 | v277;
      unint64_t v260 = v260 & 0xFFFFFFFF00000000 | v158;
      int v163 = BresenhamCoords(v277, v158, v174);
      uint64_t v175 = (void *)(v174 + 4 * v163 - 4);
      int v176 = *(const void **)(v113 + 40);
      uint64_t v177 = *(int *)(v113 + 12);
      goto LABEL_136;
    case 3:
      uint64_t v178 = *((void *)a2 + 8);
      int v179 = *(_DWORD *)(v113 + 12);
      uint64_t v180 = v179;
      if (v179 < 1)
      {
        unint64_t v184 = v253;
        unint64_t v183 = v254;
      }
      else
      {
        float v181 = (int *)(*(void *)(v113 + 40) + 4 * v179 - 4);
        float v182 = (_DWORD *)*((void *)a2 + 8);
        unint64_t v184 = v253;
        unint64_t v183 = v254;
        do
        {
          int v185 = *v181--;
          *v182++ = v185;
          --v179;
        }
        while (v179);
        uint64_t v180 = *(int *)(v113 + 12);
      }
      uint64_t v171 = v178 + 4 * v180 - 4;
      int v172 = v277;
      int v173 = v158;
      unint64_t v253 = v184 & 0xFFFFFFFF00000000 | v277;
      unint64_t v254 = v183 & 0xFFFFFFFF00000000 | v158;
LABEL_135:
      int v163 = BresenhamCoords(v172, v173, v171);
      uint64_t v175 = (void *)(v171 + 4 * v163 - 4);
      int v176 = *(const void **)(v234 + 40);
      uint64_t v177 = *(int *)(v234 + 12);
LABEL_136:
      memcpy(v175, v176, 4 * v177);
      goto LABEL_137;
    default:
      memcpy(*((void **)a2 + 8), *(const void **)(v234 + 40), 4 * *(int *)(v234 + 12) - 4);
      uint64_t v161 = *((void *)a2 + 8) + 4 * *(int *)(v234 + 12) - 4;
      unint64_t v255 = v255 & 0xFFFFFFFF00000000 | v277;
      unint64_t v256 = v256 & 0xFFFFFFFF00000000 | v158;
      int v162 = BresenhamCoords(v277, v158, v161);
      int v163 = v162;
      int v164 = *(_DWORD *)(v113 + 12);
      if (v164 < 1)
      {
LABEL_137:
        int v167 = a3;
        unint64_t v168 = v265;
        int v169 = v274;
      }
      else
      {
        uint64_t v165 = (int *)(*(void *)(v113 + 40) + 4 * v164 - 4);
        int v166 = (_DWORD *)(v161 + 4 * v162 - 4);
        int v167 = a3;
        unint64_t v168 = v265;
        int v169 = v274;
        do
        {
          int v170 = *v165--;
          *v166++ = v170;
          --v164;
        }
        while (v164);
      }
      int v186 = v169 >> 16;
      if (v167)
      {
        int v187 = v232 - (__int16)v169;
        int v189 = v233 - v186;
        BOOL v188 = v233 - v186 < 0;
      }
      else
      {
        int v187 = (__int16)v169 - v232;
        int v189 = v186 - v233;
        BOOL v188 = v186 - v233 < 0;
      }
      if (v188) {
        unsigned int v190 = -v189;
      }
      else {
        unsigned int v190 = v189;
      }
      if (v187 >= 0) {
        unsigned int v191 = v187;
      }
      else {
        unsigned int v191 = -v187;
      }
      BOOL v192 = v190 > v191;
      BOOL v193 = v190 > v191;
      if (v192) {
        unsigned int v194 = v189;
      }
      else {
        unsigned int v194 = v187;
      }
      if (!v192) {
        int v187 = v189;
      }
      a2 = v266;
      int v195 = v163 + *(_DWORD *)(v234 + 12) + *(_DWORD *)(v113 + 12) - 2;
      unint64_t v265 = v168 & 0xFFFFFFFFFF000000 | v187 & 0x10000 | v193 | (v194 >> 31 << 8);
      applyCoordTransform(v265, *((void *)v266 + 8), v195);
      straightLineLSQ(*((__int16 **)v266 + 8), v195);
      a4 = v267;
      uint64_t v93 = v272;
      if (v231 < v196) {
        goto LABEL_153;
      }
      uint64_t BridgeSegment = createBridgeSegment(*((int **)v266 + 13), v224 << 16, v277, v158);
      __int16 v199 = v228;
      uint64_t v159 = v262;
      break;
  }
LABEL_165:
  v211 = v114;
  v212 = (uint64_t *)*v114;
  if (*v114)
  {
    do
    {
      *((_WORD *)v212 + 17) = v199;
      v212 = (uint64_t *)*v212;
    }
    while (v212);
  }
  int v213 = *(_DWORD *)(a1 + 12) + *(_DWORD *)(v105 + 40 * (int)v104 + 12) + 1;
  v214 = (void *)(a1 + 32);
  switch(v159)
  {
    case 1:
      goto LABEL_172;
    case 2:
      **(void **)uint64_t v264 = BridgeSegment;
      v215 = (uint64_t *)*v114;
      goto LABEL_170;
    case 3:
      reverseContour(v105 + 40 * v104, *((void *)a2 + 12));
      v211 = v114;
LABEL_172:
      **(void **)(v105 + 40 * (int)v104 + 32) = BridgeSegment;
      *(void *)uint64_t BridgeSegment = *v230;
      v214 = v230;
      goto LABEL_173;
    default:
      **(void **)uint64_t v264 = BridgeSegment;
      reverseContour(v105 + 40 * v104, *((void *)a2 + 12));
      v215 = (uint64_t *)*v114;
LABEL_170:
      *(void *)uint64_t BridgeSegment = v215;
      v211 = (void *)(v105 + 40 * (int)v104 + 32);
LABEL_173:
      __int16 v210 = v269;
      void *v214 = *v211;
      *(_DWORD *)(a1 + 12) = v213;
      *int16x8_t v106 = 0;
      uint64_t v216 = *(unsigned int *)(BridgeSegment + 12);
      if ((int)v216 >= 1)
      {
        v217 = (uint64_t *)*((void *)a2 + 1);
        uint64_t v218 = *v217;
        uint64_t v219 = v217[3] << 32;
        v220 = (__int16 *)(*(void *)(BridgeSegment + 40) + 2);
        do
        {
          *(unsigned char *)(v218 + *(v220 - 1) + ((v219 * *v220) >> 32)) = 1;
          v220 += 2;
          --v216;
        }
        while (v216);
      }
      v221 = (uint64_t *)*((void *)a2 + 2);
      uint64_t v207 = *v221;
      uint64_t v222 = *v221 + 2 * (__int16)v277;
      uint64_t v209 = v221[3];
      *(_WORD *)(v222 + v209 * ((uint64_t)(int)v277 >> 16)) = 0;
      *(_WORD *)(v207 + 2 * (__int16)v158 + v209 * ((uint64_t)(int)v158 >> 16)) = 0;
      uint64_t result = 1;
      int v160 = v269;
      __int16 v205 = v228;
      break;
  }
LABEL_177:
  *(_WORD *)(v207 + 2 * v210 + v209 * ((uint64_t)v160 >> 16)) = v205;
  return result;
}

BOOL checkBridgeCrossing(uint64_t a1, int a2, int a3)
{
  int v3 = (__int16)a2;
  int v4 = *(__int16 **)(a1 + 64);
  unsigned int v5 = (__int16)a3 - (__int16)a2;
  int v6 = a3 >> 16;
  int v7 = a2 >> 16;
  unsigned int v8 = (a3 >> 16) - (a2 >> 16);
  if ((v5 & 0x80000000) != 0)
  {
    unsigned int v16 = (__int16)a2 - (__int16)a3;
    if ((v8 & 0x80000000) != 0)
    {
      unsigned int v22 = (a2 >> 16) - (a3 >> 16);
      LODWORD(v34) = 0;
      if (v5 > v8)
      {
        int v35 = 2 * (v8 - v5);
        int v36 = v8 + 2 * v16;
        do
        {
          uint64_t v37 = (int *)&v4[2 * (int)v34];
          *(_WORD *)uint64_t v37 = v3;
          *((_WORD *)v37 + 1) = v7;
          if (v36 < 1)
          {
            int v39 = 2 * v16;
          }
          else
          {
            uint64_t v34 = (int)v34 + 1;
            uint64_t v38 = (int *)&v4[2 * v34];
            *(_WORD *)uint64_t v38 = v3;
            *((_WORD *)v38 + 1) = v7 - 1;
            LOWORD(v3) = v3 - 1;
            int v39 = v35;
          }
          v36 += v39;
          --v7;
          LODWORD(v34) = v34 + 1;
        }
        while (v6 != v7);
        uint64_t v14 = (int)v34;
        int v15 = v16;
        goto LABEL_61;
      }
      int v50 = 2 * (v5 - v8);
      int v51 = v5 + 2 * v22;
      do
      {
        float v52 = (int *)&v4[2 * (int)v34];
        *(_WORD *)float v52 = v3;
        *((_WORD *)v52 + 1) = v7;
        if (v51 < 1)
        {
          int v54 = 2 * v22;
        }
        else
        {
          uint64_t v34 = (int)v34 + 1;
          float v53 = (int *)&v4[2 * v34];
          *(_WORD *)float v53 = v3 - 1;
          *((_WORD *)v53 + 1) = v7;
          LOWORD(v7) = v7 - 1;
          int v54 = v50;
        }
        v51 += v54;
        --v3;
        LODWORD(v34) = v34 + 1;
      }
      while ((__int16)a3 != v3);
      uint64_t v14 = (int)v34;
      LOWORD(v6) = v7;
      int v15 = v22;
    }
    else
    {
      LODWORD(v17) = 0;
      if (v16 < v8)
      {
        int v18 = -2 * v5 - v8;
        do
        {
          uint64_t v19 = (int *)&v4[2 * (int)v17];
          *(_WORD *)uint64_t v19 = v3;
          *((_WORD *)v19 + 1) = v7;
          if (v18 < 1)
          {
            int v21 = -2 * v5;
          }
          else
          {
            uint64_t v17 = (int)v17 + 1;
            int v20 = (int *)&v4[2 * v17];
            *(_WORD *)int v20 = v3;
            *((_WORD *)v20 + 1) = v7 + 1;
            LOWORD(v3) = v3 - 1;
            int v21 = 2 * (v16 - v8);
          }
          v18 += v21;
          ++v7;
          LODWORD(v17) = v17 + 1;
        }
        while (v6 != v7);
        uint64_t v14 = (int)v17;
        int v15 = -v5;
        goto LABEL_18;
      }
      int v40 = 2 * (v5 + v8);
      int v41 = v5 + 2 * v8;
      do
      {
        uint64_t v42 = (int *)&v4[2 * (int)v17];
        *(_WORD *)uint64_t v42 = v3;
        *((_WORD *)v42 + 1) = v7;
        if (v41 < 1)
        {
          int v44 = 2 * v8;
        }
        else
        {
          uint64_t v17 = (int)v17 + 1;
          __int16 v43 = (int *)&v4[2 * v17];
          *(_WORD *)__int16 v43 = v3 - 1;
          *((_WORD *)v43 + 1) = v7;
          LOWORD(v7) = v7 + 1;
          int v44 = v40;
        }
        v41 += v44;
        --v3;
        LODWORD(v17) = v17 + 1;
      }
      while ((__int16)a3 != v3);
      uint64_t v14 = (int)v17;
      LOWORD(v6) = v7;
      int v15 = v8;
    }
    unsigned int v22 = v16;
    goto LABEL_61;
  }
  if ((v8 & 0x80000000) != 0)
  {
    unsigned int v22 = (a2 >> 16) - (a3 >> 16);
    LODWORD(v23) = 0;
    if (v22 <= v5)
    {
      int v45 = 2 * ((a2 >> 16) - (a3 >> 16) - v5);
      int v46 = 2 * v22 - v5;
      do
      {
        uint64_t v47 = (int *)&v4[2 * (int)v23];
        *(_WORD *)uint64_t v47 = v3;
        *((_WORD *)v47 + 1) = v7;
        if (v46 < 1)
        {
          int v49 = 2 * v22;
        }
        else
        {
          uint64_t v23 = (int)v23 + 1;
          int v48 = (int *)&v4[2 * v23];
          *(_WORD *)int v48 = v3 + 1;
          *((_WORD *)v48 + 1) = v7;
          LOWORD(v7) = v7 - 1;
          int v49 = v45;
        }
        v46 += v49;
        ++v3;
        LODWORD(v23) = v23 + 1;
      }
      while ((__int16)a3 != v3);
      uint64_t v14 = (int)v23;
      LOWORD(v6) = v7;
      int v15 = v22;
      goto LABEL_52;
    }
    int v24 = 2 * (v5 + v8);
    int v25 = v8 + 2 * v5;
    do
    {
      int v26 = (int *)&v4[2 * (int)v23];
      *(_WORD *)int v26 = v3;
      *((_WORD *)v26 + 1) = v7;
      if (v25 < 1)
      {
        int v28 = 2 * v5;
      }
      else
      {
        uint64_t v23 = (int)v23 + 1;
        unint64_t v27 = (int *)&v4[2 * v23];
        *(_WORD *)unint64_t v27 = v3;
        *((_WORD *)v27 + 1) = v7 - 1;
        LOWORD(v3) = v3 + 1;
        int v28 = v24;
      }
      v25 += v28;
      --v7;
      LODWORD(v23) = v23 + 1;
    }
    while (v6 != v7);
    uint64_t v14 = (int)v23;
    int v15 = v5;
  }
  else
  {
    if (v8 > v5)
    {
      LODWORD(v9) = 0;
      int v10 = 2 * v5 - v8;
      do
      {
        int v11 = (int *)&v4[2 * (int)v9];
        *(_WORD *)int v11 = v3;
        *((_WORD *)v11 + 1) = v7;
        if (v10 < 1)
        {
          int v13 = 2 * v5;
        }
        else
        {
          uint64_t v9 = (int)v9 + 1;
          signed int v12 = (int *)&v4[2 * v9];
          *(_WORD *)signed int v12 = v3;
          *((_WORD *)v12 + 1) = v7 + 1;
          LOWORD(v3) = v3 + 1;
          int v13 = 2 * (v5 - v8);
        }
        v10 += v13;
        ++v7;
        LODWORD(v9) = v9 + 1;
      }
      while (v6 != v7);
      uint64_t v14 = (int)v9;
      int v15 = v5;
LABEL_18:
      unsigned int v22 = v8;
      goto LABEL_61;
    }
    if (v5)
    {
      LODWORD(v29) = 0;
      int v30 = 2 * v8 - v5;
      do
      {
        uint64_t v31 = (int *)&v4[2 * (int)v29];
        *(_WORD *)uint64_t v31 = v3;
        *((_WORD *)v31 + 1) = v7;
        if (v30 < 1)
        {
          int v33 = 2 * v8;
        }
        else
        {
          uint64_t v29 = (int)v29 + 1;
          uint64_t v32 = (int *)&v4[2 * v29];
          *(_WORD *)uint64_t v32 = v3 + 1;
          *((_WORD *)v32 + 1) = v7;
          LOWORD(v7) = v7 + 1;
          int v33 = 2 * (v8 - v5);
        }
        v30 += v33;
        ++v3;
        LODWORD(v29) = v29 + 1;
      }
      while ((__int16)a3 != v3);
      uint64_t v14 = (int)v29;
      LOWORD(v6) = v7;
      int v15 = v8;
LABEL_52:
      unsigned int v22 = v5;
      goto LABEL_61;
    }
    uint64_t v14 = 0;
    unsigned int v22 = 0;
    int v6 = a2 >> 16;
    int v15 = (a3 >> 16) - (a2 >> 16);
  }
LABEL_61:
  float v55 = (int *)&v4[2 * v14];
  *(_WORD *)float v55 = v3;
  *((_WORD *)v55 + 1) = v6;
  uint64_t v56 = v15 + v22 + 1;
  if ((int)v56 < 1)
  {
    int v61 = 0;
    int v59 = 0;
  }
  else
  {
    unint64_t v57 = *(uint64_t **)(a1 + 8);
    int v58 = *((_DWORD *)v57 + 4);
    int v59 = v56;
    int v60 = v4;
    do
    {
      *(_DWORD *)int v60 = *v60 + v60[1] * v58;
      v60 += 2;
      --v59;
    }
    while (v59);
    int v61 = 0;
    uint64_t v62 = *v57;
    do
    {
      uint64_t v64 = *(int *)v4;
      v4 += 2;
      uint64_t v63 = v64;
      if (*(unsigned char *)(v62 + v64)) {
        ++v61;
      }
      if (*(_WORD *)(**(void **)(a1 + 16) + 2 * v63)) {
        ++v59;
      }
      --v56;
    }
    while (v56);
  }
  return v61 == v59;
}

float computePolyAreaAndMetric(float *a1, float *a2, float *a3)
{
  uint64_t v3 = 0;
  float v4 = *a1;
  float v5 = a1[1];
  float v6 = 0.0;
  float v7 = v5;
  float v8 = *a1;
  float v9 = 0.0;
  do
  {
    float v10 = v8;
    float v11 = v7;
    float v8 = a1[v3 + 2];
    float v7 = a1[v3 + 3];
    float v9 = v9 + sqrtf((float)((float)(v7 - v11) * (float)(v7 - v11)) + (float)((float)(v8 - v10) * (float)(v8 - v10)));
    float v6 = v6 + (float)((float)(v10 * v7) - (float)(v8 * v11));
    v3 += 2;
  }
  while (v3 != 6);
  float v12 = v9 + sqrtf((float)((float)(v5 - v7) * (float)(v5 - v7)) + (float)((float)(v4 - v8) * (float)(v4 - v8)));
  float v13 = fabsf(v6 + (float)((float)(v8 * v5) - (float)(v4 * v7))) * 0.5;
  *a2 = v13;
  float result = (float)(v13 * 12.566) / (float)(v12 * v12);
  *a3 = result;
  return result;
}

void findContourCorners(uint64_t a1, float a2, uint64_t a3, uint64_t a4)
{
  float v86 = &v81;
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  int v94 = 0;
  int v6 = *(_DWORD *)(a1 + 12);
  MEMORY[0x1F4188790](a1);
  MEMORY[0x1F4188790](v7);
  int8x16_t v91 = (char *)&v81 - v12;
  if (v10)
  {
    uint64_t v13 = 0;
    int v14 = -1;
    int v15 = -1;
    do
    {
      *(void *)(a4 + 8 * v13) = v10;
      unsigned int v16 = (__int16 *)v10[5];
      int v17 = *v16;
      int v18 = v16[1];
      uint64_t v19 = &v16[2 * *((int *)v10 + 3)];
      int v20 = (*(v19 - 2) - v17) * (*(v19 - 2) - v17) + (*(v19 - 1) - v18) * (*(v19 - 1) - v18);
      v11[v13] = v20;
      if (v20 > v14)
      {
        int v15 = v13;
        int v14 = v20;
      }
      ++v13;
      float v10 = (uint64_t **)*v10;
    }
    while (v10);
    int v94 = v20;
  }
  else
  {
    int v15 = -1;
  }
  float v90 = v11;
  if (v8)
  {
    int v21 = v8[1] >> 1;
    v8[2] = v21;
    v8[3] = v21 - 1;
  }
  __vImage_Buffer src = 0;
  uint64_t v93 = 0;
  float v83 = v8;
  float v84 = (uint64_t *)(a4 + 8 * v15);
  int v22 = v15 - v6;
  int v85 = v9;
  unsigned int v82 = v15 - v6;
  if (!v9) {
    int v22 = 0;
  }
  LODWORD(v92) = v22;
  if (v15 > v22)
  {
    uint64_t v23 = v84;
    int v81 = v15;
    while (2)
    {
      int v24 = 0;
      uint64_t v25 = 0;
      int v26 = 0;
      int v27 = 0;
      uint64_t v28 = *v23;
      int v29 = *(_DWORD *)(v28 + 12);
      int v30 = *(__int16 **)(v28 + 40);
      float v31 = 0.0;
      int v32 = 1;
      char v33 = 1;
      int v34 = v81;
LABEL_15:
      int v89 = v24;
      uint64_t v88 = v25;
      int v87 = v32;
      uint64_t v35 = v34;
      float v36 = v31;
      while (1)
      {
        int v34 = v35 - 1;
        int v37 = (int)v35 <= 0 ? v6 : 0;
        uint64_t v38 = *(void *)(a4 + 8 * (v35 + v37) - 8);
        segmentSinCosLen2(v29, v30, *(_DWORD *)(v38 + 12), *(__int16 **)(v38 + 40), (float *)&v93 + 1, (float *)&v93, &v94);
        float v31 = fabsf(*((float *)&v93 + 1));
        int v39 = (__PAIR64__(*((float *)&v93 + 1) > 0.0, HIDWORD(v93)) - COERCE_UNSIGNED_INT(0.0)) >> 32;
        if (v26) {
          break;
        }
        if (v31 >= a2)
        {
          char v33 = 0;
          int v34 = v35 - 1;
          int v27 = (__PAIR64__(*((float *)&v93 + 1) > 0.0, HIDWORD(v93)) - COERCE_UNSIGNED_INT(0.0)) >> 32;
          uint64_t v44 = v88;
LABEL_37:
          v90[v44] = v94;
          *(_DWORD *)&v91[4 * v44] = v34;
          uint64_t v25 = v44 + 1;
          int v32 = v87 + 1;
          int v24 = v89 + 1;
          int v26 = 1;
          if (v34 > (int)v92) {
            goto LABEL_15;
          }
          if (v44)
          {
            LODWORD(v49) = 0;
            int v50 = *v90;
            uint64_t v51 = 1;
            do
            {
              if (v90[v51] > v50)
              {
                LODWORD(v49) = v51;
                int v50 = v90[v51];
              }
              ++v51;
            }
            while (v87 != v51);
            uint64_t v49 = (int)v49;
          }
          else
          {
            uint64_t v49 = 0;
          }
          LOWORD(__src) = (v6 & (*(int *)&v91[4 * v49] >> 31)) + *(_WORD *)&v91[4 * v49];
          HIWORD(__src) = (v6 & (v81 >> 31)) + v81;
          prependDequeElement(v83, &__src);
          goto LABEL_54;
        }
        BOOL v41 = v31 < v36 || v27 != v39;
        if (v34 > (int)v92 && *(float *)&v93 >= 0.0)
        {
          int v26 = 0;
          char v42 = v41 & ~v33;
          --v35;
          int v27 = (__PAIR64__(*((float *)&v93 + 1) > 0.0, HIDWORD(v93)) - COERCE_UNSIGNED_INT(0.0)) >> 32;
          float v36 = v31;
          char v33 = 0;
          if ((v42 & 1) == 0) {
            continue;
          }
        }
        goto LABEL_54;
      }
      BOOL v43 = v31 >= a2 && v39 == v27;
      uint64_t v44 = v88;
      if (v43) {
        goto LABEL_37;
      }
      int v45 = 0;
      if ((v88 & 0xFFFFFFFE) != 0)
      {
        int v46 = *v90;
        uint64_t v47 = 1;
        do
        {
          if (v90[v47] > v46)
          {
            int v45 = v47;
            int v46 = v90[v47];
          }
          ++v47;
        }
        while (v89 != v47);
      }
      int v48 = *(_DWORD *)&v91[4 * v45];
      LOWORD(__src) = (v6 & (v48 >> 31)) + v48;
      HIWORD(__src) = (v6 & (v81 >> 31)) + v81;
      prependDequeElement(v83, &__src);
      uint64_t v23 = (uint64_t *)(a4 + 8 * ((v6 & (v48 >> 31)) + v48));
      int v81 = v48;
      if (v48 > (int)v92) {
        continue;
      }
      break;
    }
  }
LABEL_54:
  if (v85)
  {
    if (v83)
    {
      int v52 = v83[2];
      uint64_t v53 = v82;
      if (v83[3] + 1 != v52)
      {
        __vImage_Buffer src = *(_DWORD *)(*((void *)v83 + 2) + *v83 * (uint64_t)v52);
        if (v15 == (__int16)__src) {
          uint64_t v53 = v15;
        }
        else {
          uint64_t v53 = (v6 + (__int16)__src);
        }
      }
    }
    else
    {
      uint64_t v53 = v82;
    }
  }
  else
  {
    uint64_t v53 = (v6 - 1);
  }
  if (v15 < (int)v53)
  {
    uint64_t v54 = *v84;
    while (2)
    {
      int v55 = 0;
      uint64_t v56 = 0;
      int v57 = 0;
      int v58 = 0;
      int v59 = *(__int16 **)(v54 + 40);
      float v60 = 0.0;
      int v61 = 1;
      int v62 = v15;
      char v63 = 1;
LABEL_65:
      int v89 = v55;
      uint64_t v92 = v56;
      LODWORD(v88) = v61;
      ++v62;
      float v64 = v60;
      while (1)
      {
        uint64_t v65 = v53;
        uint64_t v66 = *(void *)(a4 + 8 * (v62 % v6));
        segmentSinCosLen2(*(_DWORD *)(v54 + 12), v59, *(_DWORD *)(v66 + 12), *(__int16 **)(v66 + 40), (float *)&v93 + 1, (float *)&v93, &v94);
        float v60 = fabsf(*((float *)&v93 + 1));
        int v67 = (__PAIR64__(*((float *)&v93 + 1) > 0.0, HIDWORD(v93)) - COERCE_UNSIGNED_INT(0.0)) >> 32;
        if (v57) {
          break;
        }
        uint64_t v53 = v65;
        if (v60 >= a2)
        {
          char v63 = 0;
          int v58 = (__PAIR64__(*((float *)&v93 + 1) > 0.0, HIDWORD(v93)) - COERCE_UNSIGNED_INT(0.0)) >> 32;
          uint64_t v72 = v92;
LABEL_84:
          v90[v72] = v94;
          *(_DWORD *)&v91[4 * v72] = v62;
          uint64_t v56 = v72 + 1;
          int v61 = v88 + 1;
          int v55 = v89 + 1;
          int v57 = 1;
          if (v62 < (int)v53) {
            goto LABEL_65;
          }
          if (v72)
          {
            LODWORD(v77) = 0;
            int v78 = *v90;
            uint64_t v79 = 1;
            do
            {
              if (v90[v79] > v78)
              {
                LODWORD(v77) = v79;
                int v78 = v90[v79];
              }
              ++v79;
            }
            while (v88 != v79);
            uint64_t v77 = (int)v77;
          }
          else
          {
            uint64_t v77 = 0;
          }
          int v80 = *(_DWORD *)&v91[4 * v77] % v6;
          LOWORD(__src) = v15 % v6;
          HIWORD(__src) = v80;
          appendDequeElement(v83, &__src);
          return;
        }
        BOOL v69 = v60 < v64 || v58 != v67;
        if (v62 < (int)v65 && *(float *)&v93 >= 0.0)
        {
          int v57 = 0;
          char v70 = v69 & ~v63;
          ++v62;
          int v58 = (__PAIR64__(*((float *)&v93 + 1) > 0.0, HIDWORD(v93)) - COERCE_UNSIGNED_INT(0.0)) >> 32;
          float v64 = v60;
          char v63 = 0;
          if ((v70 & 1) == 0) {
            continue;
          }
        }
        return;
      }
      BOOL v71 = v60 >= a2 && v67 == v58;
      uint64_t v53 = v65;
      uint64_t v72 = v92;
      if (v71) {
        goto LABEL_84;
      }
      if ((v92 & 0xFFFFFFFE) != 0)
      {
        int v73 = 0;
        int v74 = *v90;
        uint64_t v75 = 1;
        do
        {
          if (v90[v75] > v74)
          {
            int v73 = v75;
            int v74 = v90[v75];
          }
          ++v75;
        }
        while (v89 != v75);
      }
      else
      {
        int v73 = 0;
      }
      int v76 = v15 % v6;
      int v15 = *(_DWORD *)&v91[4 * v73];
      LOWORD(__src) = v76;
      HIWORD(__src) = v15 % v6;
      appendDequeElement(v83, &__src);
      uint64_t v54 = *(void *)(a4 + 8 * (v15 % v6));
      uint64_t v53 = v65;
      if (v15 < (int)v65) {
        continue;
      }
      break;
    }
  }
}

uint64_t calcRotationParity(int a1, __int16 *a2, int a3, __int16 *a4)
{
  int v4 = (a4[2 * a3 - 2] - *a4) * (a2[1] - a2[2 * a1 - 1]) + (a4[2 * a3 - 1] - a4[1]) * (a2[2 * a1 - 2] - *a2);
  return (v4 != 0) | (v4 >> 31);
}

BOOL extendedSegmentTest(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if (a4)
  {
    uint64_t v16 = 0;
    int v8 = *(_DWORD *)(a2 + 12);
    int v9 = *(__int16 **)(a2 + 40);
    int v10 = *(_DWORD *)(a3 + 12);
    float v11 = *(__int16 **)(a3 + 40);
    segmentSinCos(v8, v9, v10, v11, (float *)&v16 + 1, (float *)&v16);
    if (fabsf(*((float *)&v16 + 1)) >= *(float *)(a5 + 80) || (BOOL result = 0, *(float *)&v16 >= 0.0))
    {
      int v13 = *(_DWORD *)(a1 + 12);
      int v14 = *(__int16 **)(a1 + 40);
LABEL_8:
      int v15 = calcRotationParity(v13, v14, v8, v9);
      return v15 == calcRotationParity(v8, v9, v10, v11);
    }
  }
  else
  {
    uint64_t v16 = 0;
    int v13 = *(_DWORD *)(a1 + 12);
    int v14 = *(__int16 **)(a1 + 40);
    int v8 = *(_DWORD *)(a2 + 12);
    int v9 = *(__int16 **)(a2 + 40);
    segmentSinCos(v13, v14, v8, v9, (float *)&v16 + 1, (float *)&v16);
    if (fabsf(*((float *)&v16 + 1)) >= *(float *)(a5 + 80) || (BOOL result = 0, *(float *)&v16 >= 0.0))
    {
      int v10 = *(_DWORD *)(a3 + 12);
      float v11 = *(__int16 **)(a3 + 40);
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t Contours2Quads(uint64_t a1, float *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  *(void *)&v503[9] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(unsigned int *)(a1 + 4);
  int v10 = *((_DWORD *)a3 + 4);
  v488 = a3;
  float v11 = (char *)malloc_type_malloc(4 * (*((_DWORD *)a3 + 2) + v10), 0x100004052888210uLL);
  float v12 = a2[20];
  float v13 = a2[17];
  v495 = a2;
  float v14 = a2[23];
  uint64_t v473 = a1;
  uint64_t v471 = *(void *)(a1 + 8);
  uint64_t v15 = (uint64_t)malloc_type_malloc(0x28uLL, 0xE36368ECuLL);
  uint64_t v502 = v15;
  long long v501 = xmmword_1A410C130;
  uint64_t v472 = v9;
  if ((int)v9 >= 1)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    v470 = v11 + 2;
    v479 = v11;
    unsigned int v480 = a5;
LABEL_3:
    int v18 = *(__int16 *)(v471 + 2 * v16);
    uint64_t v19 = *(void *)(v473 + 16);
    int v20 = (unsigned char *)(v19 + 40 * *(__int16 *)(v471 + 2 * v16));
    if (!*v20) {
      goto LABEL_326;
    }
    v474 = &v467;
    uint64_t v21 = v19 + 40 * v18;
    int v22 = *(unsigned __int8 *)(v21 + 8);
    BOOL v490 = *(unsigned char *)(v21 + 8) != 0;
    uint64_t v23 = *(int *)(v21 + 12);
    MEMORY[0x1F4188790](v15);
    int v26 = (char *)&v467 - v25;
    if (v24 >= 0x200) {
      size_t v27 = 512;
    }
    else {
      size_t v27 = v24;
    }
    bzero((char *)&v467 - v25, v27);
    uint64_t v489 = v23;
    bzero(v26, 8 * v23);
    findContourCorners((uint64_t)v20, v495[20], (uint64_t)&v501, (uint64_t)v26);
    MEMORY[0x1F4188790](v28);
    char v33 = (float32x2_t *)((char *)&v467 - v32);
    uint64_t v475 = v16;
    if ((int)v29 < 1) {
      goto LABEL_325;
    }
    int v34 = (__int16 *)(v30 + 2);
    v491 = v33;
    uint64_t v35 = v29;
    do
    {
      float v36 = *(float32x2_t **)&v26[8 * *(v34 - 1)];
      int v37 = *(float32x2_t **)&v26[8 * *v34];
      float32x2_t v38 = v36[3];
      float32x2_t v39 = v37[3];
      *(float *)v31.i32 = vmlas_n_f32((float)-v37[2].f32[1] * v38.f32[0], v36[2].f32[1], v39.f32[0]);
      v40.i32[1] = v38.i32[1];
      v40.i32[0] = v36[2].i32[1];
      float32x2_t v41 = vmul_f32(v39, vneg_f32((float32x2_t)vrev64_s32(v40)));
      v39.i32[0] = vdup_lane_s32((int32x2_t)v39, 1).u32[0];
      v39.i32[1] = v37[2].i32[1];
      *v33++ = vdiv_f32(vmla_f32(v41, v38, v39), (float32x2_t)vdup_lane_s32(v31, 0));
      v34 += 2;
      --v35;
    }
    while (v35);
    int v486 = v29 - 1;
    uint64_t v478 = (v29 - 1) & ~(((int)v29 - 1) >> 31);
    MEMORY[0x1F4188790](v15);
    v492 = (__int16 *)((char *)&v467 - ((v46 + 15) & 0x7FFFFFFF0));
    int v47 = 0;
    uint64_t v48 = 0;
    int v49 = v42 + v22;
    if (v22) {
      int v50 = -1;
    }
    else {
      int v50 = 0;
    }
    v481 = (uint64_t *)(v45 + 2);
    int v469 = v43 + v22 - v44;
    v482 = (_OWORD *)a4;
    unsigned int v487 = v17;
    uint64_t v497 = v45;
    v498 = v26;
    uint64_t v499 = v42;
    LODWORD(v477) = v22;
    LODWORD(v476) = v42 + v22;
    LODWORD(v484) = v50;
    do
    {
      if ((int)v48 < (int)v42)
      {
        uint64_t v51 = a5;
        int v52 = (__int16 *)v481 + 2 * (int)v48;
        uint64_t v53 = (int)v48;
        float v54 = v495[20];
        int v26 = v498;
        while (1)
        {
          uint64_t v55 = *(void *)&v26[8 * *(v52 - 1)];
          uint64_t v56 = *(void *)&v26[8 * *v52];
          *(void *)v503 = 0;
          segmentSinCos(*(_DWORD *)(v55 + 12), *(__int16 **)(v55 + 40), *(_DWORD *)(v56 + 12), *(__int16 **)(v56 + 40), (float *)&v503[1], (float *)v503);
          if (fabsf(*(float *)&v503[1]) >= v54 || *(float *)v503 >= 0.0) {
            break;
          }
          v52 += 2;
          ++v53;
          LODWORD(v42) = v499;
          if (v499 == v53)
          {
            uint64_t v45 = v497;
            a5 = v51;
            goto LABEL_42;
          }
        }
        uint64_t v45 = v497;
        LODWORD(v42) = v499;
        uint64_t v48 = v53;
        a5 = v51;
        int v50 = v484;
      }
      if (v48 == v42) {
        break;
      }
      int v57 = (__int16 *)(v45 + 4 * (int)v48);
      uint64_t v58 = v57[1];
      uint64_t v59 = *(void *)&v26[8 * *v57];
      uint64_t v60 = *(void *)&v26[8 * v58];
      int v61 = *(_DWORD *)(v59 + 12);
      int v62 = *(__int16 **)(v59 + 40);
      int v63 = *(_DWORD *)(v60 + 12);
      float v64 = *(__int16 **)(v60 + 40);
      *(void *)&long long v485 = v48;
      uint64_t v15 = calcRotationParity(v61, v62, v63, v64);
      uint64_t v48 = v485;
      LODWORD(v494) = v15;
      uint64_t v65 = (v485 + 1);
      if ((int)v65 >= v49)
      {
        int v85 = 1;
      }
      else
      {
        LODWORD(v483) = v47;
        int v66 = 0;
        unsigned __int16 v67 = v58;
        int v468 = v49 - v485;
        float v68 = v495[20];
        LODWORD(v493) = v469 - v485;
        while (1)
        {
          uint64_t v69 = v65;
          uint64_t v70 = (v65 + v66++);
          BOOL v71 = (unsigned __int16 *)(v497 + 4 * ((int)v70 % (int)v499));
          int v72 = *v71;
          uint64_t v73 = (__int16)v71[1];
          uint64_t v74 = *(void *)&v26[8 * (__int16)v72];
          uint64_t v75 = *(void *)&v26[8 * v73];
          int v76 = *(_DWORD *)(v74 + 12);
          uint64_t v77 = *(__int16 **)(v74 + 40);
          int v78 = *(_DWORD *)(v75 + 12);
          uint64_t v79 = *(__int16 **)(v75 + 40);
          int v496 = calcRotationParity(v76, v77, v78, v79);
          *(void *)v503 = 0;
          segmentSinCos(v76, v77, v78, v79, (float *)&v503[1], (float *)v503);
          BOOL v80 = fabsf(*(float *)&v503[1]) < v68;
          if (*(float *)v503 >= 0.0) {
            BOOL v80 = 0;
          }
          _ZF = v72 == v67 && v496 == v494;
          if (!_ZF || v80) {
            break;
          }
          unsigned __int16 v67 = v73;
          int v26 = v498;
          uint64_t v65 = v69;
          if (v493 == v66)
          {
            a5 = v480;
            a4 = (uint64_t)v482;
            uint64_t v17 = v487;
            uint64_t v45 = v497;
            LODWORD(v42) = v499;
            int v22 = v477;
            int v47 = (int)v483;
            int v49 = v476;
            int v50 = v484;
            uint64_t v48 = v485;
            int v85 = v468;
            goto LABEL_38;
          }
        }
        BOOL v490 = 0;
        int v83 = (int)v483;
        float v84 = &v492[2 * (int)v483];
        v84[1] = v66;
        *float v84 = v485;
        int v47 = v83 + 1;
        int v85 = v66;
        LODWORD(v65) = v70;
        uint64_t v48 = v70;
        a5 = v480;
        a4 = (uint64_t)v482;
        uint64_t v17 = v487;
        int v26 = v498;
        int v22 = v477;
        int v49 = v476;
        int v50 = v484;
      }
      uint64_t v45 = v497;
      LODWORD(v42) = v499;
      if (v65 == v49)
      {
LABEL_38:
        int v86 = v85 + v50;
        int v87 = &v492[2 * v47];
        v87[1] = v86;
        *int v87 = v48;
        if (v86 << 16 > 0) {
          ++v47;
        }
        LODWORD(v65) = v49;
      }
    }
    while ((int)v65 < (int)v42);
LABEL_42:
    if (v22)
    {
      int v88 = v47 - 1;
      if (v47 > 1)
      {
        int v89 = &v492[2 * v88];
        uint64_t v90 = *v89;
        uint64_t v91 = v89[1];
        uint64_t v92 = v45 + 4 * (v90 + v91);
        int v93 = *(unsigned __int16 *)(v92 - 2);
        int v94 = (unsigned __int16 *)(v45 + 4 * *v492);
        if (*v94 == v93)
        {
          LODWORD(v483) = v47;
          uint64_t v95 = (__int16)v94[1];
          uint64_t v96 = v498;
          uint64_t v97 = *(void *)&v498[8 * *(__int16 *)(v92 - 4)];
          uint64_t v98 = *(void *)&v498[8 * (__int16)v93];
          int v99 = *(_DWORD *)(v98 + 12);
          uint64_t v100 = *(__int16 **)(v98 + 40);
          int v101 = calcRotationParity(*(_DWORD *)(v97 + 12), *(__int16 **)(v97 + 40), v99, v100);
          uint64_t v102 = *(void *)&v96[8 * v95];
          LODWORD(v96) = *(_DWORD *)(v102 + 12);
          uint64_t v103 = *(__int16 **)(v102 + 40);
          int v104 = calcRotationParity(v99, v100, (int)v96, v103);
          *(void *)v503 = 0;
          segmentSinCos(v99, v100, (int)v96, v103, (float *)&v503[1], (float *)v503);
          BOOL v105 = fabsf(*(float *)&v503[1]) < v495[20];
          if (*(float *)v503 >= 0.0) {
            BOOL v105 = 0;
          }
          if (v104 == v101)
          {
            a5 = v480;
            a4 = (uint64_t)v482;
            uint64_t v17 = v487;
            uint64_t v45 = v497;
            LODWORD(v42) = v499;
            int v47 = (int)v483;
            if (!v105)
            {
              int16x8_t v106 = v492;
              v492[1] += v91;
              *int16x8_t v106 = v90;
              int v47 = v88;
            }
          }
          else
          {
            a5 = v480;
            a4 = (uint64_t)v482;
            uint64_t v17 = v487;
            uint64_t v45 = v497;
            LODWORD(v42) = v499;
            int v47 = (int)v483;
          }
        }
      }
    }
    if (v47 < 1 || (int)v17 >= (int)a5) {
      goto LABEL_325;
    }
    uint64_t v107 = 0;
    uint64_t v108 = 0;
    int v496 = v489 - 1;
    uint64_t v476 = v45 + 2;
    unint64_t v493 = v47;
    int v109 = v498;
LABEL_54:
    int v110 = &v492[2 * v107];
    int v111 = *v110;
    int v112 = v110[1];
    int v113 = v112 + v111;
    if (v490)
    {
      if (v112 == 4)
      {
        uint64_t v114 = v108;
        uint64_t v115 = 0;
        v503[0] = 0;
        float v500 = 0.0;
        uint64_t v116 = v476 + 4 * v111;
        do
        {
          if (v111 >= (int)v42) {
            int v117 = v42;
          }
          else {
            int v117 = 0;
          }
          uint64_t v118 = (__int16 *)(v116 - 4 * v117);
          uint64_t v119 = *(float **)&v109[8 * *(v118 - 1)];
          int v120 = *(float **)&v109[8 * *v118];
          float v121 = v119[5];
          float v122 = v119[6];
          float v123 = v119[7];
          float v124 = v120[5];
          float v125 = v120[6];
          float v126 = v120[7];
          float v127 = (float)(v121 * v125) - (float)(v124 * v122);
          float v128 = (float)((float)(v126 * v122) - (float)(v123 * v125)) / v127;
          float v129 = (float)((float)(v124 * v123) - (float)(v121 * v126)) / v127;
          float v130 = (float *)&v503[v115 + 1];
          float v131 = (float *)(a4 + v115 * 4);
          *float v130 = v128;
          v130[1] = v129;
          *float v131 = v128;
          v131[1] = v129;
          ++v111;
          v115 += 2;
          v116 += 4;
        }
        while (v111 < v113);
        computePolyAreaAndMetric((float *)&v503[1], (float *)v503, &v500);
        *(float *)&double v138 = v500;
        if (v500 >= v14)
        {
          uint64_t v15 = quadValid(a4, (uint64_t)v495, v138, v132, v133, v134, v135, v136, v137);
          if (v15)
          {
            a4 += 32;
            uint64_t v17 = (v17 + 1);
          }
        }
        LODWORD(v42) = v499;
        uint64_t v108 = v114;
      }
      goto LABEL_323;
    }
    if (v112 < 2) {
      goto LABEL_323;
    }
    unsigned int v487 = v17;
    v481 = &v467;
    int v139 = v113 - 1;
    MEMORY[0x1F4188790](v15);
    BOOL v147 = (float *)(&v467 - 4 * v146);
    if (v143 != 4)
    {
      unsigned int v148 = v491;
      if (v143 == 3)
      {
        unsigned int v194 = (float32x2_t *)&v147[8 * v142];
        int v109 = v498;
        int v195 = *(float32x2_t **)&v498[8 * *(__int16 *)(v144 + 4 * v111)];
        if (v111 + 1 >= v141) {
          int v196 = v141;
        }
        else {
          int v196 = 0;
        }
        float32x2_t v197 = v491[v111 + 1 - v196];
        ++v142;
        if (v111 + 2 >= v141) {
          int v198 = v141;
        }
        else {
          int v198 = 0;
        }
        int v199 = v111 + 2 - v198;
        uint64_t v200 = *(float32x2_t **)&v498[8 * *(__int16 *)(v144 + 4 * v199 + 2)];
        float32x2_t v201 = v491[v199];
        *unsigned int v194 = v491[v111];
        v194[1] = v197;
        v194[2] = v201;
        float32x2_t v202 = v200[3];
        float32x2_t v203 = v195[3];
        *(float *)v145.i32 = vmlas_n_f32((float)-v195[2].f32[1] * v202.f32[0], v200[2].f32[1], v203.f32[0]);
        v204.i32[1] = v202.i32[1];
        v204.i32[0] = v200[2].i32[1];
        float32x2_t v205 = vneg_f32((float32x2_t)vrev64_s32(v204));
        v204.i32[0] = vdup_lane_s32((int32x2_t)v203, 1).u32[0];
        v204.i32[1] = v195[2].i32[1];
        v194[3] = vdiv_f32(vmla_f32(vmul_f32(v203, v205), v202, (float32x2_t)v204), (float32x2_t)vdup_lane_s32(v145, 0));
        goto LABEL_249;
      }
      if (v143 == 2)
      {
        uint64_t v149 = *(__int16 *)(v144 + 4 * v111);
        uint64_t v150 = *(void *)&v498[8 * v149];
        if (v141 <= v111) {
          int v151 = v141;
        }
        else {
          int v151 = 0;
        }
        int v152 = v111 - v151;
        int v153 = *(unsigned __int16 *)(v144 + 4 * (v111 - v151));
        if (!*(_WORD *)(v144 + 4 * v152)) {
          goto LABEL_219;
        }
        if (v152 >= 1)
        {
          int v154 = v111 >= 1 ? 0 : v141;
          int v155 = v111 + v154 - 1;
          if (v153 == *(unsigned __int16 *)(v144 + 4 * v155 + 2))
          {
            int v156 = (float *)&v491[v155];
            float v157 = *v156;
            float v158 = v156[1];
LABEL_221:
            v346 = &v147[8 * v142];
            float *v346 = v157;
            v346[1] = v158;
            float32x2_t v347 = v148[v111];
            if (v111 + 1 >= v141) {
              int v348 = v141;
            }
            else {
              int v348 = 0;
            }
            int v349 = v111 + 1 - v348;
            float32x2_t v350 = v148[v349];
            *((float32x2_t *)v346 + 1) = v347;
            *((float32x2_t *)v346 + 2) = v350;
            uint64_t v351 = *(__int16 *)(v144 + 4 * v349 + 2);
            uint64_t v352 = *(void *)&v498[8 * v351];
            if (v113 <= v141) {
              int v353 = 0;
            }
            else {
              int v353 = v141;
            }
            int v354 = v139 - v353;
            int v109 = v498;
            v355 = (__int16 *)(v144 + 4 * v354);
            int v356 = v355[1];
            if (v496 == v356) {
              goto LABEL_246;
            }
            if (v354 < v486)
            {
              int v357 = v113 >= v141 ? v141 : 0;
              int v358 = v113 - v357;
              if (*(unsigned __int16 *)(v144 + 4 * v358) == (unsigned __int16)v356)
              {
                v359 = (float *)&v148[v358];
                float v360 = *v359;
                float v361 = v359[1];
LABEL_248:
                ++v142;
                v346[6] = v360;
                v346[7] = v361;
                goto LABEL_249;
              }
            }
            unsigned int v364 = v142;
            BOOL v140 = extendedSegmentTest(*(void *)&v498[8 * *v355], *(void *)&v498[8 * v355[1]], *(void *)&v498[8 * ((v355[1] + 1) % (int)v489)], 1, (uint64_t)v495);
            unsigned int v142 = v364;
            if (!v140)
            {
LABEL_246:
              float v386 = *(float *)(v352 + 20);
              float v387 = *(float *)(v352 + 24);
              float v388 = *(float *)(v352 + 28);
              int v389 = *(_DWORD *)(*(void *)(v352 + 40) + 4 * *(int *)(v352 + 12) - 4);
              float v390 = (float)(v387 * (float)(__int16)v389) - (float)(v386 * (float)(v389 >> 16));
              float v384 = -(float)((float)(v387 * v387) + (float)(v386 * v386));
              float v360 = (float)((float)(v386 * v388) - (float)(v387 * v390)) / v384;
              float v385 = (float)(v386 * v390) + (float)(v387 * v388);
            }
            else
            {
              if ((int)v351 + 1 >= (int)v489) {
                int v365 = v489;
              }
              else {
                int v365 = 0;
              }
              uint64_t v366 = *(void *)&v109[8 * ((int)v351 + 1 - v365)];
              uint64_t v367 = *(void *)(v366 + 40) + 4 * *(int *)(v366 + 12);
              float v368 = (float)*(__int16 *)(v367 - 4);
              float v369 = (float)*(__int16 *)(v367 - 2);
              uint64_t v370 = *(void *)(v352 + 40) + 4 * *(int *)(v352 + 12);
              float v371 = (float)*(__int16 *)(v370 - 4);
              float v372 = (float)*(__int16 *)(v370 - 2);
              float v373 = v371 - v350.f32[0];
              float v374 = v372 - v350.f32[1];
              *(float *)&unsigned int v375 = (float)((float)(v350.f32[0] - v347.f32[0]) * (float)(v372 - v350.f32[1]))
                              - (float)((float)(v371 - v350.f32[0]) * (float)(v350.f32[1] - v347.f32[1]));
              LODWORD(v370) = (__PAIR64__(*(float *)&v375 > 0.0, v375) - COERCE_UNSIGNED_INT(0.0)) >> 32;
              float v376 = v368 - v371;
              float v377 = v369 - v372;
              *(float *)&unsigned int v378 = (float)((float)(v371 - v350.f32[0]) * (float)(v369 - v372))
                              - (float)((float)(v368 - v371) * (float)(v372 - v350.f32[1]));
              if (v370 != (__PAIR64__(*(float *)&v378 > 0.0, v378) - COERCE_UNSIGNED_INT(0.0)) >> 32
                || (float v379 = 1.0
                         / sqrtf((float)((float)(v377 * v377) + (float)(v376 * v376))* (float)((float)(v374 * v374) + (float)(v373 * v373))), fabsf((float)((float)(v377 * (float)-v373) + (float)(v374 * v376)) * v379) < v495[20])&& (float)((float)((float)(v377 * v374) + (float)(v373 * v376)) * v379) < 0.0)
              {
                float v368 = v371;
                float v369 = v372;
              }
              float v380 = *(float *)(v352 + 20);
              float v381 = *(float *)(v352 + 24);
              float v382 = *(float *)(v352 + 28);
              float v383 = (float)(v381 * v368) - (float)(v380 * v369);
              float v384 = -(float)((float)(v381 * v381) + (float)(v380 * v380));
              float v360 = (float)((float)(v380 * v382) - (float)(v381 * v383)) / v384;
              float v385 = (float)(v380 * v383) + (float)(v381 * v382);
            }
            float v361 = v385 / v384;
            goto LABEL_248;
          }
        }
        int v317 = v113 <= v141 ? 0 : v141;
        unsigned int v318 = v142;
        BOOL v140 = extendedSegmentTest(*(void *)&v498[8 * ((v496 + *(__int16 *)(v144 + 4 * (v139 - v317))) % (int)v489)], *(void *)&v498[8 * *(__int16 *)(v144 + 4 * (v139 - v317))], *(void *)&v498[8 * *(__int16 *)(v144 + 4 * (v139 - v317) + 2)], 0, (uint64_t)v495);
        unsigned int v142 = v318;
        unsigned int v148 = v491;
        int v141 = v499;
        uint64_t v144 = v497;
        if (v140)
        {
          if ((int)v149 >= 1) {
            int v319 = 0;
          }
          else {
            int v319 = v489;
          }
          v320 = *(__int16 **)(*(void *)&v498[8 * (int)v149 - 8 + 8 * v319] + 40);
          float v321 = (float)*v320;
          float v322 = (float)v320[1];
          v323 = *(__int16 **)(v150 + 40);
          float v324 = (float)*v323;
          float v325 = (float)v323[1];
          v326 = (float *)&v491[v111];
          float v327 = v326[1];
          float v328 = v324 - v321;
          float v329 = v325 - v322;
          float v330 = *v326 - v324;
          float v331 = v327 - v325;
          if (v111 + 1 >= (int)v499) {
            int v333 = v499;
          }
          else {
            int v333 = 0;
          }
          *(float *)&unsigned int v332 = (float)((float)(v324 - v321) * (float)(v327 - v325)) - (float)(v330 * (float)(v325 - v322));
          *(float *)&unsigned int v334 = (float)(v330 * (float)(v491[v111 + 1 - v333].f32[1] - v327))
                          - (float)((float)(v491[v111 + 1 - v333].f32[0] - *v326) * v331);
          if ((__PAIR64__(*(float *)&v332 > 0.0, v332) - COERCE_UNSIGNED_INT(0.0)) >> 32 != (__PAIR64__(*(float *)&v334 > 0.0, v334)- COERCE_UNSIGNED_INT(0.0)) >> 32|| (float v335 = 1.0/ sqrtf((float)((float)(v329 * v329) + (float)(v328 * v328))* (float)((float)(v331 * v331) + (float)(v330 * v330))), fabsf((float)((float)(v329 * v330) - (float)(v328 * v331)) * v335) < v495[20])&& (float)((float)((float)(v329 * v331) + (float)(v328 * v330)) * v335) < 0.0)
          {
            float v321 = v324;
            float v322 = v325;
          }
          float v336 = *(float *)(v150 + 20);
          float v337 = *(float *)(v150 + 24);
          float v338 = *(float *)(v150 + 28);
          float v339 = (float)(v337 * v321) - (float)(v336 * v322);
          float v340 = -(float)((float)(v337 * v337) + (float)(v336 * v336));
          float v157 = (float)((float)(v336 * v338) - (float)(v337 * v339)) / v340;
          float v341 = (float)(v336 * v339) + (float)(v337 * v338);
        }
        else
        {
LABEL_219:
          float v342 = *(float *)(v150 + 20);
          float v343 = *(float *)(v150 + 24);
          float v344 = *(float *)(v150 + 28);
          float v345 = (float)(v343 * (float)(__int16)**(_DWORD **)(v150 + 40))
               - (float)(v342 * (float)(**(int **)(v150 + 40) >> 16));
          float v340 = -(float)((float)(v343 * v343) + (float)(v342 * v342));
          float v157 = (float)((float)(v342 * v344) - (float)(v343 * v345)) / v340;
          float v341 = (float)(v342 * v345) + (float)(v343 * v344);
        }
        float v158 = v341 / v340;
        goto LABEL_221;
      }
      int v206 = v113 - 4;
      if (v113 - 4 < v111) {
        goto LABEL_172;
      }
      v482 = (_OWORD *)a4;
      unsigned int v207 = v142;
      LODWORD(v494) = v143 + v111 - 3;
      if (v113 >= v141) {
        int v208 = v141;
      }
      else {
        int v208 = 0;
      }
      *(void *)&long long v484 = v113 - v208;
      *(void *)&long long v485 = &v491[v484];
      uint64_t v209 = (uint64_t)&v147[8 * v142 + 4];
      int v210 = v111;
      while (1)
      {
        if (v210 >= v141) {
          int v211 = v141;
        }
        else {
          int v211 = 0;
        }
        int v212 = v210;
        uint64_t v213 = v210 - (uint64_t)v211;
        uint64_t v214 = v210 + 3;
        if ((int)v214 >= v141) {
          int v215 = v141;
        }
        else {
          int v215 = 0;
        }
        uint64_t v216 = v214 - v215;
        if ((int)v213 >= v141) {
          int v217 = v141;
        }
        else {
          int v217 = 0;
        }
        int v218 = v213 - v217;
        int v219 = *(unsigned __int16 *)(v144 + 4 * ((int)v213 - v217));
        if (*(_WORD *)(v144 + 4 * v218))
        {
          if (v218 >= 1
            && ((int)v213 <= 0 ? (int v220 = v141) : (int v220 = 0),
                v219 == *(unsigned __int16 *)(v144 + 4 * ((int)v213 + v220 - 1) + 2)))
          {
            if (v213 == v111)
            {
              if (v210 <= 0) {
                int v221 = v141;
              }
              else {
                int v221 = 0;
              }
              uint64_t v222 = v210++ + (uint64_t)v221 - 1;
              if (v210 >= v141) {
                int v223 = v141;
              }
              else {
                int v223 = 0;
              }
              int v224 = (float *)&v148[v222];
              v225 = (float *)&v148[v213];
              int v226 = (float *)&v148[v210 - v223];
              float v227 = *v224;
              float v228 = *v225;
              float v229 = v225[1];
              float v230 = *v226;
              float v231 = v226[1];
              float v232 = *v225 - *v224;
              float v233 = v229 - v224[1];
              float v234 = *v226 - *v225;
              float v235 = v231 - v229;
              int v236 = v212 + 2;
              if (v212 + 2 >= v141) {
                int v237 = v141;
              }
              else {
                int v237 = 0;
              }
              *(float *)&unsigned int v238 = (float)(v234 * (float)(v148[v236 - v237].f32[1] - v231))
                              - (float)((float)(v148[v236 - v237].f32[0] - v230) * v235);
              if ((__PAIR64__((float)((float)(v232 * v235) - (float)(v234 * v233)) > 0.0, (float)(v232 * v235) - (float)(v234 * v233))- COERCE_UNSIGNED_INT(0.0)) >> 32 != (__PAIR64__(*(float *)&v238 > 0.0, v238)- COERCE_UNSIGNED_INT(0.0)) >> 32|| (float v239 = 1.0/ sqrtf((float)((float)(v233 * v233) + (float)(v232 * v232))* (float)((float)(v235 * v235) + (float)(v234 * v234))), fabsf((float)((float)(v233 * v234) - (float)(v232 * v235)) * v239) < v495[20])&& (float)((float)((float)(v233 * v235) + (float)(v232 * v234)) * v239) < 0.0)
              {
                float v227 = v228;
                uint64_t v222 = v213;
              }
              int v240 = *(float **)&v498[8 * *(__int16 *)(v144 + 4 * v213 + 2)];
              float v241 = v240[5];
              float v242 = v240[6];
              float v243 = v240[7];
              float v244 = (float)(v242 * v227) - (float)(v241 * v148[v222].f32[1]);
              float v245 = -(float)((float)(v242 * v242) + (float)(v241 * v241));
              float v246 = (float)((float)(v241 * v243) - (float)(v242 * v244)) / v245;
              float v247 = (float)((float)(v241 * v244) + (float)(v242 * v243)) / v245;
              goto LABEL_146;
            }
          }
          else
          {
            if ((int)v216 >= v141) {
              int v248 = v141;
            }
            else {
              int v248 = 0;
            }
            BOOL v140 = extendedSegmentTest(*(void *)&v498[8 * ((v496 + *(__int16 *)(v144 + 4 * ((int)v216 - v248))) % (int)v489)], *(void *)&v498[8 * *(__int16 *)(v144 + 4 * ((int)v216 - v248))], *(void *)&v498[8 * *(__int16 *)(v144 + 4 * ((int)v216 - v248) + 2)], 0, (uint64_t)v495);
            unsigned int v148 = v491;
            int v141 = v499;
            uint64_t v144 = v497;
          }
        }
        uint64_t v249 = (float *)&v148[v213];
        float v246 = *v249;
        float v247 = v249[1];
        ++v210;
        int v236 = v212 + 2;
LABEL_146:
        *(float *)(v209 - 16) = v246;
        *(float *)(v209 - 12) = v247;
        if (v210 >= v141) {
          int v250 = v141;
        }
        else {
          int v250 = 0;
        }
        float32x2_t v251 = v148[v210 - v250];
        if (v236 >= v141) {
          int v252 = v141;
        }
        else {
          int v252 = 0;
        }
        float32x2_t v253 = v148[v236 - v252];
        *(float32x2_t *)(v209 - 8) = v251;
        *(float32x2_t *)uint64_t v209 = v253;
        if ((int)v216 >= v141) {
          int v254 = v141;
        }
        else {
          int v254 = 0;
        }
        int v255 = v216 - v254;
        unint64_t v256 = (__int16 *)(v144 + 4 * ((int)v216 - v254));
        int v257 = v256[1];
        if (v496 == v257) {
          goto LABEL_168;
        }
        if (v255 >= v486
          || ((int)v216 + 1 >= v141 ? (int v258 = v141) : (int v258 = 0),
              *(unsigned __int16 *)(v144 + 4 * ((int)v216 + 1 - v258)) != (unsigned __int16)v257))
        {
          BOOL v140 = extendedSegmentTest(*(void *)&v498[8 * *v256], *(void *)&v498[8 * v256[1]], *(void *)&v498[8 * ((v256[1] + 1) % (int)v489)], 1, (uint64_t)v495);
          unsigned int v148 = v491;
          int v141 = v499;
          uint64_t v144 = v497;
LABEL_168:
          unint64_t v279 = (float *)&v148[v216];
          float v277 = *v279;
          float v278 = v279[1];
          goto LABEL_169;
        }
        if (v212 != v206) {
          goto LABEL_168;
        }
        float32x2_t v259 = v253;
        unint64_t v260 = (float *)&v148[v216];
        float v261 = *v260;
        float v262 = v260[1];
        float v263 = *(float *)v485;
        float v264 = *v260 - v259.f32[0];
        float v265 = v262 - v259.f32[1];
        float v266 = *(float *)v485 - *v260;
        float v267 = *(float *)(v485 + 4) - v262;
        *(float *)&unsigned int v268 = (float)((float)(v259.f32[0] - v251.f32[0]) * v265)
                        - (float)(v264 * (float)(v259.f32[1] - v251.f32[1]));
        if ((__PAIR64__((float)((float)(v264 * v267) - (float)(v266 * v265)) > 0.0, (float)(v264 * v267) - (float)(v266 * v265))- COERCE_UNSIGNED_INT(0.0)) >> 32 != (__PAIR64__(*(float *)&v268 > 0.0, v268) - COERCE_UNSIGNED_INT(0.0)) >> 32)goto LABEL_165; {
        float v269 = 1.0
        }
             / sqrtf((float)((float)(v265 * v265) + (float)(v264 * v264))* (float)((float)(v267 * v267) + (float)(v266 * v266)));
        if (fabsf((float)((float)(v267 * (float)-v264) + (float)(v265 * v266)) * v269) >= v495[20])
        {
          uint64_t v270 = v484;
          goto LABEL_166;
        }
        uint64_t v270 = v484;
        if ((float)((float)((float)(v265 * v267) + (float)(v264 * v266)) * v269) < 0.0)
        {
LABEL_165:
          float v263 = v261;
          uint64_t v270 = v216;
        }
LABEL_166:
        int v271 = *(float **)&v498[8 * *(__int16 *)(v144 + 4 * v216)];
        float v272 = v271[5];
        float v273 = v271[6];
        float v274 = v271[7];
        float v275 = (float)(v273 * v263) - (float)(v272 * v148[v270].f32[1]);
        float v276 = -(float)((float)(v273 * v273) + (float)(v272 * v272));
        float v277 = (float)((float)(v272 * v274) - (float)(v273 * v275)) / v276;
        float v278 = (float)((float)(v272 * v275) + (float)(v273 * v274)) / v276;
LABEL_169:
        *(float *)(v209 + 8) = v277;
        *(float *)(v209 + 12) = v278;
        v209 += 32;
        ++v207;
        if (v210 == v494)
        {
          unsigned int v142 = v207;
          a4 = (uint64_t)v482;
LABEL_172:
          int v109 = v498;
LABEL_249:
          uint64_t v391 = v142;
          MEMORY[0x1F4188790](v140);
          MEMORY[0x1F4188790](v392);
          v394 = (float *)((char *)&v467 - v393);
          MEMORY[0x1F4188790](v395);
          if ((int)v108 < 1)
          {
            uint64_t v17 = v487;
          }
          else
          {
            v397 = &v467 - 4 * v391;
            uint64_t v477 = v108;
            v482 = (_OWORD *)a4;
            v398 = v147;
            v483 = v396;
            v399 = v396;
            v400 = v394;
            uint64_t v401 = v391;
            do
            {
              computePolyAreaAndMetric(v398, v399++, v400++);
              v398 += 8;
              --v401;
            }
            while (v401);
            uint64_t v408 = 0;
            int v409 = 0;
            float v410 = 0.0;
            uint64_t v494 = 0xFFFFFFFFLL;
            do
            {
              if (v394[v408] >= v14)
              {
                v411 = (float32x2_t *)&v147[8 * v408];
                float v412 = v411->f32[1];
                float v413 = v411[3].f32[0];
                float v414 = v411[3].f32[1];
                float v415 = v413 - v411[2].f32[0];
                float v416 = v414 - v411[2].f32[1];
                v406.f32[0] = v411->f32[0] - v413;
                float v417 = v412 - v414;
                float v418 = (float)(v416 * v416) + (float)(v415 * v415);
                *(float *)&double v404 = (float)(v417 * v417) + (float)(v406.f32[0] * v406.f32[0]);
                *(float *)&double v405 = -(float)(v406.f32[0] * v416);
                double v419 = fabsf(*(float *)&v405 + (float)(v415 * v417));
                double v420 = v419 / sqrt((float)(v418 * *(float *)&v404));
                *(float *)&double v420 = v420;
                float v421 = fabsf((float)(v406.f32[0] * (float)(v411[1].f32[1] - v412))- (float)((float)(v411[1].f32[0] - v411->f32[0]) * v417))/ sqrt((float)((float)((float)((float)(v411[1].f32[1] - v412) * (float)(v411[1].f32[1] - v412))+ (float)((float)(v411[1].f32[0] - v411->f32[0])* (float)(v411[1].f32[0] - v411->f32[0])))* *(float *)&v404));
                if (v12 <= *(float *)&v420 && v12 <= v421)
                {
                  *(int32x2_t *)&long long v402 = vcvt_s32_f32(vrnda_f32(v411[3]));
                  *(int32x2_t *)&long long v403 = vcvt_s32_f32(vrnda_f32(*v411));
                  *(int32x2_t *)&long long v407 = vabd_s32(*(int32x2_t *)&v403, *(int32x2_t *)&v402);
                  if (v407 <= DWORD1(v407)) {
                    unsigned int v423 = DWORD1(v407);
                  }
                  else {
                    unsigned int v423 = v407;
                  }
                  if (v423 < 0xC) {
                    goto LABEL_310;
                  }
                  double v404 = COERCE_DOUBLE(vcvt_f32_s32(*(int32x2_t *)&v402));
                  float32x2_t v424 = vcvt_f32_s32(*(int32x2_t *)&v403);
                  *(float *)&double v419 = (float)(*((_DWORD *)v488 + 4) - 2);
                  *(float *)&double v405 = (float)(*((_DWORD *)v488 + 2) - 2);
                  float32x2_t v425 = (float32x2_t)vzip1_s32((int32x2_t)v424, *(int32x2_t *)&v404);
                  __asm { FMOV            V7.2S, #1.0 }
                  float32x2_t v430 = (float32x2_t)vzip2_s32((int32x2_t)v424, *(int32x2_t *)&v404);
                  float32x2_t v406 = (float32x2_t)vorr_s8((int8x8_t)vsub_s32((int32x2_t)vand_s8((int8x8_t)vcgt_f32(v425, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v419, 0)), (int8x8_t)0x200000002), vcgt_f32(_D7, v425)), vorr_s8(vand_s8((int8x8_t)vcgt_f32(_D7, v430), (int8x8_t)0x400000004), vand_s8((int8x8_t)vcgt_f32(v430, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v405, 0)), (int8x8_t)0x800000008)));
                  int v431 = v406.i32[1];
                  int v432 = v406.i32[0];
                  if (*(double *)&v406 == 0.0)
                  {
                    long long v485 = v407;
                    int16x4_t v444 = vuzp1_s16(*(int16x4_t *)&v403, *(int16x4_t *)&v402);
                    *(void *)&long long v403 = 0xFFFFFFFF00000001;
                    long long v484 = v403;
                    goto LABEL_291;
                  }
                  if ((v406.i32[0] & v406.i32[1]) == 0)
                  {
                    char v433 = 0;
                    char v434 = 0;
                    float v435 = v424.f32[1];
                    float v436 = *((float *)&v404 + 1);
                    *(double *)&float32x2_t v406 = 0.0;
                    LODWORD(v437) = LODWORD(v404);
                    float v438 = 0.0;
                    v439.i32[0] = v424.i32[0];
                    do
                    {
                      if (v431) {
                        int v440 = v431;
                      }
                      else {
                        int v440 = v432;
                      }
                      float v441 = v435 - v436;
                      float v442 = v439.f32[0] - *(float *)&v437;
                      if ((v440 & 4) != 0)
                      {
                        float v438 = 1.0;
                        v406.f32[0] = *(float *)&v437 + (float)((float)((float)(1.0 - v436) * v442) / v441);
                      }
                      else
                      {
                        if (v440)
                        {
                          v406.f32[0] = 1.0;
                          float v438 = v436 + (float)((float)((float)(1.0 - *(float *)&v437) * v441) / v442);
                        }
                        if ((v440 & 2) != 0)
                        {
                          v406.f32[0] = (float)(*((_DWORD *)v488 + 4) - 2);
                          float v438 = v436 + (float)((float)((float)(*(float *)&v419 - *(float *)&v437) * v441) / v442);
                        }
                        float v443 = *(float *)&v437 + (float)((float)((float)(*(float *)&v405 - v436) * v442) / v441);
                        if ((v440 & 8) != 0)
                        {
                          v406.f32[0] = v443;
                          float v438 = (float)(*((_DWORD *)v488 + 2) - 2);
                        }
                      }
                      if (v440 == v431)
                      {
                        int v431 = (v406.f32[0] < 1.0) | (2 * (v406.f32[0] > *(float *)&v419)) | (4 * (v438 < 1.0)) | (8 * (v438 > *(float *)&v405));
                        if (!(v432 | v431))
                        {
                          v406.f32[1] = v438;
                          double v404 = *(double *)&v406;
                          if ((v434 & 1) == 0) {
                            goto LABEL_290;
                          }
LABEL_289:
                          v439.f32[1] = v435;
                          *(double *)&float32x2_t v406 = v404;
                          float32x2_t v424 = v439;
LABEL_290:
                          int16x4_t v445 = (int16x4_t)vcvt_s32_f32(vrnda_f32(v424));
                          int16x4_t v446 = (int16x4_t)vcvt_s32_f32(vrnda_f32(v406));
                          v447.i16[0] = v445.i16[2];
                          v447.i16[1] = v445.i16[0];
                          v447.i16[2] = v446.i16[2];
                          v447.i16[3] = v446.i16[0];
                          v448.i16[0] = WORD2(v403);
                          v448.i16[1] = v403;
                          v448.i16[2] = WORD2(v402);
                          v448.i16[3] = v402;
                          *(int16x4_t *)&long long v403 = vceq_s16(v447, v448);
                          v447.i32[0] = WORD3(v403);
                          v447.i32[1] = WORD1(v403);
                          LODWORD(v402) = WORD2(v403);
                          DWORD1(v402) = (unsigned __int16)v403;
                          *(int8x8_t *)&long long v402 = vand_s8((int8x8_t)v447, *(int8x8_t *)&v402);
                          LODWORD(v403) = vand_s8(*(int8x8_t *)&v402, (int8x8_t)0x100000001).u32[0];
                          DWORD1(v403) = vcltz_s32(vshl_n_s32(*(int32x2_t *)&v402, 0x1FuLL)).i32[1];
                          long long v484 = v403;
                          *(int32x2_t *)&long long v402 = vabd_s32((int32x2_t)v445, (int32x2_t)v446);
                          long long v485 = v402;
                          int16x4_t v444 = vuzp1_s16(v445, v446);
LABEL_291:
                          uint64_t v15 = BresenhamCoords(v444.i32[1], v444.i32[0], (uint64_t)v479);
                          double v420 = *(double *)&v484;
                          uint64_t v449 = (v15 + DWORD1(v484));
                          int v450 = *((_DWORD *)v488 + 6);
                          uint64_t v451 = *v488;
                          long long v403 = v485;
                          *(uint32x2_t *)&long long v402 = vcgt_u32(*(uint32x2_t *)&v485, (uint32x2_t)vdup_lane_s32(*(int32x2_t *)&v485, 1));
                          if (v402)
                          {
                            if ((int)v484 < (int)v449)
                            {
                              int v452 = 0;
                              uint64_t v453 = v449 - v484;
                              v454 = &v470[4 * v484];
                              do
                              {
                                uint64_t v455 = *((__int16 *)v454 - 1) + *(__int16 *)v454 * (uint64_t)v450;
                                int v456 = *(unsigned char *)(v451 + v455)
                                    || *(unsigned char *)(v451 + (int)v455 + (uint64_t)v450)
                                    || *(unsigned __int8 *)(v451 + (int)v455 - (uint64_t)v450) != 0;
                                v454 += 4;
                                v452 += v456;
                                --v453;
                              }
                              while (v453);
                              goto LABEL_309;
                            }
LABEL_308:
                            int v452 = 0;
                            goto LABEL_309;
                          }
                          if ((int)v484 >= (int)v449) {
                            goto LABEL_308;
                          }
                          int v452 = 0;
                          uint64_t v457 = v449 - v484;
                          v458 = &v470[4 * v484];
                          do
                          {
                            uint64_t v459 = *((__int16 *)v458 - 1) + *(__int16 *)v458 * (uint64_t)v450;
                            int v460 = *(unsigned char *)(v451 + v459)
                                || *(unsigned char *)(v451 + (int)v459 + 1)
                                || *(unsigned __int8 *)((int)v459 + v451 - 1) != 0;
                            v458 += 4;
                            v452 += v460;
                            --v457;
                          }
                          while (v457);
LABEL_309:
                          *(float *)&long long v402 = (float)v452;
                          *(float *)&long long v403 = roundf(v13 * (float)(int)(v423 - 1));
                          if (*(float *)&v403 <= (float)v452)
                          {
LABEL_310:
                            uint64_t v15 = quadValid((uint64_t)&v147[8 * v408], (uint64_t)v495, *(double *)&v402, *(double *)&v403, v420, v404, v419, v405, *(double *)&v406);
                            if (v15)
                            {
                              v461 = &v397[4 * v409];
                              long long v402 = *(_OWORD *)v411->f32;
                              long long v403 = *(_OWORD *)v411[2].f32;
                              *(_OWORD *)v461 = *(_OWORD *)v411->f32;
                              *((_OWORD *)v461 + 1) = v403;
                              if (v483[v408] <= v410)
                              {
                                uint64_t v462 = v494;
                              }
                              else
                              {
                                float v410 = v483[v408];
                                uint64_t v462 = v409;
                              }
                              uint64_t v494 = v462;
                              ++v409;
                            }
                          }
                          break;
                        }
                        char v433 = 1;
                        float v436 = v438;
                        LODWORD(v437) = v406.i32[0];
                      }
                      else
                      {
                        int v432 = (*(float *)&v437 < 1.0) | (2 * (*(float *)&v437 > *(float *)&v419)) | (4 * (v436 < 1.0)) | (8 * (v436 > *(float *)&v405));
                        if (!(v432 | v431))
                        {
                          *((float *)&v437 + 1) = v436;
                          if (v433) {
                            double v404 = v437;
                          }
                          float v435 = v438;
                          v439.i32[0] = v406.i32[0];
                          goto LABEL_289;
                        }
                        char v434 = 1;
                        float v435 = v438;
                        v439.i32[0] = v406.i32[0];
                      }
                    }
                    while ((v432 & v431) <= 0);
                  }
                  int v109 = v498;
                }
              }
              ++v408;
            }
            while (v408 != v391);
            if (v409 <= 0)
            {
              a4 = (uint64_t)v482;
              uint64_t v17 = v487;
            }
            else
            {
              v463 = &v397[4 * (int)v494];
              long long v464 = *((_OWORD *)v463 + 1);
              v465 = v482;
              _OWORD *v482 = *(_OWORD *)v463;
              v465[1] = v464;
              a4 = (uint64_t)(v465 + 2);
              uint64_t v17 = v487 + 1;
            }
            LODWORD(v42) = v499;
            uint64_t v108 = v477;
          }
          a5 = v480;
LABEL_323:
          if (++v107 >= v493 || (int)v17 >= (int)a5)
          {
LABEL_325:
            uint64_t v16 = v475;
LABEL_326:
            if (++v16 == v472)
            {
              uint64_t v15 = v502;
              float v11 = v479;
              if (v502) {
                goto LABEL_328;
              }
              goto LABEL_329;
            }
            goto LABEL_3;
          }
          goto LABEL_54;
        }
      }
    }
    if (v141 <= v111) {
      int v159 = v141;
    }
    else {
      int v159 = 0;
    }
    int v160 = v111 - v159;
    int v161 = *(unsigned __int16 *)(v144 + 4 * (v111 - v159));
    int v162 = v491;
    if (*(_WORD *)(v144 + 4 * v160))
    {
      if (v160 >= 1)
      {
        int v163 = v111 >= 1 ? 0 : v141;
        uint64_t v164 = v111 + (uint64_t)v163 - 1;
        if (v161 == *(unsigned __int16 *)(v144 + 4 * v164 + 2))
        {
          int v165 = v111 + 1;
          if (v111 + 1 >= v141) {
            int v166 = v141;
          }
          else {
            int v166 = 0;
          }
          int v167 = (float *)&v491[v164];
          unint64_t v168 = (float *)&v491[v111];
          int v169 = (float *)&v491[v165 - v166];
          float v170 = *v167;
          float v171 = v167[1];
          float v172 = *v168;
          float v173 = v168[1];
          float v174 = *v169;
          float v175 = v169[1];
          float v176 = *v168 - *v167;
          float v177 = v173 - v171;
          float v178 = *v169 - *v168;
          int v180 = v111 + 2;
          if (v111 + 2 >= v141) {
            int v181 = v141;
          }
          else {
            int v181 = 0;
          }
          *(float *)&unsigned int v182 = (float)(v178 * (float)(v491[v180 - v181].f32[1] - v175))
                          - (float)((float)(v491[v180 - v181].f32[0] - v174) * (float)(v175 - v173));
          *(float *)&unsigned int v179 = (float)(v176 * (float)(v175 - v173)) - (float)(v178 * (float)(v173 - v171));
          if ((__PAIR64__(*(float *)&v179 > 0.0, v179) - COERCE_UNSIGNED_INT(0.0)) >> 32 != (__PAIR64__(*(float *)&v182 > 0.0, v182)- COERCE_UNSIGNED_INT(0.0)) >> 32|| (float v183 = v170 - v172, v184 = v171 - v173, v185 = 1.0/ sqrtf((float)((float)(v177 * v177) + (float)(v176 * v176))* (float)((float)(v184 * v184) + (float)(v183 * v183))), fabsf((float)((float)(v177 * (float)(v170 - v172)) - (float)(v176 * v184)) * v185) < v495[20])&& (float)((float)((float)(v177 * v184) + (float)(v176 * v183)) * v185) < 0.0)
          {
            float v170 = v172;
            uint64_t v164 = v111;
          }
          int v186 = *(float **)&v498[8 * *(__int16 *)(v144 + 4 * v111 + 2)];
          float v187 = v186[5];
          float v188 = v186[6];
          float v189 = v186[7];
          float v190 = (float)(v188 * v170) - (float)(v187 * v491[v164].f32[1]);
          float v191 = -(float)((float)(v188 * v188) + (float)(v187 * v187));
          float v192 = (float)((float)(v187 * v189) - (float)(v188 * v190)) / v191;
          float v193 = (float)((float)(v187 * v190) + (float)(v188 * v189)) / v191;
LABEL_178:
          uint64_t v283 = &v147[8 * v142];
          *uint64_t v283 = v192;
          v283[1] = v193;
          if (v165 >= v141) {
            int v284 = v141;
          }
          else {
            int v284 = 0;
          }
          float32x2_t v285 = v162[v165 - v284];
          if (v180 >= v141) {
            int v286 = v141;
          }
          else {
            int v286 = 0;
          }
          float32x2_t v287 = v162[v180 - v286];
          *((float32x2_t *)v283 + 1) = v285;
          *((float32x2_t *)v283 + 2) = v287;
          if (v111 + 3 >= v141) {
            int v288 = v141;
          }
          else {
            int v288 = 0;
          }
          int v289 = v111 + 3 - v288;
          uint64_t v290 = v289;
          if (v113 <= v141) {
            int v291 = 0;
          }
          else {
            int v291 = v141;
          }
          int v292 = v139 - v291;
          v293 = (__int16 *)(v144 + 4 * (v139 - v291));
          int v294 = v293[1];
          int v109 = v498;
          if (v496 != v294)
          {
            if (v292 < v486)
            {
              int v295 = v113 >= v141 ? v141 : 0;
              if (*(unsigned __int16 *)(v144 + 4 * (v113 - v295)) == (unsigned __int16)v294)
              {
                float v296 = v287.f32[0];
                float32x2_t v297 = v285;
                if (v111 + 4 >= v141) {
                  int v298 = v141;
                }
                else {
                  int v298 = 0;
                }
                v287.i32[0] = v111 + 4 - v298;
                v299 = (float *)&v162[v289];
                v300 = (float *)&v162[v287.i32[0]];
                float v301 = v299[1];
                float v302 = *v300;
                float v303 = *v299 - v296;
                float v304 = v301 - v287.f32[1];
                float v305 = *v300 - *v299;
                float v306 = v300[1] - v301;
                *(float *)&unsigned int v307 = (float)((float)(v296 - v297.f32[0]) * v304)
                                - (float)(v303 * (float)(v287.f32[1] - v297.f32[1]));
                if ((__PAIR64__((float)((float)(v303 * v306) - (float)(v305 * v304)) > 0.0, (float)(v303 * v306) - (float)(v305 * v304))- COERCE_UNSIGNED_INT(0.0)) >> 32 != (__PAIR64__(*(float *)&v307 > 0.0, v307)- COERCE_UNSIGNED_INT(0.0)) >> 32|| (float32x2_t v287 = (float32x2_t)v287.i32[0], v308 = 1.0/ sqrtf((float)((float)(v304 * v304) + (float)(v303 * v303))* (float)((float)(v306 * v306) + (float)(v305 * v305))), fabsf((float)((float)(v306 * (float)-v303) + (float)(v304 * v305)) * v308) < v495[20])&& (float)((float)((float)(v304 * v306) + (float)(v303 * v305)) * v308) < 0.0)
                {
                  float v302 = *v299;
                  float32x2_t v287 = (float32x2_t)v289;
                }
                v309 = *(float **)&v498[8 * *(__int16 *)(v144 + 4 * v289)];
                float v310 = v309[5];
                float v311 = v309[6];
                float v312 = v309[7];
                float v313 = (float)(v311 * v302) - (float)(v310 * v162[*(void *)&v287].f32[1]);
                float v314 = -(float)((float)(v311 * v311) + (float)(v310 * v310));
                float v315 = (float)((float)(v310 * v312) - (float)(v311 * v313)) / v314;
                float v316 = (float)((float)(v310 * v313) + (float)(v311 * v312)) / v314;
                goto LABEL_236;
              }
            }
            unsigned int v362 = v142;
            BOOL v140 = extendedSegmentTest(*(void *)&v498[8 * *v293], *(void *)&v498[8 * v293[1]], *(void *)&v498[8 * ((v293[1] + 1) % (int)v489)], 1, (uint64_t)v495);
            unsigned int v142 = v362;
            int v162 = v491;
          }
          v363 = (float *)&v162[v290];
          float v315 = *v363;
          float v316 = v363[1];
LABEL_236:
          ++v142;
          v283[6] = v315;
          v283[7] = v316;
          goto LABEL_249;
        }
      }
      if (v113 <= v141) {
        int v280 = 0;
      }
      else {
        int v280 = v141;
      }
      unsigned int v281 = v142;
      BOOL v140 = extendedSegmentTest(*(void *)&v498[8 * ((v496 + *(__int16 *)(v144 + 4 * (v139 - v280))) % (int)v489)], *(void *)&v498[8 * *(__int16 *)(v144 + 4 * (v139 - v280))], *(void *)&v498[8 * *(__int16 *)(v144 + 4 * (v139 - v280) + 2)], 0, (uint64_t)v495);
      unsigned int v142 = v281;
      int v162 = v491;
      int v141 = v499;
      uint64_t v144 = v497;
    }
    uint64_t v282 = (float *)&v162[v111];
    float v192 = *v282;
    float v193 = v282[1];
    int v165 = v111 + 1;
    int v180 = v111 + 2;
    goto LABEL_178;
  }
  uint64_t v17 = 0;
  if (v15) {
LABEL_328:
  }
    free((void *)v15);
LABEL_329:
  if (v11) {
    free(v11);
  }
  return v17;
}

BOOL quadValid(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  float v11 = *(float *)(a2 + 96) - *(float *)(a2 + 20);
  if (v11 < 0.0) {
    float v11 = 0.0;
  }
  float v12 = v11 * v11;
  float v13 = (float *)(a1 + 4);
  for (uint64_t i = 1; i != 5; ++i)
  {
    float v15 = (float)((float)(*v13 - *(float *)(a1 + 8 * (i & 3) + 4)) * (float)(*v13 - *(float *)(a1 + 8 * (i & 3) + 4)))
        + (float)((float)(*(v13 - 1) - *(float *)(a1 + 8 * (i & 3))) * (float)(*(v13 - 1) - *(float *)(a1 + 8 * (i & 3))));
    v13 += 2;
    if (v15 < v12) {
      return 0;
    }
  }
  float v16 = *(float *)(a2 + 52);
  if (v16 < 0.0) {
    return 1;
  }
  int32x2_t v18 = (int32x2_t)*(unsigned int *)(a2 + 56);
  LODWORD(a5) = *(_DWORD *)(a2 + 60);
  float v19 = *(float *)a1 - *(float *)v18.i32;
  *(float *)&a7 = *(float *)(a1 + 4) - *(float *)&a5;
  *(float *)&a8 = *(float *)(a1 + 16) - *(float *)v18.i32;
  *(float *)&a9 = *(float *)(a1 + 20) - *(float *)&a5;
  v20.i32[0] = *(_DWORD *)(a1 + 24);
  v21.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v9.i32 = -*(float *)&a7;
  *(float *)v10.i32 = -v19;
  v20.i32[1] = *(_DWORD *)(a1 + 8);
  float32x2_t v22 = vsub_f32(v20, (float32x2_t)vdup_lane_s32(v18, 0));
  v21.i32[1] = *(_DWORD *)(a1 + 12);
  float32x2_t v23 = vsub_f32(v21, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0));
  float32x2_t v24 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a9, 0);
  float32x2_t v25 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a8, 0);
  float32x2_t v26 = vmls_lane_f32(vmla_n_f32(vmla_n_f32(vmul_n_f32(v23, -(float)(v19 - *(float *)&a8)), v22, *(float *)&a7 - *(float *)&a9), v24, v19), v25, *(float32x2_t *)&a7, 0);
  float32x2_t v27 = (float32x2_t)vrev64_s32((int32x2_t)v23);
  float32x2_t v28 = vmla_f32(vmul_f32(v23, vneg_f32((float32x2_t)vrev64_s32((int32x2_t)vsub_f32(v22, v25)))), v22, vsub_f32(v27, v24));
  float32x2_t v29 = (float32x2_t)vrev64_s32((int32x2_t)v22);
  float32x2_t v30 = vdiv_f32(v26, vmls_lane_f32(vmla_n_f32(v28, v29, *(float *)&a9), v27, *(float32x2_t *)&a8, 0));
  __asm
  {
    FMOV            V5.2S, #-1.0
    FMOV            V7.2S, #1.0
  }
  float32x2_t v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)vdup_n_s32(0x3BA3D70Au), vabs_f32(vadd_f32(v30, _D5))), _D7, (int8x8_t)v30);
  float32x2_t v38 = vadd_f32(v37, _D5);
  float32x2_t v39 = vmla_f32((float32x2_t)vdup_lane_s32(v9, 0), v27, v37);
  float32x2_t v40 = vmla_f32((float32x2_t)vdup_lane_s32(v10, 0), v29, v37);
  float32x2_t v41 = vmla_f32(vmla_f32(vmul_f32(v39, v39), v38, vmul_n_f32(v38, v16 * v16)), v40, v40);
  float v42 = sqrtf(vdiv_f32(v41, (float32x2_t)vdup_lane_s32((int32x2_t)v41, 1)).f32[0]);
  if (v42 > 1.0) {
    float v42 = 1.0 / v42;
  }
  if (v42 < *(float *)(a2 + 44)) {
    return 0;
  }
  return v42 <= *(float *)(a2 + 48);
}

void sub_1A3E8BE88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8C178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8C25C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8C2F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8C420(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8C518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8C564(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

FILE *ImageProcessing_save(FILE *result, void *a2, int a3)
{
  if (result)
  {
    if (a2)
    {
      if (*a2)
      {
        int v4 = a2 + 2;
        if (a2[2])
        {
          float v5 = a2 + 1;
          if (a2[1])
          {
            if (a2[3] >= 2uLL)
            {
              BOOL result = fopen((const char *)result, "wb");
              if (result)
              {
                uint64_t v7 = result;
                if (!*a2 || !*v4 || !*v5 || a2[3] < 2uLL) {
                  return (FILE *)fclose(v7);
                }
                if (a3)
                {
                  uint64_t v8 = 1;
                }
                else if ((a3 & 0x3E) != 0)
                {
                  uint64_t v8 = 4;
                }
                else
                {
                  if ((a3 & 0x3C0) == 0)
                  {
                    syslog(5, "ERROR: Invalid image type");
                    return (FILE *)fclose(v7);
                  }
                  uint64_t v8 = 16;
                }
                int __ptr = 0;
                if (fwrite(&__ptr, 4uLL, 1uLL, result) == 1)
                {
                  int v16 = a3;
                  if (fwrite(&v16, 4uLL, 1uLL, v7) == 1
                    && fwrite(a2 + 2, 8uLL, 1uLL, v7) == 1
                    && fwrite(a2 + 1, 8uLL, 1uLL, v7) == 1)
                  {
                    uint64_t v15 = a2[3];
                    if (fwrite(&v15, 8uLL, 1uLL, v7) == 1)
                    {
                      int32x2_t v9 = (char *)*a2;
                      if (*a2)
                      {
                        uint64_t v10 = *v4;
                        if (*v4)
                        {
                          unint64_t v11 = *v5;
                          if (*v5)
                          {
                            unint64_t v12 = a2[3];
                            if (v12 >= 2)
                            {
                              if (v11 < 2)
                              {
                                uint64_t v13 = 0;
                                goto LABEL_35;
                              }
                              if (v12 * (v11 - 1) == fwrite(v9, 1uLL, v12 * (v11 - 1), v7) && *v5)
                              {
                                int32x2_t v9 = (char *)*a2;
                                uint64_t v13 = *v5 - 1;
                                uint64_t v10 = a2[2];
                                unint64_t v12 = a2[3];
LABEL_35:
                                unint64_t v14 = v10 * v8;
                                if (v10 * v8 == fwrite(&v9[v12 * v13], 1uLL, v10 * v8, v7) && a2[3] > v14)
                                {
                                  LOBYTE(v15) = 0;
                                  do
                                  {
                                    if (fwrite(&v15, 1uLL, 1uLL, v7) != 1) {
                                      break;
                                    }
                                    ++v14;
                                  }
                                  while (v14 < a2[3]);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                return (FILE *)fclose(v7);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

const char *CVML_getStatusDescription(unint64_t a1)
{
  uint64_t v1 = "Not supported error";
  switch(a1)
  {
    case 0x59u:
      return v1;
    case 0x5Au:
      uint64_t v1 = "General error";
      break;
    case 0x5Bu:
      uint64_t v1 = "Espresso error";
      break;
    case 0x5Cu:
      uint64_t v1 = "incorrect binserializer key";
      break;
    case 0x5Du:
      uint64_t v1 = "small sparsity error";
      break;
    case 0x5Eu:
      uint64_t v1 = "feature extraction error";
      break;
    case 0x5Fu:
      uint64_t v1 = "initialization error";
      break;
    case 0x60u:
      uint64_t v1 = "no saved state to revert";
      break;
    case 0x61u:
      uint64_t v1 = "nominal distance not changed";
      break;
    case 0x62u:
      uint64_t v1 = "batch size violation";
      break;
    case 0x63u:
      uint64_t v1 = "computation kill request was issued";
      break;
    case 0x64u:
      uint64_t v1 = "too few IDs to build VIP model";
      break;
    case 0x65u:
      uint64_t v1 = "video error";
      break;
    case 0x66u:
      uint64_t v1 = "error with projection computation";
      break;
    case 0x67u:
      uint64_t v1 = "missing positional parameter";
      break;
    case 0x68u:
      uint64_t v1 = "inconsistent state error";
      break;
    case 0x69u:
      uint64_t v1 = "warping error";
      break;
    case 0x6Au:
      uint64_t v1 = "OpenGL error";
      break;
    case 0x6Bu:
      uint64_t v1 = "invalid format";
      break;
    case 0x6Cu:
      uint64_t v1 = "out of bounds";
      break;
    case 0x6Du:
      uint64_t v1 = "singular point configuration error";
      break;
    case 0x6Eu:
      uint64_t v1 = "division by zero";
      break;
    case 0x6Fu:
      uint64_t v1 = "LAPACK error";
      break;
    case 0x70u:
      uint64_t v1 = "platform endianess not supported";
      break;
    case 0x71u:
      uint64_t v1 = "hash already in use";
      break;
    case 0x72u:
      uint64_t v1 = "invalid ID";
      break;
    case 0x73u:
      uint64_t v1 = "invalid data type";
      break;
    case 0x74u:
      uint64_t v1 = "data inconsistency error";
      break;
    case 0x75u:
      uint64_t v1 = "I/O error";
      break;
    case 0x76u:
      uint64_t v1 = "unknown option";
      break;
    case 0x77u:
      uint64_t v1 = "invalid option";
      break;
    case 0x78u:
      uint64_t v1 = "missing option";
      break;
    case 0x79u:
      uint64_t v1 = "delegate error";
      break;
    case 0x7Au:
      uint64_t v1 = "vImage related error";
      break;
    case 0x7Bu:
      uint64_t v1 = "memory allocation error";
      break;
    case 0x7Cu:
      uint64_t v1 = "invalid parameter";
      break;
    case 0x7Du:
      uint64_t v1 = "unexpected null pointer";
      break;
    case 0x7Eu:
      uint64_t v1 = "internal error";
      break;
    case 0x7Fu:
      uint64_t v1 = "not implemented error";
      break;
    case 0x80u:
      uint64_t v1 = "ok";
      break;
    default:
      uint64_t v1 = CVML_getStatusDescription_ourSharedDefaultStatusDescription;
      snprintf(CVML_getStatusDescription_ourSharedDefaultStatusDescription, 0x3FuLL, "CVML_status module %d error %lld", a1 >> 8, a1 - 128);
      break;
  }
  return v1;
}

const char *CVML_getModuleDescription(uint64_t a1)
{
  uint64_t v1 = "BinSerializer";
  switch(a1 >> 8)
  {
    case 1:
      return v1;
    case 2:
      uint64_t v1 = "ERT";
      break;
    case 3:
      uint64_t v1 = "Face3D";
      break;
    case 4:
      uint64_t v1 = "FaceDescriptor";
      break;
    case 5:
      uint64_t v1 = "FaceFrontalizer";
      break;
    case 6:
      uint64_t v1 = "FaceWarper";
      break;
    case 7:
      uint64_t v1 = "Geometry2D";
      break;
    case 8:
      uint64_t v1 = "Geometry3D";
      break;
    case 9:
      uint64_t v1 = "ImageGrouping";
      break;
    case 10:
      uint64_t v1 = "ImageQuality";
      break;
    case 11:
      uint64_t v1 = "LandmarkDetector";
      break;
    case 12:
      uint64_t v1 = "MomentProcessor";
      break;
    case 13:
      uint64_t v1 = "FaceboxAligner";
      break;
    case 14:
      uint64_t v1 = "ImageDescriptor";
      break;
    case 15:
      uint64_t v1 = "ImageClassifier";
      break;
    case 16:
      uint64_t v1 = "ImageProcessing";
      break;
    case 17:
      uint64_t v1 = "VIPIdentification";
      break;
    case 18:
      uint64_t v1 = "ImageRegistration";
      break;
    case 19:
      uint64_t v1 = "SimilarityMatrix";
      break;
    case 20:
      uint64_t v1 = "Clustering";
      break;
    case 21:
      uint64_t v1 = "HumanDetector";
      break;
    case 22:
      uint64_t v1 = "FaceRegionMap";
      break;
    case 23:
      uint64_t v1 = "ObjectDetector";
      break;
    case 24:
      uint64_t v1 = "DML";
      break;
    case 25:
      uint64_t v1 = "SGD";
      break;
    case 26:
      uint64_t v1 = "ObjectTracker";
      break;
    case 27:
      uint64_t v1 = "SRCClassifier";
      break;
    case 28:
      uint64_t v1 = "Kmeans";
      break;
    case 29:
      uint64_t v1 = "SparseCoding";
      break;
    case 30:
      uint64_t v1 = "FaceID";
      break;
    case 31:
      uint64_t v1 = "BoostedClassifier";
      break;
    case 32:
      uint64_t v1 = "FaceSegmenter";
      break;
    case 33:
      uint64_t v1 = "ImageAnalyzer";
      break;
    case 34:
      uint64_t v1 = "FaceAttributes";
      break;
    case 35:
      uint64_t v1 = "FaceprintAndAttributes";
      break;
    case 36:
      uint64_t v1 = "FaceQuality";
      break;
    case 37:
      uint64_t v1 = "Torsoprint";
      break;
    case 38:
      uint64_t v1 = "ScreenGaze";
      break;
    case 39:
      uint64_t v1 = "TapToBox";
      break;
    case 40:
      uint64_t v1 = "PetprintGenerator";
      break;
    case 41:
    case 42:
    case 43:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
      goto LABEL_5;
    case 44:
      uint64_t v1 = "RANSAC";
      break;
    case 64:
      uint64_t v1 = "Generic";
      break;
    case 65:
      uint64_t v1 = "ImageTools";
      break;
    case 66:
      uint64_t v1 = "VideoTools";
      break;
    case 67:
      uint64_t v1 = "ImageWarper";
      break;
    case 68:
      uint64_t v1 = "ThirdParty";
      break;
    case 69:
      uint64_t v1 = "BinSerializerProcessor";
      break;
    case 70:
      uint64_t v1 = "AppleNetParser";
      break;
    case 128:
      uint64_t v1 = "FaceProcessorCLI";
      break;
    case 129:
      uint64_t v1 = "ImageClassifierCLI";
      break;
    case 130:
      uint64_t v1 = "MPCmdlineClientCLI";
      break;
    case 131:
      uint64_t v1 = "ClusteringCLI";
      break;
    case 132:
      uint64_t v1 = "ImageProcessorCLI";
      break;
    case 133:
      uint64_t v1 = "PhotosProcessorCLI";
      break;
    default:
      if (a1 >> 8 == 192)
      {
        uint64_t v1 = "CVMLEngine";
      }
      else
      {
LABEL_5:
        uint64_t v1 = CVML_getModuleDescription_ourSharedModuleNameString;
        snprintf(CVML_getModuleDescription_ourSharedModuleNameString, 0x1FuLL, "CVML Module %lld", a1 >> 8);
      }
      break;
  }
  return v1;
}

void sub_1A3E8D1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8D2AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8D38C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8D478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8D570(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8D660(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8D7E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8DEA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void _recordResultsInObservationsRecipients(void *a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v5 = v3;
  uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v13;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v13 != v7) {
          objc_enumerationMutation(v5);
        }
        id v9 = *(id *)(*((void *)&v12 + 1) + 8 * v8);
        id v10 = v4;
        if (v9)
        {
          unint64_t v11 = objc_msgSend(v9, "observationsRecipient", (void)v12);
          [v10 cacheObservationsOfRequest:v11];
        }
        ++v8;
      }
      while (v6 != v8);
      uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v6);
  }
}

void sub_1A3E8E23C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8E56C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8E6B0(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3E8E728(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8E938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8EBA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<objc_class * {__strong},objc_selector *>,std::__unordered_map_hasher<objc_class * {__strong},std::__hash_value_type<objc_class * {__strong},objc_selector *>,std::hash<objc_class * {__strong}>,std::equal_to<objc_class * {__strong}>,true>,std::__unordered_map_equal<objc_class * {__strong},std::__hash_value_type<objc_class * {__strong},objc_selector *>,std::equal_to<objc_class * {__strong}>,std::hash<objc_class * {__strong}>,true>,std::allocator<std::__hash_value_type<objc_class * {__strong},objc_selector *>>>::find<objc_class * {__strong}>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  BOOL result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      BOOL result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<objc_class * {__strong},objc_selector *>,std::__unordered_map_hasher<objc_class * {__strong},std::__hash_value_type<objc_class * {__strong},objc_selector *>,std::hash<objc_class * {__strong}>,std::equal_to<objc_class * {__strong}>,true>,std::__unordered_map_equal<objc_class * {__strong},std::__hash_value_type<objc_class * {__strong},objc_selector *>,std::equal_to<objc_class * {__strong}>,std::hash<objc_class * {__strong}>,true>,std::allocator<std::__hash_value_type<objc_class * {__strong},objc_selector *>>>::__emplace_unique_key_args<objc_class * {__strong},std::piecewise_construct_t const&,std::tuple<objc_class * const {__strong}&>,std::tuple<>>(uint64_t *a1, unint64_t a2, id *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = a1[1];
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    unint64_t v11 = *(void ***)(*a1 + 8 * v3);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  long long v14 = a1 + 2;
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v8;
  i[2] = *a3;
  i[3] = 0;
  float v15 = (float)(unint64_t)(a1[3] + 1);
  float v16 = *((float *)a1 + 8);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    else {
      int8x8_t prime = (int8x8_t)v18;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v9 = a1[1];
    if (*(void *)&prime > v9) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v27 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v9 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (*(void *)&prime <= v27) {
        int8x8_t prime = (int8x8_t)v27;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float32x2_t v21 = operator new(8 * *(void *)&prime);
          float32x2_t v22 = (void *)*a1;
          *a1 = (uint64_t)v21;
          if (v22) {
            operator delete(v22);
          }
          uint64_t v23 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v23++) = 0;
          while (*(void *)&prime != v23);
          float32x2_t v24 = (void *)*v14;
          if (*v14)
          {
            unint64_t v25 = v24[1];
            uint8x8_t v26 = (uint8x8_t)vcnt_s8(prime);
            v26.i16[0] = vaddlv_u8(v26);
            if (v26.u32[0] > 1uLL)
            {
              if (v25 >= *(void *)&prime) {
                v25 %= *(void *)&prime;
              }
            }
            else
            {
              v25 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v25) = v14;
            float32x2_t v30 = (void *)*v24;
            if (*v24)
            {
              do
              {
                unint64_t v31 = v30[1];
                if (v26.u32[0] > 1uLL)
                {
                  if (v31 >= *(void *)&prime) {
                    v31 %= *(void *)&prime;
                  }
                }
                else
                {
                  v31 &= *(void *)&prime - 1;
                }
                if (v31 != v25)
                {
                  if (!*(void *)(*a1 + 8 * v31))
                  {
                    *(void *)(*a1 + 8 * v31) = v24;
                    goto LABEL_55;
                  }
                  *float32x2_t v24 = *v30;
                  *float32x2_t v30 = **(void **)(*a1 + 8 * v31);
                  **(void **)(*a1 + 8 * v31) = v30;
                  float32x2_t v30 = v24;
                }
                unint64_t v31 = v25;
LABEL_55:
                float32x2_t v24 = v30;
                float32x2_t v30 = (void *)*v30;
                unint64_t v25 = v31;
              }
              while (v30);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        float v36 = (void *)*a1;
        *a1 = 0;
        if (v36) {
          operator delete(v36);
        }
        unint64_t v9 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v32 = *a1;
  char v33 = *(void **)(*a1 + 8 * v3);
  if (v33)
  {
    *uint64_t i = *v33;
LABEL_72:
    *char v33 = i;
    goto LABEL_73;
  }
  *uint64_t i = *v14;
  *long long v14 = i;
  *(void *)(v32 + 8 * v3) = v14;
  if (*i)
  {
    unint64_t v34 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v34 >= v9) {
        v34 %= v9;
      }
    }
    else
    {
      v34 &= v9 - 1;
    }
    char v33 = (void *)(*a1 + 8 * v34);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return i;
}

void sub_1A3E8F0C0(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<objc_class * {__strong},objc_selector *>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<objc_class * {__strong},objc_selector *>,void *>>>::operator()[abi:ne180100](char a1, id *a2)
{
  if (a1)
  {
  }
  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void sub_1A3E8F1D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void sub_1A3E8F4F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8F618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E8F724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1A3E8F840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1A3E8F95C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1A3E8FA78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1A3E8FC0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1A3E8FD30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1A3E8FE4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1A3E8FF2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void sub_1A3E90000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void sub_1A3E90100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void sub_1A3E901A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E90328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9046C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1A3E90678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E90878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E909E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E90CE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E911F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_1A3E91448(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E91578(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t AltruisticBodyPoseKitLibraryCore()
{
  if (!AltruisticBodyPoseKitLibraryCore_frameworkLibrary) {
    AltruisticBodyPoseKitLibraryCore_frameworkLibrarint y = _sl_dlopen();
  }
  return AltruisticBodyPoseKitLibraryCore_frameworkLibrary;
}

Class __getABPKPoseEstimationPipelineClass_block_invoke(uint64_t a1)
{
  if (!AltruisticBodyPoseKitLibraryCore())
  {
    unint64_t v3 = (void *)abort_report_np();
    free(v3);
  }
  Class result = objc_getClass("ABPKPoseEstimationPipeline");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getABPKPoseEstimationPipelineClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    return (Class)__AltruisticBodyPoseKitLibraryCore_block_invoke();
  }
  return result;
}

uint64_t __AltruisticBodyPoseKitLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  AltruisticBodyPoseKitLibraryCore_frameworkLibrarint y = result;
  return result;
}

void sub_1A3E9186C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E91908(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E919A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E91A34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E91B70(_Unwind_Exception *a1)
{
  unint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3E91CC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E91D6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E91E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNFgBgE5MLInputElement;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3E91F0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9250C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,void *a29,uint64_t a30)
{
  if (__p) {
    operator delete(__p);
  }
  if (a29) {
    operator delete(a29);
  }
  char v33 = *(void **)(v31 - 168);
  if (v33)
  {
    *(void *)(v31 - 160) = v33;
    operator delete(v33);
  }

  _Unwind_Resume(a1);
}

void sub_1A3E92514()
{
}

void sub_1A3E9251C()
{
}

void sub_1A3E92528()
{
}

void sub_1A3E92534(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1A3E92548);
  }
  _Unwind_Resume(a1);
}

void sub_1A3E9255C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29)
{
  objc_end_catch();
  if (__p) {
    operator delete(__p);
  }
  if (a26) {
    operator delete(a26);
  }
  if (a29) {
    operator delete(a29);
  }
  uint64_t v31 = *(void **)(v29 - 168);
  if (v31)
  {
    *(void *)(v29 - 160) = v31;
    operator delete(v31);
  }

  _Unwind_Resume(a1);
}

void sub_1A3E92B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35)
{
  if (__p) {
    operator delete(__p);
  }
  if (a28) {
    operator delete(a28);
  }
  if (a31) {
    operator delete(a31);
  }
  if (a34) {
    operator delete(a34);
  }

  _Unwind_Resume(a1);
}

void sub_1A3E92F1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E93168(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E932B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E934C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3791(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3792(uint64_t a1)
{
}

void sub_1A3E93834(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E93B8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E93D70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E93EF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E94034(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E94104(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E94280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E94378(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E94594(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E94680(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E94B30(void *a1)
{
}

void sub_1A3E94B58()
{
}

void sub_1A3E94B6C()
{
  if (v0) {
    JUMPOUT(0x1A3E94B74);
  }
  JUMPOUT(0x1A3E94B78);
}

void sub_1A3E94E2C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A3E95370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9580C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3E9576CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3E95AEC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 96), 8);

  _Unwind_Resume(a1);
}

void sub_1A3E95D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3E96234(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3E961DCLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3E965C4(void *a1)
{
}

void sub_1A3E965F8()
{
}

void sub_1A3E96630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E96714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E96CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *__p)
{
  _Unwind_Resume(a1);
}

void *std::vector<BOOL>::vector(void *a1, unint64_t a2, unsigned __int8 *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<BOOL>::__vallocate[abi:ne180100](a1, a2);
    int v6 = *a3;
    unint64_t v7 = a1[1];
    unint64_t v8 = v7 + a2;
    a1[1] = v7 + a2;
    if (v7)
    {
      unint64_t v9 = v8 - 1;
      if (((v8 - 1) ^ (v7 - 1)) < 0x40)
      {
LABEL_10:
        uint64_t v13 = *a1 + 8 * (v7 >> 6);
        int v14 = v7 & 0x3F;
        if (v6) {
          std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(&v13, a2);
        }
        else {
          std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>((uint64_t)&v13, a2);
        }
        return a1;
      }
    }
    else
    {
      unint64_t v9 = v8 - 1;
    }
    unint64_t v10 = v9 >> 6;
    if (v8 >= 0x41) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = 0;
    }
    *(void *)(*a1 + 8 * v11) = 0;
    goto LABEL_10;
  }
  return a1;
}

void sub_1A3E970E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E971D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E972A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E973C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E97584(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9770C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E97780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNInstanceMaskObservation;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3E97944(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E97A3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E97B78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Geometry3D_mallocCart3D(uint64_t a1, int a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (a2 >= 1
    && (size_t v4 = 4 * a2, v5 = malloc_type_malloc(v4, 0x100004052888210uLL), (*(void *)a1 = v5) != 0)
    && (int v6 = malloc_type_malloc(v4, 0x100004052888210uLL), (*(void *)(a1 + 8) = v6) != 0)
    && (unint64_t v7 = malloc_type_malloc(v4, 0x100004052888210uLL), (*(void *)(a1 + 16) = v7) != 0))
  {
    *(_DWORD *)(a1 + 24) = a2;
  }
  else
  {
    Geometry3D_freeCart3D(a1);
  }
}

void Geometry3D_freeCart3D(uint64_t a1)
{
  if (a1)
  {
    free(*(void **)a1);
    *(void *)a1 = 0;
    free(*(void **)(a1 + 8));
    *(void *)(a1 + 8) = 0;
    free(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
  }
}

void sub_1A3E98AC4(_Unwind_Exception *a1)
{
  int v6 = *(void **)(v4 - 88);
  if (v6)
  {
    *(void *)(v4 - 80) = v6;
    operator delete(v6);
  }

  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageAnalyzer::getSceneRepresentation(vision::mod::ImageAnalyzer *this, uint64_t a2)
{
  uint64_t v4 = a2 + 824;
  int v10 = 1;
  if (*((unsigned char *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a2 + 824, 1u, &v10)+ 20))
  {
    int v10 = 1;
    unint64_t v5 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a2 + 784, 1u, &v10)+ 24;
    int v6 = this;
    int v7 = 0;
  }
  else
  {
    int v10 = 1024;
    if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v4, 0x400u, &v10)+ 20))
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = 8574;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
    int v10 = 1024;
    unint64_t v5 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a2 + 784, 0x400u, &v10)+ 24;
    int v6 = this;
    int v7 = 1;
  }
  return vision::mod::ImageAnalyzer_Tensor1D<float>::ImageAnalyzer_Tensor1D((uint64_t)v6, (long long *)v5, v7);
}

void vision::mod::ImageAnalyzer_Tensor1D<float>::getVectorFromTensor(void *a1, unint64_t *a2)
{
  std::vector<float>::vector(a1, *a2);
  if (*a2)
  {
    unint64_t v5 = 0;
    do
    {
      float v4 = vision::mod::ImageAnalyzer_Tensor1D<float>::operator[]((uint64_t)a2, v5, v4);
      *(float *)(*a1 + 4 * v5++) = v4;
    }
    while (v5 < *a2);
  }
}

void sub_1A3E98C70(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176))
  {
    int v2 = *(_DWORD *)(a1 + 168);
    switch(v2)
    {
      case 65552:
        if (*(void *)(a1 + 8)) {
          goto LABEL_10;
        }
        goto LABEL_11;
      case 262152:
        if (*(void *)(a1 + 8)) {
LABEL_10:
        }
          MEMORY[0x1A62562A0]();
LABEL_11:
        *(void *)(a1 + 8) = 0;
        return a1;
      case 65568:
        if (*(void *)(a1 + 8)) {
          goto LABEL_10;
        }
        goto LABEL_11;
    }
  }
  return a1;
}

float vision::mod::ImageAnalyzer_Tensor1D<float>::operator[](uint64_t a1, unint64_t a2, float a3)
{
  if (*(void *)a1 <= a2)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v6 = 8556;
    goto LABEL_13;
  }
  int v3 = *(_DWORD *)(a1 + 168);
  if (v3 > 131103)
  {
    if (v3 == 131104)
    {
      return (float)*(int *)(*(void *)(a1 + 8) + 4 * a2);
    }
    else
    {
      if (v3 != 262152)
      {
LABEL_14:
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v6 = 8563;
LABEL_13:
        void *exception = v6;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
      LOBYTE(a3) = *(unsigned char *)(*(void *)(a1 + 8) + a2);
      return (float)LODWORD(a3);
    }
  }
  else
  {
    if (v3 != 65568)
    {
      if (v3 == 131080) {
        return (float)*(char *)(*(void *)(a1 + 8) + a2);
      }
      goto LABEL_14;
    }
    return *(float *)(*(void *)(a1 + 8) + 4 * a2);
  }
}

void *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  int v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((unsigned char *)v10 + 20) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A3E99010(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = (char *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
  int v10 = (char *)operator new(0xC0uLL);
  *(void *)int v10 = 0;
  *((void *)v10 + 1) = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 56) = 0u;
  *(_OWORD *)(v10 + 72) = 0u;
  *(_OWORD *)(v10 + 88) = 0u;
  *(_OWORD *)(v10 + 104) = 0u;
  *(_OWORD *)(v10 + 120) = 0u;
  *(_OWORD *)(v10 + 136) = 0u;
  *(_OWORD *)(v10 + 152) = 0u;
  *(_OWORD *)(v10 + 168) = 0u;
  *((void *)v10 + 23) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *(void *)int v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  *(void *)int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*(void *)v10)
  {
    unint64_t v20 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A3E99254(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageAnalyzer_Tensor1D<float>::ImageAnalyzer_Tensor1D(uint64_t result, long long *a2, int a3)
{
  *(void *)uint64_t result = 0;
  *(unsigned char *)(result + 176) = 0;
  if (!*(void *)a2) {
    goto LABEL_28;
  }
  if (*((void *)a2 + 13) > 1uLL || *((void *)a2 + 14) >= 2uLL) {
    goto LABEL_28;
  }
  unint64_t v4 = *((void *)a2 + 10);
  int v5 = v4 > 1;
  if (v4 <= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = *((void *)a2 + 10);
  }
  *(void *)uint64_t result = v6;
  unint64_t v7 = *((void *)a2 + 11);
  if (v7 >= 2)
  {
    v6 *= v7;
    *(void *)uint64_t result = v6;
    if (v4 <= 1) {
      int v5 = 1;
    }
    else {
      int v5 = 2;
    }
  }
  unint64_t v8 = *((void *)a2 + 12);
  if (v8 >= 2)
  {
    v6 *= v8;
    *(void *)uint64_t result = v6;
    ++v5;
  }
  if (!a3)
  {
    if (v5 == 1) {
      goto LABEL_19;
    }
    goto LABEL_28;
  }
  if (*((void *)a2 + 18) != v6)
  {
    if (*((void *)a2 + 13) <= 1uLL && *((void *)a2 + 14) < 2uLL)
    {
      int v17 = *((_DWORD *)a2 + 40);
      switch(v17)
      {
        case 65552:
          operator new[]();
        case 262152:
          operator new[]();
        case 65568:
          operator new[]();
      }
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v19 = 8563;
LABEL_29:
      void *exception = v19;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
LABEL_28:
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v19 = 8572;
    goto LABEL_29;
  }
  *(unsigned char *)(result + 176) = 0;
LABEL_19:
  long long v9 = *a2;
  long long v10 = a2[1];
  *(_OWORD *)(result + 40) = a2[2];
  *(_OWORD *)(result + 24) = v10;
  *(_OWORD *)(result + 8) = v9;
  long long v11 = a2[3];
  long long v12 = a2[4];
  long long v13 = a2[5];
  *(_OWORD *)(result + 104) = a2[6];
  *(_OWORD *)(result + 88) = v13;
  *(_OWORD *)(result + 72) = v12;
  *(_OWORD *)(result + 56) = v11;
  long long v14 = a2[7];
  long long v15 = a2[8];
  long long v16 = a2[9];
  *(void *)(result + 168) = *((void *)a2 + 20);
  *(_OWORD *)(result + 152) = v16;
  *(_OWORD *)(result + 136) = v15;
  *(_OWORD *)(result + 120) = v14;
  return result;
}

void sub_1A3E998E4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 32))(v1);
  _Unwind_Resume(a1);
}

void vision::mod::EspressoUint8ElemPtr::~EspressoUint8ElemPtr(vision::mod::EspressoUint8ElemPtr *this)
{
}

void vision::mod::EspressoUint8ElemPtr::copy(vision::mod::EspressoUint8ElemPtr *this)
{
}

uint64_t vision::mod::EspressoUint8ElemPtr::increment(uint64_t this, uint64_t a2)
{
  *(void *)(this + 8) += a2;
  return this;
}

unsigned char **vision::mod::EspressoUint8ElemPtr::assign(uint64_t a1, const void **a2)
{
  if (!*a2
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 8573;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  **(unsigned char **)(a1 + 8) = *result[1];
  return result;
}

void vision::mod::EspressoUint16ElemPtr::~EspressoUint16ElemPtr(vision::mod::EspressoUint16ElemPtr *this)
{
}

void vision::mod::EspressoUint16ElemPtr::copy(vision::mod::EspressoUint16ElemPtr *this)
{
}

uint64_t vision::mod::EspressoUint16ElemPtr::increment(uint64_t this, uint64_t a2)
{
  *(void *)(this + 8) += 2 * a2;
  return this;
}

_WORD **vision::mod::EspressoUint16ElemPtr::assign(uint64_t a1, const void **a2)
{
  if (!*a2
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 8573;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  **(_WORD **)(a1 + 8) = *result[1];
  return result;
}

void vision::mod::EspressoFloatElemPtr::~EspressoFloatElemPtr(vision::mod::EspressoFloatElemPtr *this)
{
}

void vision::mod::EspressoFloatElemPtr::copy(vision::mod::EspressoFloatElemPtr *this)
{
}

uint64_t vision::mod::EspressoFloatElemPtr::increment(uint64_t this, uint64_t a2)
{
  *(void *)(this + 8) += 4 * a2;
  return this;
}

float vision::mod::EspressoFloatElemPtr::assign(uint64_t a1, const void **a2)
{
  if (!*a2
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 8573;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  float result = *v3[1];
  **(float **)(a1 + 8) = result;
  return result;
}

void sub_1A3E99EC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ma::GaborFilters::Destroy(ma::GaborFilters *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    MEMORY[0x1A62562A0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    MEMORY[0x1A62562A0](v3, 0x1000C8052888210);
  }
  if (*(void *)this) {
    MEMORY[0x1A62562A0](*(void *)this, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 8);
  if (v4) {
    MEMORY[0x1A62562A0](v4, 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 9);
  if (v5) {
    MEMORY[0x1A62562A0](v5, 0x1000C8052888210);
  }
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    MEMORY[0x1A62562A0](v6, 0x1000C8052888210);
  }
  *((void *)this + 12) = 0;
  uint64_t v7 = *((void *)this + 19);
  if (v7) {
    MEMORY[0x1A62562A0](v7, 0x1000C8052888210);
  }
  *((void *)this + 19) = 0;
  uint64_t v8 = *((void *)this + 18);
  if (v8) {
    MEMORY[0x1A62562A0](v8, 0x1000C80BDFB0063);
  }
  *((void *)this + 18) = 0;
  uint64_t v9 = *((void *)this + 13);
  if (v9) {
    MEMORY[0x1A62562A0](v9, 0x1000C8052888210);
  }
  *((void *)this + 13) = 0;
  uint64_t v10 = *((void *)this + 14);
  if (v10) {
    MEMORY[0x1A62562A0](v10, 0x1000C8052888210);
  }
  *((void *)this + 14) = 0;
  uint64_t v11 = *((void *)this + 15);
  if (v11) {
    MEMORY[0x1A62562A0](v11, 0x1000C8052888210);
  }
  *((void *)this + 15) = 0;
  uint64_t v12 = *((void *)this + 17);
  if (v12) {
    MEMORY[0x1A62562A0](v12, 0x1000C8052888210);
  }
  *((void *)this + 17) = 0;
  vDSP_destroy_fftsetup(*((FFTSetup *)this + 10));
  long long v13 = *((void *)this + 21);
  if (v13)
  {
    dispatch_release(v13);
    *((void *)this + 21) = 0;
  }
  long long v14 = *((void *)this + 22);
  if (v14)
  {
    dispatch_release(v14);
    *((void *)this + 22) = 0;
  }
  long long v15 = *((void *)this + 23);
  if (v15)
  {
    dispatch_release(v15);
    *((void *)this + 23) = 0;
  }
  long long v16 = *((void *)this + 24);
  if (v16)
  {
    dispatch_release(v16);
    *((void *)this + 24) = 0;
  }
}

void ma::GaborFilters::DispatchHelperCreateGabor(ma::GaborFilters *this, void *a2)
{
  int v47 = *(_DWORD *)(*(void *)this + 132);
  if (v47 >= 1)
  {
    uint64_t v2 = this;
    int v3 = 0;
    int v43 = *((_DWORD *)this + 3);
    __asm { FMOV            V0.4S, #-1.0 }
    float32x4_t v42 = _Q0;
    do
    {
      uint64_t v8 = *(void *)v2;
      uint64_t v9 = *(float32x4_t **)(*(void *)v2 + 120);
      int v10 = *(_DWORD *)(*(void *)v2 + 132);
      uint64_t v12 = (const int *)(*(void *)v2 + 88);
      uint64_t v11 = *v12;
      int v13 = *(_DWORD *)(*(void *)v2 + 28) * *(_DWORD *)(*(void *)v2 + 24);
      if (v13 < 0) {
        size_t v14 = -1;
      }
      else {
        size_t v14 = 4 * v13;
      }
      long long v15 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
      long long v16 = (float32x4_t *)operator new[](v14, MEMORY[0x1E4FBA2D0]);
      if ((int)v11 < 0) {
        size_t v17 = -1;
      }
      else {
        size_t v17 = 4 * v11;
      }
      uint64_t v18 = (const float *)operator new[](v17, v15);
      uint64_t v19 = v18;
      if (v16) {
        _ZF = v18 == 0;
      }
      else {
        _ZF = 1;
      }
      char v21 = !_ZF;
      if (!_ZF)
      {
        char v46 = v21;
        uint64_t v22 = v11;
        int v45 = v3 + v10 * v43;
        int v23 = 4 * v45;
        memcpy(v16, *(const void **)(v8 + 112), 4 * v11);
        uint64_t v24 = *(void *)(v8 + 96);
        if ((int)v11 >= 1)
        {
          float v25 = *(float *)(v24 + ((4 * v23) | 0xC));
          uint8x8_t v26 = (float *)v16;
          do
          {
            float v27 = v25 + *v26;
            *uint8x8_t v26 = v27;
            double v28 = v27;
            double v29 = -6.28318531;
            if (v28 > 3.14159265 || (double v29 = 6.28318531, v28 < -3.14159265))
            {
              float v30 = v29 + v28;
              *uint8x8_t v26 = v30;
            }
            ++v26;
            --v22;
          }
          while (v22);
        }
        if (*(int *)(v8 + 88) >= 1)
        {
          uint64_t v31 = 0;
          double v32 = *(float *)(v24 + ((16 * v45) | 8));
          float v33 = (v32 + v32) * 3.14159265;
          float v34 = *(float *)(v24 + 4 * v23) * -10.0;
          float v35 = (float)(1.0 / (float)*(int *)(v8 + 24)) / *(float *)(v24 + ((4 * v23) | 4));
          float v36 = v16;
          float32x2_t v37 = (float32x4_t *)v19;
          do
          {
            float32x4_t v38 = *v9++;
            float32x4_t v39 = vaddq_f32(vmulq_n_f32(v38, v35), v42);
            float32x4_t v40 = *v36++;
            *v37++ = vsubq_f32(vmulq_f32(v39, vmulq_n_f32(v39, v34)), vmulq_n_f32(vmulq_f32(v40, v40), v33));
            v31 += 4;
          }
          while (v31 < *v12);
        }
        vvexpf((float *)(*(void *)(v8 + 152) + 4 * v45 * (int)v11), v19, v12);
        uint64_t v2 = this;
        char v21 = v46;
      }
      float32x2_t v41 = *(NSObject **)(v8 + 184);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = ___ZN2ma12GaborFilters29CreateOneGaborFilterFrequencyEii_block_invoke;
      block[3] = &__block_descriptor_tmp_5_4165;
      block[4] = v8;
      char v49 = v21;
      dispatch_sync(v41, block);
      if (v16) {
        MEMORY[0x1A62562A0](v16, 0x1000C8052888210);
      }
      if (v19) {
        MEMORY[0x1A62562A0](v19, 0x1000C8052888210);
      }
      ++v3;
    }
    while (v3 != v47);
  }
}

uint64_t ___ZN2ma12GaborFilters29CreateOneGaborFilterFrequencyEii_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  char v2 = *(unsigned char *)(v1 + 160);
  if (v2) {
    char v2 = *(unsigned char *)(result + 40) != 0;
  }
  *(unsigned char *)(v1 + 160) = v2;
  return result;
}

void ma::GaborFilters::DispatchHelperDescriptor(ma::GaborFilters *this, void *a2)
{
  char v2 = this;
  uint64_t v3 = *(int *)(*(void *)this + 88);
  fftsetup = vDSP_create_fftsetup(*(unsigned int *)(*(void *)this + 32), 0);
  int v36 = v3;
  if ((int)v3 < 0) {
    size_t v5 = -1;
  }
  else {
    size_t v5 = 4 * v3;
  }
  uint64_t v6 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
  uint64_t v7 = operator new[](v5, MEMORY[0x1E4FBA2D0]);
  uint64_t v8 = operator new[](v5, v6);
  uint64_t v9 = (float *)operator new[](v5, v6);
  int v10 = (float *)operator new[](v5, v6);
  int v11 = *((_DWORD *)v2 + 3);
  uint64_t v12 = (float *)operator new[](v5, v6);
  if (v12) {
    BOOL v13 = v7 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  BOOL v16 = v13 || v8 == 0 || v9 == 0 || v10 == 0;
  char v17 = !v16;
  uint64_t v18 = *(void *)v2;
  if (!v16)
  {
    char v35 = v17;
    memcpy(v8, *(const void **)(v18 + 48), 4 * v36);
    memcpy(v7, *(const void **)(v18 + 56), 4 * v36);
    __B.realp = (float *)v8;
    __B.imagp = (float *)v7;
    __C.realp = v9;
    __C.imagp = v10;
    int v19 = *(_DWORD *)(v18 + 132);
    if (v19 >= 1)
    {
      uint64_t v31 = v10;
      double v32 = v2;
      float v33 = v8;
      float v34 = v9;
      int v20 = 0;
      vDSP_Length v21 = *(int *)(v18 + 88);
      unsigned int v22 = v19 * v11;
      vDSP_Length v24 = *(int *)(v18 + 36);
      vDSP_Length v23 = *(int *)(v18 + 40);
      do
      {
        float v25 = *(float **)(v18 + 8);
        __A.realp = (float *)(*(void *)(v18 + 152) + 4 * (v20 + v19 * v11) * (int)v21);
        __A.imagp = v25;
        vDSP_zvmul(&__A, 1, &__B, 1, &__C, 1, v21, 1);
        vDSP_fft2d_zip(fftsetup, &__C, 1, 0, v24, v23, -1);
        vDSP_zvmags(&__C, 1, v12, 1, v21);
        if ((int)v21 >= 4)
        {
          unsigned int v26 = v21 >> 2;
          float v27 = (float32x4_t *)v12;
          do
          {
            float32x4_t v28 = vrsqrteq_f32(*v27);
            float32x4_t v29 = vmulq_f32(v28, vrsqrtsq_f32(vmulq_f32(v28, v28), *v27));
            *float v27 = vmulq_n_f32(vmulq_f32(*v27, vmulq_f32(vrsqrtsq_f32(vmulq_f32(v29, v29), *v27), v29)), 1.0 / (float)(int)v21);
            ++v27;
            --v26;
          }
          while (v26);
        }
        vDSP_meanv(v12, 1, (float *)(*(void *)(v18 + 136) + 4 * v22++), v21);
        ++v20;
        int v19 = *(_DWORD *)(v18 + 132);
      }
      while (v20 < v19);
      char v2 = v32;
      uint64_t v18 = *(void *)v32;
      uint64_t v8 = v33;
      uint64_t v9 = v34;
      int v10 = v31;
    }
    char v17 = v35;
  }
  float v30 = *(NSObject **)(v18 + 192);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2ma12GaborFilters24DispatchHelperDescriptorEPv_block_invoke;
  block[3] = &__block_descriptor_tmp_4167;
  block[4] = v2;
  char v38 = v17;
  dispatch_sync(v30, block);
  vDSP_destroy_fftsetup(fftsetup);
  if (v12) {
    MEMORY[0x1A62562A0](v12, 0x1000C8052888210);
  }
  if (v7) {
    MEMORY[0x1A62562A0](v7, 0x1000C8052888210);
  }
  if (v8) {
    MEMORY[0x1A62562A0](v8, 0x1000C8052888210);
  }
  if (v10) {
    MEMORY[0x1A62562A0](v10, 0x1000C8052888210);
  }
  if (v9) {
    MEMORY[0x1A62562A0](v9, 0x1000C8052888210);
  }
}

uint64_t ___ZN2ma12GaborFilters24DispatchHelperDescriptorEPv_block_invoke(uint64_t result)
{
  uint64_t v1 = **(void **)(result + 32);
  char v2 = *(unsigned char *)(v1 + 161);
  if (v2) {
    char v2 = *(unsigned char *)(result + 40) != 0;
  }
  *(unsigned char *)(v1 + 161) = v2;
  return result;
}

void sub_1A3E9A95C(void *a1)
{
}

void sub_1A3E9A968(_Unwind_Exception *a1)
{
}

void sub_1A3E9AB68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9ACBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9AF94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *a19, uint64_t a20)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  MEMORY[0x1A62562C0](v20, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

void *std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    float result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      float result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3E9B0A8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3E9B1BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9B354(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(void **)(v1 + 8));
  MEMORY[0x1A62562C0](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

void sub_1A3E9BD2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, int a18, int a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42)
{
  if (__p) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a38);
  if (a28) {
    operator delete(a28);
  }
  if (a31) {
    operator delete(a31);
  }
  if (v42) {
    operator delete(v42);
  }
  if (a34) {
    operator delete(a34);
  }
  if (a2 == 1)
  {
    if ((*(void *)__cxa_begin_catch(a1) | 0x10) == 0xB7C)
    {
      [a17 setBlinkScore:0.0];
      int v45 = [a17 uuid];
      VNRecordBlinkDetectionFailureWarning(a16, v45);

      __cxa_end_catch();
      JUMPOUT(0x1A3E9BCA4);
    }
    __cxa_rethrow();
  }

  _Unwind_Resume(a1);
}

void sub_1A3E9BEB0()
{
  __cxa_end_catch();
  JUMPOUT(0x1A3E9BD44);
}

uint64_t **std::__tree<std::__value_type<vision::mod::_blinkType,float>,std::__map_value_compare<vision::mod::_blinkType,std::__value_type<vision::mod::_blinkType,float>,std::less<vision::mod::_blinkType>,true>,std::allocator<std::__value_type<vision::mod::_blinkType,float>>>::__emplace_unique_key_args<vision::mod::_blinkType,std::piecewise_construct_t const&,std::tuple<vision::mod::_blinkType&&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  size_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        size_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      size_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((_DWORD *)v7 + 8) = 0;
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    int v10 = (uint64_t *)**a1;
    int v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      int v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_1A3E9C02C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9C390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3E9C358);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3E9C7F4()
{
  __cxa_end_catch();
  JUMPOUT(0x1A3E9C808);
}

void sub_1A3E9CA74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  int v11 = v10;

  a9.super_class = (Class)VNFaceLandmarkDetector;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3E9CC48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9CE70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>>>::~__hash_table(uint64_t a1)
{
  char v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (std::__shared_weak_count *)v2[4];
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v4);
      }
      operator delete(v2);
      char v2 = v3;
    }
    while (v3);
  }
  size_t v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void cvml::util::binserialized_contents::init_model_values(uint64_t a1, uint64_t a2, const char *a3, unint64_t *a4)
{
  if (a3)
  {
    std::string::basic_string[abi:ne180100]<0>(&v52, "::");
    std::string::size_type v7 = strlen(a3);
    int v8 = std::string::insert((std::string *)&v52, 0, a3, v7);
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    int64_t v58 = v8->__r_.__value_.__r.__words[2];
    long long v57 = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if (SBYTE7(v53) < 0) {
      operator delete((void *)v52);
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&v57, "");
  }
  int v50 = a3;
  if (*a4)
  {
    unint64_t v10 = 0;
    do
    {
      int v11 = *(const void **)(a4[1] + 8 * v10);
      if (v58 >= 0) {
        size_t v12 = HIBYTE(v58);
      }
      else {
        size_t v12 = *((void *)&v57 + 1);
      }
      size_t v13 = strlen(*(const char **)(a4[1] + 8 * v10));
      std::string::basic_string[abi:ne180100]((uint64_t)&__p, v12 + v13);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if (v12)
      {
        if (v58 >= 0) {
          long long v15 = &v57;
        }
        else {
          long long v15 = (long long *)v57;
        }
        memmove(p_p, v15, v12);
      }
      BOOL v16 = (char *)p_p + v12;
      if (v13) {
        memmove(v16, v11, v13);
      }
      v16[v13] = 0;
      char v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v17 = &__p;
      }
      std::string::value_type v18 = v17->__r_.__value_.__s.__data_[0];
      if (v17->__r_.__value_.__s.__data_[0])
      {
        int v19 = &v17->__r_.__value_.__s.__data_[1];
        unint64_t v20 = 5381;
        do
        {
          unint64_t v20 = 33 * v20 + v18;
          int v21 = *v19++;
          std::string::value_type v18 = v21;
        }
        while (v21);
      }
      else
      {
        unint64_t v20 = 5381;
      }
      unsigned int v22 = std::__hash_table<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>>>::find<unsigned long long>(*(void *)a2, *(void *)(a2 + 8), v20);
      if (v22)
      {
        uint64_t v24 = v22[3];
        vDSP_Length v23 = (std::__shared_weak_count *)v22[4];
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *(void *)&long long v52 = v24;
        *((void *)&v52 + 1) = v23;
        long long v25 = *(_OWORD *)(v22 + 7);
        long long v53 = *(_OWORD *)(v22 + 5);
        long long v54 = v25;
        uint64_t v55 = v22[9];
        if (WORD4(v53) - 1 < 2) {
          goto LABEL_33;
        }
        if (WORD4(v53) != 3)
        {
          syslog(3, "Error %s when executing %s in file %s:%d\n", "Model file info populated incorrectly", "void cvml::util::binserialized_contents::init_model_values(const binserialized_table_of_contents &, const char *, const vision::mod::BinSerializedModelFileInfo &)", "/Library/Caches/com.apple.xbs/Sources/Vision/VisionKitFramework/VN/algorithm_util/binserialized_mapped_file_contents.h", 209);
          __assert_rtn("syslog_assert_failed", "common_defines.h", 24, "false");
        }
        if ((v24 & 3) != 0) {
LABEL_33:
        }
          operator new[]();
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        vision::mod::ModelValues::setModelValues(a1, (long long *)&__p, v24, v23, v55);
        if (v23)
        {
          std::__shared_weak_count::__release_shared[abi:nn180100](v23);
          std::__shared_weak_count::__release_shared[abi:nn180100](v23);
        }
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      ++v10;
    }
    while (v10 < *a4);
  }
  if (a4[2])
  {
    unint64_t v26 = 0;
    do
    {
      float v27 = *(const void **)(a4[3] + 8 * v26);
      if (v58 >= 0) {
        size_t v28 = HIBYTE(v58);
      }
      else {
        size_t v28 = *((void *)&v57 + 1);
      }
      size_t v29 = strlen(*(const char **)(a4[3] + 8 * v26));
      std::string::basic_string[abi:ne180100]((uint64_t)&v52, v28 + v29);
      if ((SBYTE7(v53) & 0x80u) == 0) {
        float v30 = &v52;
      }
      else {
        float v30 = (long long *)v52;
      }
      if (v28)
      {
        if (v58 >= 0) {
          uint64_t v31 = &v57;
        }
        else {
          uint64_t v31 = (long long *)v57;
        }
        memmove(v30, v31, v28);
      }
      double v32 = (char *)v30 + v28;
      if (v29) {
        memmove(v32, v27, v29);
      }
      v32[v29] = 0;
      float v33 = (long long *)v52;
      if ((SBYTE7(v53) & 0x80u) == 0) {
        float v33 = &v52;
      }
      char v34 = *(unsigned char *)v33;
      if (*(unsigned char *)v33)
      {
        char v35 = (unsigned __int8 *)v33 + 1;
        unint64_t v36 = 5381;
        do
        {
          unint64_t v36 = 33 * v36 + v34;
          int v37 = *v35++;
          char v34 = v37;
        }
        while (v37);
      }
      else
      {
        unint64_t v36 = 5381;
      }
      char v38 = std::__hash_table<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>>>::find<unsigned long long>(*(void *)a2, *(void *)(a2 + 8), v36);
      if (v38)
      {
        uint64_t v39 = v38[3];
        float32x4_t v40 = (std::__shared_weak_count *)v38[4];
        if (v40) {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (*((_WORD *)v38 + 24) != 9)
        {
          syslog(3, "Error %s when executing %s in file %s:%d\n", "Model file info populated incorrectly", "void cvml::util::binserialized_contents::init_model_values(const binserialized_table_of_contents &, const char *, const vision::mod::BinSerializedModelFileInfo &)", "/Library/Caches/com.apple.xbs/Sources/Vision/VisionKitFramework/VN/algorithm_util/binserialized_mapped_file_contents.h", 226);
          __assert_rtn("syslog_assert_failed", "common_defines.h", 24, "false");
        }
        vision::mod::ModelValues::setModelValues(a1, &v52, v39, v40, v38[9]);
        if (v40) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v40);
        }
      }
      if (SBYTE7(v53) < 0) {
        operator delete((void *)v52);
      }
      ++v26;
    }
    while (v26 < a4[2]);
  }
  if (a4[4])
  {
    uint64_t v41 = 0;
    unint64_t v42 = 0;
    do
    {
      unint64_t v43 = a4[5];
      uint64_t v44 = *(void *)(v43 + 8 * v42);
      if (v50)
      {
        if (v44)
        {
          std::string::basic_string[abi:ne180100]<0>(&__p, *(char **)(v43 + 8 * v42));
          if (v58 >= 0) {
            int v45 = (const std::string::value_type *)&v57;
          }
          else {
            int v45 = (const std::string::value_type *)v57;
          }
          if (v58 >= 0) {
            std::string::size_type v46 = HIBYTE(v58);
          }
          else {
            std::string::size_type v46 = *((void *)&v57 + 1);
          }
          int v47 = std::string::insert(&__p, 0, v45, v46);
          long long v48 = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
          *(void *)&long long v53 = *((void *)&v47->__r_.__value_.__l + 2);
          long long v52 = v48;
          v47->__r_.__value_.__l.__size_ = 0;
          v47->__r_.__value_.__r.__words[2] = 0;
          v47->__r_.__value_.__r.__words[0] = 0;
          if ((SBYTE7(v53) & 0x80u) == 0) {
            char v49 = &v52;
          }
          else {
            char v49 = (long long *)v52;
          }
          cvml::util::binserialized_contents::init_model_values(a1, a2, v49, a4[6] + v41);
          if (SBYTE7(v53) < 0) {
            operator delete((void *)v52);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          cvml::util::binserialized_contents::init_model_values(a1, a2, v50, a4[6] + v41);
        }
      }
      else
      {
        cvml::util::binserialized_contents::init_model_values(a1, a2, v44, a4[6] + v41);
      }
      ++v42;
      v41 += 56;
    }
    while (v42 < a4[4]);
  }
  if (SHIBYTE(v58) < 0) {
    operator delete((void *)v57);
  }
}

void sub_1A3E9D540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3E9D554(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (v27)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v27);
    std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  }
  if (a27 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v28 - 89) < 0) {
    JUMPOUT(0x1A3E9D63CLL);
  }
  JUMPOUT(0x1A3E9D640);
}

void sub_1A3E9D564(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

void sub_1A3E9D594(void *a1)
{
  __cxa_begin_catch(a1);
  MEMORY[0x1A62562A0](v1, 0x1000C8052888210);
  __cxa_rethrow();
}

void sub_1A3E9D5B8()
{
}

void sub_1A3E9D5CC()
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v0);
  JUMPOUT(0x1A3E9D5DCLL);
}

void sub_1A3E9D600(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  }
  if (a20 < 0) {
    JUMPOUT(0x1A3E9D620);
  }
  if (*(char *)(v21 - 89) < 0) {
    JUMPOUT(0x1A3E9D63CLL);
  }
  JUMPOUT(0x1A3E9D640);
}

void std::__shared_ptr_emplace<vision::mod::LandmarkAttributes>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<vision::mod::LandmarkAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753620;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::LandmarkAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753620;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>>>::find<unsigned long long>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  size_t v5 = *(void **)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  float result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a3)
      {
        if (result[2] == a3) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= a2) {
            v7 %= a2;
          }
        }
        else
        {
          v7 &= a2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      float result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void vision::mod::ModelValues::setModelValues(uint64_t a1, long long *a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t a5)
{
  int v6 = 2;
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = a3;
  int v8 = a4;
  uint64_t v9 = a5;
  std::pair<std::string const,vision::mod::ModelValues::ValueInfo>::pair[abi:ne180100]<std::string const&,vision::mod::ModelValues::ValueInfo,0>(&__p, a2, (uint64_t)&v6);
  std::__hash_table<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,vision::mod::ModelValues::ValueInfo>>(a1, (unsigned __int8 *)&__p, (uint64_t)&__p);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
}

{
  int v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::string __p;
  std::__shared_weak_count *v11;

  int v6 = 1;
  uint64_t v7 = a3;
  int v8 = a4;
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = a5;
  std::pair<std::string const,vision::mod::ModelValues::ValueInfo>::pair[abi:ne180100]<std::string const&,vision::mod::ModelValues::ValueInfo,0>(&__p, a2, (uint64_t)&v6);
  std::__hash_table<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,vision::mod::ModelValues::ValueInfo>>(a1, (unsigned __int8 *)&__p, (uint64_t)&__p);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
}

void sub_1A3E9D7FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::pair<std::string const,vision::mod::ModelValues::ValueInfo>::~pair((uint64_t)va);
  if (a5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a5);
  }
  _Unwind_Resume(a1);
}

void sub_1A3E9D8B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::pair<std::string const,vision::mod::ModelValues::ValueInfo>::~pair((uint64_t)va);
  if (a5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a5);
  }
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,vision::mod::ModelValues::ValueInfo>::pair[abi:ne180100]<std::string const&,vision::mod::ModelValues::ValueInfo,0>(std::string *this, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  LODWORD(this[1].__r_.__value_.__l.__data_) = *(_DWORD *)a3;
  *(_OWORD *)&this[1].__r_.__value_.__r.__words[1] = *(_OWORD *)(a3 + 8);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  this[2].__r_.__value_.__r.__words[0] = *(void *)(a3 + 24);
  return this;
}

void std::__hash_table<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,vision::mod::ModelValues::ValueInfo>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    size_t v12 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v8)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](i + 16, a2)) {
            return;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  long long v15 = (void *)(a1 + 16);
  BOOL v16 = (char *)operator new(0x48uLL);
  v39[0] = v16;
  v39[1] = a1 + 16;
  char v40 = 0;
  *(void *)BOOL v16 = 0;
  *((void *)v16 + 1) = v8;
  char v17 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v17, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v17->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v16 + 4) = *(void *)(a3 + 16);
  }
  *((_DWORD *)v16 + 10) = *(_DWORD *)(a3 + 24);
  *((_OWORD *)v16 + 3) = *(_OWORD *)(a3 + 32);
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 40) = 0;
  *((void *)v16 + 8) = *(void *)(a3 + 48);
  char v40 = 1;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    BOOL v20 = 1;
    if (v9 >= 3) {
      BOOL v20 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v9);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      int8x8_t prime = (int8x8_t)v22;
    }
    else {
      int8x8_t prime = (int8x8_t)v21;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v9 = *(void *)(a1 + 8);
    if (*(void *)&prime > v9) {
      goto LABEL_33;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v30 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v9 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (*(void *)&prime <= v30) {
        int8x8_t prime = (int8x8_t)v30;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *(void *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v24 = operator new(8 * *(void *)&prime);
          long long v25 = *(void **)a1;
          *(void *)a1 = v24;
          if (v25) {
            operator delete(v25);
          }
          uint64_t v26 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v26++) = 0;
          while (*(void *)&prime != v26);
          float v27 = (void *)*v15;
          if (*v15)
          {
            unint64_t v28 = v27[1];
            uint8x8_t v29 = (uint8x8_t)vcnt_s8(prime);
            v29.i16[0] = vaddlv_u8(v29);
            if (v29.u32[0] > 1uLL)
            {
              if (v28 >= *(void *)&prime) {
                v28 %= *(void *)&prime;
              }
            }
            else
            {
              v28 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v28) = v15;
            float v33 = (void *)*v27;
            if (*v27)
            {
              do
              {
                unint64_t v34 = v33[1];
                if (v29.u32[0] > 1uLL)
                {
                  if (v34 >= *(void *)&prime) {
                    v34 %= *(void *)&prime;
                  }
                }
                else
                {
                  v34 &= *(void *)&prime - 1;
                }
                if (v34 != v28)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v34))
                  {
                    *(void *)(*(void *)a1 + 8 * v34) = v27;
                    goto LABEL_58;
                  }
                  *float v27 = *v33;
                  *float v33 = **(void **)(*(void *)a1 + 8 * v34);
                  **(void **)(*(void *)a1 + 8 * v34) = v33;
                  float v33 = v27;
                }
                unint64_t v34 = v28;
LABEL_58:
                float v27 = v33;
                float v33 = (void *)*v33;
                unint64_t v28 = v34;
              }
              while (v33);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_62;
        }
        char v38 = *(void **)a1;
        *(void *)a1 = 0;
        if (v38) {
          operator delete(v38);
        }
        unint64_t v9 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_62:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  char v35 = *(void **)(*(void *)a1 + 8 * v3);
  uint64_t v36 = v39[0];
  if (v35)
  {
    *(void *)v39[0] = *v35;
LABEL_75:
    *char v35 = v36;
    goto LABEL_76;
  }
  *(void *)v39[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v36;
  *(void *)(*(void *)a1 + 8 * v3) = v15;
  if (*(void *)v36)
  {
    unint64_t v37 = *(void *)(*(void *)v36 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v37 >= v9) {
        v37 %= v9;
      }
    }
    else
    {
      v37 &= v9 - 1;
    }
    char v35 = (void *)(*(void *)a1 + 8 * v37);
    goto LABEL_75;
  }
LABEL_76:
  v39[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)v39);
}

void sub_1A3E9DD9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string const,vision::mod::ModelValues::ValueInfo>::~pair(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,vision::mod::ModelValues::ValueInfo>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    unint64_t v3 = (std::__shared_weak_count *)__p[4];
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t std::__shared_ptr_pointer<unsigned char const*,cvml::util::binserialized_table_of_contents::blob_info::blob_info(unsigned char const*,_BinSerializer_blobHeader_ const&)::{lambda(unsigned char const*)#1},std::allocator<unsigned char const>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"ZN4cvml4util31binserialized_table_of_contents9blob_infoC1EPKhRK26_BinSerializer_blobHeader_EUlS4_E_"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::__shared_ptr_pointer<unsigned char const*,cvml::util::binserialized_table_of_contents::blob_info::blob_info(unsigned char const*,_BinSerializer_blobHeader_ const&)::{lambda(unsigned char const*)#1},std::allocator<unsigned char const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A3E9DFE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9E0B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9E42C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9E508(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9E750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9E8C0(_Unwind_Exception *a1)
{
  if (v3) {

  }
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4428(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4429(uint64_t a1)
{
}

void sub_1A3E9EC68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t FaceRegionMap_addForeheadLandmarks(uint64_t a1)
{
  char v2 = *(float32x2_t **)a1;
  int v3 = *(float32x2_t **)(a1 + 8);
  if ((char *)v3 - (char *)v2 != 504) {
    return 5759;
  }
  float32x2_t v5 = vadd_f32(vsub_f32(v2[40], v2[41]), vsub_f32(v2[50], v2[49]));
  int32x2_t v6 = (int32x2_t)vmul_f32(v5, v5);
  *(float *)v6.i32 = sqrtf(vmlas_n_f32(*(float *)&v6.i32[1], v5.f32[0], v5.f32[0]));
  if (*(float *)v6.i32 > 0.0) {
    float32x2_t v5 = vdiv_f32(v5, (float32x2_t)vdup_lane_s32(v6, 0));
  }
  float32x2_t v8 = v2[1];
  float32x2_t v7 = v2[2];
  float v9 = v2[60].f32[0] - v2[62].f32[0];
  float32x2_t v11 = v2[5];
  float32x2_t v10 = v2[6];
  float32x2_t v12 = vmul_n_f32(v5, sqrtf((float)((float)(v2[60].f32[1] - v2[62].f32[1]) * (float)(v2[60].f32[1] - v2[62].f32[1])) + (float)(v9 * v9)));
  float32x2_t v68 = (float32x2_t)vdup_n_s32(0x3F333333u);
  float32x2_t v13 = vmla_f32(*v2, v68, v12);
  float32x2_t v14 = (float32x2_t)vdup_n_s32(0x3F666666u);
  float32x2_t v15 = v2[7];
  unint64_t v16 = *(void *)(a1 + 16);
  if ((unint64_t)v3 >= v16)
  {
    uint64_t v19 = v16 - (void)v2;
    if ((unint64_t)(v19 >> 2) <= 0x40) {
      uint64_t v20 = 64;
    }
    else {
      uint64_t v20 = v19 >> 2;
    }
    BOOL v21 = (unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v21) {
      unint64_t v22 = v20;
    }
    if (v22)
    {
      unint64_t v22 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v22);
      char v2 = *(float32x2_t **)a1;
      int v3 = *(float32x2_t **)(a1 + 8);
    }
    else
    {
      uint64_t v23 = 0;
    }
    uint64_t v24 = (float32x2_t *)(v22 + 504);
    unint64_t v16 = v22 + 8 * v23;
    *uint64_t v24 = v13;
    char v17 = v24 + 1;
    if (v3 != v2)
    {
      do
      {
        float32x2_t v25 = v3[-1];
        --v3;
        v24[-1] = v25;
        --v24;
      }
      while (v3 != v2);
      char v2 = *(float32x2_t **)a1;
    }
    *(void *)a1 = v24;
    *(void *)(a1 + 8) = v17;
    *(void *)(a1 + 16) = v16;
    if (v2)
    {
      operator delete(v2);
      unint64_t v16 = *(void *)(a1 + 16);
    }
  }
  else
  {
    *int v3 = v13;
    char v17 = v3 + 1;
  }
  float32x2_t v26 = vmla_f32(v8, v14, v12);
  *(void *)(a1 + 8) = v17;
  if ((unint64_t)v17 >= v16)
  {
    unint64_t v28 = *(float32x2_t **)a1;
    uint64_t v29 = ((uint64_t)v17 - *(void *)a1) >> 3;
    unint64_t v30 = v29 + 1;
    if ((unint64_t)(v29 + 1) >> 61) {
      goto LABEL_83;
    }
    uint64_t v31 = v16 - (void)v28;
    if (v31 >> 2 > v30) {
      unint64_t v30 = v31 >> 2;
    }
    BOOL v21 = (unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v21) {
      unint64_t v32 = v30;
    }
    if (v32)
    {
      unint64_t v32 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v32);
      unint64_t v28 = *(float32x2_t **)a1;
      char v17 = *(float32x2_t **)(a1 + 8);
    }
    else
    {
      uint64_t v33 = 0;
    }
    unint64_t v34 = (float32x2_t *)(v32 + 8 * v29);
    unint64_t v16 = v32 + 8 * v33;
    *unint64_t v34 = v26;
    float v27 = v34 + 1;
    if (v17 != v28)
    {
      do
      {
        float32x2_t v35 = v17[-1];
        --v17;
        v34[-1] = v35;
        --v34;
      }
      while (v17 != v28);
      unint64_t v28 = *(float32x2_t **)a1;
    }
    *(void *)a1 = v34;
    *(void *)(a1 + 8) = v27;
    *(void *)(a1 + 16) = v16;
    if (v28)
    {
      operator delete(v28);
      unint64_t v16 = *(void *)(a1 + 16);
    }
  }
  else
  {
    *char v17 = v26;
    float v27 = v17 + 1;
  }
  float32x2_t v36 = vmla_f32(vmul_f32(vadd_f32(v7, v11), (float32x2_t)0x3F0000003F000000), (float32x2_t)vdup_n_s32(0x3F8CCCCDu), v12);
  *(void *)(a1 + 8) = v27;
  if ((unint64_t)v27 >= v16)
  {
    char v38 = *(float32x2_t **)a1;
    uint64_t v39 = ((uint64_t)v27 - *(void *)a1) >> 3;
    unint64_t v40 = v39 + 1;
    if ((unint64_t)(v39 + 1) >> 61) {
      goto LABEL_83;
    }
    uint64_t v41 = v16 - (void)v38;
    if (v41 >> 2 > v40) {
      unint64_t v40 = v41 >> 2;
    }
    BOOL v21 = (unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v21) {
      unint64_t v42 = v40;
    }
    if (v42)
    {
      unint64_t v42 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v42);
      char v38 = *(float32x2_t **)a1;
      float v27 = *(float32x2_t **)(a1 + 8);
    }
    else
    {
      uint64_t v43 = 0;
    }
    uint64_t v44 = (float32x2_t *)(v42 + 8 * v39);
    unint64_t v16 = v42 + 8 * v43;
    *uint64_t v44 = v36;
    unint64_t v37 = v44 + 1;
    if (v27 != v38)
    {
      do
      {
        float32x2_t v45 = v27[-1];
        --v27;
        v44[-1] = v45;
        --v44;
      }
      while (v27 != v38);
      char v38 = *(float32x2_t **)a1;
    }
    *(void *)a1 = v44;
    *(void *)(a1 + 8) = v37;
    *(void *)(a1 + 16) = v16;
    if (v38)
    {
      operator delete(v38);
      unint64_t v16 = *(void *)(a1 + 16);
    }
  }
  else
  {
    *float v27 = v36;
    unint64_t v37 = v27 + 1;
  }
  float32x2_t v46 = vmla_f32(v10, v14, v12);
  *(void *)(a1 + 8) = v37;
  if ((unint64_t)v37 >= v16)
  {
    char v49 = *(float32x2_t **)a1;
    uint64_t v50 = ((uint64_t)v37 - *(void *)a1) >> 3;
    unint64_t v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 61) {
      goto LABEL_83;
    }
    uint64_t v52 = v16 - (void)v49;
    if (v52 >> 2 > v51) {
      unint64_t v51 = v52 >> 2;
    }
    BOOL v21 = (unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v21) {
      unint64_t v53 = v51;
    }
    if (v53)
    {
      unint64_t v53 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v53);
      char v49 = *(float32x2_t **)a1;
      unint64_t v37 = *(float32x2_t **)(a1 + 8);
    }
    else
    {
      uint64_t v54 = 0;
    }
    uint64_t v55 = (float32x2_t *)(v53 + 8 * v50);
    unint64_t v16 = v53 + 8 * v54;
    *uint64_t v55 = v46;
    int v47 = v55 + 1;
    if (v37 == v49)
    {
      float32x2_t v48 = v68;
    }
    else
    {
      float32x2_t v48 = v68;
      do
      {
        float32x2_t v56 = v37[-1];
        --v37;
        v55[-1] = v56;
        --v55;
      }
      while (v37 != v49);
      char v49 = *(float32x2_t **)a1;
    }
    *(void *)a1 = v55;
    *(void *)(a1 + 8) = v47;
    *(void *)(a1 + 16) = v16;
    if (v49)
    {
      operator delete(v49);
      unint64_t v16 = *(void *)(a1 + 16);
    }
  }
  else
  {
    *unint64_t v37 = v46;
    int v47 = v37 + 1;
    float32x2_t v48 = v68;
  }
  float32x2_t v57 = vmla_f32(v15, v48, v12);
  *(void *)(a1 + 8) = v47;
  if ((unint64_t)v47 >= v16)
  {
    uint64_t v59 = *(float32x2_t **)a1;
    uint64_t v60 = ((uint64_t)v47 - *(void *)a1) >> 3;
    unint64_t v61 = v60 + 1;
    if (!((unint64_t)(v60 + 1) >> 61))
    {
      uint64_t v62 = v16 - (void)v59;
      if (v62 >> 2 > v61) {
        unint64_t v61 = v62 >> 2;
      }
      BOOL v21 = (unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v21) {
        unint64_t v63 = v61;
      }
      if (v63)
      {
        unint64_t v63 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v63);
        uint64_t v59 = *(float32x2_t **)a1;
        int v47 = *(float32x2_t **)(a1 + 8);
      }
      else
      {
        uint64_t v64 = 0;
      }
      uint64_t v65 = (float32x2_t *)(v63 + 8 * v60);
      unint64_t v66 = v63 + 8 * v64;
      *uint64_t v65 = v57;
      int64_t v58 = v65 + 1;
      if (v47 != v59)
      {
        do
        {
          float32x2_t v67 = v47[-1];
          --v47;
          v65[-1] = v67;
          --v65;
        }
        while (v47 != v59);
        uint64_t v59 = *(float32x2_t **)a1;
      }
      *(void *)a1 = v65;
      *(void *)(a1 + 8) = v58;
      *(void *)(a1 + 16) = v66;
      if (v59) {
        operator delete(v59);
      }
      goto LABEL_82;
    }
LABEL_83:
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  *int v47 = v57;
  int64_t v58 = v47 + 1;
LABEL_82:
  *(void *)(a1 + 8) = v58;
  return 5760;
}

void sub_1A3E9F2F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9F4F8(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3E9F544(_Unwind_Exception *a1)
{
}

void sub_1A3E9F5DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNImageSourceManager;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3E9F6C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9F798(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9F884(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3E9F8B0(_Unwind_Exception *a1)
{
}

void sub_1A3E9F928(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3E9F93C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9F9B8(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3E9F9CC(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3E9FA58(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3E9FA6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9FAF0(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3E9FB04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  a9.super_class = (Class)VNImageBufferCache;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3E9FBBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3E9FCA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA1794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,void *a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,_Unwind_Exception *exception_object,uint64_t a34)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA1C00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA256C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A3EA2538);
}

void sub_1A3EA25B8()
{
  if (v0) {
    JUMPOUT(0x1A3EA25C0);
  }

  JUMPOUT(0x1A3EA2634);
}

void sub_1A3EA25C8(void *a1)
{
}

void sub_1A3EA25D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  JUMPOUT(0x1A3EA2670);
}

void sub_1A3EA25DC()
{
}

void sub_1A3EA25F0()
{
}

void sub_1A3EA260C()
{
  if (v0) {
    JUMPOUT(0x1A3EA2614);
  }

  JUMPOUT(0x1A3EA2634);
}

void sub_1A3EA2640(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  JUMPOUT(0x1A3EA2670);
}

void sub_1A3EA264C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  JUMPOUT(0x1A3EA269CLL);
}

void sub_1A3EA2658()
{
}

void sub_1A3EA267C()
{
}

void sub_1A3EA2790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA2CDC(void *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void sub_1A3EA2DB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA3AAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3EA3A80);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3EA3E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA43E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_unfair_lock_t lock, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3EA4304);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3EA4450(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  JUMPOUT(0x1A3EA44B8);
}

void sub_1A3EA446C(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exc_buf);
}

void sub_1A3EA448C()
{
  objc_end_catch();

  if (!v1) {
    JUMPOUT(0x1A3EA4410);
  }
  JUMPOUT(0x1A3EA440CLL);
}

void sub_1A3EA44D0()
{
  objc_end_catch();

  JUMPOUT(0x1A3EA4460);
}

void sub_1A3EA44F8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1A3EA4D5C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_unfair_lock_t lock)
{
}

void sub_1A3EA4E24()
{
  objc_end_catch();

  JUMPOUT(0x1A3EA4E30);
}

void sub_1A3EA5174(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CVPixelBufferReleaseReferencingPixelBufferCallback(__CVBuffer *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    CVPixelBufferUnlockBaseAddress(a1, 0);
    CVPixelBufferRelease(a1);
  }
  else
  {
    VNValidatedLog(4, @"VNImageBuffer - this release call should not be used with anything but a referencing pixelbuffer %s", a3, a4, a5, a6, a7, a8, (uint64_t)"void CVPixelBufferReleaseReferencingPixelBufferCallback(void * _Nullable, const void * _Nullable)");
  }
}

void sub_1A3EA5434(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA54CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA55DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA56C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA57FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA5AE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA5F60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA6280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Block_object_dispose((const void *)(v20 - 152), 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__4772(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void sub_1A3EA6B64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA6C20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNImageBuffer;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3EA6CF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA6D98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA6EC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA6F58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA708C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA728C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA7350(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA747C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA7528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA7614(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA76B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA77A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA7834(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA7918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA79C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA7B1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA7BD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA7C5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA7EEC(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(void **)(v1 + 8));
  MEMORY[0x1A62562C0](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

uint64_t Geometry2D_metricToPixelHomo2D(uint64_t *a1, float *a2, uint64_t *a3)
{
  if (!a3) {
    return 1916;
  }
  uint64_t v3 = *a3;
  if (!*a3) {
    return 1916;
  }
  uint64_t v4 = a3[1];
  if (!v4) {
    return 1916;
  }
  int32x2_t v6 = (void *)a3[2];
  if (!v6) {
    return 1916;
  }
  uint64_t v7 = 1916;
  if (!a1) {
    return v7;
  }
  uint64_t v8 = *((unsigned int *)a3 + 6);
  if ((int)v8 < 1) {
    return v7;
  }
  uint64_t v9 = *a1;
  if (!*a1) {
    return 1916;
  }
  uint64_t v10 = a1[1];
  if (!v10) {
    return 1916;
  }
  float32x2_t v11 = (char *)a1[2];
  if (!v11) {
    return 1916;
  }
  int v12 = *((_DWORD *)a1 + 6);
  uint64_t v7 = 1916;
  if (v12 >= 1 && v12 == v8)
  {
    uint64_t v13 = 0;
    float v14 = *a2;
    float v15 = a2[3];
    float v16 = a2[4];
    size_t v17 = 4 * v8;
    float v18 = a2[6];
    float v19 = a2[7];
    do
    {
      *(float *)(v3 + v13) = (float)((float)(v15 * *(float *)(v10 + v13)) + (float)(v14 * *(float *)(v9 + v13)))
                           + (float)(v18 * *(float *)&v11[v13]);
      *(float *)(v4 + v13) = (float)(v19 * *(float *)&v11[v13]) + (float)(v16 * *(float *)(v10 + v13));
      v13 += 4;
    }
    while (v17 != v13);
    memcpy(v6, v11, v17);
    return 1920;
  }
  return v7;
}

void sub_1A3EA8148(_Unwind_Exception *a1)
{
}

void sub_1A3EA82A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA83EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA8904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  _Block_object_dispose(&a51, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4859(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A3EA8CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18)
{
  _Block_object_dispose((const void *)(v20 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__39(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__40(uint64_t a1)
{
}

void sub_1A3EA8E84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA8F98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA90C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA9134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

IOSurfaceRef createIOSurfaceWithInput(uint64_t a1, uint64_t a2, uint64_t a3, void **a4, void *a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  dest.int data = (void *)*MEMORY[0x1E4F2F2C0];
  uint64_t v10 = [NSNumber numberWithUnsignedLong:a1];
  src.int data = v10;
  dest.height = *MEMORY[0x1E4F2F0E8];
  float32x2_t v11 = [NSNumber numberWithUnsignedLong:a2];
  src.height = (vImagePixelCount)v11;
  dest.width = *MEMORY[0x1E4F2EFD8];
  int v12 = [NSNumber numberWithUnsignedLong:2];
  src.width = (vImagePixelCount)v12;
  dest.rowBytes = *MEMORY[0x1E4F2EFE0];
  uint64_t v13 = [NSNumber numberWithUnsignedLong:a3];
  src.rowBytes = (size_t)v13;
  CFDictionaryRef v14 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&src forKeys:&dest count:4];

  IOSurfaceRef v15 = IOSurfaceCreate(v14);
  if (!v15)
  {
    if (a5)
    {
      float v16 = +[VNFgBgInstanceSegmenterError allocationErrorIOSurface];
      size_t v17 = +[VNFgBgInstanceSegmenterError errorWithCode:-7 description:v16];
LABEL_13:
      *a5 = v17;

      return 0;
    }
    return 0;
  }
  if (IOSurfaceLock(v15, 0, 0))
  {
    CFRelease(v15);
    if (a5) {
      goto LABEL_12;
    }
    return 0;
  }
  BaseAddress = IOSurfaceGetBaseAddress(v15);
  src.int data = *a4;
  src.height = 1;
  src.width = a2 * a1;
  src.rowBytes = 4 * a2 * a1;
  dest.int data = BaseAddress;
  dest.height = 1;
  dest.width = a2 * a1;
  dest.rowBytes = 2 * a2 * a1;
  vImage_Error v19 = vImageConvert_PlanarFtoPlanar16F(&src, &dest, 0);
  if (a5 && v19)
  {
    uint64_t v20 = +[VNFgBgInstanceSegmenterError genericErrorIOSurface];
    *a5 = +[VNFgBgInstanceSegmenterError errorWithCode:-7 description:v20];
  }
  if (IOSurfaceUnlock(v15, 0, 0))
  {
    CFRelease(v15);
    if (a5)
    {
LABEL_12:
      float v16 = +[VNFgBgInstanceSegmenterError genericErrorIOSurface];
      size_t v17 = +[VNFgBgInstanceSegmenterError errorWithCode:-7 description:v16];
      goto LABEL_13;
    }
    return 0;
  }
  return v15;
}

void sub_1A3EA9598(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EA96E0(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3EA9C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,void *a28,void *a29,uint64_t a30,void *a31,void *a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,id a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,id a52)
{
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a41, 8);

  _Block_object_dispose(&a47, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4984(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4985(uint64_t a1)
{
}

void sub_1A3EA9FE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAA268(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAA378(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *apple::vision::libraries::autotrace::EPolygon::addPointAtStart(apple::vision::libraries::autotrace::EPolygon *this)
{
  int v2 = *((_DWORD *)this + 4);
  if (v2)
  {
    uint64_t v3 = (char *)*((void *)this + 1);
LABEL_5:
    int v11 = v2 - 1;
    __n128 result = &v3[8 * v11];
    ++*(_DWORD *)this;
    *((_DWORD *)this + 4) = v11;
    return result;
  }
  uint64_t v4 = (char *)malloc_type_malloc(8 * *(int *)this + 800, 0x100004000313F17uLL);
  if (v4)
  {
    uint64_t v3 = v4;
    memmove(v4 + 400, (const void *)(*((void *)this + 1) + 8 * *((int *)this + 4)), 8 * *(int *)this);
    *((_DWORD *)this + 4) = 50;
    *((_DWORD *)this + 1) = *(_DWORD *)this + 100;
    free(*((void **)this + 1));
    *((void *)this + 1) = v3;
    int v2 = *((_DWORD *)this + 4);
    goto LABEL_5;
  }
  VNValidatedLog(4, @"%s: could not extend extract polygons point list", v5, v6, v7, v8, v9, v10, (uint64_t)"addPointAtStart");
  return 0;
}

char *apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(apple::vision::libraries::autotrace::EPolygon *this)
{
  int v2 = *(_DWORD *)this;
  int v3 = *(_DWORD *)this + *((_DWORD *)this + 4);
  if (v3 != *((_DWORD *)this + 1))
  {
    int v11 = (char *)*((void *)this + 1);
    goto LABEL_5;
  }
  uint64_t v4 = (char *)malloc_type_malloc(8 * (v2 + 100), 0x100004000313F17uLL);
  if (v4)
  {
    int v11 = v4;
    memmove(v4 + 400, (const void *)(*((void *)this + 1) + 8 * *((int *)this + 4)), 8 * *(int *)this);
    *((_DWORD *)this + 4) = 50;
    *((_DWORD *)this + 1) = *(_DWORD *)this + 100;
    free(*((void **)this + 1));
    *((void *)this + 1) = v11;
    int v2 = *(_DWORD *)this;
    int v3 = *(_DWORD *)this + *((_DWORD *)this + 4);
LABEL_5:
    __n128 result = &v11[8 * v3];
    *(_DWORD *)this = v2 + 1;
    return result;
  }
  VNValidatedLog(4, @"%s: could not extend extract polygons point list", v5, v6, v7, v8, v9, v10, (uint64_t)"addPointAtEnd");
  return 0;
}

uint64_t apple::vision::libraries::autotrace::EPolygon::containsPoint(unsigned int *a1, double a2)
{
  uint64_t v2 = *a1;
  if ((int)v2 >= 1)
  {
    uint64_t v3 = 0;
    char v4 = 0;
    uint64_t v5 = *((void *)a1 + 1);
    while (1)
    {
      uint64_t v6 = *(void *)(v5 + 8 * v3);
      if (v2 - 1 == v3) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = v3 + 1;
      }
      uint64_t v8 = *(void *)(v5 + 8 * v7);
      if (*((float *)&v6 + 1) != *((float *)&v8 + 1))
      {
        if (*((float *)&v8 + 1) <= *((float *)&v6 + 1))
        {
          float v9 = *(float *)&v8;
          LODWORD(v8) = *(void *)(v5 + 8 * v3);
          LODWORD(v10) = HIDWORD(*(void *)(v5 + 8 * v7));
          LODWORD(v11) = HIDWORD(*(void *)(v5 + 8 * v3));
        }
        else
        {
          LODWORD(v9) = *(void *)(v5 + 8 * v3);
          LODWORD(v10) = HIDWORD(*(void *)(v5 + 8 * v3));
          LODWORD(v11) = HIDWORD(*(void *)(v5 + 8 * v7));
        }
        BOOL v12 = v9 < *(float *)&a2 && *(float *)&v8 < *(float *)&a2;
        BOOL v13 = !v12 && v10 <= *((float *)&a2 + 1);
        if (v13 && v11 >= *((float *)&a2 + 1))
        {
          if (*(float *)&v8 > *(float *)&a2 && v9 > *(float *)&a2)
          {
            char v17 = v10 != *((float *)&a2 + 1);
            if (*((float *)&v8 + 1) > *((float *)&v6 + 1) || v10 == *((float *)&a2 + 1)) {
              goto LABEL_27;
            }
            goto LABEL_39;
          }
          float v16 = (float)((float)(*(float *)&a2 - *(float *)&v8) * (float)(v10 - v11))
              - (float)((float)(*((float *)&a2 + 1) - v11) * (float)(v9 - *(float *)&v8));
          if (v16 != 0.0)
          {
            BOOL v19 = v16 <= 0.0 || v10 == *((float *)&a2 + 1);
            char v17 = !v19;
            if (v19 || *((float *)&v8 + 1) > *((float *)&v6 + 1)) {
              goto LABEL_27;
            }
LABEL_39:
            char v17 = 1;
            goto LABEL_27;
          }
        }
      }
      char v17 = 0;
LABEL_27:
      ++v3;
      v4 += v17;
      if (v2 == v3) {
        return v4 & 1;
      }
    }
  }
  return 0;
}

BOOL apple::vision::libraries::autotrace::EPolygonList::init(apple::vision::libraries::autotrace::EPolygonList *this)
{
  uint64_t v8 = malloc_type_malloc(0xFA0uLL, 0x10800400A3A46C6uLL);
  *((void *)this + 1) = v8;
  if (v8)
  {
    *(void *)this = 0x6400000000;
    *((_DWORD *)this + 4) = -1;
  }
  else
  {
    VNValidatedLog(4, @"%s: could not allocate extract polygons point list", v2, v3, v4, v5, v6, v7, (uint64_t)"init");
  }
  return v8 != 0;
}

void apple::vision::libraries::autotrace::EPolygonList::term(apple::vision::libraries::autotrace::EPolygonList *this)
{
  if (*(int *)this >= 1)
  {
    int v2 = 0;
    uint64_t v3 = *((void *)this + 1);
    uint64_t v4 = v3 + 21;
    do
    {
      *(_DWORD *)(v4 + 3) = *((_DWORD *)this + 4);
      *((_DWORD *)this + 4) = -858993459 * ((unint64_t)(v3 - *((void *)this + 1)) >> 3);
      *(unsigned char *)uint64_t v4 = 1;
      free(*(void **)(v4 - 13));
      *(void *)(v4 - 13) = 0;
      *(void *)(v4 - 21) = 0;
      *(void *)(v4 + 7) = -1;
      ++v2;
      v4 += 40;
      v3 += 40;
    }
    while (v2 < *(_DWORD *)this);
  }
  uint64_t v5 = (void *)*((void *)this + 1);

  free(v5);
}

void apple::vision::libraries::autotrace::EPolygonList::freePolygon(apple::vision::libraries::autotrace::EPolygonList *this, apple::vision::libraries::autotrace::EPolygon *a2)
{
  *((_DWORD *)a2 + 6) = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = -858993459 * (((unint64_t)a2 - *((void *)this + 1)) >> 3);
  *((unsigned char *)a2 + 21) = 1;
  free(*((void **)a2 + 1));
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  *(void *)((char *)a2 + 28) = -1;

  apple::vision::libraries::autotrace::EPolygonList::verifyList(this, v4, v5, v6, v7, v8, v9, v10);
}

void apple::vision::libraries::autotrace::EPolygonList::verifyList(apple::vision::libraries::autotrace::EPolygonList *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (int i = *((_DWORD *)this + 4); i != -1; int i = *(_DWORD *)(v11 + 40 * v10 + 24))
  {
    int v10 = i;
    if (i < 0 || i >= *(_DWORD *)this) {
      VNValidatedLog(4, @"%s: free polygon %d free list index out of range (value: %d)", a3, a4, a5, a6, a7, a8, (uint64_t)"verifyList");
    }
    uint64_t v11 = *((void *)this + 1);
    if (!*(unsigned char *)(v11 + 40 * v10 + 21)) {
      VNValidatedLog(4, @"%s: polygon %d on free list is not marked free", a3, a4, a5, a6, a7, a8, (uint64_t)"verifyList");
    }
  }
  if (*(int *)this >= 1)
  {
    int v12 = 0;
    uint64_t v13 = *((void *)this + 1);
    do
    {
      if (*(unsigned char *)(v13 + 21))
      {
        for (int j = *((_DWORD *)this + 4); j != -1; int j = *(_DWORD *)(*((void *)this + 1) + 40 * j + 24))
        {
          if (j == v12) {
            goto LABEL_28;
          }
        }
        VNValidatedLog(4, @"%s: free polygon %d is not on the free list", a3, a4, a5, a6, a7, a8, (uint64_t)"verifyPolygon");
      }
      else
      {
        if ((*(_DWORD *)v13 & 0x80000000) != 0 || *(_DWORD *)v13 > *(_DWORD *)(v13 + 4)) {
          VNValidatedLog(4, @"%s: polygon %d has a bad number of points %d (maxPoints %d)", a3, a4, a5, a6, a7, a8, (uint64_t)"verifyPolygon");
        }
        int v15 = *(_DWORD *)(v13 + 32);
        if (v15 == -1)
        {
          if (*(_DWORD *)(v13 + 24) != -1) {
            VNValidatedLog(4, @"%s: top-level polygon %d has a next pointer (value: %d)", a3, a4, a5, a6, a7, a8, (uint64_t)"verifyPolygon");
          }
          for (int k = *(_DWORD *)(v13 + 28); k != -1; int k = *(_DWORD *)(*((void *)this + 1) + 40 * k + 24))
          {
            if (k < 0 || k >= *(_DWORD *)this) {
              VNValidatedLog(4, @"%s: polygon %d has a bad index (value: %d) in its child list", a3, a4, a5, a6, a7, a8, (uint64_t)"verifyPolygon");
            }
          }
        }
        else
        {
          if (v15 < 0 || v15 >= *(_DWORD *)this)
          {
            VNValidatedLog(4, @"%s: child polygon %d has a bad parent index (value %d)", a3, a4, a5, a6, a7, a8, (uint64_t)"verifyPolygon");
            int v15 = *(_DWORD *)(v13 + 32);
          }
          uint64_t v16 = *((void *)this + 1);
          for (int m = *(_DWORD *)(v16 + 40 * v15 + 28); m != -1; int m = *(_DWORD *)(v16 + 40 * m + 24))
          {
            if (m == v12) {
              goto LABEL_28;
            }
          }
          VNValidatedLog(4, @"%s: child polygon %d is not found in the child list of its parent polygon %d", a3, a4, a5, a6, a7, a8, (uint64_t)"verifyPolygon");
        }
      }
LABEL_28:
      ++v12;
      v13 += 40;
    }
    while (v12 < *(_DWORD *)this);
  }
}

uint64_t apple::vision::libraries::autotrace::EPolygonList::newPolygon(apple::vision::libraries::autotrace::EPolygonList *this, int a2, int a3)
{
  int v6 = *((_DWORD *)this + 4);
  if (v6 == -1)
  {
    int v8 = *(_DWORD *)this;
    int v9 = *((_DWORD *)this + 1);
    if (*(_DWORD *)this >= v9)
    {
      int v10 = malloc_type_malloc(40 * v9 + 4000, 0x10800400A3A46C6uLL);
      uint64_t v7 = (uint64_t)v10;
      if (!v10)
      {
        VNValidatedLog(4, @"%s: could not extend extract polygons list", v11, v12, v13, v14, v15, v16, (uint64_t)"newPolygon");
        return v7;
      }
      memmove(v10, *((const void **)this + 1), 40 * *((int *)this + 1));
      *((_DWORD *)this + 1) += 100;
      free(*((void **)this + 1));
      *((void *)this + 1) = v7;
      int v8 = *(_DWORD *)this;
    }
    else
    {
      uint64_t v7 = *((void *)this + 1);
    }
    v7 += 40 * v8;
    *(_DWORD *)this = v8 + 1;
  }
  else
  {
    uint64_t v7 = *((void *)this + 1) + 40 * v6;
    *((_DWORD *)this + 4) = *(_DWORD *)(v7 + 24);
    *(unsigned char *)(v7 + 21) = 0;
  }
  char v17 = malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
  *(void *)(v7 + 8) = v17;
  if (v17)
  {
    *(_DWORD *)uint64_t v7 = 0;
    *(_DWORD *)(v7 + 4) = a2;
    if (a2 >= 0) {
      int v25 = a2;
    }
    else {
      int v25 = a2 + 1;
    }
    int v26 = v25 >> 1;
    if (!a3) {
      int v26 = 0;
    }
    *(_DWORD *)(v7 + 16) = v26;
    *(_WORD *)(v7 + 20) = 0;
    *(void *)(v7 + 24) = -1;
    *(_DWORD *)(v7 + 32) = -1;
    apple::vision::libraries::autotrace::EPolygonList::verifyList(this, v18, v19, v20, v21, v22, v23, v24);
  }
  else
  {
    VNValidatedLog(4, @"%s: could not allocate extract polygons point list", v19, v20, v21, v22, v23, v24, (uint64_t)"newPolygon");
    return 0;
  }
  return v7;
}

void apple::vision::libraries::autotrace::EPolygonList::insertPolygon(apple::vision::libraries::autotrace::EPolygonList *this, apple::vision::libraries::autotrace::EPolygon *a2, apple::vision::libraries::autotrace::EPolygon *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*((unsigned char *)a2 + 20) || !*((unsigned char *)a3 + 20)) {
    VNValidatedLog(4, @"%s: something is not closed", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"insertPolygon");
  }
  uint64_t v11 = *((void *)this + 1);
  int v12 = -858993459 * (((unint64_t)a3 - v11) >> 3);
  int v13 = *((_DWORD *)a3 + 8);
  if (v13 != -1)
  {
    uint64_t v14 = v11 + 40 * v13;
    unsigned int v17 = *(_DWORD *)(v14 + 28);
    uint64_t v15 = (unsigned int *)(v14 + 28);
    unsigned int v16 = v17;
    if (v17 != -1)
    {
      uint64_t v18 = 0;
      while (1)
      {
        if ((v16 & 0x80000000) != 0 || (signed int)v16 >= *(_DWORD *)this)
        {
          VNValidatedLog(4, @"%s: bad next index %d in polygon %d nested list", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"insertPolygon");
          uint64_t v11 = *((void *)this + 1);
          goto LABEL_16;
        }
        uint64_t v19 = (unsigned int *)(v11 + 40 * v16 + 24);
        if (v16 == v12) {
          break;
        }
        uint64_t v18 = v11 + 40 * v16;
        unsigned int v16 = *v19;
        if (*v19 == -1) {
          goto LABEL_16;
        }
      }
      unsigned int v20 = *v19;
      if (v18) {
        *(_DWORD *)(v18 + 24) = v20;
      }
      else {
        *uint64_t v15 = v20;
      }
    }
  }
LABEL_16:
  *((_DWORD *)a3 + 6) = *((_DWORD *)a2 + 7);
  *((_DWORD *)a2 + 7) = v12;
  *((unsigned char *)a3 + 21) = 0;
  int v21 = -858993459 * (((unint64_t)a2 - v11) >> 3);
  *((_DWORD *)a3 + 8) = v21;
  if (v21 < 0 || *(_DWORD *)this <= v21) {
    VNValidatedLog(4, @"%s: parent index out of whack", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"insertPolygon");
  }

  apple::vision::libraries::autotrace::EPolygonList::verifyList(this, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
}

EPolygon *apple::vision::libraries::autotrace::EPolygonList::containsPolygon(apple::vision::libraries::autotrace::EPolygonList *this, EPolygon *a2)
{
  int v2 = *(_DWORD *)this;
  if (*(int *)this < 1) {
    return 0;
  }
  double v4 = **((double **)a2 + 1);
  for (int i = (EPolygon *)*((void *)this + 1); ; int i = (EPolygon *)((char *)i + 40))
  {
    BOOL v6 = *((unsigned char *)i + 21) || i == a2;
    if (!v6
      && *((unsigned char *)i + 20)
      && (apple::vision::libraries::autotrace::EPolygon::containsPoint((unsigned int *)i, v4) & 1) != 0)
    {
      break;
    }
    if (!--v2) {
      return 0;
    }
  }
  return i;
}

unsigned int *apple::vision::libraries::autotrace::EPolygonList::containsPolygonInChildList(apple::vision::libraries::autotrace::EPolygonList *this, int a2, EPolygon *a3, double a4)
{
  uint64_t v6 = *((void *)this + 1);
  while (1)
  {
    uint64_t v7 = (unsigned int *)(v6 + 40 * a2);
    if (apple::vision::libraries::autotrace::EPolygon::containsPoint(v7, a4)) {
      break;
    }
    a2 = *(_DWORD *)(v6 + 40 * a2 + 24);
    if (a2 == -1) {
      return 0;
    }
  }
  return v7;
}

void sub_1A3EAAFD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAB354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  _Unwind_Resume(a1);
}

void std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(*(std::string **)(a1 + 8), *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(v3 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  *(void *)(a1 + 8) = v3 + 24;
}

void sub_1A3EAB448(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

std::vector<std::string>::pointer std::vector<std::string>::__push_back_slow_path<std::string const&>(std::vector<std::string> *a1, long long *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((char *)a1->__end_ - (char *)a1->__begin_) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  p_end_cap = (std::allocator<std::string> *)&a1->__end_cap_;
  if (0x5555555555555556 * (((char *)a1->__end_cap_.__value_ - (char *)a1->__begin_) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((char *)a1->__end_cap_.__value_ - (char *)a1->__begin_) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)a1->__end_cap_.__value_ - (char *)a1->__begin_) >> 3) >= 0x555555555555555) {
    unint64_t v7 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v7 = v3;
  }
  __v.__end_cap_.__value_ = p_end_cap;
  if (v7)
  {
    int v9 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v7);
  }
  else
  {
    int v9 = 0;
    uint64_t v8 = 0;
  }
  std::__split_buffer<std::string>::pointer end = v9 + v2;
  __v.__first_ = v9;
  __v.__begin_ = end;
  __v.__end_ = end;
  __v.__end_cap_.__value_ = &v9[v8];
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(end, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    std::__split_buffer<std::string>::pointer end = __v.__end_;
  }
  else
  {
    long long v11 = *a2;
    end->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v11;
  }
  __v.__end_ = end + 1;
  std::vector<std::string>::__swap_out_circular_buffer(a1, &__v);
  std::vector<std::string>::pointer v12 = a1->__end_;
  std::__split_buffer<std::string>::~__split_buffer(&__v);
  return v12;
}

void sub_1A3EAB560(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *std::vector<std::pair<std::string,float>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 32;
      long long v6 = *(_OWORD *)(v3 - 32);
      *(void *)(v4 - 16) = *(void *)(v3 - 16);
      *(_OWORD *)(v4 - 32) = v6;
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 32) = 0;
      *(_DWORD *)(v4 - 8) = *(_DWORD *)(v3 - 8);
      v4 -= 32;
      v3 -= 32;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v7 = *result;
  *__n128 result = v5;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::pair<std::string,float>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 4;
      *(void *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v4);
        uint64_t v4 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__introsort<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *,false>(unint64_t a1, void **a2, uint64_t a3, char a4)
{
  while (2)
  {
    float v121 = (float *)(a2 - 4);
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          uint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 5;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return;
              case 2:
                if (*((float *)a2 - 2) > *(float *)(a1 + 24))
                {
                  double v136 = *(void **)(a1 + 16);
                  long long v128 = *(_OWORD *)a1;
                  long long v50 = *(_OWORD *)v121;
                  *(void *)(a1 + 16) = *(a2 - 2);
                  *(_OWORD *)a1 = v50;
                  *(a2 - 2) = v136;
                  *(_OWORD *)float v121 = v128;
                  LODWORD(v50) = *(_DWORD *)(a1 + 24);
                  *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 - 2);
                  *((_DWORD *)a2 - 2) = v50;
                }
                break;
              case 3:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)a1, (float *)(a1 + 32), v121);
                break;
              case 4:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, (long long *)(a1 + 32), (float *)(a1 + 64), v121);
                break;
              case 5:
                unint64_t v51 = (long long *)(a1 + 32);
                uint64_t v52 = (long long *)(a1 + 64);
                unint64_t v53 = (long long *)(a1 + 96);
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, (long long *)(a1 + 32), (float *)(a1 + 64), (float *)(a1 + 96));
                if (*((float *)a2 - 2) > *(float *)(a1 + 120))
                {
                  long long v54 = *v53;
                  uint64_t v55 = *(void **)(a1 + 112);
                  uint64_t v56 = (uint64_t)*(a2 - 2);
                  *unint64_t v53 = *(_OWORD *)v121;
                  *(void *)(a1 + 112) = v56;
                  *(a2 - 2) = v55;
                  *(_OWORD *)float v121 = v54;
                  LODWORD(v54) = *(_DWORD *)(a1 + 120);
                  *(_DWORD *)(a1 + 120) = *((_DWORD *)a2 - 2);
                  *((_DWORD *)a2 - 2) = v54;
                  float v57 = *(float *)(a1 + 120);
                  float v58 = *(float *)(a1 + 88);
                  if (v57 > v58)
                  {
                    uint64_t v59 = *(void *)(a1 + 80);
                    long long v60 = *v52;
                    *uint64_t v52 = *v53;
                    *(void *)(a1 + 80) = *(void *)(a1 + 112);
                    *unint64_t v53 = v60;
                    *(void *)(a1 + 112) = v59;
                    *(float *)(a1 + 88) = v57;
                    float v61 = *(float *)(a1 + 56);
                    *(float *)(a1 + 120) = v58;
                    if (v57 > v61)
                    {
                      uint64_t v62 = *(void *)(a1 + 48);
                      long long v63 = *v51;
                      *unint64_t v51 = *v52;
                      *(void *)(a1 + 48) = *(void *)(a1 + 80);
                      *uint64_t v52 = v63;
                      *(void *)(a1 + 80) = v62;
                      *(float *)(a1 + 56) = v57;
                      float v64 = *(float *)(a1 + 24);
                      *(float *)(a1 + 88) = v61;
                      if (v57 > v64)
                      {
                        uint64_t v137 = *(void *)(a1 + 16);
                        long long v129 = *(_OWORD *)a1;
                        *(_OWORD *)a1 = *v51;
                        *(void *)(a1 + 16) = *(void *)(a1 + 48);
                        *unint64_t v51 = v129;
                        *(void *)(a1 + 48) = v137;
                        *(float *)(a1 + 24) = v57;
                        *(float *)(a1 + 56) = v64;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 767)
          {
            uint64_t v65 = (void **)(a1 + 32);
            BOOL v67 = (void **)a1 == a2 || v65 == a2;
            if (a4)
            {
              if (!v67)
              {
                uint64_t v68 = 0;
                unint64_t v69 = a1;
                do
                {
                  uint64_t v70 = v65;
                  float v71 = *(float *)(v69 + 56);
                  if (v71 > *(float *)(v69 + 24))
                  {
                    int v72 = *v65;
                    *(void *)float v130 = *(void *)(v69 + 40);
                    *(void *)&v130[7] = *(void *)(v69 + 47);
                    char v73 = *(unsigned char *)(v69 + 55);
                    v65[1] = 0;
                    v65[2] = 0;
                    *uint64_t v65 = 0;
                    uint64_t v74 = v68;
                    while (1)
                    {
                      uint64_t v75 = a1 + v74;
                      int v76 = (void **)(a1 + v74 + 32);
                      if (*(char *)(a1 + v74 + 55) < 0) {
                        operator delete(*v76);
                      }
                      *(_OWORD *)int v76 = *(_OWORD *)v75;
                      *(void *)(a1 + v74 + 48) = *(void *)(v75 + 16);
                      *(unsigned char *)(v75 + 23) = 0;
                      *(unsigned char *)uint64_t v75 = 0;
                      *(_DWORD *)(v75 + 56) = *(_DWORD *)(v75 + 24);
                      if (!v74) {
                        break;
                      }
                      float v77 = *(float *)(a1 + v74 - 8);
                      v74 -= 32;
                      if (v71 <= v77)
                      {
                        uint64_t v78 = a1 + v74 + 32;
                        goto LABEL_93;
                      }
                    }
                    uint64_t v78 = a1;
LABEL_93:
                    if (*(char *)(v78 + 23) < 0) {
                      operator delete(*(void **)v78);
                    }
                    *(void *)uint64_t v78 = v72;
                    *(void *)(v78 + 8) = *(void *)v130;
                    *(void *)(v78 + 15) = *(void *)&v130[7];
                    *(unsigned char *)(v78 + 23) = v73;
                    *(float *)(v78 + 24) = v71;
                  }
                  uint64_t v65 = v70 + 4;
                  v68 += 32;
                  unint64_t v69 = (unint64_t)v70;
                }
                while (v70 + 4 != a2);
              }
            }
            else if (!v67)
            {
              unint64_t v112 = a1 - 8;
              do
              {
                int v113 = v65;
                float v114 = *(float *)(a1 + 56);
                if (v114 > *(float *)(a1 + 24))
                {
                  uint64_t v115 = *v65;
                  *(void *)double v133 = *(void *)(a1 + 40);
                  *(void *)&v133[7] = *(void *)(a1 + 47);
                  char v116 = *(unsigned char *)(a1 + 55);
                  v65[1] = 0;
                  v65[2] = 0;
                  *uint64_t v65 = 0;
                  unint64_t v117 = v112;
                  do
                  {
                    uint64_t v118 = (void **)(v117 + 40);
                    if (*(char *)(v117 + 63) < 0) {
                      operator delete(*v118);
                    }
                    *(_OWORD *)uint64_t v118 = *(_OWORD *)(v117 + 8);
                    *(void *)(v117 + 56) = *(void *)(v117 + 24);
                    *(unsigned char *)(v117 + 8) = 0;
                    unint64_t v119 = v117 + 8;
                    *(unsigned char *)(v117 + 31) = 0;
                    *(_DWORD *)(v117 + 64) = *(_DWORD *)(v117 + 32);
                    float v120 = *(float *)v117;
                    v117 -= 32;
                  }
                  while (v114 > v120);
                  if (*(char *)(v119 + 23) < 0) {
                    operator delete(*(void **)v119);
                  }
                  *(void *)unint64_t v119 = v115;
                  *(void *)(v119 + 15) = *(void *)&v133[7];
                  *(void *)(v119 + 8) = *(void *)v133;
                  *(unsigned char *)(v119 + 23) = v116;
                  *(float *)(v119 + 24) = v114;
                }
                uint64_t v65 = v113 + 4;
                v112 += 32;
                a1 = (unint64_t)v113;
              }
              while (v113 + 4 != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((void **)a1 != a2)
            {
              int64_t v79 = (unint64_t)(v12 - 2) >> 1;
              int64_t v80 = v79;
              do
              {
                int64_t v81 = v80;
                if (v79 >= v80)
                {
                  uint64_t v82 = (2 * v80) | 1;
                  unint64_t v83 = a1 + 32 * v82;
                  if (2 * v81 + 2 < v12 && *(float *)(v83 + 24) > *(float *)(v83 + 56))
                  {
                    v83 += 32;
                    uint64_t v82 = 2 * v81 + 2;
                  }
                  float v84 = *(float *)(a1 + 32 * v81 + 24);
                  if (*(float *)(v83 + 24) <= v84)
                  {
                    unint64_t v85 = a1 + 32 * v81;
                    float v122 = *(void **)v85;
                    *(void *)&v131[7] = *(void *)(v85 + 15);
                    *(void *)float v131 = *(void *)(v85 + 8);
                    char v86 = *(unsigned char *)(v85 + 23);
                    *(void *)unint64_t v85 = 0;
                    *(void *)(v85 + 8) = 0;
                    *(void *)(v85 + 16) = 0;
                    do
                    {
                      unint64_t v87 = v85;
                      unint64_t v85 = v83;
                      if (*(char *)(v87 + 23) < 0) {
                        operator delete(*(void **)v87);
                      }
                      long long v88 = *(_OWORD *)v85;
                      *(void *)(v87 + 16) = *(void *)(v85 + 16);
                      *(_OWORD *)unint64_t v87 = v88;
                      *(unsigned char *)(v85 + 23) = 0;
                      *(unsigned char *)unint64_t v85 = 0;
                      *(_DWORD *)(v87 + 24) = *(_DWORD *)(v85 + 24);
                      if (v79 < v82) {
                        break;
                      }
                      uint64_t v89 = 2 * v82;
                      uint64_t v82 = (2 * v82) | 1;
                      unint64_t v83 = a1 + 32 * v82;
                      uint64_t v90 = v89 + 2;
                      if (v90 < v12 && *(float *)(v83 + 24) > *(float *)(v83 + 56))
                      {
                        v83 += 32;
                        uint64_t v82 = v90;
                      }
                    }
                    while (*(float *)(v83 + 24) <= v84);
                    if (*(char *)(v85 + 23) < 0) {
                      operator delete(*(void **)v85);
                    }
                    *(void *)unint64_t v85 = v122;
                    *(void *)(v85 + 8) = *(void *)v131;
                    *(void *)(v85 + 15) = *(void *)&v131[7];
                    *(unsigned char *)(v85 + 23) = v86;
                    *(float *)(v85 + 24) = v84;
                  }
                }
                int64_t v80 = v81 - 1;
              }
              while (v81);
              uint64_t v91 = (unint64_t)v11 >> 5;
              do
              {
                uint64_t v92 = 0;
                int v93 = a2;
                int v94 = *(void **)a1;
                *(void *)float v125 = *(void *)(a1 + 8);
                *(void *)&v125[7] = *(void *)(a1 + 15);
                char v95 = *(unsigned char *)(a1 + 23);
                *(void *)(a1 + 8) = 0;
                *(void *)(a1 + 16) = 0;
                *(void *)a1 = 0;
                int v96 = *(_DWORD *)(a1 + 24);
                unint64_t v97 = a1;
                do
                {
                  unint64_t v98 = v97 + 32 * (v92 + 1);
                  uint64_t v99 = 2 * v92;
                  uint64_t v92 = (2 * v92) | 1;
                  uint64_t v100 = v99 + 2;
                  if (v100 < v91 && *(float *)(v98 + 24) > *(float *)(v98 + 56))
                  {
                    v98 += 32;
                    uint64_t v92 = v100;
                  }
                  if (*(char *)(v97 + 23) < 0) {
                    operator delete(*(void **)v97);
                  }
                  long long v101 = *(_OWORD *)v98;
                  *(void *)(v97 + 16) = *(void *)(v98 + 16);
                  *(_OWORD *)unint64_t v97 = v101;
                  *(unsigned char *)(v98 + 23) = 0;
                  *(unsigned char *)unint64_t v98 = 0;
                  *(_DWORD *)(v97 + 24) = *(_DWORD *)(v98 + 24);
                  unint64_t v97 = v98;
                }
                while (v92 <= (uint64_t)((unint64_t)(v91 - 2) >> 1));
                a2 -= 4;
                int v102 = *(char *)(v98 + 23);
                if ((void **)v98 == v93 - 4)
                {
                  if (v102 < 0) {
                    operator delete(*(void **)v98);
                  }
                  *(void *)unint64_t v98 = v94;
                  *(void *)(v98 + 8) = *(void *)v125;
                  *(void *)(v98 + 15) = *(void *)&v125[7];
                  *(unsigned char *)(v98 + 23) = v95;
                  *(_DWORD *)(v98 + 24) = v96;
                }
                else
                {
                  if (v102 < 0) {
                    operator delete(*(void **)v98);
                  }
                  long long v103 = *(_OWORD *)a2;
                  *(void *)(v98 + 16) = *(v93 - 2);
                  *(_OWORD *)unint64_t v98 = v103;
                  *((unsigned char *)v93 - 9) = 0;
                  *((unsigned char *)v93 - 32) = 0;
                  *(_DWORD *)(v98 + 24) = *((_DWORD *)v93 - 2);
                  if (*((char *)v93 - 9) < 0) {
                    operator delete(*a2);
                  }
                  *(v93 - 4) = v94;
                  *(void **)((char *)v93 - 17) = *(void **)&v125[7];
                  *(v93 - 3) = *(void **)v125;
                  *((unsigned char *)v93 - 9) = v95;
                  *((_DWORD *)v93 - 2) = v96;
                  uint64_t v104 = v98 + 32 - a1;
                  if (v104 >= 33)
                  {
                    unint64_t v105 = (((unint64_t)v104 >> 5) - 2) >> 1;
                    float v106 = *(float *)(v98 + 24);
                    if (*(float *)(a1 + 32 * v105 + 24) > v106)
                    {
                      uint64_t v107 = *(void **)v98;
                      *(void *)double v132 = *(void *)(v98 + 8);
                      *(void *)&v132[7] = *(void *)(v98 + 15);
                      char v108 = *(unsigned char *)(v98 + 23);
                      *(void *)(v98 + 8) = 0;
                      *(void *)(v98 + 16) = 0;
                      *(void *)unint64_t v98 = 0;
                      do
                      {
                        if (*(char *)(v98 + 23) < 0) {
                          operator delete(*(void **)v98);
                        }
                        unint64_t v109 = a1 + 32 * v105;
                        long long v110 = *(_OWORD *)v109;
                        *(void *)(v98 + 16) = *(void *)(v109 + 16);
                        *(_OWORD *)unint64_t v98 = v110;
                        *(unsigned char *)(v109 + 23) = 0;
                        *(unsigned char *)unint64_t v109 = 0;
                        *(_DWORD *)(v98 + 24) = *(_DWORD *)(v109 + 24);
                        if (!v105) {
                          break;
                        }
                        unint64_t v105 = (v105 - 1) >> 1;
                        unint64_t v98 = v109;
                      }
                      while (*(float *)(a1 + 32 * v105 + 24) > v106);
                      if (*(char *)(v109 + 23) < 0) {
                        operator delete(*(void **)v109);
                      }
                      *(void *)unint64_t v109 = v107;
                      *(void *)(v109 + 15) = *(void *)&v132[7];
                      *(void *)(v109 + 8) = *(void *)v132;
                      *(unsigned char *)(v109 + 23) = v108;
                      *(float *)(v109 + 24) = v106;
                    }
                  }
                }
              }
              while (v91-- > 2);
            }
            return;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          unint64_t v14 = a1 + 32 * ((unint64_t)v12 >> 1);
          if ((unint64_t)v11 <= 0x1000)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)v14, (float *)a1, v121);
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)a1, (float *)v14, v121);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)(a1 + 32), (float *)(v14 - 32), (float *)a2 - 16);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)(a1 + 64), (float *)(a1 + 32 + 32 * v13), (float *)a2 - 24);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)(v14 - 32), (float *)v14, (float *)(a1 + 32 + 32 * v13));
            uint64_t v134 = *(void *)(a1 + 16);
            long long v126 = *(_OWORD *)a1;
            uint64_t v15 = *(void *)(v14 + 16);
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(void *)(a1 + 16) = v15;
            *(void *)(v14 + 16) = v134;
            *(_OWORD *)unint64_t v14 = v126;
            int v16 = *(_DWORD *)(a1 + 24);
            *(_DWORD *)(a1 + 24) = *(_DWORD *)(v14 + 24);
            *(_DWORD *)(v14 + 24) = v16;
          }
          --a3;
          if (a4) {
            break;
          }
          float v17 = *(float *)(a1 + 24);
          if (*(float *)(a1 - 8) > v17) {
            goto LABEL_12;
          }
          uint64_t v36 = *(void *)a1;
          *(void *)float v124 = *(void *)(a1 + 8);
          *(void *)&v124[7] = *(void *)(a1 + 15);
          char v37 = *(unsigned char *)(a1 + 23);
          *(void *)(a1 + 8) = 0;
          *(void *)(a1 + 16) = 0;
          *(void *)a1 = 0;
          if (v17 <= *((float *)a2 - 2))
          {
            unint64_t v40 = a1 + 32;
            do
            {
              unint64_t v10 = v40;
              if (v40 >= (unint64_t)a2) {
                break;
              }
              float v41 = *(float *)(v40 + 24);
              v40 += 32;
            }
            while (v17 <= v41);
          }
          else
          {
            unint64_t v38 = a1;
            do
            {
              unint64_t v10 = v38 + 32;
              float v39 = *(float *)(v38 + 56);
              v38 += 32;
            }
            while (v17 <= v39);
          }
          unint64_t v42 = a2;
          if (v10 < (unint64_t)a2)
          {
            uint64_t v43 = a2;
            do
            {
              unint64_t v42 = v43 - 4;
              float v44 = *((float *)v43 - 2);
              v43 -= 4;
            }
            while (v17 > v44);
          }
          while (v10 < (unint64_t)v42)
          {
            double v135 = *(void **)(v10 + 16);
            long long v127 = *(_OWORD *)v10;
            long long v45 = *(_OWORD *)v42;
            *(void *)(v10 + 16) = v42[2];
            *(_OWORD *)unint64_t v10 = v45;
            v42[2] = v135;
            *(_OWORD *)unint64_t v42 = v127;
            LODWORD(v45) = *(_DWORD *)(v10 + 24);
            *(_DWORD *)(v10 + 24) = *((_DWORD *)v42 + 6);
            *((_DWORD *)v42 + 6) = v45;
            do
            {
              float v46 = *(float *)(v10 + 56);
              v10 += 32;
            }
            while (v17 <= v46);
            do
            {
              float v47 = *((float *)v42 - 2);
              v42 -= 4;
            }
            while (v17 > v47);
          }
          float32x2_t v48 = (void **)(v10 - 32);
          BOOL v4 = v10 - 32 >= a1;
          BOOL v5 = v10 - 32 == a1;
          if (v10 - 32 != a1)
          {
            if (*(char *)(a1 + 23) < 0) {
              operator delete(*(void **)a1);
            }
            long long v49 = *(_OWORD *)v48;
            *(void *)(a1 + 16) = *(void *)(v10 - 16);
            *(_OWORD *)a1 = v49;
            *(unsigned char *)(v10 - 9) = 0;
            *(unsigned char *)(v10 - 32) = 0;
            *(_DWORD *)(a1 + 24) = *(_DWORD *)(v10 - 8);
          }
          if (*(char *)(v10 - 9) < 0) {
            operator delete(*v48);
          }
          a4 = 0;
          *(void *)(v10 - 32) = v36;
          *(void *)(v10 - 17) = *(void *)&v124[7];
          *(void *)(v10 - 24) = *(void *)v124;
          *(unsigned char *)(v10 - 9) = v37;
          *(float *)(v10 - 8) = v17;
        }
        float v17 = *(float *)(a1 + 24);
LABEL_12:
        uint64_t v18 = *(void *)a1;
        *(void *)float v123 = *(void *)(a1 + 8);
        *(void *)&v123[7] = *(void *)(a1 + 15);
        char v19 = *(unsigned char *)(a1 + 23);
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
        *(void *)a1 = 0;
        unint64_t v20 = a1;
        do
        {
          unint64_t v21 = v20;
          v20 += 32;
        }
        while (*(float *)(v21 + 56) > v17);
        uint64_t v22 = a2;
        if (v21 == a1)
        {
          int v25 = a2;
          while (v20 < (unint64_t)v25)
          {
            uint64_t v23 = v25 - 4;
            float v26 = *((float *)v25 - 2);
            v25 -= 4;
            if (v26 > v17) {
              goto LABEL_22;
            }
          }
          uint64_t v23 = v25;
        }
        else
        {
          do
          {
            uint64_t v23 = v22 - 4;
            float v24 = *((float *)v22 - 2);
            v22 -= 4;
          }
          while (v24 <= v17);
        }
LABEL_22:
        unint64_t v10 = v20;
        if (v20 < (unint64_t)v23)
        {
          unint64_t v27 = (unint64_t)v23;
          do
          {
            long long v28 = *(_OWORD *)v10;
            uint64_t v29 = *(void *)(v10 + 16);
            uint64_t v30 = *(void *)(v27 + 16);
            *(_OWORD *)unint64_t v10 = *(_OWORD *)v27;
            *(void *)(v10 + 16) = v30;
            *(void *)(v27 + 16) = v29;
            *(_OWORD *)unint64_t v27 = v28;
            LODWORD(v28) = *(_DWORD *)(v10 + 24);
            *(_DWORD *)(v10 + 24) = *(_DWORD *)(v27 + 24);
            *(_DWORD *)(v27 + 24) = v28;
            do
            {
              float v31 = *(float *)(v10 + 56);
              v10 += 32;
            }
            while (v31 > v17);
            do
            {
              float v32 = *(float *)(v27 - 8);
              v27 -= 32;
            }
            while (v32 <= v17);
          }
          while (v10 < v27);
        }
        uint64_t v33 = (void **)(v10 - 32);
        if (v10 - 32 != a1)
        {
          if (*(char *)(a1 + 23) < 0) {
            operator delete(*(void **)a1);
          }
          long long v34 = *(_OWORD *)v33;
          *(void *)(a1 + 16) = *(void *)(v10 - 16);
          *(_OWORD *)a1 = v34;
          *(unsigned char *)(v10 - 9) = 0;
          *(unsigned char *)(v10 - 32) = 0;
          *(_DWORD *)(a1 + 24) = *(_DWORD *)(v10 - 8);
        }
        if (*(char *)(v10 - 9) < 0) {
          operator delete(*v33);
        }
        *(void *)(v10 - 32) = v18;
        *(void *)(v10 - 17) = *(void *)&v123[7];
        *(void *)(v10 - 24) = *(void *)v123;
        *(unsigned char *)(v10 - 9) = v19;
        *(float *)(v10 - 8) = v17;
        if (v20 >= (unint64_t)v23) {
          break;
        }
LABEL_37:
        std::__introsort<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *,false>(a1, v10 - 32, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v35 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, v10 - 32);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v35) {
        goto LABEL_37;
      }
    }
    a2 = (void **)(v10 - 32);
    if (!v35) {
      continue;
    }
    break;
  }
}

float std::vector<std::pair<std::string,float>>::__construct_one_at_end[abi:ne180100]<std::pair<std::string,float> const&>(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(*(std::string **)(a1 + 8), *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *(void *)(v4 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }
  float result = *((float *)a2 + 6);
  *(float *)(v4 + 24) = result;
  *(void *)(a1 + 8) = v4 + 32;
  return result;
}

void sub_1A3EAC314(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<std::string,float>>::__push_back_slow_path<std::pair<std::string,float> const&>(uint64_t *a1, long long *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 5;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 59) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  long long v6 = a1 + 2;
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 4 > v3) {
    unint64_t v3 = v7 >> 4;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v8 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v3;
  }
  uint64_t v18 = v6;
  if (v8)
  {
    unint64_t v10 = std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(v8);
  }
  else
  {
    unint64_t v10 = 0;
    uint64_t v9 = 0;
  }
  uint64_t v11 = (std::string *)&v10[8 * v2];
  v15[0] = v10;
  v15[1] = v11;
  int v16 = v11;
  float v17 = (char *)&v10[8 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    uint64_t v11 = v16;
  }
  else
  {
    long long v12 = *a2;
    v11->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
  }
  v10[8 * v2 + 6] = *((_DWORD *)a2 + 6);
  int v16 = (std::string *)((char *)v11 + 32);
  std::vector<std::pair<std::string,float>>::__swap_out_circular_buffer(a1, v15);
  uint64_t v13 = a1[1];
  std::__split_buffer<std::pair<std::string,float>>::~__split_buffer((uint64_t)v15);
  return v13;
}

void sub_1A3EAC418(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<std::string,float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

float std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(long long *a1, float *a2, float *a3)
{
  unint64_t v3 = a2 + 6;
  float result = a2[6];
  long long v5 = (float *)a1 + 6;
  float v6 = a3[6];
  if (result > *((float *)a1 + 6))
  {
    if (v6 <= result)
    {
      uint64_t v16 = *((void *)a1 + 2);
      long long v17 = *a1;
      uint64_t v18 = *((void *)a2 + 2);
      *a1 = *(_OWORD *)a2;
      *((void *)a1 + 2) = v18;
      *(_OWORD *)a2 = v17;
      *((void *)a2 + 2) = v16;
      float result = *((float *)a1 + 6);
      *((float *)a1 + 6) = a2[6];
      a2[6] = result;
      if (a3[6] <= result) {
        return result;
      }
      uint64_t v19 = *((void *)a2 + 2);
      long long v20 = *(_OWORD *)a2;
      uint64_t v21 = *((void *)a3 + 2);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((void *)a2 + 2) = v21;
      *(_OWORD *)a3 = v20;
      *((void *)a3 + 2) = v19;
      long long v5 = a2 + 6;
    }
    else
    {
      uint64_t v7 = *((void *)a1 + 2);
      long long v8 = *a1;
      uint64_t v9 = *((void *)a3 + 2);
      *a1 = *(_OWORD *)a3;
      *((void *)a1 + 2) = v9;
      *(_OWORD *)a3 = v8;
      *((void *)a3 + 2) = v7;
    }
    unint64_t v3 = a3 + 6;
    goto LABEL_10;
  }
  if (v6 > result)
  {
    uint64_t v10 = *((void *)a2 + 2);
    long long v11 = *(_OWORD *)a2;
    uint64_t v12 = *((void *)a3 + 2);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((void *)a2 + 2) = v12;
    *(_OWORD *)a3 = v11;
    *((void *)a3 + 2) = v10;
    *(float *)&long long v11 = a2[6];
    a2[6] = a3[6];
    *((_DWORD *)a3 + 6) = v11;
    float result = a2[6];
    if (result > *v5)
    {
      uint64_t v13 = *((void *)a1 + 2);
      long long v14 = *a1;
      uint64_t v15 = *((void *)a2 + 2);
      *a1 = *(_OWORD *)a2;
      *((void *)a1 + 2) = v15;
      *(_OWORD *)a2 = v14;
      *((void *)a2 + 2) = v13;
LABEL_10:
      float result = *v5;
      *long long v5 = *v3;
      *unint64_t v3 = result;
    }
  }
  return result;
}

float std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(uint64_t a1, long long *a2, float *a3, float *a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)a1, (float *)a2, a3);
  float result = a4[6];
  if (result > a3[6])
  {
    uint64_t v9 = *((void *)a3 + 2);
    long long v10 = *(_OWORD *)a3;
    uint64_t v11 = *((void *)a4 + 2);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *((void *)a3 + 2) = v11;
    *(_OWORD *)a4 = v10;
    *((void *)a4 + 2) = v9;
    *(float *)&long long v10 = a3[6];
    a3[6] = a4[6];
    *((_DWORD *)a4 + 6) = v10;
    float result = a3[6];
    if (result > *((float *)a2 + 6))
    {
      uint64_t v12 = *((void *)a2 + 2);
      long long v13 = *a2;
      uint64_t v14 = *((void *)a3 + 2);
      *a2 = *(_OWORD *)a3;
      *((void *)a2 + 2) = v14;
      *(_OWORD *)a3 = v13;
      *((void *)a3 + 2) = v12;
      LODWORD(v13) = *((_DWORD *)a2 + 6);
      *((float *)a2 + 6) = a3[6];
      *((_DWORD *)a3 + 6) = v13;
      float result = *((float *)a2 + 6);
      if (result > *(float *)(a1 + 24))
      {
        uint64_t v15 = *(void *)(a1 + 16);
        long long v16 = *(_OWORD *)a1;
        uint64_t v17 = *((void *)a2 + 2);
        *(_OWORD *)a1 = *a2;
        *(void *)(a1 + 16) = v17;
        *a2 = v16;
        *((void *)a2 + 2) = v15;
        float result = *(float *)(a1 + 24);
        *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 + 6);
        *((float *)a2 + 6) = result;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 8) > *(float *)(a1 + 24))
      {
        uint64_t v6 = *(void *)(a1 + 16);
        long long v7 = *(_OWORD *)a1;
        uint64_t v8 = *(void *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(void *)(a1 + 16) = v8;
        *(_OWORD *)(a2 - 32) = v7;
        *(void *)(a2 - 16) = v6;
        LODWORD(v7) = *(_DWORD *)(a1 + 24);
        *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)a1, (float *)(a1 + 32), (float *)(a2 - 32));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, (long long *)(a1 + 32), (float *)(a1 + 64), (float *)(a2 - 32));
      return 1;
    case 5:
      uint64_t v21 = (long long *)(a1 + 32);
      uint64_t v22 = (long long *)(a1 + 64);
      uint64_t v23 = (long long *)(a1 + 96);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, (long long *)(a1 + 32), (float *)(a1 + 64), (float *)(a1 + 96));
      if (*(float *)(a2 - 8) > *(float *)(a1 + 120))
      {
        uint64_t v24 = *(void *)(a1 + 112);
        long long v25 = *v23;
        uint64_t v26 = *(void *)(a2 - 16);
        *uint64_t v23 = *(_OWORD *)(a2 - 32);
        *(void *)(a1 + 112) = v26;
        *(_OWORD *)(a2 - 32) = v25;
        *(void *)(a2 - 16) = v24;
        LODWORD(v25) = *(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 120) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v25;
        float v27 = *(float *)(a1 + 120);
        float v28 = *(float *)(a1 + 88);
        if (v27 > v28)
        {
          uint64_t v29 = *(void *)(a1 + 80);
          long long v30 = *v22;
          long long *v22 = *v23;
          *(void *)(a1 + 80) = *(void *)(a1 + 112);
          *uint64_t v23 = v30;
          *(void *)(a1 + 112) = v29;
          *(float *)(a1 + 88) = v27;
          float v31 = *(float *)(a1 + 56);
          *(float *)(a1 + 120) = v28;
          if (v27 > v31)
          {
            uint64_t v32 = *(void *)(a1 + 48);
            long long v33 = *v21;
            long long *v21 = *v22;
            *(void *)(a1 + 48) = *(void *)(a1 + 80);
            long long *v22 = v33;
            *(void *)(a1 + 80) = v32;
            *(float *)(a1 + 56) = v27;
            float v34 = *(float *)(a1 + 24);
            *(float *)(a1 + 88) = v31;
            if (v27 > v34)
            {
              uint64_t v35 = *(void *)(a1 + 16);
              long long v36 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v21;
              *(void *)(a1 + 16) = *(void *)(a1 + 48);
              long long *v21 = v36;
              *(void *)(a1 + 48) = v35;
              *(float *)(a1 + 24) = v27;
              *(float *)(a1 + 56) = v34;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v9 = a1 + 64;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)a1, (float *)(a1 + 32), (float *)(a1 + 64));
      uint64_t v10 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    float v13 = *(float *)(v10 + 24);
    if (v13 > *(float *)(v9 + 24))
    {
      uint64_t v14 = *(void *)v10;
      *(void *)char v37 = *(void *)(v10 + 8);
      *(void *)&v37[7] = *(void *)(v10 + 15);
      char v15 = *(unsigned char *)(v10 + 23);
      *(void *)(v10 + 8) = 0;
      *(void *)(v10 + 16) = 0;
      *(void *)uint64_t v10 = 0;
      uint64_t v16 = v11;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        uint64_t v18 = (void **)(a1 + v16 + 96);
        if (*(char *)(a1 + v16 + 119) < 0) {
          operator delete(*v18);
        }
        *(_OWORD *)uint64_t v18 = *(_OWORD *)(v17 + 64);
        *(void *)(a1 + v16 + 112) = *(void *)(v17 + 80);
        *(unsigned char *)(v17 + 87) = 0;
        *(unsigned char *)(v17 + 64) = 0;
        *(_DWORD *)(v17 + 120) = *(_DWORD *)(v17 + 88);
        if (v16 == -64) {
          break;
        }
        float v19 = *(float *)(a1 + v16 + 56);
        v16 -= 32;
        if (v13 <= v19)
        {
          uint64_t v20 = a1 + v16 + 96;
          goto LABEL_14;
        }
      }
      uint64_t v20 = a1;
LABEL_14:
      if (*(char *)(v20 + 23) < 0) {
        operator delete(*(void **)v20);
      }
      *(void *)uint64_t v20 = v14;
      *(void *)(v20 + 8) = *(void *)v37;
      *(void *)(v20 + 15) = *(void *)&v37[7];
      *(unsigned char *)(v20 + 23) = v15;
      *(float *)(v20 + 24) = v13;
      if (++v12 == 8) {
        return v10 + 32 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 32;
    v10 += 32;
    if (v10 == a2) {
      return 1;
    }
  }
}

void ImageClassifier_getLabels(uint64_t *a1, void **a2, void *a3, unint64_t a4, float a5)
{
  unint64_t v36 = 0;
  char v37 = 0;
  unint64_t v38 = 0;
  if (a2)
  {
    uint64_t v9 = a2;
    do
    {
      uint64_t v10 = v9 + 2;
      if (*((char *)v9 + 39) < 0)
      {
        std::string::__init_copy_ctor_external(&v35, (const std::string::value_type *)v9[2], (std::string::size_type)v9[3]);
      }
      else
      {
        *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *v10;
        v35.__r_.__value_.__r.__words[2] = (std::string::size_type)v9[4];
      }
      float v11 = *((float *)v9 + 10);
      int v12 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a3, (unsigned __int8 *)&v35);
      float v13 = a5;
      if (v12)
      {
        float v13 = a5;
        if (*((float *)v12 + 10) >= a5) {
          float v13 = *((float *)v12 + 10);
        }
      }
      if (v11 >= v13)
      {
        if (*((char *)v9 + 39) < 0)
        {
          std::string::__init_copy_ctor_external(&v33, (const std::string::value_type *)v9[2], (std::string::size_type)v9[3]);
          float v11 = *((float *)v9 + 10);
        }
        else
        {
          *(_OWORD *)&v33.__r_.__value_.__l.__data_ = *v10;
          v33.__r_.__value_.__r.__words[2] = (std::string::size_type)v9[4];
        }
        float v34 = v11;
        uint64_t v14 = v37;
        if ((unint64_t)v37 >= v38)
        {
          uint64_t v16 = (uint64_t)((uint64_t)v37 - v36) >> 5;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 59) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v18 = v38 - v36;
          if ((uint64_t)(v38 - v36) >> 4 > v17) {
            unint64_t v17 = v18 >> 4;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v17;
          }
          v39[4] = (void **)&v38;
          uint64_t v20 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(v19);
          uint64_t v21 = &v20[4 * v16];
          v39[0] = v20;
          v39[1] = v21;
          v39[3] = &v20[4 * v22];
          *(std::string *)uint64_t v21 = v33;
          memset(&v33, 0, sizeof(v33));
          *((float *)v21 + 6) = v11;
          void v39[2] = v21 + 4;
          std::vector<std::pair<std::string,float>>::__swap_out_circular_buffer((uint64_t *)&v36, v39);
          char v15 = v37;
          std::__split_buffer<std::pair<std::string,float>>::~__split_buffer((uint64_t)v39);
        }
        else
        {
          *(_OWORD *)char v37 = *(_OWORD *)&v33.__r_.__value_.__l.__data_;
          v14[2] = (void *)v33.__r_.__value_.__r.__words[2];
          *((float *)v14 + 6) = v11;
          char v15 = v14 + 4;
        }
        char v37 = v15;
      }
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      uint64_t v9 = (void **)*v9;
    }
    while (v9);
    unint64_t v23 = v36;
    a2 = v37;
  }
  else
  {
    unint64_t v23 = 0;
  }
  unint64_t v24 = 126 - 2 * __clz((uint64_t)((uint64_t)a2 - v23) >> 5);
  if (a2 == (void **)v23) {
    uint64_t v25 = 0;
  }
  else {
    uint64_t v25 = v24;
  }
  std::__introsort<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *,false>(v23, a2, v25, 1);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v26 = v36;
  unint64_t v27 = (uint64_t)((uint64_t)v37 - v36) >> 5;
  if (v27 >= a4) {
    unint64_t v27 = a4;
  }
  if (v27)
  {
    uint64_t v28 = 0;
    unint64_t v29 = 0;
    unint64_t v30 = 0;
    do
    {
      float v31 = (long long *)(v26 + v28);
      if (v29 >= a1[2])
      {
        unint64_t v29 = std::vector<std::pair<std::string,float>>::__push_back_slow_path<std::pair<std::string,float> const&>(a1, v31);
      }
      else
      {
        std::vector<std::pair<std::string,float>>::__construct_one_at_end[abi:ne180100]<std::pair<std::string,float> const&>((uint64_t)a1, v31);
        v29 += 32;
      }
      a1[1] = v29;
      ++v30;
      uint64_t v26 = v36;
      unint64_t v32 = (uint64_t)((uint64_t)v37 - v36) >> 5;
      if (v32 >= a4) {
        unint64_t v32 = a4;
      }
      v28 += 32;
    }
    while (v30 < v32);
  }
  v39[0] = (void **)&v36;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](v39);
}

void sub_1A3EACC60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  a9 = &a23;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a9);
  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *,false>(unint64_t a1, void **a2, uint64_t a3, char a4)
{
  while (2)
  {
    float v121 = (float *)(a2 - 4);
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          uint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 5;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return;
              case 2:
                if (*((float *)a2 - 2) > *(float *)(a1 + 24))
                {
                  double v136 = *(void **)(a1 + 16);
                  long long v128 = *(_OWORD *)a1;
                  long long v50 = *(_OWORD *)v121;
                  *(void *)(a1 + 16) = *(a2 - 2);
                  *(_OWORD *)a1 = v50;
                  *(a2 - 2) = v136;
                  *(_OWORD *)float v121 = v128;
                  LODWORD(v50) = *(_DWORD *)(a1 + 24);
                  *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 - 2);
                  *((_DWORD *)a2 - 2) = v50;
                }
                break;
              case 3:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)a1, (float *)(a1 + 32), v121);
                break;
              case 4:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, (long long *)(a1 + 32), (float *)(a1 + 64), v121);
                break;
              case 5:
                unint64_t v51 = (long long *)(a1 + 32);
                uint64_t v52 = (long long *)(a1 + 64);
                unint64_t v53 = (long long *)(a1 + 96);
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, (long long *)(a1 + 32), (float *)(a1 + 64), (float *)(a1 + 96));
                if (*((float *)a2 - 2) > *(float *)(a1 + 120))
                {
                  long long v54 = *v53;
                  uint64_t v55 = *(void **)(a1 + 112);
                  uint64_t v56 = (uint64_t)*(a2 - 2);
                  *unint64_t v53 = *(_OWORD *)v121;
                  *(void *)(a1 + 112) = v56;
                  *(a2 - 2) = v55;
                  *(_OWORD *)float v121 = v54;
                  LODWORD(v54) = *(_DWORD *)(a1 + 120);
                  *(_DWORD *)(a1 + 120) = *((_DWORD *)a2 - 2);
                  *((_DWORD *)a2 - 2) = v54;
                  float v57 = *(float *)(a1 + 120);
                  float v58 = *(float *)(a1 + 88);
                  if (v57 > v58)
                  {
                    uint64_t v59 = *(void *)(a1 + 80);
                    long long v60 = *v52;
                    *uint64_t v52 = *v53;
                    *(void *)(a1 + 80) = *(void *)(a1 + 112);
                    *unint64_t v53 = v60;
                    *(void *)(a1 + 112) = v59;
                    *(float *)(a1 + 88) = v57;
                    float v61 = *(float *)(a1 + 56);
                    *(float *)(a1 + 120) = v58;
                    if (v57 > v61)
                    {
                      uint64_t v62 = *(void *)(a1 + 48);
                      long long v63 = *v51;
                      *unint64_t v51 = *v52;
                      *(void *)(a1 + 48) = *(void *)(a1 + 80);
                      *uint64_t v52 = v63;
                      *(void *)(a1 + 80) = v62;
                      *(float *)(a1 + 56) = v57;
                      float v64 = *(float *)(a1 + 24);
                      *(float *)(a1 + 88) = v61;
                      if (v57 > v64)
                      {
                        uint64_t v137 = *(void *)(a1 + 16);
                        long long v129 = *(_OWORD *)a1;
                        *(_OWORD *)a1 = *v51;
                        *(void *)(a1 + 16) = *(void *)(a1 + 48);
                        *unint64_t v51 = v129;
                        *(void *)(a1 + 48) = v137;
                        *(float *)(a1 + 24) = v57;
                        *(float *)(a1 + 56) = v64;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 767)
          {
            uint64_t v65 = (void **)(a1 + 32);
            BOOL v67 = (void **)a1 == a2 || v65 == a2;
            if (a4)
            {
              if (!v67)
              {
                uint64_t v68 = 0;
                unint64_t v69 = a1;
                do
                {
                  uint64_t v70 = v65;
                  float v71 = *(float *)(v69 + 56);
                  if (v71 > *(float *)(v69 + 24))
                  {
                    int v72 = *v65;
                    *(void *)float v130 = *(void *)(v69 + 40);
                    *(void *)&v130[7] = *(void *)(v69 + 47);
                    char v73 = *(unsigned char *)(v69 + 55);
                    v65[1] = 0;
                    v65[2] = 0;
                    *uint64_t v65 = 0;
                    uint64_t v74 = v68;
                    while (1)
                    {
                      uint64_t v75 = a1 + v74;
                      int v76 = (void **)(a1 + v74 + 32);
                      if (*(char *)(a1 + v74 + 55) < 0) {
                        operator delete(*v76);
                      }
                      *(_OWORD *)int v76 = *(_OWORD *)v75;
                      *(void *)(a1 + v74 + 48) = *(void *)(v75 + 16);
                      *(unsigned char *)(v75 + 23) = 0;
                      *(unsigned char *)uint64_t v75 = 0;
                      *(_DWORD *)(v75 + 56) = *(_DWORD *)(v75 + 24);
                      if (!v74) {
                        break;
                      }
                      float v77 = *(float *)(a1 + v74 - 8);
                      v74 -= 32;
                      if (v71 <= v77)
                      {
                        uint64_t v78 = a1 + v74 + 32;
                        goto LABEL_93;
                      }
                    }
                    uint64_t v78 = a1;
LABEL_93:
                    if (*(char *)(v78 + 23) < 0) {
                      operator delete(*(void **)v78);
                    }
                    *(void *)uint64_t v78 = v72;
                    *(void *)(v78 + 8) = *(void *)v130;
                    *(void *)(v78 + 15) = *(void *)&v130[7];
                    *(unsigned char *)(v78 + 23) = v73;
                    *(float *)(v78 + 24) = v71;
                  }
                  uint64_t v65 = v70 + 4;
                  v68 += 32;
                  unint64_t v69 = (unint64_t)v70;
                }
                while (v70 + 4 != a2);
              }
            }
            else if (!v67)
            {
              unint64_t v112 = a1 - 8;
              do
              {
                int v113 = v65;
                float v114 = *(float *)(a1 + 56);
                if (v114 > *(float *)(a1 + 24))
                {
                  uint64_t v115 = *v65;
                  *(void *)double v133 = *(void *)(a1 + 40);
                  *(void *)&v133[7] = *(void *)(a1 + 47);
                  char v116 = *(unsigned char *)(a1 + 55);
                  v65[1] = 0;
                  v65[2] = 0;
                  *uint64_t v65 = 0;
                  unint64_t v117 = v112;
                  do
                  {
                    uint64_t v118 = (void **)(v117 + 40);
                    if (*(char *)(v117 + 63) < 0) {
                      operator delete(*v118);
                    }
                    *(_OWORD *)uint64_t v118 = *(_OWORD *)(v117 + 8);
                    *(void *)(v117 + 56) = *(void *)(v117 + 24);
                    *(unsigned char *)(v117 + 8) = 0;
                    unint64_t v119 = v117 + 8;
                    *(unsigned char *)(v117 + 31) = 0;
                    *(_DWORD *)(v117 + 64) = *(_DWORD *)(v117 + 32);
                    float v120 = *(float *)v117;
                    v117 -= 32;
                  }
                  while (v114 > v120);
                  if (*(char *)(v119 + 23) < 0) {
                    operator delete(*(void **)v119);
                  }
                  *(void *)unint64_t v119 = v115;
                  *(void *)(v119 + 15) = *(void *)&v133[7];
                  *(void *)(v119 + 8) = *(void *)v133;
                  *(unsigned char *)(v119 + 23) = v116;
                  *(float *)(v119 + 24) = v114;
                }
                uint64_t v65 = v113 + 4;
                v112 += 32;
                a1 = (unint64_t)v113;
              }
              while (v113 + 4 != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((void **)a1 != a2)
            {
              int64_t v79 = (unint64_t)(v12 - 2) >> 1;
              int64_t v80 = v79;
              do
              {
                int64_t v81 = v80;
                if (v79 >= v80)
                {
                  uint64_t v82 = (2 * v80) | 1;
                  unint64_t v83 = a1 + 32 * v82;
                  if (2 * v81 + 2 < v12 && *(float *)(v83 + 24) > *(float *)(v83 + 56))
                  {
                    v83 += 32;
                    uint64_t v82 = 2 * v81 + 2;
                  }
                  float v84 = *(float *)(a1 + 32 * v81 + 24);
                  if (*(float *)(v83 + 24) <= v84)
                  {
                    unint64_t v85 = a1 + 32 * v81;
                    float v122 = *(void **)v85;
                    *(void *)&v131[7] = *(void *)(v85 + 15);
                    *(void *)float v131 = *(void *)(v85 + 8);
                    char v86 = *(unsigned char *)(v85 + 23);
                    *(void *)unint64_t v85 = 0;
                    *(void *)(v85 + 8) = 0;
                    *(void *)(v85 + 16) = 0;
                    do
                    {
                      unint64_t v87 = v85;
                      unint64_t v85 = v83;
                      if (*(char *)(v87 + 23) < 0) {
                        operator delete(*(void **)v87);
                      }
                      long long v88 = *(_OWORD *)v85;
                      *(void *)(v87 + 16) = *(void *)(v85 + 16);
                      *(_OWORD *)unint64_t v87 = v88;
                      *(unsigned char *)(v85 + 23) = 0;
                      *(unsigned char *)unint64_t v85 = 0;
                      *(_DWORD *)(v87 + 24) = *(_DWORD *)(v85 + 24);
                      if (v79 < v82) {
                        break;
                      }
                      uint64_t v89 = 2 * v82;
                      uint64_t v82 = (2 * v82) | 1;
                      unint64_t v83 = a1 + 32 * v82;
                      uint64_t v90 = v89 + 2;
                      if (v90 < v12 && *(float *)(v83 + 24) > *(float *)(v83 + 56))
                      {
                        v83 += 32;
                        uint64_t v82 = v90;
                      }
                    }
                    while (*(float *)(v83 + 24) <= v84);
                    if (*(char *)(v85 + 23) < 0) {
                      operator delete(*(void **)v85);
                    }
                    *(void *)unint64_t v85 = v122;
                    *(void *)(v85 + 8) = *(void *)v131;
                    *(void *)(v85 + 15) = *(void *)&v131[7];
                    *(unsigned char *)(v85 + 23) = v86;
                    *(float *)(v85 + 24) = v84;
                  }
                }
                int64_t v80 = v81 - 1;
              }
              while (v81);
              uint64_t v91 = (unint64_t)v11 >> 5;
              do
              {
                uint64_t v92 = 0;
                int v93 = a2;
                int v94 = *(void **)a1;
                *(void *)float v125 = *(void *)(a1 + 8);
                *(void *)&v125[7] = *(void *)(a1 + 15);
                char v95 = *(unsigned char *)(a1 + 23);
                *(void *)(a1 + 8) = 0;
                *(void *)(a1 + 16) = 0;
                *(void *)a1 = 0;
                int v96 = *(_DWORD *)(a1 + 24);
                unint64_t v97 = a1;
                do
                {
                  unint64_t v98 = v97 + 32 * (v92 + 1);
                  uint64_t v99 = 2 * v92;
                  uint64_t v92 = (2 * v92) | 1;
                  uint64_t v100 = v99 + 2;
                  if (v100 < v91 && *(float *)(v98 + 24) > *(float *)(v98 + 56))
                  {
                    v98 += 32;
                    uint64_t v92 = v100;
                  }
                  if (*(char *)(v97 + 23) < 0) {
                    operator delete(*(void **)v97);
                  }
                  long long v101 = *(_OWORD *)v98;
                  *(void *)(v97 + 16) = *(void *)(v98 + 16);
                  *(_OWORD *)unint64_t v97 = v101;
                  *(unsigned char *)(v98 + 23) = 0;
                  *(unsigned char *)unint64_t v98 = 0;
                  *(_DWORD *)(v97 + 24) = *(_DWORD *)(v98 + 24);
                  unint64_t v97 = v98;
                }
                while (v92 <= (uint64_t)((unint64_t)(v91 - 2) >> 1));
                a2 -= 4;
                int v102 = *(char *)(v98 + 23);
                if ((void **)v98 == v93 - 4)
                {
                  if (v102 < 0) {
                    operator delete(*(void **)v98);
                  }
                  *(void *)unint64_t v98 = v94;
                  *(void *)(v98 + 8) = *(void *)v125;
                  *(void *)(v98 + 15) = *(void *)&v125[7];
                  *(unsigned char *)(v98 + 23) = v95;
                  *(_DWORD *)(v98 + 24) = v96;
                }
                else
                {
                  if (v102 < 0) {
                    operator delete(*(void **)v98);
                  }
                  long long v103 = *(_OWORD *)a2;
                  *(void *)(v98 + 16) = *(v93 - 2);
                  *(_OWORD *)unint64_t v98 = v103;
                  *((unsigned char *)v93 - 9) = 0;
                  *((unsigned char *)v93 - 32) = 0;
                  *(_DWORD *)(v98 + 24) = *((_DWORD *)v93 - 2);
                  if (*((char *)v93 - 9) < 0) {
                    operator delete(*a2);
                  }
                  *(v93 - 4) = v94;
                  *(void **)((char *)v93 - 17) = *(void **)&v125[7];
                  *(v93 - 3) = *(void **)v125;
                  *((unsigned char *)v93 - 9) = v95;
                  *((_DWORD *)v93 - 2) = v96;
                  uint64_t v104 = v98 + 32 - a1;
                  if (v104 >= 33)
                  {
                    unint64_t v105 = (((unint64_t)v104 >> 5) - 2) >> 1;
                    float v106 = *(float *)(v98 + 24);
                    if (*(float *)(a1 + 32 * v105 + 24) > v106)
                    {
                      uint64_t v107 = *(void **)v98;
                      *(void *)double v132 = *(void *)(v98 + 8);
                      *(void *)&v132[7] = *(void *)(v98 + 15);
                      char v108 = *(unsigned char *)(v98 + 23);
                      *(void *)(v98 + 8) = 0;
                      *(void *)(v98 + 16) = 0;
                      *(void *)unint64_t v98 = 0;
                      do
                      {
                        if (*(char *)(v98 + 23) < 0) {
                          operator delete(*(void **)v98);
                        }
                        unint64_t v109 = a1 + 32 * v105;
                        long long v110 = *(_OWORD *)v109;
                        *(void *)(v98 + 16) = *(void *)(v109 + 16);
                        *(_OWORD *)unint64_t v98 = v110;
                        *(unsigned char *)(v109 + 23) = 0;
                        *(unsigned char *)unint64_t v109 = 0;
                        *(_DWORD *)(v98 + 24) = *(_DWORD *)(v109 + 24);
                        if (!v105) {
                          break;
                        }
                        unint64_t v105 = (v105 - 1) >> 1;
                        unint64_t v98 = v109;
                      }
                      while (*(float *)(a1 + 32 * v105 + 24) > v106);
                      if (*(char *)(v109 + 23) < 0) {
                        operator delete(*(void **)v109);
                      }
                      *(void *)unint64_t v109 = v107;
                      *(void *)(v109 + 15) = *(void *)&v132[7];
                      *(void *)(v109 + 8) = *(void *)v132;
                      *(unsigned char *)(v109 + 23) = v108;
                      *(float *)(v109 + 24) = v106;
                    }
                  }
                }
              }
              while (v91-- > 2);
            }
            return;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          unint64_t v14 = a1 + 32 * ((unint64_t)v12 >> 1);
          if ((unint64_t)v11 <= 0x1000)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)v14, (float *)a1, v121);
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)a1, (float *)v14, v121);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)(a1 + 32), (float *)(v14 - 32), (float *)a2 - 16);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)(a1 + 64), (float *)(a1 + 32 + 32 * v13), (float *)a2 - 24);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)(v14 - 32), (float *)v14, (float *)(a1 + 32 + 32 * v13));
            uint64_t v134 = *(void *)(a1 + 16);
            long long v126 = *(_OWORD *)a1;
            uint64_t v15 = *(void *)(v14 + 16);
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(void *)(a1 + 16) = v15;
            *(void *)(v14 + 16) = v134;
            *(_OWORD *)unint64_t v14 = v126;
            int v16 = *(_DWORD *)(a1 + 24);
            *(_DWORD *)(a1 + 24) = *(_DWORD *)(v14 + 24);
            *(_DWORD *)(v14 + 24) = v16;
          }
          --a3;
          if (a4) {
            break;
          }
          float v17 = *(float *)(a1 + 24);
          if (*(float *)(a1 - 8) > v17) {
            goto LABEL_12;
          }
          uint64_t v36 = *(void *)a1;
          *(void *)float v124 = *(void *)(a1 + 8);
          *(void *)&v124[7] = *(void *)(a1 + 15);
          char v37 = *(unsigned char *)(a1 + 23);
          *(void *)(a1 + 8) = 0;
          *(void *)(a1 + 16) = 0;
          *(void *)a1 = 0;
          if (v17 <= *((float *)a2 - 2))
          {
            unint64_t v40 = a1 + 32;
            do
            {
              unint64_t v10 = v40;
              if (v40 >= (unint64_t)a2) {
                break;
              }
              float v41 = *(float *)(v40 + 24);
              v40 += 32;
            }
            while (v17 <= v41);
          }
          else
          {
            unint64_t v38 = a1;
            do
            {
              unint64_t v10 = v38 + 32;
              float v39 = *(float *)(v38 + 56);
              v38 += 32;
            }
            while (v17 <= v39);
          }
          unint64_t v42 = a2;
          if (v10 < (unint64_t)a2)
          {
            uint64_t v43 = a2;
            do
            {
              unint64_t v42 = v43 - 4;
              float v44 = *((float *)v43 - 2);
              v43 -= 4;
            }
            while (v17 > v44);
          }
          while (v10 < (unint64_t)v42)
          {
            double v135 = *(void **)(v10 + 16);
            long long v127 = *(_OWORD *)v10;
            long long v45 = *(_OWORD *)v42;
            *(void *)(v10 + 16) = v42[2];
            *(_OWORD *)unint64_t v10 = v45;
            v42[2] = v135;
            *(_OWORD *)unint64_t v42 = v127;
            LODWORD(v45) = *(_DWORD *)(v10 + 24);
            *(_DWORD *)(v10 + 24) = *((_DWORD *)v42 + 6);
            *((_DWORD *)v42 + 6) = v45;
            do
            {
              float v46 = *(float *)(v10 + 56);
              v10 += 32;
            }
            while (v17 <= v46);
            do
            {
              float v47 = *((float *)v42 - 2);
              v42 -= 4;
            }
            while (v17 > v47);
          }
          float32x2_t v48 = (void **)(v10 - 32);
          BOOL v4 = v10 - 32 >= a1;
          BOOL v5 = v10 - 32 == a1;
          if (v10 - 32 != a1)
          {
            if (*(char *)(a1 + 23) < 0) {
              operator delete(*(void **)a1);
            }
            long long v49 = *(_OWORD *)v48;
            *(void *)(a1 + 16) = *(void *)(v10 - 16);
            *(_OWORD *)a1 = v49;
            *(unsigned char *)(v10 - 9) = 0;
            *(unsigned char *)(v10 - 32) = 0;
            *(_DWORD *)(a1 + 24) = *(_DWORD *)(v10 - 8);
          }
          if (*(char *)(v10 - 9) < 0) {
            operator delete(*v48);
          }
          a4 = 0;
          *(void *)(v10 - 32) = v36;
          *(void *)(v10 - 17) = *(void *)&v124[7];
          *(void *)(v10 - 24) = *(void *)v124;
          *(unsigned char *)(v10 - 9) = v37;
          *(float *)(v10 - 8) = v17;
        }
        float v17 = *(float *)(a1 + 24);
LABEL_12:
        uint64_t v18 = *(void *)a1;
        *(void *)float v123 = *(void *)(a1 + 8);
        *(void *)&v123[7] = *(void *)(a1 + 15);
        char v19 = *(unsigned char *)(a1 + 23);
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
        *(void *)a1 = 0;
        unint64_t v20 = a1;
        do
        {
          unint64_t v21 = v20;
          v20 += 32;
        }
        while (*(float *)(v21 + 56) > v17);
        uint64_t v22 = a2;
        if (v21 == a1)
        {
          uint64_t v25 = a2;
          while (v20 < (unint64_t)v25)
          {
            unint64_t v23 = v25 - 4;
            float v26 = *((float *)v25 - 2);
            v25 -= 4;
            if (v26 > v17) {
              goto LABEL_22;
            }
          }
          unint64_t v23 = v25;
        }
        else
        {
          do
          {
            unint64_t v23 = v22 - 4;
            float v24 = *((float *)v22 - 2);
            v22 -= 4;
          }
          while (v24 <= v17);
        }
LABEL_22:
        unint64_t v10 = v20;
        if (v20 < (unint64_t)v23)
        {
          unint64_t v27 = (unint64_t)v23;
          do
          {
            long long v28 = *(_OWORD *)v10;
            uint64_t v29 = *(void *)(v10 + 16);
            uint64_t v30 = *(void *)(v27 + 16);
            *(_OWORD *)unint64_t v10 = *(_OWORD *)v27;
            *(void *)(v10 + 16) = v30;
            *(void *)(v27 + 16) = v29;
            *(_OWORD *)unint64_t v27 = v28;
            LODWORD(v28) = *(_DWORD *)(v10 + 24);
            *(_DWORD *)(v10 + 24) = *(_DWORD *)(v27 + 24);
            *(_DWORD *)(v27 + 24) = v28;
            do
            {
              float v31 = *(float *)(v10 + 56);
              v10 += 32;
            }
            while (v31 > v17);
            do
            {
              float v32 = *(float *)(v27 - 8);
              v27 -= 32;
            }
            while (v32 <= v17);
          }
          while (v10 < v27);
        }
        std::string v33 = (void **)(v10 - 32);
        if (v10 - 32 != a1)
        {
          if (*(char *)(a1 + 23) < 0) {
            operator delete(*(void **)a1);
          }
          long long v34 = *(_OWORD *)v33;
          *(void *)(a1 + 16) = *(void *)(v10 - 16);
          *(_OWORD *)a1 = v34;
          *(unsigned char *)(v10 - 9) = 0;
          *(unsigned char *)(v10 - 32) = 0;
          *(_DWORD *)(a1 + 24) = *(_DWORD *)(v10 - 8);
        }
        if (*(char *)(v10 - 9) < 0) {
          operator delete(*v33);
        }
        *(void *)(v10 - 32) = v18;
        *(void *)(v10 - 17) = *(void *)&v123[7];
        *(void *)(v10 - 24) = *(void *)v123;
        *(unsigned char *)(v10 - 9) = v19;
        *(float *)(v10 - 8) = v17;
        if (v20 >= (unint64_t)v23) {
          break;
        }
LABEL_37:
        std::__introsort<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *,false>(a1, v10 - 32, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v35 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, v10 - 32);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v35) {
        goto LABEL_37;
      }
    }
    a2 = (void **)(v10 - 32);
    if (!v35) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 8) > *(float *)(a1 + 24))
      {
        uint64_t v6 = *(void *)(a1 + 16);
        long long v7 = *(_OWORD *)a1;
        uint64_t v8 = *(void *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(void *)(a1 + 16) = v8;
        *(_OWORD *)(a2 - 32) = v7;
        *(void *)(a2 - 16) = v6;
        LODWORD(v7) = *(_DWORD *)(a1 + 24);
        *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)a1, (float *)(a1 + 32), (float *)(a2 - 32));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, (long long *)(a1 + 32), (float *)(a1 + 64), (float *)(a2 - 32));
      return 1;
    case 5:
      unint64_t v21 = (long long *)(a1 + 32);
      uint64_t v22 = (long long *)(a1 + 64);
      unint64_t v23 = (long long *)(a1 + 96);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>(a1, (long long *)(a1 + 32), (float *)(a1 + 64), (float *)(a1 + 96));
      if (*(float *)(a2 - 8) > *(float *)(a1 + 120))
      {
        uint64_t v24 = *(void *)(a1 + 112);
        long long v25 = *v23;
        uint64_t v26 = *(void *)(a2 - 16);
        *unint64_t v23 = *(_OWORD *)(a2 - 32);
        *(void *)(a1 + 112) = v26;
        *(_OWORD *)(a2 - 32) = v25;
        *(void *)(a2 - 16) = v24;
        LODWORD(v25) = *(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 120) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v25;
        float v27 = *(float *)(a1 + 120);
        float v28 = *(float *)(a1 + 88);
        if (v27 > v28)
        {
          uint64_t v29 = *(void *)(a1 + 80);
          long long v30 = *v22;
          long long *v22 = *v23;
          *(void *)(a1 + 80) = *(void *)(a1 + 112);
          *unint64_t v23 = v30;
          *(void *)(a1 + 112) = v29;
          *(float *)(a1 + 88) = v27;
          float v31 = *(float *)(a1 + 56);
          *(float *)(a1 + 120) = v28;
          if (v27 > v31)
          {
            uint64_t v32 = *(void *)(a1 + 48);
            long long v33 = *v21;
            long long *v21 = *v22;
            *(void *)(a1 + 48) = *(void *)(a1 + 80);
            long long *v22 = v33;
            *(void *)(a1 + 80) = v32;
            *(float *)(a1 + 56) = v27;
            float v34 = *(float *)(a1 + 24);
            *(float *)(a1 + 88) = v31;
            if (v27 > v34)
            {
              uint64_t v35 = *(void *)(a1 + 16);
              long long v36 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v21;
              *(void *)(a1 + 16) = *(void *)(a1 + 48);
              long long *v21 = v36;
              *(void *)(a1 + 48) = v35;
              *(float *)(a1 + 24) = v27;
              *(float *)(a1 + 56) = v34;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v9 = a1 + 64;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *>((long long *)a1, (float *)(a1 + 32), (float *)(a1 + 64));
      uint64_t v10 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    float v13 = *(float *)(v10 + 24);
    if (v13 > *(float *)(v9 + 24))
    {
      uint64_t v14 = *(void *)v10;
      *(void *)char v37 = *(void *)(v10 + 8);
      *(void *)&v37[7] = *(void *)(v10 + 15);
      char v15 = *(unsigned char *)(v10 + 23);
      *(void *)(v10 + 8) = 0;
      *(void *)(v10 + 16) = 0;
      *(void *)uint64_t v10 = 0;
      uint64_t v16 = v11;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        uint64_t v18 = (void **)(a1 + v16 + 96);
        if (*(char *)(a1 + v16 + 119) < 0) {
          operator delete(*v18);
        }
        *(_OWORD *)uint64_t v18 = *(_OWORD *)(v17 + 64);
        *(void *)(a1 + v16 + 112) = *(void *)(v17 + 80);
        *(unsigned char *)(v17 + 87) = 0;
        *(unsigned char *)(v17 + 64) = 0;
        *(_DWORD *)(v17 + 120) = *(_DWORD *)(v17 + 88);
        if (v16 == -64) {
          break;
        }
        float v19 = *(float *)(a1 + v16 + 56);
        v16 -= 32;
        if (v13 <= v19)
        {
          uint64_t v20 = a1 + v16 + 96;
          goto LABEL_14;
        }
      }
      uint64_t v20 = a1;
LABEL_14:
      if (*(char *)(v20 + 23) < 0) {
        operator delete(*(void **)v20);
      }
      *(void *)uint64_t v20 = v14;
      *(void *)(v20 + 8) = *(void *)v37;
      *(void *)(v20 + 15) = *(void *)&v37[7];
      *(unsigned char *)(v20 + 23) = v15;
      *(float *)(v20 + 24) = v13;
      if (++v12 == 8) {
        return v10 + 32 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 32;
    v10 += 32;
    if (v10 == a2) {
      return 1;
    }
  }
}

void ImageClassifier_getBatchCumulativeLabels(uint64_t a1, uint64_t *a2, int a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v24 = v4;
LABEL_2:
  if (v5 != v4)
  {
    uint64_t v6 = *(uint64_t **)(v5 + 16);
    if (!v6) {
      goto LABEL_29;
    }
    while (1)
    {
      unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(v6 + 2));
      int8x8_t v8 = *(int8x8_t *)(a1 + 8);
      if (!*(void *)&v8) {
        goto LABEL_20;
      }
      unint64_t v9 = v7;
      uint8x8_t v10 = (uint8x8_t)vcnt_s8(v8);
      v10.i16[0] = vaddlv_u8(v10);
      unint64_t v11 = v10.u32[0];
      if (v10.u32[0] > 1uLL)
      {
        unint64_t v12 = v7;
        if (v7 >= *(void *)&v8) {
          unint64_t v12 = v7 % *(void *)&v8;
        }
      }
      else
      {
        unint64_t v12 = (*(void *)&v8 - 1) & v7;
      }
      float v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v12);
      if (!v13 || (uint64_t v14 = *v13) == 0)
      {
LABEL_20:
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,float> const&>(a1, (unsigned __int8 *)v6 + 16, (uint64_t)(v6 + 2));
        goto LABEL_21;
      }
      while (1)
      {
        unint64_t v15 = *((void *)v14 + 1);
        if (v15 == v9) {
          break;
        }
        if (v11 > 1)
        {
          if (v15 >= *(void *)&v8) {
            v15 %= *(void *)&v8;
          }
        }
        else
        {
          v15 &= *(void *)&v8 - 1;
        }
        if (v15 != v12) {
          goto LABEL_20;
        }
LABEL_19:
        uint64_t v14 = *(unsigned __int8 **)v14;
        if (!v14) {
          goto LABEL_20;
        }
      }
      if (!std::equal_to<std::string>::operator()[abi:ne180100](v14 + 16, (unsigned __int8 *)v6 + 16)) {
        goto LABEL_19;
      }
      if (a3 == 2)
      {
        uint64_t v26 = (long long *)(v6 + 2);
        float v16 = *((float *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, (unsigned __int8 *)v6 + 16, &v26)+ 10);
        float v17 = *((float *)v6 + 10);
        uint64_t v26 = (long long *)(v6 + 2);
        uint64_t v18 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, (unsigned __int8 *)v6 + 16, &v26);
        if (v16 >= v17) {
          float v19 = v16;
        }
        else {
          float v19 = v17;
        }
      }
      else
      {
        float v20 = *((float *)v6 + 10);
        uint64_t v26 = (long long *)(v6 + 2);
        uint64_t v18 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, (unsigned __int8 *)v6 + 16, &v26);
        float v19 = v20 + *((float *)v18 + 10);
      }
      *((float *)v18 + 10) = v19;
LABEL_21:
      uint64_t v6 = (uint64_t *)*v6;
      if (!v6)
      {
LABEL_29:
        v5 += 40;
        uint64_t v4 = v24;
        goto LABEL_2;
      }
    }
  }
  if (a3 == 1)
  {
    unint64_t v21 = *(float **)(a1 + 16);
    if (v21)
    {
      float v22 = (float)(0xCCCCCCCCCCCCCCCDLL * ((a2[1] - *a2) >> 3));
      do
      {
        v21[10] = v21[10] / v22;
        unint64_t v21 = *(float **)v21;
      }
      while (v21);
    }
  }
}

void sub_1A3EADE88(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void ImageClassifier_getLabelsAuto(uint64_t *a1, uint64_t *a2, float a3, float a4)
{
  unint64_t v39 = 0;
  unint64_t v40 = 0;
  unint64_t v41 = 0;
  if (a2)
  {
    unint64_t v7 = a2;
    unint64_t v8 = 0;
    do
    {
      float v9 = *((float *)v7 + 10);
      if (v9 >= a3)
      {
        if (*((char *)v7 + 39) < 0)
        {
          std::string::__init_copy_ctor_external(&v37, (const std::string::value_type *)v7[2], v7[3]);
          float v9 = *((float *)v7 + 10);
          unint64_t v8 = v40;
        }
        else
        {
          std::string v37 = *(std::string *)(v7 + 2);
        }
        float v38 = v9;
        if (v8 >= v41)
        {
          uint64_t v11 = (uint64_t)(v8 - v39) >> 5;
          if ((unint64_t)(v11 + 1) >> 59) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v12 = (uint64_t)(v41 - v39) >> 4;
          if (v12 <= v11 + 1) {
            unint64_t v12 = v11 + 1;
          }
          if (v41 - v39 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v13 = v12;
          }
          v42[4] = (void **)&v41;
          uint64_t v14 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(v13);
          unint64_t v15 = &v14[4 * v11];
          v42[0] = v14;
          v42[1] = v15;
          v42[3] = &v14[4 * v16];
          *(std::string *)unint64_t v15 = v37;
          memset(&v37, 0, sizeof(v37));
          *((float *)v15 + 6) = v9;
          v42[2] = v15 + 4;
          std::vector<std::pair<std::string,float>>::__swap_out_circular_buffer((uint64_t *)&v39, v42);
          unint64_t v8 = v40;
          std::__split_buffer<std::pair<std::string,float>>::~__split_buffer((uint64_t)v42);
        }
        else
        {
          long long v10 = *(_OWORD *)&v37.__r_.__value_.__l.__data_;
          *(void *)(v8 + 16) = *((void *)&v37.__r_.__value_.__l + 2);
          *(_OWORD *)unint64_t v8 = v10;
          *(float *)(v8 + 24) = v9;
          v8 += 32;
        }
        unint64_t v40 = v8;
      }
      unint64_t v7 = (uint64_t *)*v7;
    }
    while (v7);
    unint64_t v17 = v39;
  }
  else
  {
    unint64_t v8 = 0;
    unint64_t v17 = 0;
  }
  unint64_t v18 = 126 - 2 * __clz((uint64_t)(v8 - v17) >> 5);
  if (v8 == v17) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = v18;
  }
  std::__introsort<std::_ClassicAlgPolicy,ImageClassifier_getLabels(std::unordered_map<std::string,float> const&,float,unsigned long)::$_0 &,std::pair<std::string,float> *,false>(v17, (void **)v8, v19, 1);
  float v34 = 0;
  uint64_t v35 = 0;
  unint64_t v36 = 0;
  uint64_t v20 = v39;
  unint64_t v21 = (uint64_t)(v40 - v39) >> 5;
  if (v21 >= 0x7FFFFFFF) {
    unint64_t v21 = 0x7FFFFFFFLL;
  }
  if (v21)
  {
    uint64_t v22 = 0;
    unint64_t v23 = 0;
    unint64_t v24 = 0;
    do
    {
      long long v25 = (long long *)(v20 + v22);
      if (v23 >= v36)
      {
        unint64_t v23 = std::vector<std::pair<std::string,float>>::__push_back_slow_path<std::pair<std::string,float> const&>((uint64_t *)&v34, v25);
      }
      else
      {
        std::vector<std::pair<std::string,float>>::__construct_one_at_end[abi:ne180100]<std::pair<std::string,float> const&>((uint64_t)&v34, v25);
        v23 += 32;
      }
      uint64_t v35 = (long long *)v23;
      ++v24;
      uint64_t v20 = v39;
      unint64_t v26 = (uint64_t)(v40 - v39) >> 5;
      if (v26 >= 0x7FFFFFFF) {
        unint64_t v26 = 0x7FFFFFFFLL;
      }
      v22 += 32;
    }
    while (v24 < v26);
  }
  v42[0] = (void **)&v39;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](v42);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (v35 != v34)
  {
    unint64_t v27 = std::vector<std::pair<std::string,float>>::__push_back_slow_path<std::pair<std::string,float> const&>(a1, v34);
    float v28 = v34;
    uint64_t v29 = v35;
    a1[1] = v27;
    if ((unint64_t)((char *)v29 - (char *)v28) >= 0x21)
    {
      uint64_t v30 = 0;
      unint64_t v31 = 1;
      do
      {
        uint64_t v32 = &v28[v30];
        if ((float)(*((float *)v32 + 14) / *(float *)(*a1 + v30 * 16 + 24)) < a4) {
          break;
        }
        long long v33 = v32 + 2;
        if (v27 >= a1[2])
        {
          unint64_t v27 = std::vector<std::pair<std::string,float>>::__push_back_slow_path<std::pair<std::string,float> const&>(a1, v33);
        }
        else
        {
          std::vector<std::pair<std::string,float>>::__construct_one_at_end[abi:ne180100]<std::pair<std::string,float> const&>((uint64_t)a1, v33);
          v27 += 32;
        }
        a1[1] = v27;
        ++v31;
        float v28 = v34;
        v30 += 2;
      }
      while (v31 < ((char *)v35 - (char *)v34) >> 5);
    }
  }
  v42[0] = (void **)&v34;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](v42);
}

void sub_1A3EAE198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char *a23)
{
  a23 = &a10;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  _Unwind_Resume(a1);
}

void ImageClassifier_getLabelsAuto(uint64_t *a1, void **a2, void *a3, float a4, float a5)
{
  ImageClassifier_getLabels((uint64_t *)&v14, a2, a3, 0x7FFFFFFFuLL, a4);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (v15 != v14)
  {
    unint64_t v7 = std::vector<std::pair<std::string,float>>::__push_back_slow_path<std::pair<std::string,float> const&>(a1, v14);
    unint64_t v8 = v14;
    float v9 = v15;
    a1[1] = v7;
    if ((unint64_t)((char *)v9 - (char *)v8) >= 0x21)
    {
      uint64_t v10 = 0;
      unint64_t v11 = 1;
      do
      {
        unint64_t v12 = &v8[v10];
        if ((float)(*((float *)v12 + 14) / *(float *)(*a1 + v10 * 16 + 24)) < a5) {
          break;
        }
        unint64_t v13 = v12 + 2;
        if (v7 >= a1[2])
        {
          unint64_t v7 = std::vector<std::pair<std::string,float>>::__push_back_slow_path<std::pair<std::string,float> const&>(a1, v13);
        }
        else
        {
          std::vector<std::pair<std::string,float>>::__construct_one_at_end[abi:ne180100]<std::pair<std::string,float> const&>((uint64_t)a1, v13);
          v7 += 32;
        }
        a1[1] = v7;
        ++v11;
        unint64_t v8 = v14;
        v10 += 2;
      }
      while (v11 < ((char *)v15 - (char *)v14) >> 5);
    }
  }
  uint64_t v16 = &v14;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v16);
}

void sub_1A3EAE310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void sub_1A3EAE4CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAE5FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAE72C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAE85C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAE98C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAEB84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAEC94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAEE9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAF054(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAF198(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAF4B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  vision::mod::RPNTrackerOptions::~RPNTrackerOptions((id *)va);
  _Unwind_Resume(a1);
}

void std::shared_ptr<vision::mod::ObjectTrackerAbstract>::reset[abi:ne180100]<vision::mod::ObjectTrackerAbstract,void>()
{
}

void sub_1A3EAF5A4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void vision::mod::RPNTrackerOptions::~RPNTrackerOptions(id *this)
{
}

uint64_t std::__shared_ptr_pointer<vision::mod::ObjectTrackerAbstract *,std::shared_ptr<vision::mod::ObjectTrackerAbstract>::__shared_ptr_default_delete<vision::mod::ObjectTrackerAbstract,vision::mod::ObjectTrackerAbstract>,std::allocator<vision::mod::ObjectTrackerAbstract>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN6vision3mod21ObjectTrackerAbstractEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::__shared_ptr_pointer<vision::mod::ObjectTrackerAbstract *,std::shared_ptr<vision::mod::ObjectTrackerAbstract>::__shared_ptr_default_delete<vision::mod::ObjectTrackerAbstract,vision::mod::ObjectTrackerAbstract>,std::allocator<vision::mod::ObjectTrackerAbstract>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<vision::mod::ObjectTrackerAbstract *,std::shared_ptr<vision::mod::ObjectTrackerAbstract>::__shared_ptr_default_delete<vision::mod::ObjectTrackerAbstract,vision::mod::ObjectTrackerAbstract>,std::allocator<vision::mod::ObjectTrackerAbstract>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A3EAF96C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAFAA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAFBF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EAFCE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ObjectDetectorAbstract::setPriority(vision::mod::ObjectDetectorAbstract *this)
{
  return 6015;
}

uint64_t vision::mod::ObjectDetectorAbstract::wipeLayersMemory(vision::mod::ObjectDetectorAbstract *this)
{
  return 6015;
}

void vision::mod::ObjectDetectorAbstract::detectObjectsInImages_Planar8(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (*a2 != v4)
  {
    do
    {
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 56))(v7, a1, v3);
      std::vector<std::vector<vision::mod::DetectedObject>>::push_back[abi:ne180100]((void ***)a3, (uint64_t)v7);
      unint64_t v8 = (void **)v7;
      std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v8);
      v3 += 32;
    }
    while (v3 != v4);
  }
}

void sub_1A3EAFE2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, void ***a12)
{
  a12 = &a9;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  std::vector<std::vector<vision::mod::DetectedObject>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::vector<vision::mod::DetectedObject>>::push_back[abi:ne180100](void ***a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  unint64_t v5 = (unint64_t)a1[2];
  if ((unint64_t)v4 >= v5)
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (v4 - *a1);
    unint64_t v8 = v7 + 1;
    if (v7 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)*a1) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v8;
    }
    unint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v10);
    unint64_t v12 = &v11[24 * v7];
    uint64_t v14 = (void **)&v11[24 * v13];
    *((void *)v12 + 1) = 0;
    *((void *)v12 + 2) = 0;
    *(void *)unint64_t v12 = 0;
    *(_OWORD *)unint64_t v12 = *(_OWORD *)a2;
    *((void *)v12 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v6 = (void **)(v12 + 24);
    unint64_t v15 = *a1;
    uint64_t v16 = a1[1];
    if (v16 == *a1)
    {
      *a1 = (void **)v12;
      a1[1] = v6;
      a1[2] = v14;
    }
    else
    {
      do
      {
        *((void *)v12 - 3) = 0;
        *((void *)v12 - 2) = 0;
        v12 -= 24;
        *((void *)v12 + 2) = 0;
        long long v17 = *(_OWORD *)(v16 - 3);
        v16 -= 3;
        *(_OWORD *)unint64_t v12 = v17;
        *((void *)v12 + 2) = v16[2];
        std::string *v16 = 0;
        v16[1] = 0;
        v16[2] = 0;
      }
      while (v16 != v15);
      uint64_t v16 = *a1;
      unint64_t v18 = a1[1];
      *a1 = (void **)v12;
      a1[1] = v6;
      a1[2] = v14;
      while (v18 != v16)
      {
        v18 -= 3;
        uint64_t v19 = v18;
        std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v19);
      }
    }
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *uint64_t v4 = 0;
    v4[1] = 0;
    v4[2] = 0;
    *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
    v4[2] = *(void **)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v6 = v4 + 3;
  }
  a1[1] = v6;
}

void std::vector<std::vector<vision::mod::DetectedObject>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void vision::mod::ObjectDetector_DCNFaceDetector_v2::detectObjectsInImages_BGRA8888(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v22 = 0;
  unint64_t v23 = &v22;
  uint64_t v24 = 0x4812000000;
  long long v25 = __Block_byref_object_copy__5;
  unint64_t v26 = __Block_byref_object_dispose__6;
  unint64_t v27 = "";
  uint64_t v7 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  float v28 = 0;
  long long v33 = &v28;
  LOBYTE(v34) = 0;
  uint64_t v8 = v6 - v7;
  if (v8)
  {
    if (v8 < 0) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = v8 >> 5;
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v8 >> 5);
    float v28 = v10;
    uint64_t v30 = &v10[24 * v11];
    size_t v12 = 24 * ((24 * v9 - 24) / 0x18uLL) + 24;
    bzero(v10, v12);
    uint64_t v29 = &v10[v12];
  }
  uint64_t v13 = *(void **)(*(void *)(a1 + 112) + 8);
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  v21[2] = ___ZN6vision3mod33ObjectDetector_DCNFaceDetector_v230detectObjectsInImages_BGRA8888ERKNSt3__16vectorI13vImage_BufferNS2_9allocatorIS4_EEEE_block_invoke;
  v21[3] = &unk_1E5B1C6A0;
  v21[5] = a1;
  v21[6] = a2;
  v21[4] = &v22;
  vision::mod::dispatch_sync_guard(v13, v21);
  uint64_t v14 = v23;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  unint64_t v15 = (uint64_t *)v14[6];
  uint64_t v16 = (uint64_t *)v14[7];
  uint64_t v31 = a3;
  char v32 = 0;
  if (v16 != v15)
  {
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (v16 - v15);
    if (v17 >= 0xAAAAAAAAAAAAAABLL) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v18 = std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v17);
    *(void *)a3 = v18;
    *(void *)(a3 + 8) = v18;
    *(void *)(a3 + 16) = &v18[3 * v19];
    std::string v37 = v18;
    float v38 = v18;
    long long v33 = (char **)(a3 + 16);
    float v34 = &v37;
    uint64_t v35 = &v38;
    char v36 = 0;
    uint64_t v20 = v18;
    do
    {
      void *v20 = 0;
      v20[1] = 0;
      v20[2] = 0;
      std::vector<vision::mod::DetectedObject>::__init_with_size[abi:ne180100]<vision::mod::DetectedObject*,vision::mod::DetectedObject*>(v20, *v15, v15[1], 0xCCCCCCCCCCCCCCCDLL * ((v15[1] - *v15) >> 4));
      uint64_t v20 = v38 + 3;
      v38 += 3;
      v15 += 3;
    }
    while (v15 != v16);
    char v36 = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<vision::mod::DetectedObject>>,std::vector<vision::mod::DetectedObject>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&v33);
    *(void *)(a3 + 8) = v20;
  }
  _Block_object_dispose(&v22, 8);
  long long v33 = &v28;
  std::vector<std::vector<vision::mod::DetectedObject>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v33);
}

void sub_1A3EB02AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  *(void *)(v9 - 112) = v8;
  std::vector<std::vector<vision::mod::DetectedObject>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v9 - 112));
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__5(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::vector<vision::mod::DetectedObject>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN6vision3mod33ObjectDetector_DCNFaceDetector_v230detectObjectsInImages_BGRA8888ERKNSt3__16vectorI13vImage_BufferNS2_9allocatorIS4_EEEE_block_invoke(void *a1)
{
  uint64_t v1 = a1[6];
  uint64_t v2 = *(_OWORD **)v1;
  unint64_t v27 = *(_OWORD **)(v1 + 8);
  if (*(_OWORD **)v1 != v27)
  {
    uint64_t v3 = 0;
    uint64_t v4 = a1[5];
    do
    {
      long long v5 = v2[1];
      v31[0] = *v2;
      v31[1] = v5;
      vision::mod::ObjectDetector_DCNFaceDetector_v2::priv::detectFacesInImageBufferInternal((vision::mod::ObjectDetector_DCNFaceDetector_v2::priv *)&v29, *(const vImage_Buffer **)(v4 + 112), (uint64_t)v31, *(unsigned __int8 *)(v4 + 104), *(double *)v31);
      uint64_t v6 = *(void *)(*(void *)(a1[4] + 8) + 48);
      uint64_t v7 = (uint64_t *)(v6 + 24 * v3);
      if (v7 != &v29)
      {
        uint64_t v9 = v29;
        uint64_t v8 = v30;
        uint64_t v10 = v6 + 24 * v3;
        uint64_t v12 = *(void *)(v10 + 16);
        uint64_t v11 = (void *)(v10 + 16);
        unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((v30 - v29) >> 4);
        uint64_t v14 = *v7;
        if (0xCCCCCCCCCCCCCCCDLL * ((v12 - *v7) >> 4) >= v13)
        {
          uint64_t v21 = v6 + 24 * v3;
          uint64_t v22 = *(void *)(v21 + 8);
          unint64_t v18 = (uint64_t *)(v21 + 8);
          unint64_t v23 = 0xCCCCCCCCCCCCCCCDLL * ((v22 - v14) >> 4);
          if (v23 >= v13)
          {
            uint64_t v25 = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vision::mod::DetectedObject *,vision::mod::DetectedObject *,vision::mod::DetectedObject *,0>(v29, v30, v14);
            for (uint64_t i = *v18; i != v25; i -= 80)
            {
              if (*(char *)(i - 57) < 0) {
                operator delete(*(void **)(i - 80));
              }
            }
            uint64_t *v18 = v25;
            goto LABEL_21;
          }
          uint64_t v24 = v29 + 80 * v23;
          std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vision::mod::DetectedObject *,vision::mod::DetectedObject *,vision::mod::DetectedObject *,0>(v29, v24, v14);
          uint64_t v20 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vision::mod::DetectedObject>,vision::mod::DetectedObject*,vision::mod::DetectedObject*,vision::mod::DetectedObject*>((uint64_t)v11, v24, v8, *v18);
        }
        else
        {
          std::vector<vision::mod::DetectedObject>::__vdeallocate(v7);
          if (v13 > 0x333333333333333) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v15 = 0x999999999999999ALL * ((*v11 - *v7) >> 4);
          if (v15 <= v13) {
            unint64_t v15 = v13;
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((*v11 - *v7) >> 4) >= 0x199999999999999) {
            unint64_t v16 = 0x333333333333333;
          }
          else {
            unint64_t v16 = v15;
          }
          std::vector<vision::mod::DetectedObject>::__vallocate[abi:ne180100](v7, v16);
          uint64_t v17 = v6 + 24 * v3;
          uint64_t v19 = *(void *)(v17 + 8);
          unint64_t v18 = (uint64_t *)(v17 + 8);
          uint64_t v20 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vision::mod::DetectedObject>,vision::mod::DetectedObject*,vision::mod::DetectedObject*,vision::mod::DetectedObject*>((uint64_t)v11, v9, v8, v19);
        }
        uint64_t *v18 = v20;
      }
LABEL_21:
      ++v3;
      char v32 = (void **)&v29;
      std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v32);
      v2 += 2;
    }
    while (v2 != v27);
  }
}

void sub_1A3EB0558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void **a20)
{
  void *v21 = v20;
  a20 = (void **)&a12;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&a20);
  _Unwind_Resume(a1);
}

void vision::mod::dispatch_sync_guard(void *a1, void *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x4012000000;
  uint64_t v19 = __Block_byref_object_copy__18;
  uint64_t v20 = __Block_byref_object_dispose__19;
  uint64_t v21 = "";
  MEMORY[0x1A6255EF0](v22, "Unspecified error");
  uint64_t v12 = 0;
  unint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN6vision3modL19dispatch_sync_guardEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E5B1C6C8;
  id v5 = v4;
  id v9 = v5;
  uint64_t v10 = &v12;
  uint64_t v11 = &v16;
  dispatch_sync(v3, block);
  if (*((unsigned char *)v13 + 24))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    uint64_t v7 = (void *)MEMORY[0x1A6255F00](exception, v17 + 6);
    __cxa_throw(v7, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }

  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  MEMORY[0x1A6255F10](v22);
}

void sub_1A3EB0718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);

  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  MEMORY[0x1A6255F10](v11);

  _Unwind_Resume(a1);
}

void *std::vector<vision::mod::DetectedObject>::__init_with_size[abi:ne180100]<vision::mod::DetectedObject*,vision::mod::DetectedObject*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<vision::mod::DetectedObject>::__vallocate[abi:ne180100](result, a4);
    __n128 result = (void *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vision::mod::DetectedObject>,vision::mod::DetectedObject*,vision::mod::DetectedObject*,vision::mod::DetectedObject*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1A3EB07C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<vision::mod::DetectedObject>>,std::vector<vision::mod::DetectedObject>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void ****)(a1 + 16);
    id v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      id v5 = v3;
      std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

char *std::vector<vision::mod::DetectedObject>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DetectedObject>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[80 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vision::mod::DetectedObject>,vision::mod::DetectedObject*,vision::mod::DetectedObject*,vision::mod::DetectedObject*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      vision::mod::DetectedObject::DetectedObject(v4, v6);
      v6 += 80;
      uint64_t v4 = v11 + 80;
      v11 += 80;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vision::mod::DetectedObject>,vision::mod::DetectedObject*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A3EB0928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vision::mod::DetectedObject>,vision::mod::DetectedObject*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 16);
    uint64_t v4 = **(void **)(a1 + 8);
    while (v3 != v4)
    {
      if (*(char *)(v3 - 57) < 0) {
        operator delete(*(void **)(v3 - 80));
      }
      v3 -= 80;
    }
  }
  return a1;
}

void __Block_byref_object_copy__18()
{
}

void __Block_byref_object_dispose__19()
{
}

uint64_t ___ZN6vision3modL19dispatch_sync_guardEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1A3EB09E0(void *a1, int a2)
{
  uint64_t v4 = (const std::runtime_error *)__cxa_begin_catch(a1);
  *(unsigned char *)(*(void *)(*(void *)(v2 + 40) + 8) + 24) = 1;
  if (a2 == 2) {
    std::runtime_error::operator=((std::runtime_error *)(*(void *)(*(void *)(v2 + 48) + 8) + 48), v4);
  }
  __cxa_end_catch();
}

void vision::mod::ObjectDetector_DCNFaceDetector_v2::priv::detectFacesInImageBufferInternal(vision::mod::ObjectDetector_DCNFaceDetector_v2::priv *this, const vImage_Buffer *a2, uint64_t a3, int a4, double a5)
{
  uint64_t v6 = this;
  v58[1] = *MEMORY[0x1E4F143B8];
  float v7 = *((float *)&a2[2].width + 1);
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  unint64_t v9 = *(void *)(a3 + 8);
  unint64_t v8 = *(void *)(a3 + 16);
  LODWORD(a5) = a2->data;
  uint64_t v10 = [NSNumber numberWithFloat:a5];
  v58[0] = v10;
  unint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithObjects:v58 count:1];

  int data = a2[3].data;
  uint64_t v12 = [data detect:a3 inputIsBGR:1];
  float v13 = (float)v8;
  float v14 = (float)v9;
  *(float *)&double v15 = (float)v9;
  *(float *)&double v16 = (float)v8;
  uint64_t v17 = [data processBoxes:v12 withHeight:v41 andWidth:v15 filterThresholds:v16];

  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  id v18 = v17;
  uint64_t v19 = [v18 countByEnumeratingWithState:&v44 objects:v57 count:16];
  if (v19)
  {
    uint64_t v20 = *(void *)v45;
    int32x2_t v21 = vdup_n_s32(0x7FC00000u);
    do
    {
      uint64_t v22 = 0;
      do
      {
        if (*(void *)v45 != v20) {
          objc_enumerationMutation(v18);
        }
        unint64_t v23 = (uint64_t *)v6;
        uint64_t v24 = *(void **)(*((void *)&v44 + 1) + 8 * v22);
        std::string::basic_string[abi:ne180100]<0>(__p, "unknown");
        unint64_t v50 = (unint64_t)v21;
        int v54 = 0;
        char v55 = 0;
        int v56 = 0;
        unint64_t v51 = 0;
        uint64_t v52 = 0;
        __int16 v53 = 0;
        [v24 bounds];
        *(float *)&double v25 = v25;
        *(float *)&double v26 = v26;
        unint64_t v50 = __PAIR64__(LODWORD(v26), LODWORD(v25));
        *(float *)&double v25 = v27;
        *(float *)&double v26 = v28;
        unint64_t v51 = __PAIR64__(LODWORD(v25), LODWORD(v26));
        [v24 confidence];
        int v56 = v29;
        [v24 rotationAngle];
        LODWORD(v52) = v30;
        LOBYTE(v53) = 1;
        [v24 yawAngle];
        HIDWORD(v52) = v31;
        HIBYTE(v53) = 1;
        if (v49 < 0)
        {
          __p[1] = (void *)4;
          char v32 = (char *)__p[0];
        }
        else
        {
          char v49 = 4;
          char v32 = (char *)__p;
        }
        strcpy(v32, "face");
        uint64_t v6 = (vision::mod::ObjectDetector_DCNFaceDetector_v2::priv *)v23;
        if ((float)((float)(*(float *)&v50 + *((float *)&v51 + 1)) - v13) <= (float)(v7 * *((float *)&v51 + 1))
          && (float)(v7 * *(float *)&v51) >= (float)-*((float *)&v50 + 1)
          && (float)(v7 * *((float *)&v51 + 1)) >= (float)-*(float *)&v50
          && (float)((float)(*((float *)&v50 + 1) + *(float *)&v51) - v14) <= (float)(v7 * *(float *)&v51))
        {
          if ((float)(*(float *)&v50 + *((float *)&v51 + 1)) <= v13) {
            float v33 = 0.0;
          }
          else {
            float v33 = (float)(*(float *)&v50 + *((float *)&v51 + 1)) - v13;
          }
          if (*(float *)&v50 < 0.0) {
            float v33 = *(float *)&v50;
          }
          if ((float)(*((float *)&v50 + 1) + *(float *)&v51) > v14) {
            float v34 = (float)(*((float *)&v50 + 1) + *(float *)&v51) - v14;
          }
          else {
            float v34 = 0.0;
          }
          if (*((float *)&v50 + 1) < 0.0) {
            float v34 = *((float *)&v50 + 1);
          }
          float v35 = *(float *)&v50 - v33;
          float v36 = *((float *)&v50 + 1) - v34;
          *(float *)&unint64_t v50 = v35;
          *((float *)&v50 + 1) = *((float *)&v50 + 1) - v34;
          if ((float)(*((float *)&v51 + 1) + v35) <= v13
            && v36 >= 0.0
            && v35 >= 0.0
            && (float)(*(float *)&v51 + v36) <= v14)
          {
            if (a4) {
              *((float *)&v50 + 1) = (float)((float)*(unint64_t *)(a3 + 8) - v36) - *(float *)&v51;
            }
            unint64_t v38 = v23[1];
            if (v38 >= v23[2])
            {
              uint64_t v39 = std::vector<vision::mod::DetectedObject>::__push_back_slow_path<vision::mod::DetectedObject const&>(v23, (uint64_t)__p);
              uint64_t v6 = (vision::mod::ObjectDetector_DCNFaceDetector_v2::priv *)v23;
            }
            else
            {
              vision::mod::DetectedObject::DetectedObject(v38, (uint64_t)__p);
              uint64_t v39 = v38 + 80;
              uint64_t v6 = (vision::mod::ObjectDetector_DCNFaceDetector_v2::priv *)v23;
              v23[1] = v39;
            }
            *((void *)v6 + 1) = v39;
          }
        }
        if (v49 < 0) {
          operator delete(__p[0]);
        }
        ++v22;
      }
      while (v19 != v22);
      uint64_t v40 = [v18 countByEnumeratingWithState:&v44 objects:v57 count:16];
      uint64_t v19 = v40;
    }
    while (v40);
  }
}

void sub_1A3EB0DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vision::mod::DetectedObject *,vision::mod::DetectedObject *,vision::mod::DetectedObject *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      if (a1 != a3)
      {
        uint64_t v7 = a3 + v6;
        *(_OWORD *)(a3 + v6 + 64) = *(_OWORD *)(a1 + v6 + 64);
        std::string::operator=((std::string *)(a3 + v6), (const std::string *)(a1 + v6));
        *(_OWORD *)(v7 + 24) = *(_OWORD *)(a1 + v6 + 24);
        *(unsigned char *)(v7 + 48) = *(unsigned char *)(a1 + v6 + 48);
        *(void *)(v7 + 40) = *(void *)(a1 + v6 + 40);
        *(unsigned char *)(v7 + 49) = *(unsigned char *)(a1 + v6 + 49);
        *(unsigned char *)(v7 + 56) = *(unsigned char *)(a1 + v6 + 56);
        *(_DWORD *)(v7 + 52) = *(_DWORD *)(a1 + v6 + 52);
        *(_DWORD *)(v7 + 60) = *(_DWORD *)(a1 + v6 + 60);
      }
      v6 += 80;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void std::vector<vision::mod::DetectedObject>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<vision::mod::DetectedObject>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void vision::mod::ObjectDetectorAbstract::detectObjectsInImages_RGBA8888(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (*a2 != v4)
  {
    do
    {
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 40))(v7, a1, v3);
      std::vector<std::vector<vision::mod::DetectedObject>>::push_back[abi:ne180100]((void ***)a3, (uint64_t)v7);
      unint64_t v8 = (void **)v7;
      std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v8);
      v3 += 32;
    }
    while (v3 != v4);
  }
}

void sub_1A3EB0FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, void ***a12)
{
  a12 = &a9;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  std::vector<std::vector<vision::mod::DetectedObject>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void vision::mod::ObjectDetectorAbstract::detectObjectsInImage_Planar8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  exception = __cxa_allocate_exception(8uLL);
  void *exception = 6015;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

void sub_1A3EB1064(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void vision::mod::ObjectDetector_DCNFaceDetector_v2::detectObjectsInImage_BGRA8888(vision::mod::ObjectDetector_DCNFaceDetector_v2 *this@<X0>, const vImage_Buffer *a2@<X1>, void *a3@<X8>)
{
  uint64_t v7 = 0;
  unint64_t v8 = &v7;
  uint64_t v9 = 0x4812000000;
  uint64_t v10 = __Block_byref_object_copy__5296;
  uint64_t v11 = __Block_byref_object_dispose__5297;
  uint64_t v12 = "";
  memset(v13, 0, sizeof(v13));
  uint64_t v4 = *(void **)(*((void *)this + 14) + 8);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN6vision3mod33ObjectDetector_DCNFaceDetector_v229detectObjectsInImage_BGRA8888ERK13vImage_Buffer_block_invoke;
  v6[3] = &unk_1E5B1C6A0;
  v6[4] = &v7;
  v6[5] = this;
  v6[6] = a2;
  vision::mod::dispatch_sync_guard(v4, v6);
  uint64_t v5 = v8;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  std::vector<vision::mod::DetectedObject>::__init_with_size[abi:ne180100]<vision::mod::DetectedObject*,vision::mod::DetectedObject*>(a3, v5[6], v5[7], 0xCCCCCCCCCCCCCCCDLL * ((v5[7] - v5[6]) >> 4));
  _Block_object_dispose(&v7, 8);
  float v14 = (void **)v13;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v14);
}

void sub_1A3EB1198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  *(void *)(v10 - 24) = v9;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)(v10 - 24));
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__5296(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__5297(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN6vision3mod33ObjectDetector_DCNFaceDetector_v229detectObjectsInImage_BGRA8888ERK13vImage_Buffer_block_invoke(void *a1, double a2)
{
  vision::mod::ObjectDetector_DCNFaceDetector_v2::priv::detectFacesInImageBufferInternal((vision::mod::ObjectDetector_DCNFaceDetector_v2::priv *)&v4, *(const vImage_Buffer **)(a1[5] + 112), a1[6], *(unsigned __int8 *)(a1[5] + 104), a2);
  uint64_t v3 = *(void *)(a1[4] + 8);
  std::vector<vision::mod::DetectedObject>::__vdeallocate((uint64_t *)(v3 + 48));
  *(_OWORD *)(v3 + 48) = v4;
  *(void *)(v3 + 64) = v5;
  uint64_t v5 = 0;
  long long v4 = 0uLL;
  uint64_t v6 = (void **)&v4;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v6);
}

void vision::mod::ObjectDetectorAbstract::detectObjectsInImage_RGBA8888(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  exception = __cxa_allocate_exception(8uLL);
  void *exception = 6015;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

void sub_1A3EB12C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ObjectDetectorAbstract::getRequiredImageType(vision::mod::ObjectDetectorAbstract *this)
{
  return 0;
}

float vision::mod::ObjectDetector_DCNFaceDetector_v2::getSuggestedImageSize(vision::mod::ObjectDetector_DCNFaceDetector_v2 *this, _Geometry2D_size2D_ *a2)
{
  float height = a2->height;
  float width = a2->width;
  if (width >= a2->height) {
    float v4 = a2->height;
  }
  else {
    float v4 = a2->width;
  }
  if (height >= width) {
    float v5 = a2->height;
  }
  else {
    float v5 = a2->width;
  }
  if (v4 == 0.0 || v5 == 0.0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 5998;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if ((float)(v5 / v4) >= 1.3326) {
    float v6 = 597.0 / v5;
  }
  else {
    float v6 = 448.0 / v4;
  }
  return roundf(height * v6);
}

void vision::mod::ObjectDetector_DCNFaceDetector_v2::getLabels(std::string **a1@<X8>)
{
  *(void *)&long long v6 = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:ne180100]<0>(__p, "face");
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v3 = (std::string *)operator new(0x18uLL);
  *a1 = v3;
  a1[1] = v3;
  a1[2] = v3 + 1;
  a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((uint64_t)(a1 + 2), (long long *)__p, &v6, v3);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1A3EB1434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v18 = v17;
  *(void *)(v16 + 8) = v18;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a9);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void vision::mod::ObjectDetector_DCNFaceDetector_v2::~ObjectDetector_DCNFaceDetector_v2(vision::mod::ObjectDetector_DCNFaceDetector_v2 *this)
{
  vision::mod::ObjectDetector_DCNFaceDetector_v2::~ObjectDetector_DCNFaceDetector_v2(this);

  JUMPOUT(0x1A62562C0);
}

{
  std::__shared_weak_count *v2;

  *(void *)this = &unk_1EF752E40;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  if (*((char *)this + 95) < 0) {
    operator delete(*((void **)this + 9));
  }
  if (*((char *)this + 71) < 0) {
    operator delete(*((void **)this + 6));
  }
}

void ___ZN6vision3mod33ObjectDetector_DCNFaceDetector_v2C2ERKNS0_41ObjectDetector_DCNFaceDetector_v2_OptionsE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = (void *)(v2 + 32);
  if (*(char *)(v2 + 55) < 0) {
    uint64_t v3 = (void *)*v3;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  char v5 = [NSString stringWithUTF8String:v3];
  uint64_t v7 = v5;
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = (void *)(v8 + 56);
  if (*(char *)(v8 + 79) < 0)
  {
    if (!*(void *)(v8 + 64)) {
      goto LABEL_9;
    }
    uint64_t v9 = (void *)*v9;
    goto LABEL_8;
  }
  if (*(unsigned char *)(v8 + 79))
  {
LABEL_8:
    id v14 = v5;
    uint64_t v10 = objc_msgSend(v5, "stringByAppendingFormat:", @":%s", v9);

    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v7 = (void *)v10;
  }
LABEL_9:
  id v15 = v7;
  LODWORD(v6) = *(_DWORD *)(v8 + 4);
  uint64_t v11 = +[VNShotflowDetector processingDeviceDetectorWithModelPath:v7 networkThreshold:*(unsigned int *)(v8 + 20) preferredDeviceID:*(unsigned int *)(v8 + 24) engineID:*(unsigned int *)(v8 + 28) storageType:v6];
  uint64_t v12 = *(void *)(v4 + 112);
  float v13 = *(void **)(v12 + 96);
  *(void *)(v12 + 96) = v11;
}

void sub_1A3EB1614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::ObjectDetector_DCNFaceDetector_v2::priv>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(void **)(a1 + 32);
}

void std::__shared_ptr_emplace<vision::mod::ObjectDetector_DCNFaceDetector_v2::priv>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753B60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ObjectDetector_DCNFaceDetector_v2::priv>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753B60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A3EB1E64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB1F44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB1FF4(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3EB2170(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB22F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB2454(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB25B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB2714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB27B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB28EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB2E2C(_Unwind_Exception *a1)
{
  uint64_t v4 = v2;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5449(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5450(uint64_t a1)
{
}

void ___ZL39_writeVersion1PersonAndFaceObservationsPU44objcproto9NSCopying8NSObject14NSSecureCoding11objc_objectP7NSArrayIP17VNFaceObservationEP14NSOutputStreamP14CC_MD5state_stPU15__autoreleasingP7NSError_block_invoke(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v6 = a2;
  uint64_t v7 = (void *)MEMORY[0x1A6257080]();
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  id obj = *(id *)(v8 + 40);
  uint64_t v9 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v6 requiringSecureCoding:1 error:&obj];
  objc_storeStrong((id *)(v8 + 40), obj);
  if (v9)
  {
    int v10 = [v9 length];
    [*(id *)(a1 + 32) appendBytes:&v10 length:4];
    [*(id *)(a1 + 32) appendData:v9];
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
    *a4 = 1;
  }
}

void sub_1A3EB3014(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB3154(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB3298(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB3370(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB3424(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB35C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB37E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB39A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB3ADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB3B68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB3C90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB3D78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB3E88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB4018(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB40A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB4250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB43D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB4628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB47D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB5104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,void *a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,void *a37,void *a38,void *a39,uint64_t a40,void *a41,void *a42,void *a43)
{
  _Block_object_dispose(&STACK[0x300], 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5717(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A3EB5374(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(*(void *)(v1 + 48) + 8) + 48));
  objc_exception_rethrow();
}

void sub_1A3EB5390(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__140(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__141(uint64_t a1)
{
}

void sub_1A3EB5520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB56E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB5918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB5B2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB5BF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB5D30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB5E0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB5F90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB60B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB6188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB62A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB63B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB641C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB64CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB6568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB65C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB675C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB6CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a64, 8);
  _Unwind_Resume(a1);
}

void sub_1A3EB6E08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB6F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_1A3EB70D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB748C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v11 = v10;

  _Unwind_Resume(a1);
}

void sub_1A3EB76C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7800(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB78F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB79BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7A58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7C4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7D04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7DC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7E64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7F44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB7FCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB81E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _getObjectFromOptionsDictionary(void *a1, void *a2, void *a3, int a4, objc_class *a5, uint64_t a6)
{
  id v11 = a2;
  id v12 = a3;
  float v13 = [v11 objectForKey:v12];
  id v14 = v13;
  if (a1) {
    *a1 = v13;
  }
  if (v14)
  {
    if (a5 && (objc_opt_isKindOfClass() & 1) == 0)
    {
      if (a6)
      {
        id v15 = [NSString alloc];
        uint64_t v16 = NSStringFromClass(a5);
        uint64_t v17 = (objc_class *)objc_opt_class();
        uint64_t v18 = NSStringFromClass(v17);
        uint64_t v19 = (void *)[v15 initWithFormat:@"The %@ option was expected to be a %@, but was instead a %@ (%@)", v12, v16, v18, v14];

        uint64_t v20 = +[VNError errorWithCode:5 message:v19];
LABEL_11:
        *(void *)a6 = v20;

        a6 = 0;
        goto LABEL_13;
      }
      goto LABEL_13;
    }
LABEL_12:
    a6 = 1;
    goto LABEL_13;
  }
  if (!a4) {
    goto LABEL_12;
  }
  if (a6)
  {
    uint64_t v19 = (void *)[[NSString alloc] initWithFormat:@"The %@ required option was not found", v12];
    uint64_t v20 = +[VNError errorWithCode:7 message:v19];
    goto LABEL_11;
  }
LABEL_13:

  return a6;
}

{
  id v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  objc_class *v17;
  void *v18;
  void *v19;
  void *v20;

  id v11 = a2;
  id v12 = a3;
  float v13 = [v11 objectForKey:v12];
  id v14 = v13;
  if (a1) {
    *a1 = v13;
  }
  if (v14)
  {
    if (a5 && (objc_opt_isKindOfClass() & 1) == 0)
    {
      if (a6)
      {
        id v15 = NSString;
        uint64_t v16 = NSStringFromClass(a5);
        uint64_t v17 = (objc_class *)objc_opt_class();
        uint64_t v18 = NSStringFromClass(v17);
        uint64_t v19 = [v15 stringWithFormat:@"The %@ option was expected to be a %@, but was instead a %@ (%@)", v12, v16, v18, v14];

        uint64_t v20 = +[VNError errorWithCode:5 message:v19];
LABEL_11:
        *(void *)a6 = v20;

        a6 = 0;
        goto LABEL_13;
      }
      goto LABEL_13;
    }
LABEL_12:
    a6 = 1;
    goto LABEL_13;
  }
  if (!a4) {
    goto LABEL_12;
  }
  if (a6)
  {
    uint64_t v19 = [NSString stringWithFormat:@"The %@ required option was not found", v12];
    uint64_t v20 = +[VNError errorWithCode:7 message:v19];
    goto LABEL_11;
  }
LABEL_13:

  return a6;
}

void sub_1A3EB83B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB84D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB85A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB8690(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB8764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB8878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB8994(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB8C10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB8CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB8E34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB8ECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB8FB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB9250(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB9344(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB94CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB95C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB964C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB973C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB9848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB98C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNRequestPrivateRevisionsSet(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v10 = objc_alloc_init(MEMORY[0x1E4F28E60]);
  id v14 = (unint64_t *)&a9;
  do
  {
    if (a1 >= 0xDECAF000) {
      [v10 addIndex:a1];
    }
    id v11 = v14++;
    a1 = *v11;
  }
  while (*v11);
  id v12 = (void *)[v10 copy];

  return v12;
}

void sub_1A3EB997C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL VNRequestRevisionIsPrivate(unint64_t a1)
{
  return a1 > 0xDECAEFFF;
}

void sub_1A3EB9A28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB9DC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB9EF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EB9F8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBA160(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBA2D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBA324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBA4C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBA630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBA72C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBA8AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBA94C(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3EBA960(_Unwind_Exception *a1)
{
}

void sub_1A3EBA9FC(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3EBAA24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBAB74(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3EBAB88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
}

void sub_1A3EBAC90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBAD60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBADDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBAEE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBB098(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBB2E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBB53C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBB944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBBC50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBBD74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBBED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBC1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  if (v11) {

  }
  _Unwind_Resume(a1);
}

void sub_1A3EBC2DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBC3A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBC650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBC758(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBD0F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  float v33 = *(void **)(v31 - 192);
  if (v33)
  {
    *(void *)(v31 - 184) = v33;
    operator delete(v33);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](a12);

  _Unwind_Resume(a1);
}

void sub_1A3EBD49C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBDC98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30)
{
  if (__p) {
    operator delete(__p);
  }
  float v34 = *(void **)(v32 - 120);
  if (v34)
  {
    *(void *)(v32 - 112) = v34;
    operator delete(v34);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v31);
  if (a19 < 0) {
    operator delete(a14);
  }
  if (a25 < 0) {
    operator delete(a20);
  }

  _Unwind_Resume(a1);
}

void sub_1A3EBDF50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EBE07C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorsForAugmentedImages(uint64_t a1, uint64_t *a2, uint64_t a3, void *a4, void *a5, uint64_t a6)
{
  id v11 = a5;
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 64))(&v15, a1);
  uint64_t v12 = vision::mod::ImageDescriptorAugmenterAbstract::augment(a4, *a2, a2[1], a3);
  if ((v12 & 0x80) != 0)
  {
    vision::mod::ImageDescriptorAugmenterAbstract::getAugmentedImages((vision::mod::ImageDescriptorAugmenterAbstract *)__p, (uint64_t)a4);
    uint64_t v12 = (*(uint64_t (**)(uint64_t, void **, uint64_t, id, uint64_t))(*(void *)a1 + 96))(a1, __p, a3, v11, v15);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if ((v12 & 0x80) != 0) {
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*a4 + 24))(a4, v15, a6);
    }
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }

  return v12;
}

void sub_1A3EBE214(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }

  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorsForImages(void *a1, uint64_t a2, int a3, void *a4, uint64_t a5)
{
  id v9 = a4;
  if (a3)
  {
    if ((a3 & (a3 - 1)) != 0)
    {
      syslog(5, "ERROR: this function can handle only one image type");
      uint64_t v11 = 3710;
      goto LABEL_12;
    }
    switch(a3)
    {
      case 4:
        id v10 = (uint64_t (**)(void *, uint64_t, id, uint64_t))(*a1 + 80);
        goto LABEL_11;
      case 2:
        id v10 = (uint64_t (**)(void *, uint64_t, id, uint64_t))(*a1 + 72);
        goto LABEL_11;
      case 1:
        id v10 = (uint64_t (**)(void *, uint64_t, id, uint64_t))(*a1 + 88);
LABEL_11:
        uint64_t v11 = (*v10)(a1, a2, v9, a5);
        goto LABEL_12;
    }
  }
  uint64_t v11 = 3708;
LABEL_12:

  return v11;
}

void sub_1A3EBE39C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForImage(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3) {
    return 3708;
  }
  if ((a3 & (a3 - 1)) != 0)
  {
    syslog(5, "ERROR: this function can handle only one image type");
    return 3710;
  }
  if (a3 == 4)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)a1 + 24);
    return v3();
  }
  if (a3 == 2)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)a1 + 16);
    return v3();
  }
  if (a3 != 1) {
    return 3708;
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)a1 + 32);

  return v3();
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForImage(vision::mod::ImageDescriptorProcessorAbstract *this, __CVBuffer *a2, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  return 3711;
}

BOOL prune(float *a1, uint64_t a2, float a3, float a4)
{
  if (!*(unsigned char *)a2) {
    return 0;
  }
  float v6 = *(float *)(a2 + 4);
  if (a3 != a4)
  {
    float v10 = *(float *)(a2 + 8);
    int v11 = *(_DWORD *)(a2 + 12);
    __float2 v12 = __sincosf_stret(a3 * 0.017453);
    float v13 = atan2f(v12.__sinval * v10, v12.__cosval) * 57.296;
    __float2 v14 = __sincosf_stret(a4 * 0.017453);
    float v15 = atan2f(v14.__sinval * v10, v14.__cosval) * 57.296;
    float v16 = (float)(v13 + v15) * 0.5;
    if (vabds_f32(v13, v15) > 90.0) {
      float v16 = fmodf(v16 + 90.0, 180.0);
    }
    BOOL v17 = v16 >= 22.5 && v16 < 67.5;
    float v18 = 1.0 / v10;
    if (!v17)
    {
      if (v16 >= 67.5 && v16 < 112.5)
      {
        float v36 = v18 * a1[1];
        float v37 = v18 * a1[2];
        float v38 = v18 * a1[9];
        float v39 = v18 * a1[10];
        float v27 = (float)(v39 / v38) - (float)(v37 / v36);
        float v40 = (float)(v39 + (float)(a1[8] * (float)(v11 - 1))) / v38;
        float v41 = (float)-(float)(v37 - (float)(*a1 * (float)(v11 - 1))) / v36;
      }
      else
      {
        float v20 = (float)(v11 - 1);
        float v21 = *a1;
        float v22 = v18 * a1[1];
        float v23 = v18 * a1[2];
        float v24 = a1[8];
        float v25 = v18 * a1[9];
        float v26 = v18 * a1[10];
        if (v16 >= 112.5 && v16 < 157.5)
        {
          float v27 = v23 - v26;
          float v28 = v23 + (float)((float)(v21 + v22) * v20);
          float v29 = v26 + (float)((float)(v24 + v25) * v20);
LABEL_21:
          float v35 = v28 - v29;
          goto LABEL_25;
        }
        float v27 = (float)(v26 / v24) - (float)(v23 / v21);
        float v40 = (float)(v26 + (float)(v25 * v20)) / v24;
        float v41 = (float)(v23 + (float)(v22 * v20)) / v21;
      }
      float v35 = v40 - v41;
LABEL_25:
      float v8 = fabsf(v27);
      float v42 = fabsf(v35);
      if (v8 <= v42) {
        float v8 = v42;
      }
      return v8 < v6;
    }
    float v30 = (float)(v11 - 1);
    float v31 = v18 * a1[1];
    float v32 = v18 * a1[2];
    float v33 = v18 * a1[9];
    float v34 = v18 * a1[10];
    float v27 = (float)(v32 + (float)(v31 * v30)) - (float)(v34 + (float)(v33 * v30));
    float v28 = v32 + (float)(*a1 * v30);
    float v29 = v34 + (float)(a1[8] * v30);
    goto LABEL_21;
  }
  signed int v7 = llroundf((float)(a3 * 1440.0) / 180.0);
  if (v7 == 1440) {
    signed int v7 = 0;
  }
  float v8 = cosScaleTab[v7] * vabds_f32(a1[2], a1[10]);
  return v8 < v6;
}

unint64_t singleton(unint64_t result, uint64_t a2, _DWORD *a3)
{
  unint64_t v3 = *(unsigned int *)result;
  float v4 = *(float *)(result + 4);
  long long v21 = *(unint64_t *)(result + 8);
  long long v22 = result;
  long long v23 = v21;
  long long v24 = result;
  if ((int)v3 < 2)
  {
    int v7 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    int v7 = 0;
    float v8 = (unsigned int *)(result + 16);
    uint64_t v19 = (v3 - 1);
    unint64_t v20 = v3;
    unint64_t v9 = v3 - 1;
    float v10 = (unsigned int *)(result + 20);
    int v11 = 1;
    __float2 v12 = &leqBuffer;
    do
    {
      uint64_t v13 = v6 + 1;
      if (v6 + 1 < v3)
      {
        uint64_t v14 = 0;
        do
        {
          DWORD2(v21) = v10[v14];
          DWORD2(v22) = v11 + v14;
          DWORD2(v23) = v8[v6];
          DWORD2(v24) = v6;
          __n128 result = prune((float *)&v21, a2, v4, v4);
          if ((result & 1) == 0)
          {
            long long v15 = v21;
            long long v16 = v22;
            long long v17 = v24;
            _DWORD v12[2] = v23;
            v12[3] = v17;
            *__float2 v12 = v15;
            v12[1] = v16;
            v12 += 4;
            ++v7;
          }
          ++v14;
        }
        while (v9 != v14);
      }
      ++v11;
      --v9;
      ++v10;
      ++v6;
      unint64_t v3 = v20;
    }
    while (v13 != v19);
  }
  *a3 = v7;
  return result;
}

unsigned int *doubleton(unsigned int *result, unsigned int *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v5 = *result;
  uint64_t v6 = *a2;
  memset(&v19[8], 0, 56);
  *(void *)uint64_t v19 = *((void *)result + 1);
  *(void *)&v19[16] = result;
  *(void *)&v19[32] = *((void *)a2 + 1);
  *(void *)&v19[48] = a2;
  if ((int)v5 < 1)
  {
    int v9 = 0;
  }
  else
  {
    uint64_t v8 = 0;
    int v9 = 0;
    float v10 = result + 4;
    int v11 = a2 + 4;
    float v12 = *((float *)result + 1);
    float v13 = *((float *)a2 + 1);
    uint64_t v14 = &leqBuffer;
    do
    {
      *(_DWORD *)&v19[8] = v10[v8];
      *(_DWORD *)&v19[24] = v8;
      if ((int)v6 >= 1)
      {
        for (uint64_t i = 0; i != v6; ++i)
        {
          *(_DWORD *)&v19[40] = v11[i];
          *(_DWORD *)&v19[56] = i;
          __n128 result = (unsigned int *)prune((float *)v19, a3, v12, v13);
          if ((result & 1) == 0)
          {
            long long v16 = *(_OWORD *)v19;
            long long v17 = *(_OWORD *)&v19[16];
            long long v18 = *(_OWORD *)&v19[48];
            v14[2] = *(_OWORD *)&v19[32];
            v14[3] = v18;
            *uint64_t v14 = v16;
            v14[1] = v17;
            v14 += 4;
            ++v9;
          }
        }
      }
      ++v8;
    }
    while (v8 != v5);
  }
  *a4 = v9;
  return result;
}

float *leqIntersect(float *result, float *a2, float *a3, float *a4)
{
  float v4 = a2[1];
  float v5 = result[1];
  float v6 = (float)(*result * v4) - (float)(*a2 * v5);
  if (fabsf(v6) < 0.00000001)
  {
    *a3 = -1.0;
    float v8 = -1.0;
  }
  else
  {
    float v7 = 1.0 / v6;
    *a3 = v7 * (float)((float)(v5 * a2[2]) - (float)(result[2] * v4));
    float v8 = v7 * (float)((float)(result[2] * *a2) - (float)(*result * a2[2]));
  }
  *a4 = v8;
  return result;
}

float cgNormalizedRectToGeometryImageRect(CGRect a1, unint64_t a2)
{
  return a1.origin.x * (double)a2;
}

void sub_1A3EBF1D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void apple::vision::OpticalFlow::LKTCPU::AllocationException::~AllocationException(std::bad_alloc *this)
{
  std::bad_alloc::~bad_alloc(this);

  JUMPOUT(0x1A62562C0);
}

void *apple::vision::AlignedAllocator<unsigned char,32ul>::allocate(size_t size)
{
  __n128 result = malloc_type_aligned_alloc(0x20uLL, size, 0x100004077774924uLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v3 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v3, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  return result;
}

int32x2_t apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::estimateFlow(int32x2_t *a1, __CVBuffer **a2, __CVBuffer **a3, int *a4)
{
  float v7 = *a2;
  int v11 = v7;
  if (v7) {
    CVPixelBufferRetain(v7);
  }
  apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::createImagePyramid((uint64_t)a1, &v11, a1[115].i32[1], a4);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&v11);
  bzero(*(void **)&a1[112], 8 * *(void *)&a1[2 * *a4 + 3] * *(void *)&a1[2 * *a4 + 4]);
  apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::calculateFeaturesAndDerivatives((uint64_t)a1, a1[115].i32[1], *a4);
  float v8 = *a3;
  float v10 = v8;
  if (v8) {
    CVPixelBufferRetain(v8);
  }
  apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::computeOpticalFlow((uint64_t)a1, &v10, a4);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&v10);
  int32x2_t result = vrev64_s32(a1[115]);
  a1[115] = result;
  return result;
}

void sub_1A3EBF370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __CVBuffer *a9)
{
}

void apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::createImagePyramid(uint64_t a1, CVPixelBufferRef *a2, int a3, int *a4)
{
  uint64_t v8 = a1 + 80 * a3;
  uint64_t v9 = *(void *)(v8 + 224);
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = *(void *)(v8 + 384);
  if (CVPixelBufferGetPixelFormatType(*a2) != 1111970369)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x18uLL);
    OSType v38 = apple::vision::CVPixelBufferWrapper::pixelFormatType(*a2);
    float v39 = apple::vision::OpticalFlow::LKTCPU::InvalidPixelFormatException::InvalidPixelFormatException(exception, v38);
  }
  float v13 = *a2;
  CVPixelBufferRef pixelBuffer = v13;
  if (v13) {
    CVPixelBufferRetain(v13);
  }
  size_t Width = CVPixelBufferGetWidth(v13);
  *((void *)&context + 1) = CVPixelBufferGetHeight(pixelBuffer);
  *(void *)&long long v44 = Width;
  *((void *)&v44 + 1) = CVPixelBufferGetBytesPerRow(pixelBuffer);
  apple::vision::CVPixelBufferWrapper::BaseAddressLock<1ull>::BaseAddressLock(&texture[8], pixelBuffer);
  *(void *)&long long context = CVPixelBufferGetBaseAddress(pixelBuffer);
  *(void *)texture = pixelBuffer;
  CVPixelBufferRef pixelBuffer = 0;
  long long v41 = context;
  long long v42 = v44;
  apple::vision::CVPixelBufferWrapper::BaseAddressLock<1ull>::~BaseAddressLock((CVPixelBufferRef *)&texture[8]);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper((__CVBuffer **)texture);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&pixelBuffer);
  if (*((unsigned char *)a4 + 8))
  {
    *(_OWORD *)texture = v41;
    *(_OWORD *)&texture[16] = v42;
    *(void *)&long long context = a1;
    *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::convertBGRA8888ToYUVF32;
    long long v44 = *(_OWORD *)(a1 + 40);
    uint64_t v46 = v9;
    uint64_t v47 = v11;
    uint64_t v48 = v10;
    uint64_t v49 = v10;
    uint64_t v50 = v12;
    uint64_t v51 = v11;
    uint64_t v52 = v10;
    uint64_t v53 = 2 * v10;
    size_t v15 = *(unsigned int *)(a1 + 16);
    long long v16 = (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS1_13Pixel_BGRA_8UES8_EENS6_INS0_9NamedTypeIhNS1_15YImageParameterEEESC_EENS6_INSA_IDv2_hNS1_16UVImageParameterEEESG_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSO_ENUlPvmE_8__invokeESR_m;
  }
  else
  {
    *(_OWORD *)texture = v41;
    *(_OWORD *)&texture[16] = v42;
    *(void *)&long long context = a1;
    *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::convertBGRA8888ToYF32;
    long long v44 = *(_OWORD *)(a1 + 40);
    uint64_t v46 = v9;
    uint64_t v47 = v11;
    uint64_t v48 = v10;
    uint64_t v49 = v10;
    size_t v15 = *(unsigned int *)(a1 + 16);
    long long v16 = (void (__cdecl *)(void *, size_t))apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::dispatchProcessing<apple::vision::ImageBuffer<apple::vision::OpticalFlow::Pixel_BGRA_8U const,apple::vision::OpticalFlow::Pixel_BGRA_8U const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>>>(void (*)(apple::vision::OpticalFlow::ComputeParameters const&,apple::vision::ImageBuffer<apple::vision::OpticalFlow::Pixel_BGRA_8U const,apple::vision::OpticalFlow::Pixel_BGRA_8U const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>> const&),int,apple::vision::ImageBuffer<apple::vision::OpticalFlow::Pixel_BGRA_8U const,apple::vision::OpticalFlow::Pixel_BGRA_8U const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>> const&)::{lambda(void *,unsigned long)#1}::__invoke;
  }
  dispatch_apply_f(v15, 0, &context, v16);
  if (*a4 >= 2)
  {
    uint64_t v17 = 0;
    int v18 = a3;
    uint64_t v19 = a1 + 392;
    unint64_t v20 = (uint64_t *)(a1 + 392 + 80 * v18);
    uint64_t v21 = 1;
    do
    {
      long long v22 = (int8x16_t *)(v19 + v17 - 352);
      uint64_t v23 = *(v20 - 21);
      uint64_t v24 = *(v20 - 20);
      float v25 = (uint64_t *)(v19 + v17 - 336);
      uint64_t v26 = *v25;
      float v27 = (uint64_t *)(v19 + v17 - 328);
      uint64_t v28 = *v27;
      *(void *)&long long context = a1;
      *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::downscale2x;
      *(void *)&long long v44 = v26;
      *((void *)&v44 + 1) = v28;
      *(void *)texture = v23;
      int8x16_t v29 = *v22;
      *(int8x16_t *)&texture[8] = vextq_s8(v29, v29, 8uLL);
      *(void *)&texture[24] = v29.i64[0];
      uint64_t v46 = v24;
      uint64_t v47 = v28;
      uint64_t v48 = v26;
      uint64_t v49 = v26;
      dispatch_apply_f(*(unsigned int *)(a1 + 16), 0, &context, (void (__cdecl *)(void *, size_t))apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::dispatchProcessing<apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>>>(void (*)(apple::vision::OpticalFlow::ComputeParameters const&,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>> const&),int,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>> const&)::{lambda(void *,unsigned long)#1}::__invoke);
      if (*((unsigned char *)a4 + 8))
      {
        uint64_t v30 = *(v20 - 1);
        uint64_t v31 = *v20;
        uint64_t v32 = *v25;
        uint64_t v33 = *v27;
        int8x16_t v34 = vextq_s8(*v22, *v22, 8uLL);
        uint64_t v35 = v22->i64[0];
        uint64_t v36 = 2 * *v25;
        *(void *)&long long context = a1;
        *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::downscale2x;
        *(void *)&long long v44 = v32;
        *((void *)&v44 + 1) = v33;
        *(void *)texture = v30;
        *(int8x16_t *)&texture[8] = v34;
        *(void *)&texture[24] = 2 * v35;
        uint64_t v46 = v31;
        uint64_t v47 = v33;
        uint64_t v48 = v32;
        uint64_t v49 = v36;
        dispatch_apply_f(*(unsigned int *)(a1 + 16), 0, &context, (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_hNS1_16UVImageParameterEEESB_EENS6_ISA_SA_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSK_ENUlPvmE_8__invokeESN_m);
      }
      ++v21;
      v17 += 16;
      ++v20;
    }
    while (v21 < *a4);
  }
}

void sub_1A3EBF698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

void apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::calculateFeaturesAndDerivatives(uint64_t a1, int a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v26 = v3;
    uint64_t v27 = v4;
    unint64_t v6 = a3 + 1;
    uint64_t v7 = a1 + 80 * a2;
    do
    {
      uint64_t v8 = (void *)(v7 + 8 * (v6 - 2));
      uint64_t v9 = v8[28];
      uint64_t v10 = a1 + 16 * (v6 - 2);
      uint64_t v11 = *(void *)(v10 + 40);
      uint64_t v12 = *(void *)(v10 + 48);
      uint64_t v13 = v8[68];
      uint64_t v14 = v8[88];
      uint64_t v15 = a1;
      long long v16 = apple::vision::OpticalFlow::LKTCPUCompute::computeFeatures;
      *(void *)&long long v17 = v11;
      *((void *)&v17 + 1) = v12;
      uint64_t v18 = v9;
      uint64_t v19 = v12;
      uint64_t v20 = v11;
      uint64_t v21 = v11;
      uint64_t v22 = v13;
      uint64_t v23 = v12;
      uint64_t v24 = v11;
      uint64_t v25 = 8 * v11;
      dispatch_apply_f(*(unsigned int *)(a1 + 16), 0, &v15, (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIhNS1_15YImageParameterEEESA_EENS6_INS7_IDv2_fNS1_16FeatureParameterEEESE_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSM_ENUlPvmE_8__invokeESP_m);
      uint64_t v15 = a1;
      long long v16 = apple::vision::OpticalFlow::LKTCPUCompute::computeDerivatives;
      long long v17 = *(_OWORD *)(v10 + 40);
      uint64_t v18 = v13;
      uint64_t v19 = v12;
      uint64_t v20 = v11;
      uint64_t v21 = 8 * v11;
      uint64_t v22 = v14;
      uint64_t v23 = v12;
      uint64_t v24 = v11;
      uint64_t v25 = 16 * v11;
      dispatch_apply_f(*(unsigned int *)(a1 + 16), 0, &v15, (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_16FeatureParameterEEESB_EENS6_INS7_IDv4_fNS1_19DerivativeParameterEEESF_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSN_ENUlPvmE_8__invokeESQ_m);
      --v6;
    }
    while (v6 > 1);
  }
}

void apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::computeOpticalFlow(uint64_t a1, __CVBuffer **a2, int *a3)
{
  uint64_t v3 = *a3;
  if ((int)v3 < 1)
  {
    uint64_t v79 = 0;
  }
  else
  {
    uint64_t v79 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    long long v65 = _Q0;
    __asm { FMOV            V10.2S, #-1.0 }
    do
    {
      int v10 = *a3 - 1;
      if ((int)v3 < v10) {
        int v10 = v3;
      }
      uint64_t v67 = v3 - 1;
      uint64_t v11 = a1 + 16 * (v3 - 1);
      uint64_t v12 = *(void *)(v11 + 40);
      uint64_t v68 = (uint64_t *)(v11 + 40);
      uint64_t v13 = *(void *)(v11 + 48);
      long long v14 = v65;
      if (*a3 != v3)
      {
        float32x2_t v15 = vcvt_f32_f64(vcvtq_f64_u64(*(uint64x2_t *)(v11 + 40)));
        float32x2_t v16 = vcvt_f32_f64(vcvtq_f64_u64(*(uint64x2_t *)(a1 + 16 * v3 + 40)));
        *(float32x2_t *)&long long v17 = vdiv_f32(v15, v16);
        *((float32x2_t *)&v17 + 1) = vdiv_f32(vadd_f32(v16, _D10), vadd_f32(v15, _D10));
        long long v14 = v17;
      }
      int v58 = v3;
      unint64_t v66 = (uint64_t *)(v11 + 48);
      int v18 = a3[1];
      if (v18 >= 1)
      {
        int v19 = 0;
        uint64_t v20 = v68;
        uint64_t v63 = 16 * v12;
        float v64 = *(__CVBuffer **)(a1 + 864);
        v21.i64[0] = v13;
        v21.i64[1] = v12;
        int8x16_t v83 = v21;
        uint64_t v62 = *(void *)(a1 + 872);
        uint64_t v60 = 4 * v12;
        uint64_t v61 = *(void *)(a1 + 880);
        uint64_t v59 = *(void *)(a1 + 888);
        do
        {
          uint64_t v84 = 0;
          uint64_t v22 = *v20;
          uint64_t v23 = *v66;
          int v78 = v19 + 1;
          if (v19 + 1 == v18)
          {
            uint64_t v81 = 0;
            uint64_t v82 = 0;
            uint64_t v80 = 0;
            if (*((unsigned char *)a3 + 8))
            {
              uint64_t v81 = *(void *)(a1 + 912);
              uint64_t v82 = *v20;
              uint64_t v84 = 4 * v22;
              uint64_t v80 = *v66;
            }
          }
          else
          {
            uint64_t v81 = 0;
            uint64_t v82 = 0;
            uint64_t v80 = 0;
          }
          int v72 = *(__CVBuffer **)(a1 + 896 + 8 * v79);
          int8x16_t v24 = *(int8x16_t *)(a1 + 16 * v10 + 40);
          int8x16_t v74 = vextq_s8(v24, v24, 8uLL);
          v79 ^= 1uLL;
          uint64_t v77 = *(void *)(a1 + 896 + 8 * v79);
          uint64_t v20 = v68;
          uint64_t v25 = *(void *)(a1 + 544 + 80 * *(unsigned int *)(a1 + 920) + 8 * v67);
          uint64_t v26 = *v68;
          uint64_t v27 = *(void *)(a1 + 704 + 80 * *(unsigned int *)(a1 + 920) + 8 * v67);
          uint64_t v28 = 5 * *(unsigned int *)(a1 + 924);
          uint64_t v29 = *(void *)(a1 + 544 + 80 * *(unsigned int *)(a1 + 924) + 8 * v67);
          int8x16_t v94 = v74;
          uint64_t v73 = 8 * v24.i64[0];
          uint64_t v95 = 8 * v24.i64[0];
          *(void *)uint64_t v107 = v64;
          *(int8x16_t *)&v107[8] = v83;
          uint64_t v108 = v63;
          uint64_t v109 = v61;
          uint64_t v30 = *(void *)(a1 + 704 + 16 * v28 + 8 * v67);
          int8x16_t v110 = v83;
          uint64_t v111 = v60;
          long long v71 = v14;
          long long v112 = v14;
          *((void *)&v92 + 1) = v23;
          CVPixelBufferRef v93 = v72;
          uint64_t v75 = v22;
          uint64_t v76 = 8 * v22;
          *(void *)&long long context = a1;
          *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::prepareMatrices;
          *(void *)&long long v92 = v26;
          *(void *)int v96 = v25;
          *(void *)&v96[8] = v23;
          *(void *)&v96[16] = v26;
          *(void *)&v96[24] = 8 * v26;
          uint64_t v97 = v27;
          v98.i64[0] = v23;
          v98.i64[1] = v26;
          uint64_t v99 = 16 * v26;
          uint64_t v100 = v29;
          v101.i64[0] = v23;
          v101.i64[1] = v26;
          uint64_t v102 = 8 * v26;
          uint64_t v103 = v30;
          uint64_t v104 = v23;
          uint64_t v105 = v26;
          uint64_t v106 = 16 * v26;
          dispatch_apply_f(*(unsigned int *)(a1 + 16), 0, &context, (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_13FlowParameterEEESB_EENS6_IKNS7_IS8_NS1_16FeatureParameterEEESF_EENS6_IKNS7_IDv4_fNS1_19DerivativeParameterEEESK_EESG_SL_NS6_INS7_ISH_NS1_21MatrixAdiagBParameterEEESN_EENS6_INS7_IfNS1_18MatrixIxyParameterEEESQ_EENS1_16SolverParametersEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSZ_ENUlPvmE_8__invokeES12_m);
          int8x16_t v98 = v83;
          uint64_t v99 = v63;
          uint64_t v100 = v59;
          int8x16_t v101 = v83;
          uint64_t v102 = v60;
          *(void *)&v96[24] = v60;
          uint64_t v97 = v62;
          *(void *)&long long context = a1;
          *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::solverBox7;
          long long v92 = *(_OWORD *)v68;
          CVPixelBufferRef v93 = v64;
          int8x16_t v94 = v83;
          uint64_t v95 = v63;
          *(void *)int v96 = v61;
          *(int8x16_t *)&v96[8] = v83;
          dispatch_apply_f(*(unsigned int *)(a1 + 16), 0, &context, (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv4_fNS1_21MatrixAdiagBParameterEEESB_EENS6_IKNS7_IfNS1_18MatrixIxyParameterEEESF_EENS6_ISA_SA_EENS6_ISE_SE_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSP_ENUlPvmE_8__invokeESS_m);
          int8x16_t v94 = v74;
          uint64_t v95 = v73;
          *(void *)int v96 = v62;
          *(_OWORD *)uint64_t v107 = v71;
          CVPixelBufferRef v93 = v72;
          *(void *)&long long context = a1;
          *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::solverBoxXAndAxb;
          long long v92 = *(_OWORD *)v68;
          *(int8x16_t *)&v96[8] = v83;
          *(void *)&v96[24] = v63;
          uint64_t v97 = v59;
          int8x16_t v98 = v83;
          uint64_t v99 = v60;
          uint64_t v100 = v77;
          v101.i64[0] = v23;
          v101.i64[1] = v75;
          uint64_t v102 = v76;
          uint64_t v103 = v81;
          uint64_t v104 = v80;
          uint64_t v105 = v82;
          uint64_t v106 = v84;
          dispatch_apply_f(*(unsigned int *)(a1 + 16), 0, &context, (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_13FlowParameterEEESB_EENS6_IKNS7_IDv4_fNS1_21MatrixAdiagBParameterEEESG_EENS6_IKNS7_IfNS1_18MatrixIxyParameterEEESK_EENS6_ISA_SA_EENS6_INS7_IfNS1_14NLRegParameterEEESO_EENS1_16SolverParametersEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSX_ENUlPvmE_8__invokeES10_m);
          int v18 = a3[1];
          long long v14 = v65;
          int v10 = v67;
          int v19 = v78;
        }
        while (v78 < v18);
      }
      if (*((unsigned char *)a3 + 8))
      {
        float v31 = *((float *)a3 + 7);
        int32x2_t v32 = *(int32x2_t *)(a3 + 3);
        uint64_t v33 = v67;
        uint64_t v34 = a1 + 80 * *(unsigned int *)(a1 + 920) + 8 * v67;
        uint64_t v35 = *(__CVBuffer **)(v34 + 224);
        uint64_t v36 = *v68;
        uint64_t v37 = *v66;
        uint64_t v38 = *(void *)(v34 + 384);
        uint64_t v39 = *(void *)(a1 + 896 + 8 * v79);
        v79 ^= 1uLL;
        uint64_t v40 = *(void *)(a1 + 896 + 8 * v79);
        uint64_t v41 = *(void *)(a1 + 912);
        *(float32x2_t *)uint64_t v107 = vdiv_f32((float32x2_t)0x3F0000003F000000, *(float32x2_t *)(a3 + 5));
        *(float *)&v107[8] = 0.5 / v31;
        *(int32x2_t *)&v107[12] = vrev64_s32(v32);
        *(void *)&long long context = a1;
        *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::nonLocalRegularization;
        *(void *)&long long v92 = v36;
        *((void *)&v92 + 1) = v37;
        CVPixelBufferRef v93 = v35;
        v94.i64[0] = v37;
        v94.i64[1] = v36;
        uint64_t v95 = v36;
        *(void *)int v96 = v38;
        *(void *)&v96[8] = v37;
        *(void *)&v96[16] = v36;
        *(void *)&v96[24] = 2 * v36;
        uint64_t v97 = v39;
        v98.i64[0] = v37;
        v98.i64[1] = v36;
        uint64_t v99 = 8 * v36;
        uint64_t v100 = v41;
        v101.i64[0] = v37;
        v101.i64[1] = v36;
        uint64_t v102 = 4 * v36;
        uint64_t v103 = v40;
        uint64_t v104 = v37;
        uint64_t v105 = v36;
        uint64_t v106 = 8 * v36;
        dispatch_apply_f(*(unsigned int *)(a1 + 16), 0, &context, (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIhNS1_15YImageParameterEEESA_EENS6_IKNS7_IDv2_hNS1_16UVImageParameterEEESF_EENS6_IKNS7_IDv2_fNS1_13FlowParameterEEESK_EENS6_IKNS7_IfNS1_14NLRegParameterEEESO_EENS6_ISJ_SJ_EENS1_12NLParametersEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSY_ENUlPvmE_8__invokeES11_m);
      }
      else
      {
        uint64_t v33 = v67;
      }
      uint64_t v3 = v33;
    }
    while ((v58 & 0xFFFFFFFE) != 0);
  }
  long long v42 = *(__CVBuffer **)(a1 + 8 * v79 + 896);
  int8x16_t v85 = *(int8x16_t *)(a1 + 40);
  uint64_t v43 = *a2;
  CVPixelBufferRef texture = v43;
  if (v43) {
    CVPixelBufferRetain(v43);
  }
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v43);
  uint64_t v45 = 8 * v85.i64[0];
  int8x16_t v86 = vextq_s8(v85, v85, 8uLL);
  if (PixelFormatType == 843264102)
  {
    CVPixelBufferRef pixelBuffer = texture;
    if (texture) {
      CVPixelBufferRetain(texture);
    }
    size_t Width = CVPixelBufferGetWidth(texture);
    size_t Height = CVPixelBufferGetHeight(pixelBuffer);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
    *(void *)&long long context = 0;
    *((void *)&context + 1) = Height;
    *(void *)&long long v92 = Width;
    *((void *)&v92 + 1) = BytesPerRow;
    CVPixelBufferRef v93 = 0;
    apple::vision::CVPixelBufferWrapper::BaseAddressLock<0ull>::BaseAddressLock(&v94, pixelBuffer);
    *(void *)&long long context = CVPixelBufferGetBaseAddress(pixelBuffer);
    if (v93) {
      CVPixelBufferRelease(v93);
    }
    CVPixelBufferRef v93 = pixelBuffer;
    CVPixelBufferRef pixelBuffer = 0;
    long long v89 = context;
    long long v90 = v92;
    apple::vision::CVPixelBufferWrapper::BaseAddressLock<0ull>::~BaseAddressLock((CVPixelBufferRef *)&v94);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&v93);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&pixelBuffer);
    *(void *)&long long context = a1;
    *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::copyFlowToOutput32F;
    long long v92 = *(_OWORD *)(a1 + 40);
    CVPixelBufferRef v93 = v42;
    int8x16_t v94 = v86;
    uint64_t v95 = v45;
    *(_OWORD *)int v96 = v89;
    *(_OWORD *)&v96[16] = v90;
    size_t v49 = *(unsigned int *)(a1 + 16);
    uint64_t v50 = (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_13FlowParameterEEESB_EENS6_INS1_12Pixel_UV_32FESD_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSL_ENUlPvmE_8__invokeESO_m;
  }
  else
  {
    if (PixelFormatType != 843264104)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x18uLL);
      OSType v55 = CVPixelBufferGetPixelFormatType(texture);
      int v56 = apple::vision::OpticalFlow::LKTCPU::InvalidPixelFormatException::InvalidPixelFormatException(exception, v55);
    }
    CVPixelBufferRef pixelBuffer = texture;
    if (texture) {
      CVPixelBufferRetain(texture);
    }
    size_t v46 = CVPixelBufferGetWidth(texture);
    size_t v47 = CVPixelBufferGetHeight(pixelBuffer);
    size_t v48 = CVPixelBufferGetBytesPerRow(pixelBuffer);
    *(void *)&long long context = 0;
    *((void *)&context + 1) = v47;
    *(void *)&long long v92 = v46;
    *((void *)&v92 + 1) = v48;
    CVPixelBufferRef v93 = 0;
    apple::vision::CVPixelBufferWrapper::BaseAddressLock<0ull>::BaseAddressLock(&v94, pixelBuffer);
    *(void *)&long long context = CVPixelBufferGetBaseAddress(pixelBuffer);
    if (v93) {
      CVPixelBufferRelease(v93);
    }
    CVPixelBufferRef v93 = pixelBuffer;
    CVPixelBufferRef pixelBuffer = 0;
    long long v89 = context;
    long long v90 = v92;
    apple::vision::CVPixelBufferWrapper::BaseAddressLock<0ull>::~BaseAddressLock((CVPixelBufferRef *)&v94);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&v93);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&pixelBuffer);
    *(void *)&long long context = a1;
    *((void *)&context + 1) = apple::vision::OpticalFlow::LKTCPUCompute::copyFlowToOutput16F;
    long long v92 = *(_OWORD *)(a1 + 40);
    CVPixelBufferRef v93 = v42;
    int8x16_t v94 = v86;
    uint64_t v95 = v45;
    *(_OWORD *)int v96 = v89;
    *(_OWORD *)&v96[16] = v90;
    size_t v49 = *(unsigned int *)(a1 + 16);
    uint64_t v50 = (void (__cdecl *)(void *, size_t))_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_13FlowParameterEEESB_EENS6_INS1_12Pixel_UV_16FESD_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSL_ENUlPvmE_8__invokeESO_m;
  }
  dispatch_apply_f(v49, 0, &context, v50);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&texture);
}

void sub_1A3EBFFA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,__CVBuffer *a43,__int16 a44,char a45,char a46)
{
  __cxa_free_exception(v46);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&a43);
  _Unwind_Resume(a1);
}

void *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIhNS1_15YImageParameterEEESA_EENS6_IKNS7_IDv2_hNS1_16UVImageParameterEEESF_EENS6_IKNS7_IDv2_fNS1_13FlowParameterEEESK_EENS6_IKNS7_IfNS1_14NLRegParameterEEESO_EENS6_ISJ_SJ_EENS1_12NLParametersEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSY_ENUlPvmE_8__invokeES11_m(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v2 = (uint64_t (*)(void *))result[1];
    uint64_t v4 = result[2];
    unint64_t v3 = result[3];
    float v5 = (long long *)(result + 4);
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v3 / v6;
    uint64_t v8 = v3 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      int8x16_t v21 = (long long *)(result + 12);
      uint64_t v22 = (long long *)(result + 8);
      int v19 = (long long *)(result + 20);
      uint64_t v20 = (long long *)(result + 16);
      int v18 = result + 24;
      do
      {
        v23[0] = ++v11;
        v23[1] = v4;
        v23[2] = v3;
        long long v13 = v5[1];
        long long v24 = *v5;
        long long v25 = v13;
        long long v14 = v22[1];
        long long v26 = *v22;
        long long v27 = v14;
        long long v15 = v21[1];
        long long v28 = *v21;
        long long v29 = v15;
        long long v16 = v20[1];
        long long v30 = *v20;
        long long v31 = v16;
        long long v17 = v19[1];
        long long v32 = *v19;
        long long v33 = v17;
        int v35 = *((_DWORD *)v18 + 4);
        long long v34 = *(_OWORD *)v18;
        int32x2_t result = (void *)v2(v23);
      }
      while (v10 != v11);
    }
  }
  return result;
}

void *apple::vision::OpticalFlow::LKTCPUCompute::nonLocalRegularization(void *result, void *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, void *a6, int32x4_t *a7)
{
  uint64_t v7 = *result;
  if ((*result & 1) == 0 && (uint64_t)result[1] >= 1)
  {
    int v9 = a3;
    uint64_t v11 = 0;
    int32x4_t v12 = vzip1q_s32(*a7, (int32x4_t)vextq_s8(*(int8x16_t *)a7, *(int8x16_t *)a7, 4uLL));
    float32x4_t v117 = (float32x4_t)v12;
    unint64_t v105 = (int)v7 + 1;
    uint64_t v106 = (int)v7;
    uint64_t v104 = v7 + 1;
    float32x2_t v13 = (float32x2_t)vdup_n_s32(0x437F0000u);
    uint64_t v107 = *result;
    uint64_t v108 = result;
    do
    {
      v12.i64[0] = __PAIR64__(v7, v11);
      int8x16_t v126 = (int8x16_t)v12;
      int v15 = v7;
      uint64_t v16 = v11;
      long long v17 = result;
      unsigned int v18 = apple::vision::OpticalFlow::LKTCPUCompute::gather<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const>(a2, COERCE_DOUBLE(__PAIR64__(v7, v11)));
      unint64_t v19 = _ZN5apple6vision11OpticalFlow13LKTCPUCompute6gatherIKNS0_9NamedTypeIDv2_hNS1_16UVImageParameterEEEEEDaRKNS0_11ImageBufferIT_SB_EEDv2_i(v9, *(double *)v126.i64);
      uint64_t v23 = a7->i32[3];
      *(int32x2_t *)v28.f32 = vdup_n_s32(a7[1].i32[0] * (int)v23);
      uint64_t v111 = v16;
      v27.i32[0] = (int)v16 / (int)v23;
      v27.i32[1] = v15 / (int)v23;
      v24.i64[1] = v126.i64[1];
      int32x2_t v25 = vadd_s32((int32x2_t)vmvn_s8(*(int8x8_t *)v126.i8), vmovn_s64(*(int64x2_t *)(v17 + 1)));
      v26.i32[0] = v25.i32[0] / (int)v23;
      v26.i32[1] = v25.i32[1] / (int)v23;
      v26.i64[1] = v126.i64[1];
      *(int32x2_t *)v27.i8 = vsub_s32(*(int32x2_t *)v126.i8, vmin_s32(*(int32x2_t *)v27.i8, *(int32x2_t *)v28.f32));
      *(int32x2_t *)v28.f32 = vadd_s32(vmin_s32(*(int32x2_t *)v26.i8, *(int32x2_t *)v28.f32), *(int32x2_t *)v126.i8);
      float32x2_t v29 = 0;
      float32x2_t v30 = 0;
      float32x2_t v31 = 0;
      float32x2_t v32 = 0;
      int32x4_t v33 = 0uLL;
      if ((vcgt_s32(*(int32x2_t *)&v27, *(int32x2_t *)&v28).i32[1] & 1) == 0)
      {
        int v34 = 0;
        *(float *)v24.i32 = (float)v18;
        v35.f32[0] = (float)v19;
        v35.f32[1] = (float)BYTE1(v19);
        *(float32x2_t *)((char *)v24.i64 + 4) = vdiv_f32(v35, v13);
        *(float *)v21.i32 = (float)BYTE1(v18);
        uint64x2_t v36 = (uint64x2_t)vdupq_n_s64(v19);
        *(float32x2_t *)((char *)v21.i64 + 4) = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vmovn_s64((int64x2_t)vshlq_u64(v36, (uint64x2_t)xmmword_1A410C190)), (int8x8_t)0xFF000000FFLL)), v13);
        v22.f32[0] = (float)BYTE2(v18);
        int64x2_t v20 = (int64x2_t)vshlq_u64(v36, (uint64x2_t)xmmword_1A410C1A0);
        *(float32x2_t *)&v22.i32[1] = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vmovn_s64(v20), (int8x8_t)0xFF000000FFLL)), v13);
        *(float *)v20.i32 = (float)HIBYTE(v18);
        *(float32x2_t *)((char *)v20.i64 + 4) = vdiv_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmovn_s64((int64x2_t)vshlq_u64(v36, (uint64x2_t)xmmword_1A410C1B0)) & 0xFFFF00FFFFFF00FFLL)), v13);
        int v115 = v28.i32[1];
        int8x16_t v26 = v27;
        uint64_t v37 = v27.i32[0];
        __int32 v38 = v28.i32[0];
        int v112 = v27.i32[0] + v23;
        uint64_t v114 = v27.i32[0];
        uint64_t v122 = v28.i32[0];
        float32x4_t v120 = (float32x4_t)v20;
        float32x4_t v121 = (float32x4_t)v21;
        float32x4_t v118 = v22;
        float32x4_t v119 = (float32x4_t)v24;
        do
        {
          v26.i32[0] = v34 + v37;
          int v116 = v34;
          if (v34 + (int)v37 <= v38)
          {
            uint64_t v39 = v37 + v34;
            __int32 v40 = v112 + v34;
            do
            {
              float32x4_t v125 = (float32x4_t)v33;
              int8x16_t v127 = v26;
              unsigned int v41 = apple::vision::OpticalFlow::LKTCPUCompute::gather<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const>(a2, *(double *)v26.i64);
              long long v42 = a2;
              unsigned int v43 = BYTE1(v41);
              unsigned int v44 = v41;
              unsigned int v45 = BYTE2(v41);
              unsigned int v46 = HIBYTE(v41);
              unint64_t v47 = _ZN5apple6vision11OpticalFlow13LKTCPUCompute6gatherIKNS0_9NamedTypeIDv2_hNS1_16UVImageParameterEEEEEDaRKNS0_11ImageBufferIT_SB_EEDv2_i(a3, *(double *)v127.i64);
              if (a5[2] - 1 >= (unint64_t)(v127.i32[0] + 1)) {
                uint64_t v49 = v127.i32[0] + 1;
              }
              else {
                uint64_t v49 = a5[2] - 1;
              }
              v50.i64[1] = v127.i64[1];
              int v51 = v127.i32[1] + 1;
              uint64_t v52 = *a5;
              unint64_t v53 = a5[1] - 1;
              if (v53 >= v127.i32[1] + 1) {
                unint64_t v53 = v51;
              }
              unint64_t v54 = (unint64_t)a5[3] >> 2;
              uint64_t v55 = v52 + 4 * v54 * v127.i32[1];
              int v56 = (__int32 *)(v55 + 4 * v127.i32[0]);
              float v57 = (__int32 *)(v55 + 4 * v49);
              uint64_t v58 = v52 + 4 * v54 * v53;
              uint64_t v59 = (__int32 *)(v58 + 4 * v127.i32[0]);
              uint64_t v60 = (__int32 *)(v58 + 4 * v49);
              unint64_t v61 = a4[3];
              if (a4[2] - 1 >= (unint64_t)(v39 + 1)) {
                uint64_t v62 = v39 + 1;
              }
              else {
                uint64_t v62 = a4[2] - 1;
              }
              uint64_t v63 = *a4;
              unint64_t v64 = a4[1] - 1;
              if (v64 >= v51) {
                unint64_t v64 = v51;
              }
              uint64_t v65 = v63 + 8 * (v61 >> 3) * v127.i32[1];
              float32x2_t v66 = *(float32x2_t *)(v65 + 8 * v39);
              float32x2_t v67 = *(float32x2_t *)(v65 + 8 * v62);
              uint64_t v68 = v63 + 8 * (v61 >> 3) * v64;
              float32x2_t v69 = *(float32x2_t *)(v68 + 8 * v39);
              float32x2_t v124 = *(float32x2_t *)(v68 + 8 * v62);
              v50.i32[1] = v124.i32[1];
              *(float *)v50.i32 = (float)v44;
              *(float *)v48.i32 = (float)v47;
              *(float *)&v48.i32[1] = (float)BYTE1(v47);
              *(float32x2_t *)v48.i8 = vdiv_f32(*(float32x2_t *)v48.i8, v13);
              float32x4_t v70 = (float32x4_t)vextq_s8(vextq_s8(v50, v50, 4uLL), v48, 0xCuLL);
              *(float *)v48.i32 = (float)v43;
              a2 = v42;
              uint64x2_t v71 = (uint64x2_t)vdupq_n_s64(v47);
              int64x2_t v72 = (int64x2_t)vshlq_u64(v71, (uint64x2_t)xmmword_1A410C190);
              *(float32x2_t *)v72.i8 = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vmovn_s64(v72), (int8x8_t)0xFF000000FFLL)), v13);
              float32x4_t v73 = (float32x4_t)vextq_s8(vextq_s8(v48, v48, 4uLL), (int8x16_t)v72, 0xCuLL);
              *(float *)v72.i32 = (float)v45;
              int64x2_t v74 = (int64x2_t)vshlq_u64(v71, (uint64x2_t)xmmword_1A410C1A0);
              *(float32x2_t *)v74.i8 = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vmovn_s64(v74), (int8x8_t)0xFF000000FFLL)), v13);
              float32x4_t v75 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v72, (int8x16_t)v72, 4uLL), (int8x16_t)v74, 0xCuLL);
              *(float *)v74.i32 = (float)v46;
              int64x2_t v76 = (int64x2_t)vshlq_u64(v71, (uint64x2_t)xmmword_1A410C1B0);
              *(float32x2_t *)v76.i8 = vdiv_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmovn_s64(v76) & 0xFFFF00FFFFFF00FFLL)), v13);
              float32x4_t v77 = vsubq_f32(v119, v70);
              v77.i32[3] = *v56;
              float32x4_t v78 = vsubq_f32(v121, v73);
              v78.i32[3] = *v57;
              float32x4_t v79 = vsubq_f32(v118, v75);
              v79.i32[3] = *v59;
              float32x4_t v80 = vsubq_f32(v120, (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v74, (int8x16_t)v74, 4uLL), (int8x16_t)v76, 0xCuLL));
              v80.i32[3] = *v60;
              float32x4_t v81 = vmulq_f32(v117, v77);
              float32x4_t v82 = vmulq_f32(v81, v81);
              *(float32x2_t *)v82.f32 = vadd_f32(*(float32x2_t *)v82.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v82, (int8x16_t)v82, 8uLL));
              float32x4_t v83 = vmulq_f32(v117, v78);
              int8x16_t v84 = (int8x16_t)vmulq_f32(v83, v83);
              *(float32x2_t *)v84.i8 = vadd_f32(*(float32x2_t *)v84.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v84, v84, 8uLL));
              float32x4_t v85 = vmulq_f32(v117, v79);
              int8x16_t v86 = (int8x16_t)vmulq_f32(v85, v85);
              *(float32x2_t *)v86.i8 = vadd_f32(*(float32x2_t *)v86.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v86, v86, 8uLL));
              float32x4_t v87 = vmulq_f32(v117, v80);
              int8x16_t v88 = (int8x16_t)vmulq_f32(v87, v87);
              *(int32x2_t *)v89.f32 = vzip1_s32(*(int32x2_t *)v82.f32, *(int32x2_t *)v84.i8);
              v89.i32[2] = v86.i32[0];
              *(float32x2_t *)v88.i8 = vadd_f32(*(float32x2_t *)v88.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v88, v88, 8uLL));
              v89.i32[3] = v88.i32[0];
              *(int32x2_t *)v82.f32 = vzip2_s32(*(int32x2_t *)v82.f32, *(int32x2_t *)v84.i8);
              v82.i64[1] = __PAIR64__(v88.u32[1], vdup_lane_s32(*(int32x2_t *)v86.i8, 1).u32[0]);
              simd_float4 v28 = _simd_exp_f4((simd_float4)vnegq_f32(vaddq_f32(v89, v82)));
              __int32 v38 = v122;
              int8x16_t v26 = v127;
              int32x4_t v33 = (int32x4_t)vaddq_f32(v125, (float32x4_t)v28);
              float32x2_t v32 = vmla_n_f32(v32, v66, v28.f32[0]);
              float32x2_t v31 = vmla_lane_f32(v31, v67, *(float32x2_t *)v28.f32, 1);
              float32x2_t v30 = vmla_laneq_f32(v30, v69, (float32x4_t)v28, 2);
              float32x2_t v29 = vmla_laneq_f32(v29, v124, (float32x4_t)v28, 3);
              v39 += v23;
              v26.i32[0] = v40;
              v40 += v23;
            }
            while (v39 <= v122);
          }
          int v34 = v23 + ~v116;
          v26.i32[1] += v23;
          uint64_t v37 = v114;
        }
        while (v26.i32[1] <= v115);
      }
      unint64_t v90 = (int)v111 | 1;
      if (a4[2] - 1 < v90) {
        unint64_t v90 = a4[2] - 1;
      }
      uint64_t v91 = *a4;
      unint64_t v92 = a4[1] - 1;
      if (v92 >= v105) {
        unint64_t v92 = v105;
      }
      unint64_t v93 = (unint64_t)a4[3] >> 3;
      uint64_t v94 = v91 + 8 * v93 * v106;
      v26.i64[0] = *(void *)(v94 + 8 * v90);
      uint64_t v95 = v91 + 8 * v93 * v92;
      v28.i64[0] = *(void *)(v95 + 8 * v90);
      *(int32x2_t *)v24.i8 = vdup_lane_s32(*(int32x2_t *)v33.i8, 0);
      if (*(float *)v33.i32 <= 0.00097656) {
        unsigned int v96 = 0;
      }
      else {
        unsigned int v96 = -1;
      }
      *(float32x2_t *)v24.i8 = vdiv_f32(v32, *(float32x2_t *)v24.i8);
      int8x16_t v97 = (int8x16_t)vcltzq_s32((int32x4_t)vdupq_n_s32(v96).u64[0]);
      v27.i64[0] = *(void *)(v94 + 8 * (int)v111);
      v27.i64[0] = vbslq_s8(v97, v24, v27).u64[0];
      *(int32x2_t *)v97.i8 = vdup_lane_s32(*(int32x2_t *)v33.i8, 1);
      if (*(float *)&v33.i32[1] <= 0.00097656) {
        unsigned int v98 = 0;
      }
      else {
        unsigned int v98 = -1;
      }
      *(float32x2_t *)v97.i8 = vdiv_f32(v31, *(float32x2_t *)v97.i8);
      unint64_t v99 = vbslq_s8((int8x16_t)vcltzq_s32((int32x4_t)vdupq_n_s32(v98).u64[0]), v97, v26).u64[0];
      *(int32x2_t *)v97.i8 = vdup_laneq_s32(v33, 2);
      if (*(float *)&v33.i32[2] <= 0.00097656) {
        unsigned int v100 = 0;
      }
      else {
        unsigned int v100 = -1;
      }
      *(float32x2_t *)v97.i8 = vdiv_f32(v30, *(float32x2_t *)v97.i8);
      v20.i64[0] = *(void *)(v95 + 8 * (int)v111);
      v20.i64[0] = vbslq_s8((int8x16_t)vcltzq_s32((int32x4_t)vdupq_n_s32(v100).u64[0]), v97, (int8x16_t)v20).u64[0];
      float32x2_t v101 = (float32x2_t)vdup_laneq_s32(v33, 3);
      if (*(float *)&v33.i32[3] <= 0.00097656) {
        unsigned int v102 = 0;
      }
      else {
        unsigned int v102 = -1;
      }
      *(float32x2_t *)v21.i8 = vdiv_f32(v29, v101);
      LODWORD(v7) = v107;
      *(void *)(*a6 + 8 * (a6[3] >> 3) * v107 + 8 * v111) = v27.i64[0];
      uint64_t v103 = (8 * v111) | 8;
      *(void *)(*a6 + 8 * (a6[3] >> 3) * v107 + v103) = v99;
      int32x4_t v12 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32((int32x4_t)vdupq_n_s32(v102).u64[0]), v21, (int8x16_t)v28);
      *(void *)(*a6 + 8 * (a6[3] >> 3) * v104 + 8 * v111) = v20.i64[0];
      *(void *)(*a6 + 8 * (a6[3] >> 3) * v104 + v103) = v12.i64[0];
      uint64_t v11 = v111 + 2;
      int32x2_t result = v108;
      int v9 = a3;
    }
    while (v111 + 2 < v108[1]);
  }
  return result;
}

uint64_t apple::vision::OpticalFlow::LKTCPUCompute::gather<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const>(void *a1, double a2)
{
  LODWORD(v2) = LODWORD(a2) + 1;
  if (a1[2] - 1 >= (unint64_t)(LODWORD(a2) + 1)) {
    uint64_t v2 = (int)v2;
  }
  else {
    uint64_t v2 = a1[2] - 1;
  }
  unint64_t v4 = HIDWORD(a2) + 1;
  if (a1[1] - 1 < v4) {
    unint64_t v4 = a1[1] - 1;
  }
  uint64_t v3 = a1[3];
  return *(unsigned __int8 *)(*a1 + v3 * SHIDWORD(a2) + SLODWORD(a2)) | (*(unsigned __int8 *)(*a1
                                                                                            + v3 * SHIDWORD(a2)
                                                                                            + v2) << 8) | (*(unsigned __int8 *)(*a1 + v4 * v3 + SLODWORD(a2)) << 16) | (*(unsigned __int8 *)(*a1 + v4 * v3 + v2) << 24);
}

unint64_t _ZN5apple6vision11OpticalFlow13LKTCPUCompute6gatherIKNS0_9NamedTypeIDv2_hNS1_16UVImageParameterEEEEEDaRKNS0_11ImageBufferIT_SB_EEDv2_i(uint64_t *a1, double a2)
{
  unint64_t v2 = a1[3];
  unint64_t v3 = LODWORD(a2) + 1;
  if (a1[2] - 1 < v3) {
    unint64_t v3 = a1[2] - 1;
  }
  uint64_t v4 = *a1;
  uint64_t v5 = HIDWORD(a2) + 1;
  if (a1[1] - 1 < (unint64_t)(int)v5) {
    uint64_t v5 = a1[1] - 1;
  }
  uint64_t v6 = v4 + 2 * (v2 >> 1) * SHIDWORD(a2);
  return *(unsigned __int16 *)(v6 + 2 * SLODWORD(a2)) | ((unint64_t)*(unsigned __int16 *)(v6 + 2 * v3) << 16) | ((unint64_t)*(unsigned __int16 *)(v4 + 2 * (v2 >> 1) * v5 + 2 * SLODWORD(a2)) << 32) | ((unint64_t)*(unsigned __int16 *)(v4 + 2 * (v2 >> 1) * v5 + 2 * v3) << 48);
}

long long *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_13FlowParameterEEESB_EENS6_IKNS7_IDv4_fNS1_21MatrixAdiagBParameterEEESG_EENS6_IKNS7_IfNS1_18MatrixIxyParameterEEESK_EENS6_ISA_SA_EENS6_INS7_IfNS1_14NLRegParameterEEESO_EENS1_16SolverParametersEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSX_ENUlPvmE_8__invokeES10_m(long long *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *))*((void *)result + 1);
    uint64_t v4 = *((void *)result + 2);
    unint64_t v3 = *((void *)result + 3);
    uint64_t v5 = result + 2;
    unint64_t v6 = *(unsigned int *)(*(void *)result + 16);
    unint64_t v7 = v3 / v6;
    uint64_t v8 = v3 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      int8x16_t v21 = result + 6;
      float32x4_t v22 = result + 4;
      unint64_t v19 = result + 10;
      int64x2_t v20 = result + 8;
      unsigned int v18 = result + 12;
      do
      {
        v23[0] = ++v11;
        v23[1] = v4;
        v23[2] = v3;
        long long v13 = v5[1];
        long long v24 = *v5;
        long long v25 = v13;
        long long v14 = v22[1];
        long long v26 = *v22;
        long long v27 = v14;
        long long v15 = v21[1];
        long long v28 = *v21;
        long long v29 = v15;
        long long v16 = v20[1];
        long long v30 = *v20;
        long long v31 = v16;
        long long v17 = v19[1];
        long long v32 = *v19;
        long long v33 = v17;
        long long v34 = *v18;
        int32x2_t result = (long long *)v2(v23);
      }
      while (v10 != v11);
    }
  }
  return result;
}

void apple::vision::OpticalFlow::LKTCPUCompute::solverBoxXAndAxb(uint64_t *a1, uint64_t *a2, void *a3, void *a4, void *a5, uint64_t *a6, float32x2_t *a7)
{
  uint64_t v7 = a1[1];
  if (v7 >= 1)
  {
    uint64_t v14 = 0;
    uint64_t v15 = *a1;
    float v46 = (float)*a1;
    __asm { FMOV            V0.4S, #7.0 }
    float32x4_t v45 = _Q0;
    float32x2_t v22 = *a7;
    float32x2_t v21 = a7[1];
    uint64_t v43 = 16 * *a1;
    uint64_t v44 = 4 * *a1;
    __asm
    {
      FMOV            V12.2S, #-1.0
      FMOV            V13.2S, #1.0
    }
    do
    {
      if (v14 <= 3) {
        uint64_t v25 = 3;
      }
      else {
        uint64_t v25 = v14;
      }
      v26.f32[0] = (float)v14;
      v26.f32[1] = v46;
      float32x2_t v28 = _ZN5apple6vision11OpticalFlow13LKTCPUCompute8sampleLNINS0_9NamedTypeIDv2_fNS1_13FlowParameterEEEEET_RKNS0_11ImageBufferIKS8_SA_EES5_(a2, COERCE_DOUBLE(vmul_f32(v21, v26)));
      uint64_t v29 = v14 + 3;
      if (v7 - 1 < v14 + 3) {
        uint64_t v29 = v7 - 1;
      }
      float v30 = 0.0;
      float32x4_t v31 = 0uLL;
      if (v25 - 3 <= v29)
      {
        do
        {
          float32x4_t v31 = vaddq_f32(v31, *(float32x4_t *)(*a3 + v43 * (a3[3] >> 4) - 48 + 16 * v25));
          float v30 = v30 + *(float *)(*a4 + v44 * (a4[3] >> 2) - 12 + 4 * v25);
          uint64_t v32 = v25 - 3;
          ++v25;
        }
        while (v32 < v29);
      }
      _Q2 = vdivq_f32(v31, v45);
      _S15 = v30 / 7.0;
      _S9 = _Q2.i32[1];
      *(float *)v27.i32 = vmlas_n_f32(-(float)(_S15 * _S15), _Q2.f32[1], _Q2.f32[0]);
      uint64_t v36 = *a6;
      if (*a6)
      {
        __int32 v47 = _Q2.i32[2];
        int32x2_t v48 = v27;
        float v37 = expf((float)((float)(sqrtf(fmaxf((float)(*(float *)v27.i32 * -4.0)+ (float)((float)(_Q2.f32[0] + _Q2.f32[1]) * (float)(_Q2.f32[0] + _Q2.f32[1])), 0.0))* -0.5)+ (float)((float)(_Q2.f32[0] + _Q2.f32[1]) * 0.5))* -0.5);
        _Q2.i32[2] = v47;
        int32x2_t v27 = v48;
        *(float *)(v36 + 4 * ((unint64_t)a6[3] >> 2) * v15 + 4 * v14) = v37;
      }
      __asm
      {
        FMLA            S0, S9, V2.S[2]
        FMLS            S1, S15, V2.S[2]
      }
      _D0.i32[1] = _S1;
      float32x2_t v40 = vmul_f32(v22, v28);
      int8x8_t v41 = (int8x8_t)vdiv_f32(_D0, (float32x2_t)vdup_lane_s32(v27, 0));
      if (*(float *)v27.i32 <= 0.0) {
        unsigned int v42 = 0;
      }
      else {
        unsigned int v42 = -1;
      }
      *(float32x2_t *)(*a5 + 8 * (a5[3] >> 3) * v15 + 8 * v14++) = vadd_f32(v40, vminnm_f32(vmaxnm_f32(vsub_f32((float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32((int32x4_t)vdupq_n_s32(v42).u64[0]), v41, (int8x8_t)v40), v40), _D12), _D13));
      uint64_t v7 = a1[1];
    }
    while (v14 < v7);
  }
}

float32x2_t _ZN5apple6vision11OpticalFlow13LKTCPUCompute8sampleLNINS0_9NamedTypeIDv2_fNS1_13FlowParameterEEEEET_RKNS0_11ImageBufferIKS8_SA_EES5_(uint64_t *a1, double a2)
{
  unint64_t v2 = a1[2];
  float v3 = (float)v2 + -1.0;
  if (v3 >= *(float *)&a2) {
    float v3 = *(float *)&a2;
  }
  if (*(float *)&a2 < 0.0) {
    float v3 = 0.0;
  }
  unint64_t v4 = a1[1];
  float v6 = (float)v4 + -1.0;
  if (v6 >= *((float *)&a2 + 1)) {
    float v6 = *((float *)&a2 + 1);
  }
  if (*((float *)&a2 + 1) >= 0.0) {
    float v7 = v6;
  }
  else {
    float v7 = 0.0;
  }
  uint64_t v8 = (uint64_t)v3;
  uint64_t v9 = (uint64_t)v7;
  uint64_t v10 = v2 - 1;
  if (v10 >= (uint64_t)v3 + 1) {
    uint64_t v10 = v8 + 1;
  }
  uint64_t v11 = v4 - 1;
  if (v11 >= v9 + 1) {
    uint64_t v11 = v9 + 1;
  }
  float v12 = v3 - (float)v8;
  unint64_t v13 = (unint64_t)a1[3] >> 3;
  uint64_t v5 = *a1;
  return vmla_n_f32(vmul_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)(v5 + 8 * v11 * v13 + 8 * v10), v12), *(float32x2_t *)(v5 + 8 * v11 * v13 + 8 * v8), 1.0 - v12), v7 - (float)v9), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(v5 + 8 * v13 * v9 + 8 * v10), v12), *(float32x2_t *)(v5 + 8 * v13 * v9 + 8 * v8), 1.0 - v12), 1.0 - (float)(v7 - (float)v9));
}

void *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv4_fNS1_21MatrixAdiagBParameterEEESB_EENS6_IKNS7_IfNS1_18MatrixIxyParameterEEESF_EENS6_ISA_SA_EENS6_ISE_SE_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSP_ENUlPvmE_8__invokeESS_m(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *, _OWORD *, _OWORD *, _OWORD *, _OWORD *))result[1];
    uint64_t v3 = result[2];
    unint64_t v4 = result[3];
    uint64_t v5 = result + 4;
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      unsigned int v18 = result + 12;
      unint64_t v19 = result + 8;
      long long v17 = result + 16;
      do
      {
        v20[0] = ++v11;
        v20[1] = v3;
        v20[2] = v4;
        long long v13 = v5[1];
        v21[0] = *v5;
        v21[1] = v13;
        long long v14 = v19[1];
        v22[0] = *v19;
        v22[1] = v14;
        long long v15 = v18[1];
        v23[0] = *v18;
        v23[1] = v15;
        long long v16 = v17[1];
        v24[0] = *v17;
        v24[1] = v16;
        int32x2_t result = (void *)v2(v20, v21, v22, v23, v24);
      }
      while (v10 != v11);
    }
  }
  return result;
}

uint64_t *apple::vision::OpticalFlow::LKTCPUCompute::solverBox7(uint64_t *result, void *a2, void *a3, void *a4, void *a5)
{
  if (result[1] >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = *result;
    if (*result <= 3) {
      uint64_t v9 = 3;
    }
    else {
      uint64_t v9 = *result;
    }
    uint64_t v10 = v9 - 3;
    uint64_t v11 = 4 - v9;
    __asm { FMOV            V0.4S, #7.0 }
    do
    {
      uint64_t v17 = result[2] - 1;
      if (v17 >= v8 + 3) {
        uint64_t v17 = v8 + 3;
      }
      if (v10 <= v17)
      {
        uint64_t v20 = a2[3] >> 4;
        uint64_t v21 = a3[3] >> 2;
        uint64_t v22 = v11 + v17;
        uint64_t v23 = (float *)(*a3 + v6 + 4 * v10 * v21);
        uint64_t v24 = 4 * v21;
        uint64_t v25 = (float32x4_t *)(*a2 + v5 + 16 * v10 * v20);
        uint64_t v26 = 16 * v20;
        float v19 = 0.0;
        float32x4_t v18 = 0uLL;
        do
        {
          float32x4_t v18 = vaddq_f32(v18, *v25);
          float v19 = v19 + *v23;
          uint64_t v23 = (float *)((char *)v23 + v24);
          uint64_t v25 = (float32x4_t *)((char *)v25 + v26);
          --v22;
        }
        while (v22);
      }
      else
      {
        float32x4_t v18 = 0uLL;
        float v19 = 0.0;
      }
      *(float32x4_t *)(*a4 + 16 * (a4[3] >> 4) * v8 + 16 * v7) = vdivq_f32(v18, _Q0);
      *(float *)(*a5 + 4 * (a5[3] >> 2) * v8 + 4 * v7++) = v19 / 7.0;
      v6 += 4;
      v5 += 16;
    }
    while (v7 < result[1]);
  }
  return result;
}

long long *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_13FlowParameterEEESB_EENS6_IKNS7_IS8_NS1_16FeatureParameterEEESF_EENS6_IKNS7_IDv4_fNS1_19DerivativeParameterEEESK_EESG_SL_NS6_INS7_ISH_NS1_21MatrixAdiagBParameterEEESN_EENS6_INS7_IfNS1_18MatrixIxyParameterEEESQ_EENS1_16SolverParametersEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSZ_ENUlPvmE_8__invokeES12_m(long long *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *))*((void *)result + 1);
    uint64_t v3 = *((void *)result + 2);
    unint64_t v4 = *((void *)result + 3);
    uint64_t v5 = result + 2;
    unint64_t v6 = *(unsigned int *)(*(void *)result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      uint64_t v25 = result + 6;
      uint64_t v26 = result + 4;
      uint64_t v23 = result + 10;
      uint64_t v24 = result + 8;
      uint64_t v21 = result + 14;
      uint64_t v22 = result + 12;
      uint64_t v20 = result + 16;
      do
      {
        v27[0] = ++v11;
        v27[1] = v3;
        v27[2] = v4;
        long long v13 = v5[1];
        long long v28 = *v5;
        long long v29 = v13;
        long long v14 = v26[1];
        long long v30 = *v26;
        long long v31 = v14;
        long long v15 = v25[1];
        long long v32 = *v25;
        long long v33 = v15;
        long long v16 = v24[1];
        long long v34 = *v24;
        long long v35 = v16;
        long long v17 = v23[1];
        long long v36 = *v23;
        long long v37 = v17;
        long long v18 = v22[1];
        long long v38 = *v22;
        long long v39 = v18;
        long long v19 = v21[1];
        long long v40 = *v21;
        long long v41 = v19;
        long long v42 = *v20;
        int32x2_t result = (long long *)v2(v27);
      }
      while (v10 != v11);
    }
  }
  return result;
}

void apple::vision::OpticalFlow::LKTCPUCompute::prepareMatrices(uint64_t *a1, uint64_t *a2, void *a3, void *a4, uint64_t *a5, uint64_t *a6, void *a7, void *a8, float32x2_t *a9)
{
  if (a1[1] >= 1)
  {
    uint64_t v17 = 0;
    float32x2_t v74 = *a9;
    float32x2_t v75 = a9[1];
    float32x2_t v72 = (float32x2_t)vdup_n_s32(0x3D23D70Bu);
    float32x2_t v73 = (float32x2_t)vdup_n_s32(0x3A800000u);
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x3E4CCCCDu);
    uint64_t v19 = *a1;
    float v71 = (float)*a1;
    __asm { FMOV            V8.2S, #1.0 }
    do
    {
      v25.f32[0] = (float)v17;
      v25.f32[1] = v71;
      float32x2_t v79 = v25;
      float32x2_t v26 = _ZN5apple6vision11OpticalFlow13LKTCPUCompute8sampleLNINS0_9NamedTypeIDv2_fNS1_13FlowParameterEEEEET_RKNS0_11ImageBufferIKS8_SA_EES5_(a2, COERCE_DOUBLE(vmul_f32(v75, v25)));
      float32x2_t v27 = *(float32x2_t *)(*a3 + 8 * (a3[3] >> 3) * v19 + 8 * v17);
      float32x2_t v28 = vmul_f32(v74, v26);
      unint64_t v29 = a5[2];
      float32x2_t v30 = vadd_f32(v79, v28);
      float v31 = (float)v29 + -1.0;
      if (v31 >= v30.f32[0]) {
        float v31 = v30.f32[0];
      }
      uint64_t v33 = *a5;
      unint64_t v32 = a5[1];
      float v34 = (float)v32 + -1.0;
      if (v34 >= v30.f32[1]) {
        float v34 = v30.f32[1];
      }
      uint64_t v35 = v29 - 1;
      unint64_t v36 = a6[2];
      float v38 = (float)v36 + -1.0;
      if (v38 >= v30.f32[0]) {
        float v38 = v30.f32[0];
      }
      unint64_t v39 = a6[1];
      float v41 = (float)v39 + -1.0;
      if (v41 >= v30.f32[1]) {
        float v41 = v30.f32[1];
      }
      if (v30.f32[1] >= 0.0) {
        float v42 = v34;
      }
      else {
        float v42 = 0.0;
      }
      if (v30.f32[1] >= 0.0) {
        float v43 = v41;
      }
      else {
        float v43 = 0.0;
      }
      if (v30.f32[0] < 0.0) {
        float v31 = 0.0;
      }
      uint64_t v44 = (uint64_t)v31;
      uint64_t v45 = (uint64_t)v42;
      if (v30.f32[0] >= 0.0) {
        float v46 = v38;
      }
      else {
        float v46 = 0.0;
      }
      if (v35 >= (uint64_t)v31 + 1) {
        uint64_t v35 = v44 + 1;
      }
      uint64_t v47 = v32 - 1;
      if (v47 >= v45 + 1) {
        uint64_t v47 = v45 + 1;
      }
      unint64_t v48 = (unint64_t)a5[3] >> 3;
      float v49 = v31 - (float)v44;
      float v50 = v42 - (float)v45;
      float32x2_t v51 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)(v33 + 8 * v48 * v45 + 8 * v35), v49), *(float32x2_t *)(v33 + 8 * v48 * v45 + 8 * v44), 1.0 - v49);
      float32x2_t v52 = vmul_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)(v33 + 8 * v47 * v48 + 8 * v35), v49), *(float32x2_t *)(v33 + 8 * v47 * v48 + 8 * v44), 1.0 - v49), v50);
      uint64_t v53 = (uint64_t)v46;
      float32x2_t v54 = vmla_n_f32(v52, v51, 1.0 - v50);
      uint64_t v55 = (uint64_t)v43;
      if ((uint64_t)(v36 - 1) >= (uint64_t)v46 + 1) {
        uint64_t v56 = v53 + 1;
      }
      else {
        uint64_t v56 = v36 - 1;
      }
      if ((uint64_t)(v39 - 1) >= v55 + 1) {
        uint64_t v57 = v55 + 1;
      }
      else {
        uint64_t v57 = v39 - 1;
      }
      float v58 = v46 - (float)v53;
      unint64_t v37 = a6[3];
      uint64_t v40 = *a6;
      float32x4_t v59 = vaddq_f32(*(float32x4_t *)(*a4 + 16 * (a4[3] >> 4) * v19 + 16 * v17), vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(v40 + 16 * v57 * (v37 >> 4) + 16 * v56), v58), *(float32x4_t *)(v40 + 16 * v57 * (v37 >> 4) + 16 * v53), 1.0 - v58), v43 - (float)v55), vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(v40 + 16 * (v37 >> 4) * v55 + 16 * v56), v58), *(float32x4_t *)(v40 + 16 * (v37 >> 4) * v55 + 16 * v53), 1.0 - v58), 1.0 - (float)(v43 - (float)v55)));
      v60.i64[0] = 0x3F0000003F000000;
      v60.i64[1] = 0x3F0000003F000000;
      float32x2_t v61 = vsub_f32(v54, v27);
      float32x4_t v76 = vmulq_f32(v59, v60);
      float32x2_t v77 = (float32x2_t)vextq_s8((int8x16_t)v76, (int8x16_t)v76, 8uLL).u64[0];
      float32x2_t v78 = vsub_f32(v61, vmla_n_f32(vmul_lane_f32(v77, v28, 1), *(float32x2_t *)v76.f32, v28.f32[0]));
      float32x4_t v80 = vmulq_f32(v76, v76);
      simd_float4 v62 = (simd_float4)vextq_s8((int8x16_t)v80, (int8x16_t)v80, 8uLL);
      *(float32x2_t *)v62.f32 = vmla_f32(*(float32x2_t *)v62.f32, *(float32x2_t *)v76.f32, *(float32x2_t *)v76.f32);
      *(float32x2_t *)v63.f32 = vadd_f32(vmla_f32((float32x2_t)*(_OWORD *)&_simd_pow_f4(v62, (simd_float4)xmmword_1A410C1C0), (float32x2_t)0x4100000041000000, vabd_f32(v54, v27)), v73);
      int32x2_t v64 = (int32x2_t)vdiv_f32(vmul_f32(*(float32x2_t *)v76.f32, v77), *(float32x2_t *)v63.f32);
      v63.i64[1] = v63.i64[0];
      *(float32x2_t *)v65.f32 = v78;
      *(float32x2_t *)&v65.u32[2] = v78;
      int8x16_t v66 = (int8x16_t)vdivq_f32(v80, v63);
      int8x16_t v67 = (int8x16_t)vdivq_f32(vmulq_f32(v76, v65), v63);
      *(float32x2_t *)v65.f32 = vdiv_f32(vdiv_f32(_D8, vsqrt_f32(vadd_f32(vdiv_f32(vmul_f32(v61, v61), v72), _D8))), v18);
      int32x2_t v68 = (int32x2_t)vextq_s8(v66, v66, 8uLL).u64[0];
      *(float32x2_t *)v66.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v66.i8, v68), (float32x2_t)vzip2_s32(*(int32x2_t *)v66.i8, v68));
      float32x2_t v69 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v65.f32, v64), (float32x2_t)vzip2_s32(*(int32x2_t *)v65.f32, v64));
      int32x2_t v70 = (int32x2_t)vextq_s8(v67, v67, 8uLL).u64[0];
      *(float32x2_t *)v66.i8 = vmul_n_f32(*(float32x2_t *)v66.i8, v69.f32[0]);
      v66.u64[1] = (unint64_t)vmul_n_f32(vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v67.i8, v70), (float32x2_t)vzip2_s32(*(int32x2_t *)v67.i8, v70)), -v69.f32[0]);
      *(int8x16_t *)(*a7 + 16 * (a7[3] >> 4) * v19 + 16 * v17) = v66;
      *(_DWORD *)(*a8 + 4 * (a8[3] >> 2) * v19 + 4 * v17++) = vmul_lane_f32(v69, v69, 1).u32[0];
    }
    while (v17 < a1[1]);
  }
}

CVPixelBufferRef *apple::vision::CVPixelBufferWrapper::BaseAddressLock<0ull>::~BaseAddressLock(CVPixelBufferRef *a1)
{
  return a1;
}

std::logic_error *apple::vision::OpticalFlow::LKTCPU::InvalidPixelFormatException::InvalidPixelFormatException(std::logic_error *this, int a2)
{
  int32x2_t result = std::logic_error::logic_error(this, "pixelFormatType");
  result->__vftable = (std::logic_error_vtbl *)&unk_1EF752110;
  LODWORD(result[1].__vftable) = a2;
  return result;
}

void apple::vision::OpticalFlow::LKTCPU::InvalidPixelFormatException::~InvalidPixelFormatException(apple::vision::OpticalFlow::LKTCPU::InvalidPixelFormatException *this)
{
  MEMORY[0x1A6255F30](this);

  JUMPOUT(0x1A62562C0);
}

void *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_13FlowParameterEEESB_EENS6_INS1_12Pixel_UV_32FESD_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSL_ENUlPvmE_8__invokeESO_m(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *, _OWORD *, _OWORD *))result[1];
    uint64_t v3 = result[2];
    unint64_t v4 = result[3];
    uint64_t v5 = result + 4;
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      long long v13 = result + 8;
      do
      {
        v16[0] = ++v11;
        v16[1] = v3;
        v16[2] = v4;
        long long v14 = v5[1];
        v17[0] = *v5;
        v17[1] = v14;
        long long v15 = v13[1];
        v18[0] = *v13;
        v18[1] = v15;
        int32x2_t result = (void *)v2(v16, v17, v18);
      }
      while (v10 != v11);
    }
  }
  return result;
}

void *apple::vision::OpticalFlow::LKTCPUCompute::copyFlowToOutput32F(uint64_t *a1, void *a2, void *a3)
{
  uint64_t v3 = *a1;
  size_t v4 = a3[3];
  uint64_t v5 = (void *)(*a3 + 8 * (v4 >> 3) * *a1);
  size_t v6 = a2[3];
  unint64_t v7 = (const void *)(*a2 + 8 * (v6 >> 3) * v3);
  if (v6 >= v4) {
    size_t v8 = a3[3];
  }
  else {
    size_t v8 = v6;
  }
  return memcpy(v5, v7, v8);
}

void *apple::vision::CVPixelBufferWrapper::BaseAddressLock<0ull>::BaseAddressLock(void *a1, CVPixelBufferRef texture)
{
  *a1 = texture;
  CVPixelBufferRetain(texture);
  CVReturn v4 = CVPixelBufferLockBaseAddress(texture, 0);
  if (v4)
  {
    CVReturn v6 = v4;
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1EF752138;
    exception[2] = v6;
  }
  return a1;
}

void apple::vision::CVPixelBufferWrapper::LockException::~LockException(std::exception *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x1A62562C0);
}

void *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_13FlowParameterEEESB_EENS6_INS1_12Pixel_UV_16FESD_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSL_ENUlPvmE_8__invokeESO_m(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *, _OWORD *, _OWORD *))result[1];
    uint64_t v3 = result[2];
    unint64_t v4 = result[3];
    uint64_t v5 = result + 4;
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      long long v13 = result + 8;
      do
      {
        v16[0] = ++v11;
        v16[1] = v3;
        v16[2] = v4;
        long long v14 = v5[1];
        v17[0] = *v5;
        v17[1] = v14;
        long long v15 = v13[1];
        v18[0] = *v13;
        v18[1] = v15;
        int32x2_t result = (void *)v2(v16, v17, v18);
      }
      while (v10 != v11);
    }
  }
  return result;
}

vImage_Error apple::vision::OpticalFlow::LKTCPUCompute::copyFlowToOutput16F(uint64_t *a1, void *a2, void *a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a2[2];
  size_t v5 = a2[3];
  if (v4 >= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = a2[2];
  }
  uint64_t v7 = v6 - 1;
  uint64_t v8 = a2[1];
  uint64_t v9 = v8 - 1;
  if (v8 - 1 >= v3) {
    uint64_t v9 = *a1;
  }
  size_t v10 = v7 + (v5 >> 3) * v9;
  unint64_t v11 = v4 - v7;
  if (v11 < v4) {
    uint64_t v4 = v11;
  }
  src.int data = (void *)(*a2 + 8 * v10);
  src.float height = v8 != v9;
  src.float width = 2 * (v4 & 0x1FFFFFFFFFFFFFFFLL);
  src.rowBytes = v5;
  uint64_t v12 = a3[2];
  size_t v13 = a3[3];
  if (v12 >= 1) {
    uint64_t v14 = 1;
  }
  else {
    uint64_t v14 = a3[2];
  }
  uint64_t v15 = v14 - 1;
  uint64_t v16 = a3[1];
  if (v16 - 1 < v3) {
    uint64_t v3 = v16 - 1;
  }
  size_t v17 = v15 + (v13 >> 2) * v3;
  unint64_t v18 = v12 - v15;
  if (v18 < v12) {
    uint64_t v12 = v18;
  }
  v20.int data = (void *)(*a3 + 4 * v17);
  v20.float height = v16 != v3;
  v20.float width = 2 * (v12 & 0x3FFFFFFFFFFFFFFFLL);
  v20.rowBytes = v13;
  return vImageConvert_PlanarFtoPlanar16F(&src, &v20, 0x10u);
}

void *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_fNS1_16FeatureParameterEEESB_EENS6_INS7_IDv4_fNS1_19DerivativeParameterEEESF_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSN_ENUlPvmE_8__invokeESQ_m(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *, _OWORD *, _OWORD *))result[1];
    uint64_t v3 = result[2];
    unint64_t v4 = result[3];
    size_t v5 = result + 4;
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      size_t v13 = result + 8;
      do
      {
        v16[0] = ++v11;
        v16[1] = v3;
        v16[2] = v4;
        long long v14 = v5[1];
        v17[0] = *v5;
        v17[1] = v14;
        long long v15 = v13[1];
        v18[0] = *v13;
        v18[1] = v15;
        int32x2_t result = (void *)v2(v16, v17, v18);
      }
      while (v10 != v11);
    }
  }
  return result;
}

uint64_t *apple::vision::OpticalFlow::LKTCPUCompute::computeDerivatives(uint64_t *result, uint64_t *a2, void *a3)
{
  if (result[1] >= 1)
  {
    unint64_t v3 = 0;
    uint64_t v4 = *result;
    uint64_t v5 = *result - 2;
    uint64_t v6 = *result - 1;
    uint64_t v7 = *result + 1;
    uint64_t v8 = *result + 2;
    __asm { FMOV            V1.2S, #12.0 }
    do
    {
      uint64_t v14 = v3 - 2;
      uint64_t v15 = a2[2] - 1;
      if (v15 < (uint64_t)(v3 - 2)) {
        uint64_t v14 = a2[2] - 1;
      }
      if (v3 < 2) {
        uint64_t v14 = 0;
      }
      uint64_t v16 = *a2;
      uint64_t v17 = a2[1] - 1;
      if (v17 >= v4) {
        uint64_t v18 = v4;
      }
      else {
        uint64_t v18 = a2[1] - 1;
      }
      uint64_t v19 = v3 - 1;
      if (v15 < (uint64_t)(v3 - 1)) {
        uint64_t v19 = a2[2] - 1;
      }
      if (!v3) {
        uint64_t v19 = 0;
      }
      int64_t v20 = v3 + 1;
      if (v15 >= (uint64_t)(v3 + 1)) {
        uint64_t v21 = v3 + 1;
      }
      else {
        uint64_t v21 = a2[2] - 1;
      }
      uint64_t v22 = v3 + 2;
      if (v15 < (uint64_t)(v3 + 2)) {
        uint64_t v22 = a2[2] - 1;
      }
      if (v15 >= (uint64_t)v3) {
        uint64_t v15 = v3;
      }
      if (v17 >= v5) {
        uint64_t v23 = v5;
      }
      else {
        uint64_t v23 = a2[1] - 1;
      }
      if (v4 < 2) {
        uint64_t v23 = 0;
      }
      if (v17 >= v6) {
        uint64_t v24 = v6;
      }
      else {
        uint64_t v24 = a2[1] - 1;
      }
      if (v4 < 0) {
        uint64_t v18 = 0;
      }
      unint64_t v25 = (unint64_t)a2[3] >> 3;
      uint64_t v26 = v16 + 8 * v18 * v25;
      float32x2_t v27 = *(float32x2_t *)(v26 + 8 * v14);
      if (v4 <= 0) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = v24;
      }
      float32x2_t v29 = *(float32x2_t *)(v16 + 8 * v28 * v25 + 8 * v15);
      if (v17 >= v7) {
        uint64_t v30 = v7;
      }
      else {
        uint64_t v30 = a2[1] - 1;
      }
      if (v4 < -1) {
        uint64_t v30 = 0;
      }
      float32x2_t v31 = *(float32x2_t *)(v16 + 8 * v30 * v25 + 8 * v15);
      if (v17 >= v8) {
        uint64_t v32 = v8;
      }
      else {
        uint64_t v32 = a2[1] - 1;
      }
      if (v4 < -2) {
        uint64_t v32 = 0;
      }
      *(float32x2_t *)&long long v33 = vdiv_f32(vsub_f32(vmla_f32(vmls_f32(v27, (float32x2_t)0x4100000041000000, *(float32x2_t *)(v26 + 8 * v19)), (float32x2_t)0x4100000041000000, *(float32x2_t *)(v26 + 8 * v21)), *(float32x2_t *)(v26 + 8 * v22)), _D1);
      *((float32x2_t *)&v33 + 1) = vdiv_f32(vsub_f32(vmla_f32(vmls_f32(*(float32x2_t *)(v16 + 8 * v23 * v25 + 8 * v15), (float32x2_t)0x4100000041000000, v29), (float32x2_t)0x4100000041000000, v31), *(float32x2_t *)(v16 + 8 * v32 * v25 + 8 * v15)), _D1);
      *(_OWORD *)(*a3 + 16 * (a3[3] >> 4) * v4 + 16 * v3++) = v33;
    }
    while (v20 < result[1]);
  }
  return result;
}

void *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIhNS1_15YImageParameterEEESA_EENS6_INS7_IDv2_fNS1_16FeatureParameterEEESE_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSM_ENUlPvmE_8__invokeESP_m(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *, _OWORD *, _OWORD *))result[1];
    uint64_t v3 = result[2];
    unint64_t v4 = result[3];
    uint64_t v5 = result + 4;
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      size_t v13 = result + 8;
      do
      {
        v16[0] = ++v11;
        v16[1] = v3;
        v16[2] = v4;
        long long v14 = v5[1];
        v17[0] = *v5;
        v17[1] = v14;
        long long v15 = v13[1];
        v18[0] = *v13;
        v18[1] = v15;
        int32x2_t result = (void *)v2(v16, v17, v18);
      }
      while (v10 != v11);
    }
  }
  return result;
}

uint64_t *apple::vision::OpticalFlow::LKTCPUCompute::computeFeatures(uint64_t *result, uint64_t *a2, void *a3, double a4, double a5, double a6, double a7, double a8, float a9)
{
  if (result[1] >= 1)
  {
    uint64_t v11 = result;
    uint64_t v12 = 0;
    uint64_t v13 = *result;
    float v33 = (float)*result;
    do
    {
      *(float *)&double v14 = (float)v12;
      *((float *)&v14 + 1) = v33;
      float32x2_t v34 = *(float32x2_t *)&v14;
      unsigned int v15 = apple::vision::OpticalFlow::LKTCPUCompute::sampleLN<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>>(a2, COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v14, (float32x2_t)3204448256)), v14, a6, a7, a8, a9);
      unsigned int v21 = apple::vision::OpticalFlow::LKTCPUCompute::sampleLN<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>>(a2, COERCE_DOUBLE(vadd_f32(v34, (float32x2_t)1056964608)), v16, v17, v18, v19, v20);
      unsigned int v27 = apple::vision::OpticalFlow::LKTCPUCompute::sampleLN<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>>(a2, COERCE_DOUBLE(vadd_f32(v34, (float32x2_t)0xBF00000000000000)), v22, v23, v24, v25, v26);
      int32x2_t result = (uint64_t *)apple::vision::OpticalFlow::LKTCPUCompute::sampleLN<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>>(a2, COERCE_DOUBLE(vadd_f32(v34, (float32x2_t)0x3F00000000000000)), v28, v29, v30, v31, v32);
      *(float32x2_t *)(*a3 + 8 * (a3[3] >> 3) * v13 + 8 * v12++) = vcvt_f32_s32(vsub_s32((int32x2_t)vand_s8((int8x8_t)__PAIR64__(result, v21), (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8((int8x8_t)__PAIR64__(v27, v15), (int8x8_t)0xFF000000FFLL)));
    }
    while (v12 < v11[1]);
  }
  return result;
}

uint64_t apple::vision::OpticalFlow::LKTCPUCompute::sampleLN<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>>(uint64_t *a1, double a2, double a3, double a4, double a5, double a6, float a7)
{
  unint64_t v7 = a1[2];
  uint64_t v8 = a1[3];
  float v9 = (float)v7 + -1.0;
  if (v9 >= *(float *)&a2) {
    float v9 = *(float *)&a2;
  }
  if (*(float *)&a2 < 0.0) {
    float v9 = 0.0;
  }
  uint64_t v11 = *a1;
  unint64_t v10 = a1[1];
  float v12 = (float)v10 + -1.0;
  if (v12 >= *((float *)&a2 + 1)) {
    float v12 = *((float *)&a2 + 1);
  }
  if (*((float *)&a2 + 1) >= 0.0) {
    float v13 = v12;
  }
  else {
    float v13 = 0.0;
  }
  uint64_t v14 = (uint64_t)v9;
  uint64_t v15 = (uint64_t)v13;
  uint64_t v16 = v7 - 1;
  if (v16 >= (uint64_t)v9 + 1) {
    uint64_t v16 = v14 + 1;
  }
  uint64_t v17 = v10 - 1;
  if (v17 >= v15 + 1) {
    uint64_t v17 = v15 + 1;
  }
  *(float *)&unsigned int v18 = (float)v14;
  float v19 = v9 - (float)v14;
  float v20 = v13 - (float)v15;
  uint64_t v21 = v11 + v8 * v15;
  LOBYTE(v18) = *(unsigned char *)(v21 + v14);
  LOBYTE(a7) = *(unsigned char *)(v21 + v16);
  *(float *)&unsigned int v22 = v19 * (float)LODWORD(a7);
  *(float *)&unsigned int v23 = *(float *)&v22 + (float)((float)v18 * (float)(1.0 - v19));
  LODWORD(v21) = (int)*(float *)&v23;
  uint64_t v24 = v11 + v17 * v8;
  LOBYTE(v23) = *(unsigned char *)(v24 + v14);
  LOBYTE(v22) = *(unsigned char *)(v24 + v16);
  return (int)(float)((float)(v20
                                          * (float)(int)(float)((float)(v19 * (float)v22)
                                                                            + (float)((float)v23 * (float)(1.0 - v19))))
                                  + (float)((float)v21 * (float)(1.0 - v20)));
}

CVPixelBufferRef *apple::vision::CVPixelBufferWrapper::BaseAddressLock<1ull>::~BaseAddressLock(CVPixelBufferRef *a1)
{
  return a1;
}

void *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS0_9NamedTypeIDv2_hNS1_16UVImageParameterEEESB_EENS6_ISA_SA_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSK_ENUlPvmE_8__invokeESN_m(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *, _OWORD *, _OWORD *))result[1];
    uint64_t v3 = result[2];
    unint64_t v4 = result[3];
    uint64_t v5 = result + 4;
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      float v13 = result + 8;
      do
      {
        v16[0] = ++v11;
        v16[1] = v3;
        v16[2] = v4;
        long long v14 = v5[1];
        v17[0] = *v5;
        v17[1] = v14;
        long long v15 = v13[1];
        v18[0] = *v13;
        v18[1] = v15;
        int32x2_t result = (void *)v2(v16, v17, v18);
      }
      while (v10 != v11);
    }
  }
  return result;
}

uint64_t *apple::vision::OpticalFlow::LKTCPUCompute::downscale2x(uint64_t *result, uint64_t *a2, void *a3)
{
  if (result[1] >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *result;
    uint64_t v5 = 2 * *result;
    uint64_t v6 = 2;
    float32x2_t v7 = (float32x2_t)vdup_n_s32(0x42A00000u);
    __asm
    {
      FMOV            V1.2S, #6.0
      FMOV            V2.2S, #21.0
    }
    float32x2_t v14 = (float32x2_t)vdup_n_s32(0x43C00000u);
    do
    {
      uint64_t v15 = v6 - 3;
      uint64_t v16 = a2[2] - 1;
      if (v16 < v6 - 3) {
        uint64_t v15 = a2[2] - 1;
      }
      if (v3) {
        uint64_t v17 = v15;
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = *a2;
      uint64_t v19 = a2[1];
      uint64_t v20 = v19 - 1;
      if (v19 - 1 >= v5 - 1) {
        uint64_t v21 = v5 - 1;
      }
      else {
        uint64_t v21 = v19 - 1;
      }
      if (v16 >= v6 - 2) {
        uint64_t v22 = v6 - 2;
      }
      else {
        uint64_t v22 = a2[2] - 1;
      }
      if (v20 >= v5) {
        uint64_t v23 = v5;
      }
      else {
        uint64_t v23 = v19 - 1;
      }
      if (v16 >= v6 - 1) {
        uint64_t v24 = v6 - 1;
      }
      else {
        uint64_t v24 = a2[2] - 1;
      }
      if (v16 >= v6) {
        uint64_t v25 = v6;
      }
      else {
        uint64_t v25 = a2[2] - 1;
      }
      if (v20 >= (v5 | 1)) {
        uint64_t v26 = v5 | 1;
      }
      else {
        uint64_t v26 = v20;
      }
      if (v4 <= 0) {
        uint64_t v21 = 0;
      }
      unint64_t v27 = (unint64_t)a2[3] >> 1;
      uint64_t v28 = v18 + 2 * v21 * v27;
      v29.f32[0] = (float)*(_WORD *)(v28 + 2 * v17);
      float v30 = (float)HIBYTE(*(unsigned __int16 *)(v28 + 2 * v17));
      unsigned int v31 = *(_WORD *)(v28 + 2 * v22);
      if (v4 < 0) {
        uint64_t v23 = 0;
      }
      float v32 = (float)HIBYTE(*(unsigned __int16 *)(v28 + 2 * v22));
      uint64_t v33 = v18 + 2 * v23 * v27;
      v34.f32[0] = (float)*(_WORD *)(v33 + 2 * v17);
      float v35 = (float)HIBYTE(*(unsigned __int16 *)(v33 + 2 * v17));
      v36.f32[0] = (float)*(_WORD *)(v33 + 2 * v22);
      float v37 = (float)HIBYTE(*(unsigned __int16 *)(v33 + 2 * v22));
      v38.f32[0] = (float)*(_WORD *)(v28 + 2 * v24);
      unsigned int v39 = HIBYTE(*(unsigned __int16 *)(v28 + 2 * v24));
      unsigned int v40 = *(unsigned __int16 *)(v28 + 2 * v25);
      float v41 = (float)v39;
      v42.f32[0] = (float)v40;
      float v43 = (float)(v40 >> 8);
      unsigned int v44 = *(_WORD *)(v33 + 2 * v24);
      unsigned int v45 = HIBYTE(*(unsigned __int16 *)(v33 + 2 * v24));
      LODWORD(v33) = *(unsigned __int16 *)(v33 + 2 * v25);
      float v46 = (float)v45;
      unsigned int v47 = v33;
      unsigned int v48 = v33 >> 8;
      if (v4 < 0) {
        uint64_t v26 = 0;
      }
      uint64_t v49 = v18 + 2 * v26 * v27;
      v50.f32[0] = (float)*(_WORD *)(v49 + 2 * v17);
      float v51 = (float)HIBYTE(*(unsigned __int16 *)(v49 + 2 * v17));
      v52.f32[0] = (float)*(_WORD *)(v49 + 2 * v22);
      float v53 = (float)HIBYTE(*(unsigned __int16 *)(v49 + 2 * v22));
      v29.f32[1] = v30;
      if (v20 >= v5 + 2) {
        uint64_t v20 = v5 + 2;
      }
      if (v4 < -1) {
        uint64_t v20 = 0;
      }
      v54.f32[1] = v32;
      uint64_t v55 = v18 + 2 * v20 * v27;
      unsigned int v56 = *(unsigned __int16 *)(v55 + 2 * v17);
      v34.f32[1] = v35;
      v57.f32[0] = (float)v56;
      v36.f32[1] = v37;
      unsigned int v58 = *(unsigned __int16 *)(v55 + 2 * v22);
      v38.f32[1] = v41;
      v59.f32[0] = (float)v58;
      v42.f32[1] = v43;
      v60.f32[1] = v46;
      v61.f32[0] = (float)*(_WORD *)(v49 + 2 * v24);
      v62.f32[1] = (float)v48;
      float v63 = (float)HIBYTE(*(unsigned __int16 *)(v49 + 2 * v24));
      v50.f32[1] = v51;
      v64.f32[0] = (float)*(_WORD *)(v49 + 2 * v25);
      v52.f32[1] = v53;
      unsigned int v65 = *(unsigned __int16 *)(v55 + 2 * v24);
      v61.f32[1] = v63;
      v66.f32[0] = (float)v65;
      v64.f32[1] = (float)HIBYTE(*(unsigned __int16 *)(v49 + 2 * v25));
      unsigned int v67 = *(unsigned __int16 *)(v55 + 2 * v25);
      v57.f32[1] = (float)(v56 >> 8);
      v68.f32[0] = (float)v67;
      v59.f32[1] = (float)(v58 >> 8);
      v66.f32[1] = (float)(v65 >> 8);
      v68.f32[1] = (float)(v67 >> 8);
      v60.f32[0] = (float)v44;
      v54.f32[0] = (float)v31;
      v62.f32[0] = (float)v47;
      int32x2_t v69 = vcvt_s32_f32(vmul_f32(vadd_f32(vmla_f32(vmla_f32(vmul_f32(vadd_f32(vadd_f32(vadd_f32(v36, v60), v52), v61), v7), _D1, vadd_f32(vadd_f32(vadd_f32(v29, v42), v57), v68)), _D2, vadd_f32(v66, vadd_f32(v59, vadd_f32(vadd_f32(vadd_f32(vadd_f32(v34, vadd_f32(v54, v38)), v62), v50), v64)))), v14), (float32x2_t)0x3B0000003B000000));
      int32x2_t v70 = (unsigned char *)(*a3 + 2 * (a3[3] >> 1) * v4 + 2 * v3);
      v70[1] = v69.i8[4];
      *int32x2_t v70 = v69.i8[0];
      ++v3;
      v6 += 2;
    }
    while (v3 < result[1]);
  }
  return result;
}

void *apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::dispatchProcessing<apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>>>(void (*)(apple::vision::OpticalFlow::ComputeParameters const&,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>> const&),int,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter> const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>> const&)::{lambda(void *,unsigned long)#1}::__invoke(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *, _OWORD *, _OWORD *))result[1];
    uint64_t v3 = result[2];
    unint64_t v4 = result[3];
    uint64_t v5 = result + 4;
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      float v13 = result + 8;
      do
      {
        v16[0] = ++v11;
        v16[1] = v3;
        v16[2] = v4;
        long long v14 = v5[1];
        v17[0] = *v5;
        v17[1] = v14;
        long long v15 = v13[1];
        v18[0] = *v13;
        v18[1] = v15;
        int32x2_t result = (void *)v2(v16, v17, v18);
      }
      while (v10 != v11);
    }
  }
  return result;
}

uint64_t *apple::vision::OpticalFlow::LKTCPUCompute::downscale2x(uint64_t *result, uint64_t *a2, void *a3, double a4, double a5, double a6, float a7, float a8, float a9, float a10, float a11)
{
  if (result[1] >= 1)
  {
    uint64_t v22 = 0;
    uint64_t v23 = *result;
    uint64_t v24 = 2 * *result;
    uint64_t v25 = 2;
    do
    {
      uint64_t v26 = v25 - 2;
      uint64_t v27 = v25 - 3;
      uint64_t v28 = a2[3];
      uint64_t v29 = a2[2] - 1;
      if (v29 < v25 - 3) {
        uint64_t v27 = a2[2] - 1;
      }
      if (!v22) {
        uint64_t v27 = 0;
      }
      uint64_t v30 = *a2;
      uint64_t v31 = a2[1] - 1;
      if (v31 >= v24 - 1) {
        uint64_t v32 = v24 - 1;
      }
      else {
        uint64_t v32 = a2[1] - 1;
      }
      if (v29 < v26) {
        uint64_t v26 = a2[2] - 1;
      }
      if (v31 >= v24) {
        uint64_t v33 = v24;
      }
      else {
        uint64_t v33 = a2[1] - 1;
      }
      uint64_t v34 = v25 - 1;
      if (v29 < v25 - 1) {
        uint64_t v34 = a2[2] - 1;
      }
      if (v29 >= v25) {
        uint64_t v29 = v25;
      }
      if (v31 >= (v24 | 1)) {
        uint64_t v35 = v24 | 1;
      }
      else {
        uint64_t v35 = a2[1] - 1;
      }
      if (v23 <= 0) {
        uint64_t v32 = 0;
      }
      uint64_t v36 = v30 + v32 * v28;
      LOBYTE(a7) = *(unsigned char *)(v36 + v27);
      LOBYTE(a8) = *(unsigned char *)(v36 + v26);
      float v37 = (float)LODWORD(a7);
      float v38 = (float)LODWORD(a8);
      if (v23 < 0) {
        uint64_t v33 = 0;
      }
      uint64_t v39 = v30 + v33 * v28;
      LOBYTE(a9) = *(unsigned char *)(v39 + v27);
      a9 = (float)LODWORD(a9);
      LOBYTE(a10) = *(unsigned char *)(v39 + v26);
      float v40 = (float)LODWORD(a10);
      LOBYTE(a11) = *(unsigned char *)(v36 + v34);
      a11 = (float)LODWORD(a11);
      LOBYTE(v11) = *(unsigned char *)(v36 + v29);
      float v41 = (float)v11;
      LOBYTE(v12) = *(unsigned char *)(v39 + v34);
      float v12 = (float)LODWORD(v12);
      LOBYTE(v13) = *(unsigned char *)(v39 + v29);
      float v13 = (float)LODWORD(v13);
      if (v23 >= 0) {
        uint64_t v42 = v35;
      }
      else {
        uint64_t v42 = 0;
      }
      uint64_t v43 = v30 + v42 * v28;
      LOBYTE(v14) = *(unsigned char *)(v43 + v27);
      float v14 = (float)LODWORD(v14);
      if (v31 >= v24 + 2) {
        uint64_t v31 = v24 + 2;
      }
      if (v23 < -1) {
        uint64_t v31 = 0;
      }
      uint64_t v44 = v30 + v31 * v28;
      LOBYTE(v16) = *(unsigned char *)(v44 + v27);
      LOBYTE(v15) = *(unsigned char *)(v43 + v26);
      float v15 = (float)LODWORD(v15);
      float v16 = (float)LODWORD(v16);
      LOBYTE(v17) = *(unsigned char *)(v44 + v26);
      LOBYTE(v18) = *(unsigned char *)(v43 + v34);
      float v17 = (float)LODWORD(v17);
      float v18 = (float)LODWORD(v18);
      LOBYTE(v19) = *(unsigned char *)(v43 + v29);
      LOBYTE(v20) = *(unsigned char *)(v44 + v34);
      float v19 = (float)LODWORD(v19);
      float v20 = (float)LODWORD(v20);
      LOBYTE(v21) = *(unsigned char *)(v44 + v29);
      float v21 = (float)LODWORD(v21);
      float v45 = (float)((float)(v37 + v41) + v16) + v21;
      unsigned int v11 = 1117782016;
      a10 = (float)((float)((float)(v40 + v12) + v15) + v18) * 80.0;
      float v46 = (float)(a10 + (float)(v45 * 6.0))
          + (float)((float)((float)((float)((float)((float)((float)((float)(v38 + a11) + a9) + v13) + v14) + v19) + v17)
                          + v20)
                  * 21.0);
      a8 = 384.0;
      a7 = (float)(v46 + 384.0) * 0.0019531;
      *(unsigned char *)(*a3 + a3[3] * v23 + v22++) = (int)a7;
      v25 += 2;
    }
    while (v22 < result[1]);
  }
  return result;
}

void *apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::dispatchProcessing<apple::vision::ImageBuffer<apple::vision::OpticalFlow::Pixel_BGRA_8U const,apple::vision::OpticalFlow::Pixel_BGRA_8U const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>>>(void (*)(apple::vision::OpticalFlow::ComputeParameters const&,apple::vision::ImageBuffer<apple::vision::OpticalFlow::Pixel_BGRA_8U const,apple::vision::OpticalFlow::Pixel_BGRA_8U const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>> const&),int,apple::vision::ImageBuffer<apple::vision::OpticalFlow::Pixel_BGRA_8U const,apple::vision::OpticalFlow::Pixel_BGRA_8U const>,apple::vision::ImageBuffer<apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>,apple::vision::NamedType<unsigned char,apple::vision::OpticalFlow::YImageParameter>> const&)::{lambda(void *,unsigned long)#1}::__invoke(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *, _OWORD *, _OWORD *))result[1];
    uint64_t v3 = result[2];
    unint64_t v4 = result[3];
    uint64_t v5 = result + 4;
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      float v13 = result + 8;
      do
      {
        v16[0] = ++v11;
        v16[1] = v3;
        v16[2] = v4;
        long long v14 = v5[1];
        v17[0] = *v5;
        v17[1] = v14;
        long long v15 = v13[1];
        v18[0] = *v13;
        v18[1] = v15;
        int32x2_t result = (void *)v2(v16, v17, v18);
      }
      while (v10 != v11);
    }
  }
  return result;
}

uint64_t *apple::vision::OpticalFlow::LKTCPUCompute::convertBGRA8888ToYF32(uint64_t *result, void *a2, void *a3, double a4, double a5, double a6, float a7, float a8, float a9)
{
  if (result[1] >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = *result;
    do
    {
      uint64_t v12 = (unsigned char *)(*a2 + 4 * (a2[3] >> 2) * v11 + v9);
      LOBYTE(a7) = v12[1];
      LOBYTE(a8) = *v12;
      LOBYTE(a9) = v12[2];
      a9 = (float)LODWORD(a9);
      a8 = (float)LODWORD(a8);
      a7 = (float)((float)((float)LODWORD(a7) * 0.587) + (float)(a9 * 0.299)) + (float)(a8 * 0.114);
      *(unsigned char *)(*a3 + a3[3] * v11 + v10++) = (int)a7;
      v9 += 4;
    }
    while (v10 < result[1]);
  }
  return result;
}

void *_ZZN5apple6vision11OpticalFlow10LKTCPUImplINS1_13LKTCPUComputeEE18dispatchProcessingIJNS0_11ImageBufferIKNS1_13Pixel_BGRA_8UES8_EENS6_INS0_9NamedTypeIhNS1_15YImageParameterEEESC_EENS6_INSA_IDv2_hNS1_16UVImageParameterEEESG_EEEEEvPFvRKNS1_17ComputeParametersEDpRKT_EiSO_ENUlPvmE_8__invokeESR_m(void *result, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unint64_t v2 = (uint64_t (*)(void *, _OWORD *, _OWORD *, _OWORD *))result[1];
    uint64_t v3 = result[2];
    unint64_t v4 = result[3];
    uint64_t v5 = result + 4;
    unint64_t v6 = *(unsigned int *)(*result + 16);
    unint64_t v7 = v4 / v6;
    uint64_t v8 = v4 % v6;
    int v9 = a2 + 1;
    uint64_t v10 = -1;
    do
    {
      uint64_t v11 = v10;
      if (v8 <= 0) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = v10 + 1;
      }
      uint64_t v10 = v12 + v7;
      v8 -= v8 > 0;
      --v9;
    }
    while (v9);
    if (v11 < v10)
    {
      float v17 = result + 8;
      float v13 = result + 12;
      do
      {
        v18[0] = ++v11;
        v18[1] = v3;
        _OWORD v18[2] = v4;
        long long v14 = v5[1];
        v19[0] = *v5;
        v19[1] = v14;
        long long v15 = v17[1];
        v20[0] = *v17;
        v20[1] = v15;
        long long v16 = v13[1];
        v21[0] = *v13;
        v21[1] = v16;
        int32x2_t result = (void *)v2(v18, v19, v20, v21);
      }
      while (v10 != v11);
    }
  }
  return result;
}

uint64_t *apple::vision::OpticalFlow::LKTCPUCompute::convertBGRA8888ToYUVF32(uint64_t *result, void *a2, void *a3, void *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  if (result[1] >= 1)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = *result;
    do
    {
      float v17 = (unsigned char *)(*a2 + 4 * (a2[3] >> 2) * v16 + v14);
      LOBYTE(a12) = *v17;
      float v18 = (float)LODWORD(a12);
      v12.i8[0] = v17[1];
      float v19 = (float)v12.u32[0];
      LOBYTE(v13) = v17[2];
      float v13 = (float)LODWORD(v13);
      *(unsigned char *)(*a3 + a3[3] * v16 + v15) = (int)(float)((float)((float)(v19 * 0.587) + (float)(v13 * 0.299))
                                                       + (float)(v18 * 0.114));
      float32x2_t v12 = vmla_n_f32(vmla_n_f32(vmul_n_f32((float32x2_t)0xBED65FD9BEA9A027, v19), (float32x2_t)0x3F000000BE2CBFB1, v13), (float32x2_t)0xBDA6809D3F000000, v18);
      a12 = COERCE_DOUBLE(vcvt_s32_f32(vadd_f32(v12, (float32x2_t)0x4300000043000000)));
      float v20 = (unsigned char *)(*a4 + 2 * (a4[3] >> 1) * v16 + 2 * v15);
      v20[1] = BYTE4(a12);
      unsigned char *v20 = LOBYTE(a12);
      ++v15;
      v14 += 4;
    }
    while (v15 < result[1]);
  }
  return result;
}

void *apple::vision::CVPixelBufferWrapper::BaseAddressLock<1ull>::BaseAddressLock(void *a1, CVPixelBufferRef texture)
{
  *a1 = texture;
  CVPixelBufferRetain(texture);
  CVReturn v4 = CVPixelBufferLockBaseAddress(texture, 1uLL);
  if (v4)
  {
    CVReturn v6 = v4;
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1EF752138;
    exception[2] = v6;
  }
  return a1;
}

int32x2_t apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::estimateFlow(int32x2_t *a1, __CVBuffer **a2, __CVBuffer **a3, __CVBuffer **a4, int *a5)
{
  a1[115] = (int32x2_t)0x100000000;
  int v9 = *a2;
  uint64_t v15 = v9;
  if (v9) {
    CVPixelBufferRetain(v9);
  }
  apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::createImagePyramid((uint64_t)a1, &v15, 0, a5);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&v15);
  uint64_t v10 = *a3;
  uint64_t v14 = v10;
  if (v10) {
    CVPixelBufferRetain(v10);
  }
  apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::createImagePyramid((uint64_t)a1, &v14, 1, a5);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&v14);
  bzero(*(void **)&a1[112], 8 * *(void *)&a1[2 * *a5 + 3] * *(void *)&a1[2 * *a5 + 4]);
  apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::calculateFeaturesAndDerivatives((uint64_t)a1, 0, *a5);
  apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::calculateFeaturesAndDerivatives((uint64_t)a1, 1, *a5);
  uint64_t v11 = *a4;
  float v13 = v11;
  if (v11) {
    CVPixelBufferRetain(v11);
  }
  apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::computeOpticalFlow((uint64_t)a1, &v13, a5);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&v13);
  int32x2_t result = vrev64_s32(a1[115]);
  a1[115] = result;
  return result;
}

void sub_1A3EC29E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper((__CVBuffer **)va);
  _Unwind_Resume(a1);
}

void apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::~LKTCPUImpl(uint64_t a1)
{
  *(void *)a1 = &unk_1EF7520B8;
  unint64_t v2 = *(void **)(a1 + 200);
  if (v2)
  {
    *(void *)(a1 + 208) = v2;
    free(v2);
  }

  JUMPOUT(0x1A62562C0);
}

uint64_t apple::vision::OpticalFlow::LKTCPUImpl<apple::vision::OpticalFlow::LKTCPUCompute>::~LKTCPUImpl(uint64_t a1)
{
  *(void *)a1 = &unk_1EF7520B8;
  unint64_t v2 = *(void **)(a1 + 200);
  if (v2)
  {
    *(void *)(a1 + 208) = v2;
    free(v2);
  }

  return a1;
}

void sub_1A3EC2B90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC2CA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

void *std::vector<MPClusteringTreeNode *>::__init_with_size[abi:ne180100]<MPClusteringTreeNode **,MPClusteringTreeNode **>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    CVReturn v4 = result;
    if (a4 >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    int32x2_t result = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(a4);
    unint64_t v7 = result;
    *CVReturn v4 = result;
    v4[1] = result;
    v4[2] = &result[v8];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      int32x2_t result = memmove(result, a2, v9);
    }
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_1A3EC2D68(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3EC2E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1A3EC2FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1A3EC3138(_Unwind_Exception *a1)
{
  if (v3) {
    operator delete(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1A3EC3304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC346C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3EC3610(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC370C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC37F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC3C44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC3D84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC3DF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC3EC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC3F6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _validatedEntityPrintOriginatingRequestSpecifierCompatibility(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  if (v11)
  {
    float v13 = [v11 VNEntityIdentificationModelPrintOriginatingRequestSpecifier];
    if ([v13 hasModelEquivalencyToRequestSpecifier:v12])
    {
      id v14 = v11;
    }
    else
    {
      if (a5)
      {
        uint64_t v15 = [NSString stringWithFormat:@"%@ was generated by %@, which is not equivalent to %@", v11, v13, v12];
        VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(2, v15, 0);
        *a5 = (id)objc_claimAutoreleasedReturnValue();
      }
      id v14 = 0;
    }
    goto LABEL_9;
  }
  if (a5)
  {
    float v13 = [NSString stringWithFormat:@"%@ does not have a %@", v9, v10];
    VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(2, v13, 0);
    id v14 = 0;
    *a5 = (id)objc_claimAutoreleasedReturnValue();
LABEL_9:

    goto LABEL_10;
  }
  id v14 = 0;
LABEL_10:

  return v14;
}

void sub_1A3EC40E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC4184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC4304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC43A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC4448(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNEntityUniqueIdentifierClasses()
{
  if (VNEntityUniqueIdentifierClasses::ourOnceToken != -1) {
    dispatch_once(&VNEntityUniqueIdentifierClasses::ourOnceToken, &__block_literal_global_6619);
  }
  int v0 = (void *)VNEntityUniqueIdentifierClasses::classesSet;

  return v0;
}

uint64_t __VNEntityUniqueIdentifierClasses_block_invoke()
{
  id v0 = objc_alloc(MEMORY[0x1E4F1CAD0]);
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  VNEntityUniqueIdentifierClasses::classesSet = objc_msgSend(v0, "initWithObjects:", v1, v2, objc_opt_class(), 0);

  return MEMORY[0x1F41817F8]();
}

uint64_t __VNEntityUniqueIdentifierSupportedRequestClasses_block_invoke()
{
  id v0 = objc_alloc(MEMORY[0x1E4F1CAD0]);
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  VNEntityUniqueIdentifierSupportedRequestClasses::ourClasses = objc_msgSend(v0, "initWithObjects:", v1, v2, objc_opt_class(), 0);

  return MEMORY[0x1F41817F8]();
}

id VNEntityUniqueIdentifierSupportedRequestSpecifiers()
{
  if (VNEntityUniqueIdentifierSupportedRequestSpecifiers::ourOnceToken != -1) {
    dispatch_once(&VNEntityUniqueIdentifierSupportedRequestSpecifiers::ourOnceToken, &__block_literal_global_35);
  }
  id v0 = (void *)VNEntityUniqueIdentifierSupportedRequestSpecifiers::ourRequestSpecifiers;

  return v0;
}

void __VNEntityUniqueIdentifierSupportedRequestSpecifiers_block_invoke()
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v0 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = __VNEntityUniqueIdentifierSupportedRequestSpecifiers_block_invoke_2;
  aBlock[3] = &unk_1E5B1C9A0;
  id v1 = v0;
  id v16 = v1;
  uint64_t v2 = (void (**)(void *, void *, void *))_Block_copy(aBlock);
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  if (VNEntityUniqueIdentifierSupportedRequestClasses::ourOnceToken != -1) {
    dispatch_once(&VNEntityUniqueIdentifierSupportedRequestClasses::ourOnceToken, &__block_literal_global_30_6621);
  }
  id v3 = (id)VNEntityUniqueIdentifierSupportedRequestClasses::ourClasses;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v11 objects:v17 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        if (*(void *)v12 != v5) {
          objc_enumerationMutation(v3);
        }
        unint64_t v7 = *(void **)(*((void *)&v11 + 1) + 8 * i);
        uint64_t v8 = objc_msgSend(v7, "allSupportedRevisions", (void)v11);
        v2[2](v2, v7, v8);
      }
      uint64_t v4 = [v3 countByEnumeratingWithState:&v11 objects:v17 count:16];
    }
    while (v4);
  }

  uint64_t v9 = [v1 copy];
  id v10 = (void *)VNEntityUniqueIdentifierSupportedRequestSpecifiers::ourRequestSpecifiers;
  VNEntityUniqueIdentifierSupportedRequestSpecifiers::ourRequestSpecifiers = v9;
}

void sub_1A3EC481C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  _Unwind_Resume(a1);
}

void __VNEntityUniqueIdentifierSupportedRequestSpecifiers_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __VNEntityUniqueIdentifierSupportedRequestSpecifiers_block_invoke_3;
  v4[3] = &unk_1E5B1C978;
  uint64_t v6 = a2;
  id v5 = *(id *)(a1 + 32);
  [a3 enumerateIndexesUsingBlock:v4];
}

void sub_1A3EC48F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void __VNEntityUniqueIdentifierSupportedRequestSpecifiers_block_invoke_3(uint64_t a1, uint64_t a2)
{
  id v3 = +[VNRequestSpecifier specifierForRequestClass:*(void *)(a1 + 40) revision:a2 error:0];
  if (v3) {
    [*(id *)(a1 + 32) addObject:v3];
  }
}

void sub_1A3EC4970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t VNEntityIdentificationModelPrintConformingObject(void *a1)
{
  id v1 = a1;
  uint64_t v2 = VNEntityIdentificationModelPrintConformingClasses();
  uint64_t v3 = [v2 containsObject:objc_opt_class()];

  return v3;
}

void sub_1A3EC49E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNEntityIdentificationModelPrintConformingClasses()
{
  if (VNEntityIdentificationModelPrintConformingClasses::onceToken != -1) {
    dispatch_once(&VNEntityIdentificationModelPrintConformingClasses::onceToken, &__block_literal_global_41_6625);
  }
  id v0 = (void *)VNEntityIdentificationModelPrintConformingClasses::ourEntityPrintClasses;

  return v0;
}

void __VNEntityIdentificationModelPrintConformingClasses_block_invoke()
{
  id v0 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  uint64_t v1 = objc_opt_class();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __VNEntityIdentificationModelPrintConformingClasses_block_invoke_2;
  v5[3] = &unk_1E5B1C9C8;
  id v2 = v0;
  id v6 = v2;
  +[VisionCoreRuntimeUtilities enumerateSubclassesOfClass:v1 excludingRootClass:1 usingBlock:v5];
  uint64_t v3 = [v2 copy];
  uint64_t v4 = (void *)VNEntityIdentificationModelPrintConformingClasses::ourEntityPrintClasses;
  VNEntityIdentificationModelPrintConformingClasses::ourEntityPrintClasses = v3;
}

void sub_1A3EC4B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void __VNEntityIdentificationModelPrintConformingClasses_block_invoke_2(uint64_t a1, Class aClass)
{
  uint64_t v4 = NSStringFromClass(aClass);
  char v5 = [v4 hasPrefix:@"VN"];

  if ((v5 & 1) != 0 && class_conformsToProtocol(aClass, (Protocol *)&unk_1EF7BCDF8))
  {
    id v6 = *(void **)(a1 + 32);
    [v6 addObject:aClass];
  }
}

void sub_1A3EC4BD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t VNEntityIdentificationModelObservationConformingObject(void *a1)
{
  id v1 = a1;
  id v2 = VNEntityIdentificationModelObservationConformingClasses();
  uint64_t v3 = [v2 containsObject:objc_opt_class()];

  return v3;
}

void sub_1A3EC4C44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNEntityIdentificationModelObservationConformingClasses()
{
  if (VNEntityIdentificationModelObservationConformingClasses::onceToken != -1) {
    dispatch_once(&VNEntityIdentificationModelObservationConformingClasses::onceToken, &__block_literal_global_106);
  }
  id v0 = (void *)VNEntityIdentificationModelObservationConformingClasses::ourObservationClasses;

  return v0;
}

void __VNEntityIdentificationModelObservationConformingClasses_block_invoke()
{
  id v0 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  uint64_t v1 = objc_opt_class();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __VNEntityIdentificationModelObservationConformingClasses_block_invoke_2;
  v5[3] = &unk_1E5B1C9C8;
  id v2 = v0;
  id v6 = v2;
  +[VisionCoreRuntimeUtilities enumerateSubclassesOfClass:v1 excludingRootClass:1 usingBlock:v5];
  uint64_t v3 = [v2 copy];
  uint64_t v4 = (void *)VNEntityIdentificationModelObservationConformingClasses::ourObservationClasses;
  VNEntityIdentificationModelObservationConformingClasses::ourObservationClasses = v3;
}

void sub_1A3EC4D88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void __VNEntityIdentificationModelObservationConformingClasses_block_invoke_2(uint64_t a1, Class aClass)
{
  uint64_t v4 = NSStringFromClass(aClass);
  char v5 = [v4 hasPrefix:@"VN"];

  if ((v5 & 1) != 0 && class_conformsToProtocol(aClass, (Protocol *)&unk_1EF7B1918))
  {
    id v6 = *(void **)(a1 + 32);
    [v6 addObject:aClass];
  }
}

void sub_1A3EC4E3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC51E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float *generateQuadrilaterals(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, _DWORD *a6, float a7)
{
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a4;
  float v12 = (float)(a7 * 256.0) * (float)(a7 * 256.0);
  uint64_t v66 = a2;
  do
  {
    uint64_t v13 = 0;
    uint64_t v68 = v9;
    long long v14 = (float *)(a1 + (v9 << 6));
    int32x2_t v69 = v14 + 8;
    do
    {
      uint64_t v15 = (float *)(a3 + (v13 << 6));
      int32x2_t result = leqIntersect(v14, v15, &v70, &v71);
      if (v70 < 0.0) {
        goto LABEL_4;
      }
      unsigned int v17 = 0;
      if (v70 <= 255.0 && v71 >= 0.0 && v71 <= 255.0)
      {
        float32x2_t v72 = v14;
        uint64_t v73 = a3 + (v13 << 6);
        int32x2_t result = leqIntersect(v14, v15 + 8, &v74, &v75);
        if (v74 < 0.0) {
          goto LABEL_4;
        }
        unsigned int v17 = 0;
        if (v74 <= 255.0 && v75 >= 0.0 && v75 <= 255.0)
        {
          float32x4_t v76 = v14;
          float32x2_t v77 = v15 + 8;
          int32x2_t result = leqIntersect(v69, (float *)(a3 + (v13 << 6)), &v78, &v79);
          if (v78 < 0.0) {
            goto LABEL_4;
          }
          unsigned int v17 = 0;
          if (v78 <= 255.0 && v79 >= 0.0 && v79 <= 255.0)
          {
            float32x4_t v80 = v14 + 8;
            uint64_t v81 = a3 + (v13 << 6);
            int32x2_t result = leqIntersect(v69, v15 + 8, &v82, &v83);
            if (v82 < 0.0) {
              goto LABEL_4;
            }
            unsigned int v17 = 0;
            if (v82 <= 255.0 && v83 >= 0.0 && v83 <= 255.0)
            {
              int8x16_t v84 = v14 + 8;
              float32x4_t v85 = v15 + 8;
              float v20 = v70;
              float v21 = v71;
              float v22 = v74;
              if ((float)((float)((float)(v79 - v71) * (float)(v83 - v75))
                         + (float)((float)(v78 - v70) * (float)(v82 - v74))) < 0.0
                || (float)((float)((float)(v83 - v79) * (float)(v75 - v71))
                         + (float)((float)(v74 - v70) * (float)(v82 - v78))) < 0.0)
              {
                goto LABEL_4;
              }
              unsigned int v23 = 0;
              uint64_t v24 = -3;
              uint64_t v25 = &v75;
              float v26 = v71;
              while (2)
              {
                float v27 = *v25;
                if (*v25 <= v26)
                {
                  if (*v25 != v26)
                  {
                    unsigned int v23 = v24 + 4;
                    goto LABEL_35;
                  }
                  if (*(v25 - 1) < *(&v70 + 6 * v23)) {
                    unsigned int v23 = v24 + 4;
                  }
                }
                float v27 = v26;
LABEL_35:
                v25 += 6;
                float v26 = v27;
                BOOL v28 = __CFADD__(v24++, 1);
                if (!v28) {
                  continue;
                }
                break;
              }
              unsigned int v29 = 0;
              uint64_t v30 = -3;
              uint64_t v31 = &v75;
              while (2)
              {
                float v32 = *v31;
                if (*v31 >= v21)
                {
                  if (*v31 != v21)
                  {
                    unsigned int v29 = v30 + 4;
                    goto LABEL_44;
                  }
                  if (*(v31 - 1) > *(&v70 + 6 * v29)) {
                    unsigned int v29 = v30 + 4;
                  }
                }
                float v32 = v21;
LABEL_44:
                v31 += 6;
                float v21 = v32;
                BOOL v28 = __CFADD__(v30++, 1);
                if (v28)
                {
                  unsigned int v33 = ((1 << v29) | (1 << v23)) - 3;
                  if (v33 >= 8)
                  {
                    uint64_t v34 = 0;
                    uint64_t v35 = 1;
                  }
                  else
                  {
                    uint64_t v34 = qword_1A410D2D0[v33];
                    uint64_t v35 = qword_1A410D310[v33];
                    float v20 = *(&v70 + 6 * v34);
                    float v22 = *(&v70 + 6 * v35);
                  }
                  uint64_t v36 = &v70 + 6 * v23;
                  float v37 = *v36;
                  float v38 = v36[1];
                  uint64_t v40 = *((void *)v36 + 1);
                  uint64_t v39 = *((void *)v36 + 2);
                  float v41 = &v70 + 6 * v29;
                  float v43 = *v41;
                  float v42 = v41[1];
                  int8x16_t v44 = *(int8x16_t *)(v41 + 2);
                  float v45 = &v70 + 6 * v34;
                  float v46 = v45[1];
                  int8x16_t v47 = *(int8x16_t *)(v45 + 2);
                  unsigned int v48 = &v70 + 6 * v35;
                  float v49 = v48[1];
                  int64x2_t v50 = *(int64x2_t *)(v48 + 2);
                  float v51 = (float)((float)(v43 * (float)(v49 - v38)) + (float)(v37 * (float)(v42 - v49)))
                      + (float)(v22 * (float)(v38 - v42));
                  if ((float)((float)((float)(v43 * (float)(v46 - v38)) + (float)(v37 * (float)(v42 - v46)))
                             + (float)(v20 * (float)(v38 - v42))) >= 0.0)
                  {
                    if (v51 >= 0.0)
                    {
                      float v52 = v43;
                      float v53 = v42;
                      if (v46 >= v49)
                      {
                        float v54 = v20;
                        float v55 = v46;
                        int8x16_t v56 = v44;
                        int8x16_t v57 = v47;
                        goto LABEL_62;
                      }
                      float v54 = v22;
                      float v55 = v48[1];
                      float v22 = v20;
                      float v49 = v46;
                      int8x16_t v56 = v44;
                      int8x16_t v57 = *(int8x16_t *)(v48 + 2);
                    }
                    else
                    {
                      float v52 = v22;
                      float v53 = v48[1];
                      float v54 = v43;
                      float v55 = v42;
                      float v22 = v20;
                      float v49 = v46;
                      int8x16_t v56 = *(int8x16_t *)(v48 + 2);
                      int8x16_t v57 = v44;
                    }
                    int64x2_t v50 = (int64x2_t)v47;
                  }
                  else if (v51 >= 0.0)
                  {
                    float v52 = v20;
                    float v53 = v46;
                    float v54 = v43;
                    float v55 = v42;
                    int8x16_t v56 = v47;
                    int8x16_t v57 = v44;
                  }
                  else
                  {
                    if (v46 >= v49)
                    {
                      float v52 = v22;
                      float v53 = v48[1];
                      float v54 = v20;
                      float v55 = v46;
                      float v22 = v43;
                      float v49 = v42;
                      int8x16_t v56 = *(int8x16_t *)(v48 + 2);
                      int8x16_t v57 = v47;
                    }
                    else
                    {
                      float v52 = v20;
                      float v53 = v46;
                      float v54 = v22;
                      float v55 = v48[1];
                      float v22 = v43;
                      float v49 = v42;
                      int8x16_t v56 = v47;
                      int8x16_t v57 = *(int8x16_t *)(v48 + 2);
                    }
                    int64x2_t v50 = (int64x2_t)v44;
                  }
LABEL_62:
                  if ((float)((float)((float)(v53 - v38) * (float)(v53 - v38))
                             + (float)((float)(v52 - v37) * (float)(v52 - v37))) >= v12
                    && (float)((float)((float)(v55 - v53) * (float)(v55 - v53))
                             + (float)((float)(v54 - v52) * (float)(v54 - v52))) >= v12
                    && (float)((float)((float)(v49 - v55) * (float)(v49 - v55))
                             + (float)((float)(v22 - v54) * (float)(v22 - v54))) >= v12
                    && (float)((float)((float)(v38 - v49) * (float)(v38 - v49))
                             + (float)((float)(v37 - v22) * (float)(v37 - v22))) >= v12)
                  {
                    *(float *)a5 = v37;
                    *(float *)(a5 + 4) = v38;
                    int8x16_t v58 = (int8x16_t)vdupq_lane_s64(v57.i64[0], 0);
                    v59.i64[1] = v58.i64[1];
                    v59.i64[0] = v40;
                    *(float *)(a5 + 8) = v52;
                    *(float *)(a5 + 12) = v53;
                    int64x2_t v60 = vdupq_lane_s64(v56.i64[0], 0);
                    v61.i64[1] = v57.i64[1];
                    v61.i64[0] = v40;
                    int8x16_t v62 = vorrq_s8((int8x16_t)vceqq_s64(v59, v60), (int8x16_t)vceqq_s64(v61, (int64x2_t)vextq_s8(v56, v56, 8uLL)));
                    v60.i64[0] = v40;
                    v56.i64[0] = v39;
                    *(float *)(a5 + 16) = v54;
                    *(float *)(a5 + 20) = v55;
                    *(float *)(a5 + 24) = v22;
                    *(float *)(a5 + 28) = v49;
                    v63.i64[1] = v58.i64[1];
                    v63.i64[0] = v39;
                    v57.i64[0] = v50.i64[1];
                    v58.i64[0] = v50.i64[0];
                    int8x16_t v64 = vbslq_s8(vorrq_s8((int8x16_t)vceqq_s64(v59, vdupq_lane_s64(v50.i64[0], 0)), (int8x16_t)vceqq_s64(v63, v50)), v58, v57);
                    *(int8x16_t *)(a5 + 32) = vbslq_s8(v62, (int8x16_t)v60, v56);
                    *(int8x16_t *)(a5 + 48) = vextq_s8(v64, v64, 8uLL);
                    unsigned int v17 = 1;
                    break;
                  }
LABEL_4:
                  unsigned int v17 = 0;
                  break;
                }
                continue;
              }
            }
          }
        }
      }
      v10 += v17;
      a5 += (unint64_t)v17 << 6;
      ++v13;
    }
    while (v13 != v11);
    uint64_t v9 = v68 + 1;
  }
  while (v68 + 1 != v66);
  *a6 = v10;
  return result;
}

void processQuadrilaterals(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, double a7, double a8, double a9, double a10, float a11, float a12, float a13)
{
  float v60 = *(float *)&a7;
  if (a2)
  {
    float v17 = *(float *)&a8;
    uint64_t v19 = 0;
    int v20 = 0;
    float v57 = *(float *)&a8 * *(float *)&a8;
    float v58 = *(float *)&a9;
    uint64_t v63 = a2;
    float32x2_t v21 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a9, 0);
    float v59 = *(float *)&a10;
    float32x2_t v22 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a10, 0);
    __asm { FMOV            V14.2S, #-1.0 }
    float32x2_t v28 = (float32x2_t)vdup_n_s32(0x3BA3D70Au);
    __asm { FMOV            V9.2S, #1.0 }
    do
    {
      if (v17 < 0.0) {
        goto LABEL_11;
      }
      v30.i32[0] = *(_DWORD *)(a1 + 24);
      v31.i32[0] = *(_DWORD *)(a1 + 28);
      float v32 = (float)(*(float *)a1 * v60) - v58;
      *(float *)&a10 = *(float *)(a1 + 4) - v59;
      *(float *)&a7 = (float)(*(float *)(a1 + 16) * v60) - v58;
      *(float *)&a8 = *(float *)(a1 + 20) - v59;
      v13.f32[0] = -*(float *)&a10;
      *(float *)v14.i32 = -v32;
      v30.i32[1] = *(_DWORD *)(a1 + 8);
      float32x2_t v33 = vsub_f32(vmul_n_f32(v30, v60), v21);
      v31.i32[1] = *(_DWORD *)(a1 + 12);
      float32x2_t v34 = vsub_f32(v31, v22);
      float32x2_t v35 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a8, 0);
      float32x2_t v36 = vmla_n_f32(vmla_n_f32(vmul_n_f32(v34, -(float)(v32 - *(float *)&a7)), v33, *(float *)&a10 - *(float *)&a8), v35, v32);
      float32x2_t v37 = (float32x2_t)vdup_lane_s32((int32x2_t)v13, 0);
      float32x2_t v38 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0);
      float32x2_t v39 = vmls_lane_f32(v36, v38, *(float32x2_t *)&a10, 0);
      float32x2_t v40 = (float32x2_t)vrev64_s32((int32x2_t)v34);
      float32x2_t v13 = vneg_f32((float32x2_t)vrev64_s32((int32x2_t)vsub_f32(v33, v38)));
      float32x2_t v41 = vmla_f32(vmul_f32(v34, v13), v33, vsub_f32(v40, v35));
      float32x2_t v42 = (float32x2_t)vrev64_s32((int32x2_t)v33);
      float32x2_t v43 = vdiv_f32(v39, vmls_lane_f32(vmla_n_f32(v41, v42, *(float *)&a8), v40, *(float32x2_t *)&a7, 0));
      float32x2_t v44 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v28, vabs_f32(vadd_f32(v43, _D14))), _D9, (int8x8_t)v43);
      a8 = COERCE_DOUBLE(vadd_f32(v44, _D14));
      float32x2_t v45 = vmla_f32(v37, v40, v44);
      a10 = COERCE_DOUBLE(vmla_f32((float32x2_t)vdup_lane_s32(v14, 0), v42, v44));
      float32x2_t v46 = vmla_f32(vmla_f32(vmul_f32(v45, v45), *(float32x2_t *)&a8, vmul_n_f32(*(float32x2_t *)&a8, v57)), *(float32x2_t *)&a10, *(float32x2_t *)&a10);
      a7 = COERCE_DOUBLE(vdiv_f32(v46, (float32x2_t)vdup_lane_s32((int32x2_t)v46, 1)));
      *(float *)&a7 = sqrtf(*(float *)&a7);
      if (*(float *)&a7 > 1.0) {
        *(float *)&a7 = 1.0 / *(float *)&a7;
      }
      if (*(float *)&a7 >= a11 && *(float *)&a7 <= a12)
      {
LABEL_11:
        v64[0] = 0;
        cachedOverlap(a3, (float *)a1, (float *)(a1 + 8), *(void *)(a1 + 32), (int *)v64 + 1, v64);
        int v49 = v64[0];
        int v48 = HIDWORD(v64[0]);
        cachedOverlap(a3, (float *)(a1 + 8), (float *)(a1 + 16), *(void *)(a1 + 40), (int *)v64 + 1, v64);
        int v50 = HIDWORD(v64[0]);
        int v51 = LODWORD(v64[0]) + v49;
        cachedOverlap(a3, (float *)(a1 + 16), (float *)(a1 + 24), *(void *)(a1 + 48), (int *)v64 + 1, v64);
        int v53 = v64[0];
        int v52 = HIDWORD(v64[0]);
        cachedOverlap(a3, (float *)(a1 + 24), (float *)a1, *(void *)(a1 + 56), (int *)v64 + 1, v64);
        if (v51 + v53 + LODWORD(v64[0])) {
          *(float *)&a7 = (float)(v50 + v48 + v52 + HIDWORD(v64[0]))
        }
                        / (float)(v51 + v53 + LODWORD(v64[0]));
        else {
          a7 = 0.0;
        }
        if (*(float *)&a7 >= a13)
        {
          *(_DWORD *)(a5 + 4 * v20) = LODWORD(a7);
          *(void *)(a4 + 8 * v20++) = v19;
        }
      }
      ++v19;
      a1 += 64;
    }
    while (v63 != v19);
  }
  else
  {
    int v20 = 0;
  }
  *a6 = v20;
}

void cachedOverlap(uint64_t a1, float *a2, float *a3, uint64_t a4, int *a5, _DWORD *a6)
{
  id v6 = *(unsigned char **)(*(void *)(a4 + 16) + 8 * *(int *)(a4 + 24) + 48);
  float v8 = *(float *)a4;
  float v7 = *(float *)(a4 + 4);
  if (*(float *)a4 >= 0.0) {
    float v9 = *(float *)a4;
  }
  else {
    float v9 = -*(float *)a4;
  }
  if (v7 >= 0.0) {
    float v10 = *(float *)(a4 + 4);
  }
  else {
    float v10 = -v7;
  }
  if (v6) {
    goto LABEL_141;
  }
  float32x4_t v89 = a3;
  unint64_t v90 = a2;
  uint64_t v91 = a6;
  unint64_t v92 = a5;
  float v13 = *(float *)(a4 + 8);
  if (v9 <= v10) {
    malloc_type_id_t v14 = 3816575818;
  }
  else {
    malloc_type_id_t v14 = 1754752960;
  }
  id v6 = malloc_type_calloc(0x100uLL, 1uLL, v14);
  float v15 = fabsf(v7);
  float v88 = v9;
  if (v15 < 0.0001)
  {
    float v16 = (float)-v13 / v8;
    float v17 = 0.0;
    if (v16 >= 0.0 && v16 <= 255.0)
    {
      float v22 = 255.0;
      float v21 = (float)-v13 / v8;
      goto LABEL_98;
    }
    goto LABEL_16;
  }
  float v19 = fabsf(v8);
  if (v19 < 0.0001)
  {
    float v17 = (float)-v13 / v7;
    float v16 = 0.0;
    if (v17 >= 0.0 && v17 <= 255.0)
    {
      float v21 = 255.0;
      float v22 = (float)-v13 / v7;
      goto LABEL_98;
    }
    float v17 = 0.0;
    goto LABEL_23;
  }
  float v23 = -v13;
  if (v19 > v15)
  {
    float v24 = v23 / v8;
    float v21 = (float)-(float)(v13 + (float)(v7 * 255.0)) / v8;
    float v22 = 0.0;
    if ((float)(v23 / v8) < 0.0 && v21 < 0.0) {
      goto LABEL_97;
    }
    if (v24 > 255.0 && v21 > 255.0) {
      goto LABEL_97;
    }
    BOOL v27 = v24 < 0.0 || v21 > 255.0 || v24 > 255.0;
    if (!v27 && v21 >= 0.0)
    {
      float v16 = v23 / v8;
      float v17 = 0.0;
      float v22 = 255.0;
      goto LABEL_98;
    }
    BOOL v28 = v24 < 0.0;
    if (v21 <= 255.0) {
      BOOL v28 = 0;
    }
    if (v21 < 0.0 && v24 > 255.0 || v28)
    {
      float v17 = v23 / v7;
      float v21 = 255.0;
      float v16 = 0.0;
      float v22 = (float)-(float)(v13 + (float)(v8 * 255.0)) / v7;
      goto LABEL_98;
    }
    if (v24 >= 0.0)
    {
      if (v21 >= 0.0)
      {
        if (v24 > 255.0)
        {
          float v17 = 255.0;
          float v22 = (float)-(float)(v13 + (float)(v8 * 255.0)) / v7;
          float v16 = (float)-(float)(v13 + (float)(v7 * 255.0)) / v8;
          float v21 = 255.0;
          goto LABEL_98;
        }
        if (v21 > 255.0)
        {
          float v21 = 255.0;
          float v22 = (float)-(float)(v13 + (float)(v8 * 255.0)) / v7;
          float v16 = v23 / v8;
          float v17 = 0.0;
          goto LABEL_98;
        }
LABEL_97:
        float v16 = 0.0;
        float v17 = 0.0;
        float v21 = 0.0;
        goto LABEL_98;
      }
      float v16 = 0.0;
      float v21 = v23 / v8;
    }
    else
    {
      float v22 = 255.0;
      float v16 = 0.0;
    }
    float v17 = v23 / v7;
    goto LABEL_98;
  }
  float v31 = v23 / v7;
  float v22 = (float)-(float)(v13 + (float)(v8 * 255.0)) / v7;
  float v17 = 0.0;
  if (((float)(v23 / v7) >= 0.0 || v22 >= 0.0) && (v31 <= 255.0 || v22 <= 255.0))
  {
    float v21 = 255.0;
    BOOL v34 = v31 < 0.0 || v22 > 255.0 || v31 > 255.0;
    if (!v34 && v22 >= 0.0) {
      goto LABEL_84;
    }
    BOOL v35 = v31 < 0.0;
    if (v22 <= 255.0) {
      BOOL v35 = 0;
    }
    if (v22 < 0.0 && v31 > 255.0 || v35)
    {
      float v16 = v23 / v8;
      float v22 = 255.0;
      float v21 = (float)-(float)(v13 + (float)(v7 * 255.0)) / v8;
      goto LABEL_98;
    }
    if (v31 >= 0.0)
    {
      if (v22 >= 0.0)
      {
        if (v31 > 255.0)
        {
          float v16 = 255.0;
          float v21 = (float)-(float)(v13 + (float)(v7 * 255.0)) / v8;
          float v17 = (float)-(float)(v13 + (float)(v8 * 255.0)) / v7;
          float v22 = 255.0;
          goto LABEL_98;
        }
        if (v22 <= 255.0) {
          goto LABEL_16;
        }
        float v22 = 255.0;
        float v21 = (float)-(float)(v13 + (float)(v7 * 255.0)) / v8;
LABEL_84:
        float v16 = 0.0;
        float v17 = v23 / v7;
        goto LABEL_98;
      }
      float v21 = 0.0;
      float v22 = v23 / v7;
    }
    else
    {
      float v21 = 255.0;
    }
    float v16 = v23 / v8;
    goto LABEL_98;
  }
LABEL_16:
  float v16 = 0.0;
LABEL_23:
  float v21 = 0.0;
  float v22 = 0.0;
LABEL_98:
  float v38 = vabds_f32(v22, v17);
  float v39 = vabds_f32(v21, v16);
  if (v38 <= v39) {
    float v40 = v16;
  }
  else {
    float v40 = v17;
  }
  if (v38 <= v39)
  {
    float v41 = v21;
  }
  else
  {
    float v17 = v16;
    float v41 = v22;
  }
  if (v38 > v39) {
    float v22 = v21;
  }
  if (v40 <= v41)
  {
    float v42 = v22;
    float v43 = v41;
  }
  else
  {
    float v42 = v17;
    float v43 = v40;
    float v17 = v22;
    float v40 = v41;
  }
  float v44 = (float)(v42 - v17) / (float)(v43 - v40);
  signed int v45 = llroundf(v40);
  float v46 = v17 + (float)(v44 * (float)((float)(int)roundf(v40) - v40));
  float v95 = 0.0;
  float v47 = modff(v46, &v95);
  int v48 = (int)v95;
  signed int v49 = llroundf(v43);
  float v94 = 0.0;
  float v50 = modff(v42 + (float)(v44 * (float)((float)(int)roundf(v43) - v43)), &v94);
  int v87 = (int)v94;
  uint64_t v51 = v45;
  uint64_t v52 = a1 + v45;
  int v53 = (unsigned char *)(v52 + ((v48 << 8) + 256));
  float v54 = (unsigned char *)(v52 + (v48 << 8));
  if (v47 >= 0.5) {
    float v54 = v53;
  }
  uint64_t v55 = a1 + v48 + (v45 << 8);
  uint64_t v56 = v45;
  if (v47 >= 0.5)
  {
    uint64_t v56 = v45;
    uint64_t v55 = a1 + v48 + (v45 << 8) + 1;
  }
  if (v38 > v39)
  {
    uint64_t v51 = v56;
    float v54 = (unsigned char *)v55;
  }
  char v57 = *v54 != 0;
  v6[v51] = v57;
  float v58 = v44 + v46;
  float v93 = 0.0;
  float v59 = modff(v58, &v93);
  if (v49 - 1 > v45)
  {
    uint64_t v60 = v45;
    int v61 = v45 + 1;
    uint64_t v62 = v49 - 1 - (uint64_t)v45;
    uint64_t v63 = &v6[v60 + 1];
    uint64_t v64 = a1 + v60 + 1;
    do
    {
      int v65 = (int)v93;
      LODWORD(v60) = v60 + 1;
      if (v59 < 0.5) {
        int v66 = (int)v93;
      }
      else {
        int v66 = v65 + 1;
      }
      uint64_t v67 = a1 + v65;
      if (v59 < 0.5) {
        int v68 = v61;
      }
      else {
        int v68 = v60;
      }
      if (v59 >= 0.5) {
        ++v67;
      }
      if (v38 <= v39) {
        uint64_t v67 = v64;
      }
      else {
        int v66 = v68;
      }
      if (*(unsigned char *)(v67 + (v66 << 8))) {
        ++v57;
      }
      *v63++ = v57;
      float v58 = v44 + v58;
      float v59 = modff(v58, &v93);
      ++v61;
      ++v64;
      --v62;
    }
    while (v62);
  }
  uint64_t v69 = v49;
  uint64_t v70 = a1 + v49;
  float v71 = (unsigned char *)(v70 + ((v87 << 8) + 256));
  float32x2_t v72 = (unsigned char *)(v70 + (v87 << 8));
  if (v50 >= 0.5) {
    float32x2_t v72 = v71;
  }
  uint64_t v73 = a1 + v87 + (v49 << 8);
  uint64_t v74 = v49;
  if (v50 >= 0.5)
  {
    uint64_t v74 = v49;
    uint64_t v73 = a1 + v87 + (v49 << 8) + 1;
  }
  if (v38 > v39)
  {
    uint64_t v69 = v74;
    float32x2_t v72 = (unsigned char *)v73;
  }
  if (*v72) {
    char v75 = v57 + 1;
  }
  else {
    char v75 = v57;
  }
  v6[v69] = v75;
  *(void *)(*(void *)(a4 + 16) + 8 * *(int *)(a4 + 24) + 48) = v6;
  a6 = v91;
  a5 = v92;
  a3 = v89;
  a2 = v90;
  float v9 = v88;
LABEL_141:
  if (v9 <= v10)
  {
    signed int v76 = llroundf(*a3);
    float v77 = *a2;
  }
  else
  {
    signed int v76 = llroundf(a3[1]);
    float v77 = a2[1];
  }
  signed int v78 = llroundf(v77);
  int v80 = v78 - v76;
  BOOL v79 = v78 - v76 < 0;
  if (v78 >= v76) {
    signed int v81 = v76;
  }
  else {
    signed int v81 = v78;
  }
  if (v78 > v76) {
    signed int v76 = v78;
  }
  if (v79) {
    int v82 = -v80;
  }
  else {
    int v82 = v80;
  }
  *a6 = v82 + 1;
  int v83 = v6[v76];
  int v84 = v6[v81];
  BOOL v85 = __OFSUB__(v83, v84);
  int v86 = v83 - v84;
  if (v86 < 0 != v85) {
    v86 += 256;
  }
  *a5 = v86;
}

void mergeQuads(uint64_t a1, uint64_t a2, const float *__C, vDSP_Length *__I, char *a5, void *a6, void *a7, vDSP_Length __N, _OWORD *a9, float *a10, unint64_t a11, unint64_t *a12)
{
  if (!__N) {
    return;
  }
  malloc_type_id_t v14 = __I;
  uint64_t v18 = a12;
  float v19 = a9;
  int v20 = a10;
  if (*a12) {
    float v21 = *a10;
  }
  else {
    float v21 = -1.0;
  }
  if (a11 != 1)
  {
    if (__N == 1)
    {
      *__I = 0;
LABEL_38:
      unint64_t v36 = *a12;
      memmove(a7, a10, 4 * *a12);
      memmove(a5, a9, 32 * v36);
      if (v36)
      {
        float32x2_t v37 = a6;
        unint64_t v38 = v36;
        do
        {
          *v37++ = a5;
          a5 += 32;
          --v38;
        }
        while (v38);
      }
      uint64_t v39 = 0;
      if (__N <= 1) {
        vDSP_Length v40 = 1;
      }
      else {
        vDSP_Length v40 = __N;
      }
      do
      {
        vDSP_Length v41 = v14[v39];
        *((float *)a7 + v36 + v39) = __C[v41];
        a6[v36 + v39++] = a1 + (*(void *)(a2 + 8 * v41) << 6);
      }
      while (v40 != v39);
      vDSP_Length v42 = v36 + __N;
      if (v42)
      {
        for (vDSP_Length i = 0; i != v42; ++i)
          v14[i] = i;
      }
      vDSP_vsorti((const float *)a7, v14, 0, v42, -1);
      unint64_t v26 = a11;
      if (v42 < a11) {
        unint64_t v26 = v42;
      }
      uint64_t v18 = a12;
      if (v26)
      {
        unint64_t v44 = v26;
        do
        {
          vDSP_Length v45 = *v14++;
          *v20++ = *((float *)a7 + v45);
          float v46 = (_OWORD *)a6[v45];
          long long v47 = v46[1];
          _OWORD *v19 = *v46;
          v19[1] = v47;
          v19 += 2;
          --v44;
        }
        while (v44);
      }
      goto LABEL_53;
    }
    if (__N == 2)
    {
      if (*__C <= __C[1]) {
        long long v31 = xmmword_1A410C1D0;
      }
      else {
        long long v31 = xmmword_1A4104940;
      }
      *(_OWORD *)__I = v31;
      goto LABEL_38;
    }
    if (__N != 3)
    {
      for (vDSP_Length j = 0; j != __N; ++j)
        __I[j] = j;
      vDSP_vsorti(__C, __I, 0, __N, -1);
      goto LABEL_38;
    }
    float v27 = *__C;
    float v28 = __C[1];
    float v29 = __C[2];
    if (*__C <= v28)
    {
      if (v27 <= v29)
      {
        if (v28 <= v29) {
          long long v35 = xmmword_1A410C100;
        }
        else {
          long long v35 = xmmword_1A40E7700;
        }
        *(_OWORD *)__I = v35;
        __I[2] = 0;
        goto LABEL_38;
      }
      long long v30 = xmmword_1A410C1D0;
    }
    else
    {
      if (v28 <= v29)
      {
        if (v27 <= v29) {
          long long v34 = xmmword_1A410C1E0;
        }
        else {
          long long v34 = xmmword_1A410C1F0;
        }
        *(_OWORD *)__I = v34;
        vDSP_Length v33 = 1;
        goto LABEL_35;
      }
      long long v30 = xmmword_1A4104940;
    }
    *(_OWORD *)__I = v30;
    vDSP_Length v33 = 2;
LABEL_35:
    __I[2] = v33;
    goto LABEL_38;
  }
  uint64_t v22 = 0;
  int v23 = -1;
  do
  {
    if (__C[v22] > v21)
    {
      float v21 = __C[v22];
      int v23 = v22;
    }
    ++v22;
  }
  while (__N != v22);
  if (v23 != -1)
  {
    *a10 = v21;
    float v24 = (_OWORD *)(a1 + (*(void *)(a2 + 8 * v23) << 6));
    long long v25 = v24[1];
    *a9 = *v24;
    a9[1] = v25;
    unint64_t v26 = 1;
LABEL_53:
    unint64_t *v18 = v26;
  }
}

void sub_1A3EC6548(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC6604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC67A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC6960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC6A48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC6BD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC6D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC76A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, long long a15)
{
  operator delete(v19);
  if ((void)a15) {
    operator delete((void *)a15);
  }

  _Unwind_Resume(a1);
}

void sub_1A3EC7830(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC7938(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC7A9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC8144(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC826C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC8398(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC849C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC84E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC8998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC8B10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC8B94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC8C30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC8E10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC8ED0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC8F5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC9018(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC9140(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC92D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC9434(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC9574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC9C20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EC9D84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

#error "1A3ECA084: call analysis failed (funcsize=26)"

void sub_1A3ECA248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3ECA454(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECA54C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECAC28(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3ECAC3C(_Unwind_Exception *a1)
{
}

void sub_1A3ECACC0(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3ECACD4(_Unwind_Exception *a1)
{
}

void sub_1A3ECAE20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECAF7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECB054(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECB1F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECB420(_Unwind_Exception *a1)
{
  char v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3ECB55C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::deque<std::pair<unsigned int,unsigned int>>::emplace_back<std::pair<unsigned int,unsigned int>>(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  char v5 = (char *)a1[1];
  uint64_t v6 = v4 - v5;
  if (v4 == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v4 - v5) << 6) - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 >= 0x200)
    {
      a1[4] = v8 - 512;
      uint64_t v12 = *(void *)v5;
      float v10 = v5 + 8;
      uint64_t v11 = v12;
      a1[1] = v10;
      if ((char *)a1[3] == v4)
      {
        uint64_t v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v4 == (char *)*a1) {
            unint64_t v41 = 1;
          }
          else {
            unint64_t v41 = (uint64_t)&v4[-*a1] >> 2;
          }
          vDSP_Length v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v41);
          unint64_t v44 = &v42[8 * (v41 >> 2)];
          vDSP_Length v45 = (uint64_t *)a1[1];
          uint64_t v4 = v44;
          uint64_t v46 = a1[2] - (void)v45;
          if (v46)
          {
            uint64_t v4 = &v44[v46 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v47 = 8 * (v46 >> 3);
            int v48 = &v42[8 * (v41 >> 2)];
            do
            {
              uint64_t v49 = *v45++;
              *(void *)int v48 = v49;
              v48 += 8;
              v47 -= 8;
            }
            while (v47);
          }
          float v50 = (char *)*a1;
          *a1 = v42;
          a1[1] = v44;
          a1[2] = v4;
          a1[3] = &v42[8 * v43];
          if (v50)
          {
            operator delete(v50);
            uint64_t v4 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v14 = v13 >> 3;
          BOOL v15 = v13 >> 3 < -1;
          uint64_t v16 = (v13 >> 3) + 2;
          if (v15) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14 + 1;
          }
          uint64_t v18 = -(v17 >> 1);
          uint64_t v19 = v17 >> 1;
          int v20 = &v10[-8 * v19];
          int64_t v21 = v4 - v10;
          if (v4 == v10)
          {
            uint64_t v22 = v4;
          }
          else
          {
            memmove(&v10[-8 * v19], v10, v4 - v10);
            uint64_t v22 = (char *)a1[1];
          }
          uint64_t v4 = &v20[v21];
          a1[1] = &v22[8 * v18];
          a1[2] = &v20[v21];
        }
      }
      *(void *)uint64_t v4 = v11;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      char v5 = (char *)a1[1];
      unint64_t v9 = a1[5] + a1[4];
      goto LABEL_84;
    }
    uint64_t v23 = v6 >> 3;
    float v24 = (char *)a1[3];
    long long v25 = (char *)*a1;
    uint64_t v26 = (uint64_t)&v24[-*a1];
    if (v6 >> 3 < (unint64_t)(v26 >> 3))
    {
      float v27 = operator new(0x1000uLL);
      float v28 = v27;
      if (v24 == v4)
      {
        if (v25 == v5)
        {
          if (v4 == v5) {
            unint64_t v51 = 1;
          }
          else {
            unint64_t v51 = v26 >> 2;
          }
          uint64_t v52 = 2 * v51;
          int v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v51);
          char v5 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v55 = (uint64_t *)a1[1];
          uint64_t v56 = v5;
          uint64_t v57 = a1[2] - (void)v55;
          if (v57)
          {
            uint64_t v56 = &v5[v57 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v58 = 8 * (v57 >> 3);
            float v59 = v5;
            do
            {
              uint64_t v60 = *v55++;
              *(void *)float v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          int v61 = (char *)*a1;
          *a1 = v53;
          a1[1] = v5;
          a1[2] = v56;
          a1[3] = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            char v5 = (char *)a1[1];
          }
        }
        *((void *)v5 - 1) = v28;
        uint64_t v62 = (char *)a1[1];
        uint64_t v63 = (char *)a1[2];
        a1[1] = v62 - 8;
        uint64_t v64 = *((void *)v62 - 1);
        a1[1] = v62;
        if (v63 == (char *)a1[3])
        {
          uint64_t v65 = (uint64_t)&v62[-*a1];
          if ((unint64_t)v62 <= *a1)
          {
            if (v63 == (char *)*a1) {
              unint64_t v96 = 1;
            }
            else {
              unint64_t v96 = (uint64_t)&v63[-*a1] >> 2;
            }
            int8x16_t v97 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v96);
            unint64_t v99 = &v97[8 * (v96 >> 2)];
            unsigned int v100 = (uint64_t *)a1[1];
            uint64_t v63 = v99;
            uint64_t v101 = a1[2] - (void)v100;
            if (v101)
            {
              uint64_t v63 = &v99[v101 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v102 = 8 * (v101 >> 3);
              uint64_t v103 = &v97[8 * (v96 >> 2)];
              do
              {
                uint64_t v104 = *v100++;
                *(void *)uint64_t v103 = v104;
                v103 += 8;
                v102 -= 8;
              }
              while (v102);
            }
            unint64_t v105 = (char *)*a1;
            *a1 = v97;
            a1[1] = v99;
            a1[2] = v63;
            a1[3] = &v97[8 * v98];
            if (v105)
            {
              operator delete(v105);
              uint64_t v63 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v66 = v65 >> 3;
            BOOL v15 = v65 >> 3 < -1;
            uint64_t v67 = (v65 >> 3) + 2;
            if (v15) {
              uint64_t v68 = v67;
            }
            else {
              uint64_t v68 = v66 + 1;
            }
            uint64_t v69 = -(v68 >> 1);
            uint64_t v70 = v68 >> 1;
            float v71 = &v62[-8 * v70];
            int64_t v72 = v63 - v62;
            if (v63 != v62)
            {
              memmove(&v62[-8 * v70], v62, v63 - v62);
              uint64_t v62 = (char *)a1[1];
            }
            uint64_t v63 = &v71[v72];
            a1[1] = &v62[8 * v69];
            a1[2] = &v71[v72];
          }
        }
        *(void *)uint64_t v63 = v64;
      }
      else
      {
        *(void *)uint64_t v4 = v27;
      }
      goto LABEL_82;
    }
    if (v24 == v25) {
      unint64_t v29 = 1;
    }
    else {
      unint64_t v29 = v26 >> 2;
    }
    long long v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v29);
    uint64_t v32 = v31;
    vDSP_Length v33 = &v30[8 * v23];
    *(void *)&long long v34 = v30;
    *((void *)&v34 + 1) = v33;
    long long v109 = v34;
    long long v35 = operator new(0x1000uLL);
    *(void *)&long long v36 = v33;
    *((void *)&v36 + 1) = &v30[8 * v32];
    if (v23 == v32)
    {
      uint64_t v37 = 8 * v23;
      *(void *)&long long v38 = v109;
      if (v6 >= 1)
      {
        uint64_t v39 = v37 >> 3;
        if (v39 >= -1) {
          unint64_t v40 = v39 + 1;
        }
        else {
          unint64_t v40 = v39 + 2;
        }
        v33 -= 8 * (v40 >> 1);
        *(void *)&long long v36 = v33;
        *((void *)&v38 + 1) = v33;
        goto LABEL_56;
      }
      uint64_t v73 = v37 >> 2;
      if (v4 == v5) {
        unint64_t v74 = 1;
      }
      else {
        unint64_t v74 = v73;
      }
      char v75 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v74);
      vDSP_Length v33 = &v75[8 * (v74 >> 2)];
      *(void *)&long long v38 = v75;
      *((void *)&v38 + 1) = v33;
      *(void *)&long long v36 = v33;
      *((void *)&v36 + 1) = &v75[8 * v76];
      if (!v30) {
        goto LABEL_56;
      }
      long long v106 = v36;
      long long v109 = v38;
      operator delete(v30);
      long long v36 = v106;
    }
    long long v38 = v109;
LABEL_56:
    *(void *)vDSP_Length v33 = v35;
    *(void *)&long long v36 = v36 + 8;
    for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
    {
      signed int v78 = (void *)*((void *)&v38 + 1);
      if (*((void *)&v38 + 1) == (void)v38)
      {
        int v80 = (unsigned char *)v36;
        if ((unint64_t)v36 >= *((void *)&v36 + 1))
        {
          if (*((void *)&v36 + 1) == *((void *)&v38 + 1)) {
            unint64_t v85 = 1;
          }
          else {
            unint64_t v85 = (uint64_t)(*((void *)&v36 + 1) - *((void *)&v38 + 1)) >> 2;
          }
          int v86 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v85);
          BOOL v79 = &v86[(2 * v85 + 6) & 0xFFFFFFFFFFFFFFF8];
          float v88 = v79;
          uint64_t v89 = v80 - (unsigned char *)v78;
          if (v80 != (unsigned char *)v78)
          {
            float v88 = &v79[v89 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v90 = 8 * (v89 >> 3);
            uint64_t v91 = v79;
            unint64_t v92 = v78;
            do
            {
              uint64_t v93 = *v92++;
              *(void *)uint64_t v91 = v93;
              v91 += 8;
              v90 -= 8;
            }
            while (v90);
          }
          *(void *)&long long v38 = v86;
          *((void *)&v38 + 1) = v79;
          *(void *)&long long v36 = v88;
          *((void *)&v36 + 1) = &v86[8 * v87];
          if (v78)
          {
            long long v107 = v36;
            long long v111 = v38;
            operator delete(v78);
            long long v36 = v107;
            long long v38 = v111;
          }
        }
        else
        {
          uint64_t v81 = (uint64_t)(*((void *)&v36 + 1) - v36) >> 3;
          if (v81 >= -1) {
            uint64_t v82 = v81 + 1;
          }
          else {
            uint64_t v82 = v81 + 2;
          }
          uint64_t v83 = v82 >> 1;
          uint64_t v84 = v36 + 8 * (v82 >> 1);
          BOOL v79 = (char *)(v84 - (v36 - *((void *)&v38 + 1)));
          if ((void)v36 == *((void *)&v38 + 1))
          {
            int v80 = (unsigned char *)*((void *)&v38 + 1);
          }
          else
          {
            uint64_t v108 = *((void *)&v36 + 1);
            uint64_t v110 = v38;
            memmove((void *)(v84 - (v36 - *((void *)&v38 + 1))), *((const void **)&v38 + 1), v36 - *((void *)&v38 + 1));
            *((void *)&v36 + 1) = v108;
            *(void *)&long long v38 = v110;
          }
          *((void *)&v38 + 1) = v79;
          *(void *)&long long v36 = &v80[8 * v83];
        }
      }
      else
      {
        BOOL v79 = (char *)*((void *)&v38 + 1);
      }
      uint64_t v94 = *(void *)(i - 8);
      *((void *)v79 - 1) = v94;
      *((void *)&v38 + 1) -= 8;
    }
    float v95 = (char *)*a1;
    *(_OWORD *)a1 = v38;
    *((_OWORD *)a1 + 1) = v36;
    if (v95) {
      operator delete(v95);
    }
    goto LABEL_83;
  }
LABEL_84:
  *(void *)(*(void *)&v5[(v9 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v9 & 0x1FF)) = *a2;
  ++a1[5];
}

void sub_1A3ECBADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11)
{
  operator delete(v11);
  if ((void)a11) {
    operator delete((void *)a11);
  }
  _Unwind_Resume(a1);
}

void sub_1A3ECBBC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECBD10(_Unwind_Exception *a1)
{
  char v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3ECBE4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECBF80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECC338(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECC8B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  uint64_t v63 = v59;

  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a51, 8);
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose((const void *)(v62 - 240), 8);
  _Block_object_dispose((const void *)(v62 - 176), 8);
  _Block_object_dispose((const void *)(v62 - 112), 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__7445(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__7446(uint64_t a1)
{
}

__n128 __Block_byref_object_copy__87(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void sub_1A3ECCC38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECCF24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECD030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A3ECD0A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECD288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose((const void *)(v23 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1A3ECD358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECD6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1A3ECDB08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECDF3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, void *a17, void *a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id a25)
{
  _Block_object_dispose(&a20, 8);
  _Unwind_Resume(a1);
}

void sub_1A3ECE494(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECE7A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECEE18(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A3ECEDE0);
}

void sub_1A3ECEE68()
{
  JUMPOUT(0x1A3ECEE70);
}

uint64_t VNHashCGAffineTransform(uint64_t a1)
{
  double v1 = *(double *)a1;
  if (*(double *)a1 == 0.0) {
    double v1 = 0.0;
  }
  double v2 = *(double *)(a1 + 8);
  if (v2 == 0.0) {
    double v2 = 0.0;
  }
  double v3 = *(double *)(a1 + 16);
  if (v3 == 0.0) {
    double v3 = 0.0;
  }
  double v4 = *(double *)(a1 + 24);
  if (v4 == 0.0) {
    double v4 = 0.0;
  }
  uint64_t v5 = *(void *)&v4 ^ __ROR8__(*(void *)&v3 ^ __ROR8__(*(void *)&v2 ^ __ROR8__(*(void *)&v1, 51), 51), 51);
  if (*(double *)(a1 + 32) == 0.0) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 32);
  }
  uint64_t v7 = v6 ^ __ROR8__(v5, 51);
  double v8 = *(double *)(a1 + 40);
  if (v8 == 0.0) {
    double v8 = 0.0;
  }
  return *(void *)&v8 ^ __ROR8__(v7, 51);
}

uint64_t VNHashMatrixFloat4x4(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  unint64_t v4 = (unint64_t)a1.n128_u32[0] << 13;
  if (a1.n128_f32[0] == 0.0) {
    unint64_t v4 = 0;
  }
  uint64_t v5 = a1.n128_u32[1];
  if (a1.n128_f32[1] == 0.0) {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 ^ v5;
  uint64_t v7 = a1.n128_u32[2];
  if (a1.n128_f32[2] == 0.0) {
    uint64_t v7 = 0;
  }
  unint64_t v8 = v7 ^ (v6 << 13);
  uint64_t v9 = a1.n128_u32[3];
  if (a1.n128_f32[3] == 0.0) {
    uint64_t v9 = 0;
  }
  uint64_t v10 = v9 ^ __ROR8__(v8, 51);
  uint64_t v11 = a2.n128_u32[0];
  if (a2.n128_f32[0] == 0.0) {
    uint64_t v11 = 0;
  }
  uint64_t v12 = v11 ^ __ROR8__(v10, 51);
  uint64_t v13 = a2.n128_u32[1];
  if (a2.n128_f32[1] == 0.0) {
    uint64_t v13 = 0;
  }
  uint64_t v14 = v13 ^ __ROR8__(v12, 51);
  uint64_t v15 = a2.n128_u32[2];
  if (a2.n128_f32[2] == 0.0) {
    uint64_t v15 = 0;
  }
  uint64_t v16 = v15 ^ __ROR8__(v14, 51);
  uint64_t v17 = a2.n128_u32[3];
  if (a2.n128_f32[3] == 0.0) {
    uint64_t v17 = 0;
  }
  uint64_t v18 = v17 ^ __ROR8__(v16, 51);
  uint64_t v19 = a3.n128_u32[0];
  if (a3.n128_f32[0] == 0.0) {
    uint64_t v19 = 0;
  }
  uint64_t v20 = v19 ^ __ROR8__(v18, 51);
  uint64_t v21 = a3.n128_u32[1];
  if (a3.n128_f32[1] == 0.0) {
    uint64_t v21 = 0;
  }
  uint64_t v22 = v21 ^ __ROR8__(v20, 51);
  uint64_t v23 = a3.n128_u32[2];
  if (a3.n128_f32[2] == 0.0) {
    uint64_t v23 = 0;
  }
  uint64_t v24 = v23 ^ __ROR8__(v22, 51);
  uint64_t v25 = a3.n128_u32[3];
  if (a3.n128_f32[3] == 0.0) {
    uint64_t v25 = 0;
  }
  uint64_t v26 = v25 ^ __ROR8__(v24, 51);
  uint64_t v27 = a4.n128_u32[0];
  if (a4.n128_f32[0] == 0.0) {
    uint64_t v27 = 0;
  }
  uint64_t v28 = v27 ^ __ROR8__(v26, 51);
  uint64_t v29 = a4.n128_u32[1];
  if (a4.n128_f32[1] == 0.0) {
    uint64_t v29 = 0;
  }
  uint64_t v30 = v29 ^ __ROR8__(v28, 51);
  uint64_t v31 = a4.n128_u32[2];
  if (a4.n128_f32[2] == 0.0) {
    uint64_t v31 = 0;
  }
  uint64_t v32 = v31 ^ __ROR8__(v30, 51);
  uint64_t v33 = a4.n128_u32[3];
  if (a4.n128_f32[3] == 0.0) {
    uint64_t v33 = 0;
  }
  return v33 ^ __ROR8__(v32, 51);
}

uint64_t VNHashMemory(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  double v2 = [MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:a1 length:a2 freeWhenDone:0];
  uint64_t v3 = [v2 hash];

  return v3;
}

void sub_1A3ECF198(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ECF77C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3ECF4B8);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3ECFA68()
{
}

void sub_1A3ECFEA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a2)
  {
    _Block_object_dispose(&a23, 8);
    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3ECFE30);
  }
  _Unwind_Resume(exception_object);
}

Class __getBCSDetectedCodeClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!BarcodeSupportLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x1E4F143A8];
    v4[2] = 3221225472;
    v4[3] = __BarcodeSupportLibraryCore_block_invoke;
    void v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E5B1CBC8;
    uint64_t v6 = 0;
    BarcodeSupportLibraryCore_frameworkLibrarint y = _sl_dlopen();
    double v2 = (void *)v4[0];
    if (!BarcodeSupportLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("BCSDetectedCode");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    double v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getBCSDetectedCodeClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __BarcodeSupportLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  BarcodeSupportLibraryCore_frameworkLibrarint y = result;
  return result;
}

id _validatedVNBarcodeSymbology(void *a1)
{
  id v1 = a1;
  if (_validatedVNBarcodeSymbology_onceToken != -1) {
    dispatch_once(&_validatedVNBarcodeSymbology_onceToken, &__block_literal_global_7869);
  }
  uint64_t v2 = [(id)_validatedVNBarcodeSymbology_ourValidBarcodeSymbologies indexOfObject:v1];
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = [(id)_validatedVNBarcodeSymbology_ourValidBarcodeSymbologies objectAtIndex:v2];
  }

  return v3;
}

void ___validatedVNBarcodeSymbology_block_invoke()
{
  v2[25] = *MEMORY[0x1E4F143B8];
  v2[0] = @"VNBarcodeSymbologyAztec";
  v2[1] = @"VNBarcodeSymbologyCode39";
  v2[2] = @"VNBarcodeSymbologyCode39Checksum";
  v2[3] = @"VNBarcodeSymbologyCode39FullASCII";
  v2[4] = @"VNBarcodeSymbologyCode39FullASCIIChecksum";
  v2[5] = @"VNBarcodeSymbologyCode93";
  v2[6] = @"VNBarcodeSymbologyCode93i";
  v2[7] = @"VNBarcodeSymbologyCode128";
  v2[8] = @"VNBarcodeSymbologyDataMatrix";
  v2[9] = @"VNBarcodeSymbologyEAN8";
  v2[10] = @"VNBarcodeSymbologyEAN13";
  v2[11] = @"VNBarcodeSymbologyI2of5";
  v2[12] = @"VNBarcodeSymbologyI2of5Checksum";
  v2[13] = @"VNBarcodeSymbologyITF14";
  v2[14] = @"VNBarcodeSymbologyPDF417";
  v2[15] = @"VNBarcodeSymbologyQR";
  v2[16] = @"VNBarcodeSymbologyUPCE";
  v2[17] = @"VNBarcodeSymbologyAppClipCode";
  v2[18] = @"VNBarcodeSymbologyCodabar";
  v2[19] = @"VNBarcodeSymbologyGS1DataBar";
  v2[20] = @"VNBarcodeSymbologyGS1DataBarExpanded";
  v2[21] = @"VNBarcodeSymbologyGS1DataBarLimited";
  v2[22] = @"VNBarcodeSymbologyMicroPDF417";
  v2[23] = @"VNBarcodeSymbologyMicroQR";
  v2[24] = @"VNBarcodeSymbologyMSIPlessey";
  uint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:25];
  id v1 = (void *)_validatedVNBarcodeSymbology_ourValidBarcodeSymbologies;
  _validatedVNBarcodeSymbology_ourValidBarcodeSymbologies = v0;
}

void sub_1A3ED2FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

double vision::mod::ImageAnalyzer::getSceneSaliency(vision::mod::ImageAnalyzer *this, uint64_t a2)
{
  int v8 = 16;
  if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a2 + 824, 0x10u, &v8)+ 20))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 8574;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  int v7 = 16;
  unint64_t v4 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a2 + 784, 0x10u, &v7);
  *(void *)&double result = vision::mod::ImageAnalyzer_Tensor2D::ImageAnalyzer_Tensor2D((uint64_t)this, (long long *)(v4 + 24)).n128_u64[0];
  return result;
}

int8x16_t vision::mod::ImageAnalyzer_Tensor2D::getVImageBufferFromTensor(uint64_t a1, int8x16_t *a2, int *a3)
{
  *a3 = 0;
  __int32 v3 = a2[10].i32[0];
  if (v3 == 262152)
  {
    int v4 = 1;
    uint64_t v5 = 1;
  }
  else
  {
    if (v3 != 65568)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = 8563;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
    int v4 = 32;
    uint64_t v5 = 4;
  }
  *a3 = v4;
  *(void *)a1 = a2->i64[0];
  int8x16_t result = vextq_s8(a2[5], a2[5], 8uLL);
  *(int8x16_t *)(a1 + 8) = result;
  *(void *)(a1 + 24) = v5 * a2[8].i64[0];
  return result;
}

__n128 vision::mod::ImageAnalyzer_Tensor2D::ImageAnalyzer_Tensor2D(uint64_t a1, long long *a2)
{
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  if (!*(void *)a2
    || (*((void *)a2 + 13) <= 1uLL ? (BOOL v2 = *((void *)a2 + 14) >= 2uLL) : (BOOL v2 = 1), v2
                                                                                    || *((void *)a2 + 12) >= 2uLL))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 8572;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  long long v3 = *a2;
  long long v4 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)a1 = v3;
  long long v5 = a2[3];
  long long v6 = a2[4];
  long long v7 = a2[6];
  *(_OWORD *)(a1 + 80) = a2[5];
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 48) = v5;
  *(_OWORD *)(a1 + 64) = v6;
  __n128 result = (__n128)a2[7];
  long long v9 = a2[8];
  long long v10 = a2[9];
  *(void *)(a1 + 160) = *((void *)a2 + 20);
  *(_OWORD *)(a1 + 128) = v9;
  *(_OWORD *)(a1 + 144) = v10;
  *(__n128 *)(a1 + 112) = result;
  return result;
}

double vision::mod::ImageAnalyzer::getSceneSegmentation(vision::mod::ImageAnalyzer *this, uint64_t a2)
{
  int v8 = 32;
  if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a2 + 824, 0x20u, &v8)+ 20))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 8574;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  int v7 = 32;
  long long v4 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a2 + 784, 0x20u, &v7);
  *(void *)&double result = vision::mod::ImageAnalyzer_Tensor3D::ImageAnalyzer_Tensor3D((uint64_t)this, (long long *)(v4 + 24)).n128_u64[0];
  return result;
}

__n128 vision::mod::ImageAnalyzer_Tensor3D::getVImageBufferFromTensorChannel(_OWORD *a1, uint64_t a2, unint64_t a3, float *a4, int *a5)
{
  if (*(void *)(a2 + 96) <= a3)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v26 = 8556;
LABEL_29:
    void *exception = v26;
LABEL_30:
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  *a5 = 0;
  int v8 = *(_DWORD *)(a2 + 160);
  if (v8 == 262152)
  {
    int v9 = 1;
    uint64_t v10 = 1;
  }
  else
  {
    if (v8 != 65568) {
      goto LABEL_25;
    }
    int v9 = 32;
    uint64_t v10 = 4;
  }
  *a5 = v9;
  float v11 = a4[1];
  uint64_t v12 = (unint64_t)*a4;
  size_t v13 = v10 * *(void *)(a2 + 128);
  vImagePixelCount v15 = *(void *)(a2 + 80);
  vImagePixelCount v14 = *(void *)(a2 + 88);
  v28.int data = (void *)(*(void *)a2 + v14 * a3 * v13);
  v28.float height = v14;
  v28.float width = v15;
  v28.rowBytes = v13;
  uint64_t v16 = (unint64_t)v11;
  if (v14 != v12 || v15 != v16)
  {
    uint64_t v18 = (vImage_Buffer *)(a2 + 184);
    uint64_t v19 = ImageProcessing_reallocVImageBuffer(a2 + 184, v16, v12, v10);
    if ((v19 & 0x80) == 0)
    {
      uint64_t v27 = v19;
      exception = __cxa_allocate_exception(8uLL);
      void *exception = v27;
      goto LABEL_30;
    }
    if (*a5 == 1)
    {
      unint64_t v20 = vImageScale_Planar8(&v28, (const vImage_Buffer *)(a2 + 184), 0, 0x80u);
LABEL_16:
      if (v20 > *(void *)(a2 + 176))
      {
        uint64_t v21 = malloc_type_realloc(*(void **)(a2 + 168), v20, 0x5A716879uLL);
        *(void *)(a2 + 168) = v21;
        if (!v21)
        {
          exception = __cxa_allocate_exception(8uLL);
          uint64_t v26 = 8571;
          goto LABEL_29;
        }
      }
      if (*a5 == 1)
      {
        vImage_Error v22 = vImageScale_Planar8(&v28, (const vImage_Buffer *)(a2 + 184), *(void **)(a2 + 168), 0);
        goto LABEL_22;
      }
      if (*a5 == 32)
      {
        vImage_Error v22 = vImageScale_PlanarF(&v28, (const vImage_Buffer *)(a2 + 184), *(void **)(a2 + 168), 0);
LABEL_22:
        if (!v22) {
          goto LABEL_23;
        }
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v26 = 8570;
        goto LABEL_29;
      }
      goto LABEL_25;
    }
    if (*a5 == 32)
    {
      unint64_t v20 = vImageScale_PlanarF(&v28, (const vImage_Buffer *)(a2 + 184), 0, 0x80u);
      goto LABEL_16;
    }
LABEL_25:
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v26 = 8563;
    goto LABEL_29;
  }
  uint64_t v18 = &v28;
LABEL_23:
  __n128 result = *(__n128 *)&v18->data;
  long long v24 = *(_OWORD *)&v18->width;
  *a1 = *(_OWORD *)&v18->data;
  a1[1] = v24;
  return result;
}

float vision::mod::ImageAnalyzer_Tensor3D::valueAt(vision::mod::ImageAnalyzer_Tensor3D *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*((_DWORD *)this + 40) != 65568)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 8563;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  return *(float *)(*(void *)this + 4 * (a3 + *((void *)this + 17) * a4 + *((void *)this + 16) * a2));
}

void vision::mod::ImageAnalyzer_Tensor3D::~ImageAnalyzer_Tensor3D(vision::mod::ImageAnalyzer_Tensor3D *this)
{
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  free(*((void **)this + 27));
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
}

__n128 vision::mod::ImageAnalyzer_Tensor3D::ImageAnalyzer_Tensor3D(uint64_t a1, long long *a2)
{
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  if (!*(void *)a2 || (*((void *)a2 + 13) <= 1uLL ? (BOOL v2 = *((void *)a2 + 14) >= 2uLL) : (BOOL v2 = 1), v2))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 8572;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  long long v3 = *a2;
  long long v4 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)a1 = v3;
  long long v5 = a2[3];
  long long v6 = a2[4];
  long long v7 = a2[6];
  *(_OWORD *)(a1 + 80) = a2[5];
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 48) = v5;
  *(_OWORD *)(a1 + 64) = v6;
  __n128 result = (__n128)a2[7];
  long long v9 = a2[8];
  long long v10 = a2[9];
  *(void *)(a1 + 160) = *((void *)a2 + 20);
  *(_OWORD *)(a1 + 128) = v9;
  *(_OWORD *)(a1 + 144) = v10;
  *(__n128 *)(a1 + 112) = result;
  return result;
}

void sub_1A3ED39DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3BE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3CD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3D1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3DD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3E94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED3F50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED4218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED4384(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED4484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED45CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED470C(_Unwind_Exception *a1)
{
}

void sub_1A3ED4918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED4AEC(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void sub_1A3ED4E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void _newFaceIDModel(void *a1, int a2, uint64_t a3)
{
  uint64_t v9 = 0;
  long long v10 = &v9;
  uint64_t v11 = 0x4012000000;
  uint64_t v12 = __Block_byref_object_copy__99;
  size_t v13 = __Block_byref_object_dispose__100;
  vImagePixelCount v14 = "";
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = ___ZL15_newFaceIDModeliPU15__autoreleasingP7NSError_block_invoke;
  void v7[3] = &unk_1E5B1EDF0;
  v7[4] = &v9;
  int v8 = a2;
  long long v5 = _Block_copy(v7);
  if (VNExecuteBlock(v5, a3))
  {
    uint64_t v6 = v10[7];
    *a1 = v10[6];
    a1[1] = v6;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }

  _Block_object_dispose(&v9, 8);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
}

{
  void *v5;
  uint64_t v6;
  void v7[5];
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  __n128 (*v12)(__n128 *, __n128 *);
  void (*v13)(uint64_t);
  const char *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;

  uint64_t v9 = 0;
  long long v10 = &v9;
  uint64_t v11 = 0x4012000000;
  uint64_t v12 = __Block_byref_object_copy__122;
  size_t v13 = __Block_byref_object_dispose__123;
  vImagePixelCount v14 = "";
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = ___ZL15_newFaceIDModeliPU15__autoreleasingP7NSError_block_invoke_28828;
  void v7[3] = &unk_1E5B1EDF0;
  v7[4] = &v9;
  int v8 = a2;
  long long v5 = _Block_copy(v7);
  if (VNExecuteBlock(v5, a3))
  {
    uint64_t v6 = v10[7];
    *a1 = v10[6];
    a1[1] = v6;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }

  _Block_object_dispose(&v9, 8);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
}

void sub_1A3ED5014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  _Block_object_dispose(&a15, 8);
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  _Unwind_Resume(a1);
}

void sub_1A3ED51A8(_Unwind_Exception *a1)
{
  std::istream::~istream();
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__99(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__100(uint64_t a1)
{
  id v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t ___ZL15_newFaceIDModeliPU15__autoreleasingP7NSError_block_invoke(uint64_t a1)
{
  BOOL v2 = operator new(0x280uLL);
  v2[1] = 0;
  v2[2] = 0;
  *BOOL v2 = &unk_1EF753498;
  vision::mod::FaceIDModel::FaceIDModel((vision::mod::FaceIDModel *)(v2 + 3), *(_DWORD *)(a1 + 40), 1, 10000, 1, 0.1, 1, *(_DWORD *)(a1 + 40));
  *(void *)&long long v4 = v3;
  *((void *)&v4 + 1) = v2;
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v6 = *(std::__shared_weak_count **)(v5 + 56);
  *(_OWORD *)(v5 + 48) = v4;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  return 1;
}

uint64_t std::__shared_ptr_emplace<vision::mod::FaceIDModel>::__on_zero_shared(uint64_t a1)
{
  free(*(void **)(a1 + 368));
  *(void *)(a1 + 368) = 0;
  BOOL v2 = *(void **)(a1 + 616);
  if (v2)
  {
    *(void *)(a1 + 624) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void **)(a1 + 576);
  if (*(unsigned char *)(a1 + 608) && *v3) {
    free(*v3);
  }
  long long v4 = 0uLL;
  *(_OWORD *)uint64_t v3 = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(unsigned char *)(a1 + 608) = 1;
  uint64_t v5 = (void **)(a1 + 536);
  if (*(unsigned char *)(a1 + 568) && *v5)
  {
    free(*v5);
    long long v4 = 0uLL;
  }
  *(_OWORD *)uint64_t v5 = v4;
  *(_OWORD *)(a1 + 552) = v4;
  *(unsigned char *)(a1 + 568) = 1;
  uint64_t v6 = (void **)(a1 + 496);
  if (*(unsigned char *)(a1 + 528) && *v6) {
    free(*v6);
  }
  long long v7 = 0uLL;
  *(_OWORD *)uint64_t v6 = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(unsigned char *)(a1 + 528) = 1;
  int v8 = (void **)(a1 + 456);
  if (*(unsigned char *)(a1 + 488) && *v8)
  {
    free(*v8);
    long long v7 = 0uLL;
  }
  *(_OWORD *)int v8 = v7;
  *(_OWORD *)(a1 + 472) = v7;
  *(unsigned char *)(a1 + 488) = 1;
  uint64_t v9 = (void **)(a1 + 416);
  if (*(unsigned char *)(a1 + 448) && *v9) {
    free(*v9);
  }
  long long v10 = 0uLL;
  *(_OWORD *)uint64_t v9 = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(unsigned char *)(a1 + 448) = 1;
  uint64_t v11 = (void **)(a1 + 376);
  if (*(unsigned char *)(a1 + 408) && *v11)
  {
    free(*v11);
    long long v10 = 0uLL;
  }
  *(_OWORD *)uint64_t v11 = v10;
  *(_OWORD *)(a1 + 392) = v10;
  *(unsigned char *)(a1 + 408) = 1;
  uint64_t v12 = (void **)(a1 + 296);
  if (*(unsigned char *)(a1 + 336) && *v12) {
    free(*v12);
  }
  *(void *)(a1 + 328) = 0;
  *(_OWORD *)uint64_t v12 = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(unsigned char *)(a1 + 336) = 1;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(a1 + 248);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(a1 + 208);
  size_t v13 = (void **)(a1 + 160);
  if (*(unsigned char *)(a1 + 200) && *v13) {
    free(*v13);
  }
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)size_t v13 = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(unsigned char *)(a1 + 200) = 1;
  vImagePixelCount v14 = (void **)(a1 + 112);
  if (*(unsigned char *)(a1 + 152) && *v14) {
    free(*v14);
  }
  *(void *)(a1 + 144) = 0;
  *(_OWORD *)vImagePixelCount v14 = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(unsigned char *)(a1 + 152) = 1;

  return std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(a1 + 24);
}

void std::__shared_ptr_emplace<vision::mod::FaceIDModel>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753498;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::FaceIDModel>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753498;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ___ZL54_serialNumberToPersonUniqueIdentifierDictionaryClassesv_block_invoke()
{
  uint64_t v0 = (void *)MEMORY[0x1A6257080]();
  id v1 = VNEntityUniqueIdentifierClasses();
  BOOL v2 = (void *)[v1 mutableCopy];

  [v2 addObject:objc_opt_class()];
  uint64_t v3 = [v2 copy];
  long long v4 = (void *)_serialNumberToPersonUniqueIdentifierDictionaryClasses(void)::classes;
  _serialNumberToPersonUniqueIdentifierDictionaryClasses(void)::classes = v3;
}

void sub_1A3ED5588(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED571C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3ED58CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A3ED5A98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED5B4C(_Unwind_Exception *a1)
{
  long long v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3ED5CB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED5FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,id a38)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a33, 8);

  _Block_object_dispose((const void *)(v40 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__19(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
}

uint64_t __Block_byref_object_copy__8138(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = &unk_1EF752200;
  *(void *)(result + 56) = *(void *)(a2 + 56);
  return result;
}

void sub_1A3ED63E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void **a15, void *a16, uint64_t a17, char a18)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a16);
  a15 = (void **)&a18;
  std::vector<std::map<int,double>>::__destroy_vector::operator()[abi:ne180100](&a15);

  _Unwind_Resume(a1);
}

uint64_t std::map<int,double>::map[abi:ne180100](uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (uint64_t **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  long long v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      uint64_t v6 = (int *)(v5 + 4);
      long long v7 = *(uint64_t **)(a1 + 8);
      int v8 = v3;
      if (*(uint64_t ***)a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v9 = *(void *)(a1 + 8);
      long long v10 = v3;
      if (v7)
      {
        do
        {
          int v8 = (uint64_t **)v9;
          uint64_t v9 = *(void *)(v9 + 8);
        }
        while (v9);
      }
      else
      {
        do
        {
          int v8 = (uint64_t **)v10[2];
          BOOL v11 = *v8 == (uint64_t *)v10;
          long long v10 = v8;
        }
        while (v11);
      }
      int v12 = *v6;
      if (*((_DWORD *)v8 + 8) < *v6)
      {
LABEL_8:
        if (v7) {
          size_t v13 = v8;
        }
        else {
          size_t v13 = v3;
        }
        if (v7) {
          vImagePixelCount v14 = v8 + 1;
        }
        else {
          vImagePixelCount v14 = v3;
        }
      }
      else
      {
        size_t v13 = v3;
        vImagePixelCount v14 = v3;
        if (v7)
        {
          vImagePixelCount v14 = v3;
          while (1)
          {
            while (1)
            {
              size_t v13 = (uint64_t **)v7;
              int v18 = *((_DWORD *)v7 + 8);
              if (v12 >= v18) {
                break;
              }
              long long v7 = *v13;
              vImagePixelCount v14 = v13;
              if (!*v13) {
                goto LABEL_15;
              }
            }
            if (v18 >= v12) {
              break;
            }
            vImagePixelCount v14 = v13 + 1;
            long long v7 = v13[1];
            if (!v7) {
              goto LABEL_15;
            }
          }
        }
      }
      if (!*v14)
      {
LABEL_15:
        uint64_t v15 = (uint64_t *)operator new(0x30uLL);
        *((_OWORD *)v15 + 2) = *(_OWORD *)v6;
        std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v13, v14, v15);
      }
      uint64_t v16 = (void *)v5[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (void *)v5[2];
          BOOL v11 = *v17 == (void)v5;
          uint64_t v5 = v17;
        }
        while (!v11);
      }
      uint64_t v5 = v17;
    }
    while (v17 != v4);
  }
  return a1;
}

void sub_1A3ED65F0(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

void std::vector<std::map<int,double>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  id v1 = *a1;
  BOOL v2 = (char *)**a1;
  if (v2)
  {
    long long v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 24;
        std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((void **)v4 - 2));
        long long v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1A3ED6768(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED694C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED6B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED71E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34,uint64_t a35,std::__shared_weak_count *a36,void *__p,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45)
{
  unint64_t v51 = v45;
  if (__p) {
    operator delete(__p);
  }
  if (a36) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a36);
  }
  if (a34) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a34);
  }
  _Block_object_dispose(&a40, 8);

  _Block_object_dispose((const void *)(v47 - 216), 8);
  uint64_t v49 = *(std::__shared_weak_count **)(v47 - 144);
  if (v49) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v49);
  }

  float v50 = *(void **)(v47 - 112);
  if (v50)
  {
    *(void *)(v47 - 104) = v50;
    operator delete(v50);
  }
  if (v46) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v46);
  }

  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_48c52_ZTSNSt3__110shared_ptrIN6vision3mod11FaceIDModelEEE64c69_ZTSNSt3__110shared_ptrIN6vision3mod28ImageDescriptorBufferFloat32EEE80c39_ZTSNSt3__16vectorIiNS_9allocatorIiEEEE(void *a1)
{
  BOOL v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  long long v4 = (std::__shared_weak_count *)a1[7];
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void *__copy_helper_block_ea8_48c52_ZTSNSt3__110shared_ptrIN6vision3mod11FaceIDModelEEE64c69_ZTSNSt3__110shared_ptrIN6vision3mod28ImageDescriptorBufferFloat32EEE80c39_ZTSNSt3__16vectorIiNS_9allocatorIiEEEE(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  a1[6] = *(void *)(a2 + 48);
  a1[7] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(a2 + 72);
  a1[8] = *(void *)(a2 + 64);
  a1[9] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  return std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(a1 + 10, *(const void **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 2);
}

void sub_1A3ED74CC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 72);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  long long v4 = *(std::__shared_weak_count **)(v1 + 56);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3ED77D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, id a14)
{
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<vision::mod::ImageDescriptorBufferFloat32,std::allocator<vision::mod::ImageDescriptorBufferFloat32>,std::vector<long long> &,void *,unsigned long,int,BOOL,void>(uint64_t *a1, void **a2, void *a3, unint64_t a4, int a5, char a6)
{
  int v12 = operator new(0x90uLL);
  v12[1] = 0;
  _DWORD v12[2] = 0;
  *int v12 = &unk_1EF7539A0;
  uint64_t result = vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)(v12 + 3), a2, a3, a4, a5, a6 != 0);
  v12[3] = &unk_1EF752918;
  *((_DWORD *)v12 + 32) = 1;
  v12[17] = 0;
  v12[15] = a4 >> 2;
  *a1 = result;
  a1[1] = (uint64_t)v12;
  return result;
}

void sub_1A3ED790C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1A3ED81EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED82D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED835C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED8404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED8540(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED872C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  std::__shared_weak_count::~__shared_weak_count(v11);
  operator delete(v15);

  vision::mod::ImageDescriptorProcessorEspresso::Options::~Options(v10);
  _Unwind_Resume(a1);
}

void sub_1A3ED8B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, vision::mod::ImageClassifierAbstract *a16, void *a17, void *a18, void *a19)
{
  __cxa_free_exception(v22);

  shared_owners = (std::__shared_weak_count *)v23[6].__shared_owners_;
  if (shared_owners) {
    std::__shared_weak_count::__release_shared[abi:nn180100](shared_owners);
  }
  vision::mod::ImageClassifierAbstract::~ImageClassifierAbstract(a16);

  std::__shared_weak_count::~__shared_weak_count(v23);
  operator delete(v27);

  if (v20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  }
  vision::mod::ImageDescriptorProcessorEspresso::Options::~Options(v19);
  _Unwind_Resume(a1);
}

float vision::mod::ImageDescriptor_EspressoJunk::getRequiredImageSize(vision::mod::ImageDescriptor_EspressoJunk *this)
{
  return 64.0;
}

uint64_t vision::mod::ImageDescriptor_EspressoJunk::getRequiredImageType(vision::mod::ImageDescriptor_EspressoJunk *this)
{
  return 1;
}

void vision::mod::ImageDescriptor_EspressoJunk::~ImageDescriptor_EspressoJunk(vision::mod::ImageDescriptor_EspressoJunk *this)
{
  *(void *)this = &unk_1EF752CE0;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }

  JUMPOUT(0x1A62562C0);
}

{
  std::__shared_weak_count *v1;

  *(void *)this = &unk_1EF752CE0;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageDescriptor_EspressoJunk>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptor_EspressoJunk>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7539D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptor_EspressoJunk>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7539D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A3ED8E78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED8FEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED91F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED9378(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED93E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED944C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED94A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED9508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED955C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED95BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED9608(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED9668(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED96B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED9858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3ED9A80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL VNEntityIdentificationModelIOWriteUInt32ToOutputStream(int a1, void *a2, CC_MD5_CTX *a3, void *a4)
{
  int data = a1;
  id v6 = a2;
  uint64_t v7 = [v6 write:&data maxLength:4];
  if (v7 == 4)
  {
    CC_MD5_Update(a3, &data, 4u);
  }
  else if (a4)
  {
    int v8 = [v6 streamError];
    VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"failed to write to data stream", v8);
    *a4 = (id)objc_claimAutoreleasedReturnValue();
  }
  return v7 == 4;
}

uint64_t VNEntityIdentificationModelIOWriteBufferToOutputStream(const void *a1, CC_LONG a2, void *a3, CC_MD5_CTX *a4, void *a5)
{
  id v9 = a3;
  if (!a1)
  {
    if (a5)
    {
      VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"buffer cannot be nil", 0);
      uint64_t v10 = 0;
      *a5 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  if (!VNEntityIdentificationModelIOWriteUInt32ToOutputStream(a2, v9, a4, a5)) {
    goto LABEL_11;
  }
  if (a2)
  {
    if ([v9 write:a1 maxLength:a2] == a2)
    {
      CC_MD5_Update(a4, a1, a2);
      goto LABEL_6;
    }
    if (a5)
    {
      BOOL v11 = [v9 streamError];
      VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"failed to write to data stream", v11);
      *a5 = (id)objc_claimAutoreleasedReturnValue();
    }
LABEL_11:
    uint64_t v10 = 0;
    goto LABEL_12;
  }
LABEL_6:
  uint64_t v10 = 1;
LABEL_12:

  return v10;
}

uint64_t VNEntityIdentificationModelIOWriteTaggedBufferToOutputStream(int a1, const void *a2, CC_LONG a3, void *a4, CC_MD5_CTX *a5, void *a6)
{
  id v11 = a4;
  if (VNEntityIdentificationModelIOWriteUInt32ToOutputStream(a1, v11, a5, a6)) {
    uint64_t v12 = VNEntityIdentificationModelIOWriteBufferToOutputStream(a2, a3, v11, a5, a6);
  }
  else {
    uint64_t v12 = 0;
  }

  return v12;
}

uint64_t VNEntityIdentificationModelIOWriteTaggedUInt32ToOutputStream(int a1, int a2, void *a3, CC_MD5_CTX *a4, void *a5)
{
  int v11 = a2;
  id v8 = a3;
  if (VNEntityIdentificationModelIOWriteUInt32ToOutputStream(a1, v8, a4, a5)) {
    uint64_t v9 = VNEntityIdentificationModelIOWriteBufferToOutputStream(&v11, 4u, v8, a4, a5);
  }
  else {
    uint64_t v9 = 0;
  }

  return v9;
}

uint64_t VNEntityIdentificationModelIOWriteTaggedNSObjectToOutputStream(int a1, void *a2, void *a3, CC_MD5_CTX *a4, uint64_t a5)
{
  id v9 = a2;
  id v10 = a3;
  if (v9)
  {
    if (VNEntityIdentificationModelIOWriteUInt32ToOutputStream(a1, v10, a4, (void *)a5))
    {
      id v11 = v9;
      id v12 = v10;
      size_t v13 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v11 requiringSecureCoding:1 error:a5];
      vImagePixelCount v14 = v13;
      if (v13)
      {
        id v15 = v13;
        id v16 = v12;
        unint64_t v17 = [v15 length];
        if (HIDWORD(v17))
        {
          if (a5)
          {
            int v18 = objc_msgSend(NSString, "stringWithFormat:", @"data overflow to %lu bytes", v17);
            VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, v18, 0);
            *(void *)a5 = (id)objc_claimAutoreleasedReturnValue();

            a5 = 0;
          }
        }
        else
        {
          a5 = VNEntityIdentificationModelIOWriteBufferToOutputStream((const void *)[v15 bytes], v17, v16, a4, (void *)a5);
        }
      }
      else
      {
        a5 = 0;
      }
    }
    else
    {
      a5 = 0;
    }
  }
  else
  {
    a5 = 1;
  }

  return a5;
}

BOOL VNEntityIdentificationModelIOReadUInt32FromInputStream(void *a1, const void *a2, CC_MD5_CTX *a3, void *a4)
{
  id v7 = a1;
  uint64_t v8 = [v7 read:a2 maxLength:4];
  if (v8 == 4)
  {
    CC_MD5_Update(a3, a2, 4u);
  }
  else if (a4)
  {
    id v9 = [v7 streamError];
    VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"unexpected end of data stream", v9);
    *a4 = (id)objc_claimAutoreleasedReturnValue();
  }
  return v8 == 4;
}

BOOL VNEntityIdentificationModelIOReadBufferFromInputStream(void *a1, CC_LONG a2, const void *a3, CC_MD5_CTX *a4, void *a5)
{
  id v9 = a1;
  uint64_t v10 = a2;
  uint64_t v11 = [v9 read:a3 maxLength:a2];
  if (v11 == a2)
  {
    CC_MD5_Update(a4, a3, a2);
  }
  else if (a5)
  {
    id v12 = [v9 streamError];
    VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"unexpected end of data stream", v12);
    *a5 = (id)objc_claimAutoreleasedReturnValue();
  }
  return v11 == v10;
}

uint64_t VNEntityIdentificationModelIOReadPastUnknownTagData(void *a1, CC_MD5_CTX *a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  unsigned int v12 = 0;
  uint64_t v6 = 0;
  if (VNEntityIdentificationModelIOReadUInt32FromInputStream(v5, &v12, a2, a3))
  {
    unint64_t v7 = v12;
    id v8 = v5;
    if (v7)
    {
      while (1)
      {
        uint64_t v9 = v7 >= 0x100 ? 256 : v7;
        if ([v8 read:data maxLength:v9] != v9) {
          break;
        }
        CC_MD5_Update(a2, data, v9);
        v7 -= v9;
        if (!v7) {
          goto LABEL_8;
        }
      }
      if (a3)
      {
        uint64_t v10 = [v8 streamError];
        VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, @"unexpected end of data stream", v10);
        *a3 = (id)objc_claimAutoreleasedReturnValue();
      }
      uint64_t v6 = 0;
    }
    else
    {
LABEL_8:
      uint64_t v6 = 1;
    }
  }
  return v6;
}

BOOL VNEntityIdentificationModelIOReadBufferOfExpectedLengthFromInputStream(void *a1, uint64_t a2, const void *a3, CC_MD5_CTX *a4, void *a5)
{
  id v9 = a1;
  unsigned int v13 = 0;
  BOOL v10 = 0;
  if (VNEntityIdentificationModelIOReadUInt32FromInputStream(v9, &v13, a4, a5))
  {
    if (v13 == a2)
    {
      BOOL v10 = VNEntityIdentificationModelIOReadBufferFromInputStream(v9, a2, a3, a4, a5);
    }
    else
    {
      if (a5)
      {
        uint64_t v11 = [NSString stringWithFormat:@"encountered unexpected length of %u, instead of %u", v13, a2];
        VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, v11, 0);
        *a5 = (id)objc_claimAutoreleasedReturnValue();
      }
      BOOL v10 = 0;
    }
  }

  return v10;
}

void sub_1A3EDA920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a22);
  _Unwind_Resume(a1);
}

void sub_1A3EDACAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a22);
  _Unwind_Resume(a1);
}

void sub_1A3EDAE04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDAF40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDB008(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDB44C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  _Unwind_Resume(a1);
}

void *std::vector<_Geometry2D_point2D_>::__init_with_size[abi:ne180100]<_Geometry2D_point2D_*,_Geometry2D_point2D_*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3EDB560(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *__Block_byref_object_copy__8572(void *result, void *a2)
{
  result[6] = a2[6];
  uint64_t v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  long long v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    *uint64_t v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__8573(uint64_t a1)
{
}

void sub_1A3EDB88C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_56c62_ZTSNSt3__16vectorI20_Geometry2D_point2D_NS_9allocatorIS1_EEEE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

void *__copy_helper_block_ea8_56c62_ZTSNSt3__16vectorI20_Geometry2D_point2D_NS_9allocatorIS1_EEEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  uint64_t v2 = (void *)(a1 + 56);
  v2[2] = 0;
  return std::vector<_Geometry2D_point2D_>::__init_with_size[abi:ne180100]<_Geometry2D_point2D_*,_Geometry2D_point2D_*>(v2, *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3);
}

void sub_1A3EDB9C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  uint64_t v11 = v10;

  a9.super_class = (Class)VNFaceExpressionDetector;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3EDBB10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDBD1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::shared_ptr<vision::mod::LandmarkAttributes>::reset[abi:ne180100]<vision::mod::LandmarkAttributes,void>()
{
}

void sub_1A3EDBE2C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    vision::mod::LandmarkAttributes::~LandmarkAttributes(v1);
    MEMORY[0x1A62562C0]();
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<vision::mod::LandmarkAttributes *,std::shared_ptr<vision::mod::LandmarkAttributes>::__shared_ptr_default_delete<vision::mod::LandmarkAttributes,vision::mod::LandmarkAttributes>,std::allocator<vision::mod::LandmarkAttributes>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN6vision3mod18LandmarkAttributesEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

vision::mod::LandmarkAttributes *std::__shared_ptr_pointer<vision::mod::LandmarkAttributes *,std::shared_ptr<vision::mod::LandmarkAttributes>::__shared_ptr_default_delete<vision::mod::LandmarkAttributes,vision::mod::LandmarkAttributes>,std::allocator<vision::mod::LandmarkAttributes>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(vision::mod::LandmarkAttributes **)(a1 + 24);
  if (result)
  {
    vision::mod::LandmarkAttributes::~LandmarkAttributes(result);
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

void std::__shared_ptr_pointer<vision::mod::LandmarkAttributes *,std::shared_ptr<vision::mod::LandmarkAttributes>::__shared_ptr_default_delete<vision::mod::LandmarkAttributes,vision::mod::LandmarkAttributes>,std::allocator<vision::mod::LandmarkAttributes>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A3EDC0A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDC2A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDC36C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDC4B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDC574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDC668(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDC6E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNErrorForCVMLStatus(id a1)
{
  id v1 = a1;
  v7[1] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a1 == (id)-29)
    {
LABEL_5:
      id v1 = +[VNError errorForCancellationOfRequest:0];
      goto LABEL_8;
    }
    if (a1 == 128)
    {
      id v1 = 0;
    }
    else
    {
      if (a1 == 99) {
        goto LABEL_5;
      }
      uint64_t v2 = objc_msgSend(MEMORY[0x1E4F28E78], "stringWithFormat:", @"failure with status %lld", a1);
      objc_msgSend(v2, "appendFormat:", @" (%s)", CVML_getStatusDescription((unint64_t)v1));
      uint64_t v3 = objc_msgSend(NSString, "stringWithFormat:", @"%s ", CVML_getModuleDescription((uint64_t)v1));
      [v2 insertString:v3 atIndex:0];

      uint64_t v6 = *MEMORY[0x1E4F28568];
      v7[0] = v2;
      long long v4 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v7 forKeys:&v6 count:1];
      id v1 = [MEMORY[0x1E4F28C58] errorWithDomain:@"com.apple.Vision" code:9 userInfo:v4];
    }
  }
LABEL_8:

  return v1;
}

void sub_1A3EDCA4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDCC8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDCE40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDCF68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDD7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDB2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDC90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDD40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDD8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDDEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDE38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDE98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDEE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDF44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDDF90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDE000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDE06C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDE120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDE194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDE1F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDE240(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDE36C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDE4F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___Z13_VisionLoggerv_block_invoke()
{
  _VisionLogger(void)::_visionLogger = (uint64_t)os_log_create((const char *)[@"com.apple.Vision" UTF8String], (const char *)objc_msgSend(@"VisionLog", "UTF8String"));

  return MEMORY[0x1F41817F8]();
}

void VNValidatedLog(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a2)
  {
    char v10 = a1;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __VNValidatedLog_block_invoke;
    aBlock[3] = &__block_descriptor_36_e24_v24__0____CFString__8_16l;
    int v14 = a1;
    uint64_t v11 = _Block_copy(aBlock);
    unsigned int v12 = v11;
    if ((v10 & 6) != 0) {
      (*((void (**)(void *, uint64_t, uint64_t *))v11 + 2))(v11, a2, &a9);
    }
  }
}

void sub_1A3EDE7CC(void *a1)
{
}

void sub_1A3EDE7D8(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void __VNValidatedLog_block_invoke(uint64_t a1, CFStringRef format, va_list arguments)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, format, arguments);
  if (v4)
  {
    CFStringRef v5 = v4;
    CStringPtr = CFStringGetCStringPtr(v4, 0x8000100u);
    if (CStringPtr)
    {
      uint64_t v7 = CStringPtr;
      if (_VisionLogger(void)::onceToken != -1) {
        dispatch_once(&_VisionLogger(void)::onceToken, &__block_literal_global_8898);
      }
      size_t v8 = (id)_VisionLogger(void)::_visionLogger;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v9 = *(_DWORD *)(a1 + 32) - 1;
        if (v9 > 3) {
          char v10 = "Unknown type: ";
        }
        else {
          char v10 = off_1E5B1CCE0[v9];
        }
        int v11 = 136315394;
        unsigned int v12 = v10;
        __int16 v13 = 2080;
        int v14 = v7;
        _os_log_impl(&dword_1A3C62000, v8, OS_LOG_TYPE_DEFAULT, "%s%s\n", (uint8_t *)&v11, 0x16u);
      }

      CFRelease(v5);
    }
  }
}

void sub_1A3EDEA6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDEBC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDEDA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDEE90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDF094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDF230(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDF3A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorForUnknownPersonUniqueIdentifier(uint64_t a1)
{
  id v1 = [NSString stringWithFormat:@"unknown person (%@)", a1];
  uint64_t v2 = VNPersonsModelErrorWithLocalizedDescription(6, v1);

  return v2;
}

void sub_1A3EDF4C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorWithLocalizedDescription(uint64_t a1, void *a2)
{
  uint64_t v2 = VNPersonsModelErrorWithLocalizedDescriptionAndUnderlyingError(a1, a2, 0);

  return v2;
}

id VNPersonsModelErrorWithLocalizedDescriptionAndUnderlyingError(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = objc_alloc(MEMORY[0x1E4F1C9E8]);
  size_t v8 = objc_msgSend(v7, "initWithObjectsAndKeys:", v5, *MEMORY[0x1E4F28568], v6, *MEMORY[0x1E4F28A50], 0);
  unsigned int v9 = VNPersonsModelErrorWithUserInfo(a1, v8);

  return v9;
}

void sub_1A3EDF5B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorWithUserInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFStringRef v4 = (void *)[objc_alloc(MEMORY[0x1E4F28C58]) initWithDomain:@"com.apple.vis.VNPersonsModel" code:a1 userInfo:v3];

  return v4;
}

void sub_1A3EDF63C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorForInvalidModelData(void *a1)
{
  id v1 = VNPersonsModelErrorWithLocalizedDescription(2, a1);

  return v1;
}

void sub_1A3EDF6FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDF7D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDF83C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDFA54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDFB70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDFBDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDFD1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDFE00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EDFF14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE000C(_Unwind_Exception *a1)
{
  id v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3EE0748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

id ___ZL43_readVersion1PersonAndFaceObservationsChunkP13NSInputStreamP19NSMutableDictionaryP14CC_MD5state_stPU15__autoreleasingP7NSError_block_invoke(void *a1)
{
  id v1 = (void *)[[NSString alloc] initWithFormat:@"face observation %lu of %lu for person identifier '%@'", a1[5] + 1, a1[6], a1[4]];

  return v1;
}

uint64_t __Block_byref_object_copy__9039(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__9040(uint64_t a1)
{
}

BOOL ___ZL24_readTaggedObjectOfClassP13NSInputStreamjP10objc_classP19NSMutableDictionaryP14CC_MD5state_stPU15__autoreleasingP7NSError_block_invoke(uint64_t a1, void *a2)
{
  CFStringRef v4 = (void *)[objc_alloc(MEMORY[0x1E4F28DC0]) initForReadingFromData:*(void *)(a1 + 32) error:a2];
  id v5 = v4;
  if (v4)
  {
    [v4 setRequiresSecureCoding:1];
    [v5 setDecodingFailurePolicy:1];
    if (*(_DWORD *)(a1 + 56) == 1919895117) {
      [v5 setClass:objc_opt_class() forClassName:@"VNPersonsModelFaceModel"];
    }
    id v6 = (Class *)(a1 + 48);
    id v7 = (void *)[objc_alloc(MEMORY[0x1E4F1CAD0]) initWithObjects:a1 + 48 count:1];
    uint64_t v8 = *MEMORY[0x1E4F284E8];
    id v20 = 0;
    uint64_t v9 = [v5 decodeTopLevelObjectOfClasses:v7 forKey:v8 error:&v20];
    id v10 = v20;
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
    unsigned int v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v9;

    uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    BOOL v14 = v13 != 0;
    if (a2 && !v13)
    {
      if (v10)
      {
        *a2 = v10;
      }
      else
      {
        uint64_t v15 = NSString;
        id v16 = NSStringFromClass(*v6);
        unint64_t v17 = [v15 stringWithFormat:@"could not decode object of class %@", v16];
        VNPersonsModelErrorForIOError(v17);
        id v18 = objc_claimAutoreleasedReturnValue();
        *a2 = v18;
      }
    }
  }
  else
  {
    BOOL v14 = 0;
  }

  return v14;
}

void sub_1A3EE0AFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorForIOError(void *a1)
{
  id v1 = VNPersonsModelErrorWithLocalizedDescription(1, a1);

  return v1;
}

void sub_1A3EE0B9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE0CAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE0D3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE0FE8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);
  objc_begin_catch(a1);
  JUMPOUT(0x1A3EE0F7CLL);
}

void sub_1A3EE118C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE16B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE18D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE19DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE1AC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE1BBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorForUnacceptableModelVersion(uint64_t a1)
{
  id v1 = objc_msgSend(NSString, "stringWithFormat:", @"cannot accept model version %lu", a1);
  uint64_t v2 = VNPersonsModelErrorWithLocalizedDescription(2, v1);

  return v2;
}

void sub_1A3EE1C50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE1D08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE1D74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE1E3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE1F20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE1FD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE20A4(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3EE2220(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE22E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE2514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE267C(_Unwind_Exception *a1)
{
  id v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A3EE2864(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE2920(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE2A64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE2BA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE2C58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE2D68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE2E38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3020(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE30A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3148(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3220(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE34EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE35A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3688(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3768(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3828(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE38A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3904(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE39CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3B50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE3D60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorForReadOnlyModelWithLocalizedDescription(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc(MEMORY[0x1E4F1C9E8]);
  id v3 = objc_msgSend(v2, "initWithObjectsAndKeys:", v1, *MEMORY[0x1E4F28568], 0);
  CFStringRef v4 = VNPersonsModelErrorWithUserInfo(3, v3);

  return v4;
}

void sub_1A3EE3E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorCancelledOperation()
{
  v4[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *MEMORY[0x1E4F28568];
  v4[0] = @"operation was cancelled";
  uint64_t v0 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v4 forKeys:&v3 count:1];
  id v1 = [MEMORY[0x1E4F28C58] errorWithDomain:@"com.apple.Vision" code:1 userInfo:v0];

  return v1;
}

void sub_1A3EE3EF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorForUnsupportedAlgorithm(void *a1)
{
  id v1 = a1;
  id v2 = NSString;
  uint64_t v3 = (objc_class *)objc_opt_class();
  CFStringRef v4 = NSStringFromClass(v3);
  id v5 = [v2 stringWithFormat:@"unsupported algorithm %@", v4];

  id v6 = VNPersonsModelErrorWithLocalizedDescription(7, v5);

  return v6;
}

void sub_1A3EE3FAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id VNPersonsModelErrorForUnimplementedMethod(uint64_t a1, uint64_t a2)
{
  id v2 = +[VNError errorForUnimplementedMethod:a2 ofObject:a1];

  return v2;
}

id VNPersonsModelErrorForIncompatibleFaceprint(void *a1)
{
  id v1 = VNPersonsModelErrorWithLocalizedDescription(8, a1);

  return v1;
}

void sub_1A3EE417C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4244(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4290(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4370(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4460(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE44D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE45E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE462C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4800(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE48CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE49B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4A88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4B80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE4E38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5734(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE580C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5A08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5AEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5B6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5C10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5D5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5E54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE5FA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE618C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6B30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6CA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6D10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6D7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6DE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6E54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE6F98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE7004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE7070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE70DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE7148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE71B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE7220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE728C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE72F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE7364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE73D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE75D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE79A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *vision::mod::ImageDescriptorBufferFloat32::getRepresentative(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 72);
  if (v4 != 1)
  {
    if (v4)
    {
      id v6 = malloc_type_realloc(*(void **)(a1 + 112), 4 * v4, 0x100004052888210uLL);
      *(void *)(a1 + 112) = v6;
      if (v6)
      {
        *(void *)operator new(8uLL) = a3;
        if (malloc_type_malloc(4 * *(void *)(a1 + 96), 0x309AE310uLL)) {
          operator new();
        }
        exception = __cxa_allocate_exception(8uLL);
        void *exception = 3707;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
      uint64_t v9 = __cxa_allocate_exception(8uLL);
      uint64_t v10 = 3707;
    }
    else
    {
      syslog(5, "ERROR: Cannot compute the representative of an empty buffer");
      uint64_t v9 = __cxa_allocate_exception(8uLL);
      uint64_t v10 = 3710;
    }
    void *v9 = v10;
    __cxa_throw(v9, MEMORY[0x1E4FBA3E0], 0);
  }
  id v7 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (!v7) {
    return 0;
  }
}

void sub_1A3EE7D70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  MEMORY[0x1A62562C0](v9, 0x10B1C408DA78774);
  operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorBufferFloat32::getDescriptorLengthInBytes(vision::mod::ImageDescriptorBufferFloat32 *this)
{
  return 4 * *((void *)this + 12);
}

uint64_t vision::mod::ImageDescriptorBufferFloat32::computeSelfDistances@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(this + 72);
  if ((int)v3 > 1)
  {
    uint64_t v4 = (vision::mod::ImageDescriptorBufferAbstract *)this;
    std::vector<float>::vector(a2, (uint64_t)(int)((v3 - 1) * v3 + (((int)v3 - 1) * (int)v3 < 0)) >> 1);
    unint64_t DataForKthDescriptor = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(v4, 0);
    uint64_t v6 = 0;
    uint64_t v7 = v3;
    for (unint64_t i = 1; i != v7; ++i)
    {
      uint64_t v9 = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(v4, i);
      this = vision::mod::ImageDescriptorBufferFloat32::computeDistanceBetweenDescriptorAndDescriptors(v4, v9, DataForKthDescriptor, i, (float *)(*a2 + 4 * v6));
      if ((this & 0x80) == 0)
      {
        uint64_t v10 = this;
        exception = __cxa_allocate_exception(8uLL);
        void *exception = v10;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
      v6 += i;
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return this;
}

void sub_1A3EE7EA8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageDescriptorBufferFloat32::computeDistanceBetweenDescriptorAndDescriptors(vision::mod::ImageDescriptorBufferFloat32 *this, const float *__A, const float *a3, vDSP_Length __N, float *__C)
{
  uint64_t v5 = 3709;
  if (!__A) {
    return v5;
  }
  uint64_t v6 = a3;
  if (!a3) {
    return v5;
  }
  __Y = __C;
  if (!__C) {
    return v5;
  }
  vDSP_Length v8 = __N;
  if (__N <= 7)
  {
    if (__N)
    {
      uint64_t v5 = 3712;
      while (1)
      {
        uint64_t v11 = vision::mod::ImageDescriptorBufferFloat32::computeDistanceBetweenDescriptors(this, __A, v6, __Y);
        if ((v11 & 0x80) == 0) {
          break;
        }
        uint64_t v6 = (const float *)((char *)v6 + *((void *)this + 8));
        ++__Y;
        if (!--v8) {
          return v5;
        }
      }
      goto LABEL_22;
    }
    return 3712;
  }
  int v12 = *((_DWORD *)this + 26);
  switch(v12)
  {
    case 3:
      float __Aa = 0.5;
      vDSP_vfill(&__Aa, __C, 1, __N);
      cblas_sgemv(CblasColMajor, CblasTrans, *((_DWORD *)this + 24), v8, 0.5, v6, *((_DWORD *)this + 24), __A, 1, 1.0, __Y, 1);
      return 3712;
    case 2:
      float v17 = 0.5;
      vDSP_vfill(&v17, __C, 1, __N);
      cblas_sgemv(CblasColMajor, CblasTrans, *((_DWORD *)this + 24), v8, -0.5, v6, *((_DWORD *)this + 24), __A, 1, 1.0, __Y, 1);
      return 3712;
    case 1:
      uint64_t v5 = 3712;
      while (1)
      {
        uint64_t v11 = vision::mod::ImageDescriptorBufferFloat32::computeDistanceBetweenDescriptors(this, __A, v6, __Y);
        if ((v11 & 0x80) == 0) {
          break;
        }
        uint64_t v6 = (const float *)((char *)v6 + *((void *)this + 8));
        ++__Y;
        if (!--v8) {
          return v5;
        }
      }
LABEL_22:
      uint64_t v14 = v11;
      exception = __cxa_allocate_exception(8uLL);
      void *exception = v14;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  syslog(5, "ERROR: Unknown distance function");
  return 3702;
}

uint64_t vision::mod::ImageDescriptorBufferFloat32::computeDistanceBetweenDescriptors(vision::mod::ImageDescriptorBufferFloat32 *this, const float *__A, const float *a3, float *__C)
{
  uint64_t v4 = 3709;
  if (__A && a3)
  {
    *DSPSplitComplex __C = 0.0;
    int v6 = *((_DWORD *)this + 26);
    switch(v6)
    {
      case 3:
        float __Ca = 0.0;
        vDSP_dotpr(__A, 1, a3, 1, &__Ca, *((void *)this + 12));
        float v7 = (float)(__Ca + 1.0) * 0.5;
        break;
      case 2:
        float v10 = 0.0;
        vDSP_dotpr(__A, 1, a3, 1, &v10, *((void *)this + 12));
        float v7 = (float)((float)(v10 + 1.0) * -0.5) + 1.0;
        break;
      case 1:
        vDSP_distancesq(__A, 1, a3, 1, __C, *((void *)this + 12));
        float v7 = sqrtf(*__C);
        break;
      default:
        syslog(5, "ERROR: Unknown distance function");
        return 3702;
    }
    *DSPSplitComplex __C = v7;
    return 3712;
  }
  return v4;
}

float vision::mod::ImageDescriptorBufferFloat32::computeDistanceFrom(vision::mod::ImageDescriptorBufferFloat32 *this, const vision::mod::ImageDescriptorBufferAbstract *a2)
{
  if (*((void *)this + 9) != 1 || *((void *)a2 + 9) != 1)
  {
    syslog(5, "ERROR: Invalid number of descriptors, should be 1");
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3708;
    goto LABEL_9;
  }
  unint64_t DataForKthDescriptor = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, 0);
  int v6 = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, 0);
  float __C = 0.0;
  uint64_t v7 = vision::mod::ImageDescriptorBufferFloat32::computeDistanceBetweenDescriptors(this, DataForKthDescriptor, v6, &__C);
  if ((v7 & 0x80) == 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = v7;
LABEL_9:
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  return __C;
}

void vision::mod::ImageDescriptorBufferFloat32::computeDistancesFrom(vision::mod::ImageDescriptorBufferFloat32 *this@<X0>, vDSP_Length *lpsrc@<X1>, float **a3@<X8>)
{
  if (!v6) {
    __cxa_bad_cast();
  }
  if (v6 == this)
  {
    uint64_t v9 = *(void (**)(vision::mod::ImageDescriptorBufferFloat32 *))(*(void *)this + 96);
    v9(this);
  }
  else
  {
    if (*((void *)v6 + 12) != *((void *)this + 12))
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = 3708;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
    vDSP_Length v7 = *((void *)this + 9);
    vDSP_Length v8 = lpsrc[9];
    std::vector<float>::vector(a3, v8 * v7);
    if (v7 == 1 && v8 == 1)
    {
      **a3 = (*(float (**)(vision::mod::ImageDescriptorBufferFloat32 *, vDSP_Length *))(*(void *)this + 88))(this, lpsrc);
    }
    else if (v7 == 1)
    {
      unint64_t DataForKthDescriptor = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor((vision::mod::ImageDescriptorBufferAbstract *)lpsrc, 0);
      uint64_t v11 = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, 0);
      uint64_t v12 = vision::mod::ImageDescriptorBufferFloat32::computeDistanceBetweenDescriptorAndDescriptors(this, v11, DataForKthDescriptor, v8, *a3);
      if ((v12 & 0x80) == 0)
      {
        uint64_t v13 = __cxa_allocate_exception(8uLL);
        *uint64_t v13 = v12;
        __cxa_throw(v13, MEMORY[0x1E4FBA3E0], 0);
      }
    }
    else if (v8 == 1)
    {
      uint64_t v14 = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor((vision::mod::ImageDescriptorBufferAbstract *)lpsrc, 0);
      uint64_t v15 = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, 0);
      uint64_t v16 = vision::mod::ImageDescriptorBufferFloat32::computeDistanceBetweenDescriptorAndDescriptors(this, v14, v15, v7, *a3);
      if ((v16 & 0x80) == 0)
      {
        float v17 = __cxa_allocate_exception(8uLL);
        *float v17 = v16;
        __cxa_throw(v17, MEMORY[0x1E4FBA3E0], 0);
      }
    }
    else
    {
      unint64_t v18 = vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor((vision::mod::ImageDescriptorBufferAbstract *)lpsrc, 0);
      if ((int)v7 >= 1)
      {
        uint64_t v19 = (const float *)v18;
        unint64_t v20 = 0;
        int v21 = 0;
        uint64_t v22 = v7;
        do
        {
          uint64_t v23 = (const float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, v20);
          uint64_t v24 = vision::mod::ImageDescriptorBufferFloat32::computeDistanceBetweenDescriptorAndDescriptors(this, v23, v19, v8, &(*a3)[v21]);
          if ((v24 & 0x80) == 0)
          {
            uint64_t v25 = __cxa_allocate_exception(8uLL);
            *uint64_t v25 = v24;
            __cxa_throw(v25, MEMORY[0x1E4FBA3E0], 0);
          }
          v21 += v8;
          ++v20;
        }
        while (v22 != v20);
      }
    }
  }
}

void sub_1A3EE850C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void vision::mod::ImageDescriptorBufferFloat32::createEmptyCopy(vision::mod::ImageDescriptorBufferFloat32 *this)
{
}

void vision::mod::descriptorBufferUnpackedScores(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  *a1 = 0;
  a1[1] = 0;
  unint64_t v8 = a2[9];
  unint64_t v9 = (unint64_t)(*(uint64_t (**)(void *))(*a2 + 104))(a2) >> 2;
  if (v9 == a4)
  {
    *(void *)(a3 + 8) = *(void *)a3;
    (*(void (**)(void *))(*a2 + 24))(a2);
    operator new();
  }
  if (v9 != a4 + 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3708;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  std::vector<float>::resize((char **)a3, v8);
  std::string __p = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(&__p, (const void *)a2[1], a2[2], (uint64_t)(a2[2] - a2[1]) >> 3);
  if (v8 != (v24 - (uint64_t)__p) >> 3) {
    std::vector<long long>::resize((char **)&__p, v8);
  }
  uint64_t v10 = 4 * (v9 - 1);
  uint64_t v11 = malloc_type_malloc(v8 * v10, 0xD8247996uLL);
  uint64_t v12 = operator new(0x90uLL);
  v12[1] = 0;
  _DWORD v12[2] = 0;
  *uint64_t v12 = &unk_1EF7539A0;
  uint64_t v13 = vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)(v12 + 3), (void **)&__p, v11, v10, v8, 1);
  v12[3] = &unk_1EF752918;
  v12[17] = 0;
  *(void *)&long long v14 = v13;
  *((void *)&v14 + 1) = v12;
  *(_OWORD *)a1 = v14;
  int v15 = *((_DWORD *)a2 + 26);
  v12[15] = v9 - 1;
  *((_DWORD *)v12 + 32) = v15;
  if (v8)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 4 * v9;
    do
    {
      unint64_t v20 = (char *)(a2[7] + v16);
      int v21 = (void *)(v12[10] + v17);
      *(float *)(*(void *)a3 + 4 * v18) = *(float *)&v20[v10] / 0.00001;
      memcpy(v21, v20, v10);
      ++v18;
      v17 += v10;
      v16 += v19;
    }
    while (v8 != v18);
  }
  if (__p) {
    operator delete(__p);
  }
}

void sub_1A3EE88C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<vision::mod::ImageDescriptorBufferFloat32 *,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>::__shared_ptr_default_delete<vision::mod::ImageDescriptorBufferFloat32,vision::mod::ImageDescriptorBufferFloat32>,std::allocator<vision::mod::ImageDescriptorBufferFloat32>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN6vision3mod28ImageDescriptorBufferFloat32EE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::__shared_ptr_pointer<vision::mod::ImageDescriptorBufferFloat32 *,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>::__shared_ptr_default_delete<vision::mod::ImageDescriptorBufferFloat32,vision::mod::ImageDescriptorBufferFloat32>,std::allocator<vision::mod::ImageDescriptorBufferFloat32>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<vision::mod::ImageDescriptorBufferFloat32 *,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>::__shared_ptr_default_delete<vision::mod::ImageDescriptorBufferFloat32,vision::mod::ImageDescriptorBufferFloat32>,std::allocator<vision::mod::ImageDescriptorBufferFloat32>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A3EE8B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__10012(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__10013(uint64_t a1)
{
}

uint64_t Face3D_estimateCameraProjective(uint64_t a1, uint64_t a2, float *a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    int v6 = *(_DWORD *)(a1 + 16);
    if (v6 != *(_DWORD *)(a2 + 24))
    {
      unint64_t v9 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v10 = 2172;
      goto LABEL_47;
    }
    *(_OWORD *)__dst = 0u;
    *(_OWORD *)float __C = 0u;
    Geometry2D_mallocHomo2D((uint64_t)__dst, v6);
    unint64_t v9 = 0;
    uint64_t v10 = 2171;
    if (!__dst[0] || !__dst[1] || !__C[0]) {
      goto LABEL_46;
    }
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    if (SLODWORD(__C[1]) < 1) {
      goto LABEL_47;
    }
    if (*(void *)a1 && *(void *)(a1 + 8) && (int v13 = *(_DWORD *)(a1 + 16), v13 >= 1))
    {
      if (v13 == LODWORD(__C[1]))
      {
        memcpy(__dst[0], *(const void **)a1, 4 * LODWORD(__C[1]));
        memcpy(__dst[1], *(const void **)(a1 + 8), 4 * *(int *)(a1 + 16));
        LODWORD(__A) = 1065353216;
        vDSP_vfill((const float *)&__A, __C[0], 1, *(int *)(a1 + 16));
        long long __A = 0u;
        *(_OWORD *)__vImage_Buffer src = 0u;
        Geometry2D_mallocHomo2D((uint64_t)&__A, *(_DWORD *)(a1 + 16));
        unint64_t v9 = 0;
        uint64_t v14 = __A;
        uint64_t v10 = 2171;
        if ((void)__A)
        {
          uint64_t v15 = *((void *)&__A + 1);
          if (*((void *)&__A + 1))
          {
            uint64_t v16 = __src[0];
            if (__src[0])
            {
              uint64_t v11 = 0;
              uint64_t v12 = 0;
              if (SLODWORD(__src[1]) < 1) {
                goto LABEL_47;
              }
              uint64_t v17 = (char *)__dst[0];
              if (!__dst[0] || (uint64_t v18 = (char *)__dst[1]) == 0 || (v19 = __C[0]) == 0)
              {
                unint64_t v9 = 0;
                uint64_t v11 = 0;
                uint64_t v12 = 0;
                uint64_t v10 = 1916;
                goto LABEL_47;
              }
              unint64_t v9 = 0;
              uint64_t v10 = 1916;
              if (SLODWORD(__C[1]) >= 1)
              {
                uint64_t v11 = 0;
                uint64_t v12 = 0;
                if (LODWORD(__C[1]) == LODWORD(__src[1]))
                {
                  unint64_t v20 = 0;
                  float v21 = a3[3];
                  float v22 = a3[4];
                  float v23 = a3[7];
                  float v24 = 1.0 / *a3;
                  float v25 = *a3 * v22;
                  float v26 = (float)-v21 / v25;
                  float v27 = (float)((float)(v21 * v23) / v25) - (float)(a3[6] / *a3);
                  float v28 = 1.0 / v22;
                  size_t v29 = 4 * LODWORD(__src[1]);
                  float v30 = (float)-v23 / v22;
                  do
                  {
                    *(float *)(v14 + v20) = (float)((float)(v26 * *(float *)&v18[v20])
                                                  + (float)(v24 * *(float *)&v17[v20]))
                                          + (float)(v27 * v19[v20 / 4]);
                    *(float *)(v15 + v20) = (float)(v30 * v19[v20 / 4]) + (float)(v28 * *(float *)&v18[v20]);
                    v20 += 4;
                  }
                  while (v29 != v20);
                  memcpy(v16, v19, v29);
                  size_t v31 = 16 * *(int *)(a2 + 24);
                  uint64_t v32 = (char *)malloc_type_malloc(v31, 0xFD7F38A1uLL);
                  unint64_t v9 = v32;
                  if (v32)
                  {
                    size_t v33 = 4 * *(int *)(a2 + 24);
                    memcpy(v32, *(const void **)a2, v33);
                    long long v34 = &v9[4 * *(int *)(a2 + 24)];
                    memcpy(v34, *(const void **)(a2 + 8), v33);
                    long long v35 = &v34[4 * *(int *)(a2 + 24)];
                    memcpy(v35, *(const void **)(a2 + 16), v33);
                    vDSP_Length v36 = *(int *)(a2 + 24);
                    LODWORD(v90[0]) = 1065353216;
                    vDSP_vfill((const float *)v90, (float *)&v35[4 * v36], 1, v36);
                    uint64_t v11 = malloc_type_malloc(v31, 0x50CC6BCBuLL);
                    if (v11)
                    {
                      uint64_t v12 = (float *)malloc_type_malloc(8 * *(int *)(a2 + 24), 0x100004052888210uLL);
                      if (v12)
                      {
                        *(_OWORD *)uint64_t v90 = 0u;
                        *(_OWORD *)uint64_t v91 = 0u;
                        Geometry2D_mallocHomo2D((uint64_t)v90, *(_DWORD *)(a1 + 16));
                        uint64_t v10 = 2171;
                        if (v90[0])
                        {
                          if (v90[1])
                          {
                            if (v91[0])
                            {
                              if (SLODWORD(v91[1]) >= 1)
                              {
                                *(_OWORD *)float v88 = 0u;
                                *(_OWORD *)uint64_t v89 = 0u;
                                Geometry2D_mallocHomo2D((uint64_t)v88, *(_DWORD *)(a1 + 16));
                                uint64_t v10 = 2171;
                                if (v88[0])
                                {
                                  if (v88[1] && v89[0] && SLODWORD(v89[1]) >= 1)
                                  {
                                    uint64_t v37 = 0;
                                    int v38 = 0;
                                    *(_OWORD *)int v86 = 0u;
                                    *(_OWORD *)uint64_t v87 = 0u;
                                    if ((void)__A && *((void *)&__A + 1))
                                    {
                                      uint64_t v39 = 0;
                                      uint64_t v40 = 0;
                                      if (__src[0])
                                      {
                                        if (SLODWORD(__src[1]) < 1)
                                        {
                                          int v38 = 0;
                                          uint64_t v37 = 0;
                                          uint64_t v39 = 0;
                                          uint64_t v40 = 0;
                                        }
                                        else
                                        {
                                          Geometry2D_mallocHomo2D((uint64_t)v86, (int)__src[1]);
                                          uint64_t v40 = v86[0];
                                          uint64_t v39 = v86[1];
                                          uint64_t v37 = v87[0];
                                          int v38 = (int)v87[1];
                                          if (v86[0] && v86[1] && v87[0] && SLODWORD(v87[1]) >= 1)
                                          {
                                            size_t v41 = 4 * SLODWORD(__src[1]);
                                            LODWORD(v87[1]) = __src[1];
                                            memcpy(v86[0], (const void *)__A, v41);
                                            memcpy(v39, *((const void **)&__A + 1), v41);
                                            memcpy(v37, __src[0], v41);
                                            uint64_t v40 = v86[0];
                                            uint64_t v39 = v86[1];
                                            uint64_t v37 = v87[0];
                                            int v38 = (int)v87[1];
                                          }
                                        }
                                      }
                                    }
                                    else
                                    {
                                      uint64_t v39 = 0;
                                      uint64_t v40 = 0;
                                    }
                                    uint64_t v10 = 2171;
                                    if (v40)
                                    {
                                      if (v39 && v37 && v38 >= 1)
                                      {
                                        unsigned int v43 = 0;
                                        uint64_t v82 = "The %d argument had an illegal value.";
                                        while (1)
                                        {
                                          unsigned int v85 = v43;
                                          size_t v44 = 4 * SLODWORD(v87[1]);
                                          memcpy(v12, v86[0], v44);
                                          memcpy(&v12[SLODWORD(v87[1])], v86[1], v44);
                                          memcpy(v11, v9, v31);
                                          __int m = *(_DWORD *)(a2 + 24);
                                          char __trans = 78;
                                          __CLPK_integer __nrhs = 2;
                                          __CLPK_integer __n = 4;
                                          __CLPK_integer __ldb = __m;
                                          __CLPK_integer __lda = __m;
                                          __CLPK_integer __lwork = -1;
                                          unsigned int v98 = 0;
                                          sgels_(&__trans, &__m, &__n, &__nrhs, 0, &__lda, 0, &__ldb, &__work, &__lwork, (__CLPK_integer *)&v98);
                                          __CLPK_integer __lwork = (int)__work;
                                          vDSP_Length v45 = (__CLPK_real *)malloc_type_malloc(4 * (int)__work, 0x100004052888210uLL);
                                          if (!v45)
                                          {
                                            uint64_t v10 = 2171;
                                            goto LABEL_80;
                                          }
                                          sgels_(&__trans, &__m, &__n, &__nrhs, (__CLPK_real *)v11, &__lda, v12, &__ldb, v45, &__lwork, (__CLPK_integer *)&v98);
                                          if ((int)v98 > 0) {
                                            break;
                                          }
                                          if ((v98 & 0x80000000) != 0)
                                          {
                                            uint64_t v82 = "The %d-th diagonal element of the triangular factor of A is zero, so t"
                                                  "hat A does not have full rank; the least squares solution could not be computed.";
                                            break;
                                          }
                                          float v46 = *v12;
                                          float v47 = v12[1];
                                          float v48 = v12[2];
                                          float v49 = v12[3];
                                          float v50 = v12[__m];
                                          float v51 = v12[__m + 1];
                                          float v52 = v12[__m + 2];
                                          float v53 = v12[__m + 3];
                                          free(v45);
                                          float v54 = sqrtf((float)(1.0/ sqrtf((float)((float)(v47 * v47) + (float)(v46 * v46))+ (float)(v48 * v48)))* (float)(1.0/ sqrtf((float)((float)(v51 * v51) + (float)(v50 * v50))+ (float)(v52 * v52))));
                                          *(float *)(a4 + 44) = v54;
                                          float v55 = v46 * v54;
                                          float v56 = v47 * v54;
                                          float v57 = v48 * v54;
                                          float v58 = v49 * v54;
                                          float v59 = v50 * v54;
                                          float v60 = v51 * v54;
                                          float v61 = v52 * v54;
                                          float v83 = (float)(v57 * v59) - (float)(v55 * (float)(v52 * v54));
                                          float v84 = (float)(v56 * (float)(v52 * v54)) - (float)(v57 * v60);
                                          v105[0] = v84;
                                          v105[1] = v83;
                                          v105[2] = (float)(v55 * v60) - (float)(v56 * v59);
                                          v105[3] = v54;
                                          *(float *)(a4 + 36) = v58;
                                          *(float *)(a4 + 40) = v53 * v54;
                                          uint64_t v10 = Geometry2D_metricToPixelHomo2D((uint64_t *)v86, a3, (uint64_t *)v90);
                                          if ((v10 & 0x80) == 0) {
                                            goto LABEL_47;
                                          }
                                          uint64_t v62 = *(unsigned int *)(a2 + 24);
                                          uint64_t v63 = v87[0];
                                          __int m = 0;
                                          vDSP_vfill((const float *)&__m, v87[0], 1, (int)v62);
                                          uint64_t v64 = 0;
                                          LODWORD(v65) = 0;
                                          do
                                          {
                                            if ((int)v62 >= 1)
                                            {
                                              uint64_t v65 = (int)v65;
                                              float v66 = v105[v64];
                                              uint64_t v67 = v63;
                                              uint64_t v68 = v62;
                                              do
                                              {
                                                float *v67 = *v67 + (float)(*(float *)&v9[4 * v65] * v66);
                                                ++v67;
                                                ++v65;
                                                --v68;
                                              }
                                              while (v68);
                                            }
                                            ++v64;
                                          }
                                          while (v64 != 4);
                                          vDSP_vsdiv(v87[0], 1, (const float *)(a4 + 44), v87[0], 1, *(int *)(a2 + 24));
                                          vDSP_vmul((const float *)__A, 1, v87[0], 1, v86[0], 1, *(int *)(a2 + 24));
                                          vDSP_vmul(*((const float **)&__A + 1), 1, v87[0], 1, v86[1], 1, *(int *)(a2 + 24));
                                          uint64_t v10 = Geometry2D_metricToPixelHomo2D((uint64_t *)v86, a3, (uint64_t *)v88);
                                          if ((v10 & 0x80) == 0) {
                                            goto LABEL_47;
                                          }
                                          uint64_t v69 = LODWORD(v91[1]);
                                          if (SLODWORD(v91[1]) > 0)
                                          {
                                            uint64_t v70 = (float *)v90[0];
                                            float v71 = (float *)v90[1];
                                            float v72 = 0.0;
                                            uint64_t v73 = (float *)v88[0];
                                            unint64_t v74 = (float *)v88[1];
                                            do
                                            {
                                              float v75 = *v70++;
                                              float v76 = v75;
                                              float v77 = *v73++;
                                              float v78 = v77;
                                              float v79 = *v71++;
                                              float v80 = v79;
                                              float v81 = *v74++;
                                              float v72 = v72
                                                  + (float)((float)((float)(v80 - v81) * (float)(v80 - v81))
                                                          + (float)((float)(v76 - v78) * (float)(v76 - v78)));
                                              --v69;
                                            }
                                            while (v69);
                                            if (v85 <= 0x3E6)
                                            {
                                              unsigned int v43 = v85 + 1;
                                              if (v72 > 1.0) {
                                                continue;
                                              }
                                            }
                                          }
                                          *(float *)a4 = v55;
                                          *(float *)(a4 + 4) = v59;
                                          *(float *)(a4 + 24) = v57;
                                          *(float *)(a4 + 28) = v61;
                                          *(float *)(a4 + 8) = v84;
                                          *(float *)(a4 + 12) = v56;
                                          *(float *)(a4 + 16) = v60;
                                          *(float *)(a4 + 20) = v83;
                                          *(float *)(a4 + 32) = (float)(v55 * v60) - (float)(v56 * v59);
                                          goto LABEL_47;
                                        }
                                        syslog(3, v82, v98);
                                        uint64_t v10 = 2159;
LABEL_80:
                                        free(v45);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        goto LABEL_47;
                      }
                      goto LABEL_53;
                    }
                  }
                  else
                  {
                    uint64_t v11 = 0;
                  }
                  uint64_t v12 = 0;
LABEL_53:
                  uint64_t v10 = 2171;
                }
LABEL_47:
                free(__dst[0]);
                __dst[0] = 0;
                free(__dst[1]);
                __dst[1] = 0;
                free(__C[0]);
                __C[0] = 0;
                LODWORD(__C[1]) = 0;
                free((void *)__A);
                *(void *)&long long __A = 0;
                free(*((void **)&__A + 1));
                *((void *)&__A + 1) = 0;
                free(__src[0]);
                __src[0] = 0;
                LODWORD(__src[1]) = 0;
                free(v90[0]);
                v90[0] = 0;
                free(v90[1]);
                v90[1] = 0;
                free(v91[0]);
                v91[0] = 0;
                LODWORD(v91[1]) = 0;
                free(v88[0]);
                v88[0] = 0;
                free(v88[1]);
                v88[1] = 0;
                free(v89[0]);
                v89[0] = 0;
                LODWORD(v89[1]) = 0;
                free(v86[0]);
                v86[0] = 0;
                free(v86[1]);
                v86[1] = 0;
                free(v87[0]);
                free(v9);
                free(v11);
                free(v12);
                return v10;
              }
            }
          }
        }
LABEL_46:
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        goto LABEL_47;
      }
      uint64_t v10 = 1916;
    }
    else
    {
      uint64_t v10 = 1917;
    }
    unint64_t v9 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    goto LABEL_47;
  }
  return 893;
}

void sub_1A3EE981C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE99F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE9D3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3EE9E2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void VNRecordImageTooSmallWarningWithImageMinimumShortDimension(void *a1, uint64_t a2)
{
  id v4 = a1;
  uint64_t v3 = [NSNumber numberWithUnsignedLong:a2];
  [v4 recordWarning:@"VNRequestWarningImageMinimumShortDimension" value:v3];
}

void sub_1A3EE9EB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void VNRecordBlinkDetectionFailureWarning(void *a1, void *a2)
{
  v6[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  v6[0] = v4;
  uint64_t v5 = [MEMORY[0x1E4F1C978] arrayWithObjects:v6 count:1];
  [v3 recordWarning:@"VNRequestWarningBlinkDetectionFailure" value:v5];
}

void sub_1A3EE9F7C(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

void VNRecordImageTilingWarning(void *a1, unint64_t a2, uint64_t a3)
{
  v9[2] = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  if ((a3 | a2) >= 2)
  {
    int v6 = [NSNumber numberWithUnsignedInteger:a2];
    v9[0] = v6;
    vDSP_Length v7 = [NSNumber numberWithUnsignedInteger:a3];
    v9[1] = v7;
    unint64_t v8 = [MEMORY[0x1E4F1C978] arrayWithObjects:v9 count:2];
    [v5 recordWarning:@"VNRequestWarningTiledAnalysis" value:v8];
  }
}

void sub_1A3EEA090(_Unwind_Exception *a1)
{
  id v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3EEA128(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEA194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEA2D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEA39C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEA600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEA7D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEA964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

Class ___ZL31getVCPPetsPoseImageRequestClassv_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!VideoProcessingLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = MEMORY[0x1E4F143A8];
    void v4[2] = 3221225472;
    v4[3] = ___ZL26VideoProcessingLibraryCorePPc_block_invoke;
    void v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E5B1D0B0;
    uint64_t v6 = 0;
    VideoProcessingLibraryCore(char **)::frameworkLibrarint y = _sl_dlopen();
    id v2 = (void *)v4[0];
    if (!VideoProcessingLibraryCore(char **)::frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("VCPPetsPoseImageRequest");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    id v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getVCPPetsPoseImageRequestClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL26VideoProcessingLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  VideoProcessingLibraryCore(char **)::frameworkLibrarint y = result;
  return result;
}

uint64_t apple::vision::libraries::autotrace::ATRRecord::ATRRecord(uint64_t this, const EPolygon *a2, int a3, int a4)
{
  *(void *)this = a2;
  *(void *)(this + 64) = 0;
  *(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(this + 12) = a4;
  float64x2_t v4 = 0uLL;
  *(_OWORD *)(this + 16) = 0u;
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)(this + 48) = 0u;
  if (a4 >= 1)
  {
    int v5 = 0;
    uint64_t v6 = (float32x2_t *)*((void *)a2 + 1);
    int v7 = *(_DWORD *)a2;
    unint64_t v8 = &v6[a3];
    double v9 = 0.0;
    float v10 = 0.0;
    float v11 = 0.0;
    float v12 = 0.0;
    float v13 = 0.0;
    float64x2_t v14 = 0uLL;
    do
    {
      float32x2_t v15 = *v8;
      if (!v5)
      {
        *(_DWORD *)(this + 56) = v15.i32[0];
        *(float32x2_t *)(this + 64) = v15;
        uint64_t v18 = (__int32 *)(this + 60);
        __int32 v19 = v15.i32[1];
        float v20 = v15.f32[1];
        float v11 = v15.f32[1];
        float v12 = v15.f32[0];
        float v13 = v15.f32[0];
LABEL_12:
        __int32 *v18 = v19;
        float v10 = v20;
        goto LABEL_13;
      }
      if (v15.f32[0] >= v13)
      {
        uint64_t v16 = (_DWORD *)(this + 64);
        LODWORD(v17) = *(float32x2_t *)v8->f32;
        if (v15.f32[0] <= v12) {
          goto LABEL_9;
        }
      }
      else
      {
        uint64_t v16 = (_DWORD *)(this + 56);
        float v17 = v12;
        LODWORD(v13) = *(float32x2_t *)v8->f32;
      }
      _DWORD *v16 = v15.i32[0];
      float v12 = v17;
LABEL_9:
      __int32 v19 = v15.i32[1];
      if (v15.f32[1] < v11)
      {
        uint64_t v18 = (__int32 *)(this + 60);
        float v20 = v10;
        float v11 = v15.f32[1];
        goto LABEL_12;
      }
      uint64_t v18 = (__int32 *)(this + 68);
      float v20 = v15.f32[1];
      if (v15.f32[1] > v10) {
        goto LABEL_12;
      }
LABEL_13:
      float64x2_t v4 = vaddq_f64(v4, vcvtq_f64_f32(v15));
      float64x2_t v14 = vaddq_f64(v14, vcvtq_f64_f32(vmul_f32(v15, v15)));
      *(float64x2_t *)(this + 16) = v4;
      *(float64x2_t *)(this + 32) = v14;
      double v9 = v9 + vmul_lane_f32(v15, v15, 1).f32[0];
      *(double *)(this + 48) = v9;
      ++v8;
      if (a3 + 1 < v7)
      {
        ++a3;
      }
      else
      {
        unint64_t v8 = v6;
        a3 = 0;
      }
      ++v5;
    }
    while (a4 != v5);
  }
  return this;
}

uint64_t apple::vision::libraries::autotrace::ATRRecord::LinearRegression(apple::vision::libraries::autotrace::ATRRecord *this, BOOL *a2, float *a3, float *a4)
{
  double v4 = (float)(1.0 / (float)*((int *)this + 3));
  double v6 = *((double *)this + 2);
  double v5 = *((double *)this + 3);
  double v7 = v5 * v4;
  float v8 = v5 * v4;
  double v9 = v6 * v4;
  float v10 = *((float *)this + 16) - *((float *)this + 14);
  float v11 = v9;
  float v12 = *((float *)this + 17) - *((float *)this + 15);
  if (v10 <= v12)
  {
    float v17 = *((double *)this + 5) - v7 * v5;
    if (v17 != 0.0)
    {
      float v19 = *((double *)this + 6) - v9 * v5;
      float v15 = v19 / v17;
      float v16 = v11 - (float)(v15 * v8);
      goto LABEL_7;
    }
    return 0;
  }
  float v13 = *((double *)this + 4) - v9 * v6;
  if (v13 == 0.0) {
    return 0;
  }
  float v14 = *((double *)this + 6) + -v9 * v5;
  float v15 = v14 / v13;
  float v16 = v8 - (float)(v15 * v11);
LABEL_7:
  *a2 = v10 > v12;
  *a3 = v16;
  *a4 = v15;
  return 1;
}

float apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(int **this, unsigned int a2, float a3, float a4)
{
  int v4 = *((_DWORD *)this + 3);
  if (v4 < 1) {
    return 0.0;
  }
  uint64_t v5 = *((void *)*this + 1);
  int v6 = **this;
  float v7 = 1.0 / sqrtf((float)(a4 * a4) + 1.0);
  int v8 = *((_DWORD *)this + 2);
  float v9 = 0.0;
  do
  {
    uint64_t v12 = *(void *)(v5 + 8 * v8);
    float v10 = v7
        * vabds_f32(*(float *)((unint64_t)&v12 | (4 * a2)), a3 + (float)(a4 * *(float *)((unint64_t)&v12 | (4 * (a2 ^ 1)))));
    if (v10 > v9) {
      float v9 = v10;
    }
    if (v8 + 1 == v6) {
      int v8 = 0;
    }
    else {
      ++v8;
    }
    --v4;
  }
  while (v4);
  return v9;
}

void apple::vision::libraries::autotrace::ATRAngleOfLine(apple::vision::libraries::autotrace *this, const EPolygon *a2, int a3, int a4, int a5, float a6, float a7)
{
  float v8 = atanf(a6);
  if (a5)
  {
    float v10 = v8;
  }
  else
  {
    float v9 = 1.57079633 - v8;
    float v10 = v9;
  }
  __sincosf_stret(v10);
}

void sub_1A3EEB398(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEB5B0(_Unwind_Exception *a1)
{
  float v9 = v7;

  _Unwind_Resume(a1);
}

void sub_1A3EEB6AC(_Unwind_Exception *a1)
{
  int v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__deallocate_node(*(id **)(a1 + 16));
  id v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__deallocate_node(id *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      id v2 = (id *)*v1;

      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void sub_1A3EEBA68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEBAE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEBD88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, id *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, id *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,void *a26,void *a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,id *a38)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__deallocate_node(a17);
  if (__p) {
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__deallocate_node(a12);
  if (a10) {
    operator delete(a10);
  }

  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__deallocate_node(0);
  _Block_object_dispose(&a30, 8);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__deallocate_node(a38);
  unsigned int v43 = a36;
  a36 = 0;
  if (v43) {
    operator delete(v43);
  }

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__10470(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__10471(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table(a1 + 48);
}

void sub_1A3EEC20C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *(void *)uint64_t result = v2;
  *(void *)(result + 8) = a2[1];
  a2[1] = 0;
  uint64_t v5 = a2[2];
  id v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 16;
    *id v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t std::unordered_map<NSString * {__strong},__CVBuffer *>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (unint64_t i = *(id **)(a2 + 16); i; unint64_t i = (id *)*i)
    std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__emplace_unique_key_args<NSString * {__strong},std::pair<NSString * const {__strong},__CVBuffer *> const&>(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_1A3EEC348(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__emplace_unique_key_args<NSString * {__strong},std::pair<NSString * const {__strong},__CVBuffer *> const&>(uint64_t a1, id *a2, uint64_t a3)
{
  unint64_t v7 = [*a2 hash];
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    float v11 = *(void **)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (unint64_t i = (void *)*v11; i; unint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v7)
        {
          if ((id)i[2] == *a2) {
            return;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  float v14 = operator new(0x20uLL);
  *float v14 = 0;
  v14[1] = v8;
  id v15 = *(id *)a3;
  uint64_t v16 = *(void *)(a3 + 8);
  v14[2] = v15;
  v14[3] = v16;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v22);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v23 = *(void *)a1;
  float v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *float v14 = *v24;
LABEL_38:
    *float v24 = v14;
    goto LABEL_39;
  }
  *float v14 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  *(void *)(v23 + 8 * v3) = a1 + 16;
  if (*v14)
  {
    unint64_t v25 = *(void *)(*v14 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v25 >= v9) {
        v25 %= v9;
      }
    }
    else
    {
      v25 &= v9 - 1;
    }
    float v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_1A3EEC570(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<objc_class * {__strong},objc_selector *>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>(uint64_t a1, id *a2, id **a3)
{
  unint64_t v7 = [*a2 hash];
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    float v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (unint64_t i = *v11; i; unint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v7)
        {
          if ((id)i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  unint64_t i = operator new(0x20uLL);
  *unint64_t i = 0;
  i[1] = v8;
  i[2] = **a3;
  i[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v19);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v20 = *(void *)a1;
  unint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *unint64_t i = *v21;
LABEL_38:
    void *v21 = i;
    goto LABEL_39;
  }
  *unint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }
    else
    {
      v22 &= v9 - 1;
    }
    unint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1A3EEC7A8(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<objc_class * {__strong},objc_selector *>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void sub_1A3EECE38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,void *a45,void *a46,void *a47,void *a48,void *a49,void *a50,void *a51,void *a52,void *a53)
{
  _Unwind_Resume(a1);
}

void sub_1A3EED660(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,int a35,__int16 a36,char a37,char a38)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3EED564);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3EED894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__optional_destruct_base<std::tuple<std::unordered_map<NSString * {__strong},__CVBuffer *>,std::unordered_map<NSString * {__strong},espresso_buffer_t>>,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80))
  {
    std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table(a1 + 40);
    std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table(a1);
  }
  return a1;
}

void sub_1A3EEDBD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEE3C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__emplace_unique_key_args<NSString * {__strong},std::pair<NSString * {__strong},espresso_buffer_t>>(uint64_t a1, id *a2, uint64_t *a3)
{
  unint64_t v7 = [*a2 hash];
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    float v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      uint64_t v12 = (char *)*v11;
      if (*v11)
      {
        do
        {
          unint64_t v13 = *((void *)v12 + 1);
          if (v13 == v7)
          {
            if (*((id *)v12 + 2) == *a2) {
              return v12;
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9) {
                v13 %= v9;
              }
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v3) {
              break;
            }
          }
          uint64_t v12 = *(char **)v12;
        }
        while (v12);
      }
    }
  }
  uint64_t v12 = (char *)operator new(0xC0uLL);
  *(void *)uint64_t v12 = 0;
  *((void *)v12 + 1) = v8;
  uint64_t v14 = *a3;
  *a3 = 0;
  *((void *)v12 + 2) = v14;
  *(_OWORD *)(v12 + 136) = *(_OWORD *)(a3 + 15);
  *(_OWORD *)(v12 + 152) = *(_OWORD *)(a3 + 17);
  *(_OWORD *)(v12 + 168) = *(_OWORD *)(a3 + 19);
  *((void *)v12 + 23) = a3[21];
  *(_OWORD *)(v12 + 72) = *(_OWORD *)(a3 + 7);
  *(_OWORD *)(v12 + 88) = *(_OWORD *)(a3 + 9);
  *(_OWORD *)(v12 + 104) = *(_OWORD *)(a3 + 11);
  *(_OWORD *)(v12 + 120) = *(_OWORD *)(a3 + 13);
  *(_OWORD *)(v12 + 24) = *(_OWORD *)(a3 + 1);
  *(_OWORD *)(v12 + 40) = *(_OWORD *)(a3 + 3);
  *(_OWORD *)(v12 + 56) = *(_OWORD *)(a3 + 5);
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v20);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v21 = *(void *)a1;
  unint64_t v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)uint64_t v12 = *v22;
LABEL_38:
    void *v22 = v12;
    goto LABEL_39;
  }
  *(void *)uint64_t v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v21 + 8 * v3) = a1 + 16;
  if (*(void *)v12)
  {
    unint64_t v23 = *(void *)(*(void *)v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9) {
        v23 %= v9;
      }
    }
    else
    {
      v23 &= v9 - 1;
    }
    unint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v12;
}

void sub_1A3EEE718(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<objc_class * {__strong},objc_selector *>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void ma::HSVHistogram::~HSVHistogram(ma::HSVHistogram *this)
{
  uint64_t v2 = *(void *)this;
  if (v2) {
    MEMORY[0x1A62562A0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    MEMORY[0x1A62562A0](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4) {
    MEMORY[0x1A62562A0](v4, 0x1000C8052888210);
  }
}

void sub_1A3EEE998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEEA28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEEB34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEEBCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEED4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEEE38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEEEBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEF8A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEFB74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EEFF3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF04B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF08F4(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    free(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exc_buf);
}

void sub_1A3EF0B38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::FaceFrontalizer>::__on_zero_shared(uint64_t a1)
{
  free(*(void **)(a1 + 120));
  free(*(void **)(a1 + 32));
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  free(*(void **)(a1 + 64));
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  uint64_t v2 = *(void **)(a1 + 24);
}

void std::__shared_ptr_emplace<vision::mod::FaceFrontalizer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753540;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::FaceFrontalizer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753540;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t tplTrackerResampler_lumaDownscale2(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  if (a6 >= 2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 2 * a2;
    uint64_t v9 = result + a3 + a2 * a4;
    uint64_t v10 = v9 + a2;
    if (a5 >> 1 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = a5 >> 1;
    }
    do
    {
      if (a5 >= 2)
      {
        uint64_t v12 = 0;
        uint64_t v13 = 0;
        do
        {
          uint64_t result = *(unsigned __int8 *)(v10 + v12) + *(unsigned __int8 *)(v10 + v12 + 1);
          *(unsigned char *)(a7 + v13++) = (*(unsigned __int8 *)(v9 + v12)
                                  + *(unsigned __int8 *)(v9 + v12 + 1)
                                  + result
                                  + 2) >> 2;
          v12 += 2;
        }
        while (v11 != v13);
      }
      v9 += v8;
      v10 += v8;
      a7 += a5 >> 1;
      ++v7;
    }
    while (v7 != a6 >> 1);
  }
  return result;
}

uint64_t tplTrackerResampler_chromaDownscale2(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a6 >= 2)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 2 * a2;
    unint64_t v10 = a5 >> 1;
    uint64_t v11 = result + a2 * a4 + 2 * a3;
    uint64_t v12 = v11 + a2;
    if (a5 >> 1 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = a5 >> 1;
    }
    do
    {
      if (a5 >= 2)
      {
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        do
        {
          *(unsigned char *)(a7 + v15) = (*(unsigned __int8 *)(v11 + v14)
                                + *(unsigned __int8 *)(v11 + v14 + 2)
                                + *(unsigned __int8 *)(v12 + v14)
                                + *(unsigned __int8 *)(v12 + v14 + 2)
                                + 2) >> 2;
          uint64_t result = *(unsigned __int8 *)(v12 + v14 + 1) + *(unsigned __int8 *)(v12 + v14 + 3);
          *(unsigned char *)(a8 + v15++) = (*(unsigned __int8 *)(v11 + v14 + 1)
                                  + *(unsigned __int8 *)(v11 + v14 + 3)
                                  + result
                                  + 2) >> 2;
          v14 += 4;
        }
        while (v13 != v15);
      }
      v11 += v9;
      v12 += v9;
      a7 += v10;
      a8 += v10;
      ++v8;
    }
    while (v8 != a6 >> 1);
  }
  return result;
}

uint64_t ImageProcessing_reallocVImageBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return 4221;
  }
  unint64_t v7 = (a4 * a2 + 15) & 0xFFFFFFFFFFFFFFF0;
  uint64_t v8 = malloc_type_realloc(*(void **)a1, v7 * a3, 0xA423628BuLL);
  *(void *)a1 = v8;
  if (!v8) {
    return 4221;
  }
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = v7;
  uint64_t result = 4224;
  *(void *)(a1 + 8) = a3;
  return result;
}

uint64_t ImageProcessing_copyVImageBufferData(char **a1, uint64_t a2, char **a3)
{
  if (!a1) {
    return 4220;
  }
  uint64_t v4 = *a1;
  if (!*a1) {
    return 4220;
  }
  uint64_t v5 = a1[2];
  if (!v5) {
    return 4220;
  }
  unint64_t v6 = (unint64_t)a1[1];
  if (!v6) {
    return 4220;
  }
  unint64_t v7 = (unint64_t)a1[3];
  uint64_t result = 4220;
  if (v7 < 2 || !a3) {
    return result;
  }
  unint64_t v10 = *a3;
  if (!*a3) {
    return 4220;
  }
  uint64_t v11 = a3[2];
  if (!v11) {
    return 4220;
  }
  uint64_t v12 = a3[1];
  if (!v12) {
    return 4220;
  }
  unint64_t v13 = (unint64_t)a3[3];
  if (v13 < 2) {
    return 4220;
  }
  uint64_t result = 4220;
  if (v5 == v11 && (char *)v6 == v12)
  {
    size_t v15 = (void)v5 * a2;
    if ((uint64_t)v5 * a2 <= v13)
    {
      if (v6 < 2) {
        goto LABEL_18;
      }
      unint64_t v16 = 0;
      do
      {
        memcpy(v10, v4, v15);
        uint64_t v4 = &a1[3][(void)v4];
        unint64_t v10 = &a3[3][(void)v10];
        ++v16;
        BOOL v17 = a3[1];
      }
      while (v16 < (unint64_t)(v17 - 1));
      if (v17) {
LABEL_18:
      }
        memcpy(v10, v4, (void)a3[2] * a2);
      return 4224;
    }
  }
  return result;
}

unint64_t ImageProcessing_getPointerToPoint(void *a1, uint64_t a2, float a3, float a4)
{
  uint64_t v4 = 0;
  if (a3 >= 0.0 && a4 >= 0.0)
  {
    if ((float)((float)(unint64_t)a1[2] + -1.0) >= a3 && (float)((float)(unint64_t)a1[1] + -1.0) >= a4) {
      return *a1 + a1[3] * vcvtas_u32_f32(a4) + vcvtas_u32_f32(a3) * a2;
    }
    else {
      return 0;
    }
  }
  return v4;
}

float Geometry2D_intersectRect2D(float *a1, float *a2)
{
  if (!a1) {
    return NAN;
  }
  float v2 = *a1;
  if (!a2) {
    return NAN;
  }
  float v3 = a1[1];
  float v4 = *a2;
  float v5 = a2[1];
  if (v2 <= *a2) {
    float result = *a2;
  }
  else {
    float result = *a1;
  }
  if (v3 <= v5) {
    float v7 = a2[1];
  }
  else {
    float v7 = a1[1];
  }
  float v8 = v3 + a1[2];
  if ((float)(v2 + a1[3]) >= (float)(v4 + a2[3])) {
    float v9 = v4 + a2[3];
  }
  else {
    float v9 = v2 + a1[3];
  }
  if (v8 >= (float)(v5 + a2[2])) {
    float v8 = v5 + a2[2];
  }
  if (v9 < result || v8 < v7) {
    return NAN;
  }
  return result;
}

void sub_1A3EF1958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF1A40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF1B2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *std::ifstream::basic_ifstream(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA460] + 64;
  a1[53] = MEMORY[0x1E4FBA460] + 64;
  float v3 = a1 + 2;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA3F8] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA3F8] + 8);
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = v4;
  a1[1] = 0;
  unint64_t v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 2);
  uint64_t v7 = MEMORY[0x1E4FBA460] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  a1[53] = v2;
  MEMORY[0x1A6256000](v3);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_1A3EF1D58(_Unwind_Exception *a1)
{
  std::istream::~istream();
  MEMORY[0x1A6256200](v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,Espresso::layer_shape>,std::__map_value_compare<std::string,std::__value_type<std::string,Espresso::layer_shape>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,Espresso::layer_shape>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,Espresso::layer_shape>,std::__map_value_compare<std::string,std::__value_type<std::string,Espresso::layer_shape>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,Espresso::layer_shape>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<std::string,Espresso::layer_shape>,std::__map_value_compare<std::string,std::__value_type<std::string,Espresso::layer_shape>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,Espresso::layer_shape>>>::destroy(*((void *)a1 + 1));
    uint64_t v2 = (void *)*((void *)a1 + 12);
    if (v2)
    {
      *((void *)a1 + 13) = v2;
      operator delete(v2);
    }
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void *std::ifstream::~ifstream(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA3F8];
  uint64_t v3 = *MEMORY[0x1E4FBA3F8];
  *a1 = *MEMORY[0x1E4FBA3F8];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x1A6256010](a1 + 2);
  std::istream::~istream();
  MEMORY[0x1A6256200](a1 + 53);
  return a1;
}

void sub_1A3EF202C(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3EF1FD4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3EF223C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF22D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2328(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF23E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2490(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF25F4(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A3EF26F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2784(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF29B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2AB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2B1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2D1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2E10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF2EB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF304C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF31A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF32F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF37D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF3E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF43CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::FaceSegmenterDNN>::__on_zero_shared(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 400))
  {
    espresso_plan_destroy();
    espresso_context_destroy();
  }
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = *(void *)(a1 + 296);
    if (v5)
    {
      uint64_t v6 = v5 + 32 * v2;
      free(*(void **)v6);
      *(_OWORD *)uint64_t v6 = 0u;
      *(_OWORD *)(v6 + 16) = 0u;
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  free(*(void **)(a1 + 368));
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  free(*(void **)(a1 + 320));
  uint64_t v7 = *(void **)(a1 + 296);
  if (v7)
  {
    *(void *)(a1 + 304) = v7;
    operator delete(v7);
  }
  float v8 = *(void **)(a1 + 248);
  if (v8)
  {
    *(void *)(a1 + 256) = v8;
    operator delete(v8);
  }
  float v9 = *(void **)(a1 + 224);
  if (v9)
  {
    *(void *)(a1 + 232) = v9;
    operator delete(v9);
  }
}

void std::__shared_ptr_emplace<vision::mod::FaceSegmenterDNN>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7535B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::FaceSegmenterDNN>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7535B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A3EF4A54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF4CC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF4D64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF4DE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF4E90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF4F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF56EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getVCPVideoProcessorClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!VideoProcessingLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x1E4F143A8];
    void v4[2] = 3221225472;
    v4[3] = __VideoProcessingLibraryCore_block_invoke;
    void v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E5B1D158;
    uint64_t v6 = 0;
    VideoProcessingLibraryCore_frameworkLibrarint y = _sl_dlopen();
    uint64_t v2 = (void *)v4[0];
    if (!VideoProcessingLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("VCPVideoProcessor");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    uint64_t v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getVCPVideoProcessorClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __VideoProcessingLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  VideoProcessingLibraryCore_frameworkLibrarint y = result;
  return result;
}

void sub_1A3EF5A20(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1A3EF59C8);
  }
  _Unwind_Resume(exc_buf);
}

void sub_1A3EF6358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getVCPPersonObservationClass_block_invoke(uint64_t a1)
{
  VideoProcessingLibrary();
  Class result = objc_getClass("VCPPersonObservation");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getVCPPersonObservationClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return (Class)__getVCPHandObservationClass_block_invoke(v3);
  }
  return result;
}

Class __getVCPHandObservationClass_block_invoke(uint64_t a1)
{
  VideoProcessingLibrary();
  Class result = objc_getClass("VCPHandObservation");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getVCPHandObservationClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return (Class)__getVCPPetsObservationClass_block_invoke(v3);
  }
  return result;
}

void __getVCPPetsObservationClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("VCPPetsObservation");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getVCPPetsObservationClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    VideoProcessingLibrary();
  }
}

void VideoProcessingLibrary()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v1[0] = 0;
  if (!VideoProcessingLibraryCore_frameworkLibrary_11490)
  {
    v1[1] = MEMORY[0x1E4F143A8];
    v1[2] = 3221225472;
    v1[3] = __VideoProcessingLibraryCore_block_invoke_11491;
    v1[4] = &__block_descriptor_40_e5_v8__0l;
    v1[5] = v1;
    long long v2 = xmmword_1E5B1D170;
    uint64_t v3 = 0;
    VideoProcessingLibraryCore_frameworkLibrary_11490 = _sl_dlopen();
    uint64_t v0 = (void *)v1[0];
    if (VideoProcessingLibraryCore_frameworkLibrary_11490)
    {
      if (!v1[0]) {
        return;
      }
    }
    else
    {
      uint64_t v0 = (void *)abort_report_np();
    }
    free(v0);
  }
}

uint64_t __VideoProcessingLibraryCore_block_invoke_11491()
{
  uint64_t result = _sl_dlopen();
  VideoProcessingLibraryCore_frameworkLibrary_11490 = result;
  return result;
}

uint64_t ImageProcessing_getCVPixelFormatType(int a1)
{
  int v1 = a1 - 1;
  uint64_t result = 32;
  switch(v1)
  {
    case 0:
      uint64_t result = 1278226488;
      break;
    case 1:
      uint64_t result = 1380401729;
      break;
    case 2:
    case 4:
    case 5:
    case 6:
      uint64_t result = 0;
      break;
    case 3:
      uint64_t result = 1111970369;
      break;
    case 7:
      return result;
    default:
      uint64_t result = 1278226534;
      break;
  }
  return result;
}

uint64_t ImageProcessing_getCVPixelBufferImageType(__CVBuffer *a1)
{
  signed int PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if (PixelFormatType <= 1094862673)
  {
    if (PixelFormatType == 8) {
      return 1;
    }
    if (PixelFormatType == 32) {
      return 8;
    }
  }
  else
  {
    switch(PixelFormatType)
    {
      case 1380401729:
        return 2;
      case 1111970369:
        return 4;
      case 1094862674:
        return 16;
    }
  }
  return 0;
}

CVPixelBufferRef ImageProcessing_createDeepCopyCVPixelBufferFromVImageBuffer(char **a1, __int16 a2, int *a3)
{
  *a3 = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  if (a2)
  {
    uint64_t v5 = 1;
  }
  else if ((a2 & 0x3E) != 0)
  {
    uint64_t v5 = 4;
  }
  else
  {
    if ((a2 & 0x3C0) == 0)
    {
      syslog(5, "ERROR: Invalid image type");
      syslog(5, "ERROR: require_action");
      int v15 = -16750;
      goto LABEL_13;
    }
    uint64_t v5 = 16;
  }
  CVsigned int PixelFormatType = ImageProcessing_getCVPixelFormatType(a2);
  if (!CVPixelFormatType)
  {
    int v15 = -12743;
LABEL_13:
    *a3 = v15;
    return pixelBufferOut;
  }
  OSType v7 = CVPixelFormatType;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  float v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  unint64_t v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryRef v12 = CFDictionaryCreate(v8, 0, 0, 0, v9, v10);
  if (v12)
  {
    CFDictionaryRef v13 = v12;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F24D20], v12);
    CFRelease(v13);
  }
  if (CVPixelBufferCreate(v8, (size_t)a1[2], (size_t)a1[1], v7, Mutable, &pixelBufferOut))
  {
    int v14 = -12730;
    goto LABEL_10;
  }
  if (!CVPixelBufferLockBaseAddress(pixelBufferOut, 0))
  {
    BOOL v17 = *a1;
    unint64_t v18 = a1[1];
    unint64_t v19 = a1[2];
    size_t v20 = (size_t)a1[3];
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(pixelBufferOut);
    size_t Width = CVPixelBufferGetWidth(pixelBufferOut);
    size_t Height = CVPixelBufferGetHeight(pixelBufferOut);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBufferOut);
    unint64_t v25 = v19;
    if ((char *)Width == v19 && BaseAddress && v17 && (char *)Height == v18)
    {
      size_t v26 = BytesPerRow;
      if (v20 == BytesPerRow)
      {
        memcpy(BaseAddress, v17, v20 * (void)v18);
        goto LABEL_30;
      }
      if (v20 <= BytesPerRow)
      {
        if (v18)
        {
          size_t v27 = v5 * (void)v25;
          do
          {
            memcpy(BaseAddress, v17, v27);
            v17 += v20;
            BaseAddress += v26;
            --v18;
          }
          while (v18);
        }
LABEL_30:
        CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
        if (!Mutable) {
          return pixelBufferOut;
        }
        goto LABEL_11;
      }
    }
    syslog(5, "ERROR: require_action");
    int v14 = -16750;
LABEL_10:
    *a3 = v14;
    if (!Mutable) {
      return pixelBufferOut;
    }
LABEL_11:
    CFRelease(Mutable);
    return pixelBufferOut;
  }
  *a3 = -16750;
  CVPixelBufferRelease(pixelBufferOut);
  return 0;
}

void sub_1A3EF6B58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF6C6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF6F04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF7274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a23, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__11562(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__11563(uint64_t a1)
{
}

void sub_1A3EF7618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void *___ZL43getVCPRequestFrameWidthPropertyKeySymbolLocv_block_invoke(uint64_t a1)
{
  long long v2 = (void *)VideoProcessingLibrary();
  uint64_t result = dlsym(v2, "VCPRequestFrameWidthPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t VideoProcessingLibrary(void)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!VideoProcessingLibraryCore(char **)::frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = ___ZL26VideoProcessingLibraryCorePPc_block_invoke_11572;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    v3[5] = v3;
    long long v4 = xmmword_1E5B1D1C0;
    uint64_t v5 = 0;
    VideoProcessingLibraryCore(char **)::frameworkLibrarint y = _sl_dlopen();
    int v1 = (void *)v3[0];
    uint64_t v0 = VideoProcessingLibraryCore(char **)::frameworkLibrary;
    if (VideoProcessingLibraryCore(char **)::frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      int v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return VideoProcessingLibraryCore(char **)::frameworkLibrary;
}

void *___ZL44getVCPRequestFrameHeightPropertyKeySymbolLocv_block_invoke(uint64_t a1)
{
  long long v2 = (void *)VideoProcessingLibrary();
  uint64_t result = dlsym(v2, "VCPRequestFrameHeightPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL26VideoProcessingLibraryCorePPc_block_invoke_11572()
{
  uint64_t result = _sl_dlopen();
  VideoProcessingLibraryCore(char **)::frameworkLibrarint y = result;
  return result;
}

void sub_1A3EF7A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void *___ZL41getVCPRequestForceCPUPropertyKeySymbolLocv_block_invoke(uint64_t a1)
{
  long long v2 = (void *)VideoProcessingLibrary();
  uint64_t result = dlsym(v2, "VCPRequestForceCPUPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1A3EF8598(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF8654(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF88C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF8AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF8B64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF8CD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF9310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3EF978C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3EF9A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3EF9D1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3EF9E5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EF9FE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFA07C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFA134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFA1F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFA2D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFA480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFA66C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFAA80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, void *__p)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFAC74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFAFA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFB1D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFB6C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFB880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFB9FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFBE84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, void *__p)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFBFC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFC15C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFC304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFC7D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, void *__p)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFC918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFCAAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFCC54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFD124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, void *__p)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFD268(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFD424(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFD870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFDAB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFE72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFE968(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFE9EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFEA94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFECCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFEF00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, void *__p)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFF044(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFF210(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFF3E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFF660(_Unwind_Exception *a1)
{
  long long v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3EFF810(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A3EFFA54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFFC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFFE64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3EFFFA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F00158(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F00274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F00314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F00438(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F00560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F007A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F00904(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F00E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,void *a32,void *a33,void *a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,id a48)
{
  _Block_object_dispose(&a43, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12074(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__12075(uint64_t a1)
{
}

void sub_1A3F01238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper((__CVBuffer **)va);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void apple::vision::ScopeExit::~ScopeExit(apple::vision::ScopeExit *this)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](this);
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x1A62562C0);
}

void *_ZNKSt3__110__function6__funcIZZZ152__VNFaceDetectorPrivateRevisionLegacyFaceCore_internalProcessUsingQualityOfServiceClass_options_regionOfInterest_warningRecorder_error_progressHandler__EUb_ENK3__0clEP7CGImageEUlvE_NS_9allocatorIS5_EEFvvEE11target_typeEv()
{
  return &_ZTIZZZ152__VNFaceDetectorPrivateRevisionLegacyFaceCore_internalProcessUsingQualityOfServiceClass_options_regionOfInterest_warningRecorder_error_progressHandler__EUb_ENK3__0clEP7CGImageEUlvE_;
}

uint64_t _ZNKSt3__110__function6__funcIZZZ152__VNFaceDetectorPrivateRevisionLegacyFaceCore_internalProcessUsingQualityOfServiceClass_options_regionOfInterest_warningRecorder_error_progressHandler__EUb_ENK3__0clEP7CGImageEUlvE_NS_9allocatorIS5_EEFvvEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"ZZZ152-[VNFaceDetectorPrivateRevisionLegacyFaceCore internalProcessUsingQualityOfServiceClass:options:regionOfInterest:warningRecorder:error:progressHandler:]EUb_ENK3$_0clEP7CGImageEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void _ZNSt3__110__function6__funcIZZZ152__VNFaceDetectorPrivateRevisionLegacyFaceCore_internalProcessUsingQualityOfServiceClass_options_regionOfInterest_warningRecorder_error_progressHandler__EUb_ENK3__0clEP7CGImageEUlvE_NS_9allocatorIS5_EEFvvEEclEv(uint64_t a1)
{
}

uint64_t _ZNKSt3__110__function6__funcIZZZ152__VNFaceDetectorPrivateRevisionLegacyFaceCore_internalProcessUsingQualityOfServiceClass_options_regionOfInterest_warningRecorder_error_progressHandler__EUb_ENK3__0clEP7CGImageEUlvE_NS_9allocatorIS5_EEFvvEE7__cloneEPNS0_6__baseIS8_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF753300;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZZZ152__VNFaceDetectorPrivateRevisionLegacyFaceCore_internalProcessUsingQualityOfServiceClass_options_regionOfInterest_warningRecorder_error_progressHandler__EUb_ENK3__0clEP7CGImageEUlvE_NS_9allocatorIS5_EEFvvEE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF753300;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZZZ152__VNFaceDetectorPrivateRevisionLegacyFaceCore_internalProcessUsingQualityOfServiceClass_options_regionOfInterest_warningRecorder_error_progressHandler__EUb_ENK3__0clEP7CGImageEUlvE_NS_9allocatorIS5_EEFvvEED0Ev()
{
}

void std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:ne180100]<std::pair<std::string,std::string>,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

char *vision::mod::ImageClassfier_Graph::addParentChildRelation(uint64_t *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  vision::mod::ImageClassfier_Graph::addNodeIfNotExists(a1, a2);
  vision::mod::ImageClassfier_Graph::addNodeIfNotExists(a1, a3);
  unsigned int v43 = a2;
  uint64_t v6 = (void *)*((void *)std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, a2, (long long **)&v43)+ 5);
  unsigned int v43 = a3;
  OSType v7 = std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, a3, (long long **)&v43);
  CFAllocatorRef v8 = v7;
  unint64_t v10 = (void *)v6[5];
  unint64_t v9 = v6[6];
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = v6[4];
    uint64_t v13 = ((uint64_t)v10 - v12) >> 3;
    if ((unint64_t)(v13 + 1) >> 61) {
      goto LABEL_34;
    }
    uint64_t v14 = v9 - v12;
    uint64_t v15 = v14 >> 2;
    if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
      uint64_t v15 = v13 + 1;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16) {
      unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v16);
    }
    else {
      uint64_t v17 = 0;
    }
    unint64_t v18 = (void *)(v16 + 8 * v13);
    unint64_t v19 = v16 + 8 * v17;
    void *v18 = *((void *)v8 + 5);
    uint64_t v11 = v18 + 1;
    uint64_t v21 = (char *)v6[4];
    size_t v20 = (char *)v6[5];
    if (v20 != v21)
    {
      do
      {
        uint64_t v22 = *((void *)v20 - 1);
        v20 -= 8;
        *--unint64_t v18 = v22;
      }
      while (v20 != v21);
      size_t v20 = (char *)v6[4];
    }
    v6[4] = v18;
    v6[5] = v11;
    v6[6] = v19;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    void *v10 = *((void *)v7 + 5);
    uint64_t v11 = v10 + 1;
  }
  v6[5] = v11;
  unsigned int v43 = a3;
  unint64_t v23 = (void *)*((void *)std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, a3, (long long **)&v43)+ 5);
  unsigned int v43 = a2;
  float v24 = std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, a2, (long long **)&v43);
  unint64_t v25 = v24;
  size_t v27 = (void *)v23[8];
  unint64_t v26 = v23[9];
  if ((unint64_t)v27 < v26)
  {
    *size_t v27 = *((void *)v24 + 5);
    float v28 = v27 + 1;
    goto LABEL_33;
  }
  uint64_t v29 = v23[7];
  uint64_t v30 = ((uint64_t)v27 - v29) >> 3;
  if ((unint64_t)(v30 + 1) >> 61) {
LABEL_34:
  }
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  uint64_t v31 = v26 - v29;
  uint64_t v32 = v31 >> 2;
  if (v31 >> 2 <= (unint64_t)(v30 + 1)) {
    uint64_t v32 = v30 + 1;
  }
  if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v33 = v32;
  }
  if (v33) {
    unint64_t v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v33);
  }
  else {
    uint64_t v34 = 0;
  }
  long long v35 = (void *)(v33 + 8 * v30);
  unint64_t v36 = v33 + 8 * v34;
  *long long v35 = *((void *)v25 + 5);
  float v28 = v35 + 1;
  int v38 = (char *)v23[7];
  uint64_t v37 = (char *)v23[8];
  if (v37 != v38)
  {
    do
    {
      uint64_t v39 = *((void *)v37 - 1);
      v37 -= 8;
      *--long long v35 = v39;
    }
    while (v37 != v38);
    uint64_t v37 = (char *)v23[7];
  }
  v23[7] = v35;
  v23[8] = v28;
  v23[9] = v36;
  if (v37) {
    operator delete(v37);
  }
LABEL_33:
  v23[8] = v28;
  unsigned int v43 = a3;
  uint64_t v40 = std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, a3, (long long **)&v43);
  uint64_t v41 = (*(void *)(*((void *)v40 + 5) + 64) - *(void *)(*((void *)v40 + 5) + 56)) >> 3;
  unsigned int v43 = a3;
  uint64_t result = std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, a3, (long long **)&v43);
  *(_DWORD *)(*((void *)result + 5) + 24) = v41;
  return result;
}

unsigned __int8 *vision::mod::ImageClassfier_Graph::addNodeIfNotExists(void *a1, unsigned __int8 *a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::find<std::string>(a1, a2);
  if (!result) {
    operator new();
  }
  return result;
}

void sub_1A3F01870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  MEMORY[0x1A62562C0](v14, 0x1092C40FB66ED40);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t *a1, unsigned __int8 *a2, long long **a3)
{
  unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = a1[1];
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    uint64_t v12 = *(void ***)(*a1 + 8 * v3);
    if (v12)
    {
      uint64_t v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = *((void *)v13 + 1);
          if (v14 == v8)
          {
            if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v13 + 16, a2)) {
              return v13;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3) {
              break;
            }
          }
          uint64_t v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  uint64_t v13 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v13 = 0;
  *((void *)v13 + 1) = v8;
  uint64_t v15 = (std::string *)(v13 + 16);
  unint64_t v16 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v15, *(const std::string::value_type **)v16, *((void *)v16 + 1));
  }
  else
  {
    long long v17 = *v16;
    *((void *)v13 + 4) = *((void *)v16 + 2);
    *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v17;
  }
  unint64_t v18 = a1 + 2;
  *((void *)v13 + 5) = 0;
  float v19 = (float)(unint64_t)(a1[3] + 1);
  float v20 = *((float *)a1 + 8);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    BOOL v21 = 1;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      int8x8_t prime = (int8x8_t)v23;
    }
    else {
      int8x8_t prime = (int8x8_t)v22;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v9 = a1[1];
    if (*(void *)&prime > v9) {
      goto LABEL_33;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v31 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v9 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (*(void *)&prime <= v31) {
        int8x8_t prime = (int8x8_t)v31;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          unint64_t v25 = operator new(8 * *(void *)&prime);
          unint64_t v26 = (void *)*a1;
          *a1 = (uint64_t)v25;
          if (v26) {
            operator delete(v26);
          }
          uint64_t v27 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v27++) = 0;
          while (*(void *)&prime != v27);
          float v28 = (void *)*v18;
          if (*v18)
          {
            unint64_t v29 = v28[1];
            uint8x8_t v30 = (uint8x8_t)vcnt_s8(prime);
            v30.i16[0] = vaddlv_u8(v30);
            if (v30.u32[0] > 1uLL)
            {
              if (v29 >= *(void *)&prime) {
                v29 %= *(void *)&prime;
              }
            }
            else
            {
              v29 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v29) = v18;
            uint64_t v34 = (void *)*v28;
            if (*v28)
            {
              do
              {
                unint64_t v35 = v34[1];
                if (v30.u32[0] > 1uLL)
                {
                  if (v35 >= *(void *)&prime) {
                    v35 %= *(void *)&prime;
                  }
                }
                else
                {
                  v35 &= *(void *)&prime - 1;
                }
                if (v35 != v29)
                {
                  if (!*(void *)(*a1 + 8 * v35))
                  {
                    *(void *)(*a1 + 8 * v35) = v28;
                    goto LABEL_58;
                  }
                  *float v28 = *v34;
                  *uint64_t v34 = **(void **)(*a1 + 8 * v35);
                  **(void **)(*a1 + 8 * v35) = v34;
                  uint64_t v34 = v28;
                }
                unint64_t v35 = v29;
LABEL_58:
                float v28 = v34;
                uint64_t v34 = (void *)*v34;
                unint64_t v29 = v35;
              }
              while (v34);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_62;
        }
        uint64_t v40 = (void *)*a1;
        *a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v9 = 0;
        a1[1] = 0;
      }
    }
LABEL_62:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v36 = *a1;
  uint64_t v37 = *(void **)(*a1 + 8 * v3);
  if (v37)
  {
    *(void *)uint64_t v13 = *v37;
LABEL_75:
    *uint64_t v37 = v13;
    goto LABEL_76;
  }
  *(void *)uint64_t v13 = *v18;
  void *v18 = v13;
  *(void *)(v36 + 8 * v3) = v18;
  if (*(void *)v13)
  {
    unint64_t v38 = *(void *)(*(void *)v13 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v38 >= v9) {
        v38 %= v9;
      }
    }
    else
    {
      v38 &= v9 - 1;
    }
    uint64_t v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_75;
  }
LABEL_76:
  ++a1[3];
  return v13;
}

void sub_1A3F01D0C(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,float>,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::find<std::string>(void *a1, unsigned __int8 *a2)
{
  unint64_t v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  uint8x8_t v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (unint64_t i = *v10; i; unint64_t i = *(unsigned __int8 **)i)
  {
    unint64_t v12 = *((void *)i + 1);
    if (v12 == v6)
    {
      if (std::equal_to<std::string>::operator()[abi:ne180100](i + 16, a2)) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t *std::vector<std::pair<std::string,BOOL>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 32;
      long long v6 = *(_OWORD *)(v3 - 32);
      *(void *)(v4 - 16) = *(void *)(v3 - 16);
      *(_OWORD *)(v4 - 32) = v6;
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 32) = 0;
      *(unsigned char *)(v4 - 8) = *(unsigned char *)(v3 - 8);
      v4 -= 32;
      v3 -= 32;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v7 = *result;
  *uint64_t result = v5;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void std::vector<std::pair<std::string,BOOL>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 9) < 0) {
          operator delete(*(v4 - 4));
        }
        v4 -= 4;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *std::vector<std::pair<std::string,vision::mod::ImageClassfier_GraphNodeType>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 32;
      long long v6 = *(_OWORD *)(v3 - 32);
      *(void *)(v4 - 16) = *(void *)(v3 - 16);
      *(_OWORD *)(v4 - 32) = v6;
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 32) = 0;
      *(_DWORD *)(v4 - 8) = *(_DWORD *)(v3 - 8);
      v4 -= 32;
      v3 -= 32;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v7 = *result;
  *uint64_t result = v5;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void std::deque<vision::mod::ImageClassfier_GraphNode *>::push_back(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  uint64_t v5 = (char *)a1[1];
  uint64_t v6 = v4 - v5;
  if (v4 == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v4 - v5) << 6) - 1;
  }
  unint64_t v9 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v10 = v8 + v9;
  if (v7 == v8 + v9)
  {
    if (v9 >= 0x200)
    {
      a1[4] = v9 - 512;
      uint64_t v13 = *(void *)v5;
      unint64_t v11 = v5 + 8;
      uint64_t v12 = v13;
      a1[1] = v11;
      if ((char *)a1[3] == v4)
      {
        uint64_t v14 = (uint64_t)&v11[-*a1];
        if ((unint64_t)v11 <= *a1)
        {
          if (v4 == (char *)*a1) {
            unint64_t v42 = 1;
          }
          else {
            unint64_t v42 = (uint64_t)&v4[-*a1] >> 2;
          }
          unsigned int v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v42);
          vDSP_Length v45 = &v43[8 * (v42 >> 2)];
          float v46 = (uint64_t *)a1[1];
          uint64_t v4 = v45;
          uint64_t v47 = a1[2] - (void)v46;
          if (v47)
          {
            uint64_t v4 = &v45[v47 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v48 = 8 * (v47 >> 3);
            float v49 = &v43[8 * (v42 >> 2)];
            do
            {
              uint64_t v50 = *v46++;
              *(void *)float v49 = v50;
              v49 += 8;
              v48 -= 8;
            }
            while (v48);
          }
          float v51 = (char *)*a1;
          *a1 = v43;
          a1[1] = v45;
          a1[2] = v4;
          a1[3] = &v43[8 * v44];
          if (v51)
          {
            operator delete(v51);
            uint64_t v4 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v15 = v14 >> 3;
          BOOL v16 = v14 >> 3 < -1;
          uint64_t v17 = (v14 >> 3) + 2;
          if (v16) {
            uint64_t v18 = v17;
          }
          else {
            uint64_t v18 = v15 + 1;
          }
          uint64_t v19 = -(v18 >> 1);
          uint64_t v20 = v18 >> 1;
          BOOL v21 = &v11[-8 * v20];
          int64_t v22 = v4 - v11;
          if (v4 == v11)
          {
            unint64_t v23 = v4;
          }
          else
          {
            memmove(&v11[-8 * v20], v11, v4 - v11);
            unint64_t v23 = (char *)a1[1];
          }
          uint64_t v4 = &v21[v22];
          a1[1] = &v23[8 * v19];
          a1[2] = &v21[v22];
        }
      }
      *(void *)uint64_t v4 = v12;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      uint64_t v5 = (char *)a1[1];
      uint64_t v8 = a1[5];
      unint64_t v10 = a1[4] + v8;
      goto LABEL_84;
    }
    uint64_t v24 = v6 >> 3;
    unint64_t v25 = (char *)a1[3];
    unint64_t v26 = (char *)*a1;
    uint64_t v27 = (uint64_t)&v25[-*a1];
    if (v6 >> 3 < (unint64_t)(v27 >> 3))
    {
      float v28 = operator new(0x1000uLL);
      unint64_t v29 = v28;
      if (v25 == v4)
      {
        if (v26 == v5)
        {
          if (v4 == v5) {
            unint64_t v52 = 1;
          }
          else {
            unint64_t v52 = v27 >> 2;
          }
          uint64_t v53 = 2 * v52;
          float v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v52);
          uint64_t v5 = &v54[(v53 + 6) & 0xFFFFFFFFFFFFFFF8];
          float v56 = (uint64_t *)a1[1];
          float v57 = v5;
          uint64_t v58 = a1[2] - (void)v56;
          if (v58)
          {
            float v57 = &v5[v58 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v59 = 8 * (v58 >> 3);
            float v60 = v5;
            do
            {
              uint64_t v61 = *v56++;
              *(void *)float v60 = v61;
              v60 += 8;
              v59 -= 8;
            }
            while (v59);
          }
          uint64_t v62 = (char *)*a1;
          *a1 = v54;
          a1[1] = v5;
          a1[2] = v57;
          a1[3] = &v54[8 * v55];
          if (v62)
          {
            operator delete(v62);
            uint64_t v5 = (char *)a1[1];
          }
        }
        *((void *)v5 - 1) = v29;
        uint64_t v63 = (char *)a1[1];
        uint64_t v64 = (char *)a1[2];
        a1[1] = v63 - 8;
        uint64_t v65 = *((void *)v63 - 1);
        a1[1] = v63;
        if (v64 == (char *)a1[3])
        {
          uint64_t v66 = (uint64_t)&v63[-*a1];
          if ((unint64_t)v63 <= *a1)
          {
            if (v64 == (char *)*a1) {
              unint64_t v97 = 1;
            }
            else {
              unint64_t v97 = (uint64_t)&v64[-*a1] >> 2;
            }
            unsigned int v98 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v97);
            unsigned int v100 = &v98[8 * (v97 >> 2)];
            uint64_t v101 = (uint64_t *)a1[1];
            uint64_t v64 = v100;
            uint64_t v102 = a1[2] - (void)v101;
            if (v102)
            {
              uint64_t v64 = &v100[v102 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v103 = 8 * (v102 >> 3);
              uint64_t v104 = &v98[8 * (v97 >> 2)];
              do
              {
                uint64_t v105 = *v101++;
                *(void *)uint64_t v104 = v105;
                v104 += 8;
                v103 -= 8;
              }
              while (v103);
            }
            uint64_t v106 = (char *)*a1;
            *a1 = v98;
            a1[1] = v100;
            a1[2] = v64;
            a1[3] = &v98[8 * v99];
            if (v106)
            {
              operator delete(v106);
              uint64_t v64 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v67 = v66 >> 3;
            BOOL v16 = v66 >> 3 < -1;
            uint64_t v68 = (v66 >> 3) + 2;
            if (v16) {
              uint64_t v69 = v68;
            }
            else {
              uint64_t v69 = v67 + 1;
            }
            uint64_t v70 = -(v69 >> 1);
            uint64_t v71 = v69 >> 1;
            float v72 = &v63[-8 * v71];
            int64_t v73 = v64 - v63;
            if (v64 != v63)
            {
              memmove(&v63[-8 * v71], v63, v64 - v63);
              uint64_t v63 = (char *)a1[1];
            }
            uint64_t v64 = &v72[v73];
            a1[1] = &v63[8 * v70];
            a1[2] = &v72[v73];
          }
        }
        *(void *)uint64_t v64 = v65;
      }
      else
      {
        *(void *)uint64_t v4 = v28;
      }
      goto LABEL_82;
    }
    if (v25 == v26) {
      unint64_t v30 = 1;
    }
    else {
      unint64_t v30 = v27 >> 2;
    }
    unint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v30);
    uint64_t v33 = v32;
    uint64_t v34 = &v31[8 * v24];
    *(void *)&long long v35 = v31;
    *((void *)&v35 + 1) = v34;
    long long v110 = v35;
    uint64_t v36 = operator new(0x1000uLL);
    *(void *)&long long v37 = v34;
    *((void *)&v37 + 1) = &v31[8 * v33];
    if (v24 == v33)
    {
      uint64_t v38 = 8 * v24;
      *(void *)&long long v39 = v110;
      if (v6 >= 1)
      {
        uint64_t v40 = v38 >> 3;
        if (v40 >= -1) {
          unint64_t v41 = v40 + 1;
        }
        else {
          unint64_t v41 = v40 + 2;
        }
        v34 -= 8 * (v41 >> 1);
        *(void *)&long long v37 = v34;
        *((void *)&v39 + 1) = v34;
        goto LABEL_56;
      }
      uint64_t v74 = v38 >> 2;
      if (v4 == v5) {
        unint64_t v75 = 1;
      }
      else {
        unint64_t v75 = v74;
      }
      float v76 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v75);
      uint64_t v34 = &v76[8 * (v75 >> 2)];
      *(void *)&long long v39 = v76;
      *((void *)&v39 + 1) = v34;
      *(void *)&long long v37 = v34;
      *((void *)&v37 + 1) = &v76[8 * v77];
      if (!v31) {
        goto LABEL_56;
      }
      long long v107 = v37;
      long long v110 = v39;
      operator delete(v31);
      long long v37 = v107;
    }
    long long v39 = v110;
LABEL_56:
    *(void *)uint64_t v34 = v36;
    *(void *)&long long v37 = v37 + 8;
    for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
    {
      float v79 = (void *)*((void *)&v39 + 1);
      if (*((void *)&v39 + 1) == (void)v39)
      {
        float v81 = (unsigned char *)v37;
        if ((unint64_t)v37 >= *((void *)&v37 + 1))
        {
          if (*((void *)&v37 + 1) == *((void *)&v39 + 1)) {
            unint64_t v86 = 1;
          }
          else {
            unint64_t v86 = (uint64_t)(*((void *)&v37 + 1) - *((void *)&v39 + 1)) >> 2;
          }
          uint64_t v87 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v86);
          float v80 = &v87[(2 * v86 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v89 = v80;
          uint64_t v90 = v81 - (unsigned char *)v79;
          if (v81 != (unsigned char *)v79)
          {
            uint64_t v89 = &v80[v90 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v91 = 8 * (v90 >> 3);
            unint64_t v92 = v80;
            uint64_t v93 = v79;
            do
            {
              uint64_t v94 = *v93++;
              *(void *)unint64_t v92 = v94;
              v92 += 8;
              v91 -= 8;
            }
            while (v91);
          }
          *(void *)&long long v39 = v87;
          *((void *)&v39 + 1) = v80;
          *(void *)&long long v37 = v89;
          *((void *)&v37 + 1) = &v87[8 * v88];
          if (v79)
          {
            long long v108 = v37;
            long long v112 = v39;
            operator delete(v79);
            long long v37 = v108;
            long long v39 = v112;
          }
        }
        else
        {
          uint64_t v82 = (uint64_t)(*((void *)&v37 + 1) - v37) >> 3;
          if (v82 >= -1) {
            uint64_t v83 = v82 + 1;
          }
          else {
            uint64_t v83 = v82 + 2;
          }
          uint64_t v84 = v83 >> 1;
          uint64_t v85 = v37 + 8 * (v83 >> 1);
          float v80 = (char *)(v85 - (v37 - *((void *)&v39 + 1)));
          if ((void)v37 == *((void *)&v39 + 1))
          {
            float v81 = (unsigned char *)*((void *)&v39 + 1);
          }
          else
          {
            uint64_t v109 = *((void *)&v37 + 1);
            uint64_t v111 = v39;
            memmove((void *)(v85 - (v37 - *((void *)&v39 + 1))), *((const void **)&v39 + 1), v37 - *((void *)&v39 + 1));
            *((void *)&v37 + 1) = v109;
            *(void *)&long long v39 = v111;
          }
          *((void *)&v39 + 1) = v80;
          *(void *)&long long v37 = &v81[8 * v84];
        }
      }
      else
      {
        float v80 = (char *)*((void *)&v39 + 1);
      }
      uint64_t v95 = *(void *)(i - 8);
      *((void *)v80 - 1) = v95;
      *((void *)&v39 + 1) -= 8;
    }
    unint64_t v96 = (char *)*a1;
    *(_OWORD *)a1 = v39;
    *((_OWORD *)a1 + 1) = v37;
    if (v96) {
      operator delete(v96);
    }
    goto LABEL_83;
  }
LABEL_84:
  *(void *)(*(void *)&v5[(v10 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v10 & 0x1FF)) = *a2;
  a1[5] = v8 + 1;
}

void sub_1A3F0257C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11)
{
  operator delete(v11);
  if ((void)a11) {
    operator delete((void *)a11);
  }
  _Unwind_Resume(a1);
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    uint64_t v12 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v8)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](i + 16, a2)) {
            return;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v15 = operator new(0x28uLL);
  *uint64_t v15 = 0;
  v15[1] = v8;
  BOOL v16 = (std::string *)(v15 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v16, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v16->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v15[4] = *(void *)(a3 + 16);
  }
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v22);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *uint64_t v15 = *v24;
LABEL_41:
    *uint64_t v24 = v15;
    goto LABEL_42;
  }
  *uint64_t v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v15;
  *(void *)(v23 + 8 * v3) = a1 + 16;
  if (*v15)
  {
    unint64_t v25 = *(void *)(*v15 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v25 >= v9) {
        v25 %= v9;
      }
    }
    else
    {
      v25 &= v9 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_41;
  }
LABEL_42:
  ++*(void *)(a1 + 24);
}

void sub_1A3F027E0(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,float>,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<vision::mod::ImageClassfier_GraphNode *,std::hash<vision::mod::ImageClassfier_GraphNode *>,std::equal_to<vision::mod::ImageClassfier_GraphNode *>,std::allocator<vision::mod::ImageClassfier_GraphNode *>>::find<vision::mod::ImageClassfier_GraphNode *>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (!a2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a3) + 8) ^ HIDWORD(a3));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a3) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= a2) {
      unint64_t v7 = v5 % a2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (a2 - 1);
  }
  unint64_t v8 = *(void **)(a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == a3) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= a2) {
            v10 %= a2;
          }
        }
        else
        {
          v10 &= a2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

unint64_t **vision::mod::ImageClassfier_GraphNode::filterVectorForValidNodes(unint64_t **result, uint64_t a2)
{
  uint64_t v2 = *result;
  unint64_t v3 = result[1];
  if (*result != v3)
  {
    unint64_t v5 = result;
    uint64_t v6 = *(void *)a2;
    do
    {
      uint64_t result = (unint64_t **)std::__hash_table<vision::mod::ImageClassfier_GraphNode *,std::hash<vision::mod::ImageClassfier_GraphNode *>,std::equal_to<vision::mod::ImageClassfier_GraphNode *>,std::allocator<vision::mod::ImageClassfier_GraphNode *>>::find<vision::mod::ImageClassfier_GraphNode *>(v6, *(void *)(a2 + 8), *v2);
      if (result)
      {
        ++v2;
      }
      else
      {
        int64_t v7 = (char *)v3 - (char *)(v2 + 1);
        if (v3 != v2 + 1) {
          uint64_t result = (unint64_t **)memmove(v2, v2 + 1, (char *)v3 - (char *)(v2 + 1));
        }
        --v3;
        v5[1] = (unint64_t *)((char *)v2 + v7);
        uint64_t v6 = *(void *)a2;
      }
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t vision::mod::ImageClassifier_HierarchicalModel::infer(uint64_t a1, uint64_t **a2, void *a3, int a4)
{
  if (a4)
  {
    for (uint64_t i = (uint64_t *)a3[2]; i; uint64_t i = (uint64_t *)*i)
    {
      if (*((char *)i + 39) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)__p, (const std::string::value_type *)i[2], i[3]);
      }
      else
      {
        *(_OWORD *)std::string __p = *((_OWORD *)i + 1);
        *(void *)&long long v31 = i[4];
      }
      unint64_t v8 = *a2;
      if (!std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::find<std::string>(*a2, (unsigned __int8 *)__p)|| !std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::find<std::string>(v8 + 5, (unsigned __int8 *)__p))
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = 3966;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
      if (SBYTE7(v31) < 0) {
        operator delete(__p[0]);
      }
    }
    for (vDSP_Length j = (unsigned __int8 *)(*a2)[7]; j; vDSP_Length j = *(unsigned __int8 **)j)
    {
      unint64_t v10 = *a2;
      __p[0] = j + 16;
      if (!*(_DWORD *)(*((void *)std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v10, j + 16, (long long **)__p)+ 5)+ 84)&& !std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a3, j + 16))
      {
        unint64_t v29 = __cxa_allocate_exception(8uLL);
        *unint64_t v29 = 3966;
        __cxa_throw(v29, MEMORY[0x1E4FBA3E0], 0);
      }
    }
  }
  for (int k = (void *)(*a2)[2]; k; int k = (void *)*k)
    *(_DWORD *)(k[5] + 24) = (*(void *)(k[5] + 64) - *(void *)(k[5] + 56)) >> 3;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  long long v31 = 0u;
  long long v32 = 0u;
  *(_OWORD *)std::string __p = 0u;
  uint64_t v12 = (uint64_t *)a3[2];
  if (v12)
  {
    do
    {
      if (*((char *)v12 + 39) < 0) {
        std::string::__init_copy_ctor_external(&v34, (const std::string::value_type *)v12[2], v12[3]);
      }
      else {
        std::string v34 = *(std::string *)(v12 + 2);
      }
      uint64_t v13 = *a2;
      if (std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::find<std::string>(*a2, (unsigned __int8 *)&v34))
      {
        if (std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::find<std::string>(v13 + 5, (unsigned __int8 *)&v34))
        {
          long long v35 = &v34;
          uint64_t v14 = *((void *)std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v13, (unsigned __int8 *)&v34, (long long **)&v35)+ 5);
          uint64_t v33 = v14;
          if (*(_DWORD *)(v14 + 84) != 2)
          {
            *(_DWORD *)(v14 + 80) = *((_DWORD *)v12 + 10);
            std::deque<vision::mod::ImageClassfier_GraphNode *>::push_back(__p, &v33);
          }
        }
      }
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v34.__r_.__value_.__l.__data_);
      }
      uint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
    for (uint64_t m = *((void *)&v32 + 1); *((void *)&v32 + 1); uint64_t m = *((void *)&v32 + 1))
    {
      std::string::size_type v16 = *(void *)(*(void *)((char *)__p[1] + (((unint64_t)v32 >> 6) & 0x3FFFFFFFFFFFFF8))
                      + 8 * (v32 & 0x1FF));
      *(void *)&long long v32 = v32 + 1;
      *((void *)&v32 + 1) = m - 1;
      if ((unint64_t)v32 >= 0x400)
      {
        operator delete(*(void **)__p[1]);
        __p[1] = (char *)__p[1] + 8;
        *(void *)&long long v32 = v32 - 512;
      }
      if (!std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::find<std::string>(*a2 + 5, (unsigned __int8 *)v16))
      {
        uint64_t v17 = *(void *)(v16 + 56);
        uint64_t v18 = *(void *)(v16 + 64);
        float v19 = 0.0;
        while (v17 != v18)
        {
          if (!*(_DWORD *)(*(void *)v17 + 84))
          {
            float v20 = powf(fminf(*(float *)(*(void *)v17 + 80), 1.0), 4.0);
            float v19 = v19 - logf(1.0 - v20);
          }
          v17 += 8;
        }
        float v21 = expf(-v19);
        float v22 = powf(1.0 - v21, 0.25);
        *(float *)(v16 + 80) = v22;
        v34.__r_.__value_.__r.__words[0] = v16;
        *((float *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, (unsigned __int8 *)v16, (long long **)&v34)+ 10) = v22;
      }
      uint64_t v24 = *(std::string::size_type **)(v16 + 32);
      uint64_t v23 = *(std::string::size_type **)(v16 + 40);
      while (v24 != v23)
      {
        std::string::size_type v25 = *v24;
        v34.__r_.__value_.__r.__words[0] = v25;
        int v26 = *(_DWORD *)(v25 + 24) - 1;
        *(_DWORD *)(v25 + 24) = v26;
        if (!v26 && *(_DWORD *)(v25 + 84) != 2) {
          std::deque<vision::mod::ImageClassfier_GraphNode *>::push_back(__p, &v34);
        }
        ++v24;
      }
    }
  }
  return std::deque<std::pair<int,int>>::~deque[abi:ne180100]((uint64_t)__p);
}

void sub_1A3F02CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  std::deque<std::pair<int,int>>::~deque[abi:ne180100]((uint64_t)&a9);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v25);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::_readBinSerializerBlob(FILE *a1, unsigned char *a2, float *a3, uint64_t a4)
{
  uint64_t v18 = a3;
  if (fseek(a1, 0, 0)) {
    return 8565;
  }
  __int16 v16 = 0;
  uint64_t v13 = 0;
  if ((char)a2[23] >= 0) {
    unint64_t v8 = a2;
  }
  else {
    unint64_t v8 = *(unsigned char **)a2;
  }
  uint64_t result = BinSerializer_fgetBlobInfo(a1, v8, &v17, &v16, &v15, &v14, &v13);
  if (result == 128)
  {
    if (v13 == a4)
    {
      if (v16 != 3) {
        return 8565;
      }
      size_t v12 = 0;
      if ((char)a2[23] >= 0) {
        unint64_t v9 = a2;
      }
      else {
        unint64_t v9 = *(unsigned char **)a2;
      }
      uint64_t v10 = BinSerializer_freadInFloat(a1, v9, 0, &v18, &v12);
      if (v12 == a4 && v10 == 128) {
        return 8576;
      }
      else {
        return 8565;
      }
    }
    else
    {
      return 8564;
    }
  }
  return result;
}

void std::default_delete<std::vector<float>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1A62562C0);
}

void ImageClassifier_readLinesFromFile(std::vector<std::string> *a1, const char *__filename)
{
  a1->__begin_ = 0;
  a1->__end_ = 0;
  a1->__end_cap_.__value_ = 0;
  long long v33 = 0uLL;
  std::string::size_type v34 = 0;
  unint64_t v3 = fopen(__filename, "r");
  unint64_t v4 = v3;
  if (!v3)
  {
    int64_t v7 = 0;
    goto LABEL_20;
  }
  fseek(v3, 0, 2);
  size_t v5 = MEMORY[0x1A6256E50](v4);
  fseek(v4, 0, 0);
  uint64_t v6 = malloc_type_malloc(v5 + 1, 0x1FB75C1uLL);
  int64_t v7 = v6;
  if (!v6)
  {
    uint64_t v21 = 3963;
LABEL_22:
    free(v7);
    exception = __cxa_allocate_exception(8uLL);
    void *exception = v21;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if (fread(v6, 1uLL, v5, v4) != v5)
  {
LABEL_20:
    uint64_t v21 = 3957;
    goto LABEL_22;
  }
  *((unsigned char *)v7 + v5) = 0;
  fclose(v4);
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)v7);
  uint64_t v8 = MEMORY[0x1E4FBA488] + 104;
  v32[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v9 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v26 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v10 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v11 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  v25[0] = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)((char *)v25 + *(void *)(v25[0] - 24)) = v11;
  v25[1] = 0;
  size_t v12 = (std::ios_base *)((char *)v25 + *(void *)(v25[0] - 24));
  std::ios_base::init(v12, v27);
  uint64_t v13 = MEMORY[0x1E4FBA488] + 24;
  v12[1].__vftable = 0;
  v12[1].__fmtflags_ = -1;
  uint64_t v14 = v10[5];
  uint64_t v26 = v10[4];
  *(void *)((char *)&v27[-1] + *(void *)(v26 - 24)) = v14;
  v25[0] = v10[1];
  *(void *)((char *)v25 + *(void *)(v25[0] - 24)) = v10[6];
  v32[0] = v8;
  v25[0] = v13;
  uint64_t v26 = v9;
  std::streambuf::basic_streambuf();
  uint64_t v15 = MEMORY[0x1E4FBA470] + 16;
  v27[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)float v28 = *(_OWORD *)__p;
  uint64_t v16 = v24;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v24 = 0;
  uint64_t v29 = v16;
  uint64_t v30 = 0;
  int v31 = 24;
  std::stringbuf::__init_buf_ptrs[abi:ne180100]((uint64_t)v27);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  while (1)
  {
    std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v25, (uint64_t)&v33, 0xAu);
    if ((*((unsigned char *)&v27[1] + *(void *)(v25[0] - 24)) & 5) != 0) {
      break;
    }
    std::vector<std::string>::pointer end = a1->__end_;
    if (end >= a1->__end_cap_.__value_)
    {
      std::vector<std::string>::pointer v19 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a1, &v33);
    }
    else
    {
      if (SHIBYTE(v34) < 0)
      {
        std::string::__init_copy_ctor_external(a1->__end_, (const std::string::value_type *)v33, *((std::string::size_type *)&v33 + 1));
      }
      else
      {
        long long v18 = v33;
        end->__r_.__value_.__r.__words[2] = v34;
        *(_OWORD *)&end->__r_.__value_.__l.__data_ = v18;
      }
      std::vector<std::string>::pointer v19 = end + 1;
      a1->__end_ = end + 1;
    }
    a1->__end_ = v19;
  }
  v25[0] = *v10;
  uint64_t v20 = v10[9];
  *(void *)((char *)v25 + *(void *)(v25[0] - 24)) = v10[8];
  uint64_t v26 = v20;
  v27[0] = v15;
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1A6256200](v32);
  free(v7);
  if (SHIBYTE(v34) < 0) {
    operator delete((void *)v33);
  }
}

void sub_1A3F036C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1A6256200](a10);
  if (a16 < 0) {
    operator delete(a11);
  }
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  _Unwind_Resume(a1);
}

uint64_t ImageClassifier_splitAndTrim(uint64_t a1, const std::string *a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v36, a2);
  std::string __p = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v3 = MEMORY[0x1E4F14390];
  while (1)
  {
    std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v36, (uint64_t)&__p, 0x2Cu);
    if ((*((unsigned char *)&v36[4] + *(void *)(v36[0] - 24)) & 5) != 0) {
      break;
    }
    uint64_t v4 = HIBYTE(v35);
    char v5 = HIBYTE(v35);
    uint64_t v6 = (char *)__p;
    uint64_t v7 = v34;
    if (v35 >= 0) {
      p_p = (char *)&__p;
    }
    else {
      p_p = (char *)__p;
    }
    if (v35 >= 0) {
      uint64_t v9 = HIBYTE(v35);
    }
    else {
      uint64_t v9 = v34;
    }
    if (v9)
    {
      uint64_t v10 = &p_p[v9];
      while (1)
      {
        unsigned int v11 = *p_p;
        if (!((v11 & 0x80000000) != 0 ? __maskrune(v11, 0x4000uLL) : *(_DWORD *)(v3 + 4 * v11 + 60) & 0x4000)) {
          break;
        }
        ++p_p;
        if (!--v9)
        {
          p_p = v10;
          break;
        }
      }
      uint64_t v4 = HIBYTE(v35);
      uint64_t v6 = (char *)__p;
      uint64_t v7 = v34;
      char v5 = HIBYTE(v35);
    }
    uint64_t v13 = &v6[v7];
    uint64_t v14 = (char *)&__p + v4;
    if (v5 >= 0) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v13;
    }
    if (v5 >= 0) {
      uint64_t v16 = (char *)&__p;
    }
    else {
      uint64_t v16 = v6;
    }
    while (v15 != v16)
    {
      unsigned int v18 = *--v15;
      unsigned int v17 = v18;
      if ((v18 & 0x80000000) != 0) {
        int v19 = __maskrune(v17, 0x4000uLL);
      }
      else {
        int v19 = *(_DWORD *)(v3 + 4 * v17 + 60) & 0x4000;
      }
      if (!v19)
      {
        uint64_t v16 = v15 + 1;
        break;
      }
    }
    if (p_p >= v16)
    {
      long long v31 = 0uLL;
      std::string::size_type v32 = 0;
    }
    else
    {
      std::string::__init_with_size[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(&v31, p_p, v16, v16 - p_p);
    }
    unint64_t v21 = *(void *)(a1 + 8);
    unint64_t v20 = *(void *)(a1 + 16);
    if (v21 >= v20)
    {
      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - *(void *)a1) >> 3);
      unint64_t v24 = v23 + 1;
      if (v23 + 1 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - *(void *)a1) >> 3);
      if (2 * v25 > v24) {
        unint64_t v24 = 2 * v25;
      }
      if (v25 >= 0x555555555555555) {
        unint64_t v26 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v26 = v24;
      }
      __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 16);
      if (v26) {
        unint64_t v26 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v26);
      }
      else {
        uint64_t v27 = 0;
      }
      float v28 = (std::string *)(v26 + 24 * v23);
      __v.__first_ = (std::__split_buffer<std::string>::pointer)v26;
      __v.__begin_ = v28;
      __v.__end_cap_.__value_ = (std::string *)(v26 + 24 * v27);
      *(_OWORD *)&v28->__r_.__value_.__l.__data_ = v31;
      v28->__r_.__value_.__r.__words[2] = v32;
      long long v31 = 0uLL;
      std::string::size_type v32 = 0;
      __v.__end_ = v28 + 1;
      std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &__v);
      unint64_t v22 = *(void *)(a1 + 8);
      std::__split_buffer<std::string>::~__split_buffer(&__v);
    }
    else
    {
      *(_OWORD *)unint64_t v21 = v31;
      *(void *)(v21 + 16) = v32;
      unint64_t v22 = v21 + 24;
    }
    *(void *)(a1 + 8) = v22;
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(__p);
  }
  v36[0] = *MEMORY[0x1E4FBA408];
  uint64_t v29 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v36 + *(void *)(v36[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v36[2] = v29;
  v36[3] = MEMORY[0x1E4FBA470] + 16;
  if (v37 < 0) {
    operator delete((void *)v36[11]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A6256200](&v38);
}

void sub_1A3F03AF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22)
{
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1, const std::string *a2)
{
  uint64_t v4 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v5 = a1 + 16;
  uint64_t v6 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  uint64_t v7 = a1 + 24;
  uint64_t v8 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v9 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v10 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v10;
  *(void *)(a1 + *(void *)(v10 - 24)) = v9;
  *(void *)(a1 + 8) = 0;
  unsigned int v11 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v11, (void *)(a1 + 24));
  uint64_t v12 = MEMORY[0x1E4FBA488] + 24;
  v11[1].__vftable = 0;
  v11[1].__fmtflags_ = -1;
  uint64_t v13 = v8[5];
  uint64_t v14 = v8[4];
  *(void *)(a1 + 16) = v14;
  *(void *)(v5 + *(void *)(v14 - 24)) = v13;
  uint64_t v15 = v8[1];
  *(void *)a1 = v15;
  *(void *)(a1 + *(void *)(v15 - 24)) = v8[6];
  *(void *)a1 = v12;
  *(void *)(a1 + 128) = v4;
  *(void *)(a1 + 16) = v6;
  std::streambuf::basic_streambuf();
  uint64_t v16 = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 24) = v16;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  std::string::operator=((std::string *)(a1 + 88), a2);
  std::stringbuf::__init_buf_ptrs[abi:ne180100](v7);
  return a1;
}

void sub_1A3F03E20(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x1A6256200](v1);
  _Unwind_Resume(a1);
}

void *std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, uint64_t a2, unsigned __int8 a3)
{
  MEMORY[0x1A6256030](&v11, a1, 1);
  if (!v11) {
    return a1;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
  }
  uint64_t v6 = 0;
  while (1)
  {
    uint64_t v7 = *(void **)((char *)a1 + *(void *)(*a1 - 24) + 40);
    uint64_t v8 = (unsigned char *)v7[3];
    if (v8 != (unsigned char *)v7[4])
    {
      void v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(void *))(*v7 + 80))(v7);
    if (v7 == -1) {
      break;
    }
LABEL_9:
    if (v7 == a3)
    {
      int v9 = 0;
      goto LABEL_17;
    }
    std::string::push_back((std::string *)a2, (std::string::value_type)v7);
    ++v6;
    if (*(char *)(a2 + 23) < 0 && *(void *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      int v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6) {
    int v9 = 2;
  }
  else {
    int v9 = 6;
  }
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_1A3F03FC8(void *a1)
{
  __cxa_begin_catch(a1);
  uint64_t v2 = *v1;
  *(_DWORD *)((char *)v1 + *(void *)(*v1 - 24) + 32) |= 1u;
  if ((*((unsigned char *)v1 + *(void *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1A3F03F88);
  }
  __cxa_rethrow();
}

void sub_1A3F04044(_Unwind_Exception *a1)
{
}

void *std::string::__init_with_size[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(void *result, char *a2, char *a3, unint64_t a4)
{
  if (a4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = result;
  if (a4 > 0x16)
  {
    uint64_t v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v8 = a4 | 7;
    }
    uint64_t v9 = v8 + 1;
    uint64_t result = operator new(v8 + 1);
    v7[1] = a4;
    void v7[2] = v9 | 0x8000000000000000;
    *uint64_t v7 = result;
    uint64_t v7 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    char v10 = *a2++;
    *(unsigned char *)uint64_t v7 = v10;
    uint64_t v7 = (void *)((char *)v7 + 1);
  }
  *(unsigned char *)uint64_t v7 = 0;
  return result;
}

void std::stringbuf::__init_buf_ptrs[abi:ne180100](uint64_t a1)
{
  *(void *)(a1 + 88) = 0;
  uint64_t v2 = (std::string *)(a1 + 64);
  char v3 = *(unsigned char *)(a1 + 87);
  if (v3 < 0)
  {
    uint64_t v4 = *(std::string **)(a1 + 64);
    unint64_t v5 = *(void *)(a1 + 72);
  }
  else
  {
    uint64_t v4 = v2;
    unint64_t v5 = *(unsigned __int8 *)(a1 + 87);
  }
  int v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
    *(void *)(a1 + 88) = (char *)v4 + v5;
    *(void *)(a1 + 16) = v4;
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = (char *)v4 + v5;
  }
  if ((v6 & 0x10) != 0)
  {
    *(void *)(a1 + 88) = (char *)v4 + v5;
    std::string::size_type v7 = v3 < 0 ? (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize(v2, v7, 0);
    uint64_t v8 = *(char *)(a1 + 87) < 0 ? *(void *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(void *)(a1 + 40) = v4;
    *(void *)(a1 + 48) = v4;
    *(void *)(a1 + 56) = (char *)v4 + v8;
    if ((*(unsigned char *)(a1 + 96) & 3) != 0)
    {
      if (v5 >> 31)
      {
        uint64_t v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        unint64_t v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        uint64_t v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
        unint64_t v5 = v5 - v10 - 0x7FFFFFFF;
        *(void *)(a1 + 48) = v4;
      }
      if (v5) {
        *(void *)(a1 + 48) = (char *)v4 + v5;
      }
    }
  }
}

void ImageClassifier_loadLabelsAndBooleanFlags(char *a1, const char *a2)
{
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  ImageClassifier_readLinesFromFile(&v41, a2);
  begin = v41.__begin_;
  std::vector<std::string>::pointer end = v41.__end_;
  if (v41.__begin_ != v41.__end_)
  {
    uint64_t v5 = 0;
    char v6 = 1;
    while (1)
    {
      ImageClassifier_splitAndTrim((uint64_t)&v39, begin);
      if ((v6 & 1) == 0) {
        goto LABEL_8;
      }
      std::string::size_type v7 = (long long *)((char *)v39 + 24);
      if ((long long *)((char *)v39 + 24) != v40) {
        break;
      }
      uint64_t v5 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      uint64_t v38 = 0;
LABEL_13:
      std::pair<std::string,std::vector<BOOL>>::pair[abi:ne180100]<std::string&,std::vector<BOOL>&,0>(&v32, v39, (uint64_t)&v36);
      unint64_t v10 = *((void *)a1 + 1);
      unint64_t v11 = *((void *)a1 + 2);
      if (v10 >= v11)
      {
        unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *(void *)a1) >> 4);
        unint64_t v14 = v13 + 1;
        if (v13 + 1 > 0x555555555555555) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *(void *)a1) >> 4);
        if (2 * v15 > v14) {
          unint64_t v14 = 2 * v15;
        }
        if (v15 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v16 = 0x555555555555555;
        }
        else {
          unint64_t v16 = v14;
        }
        vDSP_Length v45 = a1 + 16;
        unsigned int v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::vector<BOOL>>>>(v16);
        unsigned int v18 = &v17[48 * v13];
        unint64_t v42 = v17;
        v43.i64[0] = (uint64_t)v18;
        uint64_t v44 = &v17[48 * v19];
        long long v20 = *(_OWORD *)&v32.__r_.__value_.__l.__data_;
        *((void *)v18 + 2) = *((void *)&v32.__r_.__value_.__l + 2);
        *(_OWORD *)unsigned int v18 = v20;
        memset(&v32, 0, sizeof(v32));
        *((void *)v18 + 3) = __p;
        *((void *)v18 + 4) = v34;
        *((void *)v18 + 5) = v35;
        std::string __p = 0;
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        unint64_t v21 = v18 + 48;
        v43.i64[1] = (uint64_t)(v18 + 48);
        uint64_t v23 = *(void *)a1;
        unint64_t v22 = *((void *)a1 + 1);
        uint64_t v24 = v43.i64[0];
        if (v22 == *(void *)a1)
        {
          int64x2_t v29 = vdupq_n_s64(v22);
        }
        else
        {
          uint64_t v25 = 0;
          do
          {
            uint64_t v26 = v24 + v25;
            uint64_t v27 = v22 + v25;
            long long v28 = *(_OWORD *)(v22 + v25 - 48);
            *(void *)(v26 - 32) = *(void *)(v22 + v25 - 32);
            *(_OWORD *)(v26 - 48) = v28;
            *(void *)(v27 - 40) = 0;
            *(void *)(v27 - 32) = 0;
            *(void *)(v27 - 48) = 0;
            *(void *)(v26 - 24) = *(void *)(v22 + v25 - 24);
            *(void *)(v26 - 16) = *(void *)(v22 + v25 - 16);
            *(void *)(v26 - 8) = *(void *)(v22 + v25 - 8);
            *(void *)(v27 - 24) = 0;
            *(void *)(v27 - 16) = 0;
            *(void *)(v27 - 8) = 0;
            v25 -= 48;
          }
          while (v22 + v25 != v23);
          v24 += v25;
          int64x2_t v29 = *(int64x2_t *)a1;
          unint64_t v21 = (char *)v43.i64[1];
        }
        *(void *)a1 = v24;
        *((void *)a1 + 1) = v21;
        int64x2_t v43 = v29;
        uint64_t v30 = (char *)*((void *)a1 + 2);
        *((void *)a1 + 2) = v44;
        uint64_t v44 = v30;
        unint64_t v42 = (char *)v29.i64[0];
        std::__split_buffer<std::pair<std::string,std::vector<BOOL>>>::~__split_buffer((uint64_t)&v42);
        long long v31 = __p;
        *((void *)a1 + 1) = v21;
        if (v31) {
          operator delete(v31);
        }
      }
      else
      {
        long long v12 = *(_OWORD *)&v32.__r_.__value_.__l.__data_;
        *(void *)(v10 + 16) = *((void *)&v32.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v10 = v12;
        memset(&v32, 0, sizeof(v32));
        *(void *)(v10 + 24) = __p;
        *(void *)(v10 + 32) = v34;
        *(void *)(v10 + 40) = v35;
        std::string __p = 0;
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        *((void *)a1 + 1) = v10 + 48;
      }
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v32.__r_.__value_.__l.__data_);
      }
      if (v36) {
        operator delete(v36);
      }
      v32.__r_.__value_.__r.__words[0] = (std::string::size_type)&v39;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v32);
      char v6 = 0;
      if (++begin == end) {
        goto LABEL_33;
      }
    }
    uint64_t v5 = 0;
    do
    {
      if (!ImageClassifier_isBooleanFlag((uint64_t)v7)) {
        break;
      }
      ++v5;
      std::string::size_type v7 = (long long *)((char *)v7 + 24);
    }
    while (v7 != v40);
LABEL_8:
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    if (v5)
    {
      uint64_t v8 = 24;
      uint64_t v9 = v5;
      do
      {
        v32.__r_.__value_.__s.__data_[0] = ImageClassifier_stringToBool((uint64_t)v39 + v8);
        std::vector<BOOL>::push_back((uint64_t *)&v36, &v32);
        v8 += 24;
        --v9;
      }
      while (v9);
    }
    goto LABEL_13;
  }
LABEL_33:
  v32.__r_.__value_.__r.__words[0] = (std::string::size_type)&v41;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v32);
}

void sub_1A3F04530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,char a22)
{
}

BOOL ImageClassifier_isBooleanFlag(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __p = *(std::string *)a1;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v1 = (std::string *)((char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]));
  }
  else {
    uint64_t v1 = (std::string *)(__p.__r_.__value_.__r.__words[0] + __p.__r_.__value_.__l.__size_);
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  while (p_p != v1)
  {
    p_p->__r_.__value_.__s.__data_[0] = __tolower(p_p->__r_.__value_.__s.__data_[0]);
    p_p = (std::string *)((char *)p_p + 1);
  }
  BOOL v3 = !std::string::compare(&__p, "true") || std::string::compare(&__p, "false") == 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v3;
}

void sub_1A3F04674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::pair<std::string,std::vector<BOOL>>::pair[abi:ne180100]<std::string&,std::vector<BOOL>&,0>(std::string *this, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::vector<BOOL>::vector(this[1].__r_.__value_.__r.__words, a3);
  return this;
}

void sub_1A3F046F0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL ImageClassifier_stringToBool(uint64_t a1)
{
  if (!ImageClassifier_isBooleanFlag(a1))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3957;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if (*(char *)(a1 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __p = *(std::string *)a1;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v2 = (std::string *)((char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]));
  }
  else {
    uint64_t v2 = (std::string *)(__p.__r_.__value_.__r.__words[0] + __p.__r_.__value_.__l.__size_);
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  while (p_p != v2)
  {
    p_p->__r_.__value_.__s.__data_[0] = __tolower(p_p->__r_.__value_.__s.__data_[0]);
    p_p = (std::string *)((char *)p_p + 1);
  }
  int v4 = std::string::compare(&__p, "true");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v4 == 0;
}

void sub_1A3F047EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::vector<BOOL>>>>(unint64_t a1)
{
  if (a1 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(48 * a1);
}

uint64_t std::__split_buffer<std::pair<std::string,std::vector<BOOL>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    std::__destroy_at[abi:ne180100]<std::tuple<std::string,std::vector<BOOL>,float>,0>(i - 48);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::pair<std::string,std::vector<BOOL>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2) {
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<std::pair<std::string,std::vector<BOOL>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:ne180100]<std::tuple<std::string,std::vector<BOOL>,float>,0>(v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::pair<std::string,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::pair<std::string,std::string>>::~__split_buffer(std::__split_buffer<std::pair<std::string, std::string>> *this)
{
  std::__split_buffer<std::pair<std::string, std::string>>::pointer begin = this->__begin_;
  for (std::__split_buffer<std::pair<std::string, std::string>>::pointer i = this->__end_; i != begin; std::__split_buffer<std::pair<std::string, std::string>>::pointer i = this->__end_)
  {
    this->__end_ = i - 1;
    std::__destroy_at[abi:ne180100]<std::pair<std::string,std::string>,0>((uint64_t)&i[-1]);
  }
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void sub_1A3F04AA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F04BFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F04CB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F04FD0(_Unwind_Exception *a1, uint64_t a2, void *__p, uint64_t a4, int a5, __int16 a6, char a7, char a8, void *a9, void *a10, int __pa, __int16 __p_4, char __p_6, char __p_7, char a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__split_buffer<std::pair<std::string, std::string>> *a30)
{
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string,std::string>::pair[abi:ne180100](std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  long long v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((void *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  return this;
}

void sub_1A3F050DC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3F05464(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0553C()
{
}

__n128 __Block_byref_object_copy__12210(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__12211(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void sub_1A3F057A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  a11 = (void **)&a17;
  std::vector<std::pair<std::string,BOOL>>::__destroy_vector::operator()[abi:ne180100](&a11);
  a11 = (void **)&a20;
  std::vector<std::pair<std::string,std::vector<BOOL>>>::__destroy_vector::operator()[abi:ne180100](&a11);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<vision::mod::ImageClassifier_HierarchicalModel,std::allocator<vision::mod::ImageClassifier_HierarchicalModel>,char const*,decltype(nullptr),std::vector<std::pair<std::string,BOOL>> &,void>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  long long v4 = (char *)operator new(0x20uLL);
  *(_OWORD *)(v4 + 8) = 0u;
  *(void *)long long v4 = &unk_1EF753B28;
  unint64_t v20 = 0;
  long long v19 = 0u;
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  uint64_t v7 = v6 - *a3;
  if (v6 != *a3)
  {
    if (v7 < 0) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    v21.__end_cap_.__value_ = (std::allocator<std::pair<std::string, std::string>> *)&v20;
    v21.__first_ = (std::__split_buffer<std::pair<std::string, std::string>>::pointer)std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(v7 >> 5);
    v21.__begin_ = v21.__first_;
    v21.__end_ = v21.__first_;
    v21.__end_cap_.__value_ = (std::__split_buffer<std::pair<std::string, std::string>>::pointer)((char *)v21.__first_
                                                                                                + 32 * v8);
    std::vector<std::pair<std::string,vision::mod::ImageClassfier_GraphNodeType>>::__swap_out_circular_buffer((uint64_t *)&v19, &v21);
    std::__split_buffer<std::pair<std::string,float>>::~__split_buffer((uint64_t)&v21);
    uint64_t v5 = *a3;
    uint64_t v6 = a3[1];
  }
  for (; v5 != v6; v5 += 32)
  {
    BOOL v9 = *(unsigned char *)(v5 + 24) == 0;
    if (*(char *)(v5 + 23) < 0) {
      std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)v5, *(void *)(v5 + 8));
    }
    else {
      std::string v22 = *(std::string *)v5;
    }
    LODWORD(v23) = v9;
    uint64_t v10 = *((void *)&v19 + 1);
    if (*((void *)&v19 + 1) >= v20)
    {
      uint64_t v12 = (uint64_t)(*((void *)&v19 + 1) - v19) >> 5;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 59) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v14 = v20 - v19;
      if ((uint64_t)(v20 - v19) >> 4 > v13) {
        unint64_t v13 = v14 >> 4;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v15 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      v21.__end_cap_.__value_ = (std::allocator<std::pair<std::string, std::string>> *)&v20;
      unint64_t v16 = (std::pair<std::string, std::string> *)std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(v15);
      unsigned int v17 = (char *)v16 + 32 * v12;
      v21.__first_ = v16;
      v21.__begin_ = (std::__split_buffer<std::pair<std::string, std::string>>::pointer)v17;
      v21.__end_cap_.__value_ = (std::pair<std::string, std::string> *)((char *)v16 + 32 * v18);
      *(std::string *)unsigned int v17 = v22;
      memset(&v22, 0, sizeof(v22));
      *((_DWORD *)v17 + 6) = v9;
      v21.__end_ = (std::__split_buffer<std::pair<std::string, std::string>>::pointer)(v17 + 32);
      std::vector<std::pair<std::string,vision::mod::ImageClassfier_GraphNodeType>>::__swap_out_circular_buffer((uint64_t *)&v19, &v21);
      uint64_t v11 = *((void *)&v19 + 1);
      std::__split_buffer<std::pair<std::string,float>>::~__split_buffer((uint64_t)&v21);
    }
    else
    {
      **((_OWORD **)&v19 + 1) = *(_OWORD *)&v22.__r_.__value_.__l.__data_;
      *(void *)(v10 + 16) = *((void *)&v22.__r_.__value_.__l + 2);
      *(_DWORD *)(v10 + 24) = v9;
      uint64_t v11 = v10 + 32;
    }
    *((void *)&v19 + 1) = v11;
  }
  operator new();
}

void sub_1A3F069D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,char *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  std::deque<std::pair<int,int>>::~deque[abi:ne180100]((uint64_t)&a37);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(v48 - 144);
  a28 = &a14;
  std::vector<std::pair<std::string,BOOL>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a28);
  std::__shared_weak_count::~__shared_weak_count(a11);
  operator delete(v50);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageClassifier_HierarchicalModel>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    for (std::__split_buffer<std::pair<std::string, std::string>>::pointer i = *(void **)(v1 + 16); i; std::__split_buffer<std::pair<std::string, std::string>>::pointer i = (void *)*i)
    {
      uint64_t v3 = i[5];
      if (v3)
      {
        long long v4 = *(void **)(v3 + 56);
        if (v4)
        {
          *(void *)(v3 + 64) = v4;
          operator delete(v4);
        }
        uint64_t v5 = *(void **)(v3 + 32);
        if (v5)
        {
          *(void *)(v3 + 40) = v5;
          operator delete(v5);
        }
        if (*(char *)(v3 + 23) < 0) {
          operator delete(*(void **)v3);
        }
        MEMORY[0x1A62562C0](v3, 0x1092C40FB66ED40);
      }
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1 + 40);
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node(*(void ***)(v1 + 16));
    uint64_t v6 = *(void **)v1;
    *(void *)uint64_t v1 = 0;
    if (v6) {
      operator delete(v6);
    }
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifier_HierarchicalModel>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753B28;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifier_HierarchicalModel>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753B28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A3F06F0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

std::string *std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(std::string *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    __n128 result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>((uint64_t)&v6->__r_.__value_.__r.__words[2], a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_1A3F06FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(uint64_t a1, long long *a2, long long *a3, std::string *this)
{
  long long v4 = this;
  uint64_t v11 = this;
  uint64_t v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)v6, *((void *)v6 + 1));
        long long v4 = v12;
      }
      else
      {
        long long v7 = *v6;
        v4->__r_.__value_.__r.__words[2] = *((void *)v6 + 2);
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      uint64_t v6 = (long long *)((char *)v6 + 24);
      uint64_t v12 = ++v4;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_1A3F07078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A3F0784C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,void *a24,void *a25,uint64_t a26,uint64_t a27,void *a28,void *a29,void *a30,char *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  std::string __p = &a40;
  std::vector<std::unordered_map<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  vDSP_Length v45 = *(std::__shared_weak_count **)(v43 - 184);
  if (v45) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v45);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F08010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,void *a28,char *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,char a37)
{
  std::string __p = &a37;
  std::vector<std::unordered_map<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);

  uint64_t v40 = *(std::__shared_weak_count **)(v38 - 144);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v40);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F0824C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F08480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F087DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

id _modelBundlePathForClassifierResource(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a3;
  id v11 = a4;
  uint64_t v12 = [a2 objectForKeyedSubscript:v10];
  if (v12)
  {
    unint64_t v13 = [v9 pathForResource:v12 ofType:v11];
    if (v13)
    {
      id v14 = v13;
      unint64_t v15 = v14;
    }
    else
    {
      if (a5)
      {
        unint64_t v16 = NSString;
        unsigned int v17 = [v9 resourcePath];
        uint64_t v18 = [v16 stringWithFormat:@"could not locate %@ in %@", 0, v17];

        *a5 = +[VNError errorForInternalErrorWithLocalizedDescription:v18];
      }
      id v14 = 0;
      unint64_t v15 = 0;
    }
    goto LABEL_9;
  }
  if (a5)
  {
    id v14 = [NSString stringWithFormat:@"resource key \"%@\" is not available", v10];
    +[VNError errorForInternalErrorWithLocalizedDescription:v14];
    unint64_t v15 = 0;
    *a5 = (id)objc_claimAutoreleasedReturnValue();
LABEL_9:

    goto LABEL_10;
  }
  unint64_t v15 = 0;
LABEL_10:

  return v15;
}

void sub_1A3F089FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F08EB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0953C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09680(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F097F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09A38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09ACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09B18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09B78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09BC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09C24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09C70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09D4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F09DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  id v11 = v10;

  _Unwind_Resume(a1);
}

void sub_1A3F09FC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0A334(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3F0A8CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0ADF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0AE94()
{
}

void sub_1A3F0AFB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0B828(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3F0B718);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3F0BEF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0BF70(void *a1)
{
}

void sub_1A3F0C4A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3F0C690(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0CAF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3F0CA9CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3F0CC7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0D010(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0D214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0D45C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0D668(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0D8AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0DAFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0E08C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0E1B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0E27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0E730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0E854(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0E920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0EDB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0EEDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0EFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0F440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0F564(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0F630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0FAB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0FBD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F0FCA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F1013C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F10260(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F1032C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F107B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F108D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F109A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F10CA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F10D18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F10DAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F10E40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::CamGazePredictorConcrete>::__on_zero_shared(uint64_t a1)
{
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  free(*(void **)(a1 + 88));
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  if (!espresso_plan_destroy())
  {
    *(void *)(a1 + 144) = 0;
    if (!espresso_context_destroy()) {
      *(void *)(a1 + 136) = 0;
    }
  }
  if (*(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }
}

void std::__shared_ptr_emplace<vision::mod::CamGazePredictorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7537E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::CamGazePredictorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7537E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A3F111D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F11270(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F11308(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F1139C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F114D8(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3F115B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t Geometry2D_normalizePoints(uint64_t a1, float *a2, uint64_t a3, float *__C, float *a5, float *a6)
{
  if (a1 && (long long v7 = *(const float **)a1) != 0 && *(void *)(a1 + 8))
  {
    uint64_t v9 = -3;
    if (a3)
    {
      vDSP_Length v10 = *(unsigned int *)(a1 + 16);
      if ((int)v10 >= 1)
      {
        if (*(void *)a3)
        {
          if (*(void *)(a3 + 8))
          {
            int v11 = *(_DWORD *)(a3 + 16);
            if (v11 >= 1)
            {
              if (v10 == v11)
              {
                unint64_t v16 = a2;
                if (!a2)
                {
                  unsigned int v17 = (float *)malloc_type_malloc(4 * v10, 0x100004052888210uLL);
                  if (!v17)
                  {
                    uint64_t v9 = -5;
                    return (v9 + 128) | 0x700;
                  }
                  unint64_t v16 = v17;
                  long long v7 = *(const float **)a1;
                }
                vDSP_meanv(v7, 1, __C, v10);
                vDSP_meanv(*(const float **)(a1 + 8), 1, a5, v10);
                float v18 = -*__C;
                float v21 = -*a5;
                float __B = v18;
                vDSP_vsadd(*(const float **)a1, 1, &__B, *(float **)a3, 1, v10);
                vDSP_vsadd(*(const float **)(a1 + 8), 1, &v21, *(float **)(a3 + 8), 1, v10);
                vDSP_vdist(*(const float **)a3, 1, *(const float **)(a3 + 8), 1, v16, 1, v10);
                float __Ca = 0.0;
                vDSP_meanv(v16, 1, &__Ca, v10);
                if (fabsf(__Ca) >= 0.00000011921)
                {
                  *a6 = 1.4142 / __Ca;
                  vDSP_vsmul(*(const float **)a3, 1, a6, *(float **)a3, 1, v10);
                  vDSP_vsmul(*(const float **)(a3 + 8), 1, a6, *(float **)(a3 + 8), 1, v10);
                  uint64_t v9 = 0;
                  if (!a2) {
LABEL_20:
                  }
                    free(v16);
                }
                else
                {
                  uint64_t v9 = -19;
                  if (!a2) {
                    goto LABEL_20;
                  }
                }
              }
              else
              {
                uint64_t v9 = -4;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v9 = -3;
  }
  return (v9 + 128) | 0x700;
}

void sub_1A3F11938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F11B60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);

  _Block_object_dispose((const void *)(v26 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12679(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__12680(uint64_t a1)
{
}

void sub_1A3F11E74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

void sub_1A3F12070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F12178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F122D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F12560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F126C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void vision::mod::GreedyClustererWithTorso::deserializeStatus(vision::mod::GreedyClustererWithTorso *this, int a2, int a3)
{
  size_t v12 = 0;
  read(a2, &v12, 8uLL);
  std::string::basic_string[abi:ne180100](__b, v12, 48);
  if (v11 >= 0) {
    uint64_t v6 = __b;
  }
  else {
    uint64_t v6 = (void **)__b[0];
  }
  read(a2, v6, v12);
  createFullPath(&__p, *((void *)this + 8), (uint64_t)__b);
  if (a3)
  {
    cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createReadOnlyFromContentsOfFile((uint64_t)&__p);
    uint64_t v7 = *((void *)this + 8);
    uint64_t v8 = *(std::__shared_weak_count **)(v7 + 80);
    *(void *)(v7 + 72) = 0;
    *(void *)(v7 + 80) = 0;
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
    std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>::reset[abi:ne180100]<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const,void>();
  }
  cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createFromContentsOfFile((uint64_t)&__p);
}

void sub_1A3F12914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

std::string *createFullPath(std::string *this, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    *this = *(std::string *)a2;
  }
  std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
  BOOL v6 = (size & 0x80u) != 0;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
  }
  if (v6) {
    uint64_t v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else {
    uint64_t v7 = this;
  }
  if (v7->__r_.__value_.__s.__data_[size - 1] != 47)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "/");
    uint64_t v8 = (v15 & 0x80u) == 0 ? (const std::string::value_type *)__p : (const std::string::value_type *)__p[0];
    uint64_t v9 = (v15 & 0x80u) == 0 ? (void *)v15 : __p[1];
    std::string::append(this, v8, (std::string::size_type)v9);
    if ((char)v15 < 0) {
      operator delete(__p[0]);
    }
  }
  int v10 = *(char *)(a3 + 23);
  if (v10 >= 0) {
    char v11 = (const std::string::value_type *)a3;
  }
  else {
    char v11 = *(const std::string::value_type **)a3;
  }
  if (v10 >= 0) {
    std::string::size_type v12 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v12 = *(void *)(a3 + 8);
  }
  return std::string::append(this, v11, v12);
}

{
  std::string::size_type size;
  BOOL v6;
  std::string *v7;
  const std::string::value_type *v8;
  void *v9;
  int v10;
  const std::string::value_type *v11;
  std::string::size_type v12;
  void *__p[2];
  unsigned __int8 v15;

  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    *this = *(std::string *)a2;
  }
  std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
  BOOL v6 = (size & 0x80u) != 0;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
  }
  if (v6) {
    uint64_t v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else {
    uint64_t v7 = this;
  }
  if (v7->__r_.__value_.__s.__data_[size - 1] != 47)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "/");
    uint64_t v8 = (v15 & 0x80u) == 0 ? (const std::string::value_type *)__p : (const std::string::value_type *)__p[0];
    uint64_t v9 = (v15 & 0x80u) == 0 ? (void *)v15 : __p[1];
    std::string::append(this, v8, (std::string::size_type)v9);
    if ((char)v15 < 0) {
      operator delete(__p[0]);
    }
  }
  int v10 = *(char *)(a3 + 23);
  if (v10 >= 0) {
    char v11 = (const std::string::value_type *)a3;
  }
  else {
    char v11 = *(const std::string::value_type **)a3;
  }
  if (v10 >= 0) {
    std::string::size_type v12 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v12 = *(void *)(a3 + 8);
  }
  return std::string::append(this, v11, v12);
}

void sub_1A3F12A4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createReadOnlyFromContentsOfFile(uint64_t a1)
{
  v10[0] = 24;
  v10[1] = 0;
  int v11 = 0;
  if (cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::isValidHeader(a1, v10)) {
    cvml::util::MMapFileBackingStore::createByMappingDirectlyFromFile((const char *)a1, 0);
  }
  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v8 = a1;
  }
  else {
    uint64_t v8 = *(void *)a1;
  }
  VNValidatedLog(4, @"BackedBuffer<BackingStore>::createByMappingDirectlyFromFile -- Invalid header detected for file '%s'", v2, v3, v4, v5, v6, v7, v8);
  return 0;
}

void sub_1A3F12BF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  MEMORY[0x1A62562C0](v15, 0x1092C4040FCC1CALL);
  if (__p) {
    operator delete(__p);
  }
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  _Unwind_Resume(a1);
}

void cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createFromContentsOfFile(uint64_t a1)
{
  v32[0] = 24;
  v32[1] = 0;
  int v33 = 0;
  if (cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::isValidHeader(a1, v32))
  {
    unint64_t v15 = v35;
    if ((v35 & 0x80u) != 0) {
      unint64_t v15 = (unint64_t)__p[1];
    }
    if (v15 == 11
      && ((v35 & 0x80u) == 0 ? (unint64_t v16 = __p) : (unint64_t v16 = (void **)__p[0]),
          (unsigned int v17 = *v16, v18 = *(uint64_t *)((char *)v16 + 3), v17 == (void *)0x494C41564E492323)
        ? (BOOL v19 = v18 == 0x232344494C41564ELL)
        : (BOOL v19 = 0),
          v19))
    {
      uint64_t v27 = @"MMapFileBackedBuffer::createFromContentsOfFile -- Could not generate a valid path for temporary file";
    }
    else
    {
      unint64_t v20 = (void *)MEMORY[0x1A6257080]();
      if (*(char *)(a1 + 23) >= 0) {
        uint64_t v21 = a1;
      }
      else {
        uint64_t v21 = *(void *)a1;
      }
      std::string v22 = [NSString stringWithUTF8String:v21];
      if ((v35 & 0x80u) == 0) {
        uint64_t v23 = __p;
      }
      else {
        uint64_t v23 = (void **)__p[0];
      }
      uint64_t v24 = [NSString stringWithUTF8String:v23];
      uint64_t v25 = [MEMORY[0x1E4F28CB8] defaultManager];
      int v26 = [v25 fileExistsAtPath:v22];
      if (v26) {
        int v1 = [v25 copyItemAtPath:v22 toPath:v24 error:0];
      }

      if (v26 & v1) {
        cvml::util::MMapFileBackingStore::createByMappingDirectlyFromFile((const char *)__p, 1);
      }
      uint64_t v27 = @"MMapFileBackedBuffer::createFromContentsOfFile -- Could not create a temporary file for file backed storage";
    }
    VNValidatedLog(4, (uint64_t)v27, v9, v10, v11, v12, v13, v14, v30);
    if ((char)v35 < 0) {
      operator delete(__p[0]);
    }
    std::shared_ptr<cvml::util::MMapFileBackingStore>::shared_ptr[abi:ne180100]<cvml::util::MMapFileBackingStore,void>(&v31, 0);
  }
  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v28 = a1;
  }
  else {
    uint64_t v28 = *(void *)a1;
  }
  VNValidatedLog(4, @"BackedBuffer<BackingStore>::createByMappingDirectlyFromFile -- Invalid header detected for file '%s'", v3, v4, v5, v6, v7, v8, v28);
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA510] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
}

void sub_1A3F12F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  MEMORY[0x1A62562C0](v21, 0x1092C4040FCC1CALL);
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  _Unwind_Resume(a1);
}

void vision::mod::GreedyClustererWithTorso::private_t::clusters_t::set_cluster_map_vector()
{
}

void std::vector<unsigned int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz)
{
  std::vector<int>::pointer begin = this->__begin_;
  std::vector<int>::pointer end = this->__end_;
  std::vector<int>::size_type v5 = end - this->__begin_;
  if (__sz <= v5)
  {
    if (__sz >= v5) {
      return;
    }
    BOOL v19 = &begin[__sz];
    goto LABEL_15;
  }
  std::vector<int>::size_type v6 = __sz - v5;
  value = this->__end_cap_.__value_;
  if (__sz - v5 <= value - end)
  {
    bzero(this->__end_, 4 * v6);
    BOOL v19 = &end[v6];
LABEL_15:
    this->__end_ = v19;
    return;
  }
  if (__sz >> 62) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = (char *)value - (char *)begin;
  std::vector<int>::size_type v9 = v8 >> 1;
  if (v8 >> 1 <= __sz) {
    std::vector<int>::size_type v9 = __sz;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v10 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  uint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v10);
  std::vector<int>::pointer v12 = this->__begin_;
  std::vector<int>::pointer v13 = this->__end_;
  uint64_t v14 = &v11[4 * v5];
  unint64_t v16 = (int *)&v11[4 * v15];
  bzero(v14, 4 * v6);
  unsigned int v17 = (int *)&v14[4 * v6];
  while (v13 != v12)
  {
    int v18 = *--v13;
    *((_DWORD *)v14 - 1) = v18;
    v14 -= 4;
  }
  this->__begin_ = (std::vector<int>::pointer)v14;
  this->__end_ = v17;
  this->__end_cap_.__value_ = v16;
  if (v12)
  {
    operator delete(v12);
  }
}

void std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::reset[abi:ne180100]<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>,void>()
{
}

void sub_1A3F131F0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::operator()[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

cvml::util::MMapFileBackingStore *std::default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::operator()[abi:ne180100](cvml::util::MMapFileBackingStore *this)
{
  if (this)
  {
    int v1 = this;
    uint64_t v2 = (void *)*((void *)this + 7);
    if (v2) {
      operator delete(v2);
    }
    cvml::util::MMapFileBackingStore::~MMapFileBackingStore(v1);
    JUMPOUT(0x1A62562C0);
  }
  return this;
}

uint64_t std::__shared_ptr_pointer<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> *,std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::__shared_ptr_default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>,cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>,std::allocator<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN4cvml4util12BackedBufferINS2_20MMapFileBackingStoreEEEE27__shared_ptr_default_deleteIS5_S5_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

cvml::util::MMapFileBackingStore *std::__shared_ptr_pointer<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> *,std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::__shared_ptr_default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>,cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>,std::allocator<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>>::__on_zero_shared(uint64_t a1)
{
  return std::default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::operator()[abi:ne180100](*(cvml::util::MMapFileBackingStore **)(a1 + 24));
}

void std::__shared_ptr_pointer<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> *,std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::__shared_ptr_default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>,cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>,std::allocator<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

uint64_t cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::isValidHeader(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = a1;
  if (*(char *)(a1 + 23) < 0) {
    a1 = *(void *)a1;
  }
  int v4 = open((const char *)a1, 0);
  int v11 = v4;
  if (v4 == -1)
  {
    uint64_t v23 = @"BackedBuffer<BackingStore>::isValidHeader -- cannot open source file '%s'";
    goto LABEL_14;
  }
  if (read(v4, a2, 0x18uLL) != 24)
  {
    uint64_t v23 = @"BackedBuffer<BackingStore>::isValidHeader -- corrupt header detected in file '%s'";
    goto LABEL_14;
  }
  unint64_t v12 = a2[4];
  if (!v12)
  {
    uint64_t v23 = @"BackedBuffer<BackingStore>::isValidHeader -- inconsistent header detected -- zero element size detected for file '%s'";
LABEL_14:
    if (*(char *)(v3 + 23) >= 0) {
      uint64_t v24 = v3;
    }
    else {
      uint64_t v24 = *(void *)v3;
    }
    VNValidatedLog(4, (uint64_t)v23, v5, v6, v7, v8, v9, v10, v24);
    exception = __cxa_allocate_exception(8uLL);
    void *exception = MEMORY[0x1E4FBA510] + 16;
    __cxa_throw(exception, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
  }
  uint64_t v13 = *(void *)a2;
  unint64_t v14 = (*(void *)a2 - 24) / v12;
  if (a2[3] != v14)
  {
    int v26 = @"BackedBuffer<BackingStore>::isValidHeader -- inconsistent header detected -- element count does not match max free element capacity for file '%s'";
    goto LABEL_20;
  }
  if (a2[2] > v14)
  {
    int v26 = @"BackedBuffer<BackingStore>::isValidHeader -- inconsistent header detected -- free element count exceeds free element capacity for file '%s'";
LABEL_20:
    if (*(char *)(v3 + 23) >= 0) {
      uint64_t v27 = v3;
    }
    else {
      uint64_t v27 = *(void *)v3;
    }
    VNValidatedLog(4, (uint64_t)v26, v5, v6, v7, v8, v9, v10, v27);
    uint64_t v28 = __cxa_allocate_exception(8uLL);
    *uint64_t v28 = MEMORY[0x1E4FBA510] + 16;
    __cxa_throw(v28, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
  }
  off_t v15 = lseek(v11, 0, 2);
  if (v15 == -1)
  {
    int64x2_t v29 = @"BackedBuffer<BackingStore>::isValidHeader -- inconsistent header detected -- could not validate file size for file '%s'";
    goto LABEL_26;
  }
  if (4 * v14 + v13 != v15)
  {
    int64x2_t v29 = @"BackedBuffer<BackingStore>::isValidHeader -- inconsistent header detected -- expected file size does not match actual file size for file '%s'";
LABEL_26:
    if (*(char *)(v3 + 23) >= 0) {
      uint64_t v30 = v3;
    }
    else {
      uint64_t v30 = *(void *)v3;
    }
    VNValidatedLog(4, (uint64_t)v29, v16, v17, v18, v19, v20, v21, v30);
    uint64_t v31 = __cxa_allocate_exception(8uLL);
    *uint64_t v31 = MEMORY[0x1E4FBA510] + 16;
    __cxa_throw(v31, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
  }
  close(v11);
  return 1;
}

void sub_1A3F1352C(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (v2 == -1) {
      JUMPOUT(0x1A3F133ACLL);
    }
    JUMPOUT(0x1A3F133A0);
  }
  _Unwind_Resume(a1);
}

void std::shared_ptr<cvml::util::MMapFileBackingStore>::shared_ptr[abi:ne180100]<cvml::util::MMapFileBackingStore,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1A3F135D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<cvml::util::MMapFileBackingStore>::reset[abi:ne180100]((cvml::util::MMapFileBackingStore **)va);
  _Unwind_Resume(a1);
}

cvml::util::MMapFileBackingStore *std::unique_ptr<cvml::util::MMapFileBackingStore>::reset[abi:ne180100](cvml::util::MMapFileBackingStore **a1)
{
  __n128 result = *a1;
  *a1 = 0;
  if (result)
  {
    cvml::util::MMapFileBackingStore::~MMapFileBackingStore(result);
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<cvml::util::MMapFileBackingStore *,std::shared_ptr<cvml::util::MMapFileBackingStore>::__shared_ptr_default_delete<cvml::util::MMapFileBackingStore,cvml::util::MMapFileBackingStore>,std::allocator<cvml::util::MMapFileBackingStore>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN4cvml4util20MMapFileBackingStoreEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

cvml::util::MMapFileBackingStore *std::__shared_ptr_pointer<cvml::util::MMapFileBackingStore *,std::shared_ptr<cvml::util::MMapFileBackingStore>::__shared_ptr_default_delete<cvml::util::MMapFileBackingStore,cvml::util::MMapFileBackingStore>,std::allocator<cvml::util::MMapFileBackingStore>>::__on_zero_shared(uint64_t a1)
{
  __n128 result = *(cvml::util::MMapFileBackingStore **)(a1 + 24);
  if (result)
  {
    cvml::util::MMapFileBackingStore::~MMapFileBackingStore(result);
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

void std::__shared_ptr_pointer<cvml::util::MMapFileBackingStore *,std::shared_ptr<cvml::util::MMapFileBackingStore>::__shared_ptr_default_delete<cvml::util::MMapFileBackingStore,cvml::util::MMapFileBackingStore>,std::allocator<cvml::util::MMapFileBackingStore>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>::reset[abi:ne180100]<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const,void>()
{
}

void sub_1A3F13784(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::operator()[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const*,std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>::__shared_ptr_default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const,cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>,std::allocator<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIKN4cvml4util12BackedBufferINS2_20MMapFileBackingStoreEEEE27__shared_ptr_default_deleteIS6_S6_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

cvml::util::MMapFileBackingStore *std::__shared_ptr_pointer<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const*,std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>::__shared_ptr_default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const,cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>,std::allocator<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>>::__on_zero_shared(uint64_t a1)
{
  return std::default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::operator()[abi:ne180100](*(cvml::util::MMapFileBackingStore **)(a1 + 24));
}

void std::__shared_ptr_pointer<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const*,std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>::__shared_ptr_default_delete<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const,cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>,std::allocator<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

BOOL vision::mod::GreedyClustererWithTorso::serializeStatus(vision::mod::GreedyClustererWithTorso *this, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  VNValidatedLog(1, @"  GreedyClustererWithTorso::serializeStatus - enter", a3, a4, a5, a6, a7, a8, v48);
  if (a2 == -1)
  {
    VNValidatedLog(4, @"  GreedyClustererWithTorso: Failed to open file - skipping serialization", v10, v11, v12, v13, v14, v15, v49);
  }
  else
  {
    vision::mod::GreedyClustererWithTorso::private_t::clusters_t::newMapFilePath(&__s, *((void *)this + 8));
    getRelativePath(&__str, *((char **)this + 8), &__s);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_s = &__s;
    }
    else {
      p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    }
    VNValidatedLog(1, @"  GreedyClustererWithTorso::serializeStatus - saving map file: %s", v16, v17, v18, v19, v20, v21, (uint64_t)p_s);
    uint64_t v23 = *((void *)this + 8);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v24 = &__s;
    }
    else {
      uint64_t v24 = (std::string *)__s.__r_.__value_.__r.__words[0];
    }
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)v24);
    uint64_t v31 = *(void *)(v23 + 88);
    if (v31 || (uint64_t v31 = *(void *)(v23 + 72)) != 0)
    {
      int v32 = cvml::util::MMapFileBackingStore::writeToFile(v31, (uint64_t)__p);
      char v33 = 0;
    }
    else
    {
      int v32 = 0;
      char v33 = 1;
    }
    if (v52 < 0) {
      operator delete(__p[0]);
    }
    if (v32) {
      char v34 = v33;
    }
    else {
      char v34 = 1;
    }
    if (v34)
    {
      VNValidatedLog(4, @"  GreedyClustererWithTorso: failed to save the file", v25, v26, v27, v28, v29, v30, v50);
      exception = __cxa_allocate_exception(8uLL);
      void *exception = 5236;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    __p[0] = (void *)size;
    write(a2, __p, 8uLL);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_str = &__str;
    }
    else {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    write(a2, p_str, (size_t)__p[0]);
    std::string::operator=((std::string *)(*((void *)this + 8) + 24), &__str);
    write(a2, (const void *)(*((void *)this + 8) + 104), 4uLL);
    write(a2, (const void *)(*((void *)this + 8) + 108), 8uLL);
    __p[0] = (void *)((uint64_t)(*(void *)(*((void *)this + 8) + 56) - *(void *)(*((void *)this + 8) + 48)) >> 2);
    write(a2, __p, 8uLL);
    uint64_t v43 = *(void *)(*((void *)this + 8) + 48);
    if ((int)((unint64_t)(*(void *)(*((void *)this + 8) + 56) - v43) >> 2) >= 1)
    {
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      do
      {
        write(a2, (const void *)(v43 + v44), 4uLL);
        ++v45;
        uint64_t v43 = *(void *)(*((void *)this + 8) + 48);
        v44 += 4;
      }
      while (v45 < (int)((unint64_t)(*(void *)(*((void *)this + 8) + 56) - v43) >> 2));
    }
    VNValidatedLog(1, @"  GreedyClustererWithTorso::serializeStatus - done", v37, v38, v39, v40, v41, v42, v50);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
  }
  return a2 != -1;
}

void sub_1A3F13A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void vision::mod::GreedyClustererWithTorso::private_t::clusters_t::newMapFilePath(std::string *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  *(void *)uu = 0;
  uint64_t v18 = 0;
  MEMORY[0x1A6257C60](uu);
  memset(out, 0, 37);
  uuid_unparse(uu, out);
  std::string::basic_string[abi:ne180100]<0>(&v14, out);
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    uint64_t v5 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v5 = *(const std::string::value_type **)a2;
  }
  if (v4 >= 0) {
    std::string::size_type v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v6 = *(void *)(a2 + 8);
  }
  uint64_t v7 = std::string::insert(&v14, 0, v5, v6);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, ".cmap");
  if ((v13 & 0x80u) == 0) {
    uint64_t v9 = __p;
  }
  else {
    uint64_t v9 = (void **)__p[0];
  }
  if ((v13 & 0x80u) == 0) {
    std::string::size_type v10 = v13;
  }
  else {
    std::string::size_type v10 = (std::string::size_type)__p[1];
  }
  uint64_t v11 = std::string::append(&v15, (const std::string::value_type *)v9, v10);
  *a1 = *v11;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if ((char)v13 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
}

void sub_1A3F13C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void *getRelativePath(void *a1, char *a2, void *__s)
{
  int v5 = a2[23];
  if (v5 >= 0) {
    size_t v6 = a2[23];
  }
  else {
    size_t v6 = *((void *)a2 + 1);
  }
  if (*((char *)__s + 23) < 0)
  {
    size_t v7 = __s[1];
    if (v6 >= v7) {
      goto LABEL_22;
    }
    long long v8 = (void *)*__s;
  }
  else
  {
    size_t v7 = *((unsigned __int8 *)__s + 23);
    long long v8 = __s;
    if (v6 >= v7) {
      goto LABEL_22;
    }
  }
  if (v5 >= 0) {
    uint64_t v9 = a2;
  }
  else {
    uint64_t v9 = *(char **)a2;
  }
  if (v6)
  {
    if ((uint64_t)v7 < (uint64_t)v6) {
      goto LABEL_22;
    }
    std::string::size_type v10 = (char *)v8 + v7;
    int v11 = *v9;
    uint64_t v12 = v8;
    while (1)
    {
      size_t v13 = v7 - v6;
      if (v13 == -1) {
        goto LABEL_22;
      }
      std::string v14 = (char *)memchr(v12, v11, v13 + 1);
      if (!v14) {
        goto LABEL_22;
      }
      std::string v15 = v14;
      if (!memcmp(v14, v9, v6)) {
        break;
      }
      uint64_t v12 = v15 + 1;
      size_t v7 = v10 - (v15 + 1);
      if ((uint64_t)v7 < (uint64_t)v6) {
        goto LABEL_22;
      }
    }
    if (v15 == v10 || (int64_t v16 = v15 - (char *)v8, v15 - (char *)v8 == -1))
    {
LABEL_22:
      exception = __cxa_allocate_exception(8uLL);
      void *exception = 5246;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
  }
  else
  {
    int64_t v16 = 0;
  }

  return std::string::basic_string[abi:ne180100](a1, __s, v16 + v6);
}

void *std::string::basic_string[abi:ne180100](void *__dst, uint64_t *a2, unint64_t a3)
{
  int v4 = a2;
  if (*((char *)a2 + 23) < 0)
  {
    unint64_t v6 = a2[1];
    if (v6 < a3) {
      goto LABEL_15;
    }
    int v4 = (uint64_t *)*a2;
  }
  else
  {
    unint64_t v6 = *((unsigned __int8 *)a2 + 23);
    if (v6 < a3) {
LABEL_15:
    }
      std::string::__throw_out_of_range[abi:ne180100]();
  }
  size_t v7 = v6 - a3;
  if (v6 - a3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v7 >= 0x17)
  {
    uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v9 = v7 | 7;
    }
    uint64_t v10 = v9 + 1;
    long long v8 = operator new(v9 + 1);
    __dst[1] = v7;
    __dst[2] = v10 | 0x8000000000000000;
    void *__dst = v8;
  }
  else
  {
    *((unsigned char *)__dst + 23) = v7;
    long long v8 = __dst;
    if (v6 == a3) {
      goto LABEL_14;
    }
  }
  memmove(v8, (char *)v4 + a3, v7);
LABEL_14:
  *((unsigned char *)v8 + v7) = 0;
  return __dst;
}

void vision::mod::GreedyClustererWithTorso::~GreedyClustererWithTorso(vision::mod::GreedyClustererWithTorso *this)
{
  vision::mod::GreedyClustererWithTorso::~GreedyClustererWithTorso(this);

  JUMPOUT(0x1A62562C0);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF752768;
  int v2 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void non-virtual thunk to'vision::mod::GreedyClustererFacesWithTorso::~GreedyClustererFacesWithTorso(vision::mod::GreedyClustererFacesWithTorso *this)
{
  vision::mod::GreedyClustererFacesWithTorso::~GreedyClustererFacesWithTorso((vision::mod::GreedyClustererFacesWithTorso *)((char *)this - 8));

  JUMPOUT(0x1A62562C0);
}

{
  vision::mod::GreedyClustererFacesWithTorso::~GreedyClustererFacesWithTorso((vision::mod::GreedyClustererFacesWithTorso *)((char *)this - 8));
}

void vision::mod::GreedyClustererFacesWithTorso::~GreedyClustererFacesWithTorso(vision::mod::GreedyClustererFacesWithTorso *this)
{
  *(void *)this = &unk_1EF752A58;
  int v2 = (vision::mod::GreedyClustererFacesWithTorso *)((char *)this + 8);
  *((void *)this + 1) = &unk_1EF752B38;
  if (*((char *)this + 215) < 0) {
    operator delete(*((void **)this + 24));
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((void **)this + 22));
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((void **)this + 19));
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((void **)this + 16));
  std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(*((void **)this + 13));
  vision::mod::GreedyClustererWithTorso::~GreedyClustererWithTorso(v2);
}

{
  uint64_t vars8;

  vision::mod::GreedyClustererFacesWithTorso::~GreedyClustererFacesWithTorso(this);

  JUMPOUT(0x1A62562C0);
}

void std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(a1[1]);
    std::__list_imp<long long>::clear(a1 + 5);
    operator delete(a1);
  }
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::getCountForCluster(vision::mod::GreedyClustererFacesWithTorso *this, uint64_t a2)
{
  if (!vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState(this, a2)) {
    return 0;
  }
  int v4 = (char *)this + 152;
  int v5 = (void *)*((void *)this + 19);
  if (!v5) {
    goto LABEL_12;
  }
  unint64_t v6 = (char *)this + 152;
  do
  {
    uint64_t v7 = v5[4];
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = v5;
    }
    else {
      uint64_t v9 = v5 + 1;
    }
    if (!v8) {
      unint64_t v6 = (char *)v5;
    }
    int v5 = (void *)*v9;
  }
  while (*v9);
  if (v6 == v4 || *((void *)v6 + 4) > a2) {
LABEL_12:
  }
    unint64_t v6 = (char *)this + 152;
  uint64_t v10 = (char *)*((void *)this + 18);
  if (v10 == v4) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v12 = *((void *)v6 + 5);
  do
  {
    if (*((void *)v10 + 5) == v12) {
      ++result;
    }
    size_t v13 = (char *)*((void *)v10 + 1);
    if (v13)
    {
      do
      {
        std::string v14 = v13;
        size_t v13 = *(char **)v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        std::string v14 = (char *)*((void *)v10 + 2);
        BOOL v15 = *(void *)v14 == (void)v10;
        uint64_t v10 = v14;
      }
      while (!v15);
    }
    uint64_t v10 = v14;
  }
  while (v14 != v4);
  return result;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState(vision::mod::GreedyClustererFacesWithTorso *this, uint64_t a2)
{
  int v2 = (void *)*((void *)this + 19);
  if (!v2)
  {
    uint64_t v3 = "FaceId=%lld not present in clustering";
LABEL_9:
    syslog(5, v3, a2);
    return 0;
  }
  uint64_t v3 = "FaceId=%lld not present in clustering";
  while (1)
  {
    uint64_t v4 = v2[4];
    if (v4 <= a2) {
      break;
    }
LABEL_6:
    int v2 = (void *)*v2;
    if (!v2) {
      goto LABEL_9;
    }
  }
  if (v4 < a2)
  {
    ++v2;
    goto LABEL_6;
  }
  unint64_t v6 = (void *)*((void *)this + 16);
  if (!v6)
  {
    syslog(5, "FaceId=%lld not present in l0 clustering");
    return 0;
  }
  uint64_t v3 = "FaceId=%lld not present in l0 clustering";
  while (1)
  {
    uint64_t v7 = v6[4];
    if (v7 <= a2) {
      break;
    }
LABEL_17:
    unint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_9;
    }
  }
  if (v7 < a2)
  {
    ++v6;
    goto LABEL_17;
  }
  return 1;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::removeIds(uint64_t **this, uint64_t *a2, void *a3)
{
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = &v43;
  uint64_t v4 = *a2;
  if (a2[1] == *a2)
  {
LABEL_40:
    vision::mod::GreedyClustererFacesWithTorso::computeDeltaAfterUpdate((uint64_t)this, a3, (uint64_t *)&v42);
    uint64_t v36 = &CVML_status_ok;
  }
  else
  {
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = (uint64_t *)(v4 + 8 * v6);
      if ((vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState((vision::mod::GreedyClustererFacesWithTorso *)this, *v7) & 1) == 0)break; {
      uint64_t v41 = 0;
      }
      uint64_t v8 = (uint64_t)std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(this + 15, *v7, (uint64_t **)v7)[5];
      uint64_t v41 = v8;
      std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v42, v8, v8);
      uint64_t v9 = this[9][9];
      if (v9) {
        unint64_t v10 = *(void *)v9 + v8 * (unint64_t)*(unsigned int *)(*(void *)v9 + 16) + 24;
      }
      else {
        unint64_t v10 = 0;
      }
      --*(_DWORD *)(v10 + 8);
      int v11 = std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(this + 12, v8, &v41);
      uint64_t v12 = v11 + 5;
      size_t v13 = (uint64_t *)std::remove[abi:ne180100]<std::__list_iterator<long long,void *>,long long>(v11[6], (uint64_t)(v11 + 5), v7);
      std::list<long long>::erase((uint64_t)v12, v13, v12);
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__erase_unique<long long>(this + 15, *v7);
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__erase_unique<long long>(this + 18, *v7);
      if (!*(_DWORD *)(v10 + 8))
      {
        std::string v14 = this[9];
        __int32 v45 = v8;
        BOOL v15 = (__int32 *)v14[7];
        int64_t v16 = wmemchr((__int32 *)v14[6], v8, ((uint64_t)v15 - v14[6]) >> 2);
        if (v16) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v15;
        }
        uint64_t v18 = (__int32 *)v14[7];
        if (v17 == v18 || (uint64_t v19 = (void *)v14[9]) == 0)
        {
          exception = __cxa_allocate_exception(8uLL);
          void *exception = 5246;
          __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
        }
        uint64_t v20 = *v19;
        if (*(_DWORD *)(*v19 + 12) > v8)
        {
          uint64_t v21 = v19[7];
          uint64_t v22 = v8 >> 6;
          uint64_t v23 = *(void *)(v21 + 8 * v22);
          if ((v23 & (1 << v8)) != 0)
          {
            *(_DWORD *)(v20 + *(void *)v20 + 4 * *(unsigned int *)(v20 + 8)) = v8;
            *(void *)(v21 + 8 * v22) = v23 & ~(1 << v8);
            ++*(_DWORD *)(v20 + 8);
          }
        }
        uint64_t v24 = std::remove[abi:ne180100]<std::__wrap_iter<unsigned int *>,unsigned int>((__int32 *)v14[6], v18, &v45);
        if ((__int32 *)v14[7] != v24) {
          v14[7] = (uint64_t)v24;
        }
        std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__erase_unique<unsigned long>(this + 12, v8);
        if (v43)
        {
          uint64_t v25 = (uint64_t *)&v43;
          uint64_t v26 = v43;
          do
          {
            uint64_t v27 = v26;
            uint64_t v28 = v25;
            unsigned int v29 = *((_DWORD *)v26 + 7);
            uint64_t v30 = v26 + 1;
            if (v29 >= v8) {
              uint64_t v25 = v26;
            }
            else {
              ++v26;
            }
            uint64_t v26 = (uint64_t *)*v26;
          }
          while (v26);
          if (v25 != (uint64_t *)&v43)
          {
            if (v29 < v8) {
              uint64_t v27 = v28;
            }
            if (*((_DWORD *)v27 + 7) <= v8)
            {
              uint64_t v31 = v28 + 1;
              if (v29 >= v8) {
                uint64_t v31 = v30;
              }
              int v32 = (uint64_t *)*v31;
              char v33 = v25;
              if (*v31)
              {
                do
                {
                  char v34 = (uint64_t **)v32;
                  int v32 = (uint64_t *)*v32;
                }
                while (v32);
              }
              else
              {
                do
                {
                  char v34 = (uint64_t **)v33[2];
                  BOOL v35 = *v34 == v33;
                  char v33 = (uint64_t *)v34;
                }
                while (!v35);
              }
              if (v42 == (uint64_t **)v25) {
                uint64_t v42 = v34;
              }
              --v44;
              std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v43, v25);
              operator delete(v25);
            }
          }
        }
      }
      ++v6;
      uint64_t v4 = *a2;
      if (v6 >= (a2[1] - *a2) >> 3) {
        goto LABEL_40;
      }
    }
    uint64_t v36 = &CVML_status_invalidParameter;
  }
  uint64_t v37 = (*v36 + 128) | 0x1400;
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v43);
  return v37;
}

void sub_1A3F14530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

uint64_t **std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t **a3)
{
  unint64_t v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = *a3;
    void v7[5] = 0;
    *uint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *unint64_t v6 = (uint64_t *)v7;
    unint64_t v10 = (uint64_t *)**a1;
    int v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      int v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>(uint64_t *result, unsigned int a2, int a3)
{
  uint64_t v4 = (uint64_t **)result;
  unint64_t v6 = (uint64_t **)(result + 1);
  int v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v9 + 7) = a3;
    return std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v6 = a1 + 1;
  int v5 = a1[1];
  uint64_t v7 = a1 + 1;
  unsigned int v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v9 <= a2) {
          break;
        }
        int v5 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      int v5 = v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    unint64_t v10 = (uint64_t *)operator new(0x40uLL);
    v12[1] = v6;
    v10[4] = *a3;
    v10[5] = (uint64_t)(v10 + 5);
    v10[6] = (uint64_t)(v10 + 5);
    v10[7] = 0;
    char v13 = 1;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v8, v7, v10);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned long,std::list<long long>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long,std::list<long long>>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return v10;
  }
  return (uint64_t *)v8;
}

uint64_t std::remove[abi:ne180100]<std::__list_iterator<long long,void *>,long long>(uint64_t result, uint64_t a2, uint64_t *a3)
{
  if (result == a2) {
    return a2;
  }
  uint64_t v3 = *a3;
  while (*(void *)(result + 16) != v3)
  {
    uint64_t result = *(void *)(result + 8);
    if (result == a2) {
      return a2;
    }
  }
  if (result == a2) {
    return a2;
  }
  for (uint64_t i = *(void *)(result + 8); i != a2; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v5 = *(void *)(i + 16);
    if (v5 != v3)
    {
      *(void *)(result + 16) = v5;
      uint64_t result = *(void *)(result + 8);
      uint64_t v3 = *a3;
    }
  }
  return result;
}

uint64_t *std::list<long long>::erase(uint64_t a1, uint64_t *__p, uint64_t *a3)
{
  if (__p != a3)
  {
    uint64_t v5 = *a3;
    uint64_t v6 = *__p;
    *(void *)(v6 + 8) = *(void *)(*a3 + 8);
    **(void **)(v5 + 8) = v6;
    do
    {
      uint64_t v7 = (uint64_t *)__p[1];
      --*(void *)(a1 + 16);
      operator delete(__p);
      std::string __p = v7;
    }
    while (v7 != a3);
  }
  return a3;
}

void std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__erase_unique<unsigned long>(uint64_t **a1, unint64_t a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 1);
  uint64_t v3 = a1[1];
  if (v3)
  {
    uint64_t v5 = v4;
    uint64_t v6 = v3;
    do
    {
      unint64_t v7 = v6[4];
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        unint64_t v9 = (uint64_t **)v6;
      }
      else {
        unint64_t v9 = (uint64_t **)(v6 + 1);
      }
      if (v8) {
        uint64_t v5 = v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && v5[4] <= a2)
    {
      unint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          int v11 = v10;
          unint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v5;
        do
        {
          int v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if (*a1 == v5) {
        *a1 = v11;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v3, v5);
      std::__list_imp<long long>::clear(v5 + 5);
      operator delete(v5);
    }
  }
}

void vision::mod::GreedyClustererFacesWithTorso::computeDeltaAfterUpdate(uint64_t a1, void *a2, uint64_t *a3)
{
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = operator new(0x30uLL);
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = 0;
  uint64_t v6 = v5 + 3;
  *uint64_t v5 = &unk_1EF753C40;
  void v5[4] = 0;
  v5[5] = 0;
  float v384 = v5 + 3;
  float v387 = (std::__shared_weak_count *)v5;
  atomic_fetch_add_explicit(v5 + 1, 1uLL, memory_order_relaxed);
  *((void *)&v412 + 1) = 0;
  *(void *)&long long v413 = 0;
  *(void *)&long long v412 = (char *)&v412 + 8;
  *((void *)&v409 + 1) = 0;
  *(void *)&long long v410 = 0;
  *(void *)&long long v409 = (char *)&v409 + 8;
  uint64_t v379 = a1;
  uint64_t v7 = a1 + 144;
  BOOL v8 = *(void **)(a1 + 144);
  float v372 = (uint64_t **)v7;
  float v383 = (void *)(v7 + 8);
  if (v8 == (void *)(v7 + 8)) {
    goto LABEL_111;
  }
  do
  {
    uint64_t v9 = v8[5];
    uint64_t v10 = *std::map<long long,unsigned long>::at(*(void **)(v379 + 128), v8[4]);
    int v11 = (uint64_t *)*((void *)&v412 + 1);
    uint64_t v12 = (uint64_t **)&v412 + 1;
    BOOL v13 = (uint64_t **)&v412 + 1;
    if (*((void *)&v412 + 1))
    {
      while (1)
      {
        while (1)
        {
          BOOL v13 = (uint64_t **)v11;
          unsigned int v14 = *((_DWORD *)v11 + 8);
          if (v14 <= v9) {
            break;
          }
          int v11 = *v13;
          uint64_t v12 = v13;
          if (!*v13) {
            goto LABEL_9;
          }
        }
        if (v14 >= v9) {
          break;
        }
        int v11 = v13[1];
        if (!v11)
        {
          uint64_t v12 = v13 + 1;
          goto LABEL_9;
        }
      }
      BOOL v15 = (char *)v13;
    }
    else
    {
LABEL_9:
      BOOL v15 = (char *)operator new(0x40uLL);
      *((_DWORD *)v15 + 8) = v9;
      *((void *)v15 + 7) = 0;
      *((void *)v15 + 6) = 0;
      *((void *)v15 + 5) = v15 + 48;
      *(void *)BOOL v15 = 0;
      *((void *)v15 + 1) = 0;
      *((void *)v15 + 2) = v13;
      *uint64_t v12 = (uint64_t *)v15;
      int64_t v16 = (uint64_t *)v15;
      if (*(void *)v412)
      {
        *(void *)&long long v412 = *(void *)v412;
        int64_t v16 = *v12;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)&v412 + 1), v16);
      *(void *)&long long v413 = v413 + 1;
    }
    std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)v15 + 5, v10, v10);
    uint64_t v17 = a3[1];
    if (!v17) {
      goto LABEL_20;
    }
    while (1)
    {
      unsigned int v18 = *(_DWORD *)(v17 + 28);
      if (v18 <= v10) {
        break;
      }
LABEL_17:
      uint64_t v17 = *(void *)v17;
      if (!v17) {
        goto LABEL_20;
      }
    }
    if (v18 < v10)
    {
      v17 += 8;
      goto LABEL_17;
    }
    std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v409, v9, v9);
LABEL_20:
    uint64_t v19 = (void *)v8[1];
    if (v19)
    {
      do
      {
        uint64_t v20 = v19;
        uint64_t v19 = (void *)*v19;
      }
      while (v19);
    }
    else
    {
      do
      {
        uint64_t v20 = (void *)v8[2];
        BOOL v21 = *v20 == (void)v8;
        BOOL v8 = v20;
      }
      while (!v21);
    }
    BOOL v8 = v20;
  }
  while (v20 != v383);
  uint64_t v22 = (_OWORD *)v412;
  if ((long long *)v412 == (long long *)((char *)&v412 + 8)) {
    goto LABEL_111;
  }
  while (2)
  {
    LODWORD(__p[0]) = *((_DWORD *)v22 + 8);
    std::set<unsigned int>::set[abi:ne180100]((uint64_t *)&__p[1], (void *)v22 + 5);
    std::set<unsigned int>::set[abi:ne180100]((uint64_t *)&__C, &__p[1]);
    uint64_t v23 = (uint64_t *)*((void *)&v409 + 1);
    if (!*((void *)&v409 + 1))
    {
LABEL_32:
      uint64_t v25 = __C;
      if (__C != (char *)v404)
      {
        unsigned int v26 = -1;
        do
        {
          unsigned int v27 = *((_DWORD *)v25 + 7);
          if (v26 == -1)
          {
            unsigned int v26 = *((_DWORD *)v25 + 7);
          }
          else
          {
            if (v27 <= v26) {
              __assert_rtn("computeInitialMergingList", "GreedyWithTorsoClustering.cpp", 2115, "L0 > mergingTo");
            }
            shared_owners = (_DWORD *)v387[1].__shared_owners_;
            unint64_t shared_weak_owners = v387[1].__shared_weak_owners_;
            if ((unint64_t)shared_owners >= shared_weak_owners)
            {
              unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)shared_owners - *v6) >> 2);
              unint64_t v32 = v31 + 1;
              if (v31 + 1 > 0x1555555555555555) {
                std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(shared_weak_owners - *v6) >> 2);
              if (2 * v33 > v32) {
                unint64_t v32 = 2 * v33;
              }
              if (v33 >= 0xAAAAAAAAAAAAAAALL) {
                unint64_t v34 = 0x1555555555555555;
              }
              else {
                unint64_t v34 = v32;
              }
              if (v34) {
                unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,unsigned int,float>>>(v34);
              }
              else {
                uint64_t v35 = 0;
              }
              uint64_t v36 = (unsigned int *)(v34 + 12 * v31);
              *uint64_t v36 = v26;
              v36[1] = v27;
              v36[2] = -1082130432;
              uint64_t v38 = v387[1].__vftable;
              uint64_t v37 = (std::__shared_weak_count_vtbl *)v387[1].__shared_owners_;
              uint64_t v39 = v36;
              if (v37 != v38)
              {
                do
                {
                  uint64_t v40 = *(uint64_t *)((char *)&v37[-1].__get_deleter + 4);
                  uint64_t v37 = (std::__shared_weak_count_vtbl *)((char *)v37 - 12);
                  unsigned int v41 = v37->~__shared_weak_count_0;
                  *(void *)(v39 - 3) = v40;
                  v39 -= 3;
                  void v39[2] = v41;
                }
                while (v37 != v38);
                uint64_t v37 = (std::__shared_weak_count_vtbl *)*v6;
              }
              uint64_t v30 = v36 + 3;
              v387[1].__vftable = (std::__shared_weak_count_vtbl *)v39;
              v387[1].__shared_owners_ = (uint64_t)(v36 + 3);
              v387[1].__shared_weak_owners_ = v34 + 12 * v35;
              if (v37) {
                operator delete(v37);
              }
            }
            else
            {
              _DWORD *shared_owners = v26;
              shared_owners[1] = v27;
              uint64_t v30 = shared_owners + 3;
              shared_owners[2] = -1082130432;
            }
            v387[1].__shared_owners_ = (uint64_t)v30;
          }
          uint64_t v42 = (char *)*((void *)v25 + 1);
          if (v42)
          {
            do
            {
              uint64_t v43 = v42;
              uint64_t v42 = *(char **)v42;
            }
            while (v42);
          }
          else
          {
            do
            {
              uint64_t v43 = (char *)*((void *)v25 + 2);
              BOOL v21 = *(void *)v43 == (void)v25;
              uint64_t v25 = v43;
            }
            while (!v21);
          }
          uint64_t v25 = v43;
        }
        while (v43 != (char *)v404);
      }
      goto LABEL_105;
    }
    while (2)
    {
      unsigned int v24 = *((_DWORD *)v23 + 7);
      if (LODWORD(__p[0]) < v24)
      {
LABEL_31:
        uint64_t v23 = (uint64_t *)*v23;
        if (!v23) {
          goto LABEL_32;
        }
        continue;
      }
      break;
    }
    if (v24 < LODWORD(__p[0]))
    {
      ++v23;
      goto LABEL_31;
    }
    uint64_t v44 = (char *)operator new(0x30uLL);
    *((void *)v44 + 2) = 0;
    *((void *)v44 + 1) = 0;
    *(void *)uint64_t v44 = &unk_1EF753C40;
    *((void *)v44 + 4) = 0;
    *((void *)v44 + 5) = 0;
    *((void *)v44 + 3) = 0;
    v396 = (uint64_t *)(v44 + 24);
    v397 = (uint64_t *)v44;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v44 + 1, 1uLL, memory_order_relaxed);
    vision::mod::GreedyClustererWithTorso::computeMergePairs(v379 + 8, &__C, &__C, &v396, 0);
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v44);
    uint64_t v401 = 0;
    uint64_t v402 = 0;
    v400 = (char *)&v401;
    __int32 v45 = (unsigned int *)*((void *)v44 + 3);
    float v46 = (unsigned int *)*((void *)v44 + 4);
    unsigned int v375 = (std::__shared_weak_count *)v44;
    while (v45 != v46)
    {
      unsigned int v48 = *v45;
      unsigned int v47 = v45[1];
      unsigned int v49 = v45[2];
      std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v400, *v45, *v45);
      std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v400, v47, v47);
      uint64_t v50 = a3[1];
      if (v50)
      {
        uint64_t v51 = a3[1];
        do
        {
          unsigned int v52 = *(_DWORD *)(v51 + 28);
          if (v48 >= v52)
          {
            if (v52 >= v48) {
              goto LABEL_90;
            }
            v51 += 8;
          }
          uint64_t v51 = *(void *)v51;
        }
        while (v51);
        do
        {
          unsigned int v53 = *(_DWORD *)(v50 + 28);
          if (v47 >= v53)
          {
            if (v53 >= v47) {
              goto LABEL_90;
            }
            v50 += 8;
          }
          uint64_t v50 = *(void *)v50;
        }
        while (v50);
      }
      uint64_t v55 = (_DWORD *)v387[1].__shared_owners_;
      unint64_t v54 = v387[1].__shared_weak_owners_;
      if ((unint64_t)v55 >= v54)
      {
        unint64_t v57 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v55 - *v384) >> 2);
        unint64_t v58 = v57 + 1;
        if (v57 + 1 > 0x1555555555555555) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v54 - *v384) >> 2);
        if (2 * v59 > v58) {
          unint64_t v58 = 2 * v59;
        }
        if (v59 >= 0xAAAAAAAAAAAAAAALL) {
          unint64_t v60 = 0x1555555555555555;
        }
        else {
          unint64_t v60 = v58;
        }
        if (v60) {
          unint64_t v60 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,unsigned int,float>>>(v60);
        }
        else {
          uint64_t v61 = 0;
        }
        uint64_t v62 = (unsigned int *)(v60 + 12 * v57);
        *uint64_t v62 = v48;
        v62[1] = v47;
        v62[2] = v49;
        uint64_t v64 = v387[1].__vftable;
        uint64_t v63 = (std::__shared_weak_count_vtbl *)v387[1].__shared_owners_;
        uint64_t v65 = v62;
        if (v63 != v64)
        {
          do
          {
            uint64_t v66 = *(uint64_t *)((char *)&v63[-1].__get_deleter + 4);
            uint64_t v63 = (std::__shared_weak_count_vtbl *)((char *)v63 - 12);
            unsigned int v67 = v63->~__shared_weak_count_0;
            *(void *)(v65 - 3) = v66;
            v65 -= 3;
            v65[2] = v67;
          }
          while (v63 != v64);
          uint64_t v63 = (std::__shared_weak_count_vtbl *)*v384;
        }
        float v56 = v62 + 3;
        v387[1].__vftable = (std::__shared_weak_count_vtbl *)v65;
        v387[1].__shared_owners_ = (uint64_t)(v62 + 3);
        v387[1].__shared_weak_owners_ = v60 + 12 * v61;
        if (v63) {
          operator delete(v63);
        }
      }
      else
      {
        *uint64_t v55 = v48;
        v55[1] = v47;
        float v56 = v55 + 3;
        v55[2] = v49;
      }
      v387[1].__shared_owners_ = (uint64_t)v56;
LABEL_90:
      v45 += 3;
    }
    uint64_t v68 = __C;
    uint64_t v6 = v384;
    if (__C != (char *)v404)
    {
      do
      {
        unsigned int v69 = *((_DWORD *)v68 + 7);
        for (uint64_t i = v401; i; uint64_t i = *(char **)i)
        {
          unsigned int v71 = *((_DWORD *)i + 7);
          if (v69 >= v71)
          {
            if (v71 >= v69) {
              goto LABEL_98;
            }
            i += 8;
          }
        }
        std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>(a3, v69, *((_DWORD *)v68 + 7));
LABEL_98:
        float v72 = (char *)*((void *)v68 + 1);
        if (v72)
        {
          do
          {
            int64_t v73 = v72;
            float v72 = *(char **)v72;
          }
          while (v72);
        }
        else
        {
          do
          {
            int64_t v73 = (char *)*((void *)v68 + 2);
            BOOL v21 = *(void *)v73 == (void)v68;
            uint64_t v68 = v73;
          }
          while (!v21);
        }
        uint64_t v68 = v73;
      }
      while (v73 != (char *)v404);
    }
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v401);
    std::__shared_weak_count::__release_shared[abi:nn180100](v375);
LABEL_105:
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v404[0]);
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy((void *)v392);
    uint64_t v74 = (void *)*((void *)v22 + 1);
    if (v74)
    {
      do
      {
        unint64_t v75 = v74;
        uint64_t v74 = (void *)*v74;
      }
      while (v74);
    }
    else
    {
      do
      {
        unint64_t v75 = (_OWORD *)*((void *)v22 + 2);
        BOOL v21 = *(void *)v75 == (void)v22;
        uint64_t v22 = v75;
      }
      while (!v21);
    }
    uint64_t v22 = v75;
    if (v75 != (long long *)((char *)&v412 + 8)) {
      continue;
    }
    break;
  }
LABEL_111:
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((void **)&v409 + 1));
  std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(*((void **)&v412 + 1));
  std::__shared_weak_count::__release_shared[abi:nn180100](v387);
  unint64_t p_shared_owners = (unint64_t)&v387->__shared_owners_;
  atomic_fetch_add_explicit(&v387->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v77 = v379;
  uint64_t v78 = v379 + 8;
  atomic_fetch_add_explicit(&v387->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v79 = *(void *)(v379 + 72);
  uint64_t v80 = *(void *)(v79 + 48);
  if (*(void *)(v79 + 56) != v80)
  {
    unint64_t v81 = 0;
    *((void *)&v412 + 1) = 0;
    *(void *)&long long v413 = 0;
    *(void *)&long long v412 = (char *)&v412 + 8;
    uint64_t v82 = *a3;
    while (1)
    {
      unsigned int v83 = *(_DWORD *)(v80 + 4 * v81);
      if ((uint64_t *)v82 == a3 + 1 || v83 != *(_DWORD *)(v82 + 28))
      {
        std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v412, v83, v83);
        uint64_t v79 = *(void *)(v379 + 72);
      }
      else
      {
        uint64_t v84 = *(void **)(v82 + 8);
        if (v84)
        {
          do
          {
            uint64_t v82 = (uint64_t)v84;
            uint64_t v84 = (void *)*v84;
          }
          while (v84);
        }
        else
        {
          do
          {
            uint64_t v85 = v82;
            uint64_t v82 = *(void *)(v82 + 16);
          }
          while (*(void *)v82 != v85);
        }
      }
      ++v81;
      uint64_t v80 = *(void *)(v79 + 48);
      if (v81 >= (*(void *)(v79 + 56) - v80) >> 2)
      {
        v400 = (char *)v6;
        uint64_t v401 = (char *)v387;
        atomic_fetch_add_explicit(&v387->__shared_owners_, 1uLL, memory_order_relaxed);
        vision::mod::GreedyClustererWithTorso::computeMergePairs(v78, &v412, a3, (uint64_t **)&v400, 1);
        std::__shared_weak_count::__release_shared[abi:nn180100](v387);
        v396 = v6;
        v397 = (uint64_t *)v387;
        atomic_fetch_add_explicit(&v387->__shared_owners_, 1uLL, memory_order_relaxed);
        vision::mod::GreedyClustererWithTorso::computeMergePairs(v78, a3, a3, &v396, 0);
        std::__shared_weak_count::__release_shared[abi:nn180100](v387);
        v395[0] = v6;
        v395[1] = &v387->__vftable;
        atomic_fetch_add_explicit(&v387->__shared_owners_, 1uLL, memory_order_relaxed);
        vision::mod::GreedyClustererWithTorso::getConnectedComponentsWithoutFiltering((uint64_t *)&v409, v78, v395);
        std::__shared_weak_count::__release_shared[abi:nn180100](v387);
        uint64_t v86 = *(void *)(v379 + 72);
        *(_OWORD *)std::string __p = 0u;
        long long v392 = 0u;
        long long v393 = 0u;
        uint64_t v394 = 0;
        uint64_t v87 = *(void **)(v86 + 72);
        if (v87) {
          cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createDeepCopy(v87);
        }
        exception = __cxa_allocate_exception(8uLL);
        void *exception = 5215;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
    }
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v387);
  atomic_fetch_add_explicit((atomic_ullong *volatile)p_shared_owners, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit((atomic_ullong *volatile)p_shared_owners, 1uLL, memory_order_relaxed);
  v88.i32[0] = 0;
  *(_OWORD *)std::string __p = 0u;
  long long v392 = 0u;
  LODWORD(v393) = 1065353216;
  uint64_t v89 = v387[1].__vftable;
  uint64_t v90 = (std::__shared_weak_count_vtbl *)v387[1].__shared_owners_;
  if (v89 != v90)
  {
    while (2)
    {
      unint64_t v91 = HIDWORD(v89->~__shared_weak_count);
      LODWORD(v412) = v89->~__shared_weak_count;
      unint64_t v92 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)__p, v412, &v412);
      uint64_t v93 = v92;
      unint64_t v94 = v92[4];
      if (v94)
      {
        uint8x8_t v88 = (uint8x8_t)vcnt_s8((int8x8_t)v94);
        v88.i16[0] = vaddlv_u8(v88);
        if (v88.u32[0] > 1uLL)
        {
          unint64_t p_shared_owners = v91;
          if (v94 <= v91) {
            unint64_t p_shared_owners = v91 % v94;
          }
        }
        else
        {
          unint64_t p_shared_owners = (v94 - 1) & v91;
        }
        uint64_t v95 = *(uint64_t ***)(v92[3] + 8 * p_shared_owners);
        if (v95)
        {
          for (vDSP_Length j = *v95; j; vDSP_Length j = (uint64_t *)*j)
          {
            unint64_t v97 = j[1];
            if (v97 == v91)
            {
              if (*((_DWORD *)j + 4) == v91) {
                goto LABEL_197;
              }
            }
            else
            {
              if (v88.u32[0] > 1uLL)
              {
                if (v97 >= v94) {
                  v97 %= v94;
                }
              }
              else
              {
                v97 &= v94 - 1;
              }
              if (v97 != p_shared_owners) {
                break;
              }
            }
          }
        }
      }
      unsigned int v98 = operator new(0x18uLL);
      void *v98 = 0;
      v98[1] = v91;
      *((_DWORD *)v98 + 4) = v91;
      *(float *)v88.i32 = (float)(unint64_t)(v93[6] + 1);
      float v99 = *((float *)v93 + 14);
      if (!v94 || (float)(v99 * (float)v94) < *(float *)v88.i32)
      {
        BOOL v100 = (v94 & (v94 - 1)) != 0;
        if (v94 < 3) {
          BOOL v100 = 1;
        }
        unint64_t v101 = v100 | (2 * v94);
        *(float *)v88.i32 = *(float *)v88.i32 / v99;
        unint64_t v102 = vcvtps_u32_f32(*(float *)v88.i32);
        if (v101 <= v102) {
          int8x8_t prime = (int8x8_t)v102;
        }
        else {
          int8x8_t prime = (int8x8_t)v101;
        }
        if (*(void *)&prime == 1)
        {
          int8x8_t prime = (int8x8_t)2;
        }
        else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
        {
          int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        }
        unint64_t v94 = v93[4];
        if (*(void *)&prime <= v94)
        {
          if (*(void *)&prime < v94)
          {
            unint64_t v109 = vcvtps_u32_f32((float)(unint64_t)v93[6] / *((float *)v93 + 14));
            if (v94 < 3 || (uint8x8_t v88 = (uint8x8_t)vcnt_s8((int8x8_t)v94), v88.i16[0] = vaddlv_u8(v88), v88.u32[0] > 1uLL))
            {
              unint64_t v109 = std::__next_prime(v109);
            }
            else
            {
              uint64_t v110 = 1 << -(char)__clz(v109 - 1);
              if (v109 >= 2) {
                unint64_t v109 = v110;
              }
            }
            if (*(void *)&prime <= v109) {
              int8x8_t prime = (int8x8_t)v109;
            }
            if (*(void *)&prime >= v94)
            {
              unint64_t v94 = v93[4];
            }
            else
            {
              if (prime) {
                goto LABEL_153;
              }
              float32x4_t v117 = (void *)v93[3];
              v93[3] = 0;
              if (v117) {
                operator delete(v117);
              }
              unint64_t v94 = 0;
              v93[4] = 0;
            }
          }
        }
        else
        {
LABEL_153:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v104 = operator new(8 * *(void *)&prime);
          uint64_t v105 = (void *)v93[3];
          v93[3] = (uint64_t)v104;
          if (v105) {
            operator delete(v105);
          }
          uint64_t v106 = 0;
          v93[4] = (uint64_t)prime;
          do
            *(void *)(v93[3] + 8 * v106++) = 0;
          while (*(void *)&prime != v106);
          long long v107 = (void *)v93[5];
          if (v107)
          {
            unint64_t v108 = v107[1];
            uint8x8_t v88 = (uint8x8_t)vcnt_s8(prime);
            v88.i16[0] = vaddlv_u8(v88);
            if (v88.u32[0] > 1uLL)
            {
              if (v108 >= *(void *)&prime) {
                v108 %= *(void *)&prime;
              }
            }
            else
            {
              v108 &= *(void *)&prime - 1;
            }
            *(void *)(v93[3] + 8 * v108) = v93 + 5;
            uint64_t v111 = (void *)*v107;
            if (*v107)
            {
              do
              {
                unint64_t v112 = v111[1];
                if (v88.u32[0] > 1uLL)
                {
                  if (v112 >= *(void *)&prime) {
                    v112 %= *(void *)&prime;
                  }
                }
                else
                {
                  v112 &= *(void *)&prime - 1;
                }
                if (v112 != v108)
                {
                  uint64_t v113 = v93[3];
                  if (!*(void *)(v113 + 8 * v112))
                  {
                    *(void *)(v113 + 8 * v112) = v107;
                    goto LABEL_178;
                  }
                  *long long v107 = *v111;
                  *uint64_t v111 = **(void **)(v93[3] + 8 * v112);
                  **(void **)(v93[3] + 8 * v112) = v111;
                  uint64_t v111 = v107;
                }
                unint64_t v112 = v108;
LABEL_178:
                long long v107 = v111;
                uint64_t v111 = (void *)*v111;
                unint64_t v108 = v112;
              }
              while (v111);
            }
          }
          unint64_t v94 = (unint64_t)prime;
        }
        if ((v94 & (v94 - 1)) != 0)
        {
          if (v94 <= v91) {
            unint64_t p_shared_owners = v91 % v94;
          }
          else {
            unint64_t p_shared_owners = v91;
          }
        }
        else
        {
          unint64_t p_shared_owners = (v94 - 1) & v91;
        }
      }
      uint64_t v114 = v93[3];
      int v115 = *(void **)(v114 + 8 * p_shared_owners);
      if (v115)
      {
        void *v98 = *v115;
      }
      else
      {
        void *v98 = v93[5];
        v93[5] = (uint64_t)v98;
        *(void *)(v114 + 8 * p_shared_owners) = v93 + 5;
        if (!*v98)
        {
LABEL_196:
          ++v93[6];
LABEL_197:
          uint64_t v89 = (std::__shared_weak_count_vtbl *)((char *)v89 + 12);
          if (v89 != v90) {
            continue;
          }
          goto LABEL_208;
        }
        unint64_t v116 = *(void *)(*v98 + 8);
        if ((v94 & (v94 - 1)) != 0)
        {
          if (v116 >= v94) {
            v116 %= v94;
          }
        }
        else
        {
          v116 &= v94 - 1;
        }
        int v115 = (void *)(v93[3] + 8 * v116);
      }
      break;
    }
    *int v115 = v98;
    goto LABEL_196;
  }
LABEL_208:
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *,false>(0, 0, 0, 1, *(float *)v88.i32);
  uint64_t v118 = (uint64_t)v387[1].__vftable;
  unint64_t v119 = v387[1].__shared_owners_;
  unint64_t v120 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v119 - v118) >> 2));
  if (v119 == v118) {
    uint64_t v121 = 0;
  }
  else {
    uint64_t v121 = v120;
  }
  std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*,false>(v118, v119, v121, 1);
  uint64_t v122 = (std::__shared_weak_count *)operator new(0x30uLL);
  v122->__shared_owners_ = 0;
  v122->__shared_weak_owners_ = 0;
  v122[1].__vftable = 0;
  float v377 = (char *)&v122[1];
  v122->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753C40;
  v122[1].__shared_owners_ = 0;
  v122[1].__shared_weak_owners_ = 0;
  long long v412 = 0u;
  long long v413 = 0u;
  int v414 = 1065353216;
  long long v409 = 0u;
  long long v410 = 0u;
  int v411 = 1065353216;
  LODWORD(v395[0]) = 0;
  srand(0x7C0u);
  float v385 = v122;
  float v123 = v387[1].__vftable;
  uint64_t v381 = v387[1].__shared_owners_;
  if (v123 != (std::__shared_weak_count_vtbl *)v381)
  {
    while (1)
    {
      unsigned int v125 = v123->~__shared_weak_count;
      float v126 = *(float *)&v123->~__shared_weak_count_0;
      unsigned int v407 = HIDWORD(v123->~__shared_weak_count);
      unsigned int v124 = v407;
      unsigned int v408 = v125;
      long long v127 = v409;
      long long v128 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v409, *((unint64_t *)&v409 + 1), v125);
      long long v129 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v127, *((unint64_t *)&v127 + 1), v124);
      if (v128) {
        int v130 = *((_DWORD *)v128 + 5);
      }
      else {
        int v130 = -1;
      }
      float v131 = &v385->__vftable;
      if (v129) {
        int v132 = *((_DWORD *)v129 + 5);
      }
      else {
        int v132 = -1;
      }
      if (v130 == -1 && v132 == -1)
      {
        double v133 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, v395[0], v395);
        uint64_t v134 = v133;
        double v136 = (unsigned int *)v133[4];
        unint64_t v135 = v133[5];
        if ((unint64_t)v136 >= v135)
        {
          int v162 = (unsigned int *)v133[3];
          uint64_t v163 = v136 - v162;
          unint64_t v164 = v163 + 1;
          if ((unint64_t)(v163 + 1) >> 62) {
            goto LABEL_572;
          }
          uint64_t v165 = v135 - (void)v162;
          if (v165 >> 1 > v164) {
            unint64_t v164 = v165 >> 1;
          }
          BOOL v309 = (unint64_t)v165 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v166 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v309) {
            unint64_t v166 = v164;
          }
          if (v166)
          {
            unint64_t v166 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v166);
            int v162 = (unsigned int *)v134[3];
            double v136 = (unsigned int *)v134[4];
          }
          else
          {
            uint64_t v167 = 0;
          }
          float v184 = (unsigned int *)(v166 + 4 * v163);
          *float v184 = v125;
          uint64_t v137 = v184 + 1;
          while (v136 != v162)
          {
            unsigned int v185 = *--v136;
            *--float v184 = v185;
          }
          v134[3] = v184;
          v134[4] = v137;
          v134[5] = v166 + 4 * v167;
          if (v162) {
            operator delete(v162);
          }
        }
        else
        {
          *double v136 = v125;
          uint64_t v137 = v136 + 1;
        }
        v134[4] = v137;
        int v186 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, v395[0], v395);
        float v187 = v186;
        float v189 = (char *)v186[4];
        unint64_t v188 = v186[5];
        if ((unint64_t)v189 >= v188)
        {
          float v191 = (char *)v186[3];
          uint64_t v192 = (v189 - v191) >> 2;
          unint64_t v193 = v192 + 1;
          if ((unint64_t)(v192 + 1) >> 62) {
LABEL_572:
          }
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          uint64_t v194 = v188 - (void)v191;
          if (v194 >> 1 > v193) {
            unint64_t v193 = v194 >> 1;
          }
          BOOL v309 = (unint64_t)v194 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v195 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v309) {
            unint64_t v195 = v193;
          }
          if (v195)
          {
            unint64_t v195 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v195);
            float v191 = (char *)v187[3];
            float v189 = (char *)v187[4];
          }
          else
          {
            uint64_t v196 = 0;
          }
          float32x2_t v197 = (_DWORD *)(v195 + 4 * v192);
          *float32x2_t v197 = v407;
          float v190 = v197 + 1;
          while (v189 != v191)
          {
            int v198 = *((_DWORD *)v189 - 1);
            v189 -= 4;
            *--float32x2_t v197 = v198;
          }
          v187[3] = v197;
          v187[4] = v190;
          v187[5] = v195 + 4 * v196;
          if (v191) {
            operator delete(v191);
          }
        }
        else
        {
          *(_DWORD *)float v189 = v407;
          float v190 = v189 + 4;
        }
        v187[4] = v190;
        int v199 = (int)v395[0];
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v409, v408, &v408)+ 5) = v199;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v409, v407, &v407)+ 5) = v199;
        LODWORD(v395[0]) = v199 + 1;
        unint64_t v201 = v385[1].__shared_owners_;
        unint64_t v200 = v385[1].__shared_weak_owners_;
        if (v201 >= v200)
        {
          unint64_t v202 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v201 - *(void *)v377) >> 2);
          unint64_t v203 = v202 + 1;
          if (v202 + 1 > 0x1555555555555555) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v204 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v200 - *(void *)v377) >> 2);
          if (2 * v204 > v203) {
            unint64_t v203 = 2 * v204;
          }
          if (v204 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v205 = 0x1555555555555555;
          }
          else {
            unint64_t v205 = v203;
          }
          if (v205) {
            unint64_t v205 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,unsigned int,float>>>(v205);
          }
          else {
            uint64_t v206 = 0;
          }
          unint64_t v207 = v205 + 12 * v202;
          *(_DWORD *)unint64_t v207 = v125;
          *(_DWORD *)(v207 + 4) = v124;
          *(float *)(v207 + 8) = v126;
          uint64_t v209 = v385[1].__vftable;
          int v208 = (std::__shared_weak_count_vtbl *)v385[1].__shared_owners_;
          unint64_t v210 = v207;
          if (v208 != v209)
          {
            do
            {
              uint64_t v211 = *(uint64_t *)((char *)&v208[-1].__get_deleter + 4);
              int v208 = (std::__shared_weak_count_vtbl *)((char *)v208 - 12);
              int v212 = (int)v208->~__shared_weak_count_0;
              *(void *)(v210 - 12) = v211;
              v210 -= 12;
              *(_DWORD *)(v210 + 8) = v212;
            }
            while (v208 != v209);
            goto LABEL_429;
          }
          goto LABEL_430;
        }
LABEL_330:
        *(_DWORD *)unint64_t v201 = v125;
        *(_DWORD *)(v201 + 4) = v124;
        goto LABEL_331;
      }
      if (v130 == -1) {
        break;
      }
      if (v132 == -1)
      {
        LODWORD(__C) = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v409, v125, &v408)+ 5);
        float v173 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, __C, &__C);
        float v174 = v173;
        float v176 = (unsigned int *)v173[4];
        unint64_t v175 = v173[5];
        if ((unint64_t)v176 >= v175)
        {
          uint64_t v213 = (unsigned int *)v173[3];
          uint64_t v214 = v176 - v213;
          unint64_t v215 = v214 + 1;
          if ((unint64_t)(v214 + 1) >> 62) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v216 = v175 - (void)v213;
          if (v216 >> 1 > v215) {
            unint64_t v215 = v216 >> 1;
          }
          BOOL v309 = (unint64_t)v216 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v217 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v309) {
            unint64_t v217 = v215;
          }
          if (v217)
          {
            unint64_t v217 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v217);
            uint64_t v213 = (unsigned int *)v174[3];
            float v176 = (unsigned int *)v174[4];
          }
          else
          {
            uint64_t v218 = 0;
          }
          int v237 = (unsigned int *)(v217 + 4 * v214);
          *int v237 = v124;
          float v177 = v237 + 1;
          while (v176 != v213)
          {
            unsigned int v238 = *--v176;
            *--int v237 = v238;
          }
          v174[3] = v237;
          v174[4] = v177;
          v174[5] = v217 + 4 * v218;
          if (v213) {
            operator delete(v213);
          }
        }
        else
        {
          *float v176 = v124;
          float v177 = v176 + 1;
        }
        v174[4] = v177;
        int v239 = (int)__C;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v409, v407, &v407)+ 5) = v239;
        unint64_t v201 = v385[1].__shared_owners_;
        unint64_t v240 = v385[1].__shared_weak_owners_;
        if (v201 < v240) {
          goto LABEL_330;
        }
        unint64_t v242 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v201 - *(void *)v377) >> 2);
        unint64_t v243 = v242 + 1;
        if (v242 + 1 > 0x1555555555555555) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v244 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v240 - *(void *)v377) >> 2);
        if (2 * v244 > v243) {
          unint64_t v243 = 2 * v244;
        }
        if (v244 >= 0xAAAAAAAAAAAAAAALL) {
          unint64_t v205 = 0x1555555555555555;
        }
        else {
          unint64_t v205 = v243;
        }
        if (v205) {
          unint64_t v205 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,unsigned int,float>>>(v205);
        }
        else {
          uint64_t v206 = 0;
        }
        unint64_t v207 = v205 + 12 * v242;
        *(_DWORD *)unint64_t v207 = v125;
        *(_DWORD *)(v207 + 4) = v124;
        *(float *)(v207 + 8) = v126;
        float v245 = v385[1].__vftable;
        int v208 = (std::__shared_weak_count_vtbl *)v385[1].__shared_owners_;
        unint64_t v210 = v207;
        if (v208 == v245) {
          goto LABEL_430;
        }
        do
        {
          uint64_t v246 = *(uint64_t *)((char *)&v208[-1].__get_deleter + 4);
          int v208 = (std::__shared_weak_count_vtbl *)((char *)v208 - 12);
          int v247 = (int)v208->~__shared_weak_count_0;
          *(void *)(v210 - 12) = v246;
          v210 -= 12;
          *(_DWORD *)(v210 + 8) = v247;
        }
        while (v208 != v245);
LABEL_429:
        int v208 = *(std::__shared_weak_count_vtbl **)v377;
        goto LABEL_430;
      }
      unsigned int v373 = v124;
      unsigned int v138 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v409, v125, &v408)+ 5);
      unsigned int v406 = v138;
      unsigned int v139 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v409, v124, &v407)+ 5);
      unsigned int v405 = v139;
      if (v138 != v139)
      {
        BOOL v140 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, v138, &v406);
        uint64_t v142 = v140[3];
        uint64_t v141 = v140[4];
        int v143 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, v139, &v405);
        if (v126 > 0.0)
        {
          uint64_t v145 = v143[3];
          uint64_t v144 = v143[4];
          uint64_t v146 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, v138, &v406);
          float __C = 0;
          v404[0] = 0;
          v404[1] = 0;
          std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&__C, (const void *)v146[3], v146[4], (uint64_t)(v146[4] - v146[3]) >> 2);
          BOOL v147 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, v139, &v405);
          v400 = 0;
          uint64_t v401 = 0;
          uint64_t v402 = 0;
          std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&v400, (const void *)v147[3], v147[4], (uint64_t)(v147[4] - v147[3]) >> 2);
          unint64_t v148 = (unint64_t)((double)(unint64_t)((v141 - v142) >> 2)
                                  * 0.25
                                  * (double)(unint64_t)((v144 - v145) >> 2));
          if (v148 >= 0x32)
          {
            unsigned int v371 = v139;
            uint64_t v149 = 0;
            float v374 = __C;
            unint64_t v150 = ((char *)v404[0] - __C) >> 2;
            float v376 = (uint64_t *)v400;
            unint64_t v151 = (v401 - v400) >> 2;
            int v152 = 50;
            while (1)
            {
              int v153 = rand();
              int v154 = rand();
              unint64_t v155 = (v153 % v150);
              if (v150 <= v155) {
                std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
              }
              unint64_t v156 = (v154 % v151);
              unsigned int v157 = *(_DWORD *)&v374[4 * v155];
              unsigned int v399 = v157;
              if (v151 <= v156) {
                std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
              }
              unsigned int v398 = *((_DWORD *)v376 + v156);
              unsigned int v158 = v398;
              int v159 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)__p, v157, &v399);
              if (std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v159 + 3, v158)|| (int v160 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)__p, v158, &v398), std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v160 + 3, v157)))
              {
                if ((unint64_t)++v149 > 0xB) {
                  break;
                }
              }
              if (!--v152) {
                goto LABEL_234;
              }
            }
            char v161 = 0;
            uint64_t v77 = v379;
            unsigned int v139 = v371;
            uint64_t v249 = v374;
            int v248 = v376;
            goto LABEL_349;
          }
          float v374 = __C;
          float v376 = (uint64_t *)v400;
          uint64_t v370 = (unsigned int *)v404[0];
          if (__C == (char *)v404[0])
          {
            char v161 = 1;
          }
          else
          {
            unsigned int v371 = v139;
            uint64_t v229 = 0;
            float v230 = v401;
            float v231 = (unsigned int *)__C;
LABEL_315:
            unsigned int v232 = *v231;
            unsigned int v399 = *v231;
            for (int k = v376; ; int k = (uint64_t *)((char *)k + 4))
            {
              if (k == (uint64_t *)v230)
              {
                if (++v231 == v370)
                {
LABEL_234:
                  char v161 = 1;
                  goto LABEL_345;
                }
                goto LABEL_315;
              }
              unsigned int v398 = *(_DWORD *)k;
              unsigned int v234 = v398;
              float v235 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)__p, v232, &v399);
              if (!std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v235 + 3, v234))
              {
                int v236 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)__p, v234, &v398);
                if (!std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v236 + 3, v232))continue; {
              }
                }
              if (++v229 >= v148) {
                break;
              }
            }
            char v161 = 0;
LABEL_345:
            uint64_t v77 = v379;
            unsigned int v139 = v371;
          }
          uint64_t v249 = v374;
          int v248 = v376;
          if (v376) {
LABEL_349:
          }
            operator delete(v248);
          if (v249) {
            operator delete(v249);
          }
          if (v161) {
            goto LABEL_433;
          }
        }
        int v250 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, v139, &v405);
        float32x2_t v251 = (int *)v250[3];
        int v252 = (int *)v250[4];
        if (v251 != v252)
        {
          do
          {
            int v253 = *v251;
            LODWORD(__C) = *v251;
            int v254 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, v138, &v406);
            int v255 = v254;
            int v257 = (char *)v254[4];
            unint64_t v256 = v254[5];
            if ((unint64_t)v257 >= v256)
            {
              float32x2_t v259 = (char *)v254[3];
              uint64_t v260 = (v257 - v259) >> 2;
              unint64_t v261 = v260 + 1;
              if ((unint64_t)(v260 + 1) >> 62) {
                std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v262 = v256 - (void)v259;
              if (v262 >> 1 > v261) {
                unint64_t v261 = v262 >> 1;
              }
              BOOL v309 = (unint64_t)v262 >= 0x7FFFFFFFFFFFFFFCLL;
              unint64_t v263 = 0x3FFFFFFFFFFFFFFFLL;
              if (!v309) {
                unint64_t v263 = v261;
              }
              if (v263)
              {
                unint64_t v263 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v263);
                float32x2_t v259 = (char *)v255[3];
                int v257 = (char *)v255[4];
              }
              else
              {
                uint64_t v264 = 0;
              }
              float v265 = (_DWORD *)(v263 + 4 * v260);
              *float v265 = v253;
              int v258 = v265 + 1;
              while (v257 != v259)
              {
                int v266 = *((_DWORD *)v257 - 1);
                v257 -= 4;
                *--float v265 = v266;
              }
              v255[3] = v265;
              v255[4] = v258;
              v255[5] = v263 + 4 * v264;
              if (v259) {
                operator delete(v259);
              }
            }
            else
            {
              *(_DWORD *)int v257 = v253;
              int v258 = v257 + 4;
            }
            v255[4] = v258;
            unsigned int v138 = v406;
            *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v409, __C, &__C)+ 5) = v138;
            ++v251;
          }
          while (v251 != v252);
          unsigned int v139 = v405;
        }
        unint64_t v267 = *((void *)&v412 + 1);
        float v131 = &v385->__vftable;
        if (*((void *)&v412 + 1))
        {
          unint64_t v268 = v139;
          uint8x8_t v269 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v412 + 8));
          v269.i16[0] = vaddlv_u8(v269);
          if (v269.u32[0] > 1uLL)
          {
            unint64_t v270 = v139;
            if (*((void *)&v412 + 1) <= (unint64_t)v139) {
              unint64_t v270 = (unint64_t)v139 % *((void *)&v412 + 1);
            }
          }
          else
          {
            unint64_t v270 = (DWORD2(v412) - 1) & v139;
          }
          int v271 = *(long long ***)(v412 + 8 * v270);
          if (v271)
          {
            float v272 = *v271;
            if (*v271)
            {
              uint64_t v273 = *((void *)&v412 + 1) - 1;
              do
              {
                unint64_t v274 = *((void *)v272 + 1);
                if (v274 == v139)
                {
                  if (*((_DWORD *)v272 + 4) == v139)
                  {
                    if (v269.u32[0] > 1uLL)
                    {
                      if (*((void *)&v412 + 1) <= (unint64_t)v139) {
                        unint64_t v268 = (unint64_t)v139 % *((void *)&v412 + 1);
                      }
                    }
                    else
                    {
                      unint64_t v268 = v273 & v139;
                    }
                    float v275 = *(long long **)(v412 + 8 * v268);
                    do
                    {
                      float v276 = v275;
                      float v275 = *(long long **)v275;
                    }
                    while (v275 != v272);
                    if (v276 == &v413) {
                      goto LABEL_406;
                    }
                    unint64_t v277 = *((void *)v276 + 1);
                    if (v269.u32[0] > 1uLL)
                    {
                      if (v277 >= *((void *)&v412 + 1)) {
                        v277 %= *((void *)&v412 + 1);
                      }
                    }
                    else
                    {
                      v277 &= v273;
                    }
                    if (v277 != v268)
                    {
LABEL_406:
                      if (!*(void *)v272) {
                        goto LABEL_407;
                      }
                      unint64_t v278 = *(void *)(*(void *)v272 + 8);
                      if (v269.u32[0] > 1uLL)
                      {
                        if (v278 >= *((void *)&v412 + 1)) {
                          v278 %= *((void *)&v412 + 1);
                        }
                      }
                      else
                      {
                        v278 &= v273;
                      }
                      if (v278 != v268) {
LABEL_407:
                      }
                        *(void *)(v412 + 8 * v268) = 0;
                    }
                    uint64_t v279 = *(void *)v272;
                    if (*(void *)v272)
                    {
                      unint64_t v280 = *(void *)(v279 + 8);
                      if (v269.u32[0] > 1uLL)
                      {
                        if (v280 >= v267) {
                          v280 %= v267;
                        }
                      }
                      else
                      {
                        v280 &= v273;
                      }
                      if (v280 != v268)
                      {
                        *(void *)(v412 + 8 * v280) = v276;
                        uint64_t v279 = *(void *)v272;
                      }
                    }
                    *(void *)float v276 = v279;
                    *(void *)float v272 = 0;
                    --*((void *)&v413 + 1);
                    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,void *>>>::operator()[abi:ne180100](1, v272);
                    break;
                  }
                }
                else
                {
                  if (v269.u32[0] > 1uLL)
                  {
                    if (v274 >= *((void *)&v412 + 1)) {
                      v274 %= *((void *)&v412 + 1);
                    }
                  }
                  else
                  {
                    v274 &= v273;
                  }
                  if (v274 != v270) {
                    break;
                  }
                }
                float v272 = *(long long **)v272;
              }
              while (v272);
            }
          }
        }
        unint64_t v201 = v385[1].__shared_owners_;
        unint64_t v281 = v385[1].__shared_weak_owners_;
        if (v201 < v281)
        {
          *(_DWORD *)unint64_t v201 = v125;
          *(_DWORD *)(v201 + 4) = v373;
LABEL_331:
          unint64_t v241 = v201 + 12;
          *(float *)(v201 + 8) = v126;
LABEL_432:
          v131[4] = v241;
          goto LABEL_433;
        }
        unint64_t v282 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v201 - *(void *)v377) >> 2);
        unint64_t v283 = v282 + 1;
        if (v282 + 1 > 0x1555555555555555) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v284 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v281 - *(void *)v377) >> 2);
        if (2 * v284 > v283) {
          unint64_t v283 = 2 * v284;
        }
        if (v284 >= 0xAAAAAAAAAAAAAAALL) {
          unint64_t v205 = 0x1555555555555555;
        }
        else {
          unint64_t v205 = v283;
        }
        if (v205) {
          unint64_t v205 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,unsigned int,float>>>(v205);
        }
        else {
          uint64_t v206 = 0;
        }
        unint64_t v207 = v205 + 12 * v282;
        *(_DWORD *)unint64_t v207 = v125;
        *(_DWORD *)(v207 + 4) = v373;
        *(float *)(v207 + 8) = v126;
        float32x2_t v285 = v385[1].__vftable;
        int v208 = (std::__shared_weak_count_vtbl *)v385[1].__shared_owners_;
        unint64_t v210 = v207;
        if (v208 != v285)
        {
          do
          {
            uint64_t v286 = *(uint64_t *)((char *)&v208[-1].__get_deleter + 4);
            int v208 = (std::__shared_weak_count_vtbl *)((char *)v208 - 12);
            int v287 = (int)v208->~__shared_weak_count_0;
            *(void *)(v210 - 12) = v286;
            v210 -= 12;
            *(_DWORD *)(v210 + 8) = v287;
          }
          while (v208 != v285);
          goto LABEL_429;
        }
LABEL_430:
        unint64_t v241 = v207 + 12;
        v131[3] = v210;
        v131[4] = v207 + 12;
        v131[5] = v205 + 12 * v206;
        if (v208) {
          operator delete(v208);
        }
        goto LABEL_432;
      }
LABEL_433:
      float v123 = (std::__shared_weak_count_vtbl *)((char *)v123 + 12);
      if (v123 == (std::__shared_weak_count_vtbl *)v381) {
        goto LABEL_434;
      }
    }
    LODWORD(__C) = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v409, v124, &v407)+ 5);
    unint64_t v168 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t *)&v412, __C, &__C);
    int v169 = v168;
    float v171 = (unsigned int *)v168[4];
    unint64_t v170 = v168[5];
    if ((unint64_t)v171 >= v170)
    {
      float v178 = (unsigned int *)v168[3];
      uint64_t v179 = v171 - v178;
      unint64_t v180 = v179 + 1;
      if ((unint64_t)(v179 + 1) >> 62) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v181 = v170 - (void)v178;
      if (v181 >> 1 > v180) {
        unint64_t v180 = v181 >> 1;
      }
      BOOL v309 = (unint64_t)v181 >= 0x7FFFFFFFFFFFFFFCLL;
      unint64_t v182 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v309) {
        unint64_t v182 = v180;
      }
      if (v182)
      {
        unint64_t v182 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v182);
        float v178 = (unsigned int *)v169[3];
        float v171 = (unsigned int *)v169[4];
      }
      else
      {
        uint64_t v183 = 0;
      }
      int v219 = (unsigned int *)(v182 + 4 * v179);
      *int v219 = v125;
      float v172 = v219 + 1;
      while (v171 != v178)
      {
        unsigned int v220 = *--v171;
        *--int v219 = v220;
      }
      v169[3] = v219;
      v169[4] = v172;
      v169[5] = v182 + 4 * v183;
      if (v178) {
        operator delete(v178);
      }
    }
    else
    {
      *float v171 = v125;
      float v172 = v171 + 1;
    }
    v169[4] = v172;
    int v221 = (int)__C;
    *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v409, v408, &v408)+ 5) = v221;
    unint64_t v201 = v385[1].__shared_owners_;
    unint64_t v222 = v385[1].__shared_weak_owners_;
    if (v201 < v222) {
      goto LABEL_330;
    }
    unint64_t v223 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v201 - *(void *)v377) >> 2);
    unint64_t v224 = v223 + 1;
    if (v223 + 1 > 0x1555555555555555) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v225 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v222 - *(void *)v377) >> 2);
    if (2 * v225 > v224) {
      unint64_t v224 = 2 * v225;
    }
    if (v225 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v205 = 0x1555555555555555;
    }
    else {
      unint64_t v205 = v224;
    }
    if (v205) {
      unint64_t v205 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,unsigned int,float>>>(v205);
    }
    else {
      uint64_t v206 = 0;
    }
    unint64_t v207 = v205 + 12 * v223;
    *(_DWORD *)unint64_t v207 = v125;
    *(_DWORD *)(v207 + 4) = v124;
    *(float *)(v207 + 8) = v126;
    int v226 = v385[1].__vftable;
    int v208 = (std::__shared_weak_count_vtbl *)v385[1].__shared_owners_;
    unint64_t v210 = v207;
    if (v208 == v226) {
      goto LABEL_430;
    }
    do
    {
      uint64_t v227 = *(uint64_t *)((char *)&v208[-1].__get_deleter + 4);
      int v208 = (std::__shared_weak_count_vtbl *)((char *)v208 - 12);
      int v228 = (int)v208->~__shared_weak_count_0;
      *(void *)(v210 - 12) = v227;
      v210 -= 12;
      *(_DWORD *)(v210 + 8) = v228;
    }
    while (v208 != v226);
    goto LABEL_429;
  }
LABEL_434:
  if (*((void *)&v392 + 1))
  {
    std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__deallocate_node((void *)v392);
    *(void *)&long long v392 = 0;
    int v288 = (char *)__p[1];
    if (__p[1])
    {
      int v289 = 0;
      do
        *((void *)__p[0] + (void)v289++) = 0;
      while (v288 != v289);
    }
    *((void *)&v392 + 1) = 0;
  }
  if (*((void *)&v413 + 1))
  {
    std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__deallocate_node((void *)v413);
    *(void *)&long long v413 = 0;
    uint64_t v290 = *((void *)&v412 + 1);
    if (*((void *)&v412 + 1))
    {
      uint64_t v291 = 0;
      do
        *(void *)(v412 + 8 * v291++) = 0;
      while (v290 != v291);
    }
    *((void *)&v413 + 1) = 0;
  }
  if (*((void *)&v410 + 1))
  {
    int v292 = (void *)v410;
    if ((void)v410)
    {
      do
      {
        v293 = (void *)*v292;
        operator delete(v292);
        int v292 = v293;
      }
      while (v293);
    }
    *(void *)&long long v410 = 0;
    uint64_t v294 = *((void *)&v409 + 1);
    if (*((void *)&v409 + 1))
    {
      uint64_t v295 = 0;
      do
        *(void *)(v409 + 8 * v295++) = 0;
      while (v294 != v295);
    }
    *((void *)&v410 + 1) = 0;
  }
  float __C = v377;
  v404[0] = &v385->__vftable;
  atomic_fetch_add_explicit(&v385->__shared_owners_, 1uLL, memory_order_relaxed);
  vision::mod::GreedyClustererWithTorso::getConnectedComponentsWithoutFiltering((uint64_t *)&v396, v379 + 8, (void **)&__C);
  std::__shared_weak_count::__release_shared[abi:nn180100](v385);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v409);
  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__deallocate_node((void *)v413);
  float v296 = (void *)v412;
  *(void *)&long long v412 = 0;
  if (v296) {
    operator delete(v296);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v385);
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__deallocate_node((void *)v392);
  float32x2_t v297 = __p[0];
  __p[0] = 0;
  if (v297) {
    operator delete(v297);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v387);
  uint64_t v388 = 0;
  int v389 = 0;
  unint64_t v390 = 0;
  int v298 = v396;
  unsigned int v378 = v397;
  if (v396 != v397)
  {
    v299 = (void *)(v77 + 104);
    do
    {
      __p[0] = 0;
      __p[1] = 0;
      *(void *)&long long v392 = 0;
      std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(__p, (const void *)*v298, v298[1], (v298[1] - *v298) >> 2);
      uint64_t v300 = *(void *)(v77 + 72);
      if (*(unsigned char *)(v300 + 112))
      {
        *(unsigned char *)(v300 + 112) = 0;
        uint64_t v367 = __cxa_allocate_exception(8uLL);
        *uint64_t v367 = 5219;
        __cxa_throw(v367, MEMORY[0x1E4FBA3E0], 0);
      }
      long long v412 = 0uLL;
      *(void *)&long long v413 = 0;
      float v302 = (unsigned int *)__p[0];
      float v301 = (unsigned int *)__p[1];
      if (__p[0] == __p[1])
      {
        unint64_t v303 = 0;
      }
      else
      {
        unint64_t v303 = 0;
        float v304 = (unsigned int *)__p[0];
        do
        {
          if (*v299)
          {
            unint64_t v305 = *v304;
            float v306 = v299;
            unsigned int v307 = (void *)*v299;
            do
            {
              unint64_t v308 = v307[4];
              BOOL v309 = v308 >= v305;
              if (v308 >= v305) {
                float v310 = v307;
              }
              else {
                float v310 = v307 + 1;
              }
              if (v309) {
                float v306 = v307;
              }
              unsigned int v307 = (void *)*v310;
            }
            while (*v310);
            if (v306 != v299 && v306[4] <= v305) {
              v303 += v306[7];
            }
          }
          ++v304;
        }
        while (v304 != __p[1]);
      }
      std::vector<long long>::reserve((void **)&v412, v303);
      float v382 = v298;
      for (uint64_t m = v301; v302 != v301; ++v302)
      {
        float v311 = (void *)*v299;
        if (*v299)
        {
          unint64_t v312 = *v302;
          float v313 = v299;
          do
          {
            unint64_t v314 = v311[4];
            BOOL v315 = v314 >= v312;
            if (v314 >= v312) {
              float v316 = v311;
            }
            else {
              float v316 = v311 + 1;
            }
            if (v315) {
              float v313 = v311;
            }
            float v311 = (void *)*v316;
          }
          while (*v316);
          if (v313 != v299 && v313[4] <= v312)
          {
            int v317 = v313 + 5;
            unsigned int v318 = (void *)v313[6];
            if (v318 != v313 + 5)
            {
              int v319 = (char *)*((void *)&v412 + 1);
              unint64_t v320 = v413;
              float v321 = (char *)v412;
              do
              {
                uint64_t v322 = v318[2];
                if ((unint64_t)v319 >= v320)
                {
                  uint64_t v324 = (v319 - v321) >> 3;
                  unint64_t v325 = v324 + 1;
                  if ((unint64_t)(v324 + 1) >> 61)
                  {
                    *(void *)&long long v413 = v320;
                    *(void *)&long long v412 = v321;
                    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                  }
                  if ((uint64_t)(v320 - (void)v321) >> 2 > v325) {
                    unint64_t v325 = (uint64_t)(v320 - (void)v321) >> 2;
                  }
                  if (v320 - (unint64_t)v321 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v326 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v326 = v325;
                  }
                  if (v326) {
                    unint64_t v326 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v326);
                  }
                  else {
                    uint64_t v327 = 0;
                  }
                  float v328 = (char *)(v326 + 8 * v324);
                  *(void *)float v328 = v322;
                  v323 = v328 + 8;
                  while (v319 != v321)
                  {
                    uint64_t v329 = *((void *)v319 - 1);
                    v319 -= 8;
                    *((void *)v328 - 1) = v329;
                    v328 -= 8;
                  }
                  unint64_t v320 = v326 + 8 * v327;
                  *((void *)&v412 + 1) = v323;
                  if (v321) {
                    operator delete(v321);
                  }
                  float v321 = v328;
                }
                else
                {
                  *(void *)int v319 = v322;
                  v323 = v319 + 8;
                }
                *((void *)&v412 + 1) = v323;
                unsigned int v318 = (void *)v318[1];
                int v319 = v323;
              }
              while (v318 != v317);
              *(void *)&long long v413 = v320;
              *(void *)&long long v412 = v321;
              float v301 = m;
            }
          }
        }
      }
      float v330 = v389;
      if ((unint64_t)v389 >= v390)
      {
        uint64_t v333 = std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>(&v388, (uint64_t)&v412);
        uint64_t v77 = v379;
        unsigned int v332 = v382;
        float v331 = (void *)v412;
      }
      else
      {
        *int v389 = 0;
        v330[1] = 0;
        v330[2] = 0;
        float v331 = (void *)v412;
        std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v330, (const void *)v412, *((uint64_t *)&v412 + 1), (uint64_t)(*((void *)&v412 + 1) - v412) >> 3);
        uint64_t v77 = v379;
        unsigned int v332 = v382;
        uint64_t v333 = (uint64_t)(v330 + 3);
      }
      int v389 = (void *)v333;
      if (v331) {
        operator delete(v331);
      }
      if (__p[0]) {
        operator delete(__p[0]);
      }
      int v298 = v332 + 3;
    }
    while (v298 != v378);
  }
  __p[0] = &v396;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  std::__shared_weak_count::__release_shared[abi:nn180100](v387);
  std::__shared_weak_count::__release_shared[abi:nn180100](v387);
  unint64_t v335 = (unint64_t)v387[1].__vftable;
  float v336 = (float *)v387[1].__shared_owners_;
  unint64_t v337 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v336 - v335) >> 2));
  if (v336 == (float *)v335) {
    uint64_t v338 = 0;
  }
  else {
    uint64_t v338 = v337;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *,false>(v335, v336, v338, 1, v334);
  __p[1] = 0;
  *(void *)&long long v392 = 0;
  __p[0] = &__p[1];
  uint64_t v339 = v388;
  float v340 = v389;
  while ((void *)v339 != v340)
  {
    float v341 = *(uint64_t **)v339;
    float v342 = *(uint64_t **)(v339 + 8);
    if (v342 != *(uint64_t **)v339)
    {
      uint64_t v343 = *v341;
      float v344 = *(uint64_t **)v339;
      do
      {
        uint64_t v346 = *v344++;
        uint64_t v345 = v346;
        if (v346 < v343) {
          uint64_t v343 = v345;
        }
      }
      while (v344 != v342);
      do
      {
        std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)__p, *v341, v341)[5] = v343;
        ++v341;
      }
      while (v341 != v342);
    }
    v339 += 24;
  }
  uint64_t v347 = *(void *)(v77 + 72);
  if (*(unsigned char *)(v347 + 112))
  {
    *(unsigned char *)(v347 + 112) = 0;
    float v368 = __cxa_allocate_exception(8uLL);
    *float v368 = 5219;
    __cxa_throw(v368, MEMORY[0x1E4FBA3E0], 0);
  }
  int v348 = (void **)__p[0];
  if (__p[0] != &__p[1])
  {
    do
    {
      int v349 = v348[4];
      float32x2_t v350 = v383;
      while (1)
      {
        float32x2_t v350 = (void *)*v350;
        if (!v350) {
          break;
        }
        uint64_t v351 = v350[4];
        if ((uint64_t)v349 >= v351)
        {
          if (v351 >= (uint64_t)v349)
          {
            if ((void *)std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v372, (uint64_t)v348[4], (uint64_t *)v348 + 4)[5] == v348[5])goto LABEL_557; {
            int v349 = v348[4];
            }
            break;
          }
          ++v350;
        }
      }
      uint64_t v352 = v348[5];
      int v353 = a2;
      v355 = (void *)a2[1];
      unint64_t v354 = a2[2];
      if ((unint64_t)v355 >= v354)
      {
        int v357 = (void *)*a2;
        uint64_t v358 = ((uint64_t)v355 - *a2) >> 4;
        unint64_t v359 = v358 + 1;
        if ((unint64_t)(v358 + 1) >> 60) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v360 = v354 - (void)v357;
        if (v360 >> 3 > v359) {
          unint64_t v359 = v360 >> 3;
        }
        if ((unint64_t)v360 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v361 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v361 = v359;
        }
        if (v361)
        {
          unint64_t v361 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v361);
          int v357 = (void *)*a2;
          v355 = (void *)a2[1];
        }
        else
        {
          uint64_t v362 = 0;
        }
        v363 = (void *)(v361 + 16 * v358);
        void *v363 = v349;
        v363[1] = v352;
        unsigned int v364 = v363;
        if (v355 == v357)
        {
          int v353 = a2;
        }
        else
        {
          int v353 = a2;
          do
          {
            *((_OWORD *)v364 - 1) = *((_OWORD *)v355 - 1);
            v364 -= 2;
            v355 -= 2;
          }
          while (v355 != v357);
          int v357 = (void *)*a2;
        }
        int v356 = v363 + 2;
        *int v353 = v364;
        v353[1] = v363 + 2;
        v353[2] = v361 + 16 * v362;
        if (v357) {
          operator delete(v357);
        }
      }
      else
      {
        void *v355 = v349;
        v355[1] = v352;
        int v356 = v355 + 2;
      }
      v353[1] = v356;
LABEL_557:
      int v365 = (void **)v348[1];
      if (v365)
      {
        do
        {
          uint64_t v366 = v365;
          int v365 = (void **)*v365;
        }
        while (v365);
      }
      else
      {
        do
        {
          uint64_t v366 = (void **)v348[2];
          BOOL v21 = *v366 == v348;
          int v348 = v366;
        }
        while (!v21);
      }
      int v348 = v366;
    }
    while (v366 != &__p[1]);
  }
  *(unsigned char *)(v77 + 88) = 0;
  if (v372 != (uint64_t **)__p) {
    std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<long long,long long>,std::__tree_node<std::__value_type<long long,long long>,void *> *,long>>((uint64_t)v372, (void *)__p[0], &__p[1]);
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy((void *)__p[1]);
  __p[0] = &v388;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  std::__shared_weak_count::__release_shared[abi:nn180100](v387);
}

void sub_1A3F171F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,char a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45)
{
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(v46 - 240);
  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::~__hash_table(v46 - 192);
  std::__shared_weak_count::__release_shared[abi:nn180100](v45);
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::~__hash_table((uint64_t)&a27);
  std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  _Unwind_Resume(a1);
}

float std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *,false>(unint64_t a1, float *a2, uint64_t a3, char a4, float result)
{
  while (2)
  {
    uint64_t v10 = a2;
    int v11 = a2 - 3;
    uint64_t v12 = (float *)a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = (unint64_t)v12;
          uint64_t v13 = (char *)v10 - (char *)v12;
          uint64_t v14 = 0xAAAAAAAAAAAAAAABLL * (v10 - v12);
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0:
              case 1:
                return result;
              case 2:
                unsigned __int8 v107 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>(v11, a1);
                if (v107 != 129 && (char)v107 < 0)
                {
                  unsigned int v108 = *(_DWORD *)a1;
                  *(float *)a1 = *(a2 - 3);
                  *((_DWORD *)a2 - 3) = v108;
                  int v109 = *(_DWORD *)(a1 + 4);
                  *(float *)(a1 + 4) = *(a2 - 2);
                  *((_DWORD *)a2 - 2) = v109;
                  uint64_t result = *(float *)(a1 + 8);
                  *(float *)(a1 + 8) = *(a2 - 1);
                  *(a2 - 1) = result;
                }
                break;
              case 3:
                uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>((_DWORD *)a1, a1 + 12, (uint64_t)v11);
                break;
              case 4:
                uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(a1, a1 + 12, a1 + 24, (uint64_t)v11);
                break;
              case 5:
                uint64_t result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(a1, a1 + 12, a1 + 24, a1 + 36, (uint64_t)v11);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v13 <= 287)
          {
            uint64_t v110 = (float *)(a1 + 12);
            BOOL v112 = (float *)a1 == v10 || v110 == v10;
            if (a4)
            {
              if (!v112)
              {
                uint64_t v113 = 0;
                uint64_t v114 = (_DWORD *)a1;
                do
                {
                  uint64_t v115 = (uint64_t)v114;
                  uint64_t v114 = v110;
                  unsigned __int8 v116 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>(v110, v115);
                  if (v116 != 129 && (char)v116 < 0)
                  {
                    unsigned int v117 = *v114;
                    unsigned int v118 = *(_DWORD *)(v115 + 16);
                    uint64_t result = *(float *)(v115 + 20);
                    uint64_t v119 = v113;
                    unsigned int v120 = *(_DWORD *)v115;
                    while (1)
                    {
                      uint64_t v121 = (_DWORD *)(a1 + v119);
                      int v122 = *(_DWORD *)(a1 + v119 + 4);
                      v121[3] = v120;
                      v121[4] = v122;
                      v121[5] = *(_DWORD *)(a1 + v119 + 8);
                      if (!v119) {
                        break;
                      }
                      unsigned int v120 = *(v121 - 3);
                      if (v117 < v120) {
                        unsigned __int8 v123 = -1;
                      }
                      else {
                        unsigned __int8 v123 = 1;
                      }
                      if (v117 == v120)
                      {
                        unsigned int v124 = *(_DWORD *)(a1 + v119 - 8);
                        BOOL v125 = v118 == v124;
                        unsigned __int8 v123 = v118 < v124 ? -1 : 1;
                        if (v125)
                        {
                          float v126 = *(float *)(a1 + v119 - 4);
                          if (result == v126) {
                            unsigned __int8 v123 = 0;
                          }
                          else {
                            unsigned __int8 v123 = -127;
                          }
                          if (result > v126) {
                            unsigned __int8 v123 = 1;
                          }
                          if (result < v126) {
                            unsigned __int8 v123 = -1;
                          }
                        }
                      }
                      v119 -= 12;
                      if (v123 == 129 || (v123 & 0x80) == 0)
                      {
                        uint64_t v127 = a1 + v119 + 12;
                        goto LABEL_300;
                      }
                    }
                    uint64_t v127 = a1;
LABEL_300:
                    *(_DWORD *)uint64_t v127 = v117;
                    *(_DWORD *)(v127 + 4) = v118;
                    *(float *)(v127 + 8) = result;
                  }
                  uint64_t v110 = (float *)(v114 + 3);
                  v113 += 12;
                }
                while (v114 + 3 != (_DWORD *)a2);
              }
            }
            else if (!v112)
            {
              unint64_t v170 = (float *)(a1 + 4);
              do
              {
                uint64_t v171 = a1;
                a1 = (unint64_t)v110;
                unsigned __int8 v172 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>(v110, v171);
                if (v172 != 129 && (char)v172 < 0)
                {
                  unsigned int v173 = *(_DWORD *)a1;
                  unsigned int v174 = *(_DWORD *)(v171 + 16);
                  uint64_t result = *(float *)(v171 + 20);
                  unint64_t v175 = v170;
                  unsigned int v176 = *(_DWORD *)v171;
                  do
                  {
                    float v177 = *v175;
                    *((_DWORD *)v175 + 2) = v176;
                    v175[3] = v177;
                    v175[4] = v175[1];
                    unsigned int v176 = *((_DWORD *)v175 - 4);
                    if (v173 < v176) {
                      unsigned __int8 v178 = -1;
                    }
                    else {
                      unsigned __int8 v178 = 1;
                    }
                    if (v173 == v176)
                    {
                      unsigned int v179 = *((_DWORD *)v175 - 3);
                      BOOL v180 = v174 == v179;
                      unsigned __int8 v178 = v174 < v179 ? -1 : 1;
                      if (v180)
                      {
                        float v181 = *(v175 - 2);
                        if (result == v181) {
                          unsigned __int8 v178 = 0;
                        }
                        else {
                          unsigned __int8 v178 = -127;
                        }
                        if (result > v181) {
                          unsigned __int8 v178 = 1;
                        }
                        if (result < v181) {
                          unsigned __int8 v178 = -1;
                        }
                      }
                    }
                    v175 -= 3;
                  }
                  while (v178 != 129 && (v178 & 0x80) != 0);
                  *((_DWORD *)v175 + 2) = v173;
                  *((_DWORD *)v175 + 3) = v174;
                  v175[4] = result;
                }
                uint64_t v110 = (float *)(a1 + 12);
                v170 += 3;
              }
              while ((float *)(a1 + 12) != a2);
            }
            return result;
          }
          if (!a3)
          {
            if ((float *)a1 != v10)
            {
              int64_t v128 = (unint64_t)(v14 - 2) >> 1;
              int64_t v184 = v128;
              do
              {
                int64_t v129 = v128;
                if (v184 >= v128)
                {
                  uint64_t v130 = (2 * v128) | 1;
                  uint64_t v131 = a1 + 12 * v130;
                  if (2 * v128 + 2 < v14)
                  {
                    unsigned __int8 v132 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)(a1 + 12 * v130), v131 + 12);
                    if (v132 != 129 && (v132 & 0x80u) != 0)
                    {
                      v131 += 12;
                      uint64_t v130 = 2 * v129 + 2;
                    }
                  }
                  uint64_t v133 = a1 + 12 * v129;
                  unsigned __int8 v134 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)v131, v133);
                  if (v134 == 129 || ((char)v134 & 0x80000000) == 0)
                  {
                    unsigned int v135 = *(_DWORD *)v133;
                    unsigned int v182 = *(_DWORD *)(v133 + 4);
                    float v136 = *(float *)(v133 + 8);
                    float v137 = *(float *)v131;
                    do
                    {
                      unsigned int v138 = (float *)v133;
                      uint64_t v133 = v131;
                      *unsigned int v138 = v137;
                      v138[1] = *(float *)(v131 + 4);
                      v138[2] = *(float *)(v131 + 8);
                      if (v184 < v130) {
                        break;
                      }
                      uint64_t v139 = (2 * v130) | 1;
                      uint64_t v131 = a1 + 12 * v139;
                      if (2 * v130 + 2 < v14)
                      {
                        unsigned __int8 v140 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)(a1 + 12 * v139), v131 + 12);
                        if (v140 != 129 && (v140 & 0x80u) != 0)
                        {
                          v131 += 12;
                          uint64_t v130 = 2 * v130 + 2;
                        }
                        else
                        {
                          uint64_t v130 = (2 * v130) | 1;
                        }
                      }
                      else
                      {
                        uint64_t v130 = (2 * v130) | 1;
                      }
                      float v137 = *(float *)v131;
                      if (*(_DWORD *)v131 < v135) {
                        unsigned __int8 v141 = -1;
                      }
                      else {
                        unsigned __int8 v141 = 1;
                      }
                      if (LODWORD(v137) == v135)
                      {
                        unsigned int v142 = *(_DWORD *)(v131 + 4);
                        BOOL v143 = v142 == v182;
                        unsigned __int8 v141 = v142 < v182 ? -1 : 1;
                        if (v143)
                        {
                          float v144 = *(float *)(v131 + 8);
                          if (v144 == v136) {
                            unsigned __int8 v141 = 0;
                          }
                          else {
                            unsigned __int8 v141 = -127;
                          }
                          if (v144 > v136) {
                            unsigned __int8 v141 = 1;
                          }
                          if (v144 < v136) {
                            unsigned __int8 v141 = -1;
                          }
                        }
                      }
                    }
                    while (v141 == 129 || (v141 & 0x80) == 0);
                    *(_DWORD *)uint64_t v133 = v135;
                    *(_DWORD *)(v133 + 4) = v182;
                    *(float *)(v133 + 8) = v136;
                  }
                }
                int64_t v128 = v129 - 1;
              }
              while (v129);
              int64_t v145 = v13 / 0xCuLL;
              do
              {
                uint64_t v146 = 0;
                unsigned int v147 = *(_DWORD *)a1;
                int v183 = *(_DWORD *)(a1 + 4);
                int v148 = *(_DWORD *)(a1 + 8);
                uint64_t v149 = v145 - 2;
                if (v145 < 2) {
                  uint64_t v149 = v145 - 1;
                }
                uint64_t v150 = v149 >> 1;
                unint64_t v151 = a1;
                do
                {
                  uint64_t v152 = v151 + 12 * v146 + 12;
                  uint64_t v153 = (2 * v146) | 1;
                  uint64_t v154 = 2 * v146 + 2;
                  if (v154 < v145)
                  {
                    unsigned __int8 v155 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)(v151 + 12 * v146 + 12), v151 + 12 * v146 + 24);
                    if (v155 != 129 && (v155 & 0x80u) != 0)
                    {
                      v152 += 12;
                      uint64_t v153 = v154;
                    }
                  }
                  *(_DWORD *)unint64_t v151 = *(_DWORD *)v152;
                  *(_DWORD *)(v151 + 4) = *(_DWORD *)(v152 + 4);
                  uint64_t result = *(float *)(v152 + 8);
                  *(float *)(v151 + 8) = result;
                  unint64_t v151 = v152;
                  uint64_t v146 = v153;
                }
                while (v153 <= v150);
                if ((float *)v152 == a2 - 3)
                {
                  *(_DWORD *)uint64_t v152 = v147;
                  *(_DWORD *)(v152 + 4) = v183;
                  *(_DWORD *)(v152 + 8) = v148;
                  int64_t v157 = v145 - 1;
                }
                else
                {
                  *(float *)uint64_t v152 = *(a2 - 3);
                  *(float *)(v152 + 4) = *(a2 - 2);
                  uint64_t result = *(a2 - 1);
                  *(float *)(v152 + 8) = result;
                  *((_DWORD *)a2 - 3) = v147;
                  *((_DWORD *)a2 - 2) = v183;
                  *((_DWORD *)a2 - 1) = v148;
                  uint64_t v156 = v152 - a1 + 12;
                  int64_t v157 = v145 - 1;
                  if (v156 >= 13)
                  {
                    unint64_t v158 = (unint64_t)(-2 - 0x5555555555555555 * (v156 >> 2)) >> 1;
                    uint64_t v159 = a1 + 12 * v158;
                    unsigned __int8 v160 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)v159, v152);
                    if (v160 != 129 && (char)v160 < 0)
                    {
                      unsigned int v161 = *(_DWORD *)v152;
                      unsigned int v162 = *(_DWORD *)(v152 + 4);
                      uint64_t result = *(float *)(v152 + 8);
                      float v163 = *(float *)v159;
                      do
                      {
                        unint64_t v164 = (float *)v152;
                        uint64_t v152 = v159;
                        *unint64_t v164 = v163;
                        v164[1] = *(float *)(v159 + 4);
                        v164[2] = *(float *)(v159 + 8);
                        if (!v158) {
                          break;
                        }
                        unint64_t v158 = (v158 - 1) >> 1;
                        uint64_t v159 = a1 + 12 * v158;
                        float v163 = *(float *)v159;
                        if (*(_DWORD *)v159 < v161) {
                          unsigned __int8 v165 = -1;
                        }
                        else {
                          unsigned __int8 v165 = 1;
                        }
                        if (LODWORD(v163) == v161)
                        {
                          unsigned int v166 = *(_DWORD *)(v159 + 4);
                          BOOL v167 = v166 == v162;
                          unsigned __int8 v165 = v166 < v162 ? -1 : 1;
                          if (v167)
                          {
                            float v168 = *(float *)(v159 + 8);
                            if (v168 == result) {
                              unsigned __int8 v165 = 0;
                            }
                            else {
                              unsigned __int8 v165 = -127;
                            }
                            if (v168 > result) {
                              unsigned __int8 v165 = 1;
                            }
                            if (v168 < result) {
                              unsigned __int8 v165 = -1;
                            }
                          }
                        }
                      }
                      while (v165 != 129 && (v165 & 0x80) != 0);
                      *(_DWORD *)uint64_t v152 = v161;
                      *(_DWORD *)(v152 + 4) = v162;
                      *(float *)(v152 + 8) = result;
                    }
                  }
                }
                a2 -= 3;
                BOOL v169 = v145 <= 2;
                int64_t v145 = v157;
              }
              while (!v169);
            }
            return result;
          }
          unint64_t v15 = (unint64_t)v14 >> 1;
          int64_t v16 = (_DWORD *)(a1 + 12 * ((unint64_t)v14 >> 1));
          if ((unint64_t)v13 < 0x601)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(v16, a1, (uint64_t)v11);
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>((_DWORD *)a1, (uint64_t)v16, (uint64_t)v11);
            uint64_t v17 = 3 * v15;
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>((_DWORD *)(a1 + 12), a1 + 4 * v17 - 12, (uint64_t)(a2 - 6));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>((_DWORD *)(a1 + 24), a1 + 12 + 4 * v17, (uint64_t)(a2 - 9));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>((_DWORD *)(a1 + 4 * v17 - 12), (uint64_t)v16, a1 + 12 + 4 * v17);
            uint64_t v18 = *(void *)a1;
            *(void *)a1 = *(void *)v16;
            *(void *)int64_t v16 = v18;
            LODWORD(v18) = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 8) = v16[2];
            v16[2] = v18;
          }
          --a3;
          uint64_t v10 = a2;
          if (a4) {
            break;
          }
          unsigned __int8 v19 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)(a1 - 12), a1);
          if (v19 != 129 && (char)v19 < 0) {
            break;
          }
          unsigned int v65 = *(_DWORD *)a1;
          unsigned int v66 = *(_DWORD *)(a1 + 4);
          uint64_t result = *(float *)(a1 + 8);
          if (*(_DWORD *)a1 < *(_DWORD *)v11) {
            unsigned __int8 v67 = -1;
          }
          else {
            unsigned __int8 v67 = 1;
          }
          if (*(_DWORD *)a1 == *(_DWORD *)v11)
          {
            unsigned int v68 = *((_DWORD *)a2 - 2);
            BOOL v69 = v66 == v68;
            unsigned __int8 v67 = v66 < v68 ? -1 : 1;
            if (v69)
            {
              float v70 = *(a2 - 1);
              if (result == v70) {
                unsigned __int8 v67 = 0;
              }
              else {
                unsigned __int8 v67 = -127;
              }
              if (result > v70) {
                unsigned __int8 v67 = 1;
              }
              if (result < v70) {
                unsigned __int8 v67 = -1;
              }
            }
          }
          if (v67 == 129 || (v67 & 0x80) == 0)
          {
            unint64_t v78 = a1 + 12;
            do
            {
              uint64_t v12 = (float *)v78;
              if (v78 >= (unint64_t)a2) {
                break;
              }
              if (v65 < *(_DWORD *)v78) {
                unsigned __int8 v79 = -1;
              }
              else {
                unsigned __int8 v79 = 1;
              }
              if (v65 == *(_DWORD *)v78)
              {
                unsigned int v80 = *(_DWORD *)(v78 + 4);
                BOOL v81 = v66 == v80;
                unsigned __int8 v79 = v66 < v80 ? -1 : 1;
                if (v81)
                {
                  float v82 = *(float *)(v78 + 8);
                  if (result == v82) {
                    unsigned __int8 v79 = 0;
                  }
                  else {
                    unsigned __int8 v79 = -127;
                  }
                  if (result > v82) {
                    unsigned __int8 v79 = 1;
                  }
                  if (result < v82) {
                    unsigned __int8 v79 = -1;
                  }
                }
              }
              v78 += 12;
            }
            while (v79 == 129 || (v79 & 0x80) == 0);
          }
          else
          {
            unsigned int v71 = (float *)a1;
            while (1)
            {
              uint64_t v12 = v71 + 3;
              unsigned int v72 = *((_DWORD *)v71 + 3);
              BOOL v73 = v65 == v72;
              if (v65 < v72) {
                unsigned __int8 v74 = -1;
              }
              else {
                unsigned __int8 v74 = 1;
              }
              if (v73)
              {
                unsigned int v75 = *((_DWORD *)v71 + 4);
                BOOL v76 = v66 == v75;
                unsigned __int8 v74 = v66 < v75 ? -1 : 1;
                if (v76)
                {
                  float v77 = v71[5];
                  if (result == v77) {
                    unsigned __int8 v74 = 0;
                  }
                  else {
                    unsigned __int8 v74 = -127;
                  }
                  if (result > v77) {
                    unsigned __int8 v74 = 1;
                  }
                  if (result < v77) {
                    unsigned __int8 v74 = -1;
                  }
                }
              }
              v71 += 3;
              if (v74 != 129)
              {
                unsigned int v71 = v12;
                if ((v74 & 0x80) != 0) {
                  break;
                }
              }
            }
          }
          unsigned int v83 = a2;
          if (v12 < a2)
          {
            uint64_t v84 = a2;
            unsigned int v83 = a2;
            do
            {
              unsigned int v85 = *((_DWORD *)v83 - 3);
              v83 -= 3;
              BOOL v86 = v65 == v85;
              if (v65 < v85) {
                unsigned __int8 v87 = -1;
              }
              else {
                unsigned __int8 v87 = 1;
              }
              if (v86)
              {
                unsigned int v88 = *((_DWORD *)v84 - 2);
                BOOL v89 = v66 == v88;
                unsigned __int8 v87 = v66 < v88 ? -1 : 1;
                if (v89)
                {
                  float v90 = *(v84 - 1);
                  if (result == v90) {
                    unsigned __int8 v87 = 0;
                  }
                  else {
                    unsigned __int8 v87 = -127;
                  }
                  if (result > v90) {
                    unsigned __int8 v87 = 1;
                  }
                  if (result < v90) {
                    unsigned __int8 v87 = -1;
                  }
                }
              }
              if (v87 == 129) {
                break;
              }
              uint64_t v84 = v83;
            }
            while ((v87 & 0x80) != 0);
          }
          if (v12 < v83)
          {
            float v91 = *v12;
            unsigned int v92 = *(_DWORD *)v83;
            do
            {
              *(_DWORD *)uint64_t v12 = v92;
              *unsigned int v83 = v91;
              int v93 = *((_DWORD *)v12 + 1);
              v12[1] = v83[1];
              *((_DWORD *)v83 + 1) = v93;
              int v94 = *((_DWORD *)v12 + 2);
              void v12[2] = v83[2];
              *((_DWORD *)v83 + 2) = v94;
              uint64_t v95 = v12;
              while (1)
              {
                uint64_t v12 = v95 + 3;
                float v91 = v95[3];
                if (v65 < LODWORD(v91)) {
                  unsigned __int8 v96 = -1;
                }
                else {
                  unsigned __int8 v96 = 1;
                }
                if (v65 == LODWORD(v91))
                {
                  unsigned int v97 = *((_DWORD *)v95 + 4);
                  BOOL v98 = v66 == v97;
                  unsigned __int8 v96 = v66 < v97 ? -1 : 1;
                  if (v98)
                  {
                    float v99 = v95[5];
                    if (result == v99) {
                      unsigned __int8 v96 = 0;
                    }
                    else {
                      unsigned __int8 v96 = -127;
                    }
                    if (result > v99) {
                      unsigned __int8 v96 = 1;
                    }
                    if (result < v99) {
                      unsigned __int8 v96 = -1;
                    }
                  }
                }
                v95 += 3;
                if (v96 != 129)
                {
                  uint64_t v95 = v12;
                  if ((v96 & 0x80) != 0) {
                    break;
                  }
                }
              }
              BOOL v100 = v83;
              do
              {
                unsigned int v101 = *((_DWORD *)v83 - 3);
                v83 -= 3;
                unsigned int v92 = v101;
                BOOL v102 = v65 == v101;
                if (v65 < v101) {
                  unsigned __int8 v103 = -1;
                }
                else {
                  unsigned __int8 v103 = 1;
                }
                if (v102)
                {
                  unsigned int v104 = *((_DWORD *)v100 - 2);
                  BOOL v105 = v66 == v104;
                  unsigned __int8 v103 = v66 < v104 ? -1 : 1;
                  if (v105)
                  {
                    float v106 = *(v100 - 1);
                    if (result == v106) {
                      unsigned __int8 v103 = 0;
                    }
                    else {
                      unsigned __int8 v103 = -127;
                    }
                    if (result > v106) {
                      unsigned __int8 v103 = 1;
                    }
                    if (result < v106) {
                      unsigned __int8 v103 = -1;
                    }
                  }
                }
                if (v103 == 129) {
                  break;
                }
                BOOL v100 = v83;
              }
              while ((v103 & 0x80) != 0);
            }
            while (v12 < v83);
          }
          BOOL v5 = (unint64_t)(v12 - 3) >= a1;
          BOOL v6 = v12 - 3 == (float *)a1;
          if (v12 - 3 != (float *)a1)
          {
            *(float *)a1 = *(v12 - 3);
            *(float *)(a1 + 4) = *(v12 - 2);
            *(float *)(a1 + 8) = *(v12 - 1);
          }
          a4 = 0;
          *((_DWORD *)v12 - 3) = v65;
          *((_DWORD *)v12 - 2) = v66;
          *(v12 - 1) = result;
        }
        unsigned int v20 = *(_DWORD *)a1;
        unsigned int v21 = *(_DWORD *)(a1 + 4);
        float v22 = *(float *)(a1 + 8);
        unint64_t v23 = a1;
        unsigned int v24 = (float *)a1;
        do
        {
          unsigned int v26 = *((_DWORD *)v24 + 3);
          v24 += 3;
          unsigned int v25 = v26;
          BOOL v27 = v26 == v20;
          if (v26 < v20) {
            unsigned __int8 v28 = -1;
          }
          else {
            unsigned __int8 v28 = 1;
          }
          if (v27)
          {
            unsigned int v29 = *(_DWORD *)(v23 + 16);
            BOOL v30 = v29 == v21;
            unsigned __int8 v28 = v29 < v21 ? -1 : 1;
            if (v30)
            {
              float v31 = *(float *)(v23 + 20);
              if (v31 == v22) {
                unsigned __int8 v28 = 0;
              }
              else {
                unsigned __int8 v28 = -127;
              }
              if (v31 > v22) {
                unsigned __int8 v28 = 1;
              }
              if (v31 < v22) {
                unsigned __int8 v28 = -1;
              }
            }
          }
          if (v28 == 129) {
            break;
          }
          unint64_t v23 = (unint64_t)v24;
        }
        while ((v28 & 0x80) != 0);
        unint64_t v32 = a2;
        if (v24 - 3 == (float *)a1)
        {
          uint64_t v40 = a2;
          while (v24 < v40)
          {
            unint64_t v33 = v40 - 3;
            unsigned int v41 = *((_DWORD *)v40 - 3);
            BOOL v42 = v41 == v20;
            if (v41 < v20) {
              unsigned __int8 v43 = -1;
            }
            else {
              unsigned __int8 v43 = 1;
            }
            if (v42)
            {
              unsigned int v44 = *((_DWORD *)v40 - 2);
              BOOL v45 = v44 == v21;
              unsigned __int8 v43 = v44 < v21 ? -1 : 1;
              if (v45)
              {
                float v46 = *(v40 - 1);
                if (v46 == v22) {
                  unsigned __int8 v43 = 0;
                }
                else {
                  unsigned __int8 v43 = -127;
                }
                if (v46 > v22) {
                  unsigned __int8 v43 = 1;
                }
                if (v46 < v22) {
                  unsigned __int8 v43 = -1;
                }
              }
            }
            v40 -= 3;
            if (v43 != 129)
            {
              uint64_t v40 = v33;
              if ((v43 & 0x80) != 0) {
                goto LABEL_76;
              }
            }
          }
          unint64_t v33 = v40;
        }
        else
        {
          while (1)
          {
            unint64_t v33 = v32 - 3;
            unsigned int v34 = *((_DWORD *)v32 - 3);
            BOOL v35 = v34 == v20;
            if (v34 < v20) {
              unsigned __int8 v36 = -1;
            }
            else {
              unsigned __int8 v36 = 1;
            }
            if (v35)
            {
              unsigned int v37 = *((_DWORD *)v32 - 2);
              BOOL v38 = v37 == v21;
              unsigned __int8 v36 = v37 < v21 ? -1 : 1;
              if (v38)
              {
                float v39 = *(v32 - 1);
                if (v39 == v22) {
                  unsigned __int8 v36 = 0;
                }
                else {
                  unsigned __int8 v36 = -127;
                }
                if (v39 > v22) {
                  unsigned __int8 v36 = 1;
                }
                if (v39 < v22) {
                  unsigned __int8 v36 = -1;
                }
              }
            }
            v32 -= 3;
            if (v36 != 129)
            {
              unint64_t v32 = v33;
              if ((v36 & 0x80) != 0) {
                break;
              }
            }
          }
        }
LABEL_76:
        if (v24 >= v33)
        {
          uint64_t v12 = v24;
        }
        else
        {
          float v47 = *v33;
          uint64_t v12 = v24;
          unsigned int v48 = v33;
          do
          {
            *uint64_t v12 = v47;
            *(_DWORD *)unsigned int v48 = v25;
            int v49 = *((_DWORD *)v12 + 1);
            v12[1] = v48[1];
            *((_DWORD *)v48 + 1) = v49;
            int v50 = *((_DWORD *)v12 + 2);
            void v12[2] = v48[2];
            *((_DWORD *)v48 + 2) = v50;
            uint64_t v51 = v12;
            do
            {
              unsigned int v52 = *((_DWORD *)v12 + 3);
              v12 += 3;
              unsigned int v25 = v52;
              BOOL v53 = v52 == v20;
              if (v52 < v20) {
                unsigned __int8 v54 = -1;
              }
              else {
                unsigned __int8 v54 = 1;
              }
              if (v53)
              {
                unsigned int v55 = *((_DWORD *)v51 + 4);
                BOOL v56 = v55 == v21;
                unsigned __int8 v54 = v55 < v21 ? -1 : 1;
                if (v56)
                {
                  float v57 = v51[5];
                  if (v57 == v22) {
                    unsigned __int8 v54 = 0;
                  }
                  else {
                    unsigned __int8 v54 = -127;
                  }
                  if (v57 > v22) {
                    unsigned __int8 v54 = 1;
                  }
                  if (v57 < v22) {
                    unsigned __int8 v54 = -1;
                  }
                }
              }
              if (v54 == 129) {
                break;
              }
              uint64_t v51 = v12;
            }
            while ((v54 & 0x80) != 0);
            while (1)
            {
              unint64_t v58 = v48 - 3;
              float v47 = *(v48 - 3);
              if (LODWORD(v47) < v20) {
                unsigned __int8 v59 = -1;
              }
              else {
                unsigned __int8 v59 = 1;
              }
              if (LODWORD(v47) == v20)
              {
                unsigned int v60 = *((_DWORD *)v48 - 2);
                BOOL v61 = v60 == v21;
                unsigned __int8 v59 = v60 < v21 ? -1 : 1;
                if (v61)
                {
                  float v62 = *(v48 - 1);
                  if (v62 == v22) {
                    char v63 = 0;
                  }
                  else {
                    char v63 = -127;
                  }
                  if (v62 > v22) {
                    char v63 = 1;
                  }
                  if (v62 < v22) {
                    unsigned __int8 v59 = -1;
                  }
                  else {
                    unsigned __int8 v59 = v63;
                  }
                }
              }
              unsigned int v48 = v58;
              if (v59 != 129)
              {
                unsigned int v48 = v58;
                if ((v59 & 0x80) != 0) {
                  break;
                }
              }
            }
            unsigned int v48 = v58;
          }
          while (v12 < v58);
        }
        if (v12 - 3 != (float *)a1)
        {
          *(float *)a1 = *(v12 - 3);
          *(float *)(a1 + 4) = *(v12 - 2);
          *(float *)(a1 + 8) = *(v12 - 1);
        }
        *((_DWORD *)v12 - 3) = v20;
        *((_DWORD *)v12 - 2) = v21;
        *(v12 - 1) = v22;
        if (v24 >= v33) {
          break;
        }
LABEL_125:
        std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *,false>(a1, v12 - 3, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v64 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>((_DWORD *)a1, v12 - 3);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(v12, a2))
      {
        break;
      }
      if (!v64) {
        goto LABEL_125;
      }
    }
    a2 = v12 - 3;
    if (!v64) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t *a3)
{
  BOOL v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        BOOL v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      BOOL v5 = v7[1];
      if (!v5)
      {
        BOOL v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x30uLL);
    v9[4] = *a3;
    v9[5] = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, v9);
    return v9;
  }
  return (uint64_t *)v7;
}

void std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<long long,long long>,std::__tree_node<std::__value_type<long long,long long>,void *> *,long>>(uint64_t a1, void *a2, void *a3)
{
  if (*(void *)(a1 + 16))
  {
    BOOL v6 = *(uint64_t **)a1;
    uint64_t v8 = (uint64_t **)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
    if (v6[1]) {
      uint64_t v9 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v9 = v6;
    }
    if (!v9)
    {
      unsigned int v20 = 0;
LABEL_29:
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v20);
      goto LABEL_30;
    }
    uint64_t v10 = std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::_DetachedTreeCache::__detach_next((uint64_t)v9);
    if (a2 != a3)
    {
      int v11 = v9;
      uint64_t v12 = a2;
      do
      {
        uint64_t v9 = v10;
        uint64_t v13 = v12[4];
        v11[4] = v13;
        v11[5] = v12[5];
        uint64_t v14 = *v8;
        unint64_t v15 = (uint64_t **)(a1 + 8);
        int64_t v16 = (uint64_t **)(a1 + 8);
        if (*v8)
        {
          do
          {
            while (1)
            {
              unint64_t v15 = (uint64_t **)v14;
              if (v13 >= v14[4]) {
                break;
              }
              uint64_t v14 = (uint64_t *)*v14;
              int64_t v16 = v15;
              if (!*v15) {
                goto LABEL_14;
              }
            }
            uint64_t v14 = (uint64_t *)v14[1];
          }
          while (v14);
          int64_t v16 = v15 + 1;
        }
LABEL_14:
        std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v15, v16, v11);
        if (v10) {
          uint64_t v10 = std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::_DetachedTreeCache::__detach_next((uint64_t)v10);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v17 = (void *)v12[1];
        if (v17)
        {
          do
          {
            a2 = v17;
            uint64_t v17 = (void *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            a2 = (void *)v12[2];
            BOOL v18 = *a2 == (void)v12;
            uint64_t v12 = a2;
          }
          while (!v18);
        }
        if (!v9) {
          break;
        }
        int v11 = v9;
        uint64_t v12 = a2;
      }
      while (a2 != a3);
    }
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v9);
    if (v10)
    {
      for (uint64_t i = (uint64_t *)v10[2]; i; uint64_t i = (uint64_t *)i[2])
        uint64_t v10 = i;
      unsigned int v20 = v10;
      goto LABEL_29;
    }
  }
LABEL_30:
  if (a2 != a3)
  {
    unsigned int v21 = (uint64_t **)(a1 + 8);
    do
    {
      float v22 = operator new(0x30uLL);
      _OWORD v22[2] = *((_OWORD *)a2 + 2);
      unint64_t v23 = *v21;
      unsigned int v24 = (uint64_t **)(a1 + 8);
      unsigned int v25 = (uint64_t **)(a1 + 8);
      if (*v21)
      {
        do
        {
          while (1)
          {
            unsigned int v24 = (uint64_t **)v23;
            if (*((void *)v22 + 4) >= v23[4]) {
              break;
            }
            unint64_t v23 = (uint64_t *)*v23;
            unsigned int v25 = v24;
            if (!*v24) {
              goto LABEL_38;
            }
          }
          unint64_t v23 = (uint64_t *)v23[1];
        }
        while (v23);
        unsigned int v25 = v24 + 1;
      }
LABEL_38:
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v24, v25, (uint64_t *)v22);
      unsigned int v26 = (void *)a2[1];
      if (v26)
      {
        do
        {
          BOOL v27 = v26;
          unsigned int v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          BOOL v27 = (void *)a2[2];
          BOOL v18 = *v27 == (void)a2;
          a2 = v27;
        }
        while (!v18);
      }
      a2 = v27;
    }
    while (v27 != a3);
  }
}

void *std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *uint64_t result = 0;
      while (1)
      {
        uint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          uint64_t result = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          uint64_t result = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>(float *a1, uint64_t a2)
{
  float v3 = *a1;
  if (*(_DWORD *)a1 < *(_DWORD *)a2) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = 1;
  }
  if (LODWORD(v3) == *(_DWORD *)a2)
  {
    unsigned int v5 = *((_DWORD *)a1 + 1);
    unsigned int v6 = *(_DWORD *)(a2 + 4);
    uint64_t result = v5 < v6 ? 0xFFFFFFFFLL : 1;
    if (v5 == v6)
    {
      float v7 = a1[2];
      float v8 = *(float *)(a2 + 8);
      if (v7 == v8) {
        unsigned int v9 = 0;
      }
      else {
        unsigned int v9 = -127;
      }
      if (v7 > v8) {
        unsigned int v9 = 1;
      }
      if (v7 < v8) {
        return 0xFFFFFFFFLL;
      }
      else {
        return v9;
      }
    }
  }
  return result;
}

float std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v6 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a2, (uint64_t)a1);
  unsigned __int8 v7 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a3, a2);
  BOOL v10 = v7 != 129 && (v7 & 0x80u) != 0;
  if (v6 == 129 || ((char)v6 & 0x80000000) == 0)
  {
    if (v10)
    {
      float v14 = *(float *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(float *)a3 = v14;
      int v15 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a3 + 4) = v15;
      int64_t v16 = (float *)(a2 + 8);
      int v17 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = v17;
      unsigned __int8 v18 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a2, (uint64_t)a1);
      if (v18 != 129 && (char)v18 < 0)
      {
        int v19 = *a1;
        *a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v19;
        int v20 = a1[1];
        a1[1] = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = v20;
        uint64_t v12 = (float *)(a1 + 2);
LABEL_19:
        float result = *v12;
        *uint64_t v12 = *v16;
        float *v16 = result;
      }
    }
  }
  else
  {
    uint64_t v12 = (float *)(a1 + 2);
    int v11 = *a1;
    if (v10)
    {
      *a1 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v11;
      int v13 = a1[1];
      a1[1] = *(_DWORD *)(a3 + 4);
LABEL_18:
      *(_DWORD *)(a3 + 4) = v13;
      int64_t v16 = (float *)(a3 + 8);
      goto LABEL_19;
    }
    *a1 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v11;
    int v21 = a1[1];
    a1[1] = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v21;
    uint64_t v12 = (float *)(a2 + 8);
    int v22 = a1[2];
    a1[2] = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a2 + 8) = v22;
    unsigned __int8 v23 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a3, a2);
    if (v23 != 129 && (char)v23 < 0)
    {
      float v24 = *(float *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(float *)a3 = v24;
      int v13 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
      goto LABEL_18;
    }
  }
  return result;
}

float std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>((_DWORD *)a1, a2, a3);
  unsigned __int8 v8 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a4, a3);
  if (v8 != 129 && (char)v8 < 0)
  {
    float v10 = *(float *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(float *)a4 = v10;
    int v11 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(a4 + 4);
    *(_DWORD *)(a4 + 4) = v11;
    int v12 = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a4 + 8) = v12;
    unsigned __int8 v13 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a3, a2);
    if (v13 != 129 && (char)v13 < 0)
    {
      float v14 = *(float *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(float *)a3 = v14;
      int v15 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a3 + 4) = v15;
      int v16 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = v16;
      unsigned __int8 v17 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a2, a1);
      if (v17 != 129 && (char)v17 < 0)
      {
        int v18 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v18;
        int v19 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = v19;
        float result = *(float *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
        *(float *)(a2 + 8) = result;
      }
    }
  }
  return result;
}

float std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(a1, a2, a3, a4);
  unsigned __int8 v10 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a5, a4);
  if (v10 != 129 && (char)v10 < 0)
  {
    float v12 = *(float *)a4;
    *(_DWORD *)a4 = *(_DWORD *)a5;
    *(float *)a5 = v12;
    int v13 = *(_DWORD *)(a4 + 4);
    *(_DWORD *)(a4 + 4) = *(_DWORD *)(a5 + 4);
    *(_DWORD *)(a5 + 4) = v13;
    int v14 = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a4 + 8) = *(_DWORD *)(a5 + 8);
    *(_DWORD *)(a5 + 8) = v14;
    unsigned __int8 v15 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a4, a3);
    if (v15 != 129 && (char)v15 < 0)
    {
      float v16 = *(float *)a3;
      *(_DWORD *)a3 = *(_DWORD *)a4;
      *(float *)a4 = v16;
      int v17 = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a3 + 4) = *(_DWORD *)(a4 + 4);
      *(_DWORD *)(a4 + 4) = v17;
      int v18 = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
      *(_DWORD *)(a4 + 8) = v18;
      unsigned __int8 v19 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a3, a2);
      if (v19 != 129 && (char)v19 < 0)
      {
        float v20 = *(float *)a2;
        *(_DWORD *)a2 = *(_DWORD *)a3;
        *(float *)a3 = v20;
        int v21 = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
        *(_DWORD *)(a3 + 4) = v21;
        int v22 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
        *(_DWORD *)(a3 + 8) = v22;
        unsigned __int8 v23 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>((float *)a2, a1);
        if (v23 != 129 && (char)v23 < 0)
        {
          int v24 = *(_DWORD *)a1;
          *(_DWORD *)a1 = *(_DWORD *)a2;
          *(_DWORD *)a2 = v24;
          int v25 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
          *(_DWORD *)(a2 + 4) = v25;
          float result = *(float *)(a1 + 8);
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
          *(float *)(a2 + 8) = result;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(_DWORD *a1, float *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 2;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unsigned __int8 v6 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>(a2 - 3, (uint64_t)a1);
      BOOL result = 1;
      if (v6 != 129 && (char)v6 < 0)
      {
        int v7 = *a1;
        *a1 = *((_DWORD *)a2 - 3);
        *((_DWORD *)a2 - 3) = v7;
        int v8 = a1[1];
        a1[1] = *((_DWORD *)a2 - 2);
        *((_DWORD *)a2 - 2) = v8;
        int v9 = a1[2];
        a1[2] = *((_DWORD *)a2 - 1);
        *((_DWORD *)a2 - 1) = v9;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(a1, (uint64_t)(a1 + 3), (uint64_t)(a2 - 3));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>((uint64_t)a1, (uint64_t)(a1 + 3), (uint64_t)(a1 + 6), (uint64_t)(a2 - 3));
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>((uint64_t)a1, (uint64_t)(a1 + 3), (uint64_t)(a1 + 6), (uint64_t)(a1 + 9), (uint64_t)(a2 - 3));
      return 1;
    default:
      unsigned __int8 v10 = (float *)(a1 + 6);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,float> *>(a1, (uint64_t)(a1 + 3), (uint64_t)(a1 + 6));
      int v11 = (float *)(a1 + 9);
      if (a1 + 9 == (_DWORD *)a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    unsigned __int8 v14 = std::__tuple_compare_three_way[abi:ne180100]<unsigned int,unsigned int,float,unsigned int,unsigned int,float,0ul,1ul,2ul>(v11, (uint64_t)v10);
    if (v14 != 129 && (char)v14 < 0)
    {
      float v15 = *v11;
      unsigned int v16 = *((_DWORD *)v11 + 1);
      float v17 = v11[2];
      uint64_t v18 = v12;
      unsigned int v19 = *(_DWORD *)v10;
      while (1)
      {
        float v20 = (_DWORD *)((char *)a1 + v18);
        int v21 = *(_DWORD *)((char *)a1 + v18 + 28);
        v20[9] = v19;
        void v20[10] = v21;
        v20[11] = *(_DWORD *)((char *)a1 + v18 + 32);
        if (v18 == -24) {
          break;
        }
        unsigned int v19 = v20[3];
        if (LODWORD(v15) < v19) {
          unsigned __int8 v22 = -1;
        }
        else {
          unsigned __int8 v22 = 1;
        }
        if (LODWORD(v15) == v19)
        {
          unsigned int v23 = *(_DWORD *)((char *)a1 + v18 + 16);
          BOOL v24 = v16 == v23;
          unsigned __int8 v22 = v16 < v23 ? -1 : 1;
          if (v24)
          {
            float v25 = *(float *)((char *)a1 + v18 + 20);
            if (v17 == v25) {
              unsigned __int8 v22 = 0;
            }
            else {
              unsigned __int8 v22 = -127;
            }
            if (v17 > v25) {
              unsigned __int8 v22 = 1;
            }
            if (v17 < v25) {
              unsigned __int8 v22 = -1;
            }
          }
        }
        v18 -= 12;
        if (v22 == 129 || (v22 & 0x80) == 0)
        {
          uint64_t v26 = (uint64_t)a1 + v18 + 36;
          goto LABEL_31;
        }
      }
      uint64_t v26 = (uint64_t)a1;
LABEL_31:
      *(float *)uint64_t v26 = v15;
      *(_DWORD *)(v26 + 4) = v16;
      *(float *)(v26 + 8) = v17;
      if (++v13 == 8) {
        return v11 + 3 == a2;
      }
    }
    unsigned __int8 v10 = v11;
    v12 += 12;
    v11 += 3;
    if (v11 == a2) {
      return 1;
    }
  }
}

void *std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unsigned __int8 v6 = result;
    BOOL result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3F18C64(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<long long>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(a2);
    unsigned int v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v7 = &v4[8 * v6];
    size_t v8 = (char *)*a1;
    int v9 = (char *)a1[1];
    unsigned __int8 v10 = v5;
    if (v9 != *a1)
    {
      unsigned __int8 v10 = v5;
      do
      {
        uint64_t v11 = *((void *)v9 - 1);
        v9 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = (void *)(a1 + 16);
  int v13 = (char *)operator new(0x40uLL);
  v35[0] = v13;
  v35[1] = a1 + 16;
  *(void *)int v13 = 0;
  *((void *)v13 + 1) = v6;
  *((_DWORD *)v13 + 4) = *a3;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *((_DWORD *)v13 + 14) = 1065353216;
  char v36 = 1;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v6 = v3;
    goto LABEL_64;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    int8x8_t prime = (int8x8_t)v18;
  }
  else {
    int8x8_t prime = (int8x8_t)v17;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = *(void *)(a1 + 8);
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v7 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
    {
      unint64_t v26 = std::__next_prime(v26);
    }
    else
    {
      uint64_t v28 = 1 << -(char)__clz(v26 - 1);
      if (v26 >= 2) {
        unint64_t v26 = v28;
      }
    }
    if (*(void *)&prime <= v26) {
      int8x8_t prime = (int8x8_t)v26;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *(void *)(a1 + 8);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      unsigned int v34 = *(void **)a1;
      *(void *)a1 = 0;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v7 = 0;
      *(void *)(a1 + 8) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  float v20 = operator new(8 * *(void *)&prime);
  int v21 = *(void **)a1;
  *(void *)a1 = v20;
  if (v21) {
    operator delete(v21);
  }
  uint64_t v22 = 0;
  *(int8x8_t *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v22++) = 0;
  while (*(void *)&prime != v22);
  unsigned int v23 = (void *)*v12;
  if (*v12)
  {
    unint64_t v24 = v23[1];
    uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
    v25.i16[0] = vaddlv_u8(v25);
    if (v25.u32[0] > 1uLL)
    {
      if (v24 >= *(void *)&prime) {
        v24 %= *(void *)&prime;
      }
    }
    else
    {
      v24 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v12;
    unsigned int v29 = (void *)*v23;
    if (*v23)
    {
      do
      {
        unint64_t v30 = v29[1];
        if (v25.u32[0] > 1uLL)
        {
          if (v30 >= *(void *)&prime) {
            v30 %= *(void *)&prime;
          }
        }
        else
        {
          v30 &= *(void *)&prime - 1;
        }
        if (v30 != v24)
        {
          if (!*(void *)(*(void *)a1 + 8 * v30))
          {
            *(void *)(*(void *)a1 + 8 * v30) = v23;
            goto LABEL_56;
          }
          *unsigned int v23 = *v29;
          *unsigned int v29 = **(void **)(*(void *)a1 + 8 * v30);
          **(void **)(*(void *)a1 + 8 * v30) = v29;
          unsigned int v29 = v23;
        }
        unint64_t v30 = v24;
LABEL_56:
        unsigned int v23 = v29;
        unsigned int v29 = (void *)*v29;
        unint64_t v24 = v30;
      }
      while (v29);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_64:
  float v31 = *(void **)(*(void *)a1 + 8 * v6);
  uint64_t i = (uint64_t *)v35[0];
  if (v31)
  {
    *(void *)v35[0] = *v31;
LABEL_72:
    *float v31 = i;
    goto LABEL_73;
  }
  *(void *)v35[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(*(void *)a1 + 8 * v6) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    float v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  v35[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>>>>::reset[abi:ne180100]((uint64_t)v35);
  return i;
}

void sub_1A3F19140(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_set<int>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  unint64_t v10 = v9;
  while (1)
  {
    unint64_t v9 = v10;
    uint64_t v11 = a2 - v10;
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v10) >> 2);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          float v48 = *(float *)(a2 - 4);
          float v49 = *(float *)(v10 + 8);
          if (v48 < v49)
          {
            float v50 = *(float *)v10;
            *(_DWORD *)unint64_t v10 = *(_DWORD *)(a2 - 12);
            *(float *)(a2 - 12) = v50;
            int v51 = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v10 + 4) = *(_DWORD *)(a2 - 8);
            *(_DWORD *)(a2 - 8) = v51;
            *(float *)(v10 + 8) = v48;
            *(float *)(a2 - 4) = v49;
          }
          break;
        case 3uLL:
          BOOL result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)v10, (float *)(v10 + 12), (float *)(a2 - 12));
          break;
        case 4uLL:
          BOOL result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v10, v10 + 12, v10 + 24, a2 - 12);
          break;
        case 5uLL:
          BOOL result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v10, v10 + 12, v10 + 24, v10 + 36);
          float v52 = *(float *)(a2 - 4);
          float v53 = *(float *)(v10 + 44);
          if (v52 < v53)
          {
            int v54 = *(_DWORD *)(v10 + 36);
            *(_DWORD *)(v10 + 36) = *(_DWORD *)(a2 - 12);
            *(_DWORD *)(a2 - 12) = v54;
            int v55 = *(_DWORD *)(v10 + 40);
            *(_DWORD *)(v10 + 40) = *(_DWORD *)(a2 - 8);
            *(_DWORD *)(a2 - 8) = v55;
            *(float *)(v10 + 44) = v52;
            *(float *)(a2 - 4) = v53;
            float v56 = *(float *)(v10 + 44);
            float v57 = *(float *)(v10 + 32);
            if (v56 < v57)
            {
              int v58 = *(_DWORD *)(v10 + 36);
              int v59 = *(_DWORD *)(v10 + 40);
              uint64_t v60 = *(void *)(v10 + 24);
              *(_DWORD *)(v10 + 24) = v58;
              *(_DWORD *)(v10 + 28) = v59;
              *(void *)(v10 + 36) = v60;
              *(float *)(v10 + 32) = v56;
              *(float *)(v10 + 44) = v57;
              float v61 = *(float *)(v10 + 20);
              if (v56 < v61)
              {
                uint64_t v62 = *(void *)(v10 + 12);
                *(_DWORD *)(v10 + 12) = v58;
                *(_DWORD *)(v10 + 16) = v59;
                *(void *)(v10 + 24) = v62;
                *(float *)(v10 + 20) = v56;
                *(float *)(v10 + 32) = v61;
                float v63 = *(float *)(v10 + 8);
                if (v56 < v63)
                {
                  uint64_t v64 = *(void *)v10;
                  *(_DWORD *)unint64_t v10 = v58;
                  *(_DWORD *)(v10 + 4) = v59;
                  *(void *)(v10 + 12) = v64;
                  *(float *)(v10 + 8) = v56;
                  *(float *)(v10 + 20) = v63;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v11 <= 287) {
      break;
    }
    if (!a3)
    {
      if (v10 == a2) {
        return result;
      }
      int64_t v77 = (v12 - 2) >> 1;
      int64_t v78 = v77;
      do
      {
        int64_t v79 = v78;
        if (v77 >= v78)
        {
          uint64_t v80 = (2 * v78) | 1;
          unint64_t v81 = v10 + 12 * v80;
          if (2 * v79 + 2 < (uint64_t)v12 && *(float *)(v81 + 8) < *(float *)(v81 + 20))
          {
            v81 += 12;
            uint64_t v80 = 2 * v79 + 2;
          }
          unint64_t v82 = v10 + 12 * v79;
          float v83 = *(float *)(v81 + 8);
          float v84 = *(float *)(v82 + 8);
          if (v83 >= v84)
          {
            uint64_t v85 = *(void *)v82;
            do
            {
              unint64_t v86 = v82;
              unint64_t v82 = v81;
              *(_DWORD *)unint64_t v86 = *(_DWORD *)v81;
              *(_DWORD *)(v86 + 4) = *(_DWORD *)(v81 + 4);
              *(float *)(v86 + 8) = v83;
              if (v77 < v80) {
                break;
              }
              uint64_t v87 = 2 * v80;
              uint64_t v80 = (2 * v80) | 1;
              unint64_t v81 = v10 + 12 * v80;
              uint64_t v88 = v87 + 2;
              if (v88 < (uint64_t)v12 && *(float *)(v81 + 8) < *(float *)(v81 + 20))
              {
                v81 += 12;
                uint64_t v80 = v88;
              }
              float v83 = *(float *)(v81 + 8);
            }
            while (v83 >= v84);
            *(void *)unint64_t v82 = v85;
            *(float *)(v82 + 8) = v84;
          }
        }
        int64_t v78 = v79 - 1;
      }
      while (v79);
      int64_t v89 = v11 / 0xCuLL;
      while (2)
      {
        int64_t v90 = 0;
        float v91 = *(float *)v10;
        int v92 = *(_DWORD *)(v10 + 4);
        float v93 = *(float *)(v10 + 8);
        unint64_t v94 = v10;
        do
        {
          uint64_t v95 = (_DWORD *)v94;
          v94 += 12 * v90 + 12;
          uint64_t v96 = 2 * v90;
          BOOL result = (2 * v90) | 1;
          int64_t v90 = result;
          uint64_t v97 = v96 + 2;
          if (v97 < v89 && *(float *)(v94 + 8) < *(float *)(v94 + 20))
          {
            v94 += 12;
            int64_t v90 = v97;
          }
          *uint64_t v95 = *(_DWORD *)v94;
          v95[1] = *(_DWORD *)(v94 + 4);
          v95[2] = *(_DWORD *)(v94 + 8);
        }
        while (v90 <= (uint64_t)((unint64_t)(v89 - 2) >> 1));
        if (v94 != a2 - 12)
        {
          *(_DWORD *)unint64_t v94 = *(_DWORD *)(a2 - 12);
          *(_DWORD *)(v94 + 4) = *(_DWORD *)(a2 - 8);
          *(_DWORD *)(v94 + 8) = *(_DWORD *)(a2 - 4);
          *(float *)(a2 - 12) = v91;
          *(_DWORD *)(a2 - 8) = v92;
          *(float *)(a2 - 4) = v93;
          uint64_t v98 = v94 - v10 + 12;
          if (v98 >= 13)
          {
            unint64_t v99 = (v98 / 0xCuLL - 2) >> 1;
            unint64_t v100 = v10 + 12 * v99;
            float v101 = *(float *)(v100 + 8);
            float v93 = *(float *)(v94 + 8);
            if (v101 < v93)
            {
              uint64_t v102 = *(void *)v94;
              do
              {
                unint64_t v103 = v94;
                unint64_t v94 = v100;
                *(_DWORD *)unint64_t v103 = *(_DWORD *)v100;
                *(_DWORD *)(v103 + 4) = *(_DWORD *)(v100 + 4);
                *(float *)(v103 + 8) = v101;
                if (!v99) {
                  break;
                }
                unint64_t v99 = (v99 - 1) >> 1;
                unint64_t v100 = v10 + 12 * v99;
                float v101 = *(float *)(v100 + 8);
              }
              while (v101 < v93);
              *(void *)unint64_t v94 = v102;
LABEL_117:
              *(float *)(v94 + 8) = v93;
            }
          }
          a2 -= 12;
          if (v89-- <= 2) {
            return result;
          }
          continue;
        }
        break;
      }
      *(float *)unint64_t v94 = v91;
      *(_DWORD *)(v94 + 4) = v92;
      goto LABEL_117;
    }
    unint64_t v13 = v12 >> 1;
    unint64_t v14 = v10 + 12 * (v12 >> 1);
    if ((unint64_t)v11 >= 0x601)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)v9, (float *)(v9 + 12 * (v12 >> 1)), (float *)(a2 - 12));
      uint64_t v15 = 3 * v13;
      BOOL v16 = (float *)(v9 + 12 * v13 - 12);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)(v9 + 12), v16, (float *)(a2 - 24));
      unint64_t v17 = (float *)(v9 + 12 + 4 * v15);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)(v9 + 24), v17, (float *)(a2 - 36));
      BOOL result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v16, (float *)v14, v17);
      uint64_t v18 = *(void *)v9;
      *(void *)unint64_t v9 = *(void *)v14;
      *(void *)unint64_t v14 = v18;
      LODWORD(v18) = *(_DWORD *)(v9 + 8);
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(v14 + 8);
      *(_DWORD *)(v14 + 8) = v18;
    }
    else
    {
      BOOL result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)(v9 + 12 * (v12 >> 1)), (float *)v9, (float *)(a2 - 12));
    }
    --a3;
    if (a4)
    {
      float v19 = *(float *)(v9 + 8);
LABEL_13:
      uint64_t v20 = *(void *)v9;
      unint64_t v21 = v9;
      do
      {
        unint64_t v22 = v21;
        v21 += 12;
      }
      while (*(float *)(v22 + 20) < v19);
      unint64_t v23 = a2;
      if (v22 == v9)
      {
        unint64_t v26 = a2;
        while (v21 < v26)
        {
          unint64_t v24 = (float *)(v26 - 12);
          float v27 = *(float *)(v26 - 4);
          v26 -= 12;
          if (v27 < v19) {
            goto LABEL_23;
          }
        }
        unint64_t v24 = (float *)v26;
      }
      else
      {
        do
        {
          unint64_t v24 = (float *)(v23 - 12);
          float v25 = *(float *)(v23 - 4);
          v23 -= 12;
        }
        while (v25 >= v19);
      }
LABEL_23:
      unint64_t v10 = v21;
      if (v21 < (unint64_t)v24)
      {
        uint64_t v28 = v24;
        do
        {
          float v29 = *(float *)v10;
          *(float *)unint64_t v10 = *v28;
          *uint64_t v28 = v29;
          int v30 = *(_DWORD *)(v10 + 4);
          *(float *)(v10 + 4) = v28[1];
          *((_DWORD *)v28 + 1) = v30;
          int v31 = *(_DWORD *)(v10 + 8);
          *(float *)(v10 + 8) = v28[2];
          *((_DWORD *)v28 + 2) = v31;
          do
          {
            float v32 = *(float *)(v10 + 20);
            v10 += 12;
          }
          while (v32 < v19);
          do
          {
            float v33 = *(v28 - 1);
            v28 -= 3;
          }
          while (v33 >= v19);
        }
        while (v10 < (unint64_t)v28);
      }
      if (v10 - 12 != v9)
      {
        *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 12);
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v10 - 8);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 4);
      }
      *(void *)(v10 - 12) = v20;
      *(float *)(v10 - 4) = v19;
      if (v21 < (unint64_t)v24) {
        goto LABEL_34;
      }
      BOOL v34 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v9, v10 - 12);
      BOOL result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v10, a2);
      if (result)
      {
        a2 = v10 - 12;
        if (v34) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v34)
      {
LABEL_34:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*,false>(v9, v10 - 12, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      float v19 = *(float *)(v9 + 8);
      if (*(float *)(v9 - 4) < v19) {
        goto LABEL_13;
      }
      if (v19 >= *(float *)(a2 - 4))
      {
        unint64_t v37 = v9 + 12;
        do
        {
          unint64_t v10 = v37;
          if (v37 >= a2) {
            break;
          }
          float v38 = *(float *)(v37 + 8);
          v37 += 12;
        }
        while (v19 >= v38);
      }
      else
      {
        unint64_t v35 = v9;
        do
        {
          unint64_t v10 = v35 + 12;
          float v36 = *(float *)(v35 + 20);
          v35 += 12;
        }
        while (v19 >= v36);
      }
      float v39 = (float *)a2;
      if (v10 < a2)
      {
        unint64_t v40 = a2;
        do
        {
          float v39 = (float *)(v40 - 12);
          float v41 = *(float *)(v40 - 4);
          v40 -= 12;
        }
        while (v19 < v41);
      }
      uint64_t v42 = *(void *)v9;
      while (v10 < (unint64_t)v39)
      {
        float v43 = *(float *)v10;
        *(float *)unint64_t v10 = *v39;
        *float v39 = v43;
        int v44 = *(_DWORD *)(v10 + 4);
        *(float *)(v10 + 4) = v39[1];
        *((_DWORD *)v39 + 1) = v44;
        int v45 = *(_DWORD *)(v10 + 8);
        *(float *)(v10 + 8) = v39[2];
        *((_DWORD *)v39 + 2) = v45;
        do
        {
          float v46 = *(float *)(v10 + 20);
          v10 += 12;
        }
        while (v19 >= v46);
        do
        {
          float v47 = *(v39 - 1);
          v39 -= 3;
        }
        while (v19 < v47);
      }
      BOOL v4 = v10 - 12 >= v9;
      BOOL v5 = v10 - 12 == v9;
      if (v10 - 12 != v9)
      {
        *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 12);
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v10 - 8);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 4);
      }
      a4 = 0;
      *(void *)(v10 - 12) = v42;
      *(float *)(v10 - 4) = v19;
    }
  }
  unsigned int v65 = (void *)(v10 + 12);
  BOOL v67 = v10 == a2 || v65 == (void *)a2;
  if (a4)
  {
    if (!v67)
    {
      uint64_t v68 = 0;
      BOOL v69 = (void *)v10;
      do
      {
        float v70 = *((float *)v69 + 5);
        float v71 = *((float *)v69 + 2);
        BOOL v69 = v65;
        if (v70 < v71)
        {
          uint64_t v72 = *v65;
          uint64_t v73 = v68;
          while (1)
          {
            unsigned __int8 v74 = (float *)(v10 + v73);
            int v75 = *(_DWORD *)(v10 + v73 + 4);
            v74[3] = *(float *)(v10 + v73);
            *((_DWORD *)v74 + 4) = v75;
            v74[5] = *(float *)(v10 + v73 + 8);
            if (!v73) {
              break;
            }
            v73 -= 12;
            if (v70 >= *(v74 - 1))
            {
              uint64_t v76 = v10 + v73 + 12;
              goto LABEL_85;
            }
          }
          uint64_t v76 = v10;
LABEL_85:
          *(void *)uint64_t v76 = v72;
          *(float *)(v76 + 8) = v70;
        }
        unsigned int v65 = (void *)((char *)v69 + 12);
        v68 += 12;
      }
      while ((void *)((char *)v69 + 12) != (void *)a2);
    }
  }
  else if (!v67)
  {
    BOOL v105 = (_DWORD *)(v10 + 8);
    do
    {
      float v106 = *(float *)(v9 + 20);
      float v107 = *(float *)(v9 + 8);
      unint64_t v9 = (unint64_t)v65;
      if (v106 < v107)
      {
        uint64_t v108 = *v65;
        int v109 = v105;
        do
        {
          int v110 = *(v109 - 1);
          v109[1] = *(v109 - 2);
          v109[2] = v110;
          v109[3] = *v109;
          float v111 = *((float *)v109 - 3);
          v109 -= 3;
        }
        while (v106 < v111);
        *(void *)(v109 + 1) = v108;
        *((float *)v109 + 3) = v106;
      }
      unsigned int v65 = (void *)(v9 + 12);
      v105 += 3;
    }
    while (v9 + 12 != a2);
  }
  return result;
}

void vision::mod::GreedyClustererWithTorso::getConnectedComponentsWithoutFiltering(uint64_t *a1, uint64_t a2, void **a3)
{
  uint64_t v4 = a2;
  memset(&v105, 0, sizeof(v105));
  std::vector<int>::reserve(&v105, (uint64_t)(*(void *)(*(void *)(a2 + 64) + 56) - *(void *)(*(void *)(a2 + 64) + 48)) >> 2);
  uint64_t v5 = *(void *)(*(void *)(v4 + 64) + 48);
  uint64_t v96 = v4;
  if (*(void *)(*(void *)(v4 + 64) + 56) == v5)
  {
    int v7 = 0;
  }
  else
  {
    unint64_t v94 = a3;
    unint64_t v6 = 0;
    int v7 = 0;
    std::vector<int>::pointer end = v105.__end_;
    value = v105.__end_cap_.__value_;
    std::vector<int>::pointer begin = v105.__begin_;
    do
    {
      int v11 = *(_DWORD *)(v5 + 4 * v6);
      if (end >= value)
      {
        uint64_t v12 = end - begin;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 62)
        {
          v105.__begin_ = begin;
          v105.__end_ = end;
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        if (((char *)value - (char *)begin) >> 1 > v13) {
          unint64_t v13 = ((char *)value - (char *)begin) >> 1;
        }
        if ((unint64_t)((char *)value - (char *)begin) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v13;
        }
        if (v14) {
          unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v14);
        }
        else {
          uint64_t v15 = 0;
        }
        BOOL v16 = (int *)(v14 + 4 * v12);
        int *v16 = v11;
        unint64_t v17 = v16 + 1;
        while (end != begin)
        {
          int v18 = *--end;
          *--BOOL v16 = v18;
        }
        value = (int *)(v14 + 4 * v15);
        if (begin) {
          operator delete(begin);
        }
        std::vector<int>::pointer begin = v16;
        std::vector<int>::pointer end = v17;
        uint64_t v4 = v96;
      }
      else
      {
        *end++ = v11;
      }
      if (v11 > v7) {
        int v7 = v11;
      }
      ++v6;
      uint64_t v5 = *(void *)(*(void *)(v4 + 64) + 48);
    }
    while (v6 < (*(void *)(*(void *)(v4 + 64) + 56) - v5) >> 2);
    v105.__end_ = end;
    v105.__end_cap_.__value_ = value;
    v105.__begin_ = begin;
    a3 = v94;
  }
  std::vector<std::vector<unsigned int>>::vector(&v103, v7 + 1);
  float v19 = (unsigned int *)**a3;
  for (uint64_t i = (unsigned int *)(*a3)[1]; v19 != i; v19 += 3)
  {
    unsigned int v21 = *v19;
    unsigned int v22 = v19[1];
    uint64_t v23 = v103 + 24 * *v19;
    float v25 = (unsigned int **)(v23 + 8);
    unint64_t v24 = *(unsigned int **)(v23 + 8);
    unint64_t v26 = *(void *)(v23 + 16);
    if ((unint64_t)v24 >= v26)
    {
      uint64_t v28 = *(unsigned int **)v23;
      uint64_t v29 = ((uint64_t)v24 - *(void *)v23) >> 2;
      unint64_t v30 = v29 + 1;
      if ((unint64_t)(v29 + 1) >> 62) {
        goto LABEL_122;
      }
      uint64_t v31 = v26 - (void)v28;
      if (v31 >> 1 > v30) {
        unint64_t v30 = v31 >> 1;
      }
      if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v32 = v30;
      }
      if (v32)
      {
        unint64_t v32 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v32);
        unint64_t v24 = *v25;
        uint64_t v28 = *(unsigned int **)v23;
      }
      else
      {
        uint64_t v33 = 0;
      }
      BOOL v34 = (unsigned int *)(v32 + 4 * v29);
      *BOOL v34 = v22;
      float v27 = v34 + 1;
      while (v24 != v28)
      {
        unsigned int v35 = *--v24;
        *--BOOL v34 = v35;
      }
      *(void *)uint64_t v23 = v34;
      *float v25 = v27;
      *(void *)(v23 + 16) = v32 + 4 * v33;
      if (v28) {
        operator delete(v28);
      }
    }
    else
    {
      *unint64_t v24 = v22;
      float v27 = v24 + 1;
    }
    *float v25 = v27;
    uint64_t v36 = v103 + 24 * v22;
    float v38 = (unsigned int **)(v36 + 8);
    unint64_t v37 = *(unsigned int **)(v36 + 8);
    unint64_t v39 = *(void *)(v36 + 16);
    if ((unint64_t)v37 >= v39)
    {
      float v41 = *(unsigned int **)v36;
      uint64_t v42 = ((uint64_t)v37 - *(void *)v36) >> 2;
      unint64_t v43 = v42 + 1;
      if ((unint64_t)(v42 + 1) >> 62) {
LABEL_122:
      }
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      uint64_t v44 = v39 - (void)v41;
      if (v44 >> 1 > v43) {
        unint64_t v43 = v44 >> 1;
      }
      if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v45 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v45 = v43;
      }
      if (v45)
      {
        unint64_t v45 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v45);
        unint64_t v37 = *v38;
        float v41 = *(unsigned int **)v36;
      }
      else
      {
        uint64_t v46 = 0;
      }
      float v47 = (unsigned int *)(v45 + 4 * v42);
      *float v47 = v21;
      unint64_t v40 = v47 + 1;
      while (v37 != v41)
      {
        unsigned int v48 = *--v37;
        *--float v47 = v48;
      }
      *(void *)uint64_t v36 = v47;
      std::__shared_weak_count_vtbl *v38 = v40;
      *(void *)(v36 + 16) = v45 + 4 * v46;
      if (v41) {
        operator delete(v41);
      }
    }
    else
    {
      *unint64_t v37 = v21;
      unint64_t v40 = v37 + 1;
    }
    std::__shared_weak_count_vtbl *v38 = v40;
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v102[0] = 0;
  v102[1] = 0;
  uint64_t v100 = 0;
  float v101 = (uint64_t *)v102;
  uint64_t v98 = &v98;
  std::string __p = &v98;
  float v49 = operator new(0x18uLL);
  v49[4] = 0;
  *(void *)float v49 = &v98;
  *((void *)v49 + 1) = &v98;
  uint64_t v98 = v49;
  std::string __p = v49;
  uint64_t v100 = 1;
  if (v104 == v103) {
    goto LABEL_119;
  }
  float v50 = 0;
  int v51 = 0;
  unint64_t v52 = 0;
  int v53 = 0;
LABEL_61:
  uint64_t v54 = *(void *)(v96 + 64);
  if (*(unsigned char *)(v54 + 112))
  {
    *(unsigned char *)(v54 + 112) = 0;
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 5219;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  unsigned int v97 = 0;
  uint64_t v55 = v100;
  if (v100)
  {
    float v56 = (void **)__p;
    unsigned int v57 = *((_DWORD *)__p + 4);
    unsigned int v97 = v57;
    uint64_t v58 = *(void *)__p;
    *(void *)(v58 + 8) = *((void *)__p + 1);
    *v56[1] = v58;
    uint64_t v100 = v55 - 1;
    operator delete(v56);
    goto LABEL_92;
  }
  uint64_t v60 = (void *)a1[1];
  unint64_t v59 = a1[2];
  if ((unint64_t)v60 >= v59)
  {
    unint64_t v63 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v60 - *a1) >> 3);
    unint64_t v64 = v63 + 1;
    if (v63 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59 - *a1) >> 3);
    if (2 * v65 > v64) {
      unint64_t v64 = 2 * v65;
    }
    if (v65 >= 0x555555555555555) {
      unint64_t v66 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v66 = v64;
    }
    int v109 = a1 + 2;
    if (v66) {
      unint64_t v66 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v66);
    }
    else {
      uint64_t v67 = 0;
    }
    uint64_t v68 = (void *)(v66 + 24 * v63);
    float v106 = (void **)v66;
    v107.i64[0] = (uint64_t)v68;
    v107.i64[1] = (uint64_t)v68;
    unint64_t v108 = v66 + 24 * v67;
    void *v68 = 0;
    v68[1] = 0;
    v68[2] = 0;
    std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v68, v50, (uint64_t)v51, v51 - v50);
    uint64_t v69 = v107.i64[0];
    uint64_t v61 = v107.i64[1] + 24;
    v107.i64[1] += 24;
    float v71 = (void *)*a1;
    float v70 = (void *)a1[1];
    if (v70 == (void *)*a1)
    {
      int64x2_t v74 = vdupq_n_s64((unint64_t)v70);
      uint64_t v73 = a1;
    }
    else
    {
      do
      {
        *(void *)(v69 - 24) = 0;
        *(void *)(v69 - 16) = 0;
        v69 -= 24;
        *(void *)(v69 + 16) = 0;
        long long v72 = *(_OWORD *)(v70 - 3);
        v70 -= 3;
        *(_OWORD *)uint64_t v69 = v72;
        *(void *)(v69 + 16) = v70[2];
        *float v70 = 0;
        v70[1] = 0;
        v70[2] = 0;
      }
      while (v70 != v71);
      uint64_t v73 = a1;
      int64x2_t v74 = *(int64x2_t *)a1;
      uint64_t v61 = v107.i64[1];
    }
    *uint64_t v73 = v69;
    v73[1] = v61;
    int64x2_t v107 = v74;
    unint64_t v75 = v73[2];
    a1[2] = v108;
    unint64_t v108 = v75;
    float v106 = (void **)v74.i64[0];
    std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)&v106);
    uint64_t v62 = a1;
  }
  else
  {
    *uint64_t v60 = 0;
    v60[1] = 0;
    v60[2] = 0;
    std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v60, v50, (uint64_t)v51, v51 - v50);
    uint64_t v61 = (uint64_t)(v60 + 3);
    uint64_t v62 = a1;
    a1[1] = (uint64_t)(v60 + 3);
  }
  v62[1] = v61;
  unint64_t v76 = v105.__end_ - v105.__begin_;
  if (v76 > v53)
  {
    uint64_t v77 = v53;
    while (1)
    {
      unsigned int v57 = v105.__begin_[v77];
      if (!v102[0])
      {
LABEL_91:
        unsigned int v97 = v105.__begin_[v77];
        ++v53;
        int v51 = v50;
LABEL_92:
        if (!*((unsigned char *)std::__tree<std::__value_type<unsigned int,BOOL>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,BOOL>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,BOOL>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(&v101, v57, &v97)+ 32))
        {
          *((unsigned char *)std::__tree<std::__value_type<unsigned int,BOOL>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,BOOL>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,BOOL>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(&v101, v57, &v97)+ 32) = 1;
          if ((unint64_t)v51 >= v52)
          {
            uint64_t v81 = v51 - v50;
            unint64_t v82 = v81 + 1;
            if ((unint64_t)(v81 + 1) >> 62) {
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            }
            if ((uint64_t)(v52 - (void)v50) >> 1 > v82) {
              unint64_t v82 = (uint64_t)(v52 - (void)v50) >> 1;
            }
            if (v52 - (unint64_t)v50 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v83 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v83 = v82;
            }
            if (v83) {
              unint64_t v83 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v83);
            }
            else {
              uint64_t v84 = 0;
            }
            uint64_t v85 = (unsigned int *)(v83 + 4 * v81);
            *uint64_t v85 = v57;
            uint64_t v80 = v85 + 1;
            while (v51 != v50)
            {
              unsigned int v86 = *--v51;
              *--uint64_t v85 = v86;
            }
            unint64_t v52 = v83 + 4 * v84;
            if (v50) {
              operator delete(v50);
            }
            float v50 = v85;
          }
          else
          {
            *int v51 = v57;
            uint64_t v80 = v51 + 1;
          }
          uint64_t v87 = v103 + 24 * v97;
          uint64_t v88 = *(_DWORD **)v87;
          int64_t v89 = *(_DWORD **)(v87 + 8);
          while (v88 != v89)
          {
            LODWORD(v106) = *v88;
            int v90 = (int)v106;
            if (!*((unsigned char *)std::__tree<std::__value_type<unsigned int,BOOL>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,BOOL>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,BOOL>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(&v101, v106, &v106)+ 32))
            {
              float v91 = operator new(0x18uLL);
              v91[4] = v90;
              int v92 = v98;
              *(void *)float v91 = v98;
              *((void *)v91 + 1) = &v98;
              v92[1] = v91;
              uint64_t v98 = v91;
              ++v100;
            }
            ++v88;
          }
          int v51 = v80;
        }
        if (v104 == v103) {
          goto LABEL_117;
        }
        goto LABEL_61;
      }
      int64_t v78 = v102[0];
      while (1)
      {
        unsigned int v79 = *((_DWORD *)v78 + 7);
        if (v57 >= v79) {
          break;
        }
LABEL_87:
        int64_t v78 = (void *)*v78;
        if (!v78)
        {
          int v53 = v77;
          goto LABEL_91;
        }
      }
      if (v79 < v57) {
        break;
      }
      if (++v77 == v76) {
        goto LABEL_117;
      }
    }
    ++v78;
    goto LABEL_87;
  }
LABEL_117:
  if (v50) {
    operator delete(v50);
  }
LABEL_119:
  std::__list_imp<long long>::clear(&v98);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v102[0]);
  float v106 = (void **)&v103;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v106);
  if (v105.__begin_) {
    operator delete(v105.__begin_);
  }
}

void sub_1A3F1A128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char *a16, void *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,char a25)
{
  a16 = a10;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  a16 = &a19;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  uint64_t v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (BOOL result = *v5; result; BOOL result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }
      else
      {
        v7 &= a2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v12 = a1 + 2;
  unint64_t v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v6 = v3;
    goto LABEL_64;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = a1[1];
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }
    else
    {
      uint64_t v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }
    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = a1[1];
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      BOOL v34 = (void *)*a1;
      *a1 = 0;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  float v19 = operator new(8 * *(void *)&prime);
  uint64_t v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0;
  a1[1] = (uint64_t)prime;
  do
    *(void *)(*a1 + 8 * v21++) = 0;
  while (*(void *)&prime != v21);
  unsigned int v22 = (void *)*v12;
  if (*v12)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }
    else
    {
      v23 &= *(void *)&prime - 1;
    }
    *(void *)(*a1 + 8 * v23) = v12;
    uint64_t v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }
        else
        {
          v29 &= *(void *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(void *)(*a1 + 8 * v29))
          {
            *(void *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          void *v22 = *v28;
          *uint64_t v28 = **(void **)(*a1 + 8 * v29);
          **(void **)(*a1 + 8 * v29) = v28;
          uint64_t v28 = v22;
        }
        unint64_t v29 = v23;
LABEL_56:
        unsigned int v22 = v28;
        uint64_t v28 = (void *)*v28;
        unint64_t v23 = v29;
      }
      while (v28);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_64:
  uint64_t v30 = *a1;
  uint64_t v31 = *(void **)(*a1 + 8 * v6);
  if (v31)
  {
    void *v10 = *v31;
LABEL_72:
    *uint64_t v31 = v10;
    goto LABEL_73;
  }
  void *v10 = *v12;
  *uint64_t v12 = v10;
  *(void *)(v30 + 8 * v6) = v12;
  if (*v10)
  {
    unint64_t v32 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    uint64_t v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_1A3F1A678(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (v7 && (float)(v13 * (float)v7) >= v12)
  {
    unint64_t v6 = v3;
    goto LABEL_64;
  }
  BOOL v14 = 1;
  if (v7 >= 3) {
    BOOL v14 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v15 = v14 | (2 * v7);
  unint64_t v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16) {
    int8x8_t prime = (int8x8_t)v16;
  }
  else {
    int8x8_t prime = (int8x8_t)v15;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      unint64_t v24 = std::__next_prime(v24);
    }
    else
    {
      uint64_t v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2) {
        unint64_t v24 = v26;
      }
    }
    if (*(void *)&prime <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      uint64_t v33 = *(void **)a1;
      *(void *)a1 = 0;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  int v18 = operator new(8 * *(void *)&prime);
  float v19 = *(void **)a1;
  *(void *)a1 = v18;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v20++) = 0;
  while (*(void *)&prime != v20);
  uint64_t v21 = (void *)*((void *)a1 + 2);
  if (v21)
  {
    unint64_t v22 = v21[1];
    uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(void *)&prime) {
        v22 %= *(void *)&prime;
      }
    }
    else
    {
      v22 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
    uint64_t v27 = (void *)*v21;
    if (*v21)
    {
      do
      {
        unint64_t v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(void *)&prime) {
            v28 %= *(void *)&prime;
          }
        }
        else
        {
          v28 &= *(void *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(void *)(*(void *)a1 + 8 * v28))
          {
            *(void *)(*(void *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          void *v21 = *v27;
          *uint64_t v27 = **(void **)(*(void *)a1 + 8 * v28);
          **(void **)(*(void *)a1 + 8 * v28) = v27;
          uint64_t v27 = v21;
        }
        unint64_t v28 = v22;
LABEL_56:
        uint64_t v21 = v27;
        uint64_t v27 = (void *)*v27;
        unint64_t v22 = v28;
      }
      while (v27);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_64:
  unint64_t v29 = *(void **)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * v6);
  if (v30)
  {
    void *v10 = *v30;
LABEL_72:
    *uint64_t v30 = v10;
    goto LABEL_73;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v6] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7) {
        v31 %= v7;
      }
    }
    else
    {
      v31 &= v7 - 1;
    }
    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A3F1AA6C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,unsigned int,float>>>(unint64_t a1)
{
  if (a1 >= 0x1555555555555556) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(12 * a1);
}

void std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]()
{
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__deallocate_node(*(void **)(a1 + 16));
  int v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__deallocate_node(*(void **)(a1 + 16));
  int v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned int>>>>::__deallocate_node(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      int v2 = (void *)*v1;
      std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)(v1 + 3));
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<unsigned int>>>>::__deallocate_node(void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      int v2 = (void *)*v1;
      unint64_t v3 = (void *)v1[3];
      if (v3)
      {
        v1[4] = v3;
        operator delete(v3);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    unint64_t v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::vector<int>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  if (__n > this->__end_cap_.__value_ - this->__begin_)
  {
    if (__n >> 62) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    int64_t v3 = (char *)this->__end_ - (char *)this->__begin_;
    unint64_t v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(__n);
    uint64_t v5 = (int *)&v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    unint64_t v7 = (int *)&v4[4 * v6];
    std::vector<int>::pointer begin = this->__begin_;
    std::vector<int>::pointer end = this->__end_;
    unint64_t v10 = v5;
    if (end != this->__begin_)
    {
      unint64_t v10 = v5;
      do
      {
        int v11 = *--end;
        *--unint64_t v10 = v11;
      }
      while (end != begin);
    }
    this->__begin_ = v10;
    this->__end_ = v5;
    this->__end_cap_.__value_ = v7;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void *std::vector<std::vector<unsigned int>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::string>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_1A3F1AD80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t **std::__tree<std::__value_type<unsigned int,BOOL>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,BOOL>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,BOOL>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  size_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        size_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      size_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = a1 + 1;
LABEL_9:
    unint64_t v9 = (uint64_t *)v7;
    unint64_t v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((unsigned char *)v7 + 32) = 0;
    *unint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    unint64_t v10 = (uint64_t *)**a1;
    int v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      int v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

float *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(float *result, float *a2, float *a3)
{
  float v3 = a2[2];
  float v4 = result[2];
  float v5 = a3[2];
  if (v3 >= v4)
  {
    if (v5 < v3)
    {
      float v8 = *a2;
      *a2 = *a3;
      *a3 = v8;
      int v9 = *((_DWORD *)a2 + 1);
      a2[1] = a3[1];
      *((_DWORD *)a3 + 1) = v9;
      a2[2] = v5;
      a3[2] = v3;
      float v10 = a2[2];
      float v11 = result[2];
      if (v10 < v11)
      {
        float v12 = *result;
        *BOOL result = *a2;
        *a2 = v12;
        int v13 = *((_DWORD *)result + 1);
        result[1] = a2[1];
        *((_DWORD *)a2 + 1) = v13;
        result[2] = v10;
        a2[2] = v11;
      }
    }
  }
  else
  {
    float v6 = *result;
    if (v5 >= v3)
    {
      *BOOL result = *a2;
      *a2 = v6;
      int v14 = *((_DWORD *)result + 1);
      result[1] = a2[1];
      *((_DWORD *)a2 + 1) = v14;
      result[2] = v3;
      a2[2] = v4;
      float v15 = a3[2];
      if (v15 >= v4) {
        return result;
      }
      float v16 = *a2;
      *a2 = *a3;
      *a3 = v16;
      int v17 = *((_DWORD *)a2 + 1);
      a2[1] = a3[1];
      *((_DWORD *)a3 + 1) = v17;
      a2[2] = v15;
    }
    else
    {
      *BOOL result = *a3;
      *a3 = v6;
      int v7 = *((_DWORD *)result + 1);
      result[1] = a3[1];
      *((_DWORD *)a3 + 1) = v7;
      result[2] = v5;
    }
    a3[2] = v4;
  }
  return result;
}

float *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)a1, (float *)a2, (float *)a3);
  float v9 = *(float *)(a4 + 8);
  float v10 = *(float *)(a3 + 8);
  if (v9 < v10)
  {
    float v11 = *(float *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(float *)a4 = v11;
    int v12 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(a4 + 4);
    *(_DWORD *)(a4 + 4) = v12;
    *(float *)(a3 + 8) = v9;
    *(float *)(a4 + 8) = v10;
    float v13 = *(float *)(a3 + 8);
    float v14 = *(float *)(a2 + 8);
    if (v13 < v14)
    {
      float v15 = *(float *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(float *)a3 = v15;
      int v16 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a3 + 4) = v16;
      *(float *)(a2 + 8) = v13;
      *(float *)(a3 + 8) = v14;
      float v17 = *(float *)(a2 + 8);
      float v18 = *(float *)(a1 + 8);
      if (v17 < v18)
      {
        float v19 = *(float *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(float *)a2 = v19;
        int v20 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = v20;
        *(float *)(a1 + 8) = v17;
        *(float *)(a2 + 8) = v18;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 2;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      float v6 = *(float *)(a2 - 4);
      float v7 = *(float *)(a1 + 8);
      if (v6 < v7)
      {
        float v8 = *(float *)a1;
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 12);
        *(float *)(a2 - 12) = v8;
        int v9 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v9;
        *(float *)(a1 + 8) = v6;
        *(float *)(a2 - 4) = v7;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)a1, (float *)(a1 + 12), (float *)(a2 - 12));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(a1, a1 + 12, a1 + 24, a2 - 12);
      return 1;
    case 5uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(a1, a1 + 12, a1 + 24, a1 + 36);
      float v20 = *(float *)(a2 - 4);
      float v21 = *(float *)(a1 + 44);
      if (v20 < v21)
      {
        int v22 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 - 12);
        *(_DWORD *)(a2 - 12) = v22;
        int v23 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v23;
        *(float *)(a1 + 44) = v20;
        *(float *)(a2 - 4) = v21;
        float v24 = *(float *)(a1 + 44);
        float v25 = *(float *)(a1 + 32);
        if (v24 < v25)
        {
          int v26 = *(_DWORD *)(a1 + 36);
          int v27 = *(_DWORD *)(a1 + 40);
          uint64_t v28 = *(void *)(a1 + 24);
          *(_DWORD *)(a1 + 24) = v26;
          *(_DWORD *)(a1 + 28) = v27;
          *(void *)(a1 + 36) = v28;
          *(float *)(a1 + 32) = v24;
          *(float *)(a1 + 44) = v25;
          float v29 = *(float *)(a1 + 20);
          if (v24 < v29)
          {
            uint64_t v30 = *(void *)(a1 + 12);
            *(_DWORD *)(a1 + 12) = v26;
            *(_DWORD *)(a1 + 16) = v27;
            *(void *)(a1 + 24) = v30;
            *(float *)(a1 + 20) = v24;
            *(float *)(a1 + 32) = v29;
            float v31 = *(float *)(a1 + 8);
            if (v24 < v31)
            {
              uint64_t v32 = *(void *)a1;
              *(_DWORD *)a1 = v26;
              *(_DWORD *)(a1 + 4) = v27;
              *(void *)(a1 + 12) = v32;
              *(float *)(a1 + 8) = v24;
              *(float *)(a1 + 20) = v31;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v10 = a1 + 24;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)a1, (float *)(a1 + 12), (float *)(a1 + 24));
      uint64_t v11 = a1 + 36;
      if (a1 + 36 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    float v14 = *(float *)(v11 + 8);
    if (v14 < *(float *)(v10 + 8))
    {
      uint64_t v15 = *(void *)v11;
      uint64_t v16 = v12;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        int v18 = *(_DWORD *)(a1 + v16 + 28);
        *(_DWORD *)(v17 + 36) = *(_DWORD *)(a1 + v16 + 24);
        *(_DWORD *)(v17 + 40) = v18;
        *(_DWORD *)(v17 + 44) = *(_DWORD *)(a1 + v16 + 32);
        if (v16 == -24) {
          break;
        }
        v16 -= 12;
        if (v14 >= *(float *)(v17 + 20))
        {
          uint64_t v19 = a1 + v16 + 36;
          goto LABEL_13;
        }
      }
      uint64_t v19 = a1;
LABEL_13:
      *(void *)uint64_t v19 = v15;
      *(float *)(v19 + 8) = v14;
      if (++v13 == 8) {
        return v11 + 12 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 12;
    v11 += 12;
    if (v11 == a2) {
      return 1;
    }
  }
}

void vision::mod::GreedyClustererWithTorso::computeMergePairs(uint64_t a1, void *a2, void *a3, uint64_t **a4, int a5)
{
  if (*(void *)(*(void *)(a1 + 64) + 56) != *(void *)(*(void *)(a1 + 64) + 48))
  {
    float v5 = (void *)*a2;
    unint64_t v76 = a2 + 1;
    if ((void *)*a2 != a2 + 1)
    {
      float v7 = a4;
      int v9 = a3 + 1;
      while (1)
      {
        unsigned int v10 = *((_DWORD *)v5 + 7);
        uint64_t v11 = **(void **)(*(void *)(a1 + 64) + 72);
        uint64_t v12 = (void *)*a3;
        BOOL v13 = !*(_DWORD *)(v11 + *(unsigned int *)(v11 + 16) * (unint64_t)v10 + 40) || v12 == v9;
        if (!v13) {
          break;
        }
LABEL_72:
        long long v72 = (void *)v5[1];
        if (v72)
        {
          do
          {
            uint64_t v73 = v72;
            long long v72 = (void *)*v72;
          }
          while (v72);
        }
        else
        {
          do
          {
            uint64_t v73 = (void *)v5[2];
            BOOL v13 = *v73 == (void)v5;
            float v5 = v73;
          }
          while (!v13);
        }
        float v5 = v73;
        if (v73 == v76) {
          return;
        }
      }
      while (1)
      {
        unsigned int v14 = *((_DWORD *)v12 + 7);
        if (v14 > v10 || a5 != 0)
        {
          uint64_t v16 = *(uint64_t **)(*(void *)(a1 + 64) + 72);
          if (v16)
          {
            uint64_t v17 = *v16;
            uint64_t v18 = v17 + 24;
            unsigned int v19 = *(_DWORD *)(v17 + 16);
            unint64_t v20 = v17 + 24 + v19 * (unint64_t)v14;
            if (*(_DWORD *)(v20 + 8) && *(_DWORD *)(v20 + 16))
            {
              uint64_t v21 = v18 + v19 * (unint64_t)v10;
              if (*(float *)(v20 + 12) >= *(float *)(v21 + 12)) {
                float v22 = *(float *)(v21 + 12);
              }
              else {
                float v22 = *(float *)(v20 + 12);
              }
              uint64_t v23 = v21 + 40;
LABEL_22:
              float __C = 0.0;
              vDSP_dotpr((const float *)v23, 1, (const float *)(v20 + 40), 1, &__C, 0x80uLL);
              float v24 = (float)(__C * -0.5) + 0.5;
              if (v24 < (float)(v22 * *(float *)(*(void *)(a1 + 32) + 12)))
              {
                uint64_t v27 = **(void **)(*(void *)(a1 + 64) + 72);
                uint64_t v25 = v27 + 24;
                LODWORD(v27) = *(_DWORD *)(v27 + 16);
                unsigned int v26 = *(_DWORD *)(v25 + v27 * (unint64_t)v14);
                LODWORD(v27) = *(_DWORD *)(v25 + v27 * (unint64_t)v10);
                if (v26 <= v27) {
                  uint64_t v28 = v27;
                }
                else {
                  uint64_t v28 = v26;
                }
                if (v26 >= v27) {
                  uint64_t v27 = v27;
                }
                else {
                  uint64_t v27 = v26;
                }
                float v29 = *v7;
                float v30 = v24 / v22;
                uint64_t v31 = v27 | (v28 << 32);
                unint64_t v33 = (*v7)[1];
                unint64_t v32 = (*v7)[2];
                if (v33 >= v32)
                {
                  unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v33 - *v29) >> 2);
                  unint64_t v36 = v35 + 1;
                  if (v35 + 1 > 0x1555555555555555) {
                    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                  }
                  unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v32 - *v29) >> 2);
                  if (2 * v37 > v36) {
                    unint64_t v36 = 2 * v37;
                  }
                  if (v37 >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v38 = 0x1555555555555555;
                  }
                  else {
                    unint64_t v38 = v36;
                  }
                  if (v38) {
                    unint64_t v38 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,unsigned int,float>>>(v38);
                  }
                  else {
                    uint64_t v39 = 0;
                  }
                  unint64_t v40 = v38 + 12 * v35;
                  *(void *)unint64_t v40 = v31;
                  *(float *)(v40 + 8) = v30;
                  uint64_t v42 = (_DWORD *)*v29;
                  float v41 = (_DWORD *)v29[1];
                  unint64_t v43 = v40;
                  if (v41 == (_DWORD *)*v29)
                  {
                    float v7 = a4;
                  }
                  else
                  {
                    float v7 = a4;
                    do
                    {
                      uint64_t v44 = *(void *)(v41 - 3);
                      v41 -= 3;
                      int v45 = v41[2];
                      *(void *)(v43 - 12) = v44;
                      v43 -= 12;
                      *(_DWORD *)(v43 + 8) = v45;
                    }
                    while (v41 != v42);
                    float v41 = (_DWORD *)*v29;
                  }
                  unint64_t v34 = v40 + 12;
                  *float v29 = v43;
                  v29[1] = v40 + 12;
                  void v29[2] = v38 + 12 * v39;
                  if (v41) {
                    operator delete(v41);
                  }
                }
                else
                {
                  *(void *)unint64_t v33 = v31;
                  *(float *)(v33 + 8) = v30;
                  unint64_t v34 = v33 + 12;
                }
                v29[1] = v34;
                uint64_t v46 = **v7;
                unint64_t v47 = (*v7)[1];
                unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v47 - v46) >> 2);
                if (v48 >= 0x86471)
                {
                  unint64_t v49 = 126 - 2 * __clz(v48);
                  if (v47 == v46) {
                    uint64_t v50 = 0;
                  }
                  else {
                    uint64_t v50 = v49;
                  }
                  std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::computeMergePairs(std::set<unsigned int> &,std::set<unsigned int> &,std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>,BOOL)::$_0 &,std::tuple<unsigned int,unsigned int,float>*,false>(v46, v47, v50, 1);
                  int v51 = *v7;
                  uint64_t v52 = **v7;
                  int v53 = (char *)(*v7)[1];
                  uint64_t v54 = &v53[-v52];
                  unint64_t v55 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v53[-v52] >> 2);
                  if (v55 >= 0x7A120)
                  {
                    float v7 = a4;
                    if (v54 != (char *)6000000) {
                      v51[1] = v52 + 6000000;
                    }
                  }
                  else
                  {
                    uint64_t v56 = v51[2];
                    if (0xAAAAAAAAAAAAAAABLL * ((v56 - (uint64_t)v53) >> 2) >= 500000 - v55)
                    {
                      size_t v69 = 12 * ((5999988 - (uint64_t)v54) / 0xCuLL) + 12;
                      bzero(v53, v69);
                      v51[1] = (uint64_t)&v53[v69];
                      float v7 = a4;
                    }
                    else
                    {
                      unint64_t v57 = 0xAAAAAAAAAAAAAAABLL * ((v56 - v52) >> 2);
                      uint64_t v58 = 2 * v57;
                      if (2 * v57 <= 0x7A120) {
                        uint64_t v58 = 500000;
                      }
                      if (v57 >= 0xAAAAAAAAAAAAAAALL) {
                        unint64_t v59 = 0x1555555555555555;
                      }
                      else {
                        unint64_t v59 = v58;
                      }
                      uint64_t v60 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<unsigned int,unsigned int,float>>>(v59);
                      uint64_t v74 = v61;
                      unint64_t v75 = v60;
                      size_t v62 = 12 * ((5999988 - (uint64_t)v54) / 0xCuLL) + 12;
                      unint64_t v63 = &v60[12 * v55];
                      bzero(v63, v62);
                      unint64_t v65 = (_DWORD *)*v51;
                      unint64_t v64 = (_DWORD *)v51[1];
                      unint64_t v66 = v63;
                      if (v64 != (_DWORD *)*v51)
                      {
                        do
                        {
                          uint64_t v67 = *(void *)(v64 - 3);
                          v64 -= 3;
                          int v68 = v64[2];
                          *(void *)(v66 - 12) = v67;
                          v66 -= 12;
                          *((_DWORD *)v66 + 2) = v68;
                        }
                        while (v64 != v65);
                        unint64_t v64 = (_DWORD *)*v51;
                      }
                      float v7 = a4;
                      *int v51 = (uint64_t)v66;
                      v51[1] = (uint64_t)&v63[v62];
                      v51[2] = (uint64_t)&v75[12 * v74];
                      if (v64) {
                        operator delete(v64);
                      }
                    }
                  }
                }
              }
            }
          }
          else if (MEMORY[8] && MEMORY[0x10])
          {
            unint64_t v20 = 0;
            float v22 = MEMORY[0xC];
            uint64_t v23 = 40;
            goto LABEL_22;
          }
        }
        float v70 = (void *)v12[1];
        if (v70)
        {
          do
          {
            float v71 = v70;
            float v70 = (void *)*v70;
          }
          while (v70);
        }
        else
        {
          do
          {
            float v71 = (void *)v12[2];
            BOOL v13 = *v71 == (void)v12;
            uint64_t v12 = v71;
          }
          while (!v13);
        }
        uint64_t v12 = v71;
        if (v71 == v9) {
          goto LABEL_72;
        }
      }
    }
  }
}

void vision::mod::GreedyClustererWithTorso::private_t::clusters_t::~clusters_t(vision::mod::GreedyClustererWithTorso::private_t::clusters_t *this)
{
  int v2 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  float v3 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v4;
    operator delete(v4);
  }
}

int *std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*,false>(int *result, int *a2, uint64_t a3, char a4)
{
  int v9 = result;
  while (2)
  {
    unsigned int v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = ((char *)a2 - (char *)v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                if (*(a2 - 1) > v10[1])
                {
                  int v44 = *v10;
                  int *v10 = *(a2 - 2);
                  *(a2 - 2) = v44;
                  int v45 = v10[1];
                  v10[1] = *(a2 - 1);
                  *(a2 - 1) = v45;
                }
                break;
              case 3uLL:
                BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v10, v10 + 2, a2 - 2);
                break;
              case 4uLL:
                BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v10, v10 + 2, v10 + 4, a2 - 2);
                break;
              case 5uLL:
                BOOL result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v10, v10 + 2, v10 + 4, v10 + 6, a2 - 2);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            uint64_t v46 = v10 + 2;
            BOOL v48 = v10 == a2 || v46 == a2;
            if (a4)
            {
              if (!v48)
              {
                uint64_t v49 = 0;
                uint64_t v50 = v10;
                do
                {
                  int v51 = v50[3];
                  int v52 = v50[1];
                  uint64_t v50 = v46;
                  if (v51 > v52)
                  {
                    int v53 = *v46;
                    int v54 = v50[1];
                    uint64_t v55 = v49;
                    while (1)
                    {
                      uint64_t v56 = (char *)v10 + v55;
                      int v57 = *(int *)((char *)v10 + v55 + 4);
                      *((_DWORD *)v56 + 2) = *(int *)((char *)v10 + v55);
                      *((_DWORD *)v56 + 3) = v57;
                      if (!v55) {
                        break;
                      }
                      v55 -= 8;
                      if (*((_DWORD *)v56 - 1) >= v54)
                      {
                        uint64_t v58 = (int *)((char *)v10 + v55 + 8);
                        goto LABEL_82;
                      }
                    }
                    uint64_t v58 = v10;
LABEL_82:
                    *uint64_t v58 = v53;
                    v58[1] = v54;
                  }
                  uint64_t v46 = v50 + 2;
                  v49 += 8;
                }
                while (v50 + 2 != a2);
              }
            }
            else if (!v48)
            {
              int v90 = v10 + 1;
              do
              {
                int v91 = v9[3];
                int v92 = v9[1];
                int v9 = v46;
                if (v91 > v92)
                {
                  uint64_t v93 = *(void *)v46;
                  uint64_t v94 = HIDWORD(*(void *)v9);
                  uint64_t v95 = v90;
                  do
                  {
                    int v96 = *v95;
                    v95[1] = *(v95 - 1);
                    v95[2] = v96;
                    int v97 = *(v95 - 2);
                    v95 -= 2;
                  }
                  while (v97 < (int)v94);
                  v95[1] = v93;
                  v95[2] = v94;
                }
                uint64_t v46 = v9 + 2;
                v90 += 2;
              }
              while (v9 + 2 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v59 = (v12 - 2) >> 1;
              int64_t v60 = v59;
              do
              {
                int64_t v61 = v60;
                if (v59 >= v60)
                {
                  uint64_t v62 = (2 * v60) | 1;
                  unint64_t v63 = &v10[2 * v62];
                  if (2 * v61 + 2 < (uint64_t)v12)
                  {
                    int v64 = v63[1];
                    int v65 = v63[3];
                    v63 += 2 * (v64 > v65);
                    if (v64 > v65) {
                      uint64_t v62 = 2 * v61 + 2;
                    }
                  }
                  unint64_t v66 = &v10[2 * v61];
                  if (v63[1] <= v66[1])
                  {
                    int v67 = *v66;
                    int v68 = v66[1];
                    do
                    {
                      size_t v69 = v66;
                      unint64_t v66 = v63;
                      *size_t v69 = *v63;
                      v69[1] = v63[1];
                      if (v59 < v62) {
                        break;
                      }
                      uint64_t v70 = (2 * v62) | 1;
                      unint64_t v63 = &v10[2 * v70];
                      uint64_t v71 = 2 * v62 + 2;
                      if (v71 < (uint64_t)v12)
                      {
                        int v72 = v63[1];
                        int v73 = v63[3];
                        v63 += 2 * (v72 > v73);
                        if (v72 > v73) {
                          uint64_t v70 = v71;
                        }
                      }
                      BOOL result = (int *)v63[1];
                      uint64_t v62 = v70;
                    }
                    while ((int)result <= v68);
                    *unint64_t v66 = v67;
                    v66[1] = v68;
                  }
                }
                int64_t v60 = v61 - 1;
              }
              while (v61);
              uint64_t v74 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v75 = 0;
                uint64_t v76 = *(void *)v10;
                uint64_t v77 = v10;
                do
                {
                  int64_t v78 = &v77[2 * v75 + 2];
                  uint64_t v79 = (2 * v75) | 1;
                  uint64_t v80 = 2 * v75 + 2;
                  if (v80 < v74)
                  {
                    int v81 = v78[1];
                    int v82 = v78[3];
                    v78 += 2 * (v81 > v82);
                    if (v81 > v82) {
                      uint64_t v79 = v80;
                    }
                  }
                  *uint64_t v77 = *v78;
                  v77[1] = v78[1];
                  uint64_t v77 = v78;
                  uint64_t v75 = v79;
                }
                while (v79 <= (uint64_t)((unint64_t)(v74 - 2) >> 1));
                if (v78 == a2 - 2)
                {
                  *(void *)int64_t v78 = v76;
                }
                else
                {
                  *int64_t v78 = *(a2 - 2);
                  v78[1] = *(a2 - 1);
                  *((void *)a2 - 1) = v76;
                  uint64_t v83 = (char *)v78 - (char *)v10 + 8;
                  if (v83 >= 9)
                  {
                    unint64_t v84 = (unint64_t)((v83 >> 3) - 2) >> 1;
                    uint64_t v85 = &v10[2 * v84];
                    if (v85[1] > v78[1])
                    {
                      int v86 = *v78;
                      int v87 = v78[1];
                      do
                      {
                        uint64_t v88 = v78;
                        int64_t v78 = v85;
                        *uint64_t v88 = *v85;
                        v88[1] = v85[1];
                        if (!v84) {
                          break;
                        }
                        unint64_t v84 = (v84 - 1) >> 1;
                        uint64_t v85 = &v10[2 * v84];
                      }
                      while (v85[1] > v87);
                      *int64_t v78 = v86;
                      v78[1] = v87;
                    }
                  }
                }
                a2 -= 2;
              }
              while (v74-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unsigned int v14 = &v10[2 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v9, &v9[2 * (v12 >> 1)], a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v9 + 2, v14 - 2, a2 - 4);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v9 + 4, &v9[2 * v13 + 2], a2 - 6);
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v14 - 2, v14, &v9[2 * v13 + 2]);
            uint64_t v15 = *(void *)v9;
            *(void *)int v9 = *(void *)v14;
            *(void *)unsigned int v14 = v15;
          }
          else
          {
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(&v9[2 * (v12 >> 1)], v9, a2 - 2);
          }
          --a3;
          if ((a4 & 1) != 0 || *(v9 - 1) > v9[1]) {
            break;
          }
          uint64_t v31 = *(void *)v9;
          uint64_t v32 = HIDWORD(*(void *)v9);
          if (*(a2 - 1) >= (int)v32)
          {
            unint64_t v35 = v9 + 2;
            do
            {
              unsigned int v10 = v35;
              if (v35 >= a2) {
                break;
              }
              int v36 = v35[1];
              v35 += 2;
            }
            while (v36 >= (int)v32);
          }
          else
          {
            unint64_t v33 = v9;
            do
            {
              unsigned int v10 = v33 + 2;
              int v34 = v33[3];
              v33 += 2;
            }
            while (v34 >= (int)v32);
          }
          unint64_t v37 = a2;
          if (v10 < a2)
          {
            unint64_t v38 = a2;
            do
            {
              unint64_t v37 = v38 - 2;
              int v39 = *(v38 - 1);
              v38 -= 2;
            }
            while (v39 < (int)v32);
          }
          while (v10 < v37)
          {
            int v40 = *v10;
            int *v10 = *v37;
            *unint64_t v37 = v40;
            int v41 = v10[1];
            v10[1] = v37[1];
            v37[1] = v41;
            do
            {
              int v42 = v10[3];
              v10 += 2;
            }
            while (v42 >= (int)v32);
            do
            {
              int v43 = *(v37 - 1);
              v37 -= 2;
            }
            while (v43 < (int)v32);
          }
          BOOL v4 = v10 - 2 >= v9;
          BOOL v5 = v10 - 2 == v9;
          if (v10 - 2 != v9)
          {
            int *v9 = *(v10 - 2);
            v9[1] = *(v10 - 1);
          }
          a4 = 0;
          *(v10 - 2) = v31;
          *(v10 - 1) = v32;
        }
        uint64_t v16 = *(void *)v9;
        uint64_t v17 = HIDWORD(*(void *)v9);
        uint64_t v18 = v9;
        do
        {
          unsigned int v19 = v18;
          v18 += 2;
        }
        while (v19[3] > (int)v17);
        unint64_t v20 = a2;
        if (v19 == v9)
        {
          uint64_t v23 = a2;
          while (v18 < v23)
          {
            uint64_t v21 = v23 - 2;
            int v24 = *(v23 - 1);
            v23 -= 2;
            if (v24 > (int)v17) {
              goto LABEL_22;
            }
          }
          uint64_t v21 = v23;
        }
        else
        {
          do
          {
            uint64_t v21 = v20 - 2;
            int v22 = *(v20 - 1);
            v20 -= 2;
          }
          while (v22 <= (int)v17);
        }
LABEL_22:
        unsigned int v10 = v18;
        if (v18 < v21)
        {
          uint64_t v25 = v21;
          do
          {
            int v26 = *v10;
            int *v10 = *v25;
            *uint64_t v25 = v26;
            int v27 = v10[1];
            v10[1] = v25[1];
            v25[1] = v27;
            do
            {
              int v28 = v10[3];
              v10 += 2;
            }
            while (v28 > (int)v17);
            do
            {
              int v29 = *(v25 - 1);
              v25 -= 2;
            }
            while (v29 <= (int)v17);
          }
          while (v10 < v25);
        }
        if (v10 - 2 != v9)
        {
          int *v9 = *(v10 - 2);
          v9[1] = *(v10 - 1);
        }
        *(v10 - 2) = v16;
        *(v10 - 1) = v17;
        if (v18 >= v21) {
          break;
        }
LABEL_33:
        BOOL result = (int *)std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*,false>(v9, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v9, v10 - 2);
      BOOL result = (int *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v10, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 2;
    if (!v30) {
      continue;
    }
    return result;
  }
}

int *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(int *result, int *a2, int *a3)
{
  float v3 = a2 + 1;
  int v4 = a2[1];
  BOOL v5 = result + 1;
  int v6 = a3[1];
  if (v4 > result[1])
  {
    int v7 = *result;
    if (v6 <= v4)
    {
      *BOOL result = *a2;
      *a2 = v7;
      int v11 = result[1];
      result[1] = a2[1];
      a2[1] = v11;
      if (a3[1] <= v11) {
        return result;
      }
      int v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      BOOL v5 = a2 + 1;
    }
    else
    {
      *BOOL result = *a3;
      *a3 = v7;
    }
    float v3 = a3 + 1;
    goto LABEL_10;
  }
  if (v6 > v4)
  {
    int v8 = *a2;
    *a2 = *a3;
    *a3 = v8;
    int v9 = a2[1];
    a2[1] = a3[1];
    a3[1] = v9;
    if (a2[1] > *v5)
    {
      int v10 = *result;
      *BOOL result = *a2;
      *a2 = v10;
LABEL_10:
      int v13 = *v5;
      *BOOL v5 = *v3;
      *float v3 = v13;
    }
  }
  return result;
}

int *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(int *a1, int *a2, int *a3, int *a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a2, a3);
  if (a4[1] > a3[1])
  {
    int v9 = *a3;
    *a3 = *a4;
    *a4 = v9;
    int v10 = a3[1];
    a3[1] = a4[1];
    a4[1] = v10;
    if (a3[1] > a2[1])
    {
      int v11 = *a2;
      *a2 = *a3;
      *a3 = v11;
      int v12 = a2[1];
      a2[1] = a3[1];
      a3[1] = v12;
      if (a2[1] > a1[1])
      {
        int v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
        int v14 = a1[1];
        a1[1] = a2[1];
        a2[1] = v14;
      }
    }
  }
  return result;
}

int *std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(int *a1, int *a2, int *a3, int *a4, int *a5)
{
  BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a2, a3, a4);
  if (a5[1] > a4[1])
  {
    int v11 = *a4;
    *a4 = *a5;
    *a5 = v11;
    int v12 = a4[1];
    a4[1] = a5[1];
    a5[1] = v12;
    if (a4[1] > a3[1])
    {
      int v13 = *a3;
      *a3 = *a4;
      *a4 = v13;
      int v14 = a3[1];
      a3[1] = a4[1];
      a4[1] = v14;
      if (a3[1] > a2[1])
      {
        int v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        int v16 = a2[1];
        a2[1] = a3[1];
        a3[1] = v16;
        if (a2[1] > a1[1])
        {
          int v17 = *a1;
          *a1 = *a2;
          *a2 = v17;
          int v18 = a1[1];
          a1[1] = a2[1];
          a2[1] = v18;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(int *a1, int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(a2 - 1) > a1[1])
      {
        int v6 = *a1;
        *a1 = *(a2 - 2);
        *(a2 - 2) = v6;
        int v7 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      int v8 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a1 + 4);
      int v9 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    if (v9[1] > v8[1])
    {
      int v12 = *v9;
      int v13 = v9[1];
      uint64_t v14 = v10;
      while (1)
      {
        int v15 = (int *)((char *)a1 + v14);
        int v16 = *(int *)((char *)a1 + v14 + 20);
        void v15[6] = *(int *)((char *)a1 + v14 + 16);
        v15[7] = v16;
        if (v14 == -16) {
          break;
        }
        v14 -= 8;
        if (v15[3] >= v13)
        {
          int v17 = (int *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      int v17 = a1;
LABEL_12:
      *int v17 = v12;
      v17[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    int v8 = v9;
    v10 += 8;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

void cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createDeepCopy(void *a1)
{
  unint64_t v2 = v9;
  if ((v9 & 0x80u) != 0) {
    unint64_t v2 = (unint64_t)__p[1];
  }
  if (v2 != 11
    || ((v9 & 0x80u) == 0 ? (float v3 = __p) : (float v3 = (void **)__p[0]),
        (uint64_t v4 = *v3, v5 = *(uint64_t *)((char *)v3 + 3), v4 == (void *)0x494C41564E492323)
      ? (BOOL v6 = v5 == 0x232344494C41564ELL)
      : (BOOL v6 = 0),
        !v6))
  {
      cvml::util::MMapFileBackingStore::createByMappingDirectlyFromFile((const char *)__p, 1);
  }
  if ((char)v9 < 0) {
    operator delete(__p[0]);
  }
  std::shared_ptr<cvml::util::MMapFileBackingStore>::shared_ptr[abi:ne180100]<cvml::util::MMapFileBackingStore,void>(&v7, 0);
}

void sub_1A3F1C4AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v18 = v17;
  MEMORY[0x1A62562C0](v18, 0x1092C4040FCC1CALL);
  if (__p) {
    operator delete(__p);
  }
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a11);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::computeMergePairs(std::set<unsigned int> &,std::set<unsigned int> &,std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>,BOOL)::$_0 &,std::tuple<unsigned int,unsigned int,float>*,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  unint64_t v10 = v9;
  while (1)
  {
    unint64_t v9 = v10;
    uint64_t v11 = a2 - v10;
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v10) >> 2);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          float v48 = *(float *)(a2 - 4);
          float v49 = *(float *)(v10 + 8);
          if (v48 < v49)
          {
            float v50 = *(float *)v10;
            *(_DWORD *)unint64_t v10 = *(_DWORD *)(a2 - 12);
            *(float *)(a2 - 12) = v50;
            int v51 = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v10 + 4) = *(_DWORD *)(a2 - 8);
            *(_DWORD *)(a2 - 8) = v51;
            *(float *)(v10 + 8) = v48;
            *(float *)(a2 - 4) = v49;
          }
          break;
        case 3uLL:
          BOOL result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)v10, (float *)(v10 + 12), (float *)(a2 - 12));
          break;
        case 4uLL:
          BOOL result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v10, v10 + 12, v10 + 24, a2 - 12);
          break;
        case 5uLL:
          BOOL result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v10, v10 + 12, v10 + 24, v10 + 36);
          float v52 = *(float *)(a2 - 4);
          float v53 = *(float *)(v10 + 44);
          if (v52 < v53)
          {
            int v54 = *(_DWORD *)(v10 + 36);
            *(_DWORD *)(v10 + 36) = *(_DWORD *)(a2 - 12);
            *(_DWORD *)(a2 - 12) = v54;
            int v55 = *(_DWORD *)(v10 + 40);
            *(_DWORD *)(v10 + 40) = *(_DWORD *)(a2 - 8);
            *(_DWORD *)(a2 - 8) = v55;
            *(float *)(v10 + 44) = v52;
            *(float *)(a2 - 4) = v53;
            float v56 = *(float *)(v10 + 44);
            float v57 = *(float *)(v10 + 32);
            if (v56 < v57)
            {
              int v58 = *(_DWORD *)(v10 + 36);
              int v59 = *(_DWORD *)(v10 + 40);
              uint64_t v60 = *(void *)(v10 + 24);
              *(_DWORD *)(v10 + 24) = v58;
              *(_DWORD *)(v10 + 28) = v59;
              *(void *)(v10 + 36) = v60;
              *(float *)(v10 + 32) = v56;
              *(float *)(v10 + 44) = v57;
              float v61 = *(float *)(v10 + 20);
              if (v56 < v61)
              {
                uint64_t v62 = *(void *)(v10 + 12);
                *(_DWORD *)(v10 + 12) = v58;
                *(_DWORD *)(v10 + 16) = v59;
                *(void *)(v10 + 24) = v62;
                *(float *)(v10 + 20) = v56;
                *(float *)(v10 + 32) = v61;
                float v63 = *(float *)(v10 + 8);
                if (v56 < v63)
                {
                  uint64_t v64 = *(void *)v10;
                  *(_DWORD *)unint64_t v10 = v58;
                  *(_DWORD *)(v10 + 4) = v59;
                  *(void *)(v10 + 12) = v64;
                  *(float *)(v10 + 8) = v56;
                  *(float *)(v10 + 20) = v63;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v11 <= 287) {
      break;
    }
    if (!a3)
    {
      if (v10 == a2) {
        return result;
      }
      int64_t v77 = (v12 - 2) >> 1;
      int64_t v78 = v77;
      do
      {
        int64_t v79 = v78;
        if (v77 >= v78)
        {
          uint64_t v80 = (2 * v78) | 1;
          unint64_t v81 = v10 + 12 * v80;
          if (2 * v79 + 2 < (uint64_t)v12 && *(float *)(v81 + 8) < *(float *)(v81 + 20))
          {
            v81 += 12;
            uint64_t v80 = 2 * v79 + 2;
          }
          unint64_t v82 = v10 + 12 * v79;
          float v83 = *(float *)(v81 + 8);
          float v84 = *(float *)(v82 + 8);
          if (v83 >= v84)
          {
            uint64_t v85 = *(void *)v82;
            do
            {
              unint64_t v86 = v82;
              unint64_t v82 = v81;
              *(_DWORD *)unint64_t v86 = *(_DWORD *)v81;
              *(_DWORD *)(v86 + 4) = *(_DWORD *)(v81 + 4);
              *(float *)(v86 + 8) = v83;
              if (v77 < v80) {
                break;
              }
              uint64_t v87 = 2 * v80;
              uint64_t v80 = (2 * v80) | 1;
              unint64_t v81 = v10 + 12 * v80;
              uint64_t v88 = v87 + 2;
              if (v88 < (uint64_t)v12 && *(float *)(v81 + 8) < *(float *)(v81 + 20))
              {
                v81 += 12;
                uint64_t v80 = v88;
              }
              float v83 = *(float *)(v81 + 8);
            }
            while (v83 >= v84);
            *(void *)unint64_t v82 = v85;
            *(float *)(v82 + 8) = v84;
          }
        }
        int64_t v78 = v79 - 1;
      }
      while (v79);
      int64_t v89 = v11 / 0xCuLL;
      while (2)
      {
        int64_t v90 = 0;
        float v91 = *(float *)v10;
        int v92 = *(_DWORD *)(v10 + 4);
        float v93 = *(float *)(v10 + 8);
        unint64_t v94 = v10;
        do
        {
          uint64_t v95 = (_DWORD *)v94;
          v94 += 12 * v90 + 12;
          uint64_t v96 = 2 * v90;
          BOOL result = (2 * v90) | 1;
          int64_t v90 = result;
          uint64_t v97 = v96 + 2;
          if (v97 < v89 && *(float *)(v94 + 8) < *(float *)(v94 + 20))
          {
            v94 += 12;
            int64_t v90 = v97;
          }
          *uint64_t v95 = *(_DWORD *)v94;
          v95[1] = *(_DWORD *)(v94 + 4);
          v95[2] = *(_DWORD *)(v94 + 8);
        }
        while (v90 <= (uint64_t)((unint64_t)(v89 - 2) >> 1));
        if (v94 != a2 - 12)
        {
          *(_DWORD *)unint64_t v94 = *(_DWORD *)(a2 - 12);
          *(_DWORD *)(v94 + 4) = *(_DWORD *)(a2 - 8);
          *(_DWORD *)(v94 + 8) = *(_DWORD *)(a2 - 4);
          *(float *)(a2 - 12) = v91;
          *(_DWORD *)(a2 - 8) = v92;
          *(float *)(a2 - 4) = v93;
          uint64_t v98 = v94 - v10 + 12;
          if (v98 >= 13)
          {
            unint64_t v99 = (v98 / 0xCuLL - 2) >> 1;
            unint64_t v100 = v10 + 12 * v99;
            float v101 = *(float *)(v100 + 8);
            float v93 = *(float *)(v94 + 8);
            if (v101 < v93)
            {
              uint64_t v102 = *(void *)v94;
              do
              {
                unint64_t v103 = v94;
                unint64_t v94 = v100;
                *(_DWORD *)unint64_t v103 = *(_DWORD *)v100;
                *(_DWORD *)(v103 + 4) = *(_DWORD *)(v100 + 4);
                *(float *)(v103 + 8) = v101;
                if (!v99) {
                  break;
                }
                unint64_t v99 = (v99 - 1) >> 1;
                unint64_t v100 = v10 + 12 * v99;
                float v101 = *(float *)(v100 + 8);
              }
              while (v101 < v93);
              *(void *)unint64_t v94 = v102;
LABEL_117:
              *(float *)(v94 + 8) = v93;
            }
          }
          a2 -= 12;
          if (v89-- <= 2) {
            return result;
          }
          continue;
        }
        break;
      }
      *(float *)unint64_t v94 = v91;
      *(_DWORD *)(v94 + 4) = v92;
      goto LABEL_117;
    }
    unint64_t v13 = v12 >> 1;
    unint64_t v14 = v10 + 12 * (v12 >> 1);
    if ((unint64_t)v11 >= 0x601)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)v9, (float *)(v9 + 12 * (v12 >> 1)), (float *)(a2 - 12));
      uint64_t v15 = 3 * v13;
      int v16 = (float *)(v9 + 12 * v13 - 12);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)(v9 + 12), v16, (float *)(a2 - 24));
      uint64_t v17 = (float *)(v9 + 12 + 4 * v15);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)(v9 + 24), v17, (float *)(a2 - 36));
      BOOL result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v16, (float *)v14, v17);
      uint64_t v18 = *(void *)v9;
      *(void *)unint64_t v9 = *(void *)v14;
      *(void *)unint64_t v14 = v18;
      LODWORD(v18) = *(_DWORD *)(v9 + 8);
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(v14 + 8);
      *(_DWORD *)(v14 + 8) = v18;
    }
    else
    {
      BOOL result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)(v9 + 12 * (v12 >> 1)), (float *)v9, (float *)(a2 - 12));
    }
    --a3;
    if (a4)
    {
      float v19 = *(float *)(v9 + 8);
LABEL_13:
      uint64_t v20 = *(void *)v9;
      unint64_t v21 = v9;
      do
      {
        unint64_t v22 = v21;
        v21 += 12;
      }
      while (*(float *)(v22 + 20) < v19);
      unint64_t v23 = a2;
      if (v22 == v9)
      {
        unint64_t v26 = a2;
        while (v21 < v26)
        {
          int v24 = (float *)(v26 - 12);
          float v27 = *(float *)(v26 - 4);
          v26 -= 12;
          if (v27 < v19) {
            goto LABEL_23;
          }
        }
        int v24 = (float *)v26;
      }
      else
      {
        do
        {
          int v24 = (float *)(v23 - 12);
          float v25 = *(float *)(v23 - 4);
          v23 -= 12;
        }
        while (v25 >= v19);
      }
LABEL_23:
      unint64_t v10 = v21;
      if (v21 < (unint64_t)v24)
      {
        int v28 = v24;
        do
        {
          float v29 = *(float *)v10;
          *(float *)unint64_t v10 = *v28;
          *int v28 = v29;
          int v30 = *(_DWORD *)(v10 + 4);
          *(float *)(v10 + 4) = v28[1];
          *((_DWORD *)v28 + 1) = v30;
          int v31 = *(_DWORD *)(v10 + 8);
          *(float *)(v10 + 8) = v28[2];
          *((_DWORD *)v28 + 2) = v31;
          do
          {
            float v32 = *(float *)(v10 + 20);
            v10 += 12;
          }
          while (v32 < v19);
          do
          {
            float v33 = *(v28 - 1);
            v28 -= 3;
          }
          while (v33 >= v19);
        }
        while (v10 < (unint64_t)v28);
      }
      if (v10 - 12 != v9)
      {
        *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 12);
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v10 - 8);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 4);
      }
      *(void *)(v10 - 12) = v20;
      *(float *)(v10 - 4) = v19;
      if (v21 < (unint64_t)v24) {
        goto LABEL_34;
      }
      BOOL v34 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::computeMergePairs(std::set<unsigned int> &,std::set<unsigned int> &,std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>,BOOL)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v9, v10 - 12);
      BOOL result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::computeMergePairs(std::set<unsigned int> &,std::set<unsigned int> &,std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>,BOOL)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(v10, a2);
      if (result)
      {
        a2 = v10 - 12;
        if (v34) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v34)
      {
LABEL_34:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::computeMergePairs(std::set<unsigned int> &,std::set<unsigned int> &,std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>,BOOL)::$_0 &,std::tuple<unsigned int,unsigned int,float>*,false>(v9, v10 - 12, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      float v19 = *(float *)(v9 + 8);
      if (*(float *)(v9 - 4) < v19) {
        goto LABEL_13;
      }
      if (v19 >= *(float *)(a2 - 4))
      {
        unint64_t v37 = v9 + 12;
        do
        {
          unint64_t v10 = v37;
          if (v37 >= a2) {
            break;
          }
          float v38 = *(float *)(v37 + 8);
          v37 += 12;
        }
        while (v19 >= v38);
      }
      else
      {
        unint64_t v35 = v9;
        do
        {
          unint64_t v10 = v35 + 12;
          float v36 = *(float *)(v35 + 20);
          v35 += 12;
        }
        while (v19 >= v36);
      }
      int v39 = (float *)a2;
      if (v10 < a2)
      {
        unint64_t v40 = a2;
        do
        {
          int v39 = (float *)(v40 - 12);
          float v41 = *(float *)(v40 - 4);
          v40 -= 12;
        }
        while (v19 < v41);
      }
      uint64_t v42 = *(void *)v9;
      while (v10 < (unint64_t)v39)
      {
        float v43 = *(float *)v10;
        *(float *)unint64_t v10 = *v39;
        *int v39 = v43;
        int v44 = *(_DWORD *)(v10 + 4);
        *(float *)(v10 + 4) = v39[1];
        *((_DWORD *)v39 + 1) = v44;
        int v45 = *(_DWORD *)(v10 + 8);
        *(float *)(v10 + 8) = v39[2];
        *((_DWORD *)v39 + 2) = v45;
        do
        {
          float v46 = *(float *)(v10 + 20);
          v10 += 12;
        }
        while (v19 >= v46);
        do
        {
          float v47 = *(v39 - 1);
          v39 -= 3;
        }
        while (v19 < v47);
      }
      BOOL v4 = v10 - 12 >= v9;
      BOOL v5 = v10 - 12 == v9;
      if (v10 - 12 != v9)
      {
        *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 12);
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v10 - 8);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 4);
      }
      a4 = 0;
      *(void *)(v10 - 12) = v42;
      *(float *)(v10 - 4) = v19;
    }
  }
  int v65 = (void *)(v10 + 12);
  BOOL v67 = v10 == a2 || v65 == (void *)a2;
  if (a4)
  {
    if (!v67)
    {
      uint64_t v68 = 0;
      size_t v69 = (void *)v10;
      do
      {
        float v70 = *((float *)v69 + 5);
        float v71 = *((float *)v69 + 2);
        size_t v69 = v65;
        if (v70 < v71)
        {
          uint64_t v72 = *v65;
          uint64_t v73 = v68;
          while (1)
          {
            uint64_t v74 = (float *)(v10 + v73);
            int v75 = *(_DWORD *)(v10 + v73 + 4);
            v74[3] = *(float *)(v10 + v73);
            *((_DWORD *)v74 + 4) = v75;
            v74[5] = *(float *)(v10 + v73 + 8);
            if (!v73) {
              break;
            }
            v73 -= 12;
            if (v70 >= *(v74 - 1))
            {
              uint64_t v76 = v10 + v73 + 12;
              goto LABEL_85;
            }
          }
          uint64_t v76 = v10;
LABEL_85:
          *(void *)uint64_t v76 = v72;
          *(float *)(v76 + 8) = v70;
        }
        int v65 = (void *)((char *)v69 + 12);
        v68 += 12;
      }
      while ((void *)((char *)v69 + 12) != (void *)a2);
    }
  }
  else if (!v67)
  {
    std::vector<int> v105 = (_DWORD *)(v10 + 8);
    do
    {
      float v106 = *(float *)(v9 + 20);
      float v107 = *(float *)(v9 + 8);
      unint64_t v9 = (unint64_t)v65;
      if (v106 < v107)
      {
        uint64_t v108 = *v65;
        int v109 = v105;
        do
        {
          int v110 = *(v109 - 1);
          v109[1] = *(v109 - 2);
          v109[2] = v110;
          v109[3] = *v109;
          float v111 = *((float *)v109 - 3);
          v109 -= 3;
        }
        while (v106 < v111);
        *(void *)(v109 + 1) = v108;
        *((float *)v109 + 3) = v106;
      }
      int v65 = (void *)(v9 + 12);
      v105 += 3;
    }
    while (v9 + 12 != a2);
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::computeMergePairs(std::set<unsigned int> &,std::set<unsigned int> &,std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>,BOOL)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 2;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      float v6 = *(float *)(a2 - 4);
      float v7 = *(float *)(a1 + 8);
      if (v6 < v7)
      {
        float v8 = *(float *)a1;
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 12);
        *(float *)(a2 - 12) = v8;
        int v9 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v9;
        *(float *)(a1 + 8) = v6;
        *(float *)(a2 - 4) = v7;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)a1, (float *)(a1 + 12), (float *)(a2 - 12));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(a1, a1 + 12, a1 + 24, a2 - 12);
      return 1;
    case 5uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>(a1, a1 + 12, a1 + 24, a1 + 36);
      float v20 = *(float *)(a2 - 4);
      float v21 = *(float *)(a1 + 44);
      if (v20 < v21)
      {
        int v22 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 - 12);
        *(_DWORD *)(a2 - 12) = v22;
        int v23 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v23;
        *(float *)(a1 + 44) = v20;
        *(float *)(a2 - 4) = v21;
        float v24 = *(float *)(a1 + 44);
        float v25 = *(float *)(a1 + 32);
        if (v24 < v25)
        {
          int v26 = *(_DWORD *)(a1 + 36);
          int v27 = *(_DWORD *)(a1 + 40);
          uint64_t v28 = *(void *)(a1 + 24);
          *(_DWORD *)(a1 + 24) = v26;
          *(_DWORD *)(a1 + 28) = v27;
          *(void *)(a1 + 36) = v28;
          *(float *)(a1 + 32) = v24;
          *(float *)(a1 + 44) = v25;
          float v29 = *(float *)(a1 + 20);
          if (v24 < v29)
          {
            uint64_t v30 = *(void *)(a1 + 12);
            *(_DWORD *)(a1 + 12) = v26;
            *(_DWORD *)(a1 + 16) = v27;
            *(void *)(a1 + 24) = v30;
            *(float *)(a1 + 20) = v24;
            *(float *)(a1 + 32) = v29;
            float v31 = *(float *)(a1 + 8);
            if (v24 < v31)
            {
              uint64_t v32 = *(void *)a1;
              *(_DWORD *)a1 = v26;
              *(_DWORD *)(a1 + 4) = v27;
              *(void *)(a1 + 12) = v32;
              *(float *)(a1 + 8) = v24;
              *(float *)(a1 + 20) = v31;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v10 = a1 + 24;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::getConnectedComponents(std::shared_ptr<std::vector<std::tuple<unsigned int,unsigned int,float>>>)::$_0 &,std::tuple<unsigned int,unsigned int,float>*>((float *)a1, (float *)(a1 + 12), (float *)(a1 + 24));
      uint64_t v11 = a1 + 36;
      if (a1 + 36 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    float v14 = *(float *)(v11 + 8);
    if (v14 < *(float *)(v10 + 8))
    {
      uint64_t v15 = *(void *)v11;
      uint64_t v16 = v12;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        int v18 = *(_DWORD *)(a1 + v16 + 28);
        *(_DWORD *)(v17 + 36) = *(_DWORD *)(a1 + v16 + 24);
        *(_DWORD *)(v17 + 40) = v18;
        *(_DWORD *)(v17 + 44) = *(_DWORD *)(a1 + v16 + 32);
        if (v16 == -24) {
          break;
        }
        v16 -= 12;
        if (v14 >= *(float *)(v17 + 20))
        {
          uint64_t v19 = a1 + v16 + 36;
          goto LABEL_13;
        }
      }
      uint64_t v19 = a1;
LABEL_13:
      *(void *)uint64_t v19 = v15;
      *(float *)(v19 + 8) = v14;
      if (++v13 == 8) {
        return v11 + 12 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 12;
    v11 += 12;
    if (v11 == a2) {
      return 1;
    }
  }
}

void *std::map<long long,unsigned long>::at(void *a1, uint64_t a2)
{
  if (!a1) {
LABEL_8:
  }
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      uint64_t v2 = a1[4];
      if (v2 <= a2) {
        break;
      }
      a1 = (void *)*a1;
      if (!a1) {
        goto LABEL_8;
      }
    }
    if (v2 >= a2) {
      return a1 + 5;
    }
    a1 = (void *)a1[1];
    if (!a1) {
      goto LABEL_8;
    }
  }
}

void std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy((void *)a1[6]);
    operator delete(a1);
  }
}

uint64_t *std::set<unsigned int>::set[abi:ne180100](uint64_t *a1, void *a2)
{
  a1[1] = 0;
  float v3 = a1 + 1;
  a1[2] = 0;
  *a1 = (uint64_t)(a1 + 1);
  uint64_t v4 = a2 + 1;
  BOOL v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>(a1, v3, *((_DWORD *)v5 + 7), *((_DWORD *)v5 + 7));
      float v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          float v7 = v6;
          float v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          float v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          BOOL v5 = v7;
        }
        while (!v8);
      }
      BOOL v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

void sub_1A3F1D11C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>(uint64_t *result, uint64_t *a2, unsigned int a3, int a4)
{
  BOOL v5 = (uint64_t **)result;
  float v6 = (uint64_t **)(result + 1);
  if (result + 1 == a2 || (unsigned int v7 = *((_DWORD *)a2 + 7), v7 > a3))
  {
    BOOL v8 = (uint64_t *)*a2;
    if ((uint64_t *)*result == a2)
    {
      uint64_t v10 = a2;
LABEL_16:
      if (v8) {
        int v13 = (uint64_t **)v10;
      }
      else {
        int v13 = (uint64_t **)a2;
      }
      if (v8) {
        uint64_t v11 = (uint64_t **)(v10 + 1);
      }
      else {
        uint64_t v11 = (uint64_t **)a2;
      }
      goto LABEL_22;
    }
    if (v8)
    {
      int v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        int v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v15 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v15[2];
        BOOL v16 = *v10 == (void)v15;
        uint64_t v15 = v10;
      }
      while (v16);
    }
    if (*((_DWORD *)v10 + 7) < a3) {
      goto LABEL_16;
    }
    uint64_t v17 = *v6;
    if (*v6)
    {
      while (1)
      {
        while (1)
        {
          int v13 = (uint64_t **)v17;
          unsigned int v18 = *((_DWORD *)v17 + 7);
          if (v18 <= a3) {
            break;
          }
          uint64_t v17 = *v13;
          float v6 = v13;
          if (!*v13) {
            goto LABEL_44;
          }
        }
        if (v18 >= a3) {
          break;
        }
        float v6 = v13 + 1;
        uint64_t v17 = v13[1];
        if (!v17) {
          goto LABEL_44;
        }
      }
LABEL_47:
      uint64_t v11 = v6;
      goto LABEL_22;
    }
  }
  else
  {
    if (v7 >= a3) {
      return result;
    }
    uint64_t v11 = (uint64_t **)(a2 + 1);
    uint64_t v12 = (uint64_t *)a2[1];
    if (v12)
    {
      do
      {
        uint64_t v11 = (uint64_t **)v12;
        uint64_t v12 = (uint64_t *)*v12;
        int v13 = v11;
        float v14 = v11;
      }
      while (v12);
    }
    else
    {
      float v14 = (uint64_t **)a2;
      do
      {
        uint64_t v19 = (uint64_t *)v14;
        float v14 = (uint64_t **)v14[2];
      }
      while (*v14 != v19);
      int v13 = (uint64_t **)a2;
    }
    if (v14 == v6 || *((_DWORD *)v14 + 7) > a3)
    {
LABEL_22:
      float v6 = v11;
      if (*v11) {
        return result;
      }
      goto LABEL_44;
    }
    float v20 = *v6;
    if (*v6)
    {
      while (1)
      {
        while (1)
        {
          int v13 = (uint64_t **)v20;
          unsigned int v21 = *((_DWORD *)v20 + 7);
          if (v21 <= a3) {
            break;
          }
          float v20 = *v13;
          float v6 = v13;
          if (!*v13) {
            goto LABEL_44;
          }
        }
        if (v21 >= a3) {
          goto LABEL_47;
        }
        float v6 = v13 + 1;
        float v20 = v13[1];
        if (!v20) {
          goto LABEL_44;
        }
      }
    }
  }
  int v13 = (uint64_t **)(result + 1);
LABEL_44:
  int v22 = (uint64_t *)operator new(0x20uLL);
  *((_DWORD *)v22 + 7) = a4;

  return std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v5, (uint64_t)v13, v6, v22);
}

void std::__shared_ptr_emplace<std::vector<std::tuple<unsigned int,unsigned int,float>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<std::tuple<unsigned int,unsigned int,float>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753C40;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<std::vector<std::tuple<unsigned int,unsigned int,float>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753C40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

__int32 *std::remove[abi:ne180100]<std::__wrap_iter<unsigned int *>,unsigned int>(__int32 *a1, __int32 *a2, __int32 *a3)
{
  BOOL result = wmemchr(a1, *a3, a2 - a1);
  if (!result) {
    BOOL result = a2;
  }
  float v6 = result + 1;
  if (result != a2 && v6 != a2)
  {
    do
    {
      if (*v6 != *a3) {
        *result++ = *v6;
      }
      ++v6;
    }
    while (v6 != a2);
  }
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned long,std::list<long long>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long,std::list<long long>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__list_imp<long long>::clear(v1 + 5);
    }
    operator delete(v1);
  }
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::cancelLongRunning(uint64_t this)
{
  *(unsigned char *)(*(void *)(this + 72) + 112) = 1;
  return this;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::getAverageDescriptorsOfClusters(vision::mod::GreedyClustererFacesWithTorso *a1, uint64_t **a2, uint64_t a3)
{
  v20[0] = 0;
  v20[1] = 0;
  uint64_t v19 = v20;
  uint64_t v6 = (*(uint64_t (**)(vision::mod::GreedyClustererFacesWithTorso *, void ***))(*(void *)a1 + 112))(a1, &v19);
  if (v6 == 5248)
  {
    unsigned int v7 = *a2;
    BOOL v8 = a2[1];
    if (*a2 == v8)
    {
LABEL_7:
      uint64_t v6 = 5248;
    }
    else
    {
      uint64_t v9 = 4 * (*(_DWORD *)(*((void *)a1 + 9) + 104) / 2);
      uint64_t v10 = (void *)(((uint64_t)(*(_DWORD *)(*((void *)a1 + 9) + 104) + (*(int *)(*((void *)a1 + 9) + 104) < 0)) >> 1) & 0x3FFFFFFFFFFFFFFFLL);
      uint64_t v6 = 5243;
      while (1)
      {
        uint64_t v11 = *v7;
        uint64_t v12 = malloc_type_malloc(v9, 0x100004052888210uLL);
        if (!v12) {
          break;
        }
        if ((vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState(a1, v11) & 1) == 0)
        {
          free(v12);
          uint64_t v6 = 5244;
          break;
        }
        vision::mod::GreedyClustererFacesWithTorso::getAverageDescriptorOfClusterContainingFace(a1, v11, (uint64_t)&v19, v12);
        int v13 = operator new(8uLL);
        *int v13 = v11;
        v15[1] = v13 + 1;
        void v15[2] = v13 + 1;
        v15[0] = v13;
        vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)v16, v15, v12, v9, 1, 1);
        int v17 = 1;
        unsigned int v18 = 0;
        v16[0] = &unk_1EF752918;
        v16[12] = v10;
        operator delete(v13);
        (*(void (**)(uint64_t, void **))(*(void *)a3 + 40))(a3, v16);
        v16[0] = &unk_1EF752918;
        free(v18);
        vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(v16);
        if (++v7 == v8) {
          goto LABEL_7;
        }
      }
    }
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v20[0]);
  return v6;
}

void sub_1A3F1D650(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*(void **)(v1 - 104));
  _Unwind_Resume(a1);
}

void vision::mod::GreedyClustererFacesWithTorso::getAverageDescriptorOfClusterContainingFace(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if ((vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState((vision::mod::GreedyClustererFacesWithTorso *)a1, a2) & 1) == 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v20 = 5244;
    goto LABEL_24;
  }
  if (!a4)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v20 = 5245;
LABEL_24:
    void *exception = v20;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  int v8 = *(_DWORD *)(a1[9] + 104);
  if (v8 >= 0) {
    int v9 = *(_DWORD *)(a1[9] + 104);
  }
  else {
    int v9 = v8 + 1;
  }
  memset(a4, 48, 4 * (v9 >> 1));
  uint64_t v10 = (void *)a1[19];
  if (!v10) {
    goto LABEL_16;
  }
  uint64_t v11 = a1 + 19;
  do
  {
    uint64_t v12 = v10[4];
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      float v14 = v10;
    }
    else {
      float v14 = v10 + 1;
    }
    if (!v13) {
      uint64_t v11 = v10;
    }
    uint64_t v10 = (void *)*v14;
  }
  while (*v14);
  if (v11 == a1 + 19 || v11[4] > a2) {
LABEL_16:
  }
    uint64_t v11 = a1 + 19;
  uint64_t v15 = v11[5];
  uint64_t v34 = v15;
  BOOL v16 = *(void **)(a3 + 8);
  if (!v16)
  {
LABEL_23:
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v20 = 5224;
    goto LABEL_24;
  }
  vDSP_Length v17 = (uint64_t)v9 >> 1;
  while (1)
  {
    uint64_t v18 = v16[4];
    if (v15 >= v18) {
      break;
    }
LABEL_22:
    BOOL v16 = (void *)*v16;
    if (!v16) {
      goto LABEL_23;
    }
  }
  if (v18 < v15)
  {
    ++v16;
    goto LABEL_22;
  }
  unsigned int v21 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)a3, v15, &v34);
  int v23 = (uint64_t *)v21[5];
  int v22 = (uint64_t *)v21[6];
  float __B = 1.0 / (float)(unint64_t)(v22 - v23);
  if (v22 != v23)
  {
    float v24 = a1 + 16;
    do
    {
      float v25 = (void *)*v24;
      if (!*v24) {
        goto LABEL_37;
      }
      uint64_t v26 = *v23;
      int v27 = a1 + 16;
      do
      {
        uint64_t v28 = v25[4];
        BOOL v29 = v28 < v26;
        if (v28 >= v26) {
          uint64_t v30 = v25;
        }
        else {
          uint64_t v30 = v25 + 1;
        }
        if (!v29) {
          int v27 = v25;
        }
        float v25 = (void *)*v30;
      }
      while (*v30);
      if (v27 == v24 || v26 < v27[4]) {
LABEL_37:
      }
        int v27 = a1 + 16;
      uint64_t v31 = *(void *)(a1[9] + 88);
      if (v31) {
        unint64_t v32 = *(void *)v31
      }
            + *((unsigned int *)v27 + 10) * (unint64_t)*(unsigned int *)(*(void *)v31 + 16)
            + 24;
      else {
        unint64_t v32 = 0;
      }
      vDSP_vadd((const float *)(v32 + 40), 1, (const float *)a4, 1, (float *)a4, 1, v17);
      ++v23;
    }
    while (v23 != v22);
  }
  vDSP_vsmul((const float *)a4, 1, &__B, (float *)a4, 1, v17);
}

uint64_t *std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      BOOL v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v7 = a1 + 1;
LABEL_9:
    int v9 = (uint64_t *)operator new(0x40uLL);
    v9[4] = *a3;
    v9[5] = 0;
    v9[6] = 0;
    v9[7] = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, v9);
    return v9;
  }
  return (uint64_t *)v7;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::descriptorLength(vision::mod::GreedyClustererFacesWithTorso *this)
{
  uint64_t v1 = *((void *)this + 9);
  if (v1) {
    return *(int *)(v1 + 104);
  }
  else {
    return 0;
  }
}

void vision::mod::GreedyClustererFacesWithTorso::getIdsForCluster(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if ((vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState((vision::mod::GreedyClustererFacesWithTorso *)a1, a2) & 1) == 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 5244;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t v8 = a1 + 19;
  unint64_t v9 = *std::map<long long,unsigned long>::at((void *)a1[19], a2);
  std::vector<long long>::reserve((void **)a3, a1[20] + 1);
  if (a4)
  {
    uint64_t v10 = std::__hash_table<std::__hash_value_type<long long,long long>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,long long>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,long long>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,long long>>>::__equal_range_multi<long long>(a4, v9);
    if (v10 != v11)
    {
      uint64_t v12 = v10;
      BOOL v13 = v11;
      float v14 = *(void **)(a3 + 8);
      do
      {
        unint64_t v15 = *(void *)(a3 + 16);
        if ((unint64_t)v14 >= v15)
        {
          vDSP_Length v17 = *(void **)a3;
          uint64_t v18 = ((uint64_t)v14 - *(void *)a3) >> 3;
          unint64_t v19 = v18 + 1;
          if ((unint64_t)(v18 + 1) >> 61) {
            goto LABEL_49;
          }
          uint64_t v20 = v15 - (void)v17;
          if (v20 >> 2 > v19) {
            unint64_t v19 = v20 >> 2;
          }
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v21 = v19;
          }
          if (v21)
          {
            unint64_t v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v21);
            vDSP_Length v17 = *(void **)a3;
            float v14 = *(void **)(a3 + 8);
          }
          else
          {
            uint64_t v22 = 0;
          }
          int v23 = (void *)(v21 + 8 * v18);
          *int v23 = v12[3];
          BOOL v16 = v23 + 1;
          while (v14 != v17)
          {
            uint64_t v24 = *--v14;
            *--int v23 = v24;
          }
          *(void *)a3 = v23;
          *(void *)(a3 + 8) = v16;
          *(void *)(a3 + 16) = v21 + 8 * v22;
          if (v17) {
            operator delete(v17);
          }
        }
        else
        {
          *float v14 = v12[3];
          BOOL v16 = v14 + 1;
        }
        *(void *)(a3 + 8) = v16;
        uint64_t v12 = (void *)*v12;
        float v14 = v16;
      }
      while (v12 != v13);
    }
  }
  else
  {
    float v25 = (void *)a1[18];
    if (v25 != v8)
    {
      do
      {
        if (v25[5] == v9)
        {
          int v27 = *(void **)(a3 + 8);
          unint64_t v26 = *(void *)(a3 + 16);
          if ((unint64_t)v27 >= v26)
          {
            BOOL v29 = *(void **)a3;
            uint64_t v30 = ((uint64_t)v27 - *(void *)a3) >> 3;
            unint64_t v31 = v30 + 1;
            if ((unint64_t)(v30 + 1) >> 61) {
LABEL_49:
            }
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            uint64_t v32 = v26 - (void)v29;
            if (v32 >> 2 > v31) {
              unint64_t v31 = v32 >> 2;
            }
            if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v33 = v31;
            }
            if (v33)
            {
              unint64_t v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v33);
              BOOL v29 = *(void **)a3;
              int v27 = *(void **)(a3 + 8);
            }
            else
            {
              uint64_t v34 = 0;
            }
            unint64_t v35 = (void *)(v33 + 8 * v30);
            *unint64_t v35 = v25[4];
            uint64_t v28 = v35 + 1;
            while (v27 != v29)
            {
              uint64_t v36 = *--v27;
              *--unint64_t v35 = v36;
            }
            *(void *)a3 = v35;
            *(void *)(a3 + 8) = v28;
            *(void *)(a3 + 16) = v33 + 8 * v34;
            if (v29) {
              operator delete(v29);
            }
          }
          else
          {
            *int v27 = v25[4];
            uint64_t v28 = v27 + 1;
          }
          *(void *)(a3 + 8) = v28;
        }
        unint64_t v37 = (void *)v25[1];
        if (v37)
        {
          do
          {
            float v38 = v37;
            unint64_t v37 = (void *)*v37;
          }
          while (v37);
        }
        else
        {
          do
          {
            float v38 = (void *)v25[2];
            BOOL v39 = *v38 == (void)v25;
            float v25 = v38;
          }
          while (!v39);
        }
        float v25 = v38;
      }
      while (v38 != v8);
    }
  }
}

void *std::__hash_table<std::__hash_value_type<long long,long long>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,long long>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,long long>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,long long>>>::__equal_range_multi<long long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  uint64_t v6 = *(void **)(*a1 + 8 * v4);
  if (!v6) {
    return 0;
  }
  BOOL result = (void *)*v6;
  if (!*v6) {
    return result;
  }
  while (1)
  {
    unint64_t v7 = result[1];
    if (v7 == a2) {
      break;
    }
    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= *(void *)&v2) {
        v7 %= *(void *)&v2;
      }
    }
    else
    {
      v7 &= *(void *)&v2 - 1;
    }
    if (v7 != v4) {
      return 0;
    }
LABEL_17:
    BOOL result = (void *)*result;
    if (!result) {
      return result;
    }
  }
  if (result[2] != a2) {
    goto LABEL_17;
  }
  uint64_t v8 = result;
  do
    uint64_t v8 = (void *)*v8;
  while (v8 && v8[2] == a2);
  return result;
}

void vision::mod::GreedyClustererFacesWithTorso::getAllClustersFromState(vision::mod::GreedyClustererFacesWithTorso *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v30 = (uint64_t *)v31;
  uint8x8_t v3 = (char *)*((void *)this + 18);
  unint64_t v4 = (char *)this + 152;
  if (v3 != (char *)this + 152)
  {
    do
    {
      uint64_t v5 = *((void *)v3 + 4);
      uint64_t v28 = *((void *)v3 + 5);
      uint64_t v6 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v30, v28, &v28);
      unint64_t v7 = v6;
      unint64_t v9 = (char *)v6[6];
      unint64_t v8 = v6[7];
      if ((unint64_t)v9 >= v8)
      {
        uint64_t v11 = (char *)v6[5];
        uint64_t v12 = (v9 - v11) >> 3;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v8 - (void)v11;
        if (v14 >> 2 > v13) {
          unint64_t v13 = v14 >> 2;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
          uint64_t v11 = (char *)v7[5];
          unint64_t v9 = (char *)v7[6];
        }
        else
        {
          uint64_t v16 = 0;
        }
        vDSP_Length v17 = (void *)(v15 + 8 * v12);
        *vDSP_Length v17 = v5;
        uint64_t v10 = v17 + 1;
        while (v9 != v11)
        {
          uint64_t v18 = *((void *)v9 - 1);
          v9 -= 8;
          *--vDSP_Length v17 = v18;
        }
        void v7[5] = (uint64_t)v17;
        v7[6] = (uint64_t)v10;
        v7[7] = v15 + 8 * v16;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(void *)unint64_t v9 = v5;
        uint64_t v10 = v9 + 8;
      }
      v7[6] = (uint64_t)v10;
      unint64_t v19 = (char *)*((void *)v3 + 1);
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          unint64_t v19 = *(char **)v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (char *)*((void *)v3 + 2);
          BOOL v21 = *(void *)v20 == (void)v3;
          uint8x8_t v3 = v20;
        }
        while (!v21);
      }
      uint8x8_t v3 = v20;
    }
    while (v20 != v4);
    uint64_t v22 = v30;
    if (v30 != (uint64_t *)v31)
    {
      do
      {
        int v23 = (const void *)v22[5];
        uint64_t v28 = v22[4];
        memset(__p, 0, sizeof(__p));
        std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(__p, v23, v22[6], (v22[6] - (uint64_t)v23) >> 3);
        unint64_t v24 = a2[1];
        if (v24 >= a2[2])
        {
          uint64_t v25 = std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>(a2, (uint64_t)__p);
        }
        else
        {
          std::vector<std::vector<long long>>::__construct_one_at_end[abi:ne180100]<std::vector<long long> const&>((uint64_t)a2, (uint64_t)__p);
          uint64_t v25 = v24 + 24;
        }
        a2[1] = v25;
        if (__p[0]) {
          operator delete(__p[0]);
        }
        unint64_t v26 = (uint64_t *)v22[1];
        if (v26)
        {
          do
          {
            int v27 = v26;
            unint64_t v26 = (uint64_t *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            int v27 = (uint64_t *)v22[2];
            BOOL v21 = *v27 == (void)v22;
            uint64_t v22 = v27;
          }
          while (!v21);
        }
        uint64_t v22 = v27;
      }
      while (v27 != (uint64_t *)v31);
    }
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v31[0]);
}

void sub_1A3F1DED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
}

void vision::mod::GreedyClustererFacesWithTorso::getClusters(vision::mod::GreedyClustererFacesWithTorso *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v30 = (uint64_t *)v31;
  uint8x8_t v3 = (char *)*((void *)this + 18);
  unint64_t v4 = (char *)this + 152;
  if (v3 != (char *)this + 152)
  {
    do
    {
      uint64_t v5 = *((void *)v3 + 4);
      uint64_t v28 = *((void *)v3 + 5);
      uint64_t v6 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v30, v28, &v28);
      unint64_t v7 = v6;
      unint64_t v9 = (char *)v6[6];
      unint64_t v8 = v6[7];
      if ((unint64_t)v9 >= v8)
      {
        uint64_t v11 = (char *)v6[5];
        uint64_t v12 = (v9 - v11) >> 3;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v8 - (void)v11;
        if (v14 >> 2 > v13) {
          unint64_t v13 = v14 >> 2;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
          uint64_t v11 = (char *)v7[5];
          unint64_t v9 = (char *)v7[6];
        }
        else
        {
          uint64_t v16 = 0;
        }
        vDSP_Length v17 = (void *)(v15 + 8 * v12);
        *vDSP_Length v17 = v5;
        uint64_t v10 = v17 + 1;
        while (v9 != v11)
        {
          uint64_t v18 = *((void *)v9 - 1);
          v9 -= 8;
          *--vDSP_Length v17 = v18;
        }
        void v7[5] = (uint64_t)v17;
        v7[6] = (uint64_t)v10;
        v7[7] = v15 + 8 * v16;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(void *)unint64_t v9 = v5;
        uint64_t v10 = v9 + 8;
      }
      v7[6] = (uint64_t)v10;
      unint64_t v19 = (char *)*((void *)v3 + 1);
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          unint64_t v19 = *(char **)v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (char *)*((void *)v3 + 2);
          BOOL v21 = *(void *)v20 == (void)v3;
          uint8x8_t v3 = v20;
        }
        while (!v21);
      }
      uint8x8_t v3 = v20;
    }
    while (v20 != v4);
    uint64_t v22 = v30;
    if (v30 != (uint64_t *)v31)
    {
      do
      {
        int v23 = (const void *)v22[5];
        uint64_t v28 = v22[4];
        memset(__p, 0, sizeof(__p));
        std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(__p, v23, v22[6], (v22[6] - (uint64_t)v23) >> 3);
        unint64_t v24 = a2[1];
        if (v24 >= a2[2])
        {
          uint64_t v25 = std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>(a2, (uint64_t)__p);
        }
        else
        {
          std::vector<std::vector<long long>>::__construct_one_at_end[abi:ne180100]<std::vector<long long> const&>((uint64_t)a2, (uint64_t)__p);
          uint64_t v25 = v24 + 24;
        }
        a2[1] = v25;
        if (__p[0]) {
          operator delete(__p[0]);
        }
        unint64_t v26 = (uint64_t *)v22[1];
        if (v26)
        {
          do
          {
            int v27 = v26;
            unint64_t v26 = (uint64_t *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            int v27 = (uint64_t *)v22[2];
            BOOL v21 = *v27 == (void)v22;
            uint64_t v22 = v27;
          }
          while (!v21);
        }
        uint64_t v22 = v27;
      }
      while (v27 != (uint64_t *)v31);
    }
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v31[0]);
}

void sub_1A3F1E12C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
}

double vision::mod::GreedyClustererFacesWithTorso::getClusteredIds(uint64_t a1, uint64_t a2)
{
  allKeys<long long,unsigned long>((char **)&v5, (void *)(a1 + 120));
  uint8x8_t v3 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v3;
    operator delete(v3);
  }
  double result = *(double *)&v5;
  *(_OWORD *)a2 = v5;
  *(void *)(a2 + 16) = v6;
  return result;
}

void allKeys<long long,unsigned long>(char **a1, void *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int8x8_t v2 = a2 + 1;
  uint8x8_t v3 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    long long v5 = 0;
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      if ((unint64_t)v7 >= v6)
      {
        uint64_t v8 = (v7 - v5) >> 3;
        unint64_t v9 = v8 + 1;
        if ((unint64_t)(v8 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        if ((uint64_t)(v6 - (void)v5) >> 2 > v9) {
          unint64_t v9 = (uint64_t)(v6 - (void)v5) >> 2;
        }
        if (v6 - (unint64_t)v5 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v10 = v9;
        }
        if (v10) {
          unint64_t v10 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v10);
        }
        else {
          uint64_t v11 = 0;
        }
        uint64_t v12 = (char *)(v10 + 8 * v8);
        *(void *)uint64_t v12 = v3[4];
        unint64_t v13 = v12 + 8;
        while (v7 != v5)
        {
          uint64_t v14 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v12 - 1) = v14;
          v12 -= 8;
        }
        unint64_t v6 = v10 + 8 * v11;
        *a1 = v12;
        a1[1] = v13;
        a1[2] = (char *)v6;
        if (v5) {
          operator delete(v5);
        }
        long long v5 = v12;
        unint64_t v7 = v13;
      }
      else
      {
        *(void *)unint64_t v7 = v3[4];
        v7 += 8;
      }
      a1[1] = v7;
      unint64_t v15 = (void *)v3[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          unint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v3[2];
          BOOL v17 = *v16 == (void)v3;
          uint8x8_t v3 = v16;
        }
        while (!v17);
      }
      uint8x8_t v3 = v16;
    }
    while (v16 != v2);
  }
}

void sub_1A3F1E300(_Unwind_Exception *exception_object)
{
  uint8x8_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::getMaximumFaceId(vision::mod::GreedyClustererFacesWithTorso *this)
{
  uint64_t v1 = (void *)*((void *)this + 18);
  int8x8_t v2 = (char *)this + 152;
  if (v1 == (void *)((char *)this + 152)) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    if (result <= v1[4]) {
      uint64_t result = v1[4];
    }
    unint64_t v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        long long v5 = v4;
        unint64_t v4 = (void *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        long long v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        uint64_t v1 = v5;
      }
      while (!v6);
    }
    uint64_t v1 = v5;
  }
  while (v5 != (void *)v2);
  return result;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::getClusterIdForFaceId(vision::mod::GreedyClustererFacesWithTorso *this, uint64_t a2)
{
  if (vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState(this, a2)) {
    return *std::map<long long,unsigned long>::at(*((void **)this + 19), a2);
  }
  else {
    return -1;
  }
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::computeClusterMapL1(uint64_t a1, uint64_t **a2)
{
  int8x8_t v2 = *(void **)(a1 + 144);
  uint8x8_t v3 = (void *)(a1 + 152);
  if (v2 != (void *)(a1 + 152))
  {
    do
    {
      long long v22 = *((_OWORD *)v2 + 2);
      long long v5 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, *((uint64_t *)&v22 + 1), (uint64_t *)&v22 + 1);
      BOOL v6 = v5;
      uint64_t v8 = (char *)v5[6];
      unint64_t v7 = v5[7];
      if ((unint64_t)v8 >= v7)
      {
        unint64_t v10 = (char *)v5[5];
        uint64_t v11 = (v8 - v10) >> 3;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v7 - (void)v10;
        if (v13 >> 2 > v12) {
          unint64_t v12 = v13 >> 2;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v14);
          unint64_t v10 = (char *)v6[5];
          uint64_t v8 = (char *)v6[6];
        }
        else
        {
          uint64_t v15 = 0;
        }
        uint64_t v16 = (void *)(v14 + 8 * v11);
        void *v16 = v22;
        unint64_t v9 = v16 + 1;
        while (v8 != v10)
        {
          uint64_t v17 = *((void *)v8 - 1);
          v8 -= 8;
          *--uint64_t v16 = v17;
        }
        v6[5] = (uint64_t)v16;
        v6[6] = (uint64_t)v9;
        void v6[7] = v14 + 8 * v15;
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        *(void *)uint64_t v8 = v22;
        unint64_t v9 = v8 + 8;
      }
      v6[6] = (uint64_t)v9;
      uint64_t v18 = (void *)v2[1];
      if (v18)
      {
        do
        {
          unint64_t v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          unint64_t v19 = (void *)v2[2];
          BOOL v20 = *v19 == (void)v2;
          int8x8_t v2 = v19;
        }
        while (!v20);
      }
      int8x8_t v2 = v19;
    }
    while (v19 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::getDistanceBetweenLevel1ClustersContaining(vision::mod::GreedyClustererFacesWithTorso *a1, uint64_t a2, uint64_t **a3, uint64_t a4, char **a5)
{
  if (!vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState(a1, a2)) {
    return 5244;
  }
  unint64_t v10 = (uint64_t)(*(_DWORD *)(*((void *)a1 + 9) + 104) + (*(int *)(*((void *)a1 + 9) + 104) < 0)) >> 1;
  v20[0] = 0;
  std::vector<float>::vector(v21, v10, v20);
  vision::mod::GreedyClustererFacesWithTorso::getAverageDescriptorOfClusterContainingFace(a1, a2, a4, v21[0]);
  int v11 = (*(uint64_t (**)(vision::mod::GreedyClustererFacesWithTorso *))(*(void *)a1 + 168))(a1);
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v20, v11, 2);
  std::vector<float>::resize(a5, a3[1] - *a3);
  unint64_t v12 = *a3;
  uint64_t v13 = a3[1];
  if (*a3 == v13)
  {
    uint64_t v15 = &CVML_status_ok;
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v15 = &CVML_status_invalidParameter;
    while (1)
    {
      uint64_t v16 = *v12;
      if ((vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState(a1, *v12) & 1) == 0) {
        break;
      }
      __C[0] = 0.0;
      std::vector<float>::vector(__B, v10, __C);
      vision::mod::GreedyClustererFacesWithTorso::getAverageDescriptorOfClusterContainingFace(a1, v16, a4, __B[0]);
      __C[0] = 0.0;
      vDSP_dotpr((const float *)v21[0], 1, __B[0], 1, __C, 0x80uLL);
      *(float *)&(*a5)[v14] = (float)(__C[0] * -0.5) + 0.5;
      if (__B[0])
      {
        __B[1] = __B[0];
        operator delete(__B[0]);
      }
      ++v12;
      v14 += 4;
      if (v12 == v13)
      {
        uint64_t v15 = &CVML_status_ok;
        break;
      }
    }
  }
  uint64_t v18 = *v15;
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v20);
  if (v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }
  return (v18 + 128) | 0x1400;
}

void sub_1A3F1E70C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a12);
  uint64_t v14 = *(void **)(v12 - 136);
  if (v14)
  {
    *(void *)(v12 - 128) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(a1);
}

uint64_t vision::mod::dist_greedy_status_t::dist_greedy_status_t(uint64_t a1, int a2, int a3)
{
  BOOL v6 = operator new(8uLL);
  *BOOL v6 = 1;
  uint64_t v17 = v6 + 1;
  uint64_t v18 = v6 + 1;
  uint64_t v16 = v6;
  if (a2 <= 0) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  }
  vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract(a1, &v16, v7, 4 * a2, 1, 1);
  *(void *)a1 = &unk_1EF752918;
  *(_DWORD *)(a1 + 104) = 1;
  *(void *)(a1 + 112) = 0;
  uint64_t v8 = a2 & 0x3FFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 96) = v8;
  operator delete(v6);
  unint64_t v9 = operator new(8uLL);
  void *v9 = 1;
  uint64_t v17 = v9 + 1;
  uint64_t v18 = v9 + 1;
  uint64_t v16 = v9;
  if (a2 < 1) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  }
  vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract(a1 + 120, &v16, v10, 4 * a2, 1, 1);
  *(void *)(a1 + 120) = &unk_1EF752918;
  *(_DWORD *)(a1 + 224) = 1;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 216) = v8;
  operator delete(v9);
  uint64_t v11 = *(void *)(a1 + 56);
  if (!v11)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 5243;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t v12 = *(void *)(a1 + 176);
  if (!v12)
  {
    uint64_t v15 = __cxa_allocate_exception(8uLL);
    *uint64_t v15 = 5243;
    __cxa_throw(v15, MEMORY[0x1E4FBA3E0], 0);
  }
  *(_DWORD *)(a1 + 104) = a3;
  *(_DWORD *)(a1 + 224) = a3;
  *(void *)(a1 + 240) = v11;
  *(void *)(a1 + 248) = v12;
  return a1;
}

void sub_1A3F1E954(_Unwind_Exception *a1)
{
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32(v2);
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32(v1);
  _Unwind_Resume(a1);
}

void vision::mod::dist_greedy_status_t::~dist_greedy_status_t(vision::mod::dist_greedy_status_t *this)
{
  int8x8_t v2 = (void **)((char *)this + 120);
  *((void *)this + 15) = &unk_1EF752918;
  free(*((void **)this + 29));
  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(v2);
  *(void *)this = &unk_1EF752918;
  free(*((void **)this + 14));

  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract((void **)this);
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::getDistanceBetweenLevel0ClustersContaining(vision::mod::GreedyClustererFacesWithTorso *this, uint64_t a2, uint64_t a3, float *a4)
{
  if (vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState(this, a2)
    && vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState(this, a3))
  {
    uint64_t v8 = *((void *)this + 9);
    unint64_t v9 = std::map<long long,unsigned long>::at(*((void **)this + 16), a2);
    uint64_t v10 = *(void *)(v8 + 88);
    if (v10) {
      unint64_t v11 = *(void *)v10 + *(unsigned int *)v9 * (unint64_t)*(unsigned int *)(*(void *)v10 + 16) + 24;
    }
    else {
      unint64_t v11 = 0;
    }
    uint64_t v13 = *((void *)this + 9);
    uint64_t v14 = std::map<long long,unsigned long>::at(*((void **)this + 16), a3);
    unint64_t v15 = *(void *)(v13 + 88);
    if (v15) {
      unint64_t v15 = *(void *)v15 + *(unsigned int *)v14 * (unint64_t)*(unsigned int *)(*(void *)v15 + 16) + 24;
    }
    uint64_t v16 = (const float *)(v11 + 40);
    uint64_t v17 = (const float *)(v15 + 40);
    int v18 = (*(uint64_t (**)(vision::mod::GreedyClustererFacesWithTorso *))(*(void *)this + 168))(this);
    if (v18 >= 0) {
      int v19 = v18;
    }
    else {
      int v19 = v18 + 1;
    }
    int v20 = v19 >> 1;
    uint64_t __C = 0;
    vDSP_Length v21 = (uint64_t)v19 >> 1;
    vDSP_dotpr(v16, 1, v17, 1, (float *)&__C + 1, v21);
    vDSP_dotpr(&v16[v20], 1, &v17[v20], 1, (float *)&__C, v21);
    float v22 = *((float *)&__C + 1) * -0.5 + 0.5;
    *a4 = v22;
    uint64_t v12 = &CVML_status_ok;
  }
  else
  {
    uint64_t v12 = &CVML_status_invalidParameter;
  }
  return (*v12 + 128) | 0x1400;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::getLevel0FacesToClusterContaining(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState((vision::mod::GreedyClustererFacesWithTorso *)a1, a2))
  {
    uint64_t v6 = *(void *)(a1 + 72);
    unint64_t v7 = std::map<long long,unsigned long>::at(*(void **)(a1 + 128), a2);
    uint64_t v8 = std::map<unsigned long,std::list<long long>>::at(*(void **)(a1 + 104), *(void *)(**(void **)(v6 + 88)+ *(unsigned int *)v7 * (unint64_t)*(unsigned int *)(**(void **)(v6 + 88) + 16)+ 24));
    if (v8 != a3) {
      std::list<long long>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<long long,void *>,std::__list_const_iterator<long long,void *>>(a3, v8[1], (uint64_t)v8);
    }
    unint64_t v9 = &CVML_status_ok;
  }
  else
  {
    unint64_t v9 = &CVML_status_invalidParameter;
  }
  return (*v9 + 128) | 0x1400;
}

void *std::map<unsigned long,std::list<long long>>::at(void *a1, unint64_t a2)
{
  if (!a1) {
LABEL_7:
  }
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      unint64_t v2 = a1[4];
      if (v2 <= a2) {
        break;
      }
      a1 = (void *)*a1;
      if (!a1) {
        goto LABEL_7;
      }
    }
    if (v2 >= a2) {
      return a1 + 5;
    }
    a1 = (void *)a1[1];
    if (!a1) {
      goto LABEL_7;
    }
  }
}

uint64_t *std::list<long long>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<long long,void *>,std::__list_const_iterator<long long,void *>>(uint64_t *result, uint64_t a2, uint64_t a3)
{
  long long v5 = result;
  for (uint64_t i = (uint64_t *)result[1]; a2 != a3 && i != result; uint64_t i = (uint64_t *)i[1])
  {
    i[2] = *(void *)(a2 + 16);
    a2 = *(void *)(a2 + 8);
  }
  if (i == result)
  {
    if (a2 != a3)
    {
      uint64_t result = (uint64_t *)operator new(0x18uLL);
      uint64_t v8 = result;
      *uint64_t result = 0;
      result[1] = 0;
      uint64_t v9 = *(void *)(a2 + 8);
      result[2] = *(void *)(a2 + 16);
      uint64_t v10 = 1;
      if (v9 != a3)
      {
        unint64_t v11 = result;
        do
        {
          uint64_t result = (uint64_t *)operator new(0x18uLL);
          *uint64_t result = (uint64_t)v11;
          result[1] = 0;
          result[2] = *(void *)(v9 + 16);
          v11[1] = (uint64_t)result;
          ++v10;
          uint64_t v9 = *(void *)(v9 + 8);
          unint64_t v11 = result;
        }
        while (v9 != a3);
      }
      uint64_t v12 = *v5;
      *(void *)(v12 + 8) = v8;
      *uint64_t v8 = v12;
      *long long v5 = (uint64_t)result;
      result[1] = (uint64_t)v5;
      v5[2] += v10;
    }
  }
  else
  {
    return std::list<long long>::erase((uint64_t)result, i, result);
  }
  return result;
}

void sub_1A3F1EDAC(void *a1)
{
  __cxa_begin_catch(a1);
  do
  {
    unint64_t v2 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1A3F1EDCC(_Unwind_Exception *a1)
{
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::computeClusterLookupMapL1(uint64_t a1, uint64_t **a2)
{
  unint64_t v2 = *(void **)(a1 + 144);
  uint8x8_t v3 = (void *)(a1 + 152);
  if (v2 != (void *)(a1 + 152))
  {
    do
    {
      long long v5 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, v2[4], v2 + 4);
      uint64_t v6 = v5;
      uint64_t v8 = (char *)v5[6];
      unint64_t v7 = v5[7];
      if ((unint64_t)v8 >= v7)
      {
        uint64_t v10 = (char *)v5[5];
        uint64_t v11 = (v8 - v10) >> 3;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v7 - (void)v10;
        if (v13 >> 2 > v12) {
          unint64_t v12 = v13 >> 2;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v14);
          uint64_t v10 = (char *)v6[5];
          uint64_t v8 = (char *)v6[6];
        }
        else
        {
          uint64_t v15 = 0;
        }
        uint64_t v16 = (void *)(v14 + 8 * v11);
        void *v16 = v2[5];
        uint64_t v9 = v16 + 1;
        while (v8 != v10)
        {
          uint64_t v17 = *((void *)v8 - 1);
          v8 -= 8;
          *--uint64_t v16 = v17;
        }
        v6[5] = (uint64_t)v16;
        v6[6] = (uint64_t)v9;
        void v6[7] = v14 + 8 * v15;
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        *(void *)uint64_t v8 = v2[5];
        uint64_t v9 = v8 + 8;
      }
      v6[6] = (uint64_t)v9;
      int v18 = (void *)v2[1];
      if (v18)
      {
        do
        {
          int v19 = v18;
          int v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          int v19 = (void *)v2[2];
          BOOL v20 = *v19 == (void)v2;
          unint64_t v2 = v19;
        }
        while (!v20);
      }
      unint64_t v2 = v19;
    }
    while (v19 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::computeClusterMapL0(uint64_t a1, uint64_t **a2)
{
  unint64_t v2 = *(void **)(a1 + 96);
  uint8x8_t v3 = (void *)(a1 + 104);
  if (v2 != (void *)(a1 + 104))
  {
    do
    {
      for (uint64_t i = (void *)v2[6]; i != v2 + 5; uint64_t i = (void *)i[1])
      {
        uint64_t v23 = v2[4];
        uint64_t v6 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, v23, &v23);
        unint64_t v7 = v6;
        uint64_t v9 = (char *)v6[6];
        unint64_t v8 = v6[7];
        if ((unint64_t)v9 >= v8)
        {
          uint64_t v11 = (char *)v6[5];
          uint64_t v12 = (v9 - v11) >> 3;
          unint64_t v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 61) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v14 = v8 - (void)v11;
          if (v14 >> 2 > v13) {
            unint64_t v13 = v14 >> 2;
          }
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v15 = v13;
          }
          if (v15)
          {
            unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
            uint64_t v11 = (char *)v7[5];
            uint64_t v9 = (char *)v7[6];
          }
          else
          {
            uint64_t v16 = 0;
          }
          uint64_t v17 = (void *)(v15 + 8 * v12);
          *uint64_t v17 = i[2];
          uint64_t v10 = v17 + 1;
          while (v9 != v11)
          {
            uint64_t v18 = *((void *)v9 - 1);
            v9 -= 8;
            *--uint64_t v17 = v18;
          }
          void v7[5] = (uint64_t)v17;
          v7[6] = (uint64_t)v10;
          v7[7] = v15 + 8 * v16;
          if (v11) {
            operator delete(v11);
          }
        }
        else
        {
          *(void *)uint64_t v9 = i[2];
          uint64_t v10 = v9 + 8;
        }
        v7[6] = (uint64_t)v10;
      }
      int v19 = (void *)v2[1];
      if (v19)
      {
        do
        {
          BOOL v20 = v19;
          int v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          BOOL v20 = (void *)v2[2];
          BOOL v21 = *v20 == (void)v2;
          unint64_t v2 = v20;
        }
        while (!v21);
      }
      unint64_t v2 = v20;
    }
    while (v20 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::computeClusterLookupMapL0(uint64_t a1, uint64_t **a2)
{
  unint64_t v2 = *(void **)(a1 + 120);
  uint8x8_t v3 = (void *)(a1 + 128);
  if (v2 != (void *)(a1 + 128))
  {
    do
    {
      long long v5 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, v2[4], v2 + 4);
      uint64_t v6 = v5;
      uint64_t v7 = v2[5];
      uint64_t v9 = (char *)v5[6];
      unint64_t v8 = v5[7];
      if ((unint64_t)v9 >= v8)
      {
        uint64_t v11 = (char *)v5[5];
        uint64_t v12 = (v9 - v11) >> 3;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v8 - (void)v11;
        if (v14 >> 2 > v13) {
          unint64_t v13 = v14 >> 2;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
          uint64_t v11 = (char *)v6[5];
          uint64_t v9 = (char *)v6[6];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = (void *)(v15 + 8 * v12);
        *uint64_t v17 = v7;
        uint64_t v10 = v17 + 1;
        while (v9 != v11)
        {
          uint64_t v18 = *((void *)v9 - 1);
          v9 -= 8;
          *--uint64_t v17 = v18;
        }
        v6[5] = (uint64_t)v17;
        v6[6] = (uint64_t)v10;
        void v6[7] = v15 + 8 * v16;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(void *)uint64_t v9 = v7;
        uint64_t v10 = v9 + 8;
      }
      v6[6] = (uint64_t)v10;
      int v19 = (void *)v2[1];
      if (v19)
      {
        do
        {
          BOOL v20 = v19;
          int v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          BOOL v20 = (void *)v2[2];
          BOOL v21 = *v20 == (void)v2;
          unint64_t v2 = v20;
        }
        while (!v21);
      }
      unint64_t v2 = v20;
    }
    while (v20 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(vision::mod::GreedyClustererFacesWithTorso *a1, uint64_t **a2, uint64_t a3, _DWORD *a4)
{
  if (!vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState(a1, a3)) {
    goto LABEL_43;
  }
  uint64_t v9 = *a2;
  unint64_t v8 = a2[1];
  if (v8 == *a2) {
    goto LABEL_43;
  }
  uint64_t v10 = (void *)((char *)a1 + 152);
  if (!*((void *)a1 + 19))
  {
LABEL_42:
    syslog(5, "FaceId=%lld not present in clustering", a3);
LABEL_43:
    uint64_t v43 = -4;
    return (v43 + 128) | 0x1400;
  }
  do
  {
    uint64_t v11 = *v9;
    uint64_t v12 = (void *)*((void *)a1 + 19);
    while (1)
    {
      uint64_t v13 = v12[4];
      if (v11 >= v13) {
        break;
      }
LABEL_8:
      uint64_t v12 = (void *)*v12;
      if (!v12) {
        goto LABEL_42;
      }
    }
    if (v13 < v11)
    {
      ++v12;
      goto LABEL_8;
    }
    ++v9;
  }
  while (v9 != v8);
  v57[0] = 0;
  v57[1] = 0;
  float v56 = (uint64_t *)v57;
  uint64_t v14 = (void *)*((void *)a1 + 18);
  if (v14 != v10)
  {
    do
    {
      *(_OWORD *)std::string __p = *((_OWORD *)v14 + 2);
      unint64_t v15 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v56, (uint64_t)__p[1], (uint64_t *)&__p[1]);
      uint64_t v16 = v15;
      uint64_t v18 = (void **)v15[6];
      unint64_t v17 = v15[7];
      if ((unint64_t)v18 >= v17)
      {
        BOOL v20 = (void **)v15[5];
        uint64_t v21 = v18 - v20;
        unint64_t v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v23 = v17 - (void)v20;
        if (v23 >> 2 > v22) {
          unint64_t v22 = v23 >> 2;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v24 = v22;
        }
        if (v24)
        {
          unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v24);
          BOOL v20 = (void **)v16[5];
          uint64_t v18 = (void **)v16[6];
        }
        else
        {
          uint64_t v25 = 0;
        }
        unint64_t v26 = (void **)(v24 + 8 * v21);
        *unint64_t v26 = __p[0];
        int v19 = v26 + 1;
        while (v18 != v20)
        {
          int v27 = *--v18;
          *--unint64_t v26 = v27;
        }
        v16[5] = (uint64_t)v26;
        v16[6] = (uint64_t)v19;
        v16[7] = v24 + 8 * v25;
        if (v20) {
          operator delete(v20);
        }
      }
      else
      {
        void *v18 = __p[0];
        int v19 = v18 + 1;
      }
      v16[6] = (uint64_t)v19;
      uint64_t v28 = (void *)v14[1];
      if (v28)
      {
        do
        {
          BOOL v29 = v28;
          uint64_t v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          BOOL v29 = (void *)v14[2];
          BOOL v30 = *v29 == (void)v14;
          uint64_t v14 = v29;
        }
        while (!v30);
      }
      uint64_t v14 = v29;
    }
    while (v29 != v10);
  }
  int v31 = *(_DWORD *)(*((void *)a1 + 9) + 104);
  if (v31 >= 0) {
    int v32 = *(_DWORD *)(*((void *)a1 + 9) + 104);
  }
  else {
    int v32 = v31 + 1;
  }
  unint64_t v33 = (char *)malloc_type_malloc(4 * (int)(v32 & 0xFFFFFFFE), 0x100004052888210uLL);
  if (v33)
  {
    vision::mod::GreedyClustererFacesWithTorso::getAverageDescriptorOfClusterContainingFace(a1, a3, (uint64_t)&v56, v33);
    std::vector<std::pair<float,unsigned long>>::vector((char **)__p, a2[1] - *a2);
    uint64_t v34 = *a2;
    unint64_t v35 = a2[1];
    if (*a2 == v35)
    {
      unint64_t v42 = 0;
      float v41 = __p[0];
    }
    else
    {
      uint64_t v36 = 0;
      unint64_t v37 = 0;
      float v38 = &v33[4 * (v32 >> 1)];
      do
      {
        uint64_t v39 = *v34;
        vision::mod::GreedyClustererFacesWithTorso::getAverageDescriptorOfClusterContainingFace(a1, *v34, (uint64_t)&v56, v38);
        float __C = 0.0;
        vDSP_dotpr((const float *)v33, 1, (const float *)v38, 1, &__C, 0x80uLL);
        *(float *)((char *)__p[0] + v36) = (float)(__C * -0.5) + 0.5;
        uint64_t v40 = (*(uint64_t (**)(vision::mod::GreedyClustererFacesWithTorso *, uint64_t))(*(void *)a1 + 200))(a1, v39);
        float v41 = __p[0];
        *(void *)((char *)__p[0] + v36 + 8) = v40;
        v37 += v40;
        ++v34;
        v36 += 16;
      }
      while (v34 != v35);
      unint64_t v42 = v37 >> 1;
    }
    unint64_t v45 = 126 - 2 * __clz(((char *)__p[1] - (char *)v41) >> 4);
    if (__p[1] == v41) {
      uint64_t v46 = 0;
    }
    else {
      uint64_t v46 = v45;
    }
    std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *,false>((uint64_t)v41, (unint64_t)__p[1], v46, 1);
    float v47 = a2[1];
    float v48 = __p[0];
    uint64_t v49 = (char *)v47 - (char *)*a2;
    if (v47 == *a2)
    {
      if (__p[0]) {
        goto LABEL_60;
      }
    }
    else
    {
      uint64_t v50 = 0;
      unint64_t v51 = 0;
      unint64_t v52 = v49 >> 3;
      if (v52 <= 1) {
        unint64_t v52 = 1;
      }
      float v53 = (uint64_t *)((char *)__p[0] + 8);
      while (1)
      {
        uint64_t v54 = *v53;
        v53 += 2;
        v51 += v54;
        if (v51 >= v42) {
          break;
        }
        if (v52 == ++v50) {
          goto LABEL_60;
        }
      }
      *a4 = *((_DWORD *)__p[0] + 4 * v50);
LABEL_60:
      __p[1] = v48;
      operator delete(v48);
    }
    uint64_t v43 = 0;
  }
  else
  {
    uint64_t v43 = -5;
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v57[0]);
  return (v43 + 128) | 0x1400;
}

void sub_1A3F1F5B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
}

char **std::vector<std::pair<float,unsigned long>>::vector(char **a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >> 60) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v4 = (char *)operator new(16 * a2);
    *a1 = v4;
    a1[1] = v4;
    long long v5 = &v4[16 * a2];
    a1[2] = v5;
    do
    {
      *(_DWORD *)unint64_t v4 = 0;
      *((void *)v4 + 1) = 0;
      v4 += 16;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1A3F1F664(_Unwind_Exception *exception_object)
{
  uint8x8_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = (_DWORD *)(a2 - 16);
    unint64_t v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v11;
          uint64_t v12 = a2 - v11;
          unint64_t v13 = (uint64_t)(a2 - v11) >> 4;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                float v43 = *(float *)v11;
                if (*(float *)v10 < *(float *)v11)
                {
                  *(_DWORD *)unint64_t v11 = *v10;
                  *(float *)(a2 - 16) = v43;
                  uint64_t v44 = *(void *)(v11 + 8);
                  *(void *)(v11 + 8) = *(void *)(a2 - 8);
                  *(void *)(a2 - 8) = v44;
                }
                break;
              case 3uLL:
                uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v11, v11 + 16, a2 - 16);
                break;
              case 4uLL:
                uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v11, v11 + 16, v11 + 32, a2 - 16);
                break;
              case 5uLL:
                uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v11, v11 + 16, v11 + 32, v11 + 48);
                float v45 = *(float *)(v11 + 48);
                if (*(float *)v10 < v45)
                {
                  *(_DWORD *)(v11 + 48) = *v10;
                  *(float *)(a2 - 16) = v45;
                  uint64_t v46 = *(void *)(v11 + 56);
                  *(void *)(v11 + 56) = *(void *)(a2 - 8);
                  *(void *)(a2 - 8) = v46;
                  float v47 = *(float *)(v11 + 48);
                  float v48 = *(float *)(v11 + 32);
                  if (v47 < v48)
                  {
                    *(float *)(v11 + 32) = v47;
                    *(float *)(v11 + 48) = v48;
                    uint64_t v49 = *(void *)(v11 + 40);
                    uint64_t v50 = *(void *)(v11 + 56);
                    *(void *)(v11 + 40) = v50;
                    *(void *)(v11 + 56) = v49;
                    float v51 = *(float *)(v11 + 16);
                    if (v47 < v51)
                    {
                      *(float *)(v11 + 16) = v47;
                      *(float *)(v11 + 32) = v51;
                      uint64_t v52 = *(void *)(v11 + 24);
                      *(void *)(v11 + 24) = v50;
                      *(void *)(v11 + 40) = v52;
                      float v53 = *(float *)v11;
                      if (v47 < *(float *)v11)
                      {
                        *(float *)unint64_t v11 = v47;
                        *(float *)(v11 + 16) = v53;
                        uint64_t v54 = *(void *)(v11 + 8);
                        *(void *)(v11 + 8) = v50;
                        *(void *)(v11 + 24) = v54;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 383)
          {
            unint64_t v55 = v11 + 16;
            BOOL v57 = v11 == a2 || v55 == a2;
            if (a4)
            {
              if (!v57)
              {
                uint64_t v58 = 0;
                unint64_t v59 = v11;
                do
                {
                  unint64_t v60 = v55;
                  float v61 = *(float *)(v59 + 16);
                  float v62 = *(float *)v59;
                  if (v61 < *(float *)v59)
                  {
                    uint64_t v63 = *(void *)(v59 + 24);
                    uint64_t v64 = v58;
                    while (1)
                    {
                      uint64_t v65 = v11 + v64;
                      *(float *)(v65 + 16) = v62;
                      *(void *)(v65 + 24) = *(void *)(v11 + v64 + 8);
                      if (!v64) {
                        break;
                      }
                      float v62 = *(float *)(v65 - 16);
                      v64 -= 16;
                      if (v61 >= v62)
                      {
                        uint64_t v66 = v11 + v64 + 16;
                        goto LABEL_85;
                      }
                    }
                    uint64_t v66 = v11;
LABEL_85:
                    *(float *)uint64_t v66 = v61;
                    *(void *)(v66 + 8) = v63;
                  }
                  unint64_t v55 = v60 + 16;
                  v58 += 16;
                  unint64_t v59 = v60;
                }
                while (v60 + 16 != a2);
              }
            }
            else if (!v57)
            {
              uint64_t v97 = (float *)(v11 + 24);
              do
              {
                unint64_t v98 = v55;
                float v99 = *(float *)(v9 + 16);
                float v100 = *(float *)v9;
                if (v99 < *(float *)v9)
                {
                  uint64_t v101 = *(void *)(v9 + 24);
                  uint64_t v102 = v97;
                  do
                  {
                    unint64_t v103 = v102;
                    *(v102 - 2) = v100;
                    uint64_t v104 = *((void *)v102 - 2);
                    v102 -= 4;
                    *(void *)unint64_t v103 = v104;
                    float v100 = *(v103 - 10);
                  }
                  while (v99 < v100);
                  *(v102 - 2) = v99;
                  *(void *)uint64_t v102 = v101;
                }
                unint64_t v55 = v98 + 16;
                v97 += 4;
                unint64_t v9 = v98;
              }
              while (v98 + 16 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v67 = (v13 - 2) >> 1;
              int64_t v68 = v67;
              do
              {
                int64_t v69 = v68;
                if (v67 >= v68)
                {
                  uint64_t v70 = (2 * v68) | 1;
                  unint64_t v71 = v11 + 16 * v70;
                  if (2 * v69 + 2 < (uint64_t)v13 && *(float *)v71 < *(float *)(v71 + 16))
                  {
                    v71 += 16;
                    uint64_t v70 = 2 * v69 + 2;
                  }
                  unint64_t v72 = v11 + 16 * v69;
                  float v73 = *(float *)v72;
                  float v74 = *(float *)v71;
                  float v75 = *(float *)v72;
                  if (*(float *)v71 >= *(float *)v72)
                  {
                    uint64_t v76 = *(void *)(v72 + 8);
                    do
                    {
                      unint64_t v77 = v72;
                      unint64_t v72 = v71;
                      *(float *)unint64_t v77 = v74;
                      *(void *)(v77 + 8) = *(void *)(v71 + 8);
                      if (v67 < v70) {
                        break;
                      }
                      uint64_t v78 = 2 * v70;
                      uint64_t v70 = (2 * v70) | 1;
                      unint64_t v71 = v11 + 16 * v70;
                      uint64_t v79 = v78 + 2;
                      if (v79 < (uint64_t)v13)
                      {
                        uint64_t result = v71 + 16;
                        if (*(float *)v71 < *(float *)(v71 + 16))
                        {
                          v71 += 16;
                          uint64_t v70 = v79;
                        }
                      }
                      float v74 = *(float *)v71;
                    }
                    while (*(float *)v71 >= v75);
                    *(float *)unint64_t v72 = v73;
                    *(void *)(v72 + 8) = v76;
                  }
                }
                int64_t v68 = v69 - 1;
              }
              while (v69);
              uint64_t v80 = (unint64_t)v12 >> 4;
              do
              {
                uint64_t v81 = 0;
                float v82 = *(float *)v11;
                uint64_t v83 = *(void *)(v11 + 8);
                unint64_t v84 = v11;
                do
                {
                  unint64_t v85 = v84;
                  v84 += 16 * v81 + 16;
                  uint64_t v86 = 2 * v81;
                  uint64_t v81 = (2 * v81) | 1;
                  uint64_t v87 = v86 + 2;
                  if (v87 < v80 && *(float *)v84 < *(float *)(v84 + 16))
                  {
                    v84 += 16;
                    uint64_t v81 = v87;
                  }
                  *(_DWORD *)unint64_t v85 = *(_DWORD *)v84;
                  *(void *)(v85 + 8) = *(void *)(v84 + 8);
                }
                while (v81 <= (uint64_t)((unint64_t)(v80 - 2) >> 1));
                if (v84 == a2 - 16)
                {
                  *(float *)unint64_t v84 = v82;
                  *(void *)(v84 + 8) = v83;
                }
                else
                {
                  *(_DWORD *)unint64_t v84 = *(_DWORD *)(a2 - 16);
                  *(void *)(v84 + 8) = *(void *)(a2 - 8);
                  *(float *)(a2 - 16) = v82;
                  *(void *)(a2 - 8) = v83;
                  uint64_t v88 = v84 - v11 + 16;
                  if (v88 >= 17)
                  {
                    unint64_t v89 = (((unint64_t)v88 >> 4) - 2) >> 1;
                    unint64_t v90 = v11 + 16 * v89;
                    float v91 = *(float *)v84;
                    float v92 = *(float *)v90;
                    float v93 = *(float *)v84;
                    if (*(float *)v90 < *(float *)v84)
                    {
                      uint64_t v94 = *(void *)(v84 + 8);
                      do
                      {
                        unint64_t v95 = v84;
                        unint64_t v84 = v90;
                        *(float *)unint64_t v95 = v92;
                        *(void *)(v95 + 8) = *(void *)(v90 + 8);
                        if (!v89) {
                          break;
                        }
                        unint64_t v89 = (v89 - 1) >> 1;
                        unint64_t v90 = v11 + 16 * v89;
                        float v92 = *(float *)v90;
                      }
                      while (*(float *)v90 < v93);
                      *(float *)unint64_t v84 = v91;
                      *(void *)(v84 + 8) = v94;
                    }
                  }
                }
                a2 -= 16;
              }
              while (v80-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          uint64_t v15 = v11 + 16 * (v13 >> 1);
          if ((unint64_t)v12 >= 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9, v9 + 16 * (v13 >> 1), a2 - 16);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9 + 16, v15 - 16, a2 - 32);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9 + 32, v9 + 16 + 16 * v14, a2 - 48);
            uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v15 - 16, v15, v9 + 16 + 16 * v14);
            float v16 = *(float *)v9;
            *(_DWORD *)unint64_t v9 = *(_DWORD *)v15;
            *(float *)uint64_t v15 = v16;
            uint64_t v17 = *(void *)(v9 + 8);
            *(void *)(v9 + 8) = *(void *)(v15 + 8);
            *(void *)(v15 + 8) = v17;
          }
          else
          {
            uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9 + 16 * (v13 >> 1), v9, a2 - 16);
          }
          --a3;
          if (a4) {
            break;
          }
          float v18 = *(float *)v9;
          uint64_t v19 = *(void *)(v9 + 8);
          float v20 = *(float *)v9;
          if (*(float *)(v9 - 16) < *(float *)v9) {
            goto LABEL_13;
          }
          if (v20 >= *(float *)v10)
          {
            unint64_t v35 = v9 + 16;
            do
            {
              unint64_t v11 = v35;
              if (v35 >= a2) {
                break;
              }
              v35 += 16;
            }
            while (v20 >= *(float *)v11);
          }
          else
          {
            unint64_t v11 = v9;
            do
            {
              float v34 = *(float *)(v11 + 16);
              v11 += 16;
            }
            while (v20 >= v34);
          }
          unint64_t v36 = a2;
          if (v11 < a2)
          {
            unint64_t v36 = a2;
            do
            {
              float v37 = *(float *)(v36 - 16);
              v36 -= 16;
            }
            while (v20 < v37);
          }
          if (v11 < v36)
          {
            float v38 = *(float *)v11;
            float v39 = *(float *)v36;
            do
            {
              *(float *)unint64_t v11 = v39;
              *(float *)unint64_t v36 = v38;
              uint64_t v40 = *(void *)(v11 + 8);
              *(void *)(v11 + 8) = *(void *)(v36 + 8);
              *(void *)(v36 + 8) = v40;
              do
              {
                float v41 = *(float *)(v11 + 16);
                v11 += 16;
                float v38 = v41;
              }
              while (v20 >= v41);
              do
              {
                float v42 = *(float *)(v36 - 16);
                v36 -= 16;
                float v39 = v42;
              }
              while (v20 < v42);
            }
            while (v11 < v36);
          }
          BOOL v4 = v11 - 16 >= v9;
          BOOL v5 = v11 - 16 == v9;
          if (v11 - 16 != v9)
          {
            *(_DWORD *)unint64_t v9 = *(_DWORD *)(v11 - 16);
            *(void *)(v9 + 8) = *(void *)(v11 - 8);
          }
          a4 = 0;
          *(float *)(v11 - 16) = v18;
          *(void *)(v11 - 8) = v19;
        }
        float v18 = *(float *)v9;
        uint64_t v19 = *(void *)(v9 + 8);
        float v20 = *(float *)v9;
LABEL_13:
        unint64_t v21 = v9;
        do
        {
          unint64_t v22 = v21;
          float v23 = *(float *)(v21 + 16);
          v21 += 16;
          float v24 = v23;
        }
        while (v20 > v23);
        uint64_t v25 = (float *)a2;
        if (v22 == v9)
        {
          uint64_t v25 = (float *)a2;
          do
          {
            if (v21 >= (unint64_t)v25) {
              break;
            }
            float v27 = *(v25 - 4);
            v25 -= 4;
          }
          while (v20 <= v27);
        }
        else
        {
          do
          {
            float v26 = *(v25 - 4);
            v25 -= 4;
          }
          while (v20 <= v26);
        }
        if (v21 >= (unint64_t)v25)
        {
          unint64_t v11 = v21;
        }
        else
        {
          float v28 = *v25;
          unint64_t v11 = v21;
          BOOL v29 = v25;
          do
          {
            *(float *)unint64_t v11 = v28;
            *BOOL v29 = v24;
            uint64_t v30 = *(void *)(v11 + 8);
            *(void *)(v11 + 8) = *((void *)v29 + 1);
            *((void *)v29 + 1) = v30;
            do
            {
              float v31 = *(float *)(v11 + 16);
              v11 += 16;
              float v24 = v31;
            }
            while (v20 > v31);
            do
            {
              float v32 = *(v29 - 4);
              v29 -= 4;
              float v28 = v32;
            }
            while (v20 <= v32);
          }
          while (v11 < (unint64_t)v29);
        }
        if (v11 - 16 != v9)
        {
          *(_DWORD *)unint64_t v9 = *(_DWORD *)(v11 - 16);
          *(void *)(v9 + 8) = *(void *)(v11 - 8);
        }
        *(float *)(v11 - 16) = v18;
        *(void *)(v11 - 8) = v19;
        if (v21 >= (unint64_t)v25) {
          break;
        }
LABEL_34:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *,false>(v9, v11 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v33 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9, v11 - 16);
      uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v11, a2);
      if (result) {
        break;
      }
      if (!v33) {
        goto LABEL_34;
      }
    }
    a2 = v11 - 16;
    if (!v33) {
      continue;
    }
    return result;
  }
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  float v3 = *(float *)a2;
  float v4 = *(float *)result;
  float v5 = *(float *)a2;
  float v6 = *(float *)a3;
  float v7 = *(float *)a3;
  if (*(float *)a2 >= *(float *)result)
  {
    if (v7 < v5)
    {
      *(float *)a2 = v6;
      *(float *)a3 = v3;
      uint64_t v9 = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = v9;
      float v10 = *(float *)result;
      if (*(float *)a2 < *(float *)result)
      {
        *(_DWORD *)uint64_t result = *(_DWORD *)a2;
        *(float *)a2 = v10;
        uint64_t v11 = *(void *)(result + 8);
        *(void *)(result + 8) = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = v11;
      }
    }
  }
  else if (v7 >= v5)
  {
    *(float *)uint64_t result = v3;
    *(float *)a2 = v4;
    uint64_t v12 = *(void *)(result + 8);
    *(void *)(result + 8) = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = v12;
    if (*(float *)a3 < v4)
    {
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(float *)a3 = v4;
      *(void *)(a2 + 8) = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = v12;
    }
  }
  else
  {
    *(float *)uint64_t result = v6;
    *(float *)a3 = v4;
    uint64_t v8 = *(void *)(result + 8);
    *(void *)(result + 8) = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = v8;
  }
  return result;
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a2, a3);
  float v9 = *(float *)a3;
  if (*(float *)a4 < *(float *)a3)
  {
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(float *)a4 = v9;
    uint64_t v10 = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = v10;
    float v11 = *(float *)a2;
    if (*(float *)a3 < *(float *)a2)
    {
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(float *)a3 = v11;
      uint64_t v12 = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = v12;
      float v13 = *(float *)a1;
      if (*(float *)a2 < *(float *)a1)
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(float *)a2 = v13;
        uint64_t v14 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = v14;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      float v6 = *(float *)a1;
      if (*(float *)(a2 - 16) < *(float *)a1)
      {
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 16);
        *(float *)(a2 - 16) = v6;
        uint64_t v7 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a2 - 16);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a1 + 32, a1 + 48);
      float v19 = *(float *)(a1 + 48);
      if (*(float *)(a2 - 16) < v19)
      {
        *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 - 16);
        *(float *)(a2 - 16) = v19;
        uint64_t v20 = *(void *)(a1 + 56);
        *(void *)(a1 + 56) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v20;
        float v21 = *(float *)(a1 + 48);
        float v22 = *(float *)(a1 + 32);
        if (v21 < v22)
        {
          *(float *)(a1 + 32) = v21;
          *(float *)(a1 + 48) = v22;
          uint64_t v23 = *(void *)(a1 + 40);
          uint64_t v24 = *(void *)(a1 + 56);
          *(void *)(a1 + 40) = v24;
          *(void *)(a1 + 56) = v23;
          float v25 = *(float *)(a1 + 16);
          if (v21 < v25)
          {
            *(float *)(a1 + 16) = v21;
            *(float *)(a1 + 32) = v25;
            uint64_t v26 = *(void *)(a1 + 24);
            *(void *)(a1 + 24) = v24;
            *(void *)(a1 + 40) = v26;
            float v27 = *(float *)a1;
            if (v21 < *(float *)a1)
            {
              *(float *)a1 = v21;
              *(float *)(a1 + 16) = v27;
              uint64_t v28 = *(void *)(a1 + 8);
              *(void *)(a1 + 8) = v24;
              *(void *)(a1 + 24) = v28;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v8 = (float *)(a1 + 32);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a1 + 32);
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    float v12 = *(float *)v9;
    float v13 = *(float *)v9;
    float v14 = *v8;
    if (*(float *)v9 < *v8)
    {
      uint64_t v15 = *(void *)(v9 + 8);
      uint64_t v16 = v10;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        *(float *)(v17 + 48) = v14;
        *(void *)(v17 + 56) = *(void *)(a1 + v16 + 40);
        if (v16 == -32) {
          break;
        }
        float v14 = *(float *)(v17 + 16);
        v16 -= 16;
        if (v13 >= v14)
        {
          uint64_t v18 = a1 + v16 + 48;
          goto LABEL_13;
        }
      }
      uint64_t v18 = a1;
LABEL_13:
      *(float *)uint64_t v18 = v12;
      *(void *)(v18 + 8) = v15;
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    uint64_t v8 = (float *)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2) {
      return 1;
    }
  }
}

void vision::mod::GreedyClustererFacesWithTorso::serialize(vision::mod::GreedyClustererFacesWithTorso *this)
{
  MEMORY[0x1F4188790](this);
  unint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  VNValidatedLog(1, @"  GreedyClustererFacesWithTorso::serialize - enter", v5, v6, v7, v8, v9, v10, v59);
  uint64_t data = (uint64_t)v2[3].__r_.__value_.__l.__data_;
  if (*(void *)(data + 72) || *(void *)(data + 88))
  {
    vision::mod::GreedyClustererWithTorso::private_t::clusters_t::newMapFilePath(&__s, data);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_s = &__s;
    }
    else {
      p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    }
    VNValidatedLog(1, @"  GreedyClustererFacesWithTorso::serialize - cachefile: %s", v12, v13, v14, v15, v16, v17, (uint64_t)p_s);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      float v19 = &__s;
    }
    else {
      float v19 = (std::string *)__s.__r_.__value_.__r.__words[0];
    }
    int v26 = open((const char *)v19, 1537, 438);
    if (v26 == -1)
    {
      VNValidatedLog(4, @"  GreedyClustererFacesWithTorso::serialize - error creating new map file for serialization", v20, v21, v22, v23, v24, v25, v60);
      *uint64_t v4 = 0;
      v4[1] = 0;
    }
    else
    {
      vision::mod::GreedyClustererWithTorso::serializeStatus((vision::mod::GreedyClustererWithTorso *)&v2->__r_.__value_.__r.__words[1], v26, v20, v21, v22, v23, v24, v25);
      __buf.__r_.__value_.__r.__words[0] = v2[5].__r_.__value_.__r.__words[2];
      write(v26, &__buf, 8uLL);
      float v27 = (std::string::size_type *)v2[5].__r_.__value_.__l.__data_;
      if (v27 != &v2[5].__r_.__value_.__r.__words[1])
      {
        int v28 = 0;
        BOOL v29 = __p;
        do
        {
          v29->__r_.__value_.__r.__words[0] = v27[4];
          v29->__r_.__value_.__l.__size_ = v27[5];
          if (v28 <= 130968)
          {
            BOOL v29 = (std::string *)((char *)v29 + 16);
            v28 += 16;
          }
          else
          {
            BOOL v29 = __p;
            write(v26, __p, (v28 + 16));
            int v28 = 0;
          }
          uint64_t v30 = (std::string::size_type *)v27[1];
          if (v30)
          {
            do
            {
              float v31 = v30;
              uint64_t v30 = (std::string::size_type *)*v30;
            }
            while (v30);
          }
          else
          {
            do
            {
              float v31 = (std::string::size_type *)v27[2];
              BOOL v32 = *v31 == (void)v27;
              float v27 = v31;
            }
            while (!v32);
          }
          float v27 = v31;
        }
        while (v31 != &v2[5].__r_.__value_.__r.__words[1]);
        if (v28 > 0) {
          write(v26, __p, v28);
        }
      }
      __buf.__r_.__value_.__r.__words[0] = v2[6].__r_.__value_.__r.__words[2];
      write(v26, &__buf, 8uLL);
      BOOL v33 = (std::string::size_type *)v2[6].__r_.__value_.__l.__data_;
      if (v33 != &v2[6].__r_.__value_.__r.__words[1])
      {
        int v34 = 0;
        unint64_t v35 = __p;
        do
        {
          v35->__r_.__value_.__r.__words[0] = v33[4];
          v35->__r_.__value_.__l.__size_ = v33[5];
          if (v34 <= 130968)
          {
            unint64_t v35 = (std::string *)((char *)v35 + 16);
            v34 += 16;
          }
          else
          {
            unint64_t v35 = __p;
            write(v26, __p, (v34 + 16));
            int v34 = 0;
          }
          unint64_t v36 = (std::string::size_type *)v33[1];
          if (v36)
          {
            do
            {
              float v37 = v36;
              unint64_t v36 = (std::string::size_type *)*v36;
            }
            while (v36);
          }
          else
          {
            do
            {
              float v37 = (std::string::size_type *)v33[2];
              BOOL v32 = *v37 == (void)v33;
              BOOL v33 = v37;
            }
            while (!v32);
          }
          BOOL v33 = v37;
        }
        while (v37 != &v2[6].__r_.__value_.__r.__words[1]);
        if (v34 > 0) {
          write(v26, __p, v34);
        }
      }
      close(v26);
      std::string::size_type size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
      if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = __s.__r_.__value_.__l.__size_;
      }
      std::allocate_shared[abi:ne180100]<std::vector<unsigned char>,std::allocator<std::vector<unsigned char>>,unsigned long,void>(&v62, size + 53);
      uint64_t v39 = *(void *)v62;
      uint64_t v40 = *(void **)v62;
      *uint64_t v40 = 0x2717C1457E25;
      float v41 = (unsigned __int8 *)(v40 + 3);
      if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float v42 = &__s;
      }
      else {
        float v42 = (std::string *)__s.__r_.__value_.__r.__words[0];
      }
      if (calculateChecksumMD5ForFile((const char *)v42, v41))
      {
        createFullPath(__p, (uint64_t)v2[3].__r_.__value_.__l.__data_, v2[3].__r_.__value_.__r.__words[0] + 24);
        if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v49 = __p;
        }
        else {
          uint64_t v49 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
        }
        if ((calculateChecksumMD5ForFile((const char *)v49, (unsigned __int8 *)(v39 + 8)) & 1) == 0) {
          VNValidatedLog(4, @"  GreedyClustererFacesWithTorso::serialize - error calculating checksum for cluster data file", v50, v51, v52, v53, v54, v55, v60);
        }
        getRelativePath(&__buf, v2[3].__r_.__value_.__l.__data_, &__s);
        int v56 = HIBYTE(__buf.__r_.__value_.__r.__words[2]);
        if ((__buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          p_buf = &__buf;
        }
        else
        {
          int v56 = __buf.__r_.__value_.__r.__words[1];
          p_buf = (std::string *)__buf.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)(v39 + 40) = v56;
        memcpy((void *)(v39 + 44), p_buf, (v56 + 1));
        std::string::operator=(v2 + 8, &__buf);
        *(_OWORD *)uint64_t v4 = v62;
        if (SHIBYTE(__buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__buf.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
      }
      else
      {
        VNValidatedLog(4, @"  GreedyClustererFacesWithTorso::serialize - error calculating checksum for cluster data file", v43, v44, v45, v46, v47, v48, v60);
        *uint64_t v4 = 0;
        v4[1] = 0;
        if (*((void *)&v62 + 1)) {
          std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v62 + 1));
        }
      }
    }
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    uint64_t v58 = operator new(0x30uLL);
    v58[1] = 0;
    v58[2] = 0;
    *uint64_t v58 = &unk_1EF753C78;
    v58[4] = 0;
    v58[5] = 0;
    v4[1] = v58;
    void v58[3] = 0;
    *uint64_t v4 = v58 + 3;
  }
}

void sub_1A3F206A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void *std::allocate_shared[abi:ne180100]<std::vector<unsigned char>,std::allocator<std::vector<unsigned char>>,unsigned long,void>(void *a1, size_t a2)
{
  uint64_t v4 = operator new(0x30uLL);
  v4[1] = 0;
  void v4[2] = 0;
  *uint64_t v4 = &unk_1EF753C78;
  BOOL result = std::vector<unsigned char>::vector(v4 + 3, a2);
  *a1 = result;
  a1[1] = v4;
  return result;
}

void sub_1A3F20784(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::__on_zero_shared(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753C78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753C78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(uint64_t a1, uint64_t a2, void **a3, uint64_t **a4)
{
  unint64_t v7 = (uint64_t)(*(_DWORD *)(*(void *)(a1 + 72) + 104) + (*(int *)(*(void *)(a1 + 72) + 104) < 0)) >> 1;
  LODWORD(v60) = 0;
  std::vector<float>::vector(__A, v7, &v60);
  LODWORD(v60) = 0;
  std::vector<float>::vector(__B, v7, &v60);
  unint64_t v8 = *(void *)(a1 + 160);
  if (v8)
  {
    if (v8 >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v8);
    uint64_t v58 = &v9[8 * v10];
    int v11 = v9;
  }
  else
  {
    int v11 = 0;
    uint64_t v58 = 0;
  }
  uint64_t v12 = *(void *)(a1 + 72);
  if (*(unsigned char *)(v12 + 112))
  {
    *(unsigned char *)(v12 + 112) = 0;
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 5219;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  vision::mod::GreedyClustererFacesWithTorso::getAverageDescriptorOfClusterContainingFace((void *)a1, a2, (uint64_t)a4, __A[0]);
  unint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 200))(a1, a2);
  uint64_t v57 = a2;
  float v14 = 0.0;
  if (v13 <= 0xA) {
    float v14 = (float)((float)((float)((float)v13 + -1.0) / -10.0) + 1.0) * 0.05;
  }
  uint64_t v15 = *a4;
  if (*a4 != (uint64_t *)(a4 + 1))
  {
    unint64_t v16 = (unint64_t)v11;
    while (1)
    {
      uint64_t v17 = (const void *)v15[5];
      uint64_t v60 = v15[4];
      long long v62 = 0;
      uint64_t v63 = 0;
      float v61 = 0;
      std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(&v61, v17, v15[6], (v15[6] - (uint64_t)v17) >> 3);
      uint64_t v18 = v61;
      if (v62 == v61)
      {
        uint64_t v18 = v62;
      }
      else
      {
        uint64_t v19 = *(void *)(a1 + 72);
        if (*(unsigned char *)(v19 + 112))
        {
          *(unsigned char *)(v19 + 112) = 0;
          uint64_t v55 = __cxa_allocate_exception(8uLL);
          *uint64_t v55 = 5219;
          __cxa_throw(v55, MEMORY[0x1E4FBA3E0], 0);
        }
        int v20 = v60;
        vision::mod::GreedyClustererFacesWithTorso::getAverageDescriptorOfClusterContainingFace((void *)a1, v60, (uint64_t)a4, __B[0]);
        __C[0] = 0.0;
        vDSP_dotpr(__A[0], 1, __B[0], 1, __C, 0x80uLL);
        float v21 = (float)(__C[0] * -0.5) + 0.5;
        if (*(float *)(*(void *)(a1 + 40) + 8) * 1.1 > (float)(v14 + v21))
        {
          if (v16 >= (unint64_t)v58)
          {
            uint64_t v25 = (uint64_t)(v16 - (void)v11) >> 3;
            unint64_t v26 = v25 + 1;
            if ((unint64_t)(v25 + 1) >> 61) {
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            }
            if ((v58 - v11) >> 2 > v26) {
              unint64_t v26 = (v58 - v11) >> 2;
            }
            if ((unint64_t)(v58 - v11) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v27 = v26;
            }
            if (v27) {
              unint64_t v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v27);
            }
            else {
              uint64_t v28 = 0;
            }
            unint64_t v29 = v27 + 8 * v25;
            *(_DWORD *)unint64_t v29 = v20;
            *(float *)(v29 + 4) = v21;
            uint64_t v30 = (char *)v29;
            while ((char *)v16 != v11)
            {
              uint64_t v31 = *(void *)(v16 - 8);
              v16 -= 8;
              *((void *)v30 - 1) = v31;
              v30 -= 8;
            }
            uint64_t v58 = (char *)(v27 + 8 * v28);
            unint64_t v16 = v29 + 8;
            if (v11) {
              operator delete(v11);
            }
            int v11 = v30;
          }
          else
          {
            *(_DWORD *)unint64_t v16 = v20;
            *(float *)(v16 + 4) = v21;
            v16 += 8;
          }
          uint64_t v18 = v61;
          if (!v61) {
            goto LABEL_18;
          }
LABEL_17:
          long long v62 = v18;
          operator delete(v18);
          goto LABEL_18;
        }
      }
      if (v18) {
        goto LABEL_17;
      }
LABEL_18:
      uint64_t v22 = (uint64_t *)v15[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = (uint64_t **)v22;
          uint64_t v22 = (uint64_t *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (uint64_t **)v15[2];
          BOOL v24 = *v23 == v15;
          uint64_t v15 = (uint64_t *)v23;
        }
        while (!v24);
      }
      uint64_t v15 = (uint64_t *)v23;
      if (v23 == a4 + 1) {
        goto LABEL_43;
      }
    }
  }
  unint64_t v16 = (unint64_t)v11;
LABEL_43:
  unint64_t v32 = 126 - 2 * __clz((uint64_t)(v16 - (void)v11) >> 3);
  if ((char *)v16 == v11) {
    uint64_t v33 = 0;
  }
  else {
    uint64_t v33 = v32;
  }
  std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *,false>((float *)v11, v16, v33, 1);
  uint64_t v34 = v57;
  if ((char *)v16 != v11)
  {
    unint64_t v35 = (float *)v11;
    do
    {
      uint64_t v36 = *(unsigned int *)v35;
      uint64_t v60 = v36;
      float v37 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a4, v36, &v60);
      uint64_t v38 = *std::map<long long,unsigned long>::at(*(void **)(a1 + 152), *(unsigned int *)v35);
      if (v38 != *std::map<long long,unsigned long>::at(*(void **)(a1 + 152), v34))
      {
        float v39 = 1.0 - v35[1];
        uint64_t v40 = *(void *)v37[5];
        uint64_t v41 = LODWORD(v39);
        uint64_t v43 = a3[1];
        unint64_t v42 = (unint64_t)a3[2];
        if ((unint64_t)v43 >= v42)
        {
          uint64_t v45 = ((char *)v43 - (unsigned char *)*a3) >> 4;
          unint64_t v46 = v45 + 1;
          if ((unint64_t)(v45 + 1) >> 60) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v47 = v42 - (void)*a3;
          if (v47 >> 3 > v46) {
            unint64_t v46 = v47 >> 3;
          }
          if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v48 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v48 = v46;
          }
          if (v48) {
            unint64_t v48 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v48);
          }
          else {
            uint64_t v49 = 0;
          }
          uint64_t v50 = (void *)(v48 + 16 * v45);
          *uint64_t v50 = v40;
          v50[1] = v41;
          uint64_t v52 = (char *)*a3;
          uint64_t v51 = (char *)a3[1];
          uint64_t v53 = v50;
          if (v51 == *a3)
          {
            uint64_t v34 = v57;
          }
          else
          {
            uint64_t v34 = v57;
            do
            {
              *((_OWORD *)v53 - 1) = *((_OWORD *)v51 - 1);
              v53 -= 2;
              v51 -= 16;
            }
            while (v51 != v52);
            uint64_t v51 = (char *)*a3;
          }
          uint64_t v44 = v50 + 2;
          *a3 = v53;
          a3[1] = v50 + 2;
          a3[2] = (void *)(v48 + 16 * v49);
          if (v51) {
            operator delete(v51);
          }
        }
        else
        {
          void *v43 = v40;
          v43[1] = LODWORD(v39);
          uint64_t v44 = v43 + 2;
          uint64_t v34 = v57;
        }
        a3[1] = v44;
      }
      v35 += 2;
    }
    while (v35 != (float *)v16);
  }
  if (v11) {
    operator delete(v11);
  }
  if (__B[0])
  {
    __B[1] = __B[0];
    operator delete(__B[0]);
  }
  if (__A[0])
  {
    __A[1] = __A[0];
    operator delete(__A[0]);
  }
  return 5248;
}

void sub_1A3F20D54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (v21) {
    operator delete(v21);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

float *std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *,false>(float *result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = (unint64_t)result;
  while (2)
  {
    uint64_t v10 = (void *)(a2 - 8);
    unint64_t v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v11;
          uint64_t v12 = a2 - v11;
          unint64_t v13 = (uint64_t)(a2 - v11) >> 3;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v48 = *(void *)v11;
                uint64_t v49 = HIDWORD(*v10);
                uint64_t v50 = HIDWORD(*(void *)v11);
                if (COERCE_FLOAT(HIDWORD(*v10)) < COERCE_FLOAT(HIDWORD(*(void *)v11)))
                {
                  *(_DWORD *)unint64_t v11 = *v10;
                  *(_DWORD *)(v11 + 4) = v49;
                  *(_DWORD *)(a2 - 8) = v48;
                  *(_DWORD *)(a2 - 4) = v50;
                }
                break;
              case 3uLL:
                BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)v11, (float *)(v11 + 8), (float *)(a2 - 8));
                break;
              case 4uLL:
                BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)v11, (float *)(v11 + 8), (float *)(v11 + 16), a2 - 8);
                break;
              case 5uLL:
                BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)v11, (float *)(v11 + 8), (float *)(v11 + 16), v11 + 24);
                uint64_t v51 = *(void *)(v11 + 24);
                uint64_t v52 = HIDWORD(*v10);
                if (COERCE_FLOAT(HIDWORD(*v10)) < *((float *)&v51 + 1))
                {
                  *(_DWORD *)(v11 + 24) = *v10;
                  *(_DWORD *)(v11 + 28) = v52;
                  *(void *)(a2 - 8) = v51;
                  uint64_t v53 = *(void *)(v11 + 16);
                  uint64_t v54 = *(void *)(v11 + 24);
                  if (*((float *)&v54 + 1) < *((float *)&v53 + 1))
                  {
                    *(void *)(v11 + 16) = v54;
                    *(void *)(v11 + 24) = v53;
                    uint64_t v55 = *(void *)(v11 + 8);
                    uint64_t v56 = *(void *)(v11 + 16);
                    if (*((float *)&v56 + 1) < *((float *)&v55 + 1))
                    {
                      *(void *)(v11 + 8) = v56;
                      *(void *)(v11 + 16) = v55;
                      uint64_t v57 = *(void *)v11;
                      uint64_t v58 = *(void *)(v11 + 8);
                      uint64_t v59 = HIDWORD(*(void *)v11);
                      if (*((float *)&v58 + 1) < COERCE_FLOAT(HIDWORD(*(void *)v11)))
                      {
                        *(void *)unint64_t v11 = v58;
                        *(_DWORD *)(v11 + 8) = v57;
                        *(_DWORD *)(v11 + 12) = v59;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 191)
          {
            unint64_t v60 = v11 + 8;
            BOOL v62 = v11 == a2 || v60 == a2;
            if (a4)
            {
              if (!v62)
              {
                uint64_t v63 = 0;
                unint64_t v64 = v11;
                do
                {
                  unint64_t v65 = v60;
                  uint64_t v66 = *(void *)v64;
                  if (*(float *)(v64 + 12) < COERCE_FLOAT(HIDWORD(*(void *)v64)))
                  {
                    int v67 = *(_DWORD *)(v64 + 8);
                    float v68 = *(float *)(v64 + 12);
                    uint64_t v69 = v63;
                    while (1)
                    {
                      uint64_t v70 = v11 + v69;
                      *(_DWORD *)(v70 + 8) = v66;
                      *(_DWORD *)(v70 + 12) = *(_DWORD *)(v11 + v69 + 4);
                      if (!v69) {
                        break;
                      }
                      uint64_t v66 = *(void *)(v70 - 8);
                      v69 -= 8;
                      if (v68 >= *((float *)&v66 + 1))
                      {
                        uint64_t v71 = v11 + v69 + 8;
                        goto LABEL_87;
                      }
                    }
                    uint64_t v71 = v11;
LABEL_87:
                    *(_DWORD *)uint64_t v71 = v67;
                    *(float *)(v71 + 4) = v68;
                  }
                  unint64_t v60 = v65 + 8;
                  v63 += 8;
                  unint64_t v64 = v65;
                }
                while (v65 + 8 != a2);
              }
            }
            else if (!v62)
            {
              float v99 = (float *)(v11 + 12);
              do
              {
                unint64_t v100 = v60;
                uint64_t v101 = *(void *)v9;
                if (*(float *)(v9 + 12) < COERCE_FLOAT(HIDWORD(*(void *)v9)))
                {
                  int v102 = *(_DWORD *)(v9 + 8);
                  float v103 = *(float *)(v9 + 12);
                  uint64_t v104 = v99;
                  do
                  {
                    std::vector<int> v105 = v104;
                    int v106 = *((_DWORD *)v104 - 2);
                    v104 -= 2;
                    *((_DWORD *)v105 - 1) = v101;
                    *(_DWORD *)std::vector<int> v105 = v106;
                    uint64_t v101 = *(void *)(v105 - 5);
                  }
                  while (v103 < *((float *)&v101 + 1));
                  *((_DWORD *)v104 - 1) = v102;
                  *uint64_t v104 = v103;
                }
                unint64_t v60 = v100 + 8;
                v99 += 2;
                unint64_t v9 = v100;
              }
              while (v100 + 8 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v72 = (v13 - 2) >> 1;
              int64_t v73 = v72;
              do
              {
                int64_t v74 = v73;
                if (v72 >= v73)
                {
                  uint64_t v75 = (2 * v73) | 1;
                  unint64_t v76 = v11 + 8 * v75;
                  if (2 * v74 + 2 < (uint64_t)v13 && *(float *)(v76 + 4) < *(float *)(v76 + 12))
                  {
                    v76 += 8;
                    uint64_t v75 = 2 * v74 + 2;
                  }
                  unint64_t v77 = (float *)(v11 + 8 * v74);
                  uint64_t v78 = *(void *)v76;
                  float v79 = v77[1];
                  if (COERCE_FLOAT(HIDWORD(*(void *)v76)) >= v79)
                  {
                    float v80 = *v77;
                    do
                    {
                      BOOL result = v77;
                      unint64_t v77 = (float *)v76;
                      *(_DWORD *)BOOL result = v78;
                      result[1] = *(float *)(v76 + 4);
                      if (v72 < v75) {
                        break;
                      }
                      uint64_t v81 = 2 * v75;
                      uint64_t v75 = (2 * v75) | 1;
                      unint64_t v76 = v11 + 8 * v75;
                      uint64_t v82 = v81 + 2;
                      if (v82 < (uint64_t)v13 && *(float *)(v76 + 4) < *(float *)(v76 + 12))
                      {
                        v76 += 8;
                        uint64_t v75 = v82;
                      }
                      uint64_t v78 = *(void *)v76;
                      BOOL result = (float *)HIDWORD(*(void *)v76);
                    }
                    while (COERCE_FLOAT(HIDWORD(*(void *)v76)) >= v79);
                    *unint64_t v77 = v80;
                    v77[1] = v79;
                  }
                }
                int64_t v73 = v74 - 1;
              }
              while (v74);
              uint64_t v83 = (unint64_t)v12 >> 3;
              do
              {
                uint64_t v84 = 0;
                float v85 = *(float *)v11;
                int v86 = *(_DWORD *)(v11 + 4);
                unint64_t v87 = v11;
                do
                {
                  uint64_t v88 = (_DWORD *)v87;
                  v87 += 8 * v84 + 8;
                  uint64_t v89 = 2 * v84;
                  uint64_t v84 = (2 * v84) | 1;
                  uint64_t v90 = v89 + 2;
                  if (v90 < v83 && *(float *)(v87 + 4) < *(float *)(v87 + 12))
                  {
                    v87 += 8;
                    uint64_t v84 = v90;
                  }
                  *uint64_t v88 = *(_DWORD *)v87;
                  v88[1] = *(_DWORD *)(v87 + 4);
                }
                while (v84 <= (uint64_t)((unint64_t)(v83 - 2) >> 1));
                if (v87 == a2 - 8)
                {
                  *(float *)unint64_t v87 = v85;
                  *(_DWORD *)(v87 + 4) = v86;
                }
                else
                {
                  *(_DWORD *)unint64_t v87 = *(_DWORD *)(a2 - 8);
                  *(_DWORD *)(v87 + 4) = *(_DWORD *)(a2 - 4);
                  *(float *)(a2 - 8) = v85;
                  *(_DWORD *)(a2 - 4) = v86;
                  uint64_t v91 = v87 - v11 + 8;
                  if (v91 >= 9)
                  {
                    unint64_t v92 = (((unint64_t)v91 >> 3) - 2) >> 1;
                    unint64_t v93 = v11 + 8 * v92;
                    uint64_t v94 = *(void *)v93;
                    float v95 = *(float *)(v87 + 4);
                    if (COERCE_FLOAT(HIDWORD(*(void *)v93)) < v95)
                    {
                      int v96 = *(_DWORD *)v87;
                      do
                      {
                        uint64_t v97 = (_DWORD *)v87;
                        unint64_t v87 = v93;
                        *uint64_t v97 = v94;
                        v97[1] = *(_DWORD *)(v93 + 4);
                        if (!v92) {
                          break;
                        }
                        unint64_t v92 = (v92 - 1) >> 1;
                        unint64_t v93 = v11 + 8 * v92;
                        uint64_t v94 = *(void *)v93;
                      }
                      while (COERCE_FLOAT(HIDWORD(*(void *)v93)) < v95);
                      *(_DWORD *)unint64_t v87 = v96;
                      *(float *)(v87 + 4) = v95;
                    }
                  }
                }
                a2 -= 8;
              }
              while (v83-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          unint64_t v15 = v11 + 8 * (v13 >> 1);
          if ((unint64_t)v12 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)v9, (float *)(v9 + 8 * (v13 >> 1)), (float *)(a2 - 8));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)(v9 + 8), (float *)(v15 - 8), (float *)(a2 - 16));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)(v9 + 16), (float *)(v9 + 8 + 8 * v14), (float *)(a2 - 24));
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)(v15 - 8), (float *)v15, (float *)(v9 + 8 + 8 * v14));
            float v16 = *(float *)v9;
            *(_DWORD *)unint64_t v9 = *(_DWORD *)v15;
            *(float *)unint64_t v15 = v16;
            int v17 = *(_DWORD *)(v9 + 4);
            *(_DWORD *)(v9 + 4) = *(_DWORD *)(v15 + 4);
            *(_DWORD *)(v15 + 4) = v17;
          }
          else
          {
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)(v9 + 8 * (v13 >> 1)), (float *)v9, (float *)(a2 - 8));
          }
          --a3;
          if (a4) {
            break;
          }
          float v18 = *(float *)v9;
          float v19 = *(float *)(v9 + 4);
          float v20 = v19;
          if (*(float *)(v9 - 4) < v19) {
            goto LABEL_13;
          }
          if (v19 >= *(float *)(a2 - 4))
          {
            unint64_t v38 = v9 + 8;
            do
            {
              unint64_t v11 = v38;
              if (v38 >= a2) {
                break;
              }
              float v39 = *(float *)(v38 + 4);
              v38 += 8;
            }
            while (v19 >= v39);
          }
          else
          {
            unint64_t v36 = v9;
            do
            {
              unint64_t v11 = v36 + 8;
              float v37 = *(float *)(v36 + 12);
              v36 += 8;
            }
            while (v19 >= v37);
          }
          uint64_t v40 = (_DWORD *)a2;
          if (v11 < a2)
          {
            unint64_t v41 = a2;
            do
            {
              uint64_t v40 = (_DWORD *)(v41 - 8);
              float v42 = *(float *)(v41 - 4);
              v41 -= 8;
            }
            while (v19 < v42);
          }
          if (v11 < (unint64_t)v40)
          {
            float v43 = *(float *)v11;
            float v44 = *(float *)v40;
            do
            {
              *(float *)unint64_t v11 = v44;
              *(float *)uint64_t v40 = v43;
              int v45 = *(_DWORD *)(v11 + 4);
              *(_DWORD *)(v11 + 4) = v40[1];
              v40[1] = v45;
              do
              {
                uint64_t v46 = *(void *)(v11 + 8);
                v11 += 8;
                float v43 = *(float *)&v46;
              }
              while (v19 >= *((float *)&v46 + 1));
              do
              {
                uint64_t v47 = *((void *)v40 - 1);
                v40 -= 2;
                float v44 = *(float *)&v47;
              }
              while (v19 < *((float *)&v47 + 1));
            }
            while (v11 < (unint64_t)v40);
          }
          BOOL v4 = v11 - 8 >= v9;
          BOOL v5 = v11 - 8 == v9;
          if (v11 - 8 != v9)
          {
            *(_DWORD *)unint64_t v9 = *(_DWORD *)(v11 - 8);
            *(_DWORD *)(v9 + 4) = *(_DWORD *)(v11 - 4);
          }
          a4 = 0;
          *(float *)(v11 - 8) = v18;
          *(float *)(v11 - 4) = v19;
        }
        float v18 = *(float *)v9;
        float v19 = *(float *)(v9 + 4);
        float v20 = v19;
LABEL_13:
        unint64_t v21 = v9;
        do
        {
          unint64_t v22 = v21;
          uint64_t v23 = *(void *)(v21 + 8);
          v21 += 8;
          int v24 = v23;
        }
        while (v20 > *((float *)&v23 + 1));
        unint64_t v25 = a2;
        if (v22 == v9)
        {
          uint64_t v28 = (float *)a2;
          while (v21 < (unint64_t)v28)
          {
            unint64_t v26 = v28 - 2;
            float v29 = *(v28 - 1);
            v28 -= 2;
            if (v20 > v29) {
              goto LABEL_23;
            }
          }
          unint64_t v26 = v28;
        }
        else
        {
          do
          {
            unint64_t v26 = (float *)(v25 - 8);
            float v27 = *(float *)(v25 - 4);
            v25 -= 8;
          }
          while (v20 <= v27);
        }
LABEL_23:
        if (v21 >= (unint64_t)v26)
        {
          unint64_t v11 = v21;
        }
        else
        {
          int v30 = *(_DWORD *)v26;
          unint64_t v11 = v21;
          uint64_t v31 = v26;
          do
          {
            *(_DWORD *)unint64_t v11 = v30;
            *(_DWORD *)uint64_t v31 = v24;
            int v32 = *(_DWORD *)(v11 + 4);
            *(float *)(v11 + 4) = v31[1];
            *((_DWORD *)v31 + 1) = v32;
            do
            {
              uint64_t v33 = *(void *)(v11 + 8);
              v11 += 8;
              int v24 = v33;
            }
            while (v20 > *((float *)&v33 + 1));
            do
            {
              uint64_t v34 = *((void *)v31 - 1);
              v31 -= 2;
              int v30 = v34;
            }
            while (v20 <= *((float *)&v34 + 1));
          }
          while (v11 < (unint64_t)v31);
        }
        if (v11 - 8 != v9)
        {
          *(_DWORD *)unint64_t v9 = *(_DWORD *)(v11 - 8);
          *(_DWORD *)(v9 + 4) = *(_DWORD *)(v11 - 4);
        }
        *(float *)(v11 - 8) = v18;
        *(float *)(v11 - 4) = v19;
        if (v21 >= (unint64_t)v26) {
          break;
        }
LABEL_36:
        BOOL result = (float *)std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *,false>(v9, v11 - 8, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v35 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>(v9, v11 - 8);
      BOOL result = (float *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>(v11, a2);
      if (result) {
        break;
      }
      if (!v35) {
        goto LABEL_36;
      }
    }
    a2 = v11 - 8;
    if (!v35) {
      continue;
    }
    return result;
  }
}

float *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>(float *result, float *a2, float *a3)
{
  float v4 = *a2;
  float v3 = a2[1];
  float v5 = result[1];
  unint64_t v6 = *(void *)a3;
  unint64_t v7 = HIDWORD(*(void *)a3);
  LODWORD(v8) = HIDWORD(*(void *)a3);
  if (v3 >= v5)
  {
    if (v8 < v3)
    {
      *(_DWORD *)a2 = v6;
      *((_DWORD *)a2 + 1) = v7;
      *a3 = v4;
      a3[1] = v3;
      uint64_t v10 = *(void *)result;
      uint64_t v11 = HIDWORD(*(void *)a2);
      unint64_t v12 = HIDWORD(*(void *)result);
      if (COERCE_FLOAT(HIDWORD(*(void *)a2)) < COERCE_FLOAT(HIDWORD(*(void *)result)))
      {
        *(_DWORD *)BOOL result = *(void *)a2;
        *((_DWORD *)result + 1) = v11;
        *(_DWORD *)a2 = v10;
        *((_DWORD *)a2 + 1) = v12;
      }
    }
  }
  else
  {
    int v9 = *(_DWORD *)result;
    if (v8 >= v3)
    {
      *BOOL result = v4;
      result[1] = v3;
      *(_DWORD *)a2 = v9;
      a2[1] = v5;
      uint64_t v13 = *(void *)a2;
      unint64_t v14 = HIDWORD(*(void *)a3);
      if (COERCE_FLOAT(HIDWORD(*(void *)a3)) >= COERCE_FLOAT(HIDWORD(*(void *)a2))) {
        return result;
      }
      *(_DWORD *)a2 = *(void *)a3;
      *((_DWORD *)a2 + 1) = v14;
      *(_DWORD *)a3 = v13;
    }
    else
    {
      *(_DWORD *)BOOL result = v6;
      *((_DWORD *)result + 1) = v7;
      *(_DWORD *)a3 = v9;
    }
    a3[1] = v5;
  }
  return result;
}

float *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>(a1, a2, a3);
  uint64_t v9 = *(void *)a3;
  uint64_t v10 = HIDWORD(*(void *)a4);
  unint64_t v11 = HIDWORD(*(void *)a3);
  if (COERCE_FLOAT(HIDWORD(*(void *)a4)) < COERCE_FLOAT(HIDWORD(*(void *)a3)))
  {
    *(_DWORD *)a3 = *(void *)a4;
    *((_DWORD *)a3 + 1) = v10;
    *(_DWORD *)a4 = v9;
    *(_DWORD *)(a4 + 4) = v11;
    uint64_t v12 = *(void *)a2;
    unint64_t v13 = HIDWORD(*(void *)a3);
    unint64_t v14 = HIDWORD(*(void *)a2);
    if (COERCE_FLOAT(HIDWORD(*(void *)a3)) < COERCE_FLOAT(HIDWORD(*(void *)a2)))
    {
      *(_DWORD *)a2 = *(void *)a3;
      *((_DWORD *)a2 + 1) = v13;
      *(_DWORD *)a3 = v12;
      *((_DWORD *)a3 + 1) = v14;
      uint64_t v15 = *(void *)a1;
      unint64_t v16 = HIDWORD(*(void *)a2);
      unint64_t v17 = HIDWORD(*(void *)a1);
      if (COERCE_FLOAT(HIDWORD(*(void *)a2)) < COERCE_FLOAT(HIDWORD(*(void *)a1)))
      {
        *(_DWORD *)a1 = *(void *)a2;
        *((_DWORD *)a1 + 1) = v16;
        *(_DWORD *)a2 = v15;
        *((_DWORD *)a2 + 1) = v17;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(void *)(a2 - 8);
      uint64_t v7 = *(void *)a1;
      uint64_t v8 = HIDWORD(*(void *)a1);
      if (*((float *)&v6 + 1) < COERCE_FLOAT(HIDWORD(*(void *)a1)))
      {
        *(void *)a1 = v6;
        *(_DWORD *)(a2 - 8) = v7;
        *(_DWORD *)(a2 - 4) = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)a1, (float *)(a1 + 8), (float *)(a2 - 8));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)a1, (float *)(a1 + 8), (float *)(a1 + 16), a2 - 8);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)a1, (float *)(a1 + 8), (float *)(a1 + 16), a1 + 24);
      uint64_t v19 = *(void *)(a2 - 8);
      uint64_t v20 = *(void *)(a1 + 24);
      if (*((float *)&v19 + 1) >= *((float *)&v20 + 1)) {
        return 1;
      }
      *(void *)(a1 + 24) = v19;
      *(void *)(a2 - 8) = v20;
      uint64_t v21 = *(void *)(a1 + 16);
      uint64_t v22 = *(void *)(a1 + 24);
      if (*((float *)&v22 + 1) >= *((float *)&v21 + 1)) {
        return 1;
      }
      *(void *)(a1 + 16) = v22;
      *(void *)(a1 + 24) = v21;
      uint64_t v23 = *(void *)(a1 + 8);
      uint64_t v24 = *(void *)(a1 + 16);
      if (*((float *)&v24 + 1) >= *((float *)&v23 + 1)) {
        return 1;
      }
      *(void *)(a1 + 8) = v24;
      *(void *)(a1 + 16) = v23;
      uint64_t v25 = *(void *)a1;
      uint64_t v26 = *(void *)(a1 + 8);
      uint64_t v27 = HIDWORD(*(void *)a1);
      if (*((float *)&v26 + 1) >= COERCE_FLOAT(HIDWORD(*(void *)a1))) {
        return 1;
      }
      *(void *)a1 = v26;
      BOOL result = 1;
      *(_DWORD *)(a1 + 8) = v25;
      *(_DWORD *)(a1 + 12) = v27;
      return result;
    default:
      uint64_t v9 = (uint64_t *)(a1 + 16);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned int,float> *>((float *)a1, (float *)(a1 + 8), (float *)(a1 + 16));
      uint64_t v10 = a1 + 24;
      if (a1 + 24 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    float v13 = *(float *)(v10 + 4);
    uint64_t v14 = *v9;
    if (v13 < COERCE_FLOAT(HIDWORD(*v9)))
    {
      int v15 = *(_DWORD *)v10;
      uint64_t v16 = v11;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        *(_DWORD *)(v17 + 24) = v14;
        *(_DWORD *)(v17 + 28) = *(_DWORD *)(a1 + v16 + 20);
        if (v16 == -16) {
          break;
        }
        uint64_t v14 = *(void *)(v17 + 8);
        v16 -= 8;
        if (v13 >= *((float *)&v14 + 1))
        {
          uint64_t v18 = a1 + v16 + 24;
          goto LABEL_13;
        }
      }
      uint64_t v18 = a1;
LABEL_13:
      *(_DWORD *)uint64_t v18 = v15;
      *(float *)(v18 + 4) = v13;
      if (++v12 == 8) {
        return v10 + 8 == a2;
      }
    }
    uint64_t v9 = (uint64_t *)v10;
    v11 += 8;
    v10 += 8;
    if (v10 == a2) {
      return 1;
    }
  }
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::affinityForFace(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  {
    return 5244;
  }
  uint64_t v34 = a2;
  if (vision::mod::GreedyClustererFacesWithTorso::isFaceIdInClustererState((vision::mod::GreedyClustererFacesWithTorso *)a1, (uint64_t)a2))
  {
    unint64_t v8 = (unint64_t)std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 120), (uint64_t)a2, &v34)[5];
    if (v8 >= (uint64_t)(*(void *)(*(void *)(a1 + 72) + 56) - *(void *)(*(void *)(a1 + 72) + 48)) >> 2)
    {
      uint64_t v14 = &CVML_status_inconsistentState;
      return (*v14 + 128) | 0x1400;
    }
    unint64_t v9 = (*(uint64_t (**)(void *))(*a3 + 104))(a3);
    uint64_t v10 = *(void *)(a1 + 72);
    if (*(_DWORD *)(v10 + 104) == v9 >> 2)
    {
      uint64_t v11 = *(void *)(v10 + 72);
      if (v11) {
        unint64_t v12 = *(void *)v11 + v8 * (unint64_t)*(unsigned int *)(*(void *)v11 + 16) + 24;
      }
      else {
        unint64_t v12 = 0;
      }
      std::vector<float>::reserve((void **)a4, a3[9]);
      if (a3[9])
      {
        unint64_t v15 = 0;
        uint64_t v16 = (const float *)(v12 + 40);
        uint64_t v14 = &CVML_status_ok;
        do
        {
          uint64_t v17 = (const float *)(a3[7] + 4 * (a3[8] >> 2) * v15);
          int v18 = *(_DWORD *)(*(void *)(a1 + 72) + 104) + (*(int *)(*(void *)(a1 + 72) + 104) < 0);
          int v19 = *(_DWORD *)(*(void *)(a1 + 72) + 104) / 2;
          uint64_t __C = 0;
          vDSP_Length v20 = (uint64_t)v18 >> 1;
          vDSP_dotpr(v17, 1, v16, 1, (float *)&__C + 1, v20);
          vDSP_dotpr(&v17[v19], 1, &v16[v19], 1, (float *)&__C, v20);
          float v21 = *((float *)&__C + 1) * -0.5 + 0.5;
          float v22 = 1.0 - v21;
          uint64_t v24 = *(float **)(a4 + 8);
          unint64_t v23 = *(void *)(a4 + 16);
          if ((unint64_t)v24 >= v23)
          {
            uint64_t v26 = *(float **)a4;
            uint64_t v27 = ((uint64_t)v24 - *(void *)a4) >> 2;
            unint64_t v28 = v27 + 1;
            if ((unint64_t)(v27 + 1) >> 62) {
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v29 = v23 - (void)v26;
            if (v29 >> 1 > v28) {
              unint64_t v28 = v29 >> 1;
            }
            if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v30 = v28;
            }
            if (v30)
            {
              unint64_t v30 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v30);
              uint64_t v26 = *(float **)a4;
              uint64_t v24 = *(float **)(a4 + 8);
            }
            else
            {
              uint64_t v31 = 0;
            }
            int v32 = (float *)(v30 + 4 * v27);
            *int v32 = v22;
            uint64_t v25 = v32 + 1;
            while (v24 != v26)
            {
              int v33 = *((_DWORD *)v24-- - 1);
              *((_DWORD *)v32-- - 1) = v33;
            }
            *(void *)a4 = v32;
            *(void *)(a4 + 8) = v25;
            *(void *)(a4 + 16) = v30 + 4 * v31;
            if (v26) {
              operator delete(v26);
            }
          }
          else
          {
            *uint64_t v24 = v22;
            uint64_t v25 = v24 + 1;
          }
          *(void *)(a4 + 8) = v25;
          ++v15;
        }
        while (a3[9] > v15);
      }
      else
      {
        uint64_t v14 = &CVML_status_ok;
      }
      return (*v14 + 128) | 0x1400;
    }
  }
  uint64_t v14 = &CVML_status_invalidParameter;
  return (*v14 + 128) | 0x1400;
}

void std::vector<float>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a2);
    float v5 = &v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    uint64_t v7 = &v4[4 * v6];
    unint64_t v8 = (char *)*a1;
    unint64_t v9 = (char *)a1[1];
    uint64_t v10 = v5;
    if (v9 != *a1)
    {
      uint64_t v10 = v5;
      do
      {
        int v11 = *((_DWORD *)v9 - 1);
        v9 -= 4;
        *((_DWORD *)v10 - 1) = v11;
        v10 -= 4;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::remove()
{
  return 5248;
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::update(uint64_t **a1, std::vector<unsigned int>::size_type *lpsrc, void *a3)
{
  {
    return 5244;
  }
  if (lpsrc[9] != (uint64_t)(lpsrc[2] - lpsrc[1]) >> 3) {
    syslog(5, "wrong number of descriptors id in descriptor buffer");
  }
  v177[0] = 0;
  v177[1] = 0;
  unsigned int v176 = v177;
  if (*((_DWORD *)lpsrc + 26) != *((_DWORD *)a1 + 8))
  {
    syslog(5, "For consistency, GreedyClustererWithTorso::addDescriptors must be called with a ImageDescriptorBufferJoint having the same distance mode as GreedyClustererWithTorso::distance_mode");
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 5244;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  std::vector<BOOL>::vector(v181, (uint64_t)(lpsrc + 15));
  uint64_t v7 = (unsigned char *)lpsrc[18];
  uint64_t v6 = (unsigned char *)lpsrc[19];
  int64_t v8 = v6 - v7;
  unsigned __int8 v165 = a1;
  uint64_t v156 = lpsrc;
  uint64_t v152 = a3;
  if (v6 == v7)
  {
    unint64_t v9 = 0;
  }
  else
  {
    if (v8 < 0) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = (int64x2_t *)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v8 >> 4);
    memmove(v9, v7, v8);
  }
  std::vector<unsigned int>::size_type v11 = lpsrc[8];
  std::vector<unsigned int>::size_type v161 = lpsrc[7];
  unsigned int v166 = v9;
  int v12 = (*(uint64_t (**)(std::vector<unsigned int>::size_type *))(*lpsrc + 104))(lpsrc);
  if (!v161)
  {
    uint64_t v149 = __cxa_allocate_exception(8uLL);
    *uint64_t v149 = 5245;
    __cxa_throw(v149, MEMORY[0x1E4FBA3E0], 0);
  }
  int v13 = v12;
  std::vector<unsigned int>::size_type v14 = lpsrc[9];
  unint64_t v15 = (std::vector<unsigned int> *)operator new(0x30uLL);
  v15->__end_ = 0;
  v15->__end_cap_.__value_ = 0;
  v15->__begin_ = (std::vector<unsigned int>::pointer)&unk_1EF753CB0;
  unsigned __int8 v155 = v15;
  uint64_t v159 = v15 + 1;
  std::vector<unsigned int>::size_type v160 = v14;
  std::vector<unsigned int>::vector(v15 + 1, v14);
  uint64_t v16 = a1[9];
  int v17 = *((_DWORD *)v16 + 26);
  unint64_t v162 = (unint64_t)v13 >> 2;
  if (v17 != v162 && v17)
  {
    uint64_t v150 = __cxa_allocate_exception(8uLL);
    *uint64_t v150 = 5244;
    __cxa_throw(v150, MEMORY[0x1E4FBA3E0], 0);
  }
  *((_DWORD *)v16 + 26) = v162;
  if (!v16[9] && !v16[11])
  {
    if (cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::create(4 * (int)v162 + 40)) {
      vision::mod::GreedyClustererWithTorso::private_t::clusters_t::set_cluster_map_vector();
    }
    unint64_t v151 = __cxa_allocate_exception(8uLL);
    *unint64_t v151 = 5246;
    __cxa_throw(v151, MEMORY[0x1E4FBA3E0], 0);
  }
  if (v14)
  {
    unint64_t v18 = 0;
    unint64_t v19 = (unint64_t)(int)v11 >> 2;
    vDSP_Length v20 = a1[5];
    float v21 = *((float *)v20 + 4);
    float v22 = *((float *)a1 + 5);
    float v23 = *((float *)v20 + 2);
    if ((v162 & 0x80000000) == 0) {
      int v24 = (unint64_t)v13 >> 2;
    }
    else {
      int v24 = v162 + 1;
    }
    vDSP_Length v168 = (uint64_t)v24 >> 1;
    uint64_t v153 = ((unint64_t)v13 >> 2);
    uint64_t v158 = (int)v19;
    uint64_t v157 = (int)v19;
    int64x2_t v164 = vdupq_n_s64(2uLL);
    uint64_t v25 = (int *)v161;
    uint64_t v154 = (v24 >> 1);
    while (1)
    {
      float v163 = v25;
      BOOL v169 = (const float *)(v161 + 4 * v18 * v158);
      float v32 = (*(float (**)(uint64_t *))*a1[5])(a1[5]);
      int v33 = a1[9];
      BOOL v35 = (unsigned int *)v33[6];
      uint64_t v34 = (unsigned int *)v33[7];
      unint64_t v172 = v18 >> 5;
      uint64_t v171 = 1 << (2 * (v18 & 0x1Fu));
      uint64_t v170 = 1 << ((2 * (v18 & 0x1F)) | 1);
      if (v35 != v34) {
        break;
      }
      unsigned int v173 = -1;
LABEL_86:
      uint64_t v67 = *((void *)v181[0] + v172);
      uint64_t v68 = v67 & v171;
      BOOL v69 = (v67 & v171) != 0;
      uint64_t v70 = v67 & v170;
      BOOL v71 = (v67 & v170) != 0;
      int64_t v72 = (cvml::util::MMapFileBackingStore *)a1[9][9];
      if ((v173 & 0x80000000) != 0)
      {
        if (!v72) {
          goto LABEL_159;
        }
        uint64_t v74 = *(void *)v72;
        int v75 = *(_DWORD *)(*(void *)v72 + 8);
        if (!v75)
        {
          unint64_t v175 = v18;
          unint64_t v76 = *(unsigned int *)(v74 + 12);
          if (v76) {
            unint64_t v77 = (2 * v76);
          }
          else {
            unint64_t v77 = 256;
          }
          if (v77 <= v76
            || (unsigned int v78 = *(_DWORD *)(v74 + 16),
                unint64_t v79 = v77 * (unint64_t)v78,
                !cvml::util::MMapFileBackingStore::growStorage(v72, (cvml::util::MMapFileBackingStore *)(v79 + 24 + 4 * v77))))
          {
            VNValidatedLog(4, @"BackedBuffer<BackingStore>::allocateElement -- could not allocate new element because grow failed", v26, v27, v28, v29, v30, v31, (uint64_t)v177);
LABEL_159:
            unsigned int v147 = __cxa_allocate_exception(8uLL);
            *unsigned int v147 = 5246;
            __cxa_throw(v147, MEMORY[0x1E4FBA3E0], 0);
          }
          uint64_t v80 = 0;
          uint64_t v81 = *(void *)v72;
          unint64_t v82 = (4 * v77 - 4 * v76 - 4) >> 2;
          uint64_t v83 = (v82 + 2) & 0x7FFFFFFFFFFFFFFELL;
          uint64x2_t v84 = (uint64x2_t)vdupq_n_s64(v82);
          float v85 = (_DWORD *)(*(void *)v72 + v79 + 28);
          int v86 = -2;
          int64x2_t v87 = (int64x2_t)xmmword_1A4104940;
          do
          {
            int32x2_t v88 = vmovn_s64((int64x2_t)vcgeq_u64(v84, (uint64x2_t)v87));
            if (v88.i8[0]) {
              *(v85 - 1) = v77 + v86 + 1;
            }
            if (v88.i8[4]) {
              *float v85 = v77 + (v80 ^ 0xFFFFFFFE);
            }
            v80 += 2;
            int64x2_t v87 = vaddq_s64(v87, v164);
            v86 -= 2;
            v85 += 2;
          }
          while (v83 != v80);
          *(void *)uint64_t v81 = v79 + 24;
          *(_DWORD *)(v81 + 12) = v77;
          *(_DWORD *)(v81 + 16) = v78;
          *(_DWORD *)(v81 + 8) = v77 - v76;
          std::vector<BOOL>::resize((uint64_t)v72 + 56, v77, 0);
          uint64_t v74 = *(void *)v72;
          int v75 = *(_DWORD *)(*(void *)v72 + 8);
          unint64_t v9 = v166;
          unint64_t v18 = v175;
        }
        unsigned int v89 = v75 - 1;
        *(_DWORD *)(v74 + 8) = v89;
        unint64_t v90 = *(unsigned int *)(v74 + *(void *)v74 + 4 * v89);
        *(void *)(*((void *)v72 + 7) + ((v90 >> 3) & 0x1FFFFFF8)) |= 1 << v90;
        if (v90 == -1) {
          goto LABEL_159;
        }
        uint64_t v91 = (uint64_t *)a1[9][9];
        if (!v91)
        {
          uint64_t v146 = __cxa_allocate_exception(8uLL);
          *uint64_t v146 = 5246;
          __cxa_throw(v146, MEMORY[0x1E4FBA3E0], 0);
        }
        uint64_t v92 = *v91;
        unsigned int v93 = *(_DWORD *)(v92 + 16);
        if ((int)v162 >= 1)
        {
          uint64_t v94 = (_DWORD *)(v92 + v93 * (unint64_t)v90 + 64);
          float v95 = v163;
          uint64_t v96 = v153;
          do
          {
            int v97 = *v95++;
            *v94++ = v97;
            --v96;
          }
          while (v96);
        }
        uint64_t v98 = v92 + v93 * (unint64_t)v90;
        *(void *)(v98 + 24) = v90;
        v98 += 24;
        *(float *)(v98 + 12) = v32;
        *(_DWORD *)(v98 + 16) = v69;
        *(_DWORD *)(v98 + 20) = v71;
        *(int64x2_t *)(v98 + 24) = v9[v18];
        *(_DWORD *)(v98 + 8) = 1;
        float v99 = a1[9];
        uint64_t v101 = (char *)v99[7];
        unint64_t v100 = v99[8];
        if ((unint64_t)v101 >= v100)
        {
          uint64_t v119 = (char *)v99[6];
          uint64_t v120 = (v101 - v119) >> 2;
          unint64_t v121 = v120 + 1;
          if ((unint64_t)(v120 + 1) >> 62) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v122 = v100 - (void)v119;
          if (v122 >> 1 > v121) {
            unint64_t v121 = v122 >> 1;
          }
          BOOL v123 = (unint64_t)v122 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v124 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v123) {
            unint64_t v124 = v121;
          }
          if (v124)
          {
            unint64_t v124 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v124);
            uint64_t v119 = (char *)v99[6];
            uint64_t v101 = (char *)v99[7];
          }
          else
          {
            uint64_t v125 = 0;
          }
          float v126 = (_DWORD *)(v124 + 4 * v120);
          *float v126 = v90;
          int v102 = v126 + 1;
          while (v101 != v119)
          {
            int v127 = *((_DWORD *)v101 - 1);
            v101 -= 4;
            *--float v126 = v127;
          }
          v99[6] = (uint64_t)v126;
          v99[7] = (uint64_t)v102;
          v99[8] = v124 + 4 * v125;
          if (v119) {
            operator delete(v119);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v101 = v90;
          int v102 = v101 + 4;
        }
        unsigned int v118 = v163;
        v99[7] = (uint64_t)v102;
        std::vector<unsigned int>::size_type v117 = v160;
      }
      else
      {
        if (v72) {
          unint64_t v73 = *(void *)v72 + *(unsigned int *)(*(void *)v72 + 16) * (unint64_t)v173 + 24;
        }
        else {
          unint64_t v73 = 0;
        }
        unint64_t v103 = v73 + 40;
        int v104 = *(_DWORD *)(v73 + 20);
        if (v68)
        {
          int v105 = *(_DWORD *)(v73 + 16);
          double v106 = (double)v105 + 1.0;
          double v107 = (double)v105 / v106;
          double v108 = 1.0 / v106;
          if ((int)v162 >= 2)
          {
            uint64_t v109 = 0;
            do
            {
              float v110 = v108 * *(float *)&v163[v109] + *(float *)(v103 + 4 * v109) * v107;
              *(float *)(v103 + 4 * v109++) = v110;
            }
            while (v154 != v109);
          }
          *(_DWORD *)(v73 + 16) = v105 + 1;
          float v111 = v108 * v32 + *(float *)(v73 + 12) * v107;
          *(float *)(v73 + 12) = v111;
        }
        if (v70)
        {
          if ((int)v168 < (int)v162)
          {
            double v112 = (double)v104 + 1.0;
            double v113 = (double)v104 / v112;
            vDSP_Length v114 = v168;
            double v115 = 1.0 / v112;
            do
            {
              float v116 = v115 * *(float *)&v163[v114] + *(float *)(v103 + 4 * v114) * v113;
              *(float *)(v103 + 4 * v114++) = v116;
            }
            while ((int)v162 != v114);
          }
          *(_DWORD *)(v73 + 20) = v104 + 1;
        }
        ++*(_DWORD *)(v73 + 8);
        LODWORD(v90) = *(_DWORD *)v73;
        std::vector<unsigned int>::size_type v117 = v160;
        unsigned int v118 = v163;
      }
      v159->__begin_[v18++] = v90;
      uint64_t v25 = &v118[v157];
      if (v18 == v117) {
        goto LABEL_137;
      }
    }
    BOOL v167 = (unsigned int *)v33[7];
    float v36 = 0.0;
    unsigned int v173 = -1;
    while (1)
    {
      uint64_t v37 = a1[9][9];
      if (v37)
      {
        unint64_t v38 = *(void *)v37 + *(unsigned int *)(*(void *)v37 + 16) * (unint64_t)*v35;
        if (*(int *)(v38 + 32) >= 1) {
          break;
        }
      }
LABEL_83:
      if (++v35 == v34) {
        goto LABEL_86;
      }
    }
    unsigned int v174 = *v35;
    unint64_t v39 = v38 + 24;
    unint64_t v40 = v18;
    int64x2_t v41 = v9[v18];
    int64x2_t v42 = *(int64x2_t *)(v39 + 24);
    int64x2_t v178 = v42;
    int64x2_t v179 = v41;
    int v43 = *((_DWORD *)a1[5] + 5);
    if (v41.i64[0]) {
      BOOL v44 = v41.i64[1] == 0;
    }
    else {
      BOOL v44 = 1;
    }
    int v45 = !v44;
    if (v42.i64[0]) {
      BOOL v46 = v42.i64[1] == 0;
    }
    else {
      BOOL v46 = 1;
    }
    int v47 = !v46;
    if (*(float *)(v39 + 12) >= v32) {
      float v48 = v32;
    }
    else {
      float v48 = *(float *)(v39 + 12);
    }
    unint64_t v49 = v39 + 40;
    uint64_t v50 = *((void *)v181[0] + v172);
    int v52 = *(_DWORD *)(v39 + 16);
    int v51 = *(_DWORD *)(v39 + 20);
    uint64_t __C = 0;
    vDSP_dotpr((const float *)(v39 + 40), 1, v169, 1, (float *)&__C + 1, v168);
    vDSP_dotpr((const float *)(v49 + 4 * v168), 1, &v169[v168], 1, (float *)&__C, v168);
    BOOL v53 = 0;
    if (v52) {
      BOOL v54 = (v50 & v171) == 0;
    }
    else {
      BOOL v54 = 1;
    }
    int v55 = !v54;
    float v56 = (*((float *)&__C + 1) * -0.5 + 0.5) / v48;
    float v57 = *(float *)&__C * -0.5 + 0.5;
    if ((v50 & v170) != 0) {
      int v58 = v45;
    }
    else {
      int v58 = 0;
    }
    if (v43 == 1)
    {
      a1 = v165;
      unint64_t v18 = v40;
      uint64_t v34 = v167;
    }
    else
    {
      int v59 = v58 & v47;
      if (v51) {
        BOOL v60 = v59 == 0;
      }
      else {
        BOOL v60 = 1;
      }
      a1 = v165;
      unint64_t v18 = v40;
      uint64_t v34 = v167;
      if (!v60)
      {
        if (v179.i64[0] == v178.i64[0])
        {
          BOOL v53 = v179.i64[1] == v178.i64[1];
          if (v179.i64[1] == v178.i64[1]) {
            int v61 = v55;
          }
          else {
            int v61 = 0;
          }
          if (v61 == 1)
          {
            unsigned int v62 = v174;
            if (v43 != 3)
            {
              if (v43 != 2)
              {
                int64_t v145 = __cxa_allocate_exception(8uLL);
                *int64_t v145 = 5238;
                __cxa_throw(v145, MEMORY[0x1E4FBA3E0], 0);
              }
              float v57 = (float)(v57 * 0.5) + (float)(v56 * 0.5);
              if (v57 > v56) {
                float v57 = (*((float *)&__C + 1) * -0.5 + 0.5) / v48;
              }
            }
            unint64_t v9 = v166;
LABEL_73:
            uint16x4_t v63 = (uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqzq_s64(v178), (int32x4_t)vceqzq_s64(v179)));
            v63.i16[0] = vmaxv_u16(v63);
            if (((*((_DWORD *)a1[5] + 5) != 1) & ~v63.i32[0]) != 0) {
              float v64 = v21;
            }
            else {
              float v64 = v23;
            }
            if (v57 < (float)(v64 * v22))
            {
              unsigned int v65 = v173;
              if (v57 < v36 || v173 == -1)
              {
                float v36 = v57;
                unsigned int v65 = v62;
              }
              unsigned int v173 = v65;
            }
            goto LABEL_83;
          }
        }
        else
        {
          BOOL v53 = 0;
        }
      }
    }
    if (!v53) {
      float v57 = 1.0;
    }
    if (v55) {
      float v57 = (*((float *)&__C + 1) * -0.5 + 0.5) / v48;
    }
    unint64_t v9 = v166;
    unsigned int v62 = v174;
    goto LABEL_73;
  }
LABEL_137:
  if (v9) {
    operator delete(v9);
  }
  int64_t v128 = (std::__shared_weak_count *)v155;
  if (v181[0]) {
    operator delete(v181[0]);
  }
  std::vector<int>::pointer begin = v155[1].__begin_;
  std::vector<int>::pointer end = v155[1].__end_;
  if (begin != end)
  {
    do
    {
      std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>((uint64_t *)&v176, (uint64_t *)v177, *begin, *begin);
      ++begin;
    }
    while (begin != end);
    uint64_t v131 = v155[1].__begin_;
    if (v155[1].__end_ != v131)
    {
      unint64_t v132 = 0;
      uint64_t v133 = v165 + 13;
      do
      {
        v179.i64[0] = *(void *)(v156[1] + 8 * v132);
        unsigned __int8 v134 = (uint64_t *)v131[v132];
        unsigned int v135 = *v133;
        float v136 = v165 + 13;
        float v137 = (uint64_t *)(v165 + 13);
        if (*v133)
        {
          while (1)
          {
            while (1)
            {
              float v137 = v135;
              unint64_t v138 = v135[4];
              if (v138 <= (unint64_t)v134) {
                break;
              }
              unsigned int v135 = (uint64_t *)*v137;
              float v136 = (uint64_t **)v137;
              if (!*v137) {
                goto LABEL_152;
              }
            }
            if (v138 >= (unint64_t)v134) {
              break;
            }
            unsigned int v135 = (uint64_t *)v137[1];
            if (!v135)
            {
              float v136 = (uint64_t **)(v137 + 1);
              goto LABEL_152;
            }
          }
        }
        else
        {
LABEL_152:
          uint64_t v139 = (uint64_t *)operator new(0x40uLL);
          v181[1] = v165 + 13;
          v139[4] = (uint64_t)v134;
          v139[5] = (uint64_t)(v139 + 5);
          v139[6] = (uint64_t)(v139 + 5);
          v139[7] = 0;
          char v182 = 1;
          std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v165 + 12, (uint64_t)v137, v136, v139);
          v181[0] = 0;
          std::unique_ptr<std::__tree_node<std::__value_type<unsigned long,std::list<long long>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long,std::list<long long>>,void *>>>>::reset[abi:ne180100]((uint64_t)v181);
          float v137 = v139;
        }
        unsigned __int8 v140 = operator new(0x18uLL);
        uint64_t v141 = v179.i64[0];
        v140[2] = v179.i64[0];
        uint64_t v143 = v137[5];
        unsigned int v142 = v137 + 5;
        *unsigned __int8 v140 = v143;
        v140[1] = v142;
        *(void *)(v143 + 8) = v140;
        *unsigned int v142 = v140;
        ++v142[2];
        std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v165 + 15, v141, (uint64_t **)&v179)[5] = v134;
        ++v132;
        int64_t v128 = (std::__shared_weak_count *)v155;
        uint64_t v131 = v155[1].__begin_;
      }
      while (v132 < v155[1].__end_ - v131);
    }
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v128);
  vision::mod::GreedyClustererFacesWithTorso::computeDeltaAfterUpdate((uint64_t)v165, v152, (uint64_t *)&v176);
  uint64_t v10 = 5248;
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v177[0]);
  return v10;
}

void sub_1A3F229B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  if (__p) {
    operator delete(__p);
  }
  BOOL v44 = *(void **)(v41 - 176);
  if (v44) {
    operator delete(v44);
  }
  if (a2 == 1)
  {
    uint64_t v45 = *(void *)__cxa_begin_catch(a1);
    __cxa_end_catch();
    if (v45 == 5248) {
      JUMPOUT(0x1A3F2283CLL);
    }
    JUMPOUT(0x1A3F22850);
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a41);
  _Unwind_Resume(a1);
}

uint64_t cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::create(uint64_t a1)
{
  if (a1) {
    cvml::util::MMapFileBackingStore::create((cvml::util::MMapFileBackingStore *)0x18);
  }
  return 0;
}

void sub_1A3F22C04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    std::vector<unsigned int>::pointer end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_1A3F22C9C(_Unwind_Exception *exception_object)
{
  int64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<std::vector<unsigned int>>::__on_zero_shared(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<unsigned int>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753CB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<std::vector<unsigned int>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753CB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

char *std::allocate_shared[abi:ne180100]<std::vector<unsigned char>,std::allocator<std::vector<unsigned char>>,unsigned char const* const&,unsigned char const*,void>(void *a1, const void *a2, uint64_t a3)
{
  BOOL result = (char *)operator new(0x30uLL);
  uint64_t v7 = result;
  *(_OWORD *)(result + 8) = 0u;
  *(void *)BOOL result = &unk_1EF753C78;
  *((void *)result + 3) = 0;
  int64_t v8 = result + 24;
  *((_OWORD *)result + 2) = 0u;
  size_t v9 = a3 - (void)a2;
  if (v9)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100]((void *)result + 3, v9);
    uint64_t v10 = (char *)*((void *)v7 + 4);
    BOOL result = (char *)memmove(v10, a2, v9);
    *((void *)v7 + 4) = &v10[v9];
  }
  *a1 = v8;
  a1[1] = v7;
  return result;
}

void sub_1A3F22E2C(_Unwind_Exception *a1)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    v1[1].__shared_owners_ = (uint64_t)v4;
    operator delete(v4);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v5);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<vision::mod::GreedyClustererFacesWithTorso,std::allocator<vision::mod::GreedyClustererFacesWithTorso>,char const*&,std::shared_ptr<std::vector<unsigned char>> &,BOOL &,std::shared_ptr<apple::vision::GreedyClusteringParamsWrapper> const&,void>(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  unint64_t v2 = v1;
  char v4 = v3;
  uint64_t v6 = v5;
  int64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  std::vector<unsigned int>::size_type v11 = operator new(0xF8uLL);
  v11[1] = 0;
  _OWORD v11[2] = 0;
  void *v11 = &unk_1EF753A10;
  v11[3] = &unk_1EF752220;
  uint64_t v12 = vision::mod::GreedyClustererWithTorso::GreedyClustererWithTorso((uint64_t)(v11 + 4), v8, v2);
  v11[27] = 0;
  v11[3] = &unk_1EF752A58;
  v11[4] = &unk_1EF752B38;
  v11[16] = 0;
  v11[15] = v11 + 16;
  v11[17] = 0;
  v11[19] = 0;
  int v17 = (vision::mod::GreedyClustererWithTorso *)v12;
  v11[18] = v11 + 19;
  v11[22] = 0;
  v11[21] = v11 + 22;
  v11[20] = 0;
  v11[25] = 0;
  v11[26] = 0;
  v11[23] = 0;
  v11[24] = v11 + 25;
  v11[28] = 0;
  v11[29] = 0;
  *((unsigned char *)v11 + 240) = 0;
  memset(&__s, 0, sizeof(__s));
  memset(&v19, 0, sizeof(v19));
  int v18 = -1;
  std::string::basic_string[abi:ne180100]<0>(__p, v8);
  uint64_t v16 = vision::mod::GreedyClustererFacesWithTorso::pasreAndVerifyClustererState((uint64_t)__p, **v6, &__s, &v19, &v18, v13, v14, v15);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  if (v16 == 5248) {
    vision::mod::GreedyClustererWithTorso::deserializeStatus(v17, v18, v4 != 0);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  void *v10 = v11 + 3;
  v10[1] = v11;
}

void sub_1A3F232C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void **a11, void **a12, uint64_t a13, void **a14, vision::mod::GreedyClustererWithTorso *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (*(char *)(v40 + 239) < 0) {
    operator delete(*v39);
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*a10);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*a11);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*a14);
  std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(*a12);
  vision::mod::GreedyClustererWithTorso::~GreedyClustererWithTorso(a15);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v40);
  operator delete(v42);
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<vision::mod::GreedyClustererFacesWithTorso,std::allocator<vision::mod::GreedyClustererFacesWithTorso>,char const*&,std::shared_ptr<apple::vision::GreedyClusteringParamsWrapper> const&,void>(void *a1, char *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0xF8uLL);
  v6[1] = 0;
  void v6[2] = 0;
  *uint64_t v6 = &unk_1EF753A10;
  v6[3] = &unk_1EF752220;
  uint64_t result = vision::mod::GreedyClustererWithTorso::GreedyClustererWithTorso((uint64_t)(v6 + 4), a2, a3);
  v6[3] = &unk_1EF752A58;
  v6[4] = &unk_1EF752B38;
  v6[16] = 0;
  v6[15] = v6 + 16;
  v6[19] = 0;
  v6[17] = 0;
  v6[18] = v6 + 19;
  v6[22] = 0;
  v6[20] = 0;
  v6[21] = v6 + 22;
  v6[26] = 0;
  v6[27] = 0;
  v6[25] = 0;
  v6[23] = 0;
  v6[24] = v6 + 25;
  v6[28] = 0;
  v6[29] = 0;
  *((unsigned char *)v6 + 240) = 1;
  *a1 = v6 + 3;
  a1[1] = v6;
  return result;
}

void sub_1A3F234A0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererWithTorso::GreedyClustererWithTorso(uint64_t a1, char *a2, uint64_t *a3)
{
  *(void *)a1 = &unk_1EF752768;
  *(void *)(a1 + 8) = 0x3F0000003F000000;
  *(_DWORD *)(a1 + 16) = 1;
  *(unsigned char *)(a1 + 20) = 1;
  *(_DWORD *)(a1 + 24) = 3;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(unsigned char *)(a1 + 80) = 0;
  if (!*a3)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 5245;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t v6 = (char *)operator new(0x90uLL);
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)uint64_t v6 = &unk_1EF753818;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_OWORD *)(v6 + 120) = 0u;
  *((void *)v6 + 17) = 0;
  *(_OWORD *)(v6 + 24) = 0u;
  *(void *)(a1 + 64) = v6 + 24;
  *(void *)(a1 + 72) = v6;
  if (a2)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, a2);
    uint64_t v7 = *(void *)(a1 + 64);
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    long long v8 = *(_OWORD *)__p;
    *(void *)(v7 + 16) = v19;
    *(_OWORD *)uint64_t v7 = v8;
    size_t v9 = *(uint64_t **)(a1 + 64);
    if (*((char *)v9 + 23) < 0)
    {
      size_t v9 = (uint64_t *)*v9;
      uint64_t v10 = *(void *)(*(void *)(a1 + 64) + 8);
    }
    else
    {
      uint64_t v10 = *((unsigned __int8 *)v9 + 23);
    }
    if (*((unsigned char *)v9 + v10 - 1) != 47)
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "/");
      std::vector<unsigned int>::size_type v11 = v19 >= 0 ? (const std::string::value_type *)__p : (const std::string::value_type *)__p[0];
      uint64_t v12 = v19 >= 0 ? (void *)HIBYTE(v19) : __p[1];
      std::string::append(*(std::string **)(a1 + 64), v11, (std::string::size_type)v12);
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  uint64_t v14 = *a3;
  uint64_t v13 = a3[1];
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 40);
  *(void *)(a1 + 32) = v14;
  *(void *)(a1 + 40) = v13;
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v15);
  }
  return a1;
}

void sub_1A3F23680(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  int v17 = (std::__shared_weak_count *)v15[9];
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  }
  int v18 = (std::__shared_weak_count *)v15[7];
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  uint64_t v19 = (std::__shared_weak_count *)v15[5];
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v19);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClustererWithTorso::private_t>::__on_zero_shared(uint64_t a1)
{
  vision::mod::GreedyClustererWithTorso::private_t::clusters_t::~clusters_t((vision::mod::GreedyClustererWithTorso::private_t::clusters_t *)(a1 + 72));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    unint64_t v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<vision::mod::GreedyClustererWithTorso::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753818;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClustererWithTorso::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753818;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<vision::mod::GreedyClustererFacesWithTorso>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::GreedyClustererFacesWithTorso>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753A10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClustererFacesWithTorso>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753A10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t vision::mod::GreedyClustererFacesWithTorso::pasreAndVerifyClustererState(uint64_t a1, uint64_t a2, std::string *a3, std::string *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 != -1052410331)
  {
    uint64_t v40 = @"  Clusterer - couldn't find sanity value\n";
LABEL_25:
    VNValidatedLog(4, (uint64_t)v40, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v52);
    uint64_t v41 = -2;
    return (v41 + 128) | 0x1400;
  }
  if (*(_DWORD *)(a2 + 4) != 10007)
  {
    uint64_t v52 = *(unsigned int *)(a2 + 4);
    uint64_t v40 = CFSTR("  Clusterer - versions mismatch (serialized: %d, current: %d");
    goto LABEL_25;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)(a2 + 44));
  createFullPath(&__str, a1, (uint64_t)__p);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  char v20 = verifyChecksumMD5ForFile((const char *)p_str, (void *)(a2 + 24));
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float v21 = &__str;
  }
  else {
    float v21 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if (v20)
  {
    int v28 = open((const char *)v21, 0);
    int v29 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
    if (v28 != -1)
    {
      uint64_t v30 = (std::string *)__str.__r_.__value_.__r.__words[0];
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v30 = &__str;
      }
      VNValidatedLog(1, @"  GreedyClustererFacesWithTorso: Opening '%s'", v22, v23, v24, v25, v26, v27, (uint64_t)v30);
      size_t __len = 0;
      read(v28, &__len, 8uLL);
      std::string::basic_string[abi:ne180100](__p, __len, 48);
      if (v56 >= 0) {
        uint64_t v31 = __p;
      }
      else {
        uint64_t v31 = (void **)__p[0];
      }
      read(v28, v31, __len);
      createFullPath(&v53, a1, (uint64_t)__p);
      if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float v32 = &v53;
      }
      else {
        float v32 = (std::string *)v53.__r_.__value_.__r.__words[0];
      }
      if (verifyChecksumMD5ForFile((const char *)v32, (void *)(a2 + 8)))
      {
        *a5 = v28;
        lseek(v28, 0, 0);
        std::string::operator=(a3, &__str);
        std::string::operator=(a4, &v53);
        unint64_t v39 = &CVML_status_ok;
      }
      else
      {
        int v51 = &v53;
        if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          int v51 = (std::string *)v53.__r_.__value_.__r.__words[0];
        }
        VNValidatedLog(4, @"  Clusterer - data checksum mismatch for file: %s", v33, v34, v35, v36, v37, v38, (uint64_t)v51);
        close(v28);
        unint64_t v39 = &CVML_status_internalError;
      }
      uint64_t v41 = *v39;
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v53.__r_.__value_.__l.__data_);
      }
      if (v56 < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_39;
    }
    std::string::size_type v43 = __str.__r_.__value_.__r.__words[0];
    __error();
    uint64_t v50 = &__str;
    if (v29 < 0) {
      uint64_t v50 = (std::string *)v43;
    }
    VNValidatedLog(4, @"  GreedyClustererFacesWithTorso: Failed to open '%s': errno=%d", v44, v45, v46, v47, v48, v49, (uint64_t)v50);
  }
  else
  {
    VNValidatedLog(4, @"  Clusterer - data checksum mismatch for file: %s", v14, v15, v16, v17, v18, v19, (uint64_t)v21);
  }
  uint64_t v41 = -2;
LABEL_39:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return (v41 + 128) | 0x1400;
}

void sub_1A3F23AF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3F23C14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F23DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A3F23E70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F23FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2476C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,void *__p,uint64_t a51)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F24A9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F24C68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F24DD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2514C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3F256B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24)
{
  _Unwind_Resume(a1);
}

void sub_1A3F25A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F25C30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12938(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__12939(uint64_t a1)
{
}

void sub_1A3F25E50(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1A3F25EE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F25FBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F260A4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1A3F261BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F26250(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F262B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNBGRBilinearUpsampler;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F26328(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2646C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2652C(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3F2654C(_Unwind_Exception *a1)
{
}

void sub_1A3F265C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F26638(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F26E78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F270F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F27190(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F27228(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F27428(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F27608(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F27674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F276C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F277FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F27F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, void *a18, void **a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,char a53)
{
  a19 = (void **)&a50;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a19);
  vision::mod::ImageAnalyzer_Tensor3D::~ImageAnalyzer_Tensor3D((vision::mod::ImageAnalyzer_Tensor3D *)&a53);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v56 - 136);

  _Unwind_Resume(a1);
}

void sub_1A3F28080()
{
}

void std::vector<std::string>::__assign_with_size[abi:ne180100]<std::string*,std::string*>(std::vector<std::string> *a1, std::string *__str, long long *a3, unint64_t a4)
{
  uint64_t v6 = (long long *)__str;
  uint64_t p_end_cap = (uint64_t)&a1->__end_cap_;
  std::vector<int>::pointer begin = a1->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)a1->__end_cap_.__value_ - (char *)a1->__begin_) >> 3) < a4)
  {
    std::vector<std::string>::__vdeallocate(a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x5555555555555556 * (((char *)a1->__end_cap_.__value_ - (char *)a1->__begin_) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * (((char *)a1->__end_cap_.__value_ - (char *)a1->__begin_) >> 3) >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<std::string>::__vallocate[abi:ne180100](a1, v11);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(p_end_cap, v6, a3, a1->__end_);
LABEL_15:
    a1->__end_ = v12;
    return;
  }
  std::vector<unsigned int>::pointer end = a1->__end_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)begin) >> 3) < a4)
  {
    uint64_t v14 = (long long *)(&__str->__r_.__value_.__l.__data_ + (((char *)end - (char *)begin) >> 3));
    if (end != begin)
    {
      uint64_t v15 = 8 * (((char *)end - (char *)begin) >> 3);
      do
      {
        std::string::operator=(begin, (const std::string *)v6);
        uint64_t v6 = (long long *)((char *)v6 + 24);
        ++begin;
        v15 -= 24;
      }
      while (v15);
      std::vector<int>::pointer begin = a1->__end_;
    }
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(p_end_cap, v14, a3, begin);
    goto LABEL_15;
  }
  if (__str != (std::string *)a3)
  {
    do
    {
      std::string::operator=(begin, (const std::string *)v6);
      uint64_t v6 = (long long *)((char *)v6 + 24);
      ++begin;
    }
    while (v6 != a3);
    std::vector<unsigned int>::pointer end = a1->__end_;
  }
  while (end != begin)
  {
    if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(end[-1].__r_.__value_.__l.__data_);
    }
    --end;
  }
  a1->__end_ = begin;
}

void sub_1A3F28224(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1A3F28B1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,void *a36,void *a37,void *a38,void *a39,void *a40,void *a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (v48) {
    operator delete(v48);
  }

  if (a47 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F28D9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F28EB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29084(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F291EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29264(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F292E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29390(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2943C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F294DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Geometry2D_mallocCart2D(void *a1, int a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 >= 1)
  {
    size_t v4 = 4 * a2;
    float v5 = malloc_type_malloc(v4, 0x100004052888210uLL);
    *a1 = v5;
    if (v5 && (uint64_t v6 = malloc_type_malloc(v4, 0x100004052888210uLL), (a1[1] = v6) != 0))
    {
      *((_DWORD *)a1 + 4) = a2;
    }
    else
    {
      free(v5);
      *a1 = 0;
      a1[1] = 0;
      *((_DWORD *)a1 + 4) = 0;
    }
  }
}

uint64_t Geometry2D_copyCart2D(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 1917;
  }
  size_t v4 = *(const void **)a1;
  if (!*(void *)a1 || !*(void *)(a1 + 8)) {
    return 1917;
  }
  uint64_t result = 1917;
  if (a2)
  {
    uint64_t v6 = *(unsigned int *)(a1 + 16);
    if ((int)v6 >= 1)
    {
      if (*(void *)a2)
      {
        if (*(void *)(a2 + 8))
        {
          int v7 = *(_DWORD *)(a2 + 16);
          if (v7 >= 1)
          {
            if (v6 != v7) {
              return 1916;
            }
            memcpy(*(void **)a2, v4, 4 * v6);
            memcpy(*(void **)(a2 + 8), *(const void **)(a1 + 8), 4 * *(int *)(a2 + 16));
            return 1920;
          }
        }
      }
      return 1917;
    }
  }
  return result;
}

float Geometry2D_cloneUsingIndicesCart2D(int *a1, int *a2)
{
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  if (a2)
  {
    if (*(void *)a2)
    {
      if (*((void *)a2 + 1))
      {
        if (a2[4] >= 1)
        {
          Geometry2D_mallocCart2D(a1, 8);
          uint64_t v5 = *(void *)a1;
          if (*(void *)a1)
          {
            uint64_t v6 = *((void *)a1 + 1);
            if (v6)
            {
              if (a1[4] >= 1)
              {
                uint64_t v7 = 0;
                uint64_t v8 = *(void *)a2;
                uint64_t v9 = *((void *)a2 + 1);
                do
                {
                  uint64_t v10 = *(int *)((char *)&LandmarkDetector_faceMesh63Parts + v7 + 1544);
                  *(_DWORD *)(v5 + v7) = *(_DWORD *)(v8 + 4 * v10);
                  float result = *(float *)(v9 + 4 * v10);
                  *(float *)(v6 + v7) = result;
                  v7 += 4;
                }
                while (v7 != 32);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void sub_1A3F29778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29A1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29AEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29C10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29E4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29F58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F29FF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2A10C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2A19C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2A4D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2A6E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _dataUnvailableError(uint64_t a1)
{
  uint64_t v1 = [NSString stringWithFormat:@"no operation point data is available for \"%@\"", a1];
  uint64_t v2 = +[VNError errorForDataUnavailableWithLocalizedDescription:v1];

  return v2;
}

void sub_1A3F2B694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2BB70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2BCE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2BE3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2BF90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2C0C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2C2B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2C718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, id a18)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2CD60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2CED0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2D0B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2D1EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2D358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2D3E8(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;

  _Unwind_Resume(a1);
}

void sub_1A3F2D4AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNLKTOpticalFlowGPU;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F2D618(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2DAB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__13918(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__13919(uint64_t a1)
{
}

void sub_1A3F2E0C8(void *a1)
{
}

uint64_t _bestDimensionForSizeRange(void *a1, unint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = [v3 idealDimension];
  if (!v4)
  {
    if ([v3 isAllowedDimension:a2])
    {
      uint64_t v4 = a2;
    }
    else
    {
      uint64_t v4 = [v3 maximumDimension];
      if (v4 - 1 >= a2)
      {
        uint64_t v5 = [v3 minimumDimension];
        if (v5) {
          uint64_t v4 = v5;
        }
        else {
          uint64_t v4 = a2;
        }
      }
    }
  }

  return v4;
}

void sub_1A3F2E71C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2E900(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__13962(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__13963(uint64_t a1)
{
}

void sub_1A3F2E9E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2EAD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2EBFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2ED48(_Unwind_Exception *a1)
{
}

void sub_1A3F2EF2C(_Unwind_Exception *a1)
{
}

void sub_1A3F2F0EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F29C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F3D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F5C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F608(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F6AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F780(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F834(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2F8F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2FA24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2FAE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2FB80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F2FD90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F30344(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F304E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F30744(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1A3F30540);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F3088C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F30A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, uint64_t a9, ...)
{
  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A3F30AB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F30BDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNTrackMaskDetectorState;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F30C70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F314F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    if (!v14) {
      JUMPOUT(0x1A3F31424);
    }
    JUMPOUT(0x1A3F31418);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3F31878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F31B98(void *a1)
{
  operator delete(v1);
  objc_begin_catch(a1);
  JUMPOUT(0x1A3F31B34);
}

void sub_1A3F31CE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F31F04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F32020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A3F32244(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F32404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3256C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F32748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F32814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNTrackMaskDetector;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F32998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F32B10(_Unwind_Exception *a1)
{
  id v3 = v2;

  _Unwind_Resume(a1);
}

uint64_t ctrTrackerAlgorithm_computeFFTx(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, DSPComplex *__C, DSPSplitComplex *__Z, OpaqueFFTSetup *a8)
{
  uint64_t v8 = 6780;
  if (a1 && a2 && a3 && a4 && a5 && __C && __Z)
  {
    uint64_t v16 = 0;
    int8x8_t v17 = 0;
    do
    {
      int8x16_t v18 = *(int8x16_t *)(a1 + v16);
      int8x8_t v19 = (int8x8_t)vextq_s8(v18, v18, 8uLL).u64[0];
      float32x4_t v20 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v19, v17) & 0xFF00FF00FF00FFLL)));
      float32x4_t v21 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v19, v17) & 0xFF00FF00FF00FFLL)));
      float32x4_t v22 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v18.i8, v17) & 0xFF00FF00FF00FFLL)));
      float32x4_t v23 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v18.i8, v17) & 0xFF00FF00FF00FFLL)));
      *(float *)v17.i32 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)v17.i32 + v23.f32[0]) + v23.f32[1]) + v23.f32[2]) + v23.f32[3]) + v22.f32[0]) + v22.f32[1])
                                                                                                + v22.f32[2])
                                                                                        + v22.f32[3])
                                                                                + v21.f32[0])
                                                                        + v21.f32[1])
                                                                + v21.f32[2])
                                                        + v21.f32[3])
                                                + v20.f32[0])
                                        + v20.f32[1])
                                + v20.f32[2])
                        + v20.f32[3];
      v16 += 16;
    }
    while (v16 != 0x4000);
    uint64_t v24 = 0;
    float v25 = 0.000061035;
    float v26 = *(float *)v17.i32 * 0.000061035;
    do
    {
      LOBYTE(v25) = *(unsigned char *)(a1 + v24);
      float v25 = (float)(*(float *)(a5 + 4 * v24) * (float)((float)LODWORD(v25) - v26)) / 255.0;
      *(&__C->real + v24++) = v25;
    }
    while (v24 != 0x4000);
    vDSP_ctoz(__C, 2, __Z, 1, 0x2000uLL);
    vDSP_fft2d_zrip(a8, __Z, 1, 0, 7uLL, 7uLL, 1);
    uint64_t v27 = 0;
    int8x8_t v28 = 0;
    do
    {
      int8x16_t v29 = *(int8x16_t *)(a2 + v27);
      int8x8_t v30 = (int8x8_t)vextq_s8(v29, v29, 8uLL).u64[0];
      float32x4_t v31 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v30, v28) & 0xFF00FF00FF00FFLL)));
      float32x4_t v32 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v30, v28) & 0xFF00FF00FF00FFLL)));
      float32x4_t v33 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v29.i8, v28) & 0xFF00FF00FF00FFLL)));
      float32x4_t v34 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v29.i8, v28) & 0xFF00FF00FF00FFLL)));
      *(float *)v28.i32 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)v28.i32 + v34.f32[0]) + v34.f32[1]) + v34.f32[2]) + v34.f32[3]) + v33.f32[0]) + v33.f32[1])
                                                                                                + v33.f32[2])
                                                                                        + v33.f32[3])
                                                                                + v32.f32[0])
                                                                        + v32.f32[1])
                                                                + v32.f32[2])
                                                        + v32.f32[3])
                                                + v31.f32[0])
                                        + v31.f32[1])
                                + v31.f32[2])
                        + v31.f32[3];
      v27 += 16;
    }
    while (v27 != 0x4000);
    uint64_t v35 = 0;
    float v36 = 0.000061035;
    float v37 = *(float *)v28.i32 * 0.000061035;
    do
    {
      LOBYTE(v36) = *(unsigned char *)(a2 + v35);
      float v36 = (float)(*(float *)(a5 + 4 * v35) * (float)((float)LODWORD(v36) - v37)) / 255.0;
      *(&__C->real + v35++) = v36;
    }
    while (v35 != 0x4000);
    vDSP_ctoz(__C, 2, __Z + 1, 1, 0x2000uLL);
    vDSP_fft2d_zrip(a8, __Z + 1, 1, 0, 7uLL, 7uLL, 1);
    uint64_t v38 = 0;
    int8x8_t v39 = 0;
    do
    {
      int8x16_t v40 = *(int8x16_t *)(a3 + v38);
      int8x8_t v41 = (int8x8_t)vextq_s8(v40, v40, 8uLL).u64[0];
      float32x4_t v42 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v41, v39) & 0xFF00FF00FF00FFLL)));
      float32x4_t v43 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v41, v39) & 0xFF00FF00FF00FFLL)));
      float32x4_t v44 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v40.i8, v39) & 0xFF00FF00FF00FFLL)));
      float32x4_t v45 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v40.i8, v39) & 0xFF00FF00FF00FFLL)));
      *(float *)v39.i32 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)v39.i32 + v45.f32[0]) + v45.f32[1]) + v45.f32[2]) + v45.f32[3]) + v44.f32[0]) + v44.f32[1])
                                                                                                + v44.f32[2])
                                                                                        + v44.f32[3])
                                                                                + v43.f32[0])
                                                                        + v43.f32[1])
                                                                + v43.f32[2])
                                                        + v43.f32[3])
                                                + v42.f32[0])
                                        + v42.f32[1])
                                + v42.f32[2])
                        + v42.f32[3];
      v38 += 16;
    }
    while (v38 != 0x4000);
    uint64_t v46 = 0;
    float v47 = 0.000061035;
    float v48 = *(float *)v39.i32 * 0.000061035;
    do
    {
      LOBYTE(v47) = *(unsigned char *)(a3 + v46);
      float v47 = (float)(*(float *)(a5 + 4 * v46) * (float)((float)LODWORD(v47) - v48)) / 255.0;
      *(&__C->real + v46++) = v47;
    }
    while (v46 != 0x4000);
    vDSP_ctoz(__C, 2, __Z + 2, 1, 0x2000uLL);
    vDSP_fft2d_zrip(a8, __Z + 2, 1, 0, 7uLL, 7uLL, 1);
    uint64_t v49 = 0;
    int8x8_t v50 = 0;
    do
    {
      int8x16_t v51 = *(int8x16_t *)(a4 + v49);
      int8x8_t v52 = (int8x8_t)vextq_s8(v51, v51, 8uLL).u64[0];
      float32x4_t v53 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v52, v50) & 0xFF00FF00FF00FFLL)));
      float32x4_t v54 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v52, v50) & 0xFF00FF00FF00FFLL)));
      float32x4_t v55 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v51.i8, v50) & 0xFF00FF00FF00FFLL)));
      float32x4_t v56 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v51.i8, v50) & 0xFF00FF00FF00FFLL)));
      *(float *)v50.i32 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)v50.i32 + v56.f32[0]) + v56.f32[1]) + v56.f32[2]) + v56.f32[3]) + v55.f32[0]) + v55.f32[1])
                                                                                                + v55.f32[2])
                                                                                        + v55.f32[3])
                                                                                + v54.f32[0])
                                                                        + v54.f32[1])
                                                                + v54.f32[2])
                                                        + v54.f32[3])
                                                + v53.f32[0])
                                        + v53.f32[1])
                                + v53.f32[2])
                        + v53.f32[3];
      v49 += 16;
    }
    while (v49 != 0x4000);
    uint64_t v57 = 0;
    float v58 = 0.000061035;
    float v59 = *(float *)v50.i32 * 0.000061035;
    do
    {
      LOBYTE(v58) = *(unsigned char *)(a4 + v57);
      float v58 = (float)(*(float *)(a5 + 4 * v57) * (float)((float)LODWORD(v58) - v59)) / 255.0;
      *(&__C->real + v57++) = v58;
    }
    while (v57 != 0x4000);
    BOOL v60 = __Z + 3;
    vDSP_ctoz(__C, 2, v60, 1, 0x2000uLL);
    vDSP_fft2d_zrip(a8, v60, 1, 0, 7uLL, 7uLL, 1);
    return 6784;
  }
  return v8;
}

uint64_t ctrTrackerAlgorithm_GaussianCorrelation(uint64_t a1, uint64_t a2, DSPSplitComplex *a3, const DSPSplitComplex *a4, DSPComplex *a5, char *a6, OpaqueFFTSetup *a7)
{
  uint64_t v7 = 6780;
  if (a1)
  {
    uint64_t v8 = a2;
    if (a2)
    {
      if (a3 && a4 && a5 && a6)
      {
        bzero(a6, 0x10000uLL);
        for (uint64_t i = 0; i != 4; ++i)
        {
          uint64_t v14 = v8;
          uint64_t v15 = (const DSPSplitComplex *)(v8 + 16 * i);
          uint64_t v16 = (const DSPSplitComplex *)(a1 + 16 * i);
          vDSP_zvcmul(v15, 1, v16, 1, a3, 1, 0x2000uLL);
          uint64_t v17 = 0;
          realp = v16->realp;
          int8x8_t v19 = v15->realp;
          float32x4_t v20 = a3->realp;
          imagp = a3->imagp;
          float *v20 = *v16->realp * *v15->realp;
          uint64_t v24 = v16->imagp;
          p_imagp = &v16->imagp;
          float32x4_t v22 = v24;
          float v26 = v15->imagp;
          float v25 = &v15->imagp;
          float *imagp = *v22 * *v26;
          _DWORD v20[64] = realp[64] * v19[64];
          imagp[64] = v22[64] * v26[64];
          uint64_t v27 = a4->realp;
          int8x8_t v28 = a4->imagp;
          int8x16_t v29 = a4[1].realp;
          int8x8_t v30 = a4[1].imagp;
          float32x4_t v31 = v19 + 192;
          float32x4_t v32 = realp + 192;
          do
          {
            v27[v17] = *(v32 - 64);
            v28[v17] = *v32;
            v29[v17] = *(v31 - 64);
            v30[v17++] = *v31;
            v31 += 128;
            v32 += 128;
          }
          while (v17 != 63);
          vDSP_zvcmul(a4 + 1, 1, a4, 1, a4 + 2, 1, 0x3EuLL);
          uint64_t v33 = 0;
          float32x4_t v34 = a4[2].realp;
          uint64_t v35 = a4[2].imagp;
          float v36 = a3->realp + 192;
          do
          {
            *(v36 - 64) = LODWORD(v34[v33]);
            *float v36 = LODWORD(v35[v33]);
            v36 += 128;
            ++v33;
          }
          while (v33 != 63);
          uint64_t v37 = 0;
          uint64_t v38 = a4->realp;
          int8x8_t v39 = a4->imagp;
          int8x16_t v40 = a4[1].realp;
          int8x8_t v41 = a4[1].imagp;
          float32x4_t v42 = *v25 + 192;
          float32x4_t v43 = *p_imagp + 192;
          do
          {
            v38[v37] = *(v43 - 64);
            v39[v37] = *v43;
            v40[v37] = *(v42 - 64);
            v41[v37++] = *v42;
            v42 += 128;
            v43 += 128;
          }
          while (v37 != 63);
          vDSP_zvcmul(a4 + 1, 1, a4, 1, a4 + 2, 1, 0x3EuLL);
          uint64_t v44 = 0;
          float32x4_t v45 = a4[2].realp;
          uint64_t v46 = a4[2].imagp;
          float v47 = a3->imagp + 192;
          uint64_t v8 = v14;
          do
          {
            *(v47 - 64) = LODWORD(v45[v44]);
            *float v47 = LODWORD(v46[v44]);
            v47 += 128;
            ++v44;
          }
          while (v44 != 63);
          vDSP_fft2d_zrip(a7, a3, 1, 0, 7uLL, 7uLL, -1);
          vDSP_ztoc(a3, 1, a5, 2, 0x2000uLL);
          float __B = 0.000015259;
          vDSP_vsmul((const float *)a5, 1, &__B, (float *)a5, 1, 0x4000uLL);
          for (uint64_t j = 0; j != 0x10000; j += 4)
            *(float *)&a6[j] = *(float *)((char *)&a5->real + j) + *(float *)&a6[j];
        }
        float v57 = 0.0;
        uint64_t v7 = ctrTrackerAlgorithm_packedNorm(a1, a3, &v57);
        if (v7 == 128)
        {
          float v56 = 0.0;
          uint64_t v7 = ctrTrackerAlgorithm_packedNorm(v14, a3, &v56);
          if (v7 == 128)
          {
            uint64_t v49 = 0;
            float v50 = v57 + v56;
            do
            {
              float v51 = (float)(v50 + (float)(*(float *)&a6[v49] * -2.0)) * 0.000015259;
              if (v51 <= 0.0) {
                float v52 = -0.0;
              }
              else {
                float v52 = v51 * -25.0;
              }
              *(float *)((char *)&a5->real + v49) = expf(v52);
              v49 += 4;
            }
            while (v49 != 0x10000);
            vDSP_ctoz(a5, 2, a3, 1, 0x2000uLL);
            vDSP_fft2d_zrip(a7, a3, 1, 0, 7uLL, 7uLL, 1);
          }
        }
      }
    }
  }
  return v7;
}

uint64_t ctrTrackerAlgorithm_packedNorm(uint64_t a1, DSPSplitComplex *__C, float *a3)
{
  if (!a3) {
    return 6780;
  }
  uint64_t v6 = 0;
  float v7 = 0.0;
  do
  {
    vDSP_zvcmul((const DSPSplitComplex *)(a1 + 16 * v6), 1, (const DSPSplitComplex *)(a1 + 16 * v6), 1, __C, 1, 0x2000uLL);
    uint64_t v9 = 0;
    float v10 = 0.0;
    do
      float v10 = v10 + __C->realp[v9++];
    while (v9 != 0x2000);
    unint64_t v11 = *(float **)(a1 + 16 * v6 + 8);
    uint64_t v8 = a1 + 16 * v6;
    float v7 = v7
       + (float)((float)(v10
                       + (float)((float)((float)((float)((float)(*v11 * *v11) + (float)(**(float **)v8 * **(float **)v8))
                                               + (float)(*(float *)(*(void *)v8 + 256)
                                                       * *(float *)(*(void *)v8 + 256)))
                                       + (float)(v11[64] * v11[64]))
                               * -0.5))
               * 0.000030518);
    ++v6;
  }
  while (v6 != 4);
  *a3 = v7;
  return 6784;
}

uint64_t ctrTrackerAlgorithm_packedDivision(float **a1, float **a2, float **a3)
{
  uint64_t v3 = 6780;
  if (a1 && a2 && a3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *a1;
    float32x4_t v6 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    do
    {
      *(float32x4_t *)&v5[v4] = vaddq_f32(*(float32x4_t *)&v5[v4], v6);
      v4 += 4;
    }
    while (v4 != 0x2000);
    unint64_t v7 = 1;
    uint64_t v8 = 192;
    do
    {
      v5[v8] = v5[v8] + -0.0001;
      v7 += 2;
      v8 += 128;
    }
    while (v7 < 0x7E);
    uint64_t v9 = 0;
    float v10 = *a2;
    unint64_t v11 = *a3;
    uint64_t v12 = a3[1];
    uint64_t v13 = v12 + 1;
    uint64_t v14 = a1[1];
    uint64_t v15 = (uint64_t)(*a3 + 1);
    uint64_t v16 = v14 + 1;
    uint64_t v17 = v5 + 1;
    uint64_t v18 = (uint64_t)(*a2 + 1);
    do
    {
      for (uint64_t i = 0; i != 63; ++i)
      {
        *(float *)(v15 + i * 4) = (float)(*(float *)(v18 + i * 4) * v17[i])
                                / (float)((float)(v16[i] * v16[i]) + (float)(v17[i] * v17[i]));
        v13[i] = (float)-(float)(*(float *)(v18 + i * 4) * v16[i])
               / (float)((float)(v16[i] * v16[i]) + (float)(v17[i] * v17[i]));
      }
      ++v9;
      v13 += 64;
      v15 += 256;
      v16 += 64;
      v17 += 64;
      v18 += 256;
    }
    while (v9 != 128);
    unint64_t v20 = 0;
    float *v11 = (float)(*v10 * *v5) / (float)((float)(*v14 * *v14) + (float)(*v5 * *v5));
    *uint64_t v12 = (float)-(float)(*v10 * *v14) / (float)((float)(*v14 * *v14) + (float)(*v5 * *v5));
    v11[64] = (float)(v10[64] * v5[64]) / (float)((float)(v14[64] * v14[64]) + (float)(v5[64] * v5[64]));
    float32x4_t v21 = v12 + 128;
    v12[64] = (float)-(float)(v10[64] * v14[64]) / (float)((float)(v14[64] * v14[64]) + (float)(v5[64] * v5[64]));
    float32x4_t v22 = v11 + 128;
    float32x4_t v23 = v14 + 128;
    uint64_t v24 = v5 + 128;
    float v25 = v10 + 128;
    do
    {
      float *v22 = (float)(*v25 * *v24) / (float)((float)(*v23 * *v23) + (float)(*v24 * *v24));
      float *v21 = (float)-(float)(*v25 * *v23) / (float)((float)(*v23 * *v23) + (float)(*v24 * *v24));
      v20 += 2;
      v21 += 128;
      v22 += 128;
      v23 += 128;
      v24 += 128;
      v25 += 128;
    }
    while (v20 < 0x7E);
    float v26 = v12 + 192;
    uint64_t v27 = v11 + 192;
    unint64_t v28 = 1;
    uint64_t v3 = 6784;
    do
    {
      *uint64_t v27 = 0;
      *float v26 = 0;
      v28 += 2;
      v26 += 128;
      v27 += 128;
    }
    while (v28 < 0x7E);
  }
  return v3;
}

float vision::mod::ImageDescriptorProcessorEspresso::getRequiredImageSize(vision::mod::ImageDescriptorProcessorEspresso *this)
{
  uint64_t v1 = (void *)**((void **)this + 6);
  if (v1 && objc_msgSend(v1, "layers_size") && espresso_vision_first_layer_number_of_input_blobs()) {
    return (float)(int)((unint64_t)espresso_vision_first_layer_first_source_blob_shape() >> 32);
  }
  else {
    return NAN;
  }
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::getRequiredImageChannelDepth(vision::mod::ImageDescriptorProcessorEspresso *this)
{
  uint64_t result = **((void **)this + 6);
  if (result)
  {
    uint64_t result = espresso_vision_first_layer_number_of_input_blobs();
    if (result) {
      return *(unsigned int *)(*((void *)this + 6) + 16);
    }
  }
  return result;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::getRequiredImageType(vision::mod::ImageDescriptorProcessorAbstract *this)
{
  return 0;
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::getDescriptorLengthInBytes(vision::mod::ImageDescriptorProcessorEspresso *this)
{
  return 4 * *(int *)(*((void *)this + 6) + 12);
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::setPriority(vision::mod::ImageDescriptorProcessorEspresso *this)
{
  if (espresso_vision_util_update_metal_priority()) {
    return 3712;
  }
  else {
    return 3708;
  }
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::wipeLayersMemory(id **this)
{
  return 3712;
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorsForImages_Planar8(_DWORD *a1, uint64_t *a2, void *a3, void *a4)
{
  unint64_t v7 = a3;
  int v8 = a1[10];
  if (!v8)
  {
    if (((*(uint64_t (**)(_DWORD *))(*(void *)a1 + 136))(a1) & 1) == 0)
    {
      uint64_t v12 = 3691;
      goto LABEL_28;
    }
    uint64_t v13 = *((void *)a1 + 6);
    if (*((unsigned char *)a1 + 8) && *(_DWORD *)(v13 + 8) > (int)((unint64_t)(a2[1] - *a2) >> 5))
    {
      syslog(5, "ERROR: The number of images submitted to batch compute the descriptors is less than the size of the internal Espresso network batch size (resulting in a waste of memory and computation)");
      exception = __cxa_allocate_exception(8uLL);
      void *exception = 3700;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
    if (*(_DWORD *)(v13 + 16) == 1)
    {
      if (v14)
      {
        uint64_t v15 = v14[12];
        if (v15 == (unint64_t)(*(uint64_t (**)(_DWORD *))(*(void *)a1 + 128))(a1) >> 2)
        {
          vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(v16, (a2[1] - *a2) >> 5, 0);
          int v29 = 0;
          LODWORD(v27) = a1[3];
          int v17 = *((unsigned __int8 *)a1 + 37);
          HIDWORD(v27) = *((unsigned __int8 *)a1 + 36);
          *(_DWORD *)unint64_t v28 = v17;
          *(_OWORD *)&v28[4] = *(_OWORD *)(a1 + 5);
          uint64_t v12 = espresso_vision_compute_batch();
          if ((v12 & 0x80) != 0)
          {
            if (*((unsigned char *)a1 + 38))
            {
              uint64_t v18 = a4[7];
              int v19 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 128))(a1);
              if (a4[9])
              {
                unsigned int v20 = 0;
                unint64_t v21 = (unint64_t)v19 >> 2;
                unsigned int v22 = 1;
                do
                {
                  normalizeMeanL2((float *)(v18 + 4 * v20), v21);
                  BOOL v23 = a4[9] > (unint64_t)v22++;
                  v20 += v21;
                }
                while (v23);
              }
            }
          }
          goto LABEL_28;
        }
      }
    }
LABEL_27:
    uint64_t v12 = 3708;
    goto LABEL_28;
  }
  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  if (v10 - *a2 != 64) {
    goto LABEL_27;
  }
  if (v9 == v10)
  {
    uint64_t v12 = 3712;
  }
  else
  {
    int v11 = 0;
    while (!v7 || (v7[2](v7) & 1) == 0)
    {
      if (v11) {
        a1[10] = 0;
      }
      (*(void (**)(uint64_t *__return_ptr, _DWORD *))(*(void *)a1 + 64))(&v27, a1);
      uint64_t v12 = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t))(*(void *)a1 + 32))(a1, v9, v27);
      a1[10] = v8;
      if ((v12 & 0x80) == 0)
      {
        float v25 = __cxa_allocate_exception(8uLL);
        *float v25 = v12;
        __cxa_throw(v25, MEMORY[0x1E4FBA3E0], 0);
      }
      (*(void (**)(void *, uint64_t))(*a4 + 40))(a4, v27);
      if (*(void *)v28) {
        std::__shared_weak_count::__release_shared[abi:nn180100](*(std::__shared_weak_count **)v28);
      }
      v9 += 32;
      --v11;
      if (v9 == v10) {
        goto LABEL_28;
      }
    }
    uint64_t v12 = -29;
  }
LABEL_28:

  return v12;
}

void sub_1A3F340A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float *normalizeMeanL2(float *result, unsigned int a2)
{
  if ((int)a2 >= 1)
  {
    uint64_t v2 = a2;
    float v3 = 0.0;
    uint64_t v4 = result;
    uint64_t v5 = a2;
    do
    {
      float v6 = *v4++;
      float v3 = v3 + v6;
      --v5;
    }
    while (v5);
    float v7 = v3 / (float)(int)a2;
    int v8 = result;
    uint64_t v9 = a2;
    do
    {
      *int v8 = *v8 - v7;
      ++v8;
      --v9;
    }
    while (v9);
    float v10 = 0.0;
    int v11 = result;
    uint64_t v12 = a2;
    do
    {
      float v13 = *v11++;
      float v10 = v10 + (float)(v13 * v13);
      --v12;
    }
    while (v12);
    if (v10 < 0.000001) {
      float v10 = 0.000001;
    }
    float v14 = 1.0 / sqrtf(v10);
    do
    {
      *uint64_t result = v14 * *result;
      ++result;
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorsForImages_BGRA8888(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) & 4) != 0) {
    uint64_t v8 = vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorsForImages_XYZA8888(a1, a2, v7, a4);
  }
  else {
    uint64_t v8 = 3691;
  }

  return v8;
}

void sub_1A3F34280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorsForImages_XYZA8888(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  uint64_t v8 = v7;
  if (v7 && ((*((uint64_t (**)(id))v7 + 2))(v7) & 1) != 0)
  {
    uint64_t v9 = 3683;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 48);
    if (*(unsigned char *)(a1 + 8) && *(_DWORD *)(v10 + 8) > (int)((a2[1] - *a2) >> 5))
    {
      syslog(5, "ERROR: The number of images submitted to batch compute the descriptors is less than the size of the internal Espresso network batch size (resulting in a waste of memory and computation)");
      exception = __cxa_allocate_exception(8uLL);
      void *exception = 3700;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
    if ((*(_DWORD *)(v10 + 16) - 3) <= 1
    {
      vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(v12, (uint64_t)(a2[1] - *a2) >> 5, 0);
      if (*(unsigned char *)(a1 + 16))
      {
        uint64_t v15 = *(void *)(*a2 + 8);
        uint64_t v16 = *(void *)(*a2 + 16);
        if (v15)
        {
          uint64_t v17 = 0;
          float v18 = 0.0;
          float v19 = 0.0;
          float v20 = 0.0;
          do
          {
            if (v16)
            {
              unint64_t v21 = (unsigned char *)(*(void *)*a2 + *(void *)(*a2 + 24) * v17 + 2);
              uint64_t v22 = *(void *)(*a2 + 16);
              do
              {
                LOBYTE(v14) = *(v21 - 2);
                *(float *)&unsigned int v23 = (float)LODWORD(v14);
                float v20 = v20 + *(float *)&v23;
                LOBYTE(v23) = *(v21 - 1);
                *(float *)&unsigned int v24 = (float)v23;
                float v19 = v19 + *(float *)&v24;
                LOBYTE(v24) = *v21;
                float v14 = (float)v24;
                float v18 = v18 + v14;
                v21 += 4;
                --v22;
              }
              while (v22);
            }
            ++v17;
          }
          while (v17 != v15);
        }
        else
        {
          float v20 = 0.0;
          float v19 = 0.0;
          float v18 = 0.0;
        }
        float v26 = (float)(unint64_t)(v16 * v15);
        *(float *)(a1 + 20) = (float)-v20 / v26;
        *(float *)(a1 + 24) = (float)-v19 / v26;
        *(float *)(a1 + 28) = (float)-v18 / v26;
      }
      uint64_t v9 = espresso_vision_compute_batch();
      if ((v9 & 0x80) != 0)
      {
        if (*(unsigned char *)(a1 + 38))
        {
          uint64_t v27 = a4[7];
          int v28 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 128))(a1);
          if (a4[9])
          {
            unsigned int v29 = 0;
            unint64_t v30 = (unint64_t)v28 >> 2;
            unsigned int v31 = 1;
            do
            {
              normalizeMeanL2((float *)(v27 + 4 * v29), v30);
              BOOL v32 = a4[9] > (unint64_t)v31++;
              v29 += v30;
            }
            while (v32);
          }
        }
      }
    }
    else
    {
      uint64_t v9 = 3708;
    }
  }

  return v9;
}

void sub_1A3F345A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorsForImages_RGBA8888(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) & 2) != 0) {
    uint64_t v8 = vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorsForImages_XYZA8888(a1, a2, v7, a4);
  }
  else {
    uint64_t v8 = 3691;
  }

  return v8;
}

void sub_1A3F34650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t vision::mod::ImageDescriptorProcessorEspresso::createDescriptorBuffer@<X0>(vision::mod::ImageDescriptorProcessorEspresso *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x90uLL);
  v4[1] = 0;
  void v4[2] = 0;
  *uint64_t v4 = &unk_1EF7539A0;
  void v4[4] = 0;
  v4[5] = 0;
  v4[8] = 0;
  v4[9] = 0;
  void v4[6] = 0;
  v4[7] = v4 + 8;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((unsigned char *)v4 + 112) = 0;
  v4[3] = &unk_1EF752918;
  v4[15] = 0;
  *((_DWORD *)v4 + 32) = 1;
  v4[17] = 0;
  unint64_t result = (*(uint64_t (**)(vision::mod::ImageDescriptorProcessorEspresso *))(*(void *)this + 128))(this);
  v4[15] = result >> 2;
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1A3F3473C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorForAugmentedImage(_DWORD *a1, _OWORD *a2, uint64_t a3, void *a4, void *lpsrc)
{
  if (a1[10])
  {
    if (!v10) {
      return 3708;
    }
    uint64_t v11 = v10[12];
    if (v11 != (unint64_t)(*(uint64_t (**)(_DWORD *))(*(void *)a1 + 128))(a1) >> 2) {
      return 3708;
    }
    a1[11] = -1082130432;
    uint64_t v12 = vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForAugmentedImage((uint64_t)a1, a2, a3, a4, (uint64_t)lpsrc);
    if ((v12 & 0x80) != 0)
    {
      int v13 = a1[11];
      float v14 = (float *)operator new(4uLL);
      *(_DWORD *)float v14 = v13;
      uint64_t v15 = *((void *)lpsrc + 9);
      uint64_t v16 = (*(uint64_t (**)(void *))(*(void *)lpsrc + 104))(lpsrc);
      if (v15 != 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = 3708;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
      unint64_t v17 = v16;
      float v18 = (const void **)(*(uint64_t (**)(void *))(*(void *)lpsrc + 24))(lpsrc);
      unint64_t v19 = v17 >> 2;
      uint64_t v20 = *((void *)lpsrc + 12);
      *((void *)lpsrc + 12) = v20 + 1;
      *((void *)lpsrc + 8) = v19 + 1;
      vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount((vision::mod::ImageDescriptorBufferAbstract *)lpsrc, 1uLL, 0);
      size_t v21 = 4 * (int)v20;
      uint64_t v22 = (char *)*((void *)lpsrc + 7);
      memcpy(v22, v18[7], v21);
      *(float *)&v22[v21] = *v14 * 0.00001;
      (*((void (**)(const void **))*v18 + 1))(v18);
      operator delete(v14);
    }
    return v12;
  }
  else
  {
    return vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForAugmentedImage((uint64_t)a1, a2, a3, a4, (uint64_t)lpsrc);
  }
}

void sub_1A3F349A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForAugmentedImage(uint64_t a1, _OWORD *a2, uint64_t a3, void *a4, uint64_t a5)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 64))(&v13);
  uint64_t v10 = vision::mod::ImageDescriptorAugmenterAbstract::augment(a4, a2, a3);
  if ((v10 & 0x80) != 0)
  {
    vision::mod::ImageDescriptorAugmenterAbstract::getAugmentedImages((vision::mod::ImageDescriptorAugmenterAbstract *)__p, (uint64_t)a4);
    uint64_t v10 = (*(uint64_t (**)(uint64_t, void **, uint64_t, void, uint64_t))(*(void *)a1 + 96))(a1, __p, a3, 0, v13);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if ((v10 & 0x80) != 0) {
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*a4 + 24))(a4, v13, a5);
    }
  }
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  return v10;
}

void sub_1A3F34ADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorForImage_Planar8(vision::mod::ImageDescriptorProcessorEspresso *this, const vImage_Buffer *a2, float **a3)
{
  if (((*(uint64_t (**)(vision::mod::ImageDescriptorProcessorEspresso *))(*(void *)this + 136))(this) & 1) == 0) {
    return 3691;
  }
  uint64_t v6 = *((void *)this + 6);
  if (*((unsigned char *)this + 8) && *(int *)(v6 + 8) >= 2)
  {
    syslog(5, "ERROR: The number of images submitted to batch compute the descriptors is less than the size of the internal Espresso network batch size (resulting in a waste of memory and computation)");
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3700;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if (*(_DWORD *)(v6 + 16) != 1) {
    return 3708;
  }
  if (!v7) {
    return 3708;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *((void *)v7 + 12);
  if (v9 != (unint64_t)(*(uint64_t (**)(vision::mod::ImageDescriptorProcessorEspresso *))(*(void *)this + 128))(this) >> 2) {
    return 3708;
  }
  vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(v8, 1uLL, 0);
  if (*((_DWORD *)this + 10))
  {
    uint64_t v5 = espresso_vision_compute_dropout_augment();
    if ((v5 & 0x80) == 0) {
      return v5;
    }
  }
  else
  {
    espresso_vision_compute();
    uint64_t v5 = 3712;
  }
  if (*((unsigned char *)this + 38))
  {
    uint64_t v11 = a3[7];
    int v12 = (*(uint64_t (**)(vision::mod::ImageDescriptorProcessorEspresso *))(*(void *)this + 128))(this);
    normalizeMeanL2(v11, (unint64_t)v12 >> 2);
  }
  if (*((_DWORD *)this + 10)) {
    *((_DWORD *)this + 11) = 1065353216;
  }
  return v5;
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorForImage_BGRA8888(vision::mod::ImageDescriptorProcessorEspresso *this, const vImage_Buffer *a2, float **a3)
{
  if (((*(uint64_t (**)(vision::mod::ImageDescriptorProcessorEspresso *))(*(void *)this + 136))(this) & 4) == 0) {
    return 3691;
  }

  return vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorForImage_XYZA8888(this, a2, a3);
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorForImage_XYZA8888(vision::mod::ImageDescriptorProcessorEspresso *this, const vImage_Buffer *a2, float **lpsrc)
{
  uint64_t v6 = *((void *)this + 6);
  if (*((unsigned char *)this + 8) && *(int *)(v6 + 8) >= 2)
  {
    syslog(5, "ERROR: The number of images submitted to batch compute the descriptors is less than the size of the internal Espresso network batch size (resulting in a waste of memory and computation)");
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3700;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if ((*(_DWORD *)(v6 + 16) - 3) > 1) {
    return 3708;
  }
  if (!v7) {
    return 3708;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *((void *)v7 + 12);
  if (v9 != (unint64_t)(*(uint64_t (**)(vision::mod::ImageDescriptorProcessorEspresso *))(*(void *)this + 128))(this) >> 2) {
    return 3708;
  }
  vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(v8, 1uLL, 0);
  if (*((unsigned char *)this + 16))
  {
    vImagePixelCount height = a2->height;
    vImagePixelCount width = a2->width;
    if (height)
    {
      uint64_t v13 = 0;
      float v14 = (char *)a2->data + 2;
      float v15 = 0.0;
      float v16 = 0.0;
      float v17 = 0.0;
      do
      {
        float v18 = v14;
        vImagePixelCount v19 = a2->width;
        if (width)
        {
          do
          {
            LOBYTE(v10) = *(v18 - 2);
            *(float *)&unsigned int v20 = (float)LODWORD(v10);
            float v17 = v17 + *(float *)&v20;
            LOBYTE(v20) = *(v18 - 1);
            *(float *)&unsigned int v21 = (float)v20;
            float v16 = v16 + *(float *)&v21;
            LOBYTE(v21) = *v18;
            float v10 = (float)v21;
            float v15 = v15 + v10;
            v18 += 4;
            --v19;
          }
          while (v19);
        }
        ++v13;
        v14 += a2->rowBytes;
      }
      while (v13 != height);
    }
    else
    {
      float v17 = 0.0;
      float v16 = 0.0;
      float v15 = 0.0;
    }
    float v23 = (float)(width * height);
    *((float *)this + 5) = (float)-v17 / v23;
    *((float *)this + 6) = (float)-v16 / v23;
    *((float *)this + 7) = (float)-v15 / v23;
  }
  espresso_vision_compute();
  if (*((unsigned char *)this + 38))
  {
    unsigned int v24 = lpsrc[7];
    int v25 = (*(uint64_t (**)(vision::mod::ImageDescriptorProcessorEspresso *))(*(void *)this + 128))(this);
    normalizeMeanL2(v24, (unint64_t)v25 >> 2);
  }
  return 3712;
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorForImage_RGBA8888(vision::mod::ImageDescriptorProcessorEspresso *this, const vImage_Buffer *a2, float **a3)
{
  if (((*(uint64_t (**)(vision::mod::ImageDescriptorProcessorEspresso *))(*(void *)this + 136))(this) & 2) == 0) {
    return 3691;
  }

  return vision::mod::ImageDescriptorProcessorEspresso::computeDescriptorForImage_XYZA8888(this, a2, a3);
}

void vision::mod::ImageDescriptorProcessorEspresso::~ImageDescriptorProcessorEspresso(vision::mod::ImageDescriptorProcessorEspresso *this)
{
  *(void *)this = &unk_1EF752CE0;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }

  JUMPOUT(0x1A62562C0);
}

{
  std::__shared_weak_count *v1;

  *(void *)this = &unk_1EF752CE0;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptorProcessorEspresso::private_t>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptorProcessorEspresso::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753AB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptorProcessorEspresso::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753AB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t vision::mod::ImageDescriptorProcessorEspresso::ImageDescriptorProcessorEspresso(uint64_t a1, unsigned __int8 *a2, const char *a3, char *a4, int a5, int a6)
{
  *(void *)a1 = &unk_1EF752CE0;
  *(unsigned char *)(a1 + 8) = 1;
  *(unsigned char *)(a1 + 39) = 0;
  *(void *)(a1 + 40) = 0xBF80000000000000;
  *(void *)(a1 + 48) = 0;
  int v12 = (void ***)(a1 + 48);
  *(void *)(a1 + 56) = 0;
  uint64_t v13 = (char *)operator new(0x40uLL);
  *((void *)v13 + 1) = 0;
  *((void *)v13 + 2) = 0;
  *(void *)uint64_t v13 = &unk_1EF753AB8;
  *(_OWORD *)(v13 + 40) = 0u;
  *(_OWORD *)(v13 + 24) = 0u;
  *((_DWORD *)v13 + 8) = 1;
  *(void *)(a1 + 48) = v13 + 24;
  *(void *)(a1 + 56) = v13;
  *((_DWORD *)v13 + 11) = a5;
  *((_DWORD *)v13 + 12) = a6;
  if (a5 == 1) {
    int v14 = 20000;
  }
  else {
    int v14 = 0;
  }
  if (a5 == 2) {
    int v14 = 1;
  }
  float v15 = (void *)*((void *)a2 + 2);
  *(_DWORD *)(a1 + 12) = 998277249;
  if (a5 == 6) {
    unsigned int v16 = 6;
  }
  else {
    unsigned int v16 = v14;
  }
  unsigned int v17 = a5 - 5;
  *((void *)v13 + 7) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  if (a5 == 5) {
    uint64_t v18 = 5;
  }
  else {
    uint64_t v18 = v16;
  }
  unsigned int v19 = a6 == 2;
  if (a6 == 3) {
    unsigned int v19 = 2;
  }
  if (v17 >= 2) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 4;
  }
  *(_DWORD *)(a1 + 35) = 0;
  *(void *)(a1 + 20) = 0;
  *(void *)(a1 + 28) = 0;
  objc_storeStrong((id *)v13 + 7, v15);
  uint64_t v22 = *(void **)(*(void *)(a1 + 48) + 32);
  if (!v22)
  {
    uint64_t v23 = [objc_alloc(MEMORY[0x1E4F611F0]) initWithPlatform:v18];
    unsigned int v24 = (*v12)[4];
    (*v12)[4] = (void *)v23;

    uint64_t v22 = (*v12)[4];
  }
  LODWORD(v21) = 4.0;
  objc_msgSend(v22, "set_priority:low_priority_max_ms_per_command_buffer:gpu_priority:", *a2, *((unsigned int *)a2 + 2), v21);
  if (a4)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, a4);
    if ((v38 & 0x80u) == 0) {
      unint64_t v25 = v38;
    }
    else {
      unint64_t v25 = (unint64_t)__p[1];
    }
    if ((char)v38 < 0)
    {
      operator delete(__p[0]);
      if (v25) {
        goto LABEL_25;
      }
    }
    else if (v25)
    {
LABEL_25:
      uint64_t v26 = [objc_alloc(MEMORY[0x1E4F61200]) initWithJSFile:a3 binSerializerId:a4 context:(*v12)[4] computePath:v20];
      goto LABEL_28;
    }
  }
  uint64_t v26 = [objc_alloc(MEMORY[0x1E4F61200]) initWithJSFile:a3 context:(*v12)[4] computePath:v20];
LABEL_28:
  uint64_t v27 = **v12;
  **int v12 = (void *)v26;

  int v28 = **v12;
  if (!v28)
  {
    syslog(5, "ERROR: Could not load network from %s", a3);
    exception = __cxa_allocate_exception(8uLL);
    void *exception = 3701;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if (!objc_msgSend(v28, "layers_size"))
  {
    syslog(5, "ERROR: The network layer size is zero");
    float v36 = __cxa_allocate_exception(8uLL);
    *float v36 = 3708;
    __cxa_throw(v36, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t layer_first_destination_blob_shape = espresso_vision_last_layer_first_destination_blob_shape();
  *((_DWORD *)*v12 + 3) = v30 * layer_first_destination_blob_shape * HIDWORD(layer_first_destination_blob_shape);
  espresso_vision_first_layer_first_source_blob_shape();
  uint64_t v31 = *(void *)(a1 + 48);
  *(_DWORD *)(v31 + 16) = v32;
  *(_DWORD *)(v31 + 8) = v33;

  return a1;
}

void sub_1A3F35578(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 56);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  vision::mod::ImageDescriptorProcessorEspresso::Options::~Options(v1);
  _Unwind_Resume(a1);
}

void sub_1A3F35660(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3572C(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A3F358C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F35D54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42)
{
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__14652(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__14653(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void *std::vector<_Geometry2D_point2D_>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<long long>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1A3F35EC4(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 __Block_byref_object_copy__37(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v3;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

void sub_1A3F36EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,void *a39,void *a40,char a41)
{
  if (v41) {
    operator delete(v41);
  }
  vision::mod::Face3D::~Face3D((vision::mod::Face3D *)&a41);

  _Unwind_Resume(a1);
}

void sub_1A3F37390(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F375A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F376B8(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3F376CC(_Unwind_Exception *a1)
{
}

void sub_1A3F37784(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3F377A4(_Unwind_Exception *a1)
{
}

void sub_1A3F37A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F37D4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F37E40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3804C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_1A3F38400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A3F386CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F388A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F38A18(_Unwind_Exception *a1)
{
  uint64_t v6 = v5;

  _Unwind_Resume(a1);
}

uint64_t ___ZL11getVNBundlev_block_invoke()
{
  getVNBundle(void)::bundle = [MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.VN"];

  return MEMORY[0x1F41817F8]();
}

void sub_1A3F38CA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F38E08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3909C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3915C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3947C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F39598(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F39714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3984C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F39B00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F39D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
}

void sub_1A3F39E8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3A02C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3A118(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3A570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3A6AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3A8D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3AAD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3AFE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _Unwind_Exception *exception_object, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3B17C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

#error "1A3F3B5D4: call analysis failed (funcsize=25)"

void sub_1A3F3B5FC()
{
}

void sub_1A3F3B608()
{
}

void sub_1A3F3B614()
{
}

BOOL _validateVNElementType(unint64_t a1, void *a2)
{
  unint64_t v2 = a1 - 1;
  if (a1 - 1 >= 2 && a2 != 0)
  {
    uint64_t v5 = NSString;
    uint64_t v6 = VNElementTypeToString(a1);
    id v7 = [v5 stringWithFormat:@"invalid element type of %@", v6];

    *a2 = +[VNError errorForInternalErrorWithLocalizedDescription:v7];
  }
  return v2 < 2;
}

void sub_1A3F3B6BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3B71C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3B840(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3B99C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3BA24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3BB00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3BCC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3BF4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3C0F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3C1CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3C298(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3C3E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3C5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose((const void *)(v24 - 96), 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__15250(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__15251(uint64_t a1)
{
}

void sub_1A3F3C6FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3C8B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3C980(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3CAD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3CD88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3CF5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3D088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3D204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3D2A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F3D310(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL CCRectLowLevel(uint64_t a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, float a10, float a11)
{
  unsigned __int32 v10 = MEMORY[0x1F4188790](a1).n128_u32[0];
  uint64_t v455 = v11;
  v510 = v13;
  v511 = v12;
  int v15 = v14;
  unsigned int v17 = v16;
  float v19 = v18;
  unsigned int v465 = v20;
  float v488 = v21;
  float v23 = v22;
  float v25 = v24;
  float v27 = v26;
  int v29 = v28;
  int v31 = v30;
  unsigned __int32 v32 = v10;
  float32x4_t v34 = v33;
  *(void *)&v566[4772] = *MEMORY[0x1E4F143B8];
  unint64_t v557 = 0;
  unint64_t v493 = (float *)malloc_type_malloc(0x1680uLL, 0x100004052888210uLL);
  v517 = malloc_type_malloc(0x4000uLL, 0x1020040166361F2uLL);
  uint64_t v35 = (uint64_t)malloc_type_malloc(0x800uLL, 0x100004000313F17uLL);
  v514 = (vDSP_Length *)malloc_type_malloc(8 * (v15 + 256), 0x100004000313F17uLL);
  int v462 = v15;
  v512 = (char *)malloc_type_malloc(32 * v15, 0x100004052888210uLL);
  v513 = malloc_type_malloc(8 * (v15 + 256), 0x80040B8603338uLL);
  v516 = malloc_type_malloc(4 * (v15 + 256), 0x100004052888210uLL);
  v515 = (float *)malloc_type_malloc(0x400uLL, 0x100004052888210uLL);
  if (CCRectLowLevel_bFirstTime == 1)
  {
    PerMeshForFFTSIZE = (float *)CCRectLowLevel_retainedPerMeshPtr;
  }
  else
  {
    if (v17) {
      PerMeshForFFTSIZE = 0;
    }
    else {
      PerMeshForFFTSIZE = createPerMeshForFFTSIZE();
    }
    CCRectLowLevel_retainedPerMeshPtr = (uint64_t)PerMeshForFFTSIZE;
    CCRectLowLevel_bFirstTime = 1;
  }
  if (v17) {
    unsigned __int8 v38 = v17;
  }
  else {
    unsigned __int8 v38 = PerMeshForFFTSIZE;
  }
  v482 = v38;
  if (v19 != -1.0)
  {
    *(float *)v36.i32 = v19 * v19;
    float32x4_t v507 = (float32x4_t)vdupq_lane_s32(v36, 0);
    int32x4_t v39 = (int32x4_t)xmmword_1A410C140;
    unint64_t v40 = 0x3FFFFFFFFFFFFA60uLL;
    float32x4_t v499 = (float32x4_t)vdupq_n_s32(0x44B40000u);
    float32x4_t v501 = (float32x4_t)vdupq_n_s32(0x40490FDBu);
    do
    {
      *(int32x4_t *)v542 = v39;
      float32x4_t v41 = vdivq_f32(vmulq_f32(vcvtq_f32_s32(v39), v501), v499);
      *(float64x2_t *)v538 = vcvtq_f64_f32(*(float32x2_t *)v41.f32);
      *(float64x2_t *)v529 = vcvt_hight_f64_f32(v41);
      __double2 v42 = __sincos_stret(*(double *)&v529[1]);
      __double2 v44 = __sincos_stret(*(double *)v529);
      *(double *)&long long v43 = v44.__sinval;
      *((void *)&v43 + 1) = *(void *)&v42.__sinval;
      *(_OWORD *)v524 = v43;
      __double2 v45 = __sincos_stret(*(double *)&v538[1]);
      __double2 v48 = __sincos_stret(*(double *)v538);
      v47.f64[0] = v48.__cosval;
      v46.f64[0] = v48.__sinval;
      v46.f64[1] = v45.__sinval;
      v49.f64[0] = v44.__cosval;
      v49.f64[1] = v42.__cosval;
      float32x4_t v50 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v46), *(float64x2_t *)v524);
      v47.f64[1] = v45.__cosval;
      float32x4_t v51 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v47), v49);
      float32x4_t v52 = vmulq_f32(v50, v50);
      float32x4_t v53 = vmulq_f32(v51, v51);
      *(float32x4_t *)((char *)&sinScaleTab + v40 * 4 + 5760) = vsqrtq_f32(vmlaq_f32(v53, v52, v507));
      *(float32x4_t *)&cosScaleTab[v40 + 1440] = vsqrtq_f32(vmlaq_f32(v52, v53, v507));
      v53.i64[0] = 0x400000004;
      v53.i64[1] = 0x400000004;
      int32x4_t v39 = vaddq_s32(*(int32x4_t *)v542, (int32x4_t)v53);
      v40 += 4;
    }
    while (v40 * 4);
  }
  float32x4_t v54 = (char *)malloc_type_malloc(0x20000uLL, 0x1000040BDFB0063uLL);
  float32x4_t v55 = (char *)malloc_type_malloc(0x20000uLL, 0x1000040BDFB0063uLL);
  float v56 = (char *)malloc_type_malloc(0x10000uLL, 0x4FEABBE8uLL);
  v543 = v54;
  v539 = v55;
  cannyEdgeWithGradientOutput(*v34, v56, v54, v55, 0.5, 0.9);
  thinBin((long long *)v56);
  for (uint64_t i = 257; i != 511; ++i)
  {
    if (v56[i]) {
      trimChain((uint64_t)v56, i - 256, 1, 6);
    }
  }
  for (uint64_t j = 0; j != 254; ++j)
  {
    if (v56[j + 65025]) {
      trimChain((uint64_t)v56, j + 1, 254, 2);
    }
  }
  int v59 = 1;
  uint64_t v60 = 257;
  do
  {
    if (v56[v60]) {
      trimChain((uint64_t)v56, 1, v59, 0);
    }
    v60 += 256;
    ++v59;
  }
  while (v59 != 255);
  int v61 = 1;
  uint64_t v62 = 510;
  do
  {
    if (v56[v62]) {
      trimChain((uint64_t)v56, 254, v61, 4);
    }
    v62 += 256;
    ++v61;
  }
  while (v61 != 255);
  for (uint64_t k = 0; k != 0x10000; k += 8)
  {
    int8x8_t v64 = vceq_s8(*(int8x8_t *)&v56[k], (int8x8_t)0x303030303030303);
    if (v64.i8[0]) {
      v56[k] = 0;
    }
    if (v64.i8[1]) {
      v56[k + 1] = 0;
    }
    if (v64.i8[2]) {
      v56[k + 2] = 0;
    }
    if (v64.i8[3]) {
      v56[k + 3] = 0;
    }
    if (v64.i8[4]) {
      v56[k + 4] = 0;
    }
    if (v64.i8[5]) {
      v56[k + 5] = 0;
    }
    if (v64.i8[6]) {
      v56[k + 6] = 0;
    }
    if (v64.i8[7]) {
      v56[k + 7] = 0;
    }
  }
  v523 = v56;
  float v472 = v23;
  uint64_t v487 = v35;
  unsigned int v65 = malloc_type_malloc(0x30uLL, 0x109004023CC7A6AuLL);
  *unsigned int v65 = 0x400000000000;
  v65[1] = 0x10000000100;
  v65[2] = malloc_type_malloc(0x4000uLL, 0x30474B5AuLL);
  void v65[3] = malloc_type_malloc(0x4000uLL, 0x50B77A67uLL);
  v65[4] = malloc_type_malloc(0x10000uLL, 0x100004052888210uLL);
  uint64_t v66 = 0;
  LODWORD(v35) = 0;
  int v67 = 0;
  v534 = malloc_type_malloc(0x400uLL, 0x100004052888210uLL);
  v65[5] = v534;
  int v68 = *((_DWORD *)v65 + 1);
  uint64_t v69 = v65[2];
  uint64_t v70 = v65[3];
  uint64_t v71 = v65[4];
  uint64_t v476 = (void **)v65;
  v65[1] = 0x10000000100;
  unsigned int v72 = 0;
  do
  {
    int v73 = 0;
    uint64_t v35 = (int)v35;
    do
    {
      if (*((unsigned char *)v523 + v35))
      {
        *(unsigned char *)(v69 + v72) = v73;
        *(unsigned char *)(v70 + v72) = v66;
        float v74 = atan2f((float)*(__int16 *)&v539[2 * v35], (float)*(__int16 *)&v543[2 * v35]);
        *(float *)(v71 + 4 * v72++) = (float)(fmodf(3.1416 - v74, 3.1416) * 180.0) / 3.1416;
        if (v72 == v68)
        {
          *(_DWORD *)unsigned int v65 = v68;
          goto LABEL_59;
        }
      }
      ++v35;
      ++v73;
    }
    while (v73 != 256);
    if (v67 == v72) {
      int v75 = -1;
    }
    else {
      int v75 = v67;
    }
    v534[v66++] = v75;
    int v67 = v72;
  }
  while (v66 != 256);
  *(_DWORD *)unsigned int v65 = v72;
  if (!v543) {
    goto LABEL_60;
  }
LABEL_59:
  free(v543);
LABEL_60:
  if (v539) {
    free(v539);
  }
  vDSP_Length __N = 0;
  unint64_t v76 = malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
  unint64_t v77 = (DSPComplex *)malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
  unint64_t v79 = v77;
  uint64_t v80 = 0;
  do
  {
    LOBYTE(v78) = *((unsigned char *)v523 + v80);
    float v78 = (float)LODWORD(v78) * 255.0;
    *(&v77->real + v80++) = v78;
  }
  while (v80 != 0x10000);
  uint64_t v81 = malloc_type_malloc(0x10000uLL, 0xF95E39ECuLL);
  long long v82 = v523[3];
  long long v84 = *v523;
  long long v83 = v523[1];
  v81[2] = v523[2];
  v81[3] = v82;
  *uint64_t v81 = v84;
  v81[1] = v83;
  long long v85 = v523[7];
  long long v87 = v523[4];
  long long v86 = v523[5];
  v81[6] = v523[6];
  v81[7] = v85;
  v81[4] = v87;
  v81[5] = v86;
  long long v88 = v523[11];
  long long v90 = v523[8];
  long long v89 = v523[9];
  v81[10] = v523[10];
  v81[11] = v88;
  v81[8] = v90;
  v81[9] = v89;
  long long v91 = v523[15];
  long long v93 = v523[12];
  long long v92 = v523[13];
  v81[14] = v523[14];
  v81[15] = v91;
  v81[12] = v93;
  v81[13] = v92;
  uint64_t v94 = v523 + 16;
  float v95 = v81 + 16;
  for (int m = 1; m != 255; ++m)
  {
    uint64_t v97 = 0;
    *(unsigned char *)float v95 = *(unsigned char *)v94;
    int v98 = (8 * (*((unsigned char *)v94 - 255) & 1)) & 0xC8 | (16 * (*((unsigned char *)v94 + 1) & 1)) & 0xD8 | (32
                                                                                              * (*((unsigned char *)v94 + 257) & 1)) | *(unsigned char *)(v94 - 16) & 1 | (2 * (*(unsigned char *)v94 & 1)) & 0xFB | (4 * (v94[16] & 1));
    do
    {
      unsigned int v99 = ((*((unsigned char *)v94 + v97 + 2) & 1) << 7) | ((*((unsigned char *)v94 + v97 - 254) & 1) << 6) | ((*((unsigned char *)v94
                                                                                                  + v97
                                                                                                  + 258) & 1) << 8) | v98;
      *((unsigned char *)v95 + v97 + 1) = dilate[v99];
      int v98 = v99 >> 3;
      ++v97;
    }
    while (v97 != 254);
    unint64_t v100 = (char *)v95 + v97;
    uint64_t v101 = (char *)v94 + v97;
    float v95 = (_OWORD *)((char *)v95 + v97 + 2);
    v100[1] = v101[1];
    uint64_t v94 = v101 + 2;
  }
  long long v102 = *v94;
  long long v103 = v94[1];
  long long v104 = v94[3];
  v95[2] = v94[2];
  v95[3] = v104;
  *float v95 = v102;
  v95[1] = v103;
  long long v105 = v94[4];
  long long v106 = v94[5];
  long long v107 = v94[7];
  v95[6] = v94[6];
  v95[7] = v107;
  v95[4] = v105;
  void v95[5] = v106;
  long long v108 = v94[8];
  long long v109 = v94[9];
  long long v110 = v94[11];
  v95[10] = v94[10];
  v95[11] = v110;
  v95[8] = v108;
  v95[9] = v109;
  long long v111 = v94[12];
  long long v112 = v94[13];
  long long v113 = v94[15];
  v95[14] = v94[14];
  v95[15] = v113;
  v95[12] = v111;
  v95[13] = v112;
  memcpy(v523, v81, 0x10000uLL);
  free(v81);
  fftGrayMag(v79, v76, v482);
  free(v79);
  int v555 = 0;
  fftProject((uint64_t)v76, v493, (float *)&v555, 0.0625);
  free(v76);
  unint64_t v114 = 0x3FFFFFFFFFFFFA60uLL;
  do
  {
    *(float32x4_t *)&v493[v114 + 1440] = vmulq_f32(*(float32x4_t *)((char *)&sinScaleTab + v114 * 4 + 5760), *(float32x4_t *)&v493[v114 + 1440]);
    v114 += 4;
  }
  while (v114 * 4);
  normalizeArray(v493, 0x5A0u);
  double v115 = (float *)malloc_type_malloc(0x1680uLL, 0x100004052888210uLL);
  float v116 = (float *)malloc_type_malloc(0x1680uLL, 0x100004052888210uLL);
  boxFilter(v493, 0x5A0u, 3u, 2, v115);
  boxFilter(v493, 0x5A0u, 0x13u, 4, v116);
  normalizeArray(v115, 0x5A0u);
  normalizeArray(v116, 0x5A0u);
  unsigned int v554 = 0;
  float v535 = 90.0 - v488;
  float v117 = 0.3;
  while (1)
  {
    float v530 = v117;
    findPeaks(v116, 1440, v564, &v554, 0.0, 0.003);
    unint64_t v118 = v554;
    if (v554 >= 2) {
      break;
    }
LABEL_72:
    float v117 = v530 * 0.8;
    if ((float)(v530 * 0.8) < 0.1)
    {
      BOOL v364 = v118 == 0;
      unint64_t v132 = (void *)v487;
      uint64_t v133 = v523;
      unsigned __int8 v134 = v493;
      if (v118)
      {
        char v131 = 1;
        goto LABEL_89;
      }
      goto LABEL_96;
    }
  }
  uint64_t v119 = 0;
  uint64_t v120 = (float *)v566;
  uint64_t v121 = 1;
  while (1)
  {
    __float2 v122 = __sincosf_stret((float)(v564[6 * v119 + 1] * 0.125) * 0.017453);
    float v123 = atan2f(v122.__sinval * v19, v122.__cosval);
    if (++v119 < v118) {
      break;
    }
LABEL_85:
    ++v121;
    v120 += 6;
    if (v119 == v118 - 1) {
      goto LABEL_72;
    }
  }
  float v124 = v123 * 57.296;
  unint64_t v125 = v118;
  float v126 = v120;
  while (1)
  {
    __float2 v127 = __sincosf_stret((float)(*v126 * 0.125) * 0.017453);
    float v128 = atan2f(v127.__sinval * v19, v127.__cosval) * 57.296;
    if (v124 <= v128)
    {
      float v130 = v128 - v124;
      float v129 = v130 >= 90.0 ? 180.0 - v130 : -v130;
    }
    else
    {
      float v129 = v124 - v128;
      if (v129 >= 90.0) {
        float v129 = v129 + -180.0;
      }
    }
    if (fabsf(v129) >= v535) {
      break;
    }
    v126 += 6;
    if (v121 == --v125) {
      goto LABEL_85;
    }
  }
  BOOL v364 = v118 == 0;
  if (v118)
  {
    char v131 = 0;
    unint64_t v132 = (void *)v487;
    uint64_t v133 = v523;
    unsigned __int8 v134 = v493;
LABEL_89:
    unsigned int v135 = (float *)&v565;
    float v136 = 1.0;
    unint64_t v137 = v118;
    do
    {
      unsigned int v138 = (int)(float)(*v135 + 0.5) % 0x5A0u;
      if (v116[(int)(float)(*(v135 - 1) + 0.5) % 0x5A0u] < v136) {
        float v136 = v116[(int)(float)(*(v135 - 1) + 0.5) % 0x5A0u];
      }
      if (v116[v138] < v136) {
        float v136 = v116[v138];
      }
      v135 += 6;
      --v137;
    }
    while (v137);
    if (v131)
    {
LABEL_96:
      free(v115);
      free(v116);
      free(v133);
      free(v517);
      BOOL v139 = 0;
      unsigned __int8 v140 = v476;
      if (v132) {
        goto LABEL_445;
      }
      goto LABEL_446;
    }
    unsigned int v553 = 0;
    findPeaks(v115, 1440, v563, &v553, v136, 0.0);
    unsigned int v141 = 0;
    if (!v364)
    {
      uint64_t v142 = 0;
      LODWORD(v143) = 0;
      unsigned int v141 = 0;
      unint64_t v144 = v553;
      int v145 = -1;
      while (1)
      {
        uint64_t v146 = &v564[6 * v142];
        float v148 = v146[2];
        float v147 = v146[3];
        float v149 = v115[(int)(float)(v148 + 0.5) % 0x5A0u];
        if (v142) {
          unsigned int v150 = 0;
        }
        else {
          unsigned int v150 = v143;
        }
        if (v148 <= v147) {
          float v151 = v148;
        }
        else {
          float v151 = 0.0;
        }
        if (v148 <= v147) {
          unint64_t v152 = v143;
        }
        else {
          unint64_t v152 = v150;
        }
        uint64_t v153 = &v563[6 * v152 + 1];
        int v154 = v152 + 1;
        do
        {
          unint64_t v143 = v152;
          int v155 = v154;
          float v156 = *v153;
          v153 += 6;
          float v157 = v156;
          ++v152;
          ++v154;
        }
        while (v156 < v151 && v143 < v144);
        if (v149 >= v115[(int)(float)(v147 + 0.5) % 0x5A0u]) {
          float v149 = v115[(int)(float)(v147 + 0.5) % 0x5A0u];
        }
        if (v148 > v147) {
          int v145 = v142;
        }
        if (v144 == v143) {
          break;
        }
        if (v157 <= v147)
        {
          while (1)
          {
            if (v115[v157] >= v149) {
              v560[v141++] = v155 - 1;
            }
            if (v144 == v155) {
              break;
            }
            float v157 = v563[6 * v155++ + 1];
            if (v157 > v147)
            {
              LODWORD(v143) = v155 - 1;
              goto LABEL_128;
            }
          }
          LODWORD(v143) = v144;
        }
LABEL_128:
        if (++v142 == v118) {
          goto LABEL_131;
        }
      }
      LODWORD(v143) = v144;
LABEL_131:
      if (v145 != -1)
      {
        uint64_t v159 = 0;
        std::vector<unsigned int>::size_type v160 = &v564[6 * v145];
        float v161 = v160[2];
        unint64_t v162 = &v563[6 * v143 + 1];
        do
        {
          unint64_t v163 = v143 + v159;
          float v164 = *v162;
          v162 += 6;
          float v165 = v164;
          ++v159;
        }
        while (v164 < v161 && v163 < v144);
        float v167 = v115[(int)(float)(v161 + 0.5) % 0x5A0u] >= v115[(int)(float)(v160[3] + 0.5) % 0x5A0u]
             ? v115[(int)(float)(v160[3] + 0.5) % 0x5A0u]
             : v115[(int)(float)(v161 + 0.5) % 0x5A0u];
        if (v163 < v144 && v165 < 1440.0)
        {
          int v168 = v143 + v159;
          do
          {
            if (v115[v165] >= v167) {
              v560[v141++] = v168 - 1;
            }
            if (v144 == v168) {
              break;
            }
            float v165 = v563[6 * v168++ + 1];
          }
          while (v165 < 1440.0);
        }
      }
      if ((int)v141 > 0)
      {
        size_t v169 = v141;
        uint64_t v170 = v560;
        uint64_t v171 = v561;
        uint64_t v172 = v141;
        do
        {
          int v173 = *v170++;
          unsigned int v174 = &v563[6 * v173];
          *(_OWORD *)uint64_t v171 = *(_OWORD *)v174;
          v171[2] = *((void *)v174 + 2);
          v171 += 3;
          --v172;
        }
        while (v172);
        goto LABEL_153;
      }
    }
  }
  else
  {
    unsigned int v553 = 0;
    findPeaks(v115, 1440, v563, &v553, 1.0, 0.0);
    unsigned int v141 = 0;
    unsigned __int8 v134 = v493;
  }
  size_t v169 = v141;
LABEL_153:
  free(v134);
  free(v115);
  free(v116);
  uint64_t v459 = (char *)malloc_type_calloc(v169 * (unint64_t)v169, 1uLL, 0x7E06169FuLL);
  unsigned int v525 = v141;
  if (v141 >= 2)
  {
    size_t v531 = v169 + 1;
    unint64_t v175 = v459;
    unsigned int v176 = v459 + 1;
    float v177 = (float *)&v562;
    uint64_t v178 = 1;
    do
    {
      __float2 v179 = __sincosf_stret((float)(*((float *)&v561[3 * v178 - 2] - 1) * 0.125) * 0.017453);
      uint64_t v180 = 0;
      float v181 = atan2f(v179.__sinval * v19, v179.__cosval) * 57.296;
      char v182 = v177;
      int v183 = v175;
      do
      {
        __float2 v184 = __sincosf_stret((float)(*v182 * 0.125) * 0.017453);
        float v185 = atan2f(v184.__sinval * v19, v184.__cosval) * 57.296;
        if (v181 <= v185)
        {
          float v187 = v185 - v181;
          if (v187 >= 90.0) {
            float v186 = 180.0 - v187;
          }
          else {
            float v186 = -v187;
          }
        }
        else
        {
          float v186 = v181 - v185;
          if (v186 >= 90.0) {
            float v186 = v186 + -180.0;
          }
        }
        if (fabsf(v186) >= v535)
        {
          v176[v180] = 1;
          v183[v169] = 1;
        }
        ++v180;
        v183 += v169;
        v182 += 6;
      }
      while (v178 + v180 < v169);
      ++v178;
      v175 += v531;
      v176 += v531;
      v177 += 6;
    }
    while (v178 != v169);
  }
  unint64_t v188 = malloc_type_calloc(4uLL, v169, 0x525D124FuLL);
  float v189 = malloc_type_calloc(4uLL, v169, 0x31F2396EuLL);
  float v190 = malloc_type_calloc(4uLL, v169, 0xF28688B8uLL);
  uint64_t v467 = v190;
  int v460 = v189;
  v461 = v188;
  if (!v525)
  {
    float v500 = (unsigned int *)malloc_type_calloc(0x50uLL, v169, 0xA1C02EEBuLL);
    v454 = (char *)malloc_type_calloc(0, 1uLL, 0xE0A881D3uLL);
    uint64_t v541 = 0;
    unsigned int v468 = 0;
    unint64_t v132 = (void *)v487;
    int v292 = v523;
    unint64_t v195 = v476;
    goto LABEL_434;
  }
  uint64_t v191 = 0;
  uint64_t v192 = (unsigned __int8 *)v459;
  unint64_t v193 = v459;
  float v194 = v472;
  unint64_t v195 = v476;
  do
  {
    uint64_t v196 = 0;
    float32x2_t v197 = v192;
    do
    {
      v188[v191] += v193[v196];
      int v198 = v189[v191] + *v197;
      v189[v191] = v198;
      ++v196;
      v197 += v169;
    }
    while (v169 != v196);
    v190[v191] = v198 + v188[v191];
    ++v191;
    ++v192;
    v193 += v169;
  }
  while (v191 != v169);
  float v500 = (unsigned int *)malloc_type_calloc(0x50uLL, v169, 0xA1C02EEBuLL);
  int v199 = v467;
  uint64_t v200 = 0;
  unsigned int v468 = 0;
  unint64_t v201 = v459;
  unint64_t v202 = v459;
  float v480 = v19;
  unsigned __int32 v481 = v32;
  do
  {
    if (!v199[v200]) {
      goto LABEL_254;
    }
    float v203 = *((float *)&v561[3 * v200] + 1) * 0.125;
    __float2 v204 = __sincosf_stret((float)(v203 * 3.1416) / 180.0);
    size_t v205 = *(unsigned int *)v195;
    uint64_t v206 = (float *)v195[4];
    unint64_t v207 = malloc_type_malloc(v205, 0xCDFC7244uLL);
    int v208 = (unsigned __int8 *)malloc_type_malloc(v205, 0x16BC031DuLL);
    uint64_t v209 = v208;
    float v210 = v203 + -5.0;
    float v544 = v203;
    float v211 = v203 + 5.0;
    uint64_t v494 = v200;
    if (v210 >= 0.0)
    {
      if (v211 < 180.0)
      {
        float cosval = v204.__cosval;
        if (!v205) {
          goto LABEL_200;
        }
        uint64_t v214 = 0;
        unsigned int v215 = 0;
        do
        {
          float v216 = v206[v214];
          if (v216 >= v210 && v216 <= v211)
          {
            v207[v215] = *((unsigned char *)v195[2] + v214);
            v208[v215++] = *((unsigned char *)v195[3] + v214);
          }
          ++v214;
        }
        while (v205 != v214);
        goto LABEL_201;
      }
      float v218 = v211 + 180.0;
      float v219 = v210;
      float v220 = fmodf(v218, 180.0);
      float v212 = v219;
      float v211 = v220;
    }
    else
    {
      float v212 = fmodf(v210 + 180.0, 180.0);
    }
    float cosval = v204.__cosval;
    if (!v205)
    {
LABEL_200:
      unsigned int v215 = 0;
      goto LABEL_201;
    }
    uint64_t v221 = 0;
    unsigned int v215 = 0;
    do
    {
      float v222 = v206[v221];
      BOOL v223 = v222 < v212 || v222 > 180.0;
      if (!v223 || (v222 >= 0.0 ? (BOOL v224 = v222 > v211) : (BOOL v224 = 1), !v224))
      {
        v207[v215] = *((unsigned char *)v195[2] + v221);
        v209[v215++] = *((unsigned char *)v195[3] + v221);
      }
      ++v221;
    }
    while (v205 != v221);
LABEL_201:
    v526 = v209;
    float v508 = fabsf(cosval);
    float sinval = v204.__sinval;
    float v502 = fabsf(v204.__sinval);
    int v226 = (float *)malloc_type_calloc(0x800uLL, 1uLL, 0x2902583DuLL);
    uint64_t v227 = v226 + 128;
    v536 = (float *)malloc_type_malloc(0x800uLL, 0x100004052888210uLL);
    v532 = (float *)malloc_type_malloc(0x600uLL, 0x1000040504FFAC1uLL);
    LODWORD(v550) = 0;
    float v559 = 0.0;
    int v228 = (float *)&v500[20 * v468];
    v228[1] = v544;
    uint64_t v229 = v228 + 2;
    float v230 = v228 + 3;
    uint64_t v489 = v202;
    v483 = v207;
    if (v508 <= v502)
    {
      *uint64_t v229 = v204.__cosval;
      float *v230 = -v204.__sinval;
      float v545 = v204.__cosval / v204.__sinval;
      if (v215)
      {
        uint64_t v239 = v215;
        unint64_t v240 = v526;
        unint64_t v241 = v207;
        do
        {
          unsigned int v242 = *v240++;
          float v243 = (float)v242;
          unsigned int v244 = *v241++;
          float v245 = modff((float)(v243 + (float)((float)-(float)(v204.__cosval / v204.__sinval) * (float)v244))+ (float)(v545 * 128.0), &v559);
          unsigned int v246 = (int)v559;
          if ((int)v559 <= 0xFF)
          {
            v227[v246] = (float)(1.0 - v245) + v227[v246];
            v227[v246 + 1] = v245 + v227[v246 + 1];
          }
          --v239;
        }
        while (v239);
        goto LABEL_213;
      }
    }
    else
    {
      *uint64_t v229 = -v204.__cosval;
      float *v230 = v204.__sinval;
      float v545 = v204.__sinval / v204.__cosval;
      if (v215)
      {
        uint64_t v231 = v215;
        unsigned int v232 = v207;
        float v233 = v526;
        do
        {
          unsigned int v234 = *v232++;
          float v235 = (float)v234;
          unsigned int v236 = *v233++;
          float v237 = modff((float)(v235 + (float)((float)-(float)(v204.__sinval / v204.__cosval) * (float)v236))+ (float)(v545 * 128.0), &v559);
          unsigned int v238 = (int)v559;
          if ((int)v559 <= 0xFF)
          {
            v227[v238] = (float)(1.0 - v237) + v227[v238];
            v227[v238 + 1] = v237 + v227[v238 + 1];
          }
          --v231;
        }
        while (v231);
LABEL_213:
        int v247 = v195;
        float sinval = v204.__sinval;
        goto LABEL_215;
      }
    }
    int v247 = v195;
LABEL_215:
    int v248 = &v500[20 * v468];
    boxFilter(v226, 0x200u, 3u, 3, v536);
    normalizeArray(v536, 0x200u);
    findPeaks(v536, 512, v532, &v550, 0.1, 0.0);
    uint64_t v249 = (int *)malloc_type_malloc(0x100uLL, 0x100004052888210uLL);
    int v250 = (float *)malloc_type_malloc(0x100uLL, 0x100004052888210uLL);
    float v558 = 0.0;
    uint64_t v251 = v550;
    if (v550)
    {
      __CLPK_integer __n = &v500[20 * v468];
      int v252 = 0;
      float v546 = -v545;
      int v253 = v532 + 1;
      float v254 = v204.__cosval;
      if (v508 <= v502) {
        float v254 = sinval;
      }
      float v540 = v254;
      int v255 = -1;
      int v256 = -1;
      *(float *)&int v257 = -1.0e10;
      *(float *)&int v258 = -1.0e10;
      do
      {
        float v259 = *v253;
        if (*v253 >= 128.0 && v259 <= 384.0)
        {
          float v261 = v25;
          float v262 = *(float *)&v257;
          int v263 = v29;
          float v264 = v27;
          float v265 = v261;
          float v266 = *(float *)&v258;
          float v267 = modff(*v253, &v558);
          float v268 = (float)((float)((float)(v226[v558] + (float)(v226[(int)v558 - 1] * (float)(1.0 - v267)))
                               + v226[(int)v558 + 1])
                       + (float)(v226[(int)v558 + 2] * v267))
               / 3.0;
          if (v268 >= 2.0)
          {
            v250[v252] = v268;
            *(float *)&int v258 = v266;
            if (v268 <= v266)
            {
              float v271 = v265;
              if (v268 <= v262) {
                float v268 = v262;
              }
              else {
                int v255 = v252;
              }
              float v27 = v264;
              float v25 = v271;
            }
            else
            {
              if (v266 <= v262) {
                float v270 = v262;
              }
              else {
                float v270 = v266;
              }
              if (v266 > v262) {
                int v255 = v256;
              }
              *(float *)&int v258 = v268;
              float v268 = v270;
              int v256 = v252;
              float v25 = v265;
              float v27 = v264;
            }
            v249[v252++] = (int)(float)(v540 * (float)((float)(v259 + -128.0) + (float)(v546 * 128.0)));
            *(float *)&int v257 = v268;
            int v29 = v263;
            float v19 = v480;
            unsigned __int32 v32 = v481;
          }
          else
          {
            *(float *)&int v258 = v266;
            float v269 = v265;
            float v27 = v264;
            int v29 = v263;
            float v19 = v480;
            unsigned __int32 v32 = v481;
            *(float *)&int v257 = v262;
            float v25 = v269;
          }
        }
        v253 += 6;
        --v251;
      }
      while (v251);
      if (v252 <= 0)
      {
        unsigned int v279 = 0;
        float v194 = v472;
        int v247 = v476;
        uint64_t v200 = v494;
        int v248 = &v500[20 * v468];
      }
      else
      {
        uint64_t v200 = v494;
        float v272 = (float *)&v500[20 * v468];
        v272[4] = (float)*v249;
        v272[8] = *v250;
        int v248 = (unsigned int *)v272;
        *__CLPK_integer __n = 1;
        int v274 = v252 - 1;
        BOOL v273 = v252 == 1;
        float v194 = v472;
        int v247 = v476;
        if (v273) {
          goto LABEL_250;
        }
        float v275 = (float *)&v500[20 * v468];
        v275[5] = (float)v249[v274];
        v275[9] = v250[v274];
        *__CLPK_integer __n = 2;
        uint64_t v276 = 2;
        if (v256 >= 1 && v256 != v274)
        {
          unint64_t v277 = (float *)&v500[20 * v468];
          v277[6] = (float)v249[v256];
          v277[10] = v250[v256];
          *__CLPK_integer __n = 3;
          uint64_t v276 = 3;
        }
        int v248 = &v500[20 * v468];
        if (v255 < 1 || v255 == v274) {
          goto LABEL_250;
        }
        uint64_t v278 = (uint64_t)&v500[20 * v468 + v276];
        *(float *)(v278 + 16) = (float)v249[v255];
        *(float *)(v278 + 32) = v250[v255];
        unsigned int v279 = v276 + 1;
      }
    }
    else
    {
      unsigned int v279 = 0;
      float v194 = v472;
      uint64_t v200 = v494;
    }
    *int v248 = v279;
LABEL_250:
    free(v483);
    free(v526);
    free(v532);
    free(v226);
    free(v536);
    free(v249);
    free(v250);
    if (*v248)
    {
      ++v468;
      int v199 = v467;
      unint64_t v202 = v489;
      unint64_t v195 = v247;
    }
    else
    {
      uint64_t v280 = 0;
      v461[v200] = 0;
      v460[v200] = 0;
      unint64_t v202 = v489;
      unint64_t v281 = v489;
      int v199 = v467;
      v467[v200] = 0;
      unint64_t v195 = v247;
      do
      {
        *unint64_t v281 = 0;
        v201[v280++] = 0;
        v281 += v169;
      }
      while (v169 != v280);
    }
LABEL_254:
    ++v200;
    v201 += v169;
    ++v202;
  }
  while (v200 != v169);
  size_t count = v468 * v468;
  unint64_t v282 = (char *)malloc_type_calloc(count, 1uLL, 0xE0A881D3uLL);
  uint64_t v283 = 0;
  int v284 = 0;
  float32x2_t v285 = v459;
  v454 = v282;
  uint64_t v286 = v282;
  unint64_t v132 = (void *)v487;
  do
  {
    if (v467[v283])
    {
      int v287 = v467;
      int v288 = v285;
      size_t v289 = v169;
      do
      {
        if (*v287++)
        {
          *v286++ = *v288;
          if (*v288) {
            ++v284;
          }
        }
        ++v288;
        --v289;
      }
      while (v289);
    }
    ++v283;
    v285 += v169;
  }
  while (v283 != v169);
  uint64_t v541 = v468;
  if (!v284)
  {
    int v292 = v523;
    goto LABEL_434;
  }
  v537 = (void **)malloc_type_calloc(count, 8uLL, 0x5FEC6413uLL);
  v533 = (char *)malloc_type_calloc(count, 4uLL, 0x9C8A125AuLL);
  float v559 = 0.0;
  uint64_t v550 = 0x424CCCCD00000001;
  float v551 = v19;
  int v552 = 256;
  if (v465 >= 0x20) {
    unsigned int v291 = 32;
  }
  else {
    unsigned int v291 = v465;
  }
  int v292 = v523;
  if (v468 > v291) {
    goto LABEL_433;
  }
  v293 = malloc_type_calloc(v468, 4uLL, 0x100004052888210uLL);
  uint64_t v294 = malloc_type_calloc(v468, 4uLL, 0x100004052888210uLL);
  int v452 = v294;
  uint64_t v453 = v293;
  if (!v468) {
    goto LABEL_432;
  }
  uint64_t v295 = 0;
  float v296 = (unsigned __int8 *)v454;
  unint64_t v297 = v468;
  int v298 = v537;
  v299 = v533;
  do
  {
    int v300 = 0;
    int v301 = 1;
    float v302 = v296;
    uint64_t v303 = v468;
    do
    {
      if (*v302++)
      {
        v300 |= v301;
        ++v294[v295];
      }
      v301 *= 2;
      --v303;
    }
    while (v303);
    *((_DWORD *)v293 + v295++) = v300;
    v296 += v468;
  }
  while (v295 != v468);
  float v558 = 0.0;
  unsigned int v549 = 0;
  uint64_t v458 = 8 * v468;
  if (v468 < 2) {
    goto LABEL_426;
  }
  unint64_t v305 = 0;
  unsigned int v306 = v468 - 1;
  unint64_t v509 = v462;
  unint64_t v307 = (unint64_t)(v500 + 20);
  uint64_t size = 4 * v468;
  unint64_t v308 = &v533[size + 4];
  uint64_t v309 = v458 + 8;
  float v310 = &v537[(unint64_t)v458 / 8 + 1];
  uint64_t v311 = 1;
  v474 = (void *)(v468 - 1);
  do
  {
    if (!*((_DWORD *)v293 + v305))
    {
      ++v305;
      goto LABEL_304;
    }
    unint64_t v312 = v305 * v297;
    float v313 = (char *)&v298[v305 * v297];
    unint64_t v314 = &v299[4 * v305 * v297];
    unsigned int v315 = *(_DWORD *)&v314[4 * v305];
    uint64_t __na = *(void *)&v313[8 * v305];
    if (__na)
    {
      float v558 = *(float *)&v314[4 * v305];
    }
    else if (v315)
    {
      unsigned int v315 = 0;
      uint64_t __na = 0;
      float v558 = 0.0;
    }
    else
    {
      unsigned int v495 = v306;
      v503 = v310;
      singleton((unint64_t)&v500[20 * v305], (uint64_t)&v550, &v558);
      unsigned int v315 = LODWORD(v558);
      if (v558 == 0.0)
      {
        uint64_t __na = 0;
        *(_DWORD *)&v314[4 * v305] = -1;
      }
      else
      {
        size_t __nd = (unint64_t)LODWORD(v558) << 6;
        float v316 = malloc_type_malloc(__nd, 0x1020040E4DCC77DuLL);
        memcpy(v316, &leqBuffer, __nd);
        uint64_t __na = (uint64_t)v316;
        *(void *)&v313[8 * v305] = v316;
        *(_DWORD *)&v314[4 * v305] = v315;
      }
      unint64_t v297 = v468;
      int v298 = v537;
      v299 = v533;
      uint64_t v309 = v458 + 8;
      float v310 = v503;
      unsigned int v306 = v495;
    }
    if (++v305 < v297)
    {
      unint64_t v490 = v305;
      int v317 = &v454[v312];
      v504 = v310;
      unsigned int v318 = v310;
      uint64_t v477 = v308;
      int v319 = (unsigned int *)v308;
      long long v484 = (void *)v307;
      unsigned int v496 = v306;
      unsigned int v320 = v306;
      uint64_t v321 = 4 * v468 + 4;
      while (1)
      {
        if (v317[v311])
        {
          uint64_t v322 = *v318;
          LODWORD(v323) = *v319;
          if (*v318)
          {
            unsigned int v549 = *v319;
            if (v315) {
              goto LABEL_292;
            }
          }
          else if (v323)
          {
            unsigned int v549 = 0;
          }
          else
          {
            singleton(v307, (uint64_t)&v550, &v549);
            uint64_t v323 = v549;
            if (v549)
            {
              uint64_t v322 = malloc_type_malloc((unint64_t)v549 << 6, 0x1020040E4DCC77DuLL);
              uint64_t v321 = 4 * v468 + 4;
              memcpy(v322, &leqBuffer, v323 << 6);
              *unsigned int v318 = v322;
              *int v319 = v323;
              unint64_t v297 = v468;
              int v298 = v537;
              v299 = v533;
              uint64_t v309 = v458 + 8;
              if (v315)
              {
LABEL_292:
                if (v323)
                {
                  generateQuadrilaterals(__na, v315, (uint64_t)v322, v323, (uint64_t)v517, &v559, v194);
                  uint64_t v309 = v458 + 8;
                  v299 = v533;
                  int v298 = v537;
                  unint64_t v297 = v468;
                  if (v559 != 0.0)
                  {
                    *(float *)&double v324 = v19;
                    LODWORD(v325) = v32;
                    LODWORD(v326) = v31;
                    LODWORD(v327) = v29;
                    processQuadrilaterals((uint64_t)v517, LODWORD(v559), (uint64_t)v523, v487, (uint64_t)v515, &__N, v324, v325, v326, v327, v27, v25, a11);
                    uint64_t v321 = 4 * v468 + 4;
                    mergeQuads((uint64_t)v517, v487, v515, v514, v512, v513, v516, __N, v511, v510, v462, &v557);
                    uint64_t v309 = v458 + 8;
                    v299 = v533;
                    int v298 = v537;
                    unint64_t v297 = v468;
                  }
                }
              }
            }
            else
            {
              *int v319 = -1;
              unint64_t v297 = v468;
              int v298 = v537;
              v299 = v533;
              uint64_t v309 = v458 + 8;
            }
          }
        }
        ++v317;
        v307 += 80;
        int v319 = (unsigned int *)((char *)v319 + v321);
        unsigned int v318 = (void **)((char *)v318 + v309);
        if (!--v320)
        {
          unint64_t v195 = v476;
          unint64_t v308 = v477;
          v293 = v453;
          unint64_t v305 = v490;
          unint64_t v307 = (unint64_t)v484;
          float v310 = v504;
          unsigned int v306 = v496;
          goto LABEL_304;
        }
      }
    }
    v293 = v453;
LABEL_304:
    ++v311;
    --v306;
    v307 += 80;
    v308 += size + 4;
    float v310 = (void **)((char *)v310 + v309);
  }
  while ((void *)v305 != v474);
  if (v468 < 3) {
    goto LABEL_426;
  }
  uint64_t v328 = 0;
  v463 = v299 + 4;
  int v450 = v298 + 1;
  while (2)
  {
    uint64_t v469 = v328;
    if (v452[v328] >= 2u)
    {
      uint64_t v329 = (char *)&v298[v328 * v297];
      float v330 = &v299[4 * v328 * v297];
      LODWORD(v331) = *(_DWORD *)&v330[4 * v328];
      uint64_t v547 = *(void *)&v329[8 * v328];
      if (v547)
      {
        float v558 = *(float *)&v330[4 * v328];
      }
      else if (v331)
      {
        LODWORD(v331) = 0;
        uint64_t v547 = 0;
        float v558 = 0.0;
      }
      else
      {
        singleton((unint64_t)&v500[20 * v328], (uint64_t)&v550, &v558);
        uint64_t v331 = LODWORD(v558);
        if (v558 == 0.0)
        {
          uint64_t v547 = 0;
          *(_DWORD *)&v330[4 * v469] = -1;
        }
        else
        {
          unsigned int v332 = malloc_type_malloc((unint64_t)LODWORD(v558) << 6, 0x1020040E4DCC77DuLL);
          memcpy(v332, &leqBuffer, v331 << 6);
          uint64_t v547 = (uint64_t)v332;
          *(void *)&v329[8 * v469] = v332;
          *(_DWORD *)&v330[4 * v469] = v331;
        }
        unint64_t v297 = v468;
        int v298 = v537;
        v299 = v533;
      }
      uint64_t v333 = 0;
      int v334 = *((_DWORD *)v453 + v469);
      int v335 = 1;
      __nb = v450;
      v505 = (unsigned int *)v463;
      uint64_t v497 = v500 + 20;
      unsigned int v491 = v468 - 1;
      while (1)
      {
        v527 = (char *)v333 + 1;
        int v485 = v335;
        if ((v335 & v334) != 0 && (unint64_t)v527 < v297) {
          break;
        }
LABEL_333:
        int v335 = 2 * v485;
        --v491;
        v497 += 20;
        v505 = (unsigned int *)((char *)v505 + size + 4);
        __nb = (void **)((char *)__nb + v458 + 8);
        uint64_t v333 = v527;
        if (v527 == v474) {
          goto LABEL_334;
        }
      }
      int v336 = 2 << (char)v333;
      unint64_t v337 = v497;
      uint64_t v478 = &v500[20 * (void)v333];
      uint64_t v338 = __nb;
      uint64_t v339 = v505;
      unsigned int v340 = v491;
      while (2)
      {
        if ((v336 & v334) != 0)
        {
          float v341 = *v338;
          LODWORD(v342) = *v339;
          if (*v338)
          {
            unsigned int v549 = *v339;
            if (v331)
            {
LABEL_323:
              if (v342)
              {
                generateQuadrilaterals(v547, v331, (uint64_t)v341, v342, (uint64_t)v517, &v559, v194);
                *(float *)&double v343 = v19;
                LODWORD(v344) = v32;
                LODWORD(v345) = v31;
                LODWORD(v346) = v29;
                processQuadrilaterals((uint64_t)v517, LODWORD(v559), (uint64_t)v523, v487, (uint64_t)v515, &__N, v343, v344, v345, v346, v27, v25, a11);
                mergeQuads((uint64_t)v517, v487, v515, v514, v512, v513, v516, __N, v511, v510, v509, &v557);
                v299 = v533;
                int v298 = v537;
                unint64_t v297 = v468;
              }
            }
          }
          else if (v342)
          {
            unsigned int v549 = 0;
          }
          else
          {
            doubleton(v478, v337, (uint64_t)&v550, &v549);
            uint64_t v342 = v549;
            if (v549)
            {
              float v341 = malloc_type_malloc((unint64_t)v549 << 6, 0x1020040E4DCC77DuLL);
              memcpy(v341, &leqBuffer, v342 << 6);
              *uint64_t v338 = v341;
              *uint64_t v339 = v342;
              unint64_t v297 = v468;
              int v298 = v537;
              v299 = v533;
              if (v331) {
                goto LABEL_323;
              }
            }
            else
            {
              *uint64_t v339 = -1;
              unint64_t v297 = v468;
              int v298 = v537;
              v299 = v533;
            }
          }
        }
        v336 *= 2;
        v337 += 20;
        ++v339;
        ++v338;
        if (!--v340) {
          goto LABEL_333;
        }
        continue;
      }
    }
LABEL_334:
    uint64_t v328 = v469 + 1;
    if (v469 + 1 != v297) {
      continue;
    }
    break;
  }
  unint64_t v195 = v476;
  uint64_t v347 = v453;
  if (v468 >= 4)
  {
    int16x4_t v445 = malloc_type_malloc(4 * count, 0x100004052888210uLL);
    uint64_t v449 = malloc_type_malloc(4 * count, 0x100004052888210uLL);
    int v348 = (int *)malloc_type_malloc(size, 0x100004052888210uLL);
    int v349 = malloc_type_malloc(size, 0x100004052888210uLL);
    uint64_t v475 = malloc_type_malloc(size, 0x100004052888210uLL);
    float32x2_t v350 = (char *)malloc_type_malloc(size, 0x100004052888210uLL);
    unsigned int v352 = v468;
    uint64_t v353 = 0;
    LODWORD(v354) = 0;
    int v355 = 0;
    do
    {
      if (v452[v353] >= 2u)
      {
        int v356 = *((_DWORD *)v453 + v353);
        v349[v355++] = v356;
        if ((int)v354 < 1)
        {
LABEL_342:
          v348[(int)v354] = v356;
          LODWORD(v354) = v354 + 1;
        }
        else
        {
          uint64_t v357 = v354;
          uint64_t v358 = v348;
          while (1)
          {
            int v359 = *v358++;
            if (v356 == v359) {
              break;
            }
            if (!--v357) {
              goto LABEL_342;
            }
          }
        }
      }
      ++v353;
    }
    while (v353 != v468);
    int16x4_t v444 = v349;
    uint64_t v360 = v537;
    unint64_t v361 = v533;
    if (v354)
    {
      uint64_t v362 = (v354 - 1);
      if (v354 == 1)
      {
        *int16x4_t v445 = *v348;
        *uint64_t v449 = *v348;
        int v363 = 1;
        goto LABEL_384;
      }
      if ((int)v354 >= 1)
      {
        unint64_t v365 = v354;
        uint64_t v366 = v348;
        uint64_t v367 = v445;
        uint64_t v368 = v354;
        do
        {
          int v369 = *v366++;
          *v367++ = v369;
          --v368;
        }
        while (v368);
        uint64_t v370 = 0;
        uint64_t v371 = 1;
        do
        {
          uint64_t v372 = v370 + 1;
          if (v370 + 1 < v365)
          {
            int v373 = v348[v370];
            uint64_t v374 = v371;
            do
            {
              int v375 = v348[v374] & v373;
              v351.i32[0] = v375;
              int8x8_t v351 = vcnt_s8(v351);
              v351.i16[0] = vaddlv_u8((uint8x8_t)v351);
              if (v375) {
                BOOL v376 = v351.i32[0] >= 2u;
              }
              else {
                BOOL v376 = 0;
              }
              if (v376)
              {
                if ((int)v354 < 1)
                {
LABEL_366:
                  v445[(int)v354] = v375;
                  LODWORD(v354) = v354 + 1;
                }
                else
                {
                  uint64_t v377 = v354;
                  unsigned int v378 = v445;
                  while (1)
                  {
                    int v379 = *v378++;
                    if (v375 == v379) {
                      break;
                    }
                    if (!--v377) {
                      goto LABEL_366;
                    }
                  }
                }
              }
              ++v374;
            }
            while (v374 != v365);
          }
          ++v371;
          uint64_t v370 = v372;
        }
        while (v372 != v362);
        if ((int)v354 > 1)
        {
          uint64_t v380 = 0;
          uint64_t v381 = v445 + 1;
          uint64_t v382 = 1;
          do
          {
            uint64_t v383 = v380 + 1;
            if (v380 + 1 < (unint64_t)v354)
            {
              uint64_t v384 = v354;
              float v385 = v381;
              while (1)
              {
                int v386 = *v385++;
                if ((v386 ^ v445[v380]) == (v386 | v445[v380])) {
                  break;
                }
                if (v382 == --v384) {
                  goto LABEL_377;
                }
              }
              v445[v380] = 0;
            }
LABEL_377:
            ++v382;
            ++v381;
            ++v380;
          }
          while (v383 != v354 - 1);
        }
        unsigned int v352 = v468;
        uint64_t v360 = v537;
        unint64_t v361 = v533;
        if ((int)v354 >= 1)
        {
          int v363 = 0;
          uint64_t v354 = v354;
          float v387 = v445;
          do
          {
            int v389 = *v387++;
            int v388 = v389;
            if (v389) {
              v449[v363++] = v388;
            }
            --v354;
          }
          while (v354);
          if (v363 >= 1)
          {
LABEL_384:
            uint64_t v390 = 0;
            uint64_t v391 = v468;
            uint64_t v446 = v363;
            v470 = v350 + 4;
            v528 = v350;
            int16x4_t v448 = v348;
            while (1)
            {
              int v392 = 0;
              int v393 = 0;
              int v394 = v449[v390];
              int v395 = 1;
              do
              {
                if ((v395 & v394) != 0) {
                  v475[v393++] = v392;
                }
                v395 *= 2;
                ++v392;
              }
              while (v391 != v392);
              uint64_t v396 = 0;
              int v397 = 0;
              do
              {
                if ((v394 & ~v347[v396]) == 0) {
                  *(_DWORD *)&v350[4 * v397++] = v396;
                }
                ++v396;
              }
              while (v391 != v396);
              uint64_t v451 = v390;
              if (v397 >= 2 && v393 >= 2) {
                break;
              }
LABEL_424:
              uint64_t v390 = v451 + 1;
              uint64_t v391 = v468;
              uint64_t v347 = v453;
              int v348 = v448;
              if (v451 + 1 == v446) {
                goto LABEL_425;
              }
            }
            uint64_t v398 = 0;
            size_t counta = (v393 - 1);
            unint64_t v486 = (v397 - 1);
            uint64_t v466 = 1;
            unint64_t v492 = v397;
            unint64_t v473 = v393;
LABEL_396:
            uint64_t v464 = v398 + 1;
            if (v398 + 1 >= v473) {
              goto LABEL_423;
            }
            uint64_t v399 = v466;
            uint64_t v471 = v398;
LABEL_398:
            unsigned int v400 = v475[v398];
            uint64_t v401 = v475[v399];
            unint64_t v402 = v400 * (unint64_t)v352;
            long long v403 = (char *)&v360[v402];
            double v404 = &v361[4 * v402];
            unsigned int v405 = *(_DWORD *)&v404[4 * v401];
            __nCC_MD5_CTX c = *(void *)&v403[8 * v401];
            uint64_t v479 = v399;
            if (__nc)
            {
              float v558 = *(float *)&v404[4 * v401];
            }
            else if (v405)
            {
              unsigned int v405 = 0;
              __nCC_MD5_CTX c = 0;
              float v558 = 0.0;
            }
            else
            {
              doubleton(&v500[20 * v400], &v500[20 * v401], (uint64_t)&v550, &v558);
              uint64_t v406 = LODWORD(v558);
              if (v558 == 0.0)
              {
                unsigned int v405 = 0;
                __nCC_MD5_CTX c = 0;
                *(_DWORD *)&v404[4 * v401] = -1;
              }
              else
              {
                unsigned int v407 = malloc_type_malloc((unint64_t)LODWORD(v558) << 6, 0x1020040E4DCC77DuLL);
                memcpy(v407, &leqBuffer, v406 << 6);
                unsigned int v405 = v406;
                __nCC_MD5_CTX c = (uint64_t)v407;
                *(void *)&v403[8 * v401] = v407;
                *(_DWORD *)&v404[4 * v401] = v406;
              }
              unsigned int v352 = v468;
              uint64_t v360 = v537;
              unint64_t v361 = v533;
              float32x2_t v350 = v528;
            }
            uint64_t v408 = 0;
            v506 = (unsigned int *)v470;
            uint64_t v409 = 1;
            uint64_t v410 = v487;
            unsigned int v548 = v405;
            while (1)
            {
              v498 = (void *)(v408 + 1);
              if (v408 + 1 < v492) {
                break;
              }
LABEL_421:
              ++v409;
              ++v506;
              ++v408;
              if (v498 == (void *)v486)
              {
                unint64_t v195 = v476;
                uint64_t v399 = v479 + 1;
                uint64_t v398 = v471;
                if (v479 + 1 == v473)
                {
LABEL_423:
                  ++v466;
                  uint64_t v398 = v464;
                  if (v464 == counta) {
                    goto LABEL_424;
                  }
                  goto LABEL_396;
                }
                goto LABEL_398;
              }
            }
            int v411 = v506;
            unint64_t v412 = v492;
            while (2)
            {
              unsigned int v413 = *(_DWORD *)&v350[4 * v408];
              unsigned int v415 = *v411++;
              uint64_t v414 = v415;
              unint64_t v416 = v413 * (unint64_t)v352;
              float v417 = (char *)&v360[v416];
              float v418 = *(void **)&v417[8 * v415];
              double v419 = &v361[4 * v416];
              LODWORD(v420) = *(_DWORD *)&v419[4 * v415];
              if (v418)
              {
                unsigned int v549 = v420;
                if (v405)
                {
LABEL_411:
                  if (v420)
                  {
                    generateQuadrilaterals(__nc, v548, (uint64_t)v418, v420, (uint64_t)v517, &v559, v194);
                    *(float *)&double v421 = v19;
                    LODWORD(v422) = v32;
                    LODWORD(v423) = v31;
                    LODWORD(v424) = v29;
                    processQuadrilaterals((uint64_t)v517, LODWORD(v559), (uint64_t)v523, v410, (uint64_t)v515, &__N, v421, v422, v423, v424, v27, v25, a11);
                    mergeQuads((uint64_t)v517, v410, v515, v514, v512, v513, v516, __N, v511, v510, v509, &v557);
                    unsigned int v405 = v548;
                    float32x2_t v350 = v528;
                    unint64_t v361 = v533;
                    uint64_t v360 = v537;
                    unsigned int v352 = v468;
                  }
                }
              }
              else if (v420)
              {
                unsigned int v549 = 0;
              }
              else
              {
                doubleton(&v500[20 * v413], &v500[20 * v414], (uint64_t)&v550, &v549);
                uint64_t v420 = v549;
                if (v549)
                {
                  float v418 = malloc_type_malloc((unint64_t)v549 << 6, 0x1020040E4DCC77DuLL);
                  uint64_t v410 = v487;
                  memcpy(v418, &leqBuffer, v420 << 6);
                  *(void *)&v417[8 * v414] = v418;
                  *(_DWORD *)&v419[4 * v414] = v420;
                  unsigned int v352 = v468;
                  uint64_t v360 = v537;
                  unint64_t v361 = v533;
                  float32x2_t v350 = v528;
                  unsigned int v405 = v548;
                  if (v548) {
                    goto LABEL_411;
                  }
                }
                else
                {
                  *(_DWORD *)&v419[4 * v414] = -1;
                  unsigned int v352 = v468;
                  uint64_t v360 = v537;
                  unint64_t v361 = v533;
                  float32x2_t v350 = v528;
                  unsigned int v405 = v548;
                }
              }
              if (v409 == --v412) {
                goto LABEL_421;
              }
              continue;
            }
          }
        }
      }
    }
LABEL_425:
    float32x2_t v425 = v350;
    free(v348);
    free(v445);
    free(v449);
    free(v444);
    free(v475);
    free(v425);
    int v298 = v537;
    unint64_t v297 = v468;
  }
LABEL_426:
  uint64_t v426 = 0;
  v427 = v298;
  do
  {
    v428 = v427;
    unint64_t v429 = v297;
    do
    {
      if (*v428) {
        free(*v428);
      }
      ++v428;
      --v429;
    }
    while (v429);
    ++v426;
    v427 = (void **)((char *)v427 + v458);
    unint64_t v297 = v468;
  }
  while (v426 != v468);
LABEL_432:
  free(v453);
  free(v452);
  unint64_t v132 = (void *)v487;
  int v292 = v523;
LABEL_433:
  free(v537);
  free(v533);
LABEL_434:
  deallocateEdgeMap(v195);
  if (v292) {
    free(v292);
  }
  free(v461);
  free(v460);
  free(v467);
  free(v459);
  free(v454);
  if (v468)
  {
    uint64_t v430 = 0;
    int v431 = (char *)(v500 + 12);
    do
    {
      for (uint64_t n = 0; n != 32; n += 8)
      {
        free(*(void **)&v431[n]);
        *(void *)&v431[n] = 0;
      }
      ++v430;
      v431 += 80;
    }
    while (v430 != v541);
  }
  free(v500);
  free(v517);
  unint64_t v433 = v557;
  BOOL v139 = v557 != 0;
  if (v557)
  {
    float v434 = v19 * a10;
    float v435 = (float *)(v511 + 1);
    do
    {
      float v436 = *(v435 - 2);
      float v437 = 255.0 - *(v435 - 1);
      float v438 = *v435;
      float v439 = 255.0 - v435[1];
      float v441 = v435[2];
      float v440 = v435[3];
      float v442 = (float)(255.0 - *(v435 - 3)) * a10;
      *(v435 - 4) = v434 * *(v435 - 4);
      *(v435 - 3) = v442;
      *(v435 - 2) = v434 * v436;
      *(v435 - 1) = v437 * a10;
      *float v435 = v434 * v438;
      v435[1] = v439 * a10;
      v435[2] = v434 * v441;
      v435[3] = (float)(255.0 - v440) * a10;
      v435 += 8;
      --v433;
    }
    while (v433);
  }
  unsigned __int8 v140 = 0;
  unsigned __int8 v134 = 0;
  if (v132) {
LABEL_445:
  }
    free(v132);
LABEL_446:
  if (v514) {
    free(v514);
  }
  if (v512) {
    free(v512);
  }
  if (v513) {
    free(v513);
  }
  if (v516) {
    free(v516);
  }
  if (v515) {
    free(v515);
  }
  if (v134) {
    free(v134);
  }
  if (v140) {
    deallocateEdgeMap(v140);
  }
  *uint64_t v455 = v557;
  return v139;
}