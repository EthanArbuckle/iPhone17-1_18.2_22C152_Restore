float *createPerMeshForFFTSIZE()
{
  float *v0;
  float *v1;

  v0 = (float *)malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
  v1 = v0;
  if (v0) {
    initializePerMesh(v0, 256, 256);
  }
  return v1;
}

void initializePerMesh(float *a1, int a2, int a3)
{
  v6 = (double *)malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
  v7 = v6;
  if (a2 != a3) {
    v7 = (double *)malloc_type_malloc(8 * a3, 0x100004000313F17uLL);
  }
  if (a2 >= 1)
  {
    uint64_t v8 = 0;
    float64x2_t v27 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)a2), 0);
    uint64x2_t v29 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    uint64x2_t v9 = (uint64x2_t)xmmword_1A4104940;
    int64x2_t v23 = vdupq_n_s64(2uLL);
    float64x2_t v25 = (float64x2_t)vdupq_n_s64(0x401921FB54442D18uLL);
    do
    {
      int64x2_t v37 = (int64x2_t)v9;
      int32x2_t v35 = vmovn_s64((int64x2_t)vcgeq_u64(v29, v9));
      v10.i64[0] = (int)v8;
      v10.i64[1] = (int)v8 + 1;
      float64x2_t __x = vdivq_f64(vmulq_f64(vcvtq_f64_s64(v10), v25), v27);
      long double v33 = cos(__x.f64[1]);
      double v11 = cos(__x.f64[0]);
      if (v35.i8[0]) {
        v6[v8] = v11;
      }
      if (v35.i8[4]) {
        v6[v8 + 1] = v33;
      }
      v8 += 2;
      uint64x2_t v9 = (uint64x2_t)vaddq_s64(v37, v23);
    }
    while (((a2 + 1) & 0x1FFFFFFFELL) != v8);
  }
  if (a2 != a3 && a3 >= 1)
  {
    uint64_t v12 = 0;
    float64x2_t v28 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)a3), 0);
    uint64x2_t v30 = (uint64x2_t)vdupq_n_s64((unint64_t)a3 - 1);
    uint64x2_t v13 = (uint64x2_t)xmmword_1A4104940;
    int64x2_t v24 = vdupq_n_s64(2uLL);
    float64x2_t v26 = (float64x2_t)vdupq_n_s64(0x401921FB54442D18uLL);
    do
    {
      int64x2_t v38 = (int64x2_t)v13;
      int32x2_t v36 = vmovn_s64((int64x2_t)vcgeq_u64(v30, v13));
      v14.i64[0] = (int)v12;
      v14.i64[1] = (int)v12 + 1;
      float64x2_t __xa = vdivq_f64(vmulq_f64(vcvtq_f64_s64(v14), v26), v28);
      long double v34 = cos(__xa.f64[1]);
      double v15 = cos(__xa.f64[0]);
      if (v36.i8[0]) {
        v7[v12] = v15;
      }
      if (v36.i8[4]) {
        v7[v12 + 1] = v34;
      }
      v12 += 2;
      uint64x2_t v13 = (uint64x2_t)vaddq_s64(v38, v24);
    }
    while (((a3 + 1) & 0x1FFFFFFFELL) != v12);
  }
  if (a3 >= 1)
  {
    uint64_t v16 = 0;
    v17 = a1;
    do
    {
      if (a2 >= 1)
      {
        double v18 = v7[v16];
        v19 = v6;
        uint64_t v20 = a2;
        do
        {
          double v21 = *v19++;
          float v22 = 1.0 / (2.0 - v21 - v18 + 2.0 - v21 - v18);
          *v17++ = v22;
          --v20;
        }
        while (v20);
      }
      ++v16;
    }
    while (v16 != a3);
  }
  *a1 = 0.0;
  free(v6);
  if (a2 != a3)
  {
    free(v7);
  }
}

void sub_1A3F41708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F417C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F418E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F41A24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<std::vector<unsigned int>>::__assign_with_size[abi:ne180100]<std::vector<unsigned int>*,std::vector<unsigned int>*>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v9 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2];
  int64x2_t v10 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *a1) >> 3) < a4)
  {
    if (v10)
    {
      std::vector<std::vector<long long>>::__clear[abi:ne180100](a1);
      operator delete((void *)*a1);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= a4) {
      uint64_t v12 = a4;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v12;
    }
    std::vector<std::string>::__vallocate[abi:ne180100](a1, v13);
    int64x2_t v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*,std::vector<unsigned int>*,std::vector<unsigned int>*>(v9, a2, a3, (void *)a1[1]);
    goto LABEL_13;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - (uint64_t)v10) >> 3) < a4)
  {
    uint64_t v15 = a2 + 8 * ((a1[1] - (uint64_t)v10) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<unsigned int> *,std::vector<unsigned int> *,std::vector<unsigned int> *>(a2, v15, v10);
    int64x2_t v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*,std::vector<unsigned int>*,std::vector<unsigned int>*>(v9, v15, a3, (void *)a1[1]);
LABEL_13:
    a1[1] = (uint64_t)v14;
    return;
  }
  uint64_t v16 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<unsigned int> *,std::vector<unsigned int> *,std::vector<unsigned int> *>(a2, a3, v10);
  v17 = (char *)a1[1];
  if (v17 != v16)
  {
    double v18 = (char *)a1[1];
    do
    {
      uint64_t v20 = (void *)*((void *)v18 - 3);
      v18 -= 24;
      v19 = v20;
      if (v20)
      {
        *((void *)v17 - 2) = v19;
        operator delete(v19);
      }
      v17 = v18;
    }
    while (v18 != v16);
  }
  a1[1] = (uint64_t)v16;
}

void sub_1A3F41BA8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1A3F41BB0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

char *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<unsigned int> *,std::vector<unsigned int> *,std::vector<unsigned int> *>(uint64_t a1, uint64_t a2, char *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      if ((char *)v5 != a3) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a3, *(char **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 2);
      }
      v5 += 24;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return a3;
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*,std::vector<unsigned int>*,std::vector<unsigned int>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  v4 = a4;
  int64x2_t v10 = a4;
  unint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      void *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 2);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A3F41CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v2 = **(void **)(a1 + 16);
    uint64_t v3 = **(void **)(a1 + 8);
    if (v2 != v3)
    {
      uint64_t v4 = **(void **)(a1 + 16);
      do
      {
        uint64_t v6 = *(void **)(v4 - 24);
        v4 -= 24;
        uint64_t v5 = v6;
        if (v6)
        {
          *(void *)(v2 - 16) = v5;
          operator delete(v5);
        }
        uint64_t v2 = v4;
      }
      while (v4 != v3);
    }
  }
  return a1;
}

void sub_1A3F41DDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F41EF0(void *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  objc_begin_catch(exc_buf);
  os_unfair_lock_unlock(v10);
  objc_exception_rethrow();
}

void sub_1A3F41F1C(_Unwind_Exception *a1)
{
}

void sub_1A3F42080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F42330(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F42480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F42784(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3F427B8(void *a1)
{
  __cxa_begin_catch(a1);
  _deleteEPolygonList(v1);
  __cxa_rethrow();
}

void sub_1A3F427CC()
{
}

void sub_1A3F42A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a13;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&a16);
  if (v16) {
    operator delete(v16);
  }
  _Unwind_Resume(a1);
}

void sub_1A3F436F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<apple::vision::libraries::autotrace::EPolygonList *,void (*)(apple::vision::libraries::autotrace::EPolygonList *),std::allocator<apple::vision::libraries::autotrace::EPolygonList>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"PFvPN5apple6vision9libraries9autotrace12EPolygonListEE"))
  {
    return a1 + 32;
  }
  else
  {
    return 0;
  }
}

uint64_t std::__shared_ptr_pointer<apple::vision::libraries::autotrace::EPolygonList *,void (*)(apple::vision::libraries::autotrace::EPolygonList *),std::allocator<apple::vision::libraries::autotrace::EPolygonList>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

void std::__shared_ptr_pointer<apple::vision::libraries::autotrace::EPolygonList *,void (*)(apple::vision::libraries::autotrace::EPolygonList *),std::allocator<apple::vision::libraries::autotrace::EPolygonList>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void _deleteEPolygonList(apple::vision::libraries::autotrace::EPolygonList *a1)
{
  apple::vision::libraries::autotrace::EPolygonList::term(a1);
  if (a1)
  {
    JUMPOUT(0x1A62562C0);
  }
}

void sub_1A3F43874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  int64x2_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNContoursObservation;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F439A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F44978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, void *a20,void *a21,uint64_t a22,void *a23,void *a24,void *a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double getHostTimeInMillis(void)
{
  kern_return_t v0;
  double v1;

  v0 = mach_timebase_info((mach_timebase_info_t)&getHostTimeInNanos(void)::info);
  uint64_t v1 = 0.0;
  if (!v0) {
    uint64_t v1 = (double)(mach_absolute_time() * getHostTimeInNanos(void)::info / *(unsigned int *)algn_1E9640794);
  }
  return v1 / 1000000.0;
}

void ObservedParabola::ObservedParabola(ObservedParabola *this, const ObservedParabola *a2)
{
  *(void *)this = *(id *)a2;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>((void *)this + 1, *((const void **)a2 + 1), *((void *)a2 + 2), (uint64_t)(*((void *)a2 + 2) - *((void *)a2 + 1)) >> 4);
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>((void *)this + 4, *((const void **)a2 + 4), *((void *)a2 + 5), (uint64_t)(*((void *)a2 + 5) - *((void *)a2 + 4)) >> 4);
  *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
  long long v4 = *(_OWORD *)((char *)a2 + 72);
  long long v5 = *(_OWORD *)((char *)a2 + 88);
  long long v6 = *(_OWORD *)((char *)a2 + 104);
  *(_OWORD *)((char *)this + 116) = *(_OWORD *)((char *)a2 + 116);
  *(_OWORD *)((char *)this + 104) = v6;
  *(_OWORD *)((char *)this + 88) = v5;
  *(_OWORD *)((char *)this + 72) = v4;
}

void sub_1A3F44D08(_Unwind_Exception *a1)
{
  long long v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }

  _Unwind_Resume(a1);
}

void ObservedParabola::~ObservedParabola(ObservedParabola *this)
{
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

void sub_1A3F44E50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F44F8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F44FF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  int64x2_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNTrajectoryProcessor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F456B8(_Unwind_Exception *a1)
{
  long long v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A3F46238(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p)
{
  v39 = *(void **)(v37 - 224);
  if (v39) {
    operator delete(v39);
  }
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void std::vector<_Geometry2D_point2D_>::resize(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v4 = v3 - *a1;
  if ((unint64_t)v4 > 0x1F7)
  {
    if (v4 == 504) {
      return;
    }
    v19 = v2 + 504;
    goto LABEL_18;
  }
  unint64_t v5 = 63 - (v4 >> 3);
  long long v6 = a1[2];
  if (v5 <= (v6 - v3) >> 3)
  {
    bzero(a1[1], 8 * v5);
    v19 = &v3[8 * v5];
LABEL_18:
    a1[1] = v19;
    return;
  }
  uint64_t v7 = v4 >> 3;
  uint64_t v8 = v6 - v2;
  uint64_t v9 = v8 >> 2;
  if ((unint64_t)(v8 >> 2) <= 0x3F) {
    uint64_t v9 = 63;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  unint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v10);
  uint64_t v12 = &v11[8 * v7];
  int64x2_t v14 = &v11[8 * v13];
  bzero(v12, 8 * v5);
  uint64_t v15 = &v12[8 * v5];
  v17 = *a1;
  uint64_t v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      uint64_t v18 = *((void *)v16 - 1);
      v16 -= 8;
      *((void *)v12 - 1) = v18;
      v12 -= 8;
    }
    while (v16 != v17);
    uint64_t v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
  {
    operator delete(v16);
  }
}

void std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*((void *)a1 + 1));
    if (a1[63] < 0) {
      operator delete(*((void **)a1 + 5));
    }
    operator delete(a1);
  }
}

void sub_1A3F46550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  unint64_t v11 = v10;

  a9.super_class = (Class)VNFaceRegionMapGenerator;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F46654(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F475CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::FaceRegionMap>::__on_zero_shared(void *a1)
{
  uint64_t v3 = (char **)(a1 + 4);
  uint64_t v2 = (char *)a1[4];
  v3[10] = v3[9];
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(v2);
  *(v3 - 1) = (char *)v3;
  *uint64_t v3 = 0;
  v3[1] = 0;
  v3[3] = v3[2];
  uint64_t v4 = v3[5];
  if (v4) {
    free(v4);
  }
  unint64_t v5 = (void *)a1[13];
  if (v5)
  {
    a1[14] = v5;
    operator delete(v5);
  }
  long long v6 = (void *)a1[6];
  if (v6)
  {
    a1[7] = v6;
    operator delete(v6);
  }
  uint64_t v7 = *v3;

  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(v7);
}

void std::__shared_ptr_emplace<vision::mod::FaceRegionMap>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753508;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::FaceRegionMap>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753508;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A3F478E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void deallocateEdgeMap(void **a1)
{
  free(a1[2]);
  a1[2] = 0;
  free(a1[3]);
  a1[3] = 0;
  free(a1[4]);
  a1[4] = 0;
  free(a1[5]);

  free(a1);
}

void sub_1A3F47BA8(_Unwind_Exception *a1)
{
  long long v6 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3F47E64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F47F68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F47FC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F48118(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F481E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F48378(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F48448(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F48500(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F48750(_Unwind_Exception *exc_buf, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x1A3F4867CLL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1A3F48870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F488F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4899C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F48ACC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F48C20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F48D50(_Unwind_Exception *a1)
{
}

void sub_1A3F48ED0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F48FD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F490A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F49160(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F49268(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F493CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4953C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F49AE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F49B74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F49BE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F49C50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F49CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4A0F8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3F4A074);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3F4A2F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4A434(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4A554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4A608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4A6A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4A734(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4ADE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4B090(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4B2B4(void *exc_buf)
{
  objc_begin_catch(exc_buf);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3F4B2E8(_Unwind_Exception *a1)
{
}

void sub_1A3F4B468(void *exc_buf)
{
  objc_begin_catch(exc_buf);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3F4B49C(_Unwind_Exception *a1)
{
}

void sub_1A3F4B644(void *exc_buf)
{
  objc_begin_catch(exc_buf);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3F4B684(_Unwind_Exception *a1)
{
}

void sub_1A3F4BAC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4C200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4C73C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4CC80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4D7C8(_Unwind_Exception *exc_buf, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x1A3F4D048);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1A3F4D8F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4DBAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4DF58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E11C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E2E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E4E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E78C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E8F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4E994(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4EA94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4EBC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4ECBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4EE38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4EEFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4F0C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4F2CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4F38C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4F5B0(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3F4F708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4F7D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4F874(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4F910(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4FBA8(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A3F4FCC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4FD60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4FE00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F4FEA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50064(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1A3F4FF18);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F50230(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F502C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50844(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50920(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50A2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50BEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50D5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50E00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F50F00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F51000(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F51138(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F512C4(_Unwind_Exception *a1)
{
  unint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3F514EC(_Unwind_Exception *a1)
{
  long long v6 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3F515E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F51740(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F51814(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F518B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F519B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F51A28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  unint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNPixelBufferObservation;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F51B18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F51C18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F51D64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F51EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F51FF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F520E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F52260(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5232C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F523C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F524E4(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3F525FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F52850(_Unwind_Exception *a1)
{
}

void sub_1A3F52A20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F52B90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F52E5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F53228(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F532FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F533E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F53824(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F53958(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F53A08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F53B10()
{
}

void sub_1A3F53D9C(_Unwind_Exception *a1)
{
  unint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3F53E9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F53FB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5417C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F54290(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F54410(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5486C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F54A00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F54B58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F54C98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F54F54(_Unwind_Exception *a1)
{
  unint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3F551D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F55368(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F553D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F55448(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5558C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F55658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F55708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F557B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F55988(_Unwind_Exception *a1, int a2)
{
  uint64_t v8 = v6;

  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1A3F5582CLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F55B20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F55C60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F55CF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F55ECC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F55F98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F56038(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F560E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

#error "1A3F56334: call analysis failed (funcsize=27)"

void sub_1A3F5648C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F565C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5666C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F56778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F56854(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F56958(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F569F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F56B40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F56BF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F56E50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F57048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F57138(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F572A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F57378(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F573F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F57500(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5759C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F57634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F576D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5782C(_Unwind_Exception *a1)
{
  unint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3F57AA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F57D00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F57DD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F58430(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F58634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F58BAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F58DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  uint64_t v18 = v17;

  _Unwind_Resume(a1);
}

void sub_1A3F58EB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3F58F5C(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3F58F70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3F59024(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3F59038(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3F59104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void sub_1A3F59210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F59324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F594D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F595B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F59634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F596F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F59814(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F598F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F599D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F59AC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F59E88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, id *location, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,void *a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50)
{
  objc_destroyWeak(v52);
  objc_destroyWeak(location);
  _Block_object_dispose(&a45, 8);

  _Block_object_dispose((const void *)(v53 - 224), 8);
  _Block_object_dispose((const void *)(v53 - 176), 8);
  objc_destroyWeak((id *)(v53 - 144));

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__16832(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__16833(uint64_t a1)
{
}

void sub_1A3F5A164(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5A3E0(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A3F5A3A0);
}

void sub_1A3F5A624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5A988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30)
{
  _Block_object_dispose(&a25, 8);
  _Unwind_Resume(a1);
}

void sub_1A3F5AB00(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3F5AB2C(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A3F5AAB8);
}

void sub_1A3F5AC68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5AD20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNDetector;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F5AF3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5AFF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5B0FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5B31C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5B484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5B644(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5B780(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5B80C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5B878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5BAAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5BD0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5BEA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__16960(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__16961(uint64_t a1)
{
}

void sub_1A3F5C71C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5CD00(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A3F5CCC4);
}

void sub_1A3F5CDDC()
{
  JUMPOUT(0x1A3F5CDFCLL);
}

void sub_1A3F5CDF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5D044(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5D118(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  unint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNVTSession;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F5D1D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  unint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNVTPixelTransferSession;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F5D260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNVTPixelRotationSession;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void std::default_delete<SessionsHandler<VNVTPixelRotationSession>>::operator()[abi:ne180100](id *a1)
{
  JUMPOUT(0x1A62562C0);
}

void sub_1A3F5D3D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

VNVTPixelTransferSession *_block_invoke_2(uint64_t a1, void *a2)
{
  self;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  uint64_t v3 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
  if (v3) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = pixelTransferSessionOut == 0;
  }
  if (v4)
  {
    if (a2)
    {
      id v5 = [NSString stringWithFormat:@"Cannot create VTPixelTransferSessionRef object: session: %lu, error: %d", pixelTransferSessionOut, v3];
      uint64_t v6 = [v5 UTF8String];
      VNValidatedLog(4, @"%s", v7, v8, v9, v10, v11, v12, v6);
      uint64_t v13 = +[VNError errorForInternalErrorWithLocalizedDescription:v5];
LABEL_11:
      *a2 = v13;
    }
LABEL_12:
    float v22 = 0;
    goto LABEL_13;
  }
  uint64_t v14 = VTSessionSetProperty(pixelTransferSessionOut, (CFStringRef)*MEMORY[0x1E4F45100], (CFTypeRef)*MEMORY[0x1E4F24C40]);
  if (v14)
  {
    if (a2)
    {
      id v5 = [NSString stringWithFormat:@"Cannot set VTSession property, error: %d", v14];
      uint64_t v15 = [v5 UTF8String];
      VNValidatedLog(4, @"%s", v16, v17, v18, v19, v20, v21, v15);
      uint64_t v13 = +[VNError errorForInternalErrorWithLocalizedDescription:v5];
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  float v22 = [VNVTPixelTransferSession alloc];
  if (v22)
  {
    v22->_pixelTransferSession = pixelTransferSessionOut;
    v25.receiver = v22;
    v25.super_class = (Class)VNVTPixelTransferSession;
    float v22 = (VNVTPixelTransferSession *)objc_msgSendSuper2(&v25, sel_initWithSession_);
  }
LABEL_13:

  return v22;
}

void sub_1A3F5D5CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _block_invoke()
{
  return 1;
}

void sub_1A3F5DA44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5DD00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5DDCC(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3F5DDE0(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3F5DF64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5DFFC(_Unwind_Exception *a1)
{
}

void sub_1A3F5E0D8(_Unwind_Exception *a1)
{
}

void sub_1A3F5E3B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5E62C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5E704(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5E804(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5E8A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5E920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5E994(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5EA8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5EB04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5EB80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5EC3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5EDD4(_Unwind_Exception *a1)
{
  uint64_t v6 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3F5EF00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5F0D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5F168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5F504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5F6E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5F7F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t AltruisticBodyPoseKitLibraryCore(char **a1)
{
  if (!AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrary) {
    AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  return AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrary;
}

uint64_t ___ZL32AltruisticBodyPoseKitLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void sub_1A3F5FA0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F5FE20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

Class ___ZL18getABPKOutputClassv_block_invoke(uint64_t a1)
{
  AltruisticBodyPoseKitLibrary();
  Class result = objc_getClass("ABPKOutput");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getABPKOutputClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    return (Class)getABPKInputClass();
  }
  return result;
}

id getABPKInputClass(void)
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2050000000;
  v0 = (void *)getABPKInputClass(void)::softClass;
  uint64_t v7 = getABPKInputClass(void)::softClass;
  if (!getABPKInputClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL17getABPKInputClassv_block_invoke;
    v3[3] = &unk_1E5B20220;
    v3[4] = &v4;
    ___ZL17getABPKInputClassv_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_1A3F6002C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getABPKCameraParamsClass(void)
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2050000000;
  v0 = (void *)getABPKCameraParamsClass(void)::softClass;
  uint64_t v7 = getABPKCameraParamsClass(void)::softClass;
  if (!getABPKCameraParamsClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL24getABPKCameraParamsClassv_block_invoke;
    v3[3] = &unk_1E5B20220;
    v3[4] = &v4;
    ___ZL24getABPKCameraParamsClassv_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_1A3F60110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL24getABPKCameraParamsClassv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("ABPKCameraParams");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getABPKCameraParamsClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    AltruisticBodyPoseKitLibrary();
  }
}

void AltruisticBodyPoseKitLibrary(void)
{
  uint64_t v2 = 0;
  uint64_t v0 = AltruisticBodyPoseKitLibraryCore(&v2);
  id v1 = v2;
  if (!v0)
  {
    id v1 = (void *)abort_report_np();
    goto LABEL_5;
  }
  if (v2) {
LABEL_5:
  }
    free(v1);
}

Class ___ZL17getABPKInputClassv_block_invoke(uint64_t a1)
{
  AltruisticBodyPoseKitLibrary();
  Class result = objc_getClass("ABPKInput");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getABPKInputClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = (VNHumanBodyPose3DDetector *)abort_report_np();
    return (Class)[(VNHumanBodyPose3DDetector *)v3 createRegionOfInterestCrop:v11 options:v5 qosClass:v6 warningRecorder:v7 pixelBuffer:v8 error:v9 progressHandler:v10];
  }
  return result;
}

void sub_1A3F60714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,void *a27)
{
  _Unwind_Resume(a1);
}

void sub_1A3F60884(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F60A88(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, ...)
{
  va_start(va, a4);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<float>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<float>>>>::~__hash_table((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<float>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<float>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<float>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  SEL v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void sub_1A3F60D88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _Unwind_Resume(a1);
}

void Geometry2D_mallocHomo2D(uint64_t a1, int a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (a2 >= 1)
  {
    size_t v4 = 4 * a2;
    id v5 = malloc_type_malloc(v4, 0x100004052888210uLL);
    *(void *)a1 = v5;
    if (v5
      && (unsigned int v6 = malloc_type_malloc(v4, 0x100004052888210uLL), (*(void *)(a1 + 8) = v6) != 0)
      && (id v7 = malloc_type_malloc(v4, 0x100004052888210uLL), (*(void *)(a1 + 16) = v7) != 0))
    {
      *(_DWORD *)(a1 + 24) = a2;
    }
    else
    {
      Geometry3D_freeCart3D(a1);
    }
  }
}

void sub_1A3F61120(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  std::streambuf::~streambuf();

  _Unwind_Resume(a1);
}

void sub_1A3F614EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);

  std::unique_ptr<vision::mod::FaceID3Model>::reset[abi:ne180100]((vision::mod::FaceID3Model **)va);
  std::istream::~istream();

  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void vision::mod::FaceID3Model::~FaceID3Model(vision::mod::FaceID3Model *this)
{
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)this + 96);
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      size_t v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  id v5 = (void *)*((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
}

uint64_t std::shared_ptr<vision::mod::FaceID3Model>::operator=[abi:ne180100]<vision::mod::FaceID3Model,std::default_delete<vision::mod::FaceID3Model>,void>(uint64_t a1, void *a2)
{
  if (*a2) {
    operator new();
  }
  *a2 = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = 0u;
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  return a1;
}

vision::mod::FaceID3Model *std::unique_ptr<vision::mod::FaceID3Model>::reset[abi:ne180100](vision::mod::FaceID3Model **a1)
{
  Class result = *a1;
  *a1 = 0;
  if (result)
  {
    vision::mod::FaceID3Model::~FaceID3Model(result);
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<vision::mod::FaceID3Model  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__114default_deleteIN6vision3mod12FaceID3ModelEEE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

vision::mod::FaceID3Model *std::__shared_ptr_pointer<vision::mod::FaceID3Model  *>::__on_zero_shared(uint64_t a1)
{
  Class result = *(vision::mod::FaceID3Model **)(a1 + 24);
  if (result)
  {
    vision::mod::FaceID3Model::~FaceID3Model(result);
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

void std::__shared_ptr_pointer<vision::mod::FaceID3Model  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A3F618BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A3F61950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F61A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3F61B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F61C28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6213C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56)
{
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32(v59);

  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a51, 8);

  _Block_object_dispose((const void *)(v60 - 256), 8);
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32((void **)(v60 - 208));

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__49_17614(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__50_17615(uint64_t a1)
{
}

uint64_t __Block_byref_object_copy__17616(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = &unk_1EF752200;
  *(void *)(result + 56) = *(void *)(a2 + 56);
  return result;
}

void sub_1A3F6254C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, char a15, uint64_t a16, uint64_t a17, void **a18)
{
  a18 = (void **)&a15;
  std::vector<std::map<int,double>>::__destroy_vector::operator()[abi:ne180100](&a18);

  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_72c47_ZTSN6vision3mod28ImageDescriptorBufferFloat32E(uint64_t a1)
{
  id v1 = (void **)(a1 + 72);
  *(void *)(a1 + 72) = &unk_1EF752918;
  free(*(void **)(a1 + 184));

  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(v1);
}

__n128 __copy_helper_block_ea8_72c47_ZTSN6vision3mod28ImageDescriptorBufferFloat32E(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 80) = 0;
  uint64_t v4 = a1 + 80;
  *(void *)(a1 + 72) = &unk_1EF752B68;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>((void *)(a1 + 80), *(const void **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 3);
  std::map<long long,int>::map[abi:ne180100]((uint64_t *)(v4 + 24), a2 + 104);
  long long v5 = *(_OWORD *)(a2 + 128);
  long long v6 = *(_OWORD *)(a2 + 144);
  *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
  *(_OWORD *)(a1 + 128) = v5;
  *(_OWORD *)(a1 + 144) = v6;
  *(void *)(a1 + 72) = &unk_1EF752918;
  __n128 result = *(__n128 *)(a2 + 168);
  *(void *)(a1 + 184) = *(void *)(a2 + 184);
  *(__n128 *)(a1 + 168) = result;
  return result;
}

void sub_1A3F626EC(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 88) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3F627E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F62A5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F62C58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F636B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, long long a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22,std::__shared_weak_count *a23,void *a24,void *a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51)
{
  if (__p) {
    operator delete(__p);
  }
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__121(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__122(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t ___ZL15_newFaceIDModelP40VNEntityIdentificationModelConfigurationPU15__autoreleasingP7NSError_block_invoke(uint64_t a1)
{
  std::allocate_shared[abi:ne180100]<vision::mod::FaceID3Model,std::allocator<vision::mod::FaceID3Model>,int const&,int const&,int const&,vision::mod::FaceIDIndexMode const&,void>(&v5, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52));
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 56);
  *(_OWORD *)(v2 + 48) = v5;
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  return 1;
}

void __destroy_helper_block_ea8_48c53_ZTSNSt3__110shared_ptrIN6vision3mod12FaceID3ModelEEE64c69_ZTSNSt3__110shared_ptrIN6vision3mod28ImageDescriptorBufferFloat32EEE80c39_ZTSNSt3__16vectorIiNS_9allocatorIiEEEE(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void *__copy_helper_block_ea8_48c53_ZTSNSt3__110shared_ptrIN6vision3mod12FaceID3ModelEEE64c69_ZTSNSt3__110shared_ptrIN6vision3mod28ImageDescriptorBufferFloat32EEE80c39_ZTSNSt3__16vectorIiNS_9allocatorIiEEEE(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  a1[6] = *(void *)(a2 + 48);
  a1[7] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(a2 + 72);
  a1[8] = *(void *)(a2 + 64);
  a1[9] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  return std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(a1 + 10, *(const void **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 2);
}

void sub_1A3F63AF0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 72);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 56);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  _Unwind_Resume(exception_object);
}

char *std::allocate_shared[abi:ne180100]<vision::mod::FaceID3Model,std::allocator<vision::mod::FaceID3Model>,int const&,int const&,int const&,vision::mod::FaceIDIndexMode const&,void>(void *a1, int a2, int a3, int a4, int a5)
{
  __n128 result = (char *)operator new(0xA0uLL);
  *((void *)result + 1) = 0;
  *((void *)result + 2) = 0;
  *((_DWORD *)result + 6) = a2;
  uint64_t v11 = result + 24;
  *(void *)__n128 result = &unk_1EF7534D0;
  *((_DWORD *)result + 7) = a3;
  *((_DWORD *)result + 8) = a4;
  *(void *)(result + 36) = 0x12C0000000ALL;
  *((void *)result + 6) = 0x3F1A36E2EB1C432DLL;
  *((_DWORD *)result + 14) = a5;
  *((_DWORD *)result + 15) = 1036831949;
  *((void *)result + 8) = 0x20000000FLL;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  *((void *)result + 13) = 0;
  *((_DWORD *)result + 28) = 1065353216;
  *(_OWORD *)(result + 120) = 0u;
  *(_OWORD *)(result + 136) = 0u;
  *((_DWORD *)result + 38) = 1065353216;
  if (a5 == 1) {
    *uint64_t v11 = 1;
  }
  *a1 = v11;
  a1[1] = result;
  return result;
}

void std::__shared_ptr_emplace<vision::mod::FaceID3Model>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<vision::mod::FaceID3Model>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7534D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::FaceID3Model>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7534D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::allocate_shared[abi:ne180100]<vision::mod::ImageDescriptorBufferFloat32,std::allocator<vision::mod::ImageDescriptorBufferFloat32>,std::vector<long long> &,void *,unsigned long const&,int,BOOL,void>(uint64_t *a1, void **a2, void *a3, unint64_t a4, int a5, char a6)
{
  uint64_t v12 = operator new(0x90uLL);
  v12[1] = 0;
  v12[2] = 0;
  *uint64_t v12 = &unk_1EF7539A0;
  uint64_t result = vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)(v12 + 3), a2, a3, a4, a5, a6 != 0);
  v12[3] = &unk_1EF752918;
  *((_DWORD *)v12 + 32) = 1;
  v12[17] = 0;
  v12[15] = a4 >> 2;
  *a1 = result;
  a1[1] = (uint64_t)v12;
  return result;
}

void sub_1A3F63D40(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1A3F63DD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F63F7C(_Unwind_Exception *a1)
{
  uint64_t v8 = v6;

  _Unwind_Resume(a1);
}

uint64_t Geometry2D_estimateRST(uint64_t a1, uint64_t a2, float *a3)
{
  uint64_t v3 = 1917;
  if (a3 && a1)
  {
    long long v5 = *(float **)a1;
    if (!*(void *)a1) {
      return 1917;
    }
    long long v6 = *(float **)(a1 + 8);
    if (!v6) {
      return 1917;
    }
    uint64_t v3 = 1917;
    if (!a2) {
      return v3;
    }
    int v8 = *(_DWORD *)(a1 + 16);
    if (v8 < 1) {
      return v3;
    }
    uint64_t v9 = *(float **)a2;
    if (!*(void *)a2) {
      return 1917;
    }
    id v10 = *(float **)(a2 + 8);
    if (!v10) {
      return 1917;
    }
    int v11 = *(_DWORD *)(a2 + 16);
    if (v11 < 1) {
      return 1917;
    }
    uint64_t v3 = 1916;
    if (v8 >= 2 && v8 == v11)
    {
      if (v8 == 2)
      {
        float v13 = v5[1];
        float v14 = *v5 - v13;
        float v15 = v6[1];
        float v16 = *v6 - v15;
        float v17 = (float)(v16 * v16) + (float)(v14 * v14);
        float v18 = v14 / v17;
        float v19 = v16 / v17;
        float v20 = v9[1];
        float v21 = *v9 - v20;
        float v22 = v10[1];
        float v23 = *v10 - v22;
        float v24 = (float)(v19 * v23) + (float)(v18 * v21);
        float v25 = (float)(v18 * v23) - (float)(v19 * v21);
        float v26 = (float)(v20 - (float)(v24 * v13)) + (float)(v25 * v15);
        float v27 = (float)(v22 - (float)(v24 * v15)) - (float)(v25 * v13);
        a3[1] = sqrtf((float)(v25 * v25) + (float)(v24 * v24));
        *a3 = atan2f(v25, v24);
        a3[2] = v26;
        a3[3] = v27;
        return 1920;
      }
      else
      {
        __A = 0;
        v47 = 0;
        vDSP_Length __N = 0;
        Geometry2D_mallocCart2D(&__A, v8);
        __B = 0;
        v44 = 0;
        uint64_t v45 = 0;
        Geometry2D_mallocCart2D(&__B, *(_DWORD *)(a2 + 16));
        uint64x2_t v29 = (float *)malloc_type_malloc(4 * *(int *)(a1 + 16), 0x100004052888210uLL);
        uint64_t v42 = 0;
        float v41 = 0.0;
        uint64_t v3 = Geometry2D_normalizePoints(a1, v29, (uint64_t)&__A, (float *)&v42 + 1, (float *)&v42, &v41);
        if ((v3 & 0x80) != 0)
        {
          float v40 = 0.0;
          uint64_t v39 = 0;
          uint64_t v3 = Geometry2D_normalizePoints(a2, v29, (uint64_t)&__B, &v40, (float *)&v39 + 1, (float *)&v39);
          if ((v3 & 0x80) != 0)
          {
            uint64_t __C = 0;
            vDSP_svesq(__A, 1, (float *)&__C + 1, *(int *)(a1 + 16));
            vDSP_svesq(v47, 1, (float *)&__C, *(int *)(a1 + 16));
            float v30 = *((float *)&__C + 1) + *(float *)&__C;
            uint64_t v37 = 0;
            vDSP_dotpr(__A, 1, __B, 1, (float *)&v37 + 1, (int)__N);
            vDSP_dotpr(v47, 1, v44, 1, (float *)&v37, (int)__N);
            float v31 = (float)(*((float *)&v37 + 1) + *(float *)&v37) / v30;
            uint64_t v36 = 0;
            vDSP_dotpr(v47, 1, __B, 1, (float *)&v36 + 1, (int)__N);
            vDSP_dotpr(__A, 1, v44, 1, (float *)&v36, (int)__N);
            float v32 = v31 * (float)(v41 / *(float *)&v39);
            float v33 = (float)((float)(*(float *)&v36 - *((float *)&v36 + 1)) / v30) * (float)(v41 / *(float *)&v39);
            float v34 = -(float)((float)((float)(v32 * *((float *)&v42 + 1)) - (float)(v33 * *(float *)&v42)) - v40);
            float v35 = -(float)((float)((float)(v32 * *(float *)&v42) + (float)(v33 * *((float *)&v42 + 1)))
                         - *((float *)&v39 + 1));
            a3[1] = v41 / *(float *)&v39;
            *a3 = atan2f(v33, v32);
            a3[2] = v34;
            a3[3] = v35;
            free(__A);
            __A = 0;
            free(v47);
            v47 = 0;
            LODWORD(__N) = 0;
            free(__B);
            __B = 0;
            free(v44);
            free(v29);
          }
        }
      }
    }
  }
  return v3;
}

uint64_t ctrTrackerComputation_repairNonValidRegion(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  LODWORD(v4) = *a4;
  if (*a4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = result;
    uint64_t v7 = a2;
    uint64_t v8 = a3;
    do
    {
      if ((int)v4 >= 1)
      {
        uint64_t v9 = 0;
        uint64_t v10 = v5 << 7;
        do
        {
          *(unsigned char *)(v6 + v9) = *(unsigned char *)(result + v10 + (int)v4);
          *(unsigned char *)(v7 + v9) = *(unsigned char *)(a2 + v10 + *a4);
          *(unsigned char *)(v8 + v9++) = *(unsigned char *)(a3 + v10 + *a4);
          uint64_t v4 = *a4;
        }
        while (v9 < v4);
      }
      ++v5;
      v8 += 128;
      v7 += 128;
      v6 += 128;
    }
    while (v5 != 128);
  }
  LODWORD(v11) = a4[2];
  if ((int)v11 <= 126)
  {
    uint64_t v12 = 0;
    uint64_t v13 = a3 + 1;
    uint64_t v14 = a2 + 1;
    for (uint64_t i = result + 1; ; i += 128)
    {
      if ((int)v11 <= 126)
      {
        uint64_t v16 = v12 << 7;
        uint64_t v11 = (int)v11;
        do
        {
          *(unsigned char *)(i + v11) = *(unsigned char *)(result + v16 + a4[2]);
          *(unsigned char *)(v14 + v11) = *(unsigned char *)(a2 + v16 + a4[2]);
          *(unsigned char *)(v13 + v11++) = *(unsigned char *)(a3 + v16 + a4[2]);
        }
        while (v11 != 127);
      }
      if (++v12 == 128) {
        break;
      }
      LODWORD(v11) = a4[2];
      v13 += 128;
      v14 += 128;
    }
  }
  if (a4[1] >= 1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    do
    {
      for (uint64_t j = 0; j != 128; ++j)
      {
        *(unsigned char *)(result + v17 + j) = *(unsigned char *)(result + ((uint64_t)a4[1] << 7) + j);
        *(unsigned char *)(a2 + v17 + j) = *(unsigned char *)(a2 + ((uint64_t)a4[1] << 7) + j);
        *(unsigned char *)(a3 + v17 + j) = *(unsigned char *)(a3 + ((uint64_t)a4[1] << 7) + j);
      }
      ++v18;
      v17 += 128;
    }
    while (v18 < a4[1]);
  }
  uint64_t v20 = a4[3];
  if ((int)v20 <= 126)
  {
    int v21 = (v20 << 7) + 128;
    do
    {
      uint64_t v22 = 0;
      ++v20;
      do
      {
        *(unsigned char *)(result + v21 + v22) = *(unsigned char *)(result + ((uint64_t)a4[3] << 7) + v22);
        *(unsigned char *)(a2 + v21 + v22) = *(unsigned char *)(a2 + ((uint64_t)a4[3] << 7) + v22);
        *(unsigned char *)(a3 + v21 + v22) = *(unsigned char *)(a3 + ((uint64_t)a4[3] << 7) + v22);
        ++v22;
      }
      while (v22 != 128);
      v21 += 128;
    }
    while (v20 != 127);
  }
  return result;
}

uint64_t ctrTrackerComputation_YCbCr2nRGB(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  for (uint64_t i = 0; i != 0x4000; ++i)
  {
    int v7 = *(unsigned __int8 *)(result + i);
    int v8 = *(unsigned __int8 *)(a2 + i) - 128;
    int v9 = *(unsigned __int8 *)(a3 + i) - 128;
    int v10 = 101 * v9 + (v7 << 6);
    if (v10 <= 16351) {
      unsigned int v11 = ((v10 + 32) >> 6) & ~((v10 + 32) >> 31);
    }
    else {
      unsigned int v11 = 255;
    }
    int v12 = -12 * v8 + (v7 << 6) - 30 * v9;
    if (v12 <= 16351) {
      unsigned int v13 = ((v12 + 32) >> 6) & ~((v12 + 32) >> 31);
    }
    else {
      unsigned int v13 = 255;
    }
    int v14 = 119 * v8 + (v7 << 6);
    if (v14 <= 16351) {
      unsigned int v15 = ((v14 + 32) >> 6) & ~((v14 + 32) >> 31);
    }
    else {
      unsigned int v15 = 255;
    }
    if (v13 <= v15) {
      unsigned int v16 = v15;
    }
    else {
      unsigned int v16 = v13;
    }
    if (v11 > v16) {
      unsigned int v16 = v11;
    }
    int v17 = ctrTrackerComputation_YCbCr2nRGB_kIlluminationInvariantLookupTable[v16];
    unsigned int v18 = v11 * v17;
    unsigned int v19 = v18 >> 4;
    unsigned int v20 = (v18 + 16) >> 5;
    if (v19 > 0x1FE) {
      LOBYTE(v20) = -1;
    }
    *(unsigned char *)(a4 + i) = v20;
    unsigned int v21 = v13 * v17;
    unsigned int v22 = v21 >> 4;
    unsigned int v23 = (v21 + 16) >> 5;
    if (v22 > 0x1FE) {
      LOBYTE(v23) = -1;
    }
    *(unsigned char *)(a5 + i) = v23;
    unsigned int v24 = v15 * v17;
    unsigned int v25 = v24 >> 4;
    unsigned int v26 = (v24 + 16) >> 5;
    if (v25 > 0x1FE) {
      LOBYTE(v26) = -1;
    }
    *(unsigned char *)(a6 + i) = v26;
  }
  return result;
}

uint64_t ctrTrackerComputation_normedGradient(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4 + 129;
  uint64_t v5 = a1 + 257;
  uint64_t v6 = a2 + 257;
  uint64_t v7 = a3 + 257;
  uint64_t v8 = 1;
  do
  {
    uint64_t v9 = 0;
    ++v8;
    do
    {
      int v10 = *(unsigned __int8 *)(v5 + v9 - 127) - *(unsigned __int8 *)(v5 + v9 - 129);
      int v11 = *(unsigned __int8 *)(v5 + v9) - *(unsigned __int8 *)(v5 + v9 - 256);
      int v12 = *(unsigned __int8 *)(v6 + v9) - *(unsigned __int8 *)(v6 + v9 - 256);
      int v13 = *(unsigned __int8 *)(v7 + v9) - *(unsigned __int8 *)(v7 + v9 - 256);
      if (v10 < 0) {
        int v10 = *(unsigned __int8 *)(v5 + v9 - 129) - *(unsigned __int8 *)(v5 + v9 - 127);
      }
      if (v11 < 0) {
        int v11 = *(unsigned __int8 *)(v5 + v9 - 256) - *(unsigned __int8 *)(v5 + v9);
      }
      unsigned int v14 = v11 + v10;
      if (*(unsigned __int8 *)(v6 + v9 - 127) - *(unsigned __int8 *)(v6 + v9 - 129) >= 0) {
        int v15 = *(unsigned __int8 *)(v6 + v9 - 127) - *(unsigned __int8 *)(v6 + v9 - 129);
      }
      else {
        int v15 = *(unsigned __int8 *)(v6 + v9 - 129) - *(unsigned __int8 *)(v6 + v9 - 127);
      }
      if (v12 < 0) {
        int v12 = *(unsigned __int8 *)(v6 + v9 - 256) - *(unsigned __int8 *)(v6 + v9);
      }
      unsigned int v16 = v12 + v15;
      if (*(unsigned __int8 *)(v7 + v9 - 127) - *(unsigned __int8 *)(v7 + v9 - 129) >= 0) {
        int v17 = *(unsigned __int8 *)(v7 + v9 - 127) - *(unsigned __int8 *)(v7 + v9 - 129);
      }
      else {
        int v17 = *(unsigned __int8 *)(v7 + v9 - 129) - *(unsigned __int8 *)(v7 + v9 - 127);
      }
      if (v13 >= 0) {
        uint64_t result = v13;
      }
      else {
        uint64_t result = *(unsigned __int8 *)(v7 + v9 - 256) - *(unsigned __int8 *)(v7 + v9);
      }
      unsigned int v19 = result + v17;
      if (v14 <= v16) {
        unsigned int v14 = v16;
      }
      if (v14 <= v19) {
        unsigned int v14 = v19;
      }
      if (v14 >= 0xFF) {
        LOBYTE(v14) = -1;
      }
      *(unsigned char *)(v4 + v9++) = v14;
    }
    while (v9 != 126);
    v4 += 128;
    v5 += 128;
    v6 += 128;
    v7 += 128;
  }
  while (v8 != 127);
  return result;
}

uint64_t ctrTrackerComputation_updateLocation(uint64_t result, uint64_t a2, int a3, int a4, double a5, double a6)
{
  uint64_t v6 = 0;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  v36[0] = 0;
  v36[1] = 0;
  int v37 = 0;
  uint64_t v7 = a4 - 2;
  do
  {
    if (v7 + v6 >= 128) {
      int v8 = -128;
    }
    else {
      int v8 = ((unint64_t)(v7 + v6) >> 56) & 0x80;
    }
    *((_DWORD *)v36 + v6) = *(_DWORD *)(result + 4 * (a4 + (a3 << 7) - 2 + (int)v6 + v8));
    ++v6;
  }
  while (v6 != 5);
  uint64_t v9 = 0;
  float v10 = 0.0;
  float v11 = 0.0;
  do
  {
    float v12 = *(float *)((char *)v36 + v9 * 4);
    float v11 = v11 + (float)(*(float *)&dword_1A410E938[v9] * v12);
    float v10 = v10 + (float)(*(float *)&dword_1A410E94C[v9++] * v12);
  }
  while (v9 != 5);
  if (v10 <= -0.0002)
  {
    float v13 = -2.0;
    if (v11 > 0.0 == v10 < 0.0)
    {
      float v13 = 2.0;
      if (v11 <= (float)(v10 * -8.0)) {
        float v13 = -2.0 - (float)(v11 / (float)(v10 + v10));
      }
    }
  }
  else
  {
    float v13 = NAN;
  }
  uint64_t v14 = 0;
  float v15 = v13 + (float)a4;
  int v16 = HIBYTE(a4) & 0x80;
  if (a4 >= 128) {
    int v16 = -128;
  }
  int v17 = v16 + a4;
  uint64_t v18 = a3 - 2;
  do
  {
    if (v18 + v14 >= 128) {
      int v19 = -128;
    }
    else {
      int v19 = ((unint64_t)(v18 + v14) >> 56) & 0x80;
    }
    *((_DWORD *)v36 + v14) = *(_DWORD *)(result + 4 * (v17 + ((a3 - 2 + (int)v14 + v19) << 7)));
    ++v14;
  }
  while (v14 != 5);
  uint64_t v20 = 0;
  float v21 = 0.0;
  float v22 = 0.0;
  do
  {
    float v23 = *(float *)((char *)v36 + v20 * 4);
    float v22 = v22 + (float)(*(float *)&dword_1A410E938[v20] * v23);
    float v21 = v21 + (float)(*(float *)&dword_1A410E94C[v20++] * v23);
  }
  while (v20 != 5);
  float v24 = 128.0;
  if (v15 < 64.0) {
    float v24 = 0.0;
  }
  float v25 = v15 - v24;
  if (v21 <= -0.0002)
  {
    float v26 = -2.0;
    if (v22 > 0.0 == v21 < 0.0)
    {
      float v26 = 2.0;
      if (v22 <= (float)(v21 * -8.0)) {
        float v26 = -2.0 - (float)(v22 / (float)(v21 + v21));
      }
    }
  }
  else
  {
    float v26 = NAN;
  }
  uint64_t v27 = 0;
  float v28 = v26 + (float)a3;
  float v29 = 128.0;
  if (v28 < 64.0) {
    float v29 = 0.0;
  }
  *(double *)&uint64_t v30 = -(float)(v28 - v29);
  float64x2_t v31 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(-v25), 0);
  float64x2_t v32 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a5, 0);
  float64x2_t v33 = (float64x2_t)vdupq_lane_s64(v30, 0);
  float64x2_t v34 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a6, 0);
  do
  {
    float v35 = (double *)(a2 + v27);
    float64x2x2_t v39 = vld2q_f64(v35);
    v39.val[0] = vmlaq_f64(v39.val[0], v32, v31);
    v39.val[1] = vmlaq_f64(v39.val[1], v34, v33);
    vst2q_f64(v35, v39);
    v27 += 32;
  }
  while (v27 != 64);
  return result;
}

void ctrTrackerComputation_colorHistogram(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, char *a5)
{
  bzero(a4, 0x400uLL);
  bzero(a5, 0x400uLL);
  uint64_t v11 = a3 + 5031;
  uint64_t v12 = a2 + 5031;
  uint64_t v13 = a1 + 5031;
  uint64_t v14 = 39;
  do
  {
    for (uint64_t i = 0; i != 50; ++i)
    {
      unsigned int v16 = *(unsigned __int8 *)(v13 + i);
      unsigned int v17 = *(unsigned __int8 *)(v12 + i);
      LOBYTE(v10) = *(unsigned char *)(v11 + i);
      double v18 = (float)((float)((float)v16 + (float)v17) + (float)v10);
      if (v18 < 0.01) {
        double v18 = 0.01;
      }
      float v19 = (double)v16 / v18;
      unsigned int v10 = 1132462080;
      int v20 = vcvtms_s32_f32(v19 * 256.0);
      float v21 = (double)v17 / v18;
      if (v20 >= 255) {
        int v20 = 255;
      }
      int v22 = vcvtms_s32_f32(v21 * 256.0);
      if (v22 >= 255) {
        int v22 = 255;
      }
      *(float *)&a4[4 * v20] = *(float *)&a4[4 * v20] + 1.0;
      *(float *)&a5[4 * v22] = *(float *)&a5[4 * v22] + 1.0;
    }
    ++v14;
    v11 += 128;
    v12 += 128;
    v13 += 128;
  }
  while (v14 != 89);
  for (uint64_t j = 0; j != 1024; j += 4)
  {
    *(float *)&a4[j] = *(float *)&a4[j] / 2500.0;
    *(float *)&a5[j] = *(float *)&a5[j] / 2500.0;
  }
}

float64x2_t ctrTrackerComputation_sizeAdaption(uint64_t a1, float64x2_t *a2, float *a3, uint64_t a4, float64x2_t *a5)
{
  uint64_t v160 = *MEMORY[0x1E4F143B8];
  v154 = (unsigned char *)(a1 + 250192);
  uint64_t v9 = a1 + 246072;
  unsigned int v10 = (float *)(a1 + 114688);
  uint64_t v11 = (unsigned __int8 *)(a1 + 84500);
  uint64_t v12 = (float *)(a1 + 248120);
  uint64_t v13 = -1024;
  do
  {
    *uint64_t v12 = sqrtf(*(float *)((char *)a2[64].f64 + v13));
    v12[256] = sqrtf(*(float *)((char *)a2[128].f64 + v13));
    ++v12;
    v13 += 4;
  }
  while (v13);
  uint64_t v14 = (int *)(a1 + 247096);
  bzero((void *)(a1 + 246072), 0x800uLL);
  for (uint64_t i = 20; i != 108; ++i)
  {
    unsigned int v17 = v11;
    uint64_t v18 = 88;
    do
    {
      unsigned int v19 = *(v17 - 0x8000);
      float v20 = (float)v19;
      double v21 = (double)v19;
      unsigned int v22 = *(v17 - 0x4000);
      unsigned int v23 = *v17++;
      double v24 = (float)((float)(v20 + (float)v22) + (float)v23);
      if (v24 < 0.01) {
        double v24 = 0.01;
      }
      float v25 = v21 / v24;
      int v26 = vcvtms_s32_f32(v25 * 256.0);
      double v27 = (double)v22;
      if (v26 >= 255) {
        int v28 = 255;
      }
      else {
        int v28 = v26;
      }
      float v29 = v27 / v24;
      int v30 = vcvtms_s32_f32(v29 * 256.0);
      if (v30 >= 255) {
        int v30 = 255;
      }
      ++*(_DWORD *)(v9 + 4 * v28);
      ++v14[v30];
      --v18;
    }
    while (v18);
    v11 += 128;
  }
  float64x2_t v32 = (float *)(v9 + 4);
  int v31 = *(_DWORD *)v9;
  float v33 = 0.0;
  uint64_t v34 = 255;
  do
  {
    uint64_t v35 = *(int *)v32;
    v31 += v35;
    float v33 = v33 + (float)(*(float *)(a4 + 4 * v35) * v32[512]);
    ++v32;
    --v34;
  }
  while (v34);
  float v36 = v33 / sqrtf((float)v31);
  *unsigned int v10 = v36;
  int v37 = *(_DWORD *)(v9 + 1024);
  uint64_t v38 = (float *)(v9 + 1028);
  float v39 = 0.0;
  uint64_t v40 = 255;
  do
  {
    uint64_t v41 = *(int *)v38;
    v37 += v41;
    float v39 = v39 + (float)(*(float *)(a4 + 4 * v41) * v38[512]);
    ++v38;
    --v40;
  }
  while (v40);
  float v42 = sqrtf((float)v37);
  uint64_t v43 = a1 + 84371;
  uint64_t v44 = a1 + 67987;
  uint64_t v45 = a1 + 51603;
  uint64_t v46 = a1 + 84460;
  uint64_t v47 = a1 + 68076;
  uint64_t v48 = a1 + 51692;
  uint64_t v49 = a1 + 95764;
  uint64_t v50 = a1 + 79380;
  uint64_t v51 = a1 + 62996;
  uint64_t v52 = a1 + 84372;
  uint64_t v53 = a1 + 67988;
  uint64_t v54 = a1 + 51604;
  uint64_t v55 = 1;
  float v56 = (float)(v36 + (float)(v39 / v42)) * 0.5;
  *unsigned int v10 = v56;
  uint64_t v57 = 11520;
  uint64_t v58 = 88;
  do
  {
    uint64_t v59 = 0;
    do
    {
      unsigned int v60 = *(unsigned __int8 *)(v45 + v59);
      float v61 = (float)v60;
      double v62 = (double)v60;
      unsigned int v63 = *(unsigned __int8 *)(v44 + v59);
      *(float *)&unsigned int v64 = (float)v63;
      LOBYTE(v64) = *(unsigned char *)(v43 + v59);
      double v65 = (float)((float)(v61 + (float)v63) + (float)v64);
      if (v65 < 0.01) {
        double v65 = 0.01;
      }
      float v66 = v62 / v65;
      int v67 = vcvtms_s32_f32(v66 * 256.0);
      double v68 = (double)v63;
      if (v67 >= 255) {
        int v69 = 255;
      }
      else {
        int v69 = v67;
      }
      float v70 = v68 / v65;
      int v71 = vcvtms_s32_f32(v70 * 256.0);
      ++*(_DWORD *)(v9 + 4 * v69);
      if (v71 >= 255) {
        int v72 = 255;
      }
      else {
        int v72 = v71;
      }
      ++v14[v72];
      unsigned int v73 = *(unsigned __int8 *)(v48 + v59);
      float v74 = (float)v73;
      double v75 = (double)v73;
      unsigned int v76 = *(unsigned __int8 *)(v47 + v59);
      *(float *)&unsigned int v77 = (float)v76;
      LOBYTE(v77) = *(unsigned char *)(v46 + v59);
      double v78 = (float)((float)(v74 + (float)v76) + (float)v77);
      if (v78 < 0.01) {
        double v78 = 0.01;
      }
      float v79 = v75 / v78;
      int v80 = vcvtms_s32_f32(v79 * 256.0);
      if (v80 >= 255) {
        int v80 = 255;
      }
      float v81 = (double)v76 / v78;
      int v82 = vcvtms_s32_f32(v81 * 256.0);
      if (v82 >= 255) {
        int v82 = 255;
      }
      ++*(_DWORD *)(v9 + 4 * v80);
      ++v14[v82];
      v59 += 128;
    }
    while (v57 != v59);
    uint64_t v83 = 0;
    do
    {
      unsigned int v84 = *(unsigned __int8 *)(v54 + v83);
      float v85 = (float)v84;
      double v86 = (double)v84;
      unsigned int v87 = *(unsigned __int8 *)(v53 + v83);
      *(float *)&unsigned int v88 = (float)v87;
      LOBYTE(v88) = *(unsigned char *)(v52 + v83);
      double v89 = (float)((float)(v85 + (float)v87) + (float)v88);
      if (v89 < 0.01) {
        double v89 = 0.01;
      }
      float v90 = v86 / v89;
      int v91 = vcvtms_s32_f32(v90 * 256.0);
      double v92 = (double)v87;
      if (v91 >= 255) {
        int v93 = 255;
      }
      else {
        int v93 = v91;
      }
      float v94 = v92 / v89;
      int v95 = vcvtms_s32_f32(v94 * 256.0);
      ++*(_DWORD *)(v9 + 4 * v93);
      if (v95 >= 255) {
        int v96 = 255;
      }
      else {
        int v96 = v95;
      }
      ++v14[v96];
      unsigned int v97 = *(unsigned __int8 *)(v51 + v83);
      float v98 = (float)v97;
      double v99 = (double)v97;
      unsigned int v100 = *(unsigned __int8 *)(v50 + v83);
      *(float *)&unsigned int v101 = (float)v100;
      LOBYTE(v101) = *(unsigned char *)(v49 + v83);
      double v102 = (float)((float)(v98 + (float)v100) + (float)v101);
      if (v102 < 0.01) {
        double v102 = 0.01;
      }
      float v103 = v99 / v102;
      int v104 = vcvtms_s32_f32(v103 * 256.0);
      if (v104 >= 255) {
        int v104 = 255;
      }
      float v105 = (double)v100 / v102;
      int v106 = vcvtms_s32_f32(v105 * 256.0);
      if (v106 >= 255) {
        int v106 = 255;
      }
      ++*(_DWORD *)(v9 + 4 * v104);
      ++v14[v106];
      ++v83;
    }
    while (v58 != v83);
    int v107 = *(_DWORD *)v9;
    float v108 = 0.0;
    v109 = (float *)(v9 + 4);
    uint64_t v110 = 255;
    do
    {
      uint64_t v111 = *(int *)v109;
      v107 += v111;
      float v108 = v108 + (float)(*(float *)(a4 + 4 * v111) * v109[512]);
      ++v109;
      --v110;
    }
    while (v110);
    float v112 = v108 / sqrtf((float)v107);
    v10[v55] = v112;
    int v113 = *v14;
    float v114 = 0.0;
    v115 = (float *)(v9 + 1028);
    uint64_t v116 = 255;
    do
    {
      uint64_t v117 = *(int *)v115;
      v113 += v117;
      float v114 = v114 + (float)(*(float *)(a4 + 4 * v117) * v115[512]);
      ++v115;
      --v116;
    }
    while (v116);
    v10[v55++] = (float)(v112 + (float)(v114 / sqrtf((float)v113))) * 0.5;
    v43 -= 129;
    v44 -= 129;
    v45 -= 129;
    v46 -= 127;
    v47 -= 127;
    v48 -= 127;
    v57 += 256;
    v58 += 2;
    v49 += 127;
    v50 += 127;
    v51 += 127;
    v52 -= 129;
    v53 -= 129;
    v54 -= 129;
  }
  while (v55 != 21);
  uint64_t v118 = 0;
  float v119 = v10[1];
  float v120 = (float)((float)(v119 * 0.19) + (float)(v56 * 0.79)) + (float)(*a3 * 0.02);
  v10[21] = v120;
  v121 = v10 + 21;
  v122 = v10;
  do
  {
    float v123 = (float)(*v122 * 0.19) + (float)(v119 * 0.6);
    float v119 = v122[2];
    v122[22] = (float)(v123 + (float)(v119 * 0.19)) + (float)(a3[v118 + 1] * 0.02);
    ++v122;
    ++v118;
  }
  while (v118 != 19);
  float v124 = (float)((float)(v10[19] * 0.19) + (float)(v10[20] * 0.79)) + (float)(a3[20] * 0.02);
  v10[41] = v124;
  float v125 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v10[22] * 0.0019763) + (float)(v120 * 0.0028233)) + (float)(v10[23] * 0.0012185)) + (float)(v10[24] * 0.00054979)) + (float)(v10[25] * -0.000029719)) + (float)(v10[26] * -0.00052007)) + (float)(v10[27] * -0.00092128)) + (float)(v10[28] * -0.0012333)) + (float)(v10[29] * -0.0014562)) + (float)(v10[30] * -0.0015899))
                                                                                               + (float)(v10[31] * -0.0016345))
                                                                                       + (float)(v10[32] * -0.0015899))
                                                                               + (float)(v10[33] * -0.0014562))
                                                                       + (float)(v10[34] * -0.0012333))
                                                               + (float)(v10[35] * -0.00092128))
                                                       + (float)(v10[36] * -0.00052007))
                                               + (float)(v10[37] * -0.000029719))
                                       + (float)(v10[38] * 0.00054979))
                               + (float)(v10[39] * 0.0012185))
                       + (float)(v10[40] * 0.0019763))
               + (float)(v124 * 0.0028233))
       * -1000.0;
  result.f64[0] = 0.0;
  if (v125 >= 0.0) {
    float v126 = v125;
  }
  else {
    float v126 = 0.0;
  }
  if (v125 <= 1.0) {
    float v127 = v126;
  }
  else {
    float v127 = 1.0;
  }
  *(float *)(v9 + 4112) = v127;
  if (*v154)
  {
    if (v127 >= *(float *)(v9 + 4116))
    {
      uint64_t v128 = 0;
      int v129 = 10;
      do
      {
        if (v121[v128] > *(float *)result.f64)
        {
          int v129 = v128;
          *(float *)result.f64 = v121[v128];
        }
        ++v128;
      }
      while (v128 != 21);
      unsigned int v130 = v129 - 2;
      result.f64[0] = 0.0;
      if (v130 < 0x11)
      {
        uint64_t v131 = 0;
        v132 = &v121[v130];
        float v133 = 0.0;
        do
        {
          float v134 = v132[v131];
          float v133 = v133 + (float)(*(float *)&dword_1A410E938[v131] * v134);
          *(float *)result.f64 = *(float *)result.f64 + (float)(*(float *)&dword_1A410E94C[v131++] * v134);
        }
        while (v131 != 5);
        if (*(float *)result.f64 <= -0.0002)
        {
          float v135 = 0.0;
          if (v133 > 0.0 == *(float *)result.f64 < 0.0)
          {
            float v135 = 4.0;
            if (v133 <= (float)(*(float *)result.f64 * -8.0)) {
              float v135 = v133 / (float)(*(float *)result.f64 * -2.0);
            }
          }
        }
        else
        {
          float v135 = NAN;
        }
        result.f64[0] = 0.0;
        if (fabsf(v135) != INFINITY)
        {
          float v151 = v135 + (float)(int)v130;
          LODWORD(result.f64[0]) = -4.0;
          if (v151 > 0.0)
          {
            LODWORD(result.f64[0]) = 4.0;
            if (v151 < 20.0)
            {
              float v152 = (float)((float)((float)(v151 - (float)(int)v151) * (float)((int)v151 + 1))
                           + (float)((float)(1.0 - (float)(v151 - (float)(int)v151)) * (float)(int)v151))
                   + -10.0;
              *(float *)result.f64 = (float)(v152 * 0.2) + (float)(v152 * 0.2);
            }
          }
        }
      }
    }
  }
  else
  {
    unsigned char *v154 = 1;
    *(float *)(v9 + 4116) = v127 * 0.5;
  }
  *(float *)result.f64 = *(float *)result.f64 / 20.0;
  if (*(float *)result.f64 != 0.0)
  {
    uint64_t v136 = 0;
    double v137 = (float)(*(float *)result.f64 + 1.0);
    float64x2_t v138 = a5[2];
    float64x2_t v139 = vsubq_f64(v138, *a5);
    __asm { FMOV            V2.2D, #0.5 }
    float64x2_t v145 = vmulq_f64(vaddq_f64(v138, *a5), _Q2);
    float64x2_t v146 = vmulq_f64(vmulq_n_f64(v139, v137), _Q2);
    float64x2_t v147 = vsubq_f64(v145, v146);
    float64_t v159 = v147.f64[1];
    float64x2_t v155 = v147;
    float64_t v156 = v147.f64[0];
    int8x16_t v148 = (int8x16_t)vaddq_f64(v145, v146);
    int8x16_t v157 = vextq_s8(v148, v148, 8uLL);
    int8x16_t v158 = v157;
    do
    {
      long long v149 = *(long long *)((char *)&v155 + v136 * 16 + 16);
      f64 = (_OWORD *)a5[v136].f64;
      _OWORD *f64 = *(float64x2_t *)((char *)&v155 + v136 * 16);
      f64[1] = v149;
      v136 += 2;
    }
    while (v136 != 4);
    float64x2_t result = vmulq_n_f64(a2[133], v137);
    a2[133] = result;
  }
  return result;
}

void sub_1A3F654C8(_Unwind_Exception *a1)
{
}

void sub_1A3F65A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1A3F65D48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F664A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F66790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A3F66B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F66D34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F67270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (v17) {
    operator delete(v17);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3F67694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F67778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F67864(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F67A64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F67B9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F67C54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F67CEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F67E24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F68018(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3F6817C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F68398(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id getVCPRequestRevisionPropertyKey(void)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v0 = (void **)getVCPRequestRevisionPropertyKeySymbolLoc(void)::ptr;
  uint64_t v8 = getVCPRequestRevisionPropertyKeySymbolLoc(void)::ptr;
  if (!getVCPRequestRevisionPropertyKeySymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)VideoProcessingLibrary();
    v6[3] = (uint64_t)dlsym(v1, "VCPRequestRevisionPropertyKey");
    getVCPRequestRevisionPropertyKeySymbolLoc(void)::ptr = v6[3];
    uint64_t v0 = (void **)v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (!v0)
  {
    dlerror();
    uint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v5, 8);
    _Unwind_Resume(v4);
  }
  uint64_t v2 = *v0;

  return v2;
}

void *___ZL41getVCPRequestRevisionPropertyKeySymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)VideoProcessingLibrary();
  float64x2_t result = dlsym(v2, "VCPRequestRevisionPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestRevisionPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t VideoProcessingLibrary()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!VideoProcessingLibraryCore(char **)::frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = ___ZL26VideoProcessingLibraryCorePPc_block_invoke_18103;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E5B1DB40;
    uint64_t v5 = 0;
    VideoProcessingLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
    uint64_t v1 = (void *)v3[0];
    uint64_t v0 = VideoProcessingLibraryCore(char **)::frameworkLibrary;
    if (VideoProcessingLibraryCore(char **)::frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      uint64_t v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return VideoProcessingLibraryCore(char **)::frameworkLibrary;
}

{
  uint64_t v0;
  void *v1;
  void v3[6];
  long long v4;
  uint64_t v5;
  uint64_t v6;

  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!VideoProcessingLibraryCore(char **)::frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = ___ZL26VideoProcessingLibraryCorePPc_block_invoke_19344;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E5B1DD18;
    uint64_t v5 = 0;
    VideoProcessingLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
    uint64_t v1 = (void *)v3[0];
    uint64_t v0 = VideoProcessingLibraryCore(char **)::frameworkLibrary;
    if (VideoProcessingLibraryCore(char **)::frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      uint64_t v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return VideoProcessingLibraryCore(char **)::frameworkLibrary;
}

{
  uint64_t v0;
  void *v1;
  void v3[6];
  long long v4;
  uint64_t v5;
  uint64_t v6;

  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!VideoProcessingLibraryCore(char **)::frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = ___ZL26VideoProcessingLibraryCorePPc_block_invoke_32743;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E5B1F628;
    uint64_t v5 = 0;
    VideoProcessingLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
    uint64_t v1 = (void *)v3[0];
    uint64_t v0 = VideoProcessingLibraryCore(char **)::frameworkLibrary;
    if (VideoProcessingLibraryCore(char **)::frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      uint64_t v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return VideoProcessingLibraryCore(char **)::frameworkLibrary;
}

uint64_t ___ZL26VideoProcessingLibraryCorePPc_block_invoke_18103()
{
  uint64_t result = _sl_dlopen();
  VideoProcessingLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void sub_1A3F687B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F688B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F68A94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

Class ___ZL32getVCPHumanPoseImageRequestClassv_block_invoke(uint64_t a1)
{
  VideoProcessingLibrary();
  Class result = objc_getClass("VCPHumanPoseImageRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getVCPHumanPoseImageRequestClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = (void *)abort_report_np();
    return (Class)+[VNEntityIdentificationModelTrainedModel supportsSecureCoding];
  }
  return result;
}

void sub_1A3F68C4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F68D2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F690C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F694B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3F69534()
{
}

void sub_1A3F698C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3F69CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ObjectTrackerEx::free(vision::mod::ObjectTrackerEx *this)
{
  uint64_t result = ctpl_trackerDelete(*((void **)this + 4));
  *((void *)this + 4) = 0;
  if (result == 128) {
    return 6784;
  }
  return result;
}

uint64_t vision::mod::ObjectTrackerEx::init(vision::mod::ObjectTrackerEx *this)
{
  uint64_t v2 = (char *)malloc_type_calloc(1uLL, 0x50uLL, 0x10200401EF7F3E0uLL);
  *((void *)this + 4) = v2;
  uint64_t v3 = (void *)((char *)this + 32);
  if (v2)
  {
    uint64_t v3 = v2 + 72;
    uint64_t result = 6784;
  }
  else
  {
    ctpl_trackerDelete(0);
    uint64_t result = 6779;
  }
  *uint64_t v3 = 0;
  return result;
}

uint64_t vision::mod::ObjectTrackerEx::update(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

uint64_t vision::mod::ObjectTrackerEx::track(uint64_t a1, __CVBuffer *a2, uint64_t *a3)
{
  uint64_t v391 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(float64x2_t **)(a1 + 32);
  if (!v3) {
    return 6751;
  }
  uint64_t v5 = a1;
  float64_t v6 = v3[4].f64[1];
  *(unsigned char *)(*(void *)&v6 + 44968) = 1;
  *(_DWORD *)(*(void *)&v6 + 44980) = 0;
  *(_OWORD *)(*(void *)&v6 + 44988) = 0u;
  *(_OWORD *)(*(void *)&v6 + 45004) = 0u;
  *(_DWORD *)(*(void *)&v6 + 45020) = 0;
  float64x2_t v7 = v3[2];
  float64x2_t v8 = *v3;
  __asm { FMOV            V3.2D, #23.0 }
  float64x2_t v365 = _Q3;
  float32x2_t v14 = vcvt_f32_f64(vdivq_f64(vsubq_f64(v7, *v3), _Q3));
  *(int32x2_t *)(*(void *)&v6 + 44996) = vrev64_s32((int32x2_t)v14);
  *(_OWORD *)(*(void *)&v6 + 45004) = xmmword_1A410C260;
  __asm { FMOV            V3.2S, #24.0 }
  float64x2_t v15 = vcvtq_f64_f32(vmul_f32(v14, *(float32x2_t *)&_Q3.f64[0]));
  float64x2_t v16 = vsubq_f64(v8, v15);
  float64x2_t v17 = vaddq_f64(v7, v15);
  v15.f64[0] = v17.f64[0];
  v15.f64[1] = v16.f64[1];
  v380[0] = v16;
  v380[1] = v15;
  v16.f64[1] = v17.f64[1];
  v380[2] = v17;
  v380[3] = v16;
  uint64_t PeakXY = tplTrackerResampler_setImage(*(void *)(*(void *)&v6 + 341240), a2, (double *)v380);
  uint64_t v19 = PeakXY;
  if (PeakXY != 128) {
    goto LABEL_278;
  }
  v366 = v3;
  uint64_t v368 = v5;
  float v20 = a3;
  v358 = (uint64_t *)(*(void *)&v6 + 341240);
  v372 = (float32x2_t *)(*(void *)&v6 + 44980);
  tplTrackerResampler_resample(*(void *)(*(void *)&v6 + 341240), (double *)v380, *(_DWORD *)(*(void *)&v6 + 45012), *(_DWORD *)(*(void *)&v6 + 45016), *(void *)&v6 + 45040, (unsigned char *)(*(void *)&v6 + 50224), (unsigned char *)(*(void *)&v6 + 55408), (int *)(*(void *)&v6 + 45024), *(float *)(*(void *)&v6 + 44996), *(float *)(*(void *)&v6 + 45000));
  v355 = (unsigned __int8 *)(*(void *)&v6 + 50224);
  v356 = (unsigned __int8 *)(*(void *)&v6 + 45040);
  v357 = (unsigned __int8 *)(*(void *)&v6 + 55408);
  tplTracker_YCbCr2RGB((unsigned __int8 *)(*(void *)&v6 + 45040), (unsigned __int8 *)(*(void *)&v6 + 50224), (unsigned __int8 *)(*(void *)&v6 + 55408), *(_DWORD *)(*(void *)&v6 + 45016) * *(_DWORD *)(*(void *)&v6 + 45012), (unsigned char *)(*(void *)&v6 + 60592), (unsigned char *)(*(void *)&v6 + 65776), (unsigned char *)(*(void *)&v6 + 70960));
  v361 = (unsigned __int8 *)(*(void *)&v6 + 70960);
  v362 = (unsigned __int8 *)(*(void *)&v6 + 65776);
  v359 = (int *)(*(void *)&v6 + 45024);
  uint64_t v360 = *(void *)&v6 + 88152;
  tplTracker_computeNormedGradient(*(void *)&v6 + 60592, *(void *)&v6 + 65776, *(void *)&v6 + 70960, *(_DWORD *)(*(void *)&v6 + 45012), *(_DWORD *)(*(void *)&v6 + 45016), (int *)(*(void *)&v6 + 45024), *(void *)&v6 + 88152);
  int v21 = *(_DWORD *)(*(void *)&v6 + 45016);
  if (v21 > 95)
  {
    uint64_t v63 = 6780;
    uint64_t v3 = v366;
    goto LABEL_44;
  }
  v363 = a3;
  unsigned int v22 = (char *)(*(void *)&v6 + 114652);
  unsigned int v23 = (char *)(*(void *)&v6 + 93336);
  uint64_t v24 = *(unsigned int *)(*(void *)&v6 + 45012);
  int v25 = v21 + 1;
  float v26 = *(float *)(*(void *)&v6 + 42064);
  float v27 = *(float *)(*(void *)&v6 + 42068);
  float v28 = *(float *)(*(void *)&v6 + 42072);
  int v29 = v21 + 2;
  v350 = (unsigned char *)(*(void *)&v6 + 60592);
  uint64_t PeakXY = calculateIntegralImage((unsigned __int8 *)(*(void *)&v6 + 60592), v21, v24, v21, v21 + 1, (_DWORD *)(*(void *)&v6 + 93336 + 4 * (v21 + 2)));
  if (PeakXY == 128)
  {
    uint64_t PeakXY = calculateIntegralImage(v362, v21, v24, v21, v21 + 1, &v22[4 * v29]);
    if (PeakXY == 128)
    {
      uint64_t PeakXY = calculateIntegralImage(v361, v21, v24, v21, v21 + 1, (_DWORD *)(*(void *)&v6 + 135968 + 4 * v29));
      if (PeakXY == 128)
      {
        uint64_t v35 = (float *)(*(void *)&v6 + 78548);
        uint64_t v36 = 4 * v25;
        if ((v24 & 0x80000000) == 0)
        {
          uint64_t v37 = v24 + 1;
          float64_t v38 = v6;
          do
          {
            *(_DWORD *)(*(void *)&v38 + 93336) = 0;
            *(_DWORD *)(*(void *)&v38 + 114652) = 0;
            *(_DWORD *)(*(void *)&v38 + 135968) = 0;
            *(void *)&v38 += v36;
            --v37;
          }
          while (v37);
        }
        int __dst = v24 - 23;
        bzero(v23, 4 * v25);
        bzero(v22, 4 * v25);
        bzero((void *)(*(void *)&v6 + 135968), 4 * v25);
        if ((int)v24 < 24)
        {
          v30.i64[0] = 0;
          LODWORD(v31) = 1212055744;
          int v49 = v21 - 23;
        }
        else
        {
          int v39 = 0;
          int v40 = *(_DWORD *)(*(void *)&v6 + 45036) + 1;
          uint64_t v41 = *(void *)&v6 + 72 * v25;
          uint64_t v42 = v41 + 136040;
          uint64_t v43 = *(void *)&v6 + 24 * v25;
          uint64_t v44 = v43 + 136040;
          uint64_t v45 = v43 + 93360;
          uint64_t v46 = v41 + 93360;
          uint64_t v47 = v43 + 114676;
          uint64_t v48 = v41 + 114676;
          int v49 = v21 - 23;
          v30.i64[0] = 0;
          LODWORD(v31) = 1212055744;
          LODWORD(v32) = 1.0;
          uint64_t v50 = *(void *)&v6 + 78548;
          do
          {
            int v51 = v40;
            if (v39 + 6 <= v40)
            {
              int v51 = *(_DWORD *)(*(void *)&v6 + 45028);
              if (v39 + 6 > v51) {
                int v51 = v39 + 6;
              }
            }
            int v52 = v40;
            if (v39 + 18 <= v40)
            {
              int v52 = *(_DWORD *)(*(void *)&v6 + 45028);
              if (v39 + 18 > v52) {
                int v52 = v39 + 18;
              }
            }
            int v53 = v52 - v51;
            if (v53 < 1) {
              double v33 = 0.0;
            }
            else {
              *(float *)&double v33 = 1.0 / (float)v53;
            }
            if (v21 >= 24)
            {
              uint64_t v54 = 0;
              uint64_t v55 = 0;
              uint64_t v56 = *(int *)(*(void *)&v6 + 45032) + 1;
              do
              {
                int v57 = v56;
                if (v55 + 6 <= v56)
                {
                  int v57 = *v359;
                  if ((int)v55 + 6 > *v359) {
                    int v57 = v55 + 6;
                  }
                }
                int v58 = v56;
                if ((int)v56 >= (int)v55 + 18)
                {
                  int v58 = *v359;
                  if ((int)v55 + 18 > *v359) {
                    int v58 = v55 + 18;
                  }
                }
                int v59 = v58 - v57;
                if (v59 < 1) {
                  v34.i64[0] = 0;
                }
                else {
                  *(float *)v34.i32 = 1.0 / (float)v59;
                }
                *(float *)v34.i32 = *(float *)&v33 * *(float *)v34.i32;
                if (*(float *)v34.i32 > 0.0)
                {
                  unsigned int v60 = *(_DWORD *)(v45 + v54)
                      - (*(_DWORD *)(v45 + v54 + 48)
                       + *(_DWORD *)(v46 + v54))
                      + *(_DWORD *)(v46 + v54 + 48);
                  unsigned int v61 = *(_DWORD *)(v47 + v54)
                      - (*(_DWORD *)(v47 + v54 + 48)
                       + *(_DWORD *)(v48 + v54))
                      + *(_DWORD *)(v48 + v54 + 48);
                  float v62 = (float)(*(_DWORD *)(v44 + v54 - 48)
                                            - (*(_DWORD *)(v44 + v54)
                                             + *(_DWORD *)(v42 + v54 - 48))
                                            + *(_DWORD *)(v42 + v54));
                  *(float *)v34.i32 = (float)((float)((float)((float)(*(float *)v34.i32 * (float)v60) - v26)
                                                    * (float)((float)(*(float *)v34.i32 * (float)v60) - v26))
                                            + (float)((float)((float)(*(float *)v34.i32 * (float)v61) - v27)
                                                    * (float)((float)(*(float *)v34.i32 * (float)v61) - v27)))
                                    + (float)((float)((float)(*(float *)v34.i32 * v62) - v28)
                                            * (float)((float)(*(float *)v34.i32 * v62) - v28));
                  *(_DWORD *)(v50 + v54) = v34.i32[0];
                  if (*(float *)v34.i32 > *(float *)v30.i32) {
                    v30.i32[0] = v34.i32[0];
                  }
                  if (*(float *)v34.i32 < *(float *)&v31) {
                    *(float *)&double v31 = *(float *)v34.i32;
                  }
                }
                ++v55;
                v54 += 4;
              }
              while (4 * (v21 - 23) != v54);
            }
            ++v39;
            v50 += 4 * (v21 - 23);
            v42 += v36;
            v44 += v36;
            v45 += v36;
            v46 += v36;
            v47 += v36;
            v48 += v36;
          }
          while (v39 != __dst);
          uint64_t v63 = 6780;
          a3 = v363;
          uint64_t v3 = v366;
          if (*(float *)&v31 < 0.0 || *(float *)v30.i32 < 0.0) {
            goto LABEL_279;
          }
        }
        uint64_t v64 = (v49 * __dst);
        if ((int)v64 >= 1)
        {
          float v65 = sqrtf(*(float *)&v31);
          float v66 = sqrtf(*(float *)v30.i32);
          LODWORD(v32) = 1060320051;
          *(float *)v30.i32 = fminf((float)(v65 + (float)((float)(v66 - v65) * 0.7))* (float)(v65 + (float)((float)(v66 - v65) * 0.7)), 1600.0);
          int v67 = (BOOL *)(*(void *)&v6 + 76144);
          do
          {
            float v68 = *v35++;
            *(float *)&double v31 = v68;
            *v67++ = v68 > *(float *)v30.i32;
            --v64;
          }
          while (v64);
        }
      }
    }
  }
  uint64_t v19 = PeakXY;
  a3 = v363;
  uint64_t v3 = v366;
  if (PeakXY != 128) {
    goto LABEL_278;
  }
  if (*(_DWORD *)(*(void *)&v6 + 45016) != 72 || *(_DWORD *)(*(void *)&v6 + 45012) != 72) {
    goto LABEL_116;
  }
  int v69 = 0;
  float v70 = (float *)(*(void *)&v6 + 178600);
  uint64_t v71 = *(void *)&v6 + 216828;
  uint64_t v72 = *(void *)&v6 + 88152;
  do
  {
    uint64_t v73 = 0;
    uint64_t v74 = v71;
    do
    {
      *(void *)(v74 - 4) = *(unsigned char *)(v72 + v73++) & 0xF0;
      v74 += 8;
    }
    while (v73 != 72);
    v72 += 72;
    ++v69;
    v71 += 576;
  }
  while (v69 != 72);
  v347 = (char *)(*(void *)&v6 + 197808);
  __dsta = (void *)(*(void *)&v6 + 299768);
  int v75 = 72;
  uint64_t v76 = *(void *)&v6 + 258296;
  uint64_t v77 = *(void *)&v6 + 216824;
  do
  {
    uint64_t v78 = tplTracker_FFT_3324(v77, v76, *(double *)v30.i64, v31, v32, v33, v34);
    if (v78 != 128)
    {
      uint64_t PeakXY = v78;
      goto LABEL_68;
    }
    v77 += 576;
    v76 += 576;
    --v75;
  }
  while (v75);
  int v79 = 0;
  uint64_t v80 = *(void *)&v6 + 299768;
  uint64_t v81 = *(void *)&v6 + 258296;
  do
  {
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    do
    {
      *(void *)(v80 + v82) = *(void *)(v81 + v83);
      v83 += 8;
      v82 += 576;
    }
    while (v83 != 576);
    v81 += 576;
    v80 += 8;
    ++v79;
  }
  while (v79 != 72);
  uint64_t v84 = 72;
  uint64_t v85 = *(void *)&v6 + 258296;
  uint64_t v86 = *(void *)&v6 + 299768;
  while (1)
  {
    uint64_t PeakXY = tplTracker_FFT_3324(v86, v85, *(double *)v30.i64, v31, v32, v33, v34);
    if (PeakXY != 128) {
      break;
    }
    v86 += 576;
    v85 += 576;
    if (!--v84)
    {
      memcpy(__dsta, (const void *)(*(void *)&v6 + 258296), 0xA200uLL);
      break;
    }
  }
LABEL_68:
  a3 = v363;
  uint64_t v5 = v368;
  if (PeakXY == 128)
  {
    uint64_t v87 = 5184;
    unsigned int v88 = *(int **)&v6;
    double v89 = (_DWORD *)(*(void *)&v6 + 216824);
    do
    {
      uint64_t v90 = (v88[74942] + 4) >> 3;
      uint64_t v91 = (v88[74943] + 4) >> 3;
      uint64_t v92 = (v88[146] + 4) >> 3;
      uint64_t v93 = (v88[147] + 4) >> 3;
      *double v89 = (unint64_t)(26512144 * ((int)v92 * (uint64_t)(int)v90 - (int)v93 * (uint64_t)(int)v91) + 0x40000000) >> 31;
      v89[1] = (unint64_t)(26512144 * ((int)v92 * (uint64_t)(int)v91 + (int)v93 * (uint64_t)(int)v90) + 0x40000000) >> 31;
      v89 += 2;
      v88 += 2;
      --v87;
    }
    while (v87);
    uint64_t PeakXY = tplTracker_IFFT_2D(*(void *)&v6 + 216824, (char *)(*(void *)&v6 + 258296), __dsta, v30);
    if (PeakXY == 128)
    {
      float v20 = v363;
      int v94 = 0;
      uint64_t v95 = 299768;
      int v96 = (float *)(*(void *)&v6 + 197808);
      uint64_t v97 = *(void *)&v6 + 197808;
      uint64_t v3 = v366;
      uint64_t v98 = *(void *)&v6 + 44980;
      do
      {
        uint64_t v99 = 0;
        uint64_t v100 = v95;
        do
        {
          *(float *)(v97 + v99) = (float)*(int *)(*(void *)&v6 + v100);
          v99 += 4;
          v100 += 8;
        }
        while (v99 != 196);
        v97 += 196;
        ++v94;
        v95 += 576;
      }
      while (v94 != 49);
      if (v6 != 0.0)
      {
        int v101 = *(_DWORD *)(*(void *)&v6 + 45012);
        uint64_t v102 = *(int *)(*(void *)&v6 + 45016);
        int v103 = v102 + 1;
        if ((v102 & 0x80000000) == 0)
        {
          int v104 = (_DWORD *)(*(void *)&v6 + 93336);
          float v105 = (_DWORD *)(*(void *)&v6 + 114652);
          uint64_t v106 = (v102 + 1);
          do
          {
            *v104++ = 0;
            *v105++ = 0;
            --v106;
          }
          while (v106);
        }
        int v107 = v102 - 23;
        uint64_t v108 = 4 * v103;
        if (v101 >= 1)
        {
          uint64_t v109 = *(void *)&v6 + 4 * v103;
          uint64_t v110 = v109 + 114652;
          uint64_t v111 = v109 + 93336;
          int v112 = 1;
          uint64_t v113 = *(void *)&v6 + 93336;
          uint64_t v114 = *(void *)&v6 + 114652;
          uint64_t v115 = *(void *)&v6 + 88152;
          do
          {
            if ((int)v102 < 1)
            {
              int v118 = 0;
              int v117 = 0;
            }
            else
            {
              uint64_t v116 = 0;
              int v117 = 0;
              int v118 = 0;
              do
              {
                int v119 = *(unsigned char *)(v115 + v116) & 0xF0;
                *(_DWORD *)(v111 + 4 * v116) = *(_DWORD *)(v113 + 4 * v116) + v118;
                *(_DWORD *)(v110 + 4 * v116) = *(_DWORD *)(v114 + 4 * v116) + v117;
                v118 += v119;
                v117 += v119 * v119;
                ++v116;
              }
              while (v102 != v116);
            }
            int v120 = *(_DWORD *)(v113 + 4 * v102);
            v113 += v108;
            *(_DWORD *)(v113 + 4 * v102) = v120 + v118;
            int v121 = *(_DWORD *)(v114 + 4 * v102);
            v114 += v108;
            *(_DWORD *)(v114 + 4 * v102) = v121 + v117;
            v115 += v102;
            v110 += v108;
            v111 += v108;
            _ZF = v112++ == v101;
          }
          while (!_ZF);
        }
        uint64_t v122 = 0;
        int v123 = 24 * v103;
        float v124 = &v23[96 * v103];
        uint64_t v125 = 4 * v107;
        uint64_t v126 = 4 * v123 + 114676 + *(void *)&v6 + 72;
        uint64_t v127 = *(void *)&v6 + 178600;
        do
        {
          for (uint64_t i = 0; i != 196; i += 4)
          {
            float v129 = (float)(*(_DWORD *)&v23[i]
                                       - (*(_DWORD *)&v23[i + 96]
                                        + *(_DWORD *)&v124[i])
                                       + *(_DWORD *)&v124[i + 96])
                 * 0.0017361;
            unsigned int v130 = (float *)(v127 + i);
            *unsigned int v130 = sqrtf((float)((float)(*(_DWORD *)&v22[i]- (*(_DWORD *)&v22[i + 96]+ *(_DWORD *)(v126 + i - 96))+ *(_DWORD *)(v126 + i))* 0.0017361)- (float)(v129 * v129));
            v130[2401] = v129;
          }
          ++v122;
          v23 += v108;
          v127 += v125;
          v126 += v108;
          v22 += v108;
          v124 += v108;
        }
        while (v122 != 49);
        int v132 = *(_DWORD *)(*(void *)&v6 + 45012);
        int v131 = *(_DWORD *)(*(void *)&v6 + 45016);
        int v133 = v132 - 23;
        int v134 = v131 - 23;
        LODWORD(v135) = (v131 - 23) * (v132 - 23);
        uint64_t v136 = *(void *)&v6 + 42056;
        double v137 = (unsigned char *)(*(void *)&v6 + 76144);
        if ((int)v135 >= 1)
        {
          float v139 = *(float *)(*(void *)&v6 + 42056);
          float v138 = *(float *)(*(void *)&v6 + 42060);
          uint64_t v140 = (v134 * v133);
          v141 = (float *)(*(void *)&v6 + 197808);
          do
          {
            float v142 = v138 * fmaxf(*v70, v138 * 0.5);
            if (v142 == 0.0 || *v137)
            {
              float *v141 = 0.0;
            }
            else
            {
              float v143 = (float)((float)(v142 + (float)(v139 * v70[2401])) + (float)(*v141 * -0.0017361))
                   / (float)(v142 + v142);
              float v144 = 1.0 - sqrtf(v143);
              if (v143 <= 0.0) {
                float v145 = 1.0;
              }
              else {
                float v145 = v144;
              }
              float *v141 = fmaxf(v145, 0.0);
            }
            ++v141;
            ++v70;
            ++v137;
            --v140;
          }
          while (v140);
        }
        goto LABEL_107;
      }
      uint64_t v63 = 6780;
LABEL_44:
      a3 = v20;
      goto LABEL_279;
    }
  }
  uint64_t v19 = PeakXY;
  uint64_t v3 = v366;
  if (PeakXY != 128) {
    goto LABEL_278;
  }
  if (v6 == 0.0)
  {
LABEL_116:
    uint64_t v63 = 6780;
    goto LABEL_279;
  }
  float v20 = v363;
  uint64_t v98 = *(void *)&v6 + 44980;
  int v132 = *(_DWORD *)(*(void *)&v6 + 45012);
  int v131 = *(_DWORD *)(*(void *)&v6 + 45016);
  int v133 = v132 - 23;
  int v134 = v131 - 23;
  LODWORD(v135) = (v131 - 23) * (v132 - 23);
  uint64_t v136 = *(void *)&v6 + 42056;
  int v96 = (float *)(*(void *)&v6 + 197808);
LABEL_107:
  if ((int)v135 < 1)
  {
    float v147 = 1.1755e-38;
    float v150 = 3.4028e38;
    long long v149 = (int *)(*(void *)&v6 + 45024);
  }
  else
  {
    uint64_t v135 = v135;
    float v146 = 3.4028e38;
    float v147 = 1.1755e-38;
    int8x16_t v148 = v96;
    long long v149 = (int *)(*(void *)&v6 + 45024);
    do
    {
      float v150 = *v148;
      if (*v148 == 0.0) {
        goto LABEL_113;
      }
      if (v150 > v147) {
        float v147 = *v148;
      }
      if (v150 >= v146) {
LABEL_113:
      }
        float v150 = v146;
      ++v148;
      float v146 = v150;
      --v135;
    }
    while (v135);
  }
  if (v147 < (float)(v150 + 0.000001))
  {
    *(_DWORD *)(v98 + 40) = 0;
    __dstb = (_DWORD *)(v98 + 40);
LABEL_120:
    *(unsigned char *)(v136 + 2912) = 0;
LABEL_121:
    uint64_t v151 = 0;
    uint64_t v152 = *(void *)&v6 + 8;
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v348 = _Q1;
    float32x2_t v154 = vcvt_f32_f64(vaddq_f64(vmulq_f64(vaddq_f64(*v3, v3[2]), _Q1), vcvtq_f64_f32(*(float32x2_t *)(v98 + 8))));
    __asm { FMOV            V8.2S, #11.5 }
    float32x2_t v156 = vmul_f32(*(float32x2_t *)(v98 + 16), _D8);
    float32x2_t v371 = *(float32x2_t *)(v98 + 16);
    do
    {
      float v157 = 1.0 - kTrackerSizeChangeScale[v151];
      float v158 = v371.f32[0] * v157;
      float v159 = v371.f32[1] * v157;
      float32x2_t v160 = (float32x2_t)vrev64_s32((int32x2_t)vmul_n_f32(v156, v157));
      float64x2_t v161 = vcvtq_f64_f32(vsub_f32(v154, v160));
      float64x2_t v162 = vcvtq_f64_f32(vadd_f32(v160, v154));
      *(float64_t *)&long long v163 = v162.f64[0];
      *((void *)&v163 + 1) = *(void *)&v161.f64[1];
      *(float64x2_t *)__p = v161;
      long long v377 = v163;
      v161.f64[1] = v162.f64[1];
      float64x2_t v378 = v162;
      float64x2_t v379 = v161;
      tplTrackerResampler_resample(*v358, (double *)__p, 0x18u, 24, (uint64_t)v356, v355, v357, v149, v158, v159);
      tplTracker_YCbCr2RGB(v356, v355, v357, 576, v350, v362, v361);
      uint64_t v164 = v360;
      tplTracker_computeNormedGradient((uint64_t)v350, (uint64_t)v362, (uint64_t)v361, 24, 24, v149, v360);
      unsigned int v165 = 0;
      unsigned int v166 = 0;
      unsigned int v167 = 0;
      uint64_t v168 = 0;
      float v169 = *(float *)(v136 + 4);
      uint64_t v170 = v152;
      do
      {
        for (uint64_t j = 0; j != 24; ++j)
        {
          int v172 = *(unsigned char *)(v164 + j) & 0xF0;
          v165 += v172;
          v166 += v172 * v172;
          v167 += (*(unsigned char *)(v170 + j) & 0xF0) * v172;
        }
        v164 += 24;
        v170 += 24;
        ++v168;
      }
      while (v168 != 24);
      float v173 = (float)v165 / 576.0;
      float v174 = (float)((float)v166 / 576.0) - (float)(v173 * v173);
      if (v174 < 0.0) {
        float v174 = 0.0;
      }
      float v175 = sqrtf(v174);
      float v176 = (float)((float)((float)v167 / -576.0) + (float)(v169 * v175)) + (float)(*(float *)v136 * v173);
      float v177 = (float)(v169 + v169) * v175;
      if (v177 < 0.00000011921) {
        float v177 = 0.00000011921;
      }
      float v178 = v176 / v177;
      if (v178 < 0.0) {
        float v178 = 0.0;
      }
      *((float *)&v381 + v151) = (float)(1.0 - sqrtf(v178)) * kTrackerSizeChangePenalty[v151];
      ++v151;
      long long v149 = v359;
    }
    while (v151 != 11);
    float v179 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*((float *)&v381 + 1)
                                                                                                 * 0.006993)
                                                                                         + (float)(*(float *)&v381
                                                                                                 * 0.017483))
                                                                                 + (float)(v382 * -0.0011655))
                                                                         + (float)(v383 * -0.006993))
                                                                 + (float)(v384 * -0.01049))
                                                         + (float)(v385 * -0.011655))
                                                 + (float)(v386 * -0.01049))
                                         + (float)(v387 * -0.006993))
                                 + (float)(v388 * -0.0011655))
                         + (float)(v389 * 0.006993))
                 + (float)(v390 * 0.017483))
         * -100.0;
    float v180 = 0.0;
    if (v179 >= 0.0) {
      float v181 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*((float *)&v381 + 1) * 0.006993)
    }
                                                                                           + (float)(*(float *)&v381 * 0.017483))
                                                                                   + (float)(v382 * -0.0011655))
                                                                           + (float)(v383 * -0.006993))
                                                                   + (float)(v384 * -0.01049))
                                                           + (float)(v385 * -0.011655))
                                                   + (float)(v386 * -0.01049))
                                           + (float)(v387 * -0.006993))
                                   + (float)(v388 * -0.0011655))
                           + (float)(v389 * 0.006993))
                   + (float)(v390 * 0.017483))
           * -100.0;
    else {
      float v181 = 0.0;
    }
    if (v179 <= 1.0) {
      float v182 = v181;
    }
    else {
      float v182 = 1.0;
    }
    v372->f32[1] = v182;
    uint64_t v3 = v366;
    if (v182 >= 0.3)
    {
      uint64_t v183 = 0;
      int v184 = 5;
      do
      {
        if (*((float *)&v381 + v183) > v180)
        {
          int v184 = v183;
          float v180 = *((float *)&v381 + v183);
        }
        ++v183;
      }
      while (v183 != 11);
      int v185 = v184 - 2;
      if ((v184 - 2) >= 7)
      {
        float v293 = kTrackerSizeChangeScale[v184];
      }
      else
      {
        uint64_t v186 = 0;
        float v187 = 0.0;
        float v188 = 0.0;
        do
        {
          float v189 = *(float *)((char *)&v381 + 4 * v185 + v186 * 4);
          float v188 = v188 + (float)(*(float *)&dword_1A410E938[v186] * v189);
          float v187 = v187 + (float)(*(float *)&dword_1A410E94C[v186++] * v189);
        }
        while (v186 != 5);
        if (v187 <= -0.005)
        {
          float v190 = 0.0;
          if (v188 > 0.0 == v187 < 0.0)
          {
            float v190 = 4.0;
            if (v188 <= (float)(v187 * -8.0)) {
              float v190 = v188 / (float)(v187 * -2.0);
            }
          }
        }
        else
        {
          float v190 = NAN;
        }
        float v293 = 0.0;
        if (fabsf(v190) != INFINITY)
        {
          float v294 = v190 + (float)v185;
          if (v294 <= 0.0)
          {
            float v293 = -0.1;
          }
          else if (v294 >= 10.0)
          {
            float v293 = 0.1;
          }
          else
          {
            float v293 = (float)((float)(v294 - (float)(int)v294) * kTrackerSizeChangeScale[(int)v294 + 1])
                 + (float)((float)(1.0 - (float)(v294 - (float)(int)v294)) * kTrackerSizeChangeScale[v294]);
          }
        }
      }
      v372[2] = vmul_n_f32(v371, 1.0 - v293);
    }
    if (*__dstb == 1)
    {
      float32x2_t v341 = vcvt_f32_f64(vaddq_f64(vmulq_f64(vaddq_f64(*v366, v366[2]), v348), vcvtq_f64_f32(v372[1])));
      float32x2_t v342 = (float32x2_t)vrev64_s32((int32x2_t)vmul_f32(v372[2], _D8));
      float64x2_t v343 = vcvtq_f64_f32(vsub_f32(v341, v342));
      float64x2_t v344 = vcvtq_f64_f32(vadd_f32(v342, v341));
      v345.f64[0] = v344.f64[0];
      v345.f64[1] = v343.f64[1];
      float64x2_t *v366 = v343;
      v366[1] = v345;
      v343.f64[1] = v344.f64[1];
      v366[2] = v344;
      v366[3] = v343;
    }
    a3 = v363;
    uint64_t v5 = v368;
    goto LABEL_281;
  }
  if (v132 < 24)
  {
    float v204 = 1.1755e-38;
    float v203 = 3.4028e38;
  }
  else
  {
    int v191 = 0;
    int v192 = *(_DWORD *)(v98 + 24);
    int v193 = *(_DWORD *)(v98 + 28);
    float v194 = *(float *)(v98 + 16);
    float v195 = *(float *)(v98 + 20);
    float v196 = (float)((float)(v195 * (float)(v134 - v193)) * (float)(v195 * (float)(v134 - v193)))
         + (float)((float)(v194 * (float)(v133 - v192)) * (float)(v194 * (float)(v133 - v192)));
    float v197 = v147 * 0.5;
    float v198 = (float)(v197 * (float)(v194 * v194)) / v196;
    float v199 = (float)(v197 * (float)(v195 * v195)) / v196;
    uint64_t v200 = v134;
    int v201 = -v193;
    uint64_t v202 = 4 * v134;
    float v203 = 3.4028e38;
    float v204 = 1.1755e-38;
    v205 = v96;
    do
    {
      if (v131 >= 24)
      {
        uint64_t v206 = 0;
        do
        {
          float v207 = v205[v206];
          if (v207 != 0.0)
          {
            float v208 = v207
                 - (float)((float)(v198 * (float)((v191 - v192) * (v191 - v192)))
                         + (float)((float)((v201 + v206) * (v201 + v206)) * v199));
            v205[v206] = v208;
            if (v208 > v204) {
              float v204 = v208;
            }
            if (v208 < v203) {
              float v203 = v208;
            }
          }
          ++v206;
        }
        while (v200 != v206);
      }
      ++v191;
      v205 = (float *)((char *)v205 + v202);
    }
    while (v191 != v133);
  }
  for (uint64_t k = 0; k != 12; k += 4)
  {
    uint64_t v381 = 0x3F7AE1483F733333;
    float v382 = 0.99;
    *(float *)((char *)__p + k) = v203 + (float)(*(float *)((char *)&v381 + k) * (float)(v204 - v203));
  }
  uint64_t v210 = 0;
  uint64_t v211 = 0;
  uint64_t v212 = *(void *)&v6 + 207412;
  float v213 = *(float *)__p;
  v214 = v96;
  a3 = v20;
  do
  {
    uint64_t v215 = 0;
    uint64_t v216 = 0;
    int32x2_t v217 = vdup_n_s32(v210);
    while (v214[v215] <= v213)
    {
LABEL_172:
      if (++v215 == 49) {
        goto LABEL_175;
      }
    }
    if (v216 && (int)v215 - *(_DWORD *)(v216 + 8) <= 2)
    {
      *(_DWORD *)(v216 + 8) = v215;
      *(_DWORD *)(v216 + 20) = v215;
      ++*(_DWORD *)(v216 + 32);
      goto LABEL_172;
    }
    if ((int)v211 <= 255)
    {
      uint64_t v216 = v212 + 36 * (int)v211;
      *(_DWORD *)(v216 + 12) = v211;
      int32x2_t v218 = vdup_n_s32(v215);
      *(_DWORD *)uint64_t v216 = v210;
      *(int32x2_t *)(v216 + 4) = v218;
      *(int32x2_t *)(v216 + 16) = v218;
      *(int32x2_t *)(v216 + 24) = v217;
      *(_DWORD *)(v216 + 32) = 1;
      uint64_t v211 = (v211 + 1);
      goto LABEL_172;
    }
    uint64_t v211 = 0xFFFFFFFFLL;
LABEL_175:
    ++v210;
    v214 += 49;
  }
  while (v210 != 49);
  uint64_t v219 = *(void *)&v6 + 216628;
  uint64_t PeakXY = tplTracker_mergeSpans(v98, 0, v211);
  if (PeakXY == 128)
  {
    char v220 = 0;
    int v221 = 0;
    uint64_t v222 = *(void *)&v6 + 197808;
    uint64_t v223 = 1;
    do
    {
      char v349 = v220;
      if (v221 >= (int)v211)
      {
        uint64_t v233 = v211;
      }
      else
      {
        uint64_t v224 = v221;
        uint64_t v225 = v221;
        uint64_t v226 = v211;
        uint64_t v346 = v223;
        do
        {
          int v227 = *(_DWORD *)(v212 + 36 * v225 + 12);
          if (v227 != v225
            || (uint64_t v228 = v212 + 36 * v225, v230 = *(_DWORD *)(v228 + 32), v229 = (_DWORD *)(v228 + 32), v230 < 9))
          {
            uint64_t v233 = v226;
            goto LABEL_204;
          }
          float v231 = *((float *)__p + v223);
          uint64_t v232 = v224;
          uint64_t v233 = v226;
LABEL_183:
          while (2)
          {
            int v234 = *(_DWORD *)(v212 + 36 * v232 + 12);
            do
            {
              int v235 = v234;
              int v234 = *(_DWORD *)(v212 + 36 * v234 + 12);
            }
            while (v235 != v234);
            if (v235 == v227)
            {
              v236 = (unsigned int *)(v212 + 36 * v232);
              signed int v237 = v236[1];
              signed int v238 = v236[2];
              if (v237 <= v238)
              {
                uint64_t v239 = 0;
                unsigned int v240 = *v236;
                int v241 = v238 + 1;
                int32x2_t v242 = vdup_n_s32(v240);
                v243 = (float *)(v222 + 4 * v237 + 4 * (int)(49 * v240));
                do
                {
                  if (*v243 > v231)
                  {
                    if (v239 && v237 - *(_DWORD *)(v239 + 8) <= 2)
                    {
                      *(_DWORD *)(v239 + 8) = v237;
                      *(_DWORD *)(v239 + 20) = v237;
                      ++*(_DWORD *)(v239 + 32);
                    }
                    else
                    {
                      if ((int)v233 > 255)
                      {
                        ++v232;
                        uint64_t v233 = 0xFFFFFFFFLL;
                        if (v232 == (int)v211)
                        {
LABEL_263:
                          int v284 = 0;
                          *(_DWORD *)(*(void *)&v6 + 216820) = -1;
                          uint64_t PeakXY = 6784;
                          uint64_t v3 = v366;
                          uint64_t v5 = v368;
                          goto LABEL_273;
                        }
                        goto LABEL_183;
                      }
                      uint64_t v239 = v212 + 36 * (int)v233;
                      *(_DWORD *)(v239 + 12) = v233;
                      int32x2_t v244 = vdup_n_s32(v237);
                      *(_DWORD *)uint64_t v239 = v240;
                      *(int32x2_t *)(v239 + 4) = v244;
                      *(int32x2_t *)(v239 + 16) = v244;
                      *(int32x2_t *)(v239 + 24) = v242;
                      *(_DWORD *)(v239 + 32) = 1;
                      uint64_t v233 = (v233 + 1);
                    }
                  }
                  ++v237;
                  ++v243;
                }
                while (v241 != v237);
              }
            }
            if (++v232 != (int)v211) {
              continue;
            }
            break;
          }
          if (v233 == -1) {
            goto LABEL_263;
          }
          if ((int)v233 > (int)v226)
          {
            uint64_t v245 = v98;
            uint64_t v246 = v222;
            uint64_t v247 = v224;
            __dstc = v229;
            tplTracker_mergeSpans(v245, v226, v233);
            uint64_t v224 = v247;
            uint64_t v223 = v346;
            uint64_t v98 = *(void *)&v6 + 44980;
            uint64_t v222 = v246;
            _DWORD *__dstc = 0;
          }
          uint64_t PeakXY = 6784;
LABEL_204:
          ++v225;
          uint64_t v226 = v233;
        }
        while (v211 != v225);
      }
      char v220 = 1;
      uint64_t v223 = 2;
      int v221 = v211;
      uint64_t v211 = v233;
    }
    while ((v349 & 1) == 0);
    if ((int)v233 < 1)
    {
      int v249 = 0;
      a3 = v363;
      uint64_t v3 = v366;
      uint64_t v219 = *(void *)&v6 + 216628;
    }
    else
    {
      uint64_t v248 = 0;
      int v249 = 0;
      a3 = v363;
      uint64_t v3 = v366;
      uint64_t v219 = *(void *)&v6 + 216628;
      do
      {
        if (v248 == *(_DWORD *)(v212 + 36 * v248 + 12) && *(_DWORD *)(v212 + 36 * v248 + 32))
        {
          v250 = (_DWORD *)(v212 + 36 * v248);
          int v252 = v250[4];
          int v251 = v250[5];
          if (v252 <= 1) {
            int v253 = 1;
          }
          else {
            int v253 = v250[4];
          }
          unsigned int v254 = v253 - 1;
          if (v252 > 49) {
            unsigned int v254 = 48;
          }
          if (v251 < 0) {
            int v255 = -1;
          }
          else {
            int v255 = v250[5];
          }
          if (v251 < 48) {
            unsigned int v256 = v255 + 1;
          }
          else {
            unsigned int v256 = 48;
          }
          int v257 = v250[6];
          int v258 = v250[7];
          if (v257 <= 1) {
            int v259 = 1;
          }
          else {
            int v259 = v250[6];
          }
          int v260 = v259 - 1;
          if (v257 > 49) {
            int v260 = 48;
          }
          if (v258 < 0) {
            int v261 = -1;
          }
          else {
            int v261 = v258;
          }
          if (v258 < 48) {
            unsigned int v262 = v261 + 1;
          }
          else {
            unsigned int v262 = 48;
          }
          float32x2_t v263 = (float32x2_t)0x7F7FFFFF00800000;
          if (v260 <= v262)
          {
            uint64_t v264 = *(void *)&v6 + 196 * v260 + 78548;
            v265 = &v347[196 * v260];
            uint64_t v266 = 4 * v254;
            int v267 = v260;
            float32x2_t v263 = (float32x2_t)0x7F7FFFFF00800000;
            do
            {
              if (v254 <= v256)
              {
                uint64_t v268 = 0;
                uint64_t v269 = v264 + v266;
                do
                {
                  v270.i32[0] = *(_DWORD *)&v265[4 * v268 + v266];
                  int8x8_t v271 = (int8x8_t)__PAIR64__(v263.u32[1], v270.u32[0]);
                  v270.i32[1] = *(_DWORD *)(v269 + 4 * v268);
                  int8x8_t v272 = (int8x8_t)vcgt_f32(v270, v263);
                  v263.i32[1] = *(_DWORD *)(v269 + 4 * v268);
                  float32x2_t v263 = (float32x2_t)vbsl_s8(v272, v271, (int8x8_t)v263);
                  ++v268;
                }
                while (v256 - v254 + 1 != v268);
              }
              v265 += 196;
              v264 += 196;
              _ZF = v267++ == v262;
            }
            while (!_ZF);
          }
          uint64_t v273 = *(void *)&v6 + 216628 + 12 * v249;
          *(unsigned char *)uint64_t v273 = v254;
          *(unsigned char *)(v273 + 1) = v260;
          *(unsigned char *)(v273 + 2) = v256;
          *(unsigned char *)(v273 + 3) = v262;
          *(float32x2_t *)(v273 + 4) = v263;
          ++v249;
          a3 = v363;
        }
        ++v248;
      }
      while (v248 != v233);
    }
    uint64_t v274 = *(void *)&v6 + 216636;
    *(_DWORD *)(*(void *)&v6 + 216820) = v249;
  }
  else
  {
    uint64_t v274 = *(void *)&v6 + 216636;
  }
  uint64_t v5 = v368;
  if (PeakXY == 128)
  {
    uint64_t v275 = *(unsigned int *)(v274 + 184);
    if ((int)v275 < 1) {
      goto LABEL_272;
    }
    uint64_t v276 = 0;
    int v277 = *(_DWORD *)(v98 + 36) - 23;
    int v278 = *(_DWORD *)(v98 + 32) - 23;
    int v279 = -1;
    float v280 = 3.4028e38;
    v281 = (float *)v274;
    do
    {
      float v282 = *v281;
      v281 += 3;
      float v283 = v282;
      if (v282 < v280)
      {
        int v279 = v276;
        float v280 = v283;
      }
      ++v276;
    }
    while (v275 != v276);
    if (v279 == -1)
    {
LABEL_272:
      int v284 = 0;
      uint64_t PeakXY = 6784;
LABEL_273:
      *(_DWORD *)(v98 + 40) = v284;
    }
    else
    {
      int v284 = 0;
      float v285 = 5.0;
      if ((float)(v280 * 1.5) >= 5.0) {
        float v285 = v280 * 1.5;
      }
      if ((float)(v280 * 1.5) <= 1000.0) {
        float v286 = v285;
      }
      else {
        float v286 = 1000.0;
      }
      do
      {
        float v287 = *(float *)v274;
        v274 += 12;
        if (v287 <= v286) {
          ++v284;
        }
        --v275;
      }
      while (v275);
      v288 = (unsigned __int8 *)(v219 + 12 * v279);
      int v289 = *v288;
      int v290 = v288[1];
      int v291 = v288[2];
      int v292 = v288[3];
      float32x2_t v375 = 0;
      uint64_t PeakXY = tplTracker_findPeakXY((uint64_t)v347, v277, v278, v289, v290, v291, v292, (uint64_t)&v375 + 4, (float *)&v375);
      if (PeakXY == 128)
      {
        *(float *)uint64_t v98 = v280;
        *(int32x2_t *)(v98 + 8) = vrev64_s32((int32x2_t)vmul_f32(*(float32x2_t *)(v98 + 16), vsub_f32(v375, vcvt_f32_s32(*(int32x2_t *)(v98 + 24)))));
        uint64_t v5 = v368;
        goto LABEL_273;
      }
      uint64_t v5 = v368;
    }
    a3 = v363;
  }
  uint64_t v19 = PeakXY;
  if (PeakXY == 128)
  {
    uint64_t v98 = *(void *)&v6 + 44980;
    __dstb = (_DWORD *)(*(void *)&v6 + 45020);
    uint64_t v136 = *(void *)&v6 + 42056;
    long long v149 = (int *)(*(void *)&v6 + 45024);
    if (*(_DWORD *)(*(void *)&v6 + 45020) == 1) {
      goto LABEL_121;
    }
    goto LABEL_120;
  }
LABEL_278:
  uint64_t v63 = PeakXY;
  if (v19 != 128)
  {
LABEL_279:
    *(unsigned char *)(*(void *)&v6 + 44968) = 0;
    BYTE1(v3[4].f64[0]) = 1;
  }
  uint64_t v295 = v63;
  if (v63 != 128) {
    goto LABEL_324;
  }
LABEL_281:
  uint64_t v296 = *(void *)&v3[4].f64[1];
  v297 = (int *)(v296 + 44956);
  int v298 = *(unsigned __int8 *)(v296 + 44968);
  LOBYTE(v3[4].f64[0]) = v298;
  float64x2_t v299 = v3[2];
  float64x2_t v300 = *v3;
  *(int32x2_t *)(v296 + 44960) = vrev64_s32((int32x2_t)vcvt_f32_f64(vdivq_f64(vsubq_f64(v299, *v3), v365)));
  int v301 = *(_DWORD *)(v296 + 44972);
  float64_t v302 = v300.f64[1];
  if (!v298)
  {
    if (!v301)
    {
      int v305 = *(_DWORD *)(v296 + 44976) + 1;
      *(_DWORD *)(v296 + 44972) = 1;
      *(_DWORD *)(v296 + 44976) = v305;
      goto LABEL_291;
    }
    int v303 = v301 + 1;
    int v304 = *(_DWORD *)(v296 + 44976) + 1;
    *(_DWORD *)(v296 + 44972) = v303;
    *(_DWORD *)(v296 + 44976) = v304;
LABEL_286:
    if (v304 == 2)
    {
      BYTE1(v3[4].f64[0]) = 1;
    }
    else if (v303 != 3)
    {
      goto LABEL_291;
    }
    *(void *)(v296 + 44972) = 0;
    goto LABEL_291;
  }
  if (v301)
  {
    int v303 = v301 + 1;
    *(_DWORD *)(v296 + 44972) = v303;
    int v304 = *(_DWORD *)(v296 + 44976);
    goto LABEL_286;
  }
LABEL_291:
  float64_t v306 = v3->f64[0];
  v299.f64[0] = v3[2].f64[0];
  v300.f64[0] = v3->f64[0];
  float64x2_t v307 = vsubq_f64(v299, v300);
  __asm { FMOV            V3.2D, #1.0 }
  float64x2_t v309 = vaddq_f64(v307, _Q3);
  v393.size.width = (double)(*(_DWORD *)v296 - 1);
  v393.size.height = (double)(*(_DWORD *)(v296 + 4) - 1);
  _Q3.f64[0] = v309.f64[1];
  v393.origin.x = 0.0;
  v393.origin.y = 0.0;
  float64x2_t v373 = v309;
  CGRect v392 = CGRectIntersection(*(CGRect *)(&v302 - 1), v393);
  uint64_t v63 = 6784;
  if (*(_DWORD *)(v296 + 45020) != 1) {
    goto LABEL_325;
  }
  float v310 = v392.size.width * v392.size.height / vmuld_lane_f64(v373.f64[0], v373, 1);
  if (v310 <= 0.5) {
    goto LABEL_325;
  }
  uint64_t v369 = v5;
  v364 = a3;
  int v374 = 576 * *v297;
  v311 = (char *)(v296 + v374 + 42076);
  v367 = v3;
  tplTrackerResampler_resample(*(void *)(v296 + 341240), v3->f64, 0x18u, 24, v296 + 45040, (unsigned char *)(v296 + 50224), (unsigned char *)(v296 + 55408), (int *)(v296 + 45024), *(float *)(v296 + 44960), *(float *)(v296 + 44964));
  tplTracker_YCbCr2RGB((unsigned __int8 *)(v296 + 45040), (unsigned __int8 *)(v296 + 50224), (unsigned __int8 *)(v296 + 55408), 576, (unsigned char *)(v296 + 60592), (unsigned char *)(v296 + 65776), (unsigned char *)(v296 + 70960));
  tplTracker_computeTemplateAvgColor((_DWORD *)v296, v312);
  tplTracker_computeNormedGradient(v296 + 60592, v296 + 65776, v296 + 70960, 24, 24, (int *)(v296 + 45024), (uint64_t)v311);
  uint64_t v313 = *(unsigned int *)(v296 + 45024);
  uint64_t v63 = 6780;
  if ((v313 & 0x80000000) != 0) {
    goto LABEL_323;
  }
  uint64_t v314 = *(unsigned int *)(v296 + 45028);
  if ((v314 & 0x80000000) != 0) {
    goto LABEL_323;
  }
  uint64_t v315 = *(unsigned int *)(v296 + 45032);
  uint64_t v63 = 6780;
  if ((int)v315 > 23) {
    goto LABEL_323;
  }
  int v316 = *(_DWORD *)(v296 + 45036);
  if (v316 > 23) {
    goto LABEL_323;
  }
  uint64_t v63 = 6780;
  if ((int)v313 > (int)v315 || (int)v314 > v316) {
    goto LABEL_323;
  }
  uint64_t v317 = v296 + 8;
  if (v314) {
    memcpy(v311, (const void *)(v296 + 8), 24 * v314);
  }
  if (v313 || (int)v315 <= 22)
  {
    uint64_t v318 = v296 + 24 * v314;
    uint64_t v319 = v374 + 24 * v314 + v296 + 42077;
    do
    {
      uint64_t v320 = v318;
      uint64_t v321 = v313;
      if (v313)
      {
        do
        {
          *(unsigned char *)(v320 + v374 + 42076) = *(unsigned char *)(v320 + 8);
          ++v320;
          --v321;
        }
        while (v321);
      }
      if ((int)v315 <= 22)
      {
        uint64_t v322 = 0;
        do
        {
          *(unsigned char *)(v319 + v315 + v322) = *(unsigned char *)(v318 + v315 + v322 + 9);
          ++v322;
        }
        while ((int)v315 + (int)v322 - 1 < 22);
      }
      v318 += 24;
      v319 += 24;
    }
    while (v316 > (int)v314++);
  }
  if (v316 <= 22) {
    memcpy(&v311[24 * v316 + 24], (const void *)(v317 + 24 * v316 + 24), (24 * (23 - v316)));
  }
  int v324 = *v297 + 1;
  int *v297 = v324;
  a3 = v364;
  if (v324 != 5)
  {
    uint64_t v63 = 6784;
    uint64_t v5 = v369;
    goto LABEL_325;
  }
  uint64_t v325 = 0;
  uint64_t v326 = v296 + 42076;
  uint64_t v5 = v369;
  do
  {
    uint64_t v327 = 0;
    unsigned int v328 = 2;
    do
    {
      v328 += *(unsigned __int8 *)(v326 + v327);
      v327 += 576;
    }
    while (v327 != 2880);
    if (v328 > 0x4FF) {
      char v329 = -1;
    }
    else {
      char v329 = v328 / 5;
    }
    *(unsigned char *)(v317 + v325++) = v329;
    ++v326;
  }
  while (v325 != 576);
  tplTracker_computeTemplateStats(v296);
  uint64_t v63 = tplTracker_computeTemplateFFT(v296);
  if (v63 == 128)
  {
    int *v297 = 0;
    goto LABEL_325;
  }
LABEL_323:
  uint64_t v5 = v369;
  BYTE1(v367[4].f64[0]) = 1;
  uint64_t v295 = v63;
  a3 = v364;
LABEL_324:
  if (v295 == 128)
  {
LABEL_325:
    std::string::basic_string[abi:ne180100]<0>(__p, "unknown");
    HIDWORD(v379.f64[0]) = 0;
    LOBYTE(v379.f64[1]) = 0;
    HIDWORD(v379.f64[1]) = 0;
    LOWORD(v379.f64[0]) = 0;
    float64x2_t v378 = 0uLL;
    v330 = *(double **)(v5 + 32);
    float v331 = v330[2] - *v330;
    *((float *)v378.f64 + 1) = v331;
    float v332 = v330[5] - v330[3];
    *(float *)&unsigned int v333 = v330[6];
    *(float *)v378.f64 = v332;
    *((void *)&v377 + 1) = v333 | 0x7FC0000000000000;
    size_t Height = CVPixelBufferGetHeight(a2);
    uint64_t v335 = *(void *)(v5 + 32);
    float v336 = 0.0;
    if (*(unsigned char *)(v335 + 64)) {
      float v336 = 1.0;
    }
    float v337 = (float)Height - *(double *)(v335 + 56);
    *((float *)&v377 + 3) = v337;
    *((float *)&v379.f64[1] + 1) = v336;
    unint64_t v338 = a3[1];
    if (v338 >= a3[2])
    {
      uint64_t v339 = std::vector<vision::mod::DetectedObject>::__push_back_slow_path<vision::mod::DetectedObject const&>(a3, (uint64_t)__p);
    }
    else
    {
      vision::mod::DetectedObject::DetectedObject(a3[1], (uint64_t)__p);
      uint64_t v339 = v338 + 80;
      a3[1] = v338 + 80;
    }
    a3[1] = v339;
    if (SBYTE7(v377) < 0) {
      operator delete(__p[0]);
    }
  }
  return v63;
}

void sub_1A3F6BBD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  uint64_t v48 = v46;
  *(void *)(v48 + 8) = v47;
  if (a46 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ObjectTrackerEx::setTargetObjects(uint64_t a1, CVPixelBufferRef pixelBuffer, uint64_t *a3)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a3;
  if (a3[1] - *a3 != 80) {
    return 6780;
  }
  float v6 = *(float *)(v3 + 24);
  float32x2_t v7 = *(float32x2_t *)(v3 + 28);
  float v8 = *(float *)(v3 + 36);
  float Width = (float)CVPixelBufferGetWidth(pixelBuffer);
  *(float *)v10.i32 = (float)CVPixelBufferGetHeight(pixelBuffer);
  float32x2_t v11 = vdiv_f32(v7, (float32x2_t)vdup_lane_s32(v10, 0));
  uint64_t v12 = *(void *)(a1 + 32);
  if (CVPixelBufferGetPlaneCount(pixelBuffer))
  {
    size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
    size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
  }
  else
  {
    size_t WidthOfPlane = CVPixelBufferGetWidth(pixelBuffer);
    size_t HeightOfPlane = CVPixelBufferGetHeight(pixelBuffer);
  }
  double v16 = (float)(v6 / Width) * (double)WidthOfPlane;
  float64x2_t v17 = vmulq_n_f64(vcvtq_f64_f32(v11), (double)HeightOfPlane);
  double v18 = (double)WidthOfPlane + -1.0;
  if (v16 >= 0.0) {
    double v19 = (float)(v6 / Width) * (double)WidthOfPlane;
  }
  else {
    double v19 = 0.0;
  }
  if (v16 > v18) {
    double v19 = (double)WidthOfPlane + -1.0;
  }
  double v20 = (double)HeightOfPlane + -1.0;
  if (v17.f64[0] >= 0.0) {
    double v21 = v17.f64[0];
  }
  else {
    double v21 = 0.0;
  }
  if (v17.f64[0] > v20) {
    double v21 = (double)HeightOfPlane + -1.0;
  }
  *(double *)uint64_t v12 = v19;
  *(double *)(v12 + 8) = v21;
  double v22 = v16 + (float)(v8 / Width) * (double)WidthOfPlane;
  if (v22 >= 0.0) {
    double v23 = v22;
  }
  else {
    double v23 = 0.0;
  }
  if (v22 <= v18) {
    double v18 = v23;
  }
  *(double *)(v12 + 16) = v18;
  *(double *)(v12 + 24) = v21;
  double v24 = vaddvq_f64(v17);
  if (v24 >= 0.0) {
    double v25 = v24;
  }
  else {
    double v25 = 0.0;
  }
  if (v24 <= v20) {
    double v20 = v25;
  }
  *(double *)(v12 + 48) = v19;
  *(double *)(v12 + 56) = v20;
  *(double *)(v12 + 32) = v18;
  *(double *)(v12 + 40) = v20;
  uint64_t v26 = *(void *)(v12 + 72);
  if (!v26)
  {
    float v27 = malloc_type_calloc(1uLL, 0x53500uLL, 0x10200401370116FuLL);
    if (!v27)
    {
      *(void *)(v12 + 72) = 0;
      return 6779;
    }
    uint64_t v26 = (uint64_t)v27;
    v27[42655] = tplTrackerResampler_alloc(72, 72);
    *(void *)(v12 + 72) = v26;
  }
  *(void *)(v26 + 44972) = 0;
  *(_OWORD *)(v26 + 42056) = 0u;
  *(_DWORD *)(v26 + 42072) = 0;
  int v28 = CVPixelBufferGetWidth(pixelBuffer);
  int Height = CVPixelBufferGetHeight(pixelBuffer);
  *(_DWORD *)uint64_t v26 = v28;
  *(_DWORD *)(v26 + 4) = Height;
  *(unsigned char *)(v26 + 44968) = 1;
  float64x2_t v30 = *(float64x2_t *)(v12 + 32);
  float64x2_t v31 = *(float64x2_t *)v12;
  __asm { FMOV            V3.2D, #23.0 }
  *(float32x2_t *)&_Q3.f64[0] = vcvt_f32_f64(vdivq_f64(vsubq_f64(v30, *(float64x2_t *)v12), _Q3));
  *(int32x2_t *)(v26 + 44960) = vrev64_s32(*(int32x2_t *)&_Q3.f64[0]);
  __asm { FMOV            V2.2S, #24.0 }
  float64x2_t v38 = vcvtq_f64_f32(vmul_f32(*(float32x2_t *)&_Q3.f64[0], _D2));
  float64x2_t v39 = vsubq_f64(v31, v38);
  float64x2_t v40 = vaddq_f64(v30, v38);
  v38.f64[0] = v40.f64[0];
  v38.f64[1] = v39.f64[1];
  float64_t v42 = _Q3.f64[0];
  v43[0] = v39;
  v43[1] = v38;
  v43[2] = v40;
  v39.f64[1] = v40.f64[1];
  v43[3] = v39;
  if (tplTrackerResampler_setImage(*(void *)(v26 + 341240), pixelBuffer, (double *)v43) == 128)
  {
    tplTrackerResampler_resample(*(void *)(v26 + 341240), (double *)v12, 0x18u, 24, v26 + 45040, (unsigned char *)(v26 + 50224), (unsigned char *)(v26 + 55408), (int *)(v26 + 45024), *((float *)&v42 + 1), *(float *)&v42);
    tplTracker_YCbCr2RGB((unsigned __int8 *)(v26 + 45040), (unsigned __int8 *)(v26 + 50224), (unsigned __int8 *)(v26 + 55408), 576, (unsigned char *)(v26 + 60592), (unsigned char *)(v26 + 65776), (unsigned char *)(v26 + 70960));
    tplTracker_computeNormedGradient(v26 + 60592, v26 + 65776, v26 + 70960, 24, 24, (int *)(v26 + 45024), v26 + 8);
    tplTracker_computeTemplateAvgColor((_DWORD *)v26, v41);
    tplTracker_computeTemplateStats(v26);
    tplTracker_computeTemplateFFT(v26);
  }
  memcpy((void *)(v26 + 42076), (const void *)(v26 + 8), 0x240uLL);
  *(_DWORD *)(v26 + 44956) = 1;
  *(unsigned char *)(v12 + 65) = 0;
  return 6784;
}

void vision::mod::ObjectTrackerEx::~ObjectTrackerEx(vision::mod::ObjectTrackerEx *this)
{
  vision::mod::ObjectTrackerEx::~ObjectTrackerEx(this);

  JUMPOUT(0x1A62562C0);
}

{
  std::__shared_weak_count *v2;

  *(void *)this = &unk_1EF752330;
  ctpl_trackerDelete(*((void **)this + 4));
  *((void *)this + 4) = 0;
  *(void *)this = &unk_1EF7525F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

uint64_t tplTracker_FFT_3324(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, int32x4_t a7)
{
  v108[70] = *MEMORY[0x1E4F143B8];
  uint64_t result = 6780;
  if (a1 && a2)
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    uint64_t v11 = 0;
    BOOL v12 = 0;
    uint64_t v13 = 0;
    do
    {
      unint64_t v14 = v13 + 4 * v12 + 8 * v11 + 24 * v10;
      if (v14 >= 0x48) {
        __assert_rtn("tplTracker_FFT_3324", "tplTrackerFFT.c", 99, "(outputIndex >= 0) && (outputIndex < 72)");
      }
      *(void *)&v107[8 * v14 + 560] = *(void *)(a1 + v9);
      unint64_t v15 = v11 + 1;
      BOOL v16 = !v12;
      if (v12) {
        uint64_t v17 = v13 + 1;
      }
      else {
        uint64_t v17 = v13;
      }
      BOOL v18 = v15 >= 3;
      if (v15 >= 3) {
        uint64_t v19 = v17;
      }
      else {
        uint64_t v19 = v13;
      }
      if (v18)
      {
        uint64_t v20 = 0;
      }
      else
      {
        BOOL v16 = v12;
        uint64_t v20 = v11 + 1;
      }
      if (v10 < 2)
      {
        ++v10;
      }
      else
      {
        uint64_t v13 = v19;
        BOOL v12 = v16;
        uint64_t v11 = v20;
        unint64_t v10 = 0;
      }
      v9 += 8;
    }
    while (v9 != 576);
    double v21 = (int32x2_t *)v108;
    double v22 = (int32x2_t *)v107;
    unint64_t v23 = -4;
    do
    {
      int32x2_t v24 = v21[-2];
      int32x2_t v25 = v21[-1];
      int32x2_t v26 = *v21;
      int32x2_t v27 = v21[1];
      v21 += 4;
      int32x2_t v28 = vadd_s32(v26, v24);
      int32x2_t v29 = vadd_s32(v25, v27);
      v22[-2] = vadd_s32(v29, v28);
      v22[-1] = vsub_s32(vadd_s32(vzip1_s32(v24, v27), vzip2_s32(v25, v24)), vadd_s32(vzip1_s32(v26, v25), vzip2_s32(v27, v26)));
      int32x2_t v30 = vsub_s32(v28, v29);
      int32x2_t v31 = vsub_s32(v24, vadd_s32(v26, vdup_lane_s32(v25, 1)));
      int32x2_t v32 = vadd_s32(v24, vdup_lane_s32(v25, 0));
      v25.i32[0] = vadd_s32(v31, vdup_lane_s32(v27, 1)).u32[0];
      v25.i32[1] = vsub_s32(v32, vadd_s32(vdup_lane_s32(v27, 0), v26)).i32[1];
      *double v22 = v30;
      v22[1] = v25;
      v22 += 4;
      v23 += 4;
    }
    while (v23 < 0x44);
    uint64_t v33 = 0;
    unint64_t v34 = -8;
    do
    {
      int v35 = *(_DWORD *)&v106[v33 + 516];
      int v36 = *(_DWORD *)&v106[v33 + 520];
      unint64_t v37 = (unint64_t)(1518500250 * *(int *)&v107[v33 + 24] + 0x40000000) >> 31;
      unint64_t v38 = (unint64_t)(1518500250 * *(int *)&v107[v33 + 28] + 0x40000000) >> 31;
      int v39 = v38 + v37;
      LODWORD(v37) = v38 - v37;
      int v40 = v35 + v39;
      unint64_t v41 = (unint64_t)(1518500250 * *(int *)&v107[v33 + 40] + 0x40000000) >> 31;
      unint64_t v42 = (unint64_t)(1518500250 * *(int *)&v107[v33 + 44] + 0x40000000) >> 31;
      int v43 = v35 - v39;
      uint64_t v44 = &v105[v33 + 508];
      int32x2_t v45 = *(int32x2_t *)&v106[v33 + 508];
      v46.i64[0] = __PAIR64__((int)v41 + (int)v42, (int)v41 - (int)v42);
      int32x2_t v47 = *(int32x2_t *)&v107[v33 + 16];
      *(int32x2_t *)uint64_t v44 = vadd_s32(v47, v45);
      int32x4_t v48 = *(int32x4_t *)&v106[v33 + 524];
      a7.i64[0] = *(void *)&v107[v33 + 32];
      int32x2_t v49 = vrev64_s32(*(int32x2_t *)v48.i8);
      *((_DWORD *)v44 + 2) = v40;
      *((_DWORD *)v44 + 3) = v36 + v37;
      int8x8_t v50 = vext_s8((int8x8_t)vadd_s32(v49, *(int32x2_t *)a7.i8), (int8x8_t)vsub_s32(v49, *(int32x2_t *)a7.i8), 4uLL);
      *(int32x2_t *)a7.i8 = vrev64_s32(*(int32x2_t *)a7.i8);
      unsigned __int32 v51 = vsubq_s32(v48, a7).u32[0];
      *((_DWORD *)v44 + 10) = v43;
      *((_DWORD *)v44 + 11) = v36 - v37;
      a7.i64[1] = __PAIR64__((int)v41 + (int)v42, (int)v41 - (int)v42);
      *((int8x8_t *)v44 + 2) = v50;
      v46.u64[1] = (unint64_t)v47;
      v52.i64[0] = vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL).u64[0];
      v52.u64[1] = (unint64_t)v45;
      int32x4_t v53 = vsubq_s32(v52, v46);
      int32x4_t v54 = vaddq_s32(v48, a7);
      *(int32x4_t *)(v44 + 24) = v53;
      v54.i32[0] = v51;
      *((int32x4_t *)v44 + 3) = v54;
      v34 += 8;
      v33 += 64;
    }
    while (v34 < 0x40);
    unint64_t v55 = 0;
    uint64_t v56 = (int *)v106;
    int v57 = v105;
    do
    {
      unint64_t v58 = 0xFFFFFFFFFFFFFF40;
      int v59 = v57;
      unsigned int v60 = v56;
      do
      {
        uint64_t v62 = *(v60 - 1);
        uint64_t v61 = *v60;
        uint64_t v63 = *(void *)((char *)&coeffsB_3324 + v58 + 192);
        uint64_t v64 = *(void *)((char *)&coeffsB_3324 + v58 + 336);
        uint64_t v66 = v60[15];
        uint64_t v65 = v60[16];
        uint64_t v67 = *(void *)((char *)&coeffsC_3324 + v58 + 192);
        uint64_t v68 = *(void *)((char *)&coeffsC_3324 + v58 + 264);
        int v70 = *(v60 - 17);
        int v69 = *(v60 - 16);
        int v71 = ((unint64_t)(v63 * v62 + 0x40000000) >> 31)
            + v70
            + ((unint64_t)(v67 * v66 + 0x40000000) >> 31)
            - (((unint64_t)(v64 * v61 + 0x40000000) >> 31)
             + ((unint64_t)(v68 * v65 + 0x40000000) >> 31));
        LODWORD(v63) = ((unint64_t)(v63 * v61 + 0x40000000) >> 31)
                     + v69
                     + ((unint64_t)(v64 * v62 + 0x40000000) >> 31)
                     + ((unint64_t)(v67 * v65 + 0x40000000) >> 31)
                     + ((unint64_t)(v68 * v66 + 0x40000000) >> 31);
        uint64_t v72 = *(void *)((char *)&coeffsB_3324 + v58 + 384);
        uint64_t v73 = *(void *)((char *)&coeffsB_3324 + v58 + 528);
        uint64_t v74 = *(void *)((char *)&coeffsC_3324 + v58 + 384);
        uint64_t v75 = *(void *)((char *)&coeffsC_3324 + v58 + 456);
        int v76 = ((unint64_t)(v72 * v62 + 0x40000000) >> 31)
            + v70
            + ((unint64_t)(v74 * v66 + 0x40000000) >> 31)
            - (((unint64_t)(v73 * v61 + 0x40000000) >> 31)
             + ((unint64_t)(v75 * v65 + 0x40000000) >> 31));
        LODWORD(v72) = ((unint64_t)(v72 * v61 + 0x40000000) >> 31)
                     + v69
                     + ((unint64_t)(v73 * v62 + 0x40000000) >> 31)
                     + ((unint64_t)(v74 * v65 + 0x40000000) >> 31)
                     + ((unint64_t)(v75 * v66 + 0x40000000) >> 31);
        uint64_t v77 = *(void *)((char *)&coeffsB_3324 + v58 + 576);
        uint64_t v78 = *(void *)((char *)&coeffsB_3324 + v58 + 720);
        uint64_t v79 = *(void *)((char *)&coeffsC_3324 + v58 + 576);
        uint64_t v80 = *(void *)((char *)&coeffsC_3324 + v58 + 648);
        *(v59 - 17) = v71;
        *(v59 - 16) = v63;
        *(v59 - 1) = v76;
        *int v59 = v72;
        v59[15] = ((unint64_t)(v77 * v62 + 0x40000000) >> 31)
                + v70
                + ((unint64_t)(v79 * v66 + 0x40000000) >> 31)
                - (((unint64_t)(v78 * v61 + 0x40000000) >> 31)
                 + ((unint64_t)(v80 * v65 + 0x40000000) >> 31));
        v59[16] = ((unint64_t)(v77 * v61 + 0x40000000) >> 31)
                + v69
                + ((unint64_t)(v78 * v62 + 0x40000000) >> 31)
                + ((unint64_t)(v79 * v65 + 0x40000000) >> 31)
                + ((unint64_t)(v80 * v66 + 0x40000000) >> 31);
        v60 += 2;
        v59 += 2;
        v58 += 24;
      }
      while (v58);
      v56 += 48;
      v57 += 192;
      BOOL v18 = v55 >= 0x30;
      v55 += 24;
    }
    while (!v18);
    uint64_t v81 = 0xC0u;
    uint64_t result = 6784;
    do
    {
      uint64_t v83 = *(int *)&v104[v81];
      uint64_t v82 = *(int *)&v104[v81 + 4];
      uint64_t v84 = *(void *)((char *)&coeffsB_3324 + v81 - 192);
      uint64_t v85 = *(void *)((char *)&coeffsB_3324 + v81 - 48);
      uint64_t v87 = *(int *)&v105[v81 + 124];
      uint64_t v86 = *(int *)&v105[v81 + 128];
      uint64_t v88 = *(void *)((char *)&coeffsC_3324 + v81 - 192);
      uint64_t v89 = *(void *)((char *)&coeffsC_3324 + v81 - 120);
      int v90 = *(_DWORD *)&v104[v81 - 192];
      int v91 = *(_DWORD *)&v104[v81 - 188];
      int v92 = ((unint64_t)(v84 * v83 + 0x40000000) >> 31)
          + v90
          + ((unint64_t)(v88 * v87 + 0x40000000) >> 31)
          - (((unint64_t)(v85 * v82 + 0x40000000) >> 31)
           + ((unint64_t)(v89 * v86 + 0x40000000) >> 31));
      LODWORD(v84) = ((unint64_t)(v84 * v82 + 0x40000000) >> 31)
                   + v91
                   + ((unint64_t)(v85 * v83 + 0x40000000) >> 31)
                   + ((unint64_t)(v88 * v86 + 0x40000000) >> 31)
                   + ((unint64_t)(v89 * v87 + 0x40000000) >> 31);
      uint64_t v93 = *(void *)((char *)&coeffsB_3324 + v81);
      uint64_t v94 = *(void *)((char *)&coeffsB_3324 + v81 + 144);
      uint64_t v95 = *(void *)((char *)&coeffsC_3324 + v81);
      uint64_t v96 = *(void *)((char *)&coeffsC_3324 + v81 + 72);
      int v97 = ((unint64_t)(v93 * v83 + 0x40000000) >> 31)
          + v90
          + ((unint64_t)(v95 * v87 + 0x40000000) >> 31)
          - (((unint64_t)(v94 * v82 + 0x40000000) >> 31)
           + ((unint64_t)(v96 * v86 + 0x40000000) >> 31));
      LODWORD(v93) = ((unint64_t)(v93 * v82 + 0x40000000) >> 31)
                   + v91
                   + ((unint64_t)(v94 * v83 + 0x40000000) >> 31)
                   + ((unint64_t)(v95 * v86 + 0x40000000) >> 31)
                   + ((unint64_t)(v96 * v87 + 0x40000000) >> 31);
      uint64_t v98 = *(void *)((char *)&coeffsB_3324 + v81 + 192);
      uint64_t v99 = *(void *)((char *)&coeffsB_3324 + v81 + 336);
      uint64_t v100 = *(void *)((char *)&coeffsC_3324 + v81 + 192);
      uint64_t v101 = *(void *)((char *)&coeffsC_3324 + v81 + 264);
      int v102 = ((unint64_t)(v98 * v83 + 0x40000000) >> 31)
           + v90
           + ((unint64_t)(v100 * v87 + 0x40000000) >> 31)
           - (((unint64_t)(v99 * v82 + 0x40000000) >> 31)
            + ((unint64_t)(v101 * v86 + 0x40000000) >> 31));
      LODWORD(v83) = ((unint64_t)(v99 * v83 + 0x40000000) >> 31)
                   + ((unint64_t)(v100 * v86 + 0x40000000) >> 31);
      int v103 = (_DWORD *)(a2 + v81);
      *(v103 - 48) = v92;
      *(v103 - 47) = v84;
      *int v103 = v97;
      v103[1] = v93;
      v103[48] = v102;
      v103[49] = ((unint64_t)(v98 * v82 + 0x40000000) >> 31)
               + v91
               + v83
               + ((unint64_t)(v101 * v87 + 0x40000000) >> 31);
      v81 += 8;
    }
    while (v81 != 384);
  }
  return result;
}

uint64_t tplTracker_IFFT_3324(uint64_t a1, uint64_t a2, int32x4_t a3)
{
  v104[72] = *MEMORY[0x1E4F143B8];
  uint64_t result = 6780;
  if (a1 && a2)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    BOOL v8 = 0;
    uint64_t v9 = 0;
    do
    {
      unint64_t v10 = v9 + 4 * v8 + 8 * v7 + 24 * v6;
      if (v10 >= 0x48) {
        __assert_rtn("tplTracker_IFFT_3324", "tplTrackerFFT.c", 313, "(outputIndex >= 0) && (outputIndex < 72)");
      }
      v104[v10] = *(void *)(a1 + v5);
      unint64_t v11 = v7 + 1;
      BOOL v12 = !v8;
      if (v8) {
        uint64_t v13 = v9 + 1;
      }
      else {
        uint64_t v13 = v9;
      }
      BOOL v14 = v11 >= 3;
      if (v11 >= 3) {
        uint64_t v15 = v13;
      }
      else {
        uint64_t v15 = v9;
      }
      if (v14)
      {
        uint64_t v16 = 0;
      }
      else
      {
        BOOL v12 = v8;
        uint64_t v16 = v7 + 1;
      }
      if (v6 < 2)
      {
        ++v6;
      }
      else
      {
        uint64_t v9 = v15;
        BOOL v8 = v12;
        uint64_t v7 = v16;
        unint64_t v6 = 0;
      }
      v5 += 8;
    }
    while (v5 != 576);
    unint64_t v17 = -4;
    BOOL v18 = v103;
    uint64_t v19 = v104;
    do
    {
      a3.i64[0] = *v19;
      int32x4_t v20 = vzip1q_s32(vrev64q_s32(a3), a3);
      int32x4_t v21 = *(int32x4_t *)(v19 + 1);
      int32x4_t v22 = vaddq_s32(v20, v21);
      int32x4_t v24 = vrev64q_s32(v22);
      int32x4_t v23 = (int32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v24, 8uLL);
      v24.i64[0] = v19[3];
      *(int32x2_t *)BOOL v18 = vadd_s32(*(int32x2_t *)v23.i8, vadd_s32(*(int32x2_t *)v21.i8, *(int32x2_t *)v24.i8));
      __int32 v25 = vsubq_s32(v20, vaddq_s32(vdupq_laneq_s32(v21, 2), v21)).i32[1] + v24.i32[1];
      int8x16_t v26 = vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL);
      unsigned __int32 v27 = vaddq_s32(v21, vdupq_laneq_s32(v21, 3)).u32[0];
      v21.i32[3] = v24.i32[0];
      v28.i64[0] = v24.i64[0];
      *((_DWORD *)v18 + 2) = v25;
      v28.i64[1] = __PAIR64__(v26.u32[1], v24.u32[1]);
      int8x16_t v29 = (int8x16_t)vsubq_s32(v23, vaddq_s32(v21, v28));
      *(int8x16_t *)(v18 + 12) = vextq_s8(v29, v29, 0xCuLL);
      *((_DWORD *)v18 + 7) = vadd_s32(*(int32x2_t *)v24.i8, vdup_lane_s32(*(int32x2_t *)a3.i8, 1)).u32[0] - v27;
      v17 += 4;
      v18 += 32;
      v19 += 4;
    }
    while (v17 < 0x44);
    uint64_t v30 = 0;
    unint64_t v31 = -8;
    do
    {
      int v32 = *(_DWORD *)&v103[v30 + 8];
      int v33 = *(_DWORD *)&v103[v30 + 12];
      unint64_t v34 = (unint64_t)(1518500250 * *(int *)&v103[v30 + 40] + 0x40000000) >> 31;
      unint64_t v35 = (unint64_t)(1518500250 * *(int *)&v103[v30 + 44] + 0x40000000) >> 31;
      int v36 = v34 - v35;
      LODWORD(v34) = v35 + v34;
      int v37 = v32 + v36;
      unint64_t v38 = (unint64_t)(1518500250 * *(int *)&v103[v30 + 56] + 0x40000000) >> 31;
      unint64_t v39 = (unint64_t)(1518500250 * *(int *)&v103[v30 + 60] + 0x40000000) >> 31;
      int v40 = v32 - v36;
      unint64_t v41 = &v101[v30 + 508];
      int32x2_t v42 = *(int32x2_t *)&v103[v30];
      v43.i64[0] = __PAIR64__((int)v39 - (int)v38, (int)v39 + (int)v38);
      int32x2_t v44 = *(int32x2_t *)&v103[v30 + 32];
      *(int32x2_t *)unint64_t v41 = vadd_s32(v44, v42);
      int32x4_t v45 = *(int32x4_t *)&v103[v30 + 16];
      v24.i64[0] = *(void *)&v103[v30 + 48];
      int32x2_t v46 = vrev64_s32(*(int32x2_t *)v45.i8);
      *((_DWORD *)v41 + 2) = v37;
      *((_DWORD *)v41 + 3) = v33 + v34;
      int8x8_t v47 = vext_s8((int8x8_t)vsub_s32(v46, *(int32x2_t *)v24.i8), (int8x8_t)vadd_s32(v46, *(int32x2_t *)v24.i8), 4uLL);
      *(int32x2_t *)v24.i8 = vrev64_s32(*(int32x2_t *)v24.i8);
      int32x4_t v48 = vsubq_s32(v45, v24);
      *((_DWORD *)v41 + 10) = v40;
      *((_DWORD *)v41 + 11) = v33 - v34;
      v24.i64[1] = __PAIR64__((int)v39 - (int)v38, (int)v39 + (int)v38);
      *((int8x8_t *)v41 + 2) = v47;
      v43.u64[1] = (unint64_t)v44;
      v49.i64[0] = vextq_s8((int8x16_t)v45, (int8x16_t)v45, 8uLL).u64[0];
      v49.u64[1] = (unint64_t)v42;
      int32x4_t v50 = vsubq_s32(v49, v43);
      int32x4_t v51 = vaddq_s32(v45, v24);
      *(int32x4_t *)(v41 + 24) = v50;
      v51.i32[1] = v48.i32[1];
      *((int32x4_t *)v41 + 3) = v51;
      v31 += 8;
      v30 += 64;
    }
    while (v31 < 0x40);
    unint64_t v52 = 0;
    int32x4_t v53 = &v102;
    int32x4_t v54 = v101;
    do
    {
      unint64_t v55 = 0xFFFFFFFFFFFFFF40;
      uint64_t v56 = v54;
      int v57 = v53;
      do
      {
        uint64_t v59 = *(v57 - 1);
        uint64_t v58 = *v57;
        uint64_t v60 = *(void *)((char *)&coeffsB_3324 + v55 + 192);
        uint64_t v61 = *(void *)((char *)&coeffsB_3324 + v55 + 336);
        uint64_t v63 = v57[15];
        uint64_t v62 = v57[16];
        uint64_t v64 = *(void *)((char *)&coeffsC_3324 + v55 + 192);
        uint64_t v65 = *(void *)((char *)&coeffsC_3324 + v55 + 264);
        int v67 = *(v57 - 17);
        int v66 = *(v57 - 16);
        int v68 = ((unint64_t)(v60 * v59 + 0x40000000) >> 31)
            + v67
            + ((unint64_t)(v61 * v58 + 0x40000000) >> 31)
            + ((unint64_t)(v64 * v63 + 0x40000000) >> 31)
            + ((unint64_t)(v65 * v62 + 0x40000000) >> 31);
        LODWORD(v60) = ((unint64_t)(v60 * v58 + 0x40000000) >> 31)
                     + v66
                     + ((unint64_t)(v64 * v62 + 0x40000000) >> 31)
                     - (((unint64_t)(v61 * v59 + 0x40000000) >> 31)
                      + ((unint64_t)(v65 * v63 + 0x40000000) >> 31));
        uint64_t v69 = *(void *)((char *)&coeffsB_3324 + v55 + 384);
        uint64_t v70 = *(void *)((char *)&coeffsB_3324 + v55 + 528);
        uint64_t v71 = *(void *)((char *)&coeffsC_3324 + v55 + 384);
        uint64_t v72 = *(void *)((char *)&coeffsC_3324 + v55 + 456);
        int v73 = ((unint64_t)(v69 * v59 + 0x40000000) >> 31)
            + v67
            + ((unint64_t)(v70 * v58 + 0x40000000) >> 31)
            + ((unint64_t)(v71 * v63 + 0x40000000) >> 31)
            + ((unint64_t)(v72 * v62 + 0x40000000) >> 31);
        LODWORD(v69) = ((unint64_t)(v69 * v58 + 0x40000000) >> 31)
                     + v66
                     + ((unint64_t)(v71 * v62 + 0x40000000) >> 31)
                     - (((unint64_t)(v70 * v59 + 0x40000000) >> 31)
                      + ((unint64_t)(v72 * v63 + 0x40000000) >> 31));
        uint64_t v74 = *(void *)((char *)&coeffsB_3324 + v55 + 576);
        uint64_t v75 = *(void *)((char *)&coeffsB_3324 + v55 + 720);
        uint64_t v76 = *(void *)((char *)&coeffsC_3324 + v55 + 576);
        uint64_t v77 = *(void *)((char *)&coeffsC_3324 + v55 + 648);
        *(v56 - 17) = v68;
        *(v56 - 16) = v60;
        *(v56 - 1) = v73;
        _DWORD *v56 = v69;
        v56[15] = ((unint64_t)(v74 * v59 + 0x40000000) >> 31)
                + v67
                + ((unint64_t)(v75 * v58 + 0x40000000) >> 31)
                + ((unint64_t)(v76 * v63 + 0x40000000) >> 31)
                + ((unint64_t)(v77 * v62 + 0x40000000) >> 31);
        v56[16] = ((unint64_t)(v74 * v58 + 0x40000000) >> 31)
                + v66
                + ((unint64_t)(v76 * v62 + 0x40000000) >> 31)
                - (((unint64_t)(v75 * v59 + 0x40000000) >> 31)
                 + ((unint64_t)(v77 * v63 + 0x40000000) >> 31));
        v57 += 2;
        v56 += 2;
        v55 += 24;
      }
      while (v55);
      v53 += 48;
      v54 += 192;
      BOOL v14 = v52 >= 0x30;
      v52 += 24;
    }
    while (!v14);
    uint64_t v78 = 0xC0u;
    uint64_t result = 6784;
    do
    {
      uint64_t v80 = *(int *)&v100[v78];
      uint64_t v79 = *(int *)&v100[v78 + 4];
      uint64_t v81 = *(void *)((char *)&coeffsB_3324 + v78 - 192);
      uint64_t v82 = *(void *)((char *)&coeffsB_3324 + v78 - 48);
      uint64_t v84 = *(int *)&v101[v78 + 124];
      uint64_t v83 = *(int *)&v101[v78 + 128];
      uint64_t v85 = *(void *)((char *)&coeffsC_3324 + v78 - 192);
      uint64_t v86 = *(void *)((char *)&coeffsC_3324 + v78 - 120);
      int v88 = *(_DWORD *)&v100[v78 - 192];
      int v87 = *(_DWORD *)&v100[v78 - 188];
      int v89 = ((unint64_t)(v81 * v80 + 0x40000000) >> 31)
          + v88
          + ((unint64_t)(v82 * v79 + 0x40000000) >> 31)
          + ((unint64_t)(v85 * v84 + 0x40000000) >> 31)
          + ((unint64_t)(v86 * v83 + 0x40000000) >> 31);
      LODWORD(v81) = ((unint64_t)(v81 * v79 + 0x40000000) >> 31)
                   + v87
                   + ((unint64_t)(v85 * v83 + 0x40000000) >> 31)
                   - (((unint64_t)(v82 * v80 + 0x40000000) >> 31)
                    + ((unint64_t)(v86 * v84 + 0x40000000) >> 31));
      uint64_t v90 = *(void *)((char *)&coeffsB_3324 + v78);
      uint64_t v91 = *(void *)((char *)&coeffsB_3324 + v78 + 144);
      uint64_t v92 = *(void *)((char *)&coeffsC_3324 + v78);
      uint64_t v93 = *(void *)((char *)&coeffsC_3324 + v78 + 72);
      LODWORD(v82) = ((unint64_t)(v90 * v80 + 0x40000000) >> 31)
                   + v88
                   + ((unint64_t)(v91 * v79 + 0x40000000) >> 31)
                   + ((unint64_t)(v92 * v84 + 0x40000000) >> 31)
                   + ((unint64_t)(v93 * v83 + 0x40000000) >> 31);
      LODWORD(v90) = ((unint64_t)(v90 * v79 + 0x40000000) >> 31)
                   + v87
                   + ((unint64_t)(v92 * v83 + 0x40000000) >> 31)
                   - (((unint64_t)(v91 * v80 + 0x40000000) >> 31)
                    + ((unint64_t)(v93 * v84 + 0x40000000) >> 31));
      uint64_t v94 = *(void *)((char *)&coeffsB_3324 + v78 + 192);
      uint64_t v95 = *(void *)((char *)&coeffsB_3324 + v78 + 336);
      uint64_t v96 = *(void *)((char *)&coeffsC_3324 + v78 + 192);
      uint64_t v97 = *(void *)((char *)&coeffsC_3324 + v78 + 264);
      int v98 = ((unint64_t)(v94 * v80 + 0x40000000) >> 31)
          + v88
          + ((unint64_t)(v95 * v79 + 0x40000000) >> 31)
          + ((unint64_t)(v96 * v84 + 0x40000000) >> 31)
          + ((unint64_t)(v97 * v83 + 0x40000000) >> 31);
      LODWORD(v79) = ((unint64_t)(v94 * v79 + 0x40000000) >> 31)
                   + v87
                   + ((unint64_t)(v96 * v83 + 0x40000000) >> 31);
      uint64_t v99 = (_DWORD *)(a2 + v78);
      *(v99 - 48) = v89;
      *(v99 - 47) = v81;
      *uint64_t v99 = v82;
      v99[1] = v90;
      v99[48] = v98;
      v99[49] = v79
              - (((unint64_t)(v95 * v80 + 0x40000000) >> 31)
               + ((unint64_t)(v97 * v84 + 0x40000000) >> 31));
      v78 += 8;
    }
    while (v78 != 384);
  }
  return result;
}

uint64_t tplTracker_IFFT_2D(uint64_t a1, char *a2, void *a3, int32x4_t a4)
{
  uint64_t v4 = 6780;
  if (a1 && a3)
  {
    uint64_t v8 = 0;
    int v9 = 72;
    do
    {
      uint64_t v10 = tplTracker_IFFT_3324(a1 + v8, (uint64_t)&a2[v8], a4);
      if (v10 != 128) {
        return v10;
      }
      v8 += 576;
      --v9;
    }
    while (v9);
    if (a2)
    {
      int v11 = 0;
      BOOL v12 = a3;
      uint64_t v13 = a2;
      do
      {
        uint64_t v14 = 0;
        uint64_t v15 = v12;
        do
        {
          *uint64_t v15 = *(void *)&v13[v14];
          v15 += 72;
          v14 += 8;
        }
        while (v14 != 576);
        v13 += 576;
        ++v12;
        ++v11;
      }
      while (v11 != 72);
      uint64_t v16 = 0;
      uint64_t v17 = 72;
      while (1)
      {
        uint64_t v4 = tplTracker_IFFT_3324((uint64_t)&a3[v16], (uint64_t)&a2[v16 * 8], a4);
        if (v4 != 128) {
          break;
        }
        v16 += 72;
        if (!--v17)
        {
          memcpy(a3, a2, 0xA200uLL);
          return v4;
        }
      }
    }
    else
    {
      return 6780;
    }
  }
  return v4;
}

void sub_1A3F6CE78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6CF40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6D990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CVPixelBufferRef *a11, __CVBuffer **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *__p,uint64_t a49)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6E1B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6E334(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6E440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6E5F0(_Unwind_Exception *a1)
{
}

uint64_t BinSerializer_fgetBlobInfo(FILE *a1, unsigned char *a2, void *a3, _WORD *a4, void *a5, void *a6, void *a7)
{
  uint64_t v14 = MEMORY[0x1A6256E50]();
  if (a2)
  {
    fseek(a1, 0, 0);
    uint64_t v15 = BinSerializer_fseek(a1, a2);
    if ((v15 & 0x80) != 0)
    {
      uint64_t v20 = 0;
      long long v18 = 0u;
      long long v19 = 0u;
      if (fread(&v18, 0x28uLL, 1uLL, a1))
      {
        *a3 = v18;
        *a4 = WORD4(v18);
        uint64_t v16 = *((void *)&v19 + 1);
        *a5 = v19;
        *a6 = v16;
        *a7 = v20;
      }
      else
      {
        uint64_t v15 = 373;
      }
    }
  }
  else
  {
    uint64_t v15 = 381;
  }
  fseek(a1, v14, 0);
  return v15;
}

uint64_t BinSerializer_freadInBytes(FILE *__stream, unsigned char *a2, void *a3, size_t *a4)
{
  if (!__stream) {
    return 381;
  }
  if (a2)
  {
    uint64_t v7 = BinSerializer_fseek(__stream, a2);
    if ((v7 & 0x80) == 0) {
      return v7;
    }
  }
  else
  {
    uint64_t v7 = 384;
  }
  size_t size = 0;
  memset(v11, 0, sizeof(v11));
  if (fread(v11, 0x28uLL, 1uLL, __stream) != 1) {
    return 373;
  }
  if (WORD4(v11[0]) != 9) {
    return 371;
  }
  size_t v8 = size;
  *a4 = size;
  int v9 = malloc_type_malloc(v8, 0x100004077774924uLL);
  *a3 = v9;
  if (!v9) {
    return 379;
  }
  if (fread(v9, 1uLL, v8, __stream) != v8) {
    return 373;
  }
  return v7;
}

uint64_t BinSerializer_convertFloats(uint64_t a1, float *a2, float *__dst)
{
  uint64_t v3 = &CVML_status_notImplementedError;
  switch(*(_WORD *)(a1 + 8))
  {
    case 1:
      uint64_t v4 = *(void *)(a1 + 32);
      if (!v4) {
        goto LABEL_13;
      }
      double v5 = *(double *)(a1 + 16);
      float v6 = *(double *)(a1 + 24) - v5;
      float v7 = v5;
      uint64_t v3 = &CVML_status_ok;
      do
      {
        unsigned int v8 = *(unsigned __int8 *)a2;
        a2 = (float *)((char *)a2 + 1);
        *__dst++ = (float)((float)(v6 * (float)v8) / 255.0) + v7;
        --v4;
      }
      while (v4);
      break;
    case 2:
      uint64_t v9 = *(void *)(a1 + 32);
      if (!v9) {
        goto LABEL_13;
      }
      double v10 = *(double *)(a1 + 16);
      float v11 = *(double *)(a1 + 24) - v10;
      float v12 = v10;
      uint64_t v3 = &CVML_status_ok;
      do
      {
        unsigned int v13 = *(unsigned __int16 *)a2;
        a2 = (float *)((char *)a2 + 2);
        *__dst++ = (float)((float)(v11 * (float)v13) / 65535.0) + v12;
        --v9;
      }
      while (v9);
      break;
    case 3:
      if (a2 != __dst) {
        memcpy(__dst, a2, 4 * *(void *)(a1 + 32));
      }
LABEL_13:
      uint64_t v3 = &CVML_status_ok;
      break;
    case 4:
      return (*v3 + 128) | 0x100;
    default:
      uint64_t v3 = &CVML_status_invalidType;
      break;
  }
  return (*v3 + 128) | 0x100;
}

void sub_1A3F6EACC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6ED3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6EFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A3F6F154(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F498(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F4F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F5A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F5F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F6A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6F74C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F6FDEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70198(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70270(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F7076C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F709BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70AE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70C0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70D28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70E40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F70FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  a9.super_class = (Class)VNSequenceRequestHandler;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F71160(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F71208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F712B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F71334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F713A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F71408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F71540(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F71694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753738;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753738;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void releaseContourDatabaseMemory(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 8) = 0;
  }
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3)
  {
    int v4 = *(_DWORD *)a1;
    if (*(int *)a1 >= 1)
    {
      int v5 = 0;
      float v6 = v3 + 7;
      do
      {
        if (*v6)
        {
          free(*v6);
          uint64_t *v6 = 0;
          int v4 = *(_DWORD *)a1;
        }
        ++v5;
        v6 += 5;
      }
      while (v5 < v4);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
    free(v3);
    *(void *)(a1 + 16) = 0;
  }
}

uint64_t SelfClosureContourHeal(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  *(void *)&v68[6] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(unsigned int *)(result + 4);
  int v47 = *(_DWORD *)result;
  uint64_t v9 = *(void *)(result + 8);
  uint64_t v8 = *(void *)(result + 16);
  int v65 = a3;
  uint64_t v53 = a3 << 32;
  if ((int)v7 >= 1)
  {
    uint64_t v10 = 0;
    int v48 = a3;
    uint64_t v55 = *(unsigned int *)(result + 4);
    uint64_t v56 = *(void *)(result + 16);
    uint64_t v54 = *(void *)(result + 8);
    do
    {
      uint64_t v11 = v8 + 40 * *(unsigned __int16 *)(v9 + 2 * v10);
      int v13 = *(unsigned __int8 *)(v11 + 8);
      float v12 = (unsigned char *)(v11 + 8);
      if (!v13 && *(unsigned char *)(v8 + 40 * *(unsigned __int16 *)(v9 + 2 * v10)))
      {
        unsigned __int16 v57 = *(_WORD *)(v9 + 2 * v10);
        uint64_t v14 = v8 + 40 * v57;
        uint64_t v16 = *(unsigned __int16 **)(v14 + 16);
        uint64_t v15 = (void *)(v14 + 16);
        uint64_t v17 = *v16;
        uint64_t v62 = (__int16)v17;
        uint64_t v18 = v16[1];
        long long v19 = &v16[2 * *((int *)v15 - 3)];
        uint64_t v20 = *(v19 - 2);
        uint64_t v61 = (__int16)v20;
        uint64_t v21 = *(v19 - 1);
        uint64_t v59 = (__int16)v18;
        uint64_t v60 = (__int16)v21;
        uint64_t v22 = v17 | (v18 << 16);
        uint64_t v23 = v20 | (v21 << 16);
        unint64_t v63 = v22 | v63 & 0xFFFFFFFF00000000;
        unint64_t v64 = v23 | v64 & 0xFFFFFFFF00000000;
        uint64_t result = healCenters(v63, v23, (uint64_t)v67);
        if (result)
        {
          int32x4_t v49 = (int *)v15 - 3;
          int32x4_t v50 = v15;
          unint64_t v52 = v12;
          uint64_t v24 = 0;
          uint64_t v25 = result;
          int8x16_t v26 = (__int16 *)v68;
          while (1)
          {
            uint64_t v27 = *(v26 - 1);
            int v28 = *v26;
            unint64_t v6 = v6 & 0xFFFFFFFF00000000 | v22;
            unint64_t v5 = v5 & 0xFFFFFFFF00000000 | v23;
            uint64_t result = heal((unsigned char *)(v27 + a2 + (v28 - 1) * (uint64_t)v65 - 1), v65, v6, v5, (uint64_t)v67, v24);
            if ((result & 0x80000000) == 0) {
              break;
            }
            v26 += 2;
            if (v25 == ++v24) {
              goto LABEL_9;
            }
          }
          uint64_t v8 = v56;
          if ((a5 & 1) == 0)
          {
            *(_WORD *)(a4 + 2 * v62 + ((v53 * v59) >> 31)) = 0;
            *(_WORD *)(a4 + 2 * v61 + ((v53 * v60) >> 31)) = 0;
          }
          switch((int)result)
          {
            case 0:
              uint64_t v29 = *v49;
              uint64_t v30 = (_WORD *)(*v50 + 4 * v29);
              *uint64_t v30 = v27;
              v30[1] = v28;
              *int32x4_t v49 = v29 + 1;
              uint64_t v31 = a2;
              goto LABEL_19;
            case 1:
              uint64_t v31 = a2;
              *(unsigned char *)(a2 + v62 + ((v53 * v59) >> 32)) = 0;
              int v32 = (_WORD *)*v50;
              _WORD *v32 = v27;
              v32[1] = v28;
              goto LABEL_19;
            case 2:
              uint64_t v31 = a2;
              *(unsigned char *)(a2 + v61 + ((v53 * v60) >> 32)) = 0;
              uint64_t v33 = *v50 + 4 * *v49;
              *(_WORD *)(v33 - 4) = v27;
              *(_WORD *)(v33 - 2) = v28;
              goto LABEL_19;
            case 3:
              uint64_t v31 = a2;
              *(unsigned char *)(a2 + v62 + ((v53 * v59) >> 32)) = 0;
              *(unsigned char *)(a2 + v61 + ((v53 * v60) >> 32)) = 0;
              unint64_t v34 = (_WORD *)*v50;
              *unint64_t v34 = v27;
              v34[1] = v28;
              --*v49;
LABEL_19:
              *(unsigned char *)(v31 + v27 + v28 * (uint64_t)v48) = 1;
              break;
            default:
              break;
          }
          unsigned char *v52 = 1;
        }
        else
        {
LABEL_9:
          if (a5)
          {
            *(_WORD *)(a4 + 2 * v62 + ((v53 * v59) >> 31)) = v57;
            *(_WORD *)(a4 + 2 * v61 + ((v53 * v60) >> 31)) = v57;
          }
          uint64_t v8 = v56;
        }
        uint64_t v9 = v54;
        uint64_t v7 = v55;
      }
      ++v10;
    }
    while (v10 != v7);
  }
  if (a5 && (int)v7 < v47 - 1)
  {
    uint64_t v35 = v47 - 1 - (uint64_t)(int)v7;
    int v36 = (unsigned __int16 *)(v9 + 2 * (int)v7);
    do
    {
      unsigned int v38 = *v36++;
      unsigned int v37 = v38;
      if (!*(unsigned char *)(v8 + 40 * v38 + 8))
      {
        uint64_t v39 = v8 + 40 * v37;
        int v40 = *(__int16 **)(v39 + 16);
        uint64_t v41 = *v40;
        uint64_t v42 = v40[1];
        int32x4_t v43 = &v40[2 * *(int *)(v39 + 4)];
        uint64_t v44 = *(v43 - 2);
        uint64_t v45 = *(v43 - 1);
        int v46 = -v37;
        *(_WORD *)(a4 + 2 * v41 + ((v53 * v42) >> 31)) = v46;
        *(_WORD *)(a4 + 2 * v44 + ((v53 * v45) >> 31)) = v46;
      }
      --v35;
    }
    while (v35);
  }
  return result;
}

uint64_t healCenters(unint64_t a1, int a2, uint64_t a3)
{
  int v3 = (__int16)a2 - (__int16)a1;
  int v4 = (a2 >> 16) - ((int)a1 >> 16);
  if (v3 >= 0) {
    unsigned int v5 = (__int16)a2 - (__int16)a1;
  }
  else {
    unsigned int v5 = (__int16)a1 - (__int16)a2;
  }
  if (v4 >= 0) {
    unsigned int v6 = (a2 >> 16) - ((int)a1 >> 16);
  }
  else {
    unsigned int v6 = ((int)a1 >> 16) - (a2 >> 16);
  }
  BOOL v7 = v5 > 2 || v6 > 2;
  if (!v7 && (v5 <= 1 ? (BOOL v8 = v6 > 1) : (BOOL v8 = 1), v8))
  {
    BOOL v9 = HIWORD(a2) == WORD1(a1) || v6 == 2;
    BOOL v10 = v5 == 2 && v9;
    BOOL v11 = (unsigned __int16)a2 == (unsigned __int16)a1 && v6 == 2;
    if (v10 || v11)
    {
      *(_WORD *)a3 = a1 + (v3 >> 1);
      *(_WORD *)(a3 + 2) = (v4 >> 1) + WORD1(a1);
      *(_DWORD *)(a3 + 4) = 0;
      return 1;
    }
    else
    {
      if (v5 == 2)
      {
        int v12 = a1 + (v3 >> 1);
        *(_WORD *)a3 = v12;
        *(_WORD *)(a3 + 2) = WORD1(a1);
        *(_WORD *)(a3 + 4) = v12;
        *(_WORD *)(a3 + 6) = HIWORD(a2);
      }
      else
      {
        if (v6 != 2) {
          __assert_rtn("healCenters", "Contours.c", 133, "ady == 2");
        }
        *(_WORD *)a3 = a1;
        int v14 = (a1 >> 16) + (v4 >> 1);
        *(_WORD *)(a3 + 2) = v14;
        *(_WORD *)(a3 + 4) = a2;
        *(_WORD *)(a3 + 6) = v14;
      }
      return 2;
    }
  }
  else
  {
    uint64_t result = 0;
    *(void *)a3 = 0;
  }
  return result;
}

uint64_t heal(unsigned char *a1, int a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  unsigned int v6 = (__int16 *)(a5 + 4 * a6);
  int v7 = *v6;
  int v8 = v6[1];
  int v9 = 3 * ((__int16)a3 - v7) - v8 + (a3 >> 16);
  int v10 = v9 + 5;
  int v11 = 3 * ((__int16)a4 - v7) - v8 + (a4 >> 16);
  int v12 = v11 + 5;
  switch((*a1 | (8 * a1[1]) | (32 * a1[2]) | (2 * a1[a2]) | (a1[a2 + 2] << 6) | (4 * a1[2 * a2]) | (16 * a1[2 * a2 + 1])) | (a1[2 * a2 + 2] << 7))
  {
    case 12:
    case 17:
    case 24:
    case 34:
    case 36:
    case 48:
    case 65:
    case 66:
    case 68:
    case 129:
    case 130:
    case 136:
      return 0;
    case 13:
    case 25:
    case 44:
    case 56:
    case 137:
    case 168:
      if (v11 == -1) {
        unsigned int v13 = 2;
      }
      else {
        unsigned int v13 = -1;
      }
      BOOL v14 = v10 == 4;
      goto LABEL_18;
    case 21:
    case 28:
    case 52:
    case 145:
    case 152:
    case 176:
      if (v11 == 1) {
        unsigned int v13 = 2;
      }
      else {
        unsigned int v13 = -1;
      }
      BOOL v14 = v10 == 6;
      goto LABEL_18;
    case 29:
    case 60:
    case 153:
    case 184:
      BOOL v17 = v9 == -1 && v12 == 6;
      BOOL v18 = v12 == 4 && v10 == 6;
      goto LABEL_52;
    case 35:
    case 38:
    case 67:
    case 70:
    case 131:
    case 134:
      if (v11 == -3) {
        unsigned int v13 = 2;
      }
      else {
        unsigned int v13 = -1;
      }
      BOOL v14 = v10 == 2;
      goto LABEL_18;
    case 50:
      if ((v10 & 0xFFFFFFFB) == 2) {
        return 1;
      }
      if ((v12 & 0xFFFFFFFB) != 2) {
        __assert_rtn("heal", "Contours.c", 213, "(endpoint2 == 6)|| (endpoint2 == 2)");
      }
      return 2;
    case 76:
      uint64_t result = 1;
      if (v9 != -1 && v9 != 3)
      {
        uint64_t result = 2;
        if (v11 != -1 && v11 != 3) {
          __assert_rtn("heal", "Contours.c", 207, "(endpoint2 == 4)|| (endpoint2 == 8)");
        }
      }
      return result;
    case 81:
      if ((v9 | 2) == 3) {
        return 1;
      }
      if ((v11 | 2) != 3) {
        __assert_rtn("heal", "Contours.c", 210, "(endpoint2 == 8)|| (endpoint2 == 6)");
      }
      return 2;
    case 97:
    case 98:
    case 100:
    case 193:
    case 194:
    case 196:
      if (v11 == 3) {
        unsigned int v13 = 2;
      }
      else {
        unsigned int v13 = -1;
      }
      BOOL v14 = v10 == 8;
LABEL_18:
      if (v14) {
        return 1;
      }
      else {
        return v13;
      }
    case 99:
    case 102:
    case 195:
      BOOL v17 = v9 == -3 && v12 == 8;
      BOOL v18 = v12 == 2 && v10 == 8;
LABEL_52:
      if (v18 || v17) {
        return 3;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    case 138:
      if ((v9 | 2) == 0xFFFFFFFF) {
        return 1;
      }
      if ((v11 | 2) != 0xFFFFFFFF) {
        __assert_rtn("heal", "Contours.c", 216, "(endpoint2 == 2)|| (endpoint2 == 4)");
      }
      return 2;
    default:
      return 0xFFFFFFFFLL;
  }
}

uint64_t testJoin(__int16 *a1, uint64_t a2, uint64_t a3, _WORD *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  __int16 v6 = 3 * (v5 - a1[3]) + v4 - a1[2];
  if ((unsigned __int16)(v6 - 5) <= 0xFFF6u) {
    __assert_rtn("testJoin", "Contours.c", 427, "(orn >= 0) && (orn <= 8)");
  }
  __int16 v7 = *a1;
  uint64_t v8 = a2 + 2 * v4;
  __int16 v9 = a1[1];
  uint64_t v10 = a3 << 32;
  int v11 = *(__int16 *)(v8 + (((a3 << 32) * v5) >> 31));
  if ((unsigned __int16)(v6 - 5) >= 0xFFF6u)
  {
    switch(v6)
    {
      case 0:
        __assert_rtn("testJoin", "Contours.c", 443, "orn != 4");
      case 1:
        for (uint64_t i = 0; i != 11; ++i)
        {
          *(_WORD *)&v24[2 * i + 22] = v7 - testJoin_sy[i];
          *(_WORD *)&v24[2 * i] = v9 + testJoin_sx[i];
        }
        break;
      case 2:
        for (uint64_t j = 0; j != 11; ++j)
        {
          *(_WORD *)&v24[2 * j + 22] = v7 + testJoin_rx[j];
          *(_WORD *)&v24[2 * j] = v9 - testJoin_ry[j];
        }
        break;
      case 3:
        for (uint64_t k = 0; k != 11; ++k)
        {
          *(_WORD *)&v24[2 * k + 22] = v7 + testJoin_sx[k];
          *(_WORD *)&v24[2 * k] = v9 - testJoin_sy[k];
        }
        break;
      case 4:
        for (uint64_t m = 0; m != 11; ++m)
        {
          *(_WORD *)&v24[2 * m + 22] = v7 - testJoin_rx[m];
          *(_WORD *)&v24[2 * m] = v9 - testJoin_ry[m];
        }
        break;
      default:
        JUMPOUT(0);
    }
  }
  else
  {
    switch(v6)
    {
      case -4:
        for (uint64_t n = 0; n != 11; ++n)
        {
          *(_WORD *)&v24[2 * n + 22] = v7 + testJoin_rx[n];
          *(_WORD *)&v24[2 * n] = v9 + testJoin_ry[n];
        }
        break;
      case -3:
        for (iuint64_t i = 0; ii != 11; ++ii)
        {
          *(_WORD *)&v24[2 * ii + 22] = v7 + testJoin_sx[ii];
          *(_WORD *)&v24[2 * ii] = v9 + testJoin_sy[ii];
        }
        break;
      case -2:
        for (juint64_t j = 0; jj != 11; ++jj)
        {
          *(_WORD *)&v24[2 * jj + 22] = v7 - testJoin_rx[jj];
          *(_WORD *)&v24[2 * jj] = v9 + testJoin_ry[jj];
        }
        break;
      case -1:
        for (kuint64_t k = 0; kk != 11; ++kk)
        {
          *(_WORD *)&v24[2 * kk + 22] = v7 + testJoin_sy[kk];
          *(_WORD *)&v24[2 * kk] = v9 + testJoin_sx[kk];
        }
        break;
      default:
        break;
    }
  }
  uint64_t v20 = 0;
  uint64_t result = 0;
  do
  {
    uint64_t v22 = *(__int16 *)&v24[v20 + 22];
    uint64_t v23 = (v10 * *(__int16 *)&v24[v20]) >> 31;
    if (*(_WORD *)(a2 + 2 * v22 + v23))
    {
      if (result) {
        goto LABEL_35;
      }
      __int16 v7 = *(_WORD *)&v24[v20 + 22];
      __int16 v9 = *(_WORD *)&v24[v20];
      uint64_t result = *(__int16 *)(a2 + 2 * v22 + v23);
    }
    v20 += 2;
  }
  while (v20 != 22);
  if (result == v11 || (int)result <= 0)
  {
LABEL_35:
    __int16 v7 = 0;
    __int16 v9 = 0;
    uint64_t result = 0;
  }
  *a4 = v7;
  a4[1] = v9;
  return result;
}

int8x16_t canonicalizeQuad(uint64_t a1, float a2)
{
  if (a2 < 0.0)
  {
    int8x16_t result = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
    *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)(a1 + 16), *(int8x16_t *)(a1 + 16), 8uLL);
    *(int8x16_t *)(a1 + 16) = result;
  }
  uint64_t v3 = 0;
  uint64_t v4 = (float *)(a1 + 4);
  int v5 = -1;
  result.i32[0] = 1399379109;
  do
  {
    float v6 = *v4;
    float v7 = (float)(v6 * v6) + (float)(*(v4 - 1) * *(v4 - 1));
    if (v7 <= *(float *)result.i32 && (v7 != *(float *)result.i32 || v6 < *(float *)(a1 + 8 * v5 + 4)))
    {
      *(float *)result.i32 = (float)(v6 * v6) + (float)(*(v4 - 1) * *(v4 - 1));
      int v5 = v3;
    }
    ++v3;
    v4 += 2;
  }
  while (v3 != 4);
  switch(v5)
  {
    case 1:
      result.i64[0] = *(void *)a1;
      long long v9 = *(_OWORD *)(a1 + 8);
      *(void *)(a1 + 16) = *(void *)(a1 + 24);
      *(_OWORD *)a1 = v9;
      *(void *)(a1 + 24) = result.i64[0];
      break;
    case 2:
      int8x16_t result = *(int8x16_t *)a1;
      *(_OWORD *)a1 = *(_OWORD *)(a1 + 16);
      *(int8x16_t *)(a1 + 16) = result;
      break;
    case 3:
      uint64_t v8 = *(void *)(a1 + 16);
      *(_OWORD *)(a1 + 8) = *(_OWORD *)a1;
      result.i64[0] = *(void *)(a1 + 24);
      *(void *)(a1 + 24) = v8;
      *(void *)a1 = result.i64[0];
      break;
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  float v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        float v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        float v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        float v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    float v7 = a1 + 1;
LABEL_9:
    long long v9 = operator new(0x48uLL);
    v9[8] = *a3;
    *((void *)v9 + 6) = 0;
    *((void *)v9 + 7) = 0;
    *((void *)v9 + 5) = 0;
    *((unsigned char *)v9 + 64) = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t vision::mod::LandmarkDetectorDNN_Options::LandmarkDetectorDNN_Options(uint64_t a1, int a2)
{
  *(unsigned char *)a1 = a2;
  *(_OWORD *)(a1 + 4) = xmmword_1A410C110;
  *(void *)(a1 + 24) = 0;
  uint64_t v3 = (_DWORD *)(a1 + 24);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = a1 + 56;
  uint64_t v4 = (uint64_t **)(a1 + 48);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 72) = a1 + 80;
  int v5 = (uint64_t **)(a1 + 72);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  float v6 = (uint64_t **)(a1 + 96);
  *(void *)(a1 + 112) = 0;
  if (a2 == 2)
  {
    *(unsigned char *)(a1 + 47) = 5;
    *uint64_t v3 = 1734438249;
    *(unsigned char *)(a1 + 28) = 101;
    *(unsigned char *)(a1 + 29) = 0;
    int v45 = 1;
    uint64_t v22 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>((uint64_t **)(a1 + 48), 1, &v45);
    if (*((char *)v22 + 63) < 0)
    {
      v22[6] = (uint64_t *)12;
      uint64_t v23 = (char *)v22[5];
    }
    else
    {
      uint64_t v23 = (char *)(v22 + 5);
      *((unsigned char *)v22 + 63) = 12;
    }
    strcpy(v23, "landmarks_63");
    int v45 = 1;
    *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 1, &v45)+ 64) = 0;
    int v45 = 1;
    uint64_t v33 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45);
    unint64_t v34 = v33 + 5;
    if (*((char *)v33 + 63) < 0) {
      operator delete(*v34);
    }
    *unint64_t v34 = 0;
    v34[1] = 0;
    v34[2] = 0;
    int v45 = 1;
    *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45)+ 64) = 0;
    int v45 = 1;
    uint64_t v35 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45);
    int v36 = v35 + 5;
    if (*((char *)v35 + 63) < 0) {
      operator delete(*v36);
    }
    *int v36 = 0;
    v36[1] = 0;
    void v36[2] = 0;
    int v45 = 1;
    *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45)+ 64) = 0;
    int v45 = 2;
    unsigned int v37 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45);
    if (*((char *)v37 + 63) < 0)
    {
      v37[6] = (uint64_t *)12;
      unsigned int v38 = (char *)v37[5];
    }
    else
    {
      unsigned int v38 = (char *)(v37 + 5);
      *((unsigned char *)v37 + 63) = 12;
    }
    strcpy(v38, "landmarks_76");
    int v45 = 2;
    *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45)+ 64) = 1;
    int v45 = 2;
    uint64_t v39 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45);
    if (*((char *)v39 + 63) < 0)
    {
      v39[6] = (uint64_t *)10;
      int v40 = (char *)v39[5];
    }
    else
    {
      int v40 = (char *)(v39 + 5);
      *((unsigned char *)v39 + 63) = 10;
    }
    strcpy(v40, "confidence");
    int v45 = 2;
    *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45)+ 64) = 0;
    int v45 = 2;
    uint64_t v41 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
    if (*((char *)v41 + 63) < 0)
    {
      v41[6] = (uint64_t *)9;
      uint64_t v42 = (char *)v41[5];
    }
    else
    {
      uint64_t v42 = (char *)(v41 + 5);
      *((unsigned char *)v41 + 63) = 9;
    }
    strcpy(v42, "occlusion");
    int v45 = 2;
    long long v19 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
  }
  else
  {
    if (a2 == 1)
    {
      *(unsigned char *)(a1 + 47) = 5;
      *uint64_t v3 = 1734438249;
      *(unsigned char *)(a1 + 28) = 101;
      *(unsigned char *)(a1 + 29) = 0;
      int v45 = 1;
      uint64_t v20 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>((uint64_t **)(a1 + 48), 1, &v45);
      if (*((char *)v20 + 63) < 0)
      {
        v20[6] = (uint64_t *)9;
        uint64_t v21 = (char *)v20[5];
      }
      else
      {
        uint64_t v21 = (char *)(v20 + 5);
        *((unsigned char *)v20 + 63) = 9;
      }
      strcpy(v21, "landmarks");
      int v45 = 1;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 1, &v45)+ 64) = 0;
      int v45 = 1;
      uint64_t v24 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45);
      uint64_t v25 = v24 + 5;
      if (*((char *)v24 + 63) < 0) {
        operator delete(*v25);
      }
      *uint64_t v25 = 0;
      v25[1] = 0;
      v25[2] = 0;
      int v45 = 1;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45)+ 64) = 0;
      int v45 = 1;
      int8x16_t v26 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45);
      uint64_t v27 = v26 + 5;
      if (*((char *)v26 + 63) < 0) {
        operator delete(*v27);
      }
      *uint64_t v27 = 0;
      v27[1] = 0;
      v27[2] = 0;
      int v45 = 1;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45)+ 64) = 0;
      int v45 = 2;
      int v28 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45);
      uint64_t v29 = v28 + 5;
      if (*((char *)v28 + 63) < 0) {
        operator delete(*v29);
      }
      *uint64_t v29 = 0;
      v29[1] = 0;
      v29[2] = 0;
      int v45 = 2;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45)+ 64) = 0;
      int v45 = 2;
      uint64_t v30 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45);
      uint64_t v31 = v30 + 5;
      if (*((char *)v30 + 63) < 0) {
        operator delete(*v31);
      }
      void *v31 = 0;
      v31[1] = 0;
      v31[2] = 0;
      int v45 = 2;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45)+ 64) = 0;
      int v45 = 2;
      int v32 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
      BOOL v18 = v32 + 5;
      if (*((char *)v32 + 63) < 0) {
        operator delete(*v18);
      }
    }
    else
    {
      if (a2)
      {
        exceptiouint64_t n = __cxa_allocate_exception(8uLL);
        *exceptiouint64_t n = 2935;
        __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
      }
      *(void *)uint64_t v3 = 0;
      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 40) = 0;
      int v45 = 1;
      float v7 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>((uint64_t **)(a1 + 48), 1, &v45);
      int v8 = v7 + 5;
      if (*((char *)v7 + 63) < 0) {
        operator delete(*v8);
      }
      *int v8 = 0;
      v8[1] = 0;
      v8[2] = 0;
      int v45 = 1;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 1, &v45)+ 64) = 0;
      int v45 = 1;
      long long v9 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45);
      uint64_t v10 = v9 + 5;
      if (*((char *)v9 + 63) < 0) {
        operator delete(*v10);
      }
      *uint64_t v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
      int v45 = 1;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45)+ 64) = 0;
      int v45 = 1;
      int v11 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45);
      int v12 = v11 + 5;
      if (*((char *)v11 + 63) < 0) {
        operator delete(*v12);
      }
      *int v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
      int v45 = 1;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45)+ 64) = 0;
      int v45 = 2;
      unsigned int v13 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45);
      BOOL v14 = v13 + 5;
      if (*((char *)v13 + 63) < 0) {
        operator delete(*v14);
      }
      *BOOL v14 = 0;
      v14[1] = 0;
      v14[2] = 0;
      int v45 = 2;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45)+ 64) = 0;
      int v45 = 2;
      uint64_t v15 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45);
      uint64_t v16 = v15 + 5;
      if (*((char *)v15 + 63) < 0) {
        operator delete(*v16);
      }
      *uint64_t v16 = 0;
      v16[1] = 0;
      v16[2] = 0;
      int v45 = 2;
      *((unsigned char *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45)+ 64) = 0;
      int v45 = 2;
      BOOL v17 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
      BOOL v18 = v17 + 5;
      if (*((char *)v17 + 63) < 0) {
        operator delete(*v18);
      }
    }
    *BOOL v18 = 0;
    v18[1] = 0;
    v18[2] = 0;
    int v45 = 2;
    long long v19 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
  }
  *((unsigned char *)v19 + 64) = 0;
  return a1;
}

void sub_1A3F72C98(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(v1 + 104));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(v1 + 80));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(v1 + 56));
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(a1);
}

void vision::mod::LandmarkDetectorDNN_Options::getBlobNamesOutput(std::vector<std::string> *this, uint64_t **a2, int a3)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  float v6 = operator new(8uLL);
  char v7 = 0;
  uint64_t v8 = 0;
  void *v6 = 0x200000001;
  do
  {
    char v9 = v7;
    int v10 = *((_DWORD *)v6 + v8);
    int v11 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[7], v10);
    uint64_t v12 = *((unsigned __int8 *)v11 + 23);
    if ((v12 & 0x80u) != 0) {
      uint64_t v12 = v11[1];
    }
    if (v12
      && *((unsigned __int8 *)std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[7], v10) + 24) == a3)
    {
      unsigned int v13 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[7], v10);
      std::vector<std::string>::pointer end = this->__end_;
      if (end >= this->__end_cap_.__value_)
      {
        std::vector<std::string>::pointer v15 = std::vector<std::string>::__push_back_slow_path<std::string const&>(this, (long long *)v13);
      }
      else
      {
        std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)this, (long long *)v13);
        std::vector<std::string>::pointer v15 = end + 1;
      }
      this->__end_ = v15;
    }
    uint64_t v16 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[10], v10);
    uint64_t v17 = *((unsigned __int8 *)v16 + 23);
    if ((v17 & 0x80u) != 0) {
      uint64_t v17 = v16[1];
    }
    if (v17
      && *((unsigned __int8 *)std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[10], v10) + 24) == a3)
    {
      BOOL v18 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[10], v10);
      std::vector<std::string>::pointer v19 = this->__end_;
      if (v19 >= this->__end_cap_.__value_)
      {
        std::vector<std::string>::pointer v20 = std::vector<std::string>::__push_back_slow_path<std::string const&>(this, (long long *)v18);
      }
      else
      {
        std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)this, (long long *)v18);
        std::vector<std::string>::pointer v20 = v19 + 1;
      }
      this->__end_ = v20;
    }
    uint64_t v21 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[13], v10);
    uint64_t v22 = *((unsigned __int8 *)v21 + 23);
    if ((v22 & 0x80u) != 0) {
      uint64_t v22 = v21[1];
    }
    if (v22
      && *((unsigned __int8 *)std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[13], v10) + 24) == a3)
    {
      uint64_t v23 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[13], v10);
      std::vector<std::string>::pointer v24 = this->__end_;
      if (v24 >= this->__end_cap_.__value_)
      {
        std::vector<std::string>::pointer v25 = std::vector<std::string>::__push_back_slow_path<std::string const&>(this, (long long *)v23);
      }
      else
      {
        std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)this, (long long *)v23);
        std::vector<std::string>::pointer v25 = v24 + 1;
      }
      this->__end_ = v25;
    }
    char v7 = 1;
    uint64_t v8 = 1;
  }
  while ((v9 & 1) == 0);

  operator delete(v6);
}

void sub_1A3F72EC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t *std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(uint64_t *a1, int a2)
{
  if (!a1) {
LABEL_8:
  }
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      int v2 = *((_DWORD *)a1 + 8);
      if (v2 <= a2) {
        break;
      }
      a1 = (uint64_t *)*a1;
      if (!a1) {
        goto LABEL_8;
      }
    }
    if (v2 >= a2) {
      return a1 + 5;
    }
    a1 = (uint64_t *)a1[1];
    if (!a1) {
      goto LABEL_8;
    }
  }
}

void vision::mod::LandmarkDetectorDNN_Options::getBlobNamesOutput(std::vector<std::string> *this, uint64_t **a2)
{
  vision::mod::LandmarkDetectorDNN_Options::getBlobNamesOutput(this, a2, 0);
  vision::mod::LandmarkDetectorDNN_Options::getBlobNamesOutput(&v33, a2, 1);
  begiuint64_t n = v33.__begin_;
  if ((char *)v33.__end_ - (char *)v33.__begin_ >= 1)
  {
    std::vector<std::string>::pointer end = this->__end_;
    int64_t v6 = v33.__end_ - v33.__begin_;
    value = this->__end_cap_.__value_;
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)end) >> 3)) >= v6)
    {
      if (v6 <= 0)
      {
        unsigned int v13 = &v33.__begin_[v6];
        BOOL v14 = &end[v6];
        std::vector<std::string>::pointer v15 = &end[-v6];
        std::vector<std::string>::pointer v16 = this->__end_;
        if (v15 < end)
        {
          std::vector<std::string>::pointer v16 = this->__end_;
          do
          {
            long long v17 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
            v16->__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v17;
            ++v16;
            v15->__r_.__value_.__l.__size_ = 0;
            v15->__r_.__value_.__r.__words[2] = 0;
            v15->__r_.__value_.__r.__words[0] = 0;
            ++v15;
          }
          while (v15 < end);
        }
        this->__end_ = v16;
        if (end != v14)
        {
          BOOL v18 = end - 1;
          uint64_t v19 = 8 * (((char *)end - (char *)v14) >> 3);
          do
          {
            if (SHIBYTE(v18->__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v18->__r_.__value_.__l.__data_);
            }
            std::vector<std::string>::pointer v20 = (long long *)((char *)&end[-1] + v19);
            long long v21 = *v20;
            v18->__r_.__value_.__r.__words[2] = end->__r_.__value_.__r.__words[(unint64_t)v19 / 8 - 1];
            *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v21;
            --v18;
            end->__r_.__value_.__s.__data_[v19 - 1] = 0;
            *(unsigned char *)std::vector<std::string>::pointer v20 = 0;
            v19 -= 24;
          }
          while (v19);
        }
        while (begin != v13)
          std::string::operator=(end++, begin++);
      }
      else
      {
        this->__end_ = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((uint64_t)&this->__end_cap_, (long long *)v33.__begin_, (long long *)v33.__end_, this->__end_);
      }
    }
    else
    {
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)this->__begin_) >> 3);
      unint64_t v9 = v8 + v6;
      if (v8 + v6 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)this->__begin_) >> 3);
      if (2 * v10 > v9) {
        unint64_t v9 = 2 * v10;
      }
      if (v10 >= 0x555555555555555) {
        unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v11 = v9;
      }
      v34.__end_cap_.__value_ = (std::allocator<std::string> *)&this->__end_cap_;
      if (v11) {
        unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v11);
      }
      else {
        uint64_t v12 = 0;
      }
      uint64_t v22 = (std::string *)(v11 + 24 * v8);
      v34.__first_ = (std::__split_buffer<std::string>::pointer)v11;
      v34.__begin_ = v22;
      v34.__end_ = v22;
      v34.__end_cap_.__value_ = (std::string *)(v11 + 24 * v12);
      uint64_t v23 = 3 * v6;
      std::vector<std::string>::pointer v24 = &v22[v6];
      uint64_t v25 = 8 * v23;
      do
      {
        if (SHIBYTE(begin->__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(v22, begin->__r_.__value_.__l.__data_, begin->__r_.__value_.__l.__size_);
        }
        else
        {
          long long v26 = *(_OWORD *)&begin->__r_.__value_.__l.__data_;
          v22->__r_.__value_.__r.__words[2] = begin->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v22->__r_.__value_.__l.__data_ = v26;
        }
        ++v22;
        ++begin;
        v25 -= 24;
      }
      while (v25);
      v34.__end_ = v24;
      v34.__begin_ = (std::__split_buffer<std::string>::pointer)std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)end, (uint64_t)end, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)v34.__begin_, (uint64_t)v34.__begin_);
      uint64_t v27 = this->__end_;
      std::__split_buffer<std::string>::pointer v28 = v34.__end_;
      std::__split_buffer<std::string>::pointer v37 = v34.__end_;
      std::__split_buffer<std::string>::pointer v38 = v34.__end_;
      v35[0] = &this->__end_cap_;
      v35[1] = &v37;
      v35[2] = &v38;
      if (end != v27)
      {
        do
        {
          long long v29 = *(_OWORD *)&end->__r_.__value_.__l.__data_;
          v28->__r_.__value_.__r.__words[2] = end->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v28->__r_.__value_.__l.__data_ = v29;
          ++v28;
          end->__r_.__value_.__l.__size_ = 0;
          end->__r_.__value_.__r.__words[2] = 0;
          end->__r_.__value_.__r.__words[0] = 0;
          ++end;
        }
        while (end != v27);
        std::__split_buffer<std::string>::pointer v38 = v28;
      }
      char v36 = 1;
      std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v35);
      long long v30 = *(_OWORD *)&this->__begin_;
      uint64_t v31 = v34.__end_cap_.__value_;
      this->__begin_ = v34.__begin_;
      this->__end_ = v28;
      *(_OWORD *)&v34.__begin_ = v30;
      int v32 = this->__end_cap_.__value_;
      this->__end_cap_.__value_ = v31;
      v34.__end_cap_.__value_ = v32;
      v34.__first_ = (std::__split_buffer<std::string>::pointer)v30;
      std::__split_buffer<std::string>::~__split_buffer(&v34);
    }
  }
  v34.__first_ = (std::__split_buffer<std::string>::pointer)&v33;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v34);
}

void sub_1A3F73270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__split_buffer<std::string> *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  *(void *)(v17 + 8) = v18;
  a17 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a17);
  a17 = (void **)v17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a17);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceIDKmeansParams::serialize()
{
  uint64_t v0 = (void *)std::ostream::write();
  if ((*((unsigned char *)v0 + *(void *)(*v0 - 24) + 32) & 5) != 0
    || (uint64_t v1 = (void *)std::ostream::write(), (*((unsigned char *)v1 + *(void *)(*v1 - 24) + 32) & 5) != 0))
  {
    int v2 = &CVML_status_IOError;
  }
  else
  {
    uint64_t v4 = (void *)std::ostream::write();
    int v2 = &CVML_status_IOError;
    if ((*((unsigned char *)v4 + *(void *)(*v4 - 24) + 32) & 5) == 0)
    {
      int v5 = (void *)std::ostream::write();
      if ((*((unsigned char *)v5 + *(void *)(*v5 - 24) + 32) & 5) == 0) {
        int v2 = &CVML_status_ok;
      }
    }
  }
  return (*v2 + 128) | 0x1E00;
}

uint64_t vision::mod::FaceIDKmeansParams::deserialize()
{
  uint64_t v0 = (void *)std::istream::read();
  if ((*((unsigned char *)v0 + *(void *)(*v0 - 24) + 32) & 5) != 0
    || (uint64_t v1 = (void *)std::istream::read(), (*((unsigned char *)v1 + *(void *)(*v1 - 24) + 32) & 5) != 0))
  {
    int v2 = &CVML_status_IOError;
  }
  else
  {
    uint64_t v4 = (void *)std::istream::read();
    int v2 = &CVML_status_IOError;
    if ((*((unsigned char *)v4 + *(void *)(*v4 - 24) + 32) & 5) == 0)
    {
      int v5 = (void *)std::istream::read();
      if ((*((unsigned char *)v5 + *(void *)(*v5 - 24) + 32) & 5) == 0) {
        int v2 = &CVML_status_ok;
      }
    }
  }
  return (*v2 + 128) | 0x1E00;
}

double vision::mod::FaceIDModel::FaceIDModel(vision::mod::FaceIDModel *this, int a2, int a3, int a4, int a5, float a6, int a7, int a8)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  *((_DWORD *)this + 10) = a2;
  *((_DWORD *)this + 11) = a4;
  *((_DWORD *)this + 12) = a3;
  *((_DWORD *)this + 13) = a5;
  *((_DWORD *)this + 14) = a8;
  *((float *)this + 15) = a6;
  *((_DWORD *)this + 16) = a7;
  *(void *)&double result = 0x12C0000000ALL;
  *(void *)((char *)this + 68) = 0x12C0000000ALL;
  *((void *)this + 10) = 0x3F1A36E2EB1C432DLL;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((void *)this + 15) = 0;
  *((unsigned char *)this + 128) = 1;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 176) = 1;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *((_DWORD *)this + 54) = 1065353216;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_DWORD *)this + 64) = 1065353216;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((unsigned char *)this + 312) = 1;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((unsigned char *)this + 384) = 1;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *((unsigned char *)this + 424) = 1;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((unsigned char *)this + 464) = 1;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *((unsigned char *)this + 504) = 1;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((unsigned char *)this + 544) = 1;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *((unsigned char *)this + 584) = 1;
  *((void *)this + 76) = 0;
  *((void *)this + 74) = 0;
  *((void *)this + 75) = 0;
  return result;
}

void *std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::find<long long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  int v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  double result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(void *)&v2) {
            v7 %= *(void *)&v2;
          }
        }
        else
        {
          v7 &= *(void *)&v2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      double result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t *a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v12 = a1 + 2;
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = a1[1];
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v19 = operator new(8 * *(void *)&prime);
          std::vector<std::string>::pointer v20 = (void *)*a1;
          *a1 = (uint64_t)v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          uint64_t v22 = (void *)*v12;
          if (*v12)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v23) = v12;
            std::__split_buffer<std::string>::pointer v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*a1 + 8 * v29))
                  {
                    *(void *)(*a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *uint64_t v22 = *v28;
                  *std::__split_buffer<std::string>::pointer v28 = **(void **)(*a1 + 8 * v29);
                  **(void **)(*a1 + 8 * v29) = v28;
                  std::__split_buffer<std::string>::pointer v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                uint64_t v22 = v28;
                std::__split_buffer<std::string>::pointer v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        std::__split_buffer<std::string> v34 = (void *)*a1;
        *a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v30 = *a1;
  uint64_t v31 = *(void **)(*a1 + 8 * v3);
  if (v31)
  {
    *unint64_t v10 = *v31;
LABEL_72:
    void *v31 = v10;
    goto LABEL_73;
  }
  *unint64_t v10 = *v12;
  *uint64_t v12 = v10;
  *(void *)(v30 + 8 * v3) = v12;
  if (*v10)
  {
    unint64_t v32 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    uint64_t v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_1A3F73A94(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(float *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x20uLL);
  *unint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  *((_DWORD *)v10 + 6) = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (v7 && (float)(v13 * (float)v7) >= v12)
  {
    unint64_t v5 = v3;
    goto LABEL_64;
  }
  BOOL v14 = 1;
  if (v7 >= 3) {
    BOOL v14 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v15 = v14 | (2 * v7);
  unint64_t v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16) {
    int8x8_t prime = (int8x8_t)v16;
  }
  else {
    int8x8_t prime = (int8x8_t)v15;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      unint64_t v24 = std::__next_prime(v24);
    }
    else
    {
      uint64_t v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2) {
        unint64_t v24 = v26;
      }
    }
    if (*(void *)&prime <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      std::vector<std::string> v33 = *(void **)a1;
      *(void *)a1 = 0;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v18 = operator new(8 * *(void *)&prime);
  uint64_t v19 = *(void **)a1;
  *(void *)a1 = v18;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v20++) = 0;
  while (*(void *)&prime != v20);
  uint64_t v21 = (void *)*((void *)a1 + 2);
  if (v21)
  {
    unint64_t v22 = v21[1];
    uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(void *)&prime) {
        v22 %= *(void *)&prime;
      }
    }
    else
    {
      v22 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
    uint64_t v27 = (void *)*v21;
    if (*v21)
    {
      do
      {
        unint64_t v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(void *)&prime) {
            v28 %= *(void *)&prime;
          }
        }
        else
        {
          v28 &= *(void *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(void *)(*(void *)a1 + 8 * v28))
          {
            *(void *)(*(void *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          *uint64_t v21 = *v27;
          *uint64_t v27 = **(void **)(*(void *)a1 + 8 * v28);
          **(void **)(*(void *)a1 + 8 * v28) = v27;
          uint64_t v27 = v21;
        }
        unint64_t v28 = v22;
LABEL_56:
        uint64_t v21 = v27;
        uint64_t v27 = (void *)*v27;
        unint64_t v22 = v28;
      }
      while (v27);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  unint64_t v29 = *(void **)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * v5);
  if (v30)
  {
    *unint64_t v10 = *v30;
LABEL_72:
    *uint64_t v30 = v10;
    goto LABEL_73;
  }
  *unint64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v5] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7) {
        v31 %= v7;
      }
    }
    else
    {
      v31 &= v7 - 1;
    }
    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A3F73E88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *vision::mod::CVMLMatrix<double,16ul>::reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 40))
  {
    unint64_t v6 = *(void **)a1;
    if (*(void *)a1) {
      free(v6);
    }
  }
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(unsigned char *)(a1 + 40) = 1;

  return vision::mod::CVMLMatrix<double,16ul>::initialize_(a1, a2, a3);
}

char *vision::mod::CVMLMatrix<double,16ul>::initialize_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = ((a3 << 63 >> 63) & ((16 - 8 * (unint64_t)(a3 & 1)) >> 3)) + a3;
  double result = (char *)malloc_type_calloc(8 * a2 * v6 + 15, 1uLL, 0x6E22AE6BuLL);
  if (!result)
  {
    exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v10 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v10, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  uint64_t v8 = 16 - (result & 0xF);
  if ((result & 0xF) == 0) {
    uint64_t v8 = 0;
  }
  *(void *)a1 = result;
  *(void *)(a1 + 8) = &result[v8];
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = v6;
  *(void *)(a1 + 16) = a2;
  *(unsigned char *)(a1 + 40) = 1;
  return result;
}

void *std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(float *a1, int a2, int *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x20uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  int v12 = *a3;
  *((_DWORD *)v10 + 5) = 0;
  *((_DWORD *)v10 + 6) = 0;
  *((_DWORD *)v10 + 4) = v12;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v19 = operator new(8 * *(void *)&prime);
          uint64_t v20 = *(void **)a1;
          *(void *)a1 = v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          unint64_t v22 = (void *)*((void *)a1 + 2);
          if (v22)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v23) = a1 + 4;
            unint64_t v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v29))
                  {
                    *(void *)(*(void *)a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *unint64_t v22 = *v28;
                  *unint64_t v28 = **(void **)(*(void *)a1 + 8 * v29);
                  **(void **)(*(void *)a1 + 8 * v29) = v28;
                  unint64_t v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                unint64_t v22 = v28;
                unint64_t v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        std::__split_buffer<std::string> v34 = *(void **)a1;
        *(void *)a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v30 = *(void **)a1;
  unint64_t v31 = *(void **)(*(void *)a1 + 8 * v3);
  if (v31)
  {
    *unint64_t v10 = *v31;
LABEL_72:
    void *v31 = v10;
    goto LABEL_73;
  }
  *unint64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v30[v3] = a1 + 4;
  if (*v10)
  {
    unint64_t v32 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    unint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A3F743B4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::CVMLMatrix<double,16ul>::ptr(void *a1, unint64_t a2)
{
  if (a1[2] <= a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"row index ", 10);
    unint64_t v3 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" of ", 4);
    std::ostream::operator<<();
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v5, (uint64_t)&v7);
    std::logic_error::logic_error(exception, &v5);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
  }
  return a1[1] + 8 * a1[4] * a2;
}

{
  void *v3;
  std::logic_error *exception;
  std::string v5;
  uint64_t v6;
  uint64_t v7;

  if (a1[2] <= a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"row index ", 10);
    unint64_t v3 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" of ", 4);
    std::ostream::operator<<();
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v5, (uint64_t)&v7);
    std::logic_error::logic_error(exception, &v5);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
  }
  return a1[1] + 8 * a1[4] * a2;
}

void sub_1A3F744C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  std::string v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1A3F74680(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1A6256200](v1);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1A6256200](a1 + 112);
  return a1;
}

uint64_t vision::mod::CVMLMatrix<double,16ul>::mean(uint64_t result, void *a2, char a3)
{
  uint64_t v4 = (void *)result;
  if (a3)
  {
    double result = (uint64_t)vision::mod::CVMLVector<double,16ul>::reset((uint64_t)a2, *(void *)(result + 24));
    unint64_t v5 = v4[3];
  }
  else
  {
    unint64_t v5 = *(void *)(result + 24);
    if (a2[2] < v5)
    {
      exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "vector length < cols");
      __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
    }
  }
  if (v5)
  {
    unint64_t v6 = 0;
    unint64_t v7 = v4[2];
    do
    {
      if (v7)
      {
        unint64_t v8 = 0;
        double v9 = 0.0;
        do
        {
          double result = vision::mod::CVMLMatrix<double,16ul>::ptr(v4, v8);
          double v9 = v9 + *(double *)(result + 8 * v6);
          ++v8;
          unint64_t v7 = v4[2];
        }
        while (v8 < v7);
        unint64_t v5 = v4[3];
      }
      else
      {
        double v9 = 0.0;
      }
      *(double *)(a2[1] + 8 * a2[3] * v6++) = v9 / (double)v7;
    }
    while (v6 < v5);
  }
  return result;
}

void sub_1A3F748AC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void vision::mod::CVMLMatrix<double,16ul>::rowNorms(uint64_t a1, void *a2, char a3)
{
  if (a3)
  {
    vision::mod::CVMLVector<double,16ul>::reset((uint64_t)a2, *(void *)(a1 + 16));
    unint64_t v5 = *(void *)(a1 + 16);
  }
  else
  {
    unint64_t v5 = *(void *)(a1 + 16);
    if (a2[2] < v5)
    {
      exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "vector length < rows");
      __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
    }
  }
  if (v5)
  {
    unint64_t v6 = 0;
    do
    {
      unint64_t v7 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr((void *)a1, v6);
      *(double *)(a2[1] + 8 * a2[3] * v6++) = cblas_ddot(*(_DWORD *)(a1 + 24), v7, 1, v7, 1);
    }
    while (v6 < *(void *)(a1 + 16));
  }
}

void sub_1A3F74998(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1A3F74AAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void *vision::mod::broadcastAdd<double,16ul>(void *a1, void *a2, int a3, void *a4)
{
  v5[4] = *MEMORY[0x1E4F143B8];
  v5[0] = &unk_1EF7531A0;
  v5[3] = v5;
  vision::mod::broadcast<double,16ul>(a1, a2, (uint64_t)v5, a3, a4);
  return std::__function::__value_func<double ()(double,double)>::~__value_func[abi:ne180100](v5);
}

void sub_1A3F74B80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<double ()(double,double)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::broadcast<double,16ul>(void *a1, void *a2, uint64_t a3, int a4, void *a5)
{
  unint64_t v9 = a1[2];
  if (v9 > a5[2] && a1[3] > a5[3])
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "matrix size too small for output");
    std::vector<std::string> v33 = (struct type_info *)off_1E5B19CC8;
    std::__split_buffer<std::string> v34 = (void (*)(void *))MEMORY[0x1E4FBA1D0];
    goto LABEL_27;
  }
  if (a4 != 1)
  {
    if (a4)
    {
      exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "unknown axis value");
LABEL_26:
      std::vector<std::string> v33 = (struct type_info *)off_1E5B19CD8;
      std::__split_buffer<std::string> v34 = (void (*)(void *))MEMORY[0x1E4FBA1E8];
LABEL_27:
      __cxa_throw(exception, v33, v34);
    }
    if (a2[2] == a1[3])
    {
      uint64_t v10 = vision::mod::CVMLMatrix<double,16ul>::ptr(a1, 0);
      uint64_t v11 = a1[4];
      uint64_t result = vision::mod::CVMLMatrix<double,16ul>::ptr(a5, 0);
      unint64_t v13 = a1[2];
      if (v13)
      {
        uint64_t v14 = result;
        unint64_t v15 = 0;
        unint64_t v16 = a1[3];
        uint64_t v17 = 8 * a5[4];
        uint64_t v18 = 8 * v11;
        do
        {
          if (v16)
          {
            for (unint64_t i = 0; i < v16; ++i)
            {
              uint64_t result = std::function<double ()(double,double)>::operator()(*(void *)(a3 + 24), *(double *)(v10 + 8 * i), *(double *)(a2[1] + 8 * a2[3] * i));
              *(void *)(v14 + 8 * i) = v20;
              unint64_t v16 = a1[3];
            }
            unint64_t v13 = a1[2];
          }
          ++v15;
          v14 += v17;
          v10 += v18;
        }
        while (v15 < v13);
      }
      return result;
    }
LABEL_25:
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "broadcast op: dimension mismatch");
    goto LABEL_26;
  }
  if (a2[2] != v9) {
    goto LABEL_25;
  }
  uint64_t v21 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a1, 0);
  uint64_t v22 = a1[4];
  uint64_t result = vision::mod::CVMLMatrix<double,16ul>::ptr(a5, 0);
  unint64_t v23 = a1[3];
  if (v23)
  {
    uint8x8_t v24 = (void *)result;
    unint64_t v25 = 0;
    unint64_t v26 = a1[2];
    uint64_t v27 = 8 * a5[4];
    uint64_t v28 = 8 * v22;
    do
    {
      if (v26)
      {
        unint64_t v29 = 0;
        uint64_t v35 = v21;
        uint64_t v30 = v24;
        do
        {
          uint64_t result = std::function<double ()(double,double)>::operator()(*(void *)(a3 + 24), *v21, *(double *)(a2[1] + 8 * a2[3] * v29));
          *uint64_t v30 = v31;
          ++v29;
          unint64_t v26 = a1[2];
          uint64_t v30 = (void *)((char *)v30 + v27);
          uint64_t v21 = (double *)((char *)v21 + v28);
        }
        while (v29 < v26);
        unint64_t v23 = a1[3];
        uint64_t v21 = v35;
      }
      ++v25;
      ++v24;
      ++v21;
    }
    while (v25 < v23);
  }
  return result;
}

void sub_1A3F74E08(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<double ()(double,double)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

std::logic_error *std::invalid_argument::invalid_argument[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4E8] + 16);
  return result;
}

uint64_t std::function<double ()(double,double)>::operator()(uint64_t a1, double a2, double a3)
{
  double v4 = a3;
  double v5 = a2;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, double *, double *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

void *std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::target_type()
{
}

uint64_t std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"ZN6vision3mod12broadcastAddIdLm16EEEvRKNS0_10CVMLMatrixIT_XT0_EEERKNS0_10CVMLVectorIS3_XT0_EEEiRS4_bEUlddE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

double std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::operator()(uint64_t a1, double *a2, double *a3)
{
  return *a2 + *a3;
}

void std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF7531A0;
}

void *std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF7531A0;
  return result;
}

void std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::~__func()
{
}

void *std::vector<double>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<long long>::__vallocate[abi:ne180100](a1, a2);
    double v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1A3F75060(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *vision::mod::CVMLVector<double,16ul>::initialize_(uint64_t a1, uint64_t a2)
{
  uint64_t result = (char *)malloc_type_calloc(8 * a2 + 15, 1uLL, 0xA9532734uLL);
  if (!result)
  {
    exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v7 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v7, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  uint64_t v5 = 16 - (result & 0xF);
  if ((result & 0xF) == 0) {
    uint64_t v5 = 0;
  }
  *(void *)a1 = result;
  *(void *)(a1 + 8) = &result[v5];
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = 1;
  *(unsigned char *)(a1 + 32) = 1;
  return result;
}

void vision::mod::Kmeans<double,16ul>::labelEstimation_(void *a1, int a2, uint64_t a3, void **a4, void *a5, void *__b, double *a7, double *a8)
{
  uint64_t v16 = a1[2];
  uint64_t v17 = 8 * v16;
  if (v16)
  {
    memset(__b, 255, 4 * v16);
    memset_pattern16(a7, &unk_1A410C4D0, 8 * v16);
  }
  vision::mod::euclideanDistances<double,16ul>(a3, a1, a5, a4);
  if (a2 >= 1)
  {
    unint64_t v18 = 0;
    do
    {
      uint64_t v19 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a5, v18);
      if (v16)
      {
        uint64_t v20 = a7;
        uint64_t v21 = __b;
        uint64_t v22 = v16;
        do
        {
          double v23 = *v19;
          if (*v19 < *v20)
          {
            *uint64_t v21 = v18;
            *uint64_t v20 = v23;
          }
          ++v21;
          ++v20;
          ++v19;
          --v22;
        }
        while (v22);
      }
      ++v18;
    }
    while (v18 != a2);
  }
  double v24 = 0.0;
  if (v16)
  {
    do
    {
      double v25 = *a7++;
      double v24 = v24 + v25;
      v17 -= 8;
    }
    while (v17);
  }
  *a8 = v24;
}

void *std::get_temporary_buffer[abi:ne180100]<unsigned long>(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  if (a1 >= 0xFFFFFFFFFFFFFFFLL) {
    unint64_t v1 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v1 = a1;
  }
  uint64_t v2 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
  while (1)
  {
    uint64_t result = operator new(8 * v1, v2);
    if (result) {
      break;
    }
    BOOL v4 = v1 > 1;
    v1 >>= 1;
    if (!v4) {
      return 0;
    }
  }
  return result;
}

uint64_t *std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    unint64_t v8 = (char *)result;
    if (a4 == 2)
    {
      uint64_t v9 = *(a2 - 1);
      uint64_t v10 = *result;
      if (*(double *)(**a3 + 8 * v9) > *(double *)(**a3 + 8 * *result))
      {
        *uint64_t result = v9;
        *(a2 - 1) = v10;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      uint64_t v22 = (char *)a5;
      unint64_t v23 = a4 >> 1;
      double v24 = &result[a4 >> 1];
      unint64_t v25 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, v25, a5);
        unint64_t v26 = (uint64_t *)&v22[8 * v23];
        uint64_t result = std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>((uint64_t *)&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v26);
        uint64_t v27 = &v22[8 * a4];
        uint64_t v28 = *a3;
        unint64_t v29 = v26;
        while (v29 != (uint64_t *)v27)
        {
          uint64_t v30 = *v29;
          double v31 = *(double *)(*v28 + 8 * *v29);
          double v32 = *(double *)(*v28 + 8 * *(void *)v22);
          if (v31 <= v32) {
            uint64_t v30 = *(void *)v22;
          }
          v22 += 8 * (v31 <= v32);
          v29 += v31 > v32;
          *(void *)unint64_t v8 = v30;
          v8 += 8;
          if (v22 == (char *)v26)
          {
            if (v29 != (uint64_t *)v27)
            {
              uint64_t v33 = 0;
              do
              {
                *(void *)&v8[v33 * 8] = v29[v33];
                ++v33;
              }
              while (&v29[v33] != (uint64_t *)v27);
            }
            return result;
          }
        }
        if (v22 != (char *)v26)
        {
          uint64_t v34 = 0;
          do
          {
            *(void *)&v8[v34] = *(void *)&v22[v34];
            v34 += 8;
          }
          while (&v22[v34] != (char *)v26);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, v25, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v22, a6);
        return (uint64_t *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v8, &v8[8 * (a4 >> 1)], (char *)a2, a3, a4 >> 1, a4 - (a4 >> 1), v22, a6);
      }
    }
    else if (result != a2)
    {
      int v12 = result + 1;
      if (result + 1 != a2)
      {
        uint64_t v13 = 0;
        uint64_t v14 = **a3;
        unint64_t v15 = result;
        do
        {
          uint64_t v17 = *v15;
          uint64_t v16 = v15[1];
          unint64_t v15 = v12;
          double v18 = *(double *)(v14 + 8 * v16);
          if (v18 > *(double *)(v14 + 8 * v17))
          {
            uint64_t v19 = v13;
            while (1)
            {
              *(uint64_t *)((char *)result + v19 + 8) = v17;
              if (!v19) {
                break;
              }
              uint64_t v17 = *(uint64_t *)((char *)result + v19 - 8);
              v19 -= 8;
              if (v18 <= *(double *)(v14 + 8 * v17))
              {
                uint64_t v20 = (uint64_t *)((char *)result + v19 + 8);
                goto LABEL_15;
              }
            }
            uint64_t v20 = result;
LABEL_15:
            *uint64_t v20 = v16;
          }
          int v12 = v15 + 1;
          v13 += 8;
        }
        while (v15 + 1 != a2);
      }
    }
  }
  return result;
}

uint64_t *std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5)
{
  if (a4)
  {
    uint64_t v5 = a5;
    unint64_t v7 = result;
    if (a4 == 1)
    {
LABEL_8:
      *uint64_t v5 = *v7;
      return result;
    }
    if (a4 == 2)
    {
      uint64_t v10 = *(a2 - 1);
      uint64_t v11 = **a3;
      double v12 = *(double *)(v11 + 8 * v10);
      double v13 = *(double *)(v11 + 8 * *result);
      if (v12 <= v13) {
        uint64_t v10 = *result;
      }
      *a5 = v10;
      uint64_t v5 = a5 + 1;
      if (v12 <= v13) {
        unint64_t v7 = a2 - 1;
      }
      goto LABEL_8;
    }
    if ((uint64_t)a4 > 8)
    {
      double v24 = &result[a4 >> 1];
      std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, a4 >> 1, a5, a4 >> 1);
      uint64_t result = (uint64_t *)std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      unint64_t v25 = *a3;
      unint64_t v26 = &v7[a4 >> 1];
      while (v26 != a2)
      {
        uint64_t v27 = *v26;
        double v28 = *(double *)(*v25 + 8 * *v26);
        double v29 = *(double *)(*v25 + 8 * *v7);
        if (v28 <= v29) {
          uint64_t v27 = *v7;
        }
        v26 += v28 > v29;
        v7 += v28 <= v29;
        *v5++ = v27;
        if (v7 == v24)
        {
          if (v26 != a2)
          {
            uint64_t v30 = 0;
            do
            {
              v5[v30] = v26[v30];
              ++v30;
            }
            while (&v26[v30] != a2);
          }
          return result;
        }
      }
      if (v7 != v24)
      {
        uint64_t v31 = 0;
        do
        {
          v5[v31] = v7[v31];
          ++v31;
        }
        while (&v7[v31] != v24);
      }
    }
    else if (result != a2)
    {
      uint64_t v14 = result + 1;
      *a5 = *result;
      if (result + 1 != a2)
      {
        uint64_t v15 = 0;
        uint64_t v16 = **a3;
        uint64_t v17 = a5;
        double v18 = a5;
        do
        {
          uint64_t v20 = *v18++;
          uint64_t v19 = v20;
          if (*(double *)(v16 + 8 * *v14) <= *(double *)(v16 + 8 * v20))
          {
            *double v18 = *v14;
          }
          else
          {
            v17[1] = v19;
            uint64_t v21 = a5;
            if (v17 != a5)
            {
              uint64_t v22 = v15;
              while (1)
              {
                uint64_t v21 = (uint64_t *)((char *)a5 + v22);
                uint64_t v23 = *(uint64_t *)((char *)a5 + v22 - 8);
                if (*(double *)(v16 + 8 * *v14) <= *(double *)(v16 + 8 * v23)) {
                  break;
                }
                *uint64_t v21 = v23;
                v22 -= 8;
                if (!v22)
                {
                  uint64_t v21 = a5;
                  break;
                }
              }
            }
            *uint64_t v21 = *v14;
          }
          ++v14;
          v15 += 8;
          uint64_t v17 = v18;
        }
        while (v14 != a2);
      }
    }
  }
  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(char *result, char *a2, char *a3, uint64_t **a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  if (a6)
  {
    uint64_t v10 = a6;
    double v13 = result;
    while (v10 > a8 && a5 > a8)
    {
      if (!a5) {
        return result;
      }
      uint64_t v14 = **a4;
      while (1)
      {
        uint64_t v15 = *(void *)v13;
        if (*(double *)(v14 + 8 * *(void *)a2) > *(double *)(v14 + 8 * *(void *)v13)) {
          break;
        }
        v13 += 8;
        if (!--a5) {
          return result;
        }
      }
      uint64_t v51 = a8;
      unint64_t v52 = a3;
      if (a5 >= v10)
      {
        if (a5 == 1)
        {
          *(void *)double v13 = *(void *)a2;
          *(void *)a2 = v15;
          return result;
        }
        uint64_t v16 = a4;
        if (a5 >= 0) {
          uint64_t v27 = a5;
        }
        else {
          uint64_t v27 = a5 + 1;
        }
        uint64_t v26 = v27 >> 1;
        uint64_t v20 = &v13[8 * (v27 >> 1)];
        uint64_t v19 = a3;
        if (a3 != a2)
        {
          unint64_t v28 = (a3 - a2) >> 3;
          uint64_t v19 = a2;
          do
          {
            unint64_t v29 = v28 >> 1;
            uint64_t v30 = &v19[8 * (v28 >> 1)];
            uint64_t v32 = *(void *)v30;
            uint64_t v31 = v30 + 8;
            v28 += ~(v28 >> 1);
            if (*(double *)(v14 + 8 * v32) > *(double *)(v14 + 8 * *(void *)v20)) {
              uint64_t v19 = v31;
            }
            else {
              unint64_t v28 = v29;
            }
          }
          while (v28);
        }
        uint64_t v18 = (v19 - a2) >> 3;
      }
      else
      {
        uint64_t v16 = a4;
        if (v10 >= 0) {
          uint64_t v17 = v10;
        }
        else {
          uint64_t v17 = v10 + 1;
        }
        uint64_t v18 = v17 >> 1;
        uint64_t v19 = &a2[8 * (v17 >> 1)];
        uint64_t v20 = a2;
        if (a2 != v13)
        {
          unint64_t v21 = (a2 - v13) >> 3;
          uint64_t v20 = v13;
          do
          {
            unint64_t v22 = v21 >> 1;
            uint64_t v23 = &v20[8 * (v21 >> 1)];
            uint64_t v25 = *(void *)v23;
            double v24 = v23 + 8;
            v21 += ~(v21 >> 1);
            if (*(double *)(v14 + 8 * *(void *)v19) > *(double *)(v14 + 8 * v25)) {
              unint64_t v21 = v22;
            }
            else {
              uint64_t v20 = v24;
            }
          }
          while (v21);
        }
        uint64_t v26 = (v20 - v13) >> 3;
      }
      a5 -= v26;
      v10 -= v18;
      uint64_t v33 = v26;
      uint64_t v34 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,unsigned long *>(v20, a2, v19);
      uint64_t v35 = v33;
      char v36 = v34;
      if (v35 + v18 >= a5 + v10)
      {
        uint64_t v39 = v52;
        uint64_t v53 = v35;
        uint64_t result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v34, v19, v39, v16, a5, v10, a7, v51);
        uint64_t v19 = v20;
        a4 = v16;
        a8 = v51;
        uint64_t v10 = v18;
        a5 = v53;
        a3 = v36;
      }
      else
      {
        std::__split_buffer<std::string>::pointer v37 = v20;
        a4 = v16;
        std::__split_buffer<std::string>::pointer v38 = v16;
        a8 = v51;
        uint64_t result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v13, v37, v34, v38, v35, v18, a7, v51);
        double v13 = v36;
        a3 = v52;
      }
      a2 = v19;
      if (!v10) {
        return result;
      }
    }
    if (a5 <= v10)
    {
      if (v13 != a2)
      {
        uint64_t v44 = 0;
        do
        {
          *(void *)&a7[v44] = *(void *)&v13[v44];
          v44 += 8;
        }
        while (&v13[v44] != a2);
        int v45 = &a7[v44];
        if (v45 != a7)
        {
          int v46 = *a4;
          while (a2 != a3)
          {
            uint64_t v47 = *(void *)a2;
            double v48 = *(double *)(*v46 + 8 * *(void *)a2);
            double v49 = *(double *)(*v46 + 8 * *(void *)a7);
            if (v48 <= v49) {
              uint64_t v47 = *(void *)a7;
            }
            a7 += 8 * (v48 <= v49);
            a2 += 8 * (v48 > v49);
            *(void *)double v13 = v47;
            v13 += 8;
            if (a7 == v45) {
              return result;
            }
          }
          return (char *)memmove(v13, a7, v45 - a7);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v40 = 0;
      do
      {
        *(void *)&a7[v40] = *(void *)&a2[v40];
        v40 += 8;
      }
      while (&a2[v40] != a3);
      uint64_t v41 = &a7[v40];
      if (v41 != a7)
      {
        uint64_t v42 = a3 - 8;
        while (a2 != v13)
        {
          uint64_t v43 = *((void *)v41 - 1);
          if (*(double *)(**a4 + 8 * v43) <= *(double *)(**a4 + 8 * *((void *)a2 - 1)))
          {
            v41 -= 8;
          }
          else
          {
            uint64_t v43 = *((void *)a2 - 1);
            a2 -= 8;
          }
          *(void *)uint64_t v42 = v43;
          v42 -= 8;
          if (v41 == a7) {
            return result;
          }
        }
        uint64_t v50 = 0;
        do
        {
          *(void *)&v42[v50] = *(void *)&v41[v50 - 8];
          v50 -= 8;
        }
        while (&v41[v50] != a7);
      }
    }
  }
  return result;
}

char *std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,unsigned long *>(char *__src, char *a2, char *a3)
{
  uint64_t v3 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 8 == a2)
    {
      uint64_t v11 = *(void *)__src;
      int64_t v12 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      uint64_t v3 = &__src[v12];
      *(void *)uint64_t v3 = v11;
    }
    else if (a2 + 8 == a3)
    {
      double v13 = a3 - 8;
      uint64_t v14 = *((void *)a3 - 1);
      uint64_t v3 = __src + 8;
      size_t v15 = a3 - 8 - __src;
      if (v13 != __src) {
        memmove(__src + 8, __src, v15);
      }
      *(void *)__src = v14;
    }
    else
    {
      uint64_t v5 = (a2 - __src) >> 3;
      if (v5 == (a3 - a2) >> 3)
      {
        uint64_t v6 = 0;
        do
        {
          uint64_t v7 = *(void *)&__src[v6];
          *(void *)&__src[v6] = *(void *)&a2[v6];
          unint64_t v8 = &__src[v6 + 8];
          *(void *)&a2[v6] = v7;
          uint64_t v9 = (uint64_t)&a2[v6 + 8];
          v6 += 8;
        }
        while (v8 != a2 && v9 != (void)a3);
        return a2;
      }
      else
      {
        uint64_t v16 = (a3 - a2) >> 3;
        uint64_t v17 = (a2 - __src) >> 3;
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = v16;
          uint64_t v16 = v18 % v16;
        }
        while (v16);
        if (v17)
        {
          uint64_t v19 = &__src[8 * v17];
          do
          {
            uint64_t v21 = *((void *)v19 - 1);
            v19 -= 8;
            uint64_t v20 = v21;
            unint64_t v22 = &v19[8 * v5];
            uint64_t v23 = v19;
            do
            {
              double v24 = v23;
              uint64_t v23 = v22;
              *(void *)double v24 = *(void *)v22;
              BOOL v25 = __OFSUB__(v5, (a3 - v22) >> 3);
              uint64_t v27 = v5 - ((a3 - v22) >> 3);
              char v26 = (v27 < 0) ^ v25;
              unint64_t v22 = &__src[8 * v27];
              if (v26) {
                unint64_t v22 = &v23[8 * v5];
              }
            }
            while (v22 != v19);
            *(void *)uint64_t v23 = v20;
          }
          while (v19 != __src);
        }
        return &__src[8 * ((a3 - a2) >> 3)];
      }
    }
  }
  return v3;
}

void vision::mod::euclideanDistances<double,16ul>(uint64_t a1, void *a2, void *a3, void **a4)
{
  if (*(void *)(a1 + 24) != a2[3])
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "dimensions of data points mismatch");
    uint64_t v17 = (struct type_info *)off_1E5B19CD8;
    uint64_t v18 = (void (*)(void *))MEMORY[0x1E4FBA1E8];
LABEL_28:
    __cxa_throw(exception, v17, v18);
  }
  if (*(void *)(a1 + 16) > a3[2] || (unint64_t v7 = a2[2], v7 > a3[3]))
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "output distance matrix too small");
    uint64_t v17 = (struct type_info *)off_1E5B19CC8;
    uint64_t v18 = (void (*)(void *))MEMORY[0x1E4FBA1D0];
    goto LABEL_28;
  }
  unint64_t v8 = a4;
  *(_OWORD *)unint64_t v22 = 0u;
  long long v23 = 0u;
  char v24 = 1;
  if (!a4)
  {
    vision::mod::CVMLVector<double,16ul>::reset((uint64_t)v22, v7);
    unint64_t v8 = v22;
    vision::mod::CVMLMatrix<double,16ul>::rowNorms((uint64_t)a2, v22, 0);
  }
  *(_OWORD *)uint64_t v19 = 0u;
  long long v20 = 0u;
  uint64_t v9 = v8;
  char v21 = 1;
  if ((void *)a1 != a2)
  {
    vision::mod::CVMLVector<double,16ul>::reset((uint64_t)v19, *(void *)(a1 + 16));
    uint64_t v9 = v19;
    vision::mod::CVMLMatrix<double,16ul>::rowNorms(a1, v19, 0);
  }
  vision::mod::matMult<double,16ul>(a1, a2, 1, a3, 0, -2.0, 0.0);
  vision::mod::broadcastAdd<double,16ul>(a3, v9, 1, a3);
  vision::mod::broadcastAdd<double,16ul>(a3, v8, 0, a3);
  if (a3[2])
  {
    unint64_t v10 = 0;
    do
    {
      uint64_t v11 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a3, v10);
      for (uint64_t i = a3[3]; i; --i)
      {
        *uint64_t v11 = fmax(*v11, 0.0);
        ++v11;
      }
      ++v10;
      unint64_t v13 = a3[2];
    }
    while (v10 < v13);
    if ((void *)a1 == a2 && v13)
    {
      unint64_t v14 = 0;
      do
      {
        *(void *)(vision::mod::CVMLMatrix<double,16ul>::ptr(a3, v14) + 8 * v14) = 0;
        ++v14;
      }
      while (v14 < a3[2]);
    }
  }
  if (v21 && v19[0]) {
    free(v19[0]);
  }
  if (v24)
  {
    size_t v15 = v22[0];
    if (v22[0])
    {
      free(v15);
    }
  }
}

void sub_1A3F75E74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

char *vision::mod::CVMLVector<double,16ul>::reset(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 32))
  {
    BOOL v4 = *(void **)a1;
    if (*(void *)a1) {
      free(v4);
    }
  }
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(unsigned char *)(a1 + 32) = 1;

  return vision::mod::CVMLVector<double,16ul>::initialize_(a1, a2);
}

void vision::mod::matMult<double,16ul>(uint64_t a1, void *a2, int a3, void *a4, char a5, double a6, double a7)
{
  uint64_t v13 = *(void *)(a1 + 24);
  if (a3)
  {
    if (v13 == a2[3])
    {
      unint64_t v14 = a2 + 2;
      goto LABEL_6;
    }
LABEL_17:
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "matrix size mismatch");
    unint64_t v29 = (struct type_info *)off_1E5B19CD8;
    uint64_t v30 = (void (*)(void *))MEMORY[0x1E4FBA1E8];
    goto LABEL_19;
  }
  if (v13 != a2[2]) {
    goto LABEL_17;
  }
  unint64_t v14 = a2 + 3;
LABEL_6:
  unint64_t v15 = *(void *)(a1 + 16);
  unint64_t v16 = *v14;
  if ((a5 & 1) == 0)
  {
    if (a4[2] >= v15 && a4[3] >= v16) {
      goto LABEL_10;
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "matrix size too small for output");
    unint64_t v29 = (struct type_info *)off_1E5B19CC8;
    uint64_t v30 = (void (*)(void *))MEMORY[0x1E4FBA1D0];
LABEL_19:
    __cxa_throw(exception, v29, v30);
  }
  vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)a4, v15, v16);
LABEL_10:
  int v17 = *(_DWORD *)(a1 + 16);
  int v18 = *(_DWORD *)(a1 + 24);
  uint64_t v19 = (int *)(a2 + 2);
  BOOL v20 = a3 == 0;
  if (a3) {
    CBLAS_TRANSPOSE v21 = CblasTrans;
  }
  else {
    CBLAS_TRANSPOSE v21 = CblasNoTrans;
  }
  if (v20) {
    uint64_t v19 = (int *)(a2 + 3);
  }
  int v22 = *v19;
  long long v23 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr((void *)a1, 0);
  int v24 = *(_DWORD *)(a1 + 32);
  __B = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a2, 0);
  uint64_t __ldb = a2[4];
  uint64_t __C = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a4, 0);
  cblas_dgemm(CblasRowMajor, CblasNoTrans, v21, v17, v22, v18, a6, v23, v24, __B, __ldb, a7, __C, a4[4]);
}

void sub_1A3F76108(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this, _DWORD *a2)
{
  uint64_t result = a2[1];
  int v4 = result - *a2;
  if (result != *a2)
  {
    unsigned int v5 = v4 + 1;
    if (v4 == -1)
    {
      return std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this);
    }
    else
    {
      uint64_t v7 = __clz(v5);
      uint64_t v8 = 31;
      if (((v5 << v7) & 0x7FFFFFFF) != 0) {
        uint64_t v8 = 32;
      }
      unint64_t v9 = v8 - v7;
      unint64_t v10 = v9 >> 5;
      if ((v9 & 0x1F) != 0) {
        ++v10;
      }
      if (v10 <= v9) {
        unsigned int v11 = 0xFFFFFFFF >> -(v9 / v10);
      }
      else {
        unsigned int v11 = 0;
      }
      do
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v12 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this) & v11;
      while (v12 >= v5);
      return *a2 + v12;
    }
  }
  return result;
}

std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this)
{
  size_t i = this->__i_;
  size_t v2 = (i + 1) % 0x270;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3 = this->__x_[(i + 397) % 0x270] ^ ((this->__x_[v2] & 0x7FFFFFFE | this->__x_[i] & 0x80000000) >> 1) ^ ((int)(this->__x_[v2] << 31) >> 31) & 0x9908B0DF;
  this->__x_[i] = v3;
  this->__i_ = v2;
  LODWORD(i) = ((v3 ^ (v3 >> 11)) << 7) & 0x9D2C5680 ^ v3 ^ (v3 >> 11);
  return (i << 15) & 0xEFC60000 ^ i ^ (((i << 15) & 0xEFC60000 ^ i) >> 18);
}

void *std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::target_type()
{
}

uint64_t std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"ZN6vision3mod14broadcastMinusIdLm16EEEvRKNS0_10CVMLMatrixIT_XT0_EEERKNS0_10CVMLVectorIS3_XT0_EEEiRS4_bEUlddE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

double std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::operator()(uint64_t a1, double *a2, double *a3)
{
  return *a2 - *a3;
}

void std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF753250;
}

void *std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF753250;
  return result;
}

void std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::~__func()
{
}

void vision::mod::FaceIDModel::shrinkD_(vision::mod::FaceIDModel *this, int a2)
{
  uint64_t v3 = a2;
  vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v11, a2, *((void *)this + 14));
  int v4 = (void *)*((void *)this + 15);
  if (v4 == v11[4])
  {
    unsigned int v5 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v11, 0);
    uint64_t v6 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr((void *)this + 11, 0);
    uint64_t v7 = 8 * v3;
    memcpy(v5, v6, 8 * v3 * *((void *)this + 15));
    vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)this + 88, v3, *((void *)this + 14));
    uint64_t v8 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr((void *)this + 11, 0);
    unint64_t v9 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v11, 0);
    memcpy(v8, v9, v7 * (void)v4);
  }
  else
  {
    syslog(5, "ERROR: stride mismatch");
  }
  if (v12)
  {
    unint64_t v10 = v11[0];
    if (v11[0])
    {
      free(v10);
    }
  }
}

void sub_1A3F76474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a14)
  {
    if (a9) {
      free(a9);
    }
  }
  _Unwind_Resume(exception_object);
}

void vision::mod::FaceIDModel::createPrintsDictionary_(uint64_t a1, vision::mod::ImageDescriptorBufferAbstract *a2, uint64_t a3)
{
  int v4 = *(uint64_t **)(a1 + 200);
  int v5 = 0;
  if (v4)
  {
    uint64_t v6 = *(void *)a3;
    unint64_t v7 = *(void *)(a3 + 8);
    do
    {
      uint64_t v8 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(v6, v7, *((_DWORD *)v4 + 4));
      if (v8) {
        int v5 = (int)(fmin((double)*(int *)(a1 + 56), (double)(unint64_t)((v8[4] - v8[3]) >> 2)) + (double)v5);
      }
      else {
        v5 += *((_DWORD *)v4 + 6);
      }
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v53 = (void *)(a1 + 136);
  vision::mod::CVMLMatrix<double,16ul>::reset(a1 + 136, v5, *(void *)(a1 + 112));
  uint64_t v57 = *((void *)a2 + 9);
  uint64_t v9 = *((void *)a2 + 12);
  int v52 = v5;
  syslog(5, "FaceID: labels=%lu printDSize=%d num_prints=%d dimensionality=%d", *(void *)(a1 + 208), v5, v57, v9);
  LOBYTE(v61) = 0;
  std::vector<BOOL>::vector(&v69, (int)v57, (unsigned __int8 *)&v61);
  unint64_t v10 = *(uint64_t **)(a1 + 200);
  if (v10)
  {
    int v55 = 0;
    uint64_t v48 = *(void *)(MEMORY[0x1E4FBA418] + 24);
    uint64_t v49 = *MEMORY[0x1E4FBA418];
    do
    {
      int v68 = *((_DWORD *)v10 + 4);
      int v11 = v68;
      int v58 = v68;
      int v12 = 0;
      if (*((int *)v10 + 6) >= 1)
      {
        for (int64_t i = *((int *)v10 + 5); i < *((int *)v10 + 6) + (uint64_t)*((int *)v10 + 5); ++i)
        {
          uint64_t v14 = vision::mod::CVMLMatrix<double,16ul>::ptr((void *)(a1 + 88), i);
          if ((int)v57 < 1) {
            goto LABEL_26;
          }
          unint64_t v15 = (double *)v14;
          unint64_t v16 = 0;
          unsigned int v17 = -1;
          double v18 = 1000.0;
          do
          {
            if (((*(void *)((char *)v69 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v16) & 1) == 0)
            {
              DataForKthDescriptor = (_DWORD *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, v16);
              double v20 = 0.0;
              if ((int)v9 >= 1)
              {
                CBLAS_TRANSPOSE v21 = v15;
                uint64_t v22 = v9;
                do
                {
                  double v23 = *v21++;
                  double v24 = v23;
                  LODWORD(v23) = *DataForKthDescriptor++;
                  double v20 = v20 + (v24 - *(float *)&v23) * (v24 - *(float *)&v23);
                  --v22;
                }
                while (v22);
              }
              double v25 = sqrt(v20);
              if (v25 < v18)
              {
                double v18 = v25;
                unsigned int v17 = v16;
              }
            }
            ++v16;
          }
          while (v16 != v57);
          if ((v17 & 0x80000000) != 0)
          {
LABEL_26:
            int v11 = v58;
            syslog(5, "FaceID: could not find a close enough faceprint for label %d", v58);
          }
          else
          {
            *(void *)((char *)v69 + (((unint64_t)v17 >> 3) & 0x1FFFFFF8)) |= 1 << v17;
            if (v12 + v55 >= v52)
            {
              syslog(5, "FaceID: row %d + %d has exceeded the prints count of %d", v55, v12, v52);
              goto LABEL_64;
            }
            char v26 = (float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, v17);
            uint64_t v27 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v53, v12 + v55);
            int v11 = v58;
            if ((int)v9 >= 1)
            {
              uint64_t v28 = v9;
              do
              {
                float v29 = *v26++;
                *v27++ = v29;
                --v28;
              }
              while (v28);
            }
            ++v12;
          }
        }
      }
      uint64_t v30 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(*(void *)a3, *(void *)(a3 + 8), v11);
      int v66 = 0;
      uint64_t v67 = 0;
      unint64_t v65 = 0;
      std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v65, (const void *)v30[3], v30[4], (v30[4] - v30[3]) >> 2);
      unsigned int v31 = *(_DWORD *)(a1 + 64) + ((*(_DWORD *)(a1 + 64) / 0x7FFFFFFFu) | ((*(_DWORD *)(a1 + 64) / 0x7FFFFFFFu) << 31));
      if (v31 <= 1) {
        unsigned int v31 = 1;
      }
      LODWORD(__p[0]) = v31;
      uint64_t v51 = (int *)v65;
      uint64_t v54 = v66;
      if ((uint64_t)((uint64_t)v66 - v65) >= 5)
      {
        unint64_t v32 = (unint64_t)(v66 - 1);
        if ((unint64_t)(v66 - 1) > v65)
        {
          uint64_t v33 = (((unint64_t)v66 - v65) >> 2) - 1;
          uint64_t v34 = (int *)v65;
          do
          {
            uint64_t v61 = 0;
            v62[0] = v33;
            uint64_t v35 = std::uniform_int_distribution<long>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>((uint64_t)__p, &v61);
            if (v35)
            {
              int v36 = *v34;
              *uint64_t v34 = v34[v35];
              v34[v35] = v36;
            }
            ++v34;
            --v33;
          }
          while ((unint64_t)v34 < v32);
        }
      }
      if (v54 == v51)
      {
        int v37 = v58;
      }
      else
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v61);
        int v37 = v58;
        if (v51 != v54 - 1)
        {
          std::__split_buffer<std::string>::pointer v38 = v51;
          do
          {
            std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v61, (uint64_t)" ", 1);
            ++v38;
          }
          while (v38 != v54 - 1);
        }
        std::ostream::operator<<();
        int v39 = *(_DWORD *)(a1 + 56);
        uint64_t v40 = v51;
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__p, (uint64_t)v62);
        uint64_t v41 = __p;
        if (v60 < 0) {
          uint64_t v41 = (void **)__p[0];
        }
        syslog(5, "FaceID: %d slots for %s", v39, (const char *)v41);
        if (v60 < 0) {
          operator delete(__p[0]);
        }
        uint64_t v61 = v49;
        *(void *)((char *)&v62[-1] + *(void *)(v49 - 24)) = v48;
        v62[0] = MEMORY[0x1E4FBA470] + 16;
        if (v63 < 0) {
          operator delete((void *)v62[8]);
        }
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        MEMORY[0x1A6256200](&v64);
        while (v12 < *(_DWORD *)(a1 + 56))
        {
          unint64_t v42 = *v40;
          if ((int)v42 >= (int)v57)
          {
            syslog(5, "FaceID: cannot place label %d with %d slots", *v40, v57);
            break;
          }
          if ((v69[v42 >> 6] & (1 << v42)) != 0)
          {
            int v37 = v58;
          }
          else
          {
            syslog(5, "FaceID: taking slot %d", *v40);
            v69[v42 >> 6] |= 1 << v42;
            uint64_t v43 = (float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, v42);
            uint64_t v44 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v53, v12 + v55);
            int v37 = v58;
            if ((int)v9 >= 1)
            {
              uint64_t v45 = v9;
              do
              {
                float v46 = *v43++;
                *v44++ = v46;
                --v45;
              }
              while (v45);
            }
            ++v12;
          }
          if (++v40 == v54) {
            break;
          }
        }
      }
      syslog(5, "FaceID: label %d -> %d...%d", v37, v55, v12 + v55 - 1);
      uint64_t v47 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((float *)(a1 + 224), v37, &v68);
      *((_DWORD *)v47 + 5) = v55;
      *((_DWORD *)v47 + 6) = v12;
      if (v51) {
        operator delete(v51);
      }
      unint64_t v10 = (uint64_t *)*v10;
      v55 += v12;
    }
    while (v10);
  }
LABEL_64:
  if (v69) {
    operator delete(v69);
  }
}

void sub_1A3F76B38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35)
{
  int v37 = *(void **)(v35 - 128);
  if (v37) {
    operator delete(v37);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::uniform_int_distribution<long>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(uint64_t a1, void *a2)
{
  uint64_t result = a2[1];
  uint64_t v5 = result - *a2;
  if (result != *a2)
  {
    unint64_t v6 = v5 + 1;
    if (v5 == -1)
    {
      std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__independent_bits_engine((uint64_t)v10, a1, 0x40uLL);
      return std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__eval((uint64_t)v10);
    }
    else
    {
      unint64_t v7 = __clz(v6);
      uint64_t v8 = 63;
      if (((v6 << v7) & 0x7FFFFFFFFFFFFFFFLL) != 0) {
        uint64_t v8 = 64;
      }
      std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__independent_bits_engine((uint64_t)v10, a1, v8 - v7);
      do
        unint64_t v9 = std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__eval((uint64_t)v10);
      while (v9 >= v6);
      return *a2 + v9;
    }
  }
  return result;
}

uint64_t std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__independent_bits_engine(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  if (a3 % 0x1E) {
    unint64_t v3 = a3 / 0x1E + 1;
  }
  else {
    unint64_t v3 = a3 / 0x1E;
  }
  unint64_t v4 = a3 / v3;
  *(void *)(result + 16) = a3 / v3;
  *(void *)(result + 24) = v3;
  unint64_t v5 = (-1 << (a3 / v3)) & 0x7FFFFFFE;
  if (a3 / v3 >= 0x40) {
    unint64_t v5 = 0;
  }
  *(void *)(result + 40) = v5;
  if ((v5 ^ 0x7FFFFFFE) > v5 / v3)
  {
    ++v3;
    unint64_t v4 = a3 / v3;
    *(void *)(result + 16) = a3 / v3;
    *(void *)(result + 24) = v3;
    if (a3 / v3 > 0x3F)
    {
      *(void *)(result + 32) = v3 - a3 + (v3 << 6);
      *(void *)(result + 40) = 0;
      LOBYTE(v4) = 64;
      goto LABEL_15;
    }
    *(void *)(result + 40) = (-1 << v4) & 0x7FFFFFFE;
  }
  *(void *)(result + 32) = v3 + a3 / v3 * v3 - a3;
  if (v4 >= 0x3F)
  {
LABEL_15:
    *(void *)(result + 48) = 0;
    unsigned int v6 = -1;
    *(_DWORD *)(result + 56) = 0xFFFFFFFF >> -(char)v4;
    goto LABEL_16;
  }
  *(void *)(result + 48) = 0x3FFFFFFFuLL >> v4 << (v4 + 1);
  unsigned int v6 = -1;
  unsigned int v7 = 0xFFFFFFFF >> -(char)v4;
  if (!v4) {
    unsigned int v7 = 0;
  }
  *(_DWORD *)(result + 56) = v7;
  if (v4 <= 0x1E) {
    unsigned int v6 = 0xFFFFFFFF >> ~(_BYTE)v4;
  }
LABEL_16:
  *(_DWORD *)(result + 60) = v6;
  return result;
}

uint64_t std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__eval(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t result = 0;
    uint64_t v4 = 0;
    unint64_t v5 = *(void *)(a1 + 16);
    unsigned int v6 = **(_DWORD **)a1;
    do
    {
      do
      {
        unsigned int v7 = v6 / 0xADC8;
        unsigned int v8 = 48271 * (v6 % 0xADC8);
        v7 *= 3399;
        BOOL v9 = v8 >= v7;
        unsigned int v10 = v8 - v7;
        if (v9) {
          int v11 = 0;
        }
        else {
          int v11 = 0x7FFFFFFF;
        }
        unsigned int v6 = v11 + v10;
        unint64_t v12 = v6 - 1;
      }
      while (*(void *)(a1 + 40) <= v12);
      uint64_t v13 = result << v5;
      if (v5 >= 0x40) {
        uint64_t v13 = 0;
      }
      uint64_t result = v13 + (*(_DWORD *)(a1 + 56) & v12);
      ++v4;
    }
    while (v4 != v2);
    **(_DWORD **)a1 = v6;
  }
  else
  {
    uint64_t result = 0;
  }
  unint64_t v14 = *(void *)(a1 + 24);
  if (v2 < v14)
  {
    unint64_t v15 = *(unsigned int **)a1;
    unint64_t v16 = *(void *)(a1 + 48);
    unint64_t v17 = *(void *)(a1 + 16);
    int v18 = *(_DWORD *)(a1 + 60);
    unsigned int v19 = *v15;
    while (1)
    {
      unsigned int v20 = v19 / 0xADC8;
      unsigned int v21 = 48271 * (v19 % 0xADC8);
      v20 *= 3399;
      BOOL v9 = v21 >= v20;
      unsigned int v22 = v21 - v20;
      if (v9) {
        int v23 = 0;
      }
      else {
        int v23 = 0x7FFFFFFF;
      }
      unsigned int v19 = v23 + v22;
      unint64_t v24 = v19 - 1;
      if (v16 > v24)
      {
        uint64_t v25 = result << (v17 + 1);
        if (v17 >= 0x3F) {
          uint64_t v25 = 0;
        }
        uint64_t result = v25 + (v18 & v24);
        if (++v2 == v14) {
          break;
        }
      }
    }
    *unint64_t v15 = v19;
  }
  return result;
}

uint64_t vision::mod::FaceIDModel::buildModel(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v403 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2[12];
  uint64_t v6 = a2[9];
  if (a2[8]) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || v6 == 0)
  {
    syslog(5, "FaceID: invalid image descriptor buffer for training");
    return 7804;
  }
  if (v6 != (uint64_t)(a3[1] - *a3) >> 2)
  {
    syslog(5, "FaceID: size mismatch between descriptors and their labels");
    return 7804;
  }
  if (*(int *)(a1 + 48) < 1)
  {
    syslog(5, "ERROR: negative or zero minElems_");
LABEL_28:
    unint64_t v14 = &CVML_status_invalidParameter;
    goto LABEL_29;
  }
  if (*(int *)(a1 + 44) < 1)
  {
    syslog(5, "ERROR: negative or zero maxNumIds_");
    goto LABEL_28;
  }
  if (*(int *)(a1 + 52) < 1)
  {
    syslog(5, "ERROR: negative or zero minNumIds_");
    goto LABEL_28;
  }
  if (*(int *)(a1 + 72) < 1)
  {
    syslog(5, "ERROR: negative or zero maxIter_");
    goto LABEL_28;
  }
  if (*(int *)(a1 + 68) < 1)
  {
    uint64_t v13 = "ERROR: negative or zero nInits_ in kmeans";
LABEL_27:
    syslog(5, v13);
    goto LABEL_28;
  }
  double v12 = *(double *)(a1 + 80);
  uint64_t v13 = "ERROR: invalid tol_ in kmeans";
  if (v12 >= 1.0 || v12 <= 0.0) {
    goto LABEL_27;
  }
  unint64_t v14 = &CVML_status_ok;
LABEL_29:
  uint64_t v17 = *v14 + 128;
  if (v17 != 128) {
    return v17 | 0x1E00;
  }
  float32x2_t v342 = (vision::mod::FaceIDModel *)a1;
  memset(v351, 0, sizeof(v351));
  int v352 = 1065353216;
  long long v348 = 0u;
  long long v349 = 0u;
  int v350 = 1065353216;
  unsigned int v19 = (unint64_t *)a2[1];
  int v18 = (void *)a2[2];
  uint64_t v20 = (uint64_t)(a3[1] - *a3) >> 2;
  uint64_t v21 = a2[9];
  if (v18 - v19 != v20 || v21 != v20)
  {
    syslog(5, "ERROR: size mismatch - descIds=%lu labels=%lu descriptors=%lu", v18 - v19, (uint64_t)(a3[1] - *a3) >> 2, v21);
    syslog(5, "ERROR: error happened in searching updated labels");
    goto LABEL_129;
  }
  uint64_t v330 = a4;
  if (v18 == v19)
  {
    memset(&__p, 0, 32);
    __p.__x_[8] = 1065353216;
    goto LABEL_131;
  }
  unint64_t v22 = 0;
  do
  {
    int v23 = std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::find<long long>(v342, v19[v22]);
    if (v23)
    {
      int v24 = *((_DWORD *)v23 + 6);
      int v25 = *(_DWORD *)(*a3 + 4 * v22);
      char v26 = a2;
      if (v24 == v25) {
        goto LABEL_41;
      }
      if ((v24 & 0x80000000) == 0)
      {
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)&v348, v24, v24);
        int v25 = *(_DWORD *)(*a3 + 4 * v22);
      }
    }
    else
    {
      int v25 = *(_DWORD *)(*a3 + 4 * v22);
      char v26 = a2;
      if (v25 == -1) {
        goto LABEL_41;
      }
    }
    if ((v25 & 0x80000000) == 0) {
      std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)&v348, v25, v25);
    }
LABEL_41:
    ++v22;
    uint64_t v28 = v26 + 1;
    unsigned int v19 = (unint64_t *)v26[1];
    uint64_t v27 = (unint64_t *)v28[1];
  }
  while (v22 < v27 - v19);
  memset(&__p, 0, 32);
  __p.__x_[8] = 1065353216;
  if (v19 != v27)
  {
    unint64_t v29 = 0;
    uint64_t v30 = 0;
    while (1)
    {
      unint64_t v31 = *v19;
      if (v29)
      {
        uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v29);
        v32.i16[0] = vaddlv_u8(v32);
        if (v32.u32[0] > 1uLL)
        {
          unint64_t v4 = *v19;
          if (v31 >= v29) {
            unint64_t v4 = v31 % v29;
          }
        }
        else
        {
          unint64_t v4 = (v29 - 1) & v31;
        }
        uint64_t v33 = *(void **)(*(void *)__p.__x_ + 8 * v4);
        if (v33)
        {
          for (int64_t i = (void *)*v33; i; int64_t i = (void *)*i)
          {
            unint64_t v35 = i[1];
            if (v35 == v31)
            {
              if (i[2] == v31) {
                goto LABEL_116;
              }
            }
            else
            {
              if (v32.u32[0] > 1uLL)
              {
                if (v35 >= v29) {
                  v35 %= v29;
                }
              }
              else
              {
                v35 &= v29 - 1;
              }
              if (v35 != v4) {
                break;
              }
            }
          }
        }
      }
      int v36 = operator new(0x18uLL);
      *int v36 = 0;
      v36[1] = v31;
      void v36[2] = *v19;
      float v37 = (float)(unint64_t)(v30 + 1);
      if (!v29 || (float)(*(float *)&__p.__x_[8] * (float)v29) < v37) {
        break;
      }
LABEL_106:
      uint64_t v53 = *(void *)__p.__x_;
      uint64_t v54 = *(void **)(*(void *)__p.__x_ + 8 * v4);
      if (v54)
      {
        *int v36 = *v54;
      }
      else
      {
        *int v36 = *(void *)&__p.__x_[4];
        *(void *)&__p.__x_[4] = v36;
        *(void *)(v53 + 8 * v4) = &__p.__x_[4];
        if (!*v36) {
          goto LABEL_115;
        }
        unint64_t v55 = *(void *)(*v36 + 8);
        if ((v29 & (v29 - 1)) != 0)
        {
          if (v55 >= v29) {
            v55 %= v29;
          }
        }
        else
        {
          v55 &= v29 - 1;
        }
        uint64_t v54 = (void *)(*(void *)__p.__x_ + 8 * v55);
      }
      *uint64_t v54 = v36;
LABEL_115:
      uint64_t v30 = ++*(void *)&__p.__x_[6];
LABEL_116:
      if (++v19 == v27) {
        goto LABEL_131;
      }
    }
    BOOL v38 = (v29 & (v29 - 1)) != 0;
    if (v29 < 3) {
      BOOL v38 = 1;
    }
    unint64_t v39 = v38 | (2 * v29);
    unint64_t v40 = vcvtps_u32_f32(v37 / *(float *)&__p.__x_[8]);
    if (v39 <= v40) {
      int8x8_t prime = (int8x8_t)v40;
    }
    else {
      int8x8_t prime = (int8x8_t)v39;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v29 = *(void *)&__p.__x_[2];
    }
    if (*(void *)&prime <= v29)
    {
      if (*(void *)&prime < v29)
      {
        unint64_t v48 = vcvtps_u32_f32((float)*(unint64_t *)&__p.__x_[6] / *(float *)&__p.__x_[8]);
        if (v29 < 3 || (uint8x8_t v49 = (uint8x8_t)vcnt_s8((int8x8_t)v29), v49.i16[0] = vaddlv_u8(v49), v49.u32[0] > 1uLL))
        {
          unint64_t v48 = std::__next_prime(v48);
        }
        else
        {
          uint64_t v50 = 1 << -(char)__clz(v48 - 1);
          if (v48 >= 2) {
            unint64_t v48 = v50;
          }
        }
        if (*(void *)&prime <= v48) {
          int8x8_t prime = (int8x8_t)v48;
        }
        if (*(void *)&prime >= v29)
        {
          unint64_t v29 = *(void *)&__p.__x_[2];
        }
        else
        {
          if (prime) {
            goto LABEL_72;
          }
          uint64_t v56 = *(void **)__p.__x_;
          *(void *)__p.__x_ = 0;
          if (v56) {
            operator delete(v56);
          }
          unint64_t v29 = 0;
          *(void *)&__p.__x_[2] = 0;
        }
      }
    }
    else
    {
LABEL_72:
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v42 = operator new(8 * *(void *)&prime);
      uint64_t v43 = *(void **)__p.__x_;
      *(void *)__p.__x_ = v42;
      if (v43) {
        operator delete(v43);
      }
      uint64_t v44 = 0;
      *(int8x8_t *)&__p.__x_[2] = prime;
      do
        *(void *)(*(void *)__p.__x_ + 8 * v44++) = 0;
      while (*(void *)&prime != v44);
      uint64_t v45 = *(void ***)&__p.__x_[4];
      if (*(void *)&__p.__x_[4])
      {
        unint64_t v46 = *(void *)(*(void *)&__p.__x_[4] + 8);
        uint8x8_t v47 = (uint8x8_t)vcnt_s8(prime);
        v47.i16[0] = vaddlv_u8(v47);
        if (v47.u32[0] > 1uLL)
        {
          if (v46 >= *(void *)&prime) {
            v46 %= *(void *)&prime;
          }
        }
        else
        {
          v46 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)__p.__x_ + 8 * v46) = &__p.__x_[4];
        for (uint64_t j = *v45; j; v46 = v52)
        {
          unint64_t v52 = j[1];
          if (v47.u32[0] > 1uLL)
          {
            if (v52 >= *(void *)&prime) {
              v52 %= *(void *)&prime;
            }
          }
          else
          {
            v52 &= *(void *)&prime - 1;
          }
          if (v52 != v46)
          {
            if (!*(void *)(*(void *)__p.__x_ + 8 * v52))
            {
              *(void *)(*(void *)__p.__x_ + 8 * v52) = v45;
              goto LABEL_97;
            }
            *uint64_t v45 = (void *)*j;
            *uint64_t j = **(void **)(*(void *)__p.__x_ + 8 * v52);
            **(void **)(*(void *)__p.__x_ + 8 * v52) = j;
            uint64_t j = v45;
          }
          unint64_t v52 = v46;
LABEL_97:
          uint64_t v45 = (void **)j;
          uint64_t j = (void *)*j;
        }
      }
      unint64_t v29 = (unint64_t)prime;
    }
    if ((v29 & (v29 - 1)) != 0)
    {
      if (v31 >= v29) {
        unint64_t v4 = v31 % v29;
      }
      else {
        unint64_t v4 = v31;
      }
    }
    else
    {
      unint64_t v4 = (v29 - 1) & v31;
    }
    goto LABEL_106;
  }
LABEL_131:
  for (uint64_t k = (uint64_t *)*((void *)v342 + 2); k; uint64_t k = (uint64_t *)*k)
  {
    if (*(void *)&__p.__x_[2])
    {
      unint64_t v58 = k[2];
      uint8x8_t v59 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&__p.__x_[2]);
      v59.i16[0] = vaddlv_u8(v59);
      if (v59.u32[0] > 1uLL)
      {
        unint64_t v60 = k[2];
        if (v58 >= *(void *)&__p.__x_[2]) {
          unint64_t v60 = v58 % *(void *)&__p.__x_[2];
        }
      }
      else
      {
        unint64_t v60 = (*(void *)&__p.__x_[2] - 1) & v58;
      }
      uint64_t v61 = *(void **)(*(void *)__p.__x_ + 8 * v60);
      if (v61)
      {
        for (uint64_t m = (void *)*v61; m; uint64_t m = (void *)*m)
        {
          unint64_t v63 = m[1];
          if (v63 == v58)
          {
            if (m[2] == v58) {
              goto LABEL_149;
            }
          }
          else
          {
            if (v59.u32[0] > 1uLL)
            {
              if (v63 >= *(void *)&__p.__x_[2]) {
                v63 %= *(void *)&__p.__x_[2];
              }
            }
            else
            {
              v63 &= *(void *)&__p.__x_[2] - 1;
            }
            if (v63 != v60) {
              break;
            }
          }
        }
      }
    }
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)&v348, *((_DWORD *)k + 6), *((_DWORD *)k + 6));
LABEL_149:
    ;
  }
  if (a2[2] != a2[1])
  {
    unint64_t v64 = 0;
    do
    {
      unint64_t v65 = std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)v351, *(_DWORD *)(*a3 + 4 * v64), (_DWORD *)(*a3 + 4 * v64));
      int v66 = v65;
      int v68 = (char *)v65[4];
      unint64_t v67 = v65[5];
      if ((unint64_t)v68 >= v67)
      {
        uint64_t v70 = (char *)v65[3];
        uint64_t v71 = (v68 - v70) >> 2;
        unint64_t v72 = v71 + 1;
        if ((unint64_t)(v71 + 1) >> 62) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v73 = v67 - (void)v70;
        if (v73 >> 1 > v72) {
          unint64_t v72 = v73 >> 1;
        }
        if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v74 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v74 = v72;
        }
        if (v74)
        {
          unint64_t v74 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v74);
          uint64_t v70 = (char *)v66[3];
          int v68 = (char *)v66[4];
        }
        else
        {
          uint64_t v75 = 0;
        }
        uint64_t v76 = (_DWORD *)(v74 + 4 * v71);
        *uint64_t v76 = v64;
        uint64_t v69 = v76 + 1;
        while (v68 != v70)
        {
          int v77 = *((_DWORD *)v68 - 1);
          v68 -= 4;
          *--uint64_t v76 = v77;
        }
        v66[3] = v76;
        v66[4] = v69;
        v66[5] = v74 + 4 * v75;
        if (v70) {
          operator delete(v70);
        }
      }
      else
      {
        *(_DWORD *)int v68 = v64;
        uint64_t v69 = v68 + 4;
      }
      v66[4] = v69;
      ++v64;
    }
    while (v64 < (uint64_t)(a2[2] - a2[1]) >> 3);
  }
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&__p);
  if (!*((void *)&v349 + 1))
  {
    uint64_t v15 = 7808;
    goto LABEL_515;
  }
  uint64_t v78 = (uint64_t *)*((void *)v342 + 25);
  uint64_t v346 = (void **)((char *)v342 + 200);
  uint64_t v79 = 0;
  uint64_t v80 = 0;
  if (v78)
  {
    unint64_t v81 = 0;
    int v335 = 0;
    do
    {
      int v82 = *((_DWORD *)v78 + 4);
      if (!std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>(&v348, v82))
      {
        if ((unint64_t)v80 >= v81)
        {
          uint64_t v84 = v80 - v79;
          unint64_t v85 = v84 + 1;
          if ((unint64_t)(v84 + 1) >> 62) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          if ((uint64_t)(v81 - (void)v79) >> 1 > v85) {
            unint64_t v85 = (uint64_t)(v81 - (void)v79) >> 1;
          }
          if (v81 - (unint64_t)v79 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v86 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v86 = v85;
          }
          if (v86)
          {
            unint64_t v86 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v86);
            int v82 = *((_DWORD *)v78 + 4);
          }
          else
          {
            uint64_t v87 = 0;
          }
          int v88 = (int *)(v86 + 4 * v84);
          *int v88 = v82;
          uint64_t v83 = v88 + 1;
          while (v80 != v79)
          {
            int v89 = *--v80;
            *--int v88 = v89;
          }
          unint64_t v81 = v86 + 4 * v87;
          if (v79) {
            operator delete(v79);
          }
          uint64_t v79 = v88;
        }
        else
        {
          *uint64_t v80 = v82;
          uint64_t v83 = v80 + 1;
        }
        v335 += *((_DWORD *)v78 + 6);
        uint64_t v80 = v83;
      }
      uint64_t v78 = (uint64_t *)*v78;
    }
    while (v78);
  }
  else
  {
    int v335 = 0;
  }
  uint64_t v90 = (uint64_t *)v349;
  int v91 = v335;
  if ((void)v349)
  {
    long long v92 = v351[0];
    int v91 = v335;
    do
    {
      uint64_t v93 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(v92, *((unint64_t *)&v92 + 1), *((_DWORD *)v90 + 4));
      if (v93)
      {
        unint64_t v94 = (unint64_t)(v93[4] - v93[3]) >> 2;
        if (*((_DWORD *)v342 + 10) < (int)v94) {
          LODWORD(v94) = *((_DWORD *)v342 + 10);
        }
        v91 += v94;
      }
      uint64_t v90 = (uint64_t *)*v90;
    }
    while (v90);
  }
  unsigned int v328 = (float *)((char *)v342 + 184);
  if (*((void *)v342 + 3))
  {
    uint64_t v95 = (void *)*((void *)v342 + 2);
    if (v95)
    {
      do
      {
        uint64_t v96 = (void *)*v95;
        operator delete(v95);
        uint64_t v95 = v96;
      }
      while (v96);
    }
    *((void *)v342 + 2) = 0;
    uint64_t v97 = *((void *)v342 + 1);
    if (v97)
    {
      for (uint64_t n = 0; n != v97; ++n)
        *(void *)(*(void *)v342 + 8 * n) = 0;
    }
    *((void *)v342 + 3) = 0;
  }
  if (v79 == v80)
  {
LABEL_216:
    uint64_t v105 = (int)v5;
    vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v342 + 136, 0, (int)v5);
    if (!v335)
    {
      vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v342 + 88, v91, (int)v5);
      if (*((void *)v342 + 26))
      {
        int v117 = *v346;
        if (*v346)
        {
          do
          {
            int v118 = (void *)*v117;
            operator delete(v117);
            int v117 = v118;
          }
          while (v118);
        }
        *((void *)v342 + 25) = 0;
        uint64_t v119 = *((void *)v342 + 24);
        if (v119)
        {
          for (iint64_t i = 0; ii != v119; ++ii)
            *(void *)(*(void *)v328 + 8 * ii) = 0;
        }
        int v116 = 0;
        *((void *)v342 + 26) = 0;
      }
      else
      {
        int v116 = 0;
      }
      uint64_t v15 = 7808;
      goto LABEL_239;
    }
    vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)&__p, v335, (int)v5);
    *(_OWORD *)uint64_t v391 = 0u;
    long long v392 = 0u;
    int v393 = 1065353216;
    if (*((void *)v342 + 14) == (int)v5 && *(void *)&__p.__x_[8] == *((void *)v342 + 15))
    {
      uint64_t v344 = *(void *)&__p.__x_[8];
      uint64_t v106 = (void *)((char *)v342 + 88);
      if (v79 == v80)
      {
        int v107 = 0;
      }
      else
      {
        int v107 = 0;
        uint64_t v108 = v79;
        do
        {
          uint64_t v109 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v328, *v108, v108);
          uint64_t v110 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&__p, v107);
          uint64_t v111 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v106, *((int *)v109 + 5));
          memcpy(v110, v111, 8 * *((void *)v342 + 15) * *((int *)v109 + 6));
          int v112 = *((_DWORD *)v109 + 6);
          uint64_t v113 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((float *)v391, *v108, v108);
          *((_DWORD *)v113 + 5) = v107;
          *((_DWORD *)v113 + 6) = v112;
          v107 += *((_DWORD *)v109 + 6);
          ++v108;
        }
        while (v108 != v80);
      }
      vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v106, v91, v105);
      if (v107 == v335)
      {
        if (*((void *)v342 + 15) == v344)
        {
          uint64_t v313 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v106, 0);
          uint64_t v314 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&__p, 0);
          memcpy(v313, v314, 8 * v344 * *(void *)&__p.__x_[4]);
          int v316 = (void *)*((void *)v342 + 23);
          unint64_t v315 = *((void *)v342 + 24);
          uint64_t v317 = v391[0];
          unint64_t v318 = (unint64_t)v391[1];
          uint64_t v320 = *((void *)v342 + 25);
          uint64_t v319 = *((void *)v342 + 26);
          long long v321 = v392;
          int v322 = *((_DWORD *)v342 + 54);
          int v323 = v393;
          *((void **)v342 + 23) = v391[0];
          *((void *)v342 + 24) = v318;
          v391[0] = v316;
          v391[1] = (void *)v315;
          *(_OWORD *)((char *)v342 + 200) = v321;
          *(void *)&long long v392 = v320;
          *((void *)&v392 + 1) = v319;
          *((_DWORD *)v342 + 54) = v323;
          int v393 = v322;
          if (*((void *)&v321 + 1))
          {
            unint64_t v324 = *(void *)(v321 + 8);
            if ((v318 & (v318 - 1)) != 0)
            {
              if (v324 >= v318) {
                v324 %= v318;
              }
            }
            else
            {
              v324 &= v318 - 1;
            }
            v317[v324] = v346;
          }
          if (v319)
          {
            unint64_t v325 = *(void *)(v392 + 8);
            if ((v315 & (v315 - 1)) != 0)
            {
              if (v325 >= v315) {
                v325 %= v315;
              }
            }
            else
            {
              v325 &= v315 - 1;
            }
            *((void *)v391[0] + v325) = &v392;
          }
          uint64_t v114 = &CVML_status_ok;
          goto LABEL_225;
        }
        int v107 = v335;
        syslog(5, "ERROR: size or stride mismatch");
      }
      else
      {
        syslog(5, "ERROR: size or stride mismatch");
      }
    }
    else
    {
      int v107 = 0;
      syslog(5, "ERROR: dimension or stride mismatch");
    }
    uint64_t v114 = &CVML_status_inconsistentState;
    int v335 = v107;
LABEL_225:
    uint64_t v115 = *v114;
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)v391);
    if (LOBYTE(__p.__x_[10]) && *(void *)__p.__x_) {
      free(*(void **)__p.__x_);
    }
    uint64_t v15 = (v115 + 128) | 0x1E00;
    int v116 = v335;
    goto LABEL_239;
  }
  uint64_t v99 = v79;
  while (1)
  {
    uint64_t v100 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(*(uint64_t *)&v351[0], *((unint64_t *)&v351[0] + 1), *v99);
    if (!v100) {
      break;
    }
    uint64_t v101 = (int *)v100[3];
    int v102 = (int *)v100[4];
    while (v101 != v102)
    {
      int v103 = *v99;
      int v104 = (unint64_t *)(a2[1] + 8 * *v101);
      *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((float *)v342, *v104, v104)+ 6) = v103;
      ++v101;
    }
    if (++v99 == v80) {
      goto LABEL_216;
    }
  }
  syslog(5, "ERROR: incomplete labelInfo");
  int v116 = 0;
  uint64_t v15 = 7806;
LABEL_239:
  if (v79) {
    operator delete(v79);
  }
  if (v15 != 128)
  {
    syslog(5, "ERROR: error happened in initializing global dictionary");
    goto LABEL_515;
  }
  int v336 = v116;
  int v121 = (uint64_t *)v349;
  if (!(void)v349)
  {
    uint64_t v122 = v342;
    goto LABEL_511;
  }
  int v332 = 0;
  uint64_t v122 = v342;
  while (2)
  {
    int v123 = *((_DWORD *)v121 + 4);
    float v124 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(*(uint64_t *)&v351[0], *((unint64_t *)&v351[0] + 1), v123);
    if (!v124) {
      goto LABEL_265;
    }
    uint64_t v125 = v124[3];
    v334 = v124;
    uint64_t v126 = v124[4] - v125;
    if (!v126) {
      goto LABEL_265;
    }
    float v331 = v121;
    unsigned int v363 = v123;
    uint64_t v127 = a2[12];
    uint64_t v128 = (int)v127;
    if ((int)v127 != *((void *)v122 + 14))
    {
      float v143 = "ERROR: dimension mismatch between input data and global dictionary";
LABEL_258:
      float v144 = &CVML_status_inconsistentState;
LABEL_259:
      syslog(5, v143);
      uint64_t v15 = (*v144 + 128) | 0x1E00;
      goto LABEL_260;
    }
    float v129 = v122;
    uint64_t v130 = a2[7];
    int v131 = *((_DWORD *)a2 + 16);
    int v132 = *((_DWORD *)a2 + 18);
    uint64_t v133 = v127 << 32;
    if (*((_DWORD *)v129 + 10) >= (int)((unint64_t)v126 >> 2))
    {
      unint64_t v150 = 0;
      uint64_t v151 = 4 * (int)v127;
      while (1)
      {
        int v152 = *(_DWORD *)(v125 + 4 * v150);
        float v143 = "ERROR: index out of range";
        float v144 = &CVML_status_internalError;
        if (v152 >= v132 || v152 < 0) {
          goto LABEL_259;
        }
        v153 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr((void *)v342 + 11, v336 + (int)v150);
        if (v133)
        {
          float32x2_t v154 = (float *)(v130 + v152 * (uint64_t)v131);
          uint64_t v155 = v151;
          do
          {
            float v156 = *v154++;
            *v153++ = v156;
            v155 -= 4;
          }
          while (v155);
        }
        ++v150;
        uint64_t v125 = v334[3];
        uint64_t v157 = v334[4] - v125;
        if (v150 >= v157 >> 2)
        {
          if (std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>(v328, v123))
          {
            float v143 = "ERROR: duplicated labels detected when build sub-dictionary";
            goto LABEL_258;
          }
          int v185 = *((_DWORD *)v342 + 10);
          uint64_t v186 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v328, v123, (int *)&v363);
          unint64_t v187 = (unint64_t)v157 >> 2;
          if (v185 < (int)((unint64_t)v157 >> 2)) {
            LODWORD(v187) = v185;
          }
          *((_DWORD *)v186 + 5) = v336;
          *((_DWORD *)v186 + 6) = v187;
          uint64_t v183 = 7808;
          goto LABEL_496;
        }
      }
    }
    vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v358, (int)(v126 >> 2), (int)v127);
    uint64_t v134 = v334[3];
    if (v334[4] != v134)
    {
      unint64_t v135 = 0;
      uint64_t v136 = 4 * v128;
      while (1)
      {
        int v137 = *(_DWORD *)(v134 + 4 * v135);
        if (v137 >= v132 || v137 < 0) {
          break;
        }
        float v138 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v358, (int)v135);
        if (v133)
        {
          float v139 = (float *)(v130 + v137 * (uint64_t)v131);
          uint64_t v140 = v136;
          do
          {
            float v141 = *v139++;
            *v138++ = v141;
            v140 -= 4;
          }
          while (v140);
        }
        ++v135;
        uint64_t v134 = v334[3];
        uint64_t v142 = v334[4] - v134;
        if (v135 >= v142 >> 2) {
          goto LABEL_277;
        }
      }
      syslog(5, "ERROR: index out of range");
      int v184 = 1;
      uint64_t v183 = 7808;
      uint64_t v15 = 7806;
      goto LABEL_492;
    }
    uint64_t v142 = 0;
LABEL_277:
    unint64_t v158 = (unint64_t)v142 >> 2;
    int v159 = *((_DWORD *)v342 + 10);
    if (v159 >= (int)v158) {
      uint64_t v160 = v158;
    }
    else {
      uint64_t v160 = v159;
    }
    unint64_t v161 = *((void *)v342 + 13);
    if (v161 <= v336 || (int)v160 + (uint64_t)v336 > v161)
    {
      exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "row index out of range");
LABEL_541:
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
      __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
    }
    std::vector<int>::size_type v329 = (int)v160;
    unint64_t v162 = *((void *)v342 + 14);
    if (!v162)
    {
      exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "col index out of range");
      goto LABEL_541;
    }
    double v163 = *((double *)v342 + 10);
    std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v164 = *((_DWORD *)v342 + 16);
    uint64_t v165 = *(void *)((char *)v342 + 68);
    uint64_t v166 = *((void *)v342 + 15);
    v353[0] = (void *)(*((void *)v342 + 12) + 8 * v166 * v336);
    v353[1] = v353[0];
    unint64_t v354 = (int)v160;
    unint64_t v355 = v162;
    uint64_t v356 = v166;
    char v357 = 0;
    int v327 = v165;
    if ((int)v165 < 1 || (int v337 = HIDWORD(v165), v165 <= 0))
    {
      syslog(5, "ERROR: invalid parameters in kmeans");
      uint64_t v183 = 7804;
      syslog(5, "ERROR: kmeans error %lu", 7804);
      int v184 = 1;
      uint64_t v15 = 7804;
    }
    else
    {
      unint64_t v167 = v360;
      vision::mod::CVMLVector<double,16ul>::initialize_((uint64_t)&__p, v360);
      if (*(void *)&__p.__x_[4] < v360)
      {
        float v312 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v312, "vector length < cols");
        v312->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
        __cxa_throw(v312, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
      }
      vision::mod::CVMLMatrix<double,16ul>::mean((uint64_t)v358, &__p, 0);
      unint64_t v168 = v360;
      float v169 = *(double **)&__p.__x_[2];
      if (v360)
      {
        uint64_t v170 = 0;
        uint64_t v171 = *(void *)&__p.__x_[6];
        float v173 = (double *)v358[1];
        std::vector<int>::size_type v172 = v359;
        double v174 = (double)v359;
        uint64_t v175 = 8 * v361;
        do
        {
          uint64_t v176 = v171 * v170;
          if (v172)
          {
            double v177 = 0.0;
            float v178 = v173;
            std::vector<int>::size_type v179 = v172;
            do
            {
              double v177 = v177 + (*v178 - v169[v176]) * (*v178 - v169[v176]);
              float v178 = (double *)((char *)v178 + v175);
              --v179;
            }
            while (v179);
          }
          else
          {
            double v177 = 0.0;
          }
          v169[v176] = v177 / v174;
          ++v170;
          ++v173;
        }
        while (v170 != v168);
      }
      if (v167)
      {
        uint64_t v180 = 8 * v167;
        double v181 = 0.0;
        do
        {
          double v182 = *v169++;
          double v181 = v181 + v182;
          v180 -= 8;
        }
        while (v180);
      }
      else
      {
        double v181 = 0.0;
      }
      if (LOBYTE(__p.__x_[8]) && *(void *)__p.__x_) {
        free(*(void **)__p.__x_);
      }
      *(_OWORD *)int v374 = 0u;
      long long v375 = 0u;
      char v376 = 1;
      vision::mod::CVMLMatrix<double,16ul>::mean((uint64_t)v358, v374, 1);
      *(void *)__p.__x_ = &unk_1EF753250;
      *(void *)&__p.__x_[6] = &__p;
      vision::mod::broadcast<double,16ul>(v358, v374, (uint64_t)&__p, 0, v358);
      std::__function::__value_func<double ()(double,double)>::~__value_func[abi:ne180100](&__p);
      *(_OWORD *)float32x2_t v371 = 0u;
      long long v372 = 0u;
      char v373 = 1;
      vision::mod::CVMLMatrix<double,16ul>::rowNorms((uint64_t)v358, v371, 1);
      vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)&v365, (int)v160, v360);
      double v188 = v181 / (double)v167 * v163;
      std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v189 = 5489;
      __p.__x_[0] = 5489;
      for (juint64_t j = 1; jj != 624; ++jj)
      {
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v189 = jj + 1812433253 * (v189 ^ (v189 >> 30));
        __p.__x_[jj] = v189;
      }
      __p.__i_ = 0;
      if ((v164 & 0x80000000) == 0)
      {
        __p.__x_[0] = v164;
        for (kuint64_t k = 1; kk != 624; ++kk)
        {
          std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v164 = kk + 1812433253 * (v164 ^ (v164 >> 30));
          __p.__x_[kk] = v164;
        }
        __p.__i_ = 0;
      }
      if (v327 >= 1)
      {
        int v333 = 0;
        int v338 = (int)log((double)(int)v160);
        LODWORD(v192) = v338 + 2;
        if (v338 + 2 <= 1) {
          uint64_t v192 = 1;
        }
        else {
          uint64_t v192 = v192;
        }
        unint64_t v345 = v338 + 2;
        uint64_t v347 = v192;
        double v193 = 1.79769313e308;
        uint64_t v341 = v160;
        while (1)
        {
          std::vector<int>::size_type v195 = v359;
          unint64_t v194 = v360;
          LODWORD(v401) = 0;
          HIDWORD(v401) = v359 - 1;
          int v196 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(&__p, &v401);
          float v197 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v365, 0);
          uint64_t v198 = v196;
          float v199 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v358, v196);
          size_t v200 = 8 * v194;
          memcpy(v197, v199, 8 * v194);
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v391, 1, v195);
          if (!v367) {
            break;
          }
          if (!v368 || v194 > v368)
          {
            float v310 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(v310, "col index out of range");
LABEL_506:
            v310->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
            __cxa_throw(v310, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
          }
          v386[0] = v366;
          v386[1] = v366;
          unint64_t v387 = 1;
          unint64_t v388 = v194;
          uint64_t v389 = v369;
          char v390 = 0;
          vision::mod::euclideanDistances<double,16ul>((uint64_t)v386, v358, v391, v371);
          if (v390 && v386[0]) {
            free(v386[0]);
          }
          int v201 = (double *)v391[1];
          *((void *)v391[1] + v198) = 0;
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v386, v345, v194);
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v382, v345, v195);
          std::vector<unsigned long>::vector(v378, v345);
          std::vector<double>::vector(&__dst, v195);
          std::vector<double>::vector(&__src, v195);
          std::vector<double>::vector(&v381, v195);
          if ((int)v160 >= 2)
          {
            unint64_t v202 = 1;
            do
            {
              float v203 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v391, 0);
              uint64_t v204 = vision::mod::CVMLMatrix<double,16ul>::ptr(v391, 0) + 8 * v195;
              begiuint64_t n = v381.__begin_;
              if (v203 != (double *)v204)
              {
                double v207 = *v203;
                uint64_t v206 = v203 + 1;
                double v208 = v207;
                *(double *)v381.__begin_ = v207;
                if (v206 != (double *)v204)
                {
                  v209 = (double *)(begin + 2);
                  do
                  {
                    double v210 = *v206++;
                    double v208 = v208 + v210;
                    *v209++ = v208;
                  }
                  while (v206 != (double *)v204);
                }
              }
              if (!begin || !v195)
              {
                float64x2_t v309 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                std::logic_error::logic_error(v309, "empty cumsum vector");
                v309->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4E8] + 16);
                __cxa_throw(v309, (struct type_info *)off_1E5B19CD8, MEMORY[0x1E4FBA1E8]);
              }
              if (v338 != -2)
              {
                uint64_t v211 = 0;
                uint64_t v212 = *(double **)v378;
                double v213 = *(double *)&begin[2 * v195 - 2];
                do
                {
                  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v214 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&__p) >> 5;
                  double v215 = v213
                       * (((double)(std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&__p) >> 6)
                         + (double)v214 * 67108864.0)
                        * 1.11022302e-16);
                  std::vector<int>::pointer v216 = begin;
                  std::vector<int>::size_type v217 = v195;
                  do
                  {
                    std::vector<int>::size_type v218 = v217 >> 1;
                    uint64_t v219 = (double *)&v216[2 * (v217 >> 1)];
                    double v221 = *v219;
                    char v220 = v219 + 1;
                    v217 += ~(v217 >> 1);
                    if (v221 < v215) {
                      std::vector<int>::pointer v216 = (std::vector<int>::pointer)v220;
                    }
                    else {
                      std::vector<int>::size_type v217 = v218;
                    }
                  }
                  while (v217);
                  *(void *)&v212[v211++] = ((char *)v216 - (char *)begin) >> 3;
                }
                while (v211 != v345);
                if (v338 >= -1)
                {
                  unint64_t v222 = 0;
                  do
                  {
                    uint64_t v223 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v386, v222);
                    uint64_t v224 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v358, *(void *)(*(void *)v378 + 8 * v222));
                    memcpy(v223, v224, v200);
                    ++v222;
                  }
                  while (v347 != v222);
                }
              }
              vision::mod::euclideanDistances<double,16ul>((uint64_t)v386, v358, v382, v371);
              if (v338 < -1)
              {
                LODWORD(v233) = -1;
              }
              else
              {
                uint64_t v225 = 0;
                uint64_t v226 = *(double **)v378;
                uint64_t v227 = v347;
                uint64_t v228 = (char *)v382[1];
                uint64_t v229 = v384;
                do
                {
                  uint64_t v230 = *(void *)v226++;
                  *(void *)&v228[8 * v225 + 8 * v230] = 0;
                  v225 += v229;
                  --v227;
                }
                while (v227);
                uint64_t v231 = 0;
                uint64_t v232 = 8 * v229;
                LODWORD(v233) = -1;
                double v234 = 1.79769313e308;
                do
                {
                  uint64_t v235 = 0;
                  v236 = (double *)__src;
                  do
                  {
                    double v237 = *(double *)&v228[8 * v235];
                    if (v237 >= v201[v235]) {
                      double v237 = v201[v235];
                    }
                    v236[v235++] = v237;
                  }
                  while (v195 != v235);
                  double v238 = 0.0;
                  if (v236 != v396)
                  {
                    uint64_t v239 = v236;
                    do
                    {
                      double v240 = *v239++;
                      double v238 = v238 + v240;
                    }
                    while (v239 != v396);
                  }
                  if (v233 == -1 || v238 < v234 && v234 - v238 > 1.0e-14)
                  {
                    uint64_t v233 = *(void *)(*(void *)v378 + 8 * v231);
                    memcpy(__dst, v236, 8 * v195);
                    double v234 = v238;
                  }
                  ++v231;
                  v228 += v232;
                }
                while (v231 != v347);
              }
              int v241 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v365, v202);
              int32x2_t v242 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v358, (int)v233);
              memcpy(v241, v242, v200);
              v243 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v391, 0);
              memcpy(v243, __dst, 8 * v195);
              ++v202;
              uint64_t v160 = v341;
            }
            while (v202 != v341);
          }
          if (v381.__begin_)
          {
            v381.__end_ = v381.__begin_;
            operator delete(v381.__begin_);
          }
          if (__src)
          {
            v396 = (double *)__src;
            operator delete(__src);
          }
          if (__dst)
          {
            v399 = __dst;
            operator delete(__dst);
          }
          if (*(void *)v378)
          {
            float64x2_t v379 = *(double **)v378;
            operator delete(*(void **)v378);
          }
          if (v385 && v382[0]) {
            free(v382[0]);
          }
          if (v390 && v386[0]) {
            free(v386[0]);
          }
          if (v394 && v391[0]) {
            free(v391[0]);
          }
          double v364 = 0.0;
          std::vector<int>::size_type v244 = v359;
          uint64_t v245 = v360;
          __x[0] = -1;
          std::vector<int>::vector(&v397, v359, __x);
          std::vector<double>::vector(&__src, v244);
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v391, v329, v245);
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v386, v329, v245);
          uint64_t v384 = 0;
          *(_OWORD *)float v382 = 0u;
          long long v383 = 0u;
          char v385 = 1;
          vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v382, v329, v244);
          v378[0] = 0;
          std::vector<int>::vector(&v381, v329, v378);
          double v364 = 1.79769313e308;
          vision::mod::CVMLVector<double,16ul>::initialize_((uint64_t)v378, v329);
          if (v337 >= 1)
          {
            int v246 = 0;
            unint64_t v247 = v392;
            while (2)
            {
              if (v247 < v367 || *((void *)&v392 + 1) < v368)
              {
                float64x2_t v307 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                std::logic_error::logic_error(v307, "output matrix size too small");
                v307->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
                __cxa_throw(v307, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
              }
              if (v367)
              {
                for (muint64_t m = 0; mm < v367; ++mm)
                {
                  int v249 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v391, mm);
                  v250 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v365, mm);
                  memcpy(v249, v250, 8 * v368);
                }
              }
              int v340 = v246;
              double v377 = 0.0;
              vision::mod::Kmeans<double,16ul>::labelEstimation_(v358, v160, (uint64_t)&v365, v371, v382, v397.__begin_, (double *)__src, &v377);
              std::vector<int>::pointer v251 = v397.__begin_;
              uint64_t v339 = __src;
              std::vector<int>::pointer v252 = v381.__begin_;
              uint64_t v254 = v359;
              unint64_t v253 = v360;
              bzero(v381.__begin_, 4 * v329);
              int v255 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v365, 0);
              bzero(v255, 8 * v329 * v369);
              if (v254)
              {
                for (nuint64_t n = 0; nn != v254; ++nn)
                  ++v252[v251[nn]];
                for (unint64_t i1 = 0; i1 != v254; ++i1)
                {
                  unint64_t v258 = v251[i1];
                  int v259 = v252[v258];
                  int v260 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v358, i1);
                  int v261 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v365, v258);
                  cblas_daxpy(v253, 1.0 / (double)v259, v260, 1, v261, 1);
                }
              }
              if ((int)v160 < 1) {
                goto LABEL_432;
              }
              unint64_t v262 = 0;
              float32x2_t v263 = 0;
              uint64_t v264 = 0;
              for (uint64_t i2 = 0; i2 != v160; ++i2)
              {
                if (!v252[i2])
                {
                  if ((unint64_t)v263 >= v262)
                  {
                    uint64_t v266 = (v263 - v264) >> 2;
                    unint64_t v267 = v266 + 1;
                    if ((unint64_t)(v266 + 1) >> 62) {
                      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                    }
                    if ((uint64_t)(v262 - (void)v264) >> 1 > v267) {
                      unint64_t v267 = (uint64_t)(v262 - (void)v264) >> 1;
                    }
                    if (v262 - (unint64_t)v264 >= 0x7FFFFFFFFFFFFFFCLL) {
                      unint64_t v268 = 0x3FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v268 = v267;
                    }
                    if (v268) {
                      unint64_t v268 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v268);
                    }
                    else {
                      uint64_t v269 = 0;
                    }
                    float32x2_t v270 = (char *)(v268 + 4 * v266);
                    *(_DWORD *)float32x2_t v270 = i2;
                    int8x8_t v271 = v270 + 4;
                    while (v263 != v264)
                    {
                      int v272 = *((_DWORD *)v263 - 1);
                      v263 -= 4;
                      *((_DWORD *)v270 - 1) = v272;
                      v270 -= 4;
                    }
                    unint64_t v262 = v268 + 4 * v269;
                    if (v264) {
                      operator delete(v264);
                    }
                    float32x2_t v263 = v271;
                    uint64_t v264 = v270;
                    uint64_t v160 = v341;
                  }
                  else
                  {
                    *(_DWORD *)float32x2_t v263 = i2;
                    v263 += 4;
                  }
                }
              }
              if (v263 == v264) {
                goto LABEL_430;
              }
              std::vector<unsigned long>::vector(&__dst, v254);
              uint64_t v273 = (uint64_t *)__dst;
              *(void *)float64x2_t __x = v339;
              uint64_t v274 = (uint64_t *)((char *)__dst + 8 * v254);
              if (v254)
              {
                uint64_t v275 = 0;
                uint64_t v276 = 8 * v254;
                do
                {
                  v273[v275] = v275;
                  ++v275;
                  v276 -= 8;
                }
                while (v276);
                v401 = __x;
                if (v254 > 128)
                {
                  int v277 = (uint64_t *)std::get_temporary_buffer[abi:ne180100]<unsigned long>(v254);
                  std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v273, v274, (uint64_t **)&v401, v254, v277, v278);
                  if (v277) {
                    operator delete(v277);
                  }
LABEL_421:
                  if (v263 != v264)
                  {
                    uint64_t v279 = 0;
                    size_t v280 = 8 * v253;
                    if ((unint64_t)((v263 - v264) >> 2) <= 1) {
                      uint64_t v281 = 1;
                    }
                    else {
                      uint64_t v281 = (v263 - v264) >> 2;
                    }
                    do
                    {
                      unint64_t v282 = *((void *)__dst + v279);
                      float v283 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v365, *(int *)&v264[4 * v279]);
                      int v284 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v358, v282);
                      memcpy(v283, v284, v280);
                      ++v279;
                    }
                    while (v281 != v279);
                    float32x2_t v263 = v264;
                  }
                  if (__dst)
                  {
                    v399 = __dst;
                    operator delete(__dst);
                    float32x2_t v263 = v264;
                  }
                  uint64_t v264 = v263;
LABEL_430:
                  if (v264) {
                    operator delete(v264);
                  }
LABEL_432:
                  double v285 = v377;
                  if (v377 < v364)
                  {
                    if (v387 < v367 || v388 < v368)
                    {
                      v308 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                      std::logic_error::logic_error(v308, "output matrix size too small");
                      v308->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
                      __cxa_throw(v308, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
                    }
                    if (v367)
                    {
                      for (unint64_t i3 = 0; i3 < v367; ++i3)
                      {
                        float v287 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v386, i3);
                        v288 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v365, i3);
                        memcpy(v287, v288, 8 * v368);
                      }
                    }
                    double v364 = v285;
                  }
                  unint64_t v247 = v392;
                  int v289 = v393;
                  int v290 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v365, 0);
                  int v291 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v391, 0);
                  cblas_daxpy(v289 * v247, -1.0, v290, 1, v291, 1);
                  vision::mod::CVMLMatrix<double,16ul>::rowNorms((uint64_t)v391, v378, 0);
                  if (v160)
                  {
                    int v292 = v379;
                    double v293 = 0.0;
                    uint64_t v294 = 8 * v329;
                    do
                    {
                      double v295 = *v292++;
                      double v293 = v293 + v295;
                      v294 -= 8;
                    }
                    while (v294);
                  }
                  else
                  {
                    double v293 = 0.0;
                  }
                  double v296 = sqrt(v293);
                  int v246 = v340 + 1;
                  if (v296 <= v188 || v246 == v337)
                  {
                    if (v296 > 0.0) {
                      vision::mod::Kmeans<double,16ul>::labelEstimation_(v358, v160, (uint64_t)v386, v371, v382, v397.__begin_, (double *)__src, &v364);
                    }
                    goto LABEL_451;
                  }
                  continue;
                }
              }
              else
              {
                v401 = __x;
              }
              break;
            }
            std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v273, v274, (uint64_t **)&v401, v254, 0, 0);
            goto LABEL_421;
          }
LABEL_451:
          if (v380 && *(void *)v378) {
            free(*(void **)v378);
          }
          if (v381.__begin_)
          {
            v381.__end_ = v381.__begin_;
            operator delete(v381.__begin_);
          }
          if (v385 && v382[0]) {
            free(v382[0]);
          }
          if (v390 && v386[0]) {
            free(v386[0]);
          }
          if (v394 && v391[0]) {
            free(v391[0]);
          }
          if (__src)
          {
            v396 = (double *)__src;
            operator delete(__src);
          }
          if (v397.__begin_)
          {
            v397.__end_ = v397.__begin_;
            operator delete(v397.__begin_);
          }
          double v298 = v364;
          if (v364 < v193)
          {
            if (v354 < v367 || v355 < v368)
            {
              v311 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(v311, "output matrix size too small");
              v311->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
              __cxa_throw(v311, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
            }
            if (v367)
            {
              for (unint64_t i4 = 0; i4 < v367; ++i4)
              {
                float64x2_t v300 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v353, i4);
                int v301 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v365, i4);
                memcpy(v300, v301, 8 * v368);
              }
            }
            double v193 = v298;
          }
          if (++v333 == v327) {
            goto LABEL_477;
          }
        }
        float v310 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v310, "row index out of range");
        goto LABEL_506;
      }
LABEL_477:
      vision::mod::broadcastAdd<double,16ul>(v358, v374, 0, v358);
      vision::mod::broadcastAdd<double,16ul>(v353, v374, 0, v353);
      if (v370 && v365) {
        free(v365);
      }
      if (v373 && v371[0]) {
        free(v371[0]);
      }
      if (v376 && v374[0]) {
        free(v374[0]);
      }
      uint64_t v15 = v363;
      if (std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>(v328, v363))
      {
        syslog(5, "ERROR: duplicated labels detected when build sub-dictionary");
        int v184 = 1;
        uint64_t v183 = 7808;
        uint64_t v15 = 7784;
      }
      else
      {
        float64_t v302 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v328, v15, (int *)&v363);
        int v184 = 0;
        *((_DWORD *)v302 + 5) = v336;
        *((_DWORD *)v302 + 6) = v160;
        uint64_t v183 = 7808;
      }
    }
    if (v357 && v353[0]) {
      free(v353[0]);
    }
LABEL_492:
    if (v362 && v358[0]) {
      free(v358[0]);
    }
    if (!v184)
    {
LABEL_496:
      uint64_t v303 = v334[3];
      if (v334[4] != v303)
      {
        unint64_t v304 = 0;
        unsigned int v305 = v363;
        do
        {
          float64_t v306 = (unint64_t *)(a2[1] + 8 * *(int *)(v303 + 4 * v304));
          *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((float *)v342, *v306, v306)+ 6) = v305;
          ++v304;
          uint64_t v303 = v334[3];
        }
        while (v304 < (v334[4] - v303) >> 2);
      }
      uint64_t v15 = v183;
    }
LABEL_260:
    if (v15 == 128)
    {
      uint64_t v146 = v334[3];
      uint64_t v145 = v334[4];
      int v147 = *((_DWORD *)v342 + 10);
      ++v332;
      int v148 = (*(uint64_t (**)(uint64_t))(*(void *)v330 + 8))(v330);
      unint64_t v149 = (unint64_t)(v145 - v146) >> 2;
      if (v147 < (int)v149) {
        LODWORD(v149) = v147;
      }
      v336 += v149;
      if (!v148)
      {
        uint64_t v122 = v342;
        int v121 = v331;
LABEL_265:
        int v121 = (uint64_t *)*v121;
        if (!v121) {
          goto LABEL_511;
        }
        continue;
      }
      uint64_t v122 = v342;
      if (v332 != DWORD2(v349))
      {
        vision::mod::FaceIDModel::shrinkD_(v342, v336);
        uint64_t v15 = 7779;
      }
LABEL_511:
      if (*((void *)v122 + 13) == v336)
      {
        vision::mod::FaceIDModel::createPrintsDictionary_((uint64_t)v122, (vision::mod::ImageDescriptorBufferAbstract *)a2, (uint64_t)v351);
        vision::mod::FeatureSignSparseCoder<double,16ul>::initialize((uint64_t)v122 + 264, (void *)v122 + 11);
        goto LABEL_515;
      }
      syslog(5, "ERROR: size mismatch in the end: bad memory access");
LABEL_129:
      uint64_t v15 = 7784;
      goto LABEL_515;
    }
    break;
  }
  syslog(5, "ERROR: error happened in building subdictionary");
LABEL_515:
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v348);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)v351);
  return v15;
}

void sub_1A3F79440()
{
  __cxa_end_catch();
  if (v1 && v0) {
    free(v0);
  }
  if (v3)
  {
    if (v2) {
      free(v2);
    }
  }
  JUMPOUT(0x1A3F79574);
}

void sub_1A3F79454()
{
}

void sub_1A3F794F0()
{
  if (LOBYTE(STACK[0x368]))
  {
    if (STACK[0x340]) {
      free((void *)STACK[0x340]);
    }
  }
  JUMPOUT(0x1A3F79568);
}

void sub_1A3F7951C(void *a1, int a2)
{
  operator delete(v2);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&STACK[0x340]);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v6);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)&v7);
  switch(a2)
  {
    case 3:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: memory allocation error");
      __cxa_end_catch();
      break;
    case 2:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: an unexpected exception thrown");
      __cxa_end_catch();
      break;
    case 1:
      uint64_t v5 = __cxa_begin_catch(a1);
      syslog(5, "ERROR: Caught unexpected failure with status code %lld", *v5);
      __cxa_end_catch();
      break;
    default:
      JUMPOUT(0x1A3F79644);
  }
  JUMPOUT(0x1A3F76F84);
}

void sub_1A3F79538(void *a1, int a2)
{
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(&v5);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table(&v6);
  switch(a2)
  {
    case 3:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: memory allocation error");
      __cxa_end_catch();
      break;
    case 2:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: an unexpected exception thrown");
      __cxa_end_catch();
      break;
    case 1:
      unint64_t v4 = __cxa_begin_catch(a1);
      syslog(5, "ERROR: Caught unexpected failure with status code %lld", *v4);
      __cxa_end_catch();
      break;
    default:
      JUMPOUT(0x1A3F79644);
  }
  JUMPOUT(0x1A3F76F84);
}

void sub_1A3F7954C()
{
}

void sub_1A3F79560(void *a1, int a2)
{
  if (v2) {
    operator delete(v2);
  }
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v6);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)&v7);
  switch(a2)
  {
    case 3:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: memory allocation error");
      __cxa_end_catch();
      break;
    case 2:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: an unexpected exception thrown");
      __cxa_end_catch();
      break;
    case 1:
      uint64_t v5 = __cxa_begin_catch(a1);
      syslog(5, "ERROR: Caught unexpected failure with status code %lld", *v5);
      __cxa_end_catch();
      break;
    default:
      JUMPOUT(0x1A3F79644);
  }
  JUMPOUT(0x1A3F76F84);
}

void sub_1A3F7960C(_Unwind_Exception *a1)
{
}

void sub_1A3F79618(_Unwind_Exception *a1)
{
}

void sub_1A3F79624(_Unwind_Exception *a1)
{
}

void sub_1A3F79630(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void vision::mod::FeatureSignSparseCoder<double,16ul>::initialize(uint64_t a1, void *a2)
{
  free(*(void **)(a1 + 80));
  *(void *)(a1 + 80) = 0;
  *(void *)a1 = a2;
  unint64_t v4 = a2[2];
  unint64_t v5 = a2[3];
  if (v5 >= v4) {
    std::vector<int>::size_type v6 = a2[2];
  }
  else {
    std::vector<int>::size_type v6 = a2[3];
  }
  unint64_t v7 = (((uint64_t)(v4 << 63) >> 63) & ((16 - ((8 * v4) & 8)) >> 3)) + v4;
  uint64_t v8 = v7 * 8 * v4 + 15;
  uint64_t v9 = 8 * v4 + 15;
  uint64_t v10 = 8 * v5 + 15;
  uint64_t v55 = 8 * v6 + 15;
  uint64_t v54 = 8 * (v6 + 1) + 15;
  size_t __val = 16 * (v55 + v10) + 8 * (v54 + v9 + v8) + 112;
  int v11 = (char *)malloc_type_calloc(__val, 1uLL, 0xBE09D42DuLL);
  *(void *)(a1 + 80) = v11;
  if (!v11)
  {
    exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v39 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v39, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  uint64_t v12 = 16 - (v11 & 0xF);
  if ((v11 & 0xF) == 0) {
    uint64_t v12 = 0;
  }
  uint64_t v13 = &v11[v12];
  uint64_t v57 = (void **)(a1 + 8);
  if (*(unsigned char *)(a1 + 48) && *v57) {
    free(*v57);
  }
  unint64_t v14 = &v13[8 * v8];
  uint64_t v15 = 16 - (v14 & 0xF);
  *(void *)(a1 + 8) = v13;
  *(void *)(a1 + 16) = v13;
  *(void *)(a1 + 24) = v4;
  *(void *)(a1 + 32) = v4;
  *(void *)(a1 + 40) = v7;
  *(unsigned char *)(a1 + 48) = 0;
  if ((v14 & 0xF) == 0) {
    uint64_t v15 = 0;
  }
  unint64_t v16 = &v14[v15];
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v17 = *(void **)(a1 + 88);
    if (v17) {
      free(v17);
    }
  }
  int v18 = &v16[8 * v9];
  uint64_t v19 = 16 - (v18 & 0xF);
  *(void *)(a1 + 88) = v16;
  *(void *)(a1 + 96) = v16;
  *(void *)(a1 + 104) = v4;
  *(void *)(a1 + 112) = 1;
  *(unsigned char *)(a1 + 120) = 0;
  if ((v18 & 0xF) == 0) {
    uint64_t v19 = 0;
  }
  uint64_t v20 = &v18[v19];
  if (*(unsigned char *)(a1 + 160))
  {
    uint64_t v21 = *(void **)(a1 + 128);
    if (v21) {
      free(v21);
    }
  }
  unint64_t v22 = &v20[8 * v55];
  uint64_t v23 = 16 - (v22 & 0xF);
  *(void *)(a1 + 128) = v20;
  *(void *)(a1 + 136) = v20;
  *(void *)(a1 + 144) = v6;
  *(void *)(a1 + 152) = 1;
  *(unsigned char *)(a1 + 160) = 0;
  if ((v22 & 0xF) == 0) {
    uint64_t v23 = 0;
  }
  int v24 = &v22[v23];
  if (*(unsigned char *)(a1 + 200))
  {
    int v25 = *(void **)(a1 + 168);
    if (v25) {
      free(v25);
    }
  }
  char v26 = &v24[8 * v10];
  uint64_t v27 = 16 - (v26 & 0xF);
  *(void *)(a1 + 168) = v24;
  *(void *)(a1 + 176) = v24;
  *(void *)(a1 + 184) = v5;
  *(void *)(a1 + 192) = 1;
  *(unsigned char *)(a1 + 200) = 0;
  if ((v26 & 0xF) == 0) {
    uint64_t v27 = 0;
  }
  uint64_t v28 = (uint64_t)&v26[v27];
  if (*(unsigned char *)(a1 + 240))
  {
    unint64_t v29 = *(void **)(a1 + 208);
    if (v29) {
      free(v29);
    }
  }
  uint64_t v30 = v28 + 8 * v10;
  uint64_t v31 = 16 - (v30 & 0xF);
  *(void *)(a1 + 208) = v28;
  *(void *)(a1 + 216) = v28;
  *(void *)(a1 + 224) = v5;
  *(void *)(a1 + 232) = 1;
  *(unsigned char *)(a1 + 240) = 0;
  if ((v30 & 0xF) == 0) {
    uint64_t v31 = 0;
  }
  uint64_t v32 = v30 + v31;
  if (*(unsigned char *)(a1 + 280))
  {
    uint64_t v33 = *(void **)(a1 + 248);
    if (v33) {
      free(v33);
    }
  }
  uint64_t v34 = v32 + 8 * v54;
  uint64_t v35 = 16 - (v34 & 0xF);
  *(void *)(a1 + 248) = v32;
  *(void *)(a1 + 256) = v32;
  *(void *)(a1 + 272) = 1;
  *(void *)(a1 + 264) = v6 + 1;
  *(unsigned char *)(a1 + 280) = 0;
  if ((v34 & 0xF) == 0) {
    uint64_t v35 = 0;
  }
  uint64_t v36 = v34 + v35;
  if (*(unsigned char *)(a1 + 320))
  {
    float v37 = *(void **)(a1 + 288);
    if (v37) {
      free(v37);
    }
  }
  *(void *)(a1 + 288) = v36;
  *(void *)(a1 + 296) = v36;
  *(void *)(a1 + 304) = v6;
  *(void *)(a1 + 312) = 1;
  *(unsigned char *)(a1 + 320) = 0;
  if (v36 + 8 * v55 - *(void *)(a1 + 80) > __val)
  {
    unint64_t v40 = v36 + 8 * v55 - *(void *)(a1 + 80);
    uint64_t v41 = (char *)__cxa_allocate_exception(0x20uLL);
    std::to_string(&v59, v40);
    unint64_t v42 = std::string::insert(&v59, 0, "aligned buffer allocation of ", 0x1DuLL);
    long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
    v60.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v43;
    v42->__r_.__value_.__l.__size_ = 0;
    v42->__r_.__value_.__r.__words[2] = 0;
    v42->__r_.__value_.__r.__words[0] = 0;
    uint64_t v44 = std::string::append(&v60, " exceeded calculated size of ", 0x1DuLL);
    long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v61.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v58, __val);
    if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v46 = &v58;
    }
    else {
      unint64_t v46 = (std::string *)v58.__r_.__value_.__r.__words[0];
    }
    if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v58.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v58.__r_.__value_.__l.__size_;
    }
    unint64_t v48 = std::string::append(&v61, (const std::string::value_type *)v46, size);
    uint64_t v50 = (const std::string::value_type *)v48->__r_.__value_.__r.__words[0];
    std::string::size_type v49 = v48->__r_.__value_.__l.__size_;
    v62[0] = v48->__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v62 + 3) = *(_DWORD *)((char *)&v48->__r_.__value_.__r.__words[2] + 3);
    int v51 = SHIBYTE(v48->__r_.__value_.__r.__words[2]);
    v48->__r_.__value_.__l.__size_ = 0;
    v48->__r_.__value_.__r.__words[2] = 0;
    v48->__r_.__value_.__r.__words[0] = 0;
    unint64_t v52 = std::bad_alloc::bad_alloc((std::bad_alloc *)v41);
    v52->__vftable = (std::bad_alloc_vtbl *)&unk_1EF752C88;
    uint64_t v53 = (std::string *)&v52[1];
    if (v51 < 0)
    {
      std::string::__init_copy_ctor_external(v53, v50, v49);
    }
    else
    {
      *((void *)v41 + 1) = v50;
      *((void *)v41 + 2) = v49;
      *((_DWORD *)v41 + 6) = v62[0];
      *(_DWORD *)(v41 + 27) = *(_DWORD *)((char *)v62 + 3);
      v41[31] = v51;
    }
  }
  std::vector<unsigned int>::resize((std::vector<int> *)(a1 + 328), v6);

  vision::mod::matMult<double,16ul>((uint64_t)a2, a2, 1, v57, 0, 1.0, 0.0);
}

void sub_1A3F79AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  std::bad_alloc::~bad_alloc(v39);
  operator delete(v40);
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  __cxa_free_exception(v39);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      char v3 = (void *)*v2;
      unint64_t v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void vision::mod::FeatureSignSparseCoder_bad_alloc::~FeatureSignSparseCoder_bad_alloc(std::bad_alloc *this)
{
  this->__vftable = (std::bad_alloc_vtbl *)&unk_1EF752C88;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }

  std::bad_alloc::~bad_alloc(this);
}

{
  uint64_t vars8;

  this->__vftable = (std::bad_alloc_vtbl *)&unk_1EF752C88;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::bad_alloc::~bad_alloc(this);

  JUMPOUT(0x1A62562C0);
}

uint64_t vision::mod::FeatureSignSparseCoder_bad_alloc::what(vision::mod::FeatureSignSparseCoder_bad_alloc *this)
{
  uint64_t result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t vision::mod::FaceIDModel::predict(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v3 = a2[8];
  uint64_t v4 = a2[12];
  BOOL v5 = (int)v3 < 1 || (int)v4 < 1;
  if (v5 || (uint64_t v6 = a2[9], (v6 & 0x80000000) != 0))
  {
    syslog(5, "ERROR: invalid image descriptor buffer");
    return 7804;
  }
  uint64_t v7 = a2[7];
  if (*(void *)(a1 + 24))
  {
    if (*(float *)(a1 + 60) <= 0.0)
    {
      uint64_t v8 = &CVML_status_invalidParameter;
      syslog(5, "ERROR: negative or zero sparsity");
    }
    else if (*(void *)(a1 + 104) && *(void *)(a1 + 112))
    {
      if (*(void *)(a1 + 208))
      {
        uint64_t v8 = &CVML_status_ok;
      }
      else
      {
        uint64_t v8 = &CVML_status_inconsistentState;
        syslog(5, "ERROR: empty dictionary labels");
      }
    }
    else
    {
      uint64_t v8 = &CVML_status_inconsistentState;
      syslog(5, "ERROR: empty dictionary D_");
    }
  }
  else
  {
    uint64_t v8 = &CVML_status_inconsistentState;
    syslog(5, "ERROR: empty usedIds_");
  }
  if ((*(unsigned char *)v8 + 0x80) != 128) {
    return (*v8 + 128) | 0x1E00;
  }
  if (!v6) {
    return 7808;
  }
  uint64_t v10 = v4;
  unint64_t v234 = v6;
  vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v253, v6, v4);
  unint64_t v11 = 0;
  do
  {
    uint64_t v12 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v253, v11);
    if (v10)
    {
      uint64_t v13 = (float *)(v7 + v11 * (int)v3);
      uint64_t v14 = 4 * v10;
      do
      {
        float v15 = *v13++;
        *v12++ = v15;
        v14 -= 4;
      }
      while (v14);
    }
    ++v11;
  }
  while (v11 != v6);
  uint64_t v251 = 0;
  *(_OWORD *)int v249 = 0u;
  long long v250 = 0u;
  char v252 = 1;
  float v16 = *(float *)(a1 + 60);
  if (v16 <= 0.0)
  {
    syslog(5, "lambda must be > 0");
    uint64_t v9 = 7804;
LABEL_45:
    syslog(5, "ERROR: error happened in sparse coding");
    goto LABEL_46;
  }
  if (!*(void *)(a1 + 344) || (uint64_t v17 = *(void *)(a1 + 264)) == 0)
  {
    syslog(5, "encoder is not initialized");
    uint64_t v9 = 7796;
    goto LABEL_45;
  }
  *(double *)(a1 + 320) = v16;
  *(unsigned char *)(a1 + 328) = 0;
  unint64_t v18 = v254;
  vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v249, v254, *(void *)(v17 + 16));
  uint64_t v19 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v249, 0);
  uint64_t v236 = v10;
  bzero(v19, 8 * v251 * v250);
  uint64_t v279 = 0;
  *(_OWORD *)int v277 = 0u;
  long long v278 = 0u;
  char v280 = 1;
  vision::mod::matMult<double,16ul>((uint64_t)v253, *(void **)(a1 + 264), 1, v277, 1, 1.0, 0.0);
  *(void *)(a1 + 336) = v277;
  uint64_t v264 = 0;
  long long v263 = 0u;
  char v265 = 1;
  memset(&v266, 0, sizeof(v266));
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
  uint64_t v269 = 0;
  memset(v274, 0, sizeof(v274));
  long long v273 = 0u;
  char v275 = 1;
  memset(&v276, 0, sizeof(v276));
  float32x2_t v270 = 0;
  int8x8_t v271 = 0;
  int __N = 0;
  uint64_t v20 = *(void **)(a1 + 264);
  if (v20[3] >= v20[2]) {
    std::vector<int>::size_type v21 = v20[2];
  }
  else {
    std::vector<int>::size_type v21 = v20[3];
  }
  *(_OWORD *)unint64_t v262 = 0uLL;
  vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v262, v21, v21);
  vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)&v273, v20[2], v20[3]);
  std::vector<unsigned int>::resize(&v266, v21);
  std::vector<unsigned int>::resize(&v276, v21);
  unint64_t v22 = v20[2];
  uint64_t v24 = (uint64_t)__p;
  uint64_t v23 = v269;
  int64_t v25 = v269 - (unsigned char *)__p;
  size_t v26 = v22 - (v269 - (unsigned char *)__p);
  if (v22 <= v269 - (unsigned char *)__p)
  {
    if (v22 < v269 - (unsigned char *)__p)
    {
      uint64_t v23 = (char *)__p + v22;
      uint64_t v269 = (char *)__p + v22;
    }
  }
  else
  {
    if (v270 - v269 >= v26)
    {
      uint64_t v32 = (char *)__p + v22;
      bzero(v269, v26);
      uint64_t v269 = &v23[v26];
    }
    else
    {
      if ((v22 & 0x8000000000000000) != 0) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v27 = 2 * (v270 - (unsigned char *)__p);
      if (v27 <= v22) {
        unint64_t v27 = v20[2];
      }
      if ((unint64_t)(v270 - (unsigned char *)__p) >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v28 = v27;
      }
      unint64_t v29 = operator new(v28);
      uint64_t v30 = (char *)v29 + v25;
      uint64_t v31 = (char *)v29 + v28;
      uint64_t v32 = (char *)v29 + v22;
      bzero(v30, v26);
      if (v23 == (char *)v24)
      {
        unint64_t v29 = v30;
      }
      else
      {
        uint64_t v33 = &v23[~v24];
        do
        {
          char v34 = *--v23;
          (v33--)[(void)v29] = v34;
        }
        while (v23 != (char *)v24);
        uint64_t v23 = (char *)__p;
      }
      std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = v29;
      uint64_t v269 = v32;
      float32x2_t v270 = v31;
      if (v23)
      {
        operator delete(v23);
        uint64_t v32 = v269;
      }
    }
    uint64_t v24 = (uint64_t)__p;
    unint64_t v18 = v254;
    uint64_t v23 = v32;
  }
  bzero((void *)v24, (size_t)&v23[-v24]);
  int8x8_t v271 = (void *)(a1 + 272);
  int v272 = v20;
  int __N = 0;
  if (!v18)
  {
    BOOL v186 = 0;
    uint64_t v37 = v236;
    goto LABEL_237;
  }
  unint64_t v36 = 0;
  uint64_t v37 = v236;
  while (2)
  {
    unint64_t v228 = v36;
    int __N = 0;
    bzero(__p, v269 - (unsigned char *)__p);
    if (v18 <= v228)
    {
      exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "row index out of range");
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
      __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
    }
    __src = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v253, v228);
    if ((unint64_t)v278 <= v228)
    {
      uint64_t v227 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v227, "row index out of range");
      v227->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
      __cxa_throw(v227, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
    }
    *(void *)uint64_t v233 = v255;
    uint64_t v38 = vision::mod::CVMLMatrix<double,16ul>::ptr(v277, v228);
    if ((unint64_t)v250 <= v228)
    {
      uint64_t v225 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v225, "row index out of range");
      v225->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
      __cxa_throw(v225, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
    }
    unint64_t v39 = (const void *)v38;
    unint64_t v40 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v249, v228);
    int v41 = 0;
    int v257 = v40;
    unint64_t v258 = (double *)v40;
    uint64_t v259 = *((void *)&v250 + 1);
    uint64_t v260 = 1;
    char v261 = 0;
    int v230 = DWORD2(v250);
    __uint64_t n = 8 * SDWORD2(v250);
    uint64_t v229 = DWORD2(v250);
    double v237 = v39;
    while (2)
    {
      int v232 = v41;
      memcpy(*(void **)(a1 + 360), v39, __n);
      vision::mod::matVecMult<double,16ul>(a1 + 272, 0, (uint64_t)&v257, a1 + 352, -1.0);
      if (v230 < 1)
      {
        int v44 = -1;
        double v43 = 0.0;
      }
      else
      {
        uint64_t v42 = 0;
        double v43 = 0.0;
        int v44 = -1;
        do
        {
          if (!*((unsigned char *)__p + v42))
          {
            double v45 = fabs(*(double *)(*(void *)(a1 + 360) + 8 * *(void *)(a1 + 376) * v42));
            if (v45 > v43)
            {
              double v43 = v45;
              int v44 = v42;
            }
          }
          ++v42;
        }
        while (v229 != v42);
      }
      if (v43 <= *(double *)(a1 + 320))
      {
LABEL_228:
        uint64_t v24 = 7552;
        goto LABEL_229;
      }
      int v46 = __N;
      uint64_t v47 = __N;
      uint64_t v48 = *(void *)(a1 + 400);
      uint64_t v49 = *(void *)(a1 + 416);
      if (__N >= 1)
      {
        begiuint64_t n = v266.__begin_;
        int v51 = *(double **)(a1 + 400);
        uint64_t v52 = __N;
        uint64_t v53 = v258;
        uint64_t v54 = v260;
        do
        {
          uint64_t v55 = *begin++;
          if (v53[v54 * v55] < 0.0) {
            double v56 = -1.0;
          }
          else {
            double v56 = 1.0;
          }
          double *v51 = v56;
          v51 += v49;
          --v52;
        }
        while (v52);
      }
      if (*(double *)(*(void *)(a1 + 360) + 8 * *(void *)(a1 + 376) * v44) < 0.0) {
        double v57 = 1.0;
      }
      else {
        double v57 = -1.0;
      }
      *(double *)(v48 + 8 * v49 * v47) = v57;
      if (v44 < 0 && v44 >= *((_DWORD *)v271 + 4))
      {
        syslog(5, "ERROR: dictionary index out of range");
        std::string v59 = &CVML_status_internalError;
      }
      else
      {
        std::vector<int>::pointer v58 = v266.__begin_;
        if (v46 == ((unint64_t)((char *)v266.__end_ - (char *)v266.__begin_) >> 2))
        {
          syslog(5, "ERROR: sparsity constraint is too small, increase lambda");
          std::string v59 = &CVML_status_smallSparsity;
        }
        else
        {
          if (v47)
          {
            uint64_t v60 = vision::mod::CVMLMatrix<double,16ul>::ptr(v271, v44);
            uint64_t v61 = vision::mod::CVMLMatrix<double,16ul>::ptr(v262, __N);
            uint64_t v62 = (__CLPK_doublereal *)v61;
            int v63 = __N;
            if (__N >= 1)
            {
              std::vector<int>::pointer v64 = v266.__begin_;
              unint64_t v65 = (void *)v61;
              uint64_t v66 = __N;
              do
              {
                uint64_t v67 = *v64++;
                *v65++ = *(void *)(v60 + 8 * v67);
                --v66;
              }
              while (v66);
            }
            __CLPK_integer v68 = (int)v264;
            uint64_t v69 = (__CLPK_doublereal *)vision::mod::CVMLMatrix<double,16ul>::ptr(v262, 0);
            char __uplo = 85;
            char __trans = 84;
            char __diag = 78;
            v296[0] = v63;
            __nrhs[0] = 1;
            __lda[0] = v68;
            __ldb[0] = v63;
            __info[0] = 0;
            dtrtrs_(&__uplo, &__trans, &__diag, v296, __nrhs, v69, __lda, v62, __ldb, __info);
            if (__info[0] < 0)
            {
              std::string v59 = &CVML_status_LAPACKError;
              goto LABEL_99;
            }
            double v70 = cblas_ddot(__N, v62, 1, v62, 1);
            uint64_t v71 = __N;
            v62[__N] = sqrt(fmax(*(double *)(v60 + 8 * v44) - v70, 0.0));
            std::vector<int>::pointer v58 = v266.__begin_;
          }
          else
          {
            uint64_t v71 = 0;
            *(double *)v262[1] = sqrt(*(double *)(v271[1] + 8 * (v44 + v44 * v271[4])));
          }
          v58[v71] = v44;
          *((unsigned char *)__p + v44) = 1;
          unint64_t v72 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v273, __N);
          uint64_t v73 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v272, v44);
          memcpy(v72, v73, 8 * v272[3]);
          ++__N;
          std::string v59 = &CVML_status_ok;
        }
      }
LABEL_99:
      uint64_t v24 = (*v59 + 128) | 0x1D00;
      if (v24 != 7552) {
        goto LABEL_229;
      }
      int v74 = 0;
      unint64_t v39 = v237;
      while (v74 <= 99)
      {
        *(void *)uint64_t v245 = __N;
        if (v74 && __N >= 1)
        {
          std::vector<int>::pointer v75 = v266.__begin_;
          uint64_t v76 = v258;
          uint64_t v77 = v260;
          uint64_t v78 = __N;
          uint64_t v79 = *(double **)(a1 + 400);
          uint64_t v80 = 8 * *(void *)(a1 + 416);
          do
          {
            uint64_t v81 = *v75++;
            if (v76[v77 * v81] < 0.0) {
              double v82 = -1.0;
            }
            else {
              double v82 = 1.0;
            }
            *uint64_t v79 = v82;
            uint64_t v79 = (double *)((char *)v79 + v80);
            --v78;
          }
          while (v78);
        }
        uint64_t v83 = *(__CLPK_doublereal **)(a1 + 360);
        uint64_t v243 = *(void *)(a1 + 376);
        uint64_t v84 = 8 * v243;
        if (v245[0] >= 1)
        {
          std::vector<int>::pointer v85 = v266.__begin_;
          unint64_t v86 = *(double **)(a1 + 400);
          uint64_t v87 = 8 * *(void *)(a1 + 416);
          int v88 = *(double **)(a1 + 360);
          uint64_t v89 = *(void *)v245;
          do
          {
            uint64_t v90 = *v85++;
            *int v88 = *((double *)v39 + v90) - *(double *)(a1 + 320) * *v86;
            int v88 = (double *)((char *)v88 + v84);
            unint64_t v86 = (double *)((char *)v86 + v87);
            --v89;
          }
          while (v89);
        }
        __CLPK_integer v91 = (int)v264;
        long long v92 = (__CLPK_doublereal *)vision::mod::CVMLMatrix<double,16ul>::ptr(v262, 0);
        char __uplo = 85;
        v296[0] = v245[0];
        __nrhs[0] = 1;
        __lda[0] = v91;
        __ldb[0] = v245[0];
        __info[0] = 0;
        dpotrs_(&__uplo, v296, __nrhs, v92, __lda, v83, __ldb, __info);
        uint64_t v93 = &CVML_status_ok;
        if (__info[0] < 0)
        {
          syslog(5, "ERROR: illegal value when solving linear equations");
          uint64_t v93 = &CVML_status_LAPACKError;
        }
        uint64_t v24 = (*v93 + 128) | 0x1D00;
        if (v24 != 7552) {
          goto LABEL_229;
        }
        unint64_t v94 = *(double **)(a1 + 400);
        uint64_t v95 = *(void *)(a1 + 416);
        *(void *)__lda = v94;
        int v284 = v94;
        uint64_t v286 = v95;
        uint64_t v285 = v245[0];
        char v287 = 0;
        *(void *)__incX = v95;
        uint64_t v96 = 8 * v95;
        if (v245[0] >= 1)
        {
          std::vector<int>::pointer v97 = v266.__begin_;
          int v98 = v94;
          uint64_t v99 = *(void *)v245;
          uint64_t v100 = v258;
          uint64_t v101 = v260;
          do
          {
            uint64_t v102 = *v97++;
            *int v98 = v100[v101 * v102];
            int v98 = (double *)((char *)v98 + v96);
            --v99;
          }
          while (v99);
        }
        if (!v245[0])
        {
          LODWORD(v112) = __N;
LABEL_222:
          unint64_t v39 = v237;
          if ((int)v112 >= 1)
          {
            std::vector<int>::pointer v181 = v266.__begin_;
            uint64_t v182 = v112;
            uint64_t v183 = v258;
            uint64_t v184 = v260;
            do
            {
              uint64_t v185 = *v181++;
              v183[v184 * v185] = *v83;
              uint64_t v83 = (__CLPK_doublereal *)((char *)v83 + v84);
              --v182;
            }
            while (v182);
          }
          uint64_t v37 = v236;
          break;
        }
        int v103 = 0;
        int v104 = v94;
        uint64_t v105 = v245[0];
        uint64_t v106 = v83;
        do
        {
          double v107 = *v104;
          if (fabs(*v104) > 2.22044605e-16)
          {
            double v108 = *v106;
            if (fabs(*v106) > 2.22044605e-16
              && (v107 <= 0.0 || v108 <= 0.0)
              && (v107 >= 0.0 || v108 >= 0.0)
              && vabdd_f64(v108, v107) >= 2.22044605e-16)
            {
              double v109 = (0.0 - v107) / (v108 - v107);
              if (v109 >= 0.0 && v109 <= 1.0)
              {
                uint64_t v111 = v103++;
                *(double *)(*(void *)(a1 + 520) + 8 * *(void *)(a1 + 536) * v111) = v109;
              }
            }
          }
          uint64_t v106 = (double *)((char *)v106 + v84);
          int v104 = (double *)((char *)v104 + v96);
          --v105;
        }
        while (v105);
        uint64_t v112 = __N;
        if (!v103) {
          goto LABEL_222;
        }
        int v239 = v74;
        uint64_t v113 = (v103 + 1);
        int v238 = v103;
        *(void *)(*(void *)(a1 + 520) + 8 * *(void *)(a1 + 536) * v103) = 0x3FF0000000000000;
        std::__sort<std::__less<double,double> &,double *>();
        *(void *)double v296 = vision::mod::CVMLMatrix<double,16ul>::ptr(&v273, 0);
        v297 = *(void **)v296;
        uint64_t v298 = __N;
        long long v299 = *(_OWORD *)&v274[1];
        char v300 = 0;
        uint64_t v114 = *(double **)(a1 + 560);
        uint64_t v115 = *(void *)(a1 + 576);
        *(void *)__nrhs = v114;
        int v290 = v114;
        uint64_t v292 = v115;
        uint64_t v291 = (int)v112;
        char v293 = 0;
        if ((int)v112 >= 1)
        {
          int v116 = v83;
          int v117 = v94;
          int v118 = v114;
          uint64_t v119 = v112;
          do
          {
            *int v118 = *v116 - *v117;
            v118 += v115;
            int v117 = (double *)((char *)v117 + v96);
            int v116 = (double *)((char *)v116 + v84);
            --v119;
          }
          while (v119);
        }
        vision::mod::matVecMult<double,16ul>((uint64_t)v296, 1, (uint64_t)__nrhs, a1 + 432, 0.0);
        double v120 = cblas_ddot(*(_DWORD *)(a1 + 448), *(const double **)(a1 + 440), *(_DWORD *)(a1 + 456), *(const double **)(a1 + 440), *(_DWORD *)(a1 + 456));
        uint64_t v121 = *(void *)(a1 + 496);
        if (v121 == 1) {
          memcpy(*(void **)(a1 + 480), __src, 8 * *(void *)v233);
        }
        else {
          cblas_dcopy(v233[0], (const double *)__src, 1, *(double **)(a1 + 480), v121);
        }
        vision::mod::matVecMult<double,16ul>((uint64_t)v296, 1, (uint64_t)__lda, a1 + 472, -1.0);
        double v122 = cblas_ddot(*(_DWORD *)(a1 + 448), *(const double **)(a1 + 440), *(_DWORD *)(a1 + 456), *(const double **)(a1 + 480), *(_DWORD *)(a1 + 496));
        int v123 = v83;
        double v124 = *(double *)(a1 + 320);
        double v125 = cblas_dasum(v245[0], v94, __incX[0]);
        if (v238 < 0)
        {
          double v131 = 0.0;
LABEL_157:
          catlas_daxpby(v245[0], v131, v123, v243, 1.0 - v131, v94, __incX[0]);
          int v74 = v239;
          if ((int)v112 < 1)
          {
            if (!__N) {
              goto LABEL_188;
            }
            int v135 = 0;
            unint64_t v168 = v276.__begin_;
            float v141 = v276.__begin_;
            uint64_t v37 = v236;
            unint64_t v39 = v237;
          }
          else
          {
            int v135 = 0;
            std::vector<int>::pointer v136 = v266.__begin_;
            int v137 = v258;
            uint64_t v138 = v260;
            do
            {
              double v139 = *v94;
              if (fabs(*v94) < 2.22044605e-16)
              {
                *unint64_t v94 = 0.0;
                *(_DWORD *)(*(void *)(a1 + 592) + 4 * v135) = *v136;
                double v139 = 0.0;
                ++v135;
              }
              uint64_t v140 = *v136++;
              v137[v138 * v140] = v139;
              unint64_t v94 = (double *)((char *)v94 + v96);
              --v112;
            }
            while (v112);
            if (!__N)
            {
LABEL_188:
              uint64_t v37 = v236;
              unint64_t v39 = v237;
              syslog(5, "ERROR: empty active set: nothing to delete");
LABEL_191:
              uint64_t v170 = 0;
              goto LABEL_204;
            }
            float v141 = v276.__begin_;
            uint64_t v37 = v236;
            unint64_t v39 = v237;
            if (v135 >= 1)
            {
              uint64_t v142 = 0;
              float v143 = *(int **)(a1 + 592);
              std::vector<int>::pointer v144 = v266.__begin_;
              do
              {
                v141[v142] = -1;
                if (__N < 1)
                {
LABEL_189:
                  int v148 = "ERROR: index to delete not in active set";
LABEL_190:
                  syslog(5, v148);
                  goto LABEL_191;
                }
                uint64_t v145 = 0;
                while (v144[v145] != v143[v142])
                {
                  if (__N == ++v145) {
                    goto LABEL_189;
                  }
                }
                v141[v142++] = v145;
              }
              while (v142 != v135);
              std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v141, &v141[v135], 126 - 2 * __clz(v135), 1);
              uint64_t v146 = 0;
              do
              {
                uint64_t v147 = v276.__begin_[v146];
                if ((v147 & 0x80000000) != 0)
                {
                  syslog(5, "ERROR: row index to delete out of range");
                  goto LABEL_191;
                }
                *(void *)int v246 = v146;
                int v148 = "ERROR: row index to delete out of range";
                if (__N <= (int)v147) {
                  goto LABEL_190;
                }
                uint64_t v149 = vision::mod::CVMLMatrix<double,16ul>::ptr(v262, 0);
                uint64_t v150 = v149;
                int v151 = (int)v264;
                int v152 = v147 * v264;
                LODWORD(v153) = __N - 1;
                if (__N - 1 > (int)v147)
                {
                  float32x2_t v154 = (char *)(v149 + 8 * v152);
                  size_t v155 = 8 * v147 + 16;
                  uint64_t v156 = 8 * (int)v264;
                  uint64_t v157 = v147;
                  do
                  {
                    unint64_t v158 = &v154[v156];
                    memcpy(v154, &v154[v156], v155);
                    ++v157;
                    uint64_t v153 = __N - 1;
                    v155 += 8;
                    float32x2_t v154 = v158;
                  }
                  while (v157 < v153);
                }
                *(double *)__info = 0.0;
                *(double *)uint64_t __ldb = 0.0;
                if ((int)v153 > (int)v147)
                {
                  uint64_t v159 = 8 * v152;
                  uint64_t v160 = v150 + 8 * v147 + 8 * v151;
                  uint64_t v161 = 8 * v151 + 8;
                  int v162 = -2 - v147;
                  uint64_t v163 = v150 + 8 * v147;
                  do
                  {
                    cblas_drotg((double *)(v163 + v159), (double *)(v163 + v159 + 8), (double *)__ldb, (double *)__info);
                    double v165 = *(double *)__info;
                    double v164 = *(double *)__ldb;
                    if (*(double *)(v163 + v159) < 0.0)
                    {
                      *(double *)(v163 + v159) = fabs(*(double *)(v163 + v159));
                      double v164 = -v164;
                      double v165 = -v165;
                      *(double *)__info = v165;
                      *(double *)uint64_t __ldb = v164;
                    }
                    *(void *)(v163 + v159 + 8) = 0;
                    cblas_drot(v162 + __N, (double *)(v160 + v159), v151, (double *)(v160 + v159 + 8), v151, v164, v165);
                    ++v147;
                    v160 += v161;
                    --v162;
                    v163 += v161;
                  }
                  while (v147 < __N - 1);
                }
                uint64_t v166 = v135;
                uint64_t v146 = *(void *)v246 + 1;
                uint64_t v37 = v236;
                unint64_t v39 = v237;
                int v74 = v239;
              }
              while (*(void *)v246 + 1 != v135);
              do
              {
                uint64_t v167 = *v143++;
                *((unsigned char *)__p + v167) = 0;
                --v166;
              }
              while (v166);
              goto LABEL_195;
            }
            unint64_t v168 = &v276.__begin_[v135];
            if (v135)
            {
              uint64_t v169 = 126 - 2 * __clz(v135);
              goto LABEL_194;
            }
          }
          uint64_t v169 = 0;
LABEL_194:
          std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v141, v168, v169, 1);
LABEL_195:
          int v171 = __N;
          if (__N >= 1)
          {
            int64_t v172 = 0;
            int v173 = 0;
            do
            {
              uint64_t v174 = v266.__begin_[v172];
              if (*((unsigned char *)__p + v174))
              {
                v276.__begin_[v173] = v174;
                if (v172 != v173)
                {
                  uint64_t v175 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v273, v173);
                  uint64_t v176 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v273, v172);
                  memcpy(v175, v176, 8 * v274[1]);
                }
                ++v173;
                int v171 = __N;
              }
              ++v172;
            }
            while (v172 < v171);
          }
          uint64_t v170 = 0;
          long long v177 = *(_OWORD *)&v266.__begin_;
          *(_OWORD *)&v266.__begin_ = *(_OWORD *)&v276.__begin_;
          *(_OWORD *)&v276.__begin_ = v177;
          value = v266.__end_cap_.__value_;
          v266.__end_cap_.__value_ = v276.__end_cap_.__value_;
          v276.__end_cap_.__value_ = value;
          int __N = v171 - v135;
          goto LABEL_204;
        }
        uint64_t v126 = 0;
        double v127 = v120 * 0.5;
        double v128 = v124 * v125;
        BOOL v130 = *(void *)__incX == 1 && v115 == 1;
        double v131 = 0.0;
        while (1)
        {
          double v132 = *(double *)(*(void *)(a1 + 520) + 8 * *(void *)(a1 + 536) * v126);
          if (v130) {
            memcpy(v114, v94, 8 * v245[0]);
          }
          else {
            cblas_dcopy(v245[0], v94, __incX[0], v114, v115);
          }
          catlas_daxpby(v245[0], v132, v123, v243, 1.0 - v132, v114, v115);
          double v133 = *(double *)(a1 + 320);
          double v134 = v122 * v132 + v127 * v132 * v132 + v133 * cblas_dasum(v112, v114, v115);
          if (v134 >= v128) {
            break;
          }
          ++v126;
          double v128 = v134;
          double v131 = v132;
          if (v113 == v126)
          {
            double v131 = v132;
            goto LABEL_157;
          }
        }
        if (v126) {
          goto LABEL_157;
        }
        uint64_t v170 = 1;
        uint64_t v37 = v236;
        unint64_t v39 = v237;
        int v74 = v239;
LABEL_204:
        if (v293 && *(void *)__nrhs) {
          free(*(void **)__nrhs);
        }
        if (v300 && *(void *)v296) {
          free(*(void **)v296);
        }
        BOOL v179 = v170 == 0;
        if (v170) {
          int v180 = 3;
        }
        else {
          int v180 = 0;
        }
        if (v179) {
          ++v74;
        }
        if (v287 && *(void *)__lda) {
          free(*(void **)__lda);
        }
        if (v180) {
          break;
        }
      }
      if (v74 != 100)
      {
        int v41 = v232 + 1;
        if (v232 == 999) {
          goto LABEL_228;
        }
        continue;
      }
      break;
    }
    uint64_t v24 = 7528;
LABEL_229:
    BOOL v186 = v24 != 7552;
    if (v261 && v257) {
      free(v257);
    }
    if (v24 == 7552)
    {
      unint64_t v36 = v228 + 1;
      unint64_t v18 = v254;
      if (v228 + 1 >= v254)
      {
        BOOL v186 = 0;
        LOBYTE(v24) = 0x80;
        break;
      }
      continue;
    }
    break;
  }
LABEL_237:
  if (v276.__begin_)
  {
    v276.__end_ = v276.__begin_;
    operator delete(v276.__begin_);
  }
  if (v275 && (void)v273) {
    free((void *)v273);
  }
  long long v273 = 0u;
  memset(v274, 0, sizeof(v274));
  char v275 = 1;
  if (__p)
  {
    uint64_t v269 = (char *)__p;
    operator delete(__p);
  }
  if (v266.__begin_)
  {
    v266.__end_ = v266.__begin_;
    operator delete(v266.__begin_);
  }
  if (v265 && v262[0]) {
    free(v262[0]);
  }
  if (v280 && v277[0]) {
    free(v277[0]);
  }
  if (v186 && v24 != 128)
  {
    uint64_t v9 = v24 | 0x1E00;
    goto LABEL_45;
  }
  vision::mod::CVMLVector<double,16ul>::initialize_((uint64_t)__nrhs, v234);
  vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v277, v234, v37);
  uint64_t v188 = *a3;
  uint64_t v187 = a3[1];
  unint64_t v189 = 0xAAAAAAAAAAAAAAABLL * ((v187 - *a3) >> 3);
  unint64_t v190 = v234 - v189;
  if (v234 <= v189)
  {
    if (v234 < v189)
    {
      uint64_t v199 = v188 + 24 * v234;
      if (v187 != v199)
      {
        do
        {
          uint64_t v200 = v187 - 24;
          std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(void **)(v187 - 16));
          uint64_t v187 = v200;
        }
        while (v200 != v199);
      }
      a3[1] = v199;
    }
  }
  else
  {
    uint64_t v191 = a3[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v191 - v187) >> 3) >= v190)
    {
      uint64_t v201 = v187 + 24 * v190;
      uint64_t v202 = 24 * v234 - 8 * ((v187 - *a3) >> 3);
      float v203 = (void *)(v187 + 8);
      do
      {
        *float v203 = 0;
        v203[1] = 0;
        *(v203 - 1) = v203;
        v203 += 3;
        v202 -= 24;
      }
      while (v202);
      a3[1] = v201;
    }
    else
    {
      uint64_t v264 = a3 + 2;
      unint64_t v192 = 0xAAAAAAAAAAAAAAABLL * ((v191 - v188) >> 3);
      unint64_t v193 = 0x5555555555555556 * ((v191 - v188) >> 3);
      if (v193 <= v234) {
        unint64_t v193 = v234;
      }
      if (v192 >= 0x555555555555555) {
        unint64_t v194 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v194 = v193;
      }
      std::vector<int>::size_type v195 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v194);
      v262[0] = v195;
      v262[1] = &v195[24 * v189];
      *((void *)&v263 + 1) = &v195[24 * v196];
      uint64_t v197 = 24 * v234 - 24 * v189;
      uint64_t v198 = (char *)v262[1] + 8;
      do
      {
        *uint64_t v198 = 0;
        v198[1] = 0;
        *(v198 - 1) = v198;
        v198 += 3;
        v197 -= 24;
      }
      while (v197);
      *(void *)&long long v263 = &v195[24 * v234];
      std::vector<std::map<int,double>>::__swap_out_circular_buffer(a3, v262);
      std::__split_buffer<std::map<int,double>>::~__split_buffer((uint64_t)v262);
    }
  }
  uint64_t v204 = *(uint64_t **)(a1 + 200);
  if (v204)
  {
    long long v205 = v250;
    uint64_t v244 = v251;
    unint64_t v247 = (char *)v249[1];
    unint64_t v206 = v254;
    *(void *)__incXa = v255;
    size_t v207 = 8 * v255;
    while (1)
    {
      unint64_t v209 = *((int *)v204 + 5);
      uint64_t v208 = *((int *)v204 + 6);
      unint64_t v210 = *(void *)(a1 + 104);
      unint64_t v211 = v208 + v209;
      if (v210 <= v209 || v211 > v210) {
        break;
      }
      uint64_t v213 = *(void *)(a1 + 112);
      if (!v213)
      {
        unint64_t v222 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v222, "col index out of range");
        goto LABEL_300;
      }
      std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v214 = *(uint64_t **)(a1 + 120);
      v262[0] = (void *)(*(void *)(a1 + 96) + 8 * (void)v214 * v209);
      v262[1] = v262[0];
      *(void *)&long long v263 = v208;
      *((void *)&v263 + 1) = v213;
      uint64_t v264 = v214;
      char v265 = 0;
      if (!(void)v205)
      {
        uint64_t v223 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v223, "row index out of range");
        goto LABEL_302;
      }
      if (*((void *)&v205 + 1) <= v209 || v211 > *((void *)&v205 + 1))
      {
        uint64_t v223 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v223, "col index out of range");
LABEL_302:
        v223->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
        __cxa_throw(v223, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
      }
      *(void *)double v296 = &v247[8 * v209];
      v297 = *(void **)v296;
      uint64_t v298 = v205;
      *(void *)&long long v299 = v208;
      *((void *)&v299 + 1) = v244;
      char v300 = 0;
      if ((unint64_t)v278 < v206 || *((void *)&v278 + 1) < *(void *)__incXa)
      {
        uint64_t v224 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v224, "output matrix size too small");
        v224->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
        __cxa_throw(v224, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
      }
      if (v206)
      {
        for (unint64_t i = 0; i != v206; ++i)
        {
          std::vector<int>::pointer v216 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v277, i);
          std::vector<int>::size_type v217 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v253, i);
          memcpy(v216, v217, v207);
        }
      }
      vision::mod::matMult<double,16ul>((uint64_t)v296, v262, 0, v277, 0, -1.0, 1.0);
      vision::mod::CVMLMatrix<double,16ul>::rowNorms((uint64_t)v277, __nrhs, 0);
      uint64_t v218 = 0;
      uint64_t v219 = v290;
      uint64_t v220 = 8 * v292;
      unint64_t v221 = v234;
      do
      {
        *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)(*a3 + v218), *((_DWORD *)v204 + 4), (_DWORD *)v204 + 4)+ 5) = fmax(1.0 - *v219, 0.0);
        v218 += 24;
        uint64_t v219 = (double *)((char *)v219 + v220);
        --v221;
      }
      while (v221);
      uint64_t v204 = (uint64_t *)*v204;
      if (!v204) {
        goto LABEL_290;
      }
    }
    unint64_t v222 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v222, "row index out of range");
LABEL_300:
    v222->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
    __cxa_throw(v222, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
  }
LABEL_290:
  if (v280 && v277[0]) {
    free(v277[0]);
  }
  if (v293 && *(void *)__nrhs) {
    free(*(void **)__nrhs);
  }
  uint64_t v9 = 7808;
LABEL_46:
  if (v252 && v249[0]) {
    free(v249[0]);
  }
  if (v256 && v253[0]) {
    free(v253[0]);
  }
  return v9;
}

void sub_1A3F7B568(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (LOBYTE(STACK[0x248]) && STACK[0x220]) {
    free((void *)STACK[0x220]);
  }
  if (LOBYTE(STACK[0x2A8]) && STACK[0x288]) {
    free((void *)STACK[0x288]);
  }
  if (a40 && a35) {
    free(a35);
  }
  if (a47 && a42) {
    free(a42);
  }
  if (a2 == 2)
  {
    __cxa_begin_catch(a1);
    syslog(5, "ERROR: memory allocation failed");
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1) {
      _Unwind_Resume(a1);
    }
    __cxa_begin_catch(a1);
    syslog(5, "ERROR: unexpected exception thrown");
    __cxa_end_catch();
  }
  JUMPOUT(0x1A3F7A0A8);
}

uint64_t **std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      BOOL v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x30uLL);
    v9[8] = *a3;
    *((void *)v9 + 5) = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t *std::vector<std::map<int,double>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      *(void *)(v6 - 24) = *(void *)(v2 + v5 - 24);
      uint64_t v7 = (uint64_t *)(v2 + v5 - 16);
      uint64_t v8 = *v7;
      *(void *)(v4 + v5 - 16) = *v7;
      uint64_t v9 = v4 + v5 - 16;
      uint64_t v10 = *(void *)(v2 + v5 - 8);
      *(void *)(v6 - 8) = v10;
      if (v10)
      {
        *(void *)(v8 + 16) = v9;
        *(void *)(v2 + v5 - 24) = v7;
        uint64_t *v7 = 0;
        *(void *)(v2 + v5 - 8) = 0;
      }
      else
      {
        *(void *)(v6 - 24) = v9;
      }
      v5 -= 24;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v11 = *result;
  *uint64_t result = v4;
  a2[1] = v11;
  uint64_t v12 = result[1];
  result[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = result[2];
  result[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::map<int,double>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(void **)(i - 16));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t vision::mod::ActiveSet<double,16ul>::~ActiveSet(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 168);
  if (v2)
  {
    *(void *)(a1 + 176) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void **)(a1 + 120);
  if (*(unsigned char *)(a1 + 160) && *v3) {
    free(*v3);
  }
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)uint64_t v3 = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(unsigned char *)(a1 + 160) = 1;
  uint64_t v4 = *(void **)(a1 + 80);
  if (v4)
  {
    *(void *)(a1 + 88) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 48);
  if (v5)
  {
    *(void *)(a1 + 56) = v5;
    operator delete(v5);
  }
  if (*(unsigned char *)(a1 + 40) && *(void *)a1) {
    free(*(void **)a1);
  }
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(unsigned char *)(a1 + 40) = 1;
  return a1;
}

void vision::mod::matVecMult<double,16ul>(uint64_t a1, int a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t v10 = *(void *)(a3 + 16);
  if (a2)
  {
    if (*(void *)(a1 + 16) == v10)
    {
      uint64_t v11 = (void *)(a1 + 24);
      goto LABEL_6;
    }
LABEL_12:
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "matrix vector size mismatch");
    uint64_t v17 = (struct type_info *)off_1E5B19CD8;
    unint64_t v18 = (void (*)(void *))MEMORY[0x1E4FBA1E8];
LABEL_13:
    __cxa_throw(exception, v17, v18);
  }
  if (*(void *)(a1 + 24) != v10) {
    goto LABEL_12;
  }
  uint64_t v11 = (void *)(a1 + 16);
LABEL_6:
  if (*v11 != *(void *)(a4 + 16))
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "vector size too small for output");
    uint64_t v17 = (struct type_info *)off_1E5B19CC8;
    unint64_t v18 = (void (*)(void *))MEMORY[0x1E4FBA1D0];
    goto LABEL_13;
  }
  int v12 = *(_DWORD *)(a1 + 16);
  int v13 = *(_DWORD *)(a1 + 24);
  uint64_t v14 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr((void *)a1, 0);
  if (a2) {
    CBLAS_TRANSPOSE v15 = CblasTrans;
  }
  else {
    CBLAS_TRANSPOSE v15 = CblasNoTrans;
  }
  cblas_dgemv(CblasRowMajor, v15, v12, v13, 1.0, v14, *(_DWORD *)(a1 + 32), *(const double **)(a3 + 8), *(_DWORD *)(a3 + 24), a5, *(double **)(a4 + 8), *(void *)(a4 + 24));
}

void sub_1A3F7BBC8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceIDModel::serialize(void *a1)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  memset(v51, 0, sizeof(v51));
  long long v50 = 0u;
  long long v49 = 0u;
  long long v48 = 0u;
  long long v47 = 0u;
  *(_OWORD *)&v46[19] = 0u;
  strcpy(v46, "FaceIDModel_v1_d18");
  uint64_t v2 = (void *)std::ostream::write();
  if ((*((unsigned char *)v2 + *(void *)(*v2 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  uint64_t v3 = (void *)std::ostream::write();
  if ((*((unsigned char *)v3 + *(void *)(*v3 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  uint64_t v4 = (void *)std::ostream::write();
  if ((*((unsigned char *)v4 + *(void *)(*v4 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  uint64_t v5 = (void *)std::ostream::write();
  if ((*((unsigned char *)v5 + *(void *)(*v5 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  uint64_t v6 = (void *)std::ostream::write();
  if ((*((unsigned char *)v6 + *(void *)(*v6 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  uint64_t v7 = (void *)std::ostream::write();
  if ((*((unsigned char *)v7 + *(void *)(*v7 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  uint64_t v8 = (void *)std::ostream::write();
  if ((*((unsigned char *)v8 + *(void *)(*v8 - 24) + 32) & 5) != 0
    || vision::mod::FaceIDKmeansParams::serialize() != 128)
  {
    return 7797;
  }
  int v45 = a1[3];
  std::vector<long long>::vector(&__p, v45);
  std::vector<int>::vector((std::vector<int> *)&__n[1], v45);
  uint64_t v9 = (uint64_t *)a1[2];
  if (v9)
  {
    uint64_t v10 = __p;
    uint64_t v11 = *(_DWORD **)&__n[1];
    do
    {
      *v10++ = v9[2];
      *v11++ = *((_DWORD *)v9 + 6);
      uint64_t v9 = (uint64_t *)*v9;
    }
    while (v9);
  }
  int v12 = (void *)std::ostream::write();
  if ((*((unsigned char *)v12 + *(void *)(*v12 - 24) + 32) & 5) != 0
    || (int v13 = (void *)std::ostream::write(), (*((unsigned char *)v13 + *(void *)(*v13 - 24) + 32) & 5) != 0)
    || (uint64_t v14 = (void *)std::ostream::write(), (*((unsigned char *)v14 + *(void *)(*v14 - 24) + 32) & 5) != 0))
  {
    uint64_t v15 = 7797;
  }
  else
  {
    int v44 = __p;
    *(void *)&__n[3] = *(void *)&__n[1];
    uint64_t v15 = vision::mod::_serialize(a1 + 11);
    if (v15 == 128)
    {
      __n[0] = a1[26];
      std::vector<int>::vector(&v41, __n[0]);
      std::vector<int>::vector(&v40, __n[0]);
      std::vector<int>::vector((std::vector<int> *)&v39[1], __n[0]);
      uint64_t v17 = (uint64_t *)a1[25];
      if (v17)
      {
        begiuint64_t n = v41.__begin_;
        std::vector<int>::pointer v19 = v40.__begin_;
        uint64_t v20 = *(_DWORD **)&v39[1];
        do
        {
          *begin++ = *((_DWORD *)v17 + 4);
          *v19++ = *((_DWORD *)v17 + 5);
          *v20++ = *((_DWORD *)v17 + 6);
          uint64_t v17 = (uint64_t *)*v17;
        }
        while (v17);
      }
      std::vector<int>::size_type v21 = (void *)std::ostream::write();
      if ((*((unsigned char *)v21 + *(void *)(*v21 - 24) + 32) & 5) != 0
        || (unint64_t v22 = (void *)std::ostream::write(), (*((unsigned char *)v22 + *(void *)(*v22 - 24) + 32) & 5) != 0)
        || (uint64_t v23 = (void *)std::ostream::write(), (*((unsigned char *)v23 + *(void *)(*v23 - 24) + 32) & 5) != 0)
        || (uint64_t v24 = (void *)std::ostream::write(), (*((unsigned char *)v24 + *(void *)(*v24 - 24) + 32) & 5) != 0))
      {
        uint64_t v15 = 7797;
      }
      else
      {
        uint64_t v15 = vision::mod::_serialize(a1 + 17);
        if (v15 == 128)
        {
          v39[0] = a1[31];
          std::vector<int>::vector(&v38, v39[0]);
          std::vector<int>::vector(&v37, v39[0]);
          std::vector<int>::vector(&v36, v39[0]);
          int64_t v25 = (uint64_t *)a1[30];
          if (v25)
          {
            std::vector<int>::pointer v26 = v38.__begin_;
            std::vector<int>::pointer v27 = v37.__begin_;
            std::vector<int>::pointer v28 = v36.__begin_;
            do
            {
              *v26++ = *((_DWORD *)v25 + 4);
              *v27++ = *((_DWORD *)v25 + 5);
              *v28++ = *((_DWORD *)v25 + 6);
              int64_t v25 = (uint64_t *)*v25;
            }
            while (v25);
          }
          unint64_t v29 = (void *)std::ostream::write();
          if ((*((unsigned char *)v29 + *(void *)(*v29 - 24) + 32) & 5) != 0
            || (uint64_t v30 = (void *)std::ostream::write(), (*((unsigned char *)v30 + *(void *)(*v30 - 24) + 32) & 5) != 0))
          {
            uint64_t v31 = &CVML_status_IOError;
          }
          else
          {
            char v34 = (void *)std::ostream::write();
            uint64_t v31 = &CVML_status_IOError;
            if ((*((unsigned char *)v34 + *(void *)(*v34 - 24) + 32) & 5) == 0)
            {
              uint64_t v35 = (void *)std::ostream::write();
              if ((*((unsigned char *)v35 + *(void *)(*v35 - 24) + 32) & 5) == 0) {
                uint64_t v31 = &CVML_status_ok;
              }
            }
          }
          uint64_t v32 = *v31;
          if (v36.__begin_)
          {
            v36.__end_ = v36.__begin_;
            operator delete(v36.__begin_);
          }
          uint64_t v33 = v32 + 128;
          if (v37.__begin_)
          {
            v37.__end_ = v37.__begin_;
            operator delete(v37.__begin_);
          }
          uint64_t v15 = v33 | 0x1E00;
          if (v38.__begin_)
          {
            v38.__end_ = v38.__begin_;
            operator delete(v38.__begin_);
          }
        }
      }
      if (*(void *)&v39[1])
      {
        *(void *)&v39[3] = *(void *)&v39[1];
        operator delete(*(void **)&v39[1]);
      }
      if (v40.__begin_)
      {
        v40.__end_ = v40.__begin_;
        operator delete(v40.__begin_);
      }
      if (v41.__begin_)
      {
        v41.__end_ = v41.__begin_;
        operator delete(v41.__begin_);
      }
    }
  }
  if (*(void *)&__n[1])
  {
    *(void *)&__n[3] = *(void *)&__n[1];
    operator delete(*(void **)&__n[1]);
  }
  if (__p)
  {
    int v44 = __p;
    operator delete(__p);
  }
  return v15;
}

void sub_1A3F7C2A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  if (a20) {
    operator delete(a20);
  }
  if (a23) {
    operator delete(a23);
  }
  if (a26) {
    operator delete(a26);
  }
  if (a30) {
    operator delete(a30);
  }
  if (a33) {
    operator delete(a33);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<long long>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<long long>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1A3F7C3D8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    std::vector<int>::pointer end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_1A3F7C450(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::_serialize(void *a1)
{
  int v9 = a1[2];
  uint64_t v2 = (void *)std::ostream::write();
  if ((*((unsigned char *)v2 + *(void *)(*v2 - 24) + 32) & 5) != 0
    || (uint64_t v3 = (void *)std::ostream::write(), (*((unsigned char *)v3 + *(void *)(*v3 - 24) + 32) & 5) != 0))
  {
    uint64_t v4 = -11;
  }
  else
  {
    uint64_t v6 = (void *)std::ostream::write();
    if ((*((unsigned char *)v6 + *(void *)(*v6 - 24) + 32) & 5) != 0
      || v9 >= 1
      && (vision::mod::CVMLMatrix<double,16ul>::ptr(a1, 0),
          uint64_t v8 = (void *)std::ostream::write(),
          (*((unsigned char *)v8 + *(void *)(*v8 - 24) + 32) & 5) != 0))
    {
      uint64_t v7 = &CVML_status_IOError;
    }
    else
    {
      uint64_t v7 = &CVML_status_ok;
    }
    uint64_t v4 = *v7;
  }
  return (v4 + 128) | 0x1E00;
}

uint64_t vision::mod::FaceIDModel::deserialize(uint64_t a1)
{
  v54[15] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)std::istream::read();
  if ((*((unsigned char *)v2 + *(void *)(*v2 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  BOOL v4 = *(void *)&__n[1] == 0x6F4D444965636146
    && v54[0] == 0x645F31765F6C6564
    && *(void *)((char *)v54 + 3) == 0x3831645F31765FLL;
  int v5 = !v4;
  if (v4
    || (*(void *)&__n[1] == 0x6F4D444965636146 ? (BOOL v6 = v54[0] == 0x645F31765F6C6564) : (BOOL v6 = 0),
        v6 ? (BOOL v7 = *(void *)((char *)v54 + 3) == 0x3731645F31765FLL) : (BOOL v7 = 0),
        v7))
  {
    char v10 = 1;
  }
  else
  {
    if (*(void *)&__n[1] != 0x6F4D444965636146
      || v54[0] != 0x645F31765F6C6564
      || *(void *)((char *)v54 + 3) != 0x3631645F31765FLL)
    {
      syslog(5, "ERROR: incorrect header");
      return 7797;
    }
    char v10 = 0;
  }
  uint64_t v11 = (void *)std::istream::read();
  if ((*((unsigned char *)v11 + *(void *)(*v11 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  int v12 = (void *)std::istream::read();
  if ((*((unsigned char *)v12 + *(void *)(*v12 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  int v13 = (void *)std::istream::read();
  if ((*((unsigned char *)v13 + *(void *)(*v13 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  uint64_t v14 = (void *)std::istream::read();
  if ((*((unsigned char *)v14 + *(void *)(*v14 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  if (!v5)
  {
    uint64_t v20 = (void *)std::istream::read();
    if ((*((unsigned char *)v20 + *(void *)(*v20 - 24) + 32) & 5) != 0) {
      return 7797;
    }
  }
  uint64_t v15 = (void *)std::istream::read();
  if ((*((unsigned char *)v15 + *(void *)(*v15 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  if (vision::mod::FaceIDKmeansParams::deserialize() != 128) {
    return 7797;
  }
  __n[0] = 0;
  float v16 = (void *)std::istream::read();
  if ((*((unsigned char *)v16 + *(void *)(*v16 - 24) + 32) & 5) != 0) {
    return 7797;
  }
  std::vector<long long>::vector(&__p, __n[0]);
  std::vector<int>::vector((std::vector<int> *)&v50[1], __n[0]);
  uint64_t v17 = (void *)std::istream::read();
  if ((*((unsigned char *)v17 + *(void *)(*v17 - 24) + 32) & 5) == 0)
  {
    unint64_t v18 = (void *)std::istream::read();
    if ((*((unsigned char *)v18 + *(void *)(*v18 - 24) + 32) & 5) == 0)
    {
      if (__n[0] >= 1)
      {
        uint64_t v22 = 0;
        uint64_t v23 = 0;
        do
        {
          int v24 = *(_DWORD *)(*(void *)&v50[1] + 4 * v23);
          *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((float *)a1, *(void *)((char *)__p + v22), (char *)__p + v22)+ 6) = v24;
          ++v23;
          v22 += 8;
        }
        while (v23 < __n[0]);
      }
      uint64_t v52 = __p;
      *(void *)&v50[3] = *(void *)&v50[1];
      uint64_t v19 = vision::mod::_deserialize();
      if (v19 != 128) {
        goto LABEL_39;
      }
      uint64_t v25 = *(void *)(a1 + 112);
      std::vector<int>::pointer v26 = (void **)(a1 + 136);
      vision::mod::CVMLMatrix<double,16ul>::reset(a1 + 136, 0, v25);
      if (*(unsigned char *)(a1 + 176) && *v26) {
        free(*v26);
      }
      *(void *)(a1 + 168) = 0;
      *(_OWORD *)std::vector<int>::pointer v26 = 0u;
      *(_OWORD *)(a1 + 152) = 0u;
      *(unsigned char *)(a1 + 176) = 1;
      uint64_t v19 = 7808;
      if (!v25 || !*(void *)(a1 + 104)) {
        goto LABEL_39;
      }
      v50[0] = 0;
      std::vector<int>::pointer v27 = (void *)std::istream::read();
      if ((*((unsigned char *)v27 + *(void *)(*v27 - 24) + 32) & 5) == 0)
      {
        std::vector<int>::vector(&v49, v50[0]);
        std::vector<int>::vector(&v48, v50[0]);
        std::vector<int>::vector((std::vector<int> *)&v47[1], v50[0]);
        std::vector<int>::pointer v28 = (void *)std::istream::read();
        if ((*((unsigned char *)v28 + *(void *)(*v28 - 24) + 32) & 5) != 0) {
          goto LABEL_60;
        }
        unint64_t v29 = (void *)std::istream::read();
        if ((*((unsigned char *)v29 + *(void *)(*v29 - 24) + 32) & 5) != 0) {
          goto LABEL_60;
        }
        uint64_t v30 = (void *)std::istream::read();
        if ((*((unsigned char *)v30 + *(void *)(*v30 - 24) + 32) & 5) != 0) {
          goto LABEL_60;
        }
        if (v50[0] >= 1)
        {
          uint64_t v31 = 0;
          do
          {
            int v32 = v48.__begin_[v31];
            int v33 = *(_DWORD *)(*(void *)&v47[1] + 4 * v31);
            char v34 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((float *)(a1 + 184), v49.__begin_[v31], &v49.__begin_[v31]);
            *((_DWORD *)v34 + 5) = v32;
            *((_DWORD *)v34 + 6) = v33;
            ++v31;
          }
          while (v31 < v50[0]);
        }
        if (v10)
        {
          uint64_t v19 = vision::mod::_deserialize();
          if (v19 != 128) {
            goto LABEL_61;
          }
        }
        if (v5) {
          goto LABEL_73;
        }
        v47[0] = 0;
        uint64_t v35 = (void *)std::istream::read();
        if ((*((unsigned char *)v35 + *(void *)(*v35 - 24) + 32) & 5) != 0) {
          goto LABEL_60;
        }
        std::vector<int>::vector(&v46, v47[0]);
        std::vector<int>::vector(&v45, v47[0]);
        std::vector<int>::vector(&v44, v47[0]);
        std::vector<int> v36 = (void *)std::istream::read();
        if ((*((unsigned char *)v36 + *(void *)(*v36 - 24) + 32) & 5) != 0
          || (std::vector<int> v37 = (void *)std::istream::read(), (*((unsigned char *)v37 + *(void *)(*v37 - 24) + 32) & 5) != 0)
          || (std::vector<int> v38 = (void *)std::istream::read(), (*((unsigned char *)v38 + *(void *)(*v38 - 24) + 32) & 5) != 0))
        {
          char v39 = 0;
        }
        else
        {
          if (v47[0] >= 1)
          {
            uint64_t v40 = 0;
            do
            {
              int v41 = v45.__begin_[v40];
              int v42 = v44.__begin_[v40];
              double v43 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((float *)(a1 + 224), v46.__begin_[v40], &v46.__begin_[v40]);
              *((_DWORD *)v43 + 5) = v41;
              *((_DWORD *)v43 + 6) = v42;
              ++v40;
            }
            while (v40 < v47[0]);
          }
          char v39 = 1;
        }
        if (v44.__begin_)
        {
          v44.__end_ = v44.__begin_;
          operator delete(v44.__begin_);
        }
        if (v45.__begin_)
        {
          v45.__end_ = v45.__begin_;
          operator delete(v45.__begin_);
        }
        if (v46.__begin_)
        {
          v46.__end_ = v46.__begin_;
          operator delete(v46.__begin_);
        }
        if ((v39 & 1) == 0)
        {
LABEL_60:
          uint64_t v19 = 7797;
        }
        else
        {
LABEL_73:
          vision::mod::FeatureSignSparseCoder<double,16ul>::initialize(a1 + 264, (void *)(a1 + 88));
          uint64_t v19 = 7808;
        }
LABEL_61:
        if (*(void *)&v47[1])
        {
          *(void *)&v47[3] = *(void *)&v47[1];
          operator delete(*(void **)&v47[1]);
        }
        if (v48.__begin_)
        {
          v48.__end_ = v48.__begin_;
          operator delete(v48.__begin_);
        }
        if (v49.__begin_)
        {
          v49.__end_ = v49.__begin_;
          operator delete(v49.__begin_);
        }
        goto LABEL_39;
      }
    }
  }
  uint64_t v19 = 7797;
LABEL_39:
  if (*(void *)&v50[1])
  {
    *(void *)&v50[3] = *(void *)&v50[1];
    operator delete(*(void **)&v50[1]);
  }
  if (__p)
  {
    uint64_t v52 = __p;
    operator delete(__p);
  }
  return v19;
}

void sub_1A3F7CE28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  if (a20) {
    operator delete(a20);
  }
  if (a23) {
    operator delete(a23);
  }
  if (a26) {
    operator delete(a26);
  }
  if (a30) {
    operator delete(a30);
  }
  if (a33) {
    operator delete(a33);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::_deserialize()
{
  uint64_t v0 = (void *)std::istream::read();
  if ((*((unsigned char *)v0 + *(void *)(*v0 - 24) + 32) & 5) != 0
    || (uint64_t v1 = (void *)std::istream::read(), (*((unsigned char *)v1 + *(void *)(*v1 - 24) + 32) & 5) != 0))
  {
    uint64_t v2 = -11;
  }
  else
  {
    BOOL v4 = (void *)std::istream::read();
    int v5 = &CVML_status_IOError;
    if ((*((unsigned char *)v4 + *(void *)(*v4 - 24) + 32) & 5) == 0) {
      int v5 = &CVML_status_ok;
    }
    uint64_t v2 = *v5;
  }
  return (v2 + 128) | 0x1E00;
}

uint64_t vision::mod::FaceIDModel::getIdentityTrainingData(void *a1, int a2, vision::mod::ImageDescriptorBufferAbstract **a3)
{
  unint64_t v3 = a1[29];
  if (!v3) {
    goto LABEL_17;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = a2;
    if (v3 <= a2) {
      unint64_t v7 = a2 % v3;
    }
  }
  else
  {
    unint64_t v7 = (v3 - 1) & a2;
  }
  uint64_t v8 = *(uint64_t ***)(a1[28] + 8 * v7);
  if (!v8 || (int v9 = *v8) == 0)
  {
LABEL_17:
    uint64_t v11 = -4;
    return (v11 + 128) | 0x1E00;
  }
  while (1)
  {
    unint64_t v10 = v9[1];
    if (v10 == a2) {
      break;
    }
    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= v3) {
        v10 %= v3;
      }
    }
    else
    {
      v10 &= v3 - 1;
    }
    if (v10 != v7) {
      goto LABEL_17;
    }
LABEL_16:
    int v9 = (uint64_t *)*v9;
    if (!v9) {
      goto LABEL_17;
    }
  }
  if (*((_DWORD *)v9 + 4) != a2) {
    goto LABEL_16;
  }
  size_t v13 = *((unsigned int *)v9 + 6);
  if ((int)v13 >= 1 && (uint64_t v14 = a1[20]) != 0)
  {
    uint64_t v15 = *((int *)v9 + 5);
    std::vector<long long>::vector(__p, *((unsigned int *)v9 + 6));
    float v16 = malloc_type_calloc(v13, 4 * v14, 0xF783D623uLL);
    if (v16)
    {
      uint64_t v17 = (std::__shared_weak_count *)operator new(0x90uLL);
      v17->__shared_owners_ = 0;
      v17->__shared_weak_owners_ = 0;
      v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7539A0;
      unint64_t v18 = (vision::mod::ImageDescriptorBufferAbstract *)&v17[1];
      vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)&v17[1], (void **)__p, v16, 4 * v14, (int)v13, 1);
      uint64_t v19 = 0;
      uint64_t v20 = a1 + 17;
      v17[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF752918;
      LODWORD(v17[5].__shared_owners_) = 1;
      v17[5].__shared_weak_owners_ = 0;
      v17[5].__vftable = (std::__shared_weak_count_vtbl *)(v14 & 0x3FFFFFFFFFFFFFFFLL);
      std::vector<int>::pointer v28 = v17;
      uint64_t shared_owners = v17[3].__shared_owners_;
      do
      {
        uint64_t v22 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v20, v19 + v15);
        uint64_t v23 = (float *)(shared_owners + 4 * v14 * v19);
        uint64_t v24 = 8 * v14;
        do
        {
          double v25 = *v22++;
          float v26 = v25;
          *v23++ = v26;
          v24 -= 8;
        }
        while (v24);
        vision::mod::ImageDescriptorBufferAbstract::setDescriptorIdForKthDescriptor(v18, v19, v19 + v15);
        ++v19;
      }
      while (v19 != (int)v13);
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      std::vector<int>::pointer v27 = (std::__shared_weak_count *)a3[1];
      *a3 = v18;
      a3[1] = (vision::mod::ImageDescriptorBufferAbstract *)v28;
      if (v27) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v27);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v28);
      uint64_t v11 = 0;
    }
    else
    {
      syslog(5, "ERROR: Failed to allocate descriptor data of count %d, stride %d", v13, 4 * v14);
      uint64_t v11 = -5;
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v11 = -24;
  }
  return (v11 + 128) | 0x1E00;
}

void sub_1A3F7D358(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  std::__shared_weak_count::~__shared_weak_count(v13);
  operator delete(v15);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A3F7E0B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _getModelDropForConfigurationOptions(void *a1, _DWORD *a2, void *a3)
{
  id v5 = a1;
  uint8x8_t v6 = +[VNValidationUtilities originatingRequestSpecifierInOptions:v5 specifyingRequestClass:objc_opt_class() error:a3];
  unint64_t v7 = v6;
  if (!v6) {
    goto LABEL_6;
  }
  if ([v6 requestRevision] != 3)
  {
    if (a3)
    {
      +[VNError errorForUnsupportedRequestSpecifier:v7];
      uint64_t v8 = 0;
      *a3 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_7;
    }
LABEL_6:
    uint64_t v8 = 0;
    goto LABEL_7;
  }
  uint64_t v8 = 1;
  *a2 = 1;
LABEL_7:

  return v8;
}

void sub_1A3F7E18C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F7E3E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F7E590(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F7EDC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, void *a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26,void *a27,void *a28,void *a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a67, 8);
  if (STACK[0x200]) {
    operator delete((void *)STACK[0x200]);
  }

  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__19261(void *result, void *a2)
{
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  result[8] = a2[8];
  a2[6] = 0;
  a2[7] = 0;
  a2[8] = 0;
  return result;
}

void __Block_byref_object_dispose__19262(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 48);
  if (v1) {
    operator delete(v1);
  }
}

void sub_1A3F7F1F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F7F828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *exc_buf, void *a13)
{
  if (a2)
  {

    objc_begin_catch(a1);
    JUMPOUT(0x1A3F7F7A8);
  }
  _Unwind_Resume(a1);
}

void sub_1A3F7FA9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F80010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void *___ZL46getVCPRequestMaxNumOfHandsPropertyKeySymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)VideoProcessingLibrary();
  uint64_t result = dlsym(v2, "VCPRequestMaxNumOfHandsPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestMaxNumOfHandsPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL26VideoProcessingLibraryCorePPc_block_invoke_19344()
{
  uint64_t result = _sl_dlopen();
  VideoProcessingLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void sub_1A3F8041C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void *___ZL41getVCPRequestRevisionPropertyKeySymbolLocv_block_invoke_19350(uint64_t a1)
{
  uint64_t v2 = (void *)VideoProcessingLibrary();
  uint64_t result = dlsym(v2, "VCPRequestRevisionPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestRevisionPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1A3F80654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

Class ___ZL31getVCPHandPoseImageRequestClassv_block_invoke(uint64_t a1)
{
  VideoProcessingLibrary();
  Class result = objc_getClass("VCPHandPoseImageRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getVCPHandPoseImageRequestClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    unint64_t v3 = (void *)abort_report_np();
    return +[VNHumanHandPoseDetector recognizedPointsObservationClass];
  }
  return result;
}

void sub_1A3F80794(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F808DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F809C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F80A4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F80AE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F80B80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F80C20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F80C6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F80F0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ColorGaborImageDescriptorBuffer::getDescriptorLengthInBytes(vision::mod::ColorGaborImageDescriptorBuffer *this)
{
  return 136;
}

void vision::mod::ColorGaborImageDescriptorBuffer::computeSelfDistances(vision::mod::ColorGaborImageDescriptorBuffer *this)
{
  exceptiouint64_t n = __cxa_allocate_exception(8uLL);
  *exceptiouint64_t n = 3711;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

float *vision::mod::ColorGaborImageDescriptorBuffer::computeDistancesFrom@<X0>(vision::mod::ColorGaborImageDescriptorBuffer *this@<X0>, const vision::mod::ImageDescriptorBufferAbstract *a2@<X1>, float **a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  unint64_t DataForKthDescriptor = vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, 0);
  unint64_t v6 = vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, 0);
  uint64_t v7 = 0;
  float v8 = 0.0;
  do
  {
    uint16x8_t v9 = *(uint16x8_t *)(DataForKthDescriptor + v7);
    float32x4_t v10 = vcvtq_f32_u32(vmovl_high_u16(v9));
    uint16x8_t v11 = *(uint16x8_t *)(v6 + v7);
    float32x4_t v12 = vsubq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v9.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v11.i8)));
    float32x4_t v13 = vsubq_f32(v10, vcvtq_f32_u32(vmovl_high_u16(v11)));
    float32x4_t v14 = vmulq_f32(v13, v13);
    HIWORD(v15) = v14.i16[3];
    float32x4_t v16 = vmulq_f32(v12, v12);
    HIWORD(v17) = v16.i16[7];
    float v8 = (float)((float)((float)((float)((float)((float)((float)(v8 + v16.f32[0]) + v16.f32[1]) + v16.f32[2])
                                       + v16.f32[3])
                               + v14.f32[0])
                       + v14.f32[1])
               + v14.f32[2])
       + v14.f32[3];
    v7 += 16;
  }
  while (v7 != 64);
  uint64_t v18 = 0;
  float v19 = 0.0;
  float v20 = 0.0;
  float v21 = 0.0;
  do
  {
    LOWORD(v15) = *(_WORD *)(DataForKthDescriptor + 64 + 2 * v18);
    LOWORD(v17) = *(_WORD *)(v6 + 64 + 2 * v18);
    float v22 = (float)LODWORD(v15);
    float v17 = (float)LODWORD(v17);
    if (v18 >= 8) {
      float v23 = -0.0;
    }
    else {
      float v23 = v22;
    }
    float v21 = v21 + v23;
    if (v18 >= 8) {
      float v24 = -0.0;
    }
    else {
      float v24 = v17;
    }
    float v20 = v20 + v24;
    float v15 = sqrtf(v22 * v17);
    float v19 = v19 + v15;
    ++v18;
  }
  while (v18 != 36);
  float v25 = v21 / 65535.0;
  float v26 = sqrtf(v8) / 65535.0;
  if ((float)(v21 / 65535.0) > 0.97 || (float)(v20 / 65535.0) > 0.97)
  {
    float v48 = v26 + v26;
    goto LABEL_40;
  }
  uint64_t v27 = 0;
  float v28 = 1.0 - (float)(v19 / 65535.0);
  float v29 = 0.0;
  float v30 = 0.0;
  do
  {
    LOWORD(v25) = *(_WORD *)(DataForKthDescriptor + 64 + v27);
    LOWORD(v17) = *(_WORD *)(v6 + 64 + v27);
    float v17 = (float)LODWORD(v17) / 65535.0;
    float v31 = v29 + (float)((float)LODWORD(v25) / 65535.0);
    float v29 = v31 - v17;
    float v25 = vabds_f32(v31, v17);
    float v30 = v30 + v25;
    v27 += 2;
  }
  while (v27 != 72);
  int v32 = (uint16x4_t *)(v6 + 64);
  int v33 = (uint16x4_t *)(DataForKthDescriptor + 64);
  float v34 = 1.0;
  int v35 = 1;
  unint64_t v36 = 28;
  int v37 = 1;
  float v38 = 1.0;
  float v39 = 0.0;
  do
  {
    uint16x4_t v40 = *v33++;
    float32x4_t v41 = vcvtq_f32_u32(vmovl_u16(v40));
    uint16x4_t v42 = *v32++;
    float32x4_t v43 = vcvtq_f32_u32(vmovl_u16(v42));
    v43.f32[0] = (float)((float)(v43.f32[0] + 0.0) + v43.f32[1]) + v43.f32[2];
    float v44 = v43.f32[0] + v43.f32[3];
    float v45 = (float)((float)((float)(v41.f32[0] + 0.0) + v41.f32[1]) + v41.f32[2]) + v41.f32[3];
    BOOL v46 = v38 < v45;
    if (v38 < v45) {
      float v38 = v45;
    }
    v36 += 4;
    if (v46) {
      int v37 = v36;
    }
    if (v34 < v44)
    {
      float v34 = v43.f32[0] + v43.f32[3];
      int v35 = v36;
    }
    float v39 = v39 + sqrtf(v45 * v44);
  }
  while (v36 < 0x40);
  float v47 = (float)(v39 / -65535.0) + 1.0;
  if (v37 == v35)
  {
    if (v37 == 32)
    {
      float v47 = v28;
      goto LABEL_32;
    }
    if ((float)(v28 / v47) > 3.0)
    {
      float v47 = (float)(v47 * 0.75) + v28 * 0.25;
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  if (v30 >= 2.5) {
LABEL_31:
  }
    float v47 = (float)(v28 + v47) * 0.5;
LABEL_32:
  if (v26 >= v47) {
    float v49 = v47;
  }
  else {
    float v49 = v26;
  }
  BOOL v50 = v47 < 0.05 || v26 < 0.05;
  float v51 = v49 + v49;
  float v48 = v26 + v47;
  if (v50) {
    float v48 = v51;
  }
LABEL_40:
  float v52 = v48 * 1.4;
  if ((float)(v48 * 1.4) > 0.6) {
    float v52 = 1.0 - expf(-(float)((float)(v52 + 0.3572) * (float)(v52 + 0.3572)));
  }
  uint64_t v53 = (float *)operator new(4uLL);
  *a3 = v53;
  *uint64_t v53 = v52;
  Class result = v53 + 1;
  a3[1] = result;
  a3[2] = result;
  return result;
}

void vision::mod::ColorGaborImageDescriptorBuffer::~ColorGaborImageDescriptorBuffer(void **this)
{
  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(this);

  JUMPOUT(0x1A62562C0);
}

float vision::mod::ImageDescriptorProcessorAbstract::getRequiredImageSize(vision::mod::ImageDescriptorProcessorAbstract *this)
{
  return NAN;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::getRequiredImageChannelDepth(vision::mod::ImageDescriptorProcessorAbstract *this)
{
  return 0;
}

uint64_t vision::mod::ColorGaborImageDescriptorProcessor::getDescriptorLengthInBytes(vision::mod::ColorGaborImageDescriptorProcessor *this)
{
  return 136;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::setPriority(vision::mod::ImageDescriptorProcessorAbstract *this)
{
  return 3711;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::wipeLayersMemory(vision::mod::ImageDescriptorProcessorAbstract *this)
{
  return 3711;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorsForImages_Planar8(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 == v5) {
    return 3712;
  }
  while (!a3 || ((*(uint64_t (**)(uint64_t))(a3 + 16))(a3) & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 64))(&v11, a1);
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 32))(a1, v4, v11);
    if ((v9 & 0x80) != 0) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a4 + 40))(a4, v11);
    }
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    }
    if ((v9 & 0x80) != 0)
    {
      v4 += 32;
      if (v4 != v5) {
        continue;
      }
    }
    return v9;
  }
  return 3683;
}

void sub_1A3F81480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorsForImages_BGRA8888(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 == v5) {
    return 3712;
  }
  while (!a3 || ((*(uint64_t (**)(uint64_t))(a3 + 16))(a3) & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 64))(&v11, a1);
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, v4, v11);
    if ((v9 & 0x80) != 0) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a4 + 40))(a4, v11);
    }
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    }
    if ((v9 & 0x80) != 0)
    {
      v4 += 32;
      if (v4 != v5) {
        continue;
      }
    }
    return v9;
  }
  return 3683;
}

void sub_1A3F815C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorsForImages_RGBA8888(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 == v5) {
    return 3712;
  }
  while (!a3 || ((*(uint64_t (**)(uint64_t))(a3 + 16))(a3) & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 64))(&v11, a1);
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 16))(a1, v4, v11);
    if ((v9 & 0x80) != 0) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a4 + 40))(a4, v11);
    }
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    }
    if ((v9 & 0x80) != 0)
    {
      v4 += 32;
      if (v4 != v5) {
        continue;
      }
    }
    return v9;
  }
  return 3683;
}

void sub_1A3F81708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

double vision::mod::ColorGaborImageDescriptorProcessor::createDescriptorBuffer@<D0>(void *a1@<X8>)
{
  unint64_t v3 = operator new(0x78uLL);
  v3[1] = 0;
  v3[2] = 0;
  *unint64_t v3 = &unk_1EF753A80;
  v3[4] = 0;
  void v3[5] = 0;
  v3[8] = 0;
  v3[9] = 0;
  void v3[6] = 0;
  v3[7] = v3 + 8;
  double result = 0.0;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((unsigned char *)v3 + 112) = 0;
  v3[3] = &unk_1EF752BF8;
  *a1 = v3 + 3;
  a1[1] = v3;
  return result;
}

uint64_t std::__shared_ptr_emplace<vision::mod::ColorGaborImageDescriptorBuffer>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::ColorGaborImageDescriptorBuffer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753A80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ColorGaborImageDescriptorBuffer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753A80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t vision::mod::ColorGaborImageDescriptorProcessor::computeDescriptorForImage(vision::mod::ColorGaborImageDescriptorProcessor *this, __CVBuffer *a2, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  uint64_t v274 = *MEMORY[0x1E4F143B8];
  vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(a3, 1uLL, 0);
  unint64_t v6 = (void *)*((void *)a3 + 7);
  int v257 = 0;
  unint64_t v258 = 0;
  uint64_t v259 = 0;
  uint64_t v7 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
  float v8 = operator new[](0x88uLL, MEMORY[0x1E4FBA2D0]);
  uint64_t v9 = (char *)operator new(0xD8uLL, v7);
  if (v9)
  {
    float32x4_t v10 = (DSPSplitComplex *)v9;
    *((_OWORD *)v9 + 3) = 0u;
    *((_OWORD *)v9 + 6) = 0u;
    uint64_t v11 = (char **)(v9 + 96);
    *((void *)v9 + 17) = 0;
    float32x4_t v12 = v9 + 136;
    *(_OWORD *)uint64_t v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    *((_OWORD *)v9 + 4) = 0u;
    *((void *)v9 + 10) = 0;
    *((_OWORD *)v9 + 7) = 0u;
    *((void *)v9 + 18) = 0;
    *((void *)v9 + 19) = 0;
    *((_DWORD *)v9 + 22) = -1;
    *((void *)v9 + 16) = 0;
    *((void *)v9 + 4) = 0;
    *((_DWORD *)v9 + 10) = 0;
    *((_WORD *)v9 + 80) = 0;
    *(_OWORD *)(v9 + 200) = 0u;
    *(_OWORD *)(v9 + 184) = 0u;
    *(_OWORD *)(v9 + 168) = 0u;
    if (!v8)
    {
      OSStatus v123 = -108;
      goto LABEL_248;
    }
    uint64_t __C = (DSPSplitComplex *)(v9 + 48);
    uint64_t v244 = v6;
    uint64_t v245 = this;
    v9[161] = 1;
    uint64_t v248 = v8;
    __A = (DSPSplitComplex *)v9;
    ma::GaborFilters::Destroy((ma::GaborFilters *)v9);
    LOBYTE(__A[10].realp) = 1;
    v13.realp = (float *)0x8000000080;
    v13.imagp = (float *)0x8000000080;
    __A[1] = v13;
    LODWORD(__A[2].imagp) = 7;
    __A[2].realp = (float *)0x700000007;
    LODWORD(__A[5].imagp) = 0x4000;
    float32x4_t v14 = MEMORY[0x1E4F14430];
    float v15 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E4F14430], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    __A[10].imagp = (float *)dispatch_queue_create("com.apple.VN.createGaborFilterBankGCDQueueName", v15);
    float32x4_t v16 = dispatch_queue_attr_make_with_autorelease_frequency(v14, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    __A[11].realp = (float *)dispatch_queue_create("com.apple.VN.extractGaborDescriptorGCDQueueName", v16);
    float v17 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    __A[11].imagp = (float *)dispatch_queue_create("com.apple.VN.gaborReadySyncQueueName", v17);
    uint64_t v18 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    __A[12].realp = (float *)dispatch_queue_create("com.apple.VN.gaborDescriptorReadySyncQueueName", v18);
    float v19 = __A;
    __A[5].realp = (float *)vDSP_create_fftsetup(SLODWORD(__A[2].realp), 0);
    imagp = __A[3].imagp;
    if (!imagp)
    {
      uint64_t imagp_low = SLODWORD(__A[5].imagp);
      if ((int)imagp_low < 0) {
        size_t v22 = -1;
      }
      else {
        size_t v22 = 4 * imagp_low;
      }
      imagp = (float *)operator new[](v22, MEMORY[0x1E4FBA2D0]);
      __A[3].imagp = imagp;
    }
    char v252 = imagp;
    realp = __A[4].realp;
    int32x2_t v242 = __A + 4;
    if (!realp)
    {
      uint64_t v24 = SLODWORD(__A[5].imagp);
      if ((int)v24 < 0) {
        size_t v25 = -1;
      }
      else {
        size_t v25 = 4 * v24;
      }
      realp = (float *)operator new[](v25, MEMORY[0x1E4FBA2D0]);
      __A[4].realp = realp;
    }
    long long v250 = realp;
    float v26 = __A[4].imagp;
    if (!v26)
    {
      uint64_t v27 = SLODWORD(__A[5].imagp);
      if ((int)v27 < 0) {
        size_t v28 = -1;
      }
      else {
        size_t v28 = 4 * v27;
      }
      float v26 = (float *)operator new[](v28, MEMORY[0x1E4FBA2D0]);
      __A[4].imagp = v26;
    }
    float v29 = __A[6].imagp;
    if (!v29)
    {
      uint64_t v30 = SLODWORD(__A[5].imagp);
      if ((int)v30 < 0) {
        size_t v31 = -1;
      }
      else {
        size_t v31 = 4 * v30;
      }
      float v29 = (float *)operator new[](v31, MEMORY[0x1E4FBA2D0]);
      __A[6].imagp = v29;
    }
    unint64_t v247 = v29;
    int v32 = __A[7].imagp;
    if (!v32)
    {
      uint64_t v33 = SLODWORD(__A[5].imagp);
      if ((int)v33 < 0) {
        size_t v34 = -1;
      }
      else {
        size_t v34 = 4 * v33;
      }
      int v32 = (float *)operator new[](v34, MEMORY[0x1E4FBA2D0]);
      __A[7].imagp = v32;
    }
    pixelBuffer = a2;
    int v35 = __A[7].realp;
    if (!v35)
    {
      uint64_t v36 = SLODWORD(__A[5].imagp);
      if ((int)v36 < 0) {
        size_t v37 = -1;
      }
      else {
        size_t v37 = 4 * v36;
      }
      int v35 = (float *)operator new[](v37, MEMORY[0x1E4FBA2D0]);
      __A[7].realp = v35;
    }
    float v38 = __A->realp;
    if (!__A->realp)
    {
      uint64_t v39 = SLODWORD(__A[5].imagp);
      if ((int)v39 < 0) {
        size_t v40 = -1;
      }
      else {
        size_t v40 = 4 * v39;
      }
      float v38 = (float *)operator new[](v40, MEMORY[0x1E4FBA2D0]);
      __A->realp = v38;
    }
    float32x4_t v41 = __A->imagp;
    if (!v41)
    {
      uint64_t v42 = SLODWORD(__A[5].imagp);
      if ((int)v42 < 0) {
        size_t v43 = -1;
      }
      else {
        size_t v43 = 4 * v42;
      }
      float32x4_t v41 = (float *)operator new[](v43, MEMORY[0x1E4FBA2D0]);
      __A->imagp = v41;
    }
    __A[8].realp = (float *)0x800000004;
    float v44 = __A[8].imagp;
    if (!v44)
    {
      float v44 = operator new[](0x80uLL, MEMORY[0x1E4FBA2D0]);
      *float32x4_t v12 = v44;
    }
    float v45 = __A[9].realp;
    if (!v45)
    {
      float v45 = (float *)operator new[](0x40uLL, MEMORY[0x1E4FBA2D0]);
      __A[9].realp = v45;
    }
    BOOL v46 = *v11;
    if (!*v11)
    {
      BOOL v46 = (char *)operator new[](0x200uLL, MEMORY[0x1E4FBA2D0]);
      *uint64_t v11 = v46;
    }
    float v47 = __A[9].imagp;
    if (!v47)
    {
      uint64_t v48 = SLODWORD(__A[5].imagp);
      if ((int)v48 < 0) {
        size_t v49 = -1;
      }
      else {
        size_t v49 = v48 << 7;
      }
      float v47 = (float *)operator new[](v49, MEMORY[0x1E4FBA2D0]);
      __A[9].imagp = v47;
    }
    if (!v252 || !v250 || !v26 || !v32 || !v35 || !v38 || !v41 || !v44 || !v45 || !v247 || !v46 || !v47)
    {
      ma::GaborFilters::Destroy((ma::GaborFilters *)__A);
      int v118 = v248;
      float32x4_t v10 = __A;
      LOBYTE(__A[10].realp) = 0;
      goto LABEL_104;
    }
    int v50 = 0;
    int v51 = 0;
    int32x4_t v52 = vdupq_n_s32(0x3EB33333u);
    __asm { FMOV            V2.4S, #1.0 }
    long long v57 = xmmword_1A410C270;
    long long v58 = xmmword_1A410C280;
    do
    {
      long long v251 = v58;
      int32x4_t v253 = v52;
      long long v255 = _Q2;
      long long v256 = v57;
      *(float *)v59.i32 = 0.2 / powf(1.85, (float)v50);
      int32x4_t v254 = vdupq_lane_s32(v59, 0);
      long long v58 = v251;
      int32x4_t v52 = v253;
      int32x4_t v60 = v254;
      _Q2 = v255;
      long long v57 = v256;
      uint64_t v61 = (float *)&v46[4 * v51];
      int32x4_t v62 = v253;
      int32x4_t v63 = v254;
      long long v64 = v255;
      vst4q_f32(v61, *(float32x4x4_t *)(&v58 - 3));
      unint64_t v65 = (float *)&v46[4 * v51 + 64];
      vst4q_f32(v65, *(float32x4x4_t *)v52.i8);
      v51 += 32;
      ++v50;
    }
    while (v50 != 4);
    bzero(v41, 4 * SLODWORD(__A[5].imagp));
    LOBYTE(__A[10].realp) = 1;
    int v67 = (int)__A[1].imagp;
    int imagp_high = HIDWORD(__A[1].imagp);
    if (v67 >= 0) {
      int v68 = (int)__A[1].imagp;
    }
    else {
      int v68 = v67 + 1;
    }
    if (imagp_high >= 0) {
      int v69 = HIDWORD(__A[1].imagp);
    }
    else {
      int v69 = imagp_high + 1;
    }
    if (imagp_high >= 2)
    {
      int v70 = 0;
      uint64_t v71 = (v68 >> 1);
      uint64_t v72 = (v69 >> 1);
      int v73 = -(v69 >> 1);
      int v74 = v73;
      do
      {
        if (v67 >= 2)
        {
          uint64_t v75 = v70;
          int v76 = -(int)v71;
          uint64_t v79 = v19 + 7;
          uint64_t v77 = v19[7].realp;
          uint64_t v78 = v79->imagp;
          do
          {
            v78[v75] = sqrtf((float)(v74 * v74 + v76 * v76));
            v77[v75++] = atan2f((float)v74, (float)v76++);
          }
          while (v76 < (int)v71);
          int v70 = v75;
          float v19 = __A;
        }
        ++v74;
      }
      while (v74 < (int)v72);
      uint64_t v80 = 0;
      uint64_t v81 = 0;
      uint64_t v82 = 4 * v67 * (uint64_t)(int)v72;
      uint64_t v83 = 4 * v67;
      uint64_t v84 = 4 * ((int)v71 + v67 * (uint64_t)(int)v72);
      uint64_t v85 = 4 * (int)v71;
      do
      {
        if (v67 >= 2)
        {
          uint64_t v86 = 0;
          uint64_t v87 = v19[7].realp;
          int v88 = v19[7].imagp;
          uint64_t v89 = (uint64_t)v87 + v82;
          uint64_t v90 = (uint64_t)v88 + v82;
          uint64_t v91 = (uint64_t)v87 + v84;
          uint64_t v92 = (uint64_t)v88 + v84;
          uint64_t v93 = (uint64_t)v87 + v80;
          uint64_t v94 = (uint64_t)v87 + v85;
          uint64_t v95 = (uint64_t)v88 + v85;
          uint64_t v96 = (uint64_t)v88 + v80;
          do
          {
            int v97 = *(_DWORD *)(v96 + 4 * v86);
            *(_DWORD *)(v96 + 4 * v86) = *(_DWORD *)(v92 + 4 * v86);
            *(_DWORD *)(v92 + 4 * v86) = v97;
            int v98 = *(_DWORD *)(v90 + 4 * v86);
            *(_DWORD *)(v90 + 4 * v86) = *(_DWORD *)(v95 + 4 * v86);
            *(_DWORD *)(v95 + 4 * v86) = v98;
            int v99 = *(_DWORD *)(v93 + 4 * v86);
            *(_DWORD *)(v93 + 4 * v86) = *(_DWORD *)(v91 + 4 * v86);
            *(_DWORD *)(v91 + 4 * v86) = v99;
            int v100 = *(_DWORD *)(v89 + 4 * v86);
            *(_DWORD *)(v89 + 4 * v86) = *(_DWORD *)(v94 + 4 * v86);
            *(_DWORD *)(v94 + 4 * v86++) = v100;
          }
          while (v71 != v86);
        }
        ++v81;
        v82 += v83;
        v84 += v83;
        v80 += v83;
        v85 += v83;
      }
      while (v81 != v72);
      int v101 = 0;
      do
      {
        if (v67 >= 2)
        {
          uint64_t v102 = v19->realp;
          uint64_t v103 = v101;
          int v104 = -(int)v71;
          do
          {
            v102[v103++] = expf((float)(v73 * v73 + v104 * v104) * -0.043322);
            ++v104;
          }
          while (v104 < (int)v71);
          int v101 = v103;
          float v19 = __A;
        }
        ++v73;
      }
      while (v73 < (int)v72);
      uint64_t v105 = 0;
      uint64_t v106 = 0;
      uint64_t v107 = v67 * (uint64_t)(int)v72;
      uint64_t v108 = (int)v71 + v107;
      do
      {
        if (v67 >= 2)
        {
          double v109 = (int *)((char *)v19->realp + v105);
          uint64_t v110 = v71;
          do
          {
            int v111 = *v109;
            int *v109 = v109[v108];
            v109[v108] = v111;
            int v112 = v109[v107];
            v109[v107] = v109[(int)v71];
            v109[(int)v71] = v112;
            ++v109;
            --v110;
          }
          while (v110);
        }
        ++v106;
        v105 += v83;
      }
      while (v106 != v72);
    }
    uint64_t v113 = dispatch_group_create();
    context = v19;
    int v263 = v67;
    int v264 = 0;
    char v265 = v19;
    int v266 = v67;
    int v267 = 1;
    unint64_t v268 = v19;
    int v269 = v67;
    int v270 = 2;
    int8x8_t v271 = v19;
    int v272 = v67;
    int v273 = 3;
    dispatch_group_async_f(v113, (dispatch_queue_t)v19[10].imagp, &context, (dispatch_function_t)ma::GaborFilters::DispatchHelperCreateGabor);
    dispatch_group_async_f(v113, (dispatch_queue_t)v19[10].imagp, &v265, (dispatch_function_t)ma::GaborFilters::DispatchHelperCreateGabor);
    dispatch_group_async_f(v113, (dispatch_queue_t)v19[10].imagp, &v268, (dispatch_function_t)ma::GaborFilters::DispatchHelperCreateGabor);
    dispatch_group_async_f(v113, (dispatch_queue_t)v19[10].imagp, &v271, (dispatch_function_t)ma::GaborFilters::DispatchHelperCreateGabor);
    dispatch_group_wait(v113, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v113);
    VTPixelTransferSessionRef pixelTransferSessionOut = 0;
    CVPixelBufferRef pixelBufferOut = 0;
    size_t Width = CVPixelBufferGetWidth(pixelBuffer);
    size_t Height = CVPixelBufferGetHeight(pixelBuffer);
    float v116 = (float)Width;
    float v117 = (float)Height;
    if (fminf((float)Width, (float)Height) < 16.0)
    {
      int v118 = v248;
      float32x4_t v10 = __A;
      uint64_t v119 = __A[9].realp;
      *((_OWORD *)v119 + 2) = 0u;
      *((_OWORD *)v119 + 3) = 0u;
      *(_OWORD *)uint64_t v119 = 0u;
      *((_OWORD *)v119 + 1) = 0u;
      uint64_t v121 = v244;
      double v120 = v245;
LABEL_150:
      if (!BYTE1(v10[10].realp))
      {
        OSStatus v123 = -50;
        goto LABEL_247;
      }
      int v173 = v10[9].realp;
      long long v174 = *((_OWORD *)v173 + 3);
      long long v176 = *(_OWORD *)v173;
      long long v175 = *((_OWORD *)v173 + 1);
      v118[2] = *((_OWORD *)v173 + 2);
      v118[3] = v174;
      *int v118 = v176;
      v118[1] = v175;
      if (v257)
      {
LABEL_152:
        VTPixelTransferSessionRef pixelTransferSessionOut = 0;
        context = 0;
        OSStatus v123 = VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)&context);
        if (!v123)
        {
          size_t v178 = CVPixelBufferGetWidth(pixelBuffer);
          size_t v179 = CVPixelBufferGetHeight(pixelBuffer);
          OSStatus v123 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v178, v179, 0x20u, 0, &pixelTransferSessionOut);
          int v180 = pixelTransferSessionOut;
          if (!v123)
          {
            OSStatus v123 = VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)context, pixelBuffer, pixelTransferSessionOut);
            int v180 = pixelTransferSessionOut;
            if (!v123)
            {
              if (CVPixelBufferGetPixelFormatType(pixelTransferSessionOut) == 32
                && (std::vector<int>::pointer v181 = v257) != 0
                && (uint64_t v182 = v258) != 0
                && (uint64_t v183 = v259) != 0)
              {
                *((_OWORD *)v257 + 7) = 0u;
                *((_OWORD *)v181 + 8) = 0u;
                *((_OWORD *)v181 + 5) = 0u;
                *((_OWORD *)v181 + 6) = 0u;
                *((_OWORD *)v181 + 3) = 0u;
                *((_OWORD *)v181 + 4) = 0u;
                *((_OWORD *)v181 + 1) = 0u;
                *((_OWORD *)v181 + 2) = 0u;
                *(_OWORD *)std::vector<int>::pointer v181 = 0u;
                *((_OWORD *)v182 + 7) = 0u;
                *((_OWORD *)v182 + 8) = 0u;
                *((_OWORD *)v182 + 5) = 0u;
                *((_OWORD *)v182 + 6) = 0u;
                *((_OWORD *)v182 + 3) = 0u;
                *((_OWORD *)v182 + 4) = 0u;
                *((_OWORD *)v182 + 1) = 0u;
                *((_OWORD *)v182 + 2) = 0u;
                *(_OWORD *)uint64_t v182 = 0u;
                *((_OWORD *)v183 + 7) = 0u;
                *((_OWORD *)v183 + 8) = 0u;
                *((_OWORD *)v183 + 5) = 0u;
                *((_OWORD *)v183 + 6) = 0u;
                *((_OWORD *)v183 + 3) = 0u;
                *((_OWORD *)v183 + 4) = 0u;
                *((_OWORD *)v183 + 1) = 0u;
                *((_OWORD *)v183 + 2) = 0u;
                *(_OWORD *)uint64_t v183 = 0u;
                CVPixelBufferLockBaseAddress(v180, 1uLL);
                int v184 = CVPixelBufferGetWidth(v180);
                int v185 = CVPixelBufferGetHeight(v180);
                int BytesPerRow = CVPixelBufferGetBytesPerRow(v180);
                BaseAddress = (char *)CVPixelBufferGetBaseAddress(v180);
                if (v185 >= 0) {
                  int v189 = v185;
                }
                else {
                  int v189 = v185 + 7;
                }
                int v190 = v189 >> 3;
                int v191 = v185 - (v189 >> 3);
                if (v190 >= v191)
                {
                  int v192 = 0;
                }
                else
                {
                  int v192 = 0;
                  uint64_t v193 = BytesPerRow;
                  if (v184 >= 0) {
                    int v194 = v184;
                  }
                  else {
                    int v194 = v184 + 7;
                  }
                  int v195 = v194 >> 3;
                  uint64_t v196 = &BaseAddress[BytesPerRow * (uint64_t)v190];
                  int v197 = v184 - (v194 >> 3);
                  uint64_t v198 = (uint64_t)v194 >> 3;
                  int v199 = v184 - 2 * v195;
                  uint64_t v200 = v257;
                  uint64_t v201 = v258;
                  uint64_t v202 = v259;
                  do
                  {
                    if ((int)v198 < v197)
                    {
                      uint64_t v203 = v198;
                      do
                      {
                        uint64_t v204 = &v196[4 * (int)v203];
                        LOBYTE(v188) = v204[1];
                        float v205 = (float)LODWORD(v188);
                        LOBYTE(v188) = v204[2];
                        float v206 = (float)LODWORD(v188);
                        LOBYTE(v188) = v204[3];
                        float v207 = (float)LODWORD(v188);
                        if (v206 >= v205) {
                          float v208 = v205;
                        }
                        else {
                          float v208 = v206;
                        }
                        if (v208 > v207) {
                          float v208 = v207;
                        }
                        if (v205 >= v206) {
                          float v209 = v205;
                        }
                        else {
                          float v209 = v206;
                        }
                        if (v209 >= v207) {
                          float v210 = v209;
                        }
                        else {
                          float v210 = v207;
                        }
                        float v211 = v210 - v208;
                        if (v211 == 0.0) {
                          float v212 = 0.1;
                        }
                        else {
                          float v212 = v211;
                        }
                        float v213 = 0.0;
                        float v214 = 0.0;
                        float v215 = 0.0;
                        if (v210 > 0.0)
                        {
                          float v214 = v212 / v210;
                          float v216 = (float)((float)(v205 - v206) / v212) + 4.0;
                          if (v210 == v206) {
                            float v216 = (float)((float)(v207 - v205) / v212) + 2.0;
                          }
                          float v217 = (float)(v206 - v207) / v212;
                          if (v210 == v205) {
                            float v218 = v217;
                          }
                          else {
                            float v218 = v216;
                          }
                          float v219 = v218 / 6.0;
                          float v215 = v219 + 1.0;
                          if (v219 >= 0.0) {
                            float v215 = v219;
                          }
                          float v213 = v210;
                        }
                        int v220 = 0;
                        float v221 = v213 / 255.0;
                        if ((float)(v213 / 255.0) >= 0.2 && v214 <= 0.1 && v221 < 0.8) {
                          int v220 = (int)(float)(floorf((float)(v221 + -0.2) * 10.0) + 1.0);
                        }
                        if (v221 >= 0.8 && v214 < 0.1 && v221 <= 1.0) {
                          int v220 = 7;
                        }
                        if (v221 <= 1.0 && v221 >= 0.2 && v214 >= 0.1 && v214 <= 1.0)
                        {
                          float v224 = v215 * 360.0;
                          if (v224 > 22.0)
                          {
                            uint64_t v225 = 0;
                            while (v225 != 6)
                            {
                              uint64_t v226 = v225 + 1;
                              float v227 = (float)ma::HSVHistogram::GenerateHistogramsRgbSpace(__CVBuffer *)::kPivots[++v225];
                              if (v224 <= v227)
                              {
                                if ((unint64_t)(v226 - 1) >= 6) {
                                  LODWORD(v226) = v226 - 7;
                                }
                                goto LABEL_215;
                              }
                            }
                          }
                          LODWORD(v226) = 0;
LABEL_215:
                          if (v221 < 0.7) {
                            int v228 = 8;
                          }
                          else {
                            int v228 = 9;
                          }
                          int v220 = (v228 | (2 * (v214 >= 0.65))) + 4 * v226;
                          float32x4_t v10 = __A;
                        }
                        v200[v220] = v200[v220] + 1.0;
                        v201[v220] = v201[v220] + (float)(int)v203;
                        float v188 = v202[v220] + (float)v190;
                        v202[v220] = v188;
                        ++v203;
                      }
                      while (v203 != v197);
                      v192 += v199;
                    }
                    v196 += v193;
                    ++v190;
                  }
                  while (v190 != v191);
                }
                CVPixelBufferUnlockBaseAddress(v180, 1uLL);
                uint64_t v237 = 0;
                int v238 = v257;
                int v239 = v258;
                double v240 = v259;
                do
                {
                  if (v192 < 1) {
                    float v241 = 0.0;
                  }
                  else {
                    float v241 = v238[v237] / (float)v192;
                  }
                  v238[v237] = v241;
                  if (v192 * v184 < 1)
                  {
                    v239[v237] = 0.0;
                    v240[v237] = 0.0;
                  }
                  else
                  {
                    v239[v237] = v239[v237] / (float)((float)v184 * (float)v192);
                    v240[v237] = v240[v237] / (float)((float)v185 * (float)v192);
                  }
                  ++v237;
                }
                while (v237 != 36);
                OSStatus v123 = 0;
              }
              else
              {
                OSStatus v123 = -50;
              }
              int v180 = pixelTransferSessionOut;
            }
          }
          if (v180)
          {
            CFRelease(v180);
            VTPixelTransferSessionRef pixelTransferSessionOut = 0;
          }
        }
        if (context) {
          CFRelease(context);
        }
        if (!v123)
        {
          uint64_t v232 = 0;
          uint64_t v233 = v257;
          v177.n128_u32[0] = 1199570688;
          do
          {
            *((_WORD *)v118 + v232 + 32) = (int)(float)(v233[v232] * 65535.0);
            ++v232;
          }
          while (v232 != 36);
          size_t v234 = (*(uint64_t (**)(vision::mod::ColorGaborImageDescriptorProcessor *, __n128))(*(void *)v120 + 128))(v120, v177);
          memcpy(v121, v118, v234);
          OSStatus v123 = 0;
        }
        goto LABEL_247;
      }
      uint64_t v229 = (float *)operator new[](0x90uLL, MEMORY[0x1E4FBA2D0]);
      int v257 = v229;
      int v230 = v258;
      if (!v258)
      {
        int v230 = (float *)operator new[](0x90uLL, MEMORY[0x1E4FBA2D0]);
        unint64_t v258 = v230;
      }
      uint64_t v231 = v259;
      if (!v259)
      {
        uint64_t v231 = (float *)operator new[](0x90uLL, MEMORY[0x1E4FBA2D0]);
        uint64_t v259 = v231;
      }
      if (v229)
      {
        if (v230 && v231) {
          goto LABEL_152;
        }
        MEMORY[0x1A62562A0](v229, 0x1000C8052888210);
        int v230 = v258;
      }
      int v257 = 0;
      if (v230) {
        MEMORY[0x1A62562A0](v230, 0x1000C8052888210);
      }
      unint64_t v258 = 0;
      if (v259) {
        MEMORY[0x1A62562A0](v259, 0x1000C8052888210);
      }
      uint64_t v259 = 0;
LABEL_104:
      OSStatus v123 = -108;
LABEL_247:
      MEMORY[0x1A62562A0](v118, 0x1000C80BDFB0063);
LABEL_248:
      ma::GaborFilters::Destroy((ma::GaborFilters *)v10);
      MEMORY[0x1A62562C0](v10, 0x10B0C406B6CA85BLL);
      double v122 = &CVML_status_internalError;
      if (!v123) {
        double v122 = &CVML_status_ok;
      }
      goto LABEL_250;
    }
    unsigned int v124 = (vcvtps_s32_f32((float)(v117 * 128.0) / v116) + 1) & 0xFFFFFFFE;
    unsigned int v125 = (vcvtps_s32_f32((float)(v116 * 128.0) / v117) + 1) & 0xFFFFFFFE;
    if (v116 <= v117)
    {
      int v126 = 128;
    }
    else
    {
      unsigned int v124 = 128;
      int v126 = v125;
    }
    HIDWORD(__A[12].imagp) = v126;
    LODWORD(__A[13].realp) = v124;
    OSStatus v123 = VTPixelTransferSessionCreate(0, &pixelTransferSessionOut);
    if (!v123)
    {
      if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], SHIDWORD(__A[12].imagp), SLODWORD(__A[13].realp), 0x34323076u, 0, &pixelBufferOut))
      {
LABEL_110:
        OSStatus v123 = 3710;
        goto LABEL_145;
      }
      OSStatus v123 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, pixelBuffer, pixelBufferOut);
      if (!v123)
      {
        HIDWORD(__A[13].realp) = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferOut, 0);
        CVPixelBufferLockBaseAddress(pixelBufferOut, 1uLL);
        BaseAddressOfPlane = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(pixelBufferOut, 0);
        if (!BaseAddressOfPlane) {
          goto LABEL_110;
        }
        int v128 = (int)__A[1].imagp;
        fftsetup = vDSP_create_fftsetup(SLODWORD(__A[2].realp), 0);
        BOOL v130 = dispatch_group_create();
        context = __A;
        int v263 = v128;
        int v264 = 0;
        char v265 = __A;
        int v266 = v128;
        int v267 = 1;
        unint64_t v268 = __A;
        int v269 = v128;
        int v270 = 2;
        int v272 = v128;
        int v273 = 3;
        uint64_t v131 = SLODWORD(__A[5].imagp);
        size_t v132 = 4 * v131;
        if ((int)v131 < 0) {
          size_t v133 = -1;
        }
        else {
          size_t v133 = 4 * v131;
        }
        int8x8_t v271 = __A;
        double v134 = operator new[](v133, MEMORY[0x1E4FBA2D0]);
        int v135 = v134;
        int v136 = HIDWORD(__A[12].imagp) - 128;
        if (HIDWORD(__A[12].imagp) == 128)
        {
          int v137 = (int)((double)(LODWORD(__A[13].realp) - 128) * 0.5);
        }
        else
        {
          int v137 = 0;
          int v136 = (int)((double)v136 * 0.5);
        }
        if (v134)
        {
          int v138 = 0;
          signed int v139 = 0;
          uint64_t v140 = v131;
          float v141 = 1.0 / (double)(int)v131;
          int realp_high = HIDWORD(__A[13].realp);
          float v143 = __A[6].imagp;
          int v144 = v136 + v137 * realp_high;
          int v145 = 255;
          uint64_t v146 = v143;
          do
          {
            for (uint64_t i = 0; i != 128; ++i)
            {
              signed int v148 = BaseAddressOfPlane[v144 + i];
              if (v145 >= v148) {
                int v145 = BaseAddressOfPlane[v144 + i];
              }
              if (v139 <= v148) {
                signed int v139 = BaseAddressOfPlane[v144 + i];
              }
              v146[i] = (float)v148;
            }
            ++v138;
            v144 += realp_high;
            v146 += 128;
          }
          while (v138 != 128);
          int v149 = v139 - v145;
          if (v149 < 1) {
            float v150 = 255.0;
          }
          else {
            float v150 = 255.0 / (float)v149;
          }
          if ((int)v140 >= 1)
          {
            float v151 = (float)v145;
            int v152 = v143;
            do
            {
              float v153 = log((float)(v150 * (float)(*v152 - v151)) + 1.0);
              *v152++ = v153;
              --v140;
            }
            while (v140);
          }
          memcpy(v135, v143, v132);
          __A[3].realp = v143;
          bzero(__A[3].imagp, v132);
          vDSP_fft2d_zip((FFTSetup)__A[5].realp, __C, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), 1);
          vDSP_zvmul(__A, 1, __C, 1, v242, 1, SLODWORD(__A[5].imagp), 1);
          vDSP_fft2d_zip((FFTSetup)__A[5].realp, v242, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), -1);
          int v154 = (int)__A[5].imagp;
          if (v154 >= 1)
          {
            size_t v155 = __A[4].realp;
            uint64_t v156 = __A[6].imagp;
            uint64_t v157 = (float *)v135;
            uint64_t v158 = LODWORD(__A[5].imagp);
            do
            {
              float v159 = *v155++;
              float v160 = *v157 + (float)((float)-v141 * v159);
              *v157++ = v160;
              *v156++ = v160 * v160;
              --v158;
            }
            while (v158);
          }
          bzero(__A[3].imagp, 4 * v154);
          vDSP_fft2d_zip((FFTSetup)__A[5].realp, __C, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), 1);
          vDSP_zvmul(__A, 1, __C, 1, v242, 1, SLODWORD(__A[5].imagp), 1);
          vDSP_fft2d_zip((FFTSetup)__A[5].realp, v242, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), -1);
          uint64_t v161 = LODWORD(__A[5].imagp);
          if ((int)v161 >= 1)
          {
            int v162 = __A[4].realp;
            uint64_t v163 = __A[6].imagp;
            double v164 = (float *)v135;
            do
            {
              float v165 = sqrtf(fabsf(*v162 * v141));
              *v162++ = v165;
              float v166 = *v164++;
              *v163++ = v166 / (float)(v165 + 0.2);
              --v161;
            }
            while (v161);
          }
          MEMORY[0x1A62562A0](v135, 0x1000C8052888210);
          bzero(__A[3].imagp, 4 * SLODWORD(__A[5].imagp));
          vDSP_fft2d_zip(fftsetup, __C, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), 1);
          dispatch_group_async_f(v130, (dispatch_queue_t)__A[11].realp, &context, (dispatch_function_t)ma::GaborFilters::DispatchHelperDescriptor);
          dispatch_group_async_f(v130, (dispatch_queue_t)__A[11].realp, &v265, (dispatch_function_t)ma::GaborFilters::DispatchHelperDescriptor);
          dispatch_group_async_f(v130, (dispatch_queue_t)__A[11].realp, &v268, (dispatch_function_t)ma::GaborFilters::DispatchHelperDescriptor);
          dispatch_group_async_f(v130, (dispatch_queue_t)__A[11].realp, &v271, (dispatch_function_t)ma::GaborFilters::DispatchHelperDescriptor);
          dispatch_group_wait(v130, 0xFFFFFFFFFFFFFFFFLL);
          dispatch_release(v130);
          uint64_t v167 = 0;
          unint64_t v168 = (float32x4_t *)__A[8].imagp;
          uint64_t v169 = __A[9].realp;
          float32x4_t v170 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
          do
          {
            float32x4_t v172 = *v168;
            float32x4_t v171 = v168[1];
            v168 += 2;
            *(int16x8_t *)&v169[v167] = vuzp1q_s16((int16x8_t)vcvtq_u32_f32(vmulq_f32(v172, v170)), (int16x8_t)vcvtq_u32_f32(vmulq_f32(v171, v170)));
            v167 += 4;
          }
          while (v167 != 16);
          OSStatus v123 = 0;
        }
        else
        {
          OSStatus v123 = -108;
        }
        vDSP_destroy_fftsetup(fftsetup);
        CVPixelBufferUnlockBaseAddress(pixelBufferOut, 1uLL);
      }
    }
LABEL_145:
    if (pixelBufferOut)
    {
      CFRelease(pixelBufferOut);
      CVPixelBufferRef pixelBufferOut = 0;
    }
    if (pixelTransferSessionOut) {
      CFRelease(pixelTransferSessionOut);
    }
    int v118 = v248;
    float32x4_t v10 = __A;
    uint64_t v121 = v244;
    double v120 = v245;
    if (v123) {
      goto LABEL_247;
    }
    goto LABEL_150;
  }
  if (v8) {
    MEMORY[0x1A62562A0](v8, 0x1000C80BDFB0063);
  }
  double v122 = &CVML_status_internalError;
LABEL_250:
  uint64_t v235 = *v122;
  ma::HSVHistogram::~HSVHistogram((ma::HSVHistogram *)&v257);
  return (v235 + 128) | 0xE00;
}

void sub_1A3F82C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForImage_Planar8(vision::mod::ImageDescriptorProcessorAbstract *this, const vImage_Buffer *a2, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  return 3711;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForImage_BGRA8888(vision::mod::ImageDescriptorProcessorAbstract *this, const vImage_Buffer *a2, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  return 3711;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForImage_RGBA8888(vision::mod::ImageDescriptorProcessorAbstract *this, const vImage_Buffer *a2, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  return 3711;
}

void vision::mod::ColorGaborImageDescriptorProcessor::~ColorGaborImageDescriptorProcessor(vision::mod::ColorGaborImageDescriptorProcessor *this)
{
}

void sub_1A3F82E68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F82FC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F83108(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F832B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F83384(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F83428(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F83528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F83620(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F836DC(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3F84568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,uint64_t a32,uint64_t a33,void *a34,void *a35,void *a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,id a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table((uint64_t)&a37);

  _Block_object_dispose(&STACK[0x258], 8);
  _Block_object_dispose(&STACK[0x330], 8);

  _Block_object_dispose(&STACK[0x360], 8);
  _Block_object_dispose(&STACK[0x398], 8);
  std::deque<-[VNPersonSegmentationGeneratorLearnedMattingTiled _processTiledImageBuffer:inputMaskObservation:options:qosClass:error:]::OutputTileData>::~deque[abi:ne180100](a12);

  _Block_object_dispose(&STACK[0x450], 8);
  _Block_object_dispose(&STACK[0x480], 8);

  _Block_object_dispose(&STACK[0x4B0], 8);
  _Block_object_dispose(&STACK[0x5B0], 8);
  _Block_object_dispose(&STACK[0x5D0], 8);
  _Block_object_dispose((const void *)(v73 - 256), 8);

  _Unwind_Resume(a1);
}

void sub_1A3F84A68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__19625(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__19626(uint64_t a1)
{
}

double __Block_byref_object_copy__46(void *a1, void *a2)
{
  a1[6] = a2[6];
  a1[7] = a2[7];
  a1[8] = a2[8];
  a1[9] = a2[9];
  double result = 0.0;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  a1[10] = a2[10];
  a1[11] = a2[11];
  a2[10] = 0;
  a2[11] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__47(uint64_t a1)
{
  return std::deque<-[VNPersonSegmentationGeneratorLearnedMattingTiled _processTiledImageBuffer:inputMaskObservation:options:qosClass:error:]::OutputTileData>::~deque[abi:ne180100](a1 + 48);
}

uint64_t __Block_byref_object_copy__48_19628(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A3F84FBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F85258(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F8552C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v28 - 160), 8);

  _Unwind_Resume(a1);
}

void sub_1A3F85E34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  operator delete(__p);
  operator delete(v29);

  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table((uint64_t)&a29);
  _Block_object_dispose((const void *)(v30 - 120), 8);

  _Unwind_Resume(a1);
}

void sub_1A3F85FCC(void *a1)
{
}

void sub_1A3F85FE8()
{
  if (v0) {
    JUMPOUT(0x1A3F85FF0);
  }
  JUMPOUT(0x1A3F85FF4);
}

void sub_1A3F86068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F860E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F8652C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);

  std::__optional_destruct_base<std::tuple<std::unordered_map<NSString * {__strong},__CVBuffer *>,std::unordered_map<NSString * {__strong},espresso_buffer_t>>,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A3F8671C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F86840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F86B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a11);

  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<float,MPClusteringTreeNode *>,std::__map_value_compare<float,std::__value_type<float,MPClusteringTreeNode *>,std::less<float>,true>,std::allocator<std::__value_type<float,MPClusteringTreeNode *>>>::__emplace_multi<std::pair<float,MPClusteringTreeNode *>>(uint64_t **a1, uint64_t a2, float a3)
{
  unint64_t v6 = (uint64_t *)operator new(0x30uLL);
  uint64_t v7 = v6;
  *((float *)v6 + 8) = a3;
  v6[5] = a2;
  float v8 = a1 + 1;
  uint64_t v9 = (uint64_t **)a1[1];
  if (v9)
  {
    do
    {
      while (1)
      {
        float v8 = v9;
        if (*((float *)v9 + 8) <= a3) {
          break;
        }
        uint64_t v9 = (uint64_t **)*v9;
        float32x4_t v10 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      uint64_t v9 = (uint64_t **)v9[1];
    }
    while (v9);
    float32x4_t v10 = v8 + 1;
  }
  else
  {
    float32x4_t v10 = a1 + 1;
  }
LABEL_8:
  uint64_t *v6 = 0;
  v6[1] = 0;
  v6[2] = (uint64_t)v8;
  *float32x4_t v10 = v6;
  uint64_t v11 = (uint64_t *)**a1;
  if (v11)
  {
    *a1 = v11;
    uint64_t v7 = *v10;
  }
  double result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v7);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void sub_1A3F87124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a16);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a19);

  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<int,MPClusteringTreeNode *>,std::__map_value_compare<int,std::__value_type<int,MPClusteringTreeNode *>,std::less<int>,true>,std::allocator<std::__value_type<int,MPClusteringTreeNode *>>>::__emplace_unique_key_args<int,std::pair<int,MPClusteringTreeNode *>>(uint64_t *result, int a2, int a3, uint64_t a4)
{
  unint64_t v6 = result;
  float v8 = (uint64_t **)(result + 1);
  uint64_t v7 = result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (void *)v7;
        int v10 = *(_DWORD *)(v7 + 32);
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        float v8 = (uint64_t **)v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        float v8 = (uint64_t **)(v9 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = result + 1;
LABEL_9:
    uint64_t v11 = operator new(0x30uLL);
    v11[8] = a3;
    *((void *)v11 + 5) = a4;
    *(void *)uint64_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v9;
    *float v8 = (uint64_t *)v11;
    uint64_t v12 = *(void *)*v6;
    if (v12)
    {
      uint64_t *v6 = v12;
      DSPSplitComplex v13 = *v8;
    }
    else
    {
      DSPSplitComplex v13 = (uint64_t *)v11;
    }
    double result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v6[1], v13);
    ++v6[2];
  }
  return result;
}

void MPClusteringTreeNode::getLeafNodes(MPClusteringTreeNode *this, uint64_t a2)
{
  this->id var0 = 0;
  *(void *)&this->var1 = 0;
  *(void *)&this->var3 = 0;
  if (*(void *)(a2 + 24) && *(void *)(a2 + 32))
  {
    MPClusteringTreeNode::getLeafNodes(&v9);
    MPClusteringTreeNode::getLeafNodes((MPClusteringTreeNode *)&v7);
    id var0 = v9.var0;
    std::vector<MPClusteringTreeNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<MPClusteringTreeNode **>,std::__wrap_iter<MPClusteringTreeNode **>>((uint64_t)this, 0, (char *)v9.var0, *(char **)&v9.var1, (uint64_t)(*(void *)&v9.var1 - (unint64_t)v9.var0) >> 3);
    uint64_t v5 = v7;
    std::vector<MPClusteringTreeNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<MPClusteringTreeNode **>,std::__wrap_iter<MPClusteringTreeNode **>>((uint64_t)this, *(char **)&this->var1, v7, v8, (v8 - v7) >> 3);
    if (v5) {
      operator delete(v5);
    }
    if (var0) {
      operator delete(var0);
    }
  }
  else
  {
    unint64_t v6 = operator new(8uLL);
    this->id var0 = v6;
    *v6++ = a2;
    *(void *)&this->var1 = v6;
    *(void *)&this->var3 = v6;
  }
}

void sub_1A3F87314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v14) {
    operator delete(v14);
  }
  if (v13) {
    operator delete(v13);
  }
  float32x4_t v16 = *(void **)v12;
  if (*(void *)v12)
  {
    *(void *)(v12 + 8) = v16;
    operator delete(v16);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<MPClusteringTreeNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<MPClusteringTreeNode **>,std::__wrap_iter<MPClusteringTreeNode **>>(uint64_t a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  unint64_t v6 = __src;
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (a5 > (uint64_t)(v9 - v10) >> 3)
  {
    uint64_t v11 = *(char **)a1;
    unint64_t v12 = a5 + ((uint64_t)(v10 - *(void *)a1) >> 3);
    if (v12 >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = (__dst - v11) >> 3;
    uint64_t v14 = v9 - (void)v11;
    if (v14 >> 2 > v12) {
      unint64_t v12 = v14 >> 2;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v12;
    }
    if (v15) {
      unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
    }
    else {
      uint64_t v16 = 0;
    }
    float v26 = (void *)(v15 + 8 * v13);
    uint64_t v27 = (char *)&v26[a5];
    uint64_t v28 = 8 * a5;
    float v29 = v26;
    do
    {
      uint64_t v30 = *(void *)v6;
      v6 += 8;
      *v29++ = v30;
      v28 -= 8;
    }
    while (v28);
    size_t v31 = *(char **)a1;
    if (*(char **)a1 != __dst)
    {
      int v32 = __dst;
      do
      {
        uint64_t v33 = *((void *)v32 - 1);
        v32 -= 8;
        *--float v26 = v33;
      }
      while (v32 != v31);
    }
    unint64_t v34 = v15 + 8 * v16;
    int v35 = *(unsigned char **)(a1 + 8);
    uint64_t v36 = v35 - __dst;
    if (v35 != __dst) {
      memmove(v27, __dst, v35 - __dst);
    }
    size_t v37 = *(char **)a1;
    *(void *)a1 = v26;
    *(void *)(a1 + 8) = &v27[v36];
    *(void *)(a1 + 16) = v34;
    if (v37)
    {
      operator delete(v37);
    }
    return;
  }
  uint64_t v17 = v10 - (void)__dst;
  uint64_t v18 = (uint64_t)(v10 - (void)__dst) >> 3;
  if (v18 >= a5)
  {
    float v19 = &__src[8 * a5];
    float v21 = *(char **)(a1 + 8);
LABEL_17:
    size_t v22 = &__dst[8 * a5];
    float v23 = &v21[-8 * a5];
    uint64_t v24 = v21;
    if ((unint64_t)v23 < v10)
    {
      uint64_t v24 = v21;
      do
      {
        uint64_t v25 = *(void *)v23;
        v23 += 8;
        *(void *)uint64_t v24 = v25;
        v24 += 8;
      }
      while ((unint64_t)v23 < v10);
    }
    *(void *)(a1 + 8) = v24;
    if (v21 != v22) {
      memmove(&v21[-8 * ((v21 - v22) >> 3)], __dst, v21 - v22);
    }
    if (v19 != v6)
    {
      memmove(__dst, v6, v19 - v6);
    }
    return;
  }
  float v19 = &__src[8 * v18];
  int64_t v20 = a4 - v19;
  if (a4 != v19) {
    memmove(*(void **)(a1 + 8), &__src[8 * v18], a4 - v19);
  }
  float v21 = (char *)(v10 + v20);
  *(void *)(a1 + 8) = v10 + v20;
  if (v17 >= 1) {
    goto LABEL_17;
  }
}

void MPClusteringTreeNode::freeNodeAndItsSubtree(MPClusteringTreeNode *this)
{
  var5 = this->var5;
  if (var5) {
    MPClusteringTreeNode::freeNodeAndItsSubtree(var5);
  }
  var6 = this->var6;
  if (var6) {
    MPClusteringTreeNode::freeNodeAndItsSubtree(var6);
  }

  free(this);
}

void sub_1A3F876B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F8770C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  unint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNEspressoResources;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3F8798C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F87B28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F87C34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F88034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32)
{
  _Unwind_Resume(a1);
}

void sub_1A3F8819C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F882D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ctpl_trackerDelete(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void ***)a1[9];
    if (v2) {
      tplTrackerResampler_free(v2 + 42655);
    }
    free(v2);
    free(a1);
    unint64_t v3 = &CVML_status_ok;
  }
  else
  {
    unint64_t v3 = &CVML_status_invalidParameter;
  }
  return (*v3 + 128) | 0x1A00;
}

void vision::mod::ImageAnalyzer_CustomClassifier::~ImageAnalyzer_CustomClassifier(vision::mod::ImageAnalyzer_CustomClassifier *this)
{
  if (!*((unsigned char *)this + 240)) {
    espresso_plan_destroy();
  }
  espresso_context_destroy();
  uint64_t v2 = (void **)((char *)this + 312);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v2);

  vision::mod::ImageAnalyzer_CustomClassifierOptions::~ImageAnalyzer_CustomClassifierOptions((void **)this);
}

void vision::mod::ImageAnalyzer_CustomClassifierOptions::~ImageAnalyzer_CustomClassifierOptions(void **this)
{
  if (*((char *)this + 191) < 0) {
    operator delete(this[21]);
  }
  if (*((char *)this + 167) < 0) {
    operator delete(this[18]);
  }
  if (*((char *)this + 143) < 0) {
    operator delete(this[15]);
  }
  if (*((char *)this + 119) < 0) {
    operator delete(this[12]);
  }
  if (*((char *)this + 95) < 0) {
    operator delete(this[9]);
  }
  if (*((char *)this + 71) < 0) {
    operator delete(this[6]);
  }
  if (*((char *)this + 47) < 0) {
    operator delete(this[3]);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*this);
  }
}

void vision::mod::ImageAnalyzer_CustomClassifier::performInference()
{
}

void sub_1A3F88940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)va);
  std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100]((void ***)(v3 - 112));
  _Unwind_Resume(a1);
}

void ***std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100](void ***result)
{
  uint64_t v1 = *result;
  *double result = 0;
  if (v1)
  {
    uint64_t v2 = v1;
    std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&v2);
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

void sub_1A3F88BC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F88CA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F88D94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void vision::mod::ImageAnalyzer::createImageAnalyzer(vision::mod::ImageAnalyzer *this, uint64_t *a2, char *a3, const char *a4, const char *a5, const char *a6, const char *a7, const char *a8, std::string *__str, const char *a10, const vision::mod::ImageAnalyzer_Options *a11)
{
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (char *)operator new(0x440uLL);
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *(void *)uint64_t v11 = &unk_1EF7536C8;
  unint64_t v12 = vision::mod::ImageAnalyzer_Options::ImageAnalyzer_Options((vision::mod::ImageAnalyzer_Options *)(v11 + 24));
  *((void *)v11 + 78) = 0;
  *((_DWORD *)v11 + 158) = 0;
  *((_OWORD *)v11 + 40) = 0u;
  v11[656] = 0;
  *((_OWORD *)v12 + 40) = 0u;
  *((_OWORD *)v12 + 41) = 0u;
  *((_OWORD *)v12 + 42) = 0u;
  *((_OWORD *)v12 + 43) = 0u;
  *((_OWORD *)v12 + 44) = 0u;
  *((_OWORD *)v12 + 45) = 0u;
  *((_DWORD *)v11 + 190) = 1065353216;
  *((_OWORD *)v11 + 48) = 0u;
  *((_OWORD *)v11 + 49) = 0u;
  *((_DWORD *)v11 + 200) = 1065353216;
  *((_OWORD *)v12 + 49) = 0u;
  *((_OWORD *)v12 + 50) = 0u;
  *((_DWORD *)v11 + 210) = 1065353216;
  *((_OWORD *)v11 + 53) = 0u;
  *((_OWORD *)v11 + 54) = 0u;
  *((_DWORD *)v11 + 220) = 1065353216;
  *((_OWORD *)v12 + 54) = 0u;
  *((_OWORD *)v12 + 55) = 0u;
  *((_DWORD *)v11 + 230) = 1065353216;
  *((_OWORD *)v11 + 58) = 0u;
  *((_OWORD *)v11 + 59) = 0u;
  *((_DWORD *)v11 + 240) = 1065353216;
  *((_OWORD *)v12 + 59) = 0u;
  *((_OWORD *)v12 + 60) = 0u;
  *((_OWORD *)v12 + 61) = 0u;
  *((void *)v11 + 127) = 0;
  *((_DWORD *)v11 + 256) = 1065353216;
  *((int32x4_t *)v12 + 63) = vdupq_n_s32(0x7FC00000u);
  *((_OWORD *)v12 + 64) = 0u;
  *((_OWORD *)v12 + 65) = 0u;
  *((void *)v11 + 135) = 0;
  uint64_t v114 = (std::string *)v12;
  std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) != 0) {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
  }
  unsigned int v124 = v11;
  if (!size || !LODWORD(__str[1].__r_.__value_.__r.__words[2])) {
    goto LABEL_157;
  }
  std::string::size_type v14 = HIBYTE(__str[2].__r_.__value_.__r.__words[2]);
  if ((v14 & 0x80u) != 0) {
    std::string::size_type v14 = __str[2].__r_.__value_.__l.__size_;
  }
  if (!v14)
  {
LABEL_157:
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    uint64_t v104 = 8567;
    goto LABEL_160;
  }
  std::string::operator=((std::string *)v12, __str);
  *((_OWORD *)v11 + 3) = *(_OWORD *)&__str[1].__r_.__value_.__l.__data_;
  *((_DWORD *)v11 + 16) = __str[1].__r_.__value_.__r.__words[2];
  double v122 = (std::string *)(v11 + 72);
  std::string::operator=((std::string *)v11 + 3, __str + 2);
  double v120 = (std::string *)(v11 + 96);
  std::string::operator=((std::string *)v11 + 4, __str + 3);
  uint64_t v113 = (std::string *)(v11 + 120);
  std::string::operator=((std::string *)v11 + 5, __str + 4);
  uint64_t v119 = (std::string *)(v11 + 144);
  std::string::operator=((std::string *)v11 + 6, __str + 5);
  int v118 = (std::string *)(v11 + 168);
  std::string::operator=((std::string *)v11 + 7, __str + 6);
  float v117 = (std::string *)(v11 + 192);
  std::string::operator=((std::string *)v11 + 8, __str + 7);
  float v116 = (std::string *)(v11 + 216);
  std::string::operator=((std::string *)v11 + 9, __str + 8);
  uint64_t v121 = (std::string *)(v11 + 240);
  std::string::operator=((std::string *)v11 + 10, __str + 9);
  std::string::operator=((std::string *)v11 + 11, __str + 10);
  unint64_t v15 = (const std::string *)(v11 + 288);
  std::string::operator=((std::string *)v11 + 12, __str + 11);
  uint64_t v115 = (std::string *)(v11 + 312);
  std::string::operator=((std::string *)v11 + 13, __str + 12);
  int v112 = (std::string *)(v11 + 336);
  std::string::operator=((std::string *)v11 + 14, __str + 13);
  if (v114 != __str) {
    std::vector<std::string>::__assign_with_size[abi:ne180100]<std::string*,std::string*>((std::vector<std::string> *)v11 + 15, (std::string *)__str[14].__r_.__value_.__l.__data_, (long long *)__str[14].__r_.__value_.__l.__size_, 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(__str[14].__r_.__value_.__l.__size_ - __str[14].__r_.__value_.__r.__words[0]) >> 3));
  }
  int v111 = (std::string *)(v11 + 384);
  std::string::operator=((std::string *)v11 + 16, __str + 15);
  *((_WORD *)v11 + 204) = __str[16].__r_.__value_.__l.__data_;
  uint64_t v110 = (std::string *)(v11 + 416);
  std::string::operator=((std::string *)(v11 + 416), (std::string *)((char *)__str + 392));
  long long v16 = *(_OWORD *)&__str[18].__r_.__value_.__l.__data_;
  *(_OWORD *)(v11 + 440) = *(_OWORD *)&__str[17].__r_.__value_.__r.__words[1];
  *(_OWORD *)(v11 + 456) = v16;
  *(_OWORD *)(v11 + 470) = *(_OWORD *)((char *)&__str[18].__r_.__value_.__r.__words[1] + 6);
  if (v114 == __str)
  {
LABEL_75:
    *((_OWORD *)v124 + 38) = *(_OWORD *)&__str[24].__r_.__value_.__r.__words[1];
    std::string::operator=((std::string *)v124 + 28, v122);
    uint64_t v63 = (uint64_t)(v124 + 728);
    LODWORD(v126.__r_.__value_.__l.__data_) = 1;
    long long v64 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)(v124 + 728), 1u, &v126);
    std::string::operator=(v64 + 1, v120);
    LODWORD(v126.__r_.__value_.__l.__data_) = 2;
    unint64_t v65 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)(v124 + 728), 2u, &v126);
    std::string::operator=(v65 + 1, v119);
    LODWORD(v126.__r_.__value_.__l.__data_) = 4;
    uint64_t v66 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)(v124 + 728), 4u, &v126);
    std::string::operator=(v66 + 1, v118);
    LODWORD(v126.__r_.__value_.__l.__data_) = 8;
    int v67 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)(v124 + 728), 8u, &v126);
    std::string::operator=(v67 + 1, v117);
    LODWORD(v126.__r_.__value_.__l.__data_) = 16;
    int v68 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)(v124 + 728), 0x10u, &v126);
    std::string::operator=(v68 + 1, v116);
    LODWORD(v126.__r_.__value_.__l.__data_) = 32;
    int v69 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)(v124 + 728), 0x20u, &v126);
    std::string::operator=(v69 + 1, v115);
    if (v124[485])
    {
      LODWORD(v126.__r_.__value_.__l.__data_) = 64;
      int v70 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v63, 0x40u, &v126);
      std::string::operator=(v70 + 1, v121);
    }
    else
    {
      LODWORD(v126.__r_.__value_.__l.__data_) = 64;
      uint64_t v71 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v63, 0x40u, &v126);
      std::string::operator=(v71 + 1, v110);
    }
    LODWORD(v126.__r_.__value_.__l.__data_) = 128;
    uint64_t v72 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v63, 0x80u, &v126);
    std::string::operator=(v72 + 1, v15);
    uint64_t v73 = (long long *)*((void *)v124 + 45);
    for (uint64_t i = (long long *)*((void *)v124 + 46); v73 != i; v73 = (long long *)((char *)v73 + 24))
    {
      if (*((char *)v73 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v126, *(const std::string::value_type **)v73, *((void *)v73 + 1));
      }
      else
      {
        long long v75 = *v73;
        v126.__r_.__value_.__r.__words[2] = *((void *)v73 + 2);
        *(_OWORD *)&v126.__r_.__value_.__l.__data_ = v75;
      }
      int v76 = (uint64_t *)*((void *)v124 + 93);
      if (v76)
      {
        char v77 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
        if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v78 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v78 = v126.__r_.__value_.__l.__size_;
        }
        if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v79 = &v126;
        }
        else {
          uint64_t v79 = (std::string *)v126.__r_.__value_.__r.__words[0];
        }
        signed int v80 = 256;
        do
        {
          int v81 = *((_DWORD *)v76 + 4);
          if (v81 > 0x2000)
          {
            uint64_t v82 = *((unsigned __int8 *)v76 + 47);
            uint64_t v83 = (v82 & 0x80u) == 0 ? *((unsigned __int8 *)v76 + 47) : v76[4];
            if (v83 == v78)
            {
              uint64_t v84 = (const void **)(v76 + 3);
              if ((v82 & 0x80) != 0)
              {
                if (!memcmp(*v84, v79, v76[4])) {
                  goto LABEL_111;
                }
              }
              else
              {
                if (!*((unsigned char *)v76 + 47)) {
                  goto LABEL_111;
                }
                uint64_t v85 = v79;
                while (*(unsigned __int8 *)v84 == v85->__r_.__value_.__s.__data_[0])
                {
                  uint64_t v84 = (const void **)((char *)v84 + 1);
                  uint64_t v85 = (std::string *)((char *)v85 + 1);
                  if (!--v82) {
                    goto LABEL_111;
                  }
                }
              }
            }
          }
          if (v81 < 0x2000 && v81 >= v80) {
            signed int v80 = v81 + 1;
          }
          int v76 = (uint64_t *)*v76;
        }
        while (v76);
      }
      else
      {
        signed int v80 = 256;
      }
      LODWORD(v125.__r_.__value_.__l.__data_) = v80;
      uint64_t v87 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v63, v80, &v125);
      std::string::operator=(v87 + 1, &v126);
      char v77 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
LABEL_111:
      if (v77 < 0) {
        operator delete(v126.__r_.__value_.__l.__data_);
      }
    }
    LODWORD(v125.__r_.__value_.__l.__data_) = 1024;
    int v88 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v63, 0x400u, &v125);
    std::string::operator=(v88 + 1, v113);
    LODWORD(v125.__r_.__value_.__l.__data_) = 2048;
    uint64_t v89 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v63, 0x800u, &v125);
    std::string::operator=(v89 + 1, v112);
    LODWORD(v125.__r_.__value_.__l.__data_) = 4096;
    uint64_t v90 = (std::string *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v63, 0x1000u, &v125);
    std::string::operator=(v90 + 1, v111);
    if (a3)
    {
      uint64_t context = espresso_create_context();
      *((void *)v124 + 80) = context;
      if (context)
      {
        plauint64_t n = espresso_create_plan();
        *((void *)v124 + 81) = plan;
        if (plan)
        {
          std::string::basic_string[abi:ne180100]<0>(&v126, a3);
          if (espresso_plan_add_network())
          {
            espresso_plan_get_error_info();
            uint64_t v105 = __cxa_allocate_exception(8uLL);
            *uint64_t v105 = 8539;
            __cxa_throw(v105, MEMORY[0x1E4FBA3E0], 0);
          }
          if (espresso_network_set_memory_pool_id())
          {
            espresso_plan_get_error_info();
            uint64_t v106 = __cxa_allocate_exception(8uLL);
            *uint64_t v106 = 8539;
            __cxa_throw(v106, MEMORY[0x1E4FBA3E0], 0);
          }
          if (espresso_network_declare_input())
          {
            espresso_plan_get_error_info();
            uint64_t v107 = __cxa_allocate_exception(8uLL);
            *uint64_t v107 = 8539;
            __cxa_throw(v107, MEMORY[0x1E4FBA3E0], 0);
          }
          uint64_t v93 = (uint64_t *)*((void *)v124 + 93);
          if (!v93)
          {
LABEL_151:
            if (!espresso_plan_build())
            {
              if (!espresso_network_query_blob_dimensions())
              {
                if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v126.__r_.__value_.__l.__data_);
                }
                LOWORD(v126.__r_.__value_.__l.__data_) = 2;
                v126.__r_.__value_.__s.__data_[2] = 0;
                *(std::string::size_type *)((char *)v126.__r_.__value_.__r.__words + 4) = 0x437F000000000000;
                HIDWORD(v126.__r_.__value_.__r.__words[1]) = 32;
                v126.__r_.__value_.__s.__data_[16] = 0;
                operator new();
              }
              espresso_plan_get_error_info();
              double v109 = __cxa_allocate_exception(8uLL);
              void *v109 = 8539;
              __cxa_throw(v109, MEMORY[0x1E4FBA3E0], 0);
            }
            espresso_plan_get_error_info();
            uint64_t v108 = __cxa_allocate_exception(8uLL);
            *uint64_t v108 = 8539;
            __cxa_throw(v108, MEMORY[0x1E4FBA3E0], 0);
          }
          while (1)
          {
            if (*((char *)v93 + 47) < 0)
            {
              uint64_t v95 = v93[4];
              BOOL v94 = *((_DWORD *)v93 + 4) == 64;
              if (v95 && *((_DWORD *)v93 + 4) != 64)
              {
LABEL_127:
                if (espresso_network_declare_output())
                {
                  espresso_plan_get_error_info();
                  uint64_t v102 = __cxa_allocate_exception(8uLL);
                  *uint64_t v102 = 8539;
                  __cxa_throw(v102, MEMORY[0x1E4FBA3E0], 0);
                }
                goto LABEL_138;
              }
            }
            else
            {
              BOOL v94 = *((_DWORD *)v93 + 4) == 64;
              uint64_t v95 = *((unsigned __int8 *)v93 + 47);
              if (*((unsigned char *)v93 + 47) && *((_DWORD *)v93 + 4) != 64) {
                goto LABEL_127;
              }
            }
            BOOL v96 = !v95 || !v94;
            if (!v96) {
              break;
            }
LABEL_138:
            uint64_t v93 = (uint64_t *)*v93;
            if (!v93) {
              goto LABEL_151;
            }
          }
          if (v124[485])
          {
            if (espresso_network_declare_output()) {
              espresso_plan_get_error_info();
            }
            if (espresso_network_declare_output()) {
              espresso_plan_get_error_info();
            }
            goto LABEL_138;
          }
          int v97 = (uint64_t *)*((void *)v124 + 67);
          int v98 = (uint64_t *)*((void *)v124 + 68);
LABEL_141:
          if (v97 == v98) {
            goto LABEL_138;
          }
          uint64_t v99 = *v97;
          uint64_t v100 = v97[1];
          while (1)
          {
            if (v99 == v100)
            {
              v97 += 3;
              goto LABEL_141;
            }
            if (*(char *)(v99 + 23) < 0)
            {
              if (!*(void *)(v99 + 8)) {
                goto LABEL_149;
              }
            }
            else if (!*(unsigned char *)(v99 + 23))
            {
              goto LABEL_149;
            }
            if (espresso_network_declare_output())
            {
              espresso_plan_get_error_info();
              int v101 = __cxa_allocate_exception(8uLL);
              *int v101 = 8539;
              __cxa_throw(v101, MEMORY[0x1E4FBA3E0], 0);
            }
LABEL_149:
            v99 += 24;
          }
        }
      }
      exceptiouint64_t n = __cxa_allocate_exception(8uLL);
      uint64_t v104 = 8539;
    }
    else
    {
      exceptiouint64_t n = __cxa_allocate_exception(8uLL);
      uint64_t v104 = 8573;
    }
LABEL_160:
    *exceptiouint64_t n = v104;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v11 + 488, (char *)__str[19].__r_.__value_.__l.__size_, __str[19].__r_.__value_.__r.__words[2], (uint64_t)(__str[19].__r_.__value_.__r.__words[2] - __str[19].__r_.__value_.__l.__size_) >> 2);
  uint64_t v17 = (long long ***)__str[20].__r_.__value_.__l.__size_;
  uint64_t v18 = (long long ***)__str[20].__r_.__value_.__r.__words[2];
  unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (v18 - v17);
  uint64_t v20 = (uint64_t)(v124 + 528);
  uint64_t v21 = *((void *)v124 + 66);
  uint64_t v22 = *((void *)v124 + 64);
  if (0xAAAAAAAAAAAAAAABLL * ((v21 - v22) >> 3) >= v19)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v124 + 65) - v22) >> 3) >= v19)
    {
      uint64_t v33 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<std::string>> *,std::vector<std::vector<std::string>> *,std::vector<std::vector<std::string>> *>((long long ***)__str[20].__r_.__value_.__l.__size_, (long long ***)__str[20].__r_.__value_.__r.__words[2], *((void *)v124 + 64));
      std::string::size_type v34 = *((void *)v124 + 65);
      while (v34 != v33)
      {
        v34 -= 24;
        v126.__r_.__value_.__r.__words[0] = v34;
        std::vector<std::vector<std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v126);
      }
      uint64_t v30 = v124;
      *((void *)v124 + 65) = v33;
LABEL_32:
      std::vector<std::vector<std::string>>::__assign_with_size[abi:ne180100]<std::vector<std::string>*,std::vector<std::string>*>((uint64_t)(v30 + 536), (long long **)__str[21].__r_.__value_.__l.__size_, (long long **)__str[21].__r_.__value_.__r.__words[2], 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(__str[21].__r_.__value_.__r.__words[2] - __str[21].__r_.__value_.__l.__size_) >> 3));
      int v35 = (uint64_t *)__str[22].__r_.__value_.__l.__size_;
      uint64_t v36 = (uint64_t *)__str[22].__r_.__value_.__r.__words[2];
      unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * (v36 - v35);
      float v38 = v124 + 576;
      uint64_t v39 = (uint64_t *)*((void *)v124 + 70);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v124 + 72) - (void)v39) >> 3) >= v37)
      {
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v124 + 71) - (void)v39) >> 3) >= v37)
        {
          BOOL v46 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>((uint64_t *)__str[22].__r_.__value_.__l.__size_, (uint64_t *)__str[22].__r_.__value_.__r.__words[2], v39);
          std::string::size_type v47 = *((void *)v124 + 71);
          while ((uint64_t *)v47 != v46)
          {
            v47 -= 24;
            v126.__r_.__value_.__r.__words[0] = v47;
            std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v126);
          }
          size_t v43 = v124;
          *((void *)v124 + 71) = v46;
          goto LABEL_47;
        }
        float v45 = &v35[(uint64_t)(*((void *)v124 + 71) - (void)v39) >> 3];
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>((uint64_t *)__str[22].__r_.__value_.__l.__size_, v45, v39);
        size_t v43 = v124;
        float v44 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)v38, v45, v36, *((void **)v124 + 71));
      }
      else
      {
        size_t v40 = v124 + 560;
        std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)v124 + 70);
        if (v37 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v41 = 0x5555555555555556 * ((uint64_t)(*v38 - *v40) >> 3);
        if (v41 <= v37) {
          unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * (v36 - v35);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v38 - *v40) >> 3) >= 0x555555555555555) {
          unint64_t v42 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v42 = v41;
        }
        std::vector<std::vector<std::vector<float>>>::__vallocate[abi:ne180100](v40, v42);
        size_t v43 = v124;
        float v44 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>((uint64_t)v38, v35, v36, *((void **)v124 + 71));
      }
      v43[71] = v44;
LABEL_47:
      std::string::size_type v48 = __str[23].__r_.__value_.__l.__size_;
      size_t v49 = &__str[23].__r_.__value_.__s.__data_[16];
      if (v43[75])
      {
        std::string::size_type v50 = v43[73];
        v43[73] = v43 + 74;
        *(void *)(v43[74] + 16) = 0;
        *((_OWORD *)v43 + 37) = 0u;
        if (*(void *)(v50 + 8)) {
          std::string::size_type v51 = *(void *)(v50 + 8);
        }
        else {
          std::string::size_type v51 = v50;
        }
        v126.__r_.__value_.__r.__words[0] = (std::string::size_type)(v43 + 73);
        v126.__r_.__value_.__l.__size_ = v51;
        v126.__r_.__value_.__r.__words[2] = v51;
        if (!v51
          || (v126.__r_.__value_.__l.__size_ = (std::string::size_type)std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::_DetachedTreeCache::__detach_next(v51),
              (char *)v48 == v49))
        {
          uint64_t v55 = (char *)v48;
        }
        else
        {
          do
          {
            std::string::operator=((std::string *)(v51 + 32), (const std::string *)(v48 + 32));
            *(_DWORD *)(v51 + 56) = *(_DWORD *)(v48 + 56);
            int32x4_t v52 = (uint64_t *)v126.__r_.__value_.__r.__words[2];
            leaf_high = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_leaf_high((uint64_t)(v43 + 73), &v125, (void *)(v126.__r_.__value_.__r.__words[2] + 32));
            std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)v43 + 73, (uint64_t)v125.__r_.__value_.__l.__data_, leaf_high, v52);
            std::string::size_type v51 = v126.__r_.__value_.__l.__size_;
            v126.__r_.__value_.__r.__words[2] = v126.__r_.__value_.__l.__size_;
            if (v126.__r_.__value_.__l.__size_) {
              v126.__r_.__value_.__l.__size_ = (std::string::size_type)std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::_DetachedTreeCache::__detach_next(v126.__r_.__value_.__l.__size_);
            }
            uint64_t v54 = *(char **)(v48 + 8);
            if (v54)
            {
              do
              {
                uint64_t v55 = v54;
                uint64_t v54 = *(char **)v54;
              }
              while (v54);
            }
            else
            {
              do
              {
                uint64_t v55 = *(char **)(v48 + 16);
                BOOL v96 = *(void *)v55 == v48;
                std::string::size_type v48 = (std::string::size_type)v55;
              }
              while (!v96);
            }
            if (!v51) {
              break;
            }
            std::string::size_type v48 = (std::string::size_type)v55;
          }
          while (v55 != v49);
        }
        std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)&v126);
        std::string::size_type v48 = (std::string::size_type)v55;
      }
      if ((char *)v48 != v49)
      {
        do
        {
          double v56 = (char *)operator new(0x40uLL);
          long long v57 = v56;
          long long v58 = v56 + 32;
          if (*(char *)(v48 + 55) < 0)
          {
            std::string::__init_copy_ctor_external((std::string *)(v56 + 32), *(const std::string::value_type **)(v48 + 32), *(void *)(v48 + 40));
          }
          else
          {
            long long v59 = *(_OWORD *)(v48 + 32);
            *((void *)v56 + 6) = *(void *)(v48 + 48);
            *(_OWORD *)long long v58 = v59;
          }
          *((_DWORD *)v57 + 14) = *(_DWORD *)(v48 + 56);
          int32x4_t v60 = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_leaf_high((uint64_t)(v43 + 73), &v126, v58);
          std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)v43 + 73, (uint64_t)v126.__r_.__value_.__l.__data_, v60, (uint64_t *)v57);
          uint64_t v61 = *(char **)(v48 + 8);
          if (v61)
          {
            do
            {
              int32x4_t v62 = v61;
              uint64_t v61 = *(char **)v61;
            }
            while (v61);
          }
          else
          {
            do
            {
              int32x4_t v62 = *(char **)(v48 + 16);
              BOOL v96 = *(void *)v62 == v48;
              std::string::size_type v48 = (std::string::size_type)v62;
            }
            while (!v96);
          }
          std::string::size_type v48 = (std::string::size_type)v62;
        }
        while (v62 != v49);
      }
      goto LABEL_75;
    }
    int v32 = &v17[(*((void *)v124 + 65) - v22) >> 3];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<std::string>> *,std::vector<std::vector<std::string>> *,std::vector<std::vector<std::string>> *>((long long ***)__str[20].__r_.__value_.__l.__size_, v32, *((void *)v124 + 64));
    uint64_t v30 = v124;
    uint64_t v31 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<std::string>>>,std::vector<std::vector<std::string>>*,std::vector<std::vector<std::string>>*,std::vector<std::vector<std::string>>*>(v20, v32, v18, *((void *)v124 + 65));
  }
  else
  {
    if (v22)
    {
      float v23 = (void **)(v124 + 512);
      std::string::size_type v24 = *((void *)v124 + 65);
      uint64_t v25 = (void *)*((void *)v124 + 64);
      if (v24 != v22)
      {
        do
        {
          v24 -= 24;
          v126.__r_.__value_.__r.__words[0] = v24;
          std::vector<std::vector<std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v126);
        }
        while (v24 != v22);
        uint64_t v25 = *v23;
      }
      *((void *)v124 + 65) = v22;
      operator delete(v25);
      uint64_t v21 = 0;
      *float v23 = 0;
      *((void *)v124 + 65) = 0;
      *((void *)v124 + 66) = 0;
    }
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_166;
    }
    unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * (v21 >> 3);
    uint64_t v27 = 2 * v26;
    if (2 * v26 <= v19) {
      uint64_t v27 = 0xAAAAAAAAAAAAAAABLL * (v18 - v17);
    }
    unint64_t v28 = v26 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v27;
    if (v28 > 0xAAAAAAAAAAAAAAALL) {
LABEL_166:
    }
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    float v29 = (char *)operator new(24 * v28);
    uint64_t v30 = v124;
    *((void *)v124 + 64) = v29;
    *((void *)v124 + 65) = v29;
    *((void *)v124 + 66) = &v29[24 * v28];
    uint64_t v31 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<std::string>>>,std::vector<std::vector<std::string>>*,std::vector<std::vector<std::string>>*,std::vector<std::vector<std::string>>*>(v20, v17, v18, (uint64_t)v29);
  }
  *((void *)v30 + 65) = v31;
  goto LABEL_32;
}

void sub_1A3F8AE00(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34)
{
  *(void *)(v35 + 568) = v34;
  if (a2 == 1)
  {
    *a22 = *(void *)__cxa_begin_catch(a1);
    *a23 = 0;
    a23[1] = 0;
    __cxa_end_catch();
    JUMPOUT(0x1A3F8AB8CLL);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](a34);
  _Unwind_Resume(a1);
}

void sub_1A3F8B16C()
{
}

void *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *unint64_t v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A3F8B388(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageAnalyzer::loadLabels(std::vector<std::string> *this, const char *a2)
{
  v14[19] = *MEMORY[0x1E4F143B8];
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (a2 && *a2)
  {
    __p[0] = 0;
    __p[1] = 0;
    std::string::size_type v10 = 0;
    std::ifstream::basic_ifstream(v12);
    unint64_t v3 = (std::locale::id *)MEMORY[0x1E4FBA258];
    while (1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(v12[0] - 24)));
      uint64_t v4 = std::locale::use_facet(&v11, v3);
      unsigned __int8 v5 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 10);
      std::locale::~locale(&v11);
      std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v12, (uint64_t)__p, v5);
      if ((v13[*(void *)(v12[0] - 24) + 16] & 5) != 0) {
        break;
      }
      std::vector<std::string>::pointer end = this->__end_;
      if (end >= this->__end_cap_.__value_)
      {
        std::vector<std::string>::pointer v8 = std::vector<std::string>::__push_back_slow_path<std::string const&>(this, (long long *)__p);
      }
      else
      {
        if (SHIBYTE(v10) < 0)
        {
          std::string::__init_copy_ctor_external(this->__end_, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
        }
        else
        {
          long long v7 = *(_OWORD *)__p;
          end->__r_.__value_.__r.__words[2] = v10;
          *(_OWORD *)&end->__r_.__value_.__l.__data_ = v7;
        }
        std::vector<std::string>::pointer v8 = end + 1;
        this->__end_ = end + 1;
      }
      this->__end_ = v8;
    }
    v12[0] = *MEMORY[0x1E4FBA3F8];
    *(uint64_t *)((char *)v12 + *(void *)(v12[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
    MEMORY[0x1A6256010](v13);
    std::istream::~istream();
    MEMORY[0x1A6256200](v14);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1A3F8B5E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::locale a16, uint64_t a17)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_rethrow();
  }
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  _Unwind_Resume(a1);
}

void sub_1A3F8B66C(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x1A3F8B664);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::unordered_set<std::string>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)v1 + 24);
    }
    operator delete(v1);
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  if (a1)
  {
    unint64_t v3 = __p + 3;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  if (__p)
  {
    operator delete(__p);
  }
}

uint64_t vision::mod::_isBooleanFlag(uint64_t a1, unsigned char *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __p = *(std::string *)a1;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v3 = (std::string *)((char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]));
  }
  else {
    unint64_t v3 = (std::string *)(__p.__r_.__value_.__r.__words[0] + __p.__r_.__value_.__l.__size_);
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  while (p_p != v3)
  {
    p_p->__r_.__value_.__s.__data_[0] = __tolower(p_p->__r_.__value_.__s.__data_[0]);
    p_p = (std::string *)((char *)p_p + 1);
  }
  if (std::string::compare(&__p, "true"))
  {
    if (std::string::compare(&__p, "false"))
    {
      uint64_t v5 = 0;
      goto LABEL_21;
    }
    if (!a2) {
      goto LABEL_20;
    }
    LOBYTE(v5) = 0;
LABEL_19:
    *a2 = v5;
LABEL_20:
    uint64_t v5 = 1;
    goto LABEL_21;
  }
  uint64_t v5 = 1;
  if (a2) {
    goto LABEL_19;
  }
LABEL_21:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v5;
}

void sub_1A3F8B830(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      std::string::size_type v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          std::string::size_type v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  std::string::size_type v10 = operator new(0x30uLL);
  *std::string::size_type v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *std::string::size_type v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  *std::string::size_type v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A3F8BA54(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(void *a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = a2;
  unint64_t v6 = a1[1];
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*a1 + 8 * v8);
    unint64_t v85 = v8;
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return i;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  float v12 = (char *)operator new(0x90uLL);
  v91[0] = v12;
  v91[1] = a1 + 2;
  uint64_t v86 = a1 + 2;
  char v92 = 0;
  *(void *)float v12 = 0;
  *((void *)v12 + 1) = v5;
  *((_DWORD *)v12 + 4) = *a3;
  *(_OWORD *)(v12 + 24) = 0u;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_OWORD *)(v12 + 72) = 0u;
  *(_OWORD *)(v12 + 88) = 0u;
  *(_OWORD *)(v12 + 104) = 0u;
  *(_OWORD *)(v12 + 120) = 0u;
  *((void *)v12 + 17) = 0;
  std::string::basic_string[abi:ne180100]<0>((void *)v12 + 3, "unknown");
  uint64_t v90 = v12;
  *((void *)v12 + 7) = 0;
  *((void *)v12 + 8) = 0;
  *((void *)v12 + 6) = v12 + 56;
  std::string::basic_string[abi:ne180100]<0>(v97, "noMapping");
  int v98 = &unk_1EF753098;
  uint64_t v99 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::readParametersNoMapping;
  uint64_t v100 = &v98;
  std::string::basic_string[abi:ne180100]<0>(v101, "1DAffineMapping");
  uint64_t v102 = &unk_1EF753098;
  uint64_t v103 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::readParameters1DAffineMapping;
  uint64_t v104 = &v102;
  std::string::basic_string[abi:ne180100]<0>(v105, "1DLogisticMapping");
  unint64_t v87 = v6;
  unint64_t v88 = v5;
  uint64_t v89 = (float *)a1;
  uint64_t v106 = &unk_1EF753098;
  uint64_t v107 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::readParameters1DLogisticMapping;
  uint64_t v108 = &v106;
  std::string::basic_string[abi:ne180100]<0>(v109, "1DPairwiseAffineMapping");
  float v13 = 0;
  uint64_t v14 = 0;
  uint64_t v110 = &unk_1EF753098;
  int v111 = vision::mod::readParameters1DPairwiseAffineMapping;
  int v112 = &v110;
  *((void *)v12 + 10) = 0;
  *((void *)v12 + 11) = 0;
  unint64_t v15 = v12 + 80;
  *((void *)v90 + 9) = v90 + 80;
  while (1)
  {
    unint64_t v16 = (const std::string::value_type **)&v97[7 * v14];
    size_t v17 = v15;
    if (*((void **)v90 + 9) == v15) {
      goto LABEL_33;
    }
    uint64_t v18 = v13;
    unint64_t v19 = v15;
    if (v13)
    {
      do
      {
        size_t v17 = v18;
        uint64_t v18 = (void *)v18[1];
      }
      while (v18);
    }
    else
    {
      do
      {
        size_t v17 = (void *)v19[2];
        BOOL v20 = *v17 == (void)v19;
        unint64_t v19 = v17;
      }
      while (v20);
    }
    if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v17 + 4, &v97[7 * v14]) & 0x80) != 0)
    {
LABEL_33:
      uint64_t v21 = (uint64_t **)v15;
      uint64_t v22 = (uint64_t **)v15;
      if (v13)
      {
        uint64_t v22 = (uint64_t **)(v17 + 1);
        if (v17[1]) {
          goto LABEL_48;
        }
        uint64_t v21 = (uint64_t **)v17;
      }
    }
    else
    {
      uint64_t v21 = (uint64_t **)v15;
      uint64_t v22 = (uint64_t **)v15;
      if (v13)
      {
        float v23 = v13;
        do
        {
          while (1)
          {
            uint64_t v21 = (uint64_t **)v23;
            std::string::size_type v24 = v23 + 4;
            if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v97[7 * v14], v23 + 4) & 0x80) == 0)break; {
            float v23 = *v21;
            }
            uint64_t v22 = v21;
            if (!*v21) {
              goto LABEL_36;
            }
          }
          if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v24, &v97[7 * v14]) & 0x80) == 0) {
            goto LABEL_48;
          }
          uint64_t v22 = v21 + 1;
          float v23 = v21[1];
        }
        while (v23);
      }
    }
LABEL_36:
    uint64_t v25 = (char *)operator new(0x58uLL);
    unint64_t v26 = (uint64_t *)v25;
    uint64_t v93 = v25;
    BOOL v94 = v15;
    char v95 = 0;
    if (*((char *)v16 + 23) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)(v25 + 32), *v16, (std::string::size_type)v16[1]);
    }
    else
    {
      *((_OWORD *)v25 + 2) = *(_OWORD *)v16;
      *((void *)v25 + 6) = v16[2];
    }
    uint64_t v27 = &v97[7 * v14];
    unint64_t v28 = (void *)v27[6];
    if (v28)
    {
      if (v28 == v27 + 3)
      {
        v26[10] = (uint64_t)(v26 + 7);
        (*(void (**)(void *))(v27[3] + 24))(v27 + 3);
        goto LABEL_45;
      }
      uint64_t v29 = (*(uint64_t (**)(void *))(*v28 + 16))(v28);
    }
    else
    {
      uint64_t v29 = 0;
    }
    v26[10] = v29;
LABEL_45:
    char v95 = 1;
    *unint64_t v26 = 0;
    v26[1] = 0;
    v26[2] = (uint64_t)v21;
    *uint64_t v22 = v26;
    uint64_t v30 = **((void **)v90 + 9);
    if (v30)
    {
      *((void *)v90 + 9) = v30;
      unint64_t v26 = *v22;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v90 + 10), v26);
    ++*((void *)v90 + 11);
    uint64_t v93 = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v93);
LABEL_48:
    if (++v14 == 4) {
      break;
    }
    float v13 = (void *)*v15;
  }
  for (uint64_t j = 0; j != -28; j -= 7)
  {
    std::__function::__value_func<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::~__value_func[abi:ne180100]((void **)((char *)&v110 + j * 8));
    if (SHIBYTE(v109[j + 2]) < 0) {
      operator delete((void *)v109[j]);
    }
  }
  std::string::basic_string[abi:ne180100]<0>(v97, "noMapping");
  int v98 = &unk_1EF753040;
  uint64_t v99 = vision::mod::getOutputSizeNoMapping;
  uint64_t v100 = &v98;
  std::string::basic_string[abi:ne180100]<0>(v101, "1DAffineMapping");
  uint64_t v102 = &unk_1EF753040;
  uint64_t v103 = vision::mod::getOutputSize1DAffineMapping;
  uint64_t v104 = &v102;
  std::string::basic_string[abi:ne180100]<0>(v105, "1DLogisticMapping");
  uint64_t v106 = &unk_1EF753040;
  uint64_t v107 = vision::mod::getOutputSize1DLogisticMapping;
  uint64_t v108 = &v106;
  std::string::basic_string[abi:ne180100]<0>(v109, "1DPairwiseAffineMapping");
  int v32 = 0;
  uint64_t v33 = 0;
  uint64_t v110 = &unk_1EF753040;
  *((void *)v90 + 13) = 0;
  *((void *)v90 + 14) = 0;
  uint64_t v34 = (uint64_t *)(v90 + 104);
  int v111 = vision::mod::getOutputSize1DPairwiseAffineMapping;
  int v112 = &v110;
  uint64_t v35 = (uint64_t **)(v90 + 96);
  *((void *)v90 + 12) = v90 + 104;
  while (2)
  {
    uint64_t v36 = (const std::string::value_type **)&v97[7 * v33];
    unint64_t v37 = v90 + 104;
    if (*v35 != v34)
    {
      float v38 = v32;
      uint64_t v39 = v90 + 104;
      if (v32)
      {
        do
        {
          unint64_t v37 = v38;
          float v38 = (void *)v38[1];
        }
        while (v38);
      }
      else
      {
        do
        {
          unint64_t v37 = (void *)v39[2];
          BOOL v20 = *v37 == (void)v39;
          uint64_t v39 = v37;
        }
        while (v20);
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v37 + 4, &v97[7 * v33]) & 0x80) == 0)
      {
        size_t v40 = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>((uint64_t)v35, &v96, &v97[7 * v33]);
        goto LABEL_64;
      }
    }
    if (!v32)
    {
      BOOL v96 = v90 + 104;
      size_t v40 = (uint64_t **)(v90 + 104);
      goto LABEL_67;
    }
    BOOL v96 = v37;
    size_t v40 = (uint64_t **)(v37 + 1);
LABEL_64:
    if (!*v40)
    {
LABEL_67:
      unint64_t v41 = (char *)operator new(0x58uLL);
      unint64_t v42 = (uint64_t *)v41;
      uint64_t v93 = v41;
      BOOL v94 = v90 + 104;
      char v95 = 0;
      if (*((char *)v36 + 23) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v41 + 32), *v36, (std::string::size_type)v36[1]);
      }
      else
      {
        *((_OWORD *)v41 + 2) = *(_OWORD *)v36;
        *((void *)v41 + 6) = v36[2];
      }
      size_t v43 = &v97[7 * v33];
      float v44 = (void *)v43[6];
      if (v44)
      {
        if (v44 != v43 + 3)
        {
          uint64_t v45 = (*(uint64_t (**)(void *))(*v44 + 16))(v44);
          goto LABEL_74;
        }
        v42[10] = (uint64_t)(v42 + 7);
        (*(void (**)(void *))(v43[3] + 24))(v43 + 3);
      }
      else
      {
        uint64_t v45 = 0;
LABEL_74:
        v42[10] = v45;
      }
      char v95 = 1;
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v35, (uint64_t)v96, v40, v42);
      uint64_t v93 = 0;
      std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v93);
    }
    if (++v33 != 4)
    {
      int v32 = (void *)*v34;
      continue;
    }
    break;
  }
  for (uint64_t k = 0; k != -28; k -= 7)
  {
    std::__function::__value_func<unsigned long ()(unsigned long)>::~__value_func[abi:ne180100]((void **)((char *)&v110 + k * 8));
    if (SHIBYTE(v109[k + 2]) < 0) {
      operator delete((void *)v109[k]);
    }
  }
  std::string::basic_string[abi:ne180100]<0>(v97, "noMapping");
  int v98 = &unk_1EF7530F0;
  uint64_t v99 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::computeNoMapping;
  uint64_t v100 = &v98;
  std::string::basic_string[abi:ne180100]<0>(v101, "1DAffineMapping");
  uint64_t v102 = &unk_1EF7530F0;
  uint64_t v103 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::compute1DAffineMapping;
  uint64_t v104 = &v102;
  std::string::basic_string[abi:ne180100]<0>(v105, "1DLogisticMapping");
  uint64_t v106 = &unk_1EF7530F0;
  uint64_t v107 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::compute1DLogisticMapping;
  uint64_t v108 = &v106;
  std::string::basic_string[abi:ne180100]<0>(v109, "1DPairwiseAffineMapping");
  std::string::size_type v47 = 0;
  uint64_t v48 = 0;
  uint64_t v110 = &unk_1EF7530F0;
  *((void *)v90 + 16) = 0;
  *((void *)v90 + 17) = 0;
  size_t v49 = (uint64_t *)(v90 + 128);
  int v111 = vision::mod::compute1DPairwiseAffineMapping;
  int v112 = &v110;
  std::string::size_type v50 = (uint64_t **)(v90 + 120);
  *((void *)v90 + 15) = v90 + 128;
  while (2)
  {
    std::string::size_type v51 = (const std::string::value_type **)&v97[7 * v48];
    int32x4_t v52 = v90 + 128;
    if (*v50 != v49)
    {
      uint64_t v53 = v47;
      uint64_t v54 = v90 + 128;
      if (v47)
      {
        do
        {
          int32x4_t v52 = v53;
          uint64_t v53 = (void *)v53[1];
        }
        while (v53);
      }
      else
      {
        do
        {
          int32x4_t v52 = (void *)v54[2];
          BOOL v20 = *v52 == (void)v54;
          uint64_t v54 = v52;
        }
        while (v20);
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v52 + 4, &v97[7 * v48]) & 0x80) == 0)
      {
        uint64_t v55 = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>((uint64_t)v50, &v96, &v97[7 * v48]);
        goto LABEL_93;
      }
    }
    if (!v47)
    {
      BOOL v96 = v90 + 128;
      uint64_t v55 = (uint64_t **)(v90 + 128);
      goto LABEL_96;
    }
    BOOL v96 = v52;
    uint64_t v55 = (uint64_t **)(v52 + 1);
LABEL_93:
    if (!*v55)
    {
LABEL_96:
      double v56 = (char *)operator new(0x58uLL);
      long long v57 = (uint64_t *)v56;
      uint64_t v93 = v56;
      BOOL v94 = v90 + 128;
      char v95 = 0;
      if (*((char *)v51 + 23) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v56 + 32), *v51, (std::string::size_type)v51[1]);
      }
      else
      {
        *((_OWORD *)v56 + 2) = *(_OWORD *)v51;
        *((void *)v56 + 6) = v51[2];
      }
      long long v58 = &v97[7 * v48];
      long long v59 = (void *)v58[6];
      if (v59)
      {
        if (v59 != v58 + 3)
        {
          uint64_t v60 = (*(uint64_t (**)(void *))(*v59 + 16))(v59);
          goto LABEL_103;
        }
        v57[10] = (uint64_t)(v57 + 7);
        (*(void (**)(void *))(v58[3] + 24))(v58 + 3);
      }
      else
      {
        uint64_t v60 = 0;
LABEL_103:
        v57[10] = v60;
      }
      char v95 = 1;
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v50, (uint64_t)v96, v55, v57);
      uint64_t v93 = 0;
      std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v93);
    }
    if (++v48 != 4)
    {
      std::string::size_type v47 = (void *)*v49;
      continue;
    }
    break;
  }
  uint64_t v61 = 0;
  int8x8_t v62 = (int8x8_t)v87;
  do
  {
    std::__function::__value_func<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::~__value_func[abi:ne180100]((void **)((char *)&v110 + v61 * 8));
    if (SHIBYTE(v109[v61 + 2]) < 0) {
      operator delete((void *)v109[v61]);
    }
    v61 -= 7;
  }
  while (v61 != -28);
  char v92 = 1;
  float v63 = (float)(unint64_t)(*((void *)v89 + 3) + 1);
  float v64 = v89[8];
  unint64_t v65 = v85;
  if (!v87 || (float)(v64 * (float)v87) < v63)
  {
    BOOL v66 = 1;
    if (v87 >= 3) {
      BOOL v66 = (v87 & (v87 - 1)) != 0;
    }
    unint64_t v67 = v66 | (2 * v87);
    unint64_t v68 = vcvtps_u32_f32(v63 / v64);
    if (v67 <= v68) {
      int8x8_t prime = (int8x8_t)v68;
    }
    else {
      int8x8_t prime = (int8x8_t)v67;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    int8x8_t v62 = *(int8x8_t *)(v89 + 2);
    if (*(void *)&prime <= *(void *)&v62)
    {
      if (*(void *)&prime < *(void *)&v62)
      {
        unint64_t v76 = vcvtps_u32_f32((float)*((unint64_t *)v89 + 3) / v89[8]);
        if (*(void *)&v62 < 3uLL || (uint8x8_t v77 = (uint8x8_t)vcnt_s8(v62), v77.i16[0] = vaddlv_u8(v77), v77.u32[0] > 1uLL))
        {
          unint64_t v76 = std::__next_prime(v76);
        }
        else
        {
          uint64_t v78 = 1 << -(char)__clz(v76 - 1);
          if (v76 >= 2) {
            unint64_t v76 = v78;
          }
        }
        if (*(void *)&prime <= v76) {
          int8x8_t prime = (int8x8_t)v76;
        }
        if (*(void *)&prime >= *(void *)&v62)
        {
          int8x8_t v62 = *(int8x8_t *)(v89 + 2);
        }
        else
        {
          if (prime) {
            goto LABEL_124;
          }
          uint64_t v84 = *(void **)v89;
          *(void *)uint64_t v89 = 0;
          if (v84) {
            operator delete(v84);
          }
          int8x8_t v62 = 0;
          *((void *)v89 + 1) = 0;
        }
      }
    }
    else
    {
LABEL_124:
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int v70 = operator new(8 * *(void *)&prime);
      uint64_t v71 = *(void **)v89;
      *(void *)uint64_t v89 = v70;
      if (v71) {
        operator delete(v71);
      }
      uint64_t v72 = 0;
      *((int8x8_t *)v89 + 1) = prime;
      do
        *(void *)(*(void *)v89 + 8 * v72++) = 0;
      while (*(void *)&prime != v72);
      uint64_t v73 = (void *)*v86;
      if (*v86)
      {
        unint64_t v74 = v73[1];
        uint8x8_t v75 = (uint8x8_t)vcnt_s8(prime);
        v75.i16[0] = vaddlv_u8(v75);
        if (v75.u32[0] > 1uLL)
        {
          if (v74 >= *(void *)&prime) {
            v74 %= *(void *)&prime;
          }
        }
        else
        {
          v74 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)v89 + 8 * v74) = v86;
        uint64_t v79 = (void *)*v73;
        if (*v73)
        {
          do
          {
            unint64_t v80 = v79[1];
            if (v75.u32[0] > 1uLL)
            {
              if (v80 >= *(void *)&prime) {
                v80 %= *(void *)&prime;
              }
            }
            else
            {
              v80 &= *(void *)&prime - 1;
            }
            if (v80 != v74)
            {
              if (!*(void *)(*(void *)v89 + 8 * v80))
              {
                *(void *)(*(void *)v89 + 8 * v80) = v73;
                goto LABEL_149;
              }
              *uint64_t v73 = *v79;
              *uint64_t v79 = **(void **)(*(void *)v89 + 8 * v80);
              **(void **)(*(void *)v89 + 8 * v80) = v79;
              uint64_t v79 = v73;
            }
            unint64_t v80 = v74;
LABEL_149:
            uint64_t v73 = v79;
            uint64_t v79 = (void *)*v79;
            unint64_t v74 = v80;
          }
          while (v79);
        }
      }
      int8x8_t v62 = prime;
    }
    if ((*(void *)&v62 & (*(void *)&v62 - 1)) != 0)
    {
      if (*(void *)&v62 <= v88) {
        unint64_t v65 = v88 % *(void *)&v62;
      }
      else {
        unint64_t v65 = v88;
      }
    }
    else
    {
      unint64_t v65 = (v62.i32[0] - 1) & v88;
    }
  }
  int v81 = *(void **)(*(void *)v89 + 8 * v65);
  uint64_t i = (uint64_t *)v91[0];
  if (v81)
  {
    *(void *)v91[0] = *v81;
    goto LABEL_166;
  }
  *(void *)v91[0] = *((void *)v89 + 2);
  *((void *)v89 + 2) = i;
  *(void *)(*(void *)v89 + 8 * v65) = v86;
  if (*i)
  {
    unint64_t v82 = *(void *)(*i + 8);
    if ((*(void *)&v62 & (*(void *)&v62 - 1)) != 0)
    {
      if (v82 >= *(void *)&v62) {
        v82 %= *(void *)&v62;
      }
    }
    else
    {
      v82 &= *(void *)&v62 - 1;
    }
    int v81 = (void *)(*(void *)v89 + 8 * v82);
LABEL_166:
    *int v81 = i;
  }
  v91[0] = 0;
  ++*((void *)v89 + 3);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>>>>::reset[abi:ne180100]((uint64_t)v91);
  return i;
}

void sub_1A3F8C87C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<float>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<unsigned long ()(unsigned long)>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,0>(uint64_t a1)
{
  std::__function::__value_func<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::~__value_func[abi:ne180100]((void *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void *std::__function::__value_func<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<unsigned long ()(unsigned long)>>,0>(uint64_t a1)
{
  std::__function::__value_func<unsigned long ()(unsigned long)>::~__value_func[abi:ne180100]((void *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void *std::__function::__value_func<unsigned long ()(unsigned long)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,0>(uint64_t a1)
{
  std::__function::__value_func<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::~__value_func[abi:ne180100]((void *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void *std::__function::__value_func<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<vision::mod::ImageAnalyzer_AnalysisType const,vision::mod::ImageAnalyzer_PostProcessor>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<vision::mod::ImageAnalyzer_AnalysisType const,vision::mod::ImageAnalyzer_PostProcessor>,0>(uint64_t a1)
{
  std::__tree<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>>>::destroy(*(void **)(a1 + 112));
  std::__tree<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>>>::destroy(*(void **)(a1 + 88));
  std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(*(void **)(a1 + 64));
  std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(*(void **)(a1 + 40));
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

uint64_t std::pair<std::string const,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::pair<std::string const,std::function<unsigned long ()(unsigned long)>>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::pair<std::string const,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void *std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::target_type()
{
}

uint64_t std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), 0x80000001A410FDEBLL)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a2, a3, a4);
}

__n128 std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF7530F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF7530F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::~__func()
{
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<unsigned long ()(unsigned long)>>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void *std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::target_type()
{
}

uint64_t std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), 0x80000001A410FBAELL)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::operator()(uint64_t a1, void *a2)
{
  return (*(uint64_t (**)(void))(a1 + 8))(*a2);
}

__n128 std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF753040;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF753040;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::~__func()
{
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void *std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::target_type()
{
}

uint64_t std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__16__bindIRFxP7__sFILEPKcRNS_3mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIfNS9_IfEEEENS_4lessISB_EENS9_INS_4pairIKSB_SE_EEEEEEEJRKNS_12placeholders4__phILi1EEERKNSQ_ILi2EEERKNSQ_ILi3EEEEEE"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::operator()(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t))(a1 + 8))(*a2, *a3, a4);
}

__n128 std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF753098;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF753098;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::~__func()
{
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 47) < 0) {
      operator delete(__p[3]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::vector<std::vector<std::string>>::__assign_with_size[abi:ne180100]<std::vector<std::string>*,std::vector<std::string>*>(uint64_t a1, long long **a2, long long **a3, unint64_t a4)
{
  uint64_t v9 = a1 + 16;
  uint64_t v8 = *(void *)(a1 + 16);
  std::string::size_type v10 = *(std::vector<std::string> **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)a1) >> 3) < a4)
  {
    if (v10)
    {
      unint64_t v11 = *(void ***)(a1 + 8);
      float v12 = *(std::vector<std::string> **)a1;
      if (v11 != (void **)v10)
      {
        do
        {
          v11 -= 3;
          BOOL v20 = v11;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v20);
        }
        while (v11 != (void **)v10);
        float v12 = *(std::vector<std::string> **)a1;
      }
      *(void *)(a1 + 8) = v10;
      operator delete(v12);
      uint64_t v8 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v14 = 2 * v13;
    if (2 * v13 <= a4) {
      uint64_t v14 = a4;
    }
    if (v13 >= 0x555555555555555) {
      unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v15 = v14;
    }
    std::vector<std::string>::__vallocate[abi:ne180100]((void *)a1, v15);
    unint64_t v16 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::string>>,std::vector<std::string>*,std::vector<std::string>*,std::vector<std::string>*>(v9, a2, a3, *(std::string **)(a1 + 8));
    goto LABEL_16;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v10) >> 3) < a4)
  {
    size_t v17 = &a2[(uint64_t)(*(void *)(a1 + 8) - (void)v10) >> 3];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::string> *,std::vector<std::string> *,std::vector<std::string> *>((uint64_t)a2, (uint64_t)v17, v10);
    unint64_t v16 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::string>>,std::vector<std::string>*,std::vector<std::string>*,std::vector<std::string>*>(v9, v17, a3, *(std::string **)(a1 + 8));
LABEL_16:
    *(void *)(a1 + 8) = v16;
    return;
  }
  uint64_t v18 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::string> *,std::vector<std::string> *,std::vector<std::string> *>((uint64_t)a2, (uint64_t)a3, v10);
  unint64_t v19 = *(void ***)(a1 + 8);
  while (v19 != (void **)v18)
  {
    v19 -= 3;
    BOOL v20 = v19;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v20);
  }
  *(void *)(a1 + 8) = v18;
}

void sub_1A3F8D57C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1A3F8D584(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_leaf_high(uint64_t a1, void *a2, void *a3)
{
  unint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unint64_t v5 = v4;
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v4 + 4) & 0x80) == 0) {
          break;
        }
        uint64_t v4 = (void *)*v5;
        __n128 result = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      uint64_t v4 = (void *)v5[1];
    }
    while (v4);
    __n128 result = v5 + 1;
  }
  else
  {
    __n128 result = (void *)(a1 + 8);
  }
LABEL_8:
  *a2 = v5;
  return result;
}

uint64_t std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(*(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy((char *)v2);
  }
  return a1;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,float>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 55) < 0) {
      operator delete(__p[4]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  if (a1 != a2)
  {
    unint64_t v5 = a1;
    do
    {
      if (v5 != a3) {
        std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(a3, *v5, v5[1], 0xAAAAAAAAAAAAAAABLL * ((v5[1] - *v5) >> 3));
      }
      v5 += 3;
      a3 += 3;
    }
    while (v5 != a2);
  }
  return a3;
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a4;
  std::string::size_type v10 = a4;
  unint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    unint64_t v6 = a2;
    do
    {
      void *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * ((v6[1] - *v6) >> 3));
      uint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 3;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A3F8D7D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::vector<std::vector<std::vector<float>>>::__vdeallocate(void ***a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        unint64_t v5 = v3;
        std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<std::vector<std::vector<float>>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v3 = 3 * a2;
  __n128 result = (char *)operator new(24 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v3];
  return result;
}

void *std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    __n128 result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1A3F8D914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void ****)(a1 + 16);
    uint64_t v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      unint64_t v5 = v3;
      std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  unint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      void *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 2);
      uint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A3F8DA38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v9 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2];
  uint64_t v10 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *a1) >> 3) < a4)
  {
    if (v10)
    {
      std::vector<std::vector<long long>>::__clear[abi:ne180100](a1);
      operator delete((void *)*a1);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= a4) {
      uint64_t v12 = a4;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v12;
    }
    std::vector<std::string>::__vallocate[abi:ne180100](a1, v13);
    uint64_t v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v9, a2, a3, (void *)a1[1]);
    goto LABEL_13;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - (uint64_t)v10) >> 3) < a4)
  {
    uint64_t v15 = a2 + 8 * ((a1[1] - (uint64_t)v10) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<unsigned int> *,std::vector<unsigned int> *,std::vector<unsigned int> *>(a2, v15, v10);
    uint64_t v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v9, v15, a3, (void *)a1[1]);
LABEL_13:
    a1[1] = (uint64_t)v14;
    return;
  }
  unint64_t v16 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<unsigned int> *,std::vector<unsigned int> *,std::vector<unsigned int> *>(a2, a3, v10);
  size_t v17 = (char *)a1[1];
  if (v17 != v16)
  {
    uint64_t v18 = (char *)a1[1];
    do
    {
      BOOL v20 = (void *)*((void *)v18 - 3);
      v18 -= 24;
      unint64_t v19 = v20;
      if (v20)
      {
        *((void *)v17 - 2) = v19;
        operator delete(v19);
      }
      size_t v17 = v18;
    }
    while (v18 != v16);
  }
  a1[1] = (uint64_t)v16;
}

void sub_1A3F8DBC0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1A3F8DBC8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

std::vector<std::string> *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::string> *,std::vector<std::string> *,std::vector<std::string> *>(uint64_t a1, uint64_t a2, std::vector<std::string> *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      if ((std::vector<std::string> *)v5 != a3) {
        std::vector<std::string>::__assign_with_size[abi:ne180100]<std::string*,std::string*>(a3, *(std::string **)v5, *(long long **)(v5 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3));
      }
      v5 += 24;
      ++a3;
    }
    while (v5 != a2);
  }
  return a3;
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::string>>,std::vector<std::string>*,std::vector<std::string>*,std::vector<std::string>*>(uint64_t a1, long long **a2, long long **a3, std::string *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  unint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      v4->__r_.__value_.__r.__words[0] = 0;
      v4->__r_.__value_.__l.__size_ = 0;
      v4->__r_.__value_.__r.__words[2] = 0;
      std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v6[1] - (char *)*v6) >> 3));
      uint64_t v4 = ++v11;
      v6 += 3;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::string>>,std::vector<std::string>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A3F8DCF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::string>>,std::vector<std::string>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void ****)(a1 + 16);
    uint64_t v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      uint64_t v5 = v3;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<std::string>> *,std::vector<std::vector<std::string>> *,std::vector<std::vector<std::string>> *>(long long ***a1, long long ***a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      if (v5 != (long long ***)a3) {
        std::vector<std::vector<std::string>>::__assign_with_size[abi:ne180100]<std::vector<std::string>*,std::vector<std::string>*>(a3, *v5, v5[1], 0xAAAAAAAAAAAAAAABLL * (v5[1] - *v5));
      }
      v5 += 3;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<std::string>>>,std::vector<std::vector<std::string>>*,std::vector<std::vector<std::string>>*,std::vector<std::vector<std::string>>*>(uint64_t a1, long long ***a2, long long ***a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v12 = a4;
  v13[0] = a4;
  v10[0] = a1;
  v10[1] = &v12;
  v10[2] = v13;
  char v11 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      *(void *)(v4 + 16) = 0;
      uint8x8_t v7 = *v6;
      uint64_t v8 = v6[1];
      v13[1] = v4;
      char v14 = 0;
      if (v8 != v7)
      {
        std::vector<std::string>::__vallocate[abi:ne180100]((void *)v4, 0xAAAAAAAAAAAAAAABLL * (v8 - v7));
        *(void *)(v4 + 8) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::string>>,std::vector<std::string>*,std::vector<std::string>*,std::vector<std::string>*>(v4 + 16, v7, v8, *(std::string **)(v4 + 8));
        uint64_t v4 = v13[0];
      }
      v4 += 24;
      v13[0] = v4;
      v6 += 3;
    }
    while (v6 != a3);
  }
  char v11 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<std::string>>>,std::vector<std::vector<std::string>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v10);
  return v4;
}

void sub_1A3F8DEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<std::string>>>,std::vector<std::vector<std::string>>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void ****)(a1 + 16);
    uint64_t v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      uint64_t v5 = v3;
      std::vector<std::vector<std::string>>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

void std::__shared_ptr_emplace<vision::mod::ImageAnalyzerConcrete>::__on_zero_shared(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 656))
  {
    espresso_plan_destroy();
    espresso_context_destroy();
  }
  uint64_t v2 = *(void *)(a1 + 1080);
  *(void *)(a1 + 1080) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void ***)(a1 + 1008);
  if (v3)
  {
    do
    {
      uint64_t v4 = (void **)*v3;
      if (*((char *)v3 + 39) < 0) {
        operator delete(v3[2]);
      }
      operator delete(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
  uint64_t v5 = *(void **)(a1 + 992);
  *(void *)(a1 + 992) = 0;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(void *)(a1 + 968);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 976);
    uint64_t v8 = *(void **)(a1 + 968);
    if (v7 != v6)
    {
      uint64_t v9 = *(void *)(a1 + 976);
      do
      {
        char v11 = *(void **)(v9 - 24);
        v9 -= 24;
        uint64_t v10 = v11;
        if (v11)
        {
          *(void *)(v7 - 16) = v10;
          operator delete(v10);
        }
        uint64_t v7 = v9;
      }
      while (v9 != v6);
      uint64_t v8 = *(void **)(a1 + 968);
    }
    *(void *)(a1 + 976) = v6;
    operator delete(v8);
  }
  uint64_t v12 = *(void **)(a1 + 944);
  if (v12)
  {
    do
    {
      unint64_t v13 = (void *)*v12;
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)(v12 + 3));
      operator delete(v12);
      uint64_t v12 = v13;
    }
    while (v13);
  }
  char v14 = *(void **)(a1 + 928);
  *(void *)(a1 + 928) = 0;
  if (v14) {
    operator delete(v14);
  }
  uint64_t v15 = *(char **)(a1 + 904);
  if (v15)
  {
    do
    {
      unint64_t v16 = *(char **)v15;
      uint64_t v30 = (void **)(v15 + 24);
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v30);
      operator delete(v15);
      uint64_t v15 = v16;
    }
    while (v16);
  }
  size_t v17 = *(void **)(a1 + 888);
  *(void *)(a1 + 888) = 0;
  if (v17) {
    operator delete(v17);
  }
  uint64_t v18 = *(void **)(a1 + 864);
  if (v18)
  {
    do
    {
      unint64_t v19 = (void *)*v18;
      operator delete(v18);
      uint64_t v18 = v19;
    }
    while (v19);
  }
  BOOL v20 = *(void **)(a1 + 848);
  *(void *)(a1 + 848) = 0;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = *(void **)(a1 + 824);
  if (v21)
  {
    do
    {
      uint64_t v22 = (void *)*v21;
      operator delete(v21);
      uint64_t v21 = v22;
    }
    while (v22);
  }
  float v23 = *(void **)(a1 + 808);
  *(void *)(a1 + 808) = 0;
  if (v23) {
    operator delete(v23);
  }
  std::string::size_type v24 = *(void **)(a1 + 784);
  if (v24)
  {
    do
    {
      uint64_t v25 = (void *)*v24;
      std::__destroy_at[abi:ne180100]<std::pair<vision::mod::ImageAnalyzer_AnalysisType const,vision::mod::ImageAnalyzer_PostProcessor>,0>((uint64_t)(v24 + 2));
      operator delete(v24);
      std::string::size_type v24 = v25;
    }
    while (v25);
  }
  unint64_t v26 = *(void **)(a1 + 768);
  *(void *)(a1 + 768) = 0;
  if (v26) {
    operator delete(v26);
  }
  uint64_t v27 = *(void ***)(a1 + 744);
  if (v27)
  {
    do
    {
      unint64_t v28 = (void **)*v27;
      if (*((char *)v27 + 47) < 0) {
        operator delete(v27[3]);
      }
      operator delete(v27);
      uint64_t v27 = v28;
    }
    while (v28);
  }
  uint64_t v29 = *(void **)(a1 + 728);
  *(void *)(a1 + 728) = 0;
  if (v29) {
    operator delete(v29);
  }
  if (*(char *)(a1 + 695) < 0) {
    operator delete(*(void **)(a1 + 672));
  }
  std::unique_ptr<vision::mod::ImageProcessing_Preprocessor>::reset[abi:ne180100]((uint64_t *)(a1 + 664), 0);

  vision::mod::ImageAnalyzer_Options::~ImageAnalyzer_Options((vision::mod::ImageAnalyzer_Options *)(a1 + 24));
}

void std::__shared_ptr_emplace<vision::mod::ImageAnalyzerConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7536C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageAnalyzerConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7536C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3F8E284(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageAnalyzer_PostProcessor::getOutputSize(vision::mod::ImageAnalyzer_PostProcessor *this, uint64_t a2)
{
  if (!std::string::compare((const std::string *)this, "unknown"))
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 8564;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t v4 = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>((uint64_t)this + 72, &v13, this);
  uint64_t v5 = *v4;
  if (!*v4)
  {
    uint64_t v6 = v4;
    uint64_t v5 = (uint64_t *)operator new(0x58uLL);
    v11[0] = v5;
    v11[1] = (char *)this + 80;
    char v12 = 0;
    uint64_t v7 = (std::string *)(v5 + 4);
    if (*((char *)this + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)this, *((void *)this + 1));
    }
    else
    {
      *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)this;
      v5[6] = *((void *)this + 2);
    }
    v5[10] = 0;
    char v12 = 1;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)this + 9, v13, v6, v5);
    v11[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<unsigned long ()(unsigned long)>>,void *>>>>::reset[abi:ne180100]((uint64_t)v11);
  }
  v11[0] = a2;
  uint64_t v8 = v5[10];
  if (!v8) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 48))(v8, v11);
}

void sub_1A3F8E3D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x30uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  void v10[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *uint64_t v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A3F8E5EC(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<std::string,espresso_buffer_t>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,espresso_buffer_t>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t *a1, unsigned __int8 *a2, long long **a3)
{
  unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = a1[1];
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    float v12 = *(void ***)(*a1 + 8 * v3);
    if (v12)
    {
      float v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = *((void *)v13 + 1);
          if (v14 == v8)
          {
            if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v13 + 16, a2)) {
              return v13;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3) {
              break;
            }
          }
          float v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  float v13 = (char *)operator new(0xD0uLL);
  *(void *)float v13 = 0;
  *((void *)v13 + 1) = v8;
  unint64_t v15 = (std::string *)(v13 + 16);
  unint64_t v16 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v15, *(const std::string::value_type **)v16, *((void *)v16 + 1));
  }
  else
  {
    long long v17 = *v16;
    *((void *)v13 + 4) = *((void *)v16 + 2);
    *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v17;
  }
  uint64_t v18 = a1 + 2;
  *((void *)v13 + 25) = 0;
  *(_OWORD *)(v13 + 184) = 0u;
  *(_OWORD *)(v13 + 168) = 0u;
  *(_OWORD *)(v13 + 152) = 0u;
  *(_OWORD *)(v13 + 136) = 0u;
  *(_OWORD *)(v13 + 120) = 0u;
  *(_OWORD *)(v13 + 104) = 0u;
  *(_OWORD *)(v13 + 88) = 0u;
  *(_OWORD *)(v13 + 72) = 0u;
  *(_OWORD *)(v13 + 56) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  float v19 = (float)(unint64_t)(a1[3] + 1);
  float v20 = *((float *)a1 + 8);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    BOOL v21 = 1;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      int8x8_t prime = (int8x8_t)v23;
    }
    else {
      int8x8_t prime = (int8x8_t)v22;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v9 = a1[1];
    if (*(void *)&prime > v9) {
      goto LABEL_33;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v31 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v9 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (*(void *)&prime <= v31) {
        int8x8_t prime = (int8x8_t)v31;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v25 = operator new(8 * *(void *)&prime);
          unint64_t v26 = (void *)*a1;
          *a1 = (uint64_t)v25;
          if (v26) {
            operator delete(v26);
          }
          uint64_t v27 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v27++) = 0;
          while (*(void *)&prime != v27);
          unint64_t v28 = (void *)*v18;
          if (*v18)
          {
            unint64_t v29 = v28[1];
            uint8x8_t v30 = (uint8x8_t)vcnt_s8(prime);
            v30.i16[0] = vaddlv_u8(v30);
            if (v30.u32[0] > 1uLL)
            {
              if (v29 >= *(void *)&prime) {
                v29 %= *(void *)&prime;
              }
            }
            else
            {
              v29 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v29) = v18;
            uint64_t v34 = (void *)*v28;
            if (*v28)
            {
              do
              {
                unint64_t v35 = v34[1];
                if (v30.u32[0] > 1uLL)
                {
                  if (v35 >= *(void *)&prime) {
                    v35 %= *(void *)&prime;
                  }
                }
                else
                {
                  v35 &= *(void *)&prime - 1;
                }
                if (v35 != v29)
                {
                  if (!*(void *)(*a1 + 8 * v35))
                  {
                    *(void *)(*a1 + 8 * v35) = v28;
                    goto LABEL_58;
                  }
                  *unint64_t v28 = *v34;
                  *uint64_t v34 = **(void **)(*a1 + 8 * v35);
                  **(void **)(*a1 + 8 * v35) = v34;
                  uint64_t v34 = v28;
                }
                unint64_t v35 = v29;
LABEL_58:
                unint64_t v28 = v34;
                uint64_t v34 = (void *)*v34;
                unint64_t v29 = v35;
              }
              while (v34);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_62;
        }
        size_t v40 = (void *)*a1;
        *a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v9 = 0;
        a1[1] = 0;
      }
    }
LABEL_62:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v36 = *a1;
  unint64_t v37 = *(void **)(*a1 + 8 * v3);
  if (v37)
  {
    *(void *)float v13 = *v37;
LABEL_75:
    *unint64_t v37 = v13;
    goto LABEL_76;
  }
  *(void *)float v13 = *v18;
  *uint64_t v18 = v13;
  *(void *)(v36 + 8 * v3) = v18;
  if (*(void *)v13)
  {
    unint64_t v38 = *(void *)(*(void *)v13 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v38 >= v9) {
        v38 %= v9;
      }
    }
    else
    {
      v38 &= v9 - 1;
    }
    unint64_t v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_75;
  }
LABEL_76:
  ++a1[3];
  return v13;
}

void sub_1A3F8EA48(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,float>,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

vision::mod::ImageAnalyzer *vision::mod::ImageAnalyzer::analyzeUsingCVPixelBuffer(vision::mod::ImageAnalyzer *this, int a2, __CVBuffer *a3)
{
  uint64_t v5 = (uint64_t *)((char *)this + 824);
  unint64_t v6 = (uint64_t *)*((void *)this + 105);
  if (v6)
  {
    unint64_t v7 = (void *)((char *)this + 840);
    unint64_t v8 = *((void *)this + 104);
    do
    {
      unint64_t v9 = *((unsigned int *)v6 + 4);
      if (v8)
      {
        uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
        v10.i16[0] = vaddlv_u8(v10);
        if (v10.u32[0] > 1uLL)
        {
          unint64_t v3 = *((unsigned int *)v6 + 4);
          if (v8 <= v9) {
            unint64_t v3 = v9 % v8;
          }
        }
        else
        {
          unint64_t v3 = (v8 - 1) & v9;
        }
        unint64_t v11 = *(void ***)(*v5 + 8 * v3);
        if (v11)
        {
          float v12 = *v11;
          if (*v11)
          {
            do
            {
              unint64_t v13 = v12[1];
              if (v13 == v9)
              {
                if (*((_DWORD *)v12 + 4) == v9) {
                  goto LABEL_41;
                }
              }
              else
              {
                if (v10.u32[0] > 1uLL)
                {
                  if (v13 >= v8) {
                    v13 %= v8;
                  }
                }
                else
                {
                  v13 &= v8 - 1;
                }
                if (v13 != v3) {
                  break;
                }
              }
              float v12 = (void *)*v12;
            }
            while (v12);
          }
        }
      }
      float v12 = operator new(0x18uLL);
      *float v12 = 0;
      v12[1] = v9;
      *((_DWORD *)v12 + 4) = *((_DWORD *)v6 + 4);
      *((unsigned char *)v12 + 20) = 0;
      float v14 = (float)(unint64_t)(*((void *)this + 106) + 1);
      float v15 = *((float *)this + 214);
      if (!v8 || (float)(v15 * (float)v8) < v14)
      {
        BOOL v16 = (v8 & (v8 - 1)) != 0;
        if (v8 < 3) {
          BOOL v16 = 1;
        }
        unint64_t v17 = v16 | (2 * v8);
        unint64_t v18 = vcvtps_u32_f32(v14 / v15);
        if (v17 <= v18) {
          size_t v19 = v18;
        }
        else {
          size_t v19 = v17;
        }
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>((uint64_t)v5, v19);
        unint64_t v8 = *((void *)this + 104);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v8 <= v9) {
            unint64_t v3 = v9 % v8;
          }
          else {
            unint64_t v3 = v9;
          }
        }
        else
        {
          unint64_t v3 = (v8 - 1) & v9;
        }
      }
      uint64_t v20 = *v5;
      BOOL v21 = *(void **)(*v5 + 8 * v3);
      if (v21)
      {
        *float v12 = *v21;
      }
      else
      {
        *float v12 = *v7;
        void *v7 = v12;
        *(void *)(v20 + 8 * v3) = v7;
        if (!*v12) {
          goto LABEL_40;
        }
        unint64_t v22 = *(void *)(*v12 + 8);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v22 >= v8) {
            v22 %= v8;
          }
        }
        else
        {
          v22 &= v8 - 1;
        }
        BOOL v21 = (void *)(*v5 + 8 * v22);
      }
      *BOOL v21 = v12;
LABEL_40:
      ++*((void *)this + 106);
LABEL_41:
      *((unsigned char *)v12 + 20) = 0;
      unint64_t v6 = (uint64_t *)*v6;
    }
    while (v6);
  }
  uint64_t v178 = (uint64_t)v5;
  int v180 = (void *)((char *)this + 720);
  unint64_t v23 = (uint64_t *)*((void *)this + 90);
  if (!v23) {
    goto LABEL_216;
  }
  float v188 = (uint64_t *)((char *)this + 784);
  int v184 = (uint64_t *)((char *)this + 704);
  BOOL v186 = (void *)((char *)this + 864);
  std::string::size_type v182 = *(void *)(MEMORY[0x1E4FBA418] + 24);
  std::string::size_type v183 = *MEMORY[0x1E4FBA418];
  std::vector<int>::pointer v181 = (void *)((char *)this + 800);
  __n128 v177 = (void *)((char *)this + 744);
  size_t v179 = (unsigned __int8 *)this + 216;
  do
  {
    uint64_t v25 = (unsigned int *)(v23 + 2);
    unint64_t v24 = *((unsigned int *)v23 + 4);
    if (!v24) {
      goto LABEL_49;
    }
    int v26 = -1;
    unsigned int v27 = *((_DWORD *)v23 + 4);
    do
    {
      ++v26;
      BOOL v29 = v27 > 1;
      v27 >>= 1;
    }
    while (v29);
    if (v26 == -1) {
LABEL_49:
    }
      int v28 = 0;
    else {
      int v28 = 1 << v26;
    }
    BOOL v29 = (v28 & a2) != 0 || v24 > 0x2000;
    char v30 = !v29;
    if v24 == 64 || (v30) {
      goto LABEL_215;
    }
    if (*((char *)v23 + 47) < 0)
    {
      if (!v23[4])
      {
LABEL_296:
        exceptiouint64_t n = __cxa_allocate_exception(8uLL);
        uint64_t v175 = 8574;
        goto LABEL_297;
      }
    }
    else if (!*((unsigned char *)v23 + 47))
    {
      goto LABEL_296;
    }
    unint64_t v31 = *((void *)this + 99);
    if (v31)
    {
      uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v31);
      v32.i16[0] = vaddlv_u8(v32);
      if (v32.u32[0] > 1uLL)
      {
        unint64_t v3 = *((unsigned int *)v23 + 4);
        if (v31 <= v24) {
          unint64_t v3 = v24 % v31;
        }
      }
      else
      {
        unint64_t v3 = (v31 - 1) & v24;
      }
      uint64_t v33 = *(uint64_t ***)(*v188 + 8 * v3);
      if (v33)
      {
        for (uint64_t i = *v33; i; uint64_t i = (uint64_t *)*i)
        {
          unint64_t v35 = i[1];
          if (v35 == v24)
          {
            if (*((_DWORD *)i + 4) == v24) {
              goto LABEL_100;
            }
          }
          else
          {
            if (v32.u32[0] > 1uLL)
            {
              if (v35 >= v31) {
                v35 %= v31;
              }
            }
            else
            {
              v35 &= v31 - 1;
            }
            if (v35 != v3) {
              break;
            }
          }
        }
      }
    }
    uint64_t v36 = (char *)operator new(0xC0uLL);
    *(void *)uint64_t v36 = 0;
    *((void *)v36 + 1) = v24;
    *((_DWORD *)v36 + 4) = *v25;
    *((void *)v36 + 23) = 0;
    *(_OWORD *)(v36 + 168) = 0u;
    *(_OWORD *)(v36 + 152) = 0u;
    *(_OWORD *)(v36 + 136) = 0u;
    *(_OWORD *)(v36 + 120) = 0u;
    *(_OWORD *)(v36 + 104) = 0u;
    *(_OWORD *)(v36 + 88) = 0u;
    *(_OWORD *)(v36 + 72) = 0u;
    *(_OWORD *)(v36 + 56) = 0u;
    *(_OWORD *)(v36 + 40) = 0u;
    *(_OWORD *)(v36 + 24) = 0u;
    float v37 = (float)(unint64_t)(*((void *)this + 101) + 1);
    float v38 = *((float *)this + 204);
    if (!v31 || (float)(v38 * (float)v31) < v37)
    {
      BOOL v39 = (v31 & (v31 - 1)) != 0;
      if (v31 < 3) {
        BOOL v39 = 1;
      }
      unint64_t v40 = v39 | (2 * v31);
      unint64_t v41 = vcvtps_u32_f32(v37 / v38);
      if (v40 <= v41) {
        size_t v42 = v41;
      }
      else {
        size_t v42 = v40;
      }
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>((uint64_t)v188, v42);
      unint64_t v31 = *((void *)this + 99);
      if ((v31 & (v31 - 1)) != 0)
      {
        if (v31 <= v24) {
          unint64_t v3 = v24 % v31;
        }
        else {
          unint64_t v3 = v24;
        }
      }
      else
      {
        unint64_t v3 = (v31 - 1) & v24;
      }
    }
    uint64_t v43 = *v188;
    float v44 = *(void **)(*v188 + 8 * v3);
    if (v44)
    {
      *(void *)uint64_t v36 = *v44;
    }
    else
    {
      *(void *)uint64_t v36 = *v181;
      *std::vector<int>::pointer v181 = v36;
      *(void *)(v43 + 8 * v3) = v181;
      if (!*(void *)v36) {
        goto LABEL_99;
      }
      unint64_t v45 = *(void *)(*(void *)v36 + 8);
      if ((v31 & (v31 - 1)) != 0)
      {
        if (v45 >= v31) {
          v45 %= v31;
        }
      }
      else
      {
        v45 &= v31 - 1;
      }
      float v44 = (void *)(*v188 + 8 * v45);
    }
    void *v44 = v36;
LABEL_99:
    ++*((void *)this + 101);
LABEL_100:
    if (espresso_network_bind_buffer()) {
      goto LABEL_295;
    }
    int8x8_t v46 = *(int8x8_t *)((char *)this + 872);
    if (!*(void *)&v46) {
      goto LABEL_215;
    }
    unint64_t v47 = *v25;
    uint8x8_t v48 = (uint8x8_t)vcnt_s8(v46);
    v48.i16[0] = vaddlv_u8(v48);
    if (v48.u32[0] > 1uLL)
    {
      unint64_t v49 = *v25;
      if (*(void *)&v46 <= v47) {
        unint64_t v49 = v47 % *(void *)&v46;
      }
    }
    else
    {
      unint64_t v49 = (v46.i32[0] - 1) & v47;
    }
    std::string::size_type v50 = *(uint64_t ***)(*v186 + 8 * v49);
    if (!v50) {
      goto LABEL_215;
    }
    std::string::size_type v51 = *v50;
    if (!v51) {
      goto LABEL_215;
    }
    while (1)
    {
      unint64_t v52 = v51[1];
      if (v52 == v47) {
        break;
      }
      if (v48.u32[0] > 1uLL)
      {
        if (v52 >= *(void *)&v46) {
          v52 %= *(void *)&v46;
        }
      }
      else
      {
        v52 &= *(void *)&v46 - 1;
      }
      if (v52 != v49) {
        goto LABEL_215;
      }
LABEL_116:
      std::string::size_type v51 = (uint64_t *)*v51;
      if (!v51) {
        goto LABEL_215;
      }
    }
    if (*((_DWORD *)v51 + 4) != v47) {
      goto LABEL_116;
    }
    uint64_t v53 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType const&>,std::tuple<>>((uint64_t)v186, v47, (_DWORD *)v23 + 4);
    uint64_t v55 = v53[3];
    uint64_t v54 = v53[4];
    int v56 = *v25 & a2;
    if (v56 <= 31)
    {
      unint64_t v3 = 4;
      if (v56 == 2)
      {
        LODWORD(v192.__r_.__value_.__l.__data_) = 2;
        unint64_t v3 = 2;
        unint64_t v67 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)v188, 2u, &v192);
        uint64_t OutputSize = *((void *)v67 + 14)
                   * *((void *)v67 + 13)
                   * *((void *)v67 + 15)
                   * *((void *)v67 + 16)
                   * *((void *)v67 + 17);
        if (!std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v177, 2u))goto LABEL_151; {
        LODWORD(v192.__r_.__value_.__l.__data_) = 2;
        }
        long long v59 = (void *)((char *)this + 744);
        unsigned int v60 = 2;
      }
      else
      {
        if (v56 != 4) {
          goto LABEL_300;
        }
        LODWORD(v192.__r_.__value_.__l.__data_) = 4;
        uint64_t v61 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)v188, 4u, &v192);
        uint64_t OutputSize = *((void *)v61 + 14)
                   * *((void *)v61 + 13)
                   * *((void *)v61 + 15)
                   * *((void *)v61 + 16)
                   * *((void *)v61 + 17);
        if (!std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v177, 2u))goto LABEL_151; {
        LODWORD(v192.__r_.__value_.__l.__data_) = 4;
        }
        long long v59 = (void *)((char *)this + 744);
        unsigned int v60 = 4;
      }
LABEL_135:
      unint64_t v68 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v59, v60, &v192);
      uint64_t OutputSize = vision::mod::ImageAnalyzer_PostProcessor::getOutputSize((vision::mod::ImageAnalyzer_PostProcessor *)(v68 + 3), OutputSize);
      goto LABEL_151;
    }
    unint64_t v3 = 4096;
    if (v56 == 32)
    {
      LODWORD(v192.__r_.__value_.__l.__data_) = 32;
      uint64_t OutputSize = *((void *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)v188, 0x20u, &v192)+ 15);
      goto LABEL_151;
    }
    if (v56 != 64)
    {
      if (v56 != 4096) {
        goto LABEL_300;
      }
      LODWORD(v192.__r_.__value_.__l.__data_) = 4096;
      long long v57 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)v188, 0x1000u, &v192);
      uint64_t OutputSize = *((void *)v57 + 14)
                 * *((void *)v57 + 13)
                 * *((void *)v57 + 15)
                 * *((void *)v57 + 16)
                 * *((void *)v57 + 17);
      if (!std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v177, 0x1000u))goto LABEL_151; {
      LODWORD(v192.__r_.__value_.__l.__data_) = 4096;
      }
      long long v59 = (void *)((char *)this + 744);
      unsigned int v60 = 4096;
      goto LABEL_135;
    }
    if (!*((unsigned char *)this + 461))
    {
      uint64_t OutputSize = *(void *)(**((void **)this + 118) + 264);
      goto LABEL_151;
    }
    uint64_t v176 = v53[4];
    unint64_t v62 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)v179);
    int8x8_t v63 = *(int8x8_t *)((char *)this + 976);
    if (!*(void *)&v63) {
      goto LABEL_298;
    }
    unint64_t v64 = v62;
    uint8x8_t v65 = (uint8x8_t)vcnt_s8(v63);
    v65.i16[0] = vaddlv_u8(v65);
    unint64_t v3 = v65.u32[0];
    if (v65.u32[0] > 1uLL)
    {
      unint64_t v66 = v62;
      if (v62 >= *(void *)&v63) {
        unint64_t v66 = v62 % *(void *)&v63;
      }
    }
    else
    {
      unint64_t v66 = (*(void *)&v63 - 1) & v62;
    }
    int v69 = *(unsigned __int8 ***)(*((void *)this + 121) + 8 * v66);
    if (!v69 || (int v70 = *v69) == 0) {
LABEL_298:
    }
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
    while (2)
    {
      unint64_t v71 = *((void *)v70 + 1);
      if (v71 != v64)
      {
        if (v3 > 1)
        {
          if (v71 >= *(void *)&v63) {
            v71 %= *(void *)&v63;
          }
        }
        else
        {
          v71 &= *(void *)&v63 - 1;
        }
        if (v71 != v66) {
          goto LABEL_298;
        }
LABEL_149:
        int v70 = *(unsigned __int8 **)v70;
        if (!v70) {
          goto LABEL_298;
        }
        continue;
      }
      break;
    }
    if (!std::equal_to<std::string>::operator()[abi:ne180100](v70 + 16, v179)) {
      goto LABEL_149;
    }
    uint64_t OutputSize = *((void *)v70 + 17);
    uint64_t v54 = v176;
LABEL_151:
    if (v54 == v55)
    {
      if (!OutputSize) {
        goto LABEL_215;
      }
      uint64_t v73 = 0;
      while (2)
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v192);
        unint64_t v74 = *v25;
        unint64_t v75 = *((void *)this + 89);
        if (v75)
        {
          uint8x8_t v76 = (uint8x8_t)vcnt_s8((int8x8_t)v75);
          v76.i16[0] = vaddlv_u8(v76);
          if (v76.u32[0] > 1uLL)
          {
            unint64_t v3 = *v25;
            if (v75 <= v74) {
              unint64_t v3 = v74 % v75;
            }
          }
          else
          {
            unint64_t v3 = (v75 - 1) & v74;
          }
          uint8x8_t v77 = *(void ***)(*v184 + 8 * v3);
          if (v77)
          {
            uint64_t v78 = *v77;
            if (*v77)
            {
              do
              {
                unint64_t v79 = v78[1];
                if (v79 == v74)
                {
                  if (*((_DWORD *)v78 + 4) == v74) {
                    goto LABEL_194;
                  }
                }
                else
                {
                  if (v76.u32[0] > 1uLL)
                  {
                    if (v79 >= v75) {
                      v79 %= v75;
                    }
                  }
                  else
                  {
                    v79 &= v75 - 1;
                  }
                  if (v79 != v3) {
                    break;
                  }
                }
                uint64_t v78 = (void *)*v78;
              }
              while (v78);
            }
          }
        }
        uint64_t v78 = operator new(0x30uLL);
        *uint64_t v78 = 0;
        v78[1] = v74;
        *((_DWORD *)v78 + 4) = *v25;
        v78[4] = 0;
        v78[5] = 0;
        v78[3] = 0;
        float v80 = (float)(unint64_t)(*((void *)this + 91) + 1);
        float v81 = *((float *)this + 184);
        if (!v75 || (float)(v81 * (float)v75) < v80)
        {
          BOOL v82 = (v75 & (v75 - 1)) != 0;
          if (v75 < 3) {
            BOOL v82 = 1;
          }
          unint64_t v83 = v82 | (2 * v75);
          unint64_t v84 = vcvtps_u32_f32(v80 / v81);
          if (v83 <= v84) {
            size_t v85 = v84;
          }
          else {
            size_t v85 = v83;
          }
          std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>((uint64_t)v184, v85);
          unint64_t v75 = *((void *)this + 89);
          if ((v75 & (v75 - 1)) != 0)
          {
            if (v75 <= v74) {
              unint64_t v3 = v74 % v75;
            }
            else {
              unint64_t v3 = v74;
            }
          }
          else
          {
            unint64_t v3 = (v75 - 1) & v74;
          }
        }
        uint64_t v86 = *v184;
        unint64_t v87 = *(void **)(*v184 + 8 * v3);
        if (v87)
        {
          *uint64_t v78 = *v87;
          goto LABEL_192;
        }
        *uint64_t v78 = *v180;
        *int v180 = v78;
        *(void *)(v86 + 8 * v3) = v180;
        if (*v78)
        {
          unint64_t v88 = *(void *)(*v78 + 8);
          if ((v75 & (v75 - 1)) != 0)
          {
            if (v88 >= v75) {
              v88 %= v75;
            }
          }
          else
          {
            v88 &= v75 - 1;
          }
          unint64_t v87 = (void *)(*v184 + 8 * v88);
LABEL_192:
          *unint64_t v87 = v78;
        }
        ++*((void *)this + 91);
LABEL_194:
        uint64_t v91 = v78[3];
        uint64_t v90 = (char *)(v78 + 3);
        uint64_t v89 = v91;
        int v92 = v90[23];
        if (v92 >= 0) {
          uint64_t v93 = (uint64_t)v90;
        }
        else {
          uint64_t v93 = v89;
        }
        if (v92 >= 0) {
          uint64_t v94 = v90[23];
        }
        else {
          uint64_t v94 = *((void *)v90 + 1);
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v192, v93, v94);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v192, (uint64_t)"-", 1);
        std::ostream::operator<<();
        char v95 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType const&>,std::tuple<>>((uint64_t)v186, *v25, (_DWORD *)v23 + 4);
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&__dst, (uint64_t)&v192.__r_.__value_.__l.__size_);
        unint64_t v96 = v95[5];
        unint64_t v97 = v95[4];
        if (v97 >= v96)
        {
          uint64_t v99 = v95[3];
          unint64_t v100 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v97 - v99) >> 3);
          unint64_t v101 = v100 + 1;
          if (v100 + 1 > 0xAAAAAAAAAAAAAAALL) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v102 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v96 - v99) >> 3);
          if (2 * v102 > v101) {
            unint64_t v101 = 2 * v102;
          }
          if (v102 >= 0x555555555555555) {
            unint64_t v103 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v103 = v101;
          }
          __v.__end_cap_.__value_ = (std::allocator<std::string> *)(v95 + 5);
          if (v103) {
            unint64_t v103 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v103);
          }
          else {
            uint64_t v104 = 0;
          }
          uint64_t v105 = (std::string *)(v103 + 24 * v100);
          __v.__first_ = (std::__split_buffer<std::string>::pointer)v103;
          __v.__begin_ = v105;
          __v.__end_cap_.__value_ = (std::string *)(v103 + 24 * v104);
          *(_OWORD *)&v105->__r_.__value_.__l.__data_ = __dst;
          v105->__r_.__value_.__r.__words[2] = v191;
          long long __dst = 0uLL;
          std::string::size_type v191 = 0;
          __v.__end_ = v105 + 1;
          std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)v95 + 1, &__v);
          unint64_t v98 = v95[4];
          std::__split_buffer<std::string>::~__split_buffer(&__v);
        }
        else
        {
          *(_OWORD *)unint64_t v97 = __dst;
          *(void *)(v97 + 16) = v191;
          unint64_t v98 = v97 + 24;
        }
        v95[4] = v98;
        v192.__r_.__value_.__r.__words[0] = v183;
        *(std::string::size_type *)((char *)v192.__r_.__value_.__r.__words + *(void *)(v183 - 24)) = v182;
        v192.__r_.__value_.__l.__size_ = MEMORY[0x1E4FBA470] + 16;
        if (v194 < 0) {
          operator delete(__p);
        }
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        MEMORY[0x1A6256200](&v195);
        if (++v73 == OutputSize) {
          goto LABEL_215;
        }
        continue;
      }
    }
    uint64_t v72 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType const&>,std::tuple<>>((uint64_t)v186, *v25, (_DWORD *)v23 + 4);
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v72[4] - v72[3]) >> 3) != OutputSize)
    {
LABEL_300:
      exceptiouint64_t n = __cxa_allocate_exception(8uLL);
      uint64_t v175 = 8572;
LABEL_297:
      *exceptiouint64_t n = v175;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
LABEL_215:
    unint64_t v23 = (uint64_t *)*v23;
  }
  while (v23);
LABEL_216:
  if ((a2 & 0x40) == 0) {
    goto LABEL_275;
  }
  if (!*((unsigned char *)this + 461))
  {
    unint64_t v106 = *((void *)this + 54);
    uint64_t v107 = (void *)*((void *)this + 119);
    uint64_t v108 = (void *)*((void *)this + 118);
    unint64_t v109 = 0xAAAAAAAAAAAAAAABLL * (v107 - v108);
    unint64_t v110 = v106 - v109;
    if (v106 <= v109)
    {
      if (v106 < v109)
      {
        unsigned int v124 = &v108[3 * v106];
        if (v107 != v124)
        {
          std::string v125 = (void *)*((void *)this + 119);
          do
          {
            uint64_t v127 = (void *)*(v125 - 3);
            v125 -= 3;
            std::string v126 = v127;
            if (v127)
            {
              *(v107 - 2) = v126;
              operator delete(v126);
            }
            uint64_t v107 = v125;
          }
          while (v125 != v124);
        }
        *((void *)this + 119) = v124;
      }
    }
    else
    {
      uint64_t v111 = *((void *)this + 120);
      if (0xAAAAAAAAAAAAAAABLL * ((v111 - (uint64_t)v107) >> 3) >= v110)
      {
        bzero(*((void **)this + 119), 24 * ((24 * v110 - 24) / 0x18) + 24);
        *((void *)this + 119) = &v107[3 * ((24 * v110 - 24) / 0x18) + 3];
      }
      else
      {
        if (v106 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v112 = 0xAAAAAAAAAAAAAAABLL * ((v111 - (uint64_t)v108) >> 3);
        if (2 * v112 > v106) {
          unint64_t v106 = 2 * v112;
        }
        if (v112 >= 0x555555555555555) {
          unint64_t v106 = 0xAAAAAAAAAAAAAAALL;
        }
        if (v106 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v113 = 3 * v106;
        uint64_t v114 = (char *)operator new(24 * v106);
        uint64_t v115 = &v114[8 * (v107 - v108)];
        float v116 = &v114[8 * v113];
        size_t v117 = 24 * ((24 * v110 - 24) / 0x18) + 24;
        bzero(v115, v117);
        int v118 = &v115[v117];
        if (v107 == v108)
        {
          *((void *)this + 118) = v115;
          *((void *)this + 119) = v118;
          *((void *)this + 120) = v116;
        }
        else
        {
          do
          {
            *((void *)v115 - 3) = 0;
            *((void *)v115 - 2) = 0;
            v115 -= 24;
            *((void *)v115 + 2) = 0;
            long long v119 = *(_OWORD *)(v107 - 3);
            v107 -= 3;
            *(_OWORD *)uint64_t v115 = v119;
            *((void *)v115 + 2) = v107[2];
            *uint64_t v107 = 0;
            v107[1] = 0;
            v107[2] = 0;
          }
          while (v107 != v108);
          double v120 = (void *)*((void *)this + 118);
          uint64_t v107 = (void *)*((void *)this + 119);
          *((void *)this + 118) = v115;
          *((void *)this + 119) = v118;
          *((void *)this + 120) = v116;
          if (v107 != v120)
          {
            uint64_t v121 = v107;
            do
            {
              OSStatus v123 = (void *)*(v121 - 3);
              v121 -= 3;
              double v122 = v123;
              if (v123)
              {
                *(v107 - 2) = v122;
                operator delete(v122);
              }
              uint64_t v107 = v121;
            }
            while (v121 != v120);
            uint64_t v107 = v120;
          }
        }
        if (v107) {
          operator delete(v107);
        }
      }
    }
    if (!*((void *)this + 54)) {
      goto LABEL_275;
    }
    uint64_t v128 = 0;
    while (1)
    {
      uint64_t v129 = *((void *)this + 118);
      BOOL v130 = (void *)(v129 + 24 * v128);
      size_t v132 = (void **)(v130 + 1);
      uint64_t v131 = (char *)v130[1];
      size_t v133 = (char *)*v130;
      uint64_t v134 = (uint64_t)&v131[-*v130];
      unint64_t v135 = 0xCF3CF3CF3CF3CF3DLL * (v134 >> 3);
      if (v135 > 1)
      {
        if (v134 == 336) {
          goto LABEL_266;
        }
        float v159 = v133 + 336;
      }
      else
      {
        uint64_t v136 = v129 + 24 * v128;
        uint64_t v139 = *(void *)(v136 + 16);
        int v138 = (void *)(v136 + 16);
        uint64_t v137 = v139;
        if (0xCF3CF3CF3CF3CF3DLL * ((v139 - (uint64_t)v131) >> 3) < 2 - v135)
        {
          int v185 = v138;
          unint64_t v140 = 0xCF3CF3CF3CF3CF3DLL * ((v137 - (uint64_t)v133) >> 3);
          uint64_t v141 = 2 * v140;
          if (2 * v140 <= 2) {
            uint64_t v141 = 2;
          }
          if (v140 >= 0xC30C30C30C30C3) {
            unint64_t v142 = 0x186186186186186;
          }
          else {
            unint64_t v142 = v141;
          }
          float v143 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<espresso_buffer_t>>(v142);
          uint64_t v187 = v144;
          int v145 = &v143[8 * (v134 >> 3)];
          uint64_t v146 = v143;
          size_t v147 = 168 * ((168 - v134) / 0xA8uLL) + 168;
          bzero(v145, v147);
          signed int v148 = (char *)*v132;
          int v149 = (char *)*v130;
          float v150 = v145;
          if (*v132 != (void *)*v130)
          {
            do
            {
              long long v151 = *(_OWORD *)(v148 - 168);
              long long v152 = *(_OWORD *)(v148 - 152);
              *(_OWORD *)(v150 - 136) = *(_OWORD *)(v148 - 136);
              *(_OWORD *)(v150 - 152) = v152;
              *(_OWORD *)(v150 - 168) = v151;
              long long v153 = *(_OWORD *)(v148 - 120);
              long long v154 = *(_OWORD *)(v148 - 104);
              long long v155 = *(_OWORD *)(v148 - 88);
              *(_OWORD *)(v150 - 72) = *(_OWORD *)(v148 - 72);
              *(_OWORD *)(v150 - 88) = v155;
              *(_OWORD *)(v150 - 104) = v154;
              *(_OWORD *)(v150 - 120) = v153;
              long long v156 = *(_OWORD *)(v148 - 56);
              long long v157 = *(_OWORD *)(v148 - 40);
              long long v158 = *(_OWORD *)(v148 - 24);
              *((void *)v150 - 1) = *((void *)v148 - 1);
              *(_OWORD *)(v150 - 24) = v158;
              *(_OWORD *)(v150 - 40) = v157;
              *(_OWORD *)(v150 - 56) = v156;
              v150 -= 168;
              v148 -= 168;
            }
            while (v148 != v149);
            signed int v148 = (char *)*v130;
          }
          *BOOL v130 = v150;
          float *v132 = &v145[v147];
          *int v185 = &v146[168 * v187];
          if (v148) {
            operator delete(v148);
          }
          goto LABEL_266;
        }
        bzero(v131, 168 * ((168 - v134) / 0xA8uLL) + 168);
        float v159 = &v131[168 * ((168 - v134) / 0xA8uLL) + 168];
      }
      float *v132 = v159;
LABEL_266:
      uint64_t v160 = 0;
      char v161 = 1;
      do
      {
        char v162 = v161;
        uint64_t v163 = *(void *)(*((void *)this + 64) + 24 * v128) + 24 * v160;
        if (*(char *)(v163 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v192, *(const std::string::value_type **)v163, *(void *)(v163 + 8));
        }
        else
        {
          long long v164 = *(_OWORD *)v163;
          v192.__r_.__value_.__r.__words[2] = *(void *)(v163 + 16);
          *(_OWORD *)&v192.__r_.__value_.__l.__data_ = v164;
        }
        if (espresso_network_bind_buffer())
        {
          espresso_plan_get_error_info();
          int v173 = __cxa_allocate_exception(8uLL);
          *int v173 = 8539;
          __cxa_throw(v173, MEMORY[0x1E4FBA3E0], 0);
        }
        if (SHIBYTE(v192.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v192.__r_.__value_.__l.__data_);
        }
        char v161 = 0;
        uint64_t v160 = 1;
      }
      while ((v162 & 1) != 0);
      if ((unint64_t)++v128 >= *((void *)this + 54)) {
        goto LABEL_275;
      }
    }
  }
  v192.__r_.__value_.__r.__words[0] = (std::string::size_type)this + 216;
  std::__hash_table<std::__hash_value_type<std::string,espresso_buffer_t>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,espresso_buffer_t>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t *)this + 121, (unsigned __int8 *)this + 216, (long long **)&v192);
  if (espresso_network_bind_buffer()) {
    goto LABEL_295;
  }
  v192.__r_.__value_.__r.__words[0] = (std::string::size_type)this + 240;
  std::__hash_table<std::__hash_value_type<std::string,espresso_buffer_t>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,espresso_buffer_t>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t *)this + 121, (unsigned __int8 *)this + 240, (long long **)&v192);
  if (espresso_network_bind_buffer()) {
    goto LABEL_295;
  }
LABEL_275:
  if (espresso_network_bind_cvpixelbuffer() || espresso_plan_execute_sync())
  {
LABEL_295:
    espresso_plan_get_error_info();
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    uint64_t v175 = 8539;
    goto LABEL_297;
  }
  float v165 = (uint64_t *)*v180;
  if (*v180)
  {
    do
    {
      unsigned int v166 = *((_DWORD *)v165 + 4);
      if (!v166) {
        goto LABEL_283;
      }
      int v167 = -1;
      unsigned int v168 = *((_DWORD *)v165 + 4);
      do
      {
        ++v167;
        BOOL v29 = v168 > 1;
        v168 >>= 1;
      }
      while (v29);
      if (v167 == -1) {
LABEL_283:
      }
        int v169 = 0;
      else {
        int v169 = 1 << v167;
      }
      if ((v169 & a2) != 0)
      {
        if (!v166) {
          goto LABEL_290;
        }
        int v170 = -1;
        do
        {
          ++v170;
          BOOL v29 = v166 > 1;
          v166 >>= 1;
        }
        while (v29);
        if (v170 == -1) {
LABEL_290:
        }
          unsigned int v171 = 0;
        else {
          unsigned int v171 = 1 << v170;
        }
        LODWORD(v192.__r_.__value_.__l.__data_) = v171;
        *((unsigned char *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v178, v171, &v192)+ 20) = 1;
      }
      float v165 = (uint64_t *)*v165;
    }
    while (v165);
  }
  return this;
}

void sub_1A3F8FDC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a30);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, long long **a3)
{
  unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    float v12 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      unint64_t v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = *((void *)v13 + 1);
          if (v14 == v8)
          {
            if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v13 + 16, a2)) {
              return v13;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3) {
              break;
            }
          }
          unint64_t v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  float v15 = (void *)(a1 + 16);
  unint64_t v13 = (char *)operator new(0x40uLL);
  v29[0] = v13;
  v29[1] = a1 + 16;
  char v30 = 0;
  *(void *)unint64_t v13 = 0;
  *((void *)v13 + 1) = v8;
  BOOL v16 = (std::string *)(v13 + 16);
  unint64_t v17 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v16, *(const std::string::value_type **)v17, *((void *)v17 + 1));
  }
  else
  {
    long long v18 = *v17;
    *((void *)v13 + 4) = *((void *)v17 + 2);
    *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v18;
  }
  *((void *)v13 + 5) = 0;
  *((void *)v13 + 6) = 0;
  *((void *)v13 + 7) = 0;
  char v30 = 1;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    BOOL v21 = 1;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v24);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v25 = *(void *)a1;
  int v26 = *(void **)(*(void *)a1 + 8 * v3);
  if (v26)
  {
    *(void *)unint64_t v13 = *v26;
LABEL_41:
    *int v26 = v13;
    goto LABEL_42;
  }
  *(void *)unint64_t v13 = *v15;
  *float v15 = v13;
  *(void *)(v25 + 8 * v3) = v15;
  if (*(void *)v13)
  {
    unint64_t v27 = *(void *)(*(void *)v13 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v27 >= v9) {
        v27 %= v9;
      }
    }
    else
    {
      v27 &= v9 - 1;
    }
    int v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_41;
  }
LABEL_42:
  v29[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v29);
  return v13;
}

void sub_1A3F900A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<std::tuple<float,_Geometry2D_rect2D_>>::reserve(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 2) <= 0x18)
  {
    unint64_t v3 = *(unsigned char **)(a1 + 8);
    uint64_t v4 = (char *)operator new(0x1F4uLL);
    uint64_t v5 = &v4[20 * ((v3 - v1) / 20)];
    unint64_t v6 = v5;
    if (v3 != v1)
    {
      unint64_t v7 = &v4[20 * ((v3 - v1) / 20)];
      do
      {
        unint64_t v6 = v7 - 20;
        long long v8 = *(_OWORD *)(v3 - 20);
        *((_DWORD *)v7 - 1) = *((_DWORD *)v3 - 1);
        *(_OWORD *)(v7 - 20) = v8;
        v3 -= 20;
        v7 -= 20;
      }
      while (v3 != v1);
    }
    *(void *)a1 = v6;
    *(void *)(a1 + 8) = v5;
    *(void *)(a1 + 16) = v4 + 500;
    if (v1)
    {
      operator delete(v1);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<float,_Geometry2D_rect2D_>>>(unint64_t a1)
{
  if (a1 >= 0xCCCCCCCCCCCCCCDLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(20 * a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<float>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

BOOL vision::mod::sortDetectionsByConfidence(float *a1, float *a2)
{
  return *a1 > *a2;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*,false>(unint64_t a1, int *a2, uint64_t (**a3)(long long *, long long *), uint64_t a4, char a5)
{
  while (2)
  {
    long long v152 = a2 - 5;
    int v149 = (long long *)(a2 - 15);
    float v150 = (long long *)(a2 - 10);
    unint64_t v10 = a1;
    long long v156 = a2;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)((uint64_t)a2 - v10) >> 2);
          if (v6 || !v5)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                int v69 = *a3;
                int v70 = v152[4];
                long long v164 = *(_OWORD *)v152;
                int v165 = v70;
                int v71 = *(_DWORD *)(a1 + 16);
                long long v162 = *(_OWORD *)a1;
                int v163 = v71;
                if (v69(&v164, &v162))
                {
                  int v72 = *(_DWORD *)a1;
                  *(_DWORD *)a1 = *(a2 - 5);
                  *(a2 - 5) = v72;
                  *(_OWORD *)int v180 = *(_OWORD *)(a1 + 4);
                  *(_OWORD *)(a1 + 4) = *((_OWORD *)a2 - 1);
                  *((_OWORD *)a2 - 1) = *(_OWORD *)v180;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((long long *)a1, (long long *)(a1 + 20), (long long *)v152, a3);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((int *)a1, (long long *)(a1 + 20), (long long *)(a1 + 40), (long long *)v152, a3);
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((long long *)a1, (long long *)(a1 + 20), (long long *)(a1 + 40), (long long *)(a1 + 60), (long long *)v152, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 479)
          {
            if (a5)
            {
              if ((int *)a1 != a2)
              {
                unint64_t v73 = a1 + 20;
                if ((int *)(a1 + 20) != a2)
                {
                  uint64_t v74 = 0;
                  unint64_t v75 = a1;
                  do
                  {
                    unint64_t v76 = v73;
                    uint8x8_t v77 = *a3;
                    int v78 = *(_DWORD *)(v76 + 16);
                    *(_OWORD *)int v180 = *(_OWORD *)v76;
                    *(_DWORD *)&v180[16] = v78;
                    int v79 = *(_DWORD *)(v75 + 16);
                    *(_OWORD *)size_t v179 = *(_OWORD *)v75;
                    *(_DWORD *)&v179[16] = v79;
                    if (v77((long long *)v180, (long long *)v179))
                    {
                      int v80 = *(_DWORD *)v76;
                      *(_OWORD *)uint64_t v176 = *(_OWORD *)(v75 + 24);
                      uint64_t v81 = v74;
                      while (1)
                      {
                        uint64_t v82 = v81;
                        uint64_t v83 = a1 + v81;
                        *(_DWORD *)(v83 + 20) = *(_DWORD *)v83;
                        *(_OWORD *)(v83 + 24) = *(_OWORD *)(v83 + 4);
                        if (!v82) {
                          break;
                        }
                        unint64_t v84 = *a3;
                        *(_DWORD *)uint64_t v178 = v80;
                        *(_OWORD *)&v178[4] = *(_OWORD *)v176;
                        long long v85 = *(_OWORD *)(v83 - 20);
                        *(_DWORD *)&v177[16] = *(_DWORD *)(v83 - 4);
                        *(_OWORD *)__n128 v177 = v85;
                        char v86 = v84((long long *)v178, (long long *)v177);
                        uint64_t v81 = v82 - 20;
                        if ((v86 & 1) == 0)
                        {
                          unint64_t v87 = (_DWORD *)(a1 + v82);
                          unint64_t v88 = (_OWORD *)(a1 + v82 + 4);
                          goto LABEL_73;
                        }
                      }
                      unint64_t v88 = (_OWORD *)(v83 + 4);
                      unint64_t v87 = (_DWORD *)a1;
LABEL_73:
                      *unint64_t v87 = v80;
                      *unint64_t v88 = *(_OWORD *)v176;
                    }
                    unint64_t v73 = v76 + 20;
                    v74 += 20;
                    unint64_t v75 = v76;
                  }
                  while ((int *)(v76 + 20) != a2);
                }
              }
            }
            else if ((int *)a1 != a2)
            {
              unint64_t v137 = a1 + 20;
              if ((int *)(a1 + 20) != a2)
              {
                int v138 = (_OWORD *)(a1 + 24);
                do
                {
                  unint64_t v139 = v137;
                  unint64_t v140 = *a3;
                  int v141 = *(_DWORD *)(v139 + 16);
                  *(_OWORD *)int v180 = *(_OWORD *)v139;
                  *(_DWORD *)&v180[16] = v141;
                  int v142 = *(_DWORD *)(a1 + 16);
                  *(_OWORD *)size_t v179 = *(_OWORD *)a1;
                  *(_DWORD *)&v179[16] = v142;
                  if (v140((long long *)v180, (long long *)v179))
                  {
                    int v143 = *(_DWORD *)v139;
                    *(_OWORD *)uint64_t v176 = *(_OWORD *)(a1 + 24);
                    uint64_t v144 = v138;
                    do
                    {
                      *((_DWORD *)v144 - 1) = *((_DWORD *)v144 - 6);
                      int v145 = (_OWORD *)((char *)v144 - 20);
                      *uint64_t v144 = *(_OWORD *)((char *)v144 - 20);
                      uint64_t v146 = *a3;
                      *(_DWORD *)uint64_t v178 = v143;
                      *(_OWORD *)&v178[4] = *(_OWORD *)v176;
                      long long v147 = *(_OWORD *)((char *)v144 - 44);
                      *(_DWORD *)&v177[16] = *((_DWORD *)v144 - 7);
                      *(_OWORD *)__n128 v177 = v147;
                      char v148 = v146((long long *)v178, (long long *)v177);
                      uint64_t v144 = v145;
                    }
                    while ((v148 & 1) != 0);
                    *((_DWORD *)v145 - 1) = v143;
                    *int v145 = *(_OWORD *)v176;
                  }
                  unint64_t v137 = v139 + 20;
                  int v138 = (_OWORD *)((char *)v138 + 20);
                  a1 = v139;
                }
                while ((int *)(v139 + 20) != a2);
              }
            }
            return;
          }
          if (!a4)
          {
            if ((int *)a1 != a2)
            {
              int64_t v89 = (v12 - 2) >> 1;
              int64_t v90 = v89;
              uint64_t v153 = v11;
              do
              {
                int64_t v91 = v90;
                if (v89 >= v90)
                {
                  int64_t v155 = v90;
                  uint64_t v92 = (2 * v90) | 1;
                  unint64_t v93 = a1 + 20 * v92;
                  uint64_t v94 = 2 * v90 + 2;
                  if (v94 < (uint64_t)v12)
                  {
                    char v95 = *a3;
                    int v96 = *(_DWORD *)(v93 + 16);
                    *(_OWORD *)int v180 = *(_OWORD *)v93;
                    *(_DWORD *)&v180[16] = v96;
                    int v97 = *(_DWORD *)(v93 + 36);
                    *(_OWORD *)size_t v179 = *(_OWORD *)(v93 + 20);
                    *(_DWORD *)&v179[16] = v97;
                    if (v95((long long *)v180, (long long *)v179))
                    {
                      v93 += 20;
                      uint64_t v92 = v94;
                    }
                  }
                  int64_t v91 = v155;
                  unint64_t v98 = a1 + 20 * v155;
                  uint64_t v99 = *a3;
                  int v100 = *(_DWORD *)(v93 + 16);
                  *(_OWORD *)uint64_t v178 = *(_OWORD *)v93;
                  *(_DWORD *)&v178[16] = v100;
                  int v101 = *(_DWORD *)(v98 + 16);
                  *(_OWORD *)__n128 v177 = *(_OWORD *)v98;
                  *(_DWORD *)&v177[16] = v101;
                  char v102 = v99((long long *)v178, (long long *)v177);
                  uint64_t v11 = v153;
                  if ((v102 & 1) == 0)
                  {
                    int v103 = *(_DWORD *)v98;
                    *(_OWORD *)unsigned int v171 = *(_OWORD *)(v98 + 4);
                    do
                    {
                      unint64_t v104 = v98;
                      unint64_t v98 = v93;
                      *(_DWORD *)unint64_t v104 = *(_DWORD *)v93;
                      *(_OWORD *)(v104 + 4) = *(_OWORD *)(v93 + 4);
                      if (v89 < v92) {
                        break;
                      }
                      uint64_t v105 = (2 * v92) | 1;
                      unint64_t v93 = a1 + 20 * v105;
                      uint64_t v106 = 2 * v92 + 2;
                      if (v106 < (uint64_t)v12)
                      {
                        uint64_t v107 = *a3;
                        int v108 = *(_DWORD *)(v93 + 16);
                        *(_OWORD *)uint64_t v176 = *(_OWORD *)v93;
                        *(_DWORD *)&v176[16] = v108;
                        int v109 = *(_DWORD *)(v93 + 36);
                        long long v174 = *(_OWORD *)(v93 + 20);
                        int v175 = v109;
                        if (v107((long long *)v176, &v174))
                        {
                          v93 += 20;
                          uint64_t v105 = v106;
                        }
                      }
                      unint64_t v110 = *a3;
                      int v111 = *(_DWORD *)(v93 + 16);
                      *(_OWORD *)int v173 = *(_OWORD *)v93;
                      *(_DWORD *)&v173[16] = v111;
                      *(_DWORD *)float32x4_t v172 = v103;
                      *(_OWORD *)&v172[4] = *(_OWORD *)v171;
                      uint64_t v92 = v105;
                    }
                    while (!v110((long long *)v173, (long long *)v172));
                    *(_DWORD *)unint64_t v98 = v103;
                    *(_OWORD *)(v98 + 4) = *(_OWORD *)v171;
                    uint64_t v11 = v153;
                    int64_t v91 = v155;
                  }
                }
                int64_t v90 = v91 - 1;
              }
              while (v91);
              int64_t v112 = v11 / 0x14uLL;
              uint64_t v113 = v156;
              do
              {
                uint64_t v114 = 0;
                int v115 = *(_DWORD *)a1;
                long long v174 = *(_OWORD *)(a1 + 4);
                uint64_t v116 = v112 - 2;
                long long v157 = v113;
                if (v112 < 2) {
                  uint64_t v116 = v112 - 1;
                }
                uint64_t v117 = v116 >> 1;
                unint64_t v118 = a1;
                do
                {
                  uint64_t v119 = v118 + 20 * v114 + 20;
                  uint64_t v120 = (2 * v114) | 1;
                  uint64_t v121 = 2 * v114 + 2;
                  if (v121 < v112)
                  {
                    double v122 = *a3;
                    int v123 = *(_DWORD *)(v119 + 16);
                    *(_OWORD *)int v180 = *(_OWORD *)v119;
                    *(_DWORD *)&v180[16] = v123;
                    int v124 = *(_DWORD *)(v119 + 36);
                    *(_OWORD *)size_t v179 = *(_OWORD *)(v119 + 20);
                    *(_DWORD *)&v179[16] = v124;
                    if (v122((long long *)v180, (long long *)v179))
                    {
                      v119 += 20;
                      uint64_t v120 = v121;
                    }
                  }
                  *(_DWORD *)unint64_t v118 = *(_DWORD *)v119;
                  *(_OWORD *)(v118 + 4) = *(_OWORD *)(v119 + 4);
                  unint64_t v118 = v119;
                  uint64_t v114 = v120;
                }
                while (v120 <= v117);
                std::string v125 = (_OWORD *)(v119 + 4);
                uint64_t v113 = v157 - 5;
                if ((int *)v119 == v157 - 5)
                {
                  *(_DWORD *)uint64_t v119 = v115;
                  *std::string v125 = v174;
                }
                else
                {
                  *(_DWORD *)uint64_t v119 = *(v157 - 5);
                  *std::string v125 = *((_OWORD *)v157 - 1);
                  *(v157 - 5) = v115;
                  *((_OWORD *)v157 - 1) = v174;
                  uint64_t v126 = v119 - a1 + 20;
                  if (v126 >= 21)
                  {
                    unint64_t v127 = (unint64_t)(-2 - 0x3333333333333333 * (v126 >> 2)) >> 1;
                    uint64_t v128 = a1 + 20 * v127;
                    uint64_t v129 = *a3;
                    int v130 = *(_DWORD *)(v128 + 16);
                    *(_OWORD *)int v180 = *(_OWORD *)v128;
                    *(_DWORD *)&v180[16] = v130;
                    int v131 = *(_DWORD *)(v119 + 16);
                    *(_OWORD *)size_t v179 = *(_OWORD *)v119;
                    *(_DWORD *)&v179[16] = v131;
                    if (v129((long long *)v180, (long long *)v179))
                    {
                      int v132 = *(_DWORD *)v119;
                      *(_OWORD *)uint64_t v176 = *v125;
                      do
                      {
                        uint64_t v133 = v119;
                        uint64_t v119 = v128;
                        *(_DWORD *)uint64_t v133 = *(_DWORD *)v128;
                        *(_OWORD *)(v133 + 4) = *(_OWORD *)(v128 + 4);
                        if (!v127) {
                          break;
                        }
                        unint64_t v127 = (v127 - 1) >> 1;
                        uint64_t v128 = a1 + 20 * v127;
                        uint64_t v134 = *a3;
                        int v135 = *(_DWORD *)(v128 + 16);
                        *(_OWORD *)uint64_t v178 = *(_OWORD *)v128;
                        *(_DWORD *)&v178[16] = v135;
                        *(_DWORD *)__n128 v177 = v132;
                        *(_OWORD *)&v177[4] = *(_OWORD *)v176;
                      }
                      while ((v134((long long *)v178, (long long *)v177) & 1) != 0);
                      *(_DWORD *)uint64_t v119 = v132;
                      *(_OWORD *)(v119 + 4) = *(_OWORD *)v176;
                    }
                  }
                }
              }
              while (v112-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = (long long *)(a1 + 20 * (v12 >> 1));
          if ((unint64_t)v11 < 0xA01)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(v14, (long long *)a1, (long long *)v152, a3);
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((long long *)a1, v14, (long long *)v152, a3);
            uint64_t v15 = 5 * v13;
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((long long *)(a1 + 20), (long long *)(a1 + 4 * v15 - 20), v150, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((long long *)(a1 + 40), (long long *)(a1 + 20 + 4 * v15), v149, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((long long *)(a1 + 4 * v15 - 20), v14, (long long *)(a1 + 20 + 4 * v15), a3);
            int v16 = *(_DWORD *)a1;
            *(_DWORD *)a1 = *(_DWORD *)v14;
            *(_DWORD *)unint64_t v14 = v16;
            *(_OWORD *)int v180 = *(_OWORD *)(a1 + 4);
            *(_OWORD *)(a1 + 4) = *(long long *)((char *)v14 + 4);
            *(long long *)((char *)v14 + 4) = *(_OWORD *)v180;
          }
          --a4;
          if (a5) {
            break;
          }
          unint64_t v17 = *a3;
          int v18 = *(_DWORD *)(a1 - 4);
          long long v160 = *(_OWORD *)(a1 - 20);
          int v161 = v18;
          int v19 = *(_DWORD *)(a1 + 16);
          long long v158 = *(_OWORD *)a1;
          int v159 = v19;
          if (v17(&v160, &v158)) {
            break;
          }
          int v43 = *(_DWORD *)a1;
          long long v169 = *(_OWORD *)(a1 + 4);
          float v44 = *a3;
          *(_DWORD *)int v180 = v43;
          *(_OWORD *)&v180[4] = *(_OWORD *)(a1 + 4);
          long long v45 = *(_OWORD *)v152;
          *(_DWORD *)&v179[16] = v152[4];
          *(_OWORD *)size_t v179 = v45;
          if (v44((long long *)v180, (long long *)v179))
          {
            unint64_t v46 = a1;
            unint64_t v47 = v156;
            do
            {
              unint64_t v10 = v46 + 20;
              uint8x8_t v48 = *a3;
              *(_DWORD *)uint64_t v178 = v43;
              *(_OWORD *)&v178[4] = v169;
              long long v49 = *(_OWORD *)(v46 + 20);
              *(_DWORD *)&v177[16] = *(_DWORD *)(v46 + 36);
              *(_OWORD *)__n128 v177 = v49;
              char v50 = v48((long long *)v178, (long long *)v177);
              unint64_t v46 = v10;
            }
            while ((v50 & 1) == 0);
          }
          else
          {
            unint64_t v51 = a1 + 20;
            unint64_t v47 = v156;
            do
            {
              unint64_t v10 = v51;
              if (v51 >= (unint64_t)v156) {
                break;
              }
              unint64_t v52 = *a3;
              *(_DWORD *)uint64_t v176 = v43;
              *(_OWORD *)&v176[4] = v169;
              long long v53 = *(_OWORD *)v10;
              *(_DWORD *)&v177[16] = *(_DWORD *)(v10 + 16);
              *(_OWORD *)__n128 v177 = v53;
              int v54 = v52((long long *)v176, (long long *)v177);
              unint64_t v51 = v10 + 20;
            }
            while (!v54);
          }
          uint64_t v55 = (long long *)((char *)&v174 + 4);
          int v56 = v47;
          if (v10 < (unint64_t)v47)
          {
            long long v57 = v156;
            do
            {
              int v56 = v57 - 5;
              long long v58 = *a3;
              LODWORD(v174) = v43;
              *uint64_t v55 = v169;
              long long v59 = *(_OWORD *)(v57 - 5);
              *(_DWORD *)&v173[16] = *(v57 - 1);
              *(_OWORD *)int v173 = v59;
              unsigned int v60 = v55;
              char v61 = v58(&v174, (long long *)v173);
              uint64_t v55 = v60;
              long long v57 = v56;
            }
            while ((v61 & 1) != 0);
          }
          if (v10 >= (unint64_t)v56)
          {
            a2 = v156;
          }
          else
          {
            a2 = v156;
            do
            {
              int v62 = *(_DWORD *)v10;
              *(_DWORD *)unint64_t v10 = *v56;
              int *v56 = v62;
              long long v170 = *(_OWORD *)(v10 + 4);
              *(_OWORD *)(v10 + 4) = *(_OWORD *)(v56 + 1);
              *(_OWORD *)(v56 + 1) = v170;
              do
              {
                *(_DWORD *)float32x4_t v172 = v43;
                *(_OWORD *)&v172[4] = v169;
                long long v63 = *(_OWORD *)(v10 + 20);
                int v64 = *(_DWORD *)(v10 + 36);
                v10 += 20;
                uint8x8_t v65 = *a3;
                *(_DWORD *)&v171[16] = v64;
                *(_OWORD *)unsigned int v171 = v63;
              }
              while (!v65((long long *)v172, (long long *)v171));
              do
              {
                LODWORD(v168[0]) = v43;
                *(_OWORD *)((char *)v168 + 4) = v169;
                long long v66 = *(_OWORD *)(v56 - 5);
                int v67 = *(v56 - 1);
                v56 -= 5;
                unint64_t v68 = *a3;
                int v167 = v67;
                long long v166 = v66;
              }
              while ((v68(v168, &v166) & 1) != 0);
            }
            while (v10 < (unint64_t)v56);
          }
          BOOL v5 = v10 - 20 >= a1;
          BOOL v6 = v10 - 20 == a1;
          if (v10 - 20 != a1)
          {
            *(_DWORD *)a1 = *(_DWORD *)(v10 - 20);
            *(_OWORD *)(a1 + 4) = *(_OWORD *)(v10 - 16);
          }
          a5 = 0;
          *(_DWORD *)(v10 - 20) = v43;
          *(_OWORD *)(v10 - 16) = v169;
        }
        int v20 = *(_DWORD *)a1;
        long long v166 = *(_OWORD *)(a1 + 4);
        unint64_t v21 = a1;
        do
        {
          unint64_t v22 = v21;
          v21 += 20;
          unint64_t v23 = *a3;
          int v24 = *(_DWORD *)(v22 + 36);
          *(_OWORD *)int v180 = *(_OWORD *)(v22 + 20);
          *(_DWORD *)&v180[16] = v24;
          *(_DWORD *)size_t v179 = v20;
          *(_OWORD *)&v179[4] = v166;
        }
        while ((v23((long long *)v180, (long long *)v179) & 1) != 0);
        uint64_t v25 = v156;
        if (v22 == a1)
        {
          char v30 = v156;
          while (v21 < (unint64_t)v30)
          {
            unint64_t v31 = *a3;
            int v26 = v30 - 5;
            int v32 = *(v30 - 1);
            *(_OWORD *)uint64_t v178 = *(_OWORD *)(v30 - 5);
            *(_DWORD *)&v178[16] = v32;
            *(_DWORD *)__n128 v177 = v20;
            *(_OWORD *)&v177[4] = v166;
            char v33 = v31((long long *)v178, (long long *)v177);
            char v30 = v26;
            if (v33) {
              goto LABEL_21;
            }
          }
          int v26 = v30;
        }
        else
        {
          do
          {
            int v26 = v25 - 5;
            unint64_t v27 = *a3;
            int v28 = *(v25 - 1);
            *(_OWORD *)uint64_t v178 = *(_OWORD *)(v25 - 5);
            *(_DWORD *)&v178[16] = v28;
            *(_DWORD *)uint64_t v176 = v20;
            *(_OWORD *)&v176[4] = v166;
            int v29 = v27((long long *)v178, (long long *)v176);
            uint64_t v25 = v26;
          }
          while (!v29);
        }
LABEL_21:
        unint64_t v10 = v21;
        if (v21 < (unint64_t)v26)
        {
          unint64_t v34 = (unint64_t)v26;
          do
          {
            int v35 = *(_DWORD *)v10;
            *(_DWORD *)unint64_t v10 = *(_DWORD *)v34;
            *(_DWORD *)unint64_t v34 = v35;
            v168[0] = *(_OWORD *)(v10 + 4);
            *(_OWORD *)(v10 + 4) = *(_OWORD *)(v34 + 4);
            *(_OWORD *)(v34 + 4) = v168[0];
            do
            {
              int v36 = *(_DWORD *)(v10 + 36);
              long long v37 = *(_OWORD *)(v10 + 20);
              v10 += 20;
              float v38 = *a3;
              long long v174 = v37;
              int v175 = v36;
              *(_DWORD *)int v173 = v20;
              *(_OWORD *)&v173[4] = v166;
            }
            while ((v38(&v174, (long long *)v173) & 1) != 0);
            do
            {
              int v39 = *(_DWORD *)(v34 - 4);
              long long v40 = *(_OWORD *)(v34 - 20);
              v34 -= 20;
              unint64_t v41 = *a3;
              *(_OWORD *)float32x4_t v172 = v40;
              *(_DWORD *)&v172[16] = v39;
              *(_DWORD *)unsigned int v171 = v20;
              *(_OWORD *)&v171[4] = v166;
            }
            while (!v41((long long *)v172, (long long *)v171));
          }
          while (v10 < v34);
        }
        if (v10 - 20 != a1)
        {
          *(_DWORD *)a1 = *(_DWORD *)(v10 - 20);
          *(_OWORD *)(a1 + 4) = *(_OWORD *)(v10 - 16);
        }
        *(_DWORD *)(v10 - 20) = v20;
        *(_OWORD *)(v10 - 16) = v166;
        BOOL v5 = v21 >= (unint64_t)v26;
        a2 = v156;
        if (v5) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*,false>(a1, v10 - 20, a3, a4, a5 & 1);
        a5 = 0;
      }
      BOOL v42 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((long long *)a1, (int *)(v10 - 20), a3);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((long long *)v10, v156, a3))
      {
        break;
      }
      if (!v42) {
        goto LABEL_33;
      }
    }
    a2 = (int *)(v10 - 20);
    if (!v42) {
      continue;
    }
    break;
  }
}

char *std::vector<std::tuple<float,_Geometry2D_rect2D_>>::__assign_with_size[abi:ne180100]<std::tuple<float,_Geometry2D_rect2D_>*,std::tuple<float,_Geometry2D_rect2D_>*>(char **a1, long long *a2, long long *a3, unint64_t a4)
{
  BOOL v6 = a2;
  uint64_t v8 = (uint64_t)a1[2];
  __n128 result = *a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((v8 - (uint64_t)result) >> 2) >= a4)
  {
    int v19 = a1[1];
    unint64_t v17 = (void **)(a1 + 1);
    int v18 = v19;
    unint64_t v20 = 0xCCCCCCCCCCCCCCCDLL * ((v19 - result) >> 2);
    if (v20 >= a4)
    {
      int v24 = result;
      while (v6 != a3)
      {
        *(_DWORD *)int v24 = *(_DWORD *)v6;
        *(_OWORD *)(v24 + 4) = *(long long *)((char *)v6 + 4);
        v24 += 20;
        BOOL v6 = (long long *)((char *)v6 + 20);
      }
      uint64_t v16 = v24 - result;
    }
    else
    {
      unint64_t v21 = (long long *)((char *)a2 + 20 * v20);
      if (v18 != result)
      {
        do
        {
          *(_DWORD *)__n128 result = *(_DWORD *)v6;
          *(_OWORD *)(result + 4) = *(long long *)((char *)v6 + 4);
          BOOL v6 = (long long *)((char *)v6 + 20);
          result += 20;
        }
        while (v6 != v21);
        __n128 result = (char *)*v17;
      }
      unint64_t v22 = result;
      if (v21 != a3)
      {
        unint64_t v22 = result;
        do
        {
          long long v23 = *v21;
          *((_DWORD *)v22 + 4) = *((_DWORD *)v21 + 4);
          *(_OWORD *)unint64_t v22 = v23;
          v22 += 20;
          unint64_t v21 = (long long *)((char *)v21 + 20);
        }
        while (v21 != a3);
      }
      uint64_t v16 = v22 - result;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0xCCCCCCCCCCCCCCCLL) {
      goto LABEL_28;
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 2);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    unint64_t v12 = v10 >= 0x666666666666666 ? 0xCCCCCCCCCCCCCCCLL : v11;
    if (v12 > 0xCCCCCCCCCCCCCCCLL) {
LABEL_28:
    }
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<float,_Geometry2D_rect2D_>>>(v12);
    a1[1] = result;
    *a1 = result;
    a1[2] = &result[20 * v13];
    unint64_t v14 = result;
    if (v6 != a3)
    {
      unint64_t v14 = result;
      do
      {
        long long v15 = *v6;
        *((_DWORD *)v14 + 4) = *((_DWORD *)v6 + 4);
        *(_OWORD *)unint64_t v14 = v15;
        v14 += 20;
        BOOL v6 = (long long *)((char *)v6 + 20);
      }
      while (v6 != a3);
    }
    uint64_t v16 = v14 - result;
    unint64_t v17 = (void **)(a1 + 1);
  }
  long long *v17 = &result[v16];
  return result;
}

__n128 std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(long long *a1, long long *a2, long long *a3, uint64_t (**a4)(long long *, long long *))
{
  uint64_t v8 = *a4;
  long long v40 = *a2;
  int v41 = *((_DWORD *)a2 + 4);
  long long v38 = *a1;
  int v39 = *((_DWORD *)a1 + 4);
  char v9 = v8(&v40, &v38);
  unint64_t v10 = *a4;
  if (v9)
  {
    long long v28 = *a3;
    int v29 = *((_DWORD *)a3 + 4);
    long long v26 = *a2;
    int v27 = *((_DWORD *)a2 + 4);
    int v11 = v10(&v28, &v26);
    unint64_t v12 = (__n128 *)((char *)a1 + 4);
    int v13 = *(_DWORD *)a1;
    if (v11)
    {
      *(_DWORD *)a1 = *(_DWORD *)a3;
    }
    else
    {
      *(_DWORD *)a1 = *(_DWORD *)a2;
      *(_DWORD *)a2 = v13;
      __n128 v20 = *v12;
      *unint64_t v12 = *(__n128 *)((char *)a2 + 4);
      *(long long *)((char *)a2 + 4) = (__int128)v20;
      unint64_t v21 = *a4;
      long long v24 = *a3;
      int v25 = *((_DWORD *)a3 + 4);
      int v23 = *((_DWORD *)a2 + 4);
      long long v22 = *a2;
      if (!v21(&v24, &v22)) {
        return result;
      }
      unint64_t v12 = (__n128 *)((char *)a2 + 4);
      int v13 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
    }
    *(_DWORD *)a3 = v13;
    __n128 result = *v12;
    *unint64_t v12 = *(__n128 *)((char *)a3 + 4);
    *(long long *)((char *)a3 + 4) = (__int128)result;
  }
  else
  {
    long long v36 = *a3;
    int v37 = *((_DWORD *)a3 + 4);
    long long v34 = *a2;
    int v35 = *((_DWORD *)a2 + 4);
    if (v10(&v36, &v34))
    {
      int v15 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v15;
      long long v16 = *(long long *)((char *)a2 + 4);
      *(long long *)((char *)a2 + 4) = *(long long *)((char *)a3 + 4);
      *(long long *)((char *)a3 + 4) = v16;
      unint64_t v17 = *a4;
      int v33 = *((_DWORD *)a2 + 4);
      long long v32 = *a2;
      long long v18 = *a1;
      int v31 = *((_DWORD *)a1 + 4);
      long long v30 = v18;
      if (v17(&v32, &v30))
      {
        int v19 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v19;
        __n128 result = *(__n128 *)((char *)a1 + 4);
        *(long long *)((char *)a1 + 4) = *(long long *)((char *)a2 + 4);
        *(long long *)((char *)a2 + 4) = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(int *a1, long long *a2, long long *a3, long long *a4, uint64_t (**a5)(long long *, long long *))
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((long long *)a1, a2, a3, a5);
  unint64_t v10 = *a5;
  long long v31 = *a4;
  int v32 = *((_DWORD *)a4 + 4);
  long long v29 = *a3;
  int v30 = *((_DWORD *)a3 + 4);
  if (v10(&v31, &v29))
  {
    int v12 = *(_DWORD *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_DWORD *)a4 = v12;
    long long v13 = *(long long *)((char *)a3 + 4);
    *(long long *)((char *)a3 + 4) = *(long long *)((char *)a4 + 4);
    *(long long *)((char *)a4 + 4) = v13;
    unint64_t v14 = *a5;
    int v28 = *((_DWORD *)a3 + 4);
    long long v27 = *a3;
    long long v15 = *a2;
    int v26 = *((_DWORD *)a2 + 4);
    long long v25 = v15;
    if (v14(&v27, &v25))
    {
      int v16 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v16;
      long long v17 = *(long long *)((char *)a2 + 4);
      *(long long *)((char *)a2 + 4) = *(long long *)((char *)a3 + 4);
      *(long long *)((char *)a3 + 4) = v17;
      long long v18 = *a5;
      int v24 = *((_DWORD *)a2 + 4);
      long long v23 = *a2;
      long long v19 = *(_OWORD *)a1;
      int v22 = a1[4];
      long long v21 = v19;
      if (v18(&v23, &v21))
      {
        int v20 = *a1;
        *a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v20;
        __n128 result = *(__n128 *)(a1 + 1);
        *(_OWORD *)(a1 + 1) = *(long long *)((char *)a2 + 4);
        *(long long *)((char *)a2 + 4) = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(long long *a1, long long *a2, long long *a3, long long *a4, long long *a5, uint64_t (**a6)(long long *, long long *))
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((int *)a1, a2, a3, a4, a6);
  int v12 = *a6;
  long long v41 = *a5;
  int v42 = *((_DWORD *)a5 + 4);
  long long v39 = *a4;
  int v40 = *((_DWORD *)a4 + 4);
  if (v12(&v41, &v39))
  {
    int v14 = *(_DWORD *)a4;
    *(_DWORD *)a4 = *(_DWORD *)a5;
    *(_DWORD *)a5 = v14;
    long long v15 = *(long long *)((char *)a4 + 4);
    *(long long *)((char *)a4 + 4) = *(long long *)((char *)a5 + 4);
    *(long long *)((char *)a5 + 4) = v15;
    int v16 = *a6;
    int v38 = *((_DWORD *)a4 + 4);
    long long v37 = *a4;
    long long v17 = *a3;
    int v36 = *((_DWORD *)a3 + 4);
    long long v35 = v17;
    if (v16(&v37, &v35))
    {
      int v18 = *(_DWORD *)a3;
      *(_DWORD *)a3 = *(_DWORD *)a4;
      *(_DWORD *)a4 = v18;
      long long v19 = *(long long *)((char *)a3 + 4);
      *(long long *)((char *)a3 + 4) = *(long long *)((char *)a4 + 4);
      *(long long *)((char *)a4 + 4) = v19;
      int v20 = *a6;
      int v34 = *((_DWORD *)a3 + 4);
      long long v33 = *a3;
      long long v21 = *a2;
      int v32 = *((_DWORD *)a2 + 4);
      long long v31 = v21;
      if (v20(&v33, &v31))
      {
        int v22 = *(_DWORD *)a2;
        *(_DWORD *)a2 = *(_DWORD *)a3;
        *(_DWORD *)a3 = v22;
        long long v23 = *(long long *)((char *)a2 + 4);
        *(long long *)((char *)a2 + 4) = *(long long *)((char *)a3 + 4);
        *(long long *)((char *)a3 + 4) = v23;
        int v24 = *a6;
        int v30 = *((_DWORD *)a2 + 4);
        long long v29 = *a2;
        long long v25 = *a1;
        int v28 = *((_DWORD *)a1 + 4);
        long long v27 = v25;
        if (v24(&v29, &v27))
        {
          int v26 = *(_DWORD *)a1;
          *(_DWORD *)a1 = *(_DWORD *)a2;
          *(_DWORD *)a2 = v26;
          __n128 result = *(__n128 *)((char *)a1 + 4);
          *(long long *)((char *)a1 + 4) = *(long long *)((char *)a2 + 4);
          *(long long *)((char *)a2 + 4) = (__int128)result;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(long long *a1, int *a2, uint64_t (**a3)(long long *, long long *))
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 2;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = *a3;
      long long v36 = *(_OWORD *)(a2 - 5);
      int v37 = *(a2 - 1);
      long long v34 = *a1;
      int v35 = *((_DWORD *)a1 + 4);
      if (v8(&v36, &v34))
      {
        int v9 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(a2 - 5);
        *(a2 - 5) = v9;
        long long v10 = *(long long *)((char *)a1 + 4);
        *(long long *)((char *)a1 + 4) = *((_OWORD *)a2 - 1);
        *((_OWORD *)a2 - 1) = v10;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(a1, (long long *)((char *)a1 + 20), (long long *)(a2 - 5), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((int *)a1, (long long *)((char *)a1 + 20), (long long *)((char *)a1 + 40), (long long *)(a2 - 5), a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(a1, (long long *)((char *)a1 + 20), (long long *)((char *)a1 + 40), (long long *)((char *)a1 + 60), (long long *)(a2 - 5), a3);
      return 1;
    default:
      int v11 = (long long *)((char *)a1 + 40);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(a1, (long long *)((char *)a1 + 20), (long long *)((char *)a1 + 40), a3);
      int v12 = (long long *)((char *)a1 + 60);
      if ((int *)((char *)a1 + 60) == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (1)
  {
    long long v15 = *a3;
    long long v32 = *v12;
    int v33 = *((_DWORD *)v12 + 4);
    int v16 = *((_DWORD *)v11 + 4);
    long long v30 = *v11;
    int v31 = v16;
    if (v15(&v32, &v30))
    {
      int v17 = *(_DWORD *)v12;
      long long v29 = *(long long *)((char *)v12 + 4);
      uint64_t v18 = v13;
      while (1)
      {
        uint64_t v19 = v18;
        uint64_t v20 = (uint64_t)a1 + v18;
        *(_DWORD *)(v20 + 60) = *(_DWORD *)(v20 + 40);
        *(_OWORD *)(v20 + 64) = *(_OWORD *)(v20 + 44);
        if (v19 == -40) {
          break;
        }
        long long v21 = *a3;
        int v27 = v17;
        long long v28 = v29;
        long long v25 = *(_OWORD *)(v20 + 20);
        int v26 = *(_DWORD *)(v20 + 36);
        char v22 = v21((long long *)&v27, &v25);
        uint64_t v18 = v19 - 20;
        if ((v22 & 1) == 0)
        {
          long long v23 = (long long *)((char *)a1 + v18 + 60);
          int v24 = (long long *)((char *)a1 + v19 + 44);
          goto LABEL_12;
        }
      }
      int v24 = (_OWORD *)(v20 + 44);
      long long v23 = a1;
LABEL_12:
      *(_DWORD *)long long v23 = v17;
      *int v24 = v29;
      if (++v14 == 8) {
        return (int *)((char *)v12 + 20) == a2;
      }
    }
    int v11 = v12;
    v13 += 20;
    int v12 = (long long *)((char *)v12 + 20);
    if (v12 == (long long *)a2) {
      return 1;
    }
  }
}

uint64_t vision::mod::ImageAnalyzer_PostProcessor::process(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (uint64_t **)(a1 + 96);
  unint64_t v7 = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>(a1 + 96, &v17, (void *)a1);
  uint64_t v8 = *v7;
  if (!*v7)
  {
    int v9 = v7;
    uint64_t v8 = (uint64_t *)operator new(0x58uLL);
    v15[0] = v8;
    v15[1] = a1 + 104;
    char v16 = 0;
    long long v10 = (std::string *)(v8 + 4);
    if (*(char *)(a1 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
    }
    else
    {
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
      v8[6] = *(void *)(a1 + 16);
    }
    v8[10] = 0;
    char v16 = 1;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v6, v17, v9, v8);
    v15[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)v15);
  }
  uint64_t v11 = v8[10];
  if (!v11) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 48))(v11, a1 + 24, a2, a3);
  if ((v12 & 0x80) == 0)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = v12;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  return a1;
}

void sub_1A3F919A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t vision::mod::ImageAnalyzer::getSceneLabelsConfidences(vision::mod::ImageAnalyzer *this, float a2, uint64_t a3)
{
  uint64_t v4 = (uint64_t)this;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  long long v44 = 0u;
  long long v45 = 0u;
  float v46 = 1.0;
  uint64_t v5 = a3 + 864;
  LODWORD(__p) = 2;
  uint64_t v6 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a3 + 864, 2u, &__p);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>((uint64_t)&v44, vcvtps_u32_f32((float)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6[4] - v6[3]) >> 3)) / 1.0));
  LODWORD(__p) = 2;
  if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a3 + 824, 2u, &__p)+ 20))
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 8574;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if (*(unsigned char *)(a3 + 384))
  {
    long long v39 = __cxa_allocate_exception(8uLL);
    void *v39 = 8575;
    __cxa_throw(v39, MEMORY[0x1E4FBA3E0], 0);
  }
  LODWORD(v47) = 2;
  unint64_t v7 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a3 + 784, 2u, &v47);
  vision::mod::ImageAnalyzer_Tensor1D<float>::ImageAnalyzer_Tensor1D((uint64_t)&__p, (long long *)(v7 + 24), 0);
  vision::mod::ImageAnalyzer_Tensor1D<float>::getVectorFromTensor(&v51, (unint64_t *)&__p);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)&__p);
  std::string __p = 0;
  long long v49 = 0;
  uint64_t v50 = 0;
  long long v41 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>((void *)(a3 + 744), 2u);
  if (v41)
  {
    LODWORD(v47) = 2;
    uint64_t v8 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((void *)(a3 + 744), 2u, &v47);
    vision::mod::ImageAnalyzer_PostProcessor::process((uint64_t)(v8 + 3), (uint64_t)&v51, (uint64_t)&__p);
  }
  DisallowedLabels = vision::mod::ImageAnalyzer::getDisallowedLabels(a3, 2u);
  int v9 = v51;
  long long v10 = v41;
  if ((int)((unint64_t)(v52 - v51) >> 2) >= 1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = DisallowedLabels[3];
    int v42 = (long long *)(a3 + 1008);
    uint64_t v40 = v4;
    while (1)
    {
      LODWORD(v47) = 2;
      uint64_t v13 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v5, 2u, &v47)[3];
      uint64_t v14 = v13 + 24 * v11;
      if (!v12
        || !std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(DisallowedLabels, (unsigned __int8 *)(v13 + 24 * v11)))
      {
        break;
      }
LABEL_54:
      ++v11;
      int v9 = v51;
      if (v11 >= (int)((unint64_t)(v52 - v51) >> 2))
      {
        uint64_t v4 = v40;
        goto LABEL_56;
      }
    }
    p_p = &__p;
    if (!v10) {
      p_p = (void **)&v51;
    }
    int v16 = *((_DWORD *)*p_p + v11);
    long long v47 = *v42;
    unint64_t v17 = std::__string_hash<char>::operator()[abi:ne180100](v14);
    unint64_t v18 = v17;
    unint64_t v19 = *((void *)&v44 + 1);
    if (*((void *)&v44 + 1))
    {
      uint8x8_t v20 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v44 + 8));
      v20.i16[0] = vaddlv_u8(v20);
      unint64_t v21 = v20.u32[0];
      if (v20.u32[0] > 1uLL)
      {
        uint64_t v4 = v17;
        if (v17 >= *((void *)&v44 + 1)) {
          uint64_t v4 = v17 % *((void *)&v44 + 1);
        }
      }
      else
      {
        uint64_t v4 = (*((void *)&v44 + 1) - 1) & v17;
      }
      char v22 = *(void ***)(v44 + 8 * v4);
      if (v22)
      {
        long long v23 = (char *)*v22;
        if (*v22)
        {
          while (1)
          {
            unint64_t v24 = *((void *)v23 + 1);
            if (v24 == v18)
            {
              if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v23 + 16, (unsigned __int8 *)v14))
              {
                long long v10 = v41;
                goto LABEL_53;
              }
            }
            else
            {
              if (v21 > 1)
              {
                if (v24 >= v19) {
                  v24 %= v19;
                }
              }
              else
              {
                v24 &= v19 - 1;
              }
              if (v24 != v4)
              {
LABEL_27:
                long long v10 = v41;
                break;
              }
            }
            long long v23 = *(char **)v23;
            if (!v23) {
              goto LABEL_27;
            }
          }
        }
      }
    }
    long long v23 = (char *)operator new(0x40uLL);
    *(void *)long long v23 = 0;
    *((void *)v23 + 1) = v18;
    long long v25 = (std::string *)(v23 + 16);
    if (*(char *)(v14 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v25, *(const std::string::value_type **)v14, *(void *)(v14 + 8));
    }
    else
    {
      long long v26 = *(_OWORD *)v14;
      *((void *)v23 + 4) = *(void *)(v14 + 16);
      *(_OWORD *)&v25->__r_.__value_.__l.__data_ = v26;
    }
    *((void *)v23 + 5) = 0;
    *((void *)v23 + 6) = 0;
    *((_DWORD *)v23 + 14) = 0;
    float v27 = (float)(unint64_t)(*((void *)&v45 + 1) + 1);
    if (!v19 || (float)(v46 * (float)v19) < v27)
    {
      BOOL v28 = (v19 & (v19 - 1)) != 0;
      if (v19 < 3) {
        BOOL v28 = 1;
      }
      unint64_t v29 = v28 | (2 * v19);
      unint64_t v30 = vcvtps_u32_f32(v27 / v46);
      if (v29 <= v30) {
        size_t v31 = v30;
      }
      else {
        size_t v31 = v29;
      }
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>((uint64_t)&v44, v31);
      unint64_t v19 = *((void *)&v44 + 1);
      if ((*((void *)&v44 + 1) & (*((void *)&v44 + 1) - 1)) != 0)
      {
        if (v18 >= *((void *)&v44 + 1)) {
          uint64_t v4 = v18 % *((void *)&v44 + 1);
        }
        else {
          uint64_t v4 = v18;
        }
      }
      else
      {
        uint64_t v4 = (*((void *)&v44 + 1) - 1) & v18;
      }
    }
    uint64_t v32 = v44;
    int v33 = *(void **)(v44 + 8 * v4);
    if (v33)
    {
      *(void *)long long v23 = *v33;
    }
    else
    {
      *(void *)long long v23 = v45;
      *(void *)&long long v45 = v23;
      *(void *)(v32 + 8 * v4) = &v45;
      if (!*(void *)v23) {
        goto LABEL_52;
      }
      unint64_t v34 = *(void *)(*(void *)v23 + 8);
      if ((v19 & (v19 - 1)) != 0)
      {
        if (v34 >= v19) {
          v34 %= v19;
        }
      }
      else
      {
        v34 &= v19 - 1;
      }
      int v33 = (void *)(v44 + 8 * v34);
    }
    *int v33 = v23;
LABEL_52:
    ++*((void *)&v45 + 1);
LABEL_53:
    *((_DWORD *)v23 + 10) = v16;
    *(_OWORD *)(v23 + 44) = v47;
    goto LABEL_54;
  }
LABEL_56:
  if (__p)
  {
    long long v49 = __p;
    operator delete(__p);
    int v9 = v51;
  }
  if (v9)
  {
    unint64_t v52 = v9;
    operator delete(v9);
  }
  for (uint64_t i = (uint64_t *)v45; i; uint64_t i = (uint64_t *)*i)
  {
    int v36 = *((_DWORD *)i + 10);
    std::string __p = i + 2;
    *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v4, (unsigned __int8 *)i + 16, (long long **)&__p)+ 10) = v36;
  }
  return std::__hash_table<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>>>::~__hash_table((uint64_t)&v44);
}

void sub_1A3F91E9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }
  BOOL v28 = *(void **)(v26 - 128);
  if (v28)
  {
    *(void *)(v26 - 120) = v28;
    operator delete(v28);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>>>::~__hash_table((uint64_t)&a15);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v25);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t vision::mod::ImageAnalyzer::getSlidersAdjustments(vision::mod::ImageAnalyzer *this, void *a2)
{
  unint64_t v3 = a2;
  LODWORD(v57[0]) = 256;
  uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)(a2 + 103), 0x100u, v57);
  if (!*(unsigned char *)(result + 20))
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 8574;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  uint64_t v6 = (uint64_t *)v3[90];
  if (v6)
  {
    int v56 = (void *)((char *)this + 16);
LABEL_4:
    unint64_t v7 = *((unsigned int *)v6 + 4);
    if (!v7) {
      goto LABEL_104;
    }
    int v8 = -1;
    unsigned int v9 = *((_DWORD *)v6 + 4);
    do
    {
      ++v8;
      BOOL v10 = v9 > 1;
      v9 >>= 1;
    }
    while (v10);
    if (v8 != 8) {
      goto LABEL_104;
    }
    int8x8_t v11 = (int8x8_t)v3[99];
    if (!*(void *)&v11) {
      goto LABEL_116;
    }
    uint8x8_t v12 = (uint8x8_t)vcnt_s8(v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v13 = *((unsigned int *)v6 + 4);
      if (*(void *)&v11 <= v7) {
        unint64_t v13 = v7 % *(void *)&v11;
      }
    }
    else
    {
      unint64_t v13 = (v11.i32[0] - 1) & v7;
    }
    uint64_t v14 = *(uint64_t ***)(v3[98] + 8 * v13);
    if (!v14 || (long long v15 = *v14) == 0) {
LABEL_116:
    }
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
    while (1)
    {
      unint64_t v16 = v15[1];
      if (v16 == v7)
      {
        if (*((_DWORD *)v15 + 4) == v7)
        {
          long long v17 = *(_OWORD *)(v15 + 17);
          long long v18 = *(_OWORD *)(v15 + 21);
          v60[8] = *(_OWORD *)(v15 + 19);
          v60[9] = v18;
          uint64_t v61 = v15[23];
          long long v19 = *(_OWORD *)(v15 + 9);
          long long v20 = *(_OWORD *)(v15 + 13);
          v60[4] = *(_OWORD *)(v15 + 11);
          v60[5] = v20;
          v60[6] = *(_OWORD *)(v15 + 15);
          v60[7] = v17;
          long long v21 = *(_OWORD *)(v15 + 5);
          v60[0] = *(_OWORD *)(v15 + 3);
          v60[1] = v21;
          v60[2] = *(_OWORD *)(v15 + 7);
          v60[3] = v19;
          vision::mod::ImageAnalyzer_Tensor1D<float>::ImageAnalyzer_Tensor1D((uint64_t)v57, v60, 1);
          vision::mod::ImageAnalyzer_Tensor1D<float>::getVectorFromTensor(&v58, v57);
          unint64_t v22 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(v6 + 3));
          unint64_t v23 = v22;
          unint64_t v24 = *((void *)this + 1);
          if (v24)
          {
            uint64_t v25 = v3;
            uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v24);
            v26.i16[0] = vaddlv_u8(v26);
            unint64_t v27 = v26.u32[0];
            if (v26.u32[0] > 1uLL)
            {
              unint64_t v2 = v22;
              if (v22 >= v24) {
                unint64_t v2 = v22 % v24;
              }
            }
            else
            {
              unint64_t v2 = (v24 - 1) & v22;
            }
            BOOL v28 = *(uint64_t ***)(*(void *)this + 8 * v2);
            if (v28)
            {
              for (uint64_t i = *v28; i; uint64_t i = (uint64_t *)*i)
              {
                unint64_t v30 = i[1];
                if (v30 == v23)
                {
                  if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)i + 16, (unsigned __int8 *)v6 + 24))
                  {
                    unint64_t v3 = v25;
                    goto LABEL_101;
                  }
                }
                else
                {
                  if (v27 > 1)
                  {
                    if (v30 >= v24) {
                      v30 %= v24;
                    }
                  }
                  else
                  {
                    v30 &= v24 - 1;
                  }
                  if (v30 != v2) {
                    break;
                  }
                }
              }
            }
            unint64_t v3 = v25;
          }
          size_t v31 = operator new(0x40uLL);
          v62[0] = v31;
          v62[1] = (char *)this + 16;
          char v63 = 0;
          void *v31 = 0;
          v31[1] = v23;
          uint64_t v32 = (std::string *)(v31 + 2);
          if (*((char *)v6 + 47) < 0)
          {
            std::string::__init_copy_ctor_external(v32, (const std::string::value_type *)v6[3], v6[4]);
          }
          else
          {
            long long v33 = *(_OWORD *)(v6 + 3);
            v31[4] = v6[5];
            *(_OWORD *)&v32->__r_.__value_.__l.__data_ = v33;
          }
          v31[5] = 0;
          v31[6] = 0;
          v31[7] = 0;
          char v63 = 1;
          float v34 = (float)(unint64_t)(*((void *)this + 3) + 1);
          float v35 = *((float *)this + 8);
          if (!v24 || (float)(v35 * (float)v24) < v34)
          {
            BOOL v36 = (v24 & (v24 - 1)) != 0;
            if (v24 < 3) {
              BOOL v36 = 1;
            }
            unint64_t v37 = v36 | (2 * v24);
            unint64_t v38 = vcvtps_u32_f32(v34 / v35);
            if (v37 <= v38) {
              int8x8_t prime = (int8x8_t)v38;
            }
            else {
              int8x8_t prime = (int8x8_t)v37;
            }
            if (*(void *)&prime == 1)
            {
              int8x8_t prime = (int8x8_t)2;
            }
            else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
            {
              int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
            }
            unint64_t v24 = *((void *)this + 1);
            if (*(void *)&prime <= v24)
            {
              if (*(void *)&prime < v24)
              {
                unint64_t v46 = vcvtps_u32_f32((float)*((unint64_t *)this + 3) / *((float *)this + 8));
                if (v24 < 3
                  || (uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)v24), v47.i16[0] = vaddlv_u8(v47), v47.u32[0] > 1uLL))
                {
                  unint64_t v46 = std::__next_prime(v46);
                }
                else
                {
                  uint64_t v48 = 1 << -(char)__clz(v46 - 1);
                  if (v46 >= 2) {
                    unint64_t v46 = v48;
                  }
                }
                if (*(void *)&prime <= v46) {
                  int8x8_t prime = (int8x8_t)v46;
                }
                if (*(void *)&prime >= v24)
                {
                  unint64_t v24 = *((void *)this + 1);
                }
                else
                {
                  if (prime) {
                    goto LABEL_57;
                  }
                  int v54 = *(void **)this;
                  *(void *)this = 0;
                  if (v54) {
                    operator delete(v54);
                  }
                  unint64_t v24 = 0;
                  *((void *)this + 1) = 0;
                }
              }
            }
            else
            {
LABEL_57:
              if (*(void *)&prime >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              uint64_t v40 = operator new(8 * *(void *)&prime);
              long long v41 = *(void **)this;
              *(void *)this = v40;
              if (v41) {
                operator delete(v41);
              }
              uint64_t v42 = 0;
              *((int8x8_t *)this + 1) = prime;
              do
                *(void *)(*(void *)this + 8 * v42++) = 0;
              while (*(void *)&prime != v42);
              int v43 = (void *)*v56;
              if (*v56)
              {
                unint64_t v44 = v43[1];
                uint8x8_t v45 = (uint8x8_t)vcnt_s8(prime);
                v45.i16[0] = vaddlv_u8(v45);
                if (v45.u32[0] > 1uLL)
                {
                  if (v44 >= *(void *)&prime) {
                    v44 %= *(void *)&prime;
                  }
                }
                else
                {
                  v44 &= *(void *)&prime - 1;
                }
                *(void *)(*(void *)this + 8 * v44) = v56;
                long long v49 = (void *)*v43;
                if (*v43)
                {
                  do
                  {
                    unint64_t v50 = v49[1];
                    if (v45.u32[0] > 1uLL)
                    {
                      if (v50 >= *(void *)&prime) {
                        v50 %= *(void *)&prime;
                      }
                    }
                    else
                    {
                      v50 &= *(void *)&prime - 1;
                    }
                    if (v50 != v44)
                    {
                      if (!*(void *)(*(void *)this + 8 * v50))
                      {
                        *(void *)(*(void *)this + 8 * v50) = v43;
                        goto LABEL_82;
                      }
                      *int v43 = *v49;
                      *long long v49 = **(void **)(*(void *)this + 8 * v50);
                      **(void **)(*(void *)this + 8 * v50) = v49;
                      long long v49 = v43;
                    }
                    unint64_t v50 = v44;
LABEL_82:
                    int v43 = v49;
                    long long v49 = (void *)*v49;
                    unint64_t v44 = v50;
                  }
                  while (v49);
                }
              }
              unint64_t v24 = (unint64_t)prime;
            }
            if ((v24 & (v24 - 1)) != 0)
            {
              if (v23 >= v24) {
                unint64_t v2 = v23 % v24;
              }
              else {
                unint64_t v2 = v23;
              }
            }
            else
            {
              unint64_t v2 = (v24 - 1) & v23;
            }
          }
          unint64_t v51 = *(void **)(*(void *)this + 8 * v2);
          uint64_t i = (uint64_t *)v62[0];
          if (v51)
          {
            *(void *)v62[0] = *v51;
            goto LABEL_99;
          }
          *(void *)v62[0] = *((void *)this + 2);
          *((void *)this + 2) = i;
          *(void *)(*(void *)this + 8 * v2) = v56;
          if (*i)
          {
            unint64_t v52 = *(void *)(*i + 8);
            if ((v24 & (v24 - 1)) != 0)
            {
              if (v52 >= v24) {
                v52 %= v24;
              }
            }
            else
            {
              v52 &= v24 - 1;
            }
            unint64_t v51 = (void *)(*(void *)this + 8 * v52);
LABEL_99:
            void *v51 = i;
          }
          v62[0] = 0;
          ++*((void *)this + 3);
          std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v62);
LABEL_101:
          long long v53 = (void *)i[5];
          if (v53)
          {
            i[6] = (uint64_t)v53;
            operator delete(v53);
            i[5] = 0;
            i[6] = 0;
            i[7] = 0;
          }
          *(_OWORD *)(i + 5) = v58;
          i[7] = v59;
          uint64_t v59 = 0;
          long long v58 = 0uLL;
          uint64_t result = vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)v57);
LABEL_104:
          uint64_t v6 = (uint64_t *)*v6;
          if (!v6) {
            return result;
          }
          goto LABEL_4;
        }
      }
      else
      {
        if (v12.u32[0] > 1uLL)
        {
          if (v16 >= *(void *)&v11) {
            v16 %= *(void *)&v11;
          }
        }
        else
        {
          v16 &= *(void *)&v11 - 1;
        }
        if (v16 != v13) {
          goto LABEL_116;
        }
      }
      long long v15 = (uint64_t *)*v15;
      if (!v15) {
        goto LABEL_116;
      }
    }
  }
  return result;
}

void sub_1A3F925F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100](v35 - 120);
  if (__p)
  {
    a34 = (uint64_t)__p;
    operator delete(__p);
  }
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)&a10);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<float>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<float>>>>::~__hash_table(v34);
  _Unwind_Resume(a1);
}

void sub_1A3F926F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9291C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void BmMixedBufSize::BmMixedBufSize(BmMixedBufSize *this)
{
  *(void *)this = 0;
}

void sub_1A3F92C10(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A3F92C28()
{
}

void sub_1A3F92ED0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A3F92EE8()
{
}

void sub_1A3F9350C(_Unwind_Exception *a1, int a2)
{
  MEMORY[0x1A62562C0](v3, 0x10F1C40885E7AD1);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1A3F93494);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F9359C()
{
}

void sub_1A3F9379C(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3F93840(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F938FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F93ABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F93C70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose((const void *)(v23 - 80), 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__20174(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20175(uint64_t a1)
{
}

void sub_1A3F93E6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F93F1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F940CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F94180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F94270(_Unwind_Exception *a1)
{
  uint64_t v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A3F94348(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F943E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _unavailableTensorKeyError(NSString *a1)
{
  uint64_t v1 = a1;
  unint64_t v2 = (void *)[[NSString alloc] initWithFormat:@"VNDetectionprintTensor '%@' is not available", v1];
  uint64_t v3 = +[VNError errorForInvalidArgumentWithLocalizedDescription:v2];

  return v3;
}

void sub_1A3F94484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9457C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F946A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9480C(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void vision::mod::FaceBoxPoseAligner<signed char>::loadERTModel(uint64_t *a1, void *a2)
{
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNumCascadeStages");
  if (v73.i8[15] < 0) {
    operator delete(__p);
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNumTrees");
  if (v73.i8[15] < 0) {
    operator delete(__p);
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNumPredictions");
  if (v73.i8[15] < 0) {
    operator delete(__p);
  }
  memset(v70, 0, sizeof(v70));
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNodesThresholds");
  if (v73.i8[15] < 0) {
    operator delete(__p);
  }
  memset(v69, 0, sizeof(v69));
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNodesPredictions");
  if (v73.i8[15] < 0) {
    operator delete(__p);
  }
  std::string::basic_string[abi:ne180100]<0>(&v66, "ERTFaceBox::ERTNodesFeatureIDs");
  uint64_t v5 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)&v66);
  if (!v5 || *((_DWORD *)v5 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__p);
    uint64_t v61 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v73.i64[1], (uint64_t)"Error: ", 7);
    if (v68 >= 0) {
      int v62 = &v66;
    }
    else {
      int v62 = v66;
    }
    if (v68 >= 0) {
      uint64_t v63 = HIBYTE(v68);
    }
    else {
      uint64_t v63 = (uint64_t)v67;
    }
    int v64 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v61, (uint64_t)v62, v63);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v64, (uint64_t)" failed to load from ERT model file!", 36);
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)v74);
  }
  unint64_t v7 = (const void *)*((void *)v5 + 6);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v5 + 7);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  size_t v8 = *((void *)v5 + 8);
  if (v8 >= 8)
  {
    unsigned int v9 = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v8 >> 3);
    bzero(v9, v8 & 0xFFFFFFFFFFFFFFF8);
  }
  else
  {
    unsigned int v9 = 0;
  }
  memcpy(v9, v7, v8);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  if (SHIBYTE(v68) < 0) {
    operator delete(v66);
  }
  memset(__dst, 0, sizeof(__dst));
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNodesLeafFlags");
  if (v73.i8[15] < 0) {
    operator delete(__p);
  }
  unint64_t v10 = a1[1] * *a1;
  if (v10)
  {
    int8x8_t v11 = 0;
    unint64_t v12 = (char *)__dst[1] - (char *)__dst[0];
    unint64_t v13 = ((char *)__dst[1] - (char *)__dst[0]) / v10;
    a1[2] = v13;
    long long v66 = 0;
    int v67 = 0;
    uint64_t v68 = 0;
    if (v10 <= v12)
    {
      std::vector<vision::mod::ERTTreeNode>::__vallocate[abi:ne180100](&v66, v13);
      uint64_t v14 = (char *)v67;
      size_t v15 = 48 * ((48 * v13 - 48) / 0x30) + 48;
      bzero(v67, v15);
      int8x8_t v11 = &v14[v15];
      int v67 = v11;
    }
    uint64_t v16 = a1[11];
    long long v17 = (void *)a1[12];
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v17 - v16) >> 3);
    unint64_t v19 = v10 - v18;
    if (v10 <= v18)
    {
      if (v10 < v18)
      {
        unint64_t v37 = (void *)(v16 + 24 * v10);
        if (v17 != v37)
        {
          unint64_t v38 = (void *)a1[12];
          do
          {
            uint64_t v40 = (void *)*(v38 - 3);
            v38 -= 3;
            long long v39 = v40;
            if (v40)
            {
              *(v17 - 2) = v39;
              operator delete(v39);
            }
            long long v17 = v38;
          }
          while (v38 != v37);
        }
        a1[12] = (uint64_t)v37;
      }
    }
    else
    {
      uint64_t v20 = a1[13];
      if (0xAAAAAAAAAAAAAAABLL * ((v20 - (uint64_t)v17) >> 3) >= v19)
      {
        long long v41 = &v17[3 * v19];
        uint64_t v42 = v66;
        unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((v11 - (unsigned char *)v66) >> 4);
        uint64_t v44 = 24 * v10 - 8 * (((uint64_t)v17 - v16) >> 3);
        do
        {
          void *v17 = 0;
          v17[1] = 0;
          v17[2] = 0;
          std::vector<vision::mod::ERTTreeNode>::__init_with_size[abi:ne180100]<vision::mod::ERTTreeNode*,vision::mod::ERTTreeNode*>(v17, v42, (uint64_t)v11, v43);
          v17 += 3;
          v44 -= 24;
        }
        while (v44);
        a1[12] = (uint64_t)v41;
      }
      else
      {
        if (v10 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v20 - v16) >> 3);
        uint64_t v22 = 2 * v21;
        if (2 * v21 <= v10) {
          uint64_t v22 = v10;
        }
        if (v21 >= 0x555555555555555) {
          unint64_t v23 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v23 = v22;
        }
        v74[1] = a1 + 13;
        if (v23 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        unint64_t v24 = (char *)operator new(24 * v23);
        uint64_t v25 = 3 * v18;
        uint8x8_t v26 = &v24[24 * v18];
        std::string __p = v24;
        v73.i64[0] = (uint64_t)v26;
        v73.i64[1] = (uint64_t)v26;
        v74[0] = &v24[24 * v23];
        unint64_t v27 = &v24[24 * v10];
        BOOL v28 = v66;
        unint64_t v29 = v67;
        unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)v67 - (unsigned char *)v66) >> 4);
        uint64_t v31 = 24 * v10 - 8 * v25;
        do
        {
          *(void *)uint8x8_t v26 = 0;
          *((void *)v26 + 1) = 0;
          *((void *)v26 + 2) = 0;
          std::vector<vision::mod::ERTTreeNode>::__init_with_size[abi:ne180100]<vision::mod::ERTTreeNode*,vision::mod::ERTTreeNode*>(v26, v28, (uint64_t)v29, v30);
          v26 += 24;
          v31 -= 24;
        }
        while (v31);
        v73.i64[1] = (uint64_t)v27;
        long long v33 = (void *)a1[11];
        uint64_t v32 = (void *)a1[12];
        uint64_t v34 = v73.i64[0];
        if (v32 == v33)
        {
          int64x2_t v36 = vdupq_n_s64((unint64_t)v32);
        }
        else
        {
          do
          {
            *(void *)(v34 - 24) = 0;
            *(void *)(v34 - 16) = 0;
            v34 -= 24;
            *(void *)(v34 + 16) = 0;
            long long v35 = *(_OWORD *)(v32 - 3);
            v32 -= 3;
            *(_OWORD *)uint64_t v34 = v35;
            *(void *)(v34 + 16) = v32[2];
            void *v32 = 0;
            v32[1] = 0;
            v32[2] = 0;
          }
          while (v32 != v33);
          int64x2_t v36 = *(int64x2_t *)(a1 + 11);
          unint64_t v27 = (char *)v73.i64[1];
        }
        a1[11] = v34;
        a1[12] = (uint64_t)v27;
        int64x2_t v73 = v36;
        uint64_t v45 = a1[13];
        a1[13] = v74[0];
        v74[0] = v45;
        std::string __p = (void *)v36.i64[0];
        std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)&__p);
      }
    }
    if (v66) {
      operator delete(v66);
    }
    uint64_t v46 = 0;
    uint64_t v47 = a1[2];
    uint64_t v48 = v70[0];
    long long v49 = __dst[0];
    unint64_t v50 = (char *)v69[0];
    do
    {
      if (v47)
      {
        uint64_t v51 = 0;
        uint64_t v52 = v47 * v46;
        uint64_t v53 = *(void *)(a1[11] + 24 * v46);
        int v54 = (_DWORD *)(v53 + 16);
        uint64_t v55 = (int *)v50;
        do
        {
          uint64_t v56 = v53 + 48 * v51;
          *(_DWORD *)uint64_t v56 = v48[v52 + v51];
          *(void *)(v56 + 8) = *((void *)v9 + v52 + v51);
          *(unsigned char *)(v56 + 44) = v49[v52 + v51] != 0;
          long long v57 = v55;
          long long v58 = v54;
          for (uint64_t i = SizeFromBytesHelper; i; --i)
          {
            int v60 = *v57++;
            *v58++ = v60;
          }
          ++v51;
          v54 += 12;
          v55 += SizeFromBytesHelper;
        }
        while (v51 != v47);
      }
      ++v46;
      v50 += 4 * v47 * SizeFromBytesHelper;
    }
    while (v46 != v10);
  }
  else
  {
    syslog(5, "Loading ERT model failed - unexpected zero number of trees");
  }
  if (__dst[0])
  {
    __dst[1] = __dst[0];
    operator delete(__dst[0]);
  }
  if (v9) {
    operator delete(v9);
  }
  if (v69[0]) {
    operator delete(v69[0]);
  }
  if (v70[0]) {
    operator delete(v70[0]);
  }
}

#error "1A3F95190: call analysis failed (funcsize=48)"

void vision::mod::FaceBoxPoseAligner<signed char>::loadGlobalShifts(void *a1, char **a2)
{
  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTGlobalShift");
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

#error "1A3F95274: call analysis failed (funcsize=28)"

void vision::mod::FaceBoxPoseAligner<signed char>::loadXYPairs(uint64_t a1, void *a2, char **a3)
{
  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTNumXYPairs");
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTXYPairs");
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

#error "1A3F9539C: call analysis failed (funcsize=29)"

void vision::mod::FaceBoxPoseAligner<signed char>::loadDefaultPixelValue(void *a1, unsigned char *a2)
{
  size_t v8 = 0;
  unsigned int v9 = 0;
  uint64_t v10 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTDefaultPixelValue");
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v4 = v8;
  if (v9 == v8)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(__p, "ERROR: ERTDefaultPixelValue failed to load from ERT model file!");
  }
  *a2 = *v8;
  unsigned int v9 = v4;
  operator delete(v4);
}

#error "1A3F9553C: call analysis failed (funcsize=40)"

void vision::mod::FaceBoxPoseAligner<signed char>::loadDefaultFeatureValue(void *a1, unsigned char *a2)
{
  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTDefaultFeatureValue");
  uint64_t v4 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a1, (unsigned __int8 *)__p);
  if (!v4 || *((_DWORD *)v4 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v19);
    uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v20, (uint64_t)"Error: ", 7);
    if ((v17 & 0x80u) == 0) {
      int8x8_t v11 = __p;
    }
    else {
      int8x8_t v11 = (void **)__p[0];
    }
    if ((v17 & 0x80u) == 0) {
      uint64_t v12 = v17;
    }
    else {
      uint64_t v12 = (uint64_t)__p[1];
    }
    unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)v11, v12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" failed to load from ERT model file!", 36);
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&__dst, (uint64_t)&v21);
  }
  char v5 = (const void *)*((void *)v4 + 6);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 7);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  size_t v7 = *((void *)v4 + 8);
  if (v7)
  {
    if ((v7 & 0x8000000000000000) != 0) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    size_t v8 = operator new(*((void *)v4 + 8));
    unsigned int v9 = &v8[v7];
    bzero(v8, v7);
  }
  else
  {
    size_t v8 = 0;
    unsigned int v9 = 0;
  }
  memcpy(v8, v5, v7);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  if ((char)v17 < 0) {
    operator delete(__p[0]);
  }
  if (v9 == v8)
  {
    size_t v15 = __cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(&v19, "ERROR: ERTDefaultFeatureValue failed to load from ERT model file!");
  }
  *a2 = *v8;
  operator delete(v8);
}

#error "1A3F95884: call analysis failed (funcsize=46)"

void std::vector<vision::mod::ERTTree>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    char v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (char *)v1[1];
      do
      {
        size_t v8 = (void *)*((void *)v6 - 3);
        v6 -= 24;
        size_t v7 = v8;
        if (v8)
        {
          *((void *)v4 - 2) = v7;
          operator delete(v7);
        }
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      char v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *vision::mod::anonymous namespace'::BoxAlignerException::BoxAlignerException(void *a1, long long *a2)
{
  *a1 = &unk_1EF7521D8;
  uint64_t v3 = (std::string *)(a1 + 1);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    v3->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = v4;
  }
  return a1;
}

void sub_1A3F959B4(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void vision::mod::anonymous namespace'::BoxAlignerException::~BoxAlignerException(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF7521D8;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }

  std::exception::~exception(this);
}

{
  uint64_t vars8;

  this->__vftable = (std::exception_vtbl *)&unk_1EF7521D8;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);

  JUMPOUT(0x1A62562C0);
}

uint64_t vision::mod::anonymous namespace'::BoxAlignerException::what(vision::mod::_anonymous_namespace_::BoxAlignerException *this)
{
  uint64_t result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void vision::mod::anonymous namespace'::readTypedVectorFromBytesHelper<unsigned char>(uint64_t a1, void *a2, unint64_t *a3)
{
  char v5 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)a1);
  if (!v5 || *((_DWORD *)v5 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v18);
    int8x8_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v19, (uint64_t)"Error: ", 7);
    int v12 = *(char *)(a1 + 23);
    if (v12 >= 0) {
      uint64_t v13 = a1;
    }
    else {
      uint64_t v13 = *(void *)a1;
    }
    if (v12 >= 0) {
      uint64_t v14 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      uint64_t v14 = *(void *)(a1 + 8);
    }
    size_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, v13, v14);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" failed to load from ERT model file!", 36);
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v17, (uint64_t)&v20);
  }
  size_t v7 = (const void *)*((void *)v5 + 6);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v5 + 7);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  size_t v8 = *((void *)v5 + 8);
  unsigned int v9 = (void *)*a3;
  size_t v10 = a3[1] - *a3;
  if (v8 <= v10)
  {
    if (v8 < v10) {
      a3[1] = (unint64_t)v9 + v8;
    }
  }
  else
  {
    std::vector<unsigned char>::__append(a3, v8 - v10);
    unsigned int v9 = (void *)*a3;
  }
  memcpy(v9, v7, v8);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1A3F95C30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t vision::mod::anonymous namespace'::readSizeFromBytesHelper(uint64_t a1, void *a2)
{
  uint64_t v3 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)a1);
  if (!v3 || *((_DWORD *)v3 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v21);
    size_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Error: ", 7);
    int v9 = *(char *)(a1 + 23);
    if (v9 >= 0) {
      uint64_t v10 = a1;
    }
    else {
      uint64_t v10 = *(void *)a1;
    }
    if (v9 >= 0) {
      uint64_t v11 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      uint64_t v11 = *(void *)(a1 + 8);
    }
    int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, v10, v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" failed to load from ERT model file!", 36);
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v20, (uint64_t)v23);
  }
  long long v4 = (uint64_t *)*((void *)v3 + 6);
  char v5 = (std::__shared_weak_count *)*((void *)v3 + 7);
  if (!v5)
  {
    if (*((void *)v3 + 8) == 8) {
      return *v4;
    }
LABEL_16:
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v21);
    uint64_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Error: ", 7);
    int v15 = *(char *)(a1 + 23);
    if (v15 >= 0) {
      uint64_t v16 = a1;
    }
    else {
      uint64_t v16 = *(void *)a1;
    }
    if (v15 >= 0) {
      uint64_t v17 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      uint64_t v17 = *(void *)(a1 + 8);
    }
    unint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, v16, v17);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" unexpected size of value", 25);
    uint64_t v19 = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v20, (uint64_t)v23);
  }
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  if (*((void *)v3 + 8) != 8) {
    goto LABEL_16;
  }
  uint64_t v6 = *v4;
  std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  return v6;
}

void sub_1A3F95E6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
      if (v15) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v15);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void vision::mod::anonymous namespace'::readTypedVectorFromBytesHelper<float>(uint64_t a1, void *a2, char **a3)
{
  char v5 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)a1);
  if (!v5 || *((_DWORD *)v5 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v16);
    int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, (uint64_t)"Error: ", 7);
    int v10 = *(char *)(a1 + 23);
    if (v10 >= 0) {
      uint64_t v11 = a1;
    }
    else {
      uint64_t v11 = *(void *)a1;
    }
    if (v10 >= 0) {
      uint64_t v12 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      uint64_t v12 = *(void *)(a1 + 8);
    }
    uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, v11, v12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" failed to load from ERT model file!", 36);
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v15, (uint64_t)&v18);
  }
  size_t v7 = (const void *)*((void *)v5 + 6);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v5 + 7);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  size_t v8 = *((void *)v5 + 8);
  std::vector<float>::resize(a3, v8 >> 2);
  memcpy(*a3, v7, v8);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1A3F96070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void *std::vector<vision::mod::ERTTreeNode>::__init_with_size[abi:ne180100]<vision::mod::ERTTreeNode*,vision::mod::ERTTreeNode*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<vision::mod::ERTTreeNode>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8 - 3);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3F96134(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<vision::mod::ERTTreeNode>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v3 = 3 * a2;
  uint64_t result = (char *)operator new(48 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v3];
  return result;
}

void sub_1A3F963F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F96604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F969C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F96C58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F96D60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F96E34(_Unwind_Exception *a1)
{
}

void sub_1A3F97100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void addSpan(int *a1, uint64_t a2)
{
  if (!a1) {
    __assert_rtn("addSpan", "Spans.c", 88, "spl != NULL");
  }
  int v4 = *a1;
  int v5 = a1[1];
  if (*a1 < v5 - 1)
  {
    uint64_t v6 = (void *)*((void *)a1 + 1);
LABEL_9:
    v6[v4] = a2;
    ++*a1;
    return;
  }
  if (v5 <= 2) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = 2 * v5;
  }
  uint64_t v8 = malloc_type_malloc(8 * v7, 0x100004000313F17uLL);
  if (v8)
  {
    uint64_t v6 = v8;
    memcpy(v8, *((const void **)a1 + 1), 8 * *a1);
    bzero(&v6[*a1], 8 * (int)(v7 - *a1));
    a1[1] = v7;
    free(*((void **)a1 + 1));
    *((void *)a1 + 1) = v6;
    int v4 = *a1;
    goto LABEL_9;
  }
}

void sub_1A3F983F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F98544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9860C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F98A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, _Unwind_Exception *exception_object, void *a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F98C74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F99010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F992B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3F99310()
{
}

void sub_1A3F99318()
{
}

void sub_1A3F99320()
{
}

void sub_1A3F9968C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  std::__shared_weak_count::~__shared_weak_count(v12);
  operator delete(v14);
  _Unwind_Resume(a1);
}

BOOL horizonDetectionFFT(uint64_t a1, int a2, int a3, int a4, float *a5, int a6)
{
  v13[0] = a1;
  v13[1] = a4;
  void v13[2] = a3;
  v13[3] = a2;
  int Angles = HorizonDetection::getAngles((uint64_t)v13, a6 != 0, &v12, (float *)v13, 0.0);
  if (Angles == 1)
  {
    float v8 = (float)(v12 * -180.0) / 3.14159265;
    if (v8 <= 135.0)
    {
      if (v8 < 45.0)
      {
LABEL_7:
        float v10 = v8 * 3.14159265 / -180.0;
        *a5 = v10;
        return Angles == 1;
      }
      float v9 = -90.0;
    }
    else
    {
      float v9 = -180.0;
    }
    float v8 = v8 + v9;
    goto LABEL_7;
  }
  return Angles == 1;
}

unint64_t HorizonDetection::getAngles(uint64_t a1, int a2, float *a3, float *a4, float a5)
{
  ++HorizonDetection::frameCount_;
  unint64_t v11 = *(void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 16);
  if (a2) {
    int v12 = 4;
  }
  else {
    int v12 = 1;
  }
  std::vector<unsigned char,apple::vision::AlignedAllocator<unsigned char,32ul>>::vector(data, (v12 << 16));
  if (a2) {
    CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceRGB();
  }
  else {
    CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceGray();
  }
  uint64_t v14 = DeviceRGB;
  long long v15 = CGDataProviderCreateWithData(0, *(const void **)a1, *(void *)(a1 + 8) * *(void *)(a1 + 24), 0);
  if (a2) {
    size_t v16 = 32;
  }
  else {
    size_t v16 = 8;
  }
  uint64_t v17 = CGImageCreate(*(void *)(a1 + 16), *(void *)(a1 + 8), 8uLL, v16, *(void *)(a1 + 24), v14, 5u, v15, 0, 1, kCGRenderingIntentDefault);
  uint64_t v18 = CGBitmapContextCreate(data[0], 0x100uLL, 0x100uLL, 8uLL, (v12 << 8), v14, 5u);
  CGContextSetInterpolationQuality(v18, kCGInterpolationHigh);
  v99.size.width = 256.0;
  v99.origin.x = 0.0;
  v99.origin.y = 0.0;
  v99.size.height = 256.0;
  CGContextDrawImage(v18, v99, v17);
  Image = CGBitmapContextCreateImage(v18);
  CGContextRelease(v18);
  CGImageRelease(v17);
  CGImageRelease(Image);
  CGDataProviderRelease(v15);
  CGColorSpaceRelease(v14);
  std::vector<unsigned char,apple::vision::AlignedAllocator<unsigned char,32ul>>::vector(v90, 0x10000uLL);
  cannyEdgeWithGradientOutput((unsigned char *)data[0], v90[0], 0, 0, 0.55, 0.7);
  thinBin((long long *)v90[0]);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(v98, 0x10000);
  *(int64x2_t *)&src.height = vdupq_n_s64(0x100uLL);
  src.rowBytes = 256;
  dest.data = v98[0];
  *(_OWORD *)&dest.height = *(_OWORD *)&src.height;
  dest.rowBytes = 1024;
  src.data = v90[0];
  vImageConvert_Planar8toPlanarF(&src, &dest, 1.0, 0.0, 0);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(v89, 0x10000);
  fftGrayMag((const DSPComplex *)v98[0], (_DWORD *)v89[0], 0);
  if (v98[0])
  {
    v98[1] = v98[0];
    free(v98[0]);
  }
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(v88, 1440);
  fftProject((uint64_t)v89[0], (float *)v88[0], (float *)&src, 0.0);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(&v94, 1440);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(&src, 1440);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(&dest, 1440);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(v98, 1440);
  long long v20 = malloc_type_aligned_alloc(0x20uLL, 0x1680uLL, 0x100004052888210uLL);
  uint64_t v21 = v20;
  float v87 = a5;
  if (!v20)
  {
    exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    char v86 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v86, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  float v22 = (float)v10 / (float)v11;
  float v23 = (float)v11 / (float)v10;
  bzero(v20 + 1, 0x167CuLL);
  if (v22 >= v23) {
    float v24 = 1.0;
  }
  else {
    float v24 = (float)v11 / (float)v10;
  }
  if (v22 >= v23) {
    float v25 = (float)v10 / (float)v11;
  }
  else {
    float v25 = 1.0;
  }
  float v26 = atan2f(v25 * -0.0010908, v24 * 1.0) * 458.366236 + 1440.0;
  float v27 = atan2f(v25 * 0.0010908, v24 * 1.0) * 458.366236;
  float v28 = modff(v26, (float *)&v97 + 1);
  float v29 = modff(v27, (float *)&v97);
  unint64_t v30 = (float *)src.data;
  *(float *)src.data = 1.0 - v28;
  uint64_t v31 = dest.data;
  *(float *)dest.data = v29;
  uint64_t v32 = (float *)v98[0];
  *(_DWORD *)v98[0] = 0;
  *uint64_t v21 = 0;
  for (uint64_t i = 1; i != 1440; ++i)
  {
    float v34 = (float)((float)(int)i + -0.5) * 3.14159265 / 1440.0;
    __float2 v35 = __sincosf_stret(v34);
    float v36 = atan2f(v25 * v35.__sinval, v24 * v35.__cosval) * 458.366236;
    float v37 = (float)(int)i * 3.14159265 / 1440.0;
    __float2 v38 = __sincosf_stret(v37);
    float v39 = atan2f(v25 * v38.__sinval, v24 * v38.__cosval) * 458.366236;
    float v40 = (float)((float)(int)i + 0.5) * 3.14159265 / 1440.0;
    __float2 v41 = __sincosf_stret(v40);
    float v42 = atan2f(v25 * v41.__sinval, v24 * v41.__cosval) * 458.366236;
    uint64_t v97 = 0;
    float v43 = modff(v36, (float *)&v97 + 1);
    float v44 = modff(v42, (float *)&v97);
    int v45 = (int)*((float *)&v97 + 1);
    float v46 = *(float *)&v97;
    v21[i] = (int)v39;
    int v47 = (int)v46 - v45;
    if (v47 == 2)
    {
      v30[i] = 1.0 - v43;
      v31[i] = 1065353216;
      goto LABEL_27;
    }
    if (v47 != 1)
    {
      if (v47) {
        continue;
      }
      v30[i] = 0.0;
      float v44 = v44 - v43;
      goto LABEL_29;
    }
    if (v45 == (int)v39)
    {
      v30[i] = 0.0;
      *(float *)&v31[i] = 1.0 - v43;
LABEL_27:
      v32[i] = v44;
      continue;
    }
    v30[i] = 1.0 - v43;
LABEL_29:
    *(float *)&v31[i] = v44;
    v32[i] = 0.0;
  }
  uint64_t v48 = 0;
  long long v49 = (float *)v88[0];
  unint64_t v50 = v94;
  do
  {
    float v51 = v49[v48];
    float v52 = v51 * *(float *)&v31[v48];
    uint64_t v53 = (int)v21[v48];
    if (v53 >= 1) {
      int v54 = -1;
    }
    else {
      int v54 = 1439;
    }
    float v55 = v32[v48];
    v50[v54 + (int)v53] = (float)(v51 * v30[v48]) + v50[v54 + (int)v53];
    if (v53 <= 1438) {
      int v56 = v53 + 1;
    }
    else {
      int v56 = v53 - 1439;
    }
    v50[v53] = v52 + v50[v53];
    v50[v56] = (float)(v51 * v55) + v50[v56];
    ++v48;
  }
  while (v48 != 1440);
  free(v21);
  free(v32);
  free(v31);
  free(v30);
  long long v57 = v94;
  long long v58 = v95;
  uint64_t v94 = 0;
  char v95 = 0;
  uint64_t v96 = 0;
  v59.i32[0] = *(__int32 *)std::__minmax_element_impl[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>,std::__identity,std::__less<void,void>>(v57, v58);
  float v61 = *v60;
  if (*v60 != 1.0 && (*(float *)v59.i32 != 0.0 ? (BOOL v62 = *(float *)v59.i32 == v61) : (BOOL v62 = 0), v62))
  {
    if ((char *)v58 - (char *)v57 >= 1) {
      memset_pattern16(v57, &unk_1A410C510, 4 * (((unint64_t)((char *)v58 - (char *)v57) >> 2) - ((unint64_t)((char *)v58 - (char *)v57) > 3))+ 4);
    }
  }
  else
  {
    float v63 = v61 - *(float *)v59.i32;
    float32x4_t v64 = (float32x4_t)vdupq_lane_s32(v59, 0);
    uint64_t v65 = 0x3FFFFFFFFFFFFA60;
    float v66 = 1.0 / v63;
    do
    {
      int v67 = (float32x4_t *)&v57[v65];
      float32x4_t v68 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)&v57[v65 + 1444], v64), v66);
      v67[360] = vmulq_n_f32(vsubq_f32(*(float32x4_t *)&v57[v65 + 1440], v64), v66);
      v67[361] = v68;
      v65 += 8;
    }
    while (v65 * 4);
  }
  if (v57 == v58)
  {
    int v70 = a3;
  }
  else
  {
    float v69 = 0.0;
    int v70 = a3;
    int v71 = v57;
    do
    {
      float v72 = *v71;
      int64x2_t v73 = a3;
      if (v70 != a3)
      {
        unint64_t v74 = ((char *)v70 - (char *)a3) >> 3;
        int64x2_t v73 = a3;
        do
        {
          unint64_t v75 = v74 >> 1;
          unint64_t v76 = &v73[2 * (v74 >> 1)];
          float v77 = v76[1];
          int v78 = v76 + 2;
          v74 += ~(v74 >> 1);
          if (v77 < v72) {
            unint64_t v74 = v75;
          }
          else {
            int64x2_t v73 = v78;
          }
        }
        while (v74);
      }
      if (v73 != a4)
      {
        int v79 = a3;
        float v80 = (float)(v69 * -3.1416) / 1440.0;
        if (v73 == a3)
        {
LABEL_61:
          if (v73 == v70)
          {
LABEL_65:
            uint64_t v81 = v70;
          }
          else
          {
            uint64_t v81 = v73;
            while (vabds_f32(*v81, v80) >= v87)
            {
              v81 += 2;
              if (v81 == v70) {
                goto LABEL_65;
              }
            }
            if (v81 != v70)
            {
              for (uint64_t j = v81 + 2; j != v70; j += 2)
              {
                if (vabds_f32(*j, v80) >= v87)
                {
                  *(void *)uint64_t v81 = *(void *)j;
                  v81 += 2;
                }
              }
            }
          }
          uint64_t v82 = v81 + 2;
          if (v82 <= a4) {
            int v70 = v82;
          }
          else {
            int v70 = a4;
          }
          if (v73 < v70 && v70 - 2 != v73) {
            memmove(v73 + 2, v73, (char *)(v70 - 2) - (char *)v73);
          }
          *int64x2_t v73 = v80;
          v73[1] = v72;
        }
        else
        {
          while (vabds_f32(*v79, v80) >= v87)
          {
            v79 += 2;
            if (v79 == v73) {
              goto LABEL_61;
            }
          }
        }
      }
      float v69 = v69 + 1.0;
      ++v71;
    }
    while (v71 != v58);
  }
  if (v57) {
    free(v57);
  }
  if (v88[0])
  {
    v88[1] = v88[0];
    free(v88[0]);
  }
  if (v89[0])
  {
    v89[1] = v89[0];
    free(v89[0]);
  }
  if (v90[0])
  {
    v90[1] = v90[0];
    free(v90[0]);
  }
  if (data[0])
  {
    data[1] = data[0];
    free(data[0]);
  }
  return (unint64_t)((char *)v70 - (char *)a3) >> 3;
}

void sub_1A3F99FB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33)
{
  if (a24) {
    free(a24);
  }
  if (a28) {
    free(a28);
  }
  if (a32) {
    free(a32);
  }
  if (a12) {
    free(a12);
  }
  if (a15) {
    free(a15);
  }
  if (a18) {
    free(a18);
  }
  if (a21) {
    free(a21);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  size_t v4 = 4 * a2;
  int v5 = (char *)malloc_type_aligned_alloc(0x20uLL, 4 * a2, 0x100004052888210uLL);
  uint64_t v6 = v5;
  if (!v5)
  {
    exceptiouint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    float v9 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v9, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  *a1 = v5;
  a1[2] = &v5[4 * a2];
  bzero(v5, v4);
  a1[1] = &v6[v4];
  return a1;
}

void sub_1A3F9A170(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<unsigned char,apple::vision::AlignedAllocator<unsigned char,32ul>>::vector(void *a1, size_t size)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  size_t v4 = (char *)apple::vision::AlignedAllocator<unsigned char,32ul>::allocate(size);
  *a1 = v4;
  int v5 = &v4[size];
  a1[2] = &v4[size];
  bzero(v4, size);
  a1[1] = v5;
  return a1;
}

void sub_1A3F9A1E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t horizonDetectionFFTAngles(uint64_t a1, int a2, int a3, int a4, int a5, int a6, float *a7, float a8)
{
  v9[0] = a1;
  v9[1] = a4;
  v9[2] = a3;
  v9[3] = a2;
  return HorizonDetection::getAngles((uint64_t)v9, a5, a7, &a7[2 * a6], a8);
}

void sub_1A3F9A2C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9A660(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9A78C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9A960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9AA10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9AA5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9ABFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *std::vector<vImage_Buffer>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void sub_1A3F9B7EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,uint64_t a60,void *a61,uint64_t a62)
{
  if (__p) {
    operator delete(__p);
  }
  if (a61) {
    operator delete(a61);
  }

  _Unwind_Resume(a1);
}

void sub_1A3F9BCDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9BEE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9BFB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9C130(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9C2A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9C354(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9C538(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9C758(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9C8D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9C91C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9CABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::GazeFollowPredictorConcrete>::__on_zero_shared(uint64_t a1)
{
  if (espresso_plan_destroy())
  {
    syslog(5, "[Espresso Error]: Failed to destroy the existing GazeFollow espresso plan");
LABEL_5:
    syslog(5, "[Error]: Failed to destroy GazeFollowPredictor object");
    goto LABEL_6;
  }
  *(void *)(a1 + 376) = 0;
  if (espresso_context_destroy())
  {
    syslog(5, "[Espresso Error]: Failed to destroy the existing GazeFollow context");
    goto LABEL_5;
  }
  *(void *)(a1 + 368) = 0;
LABEL_6:
  if (*(char *)(a1 + 927) < 0) {
    operator delete(*(void **)(a1 + 904));
  }
}

double vision::mod::GazeFollowPredictor::releaseCachedImageBuffers(void **this)
{
  free(this[12]);
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  free(this[16]);
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  free(this[20]);
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  free(this[24]);
  double result = 0.0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  return result;
}

void std::__shared_ptr_emplace<vision::mod::GazeFollowPredictorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753888;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::GazeFollowPredictorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753888;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::vector<std::vector<float>>::resize(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  uint64_t v6 = (void *)a1[1];
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v6 - *a1) >> 3);
  unint64_t v8 = a2 - v7;
  if (a2 <= v7)
  {
    if (a2 < v7)
    {
      long long v20 = (void *)(v5 + 24 * a2);
      if (v6 != v20)
      {
        uint64_t v21 = (void *)a1[1];
        do
        {
          float v23 = (void *)*(v21 - 3);
          v21 -= 3;
          float v22 = v23;
          if (v23)
          {
            *(v6 - 2) = v22;
            operator delete(v22);
          }
          uint64_t v6 = v21;
        }
        while (v21 != v20);
      }
      a1[1] = (uint64_t)v20;
    }
  }
  else
  {
    uint64_t v10 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v10 - (uint64_t)v6) >> 3) >= v8)
    {
      float v24 = &v6[3 * v8];
      uint64_t v25 = 24 * a2 - 8 * (((uint64_t)v6 - *a1) >> 3);
      do
      {
        void *v6 = 0;
        v6[1] = 0;
        v6[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v6, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
        v6 += 3;
        v25 -= 24;
      }
      while (v25);
      a1[1] = (uint64_t)v24;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      float v29 = a1 + 2;
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v5) >> 3);
      uint64_t v12 = 2 * v11;
      if (2 * v11 <= a2) {
        uint64_t v12 = a2;
      }
      if (v11 >= 0x555555555555555) {
        unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v13 = v12;
      }
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v13);
      long long v15 = &v14[24 * v7];
      v26[0] = v14;
      v26[1] = v15;
      float v27 = v15;
      float v28 = &v14[24 * v16];
      uint64_t v17 = 3 * a2;
      uint64_t v18 = &v14[24 * a2];
      uint64_t v19 = 8 * v17 - 24 * v7;
      do
      {
        *(void *)long long v15 = 0;
        *((void *)v15 + 1) = 0;
        *((void *)v15 + 2) = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v15, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
        v15 += 24;
        v19 -= 24;
      }
      while (v19);
      float v27 = v18;
      std::vector<std::vector<CGPoint>>::__swap_out_circular_buffer(a1, v26);
      std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)v26);
    }
  }
}

void sub_1A3F9CF24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

void std::vector<float>::resize(char **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v7 = (v5 - *a1) >> 2;
  if (a2 <= v7)
  {
    if (a2 < v7) {
      a1[1] = &v6[4 * a2];
    }
  }
  else
  {
    float v9 = a1[2];
    if (a2 - v7 <= (v9 - v5) >> 2)
    {
      float v23 = &v5[4 * (a2 - v7)];
      uint64_t v24 = 4 * a2 - 4 * v7;
      do
      {
        *(_DWORD *)uint64_t v5 = *a3;
        v5 += 4;
        v24 -= 4;
      }
      while (v24);
      a1[1] = v23;
    }
    else
    {
      if (a2 >> 62) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v10 = v9 - v6;
      unint64_t v11 = (v9 - v6) >> 1;
      if (v11 <= a2) {
        unint64_t v11 = a2;
      }
      if (v10 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v12);
      long long v15 = &v13[4 * v7];
      uint64_t v16 = &v13[4 * a2];
      uint64_t v17 = 4 * a2 - 4 * v7;
      uint64_t v18 = v15;
      do
      {
        *(_DWORD *)uint64_t v18 = *a3;
        v18 += 4;
        v17 -= 4;
      }
      while (v17);
      uint64_t v19 = &v13[4 * v14];
      long long v20 = *a1;
      for (uint64_t i = a1[1]; i != v20; i -= 4)
      {
        int v22 = *((_DWORD *)i - 1);
        *((_DWORD *)v15 - 1) = v22;
        v15 -= 4;
      }
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (v20)
      {
        operator delete(v20);
      }
    }
  }
}

uint64_t vision::mod::GazeFollowPredictor::postProcessGazeLabels(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    float v4 = *(float *)a4;
    float v5 = *(float *)(a4 + 8);
    uint64_t v6 = a2;
    do
    {
      if (!*(_DWORD *)(v6 + 16) && *(float *)(v6 + 48) >= v4 && (*(float *)(v6 + 12) >= v5 || *(float *)(v6 + 8) >= v5))
      {
        int v8 = 0;
        signed int v9 = *(_DWORD *)(a4 + 4);
        for (uint64_t i = a2; i != a3; i += 136)
        {
          if (*(_DWORD *)(i + 16) != -1
            && (vabds_f32(*(float *)v6, *(float *)i) >= 0.00000011921
             || vabds_f32(*(float *)(v6 + 4), *(float *)(i + 4)) >= 0.00000011921))
          {
            float v11 = *(float *)(i + 8);
            float v12 = *(float *)(i + 12);
            if (v12 >= v5 || v11 >= v5)
            {
              int v14 = *(_DWORD *)(v6 + 52);
              int v15 = v14
                  - llroundf((float)(*(float *)i + (float)(v12 * 0.5))* (float)(unint64_t)(*(void *)(result + 232) - 1));
              if (v15 < 0) {
                int v15 = -v15;
              }
              if (v15 <= v9)
              {
                signed int v16 = *(_DWORD *)(v6 + 56)
                    - llroundf((float)((float)(v11 * 0.5) + *(float *)(i + 4))* (float)(unint64_t)(*(void *)(result + 240) - 1));
                if (v16 < 0) {
                  signed int v16 = -v16;
                }
                if (v16 <= v9)
                {
                  *(_DWORD *)(v6 + 16) = 3;
                  *(_DWORD *)(v6 + 60) = v8;
                  break;
                }
              }
              int v17 = v14 - *(_DWORD *)(i + 52);
              if (v17 < 0) {
                int v17 = -v17;
              }
              if (v17 <= v9)
              {
                int v18 = *(_DWORD *)(v6 + 56) - *(_DWORD *)(i + 56);
                if (v18 < 0) {
                  int v18 = *(_DWORD *)(i + 56) - *(_DWORD *)(v6 + 56);
                }
                if (v18 <= v9 && *(float *)(i + 48) >= v4) {
                  *(_DWORD *)(v6 + 16) = 4;
                }
              }
            }
          }
          ++v8;
        }
      }
      v6 += 136;
    }
    while (v6 != a3);
  }
  return result;
}

void sub_1A3F9D364(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9D41C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9D520(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9D7A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9D8B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9D96C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9DA44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9DA90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9DB08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9DB54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9E1B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9E7A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, void *a20,void *a21,void *a22)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9F3B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,void *a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,void *a34,void *a35,void *a36)
{
  objc_destroyWeak((id *)&STACK[0x308]);
  _Block_object_dispose(&STACK[0x310], 8);
  _Block_object_dispose((const void *)(v37 - 248), 8);

  float v39 = *(void **)(v37 - 200);
  if (v39)
  {
    *(void *)(v37 - 192) = v39;
    operator delete(v39);
  }

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__21204(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__21205(uint64_t a1)
{
}

uint64_t __Block_byref_object_copy__46_21206(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A3F9F7DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9FAE8()
{
}

void sub_1A3F9FB3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  objc_end_catch();

  JUMPOUT(0x1A3F9FB88);
}

void sub_1A3F9FC2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3F9FE50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA003C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA0188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA0334(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA04C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA05B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA0890(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    id v9 = objc_begin_catch(a1);
    id v10 = [NSString alloc];
    uint64_t v13 = [v9 reason];
    float v11 = (void *)[v10 initWithFormat:@"Failed to unarchive VNFaceLandmarkRegion object. Error: %@"];

    float v12 = +[VNError errorForInternalErrorWithLocalizedDescription:v11];
    [v2 failWithError:v12];

    objc_end_catch();
    JUMPOUT(0x1A3FA067CLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FA099C()
{
  objc_end_catch();
  JUMPOUT(0x1A3FA08F4);
}

void sub_1A3FA0A7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA0AC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA0CC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA0F2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA10DC(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA1108()
{
}

void sub_1A3FA1274(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA129C()
{
}

void sub_1A3FA13F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA1684(_Unwind_Exception *a1, int a2)
{
  int v8 = v5;

  if (a2 == 1)
  {
    id v10 = objc_begin_catch(a1);
    id v11 = [NSString alloc];
    int v14 = [v10 reason];
    float v12 = (void *)[v11 initWithFormat:@"Failed to unarchive VNFaceLandmarkRegion2D object. Error: %@"];

    uint64_t v13 = +[VNError errorForInternalErrorWithLocalizedDescription:v12];
    [v2 failWithError:v13];

    objc_end_catch();
    JUMPOUT(0x1A3FA165CLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FA1814(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA19B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA1BA4(_Unwind_Exception *a1, int a2)
{
  int v8 = v5;

  if (a2 == 1)
  {
    id v10 = objc_begin_catch(a1);
    id v11 = [NSString alloc];
    int v14 = [v10 reason];
    float v12 = (void *)[v11 initWithFormat:@"Failed to unarchive VNFaceLandmarkRegion3D object. Error: %@"];

    uint64_t v13 = +[VNError errorForInternalErrorWithLocalizedDescription:v12];
    [v2 failWithError:v13];

    objc_end_catch();
    JUMPOUT(0x1A3FA1B7CLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FA1D94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA1F4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA217C(_Unwind_Exception *a1)
{
  float v5 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3FA2410(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA2658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA2A5C(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    id v10 = objc_begin_catch(a1);
    id v11 = [NSString alloc];
    int v14 = [v10 reason];
    float v12 = (void *)[v11 initWithFormat:@"Failed to unarchive VNFaceLandmarks object. Error: %@"];

    uint64_t v13 = +[VNError errorForInternalErrorWithLocalizedDescription:v12];
    [v2 failWithError:v13];

    objc_end_catch();
    JUMPOUT(0x1A3FA28ECLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FA2BA4()
{
  objc_end_catch();
  JUMPOUT(0x1A3FA2AA0);
}

void sub_1A3FA2C14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA2EAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA2F88(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA2FA0(_Unwind_Exception *a1)
{
}

void sub_1A3FA305C(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA3074(_Unwind_Exception *a1)
{
}

void sub_1A3FA3130(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA3148(_Unwind_Exception *a1)
{
}

void sub_1A3FA3204(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA321C(_Unwind_Exception *a1)
{
}

void sub_1A3FA32D8(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA32F0(_Unwind_Exception *a1)
{
}

void sub_1A3FA33AC(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA33C4(_Unwind_Exception *a1)
{
}

void sub_1A3FA3480(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA3498(_Unwind_Exception *a1)
{
}

void sub_1A3FA3554(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA356C(_Unwind_Exception *a1)
{
}

void sub_1A3FA3628(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA3640(_Unwind_Exception *a1)
{
}

void sub_1A3FA36FC(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA3714(_Unwind_Exception *a1)
{
}

void sub_1A3FA37D0(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA37E8(_Unwind_Exception *a1)
{
}

void sub_1A3FA38F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA3A60(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA3AA8(_Unwind_Exception *a1)
{
}

void sub_1A3FA3C28(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA3C64(_Unwind_Exception *a1)
{
}

void sub_1A3FA3E14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA3FCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA41E8(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    id v8 = objc_begin_catch(a1);
    id v9 = [NSString alloc];
    float v12 = [v8 reason];
    id v10 = (void *)[v9 initWithFormat:@"Failed to unarchive VNFaceLandmarks2D object. Error: %@"];

    id v11 = +[VNError errorForInternalErrorWithLocalizedDescription:v10];
    [v2 failWithError:v11];

    objc_end_catch();
    JUMPOUT(0x1A3FA41BCLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FA4458(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA4528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA4748(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA4770(_Unwind_Exception *a1)
{
}

void sub_1A3FA4858(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA4880(_Unwind_Exception *a1)
{
}

void sub_1A3FA4968(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA4990(_Unwind_Exception *a1)
{
}

void sub_1A3FA4A78(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA4AA0(_Unwind_Exception *a1)
{
}

void sub_1A3FA4B88(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA4BB0(_Unwind_Exception *a1)
{
}

void sub_1A3FA4C98(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA4CC0(_Unwind_Exception *a1)
{
}

void sub_1A3FA4DA8(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA4DD0(_Unwind_Exception *a1)
{
}

void sub_1A3FA4EB8(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA4EE0(_Unwind_Exception *a1)
{
}

void sub_1A3FA4FC8(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA4FF0(_Unwind_Exception *a1)
{
}

void sub_1A3FA50D8(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA5100(_Unwind_Exception *a1)
{
}

void sub_1A3FA5268(void *a1)
{
  if (v2) {
    operator delete(v2);
  }
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FA52A8(_Unwind_Exception *a1)
{
}

void sub_1A3FA53BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA5434(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA55B4(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    id v8 = objc_begin_catch(a1);
    id v9 = [NSString alloc];
    float v12 = [v8 reason];
    id v10 = (void *)[v9 initWithFormat:@"Failed to unarchive VNFaceLandmarks3D object. Error: %@"];

    id v11 = +[VNError errorForInternalErrorWithLocalizedDescription:v10];
    [v2 failWithError:v11];

    objc_end_catch();
    JUMPOUT(0x1A3FA5580);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FA57C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t straightLineLSQ(__int16 *a1, int a2)
{
  if (a2 == 2)
  {
    int v2 = *a1;
    int v3 = a1[1];
    float v4 = (float)(a1[2] - v2) / (float)(a1[3] - v3);
    float v5 = (float)v3 - (float)(v4 * (float)v2);
  }
  else
  {
    if (a2 < 1)
    {
      float v14 = 0.0;
      float v16 = 0.0;
      float v15 = 0.0;
      float v17 = 0.0;
    }
    else
    {
      int v6 = 0;
      int v7 = 0;
      int v8 = 0;
      int v9 = 0;
      int v10 = a2;
      id v11 = a1;
      do
      {
        int v12 = *v11;
        int v13 = v11[1];
        v9 += v12;
        v8 += v13;
        v7 += v12 * v12;
        v6 += v13 * v12;
        v11 += 2;
        --v10;
      }
      while (v10);
      float v14 = (float)v9;
      float v15 = (float)v7;
      float v16 = (float)v8;
      float v17 = (float)v6;
    }
    float v18 = v14 / (float)a2;
    float v19 = -(float)(v18 * (float)a2);
    float v20 = v15 + (float)(v19 * v18);
    if (v20 == 0.0)
    {
      float v5 = (float)*a1;
      float v4 = INFINITY;
    }
    else
    {
      float v21 = v16 / (float)a2;
      float v4 = (float)(v17 + (float)(v19 * v21)) / v20;
      float v5 = v21 - (float)(v4 * v18);
      if (a2 >= 1)
      {
        int v22 = 0;
        float v23 = -1.0;
        do
        {
          float v24 = vabds_f32((float)a1[1] + (float)((float)-v4 * (float)*a1), v5);
          if (v24 > v23) {
            float v23 = v24;
          }
          ++v22;
          a1 += 2;
        }
        while (a2 != v22);
      }
    }
  }
  return LODWORD(v4) | ((unint64_t)LODWORD(v5) << 32);
}

unint64_t straightLineWLSQ(__int16 *a1, int a2)
{
  int v2 = *a1;
  int v3 = a1[1];
  if (a2 == 2)
  {
    float v4 = (float)(a1[3] - v3) / (float)(a1[2] - v2);
    float v5 = (float)v3 - (float)(v4 * (float)v2);
  }
  else
  {
    float v5 = (float)v3;
    if (a2 < 2) {
      goto LABEL_17;
    }
    int v6 = 0;
    int v7 = a1 + 2;
    float v8 = (float)v2;
    float v9 = (float)((float)v2 * v5) * 0.5;
    float v10 = (float)(v8 * v8) * 0.5;
    float v11 = v5 * 0.5;
    float v12 = (float)v2 * 0.5;
    float v13 = 0.0;
    int v14 = 1;
    float v15 = (float)v3;
    float v16 = (float)v2;
    float v17 = 0.5;
    do
    {
      int v18 = *v7;
      int v19 = v7[1];
      if (v3 != v19)
      {
        int v20 = v2 + v18;
        float v21 = (float)v20 * 0.5;
        float v22 = v21 - v16;
        if (v6)
        {
          if (v22 > v13) {
            float v13 = v21 - v16;
          }
          float v12 = v12 + (float)(v16 * v13);
          float v11 = v11 + (float)(v15 * v13);
          float v10 = v10 + (float)((float)(v16 * v16) * v13);
          float v9 = v9 + (float)((float)(v16 * v15) * v13);
          float v17 = v17 + v13;
        }
        float v15 = (float)(v3 + v19) * 0.5;
        ++v6;
        float v16 = (float)v20 * 0.5;
        float v13 = v22;
      }
      ++v14;
      v7 += 2;
      int v3 = v19;
      int v2 = v18;
    }
    while (a2 != v14);
    if (v6)
    {
      float v23 = (float)a1[2 * (a2 - 2) + 2];
      float v24 = v23 - v16;
      if ((float)(v23 - v16) <= v13) {
        float v24 = v13;
      }
      float v25 = (float)(v17 + v24) + 0.5;
      float v26 = (float)((float)(v12 + (float)(v16 * v24)) + (float)(v23 * 0.5)) / v25;
      float v27 = -(float)(v25 * v26);
      float v28 = (float)((float)(v10 + (float)((float)(v16 * v16) * v24)) + (float)((float)(v23 * v23) * 0.5))
          + (float)(v27 * v26);
      if (v28 == 0.0)
      {
        float v4 = INFINITY;
        float v5 = v8;
      }
      else
      {
        int v30 = 0;
        int v31 = a1[2 * (a2 - 2) + 3];
        float v32 = (float)((float)(v11 + (float)(v15 * v24)) + (float)((float)v31 * 0.5)) / v25;
        float v4 = (float)((float)((float)(v9 + (float)((float)(v16 * v15) * v24)) + (float)((float)(v23 * (float)v31) * 0.5))
                   + (float)(v27 * v32))
           / v28;
        float v5 = v32 - (float)(v4 * v26);
        float v33 = -1.0;
        do
        {
          float v34 = vabds_f32((float)a1[1] + (float)((float)-v4 * (float)*a1), v5);
          if (v34 > v33) {
            float v33 = v34;
          }
          ++v30;
          a1 += 2;
        }
        while (a2 != v30);
      }
    }
    else
    {
LABEL_17:
      float v4 = 0.0;
    }
  }
  return LODWORD(v4) | ((unint64_t)LODWORD(v5) << 32);
}

float Lsq2Leq(uint64_t a1)
{
  if (fabsf(*(float *)&a1) == INFINITY) {
    return 1.0;
  }
  float v1 = 1.0 / sqrtf((float)(*(float *)&a1 * *(float *)&a1) + 1.0);
  float result = -(float)(*(float *)&a1 * v1);
  if ((float)(v1 * COERCE_FLOAT(HIDWORD(a1) ^ 0x80000000)) > 0.0) {
    return -(float)(v1 * (float)-*(float *)&a1);
  }
  return result;
}

uint64_t applyCoordTransform(uint64_t result, uint64_t a2, int a3)
{
  if ((result & 1) != 0 && a3 >= 1)
  {
    int v3 = a3;
    float v4 = (_DWORD *)a2;
    do
    {
      HIDWORD(v5) = *v4;
      LODWORD(v5) = *v4;
      *v4++ = v5 >> 16;
      --v3;
    }
    while (v3);
  }
  if ((result & 0x100) != 0 && a3 >= 1)
  {
    int v6 = a3;
    int v7 = (_WORD *)a2;
    do
    {
      _WORD *v7 = -*v7;
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  if ((result & 0x10000) != 0 && a3 >= 1)
  {
    float v8 = (_WORD *)(a2 + 2);
    do
    {
      *float v8 = -*v8;
      v8 += 2;
      --a3;
    }
    while (a3);
  }
  return result;
}

void sub_1A3FA5EDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA5FE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6174(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6258(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA62F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA63F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6584(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6698(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6768(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6970(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6B38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6C0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6D3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL _validatePercentageValue(void *a1, void *a2, double a3)
{
  id v5 = a1;
  BOOL v6 = a3 <= 1.0 && a3 >= 0.0;
  if (!v6 && a2)
  {
    int v7 = [NSNumber numberWithDouble:a3];
    *a2 = +[VNError errorForInvalidOption:v7 named:v5 localizedDescription:0];
  }
  return v6;
}

void sub_1A3FA6E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA6F04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA701C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA70F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA71E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA72B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA749C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7578(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7738(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA780C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA78E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA79C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7BE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7CC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7D84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7E74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7F30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA7FB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA8130(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA824C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA85C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA8758(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA880C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA8DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *exc_buf, void *a12, void *a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
  if (a2)
  {

    if (__p) {
      operator delete(__p);
    }

    if (a17) {
      operator delete(a17);
    }

    objc_begin_catch(a1);
    JUMPOUT(0x1A3FA8C1CLL);
  }
  _Unwind_Resume(a1);
}

void std::vector<_Geometry2D_point2D_>::push_back[abi:ne180100](void **a1, void *a2)
{
  id v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = ((char *)v5 - (unsigned char *)*a1) >> 3;
    if ((unint64_t)(v7 + 1) >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = v4 - (void)*a1;
    uint64_t v9 = v8 >> 2;
    if (v8 >> 2 <= (unint64_t)(v7 + 1)) {
      uint64_t v9 = v7 + 1;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10) {
      unint64_t v10 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v10);
    }
    else {
      uint64_t v11 = 0;
    }
    float v12 = (void *)(v10 + 8 * v7);
    unint64_t v13 = v10 + 8 * v11;
    *float v12 = *a2;
    BOOL v6 = v12 + 1;
    float v15 = (char *)*a1;
    int v14 = (char *)a1[1];
    if (v14 != *a1)
    {
      do
      {
        uint64_t v16 = *((void *)v14 - 1);
        v14 -= 8;
        *--float v12 = v16;
      }
      while (v14 != v15);
      int v14 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v6;
    a1[2] = (void *)v13;
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    *id v5 = *a2;
    BOOL v6 = v5 + 1;
  }
  a1[1] = v6;
}

void sub_1A3FA90CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA99C0(_Unwind_Exception *a1, int a2)
{
  uint64_t v7 = v5;

  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1A3FA98C8);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FA9BF0(_Unwind_Exception *a1)
{
  BOOL v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A3FA9D7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FA9F38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAA12C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAA144(void *exc_buf, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x1A3FAA018);
  }
  JUMPOUT(0x1A3FAA134);
}

void sub_1A3FAA690(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAAAC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAAC68(_Unwind_Exception *a1, int a2)
{
  uint64_t v7 = v5;

  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1A3FAABFCLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FAAEB0(_Unwind_Exception *a1)
{
  uint64_t v8 = v6;

  _Unwind_Resume(a1);
}

void sub_1A3FAB1F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAB45C(_Unwind_Exception *a1)
{
  id v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3FAB5E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__22470(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__22471(uint64_t a1)
{
}

void sub_1A3FABC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL apple::vision::VNGetSerializingClassCodeForClassName(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[VNClassRegistrar getClassCode:a2 forClassName:a1 error:a3];
}

void sub_1A3FABEE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAC00C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAC14C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAC318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAC3B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAC488(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAC66C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FAC764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FACE54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceID3KmeansParams::serialize()
{
  int v0 = (void *)std::ostream::write();
  if ((*((unsigned char *)v0 + *(void *)(*v0 - 24) + 32) & 5) != 0
    || (float v1 = (void *)std::ostream::write(), (*((unsigned char *)v1 + *(void *)(*v1 - 24) + 32) & 5) != 0))
  {
    int v2 = &CVML_status_IOError;
  }
  else
  {
    unint64_t v4 = (void *)std::ostream::write();
    int v2 = &CVML_status_IOError;
    if ((*((unsigned char *)v4 + *(void *)(*v4 - 24) + 32) & 5) == 0)
    {
      id v5 = (void *)std::ostream::write();
      if ((*((unsigned char *)v5 + *(void *)(*v5 - 24) + 32) & 5) == 0) {
        int v2 = &CVML_status_ok;
      }
    }
  }
  return (*v2 + 128) | 0x2B00;
}

uint64_t vision::mod::FaceID3KmeansParams::deserialize()
{
  int v0 = (void *)std::istream::read();
  if ((*((unsigned char *)v0 + *(void *)(*v0 - 24) + 32) & 5) != 0
    || (float v1 = (void *)std::istream::read(), (*((unsigned char *)v1 + *(void *)(*v1 - 24) + 32) & 5) != 0))
  {
    int v2 = &CVML_status_IOError;
  }
  else
  {
    unint64_t v4 = (void *)std::istream::read();
    int v2 = &CVML_status_IOError;
    if ((*((unsigned char *)v4 + *(void *)(*v4 - 24) + 32) & 5) == 0)
    {
      id v5 = (void *)std::istream::read();
      if ((*((unsigned char *)v5 + *(void *)(*v5 - 24) + 32) & 5) == 0) {
        int v2 = &CVML_status_ok;
      }
    }
  }
  return (*v2 + 128) | 0x2B00;
}

void *std::__hash_table<std::__hash_value_type<int,std::vector<long long>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<long long>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<long long>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<long long>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t *a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  float v12 = a1 + 2;
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  void v10[3] = 0;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = a1[1];
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          int v19 = operator new(8 * *(void *)&prime);
          int v20 = (void *)*a1;
          *a1 = (uint64_t)v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          float v22 = (void *)*v12;
          if (*v12)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v23) = v12;
            float v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*a1 + 8 * v29))
                  {
                    *(void *)(*a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *float v22 = *v28;
                  *float v28 = **(void **)(*a1 + 8 * v29);
                  **(void **)(*a1 + 8 * v29) = v28;
                  float v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                float v22 = v28;
                float v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        float v34 = (void *)*a1;
        *a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v30 = *a1;
  int v31 = *(void **)(*a1 + 8 * v3);
  if (v31)
  {
    *unint64_t v10 = *v31;
LABEL_72:
    void *v31 = v10;
    goto LABEL_73;
  }
  *unint64_t v10 = *v12;
  *float v12 = v10;
  *(void *)(v30 + 8 * v3) = v12;
  if (*v10)
  {
    unint64_t v32 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    int v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_1A3FAD690(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceID3Model::buildModel(uint64_t a1, vision::mod::ImageDescriptorBufferAbstract *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v303 = *MEMORY[0x1E4F143B8];
  if (*((void *)a2 + 8)) {
    BOOL v4 = *((void *)a2 + 12) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4 || (uint64_t v6 = *((void *)a2 + 9)) == 0)
  {
    syslog(5, "ERROR: invalid image descriptor buffer for training");
    return 11132;
  }
  if (v6 != (a3[1] - *a3) >> 2)
  {
    syslog(5, "ERROR: size mismatch between descriptors and their labels");
    return 11132;
  }
  if (*(int *)a1 < 1)
  {
    syslog(5, "ERROR: negative or zero maxElems_");
LABEL_23:
    float v12 = &CVML_status_invalidParameter;
    goto LABEL_24;
  }
  if (*(int *)(a1 + 4) < 1)
  {
    syslog(5, "ERROR: negative or zero maxNumIds_");
    goto LABEL_23;
  }
  if (*(int *)(a1 + 16) < 1)
  {
    syslog(5, "ERROR: negative or zero maxIter_");
    goto LABEL_23;
  }
  if (*(int *)(a1 + 12) < 1)
  {
    unint64_t v11 = "ERROR: negative or zero nInits_ in kmeans";
LABEL_22:
    syslog(5, v11);
    goto LABEL_23;
  }
  double v10 = *(double *)(a1 + 24);
  unint64_t v11 = "ERROR: invalid tol_ in kmeans";
  if (v10 >= 1.0 || v10 <= 0.0) {
    goto LABEL_22;
  }
  float v12 = &CVML_status_ok;
LABEL_24:
  uint64_t v13 = (*v12 + 128) | 0x2B00;
  if (v13 != 11136) {
    return v13;
  }
  memset(v247, 0, sizeof(v247));
  int v248 = 1065353216;
  long long v244 = 0u;
  long long v245 = 0u;
  int v246 = 1065353216;
  uint64_t v15 = *a3;
  if (a3[1] == *a3) {
    goto LABEL_354;
  }
  unint64_t v16 = 0;
  do
  {
    unint64_t v17 = std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)v247, *(_DWORD *)(v15 + 4 * v16), (_DWORD *)(v15 + 4 * v16));
    int v18 = v17;
    int v20 = (char *)v17[4];
    unint64_t v19 = v17[5];
    if ((unint64_t)v20 >= v19)
    {
      float v22 = (char *)v17[3];
      uint64_t v23 = (v20 - v22) >> 2;
      unint64_t v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 62) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v25 = v19 - (void)v22;
      if (v25 >> 1 > v24) {
        unint64_t v24 = v25 >> 1;
      }
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v26 = v24;
      }
      if (v26)
      {
        unint64_t v26 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v26);
        float v22 = (char *)v18[3];
        int v20 = (char *)v18[4];
      }
      else
      {
        uint64_t v27 = 0;
      }
      float v28 = (_DWORD *)(v26 + 4 * v23);
      *float v28 = v16;
      uint64_t v21 = v28 + 1;
      while (v20 != v22)
      {
        int v29 = *((_DWORD *)v20 - 1);
        v20 -= 4;
        *--float v28 = v29;
      }
      v18[3] = v28;
      v18[4] = v21;
      v18[5] = v26 + 4 * v27;
      if (v22) {
        operator delete(v22);
      }
    }
    else
    {
      *(_DWORD *)int v20 = v16;
      uint64_t v21 = v20 + 4;
    }
    v18[4] = v21;
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)&v244, *(_DWORD *)(*a3 + 4 * v16), *(_DWORD *)(*a3 + 4 * v16));
    ++v16;
    uint64_t v15 = *a3;
  }
  while (v16 < (a3[1] - *a3) >> 2);
  if (!*((void *)&v245 + 1) || (uint64_t v30 = v245) == 0)
  {
LABEL_354:
    uint64_t v13 = 11136;
    goto LABEL_355;
  }
  uint64_t v229 = (vision::mod::FaceID3Model *)a1;
  int v230 = a2;
  uint64_t v224 = a4;
  int v227 = 0;
  int v228 = (float *)(a1 + 96);
  unint64_t v222 = (uint64_t *)(a1 + 56);
  while (1)
  {
    uint64_t v226 = (uint64_t *)v30;
    int v31 = *(_DWORD *)(v30 + 16);
    unint64_t v32 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(*(uint64_t *)&v247[0], *((unint64_t *)&v247[0] + 1), v31);
    int v260 = v31;
    uint64_t v34 = v32[3];
    uint64_t v33 = v32[4];
    uint64_t v35 = v33 - v34;
    if (v33 == v34) {
      goto LABEL_342;
    }
    float v36 = v32;
    uint64_t v37 = *((void *)v230 + 12);
    uint64_t v38 = *((void *)v229 + 6);
    uint64_t v39 = (int)v37;
    if (v38)
    {
      if ((int)v37 != *(void *)(v38 + 96)) {
        break;
      }
    }
    uint64_t v40 = v35 >> 2;
    vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)v256, v35 >> 2, (int)v37);
    uint64_t v231 = v37 << 32;
    uint64_t v41 = v36[3];
    if (v36[4] != v41)
    {
      unint64_t v42 = 0;
      do
      {
        unint64_t DataForKthDescriptor = (const void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(v230, *(int *)(v41 + 4 * v42));
        float v44 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v256, v42);
        if (v231) {
          memmove(v44, DataForKthDescriptor, v231 >> 30);
        }
        ++v42;
        uint64_t v41 = v36[3];
      }
      while (v42 < (v36[4] - v41) >> 2);
    }
    uint64_t v45 = *(int *)v229;
    if ((int)v45 >= (int)((unint64_t)v35 >> 2))
    {
      int v67 = 0;
      float32x4_t v68 = 0;
      unint64_t v69 = 0;
      uint64_t v70 = 0;
      __p[1] = 0;
      __p[0] = 0;
      *(void *)&long long v280 = 0;
      while (1)
      {
        *(void *)v302.__x_ = 0;
        if (vision::mod::FaceID3Model::generateDescriptorID_(v229, (uint64_t *)&v302) != 11136) {
          break;
        }
        if ((unint64_t)v67 >= v69)
        {
          uint64_t v71 = (v67 - v68) >> 3;
          unint64_t v72 = v71 + 1;
          if ((unint64_t)(v71 + 1) >> 61)
          {
            *(void *)&long long v280 = v69;
            __p[0] = v68;
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          if ((uint64_t)(v69 - (void)v68) >> 2 > v72) {
            unint64_t v72 = (uint64_t)(v69 - (void)v68) >> 2;
          }
          if (v69 - (unint64_t)v68 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v73 = v72;
          }
          if (v73) {
            unint64_t v73 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v73);
          }
          else {
            uint64_t v74 = 0;
          }
          unint64_t v75 = (char *)(v73 + 8 * v71);
          *(void *)unint64_t v75 = *(void *)v302.__x_;
          unint64_t v76 = v75 + 8;
          while (v67 != v68)
          {
            uint64_t v77 = *((void *)v67 - 1);
            v67 -= 8;
            *((void *)v75 - 1) = v77;
            v75 -= 8;
          }
          unint64_t v69 = v73 + 8 * v74;
          __p[1] = v76;
          if (v68) {
            operator delete(v68);
          }
          float32x4_t v68 = v75;
          int v67 = (char *)v76;
        }
        else
        {
          *(void *)int v67 = *(void *)v302.__x_;
          v67 += 8;
        }
        __p[1] = v67;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v228, *(unint64_t *)v302.__x_, &v302)+ 6) = v31;
        if (++v70 == v40)
        {
          *(void *)&long long v280 = v69;
          __p[0] = v68;
          int v78 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v256, 0);
          vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)&v302, (void **)__p, v78, v231 >> 30, (v67 - v68) >> 3, 0);
          v302.__x_[26] = 1;
          *(void *)&v302.__x_[28] = 0;
          *(void *)v302.__x_ = &unk_1EF752918;
          *(void *)&v302.__x_[24] = (unint64_t)(v231 >> 30) >> 2;
          uint64_t v79 = *((void *)v229 + 6);
          if (v79)
          {
            (*(void (**)(uint64_t, std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *))(*(void *)v79 + 40))(v79, &v302);
          }
          else
          {
            uint64_t DeepCopy = vision::mod::ImageDescriptorBufferAbstract::createDeepCopy((vision::mod::ImageDescriptorBufferAbstract *)&v302);
            uint64_t v83 = *((void *)v229 + 6);
            *((void *)v229 + 6) = DeepCopy;
            if (v83) {
              (*(void (**)(uint64_t))(*(void *)v83 + 8))(v83);
            }
          }
          unint64_t v84 = (char *)std::__hash_table<std::__hash_value_type<int,std::vector<long long>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<long long>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<long long>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<long long>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v222, v260, &v260);
          std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>(v84 + 24, v68, (uint64_t)v67, (v67 - v68) >> 3);
          *(void *)v302.__x_ = &unk_1EF752918;
          free(*(void **)&v302.__x_[28]);
          vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract((void **)&v302);
          if (__p[0]) {
            operator delete(__p[0]);
          }
          goto LABEL_335;
        }
      }
      *(void *)&long long v280 = v69;
      __p[0] = v68;
      if (v68)
      {
        __p[1] = v68;
        operator delete(v68);
      }
      uint64_t v13 = 11107;
      goto LABEL_333;
    }
    vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)v252, *(int *)v229, v39);
    vision::mod::CVMLVector<float,16ul>::initialize_((uint64_t)v249, v39);
    LODWORD(v46) = v45;
    int v47 = *((_DWORD *)v229 + 8);
    uint64_t v236 = v45;
    if (v47 == 1)
    {
      vision::mod::CVMLMatrix<float,16ul>::mean((uint64_t)v256, v249, 0);
      float v80 = v249[1];
    }
    else
    {
      if (v47)
      {
        syslog(5, "ERROR: unknown index mode");
        int v81 = 1;
        uint64_t v13 = 11132;
        goto LABEL_326;
      }
      uint64_t v48 = *(void *)((char *)v229 + 12);
      int v223 = v48;
      if ((int)v48 < 1 || (int v232 = HIDWORD(v48), v48 <= 0))
      {
        syslog(5, "ERROR: invalid parameters in kmeans", v222);
        syslog(5, "ERROR: kmeans error");
        int v81 = 1;
        uint64_t v13 = 11136;
        goto LABEL_326;
      }
      double v49 = *((double *)v229 + 3);
      std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v50 = *((_DWORD *)v229 + 2);
      unint64_t v51 = *((void *)&v257 + 1);
      vision::mod::CVMLVector<float,16ul>::initialize_((uint64_t)&v283, *((uint64_t *)&v257 + 1));
      if (v285 < *((void *)&v257 + 1))
      {
        exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "vector length < cols");
        exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
        __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
      }
      vision::mod::CVMLMatrix<float,16ul>::mean((uint64_t)v256, &v283, 0);
      uint64_t v52 = *((void *)&v257 + 1);
      uint64_t v53 = v284;
      if (*((void *)&v257 + 1))
      {
        uint64_t v54 = 0;
        unint64_t v55 = v286;
        long long v57 = (float *)v256[1];
        uint64_t v56 = v257;
        float v58 = (float)(unint64_t)v257;
        uint64_t v59 = 4 * v258;
        do
        {
          uint64_t v60 = v55 * v54;
          if (v56)
          {
            float v61 = 0.0;
            BOOL v62 = v57;
            uint64_t v63 = v56;
            do
            {
              float v61 = v61 + (float)((float)(*v62 - v53[v60]) * (float)(*v62 - v53[v60]));
              BOOL v62 = (float *)((char *)v62 + v59);
              --v63;
            }
            while (v63);
          }
          else
          {
            float v61 = 0.0;
          }
          v53[v60] = v61 / v58;
          ++v54;
          ++v57;
        }
        while (v54 != v52);
      }
      if (v51)
      {
        uint64_t v64 = 4 * v51;
        float v65 = 0.0;
        do
        {
          float v66 = *v53++;
          float v65 = v65 + v66;
          v64 -= 4;
        }
        while (v64);
      }
      else
      {
        float v65 = 0.0;
      }
      if ((_BYTE)v287 && v283) {
        free(v283);
      }
      *(_OWORD *)int8x8_t v271 = 0u;
      long long v272 = 0u;
      char v273 = 1;
      vision::mod::CVMLMatrix<float,16ul>::mean((uint64_t)v256, v271, 1);
      *(void *)v302.__x_ = &unk_1EF7532A8;
      *(void *)&v302.__x_[6] = &v302;
      vision::mod::broadcast<float,16ul>(v256, v271, (uint64_t)&v302, 0, v256);
      std::__function::__value_func<float ()(float,float)>::~__value_func[abi:ne180100](&v302);
      *(_OWORD *)unint64_t v268 = 0u;
      long long v269 = 0u;
      char v270 = 1;
      vision::mod::CVMLMatrix<float,16ul>::rowNorms((uint64_t)v256, v268, 1);
      vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v262, v45, *((uint64_t *)&v257 + 1));
      float v85 = v49;
      float v86 = (float)(v65 / (float)v51) * v85;
      std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v87 = 5489;
      v302.__x_[0] = 5489;
      for (uint64_t i = 1; i != 624; ++i)
      {
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v87 = i + 1812433253 * (v87 ^ (v87 >> 30));
        v302.__x_[i] = v87;
      }
      v302.__i_ = 0;
      if ((v50 & 0x80000000) == 0)
      {
        v302.__x_[0] = v50;
        for (uint64_t j = 1; j != 624; ++j)
        {
          std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v50 = j + 1812433253 * (v50 ^ (v50 >> 30));
          v302.__x_[j] = v50;
        }
        v302.__i_ = 0;
      }
      if (v223 >= 1)
      {
        int v90 = 0;
        int v233 = (int)log((double)(int)v45);
        LODWORD(v91) = v233 + 2;
        if (v233 + 2 <= 1) {
          uint64_t v91 = 1;
        }
        else {
          uint64_t v91 = v91;
        }
        unint64_t v242 = v233 + 2;
        uint64_t v243 = v91;
        uint64_t v235 = 4 * v45;
        float v92 = 3.4028e38;
        uint64_t v239 = v45;
        while (1)
        {
          int v225 = v90;
          long long v93 = v257;
          LODWORD(v301) = 0;
          HIDWORD(v301) = v257 - 1;
          int v94 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(&v302, &v301);
          char v95 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v262, 0);
          uint64_t v96 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v256, v94);
          size_t v234 = 4 * *((void *)&v93 + 1);
          memcpy(v95, v96, 4 * *((void *)&v93 + 1));
          vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v289, 1, v93);
          if (!v264) {
            break;
          }
          if (!v265 || *((void *)&v93 + 1) > v265)
          {
            float v219 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(v219, "col index out of range");
LABEL_351:
            v219->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
            __cxa_throw(v219, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
          }
          float v283 = v263;
          int v284 = (float *)v263;
          unint64_t v285 = 1;
          unint64_t v286 = *((void *)&v93 + 1);
          uint64_t v287 = v266;
          char v288 = 0;
          vision::mod::euclideanDistances<float,16ul>((uint64_t)&v283, v256, &v289, v268);
          if (v288 && v283) {
            free(v283);
          }
          uint64_t v97 = v290;
          *(_DWORD *)(v290 + 4 * v94) = 0;
          vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v283, v242, *((uint64_t *)&v93 + 1));
          vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)__p, v242, v93);
          std::vector<int>::size_type v98 = v236;
          std::vector<unsigned long>::vector(v275, v242);
          std::vector<float>::vector(&__dst, v93);
          std::vector<float>::vector(&__src, v93);
          std::vector<float>::vector(&v278, v93);
          if ((int)v46 >= 2)
          {
            __unint64_t n = 4 * v93;
            CGRect v99 = __p[1];
            uint64_t v100 = v281;
            uint64_t v101 = 4 * v281;
            unint64_t v237 = 1;
            do
            {
              char v102 = (int *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v289, 0);
              uint64_t v103 = vision::mod::CVMLMatrix<float,16ul>::ptr(&v289, 0) + 4 * v93;
              begiunint64_t n = v278.__begin_;
              if (v102 != (int *)v103)
              {
                int v106 = *v102;
                uint64_t v105 = (float *)(v102 + 1);
                float v107 = *(float *)&v106;
                *v278.__begin_ = v106;
                if (v105 != (float *)v103)
                {
                  int v108 = (float *)(begin + 1);
                  do
                  {
                    float v109 = *v105++;
                    float v107 = v107 + v109;
                    *v108++ = v107;
                  }
                  while (v105 != (float *)v103);
                }
              }
              if (!begin || !(void)v93)
              {
                float v218 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                std::logic_error::logic_error(v218, "empty cumsum vector");
                v218->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4E8] + 16);
                __cxa_throw(v218, (struct type_info *)off_1E5B19CD8, MEMORY[0x1E4FBA1E8]);
              }
              if (v233 != -2)
              {
                uint64_t v110 = 0;
                int v111 = *(float **)v275;
                float v112 = *(float *)&begin[v93 - 1];
                do
                {
                  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v113 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v302) >> 5;
                  float v114 = ((double)(std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v302) >> 6)
                        + (double)v113 * 67108864.0)
                       * 1.11022302e-16;
                  float v115 = v112 * v114;
                  std::vector<int>::pointer v116 = begin;
                  unint64_t v117 = v93;
                  do
                  {
                    unint64_t v118 = v117 >> 1;
                    uint64_t v119 = (float *)&v116[v117 >> 1];
                    float v121 = *v119;
                    uint64_t v120 = v119 + 1;
                    v117 += ~(v117 >> 1);
                    if (v121 < v115) {
                      std::vector<int>::pointer v116 = (std::vector<int>::pointer)v120;
                    }
                    else {
                      unint64_t v117 = v118;
                    }
                  }
                  while (v117);
                  *(void *)&v111[2 * v110++] = v116 - begin;
                }
                while (v110 != v242);
                std::vector<int>::size_type v98 = v236;
                if (v233 >= -1)
                {
                  unint64_t v122 = 0;
                  do
                  {
                    int v123 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v283, v122);
                    int v124 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v256, *(void *)(*(void *)v275 + 8 * v122));
                    memcpy(v123, v124, v234);
                    ++v122;
                  }
                  while (v243 != v122);
                }
              }
              vision::mod::euclideanDistances<float,16ul>((uint64_t)&v283, v256, __p, v268);
              if (v233 < -1)
              {
                LODWORD(v130) = -1;
              }
              else
              {
                uint64_t v125 = 0;
                uint64_t v126 = *(float **)v275;
                uint64_t v127 = v243;
                do
                {
                  uint64_t v128 = *(void *)v126;
                  v126 += 2;
                  v99[v125 + v128] = 0;
                  v125 += v100;
                  --v127;
                }
                while (v127);
                uint64_t v129 = 0;
                LODWORD(v130) = -1;
                float v131 = 3.4028e38;
                int v132 = v99;
                do
                {
                  uint64_t v133 = 0;
                  uint64_t v134 = (float *)__src;
                  do
                  {
                    float v135 = *(float *)&v132[v133];
                    if (v135 >= *(float *)(v97 + 4 * v133)) {
                      float v135 = *(float *)(v97 + 4 * v133);
                    }
                    v134[v133++] = v135;
                  }
                  while ((void)v93 != v133);
                  float v136 = 0.0;
                  if (v134 != v296)
                  {
                    unint64_t v137 = v134;
                    do
                    {
                      float v138 = *v137++;
                      float v136 = v136 + v138;
                    }
                    while (v137 != v296);
                  }
                  if (v130 == -1 || v136 < v131 && (float)(v131 - v136) > 1.0e-14)
                  {
                    uint64_t v130 = *(void *)(*(void *)v275 + 8 * v129);
                    memcpy(__dst, v134, __n);
                    float v131 = v136;
                  }
                  ++v129;
                  int v132 = (_DWORD *)((char *)v132 + v101);
                }
                while (v129 != v243);
              }
              unint64_t v139 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v262, v237);
              unint64_t v140 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v256, (int)v130);
              memcpy(v139, v140, v234);
              int v141 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v289, 0);
              memcpy(v141, __dst, __n);
              ++v237;
            }
            while (v237 != v239);
          }
          if (v278.__begin_)
          {
            v278.__end_ = v278.__begin_;
            operator delete(v278.__begin_);
          }
          uint64_t v46 = v239;
          if (__src)
          {
            double v296 = (float *)__src;
            operator delete(__src);
          }
          if (__dst)
          {
            long long v299 = __dst;
            operator delete(__dst);
          }
          if (*(void *)v275)
          {
            std::vector<int> v276 = *(float **)v275;
            operator delete(*(void **)v275);
          }
          if (v282 && __p[0]) {
            free(__p[0]);
          }
          if (v288 && v283) {
            free(v283);
          }
          if (v294 && v289) {
            free(v289);
          }
          float v261 = 0.0;
          long long v142 = v257;
          __x[0] = -1;
          std::vector<int>::vector(&v297, v257, __x);
          std::vector<float>::vector(&__src, v142);
          vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v289, v98, *((uint64_t *)&v142 + 1));
          vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v283, v98, *((uint64_t *)&v142 + 1));
          uint64_t v281 = 0;
          *(_OWORD *)std::string __p = 0u;
          long long v280 = 0u;
          char v282 = 1;
          vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)__p, v98, v142);
          v275[0] = 0;
          std::vector<int>::vector(&v278, v98, v275);
          float v261 = 3.4028e38;
          vision::mod::CVMLVector<float,16ul>::initialize_((uint64_t)v275, v98);
          if (v232 >= 1)
          {
            int v143 = 0;
            unint64_t v144 = v291;
            while (2)
            {
              if (v144 < v264 || v292 < v265)
              {
                float v216 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                std::logic_error::logic_error(v216, "output matrix size too small");
                v216->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
                __cxa_throw(v216, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
              }
              if (v264)
              {
                for (unint64_t k = 0; k < v264; ++k)
                {
                  uint64_t v146 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v289, k);
                  long long v147 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v262, k);
                  memcpy(v146, v147, 4 * v265);
                }
              }
              int __na = v143;
              float v274 = 0.0;
              vision::mod::Kmeans<float,16ul>::labelEstimation_(v256, v46, (uint64_t)&v262, v268, __p, v297.__begin_, (float *)__src, &v274);
              std::vector<int>::pointer v148 = v297.__begin_;
              int v238 = __src;
              std::vector<int>::pointer v149 = v278.__begin_;
              uint64_t v150 = *((void *)&v257 + 1);
              uint64_t v151 = v257;
              bzero(v278.__begin_, v235);
              long long v152 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v262, 0);
              bzero(v152, v266 * v235);
              if (v151)
              {
                for (uint64_t m = 0; m != v151; ++m)
                  ++v149[v148[m]];
                for (unint64_t n = 0; n != v151; ++n)
                {
                  unint64_t v155 = v148[n];
                  int v156 = v149[v155];
                  long long v157 = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr(v256, n);
                  long long v158 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v262, v155);
                  cblas_saxpy(v150, 1.0 / (float)v156, v157, 1, v158, 1);
                }
              }
              if ((int)v46 < 1) {
                goto LABEL_234;
              }
              unint64_t v159 = 0;
              long long v160 = 0;
              int v161 = 0;
              for (iuint64_t i = 0; ii != v46; ++ii)
              {
                if (!v149[ii])
                {
                  if ((unint64_t)v160 >= v159)
                  {
                    uint64_t v163 = (v160 - v161) >> 2;
                    unint64_t v164 = v163 + 1;
                    if ((unint64_t)(v163 + 1) >> 62) {
                      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                    }
                    if ((uint64_t)(v159 - (void)v161) >> 1 > v164) {
                      unint64_t v164 = (uint64_t)(v159 - (void)v161) >> 1;
                    }
                    if (v159 - (unint64_t)v161 >= 0x7FFFFFFFFFFFFFFCLL) {
                      unint64_t v165 = 0x3FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v165 = v164;
                    }
                    if (v165) {
                      unint64_t v165 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v165);
                    }
                    else {
                      uint64_t v166 = 0;
                    }
                    int v167 = (char *)(v165 + 4 * v163);
                    *(_DWORD *)int v167 = ii;
                    unsigned int v168 = v167 + 4;
                    while (v160 != v161)
                    {
                      int v169 = *((_DWORD *)v160 - 1);
                      v160 -= 4;
                      *((_DWORD *)v167 - 1) = v169;
                      v167 -= 4;
                    }
                    unint64_t v159 = v165 + 4 * v166;
                    if (v161) {
                      operator delete(v161);
                    }
                    long long v160 = v168;
                    int v161 = v167;
                    uint64_t v46 = v239;
                  }
                  else
                  {
                    *(_DWORD *)long long v160 = ii;
                    v160 += 4;
                  }
                }
              }
              if (v160 == v161) {
                goto LABEL_232;
              }
              std::vector<unsigned long>::vector(&__dst, v151);
              long long v170 = (uint64_t *)__dst;
              *(void *)float64x2_t __x = v238;
              unsigned int v171 = (uint64_t *)((char *)__dst + 8 * v151);
              if (v151)
              {
                uint64_t v172 = 0;
                uint64_t v173 = 8 * v151;
                do
                {
                  v170[v172] = v172;
                  ++v172;
                  v173 -= 8;
                }
                while (v173);
                int v301 = __x;
                if (v151 > 128)
                {
                  long long v174 = (uint64_t *)std::get_temporary_buffer[abi:ne180100]<unsigned long>(v151);
                  std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v170, v171, (uint64_t **)&v301, v151, v174, v175);
                  if (v174) {
                    operator delete(v174);
                  }
LABEL_223:
                  if (v160 != v161)
                  {
                    uint64_t v176 = 0;
                    size_t v177 = 4 * v150;
                    if ((unint64_t)((v160 - v161) >> 2) <= 1) {
                      uint64_t v178 = 1;
                    }
                    else {
                      uint64_t v178 = (v160 - v161) >> 2;
                    }
                    do
                    {
                      unint64_t v179 = *((void *)__dst + v176);
                      int v180 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v262, *(int *)&v161[4 * v176]);
                      std::vector<int>::pointer v181 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v256, v179);
                      memcpy(v180, v181, v177);
                      ++v176;
                    }
                    while (v178 != v176);
                    long long v160 = v161;
                  }
                  if (__dst)
                  {
                    long long v299 = __dst;
                    operator delete(__dst);
                    long long v160 = v161;
                  }
                  int v161 = v160;
LABEL_232:
                  if (v161) {
                    operator delete(v161);
                  }
LABEL_234:
                  float v182 = v274;
                  if (v274 < v261)
                  {
                    if (v285 < v264 || v286 < v265)
                    {
                      float v217 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                      std::logic_error::logic_error(v217, "output matrix size too small");
                      v217->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
                      __cxa_throw(v217, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
                    }
                    if (v264)
                    {
                      for (juint64_t j = 0; jj < v264; ++jj)
                      {
                        int v184 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v283, jj);
                        int v185 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v262, jj);
                        memcpy(v184, v185, 4 * v265);
                      }
                    }
                    float v261 = v182;
                  }
                  unint64_t v144 = v291;
                  int v186 = v293;
                  uint64_t v187 = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v262, 0);
                  float v188 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v289, 0);
                  cblas_saxpy(v186 * v144, -1.0, v187, 1, v188, 1);
                  vision::mod::CVMLMatrix<float,16ul>::rowNorms((uint64_t)&v289, v275, 0);
                  if (v236)
                  {
                    int v189 = v276;
                    float v190 = 0.0;
                    uint64_t v191 = v235;
                    do
                    {
                      float v192 = *v189++;
                      float v190 = v190 + v192;
                      v191 -= 4;
                    }
                    while (v191);
                  }
                  else
                  {
                    float v190 = 0.0;
                  }
                  float v193 = sqrtf(v190);
                  int v143 = __na + 1;
                  if (v193 <= v86 || v143 == v232)
                  {
                    if (v193 > 0.0) {
                      vision::mod::Kmeans<float,16ul>::labelEstimation_(v256, v236, (uint64_t)&v283, v268, __p, v297.__begin_, (float *)__src, &v261);
                    }
                    goto LABEL_253;
                  }
                  continue;
                }
              }
              else
              {
                int v301 = __x;
              }
              break;
            }
            std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v170, v171, (uint64_t **)&v301, v151, 0, 0);
            goto LABEL_223;
          }
LABEL_253:
          if (v277 && *(void *)v275) {
            free(*(void **)v275);
          }
          if (v278.__begin_)
          {
            v278.__end_ = v278.__begin_;
            operator delete(v278.__begin_);
          }
          if (v282 && __p[0]) {
            free(__p[0]);
          }
          if (v288 && v283) {
            free(v283);
          }
          if (v294 && v289) {
            free(v289);
          }
          if (__src)
          {
            double v296 = (float *)__src;
            operator delete(__src);
          }
          if (v297.__begin_)
          {
            v297.__end_ = v297.__begin_;
            operator delete(v297.__begin_);
          }
          float v195 = v261;
          if (v261 < v92)
          {
            if ((unint64_t)v253 < v264 || *((void *)&v253 + 1) < v265)
            {
              int v220 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(v220, "output matrix size too small");
              v220->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
              __cxa_throw(v220, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
            }
            if (v264)
            {
              for (kunint64_t k = 0; kk < v264; ++kk)
              {
                int v197 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v252, kk);
                uint64_t v198 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v262, kk);
                memcpy(v197, v198, 4 * v265);
              }
            }
            float v92 = v195;
          }
          int v90 = v225 + 1;
          if (v225 + 1 == v223) {
            goto LABEL_279;
          }
        }
        float v219 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v219, "row index out of range");
        goto LABEL_351;
      }
LABEL_279:
      vision::mod::broadcastAdd<float,16ul>(v256, v271, 0, v256);
      vision::mod::broadcastAdd<float,16ul>(v252, v271, 0, v252);
      if (v267 && v262) {
        free(v262);
      }
      if (v270 && v268[0]) {
        free(v268[0]);
      }
      if (v273 && v271[0]) {
        free(v271[0]);
      }
      float v80 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v252, 0);
    }
    __p[1] = 0;
    __p[0] = 0;
    *(void *)&long long v280 = 0;
    if (v46)
    {
      int v199 = 0;
      uint64_t v200 = 0;
      unint64_t v201 = 0;
      uint64_t v202 = 0;
      int v203 = v260;
      while (1)
      {
        *(void *)v302.__x_ = 0;
        if (vision::mod::FaceID3Model::generateDescriptorID_(v229, (uint64_t *)&v302) != 11136) {
          break;
        }
        if ((unint64_t)v199 >= v201)
        {
          uint64_t v204 = (v199 - v200) >> 3;
          unint64_t v205 = v204 + 1;
          if ((unint64_t)(v204 + 1) >> 61)
          {
            *(void *)&long long v280 = v201;
            __p[0] = v200;
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          if ((uint64_t)(v201 - (void)v200) >> 2 > v205) {
            unint64_t v205 = (uint64_t)(v201 - (void)v200) >> 2;
          }
          if (v201 - (unint64_t)v200 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v206 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v206 = v205;
          }
          if (v206) {
            unint64_t v206 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v206);
          }
          else {
            uint64_t v207 = 0;
          }
          float v208 = (char *)(v206 + 8 * v204);
          *(void *)float v208 = *(void *)v302.__x_;
          float v209 = v208 + 8;
          while (v199 != v200)
          {
            uint64_t v210 = *((void *)v199 - 1);
            v199 -= 8;
            *((void *)v208 - 1) = v210;
            v208 -= 8;
          }
          unint64_t v201 = v206 + 8 * v207;
          __p[1] = v209;
          if (v200) {
            operator delete(v200);
          }
          uint64_t v200 = v208;
          int v199 = (char *)v209;
        }
        else
        {
          *(void *)int v199 = *(void *)v302.__x_;
          v199 += 8;
        }
        __p[1] = v199;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v228, *(unint64_t *)v302.__x_, &v302)+ 6) = v203;
        if (++v202 == v236)
        {
          *(void *)&long long v280 = v201;
          __p[0] = v200;
          goto LABEL_312;
        }
      }
      *(void *)&long long v280 = v201;
      __p[0] = v200;
      int v81 = 1;
      uint64_t v13 = 11107;
    }
    else
    {
      uint64_t v200 = 0;
      int v199 = 0;
LABEL_312:
      vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)&v302, (void **)__p, v80, v231 >> 30, (v199 - v200) >> 3, 0);
      v302.__x_[26] = 1;
      *(void *)&v302.__x_[28] = 0;
      *(void *)v302.__x_ = &unk_1EF752918;
      *(void *)&v302.__x_[24] = (unint64_t)(v231 >> 30) >> 2;
      uint64_t v211 = *((void *)v229 + 6);
      if (v211)
      {
        (*(void (**)(uint64_t, std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *))(*(void *)v211 + 40))(v211, &v302);
      }
      else
      {
        uint64_t v212 = vision::mod::ImageDescriptorBufferAbstract::createDeepCopy((vision::mod::ImageDescriptorBufferAbstract *)&v302);
        uint64_t v213 = *((void *)v229 + 6);
        *((void *)v229 + 6) = v212;
        if (v213) {
          (*(void (**)(uint64_t))(*(void *)v213 + 8))(v213);
        }
      }
      float v214 = (char *)std::__hash_table<std::__hash_value_type<int,std::vector<long long>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<long long>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<long long>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<long long>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v222, v260, &v260);
      std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>(v214 + 24, v200, (uint64_t)v199, (v199 - v200) >> 3);
      if (v251 && v249[0]) {
        free(v249[0]);
      }
      *(_OWORD *)int v249 = 0u;
      long long v250 = 0u;
      char v251 = 1;
      if (v255 && v252[0]) {
        free(v252[0]);
      }
      uint64_t v254 = 0;
      *(_OWORD *)char v252 = 0u;
      long long v253 = 0u;
      char v255 = 1;
      *(void *)v302.__x_ = &unk_1EF752918;
      free(*(void **)&v302.__x_[28]);
      vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract((void **)&v302);
      int v81 = 0;
      uint64_t v200 = (char *)__p[0];
      uint64_t v13 = 11136;
    }
    if (v200)
    {
      __p[1] = v200;
      operator delete(v200);
    }
LABEL_326:
    if (v251 && v249[0]) {
      free(v249[0]);
    }
    if (v255 && v252[0]) {
      free(v252[0]);
    }
    if (!v81)
    {
LABEL_335:
      if (v259 && v256[0]) {
        free(v256[0]);
      }
      float v215 = 0;
      uint64_t v258 = 0;
      *(_OWORD *)long long v256 = 0u;
      long long v257 = 0u;
      uint64_t v13 = 11136;
      char v259 = 1;
      goto LABEL_339;
    }
LABEL_333:
    if (!v259) {
      goto LABEL_341;
    }
    float v215 = v256[0];
LABEL_339:
    if (v215) {
      free(v215);
    }
LABEL_341:
    if (v13 != 11136) {
      goto LABEL_360;
    }
LABEL_342:
    ++v227;
    if ((*(unsigned int (**)(uint64_t))(*(void *)v224 + 8))(v224))
    {
      if (v227 == DWORD2(v245)) {
        uint64_t v13 = 11136;
      }
      else {
        uint64_t v13 = 11107;
      }
      goto LABEL_355;
    }
    uint64_t v30 = *v226;
    if (!*v226) {
      goto LABEL_354;
    }
  }
  syslog(5, "ERROR: dimension mismatch between input data and global dictionary");
  uint64_t v13 = 11112;
LABEL_360:
  syslog(5, "ERROR: error happened in building subdictionary", v222);
LABEL_355:
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v244);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)v247);
  return v13;
}

void sub_1A3FAF44C()
{
  __cxa_end_catch();
  if (v1 && v0) {
    free(v0);
  }
  if (v3)
  {
    if (v2) {
      free(v2);
    }
  }
  JUMPOUT(0x1A3FAF580);
}

void sub_1A3FAF468(void *a1, int a2)
{
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32((void **)&STACK[0x358]);
  if (v2)
  {
    STACK[0x278] = (unint64_t)v2;
    operator delete(v2);
  }
  if (v8 && v7) {
    free(v7);
  }
  if (v10 && v9) {
    free(v9);
  }
  if (v12 && v11) {
    free(v11);
  }
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v5);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)&v6);
  if (a2 == 2)
  {
    __cxa_begin_catch(a1);
    syslog(5, "ERROR: memory allocation error");
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1) {
      JUMPOUT(0x1A3FAF628);
    }
    __cxa_begin_catch(a1);
    syslog(5, "ERROR: an unexpected exception thrown");
    __cxa_end_catch();
  }
  JUMPOUT(0x1A3FAD794);
}

void sub_1A3FAF548()
{
  STACK[0x280] = v1;
  STACK[0x270] = v0;
  JUMPOUT(0x1A3FAF558);
}

void sub_1A3FAF56C()
{
}

void sub_1A3FAF5FC(_Unwind_Exception *a1)
{
}

void sub_1A3FAF608(_Unwind_Exception *a1)
{
}

void sub_1A3FAF614(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

char *vision::mod::CVMLMatrix<float,16ul>::initialize_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (16 - ((4 * (int)a3) & 0xCuLL)) >> 2;
  if (((4 * (int)a3) & 0xCLL) == 0) {
    unint64_t v6 = 0;
  }
  uint64_t v7 = v6 + a3;
  float result = (char *)malloc_type_calloc(4 * a2 * (v6 + a3) + 15, 1uLL, 0x6E22AE6BuLL);
  if (!result)
  {
    exceptiounint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v11 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v11, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  uint64_t v9 = 16 - (result & 0xF);
  if ((result & 0xF) == 0) {
    uint64_t v9 = 0;
  }
  *(void *)a1 = result;
  *(void *)(a1 + 8) = &result[v9];
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 16) = a2;
  *(unsigned char *)(a1 + 40) = 1;
  return result;
}

uint64_t vision::mod::CVMLMatrix<float,16ul>::ptr(void *a1, unint64_t a2)
{
  if (a1[2] <= a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"row index ", 10);
    char v3 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" of ", 4);
    std::ostream::operator<<();
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v5, (uint64_t)&v7);
    std::logic_error::logic_error(exception, &v5);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
  }
  return a1[1] + 4 * a1[4] * a2;
}

{
  void *v3;
  std::logic_error *exception;
  std::string v5;
  uint64_t v6;
  uint64_t v7;

  if (a1[2] <= a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"row index ", 10);
    char v3 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" of ", 4);
    std::ostream::operator<<();
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v5, (uint64_t)&v7);
    std::logic_error::logic_error(exception, &v5);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
  }
  return a1[1] + 4 * a1[4] * a2;
}

void sub_1A3FAF7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

char *vision::mod::CVMLVector<float,16ul>::initialize_(uint64_t a1, uint64_t a2)
{
  float result = (char *)malloc_type_calloc(4 * a2 + 15, 1uLL, 0xA9532734uLL);
  if (!result)
  {
    exceptiounint64_t n = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v7 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v7, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  uint64_t v5 = 16 - (result & 0xF);
  if ((result & 0xF) == 0) {
    uint64_t v5 = 0;
  }
  *(void *)a1 = result;
  *(void *)(a1 + 8) = &result[v5];
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = 1;
  *(unsigned char *)(a1 + 32) = 1;
  return result;
}

uint64_t vision::mod::CVMLMatrix<float,16ul>::mean(uint64_t result, void *a2, char a3)
{
  BOOL v4 = (void *)result;
  if (a3)
  {
    float result = (uint64_t)vision::mod::CVMLVector<float,16ul>::reset((uint64_t)a2, *(void *)(result + 24));
    unint64_t v5 = v4[3];
  }
  else
  {
    unint64_t v5 = *(void *)(result + 24);
    if (a2[2] < v5)
    {
      exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "vector length < cols");
      __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
    }
  }
  if (v5)
  {
    unint64_t v6 = 0;
    unint64_t v7 = v4[2];
    do
    {
      if (v7)
      {
        unint64_t v8 = 0;
        double v9 = 0.0;
        do
        {
          float result = vision::mod::CVMLMatrix<float,16ul>::ptr(v4, v8);
          double v9 = v9 + *(float *)(result + 4 * v6);
          ++v8;
          unint64_t v7 = v4[2];
        }
        while (v8 < v7);
        unint64_t v5 = v4[3];
      }
      else
      {
        double v9 = 0.0;
      }
      float v10 = v9 / (double)v7;
      *(float *)(a2[1] + 4 * a2[3] * v6++) = v10;
    }
    while (v6 < v5);
  }
  return result;
}

void sub_1A3FAF9E4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceID3Model::generateDescriptorID_(vision::mod::FaceID3Model *this, uint64_t *a2)
{
  char v3 = (void *)((char *)this + 96);
  int v4 = 10001;
  uint64_t v5 = 11136;
  while (1)
  {
    int v6 = rand();
    *a2 = v6;
    if (!std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::find<long long>(v3, v6))break; {
    if (!--v4)
    }
    {
      syslog(5, "reach maximum try to find the descriptorID");
      return 11107;
    }
  }
  return v5;
}

char *vision::mod::CVMLVector<float,16ul>::reset(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 32))
  {
    int v4 = *(void **)a1;
    if (*(void *)a1) {
      free(v4);
    }
  }
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(unsigned char *)(a1 + 32) = 1;

  return vision::mod::CVMLVector<float,16ul>::initialize_(a1, a2);
}

void vision::mod::CVMLMatrix<float,16ul>::rowNorms(uint64_t a1, void *a2, char a3)
{
  if (a3)
  {
    vision::mod::CVMLVector<float,16ul>::reset((uint64_t)a2, *(void *)(a1 + 16));
    unint64_t v5 = *(void *)(a1 + 16);
  }
  else
  {
    unint64_t v5 = *(void *)(a1 + 16);
    if (a2[2] < v5)
    {
      exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "vector length < rows");
      __cxa_throw(exception, (struct type_info *)off_1E5B19CC8, MEMORY[0x1E4FBA1D0]);
    }
  }
  if (v5)
  {
    unint64_t v6 = 0;
    do
    {
      unint64_t v7 = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr((void *)a1, v6);
      *(float *)(a2[1] + 4 * a2[3] * v6++) = cblas_sdot(*(_DWORD *)(a1 + 24), v7, 1, v7, 1);
    }
    while (v6 < *(void *)(a1 + 16));
  }
}

void sub_1A3FAFB9C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1A3FAFCB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void *vision::mod::broadcastAdd<float,16ul>(void *a1, void *a2, int a3, void *a4)
{
  v5[4] = *MEMORY[0x1E4F143B8];
  v5[0] = &unk_1EF7531F8;
  v5[3] = v5;
  vision::mod::broadcast<float,16ul>(a1, a2, (uint64_t)v5, a3, a4);
  return std::__function::__value_func<float ()(float,float)>::~__value_func[abi:ne180100](v5);
}

void sub_1A3FAFD84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<float ()(float,float)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::broadcast<float,16ul>(void *a1, void *a2, uint64_t a3, int a4, void *a5)
{
  unint64_t v9 = a1[2];
  if (v9 > a5[2] && a1[3] > a5[3])
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "matrix size too small for output");
    uint64_t v33 = (struct type_info *)off_1E5B19CC8;
    uint64_t v34 = (void (*)(void *))MEMORY[0x1E4FBA1D0];
    goto LABEL_27;
  }
  if (a4 != 1)
  {
    if (a4)
    {
      exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "unknown axis value");
LABEL_26:
      uint64_t v33 = (struct type_info *)off_1E5B19CD8;
      uint64_t v34 = (void (*)(void *))MEMORY[0x1E4FBA1E8];
LABEL_27:
      __cxa_throw(exception, v33, v34);
    }
    if (a2[2] == a1[3])
    {
      uint64_t v10 = vision::mod::CVMLMatrix<float,16ul>::ptr(a1, 0);
      uint64_t v11 = a1[4];
      uint64_t result = vision::mod::CVMLMatrix<float,16ul>::ptr(a5, 0);
      unint64_t v13 = a1[2];
      if (v13)
      {
        uint64_t v14 = result;
        unint64_t v15 = 0;
        unint64_t v16 = a1[3];
        uint64_t v17 = 4 * a5[4];
        uint64_t v18 = 4 * v11;
        do
        {
          if (v16)
          {
            for (unint64_t i = 0; i < v16; ++i)
            {
              uint64_t result = std::function<float ()(float,float)>::operator()(*(void *)(a3 + 24), *(float *)(v10 + 4 * i), *(float *)(a2[1] + 4 * a2[3] * i));
              *(_DWORD *)(v14 + 4 * i) = v20;
              unint64_t v16 = a1[3];
            }
            unint64_t v13 = a1[2];
          }
          ++v15;
          v14 += v17;
          v10 += v18;
        }
        while (v15 < v13);
      }
      return result;
    }
LABEL_25:
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "broadcast op: dimension mismatch");
    goto LABEL_26;
  }
  if (a2[2] != v9) {
    goto LABEL_25;
  }
  uint64_t v21 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a1, 0);
  uint64_t v22 = a1[4];
  uint64_t result = vision::mod::CVMLMatrix<float,16ul>::ptr(a5, 0);
  unint64_t v23 = a1[3];
  if (v23)
  {
    unint64_t v24 = (_DWORD *)result;
    unint64_t v25 = 0;
    unint64_t v26 = a1[2];
    uint64_t v27 = 4 * a5[4];
    uint64_t v28 = 4 * v22;
    do
    {
      if (v26)
      {
        unint64_t v29 = 0;
        uint64_t v35 = v21;
        uint64_t v30 = v24;
        do
        {
          uint64_t result = std::function<float ()(float,float)>::operator()(*(void *)(a3 + 24), *v21, *(float *)(a2[1] + 4 * a2[3] * v29));
          *uint64_t v30 = v31;
          ++v29;
          unint64_t v26 = a1[2];
          uint64_t v30 = (_DWORD *)((char *)v30 + v27);
          uint64_t v21 = (float *)((char *)v21 + v28);
        }
        while (v29 < v26);
        unint64_t v23 = a1[3];
        uint64_t v21 = v35;
      }
      ++v25;
      ++v24;
      ++v21;
    }
    while (v25 < v23);
  }
  return result;
}

void sub_1A3FB000C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<float ()(float,float)>::~__value_func[abi:ne180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::function<float ()(float,float)>::operator()(uint64_t a1, float a2, float a3)
{
  float v5 = a2;
  float v4 = a3;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, float *, float *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

void *std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::target_type()
{
}

uint64_t std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"ZN6vision3mod12broadcastAddIfLm16EEEvRKNS0_10CVMLMatrixIT_XT0_EEERKNS0_10CVMLVectorIS3_XT0_EEEiRS4_bEUlffE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

float std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::operator()(uint64_t a1, float *a2, float *a3)
{
  return *a2 + *a3;
}

void std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF7531F8;
}

void *std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF7531F8;
  return result;
}

void std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::~__func()
{
}

void vision::mod::Kmeans<float,16ul>::labelEstimation_(void *a1, int a2, uint64_t a3, void **a4, void *a5, void *__b, float *a7, float *a8)
{
  uint64_t v16 = a1[2];
  uint64_t v17 = 4 * v16;
  if (v16)
  {
    memset(__b, 255, 4 * v16);
    memset_pattern16(a7, &unk_1A410C4F0, 4 * v16);
  }
  vision::mod::euclideanDistances<float,16ul>(a3, a1, a5, a4);
  if (a2 >= 1)
  {
    unint64_t v18 = 0;
    do
    {
      unint64_t v19 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a5, v18);
      if (v16)
      {
        int v20 = a7;
        uint64_t v21 = __b;
        uint64_t v22 = v16;
        do
        {
          float v23 = *v19;
          if (*v19 < *v20)
          {
            *uint64_t v21 = v18;
            *int v20 = v23;
          }
          ++v21;
          ++v20;
          ++v19;
          --v22;
        }
        while (v22);
      }
      ++v18;
    }
    while (v18 != a2);
  }
  float v24 = 0.0;
  if (v16)
  {
    do
    {
      float v25 = *a7++;
      float v24 = v24 + v25;
      v17 -= 4;
    }
    while (v17);
  }
  *a8 = v24;
}

uint64_t *std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    unint64_t v8 = (char *)result;
    if (a4 == 2)
    {
      uint64_t v9 = *(a2 - 1);
      uint64_t v10 = *result;
      if (*(float *)(**a3 + 4 * v9) > *(float *)(**a3 + 4 * *result))
      {
        *uint64_t result = v9;
        *(a2 - 1) = v10;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      uint64_t v22 = (char *)a5;
      unint64_t v23 = a4 >> 1;
      float v24 = &result[a4 >> 1];
      unint64_t v25 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, v25, a5);
        unint64_t v26 = (uint64_t *)&v22[8 * v23];
        uint64_t result = std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>((uint64_t *)&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v26);
        uint64_t v27 = &v22[8 * a4];
        uint64_t v28 = *a3;
        unint64_t v29 = v26;
        while (v29 != (uint64_t *)v27)
        {
          uint64_t v30 = *v29;
          float v31 = *(float *)(*v28 + 4 * *v29);
          float v32 = *(float *)(*v28 + 4 * *(void *)v22);
          if (v31 <= v32) {
            uint64_t v30 = *(void *)v22;
          }
          v22 += 8 * (v31 <= v32);
          v29 += v31 > v32;
          *(void *)unint64_t v8 = v30;
          v8 += 8;
          if (v22 == (char *)v26)
          {
            if (v29 != (uint64_t *)v27)
            {
              uint64_t v33 = 0;
              do
              {
                *(void *)&v8[v33 * 8] = v29[v33];
                ++v33;
              }
              while (&v29[v33] != (uint64_t *)v27);
            }
            return result;
          }
        }
        if (v22 != (char *)v26)
        {
          uint64_t v34 = 0;
          do
          {
            *(void *)&v8[v34] = *(void *)&v22[v34];
            v34 += 8;
          }
          while (&v22[v34] != (char *)v26);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, v25, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v22, a6);
        return (uint64_t *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v8, &v8[8 * (a4 >> 1)], (char *)a2, a3, a4 >> 1, a4 - (a4 >> 1), v22, a6);
      }
    }
    else if (result != a2)
    {
      char v12 = result + 1;
      if (result + 1 != a2)
      {
        uint64_t v13 = 0;
        uint64_t v14 = **a3;
        unint64_t v15 = result;
        do
        {
          uint64_t v17 = *v15;
          uint64_t v16 = v15[1];
          unint64_t v15 = v12;
          float v18 = *(float *)(v14 + 4 * v16);
          if (v18 > *(float *)(v14 + 4 * v17))
          {
            uint64_t v19 = v13;
            while (1)
            {
              *(uint64_t *)((char *)result + v19 + 8) = v17;
              if (!v19) {
                break;
              }
              uint64_t v17 = *(uint64_t *)((char *)result + v19 - 8);
              v19 -= 8;
              if (v18 <= *(float *)(v14 + 4 * v17))
              {
                int v20 = (uint64_t *)((char *)result + v19 + 8);
                goto LABEL_15;
              }
            }
            int v20 = result;
LABEL_15:
            *int v20 = v16;
          }
          char v12 = v15 + 1;
          v13 += 8;
        }
        while (v15 + 1 != a2);
      }
    }
  }
  return result;
}

uint64_t *std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5)
{
  if (a4)
  {
    float v5 = a5;
    unint64_t v7 = result;
    if (a4 == 1)
    {
LABEL_8:
      *float v5 = *v7;
      return result;
    }
    if (a4 == 2)
    {
      uint64_t v10 = *(a2 - 1);
      uint64_t v11 = **a3;
      float v12 = *(float *)(v11 + 4 * v10);
      float v13 = *(float *)(v11 + 4 * *result);
      if (v12 <= v13) {
        uint64_t v10 = *result;
      }
      *a5 = v10;
      float v5 = a5 + 1;
      if (v12 <= v13) {
        unint64_t v7 = a2 - 1;
      }
      goto LABEL_8;
    }
    if ((uint64_t)a4 > 8)
    {
      float v24 = &result[a4 >> 1];
      std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, a4 >> 1, a5, a4 >> 1);
      uint64_t result = (uint64_t *)std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      unint64_t v25 = *a3;
      unint64_t v26 = &v7[a4 >> 1];
      while (v26 != a2)
      {
        uint64_t v27 = *v26;
        float v28 = *(float *)(*v25 + 4 * *v26);
        float v29 = *(float *)(*v25 + 4 * *v7);
        if (v28 <= v29) {
          uint64_t v27 = *v7;
        }
        v26 += v28 > v29;
        v7 += v28 <= v29;
        *v5++ = v27;
        if (v7 == v24)
        {
          if (v26 != a2)
          {
            uint64_t v30 = 0;
            do
            {
              v5[v30] = v26[v30];
              ++v30;
            }
            while (&v26[v30] != a2);
          }
          return result;
        }
      }
      if (v7 != v24)
      {
        uint64_t v31 = 0;
        do
        {
          v5[v31] = v7[v31];
          ++v31;
        }
        while (&v7[v31] != v24);
      }
    }
    else if (result != a2)
    {
      uint64_t v14 = result + 1;
      *a5 = *result;
      if (result + 1 != a2)
      {
        uint64_t v15 = 0;
        uint64_t v16 = **a3;
        uint64_t v17 = a5;
        float v18 = a5;
        do
        {
          uint64_t v20 = *v18++;
          uint64_t v19 = v20;
          if (*(float *)(v16 + 4 * *v14) <= *(float *)(v16 + 4 * v20))
          {
            *float v18 = *v14;
          }
          else
          {
            v17[1] = v19;
            uint64_t v21 = a5;
            if (v17 != a5)
            {
              uint64_t v22 = v15;
              while (1)
              {
                uint64_t v21 = (uint64_t *)((char *)a5 + v22);
                uint64_t v23 = *(uint64_t *)((char *)a5 + v22 - 8);
                if (*(float *)(v16 + 4 * *v14) <= *(float *)(v16 + 4 * v23)) {
                  break;
                }
                *uint64_t v21 = v23;
                v22 -= 8;
                if (!v22)
                {
                  uint64_t v21 = a5;
                  break;
                }
              }
            }
            *uint64_t v21 = *v14;
          }
          ++v14;
          v15 += 8;
          uint64_t v17 = v18;
        }
        while (v14 != a2);
      }
    }
  }
  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(char *result, char *a2, char *a3, uint64_t **a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  if (a6)
  {
    uint64_t v10 = a6;
    float v13 = result;
    while (v10 > a8 && a5 > a8)
    {
      if (!a5) {
        return result;
      }
      uint64_t v14 = **a4;
      while (1)
      {
        uint64_t v15 = *(void *)v13;
        if (*(float *)(v14 + 4 * *(void *)a2) > *(float *)(v14 + 4 * *(void *)v13)) {
          break;
        }
        v13 += 8;
        if (!--a5) {
          return result;
        }
      }
      uint64_t v51 = a8;
      uint64_t v52 = a3;
      if (a5 >= v10)
      {
        if (a5 == 1)
        {
          *(void *)float v13 = *(void *)a2;
          *(void *)a2 = v15;
          return result;
        }
        uint64_t v16 = a4;
        if (a5 >= 0) {
          uint64_t v27 = a5;
        }
        else {
          uint64_t v27 = a5 + 1;
        }
        uint64_t v26 = v27 >> 1;
        uint64_t v20 = &v13[8 * (v27 >> 1)];
        uint64_t v19 = a3;
        if (a3 != a2)
        {
          unint64_t v28 = (a3 - a2) >> 3;
          uint64_t v19 = a2;
          do
          {
            unint64_t v29 = v28 >> 1;
            uint64_t v30 = &v19[8 * (v28 >> 1)];
            uint64_t v32 = *(void *)v30;
            uint64_t v31 = v30 + 8;
            v28 += ~(v28 >> 1);
            if (*(float *)(v14 + 4 * v32) > *(float *)(v14 + 4 * *(void *)v20)) {
              uint64_t v19 = v31;
            }
            else {
              unint64_t v28 = v29;
            }
          }
          while (v28);
        }
        uint64_t v18 = (v19 - a2) >> 3;
      }
      else
      {
        uint64_t v16 = a4;
        if (v10 >= 0) {
          uint64_t v17 = v10;
        }
        else {
          uint64_t v17 = v10 + 1;
        }
        uint64_t v18 = v17 >> 1;
        uint64_t v19 = &a2[8 * (v17 >> 1)];
        uint64_t v20 = a2;
        if (a2 != v13)
        {
          unint64_t v21 = (a2 - v13) >> 3;
          uint64_t v20 = v13;
          do
          {
            unint64_t v22 = v21 >> 1;
            uint64_t v23 = &v20[8 * (v21 >> 1)];
            uint64_t v25 = *(void *)v23;
            float v24 = v23 + 8;
            v21 += ~(v21 >> 1);
            if (*(float *)(v14 + 4 * *(void *)v19) > *(float *)(v14 + 4 * v25)) {
              unint64_t v21 = v22;
            }
            else {
              uint64_t v20 = v24;
            }
          }
          while (v21);
        }
        uint64_t v26 = (v20 - v13) >> 3;
      }
      a5 -= v26;
      v10 -= v18;
      uint64_t v33 = v26;
      uint64_t v34 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,unsigned long *>(v20, a2, v19);
      uint64_t v35 = v33;
      float v36 = v34;
      if (v35 + v18 >= a5 + v10)
      {
        uint64_t v39 = v52;
        uint64_t v53 = v35;
        uint64_t result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v34, v19, v39, v16, a5, v10, a7, v51);
        uint64_t v19 = v20;
        a4 = v16;
        a8 = v51;
        uint64_t v10 = v18;
        a5 = v53;
        a3 = v36;
      }
      else
      {
        uint64_t v37 = v20;
        a4 = v16;
        uint64_t v38 = v16;
        a8 = v51;
        uint64_t result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v13, v37, v34, v38, v35, v18, a7, v51);
        float v13 = v36;
        a3 = v52;
      }
      a2 = v19;
      if (!v10) {
        return result;
      }
    }
    if (a5 <= v10)
    {
      if (v13 != a2)
      {
        uint64_t v44 = 0;
        do
        {
          *(void *)&a7[v44] = *(void *)&v13[v44];
          v44 += 8;
        }
        while (&v13[v44] != a2);
        uint64_t v45 = &a7[v44];
        if (v45 != a7)
        {
          uint64_t v46 = *a4;
          while (a2 != a3)
          {
            uint64_t v47 = *(void *)a2;
            float v48 = *(float *)(*v46 + 4 * *(void *)a2);
            float v49 = *(float *)(*v46 + 4 * *(void *)a7);
            if (v48 <= v49) {
              uint64_t v47 = *(void *)a7;
            }
            a7 += 8 * (v48 <= v49);
            a2 += 8 * (v48 > v49);
            *(void *)float v13 = v47;
            v13 += 8;
            if (a7 == v45) {
              return result;
            }
          }
          return (char *)memmove(v13, a7, v45 - a7);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v40 = 0;
      do
      {
        *(void *)&a7[v40] = *(void *)&a2[v40];
        v40 += 8;
      }
      while (&a2[v40] != a3);
      uint64_t v41 = &a7[v40];
      if (v41 != a7)
      {
        unint64_t v42 = a3 - 8;
        while (a2 != v13)
        {
          uint64_t v43 = *((void *)v41 - 1);
          if (*(float *)(**a4 + 4 * v43) <= *(float *)(**a4 + 4 * *((void *)a2 - 1)))
          {
            v41 -= 8;
          }
          else
          {
            uint64_t v43 = *((void *)a2 - 1);
            a2 -= 8;
          }
          *(void *)unint64_t v42 = v43;
          v42 -= 8;
          if (v41 == a7) {
            return result;
          }
        }
        uint64_t v50 = 0;
        do
        {
          *(void *)&v42[v50] = *(void *)&v41[v50 - 8];
          v50 -= 8;
        }
        while (&v41[v50] != a7);
      }
    }
  }
  return result;
}

void vision::mod::euclideanDistances<float,16ul>(uint64_t a1, void *a2, void *a3, void **a4)
{
  if (*(void *)(a1 + 24) != a2[3])
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "dimensions of data points mismatch");
    float v24 = (struct type_info *)off_1E5B19CD8;
    uint64_t v25 = (void (*)(void *))MEMORY[0x1E4FBA1E8];
LABEL_31:
    __cxa_throw(exception, v24, v25);
  }
  if (*(void *)(a1 + 16) > a3[2] || (unint64_t v7 = a2[2], v7 > a3[3]))
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "output distance matrix too small");
    float v24 = (struct type_info *)off_1E5B19CC8;
    uint64_t v25 = (void (*)(void *))MEMORY[0x1E4FBA1D0];
    goto LABEL_31;
  }
  unint64_t v8 = a4;
  *(_OWORD *)uint64_t v35 = 0u;
  long long v36 = 0u;
  char v37 = 1;
  if (!a4)
  {
    vision::mod::CVMLVector<float,16ul>::reset((uint64_t)v35, v7);
    unint64_t v8 = v35;
    vision::mod::CVMLMatrix<float,16ul>::rowNorms((uint64_t)a2, v35, 0);
  }
  *(_OWORD *)uint64_t v32 = 0u;
  long long v33 = 0u;
  uint64_t v30 = v8;
  uint64_t v31 = v8;
  char v34 = 1;
  if ((void *)a1 != a2)
  {
    vision::mod::CVMLVector<float,16ul>::reset((uint64_t)v32, *(void *)(a1 + 16));
    uint64_t v31 = v32;
    vision::mod::CVMLMatrix<float,16ul>::rowNorms(a1, v32, 0);
  }
  uint64_t v9 = *(void *)(a1 + 24);
  if (v9 != a2[3])
  {
    uint64_t v26 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v26, "matrix size mismatch");
    uint64_t v27 = (void (*)(void *))MEMORY[0x1E4FBA1E8];
    unint64_t v28 = (struct type_info *)off_1E5B19CD8;
    uint64_t v29 = MEMORY[0x1E4FBA4E8] + 16;
    goto LABEL_34;
  }
  unint64_t v10 = *(void *)(a1 + 16);
  if (a3[2] < v10 || (unint64_t v11 = a2[2], a3[3] < v11))
  {
    uint64_t v26 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v26, "matrix size too small for output");
    uint64_t v27 = (void (*)(void *))MEMORY[0x1E4FBA1D0];
    unint64_t v28 = (struct type_info *)off_1E5B19CC8;
    uint64_t v29 = MEMORY[0x1E4FBA4D8] + 16;
LABEL_34:
    v26->__vftable = (std::logic_error_vtbl *)v29;
    __cxa_throw(v26, v28, v27);
  }
  float v12 = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr((void *)a1, 0);
  int v13 = *(_DWORD *)(a1 + 32);
  __B = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a2, 0);
  uint64_t __ldb = a2[4];
  uint64_t __C = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a3, 0);
  cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasTrans, v10, v11, v9, -2.0, v12, v13, __B, __ldb, 0.0, __C, a3[4]);
  vision::mod::broadcastAdd<float,16ul>(a3, v31, 1, a3);
  vision::mod::broadcastAdd<float,16ul>(a3, v30, 0, a3);
  if (a3[2])
  {
    unint64_t v17 = 0;
    do
    {
      uint64_t v18 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a3, v17);
      for (uint64_t i = a3[3]; i; --i)
      {
        *uint64_t v18 = fmaxf(*v18, 0.0);
        ++v18;
      }
      ++v17;
      unint64_t v20 = a3[2];
    }
    while (v17 < v20);
    if ((void *)a1 == a2 && v20)
    {
      unint64_t v21 = 0;
      do
      {
        *(_DWORD *)(vision::mod::CVMLMatrix<float,16ul>::ptr(a3, v21) + 4 * v21) = 0;
        ++v21;
      }
      while (v21 < a3[2]);
    }
  }
  if (v34 && v32[0]) {
    free(v32[0]);
  }
  if (v37)
  {
    unint64_t v22 = v35[0];
    if (v35[0])
    {
      free(v22);
    }
  }
}

void sub_1A3FB0EB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  __cxa_free_exception(v25);
  if (a19 && a15) {
    free(a15);
  }
  if (a25)
  {
    if (a21) {
      free(a21);
    }
  }
  _Unwind_Resume(a1);
}

void *std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::target_type()
{
}

uint64_t std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"ZN6vision3mod14broadcastMinusIfLm16EEEvRKNS0_10CVMLMatrixIT_XT0_EEERKNS0_10CVMLVectorIS3_XT0_EEEiRS4_bEUlffE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

float std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::operator()(uint64_t a1, float *a2, float *a3)
{
  return *a2 - *a3;
}

void std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF7532A8;
}

void *std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF7532A8;
  return result;
}

void std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::~__func()
{
}

uint64_t vision::mod::FaceID3Model::getIdentityTrainingData(vision::mod::FaceID3Model *this, vision::mod::FaceID3Model *a2, uint64_t *a3, uint64_t *a4)
{
  int v5 = (int)a3;
  uint64_t v8 = vision::mod::FaceID3Model::checkTestingParams_(a2);
  *a4 = v8;
  if (v8 != 11136)
  {
    uint64_t result = 0;
    goto LABEL_23;
  }
  unint64_t v9 = *((void *)a2 + 8);
  if (!v9) {
    goto LABEL_21;
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v11 = v5;
    if (v9 <= v5) {
      unint64_t v11 = v5 % v9;
    }
  }
  else
  {
    unint64_t v11 = (v9 - 1) & v5;
  }
  int v13 = *(uint64_t ***)(*((void *)a2 + 7) + 8 * v11);
  if (!v13 || (uint64_t v14 = *v13) == 0)
  {
LABEL_21:
    uint64_t v15 = &CVML_status_invalidParameter;
    goto LABEL_22;
  }
  uint64_t v15 = &CVML_status_invalidParameter;
  while (1)
  {
    unint64_t v16 = v14[1];
    if (v16 == v5) {
      break;
    }
    if (v10.u32[0] > 1uLL)
    {
      if (v16 >= v9) {
        v16 %= v9;
      }
    }
    else
    {
      v16 &= v9 - 1;
    }
    if (v16 != v11) {
      goto LABEL_22;
    }
LABEL_19:
    uint64_t v14 = (uint64_t *)*v14;
    if (!v14) {
      goto LABEL_22;
    }
  }
  if (*((_DWORD *)v14 + 4) != v5) {
    goto LABEL_19;
  }
  uint64_t v18 = v14[3];
  uint64_t v19 = v14[4];
  unint64_t v17 = v14 + 3;
  if (v19 == v18)
  {
    uint64_t v15 = &CVML_status_inconsistentState;
LABEL_22:
    uint64_t result = 0;
    *a4 = (*v15 + 128) | 0x2B00;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t *))(**((void **)a2 + 6) + 32))(*((void *)a2 + 6), v17);
    if (!result)
    {
      uint64_t v15 = &CVML_status_memoryAllocationError;
      goto LABEL_22;
    }
  }
LABEL_23:
  *(void *)this = result;
  return result;
}

uint64_t vision::mod::FaceID3Model::checkTestingParams_(vision::mod::FaceID3Model *this)
{
  uint64_t v1 = *((void *)this + 15);
  if (!v1)
  {
    syslog(5, "ERROR: empty dictIds_");
LABEL_10:
    char v3 = &CVML_status_inconsistentState;
    return (*v3 + 128) | 0x2B00;
  }
  if (!*((void *)this + 10))
  {
    syslog(5, "ERROR: empty labels");
    goto LABEL_10;
  }
  uint64_t v2 = *(void *)(*((void *)this + 6) + 72);
  if (!v2)
  {
    syslog(5, "ERROR: empty dictionary data");
    goto LABEL_10;
  }
  if (v1 != v2)
  {
    syslog(5, "ERROR: number of elements dismatch between dictIds_ and dictData_");
    goto LABEL_10;
  }
  char v3 = &CVML_status_ok;
  return (*v3 + 128) | 0x2B00;
}

uint64_t vision::mod::FaceID3Model::predict(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL v3 = *(int *)(a2 + 64) < 1 || *(_DWORD *)(a2 + 96) < 1;
  if (v3 || (v4 = a2, uint64_t v5 = *(void *)(a2 + 72), (v5 & 0x80000000) != 0))
  {
    syslog(5, "ERROR: invalid image descriptor buffer");
    return 11132;
  }
  if (v5)
  {
    uint64_t result = vision::mod::FaceID3Model::checkTestingParams_((vision::mod::FaceID3Model *)a1);
    if (result != 11136) {
      return result;
    }
    uint64_t v9 = *(void *)(a1 + 48);
    int v108 = 0;
    uint64_t v109 = 0;
    float v107 = 0;
    std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(&v107, *(const void **)(v9 + 8), *(void *)(v9 + 16), (uint64_t)(*(void *)(v9 + 16) - *(void *)(v9 + 8)) >> 3);
    vision::mod::FaceID3Model::normalizeDescriptor_((vision::mod::FaceID3Model *)&v106, *(vision::mod::ImageDescriptorBufferFloat32 **)(a1 + 48));
    uint64_t v93 = v5;
    uint64_t v10 = 0;
    int v90 = a3 + 2;
    uint64_t v91 = v4;
    float v92 = a3;
    do
    {
      unint64_t v11 = (vision::mod::ImageDescriptorBufferFloat32 *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
      (*(void (**)(uint64_t, vision::mod::ImageDescriptorBufferFloat32 *, uint64_t))(*(void *)v4 + 112))(v4, v11, v10);
      vision::mod::FaceID3Model::normalizeDescriptor_((vision::mod::FaceID3Model *)&v105, v11);
      uint64_t v96 = v10;
      uint64_t v13 = v105;
      uint64_t v12 = v106;
      *(_DWORD *)(v105 + 104) = *(_DWORD *)(a1 + 44);
      uint64_t v94 = v12;
      (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v13 + 80))(&__p, v13);
      uint64_t v14 = (float *)__p;
      uint64_t v15 = v104;
      while (v14 != v15)
      {
        *uint64_t v14 = *v14 + *v14;
        ++v14;
      }
      uint64_t v101 = 0;
      uint64_t v102 = 0;
      uint64_t v100 = (uint64_t *)&v101;
      unint64_t v16 = v107;
      if (v108 == v107) {
        goto LABEL_40;
      }
      uint64_t v17 = 0;
      uint64_t v18 = (unint64_t)((v108 - (unsigned char *)v107) >> 3) <= 1 ? 1 : (v108 - (unsigned char *)v107) >> 3;
      do
      {
        uint64_t v110 = (uint64_t *)v16[v17];
        float v19 = 1.0 - *((float *)__p + v17);
        int v20 = *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((float *)(a1 + 96), (unint64_t)v110, &v110)+ 6);
        LODWORD(v97) = v20;
        unint64_t v21 = v101;
        if (!v101) {
          goto LABEL_25;
        }
        unint64_t v22 = &v101;
        do
        {
          uint64_t v23 = v21;
          float v24 = v22;
          int v25 = *((_DWORD *)v21 + 8);
          uint64_t v26 = v21 + 1;
          if (v25 >= v20)
          {
            uint64_t v26 = v23;
            unint64_t v22 = (void **)v23;
          }
          unint64_t v21 = (void *)*v26;
        }
        while (v21);
        if (v22 == &v101) {
          goto LABEL_25;
        }
        if (v25 < v20) {
          uint64_t v23 = v24;
        }
        if (v20 >= *((_DWORD *)v23 + 8))
        {
          double v27 = v19;
          if (*((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v100, v20, &v97)+ 5) >= v27)double v27 = *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v100, v20, &v97)+ 5); {
          *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v100, v20, &v97)+ 5) = v27;
          }
        }
        else
        {
LABEL_25:
          *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v100, v20, &v97)+ 5) = v19;
        }
        ++v17;
      }
      while (v17 != v18);
      if (v102 != 1)
      {
LABEL_40:
        uint64_t v95 = v13;
        uint64_t v32 = v100;
        if (v100 == (uint64_t *)&v101)
        {
          long long v33 = 0;
          unint64_t v34 = 0;
        }
        else
        {
          long long v33 = 0;
          unint64_t v34 = 0;
          uint64_t v35 = 0;
          do
          {
            int v36 = *((_DWORD *)v32 + 8);
            uint64_t v37 = v32[5];
            if (v34 >= (unint64_t)v35)
            {
              uint64_t v38 = (uint64_t)(v34 - (void)v33) >> 4;
              unint64_t v39 = v38 + 1;
              if ((unint64_t)(v38 + 1) >> 60) {
                std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
              }
              if ((v35 - v33) >> 3 > v39) {
                unint64_t v39 = (v35 - v33) >> 3;
              }
              if ((unint64_t)(v35 - v33) >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v40 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v40 = v39;
              }
              if (v40)
              {
                if (v40 >> 60) {
                  std::__throw_bad_array_new_length[abi:ne180100]();
                }
                uint64_t v41 = (char *)operator new(16 * v40);
              }
              else
              {
                uint64_t v41 = 0;
              }
              unint64_t v42 = &v41[16 * v38];
              *(_DWORD *)unint64_t v42 = v36;
              *((void *)v42 + 1) = v37;
              if ((char *)v34 == v33)
              {
                uint64_t v44 = &v41[16 * v38];
              }
              else
              {
                uint64_t v43 = &v41[16 * v38];
                do
                {
                  uint64_t v44 = v43 - 16;
                  *((_OWORD *)v43 - 1) = *(_OWORD *)(v34 - 16);
                  v34 -= 16;
                  v43 -= 16;
                }
                while ((char *)v34 != v33);
              }
              uint64_t v35 = &v41[16 * v40];
              unint64_t v34 = (unint64_t)(v42 + 16);
              if (v33) {
                operator delete(v33);
              }
              long long v33 = v44;
            }
            else
            {
              *(_DWORD *)unint64_t v34 = v36;
              *(void *)(v34 + 8) = v37;
              v34 += 16;
            }
            uint64_t v45 = (uint64_t *)v32[1];
            if (v45)
            {
              do
              {
                uint64_t v46 = v45;
                uint64_t v45 = (uint64_t *)*v45;
              }
              while (v45);
            }
            else
            {
              do
              {
                uint64_t v46 = (uint64_t *)v32[2];
                BOOL v51 = *v46 == (void)v32;
                uint64_t v32 = v46;
              }
              while (!v51);
            }
            uint64_t v32 = v46;
          }
          while (v46 != (uint64_t *)&v101);
        }
        unint64_t v47 = 126 - 2 * __clz((uint64_t)(v34 - (void)v33) >> 4);
        if ((char *)v34 == v33) {
          uint64_t v48 = 0;
        }
        else {
          uint64_t v48 = v47;
        }
        std::__introsort<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *,false>((double *)v33, v34, v48, 1);
        int v111 = 0;
        unint64_t v112 = 0;
        float v49 = v33;
        uint64_t v110 = (uint64_t *)&v111;
        if ((char *)v34 == v33)
        {
          std::vector<int>::size_type v98 = 0;
          uint64_t v99 = 0;
          uint64_t v97 = (uint64_t *)&v98;
          uint64_t v13 = v95;
          uint64_t v29 = v92;
        }
        else
        {
          do
          {
            uint64_t v50 = (uint64_t *)*((void *)v49 + 1);
            std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v110, *(_DWORD *)v49, v49)[5] = v50;
            v49 += 16;
            BOOL v51 = v112 >= *(int *)(a1 + 40) || v49 == (char *)v34;
          }
          while (!v51);
          uint64_t v52 = v110;
          std::vector<int>::size_type v98 = 0;
          uint64_t v99 = 0;
          uint64_t v97 = (uint64_t *)&v98;
          uint64_t v13 = v95;
          uint64_t v29 = v92;
          if (v110 != (uint64_t *)&v111)
          {
            float v53 = *(float *)(a1 + 36);
            float v54 = 0.0;
            do
            {
              double v55 = *((double *)v52 + 5);
              *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v97, *((_DWORD *)v52 + 8), (_DWORD *)v52 + 8)+ 5) = v55 / v53;
              float v53 = *(float *)(a1 + 36);
              double v56 = exp(*((double *)v52 + 5) / v53);
              long long v57 = (uint64_t *)v52[1];
              if (v57)
              {
                do
                {
                  float v58 = v57;
                  long long v57 = (uint64_t *)*v57;
                }
                while (v57);
              }
              else
              {
                do
                {
                  float v58 = (uint64_t *)v52[2];
                  BOOL v51 = *v58 == (void)v52;
                  uint64_t v52 = v58;
                }
                while (!v51);
              }
              double v59 = v56 + v54;
              float v54 = v59;
              uint64_t v52 = v58;
            }
            while (v58 != (uint64_t *)&v111);
            uint64_t v60 = v97;
            if (v97 != (uint64_t *)&v98)
            {
              float v61 = v59;
              double v62 = logf(v61);
              do
              {
                *((long double *)v60 + 5) = exp(*((double *)v60 + 5) - v62);
                uint64_t v63 = (uint64_t *)v60[1];
                if (v63)
                {
                  do
                  {
                    uint64_t v64 = v63;
                    uint64_t v63 = (uint64_t *)*v63;
                  }
                  while (v63);
                }
                else
                {
                  do
                  {
                    uint64_t v64 = (uint64_t *)v60[2];
                    BOOL v51 = *v64 == (void)v60;
                    uint64_t v60 = v64;
                  }
                  while (!v51);
                }
                uint64_t v60 = v64;
              }
              while (v64 != (uint64_t *)&v98);
            }
          }
        }
        float v65 = v100;
        if (v100 != (uint64_t *)&v101)
        {
          do
          {
            int v66 = *((_DWORD *)v65 + 8);
            int v67 = v98;
            if (!v98) {
              goto LABEL_107;
            }
            float32x4_t v68 = &v98;
            do
            {
              unint64_t v69 = v67;
              uint64_t v70 = v68;
              int v71 = *((_DWORD *)v67 + 8);
              unint64_t v72 = v67 + 1;
              if (v71 >= v66)
              {
                unint64_t v72 = v69;
                float32x4_t v68 = (void **)v69;
              }
              int v67 = (void *)*v72;
            }
            while (v67);
            if (v68 == &v98) {
              goto LABEL_107;
            }
            if (v71 < v66) {
              unint64_t v69 = v70;
            }
            if (v66 < *((_DWORD *)v69 + 8)) {
LABEL_107:
            }
              std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v97, v66, (_DWORD *)v65 + 8)[5] = 0;
            unint64_t v73 = (uint64_t *)v65[1];
            if (v73)
            {
              do
              {
                uint64_t v74 = v73;
                unint64_t v73 = (uint64_t *)*v73;
              }
              while (v73);
            }
            else
            {
              do
              {
                uint64_t v74 = (uint64_t *)v65[2];
                BOOL v51 = *v74 == (void)v65;
                float v65 = v74;
              }
              while (!v51);
            }
            float v65 = v74;
          }
          while (v74 != (uint64_t *)&v101);
        }
        std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v111);
        if (v33) {
          operator delete(v33);
        }
      }
      else
      {
        std::vector<int>::size_type v98 = 0;
        uint64_t v99 = 0;
        uint64_t v97 = (uint64_t *)&v98;
        unint64_t v28 = v100;
        uint64_t v29 = v92;
        if (v100 != (uint64_t *)&v101)
        {
          do
          {
            *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v97, *((_DWORD *)v28 + 8), (_DWORD *)v28 + 8)+ 5) = fmax(fmin(*((double *)v28 + 5), 1.0), 0.0);
            uint64_t v30 = (uint64_t *)v28[1];
            if (v30)
            {
              do
              {
                uint64_t v31 = v30;
                uint64_t v30 = (uint64_t *)*v30;
              }
              while (v30);
            }
            else
            {
              do
              {
                uint64_t v31 = (uint64_t *)v28[2];
                BOOL v51 = *v31 == (void)v28;
                unint64_t v28 = v31;
              }
              while (!v51);
            }
            unint64_t v28 = v31;
          }
          while (v31 != (uint64_t *)&v101);
        }
      }
      unint64_t v75 = (void *)v29[1];
      unint64_t v76 = v29[2];
      if ((unint64_t)v75 >= v76)
      {
        unint64_t v80 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v75 - *v29) >> 3);
        unint64_t v81 = v80 + 1;
        uint64_t v4 = v91;
        if (v80 + 1 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v76 - *v29) >> 3);
        if (2 * v82 > v81) {
          unint64_t v81 = 2 * v82;
        }
        if (v82 >= 0x555555555555555) {
          unint64_t v83 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v83 = v81;
        }
        float v114 = v90;
        if (v83) {
          unint64_t v83 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v83);
        }
        else {
          uint64_t v84 = 0;
        }
        float v86 = (void *)(v83 + 24 * v80);
        uint64_t v110 = (uint64_t *)v83;
        int v111 = v86;
        unint64_t v113 = v83 + 24 * v84;
        *float v86 = v97;
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v87 = v98;
        v86[1] = v98;
        unint64_t v88 = v86 + 1;
        uint64_t v89 = v99;
        v86[2] = v99;
        if (v89)
        {
          v87[2] = v88;
          uint64_t v97 = (uint64_t *)&v98;
          std::vector<int>::size_type v98 = 0;
          uint64_t v99 = 0;
        }
        else
        {
          *float v86 = v88;
        }
        unint64_t v112 = (unint64_t)(v86 + 3);
        std::vector<std::map<int,double>>::__swap_out_circular_buffer(v29, &v110);
        float v85 = (void *)v29[1];
        std::__split_buffer<std::map<int,double>>::~__split_buffer((uint64_t)&v110);
      }
      else
      {
        *unint64_t v75 = v97;
        uint64_t v77 = v98;
        v75[1] = v98;
        int v78 = v75 + 1;
        uint64_t v79 = v99;
        v75[2] = v99;
        uint64_t v4 = v91;
        if (v79)
        {
          v77[2] = v78;
          uint64_t v97 = (uint64_t *)&v98;
          std::vector<int>::size_type v98 = 0;
          uint64_t v99 = 0;
        }
        else
        {
          *unint64_t v75 = v78;
        }
        float v85 = v75 + 3;
      }
      v29[1] = (uint64_t)v85;
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v98);
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v101);
      if (__p)
      {
        unint64_t v104 = (float *)__p;
        operator delete(__p);
      }
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      uint64_t v10 = v96 + 1;
    }
    while (v96 + 1 != v93);
    if (v94) {
      (*(void (**)(uint64_t))(*(void *)v94 + 8))(v94);
    }
    if (v107) {
      operator delete(v107);
    }
  }
  return 11136;
}

void sub_1A3FB1AC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (__p) {
    operator delete(__p);
  }
  if (a2 == 2)
  {
    __cxa_begin_catch(exception_object);
    syslog(5, "ERROR: memory allocation failed");
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1) {
      _Unwind_Resume(exception_object);
    }
    __cxa_begin_catch(exception_object);
    syslog(5, "ERROR: unexpected exception thrown");
    __cxa_end_catch();
  }
  JUMPOUT(0x1A3FB1A7CLL);
}

uint64_t vision::mod::FaceID3Model::normalizeDescriptor_(vision::mod::FaceID3Model *this, vision::mod::ImageDescriptorBufferFloat32 *a2)
{
  uint64_t v4 = *((void *)a2 + 9);
  if (v4)
  {
    unint64_t v5 = 0;
    vDSP_Length v6 = *((void *)a2 + 12);
    do
    {
      unint64_t DataForKthDescriptor = (float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, v5);
      float __C = 0.0;
      vDSP_svesq(DataForKthDescriptor, 1, &__C, v6);
      float __B = 1.0 / sqrtf(__C);
      vDSP_vsmul(DataForKthDescriptor, 1, &__B, DataForKthDescriptor, 1, v6);
      ++v5;
    }
    while (v4 != v5);
  }
  uint64_t result = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferFloat32 *))(*(void *)a2 + 24))(a2);
  *(void *)this = result;
  return result;
}

double *std::__introsort<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *,false>(double *result, unint64_t a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = (unint64_t)v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = (double *)v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = (uint64_t)(a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                double v44 = *(double *)(a2 - 8);
                double v45 = *(double *)(v10 + 8);
                if (v44 > v45)
                {
                  int v46 = *(_DWORD *)v10;
                  *(_DWORD *)unint64_t v10 = *(_DWORD *)(a2 - 16);
                  *(_DWORD *)(a2 - 16) = v46;
                  *(double *)(v10 + 8) = v44;
                  *(double *)(a2 - 8) = v45;
                }
                break;
              case 3uLL:
                uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)v10, (double *)(v10 + 16), (double *)(a2 - 16));
                break;
              case 4uLL:
                uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)v10, (double *)(v10 + 16), (double *)(v10 + 32), a2 - 16);
                break;
              case 5uLL:
                uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)v10, (double *)(v10 + 16), (double *)(v10 + 32), v10 + 48);
                double v47 = *(double *)(a2 - 8);
                double v48 = *(double *)(v10 + 56);
                if (v47 > v48)
                {
                  int v49 = *(_DWORD *)(v10 + 48);
                  *(_DWORD *)(v10 + 48) = *(_DWORD *)(a2 - 16);
                  *(_DWORD *)(a2 - 16) = v49;
                  *(double *)(v10 + 56) = v47;
                  *(double *)(a2 - 8) = v48;
                  double v50 = *(double *)(v10 + 56);
                  double v51 = *(double *)(v10 + 40);
                  if (v50 > v51)
                  {
                    int v52 = *(_DWORD *)(v10 + 32);
                    int v53 = *(_DWORD *)(v10 + 48);
                    *(_DWORD *)(v10 + 32) = v53;
                    *(_DWORD *)(v10 + 48) = v52;
                    *(double *)(v10 + 40) = v50;
                    *(double *)(v10 + 56) = v51;
                    double v54 = *(double *)(v10 + 24);
                    if (v50 > v54)
                    {
                      int v55 = *(_DWORD *)(v10 + 16);
                      *(_DWORD *)(v10 + 16) = v53;
                      *(_DWORD *)(v10 + 32) = v55;
                      *(double *)(v10 + 24) = v50;
                      *(double *)(v10 + 40) = v54;
                      double v56 = *(double *)(v10 + 8);
                      if (v50 > v56)
                      {
                        int v57 = *(_DWORD *)v10;
                        *(_DWORD *)unint64_t v10 = v53;
                        *(_DWORD *)(v10 + 16) = v57;
                        *(double *)(v10 + 8) = v50;
                        *(double *)(v10 + 24) = v56;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 383)
          {
            float v58 = (double *)(v10 + 16);
            BOOL v60 = v10 == a2 || v58 == (double *)a2;
            if (a4)
            {
              if (!v60)
              {
                uint64_t v61 = 0;
                double v62 = (double *)v10;
                do
                {
                  double v63 = v62[3];
                  double v64 = v62[1];
                  double v62 = v58;
                  if (v63 > v64)
                  {
                    int v65 = *(_DWORD *)v58;
                    uint64_t v66 = v61;
                    while (1)
                    {
                      uint64_t v67 = v10 + v66;
                      *(_DWORD *)(v67 + 16) = *(_DWORD *)(v10 + v66);
                      *(void *)(v67 + 24) = *(void *)(v10 + v66 + 8);
                      if (!v66) {
                        break;
                      }
                      v66 -= 16;
                      if (v63 <= *(double *)(v67 - 8))
                      {
                        uint64_t v68 = v10 + v66 + 16;
                        goto LABEL_85;
                      }
                    }
                    uint64_t v68 = v10;
LABEL_85:
                    *(_DWORD *)uint64_t v68 = v65;
                    *(double *)(v68 + 8) = v63;
                  }
                  float v58 = v62 + 2;
                  v61 += 16;
                }
                while (v62 + 2 != (double *)a2);
              }
            }
            else if (!v60)
            {
              unint64_t v97 = v10 + 8;
              do
              {
                double v98 = v9[3];
                double v99 = v9[1];
                uint64_t v9 = v58;
                if (v98 > v99)
                {
                  int v100 = *(_DWORD *)v58;
                  unint64_t v101 = v97;
                  do
                  {
                    *(_DWORD *)(v101 + 8) = *(_DWORD *)(v101 - 8);
                    *(void *)(v101 + 16) = *(void *)v101;
                    double v102 = *(double *)(v101 - 16);
                    v101 -= 16;
                  }
                  while (v98 > v102);
                  *(_DWORD *)(v101 + 8) = v100;
                  *(double *)(v101 + 16) = v98;
                }
                float v58 = v9 + 2;
                v97 += 16;
              }
              while (v9 + 2 != (double *)a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v69 = (v12 - 2) >> 1;
              int64_t v70 = v69;
              do
              {
                int64_t v71 = v70;
                if (v69 >= v70)
                {
                  uint64_t v72 = (2 * v70) | 1;
                  unint64_t v73 = v10 + 16 * v72;
                  if (2 * v71 + 2 < (uint64_t)v12 && *(double *)(v73 + 8) > *(double *)(v73 + 24))
                  {
                    v73 += 16;
                    uint64_t v72 = 2 * v71 + 2;
                  }
                  double v74 = *(double *)(v73 + 8);
                  double v75 = *(double *)(v10 + 16 * v71 + 8);
                  if (v74 <= v75)
                  {
                    unint64_t v76 = v10 + 16 * v71;
                    int v77 = *(_DWORD *)v76;
                    do
                    {
                      unint64_t v78 = v76;
                      unint64_t v76 = v73;
                      *(_DWORD *)unint64_t v78 = *(_DWORD *)v73;
                      *(double *)(v78 + 8) = v74;
                      if (v69 < v72) {
                        break;
                      }
                      uint64_t v79 = 2 * v72;
                      uint64_t v72 = (2 * v72) | 1;
                      unint64_t v73 = v10 + 16 * v72;
                      uint64_t v80 = v79 + 2;
                      if (v80 < (uint64_t)v12 && *(double *)(v73 + 8) > *(double *)(v73 + 24))
                      {
                        v73 += 16;
                        uint64_t v72 = v80;
                      }
                      double v74 = *(double *)(v73 + 8);
                    }
                    while (v74 <= v75);
                    *(_DWORD *)unint64_t v76 = v77;
                    *(double *)(v76 + 8) = v75;
                  }
                }
                int64_t v70 = v71 - 1;
              }
              while (v71);
              uint64_t v81 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v82 = 0;
                int v83 = *(_DWORD *)v10;
                uint64_t v84 = *(void *)(v10 + 8);
                unint64_t v85 = v10;
                do
                {
                  unint64_t v86 = v85;
                  v85 += 16 * (v82 + 1);
                  uint64_t v87 = 2 * v82;
                  uint64_t v82 = (2 * v82) | 1;
                  uint64_t v88 = v87 + 2;
                  if (v88 < v81 && *(double *)(v85 + 8) > *(double *)(v85 + 24))
                  {
                    v85 += 16;
                    uint64_t v82 = v88;
                  }
                  *(_DWORD *)unint64_t v86 = *(_DWORD *)v85;
                  *(void *)(v86 + 8) = *(void *)(v85 + 8);
                }
                while (v82 <= (uint64_t)((unint64_t)(v81 - 2) >> 1));
                if (v85 == a2 - 16)
                {
                  *(_DWORD *)unint64_t v85 = v83;
                  *(void *)(v85 + 8) = v84;
                }
                else
                {
                  *(_DWORD *)unint64_t v85 = *(_DWORD *)(a2 - 16);
                  *(void *)(v85 + 8) = *(void *)(a2 - 8);
                  *(_DWORD *)(a2 - 16) = v83;
                  *(void *)(a2 - 8) = v84;
                  uint64_t v89 = v85 - v10 + 16;
                  if (v89 >= 17)
                  {
                    unint64_t v90 = (((unint64_t)v89 >> 4) - 2) >> 1;
                    double v91 = *(double *)(v10 + 16 * v90 + 8);
                    double v92 = *(double *)(v85 + 8);
                    if (v91 > v92)
                    {
                      int v93 = *(_DWORD *)v85;
                      do
                      {
                        unint64_t v94 = v90;
                        unint64_t v95 = v85;
                        unint64_t v85 = v10 + 16 * v94;
                        *(_DWORD *)unint64_t v95 = *(_DWORD *)v85;
                        *(double *)(v95 + 8) = v91;
                        if (!v94) {
                          break;
                        }
                        unint64_t v90 = (v94 - 1) >> 1;
                        double v91 = *(double *)(v10 + 16 * v90 + 8);
                      }
                      while (v91 > v92);
                      *(_DWORD *)unint64_t v85 = v93;
                      *(double *)(v10 + 16 * v94 + 8) = v92;
                    }
                  }
                }
                a2 -= 16;
              }
              while (v81-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (double *)(v10 + 16 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v9, &v9[2 * (v12 >> 1)], (double *)(a2 - 16));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v9 + 2, v14 - 2, (double *)(a2 - 32));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v9 + 4, &v9[2 * v13 + 2], (double *)(a2 - 48));
            uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v14 - 2, v14, &v9[2 * v13 + 2]);
            int v15 = *(_DWORD *)v9;
            *(_DWORD *)uint64_t v9 = *(_DWORD *)v14;
            *(_DWORD *)uint64_t v14 = v15;
            uint64_t v16 = *((void *)v9 + 1);
            v9[1] = v14[1];
            *((void *)v14 + 1) = v16;
          }
          else
          {
            uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(&v9[2 * (v12 >> 1)], v9, (double *)(a2 - 16));
          }
          --a3;
          if (a4) {
            break;
          }
          double v17 = v9[1];
          if (*(v9 - 1) > v17) {
            goto LABEL_13;
          }
          if (v17 <= *(double *)(a2 - 8))
          {
            unint64_t v34 = v9 + 2;
            do
            {
              unint64_t v10 = (unint64_t)v34;
              if ((unint64_t)v34 >= a2) {
                break;
              }
              double v35 = v34[1];
              v34 += 2;
            }
            while (v17 <= v35);
          }
          else
          {
            uint64_t v32 = v9;
            do
            {
              unint64_t v10 = (unint64_t)(v32 + 2);
              double v33 = v32[3];
              v32 += 2;
            }
            while (v17 <= v33);
          }
          unint64_t v36 = a2;
          if (v10 < a2)
          {
            unint64_t v37 = a2;
            do
            {
              unint64_t v36 = v37 - 16;
              double v38 = *(double *)(v37 - 8);
              v37 -= 16;
            }
            while (v17 > v38);
          }
          int v39 = *(_DWORD *)v9;
          while (v10 < v36)
          {
            int v40 = *(_DWORD *)v10;
            *(_DWORD *)unint64_t v10 = *(_DWORD *)v36;
            *(_DWORD *)unint64_t v36 = v40;
            uint64_t v41 = *(void *)(v10 + 8);
            *(void *)(v10 + 8) = *(void *)(v36 + 8);
            *(void *)(v36 + 8) = v41;
            do
            {
              double v42 = *(double *)(v10 + 24);
              v10 += 16;
            }
            while (v17 <= v42);
            do
            {
              double v43 = *(double *)(v36 - 8);
              v36 -= 16;
            }
            while (v17 > v43);
          }
          BOOL v4 = v10 - 16 >= (unint64_t)v9;
          BOOL v5 = v10 - 16 == (void)v9;
          if ((double *)(v10 - 16) != v9)
          {
            *(_DWORD *)uint64_t v9 = *(_DWORD *)(v10 - 16);
            v9[1] = *(double *)(v10 - 8);
          }
          a4 = 0;
          *(_DWORD *)(v10 - 16) = v39;
          *(double *)(v10 - 8) = v17;
        }
        double v17 = v9[1];
LABEL_13:
        int v18 = *(_DWORD *)v9;
        float v19 = v9;
        do
        {
          int v20 = v19;
          v19 += 2;
        }
        while (v20[3] > v17);
        unint64_t v21 = a2;
        if (v20 == v9)
        {
          unint64_t v24 = a2;
          while ((unint64_t)v19 < v24)
          {
            unint64_t v22 = v24 - 16;
            double v25 = *(double *)(v24 - 8);
            v24 -= 16;
            if (v25 > v17) {
              goto LABEL_23;
            }
          }
          unint64_t v22 = v24;
        }
        else
        {
          do
          {
            unint64_t v22 = v21 - 16;
            double v23 = *(double *)(v21 - 8);
            v21 -= 16;
          }
          while (v23 <= v17);
        }
LABEL_23:
        unint64_t v10 = (unint64_t)v19;
        if ((unint64_t)v19 < v22)
        {
          unint64_t v26 = v22;
          do
          {
            int v27 = *(_DWORD *)v10;
            *(_DWORD *)unint64_t v10 = *(_DWORD *)v26;
            *(_DWORD *)unint64_t v26 = v27;
            uint64_t v28 = *(void *)(v10 + 8);
            *(void *)(v10 + 8) = *(void *)(v26 + 8);
            *(void *)(v26 + 8) = v28;
            do
            {
              double v29 = *(double *)(v10 + 24);
              v10 += 16;
            }
            while (v29 > v17);
            do
            {
              double v30 = *(double *)(v26 - 8);
              v26 -= 16;
            }
            while (v30 <= v17);
          }
          while (v10 < v26);
        }
        if ((double *)(v10 - 16) != v9)
        {
          *(_DWORD *)uint64_t v9 = *(_DWORD *)(v10 - 16);
          v9[1] = *(double *)(v10 - 8);
        }
        *(_DWORD *)(v10 - 16) = v18;
        *(double *)(v10 - 8) = v17;
        if ((unint64_t)v19 >= v22) {
          break;
        }
LABEL_34:
        uint64_t result = (double *)std::__introsort<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *,false>(v9, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v31 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((uint64_t)v9, v10 - 16);
      uint64_t result = (double *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v10, a2);
      if (result) {
        break;
      }
      if (!v31) {
        goto LABEL_34;
      }
    }
    a2 = v10 - 16;
    if (!v31) {
      continue;
    }
    return result;
  }
}

double *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(double *result, double *a2, double *a3)
{
  double v3 = a2[1];
  double v4 = result[1];
  double v5 = a3[1];
  if (v3 <= v4)
  {
    if (v5 > v3)
    {
      int v7 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v7;
      a2[1] = v5;
      a3[1] = v3;
      double v8 = a2[1];
      double v9 = result[1];
      if (v8 > v9)
      {
        int v10 = *(_DWORD *)result;
        *(_DWORD *)uint64_t result = *(_DWORD *)a2;
        *(_DWORD *)a2 = v10;
        result[1] = v8;
        a2[1] = v9;
      }
    }
  }
  else
  {
    int v6 = *(_DWORD *)result;
    if (v5 <= v3)
    {
      *(_DWORD *)uint64_t result = *(_DWORD *)a2;
      *(_DWORD *)a2 = v6;
      result[1] = v3;
      a2[1] = v4;
      double v11 = a3[1];
      if (v11 <= v4) {
        return result;
      }
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v6;
      a2[1] = v11;
    }
    else
    {
      *(_DWORD *)uint64_t result = *(_DWORD *)a3;
      *(_DWORD *)a3 = v6;
      result[1] = v5;
    }
    a3[1] = v4;
  }
  return result;
}

double *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(double *a1, double *a2, double *a3, uint64_t a4)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(a1, a2, a3);
  double v9 = *(double *)(a4 + 8);
  double v10 = a3[1];
  if (v9 > v10)
  {
    int v11 = *(_DWORD *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_DWORD *)a4 = v11;
    a3[1] = v9;
    *(double *)(a4 + 8) = v10;
    double v12 = a3[1];
    double v13 = a2[1];
    if (v12 > v13)
    {
      int v14 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v14;
      a2[1] = v12;
      a3[1] = v13;
      double v15 = a2[1];
      double v16 = a1[1];
      if (v15 > v16)
      {
        int v17 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v17;
        a1[1] = v15;
        a2[1] = v16;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      double v6 = *(double *)(a2 - 8);
      double v7 = *(double *)(a1 + 8);
      if (v6 > v7)
      {
        int v8 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v8;
        *(double *)(a1 + 8) = v6;
        *(double *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)a1, (double *)(a1 + 16), (double *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)a1, (double *)(a1 + 16), (double *)(a1 + 32), a2 - 16);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)a1, (double *)(a1 + 16), (double *)(a1 + 32), a1 + 48);
      double v18 = *(double *)(a2 - 8);
      double v19 = *(double *)(a1 + 56);
      if (v18 > v19)
      {
        int v20 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v20;
        *(double *)(a1 + 56) = v18;
        *(double *)(a2 - 8) = v19;
        double v21 = *(double *)(a1 + 56);
        double v22 = *(double *)(a1 + 40);
        if (v21 > v22)
        {
          int v23 = *(_DWORD *)(a1 + 32);
          int v24 = *(_DWORD *)(a1 + 48);
          *(_DWORD *)(a1 + 32) = v24;
          *(_DWORD *)(a1 + 48) = v23;
          *(double *)(a1 + 40) = v21;
          *(double *)(a1 + 56) = v22;
          double v25 = *(double *)(a1 + 24);
          if (v21 > v25)
          {
            int v26 = *(_DWORD *)(a1 + 16);
            *(_DWORD *)(a1 + 16) = v24;
            *(_DWORD *)(a1 + 32) = v26;
            *(double *)(a1 + 24) = v21;
            *(double *)(a1 + 40) = v25;
            double v27 = *(double *)(a1 + 8);
            if (v21 > v27)
            {
              int v28 = *(_DWORD *)a1;
              *(_DWORD *)a1 = v24;
              *(_DWORD *)(a1 + 16) = v28;
              *(double *)(a1 + 8) = v21;
              *(double *)(a1 + 24) = v27;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v9 = a1 + 32;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)a1, (double *)(a1 + 16), (double *)(a1 + 32));
      uint64_t v10 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    double v13 = *(double *)(v10 + 8);
    if (v13 > *(double *)(v9 + 8))
    {
      int v14 = *(_DWORD *)v10;
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        *(_DWORD *)(v16 + 48) = *(_DWORD *)(a1 + v15 + 32);
        *(void *)(v16 + 56) = *(void *)(a1 + v15 + 40);
        if (v15 == -32) {
          break;
        }
        v15 -= 16;
        if (v13 <= *(double *)(v16 + 24))
        {
          uint64_t v17 = a1 + v15 + 48;
          goto LABEL_13;
        }
      }
      uint64_t v17 = a1;
LABEL_13:
      *(_DWORD *)uint64_t v17 = v14;
      *(double *)(v17 + 8) = v13;
      if (++v12 == 8) {
        return v10 + 16 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2) {
      return 1;
    }
  }
}

uint64_t vision::mod::FaceID3Model::serialize(void *a1)
{
  *(void *)&__n[140] = *MEMORY[0x1E4F143B8];
  strcpy(&__n[4], "FaceID3Model_v1_d16");
  uint64_t v2 = (void *)std::ostream::write();
  if ((*((unsigned char *)v2 + *(void *)(*v2 - 24) + 32) & 5) != 0
    || (double v3 = (void *)std::ostream::write(), (*((unsigned char *)v3 + *(void *)(*v3 - 24) + 32) & 5) != 0)
    || (uint64_t v4 = (void *)std::ostream::write(), (*((unsigned char *)v4 + *(void *)(*v4 - 24) + 32) & 5) != 0)
    || (double v5 = (void *)std::ostream::write(), (*((unsigned char *)v5 + *(void *)(*v5 - 24) + 32) & 5) != 0)
    || (double v6 = (void *)std::ostream::write(), (*((unsigned char *)v6 + *(void *)(*v6 - 24) + 32) & 5) != 0)
    || (double v7 = (void *)std::ostream::write(), (*((unsigned char *)v7 + *(void *)(*v7 - 24) + 32) & 5) != 0)
    || vision::mod::FaceID3KmeansParams::serialize() != 11136)
  {
    uint64_t v12 = -11;
    return (v12 + 128) | 0x2B00;
  }
  *(_DWORD *)__unint64_t n = a1[15];
  std::vector<long long>::vector(&__p, *(int *)__n);
  std::vector<int>::vector(&v23, *(int *)__n);
  int v8 = (uint64_t *)a1[14];
  if (v8)
  {
    uint64_t v9 = __p;
    begiunint64_t n = v23.__begin_;
    do
    {
      *v9++ = v8[2];
      *begin++ = *((_DWORD *)v8 + 6);
      int v8 = (uint64_t *)*v8;
    }
    while (v8);
  }
  uint64_t v11 = (void *)std::ostream::write();
  if ((*((unsigned char *)v11 + *(void *)(*v11 - 24) + 32) & 5) == 0)
  {
    if (!*(_DWORD *)__n)
    {
      uint64_t v12 = 0;
      goto LABEL_13;
    }
    int v14 = (void *)std::ostream::write();
    if ((*((unsigned char *)v14 + *(void *)(*v14 - 24) + 32) & 5) == 0)
    {
      uint64_t v15 = (void *)std::ostream::write();
      if ((*((unsigned char *)v15 + *(void *)(*v15 - 24) + 32) & 5) == 0)
      {
        double v25 = __p;
        v23.__end_ = v23.__begin_;
        uint64_t v16 = a1[6];
        if (*(void *)(v16 + 72) == *(int *)__n)
        {
          v22[3] = *(void **)(v16 + 96);
          memset(v22, 0, 24);
          std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v22, *(const void **)(v16 + 8), *(void *)(v16 + 16), (uint64_t)(*(void *)(v16 + 16) - *(void *)(v16 + 8)) >> 3);
          uint64_t v17 = (void *)std::ostream::write();
          double v18 = v22[0];
          if ((*((unsigned char *)v17 + *(void *)(*v17 - 24) + 32) & 5) != 0)
          {
            double v19 = &CVML_status_IOError;
          }
          else
          {
            int v20 = (void *)std::ostream::write();
            double v19 = &CVML_status_IOError;
            if ((*((unsigned char *)v20 + *(void *)(*v20 - 24) + 32) & 5) == 0)
            {
              double v21 = (void *)std::ostream::write();
              if ((*((unsigned char *)v21 + *(void *)(*v21 - 24) + 32) & 5) == 0) {
                double v19 = &CVML_status_ok;
              }
            }
          }
          uint64_t v12 = *v19;
          if (v18) {
            operator delete(v18);
          }
          goto LABEL_13;
        }
        syslog(5, "ERROR: number of elements dismatch between dictIds_ and dictData_");
      }
    }
  }
  uint64_t v12 = -11;
LABEL_13:
  if (v23.__begin_)
  {
    v23.__end_ = v23.__begin_;
    operator delete(v23.__begin_);
  }
  if (__p)
  {
    double v25 = __p;
    operator delete(__p);
  }
  return (v12 + 128) | 0x2B00;
}

void sub_1A3FB2D20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void vision::mod::FaceID3Model::deserialize(void *a1, uint64_t a2, void *a3)
{
  *a3 = 11136;
  double v5 = (void *)std::istream::read();
  if ((*((unsigned char *)v5 + *(void *)(*v5 - 24) + 32) & 5) == 0)
  {
    if (v13 == 0x4D33444965636146
      && *(void *)v14 == 0x5F31765F6C65646FLL
      && *(void *)&v14[3] == 0x3631645F31765F6CLL)
    {
      int v8 = (void *)std::istream::read();
      if ((*((unsigned char *)v8 + *(void *)(*v8 - 24) + 32) & 5) == 0)
      {
        uint64_t v9 = (void *)std::istream::read();
        if ((*((unsigned char *)v9 + *(void *)(*v9 - 24) + 32) & 5) == 0)
        {
          uint64_t v10 = (void *)std::istream::read();
          if ((*((unsigned char *)v10 + *(void *)(*v10 - 24) + 32) & 5) == 0)
          {
            uint64_t v11 = (void *)std::istream::read();
            if ((*((unsigned char *)v11 + *(void *)(*v11 - 24) + 32) & 5) == 0)
            {
              uint64_t v12 = (void *)std::istream::read();
              if ((*((unsigned char *)v12 + *(void *)(*v12 - 24) + 32) & 5) == 0
                && vision::mod::FaceID3KmeansParams::deserialize() == 11136)
              {
                std::make_unique[abi:ne180100]<vision::mod::FaceID3Model,int &,int &,int &,vision::mod::FaceIDIndexMode &,float &>();
              }
            }
          }
        }
      }
    }
    else
    {
      syslog(5, "ERROR: incorrect header");
    }
  }
  *a3 = 11125;
  *a1 = 0;
}

void sub_1A3FB33A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,vision::mod::FaceID3Model *a37)
{
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a30)
  {
    a31 = (uint64_t)a30;
    operator delete(a30);
  }
  if (a33)
  {
    a34 = (uint64_t)a33;
    operator delete(a33);
  }
  std::unique_ptr<vision::mod::FaceID3Model>::reset[abi:ne180100](&a37);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<vision::mod::FaceID3Model,int &,int &,int &,vision::mod::FaceIDIndexMode &,float &>()
{
}

void std::vector<long long>::push_back[abi:ne180100](uint64_t a1, void *a2)
{
  double v5 = *(void **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    double v7 = *(void **)a1;
    uint64_t v8 = ((uint64_t)v5 - *(void *)a1) >> 3;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    BOOL v11 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v9;
    }
    if (v12)
    {
      unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v12);
      double v7 = *(void **)a1;
      double v5 = *(void **)(a1 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    int v14 = (void *)(v12 + 8 * v8);
    unint64_t v15 = v12 + 8 * v13;
    *int v14 = *a2;
    double v6 = v14 + 1;
    while (v5 != v7)
    {
      uint64_t v16 = *--v5;
      *--int v14 = v16;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v6;
    *(void *)(a1 + 16) = v15;
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    *double v5 = *a2;
    double v6 = v5 + 1;
  }
  *(void *)(a1 + 8) = v6;
}

void sub_1A3FB36A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB372C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB3798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNPixelBufferMLFeatureProvider;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3FB3880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB39F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB3AA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB3B90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB3DF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB3F00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB3FF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB408C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB4380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB4498(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB4648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB47AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB4878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB5014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB62E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33,void *a34,void *a35,void *a36,void *a37,void *a38,void *a39)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB6834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB6BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB6C6C()
{
}

void sub_1A3FB6DD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB6EA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB6FAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB7058(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB74E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__23083(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__23084(uint64_t a1)
{
}

void sub_1A3FB79CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FB7BAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _createValueConfidenceCurveForValidPairData(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v12 = 0;
  memset(v11, 0, sizeof(v11));
  int v10 = 0;
  memset(v9, 0, sizeof(v9));
  do
  {
    float v6 = *(float *)(a1 + v4 + 4);
    if (v6 >= 0.0)
    {
      *((_DWORD *)v11 + v5) = *(_DWORD *)(a1 + v4);
      *((float *)v9 + v5++) = v6;
    }
    v4 += 8;
  }
  while (v4 != 72);
  if (!v5)
  {
    uint64_t result = 0;
    goto LABEL_9;
  }
  uint64_t result = [MEMORY[0x1E4FB3F58] curveWithValues:v11 confidences:v9 count:v5 error:a3];
  if (result)
  {
LABEL_9:
    id v8 = (id) result;
    *a2 = v8;

    return 1;
  }
  return result;
}

uint64_t _getValueForConfidence(void *a1, float *a2, int a3, float *a4, void *a5, float a6)
{
  id v11 = a1;
  BOOL v12 = _validateValueConfidencePair(a2, v11, a5);
  if (!a3)
  {
    if (v12)
    {
      if (a2[1] > a6)
      {
        uint64_t v13 = a2 + 2;
        uint64_t v16 = 1;
        while (_validateValueConfidencePair(v13, v11, a5))
        {
          float v17 = v13[1];
          if (v17 < a6)
          {
            double v25 = &a2[2 * v16];
            double v21 = v25 - 2;
            float v26 = *(v25 - 1) - v17;
            if (v26 == 0.0) {
              float v27 = 0.5;
            }
            else {
              float v27 = (float)(a6 - v17) / v26;
            }
LABEL_28:
            float v18 = *v21 + (float)(v27 * (float)(*v13 - *v21));
            goto LABEL_29;
          }
          if (v17 == a6)
          {
LABEL_20:
            float v18 = *v13;
            goto LABEL_29;
          }
          ++v16;
          v13 += 2;
          if (v16 == 9)
          {
LABEL_17:
            float v18 = a2[16];
            goto LABEL_29;
          }
        }
        goto LABEL_18;
      }
      goto LABEL_19;
    }
LABEL_18:
    uint64_t v19 = 0;
    goto LABEL_30;
  }
  if (!v12) {
    goto LABEL_18;
  }
  if (a2[1] < a6)
  {
    uint64_t v13 = a2 + 2;
    uint64_t v14 = 1;
    while (_validateValueConfidencePair(v13, v11, a5))
    {
      float v15 = v13[1];
      if (v15 > a6)
      {
        int v20 = &a2[2 * v14];
        double v21 = v20 - 2;
        float v22 = *(v20 - 1);
        float v23 = v15 - v22;
        if (v23 == 0.0) {
          float v24 = 0.5;
        }
        else {
          float v24 = (float)(a6 - v22) / v23;
        }
        float v27 = 1.0 - v24;
        goto LABEL_28;
      }
      if (v15 == a6) {
        goto LABEL_20;
      }
      ++v14;
      v13 += 2;
      if (v14 == 9) {
        goto LABEL_17;
      }
    }
    goto LABEL_18;
  }
LABEL_19:
  float v18 = *a2;
LABEL_29:
  *a4 = v18;
  uint64_t v19 = 1;
LABEL_30:

  return v19;
}

BOOL _validateValueConfidencePair(float *a1, void *a2, void *a3)
{
  float v3 = a1[1];
  if (a3 && v3 < 0.0)
  {
    uint64_t v5 = NSString;
    float v6 = NSNumber;
    float v7 = *a1;
    id v8 = a2;
    *(float *)&double v9 = v7;
    int v10 = [v6 numberWithFloat:v9];
    id v11 = [v5 stringWithFormat:@"no %@ is defined at %@", v8, v10];

    *a3 = +[VNError errorForOutOfBoundsErrorWithLocalizedDescription:v11];
  }
  return v3 >= 0.0;
}

uint64_t _getConfidenceForValue(void *a1, float *a2, int a3, float *a4, void *a5, float a6)
{
  id v11 = a1;
  if (!_validateValueConfidencePair(a2, v11, a5))
  {
LABEL_9:
    uint64_t v15 = 0;
    goto LABEL_22;
  }
  if (*a2 < a6)
  {
    BOOL v12 = a2 + 2;
    uint64_t v13 = 1;
    while (_validateValueConfidencePair(v12, v11, a5))
    {
      if (*v12 > a6)
      {
        uint64_t v16 = &a2[2 * v13];
        float v18 = *(v16 - 2);
        float v17 = v16 - 2;
        float v19 = v18;
        float v20 = *v12 - v18;
        if (v20 == 0.0) {
          float v21 = 0.5;
        }
        else {
          float v21 = (float)(a6 - v19) / v20;
        }
        if (a3)
        {
          float v22 = v17;
        }
        else
        {
          float v21 = 1.0 - v21;
          float v22 = v12;
        }
        if (a3) {
          float v17 = v12;
        }
        float v14 = v22[1] + (float)(v21 * (float)(v17[1] - v22[1]));
        goto LABEL_21;
      }
      if (*v12 == a6)
      {
        float v14 = a2[2 * v13 + 1];
        goto LABEL_21;
      }
      ++v13;
      v12 += 2;
      if (v13 == 9)
      {
        float v14 = a2[17];
        goto LABEL_21;
      }
    }
    goto LABEL_9;
  }
  float v14 = a2[1];
LABEL_21:
  *a4 = v14;
  uint64_t v15 = 1;
LABEL_22:

  return v15;
}

void sub_1A3FB92B0(_Unwind_Exception *a1)
{
}

void sub_1A3FB92D0(void *a1)
{
}

void sub_1A3FB97A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    free(a13);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

uint64_t _parseValueConfidenceArrayWithIncreasingConfidences(void *a1, uint64_t a2, int a3)
{
  id v5 = a1;
  if ([v5 count] == 18)
  {
    uint64_t v6 = 0;
    float v7 = 1.0;
    float v8 = 0.0;
    if (a3) {
      float v7 = 0.0;
    }
    while (1)
    {
      float v9 = v7;
      int v10 = (float *)(a2 + 4 * v6);
      id v11 = [v5 objectAtIndex:v6];
      [v11 floatValue];
      *(_DWORD *)int v10 = v12;

      if (*v10 < v8) {
        break;
      }
      uint64_t v14 = v6 + 1;
      *(float *)&double v13 = *v10;
      uint64_t v15 = objc_msgSend(v5, "objectAtIndex:", v14, v13);
      [v15 floatValue];
      *((_DWORD *)v10 + 1) = v16;

      float v7 = v10[1];
      if (v7 >= 0.0)
      {
        if (a3)
        {
          if (v7 < v9) {
            break;
          }
        }
        else if (v7 > v9)
        {
          break;
        }
      }
      float v8 = *v10;
      unint64_t v17 = v14 - 1;
      uint64_t v6 = v14 + 1;
      if (v17 >= 0x10)
      {
        uint64_t v18 = 1;
        goto LABEL_13;
      }
    }
  }
  uint64_t v18 = 0;
LABEL_13:

  return v18;
}

void polynomialFit(const double *a1, double *a2, double *a3, int a4, const double *a5, const double *a6, const double *a7)
{
  std::vector<double>::vector(&__p, 4uLL);
  int v10 = (double *)__p;
  double v11 = *a2;
  int v12 = (double *)malloc_type_calloc(9uLL, 8uLL, 0x100004000313F17uLL);
  double v13 = malloc_type_malloc(0x30uLL, 0x100004000313F17uLL);
  uint64_t v14 = (double *)malloc_type_malloc(0x18uLL, 0x100004000313F17uLL);
  uint64_t v15 = (double *)malloc_type_calloc(3uLL, 8uLL, 0x100004000313F17uLL);
  int v16 = (double *)malloc_type_calloc(3uLL, 8uLL, 0x100004000313F17uLL);
  unint64_t v17 = malloc_type_calloc(3 * a4, 8uLL, 0x100004000313F17uLL);
  uint64_t v18 = v17;
  uint64_t v19 = 8 * a4;
  if (a4 >= 1)
  {
    uint64_t v20 = 0;
    float v21 = (double *)v17;
    do
    {
      *((void *)v17 + v20) = 0x3FF0000000000000;
      float v22 = v21;
      uint64_t v23 = 2;
      do
      {
        double v24 = (a2[v20] - v11) * *v22;
        float v22 = (double *)((char *)v22 + v19);
        *float v22 = v24;
        --v23;
      }
      while (v23);
      ++v20;
      ++v21;
    }
    while (v20 != a4);
  }
  uint64_t v25 = 0;
  if (a4 <= 1) {
    uint64_t v26 = 1;
  }
  else {
    uint64_t v26 = a4;
  }
  float v27 = (double *)v17;
  do
  {
    if (a4 <= 0)
    {
      double v28 = v16[v25];
    }
    else
    {
      double v28 = v16[v25];
      double v29 = v27;
      uint64_t v30 = v26;
      do
      {
        double v31 = *v29++;
        double v28 = v28 + v31 * v31;
        v16[v25] = v28;
        --v30;
      }
      while (v30);
    }
    v16[v25++] = sqrt(v28);
    float v27 = (double *)((char *)v27 + v19);
  }
  while (v25 != 3);
  uint64_t v32 = 0;
  double v33 = (double *)v17;
  do
  {
    uint64_t v34 = 0;
    double v35 = (double *)v17;
    do
    {
      double v36 = 0.0;
      if (a4 >= 1)
      {
        unint64_t v37 = v35;
        double v38 = v33;
        uint64_t v39 = v26;
        do
        {
          double v40 = *v37++;
          double v41 = v40;
          double v42 = *v38++;
          double v36 = v36 + v41 * v42;
          --v39;
        }
        while (v39);
      }
      v12[3 * v32 + v34] = v36 / (v16[v34] * v16[v32]);
      ++v34;
      double v35 = (double *)((char *)v35 + v19);
    }
    while (v34 != 3);
    ++v32;
    double v33 = (double *)((char *)v33 + v19);
  }
  while (v32 != 3);
  uint64_t v43 = 0;
  double v44 = (double *)v17;
  do
  {
    if (a4 <= 0)
    {
      double v45 = v15[v43];
    }
    else
    {
      double v45 = v15[v43];
      int v46 = v44;
      double v47 = a3;
      uint64_t v48 = a4;
      do
      {
        double v49 = *v46++;
        double v50 = v49;
        double v51 = *v47++;
        double v45 = v50 * v51 + v45;
        v15[v43] = v45;
        --v48;
      }
      while (v48);
    }
    v15[v43] = v45 / v16[v43];
    ++v43;
    double v44 = (double *)((char *)v44 + v19);
  }
  while (v43 != 3);
  unint64_t v52 = 0;
  int v53 = (char *)(v13 + 1);
  uint64_t v54 = 1;
  uint64_t v55 = 8;
  uint64_t v56 = 16;
  int v57 = v13;
  float v58 = (double *)v13;
  double v59 = v12;
  do
  {
    double v60 = *v59;
    double *v58 = *v59;
    if (v52)
    {
      for (uint64_t i = 0; i != v52; ++i)
      {
        double v60 = v60 - *(double *)&v57[i] * *(double *)&v57[i];
        double *v58 = v60;
      }
    }
    if (v60 < *v59 * 0.000000001) {
      double v60 = *v59 * 0.000000001;
    }
    double *v58 = sqrt(v60);
    if (v52 <= 1)
    {
      double v62 = &v58[v52 + 1];
      double v63 = v53;
      uint64_t v64 = v56;
      uint64_t v65 = v54;
      do
      {
        double v66 = v59[1];
        ++v59;
        double v67 = v66;
        *double v62 = v66;
        if (v52)
        {
          for (uint64_t j = 0; j != v52; ++j)
          {
            double v67 = v67 - *(double *)&v63[8 * j] * *(double *)&v57[j];
            *double v62 = v67;
          }
        }
        *double v62 = v67 / *v58;
        v62 += ++v65;
        v63 += v64;
        v64 += 8;
      }
      while (v65 != 3);
    }
    v58 += v52 + 2;
    v59 += v52 + 2;
    ++v54;
    int v57 = (void *)((char *)v57 + v55);
    v55 += 8;
    v53 += v56;
    v56 += 8;
    ++v52;
  }
  while (v52 != 3);
  int64_t v69 = (double *)malloc_type_calloc(3uLL, 8uLL, 0x100004000313F17uLL);
  unint64_t v70 = 0;
  int64_t v71 = (double *)v13;
  do
  {
    double v72 = v15[v70];
    v69[v70] = v72;
    if (v70)
    {
      unint64_t v73 = v69;
      unint64_t v74 = v70;
      double v75 = v71;
      do
      {
        double v76 = *v75++;
        double v77 = v76;
        double v78 = *v73++;
        double v72 = v72 - v77 * v78;
        v69[v70] = v72;
        --v74;
      }
      while (v74);
    }
    else
    {
      double v75 = v71;
    }
    int64_t v71 = v75 + 1;
    v69[v70++] = v72 / *v75;
  }
  while (v70 != 3);
  do
  {
    unint64_t v79 = v70 - 1;
    double v80 = v69[v70 - 1];
    v14[v70 - 1] = v80;
    if (v70 <= 2)
    {
      uint64_t v81 = &v75[v70];
      unint64_t v82 = v70;
      do
      {
        double v80 = v80 - *v81 * v14[v82];
        v14[v79] = v80;
        v81 += ++v82;
      }
      while (v82 != 3);
    }
    v14[v79] = v80 / *v75;
    v75 -= v70;
  }
  while (v70-- > 1);
  free(v69);
  uint64_t v84 = 0;
  void v10[3] = v11;
  do
  {
    v10[v84] = v14[v84] / v16[v84];
    ++v84;
  }
  while (v84 != 3);
  free(v12);
  free(v13);
  free(v14);
  free(v15);
  free(v16);
  free(v18);
  long long v87 = 0uLL;
  uint64_t v88 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&v87, __p, (uint64_t)v90, (v90 - (unsigned char *)__p) >> 3);
  a1[3] = 0.0;
  unint64_t v85 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v85 = &unk_1EF753148;
  *(_OWORD *)(v85 + 8) = v87;
  *((void *)v85 + 3) = v88;
  *((void *)v85 + 4) = 2;
  *((void *)a1 + 3) = v85;
  if (__p)
  {
    unint64_t v90 = __p;
    operator delete(__p);
  }
}

void sub_1A3FBA0B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3FBA140(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::target_type()
{
}

uint64_t std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"Z13polynomialFitPKdS0_mmS0_S0_S0_E3$_0")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::operator()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(a2, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
}

void std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF753148;
  a2[2] = 0;
  a2[3] = 0;
  a2[1] = 0;
  uint64_t result = std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(a2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  a2[4] = *(void *)(a1 + 32);
  return result;
}

void *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = &unk_1EF753148;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(v2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  v2[4] = *(void *)(a1 + 32);
  return v2;
}

void sub_1A3FBA2EC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::~__func(void *a1)
{
  *a1 = &unk_1EF753148;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1A62562C0);
}

void *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::~__func(void *a1)
{
  *a1 = &unk_1EF753148;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1A3FBA68C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBA8D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBAB4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBAE08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBAF4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v15 = v14;

  _Unwind_Resume(a1);
}

void ctrTrackerInitialization_freeContext(void *a1)
{
  if (a1)
  {
    if (*(void *)a1)
    {
      for (uint64_t i = 2048; i != 2112; i += 16)
      {
        free(*(void **)(*(void *)a1 + i));
        free(*(void **)(*(void *)a1 + i + 8));
      }
      free(*(void **)(*(void *)a1 + 2112));
      free(*(void **)(*(void *)a1 + 2120));
      float v3 = *(void **)a1;
    }
    else
    {
      float v3 = 0;
    }
    free(v3);
    uint64_t v4 = *((void *)a1 + 2);
    if (v4)
    {
      free(*(void **)(v4 + 245992));
      free(*(void **)(*((void *)a1 + 2) + 246000));
      free(*(void **)(*((void *)a1 + 2) + 246008));
      free(*(void **)(*((void *)a1 + 2) + 246016));
      uint64_t v5 = 4;
      uint64_t v6 = 245936;
      do
      {
        free(*(void **)(*((void *)a1 + 2) + v6 - 8));
        free(*(void **)(*((void *)a1 + 2) + v6));
        v6 += 16;
        --v5;
      }
      while (v5);
      uint64_t v7 = 246032;
      uint64_t v8 = 3;
      do
      {
        free(*(void **)(*((void *)a1 + 2) + v7 - 8));
        free(*(void **)(*((void *)a1 + 2) + v7));
        v7 += 16;
        --v8;
      }
      while (v8);
      vDSP_destroy_fftsetup(*(FFTSetup *)(*((void *)a1 + 2) + 250200));
      float v9 = (void *)*((void *)a1 + 2);
    }
    else
    {
      float v9 = 0;
    }
    free(v9);
    uint64_t v10 = *((void *)a1 + 4);
    if (v10)
    {
      free(*(void **)(v10 + 65632));
      free(*(void **)(*((void *)a1 + 4) + 65640));
      double v11 = (void *)*((void *)a1 + 4);
    }
    else
    {
      double v11 = 0;
    }
    free(v11);
    free(*((void **)a1 + 1));
    tplTrackerResampler_free((void ***)a1 + 3);
    free(a1);
  }
}

void sub_1A3FBB29C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBB30C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBB40C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBB79C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBB92C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBBA3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBBF2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBC2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBC35C()
{
}

void sub_1A3FBC6D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  _Block_object_dispose(&a36, 8);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a42);
  _Block_object_dispose((const void *)(v45 - 192), 8);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v45 - 144);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__23565(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__23566(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(a1 + 48);
}

void sub_1A3FBCC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  a9 = (void **)&a14;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierAbstract::classifyDescriptors(vision::mod::ImageClassifierAbstract *this, const vision::mod::ImageDescriptorBufferAbstract *a2, void *a3, int a4)
{
  (*(void (**)(int64x2_t **__return_ptr, const vision::mod::ImageDescriptorBufferAbstract *))(*(void *)a2 + 24))(&v27, a2);
  (*(void (**)(uint64_t *__return_ptr))(v27->i64[0] + 64))(&v25);
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v28);
  }
  vision::mod::ImageClassifierAbstract::classifyDescriptorsNoComulative(&v24, a2, a3, a4);
  memset(v22, 0, sizeof(v22));
  int v23 = 1065353216;
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  int v8 = *((_DWORD *)a2 + 24);
  if (v8 == 1)
  {
    float v11 = *((float *)a2 + 25);
    float v12 = *((float *)a2 + 26);
    ImageClassifier_getBatchCumulativeLabels((uint64_t)&v27, v24.i64, *((_DWORD *)a2 + 28));
    ImageClassifier_getLabelsAuto((uint64_t *)&v18, v29, v22, v11, v12);
  }
  else
  {
    if (v8)
    {
      exceptiounint64_t n = __cxa_allocate_exception(8uLL);
      *exceptiounint64_t n = 3955;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
    float v9 = *((float *)a2 + 25);
    unint64_t v10 = *((int *)a2 + 27);
    ImageClassifier_getBatchCumulativeLabels((uint64_t)&v27, v24.i64, *((_DWORD *)a2 + 28));
    ImageClassifier_getLabels((uint64_t *)&v18, v29, v22, v10, v9);
  }
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node(v29);
  double v13 = (long long *)v27;
  float v27 = 0;
  if (v13) {
    operator delete(v13);
  }
  std::vector<std::pair<std::string,float>>::__vdeallocate((uint64_t *)&v20);
  long long v20 = v18;
  uint64_t v21 = v19;
  uint64_t v19 = 0;
  long long v18 = 0uLL;
  float v27 = (int64x2_t *)&v18;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  uint64_t v15 = (int64x2_t *)*((void *)&v20 + 1);
  for (uint64_t i = (int64x2_t *)v20; i != v15; i += 2)
  {
    __int32 v16 = i[1].i32[2];
    float v27 = i;
    *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)this, (unsigned __int8 *)i, (long long **)&v27)+ 10) = v16;
  }
  float v27 = (int64x2_t *)&v20;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node(0);
  float v27 = &v24;
  std::vector<std::unordered_map<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
  if (v26) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v26);
  }
}

void sub_1A3FBCF18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v23 - 104);
  a9 = (void **)&a13;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a17);
  a17 = (void **)&a23;
  std::vector<std::unordered_map<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&a17);
  uint64_t v25 = *(std::__shared_weak_count **)(v23 - 112);
  if (v25) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v25);
  }
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierAbstract::classifyDescriptorsNoComulative(int64x2_t *this, const vision::mod::ImageDescriptorBufferAbstract *a2, void *a3, int a4)
{
  (*(void (**)(void **__return_ptr, const vision::mod::ImageDescriptorBufferAbstract *))(*(void *)a2 + 24))(&__p, a2);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)__p + 64))(&v31);
  if (v34[0]) {
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v34[0]);
  }
  this->i64[0] = 0;
  this->i64[1] = 0;
  this[1].i64[0] = 0;
  if (a3[9])
  {
    unint64_t v8 = 0;
    do
    {
      (*(void (**)(void *, uint64_t, unint64_t))(*a3 + 112))(a3, v31, v8);
      (*(void (**)(void **__return_ptr, const vision::mod::ImageDescriptorBufferAbstract *, uint64_t))(*(void *)a2 + 56))(v28, a2, v31);
      *(_OWORD *)uint64_t v25 = 0u;
      *(_OWORD *)uint64_t v26 = 0u;
      int v27 = 1065353216;
      if (a4)
      {
        vision::mod::ImageClassifierAbstract::ImageClassifier_filterdisallowedListedLabels((uint64_t)&__p, (uint64_t)a2, (uint64_t)v28);
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__move_assign((uint64_t)v25, (uint64_t *)&__p);
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v34[1]);
        float v9 = __p;
        std::string __p = 0;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        int v27 = v30;
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,float>,void *> *>>(v25, (uint64_t *)v29);
      }
      unint64_t v11 = this->u64[1];
      unint64_t v10 = this[1].u64[0];
      if (v11 >= v10)
      {
        unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v11 - this->i64[0]) >> 3);
        unint64_t v14 = v13 + 1;
        if (v13 + 1 > 0x666666666666666) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - this->i64[0]) >> 3);
        if (2 * v15 > v14) {
          unint64_t v14 = 2 * v15;
        }
        if (v15 >= 0x333333333333333) {
          unint64_t v16 = 0x666666666666666;
        }
        else {
          unint64_t v16 = v14;
        }
        double v36 = this + 1;
        if (v16) {
          unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unordered_map<std::string,float>>>(v16);
        }
        else {
          uint64_t v17 = 0;
        }
        std::string __p = (void *)v16;
        v34[0] = (void *)(v16 + 40 * v13);
        v34[1] = v34[0];
        unint64_t v35 = v16 + 40 * v17;
        std::unordered_map<std::string,float>::unordered_map((uint64_t)v34[0], (uint64_t)v25);
        long long v18 = v34[0];
        float v12 = (char *)v34[1] + 40;
        v34[1] = (char *)v34[1] + 40;
        long long v20 = (uint64_t *)this->i64[0];
        uint64_t v19 = (uint64_t *)this->i64[1];
        if (v19 == (uint64_t *)this->i64[0])
        {
          int64x2_t v21 = vdupq_n_s64((unint64_t)v19);
        }
        else
        {
          do
          {
            v19 -= 5;
            long long v18 = (void *)std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__hash_table((uint64_t)v18 - 40, v19);
          }
          while (v19 != v20);
          int64x2_t v21 = *this;
          float v12 = (char *)v34[1];
        }
        this->i64[0] = (uint64_t)v18;
        this->i64[1] = (uint64_t)v12;
        *(int64x2_t *)uint64_t v34 = v21;
        unint64_t v22 = this[1].u64[0];
        this[1].i64[0] = v35;
        unint64_t v35 = v22;
        std::string __p = (void *)v21.i64[0];
        std::__split_buffer<std::unordered_map<std::string,float>>::~__split_buffer((uint64_t)&__p);
      }
      else
      {
        std::unordered_map<std::string,float>::unordered_map(this->i64[1], (uint64_t)v25);
        float v12 = (char *)(v11 + 40);
        this->i64[1] = v11 + 40;
      }
      this->i64[1] = (uint64_t)v12;
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v26[0]);
      uint64_t v23 = v25[0];
      v25[0] = 0;
      if (v23) {
        operator delete(v23);
      }
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v29);
      int64x2_t v24 = v28[0];
      v28[0] = 0;
      if (v24) {
        operator delete(v24);
      }
      ++v8;
    }
    while (a3[9] > v8);
  }
  if (v32) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v32);
  }
}

void sub_1A3FBD2A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,std::__shared_weak_count *a23)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::unordered_map<std::string,float>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(unsigned __int8 **)(a2 + 16); i; uint64_t i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,float> const&>(a1, i + 16, (uint64_t)(i + 16));
  return a1;
}

void sub_1A3FBD374(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::unordered_map<std::string,float>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(i - 40);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1A3FBD7A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  *(void *)(v36 - 112) = &a13;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v36 - 112));

  _Block_object_dispose(&a26, 8);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a32);

  _Unwind_Resume(a1);
}

void sub_1A3FBDA40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBDD48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20)
{
  _Block_object_dispose((const void *)(v24 - 152), 8);
  _Block_object_dispose((const void *)(v24 - 120), 8);

  _Unwind_Resume(a1);
}

void sub_1A3FBE4DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33)
{
  if (__p) {
    operator delete(__p);
  }

  unint64_t v37 = *(void **)(v35 - 144);
  if (v37)
  {
    *(void *)(v35 - 136) = v37;
    operator delete(v37);
  }
  _Unwind_Resume(a1);
}

void sub_1A3FBE754(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  vision::mod::ImageDescriptorAugmenterAbstract::~ImageDescriptorAugmenterAbstract((vision::mod::ImageDescriptorAugmenterAbstract *)&a9);

  _Unwind_Resume(a1);
}

void *std::vector<vImage_Buffer>::__init_with_size[abi:ne180100]<vImage_Buffer*,vImage_Buffer*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<vImage_Buffer>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3FBE7DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_ea8_56c55_ZTSNSt3__16vectorI13vImage_BufferNS_9allocatorIS1_EEEE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

void *__copy_helper_block_ea8_56c55_ZTSNSt3__16vectorI13vImage_BufferNS_9allocatorIS1_EEEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  uint64_t v2 = (void *)(a1 + 56);
  v2[2] = 0;
  return std::vector<vImage_Buffer>::__init_with_size[abi:ne180100]<vImage_Buffer*,vImage_Buffer*>(v2, *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 5);
}

void sub_1A3FBEB28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBEC08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBEE90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBEFA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBF06C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBF0F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FBF164(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<int,ObservedParabola>,std::__map_value_compare<int,std::__value_type<int,ObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,ObservedParabola>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<int,ObservedParabola>,std::__map_value_compare<int,std::__value_type<int,ObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,ObservedParabola>>>::destroy(*a1);
    std::__tree<std::__value_type<int,ObservedParabola>,std::__map_value_compare<int,std::__value_type<int,ObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,ObservedParabola>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<int const,ObservedParabola>,0>(a1 + 4);
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<int,InternalObservedParabola>,std::__map_value_compare<int,std::__value_type<int,InternalObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,InternalObservedParabola>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<int,InternalObservedParabola>,std::__map_value_compare<int,std::__value_type<int,InternalObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,InternalObservedParabola>>>::destroy(*a1);
    std::__tree<std::__value_type<int,InternalObservedParabola>,std::__map_value_compare<int,std::__value_type<int,InternalObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,InternalObservedParabola>>>::destroy(a1[1]);
    InternalObservedParabola::~InternalObservedParabola((InternalObservedParabola *)(a1 + 6));
    operator delete(a1);
  }
}

void InternalObservedParabola::~InternalObservedParabola(InternalObservedParabola *this)
{
  uint64_t v2 = (void *)*((void *)this + 91);
  if (v2)
  {
    *((void *)this + 92) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 85);
  if (v3)
  {
    *((void *)this + 86) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 82);
  if (v4)
  {
    *((void *)this + 83) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 13);
  if (v5)
  {
    *((void *)this + 14) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 10);
  if (v6)
  {
    *((void *)this + 11) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 7);
  if (v7)
  {
    *((void *)this + 8) = v7;
    operator delete(v7);
  }
  size_t v8 = (void *)*((void *)this + 1);
  if (v8)
  {
    *((void *)this + 2) = v8;
    operator delete(v8);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<int const,ObservedParabola>,0>(void *a1)
{
  uint64_t v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[2];
}

BOOL sortPointsByXThenY(double *a1, double *a2)
{
  if (*a1 > *a2) {
    return 1;
  }
  if (*a1 == *a2) {
    return a1[1] > a2[1];
  }
  return 0;
}

double *sanitize(double **a1, long long **a2, int a3, int a4)
{
  size_t v8 = *a2;
  float v9 = a2[1];
  unint64_t v10 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (v9 - v8));
  unint64_t v37 = sortPointsByXThenY;
  if (v9 == v8) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v10;
  }
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*,false>(v8, v9, (unsigned int (**)(long long *, long long *))&v37, v11, 1);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  float v12 = *a2;
  unint64_t v13 = a2[1];
  uint64_t result = (double *)operator new(0x30uLL);
  unint64_t v15 = (unint64_t)((char *)v13 - (char *)v12) >> 4;
  unint64_t v16 = result + 6;
  long long v17 = *(v13 - 3);
  long long v18 = *(v13 - 1);
  *((_OWORD *)result + 1) = *(v13 - 2);
  *((_OWORD *)result + 2) = v18;
  *(_OWORD *)uint64_t result = v17;
  *a1 = result;
  a1[1] = result + 6;
  a1[2] = result + 6;
  uint64_t v19 = (-1431655765 * v15 - 2);
  if ((v19 & 0x80000000) == 0)
  {
    do
    {
      uint64_t v20 = (uint64_t)&(*a2)[3 * v19];
      if (vabdd_f64(*(double *)v20, *(v16 - 6)) > (double)a3
        || vabdd_f64(*(double *)(v20 + 8), *(v16 - 5)) > (double)a4)
      {
        unint64_t v21 = (unint64_t)a1[2];
        if ((unint64_t)v16 >= v21)
        {
          unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v16 - (char *)result) >> 4);
          unint64_t v25 = v24 + 1;
          if (v24 + 1 > 0x555555555555555) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - (void)result) >> 4);
          if (2 * v26 > v25) {
            unint64_t v25 = 2 * v26;
          }
          if (v26 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v27 = 0x555555555555555;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27)
          {
            unint64_t v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::vector<BOOL>>>>(v27);
            uint64_t result = *a1;
          }
          else
          {
            uint64_t v28 = 0;
          }
          double v29 = (_OWORD *)(v27 + 48 * v24);
          long long v30 = *(_OWORD *)v20;
          long long v31 = *(_OWORD *)(v20 + 32);
          v29[1] = *(_OWORD *)(v20 + 16);
          void v29[2] = v31;
          *double v29 = v30;
          if (v16 == result)
          {
            uint64_t v35 = (double *)(v27 + 48 * v24);
          }
          else
          {
            unint64_t v32 = v27 + 48 * v24;
            do
            {
              long long v33 = *((_OWORD *)v16 - 3);
              long long v34 = *((_OWORD *)v16 - 2);
              uint64_t v35 = (double *)(v32 - 48);
              *(_OWORD *)(v32 - 20) = *(_OWORD *)((char *)v16 - 20);
              *(_OWORD *)(v32 - 48) = v33;
              *(_OWORD *)(v32 - 32) = v34;
              v16 -= 6;
              v32 -= 48;
            }
            while (v16 != result);
          }
          unint64_t v16 = (double *)(v29 + 3);
          *a1 = v35;
          a1[1] = (double *)(v29 + 3);
          a1[2] = (double *)(v27 + 48 * v28);
          if (result)
          {
            operator delete(result);
            uint64_t result = *a1;
          }
          else
          {
            uint64_t result = v35;
          }
        }
        else
        {
          long long v22 = *(_OWORD *)v20;
          long long v23 = *(_OWORD *)(v20 + 32);
          *((_OWORD *)v16 + 1) = *(_OWORD *)(v20 + 16);
          *((_OWORD *)v16 + 2) = v23;
          *(_OWORD *)unint64_t v16 = v22;
          v16 += 6;
        }
        a1[1] = v16;
      }
    }
    while (v19-- > 0);
  }
  return result;
}

void sub_1A3FBF8A0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*,false>(long long *a1, long long *a2, unsigned int (**a3)(long long *, long long *), uint64_t a4, char a5)
{
  while (2)
  {
    int v238 = a2 - 3;
    int v233 = a2 - 9;
    size_t v234 = a2 - 6;
    uint64_t v11 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v11;
          uint64_t v12 = (char *)a2 - (char *)v11;
          uint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (a2 - v11);
          if (v6 || !v5)
          {
            switch(v13)
            {
              case 0:
              case 1:
                return;
              case 2:
                int v108 = *a3;
                long long v110 = v238[1];
                long long v109 = v238[2];
                v243[0] = *v238;
                v243[1] = v110;
                v243[2] = v109;
                long long v111 = *a1;
                long long v112 = a1[2];
                v242[1] = a1[1];
                v242[2] = v112;
                v242[0] = v111;
                if (v108(v243, v242))
                {
                  long long v113 = *a1;
                  long long v114 = a1[2];
                  *(_OWORD *)char v270 = a1[1];
                  *(_OWORD *)&v270[16] = v114;
                  long long v269 = v113;
                  long long v115 = *v238;
                  long long v116 = v238[1];
                  *(long long *)((char *)a1 + 28) = *(long long *)((char *)v238 + 28);
                  *a1 = v115;
                  a1[1] = v116;
                  long long v117 = v269;
                  long long v118 = *(_OWORD *)v270;
                  *(long long *)((char *)v238 + 28) = *(_OWORD *)&v270[12];
                  *int v238 = v117;
                  v238[1] = v118;
                }
                break;
              case 3:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, v238, (unsigned int (**)(void, void))a3);
                break;
              case 4:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a1 + 6, v238, (unsigned int (**)(void, void))a3);
                break;
              case 5:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a1 + 6, a1 + 9, v238, (unsigned int (**)(void, void))a3);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v12 <= 1151)
          {
            uint64_t v119 = a1 + 3;
            BOOL v121 = a1 == a2 || v119 == a2;
            if (a5)
            {
              if (!v121)
              {
                unint64_t v122 = a2;
                uint64_t v123 = 0;
                int v124 = a1;
                do
                {
                  uint64_t v125 = v124;
                  int v124 = v119;
                  uint64_t v126 = *a3;
                  long long v128 = v124[1];
                  long long v127 = v124[2];
                  long long v269 = *v124;
                  *(_OWORD *)char v270 = v128;
                  *(_OWORD *)&v270[16] = v127;
                  long long v129 = *v125;
                  long long v130 = v125[2];
                  *(_OWORD *)unint64_t v268 = v125[1];
                  *(_OWORD *)&v268[16] = v130;
                  long long v267 = v129;
                  if (v126(&v269, &v267))
                  {
                    long long v131 = *v124;
                    long long v132 = v124[2];
                    *(_OWORD *)uint64_t v266 = v124[1];
                    *(_OWORD *)&v266[16] = v132;
                    long long v265 = v131;
                    uint64_t v133 = v123;
                    while (1)
                    {
                      uint64_t v134 = (long long *)((char *)a1 + v133);
                      long long v135 = *(long long *)((char *)a1 + v133 + 16);
                      v134[3] = *(long long *)((char *)a1 + v133);
                      v134[4] = v135;
                      *(_OWORD *)((char *)v134 + 76) = *(long long *)((char *)a1 + v133 + 28);
                      if (!v133) {
                        break;
                      }
                      float v136 = (uint64_t (*)(long long *, long long *))*a3;
                      long long v262 = v265;
                      long long v263 = *(_OWORD *)v266;
                      long long v264 = *(_OWORD *)&v266[16];
                      long long v137 = *(v134 - 3);
                      long long v138 = *(v134 - 1);
                      *(_OWORD *)float v261 = *(v134 - 2);
                      *(_OWORD *)&v261[16] = v138;
                      long long v260 = v137;
                      v133 -= 48;
                      if ((v136(&v262, &v260) & 1) == 0)
                      {
                        unint64_t v139 = (long long *)((char *)a1 + v133 + 48);
                        goto LABEL_75;
                      }
                    }
                    unint64_t v139 = a1;
LABEL_75:
                    long long v140 = v265;
                    long long v141 = *(_OWORD *)v266;
                    *(long long *)((char *)v139 + 28) = *(_OWORD *)&v266[12];
                    *unint64_t v139 = v140;
                    v139[1] = v141;
                  }
                  uint64_t v119 = v124 + 3;
                  v123 += 48;
                }
                while (v124 + 3 != v122);
              }
            }
            else if (!v121)
            {
              do
              {
                float v216 = a1;
                a1 = v119;
                float v217 = *a3;
                long long v219 = a1[1];
                long long v218 = a1[2];
                long long v269 = *a1;
                *(_OWORD *)char v270 = v219;
                *(_OWORD *)&v270[16] = v218;
                long long v220 = *v216;
                long long v221 = v216[2];
                *(_OWORD *)unint64_t v268 = v216[1];
                *(_OWORD *)&v268[16] = v221;
                long long v267 = v220;
                if (v217(&v269, &v267))
                {
                  long long v222 = *a1;
                  long long v223 = a1[2];
                  *(_OWORD *)uint64_t v266 = a1[1];
                  *(_OWORD *)&v266[16] = v223;
                  long long v265 = v222;
                  uint64_t v224 = a1;
                  do
                  {
                    int v225 = v224 - 3;
                    long long v226 = *(v224 - 2);
                    *uint64_t v224 = *(v224 - 3);
                    v224[1] = v226;
                    *(long long *)((char *)v224 + 28) = *(long long *)((char *)v224 - 20);
                    int v227 = *a3;
                    long long v262 = v265;
                    long long v263 = *(_OWORD *)v266;
                    long long v264 = *(_OWORD *)&v266[16];
                    long long v228 = *(v224 - 6);
                    long long v229 = *(v224 - 4);
                    *(_OWORD *)float v261 = *(v224 - 5);
                    *(_OWORD *)&v261[16] = v229;
                    long long v260 = v228;
                    char v230 = v227(&v262, &v260);
                    uint64_t v224 = v225;
                  }
                  while ((v230 & 1) != 0);
                  long long v231 = v265;
                  long long v232 = *(_OWORD *)v266;
                  *(long long *)((char *)v225 + 28) = *(_OWORD *)&v266[12];
                  *int v225 = v231;
                  v225[1] = v232;
                }
                uint64_t v119 = a1 + 3;
              }
              while (a1 + 3 != a2);
            }
            return;
          }
          if (!a4)
          {
            if (a1 != a2)
            {
              int64_t v142 = (unint64_t)(v13 - 2) >> 1;
              uint64_t v236 = a2;
              int64_t v239 = v142;
              do
              {
                int64_t v143 = v142;
                if (v239 >= v142)
                {
                  uint64_t v144 = (2 * v142) | 1;
                  int v145 = &a1[3 * v144];
                  if (2 * v142 + 2 < v13)
                  {
                    uint64_t v146 = *a3;
                    long long v148 = v145[1];
                    long long v147 = v145[2];
                    long long v269 = *v145;
                    *(_OWORD *)char v270 = v148;
                    *(_OWORD *)&v270[16] = v147;
                    long long v149 = v145[3];
                    long long v150 = v145[5];
                    *(_OWORD *)unint64_t v268 = v145[4];
                    *(_OWORD *)&v268[16] = v150;
                    long long v267 = v149;
                    if (v146(&v269, &v267))
                    {
                      v145 += 3;
                      uint64_t v144 = 2 * v143 + 2;
                    }
                  }
                  uint64_t v151 = &a1[3 * v143];
                  long long v152 = (uint64_t (*)(long long *, long long *))*a3;
                  long long v154 = v145[1];
                  long long v153 = v145[2];
                  long long v265 = *v145;
                  *(_OWORD *)uint64_t v266 = v154;
                  *(_OWORD *)&v266[16] = v153;
                  long long v155 = *v151;
                  long long v156 = v151[2];
                  long long v263 = v151[1];
                  long long v264 = v156;
                  long long v262 = v155;
                  if ((v152(&v265, &v262) & 1) == 0)
                  {
                    long long v157 = *v151;
                    long long v158 = v151[2];
                    *(_OWORD *)float v261 = v151[1];
                    *(_OWORD *)&v261[16] = v158;
                    long long v260 = v157;
                    do
                    {
                      unint64_t v159 = v145;
                      long long v160 = *v145;
                      long long v161 = v145[1];
                      *(long long *)((char *)v151 + 28) = *(long long *)((char *)v145 + 28);
                      *uint64_t v151 = v160;
                      v151[1] = v161;
                      if (v239 < v144) {
                        break;
                      }
                      uint64_t v162 = (2 * v144) | 1;
                      int v145 = &a1[3 * v162];
                      if (2 * v144 + 2 < v13)
                      {
                        uint64_t v163 = *a3;
                        long long v165 = v145[1];
                        long long v164 = v145[2];
                        long long v258 = *v145;
                        *(_OWORD *)char v259 = v165;
                        *(_OWORD *)&v259[16] = v164;
                        long long v166 = v145[3];
                        long long v167 = v145[5];
                        long long v256 = v145[4];
                        long long v257 = v167;
                        long long v255 = v166;
                        if (v163(&v258, &v255))
                        {
                          v145 += 3;
                          uint64_t v162 = 2 * v144 + 2;
                        }
                      }
                      unsigned int v168 = *a3;
                      long long v170 = v145[1];
                      long long v169 = v145[2];
                      long long v252 = *v145;
                      long long v253 = v170;
                      long long v254 = v169;
                      long long v250 = *(_OWORD *)v261;
                      long long v251 = *(_OWORD *)&v261[16];
                      long long v249 = v260;
                      uint64_t v151 = v159;
                      uint64_t v144 = v162;
                    }
                    while (!v168(&v252, &v249));
                    long long v171 = v260;
                    long long v172 = *(_OWORD *)v261;
                    *(long long *)((char *)v159 + 28) = *(_OWORD *)&v261[12];
                    *unint64_t v159 = v171;
                    v159[1] = v172;
                  }
                }
                int64_t v142 = v143 - 1;
              }
              while (v143);
              int64_t v173 = v12 / 0x30uLL;
              long long v174 = v236;
              do
              {
                uint64_t v175 = 0;
                long long v176 = *a1;
                long long v177 = a1[2];
                *(_OWORD *)char v259 = a1[1];
                *(_OWORD *)&v259[16] = v177;
                long long v258 = v176;
                uint64_t v178 = v173 - 2;
                unint64_t v237 = v174;
                if (v173 < 2) {
                  uint64_t v178 = v173 - 1;
                }
                uint64_t v179 = v178 >> 1;
                int v180 = a1;
                do
                {
                  std::vector<int>::pointer v181 = &v180[3 * v175 + 3];
                  uint64_t v182 = (2 * v175) | 1;
                  uint64_t v183 = 2 * v175 + 2;
                  if (v183 < v173)
                  {
                    int v184 = *a3;
                    long long v186 = v181[1];
                    long long v185 = v181[2];
                    long long v269 = *v181;
                    *(_OWORD *)char v270 = v186;
                    *(_OWORD *)&v270[16] = v185;
                    long long v187 = v181[3];
                    long long v188 = v181[5];
                    *(_OWORD *)unint64_t v268 = v181[4];
                    *(_OWORD *)&v268[16] = v188;
                    long long v267 = v187;
                    if (v184(&v269, &v267))
                    {
                      v181 += 3;
                      uint64_t v182 = v183;
                    }
                  }
                  long long v189 = *v181;
                  long long v190 = v181[1];
                  *(long long *)((char *)v180 + 28) = *(long long *)((char *)v181 + 28);
                  *int v180 = v189;
                  v180[1] = v190;
                  int v180 = v181;
                  uint64_t v175 = v182;
                }
                while (v182 <= v179);
                long long v174 = v237 - 3;
                if (v181 == v237 - 3)
                {
                  long long v213 = v258;
                  long long v214 = *(_OWORD *)v259;
                  *(long long *)((char *)v181 + 28) = *(_OWORD *)&v259[12];
                  *std::vector<int>::pointer v181 = v213;
                  v181[1] = v214;
                }
                else
                {
                  long long v191 = *v174;
                  long long v192 = *(v237 - 2);
                  *(long long *)((char *)v181 + 28) = *(long long *)((char *)v237 - 20);
                  *std::vector<int>::pointer v181 = v191;
                  v181[1] = v192;
                  long long v193 = v258;
                  long long v194 = *(_OWORD *)v259;
                  *(long long *)((char *)v237 - 20) = *(_OWORD *)&v259[12];
                  *long long v174 = v193;
                  *(v237 - 2) = v194;
                  uint64_t v195 = (char *)v181 - (char *)a1 + 48;
                  if (v195 >= 49)
                  {
                    unint64_t v196 = (unint64_t)(-2 - 0x5555555555555555 * (v195 >> 4)) >> 1;
                    int v197 = &a1[3 * v196];
                    uint64_t v198 = *a3;
                    long long v200 = v197[1];
                    long long v199 = v197[2];
                    long long v269 = *v197;
                    *(_OWORD *)char v270 = v200;
                    *(_OWORD *)&v270[16] = v199;
                    long long v201 = *v181;
                    long long v202 = v181[2];
                    *(_OWORD *)unint64_t v268 = v181[1];
                    *(_OWORD *)&v268[16] = v202;
                    long long v267 = v201;
                    if (v198(&v269, &v267))
                    {
                      long long v203 = *v181;
                      long long v204 = v181[2];
                      *(_OWORD *)uint64_t v266 = v181[1];
                      *(_OWORD *)&v266[16] = v204;
                      long long v265 = v203;
                      do
                      {
                        unint64_t v205 = v197;
                        long long v206 = *v197;
                        long long v207 = v197[1];
                        *(long long *)((char *)v181 + 28) = *(long long *)((char *)v197 + 28);
                        *std::vector<int>::pointer v181 = v206;
                        v181[1] = v207;
                        if (!v196) {
                          break;
                        }
                        unint64_t v196 = (v196 - 1) >> 1;
                        float v208 = (uint64_t (*)(long long *, long long *))*a3;
                        int v197 = &a1[3 * v196];
                        long long v210 = v197[1];
                        long long v209 = v197[2];
                        long long v262 = *v197;
                        long long v263 = v210;
                        long long v264 = v209;
                        *(_OWORD *)float v261 = *(_OWORD *)v266;
                        *(_OWORD *)&v261[16] = *(_OWORD *)&v266[16];
                        long long v260 = v265;
                        std::vector<int>::pointer v181 = v205;
                      }
                      while ((v208(&v262, &v260) & 1) != 0);
                      long long v211 = v265;
                      long long v212 = *(_OWORD *)v266;
                      *(long long *)((char *)v205 + 28) = *(_OWORD *)&v266[12];
                      long long *v205 = v211;
                      v205[1] = v212;
                      long long v174 = v237 - 3;
                    }
                  }
                }
              }
              while (v173-- > 2);
            }
            return;
          }
          unint64_t v14 = (unint64_t)v13 >> 1;
          unint64_t v15 = &a1[3 * ((unint64_t)v13 >> 1)];
          if ((unint64_t)v12 < 0x1801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(v15, a1, v238, (unsigned int (**)(void, void))a3);
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, v15, v238, (unsigned int (**)(void, void))a3);
            uint64_t v16 = 3 * v14;
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1 + 3, &a1[v16 - 3], v234, (unsigned int (**)(void, void))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1 + 6, &a1[v16 + 3], v233, (unsigned int (**)(void, void))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(&a1[v16 - 3], v15, &a1[v16 + 3], (unsigned int (**)(void, void))a3);
            long long v17 = *a1;
            long long v18 = a1[2];
            *(_OWORD *)char v270 = a1[1];
            *(_OWORD *)&v270[16] = v18;
            long long v269 = v17;
            long long v19 = *(long long *)((char *)v15 + 28);
            long long v20 = v15[1];
            *a1 = *v15;
            a1[1] = v20;
            *(long long *)((char *)a1 + 28) = v19;
            long long v21 = v269;
            long long v22 = *(_OWORD *)v270;
            *(long long *)((char *)v15 + 28) = *(_OWORD *)&v270[12];
            *unint64_t v15 = v21;
            v15[1] = v22;
          }
          --a4;
          if (a5) {
            break;
          }
          long long v23 = *a3;
          long long v25 = *(a1 - 2);
          long long v24 = *(a1 - 1);
          v241[0] = *(a1 - 3);
          v241[1] = v25;
          v241[2] = v24;
          long long v26 = *a1;
          long long v27 = a1[2];
          v240[1] = a1[1];
          v240[2] = v27;
          v240[0] = v26;
          if (((uint64_t (*)(_OWORD *, _OWORD *))v23)(v241, v240)) {
            break;
          }
          long long v66 = *a1;
          long long v67 = a1[2];
          *(_OWORD *)unint64_t v268 = a1[1];
          *(_OWORD *)&v268[16] = v67;
          long long v267 = v66;
          uint64_t v68 = (uint64_t (*)(long long *, long long *))*a3;
          long long v70 = a1[1];
          long long v69 = a1[2];
          long long v265 = *a1;
          *(_OWORD *)uint64_t v266 = v70;
          *(_OWORD *)&v266[16] = v69;
          long long v71 = *v238;
          long long v72 = v238[2];
          long long v263 = v238[1];
          long long v264 = v72;
          long long v262 = v71;
          if (v68(&v265, &v262))
          {
            unint64_t v73 = a1;
            do
            {
              uint64_t v11 = v73 + 3;
              unint64_t v74 = *a3;
              long long v260 = v267;
              *(_OWORD *)float v261 = *(_OWORD *)v268;
              *(_OWORD *)&v261[16] = *(_OWORD *)&v268[16];
              long long v75 = v73[3];
              long long v76 = v73[5];
              *(_OWORD *)char v259 = v73[4];
              *(_OWORD *)&v259[16] = v76;
              long long v258 = v75;
              char v77 = v74(&v260, &v258);
              unint64_t v73 = v11;
            }
            while ((v77 & 1) == 0);
          }
          else
          {
            double v78 = a1 + 3;
            do
            {
              uint64_t v11 = v78;
              if (v78 >= a2) {
                break;
              }
              unint64_t v79 = *a3;
              long long v260 = v267;
              *(_OWORD *)float v261 = *(_OWORD *)v268;
              *(_OWORD *)&v261[16] = *(_OWORD *)&v268[16];
              long long v80 = *v11;
              long long v81 = v11[2];
              *(_OWORD *)char v259 = v11[1];
              *(_OWORD *)&v259[16] = v81;
              long long v258 = v80;
              unsigned int v82 = v79(&v260, &v258);
              double v78 = v11 + 3;
            }
            while (!v82);
          }
          int v83 = a2;
          if (v11 < a2)
          {
            uint64_t v84 = a2;
            do
            {
              int v83 = v84 - 3;
              unint64_t v85 = *a3;
              long long v255 = v267;
              long long v256 = *(_OWORD *)v268;
              long long v257 = *(_OWORD *)&v268[16];
              long long v86 = *(v84 - 3);
              long long v87 = *(v84 - 1);
              long long v253 = *(v84 - 2);
              long long v254 = v87;
              long long v252 = v86;
              char v88 = v85(&v255, &v252);
              uint64_t v84 = v83;
            }
            while ((v88 & 1) != 0);
          }
          while (v11 < v83)
          {
            long long v89 = *v11;
            long long v90 = v11[2];
            *(_OWORD *)char v270 = v11[1];
            *(_OWORD *)&v270[16] = v90;
            long long v269 = v89;
            long long v91 = *v83;
            long long v92 = v83[1];
            *(long long *)((char *)v11 + 28) = *(long long *)((char *)v83 + 28);
            *uint64_t v11 = v91;
            v11[1] = v92;
            long long v93 = v269;
            long long v94 = *(_OWORD *)v270;
            *(long long *)((char *)v83 + 28) = *(_OWORD *)&v270[12];
            *int v83 = v93;
            v83[1] = v94;
            do
            {
              long long v249 = v267;
              long long v250 = *(_OWORD *)v268;
              long long v251 = *(_OWORD *)&v268[16];
              long long v96 = v11[3];
              long long v95 = v11[4];
              long long v97 = v11[5];
              v11 += 3;
              double v98 = *a3;
              long long v247 = v95;
              long long v248 = v97;
              long long v246 = v96;
            }
            while (!v98(&v249, &v246));
            do
            {
              v245[0] = v267;
              v245[1] = *(_OWORD *)v268;
              int v245[2] = *(_OWORD *)&v268[16];
              long long v100 = *(v83 - 3);
              long long v99 = *(v83 - 2);
              long long v101 = *(v83 - 1);
              v83 -= 3;
              double v102 = *a3;
              v244[1] = v99;
              v244[2] = v101;
              v244[0] = v100;
            }
            while ((((uint64_t (*)(_OWORD *, _OWORD *))v102)(v245, v244) & 1) != 0);
          }
          uint64_t v103 = v11 - 3;
          BOOL v5 = v11 - 3 >= a1;
          BOOL v6 = v11 - 3 == a1;
          if (v11 - 3 != a1)
          {
            long long v104 = *v103;
            long long v105 = *(v11 - 2);
            *(long long *)((char *)a1 + 28) = *(long long *)((char *)v11 - 20);
            *a1 = v104;
            a1[1] = v105;
          }
          a5 = 0;
          long long v106 = v267;
          long long v107 = *(_OWORD *)v268;
          *(long long *)((char *)v11 - 20) = *(_OWORD *)&v268[12];
          *uint64_t v103 = v106;
          *(v11 - 2) = v107;
        }
        long long v28 = *a1;
        long long v29 = a1[2];
        *(_OWORD *)unint64_t v268 = a1[1];
        *(_OWORD *)&v268[16] = v29;
        long long v267 = v28;
        long long v30 = a1;
        do
        {
          long long v31 = v30;
          unint64_t v32 = (uint64_t (*)(long long *, long long *))*a3;
          v30 += 3;
          long long v34 = v31[4];
          long long v33 = v31[5];
          long long v265 = v31[3];
          *(_OWORD *)uint64_t v266 = v34;
          *(_OWORD *)&v266[16] = v33;
          long long v263 = *(_OWORD *)v268;
          long long v264 = *(_OWORD *)&v268[16];
          long long v262 = v267;
        }
        while ((v32(&v265, &v262) & 1) != 0);
        uint64_t v35 = a2;
        uint64_t v36 = a2;
        if (v31 == a1)
        {
          double v42 = a2;
          while (v30 < v42)
          {
            uint64_t v43 = *a3;
            unint64_t v37 = v42 - 3;
            long long v45 = *(v42 - 2);
            long long v44 = *(v42 - 1);
            long long v260 = *(v42 - 3);
            *(_OWORD *)float v261 = v45;
            *(_OWORD *)&v261[16] = v44;
            *(_OWORD *)char v259 = *(_OWORD *)v268;
            *(_OWORD *)&v259[16] = *(_OWORD *)&v268[16];
            long long v258 = v267;
            char v46 = v43(&v260, &v258);
            double v42 = v37;
            if (v46) {
              goto LABEL_21;
            }
          }
          unint64_t v37 = v42;
        }
        else
        {
          do
          {
            unint64_t v37 = v36 - 3;
            double v38 = *a3;
            long long v40 = *(v36 - 2);
            long long v39 = *(v36 - 1);
            long long v260 = *(v36 - 3);
            *(_OWORD *)float v261 = v40;
            *(_OWORD *)&v261[16] = v39;
            *(_OWORD *)char v259 = *(_OWORD *)v268;
            *(_OWORD *)&v259[16] = *(_OWORD *)&v268[16];
            long long v258 = v267;
            unsigned int v41 = v38(&v260, &v258);
            uint64_t v36 = v37;
          }
          while (!v41);
        }
LABEL_21:
        if (v30 < v37)
        {
          double v47 = v30;
          uint64_t v48 = v37;
          do
          {
            long long v49 = v47[2];
            *(_OWORD *)char v270 = v47[1];
            long long v50 = *(_OWORD *)v270;
            *(_OWORD *)&v270[16] = v49;
            long long v269 = *v47;
            long long v51 = v269;
            long long v53 = *v48;
            long long v52 = v48[1];
            *(long long *)((char *)v47 + 28) = *(long long *)((char *)v48 + 28);
            long long *v47 = v53;
            v47[1] = v52;
            *(long long *)((char *)v48 + 28) = *(_OWORD *)&v270[12];
            *uint64_t v48 = v51;
            v48[1] = v50;
            do
            {
              long long v31 = v47;
              uint64_t v54 = (uint64_t (*)(long long *, long long *))*a3;
              v47 += 3;
              long long v56 = v31[4];
              long long v55 = v31[5];
              long long v255 = v31[3];
              long long v256 = v56;
              long long v257 = v55;
              long long v253 = *(_OWORD *)v268;
              long long v254 = *(_OWORD *)&v268[16];
              long long v252 = v267;
            }
            while ((v54(&v255, &v252) & 1) != 0);
            do
            {
              long long v58 = *(v48 - 2);
              long long v57 = *(v48 - 1);
              long long v59 = *(v48 - 3);
              v48 -= 3;
              double v60 = *a3;
              long long v249 = v59;
              long long v250 = v58;
              long long v251 = v57;
              long long v247 = *(_OWORD *)v268;
              long long v248 = *(_OWORD *)&v268[16];
              long long v246 = v267;
            }
            while (!v60(&v249, &v246));
          }
          while (v47 < v48);
        }
        if (v31 != a1)
        {
          long long v61 = *v31;
          long long v62 = v31[1];
          *(long long *)((char *)a1 + 28) = *(long long *)((char *)v31 + 28);
          *a1 = v61;
          a1[1] = v62;
        }
        long long v63 = v267;
        long long v64 = *(_OWORD *)v268;
        *(long long *)((char *)v31 + 28) = *(_OWORD *)&v268[12];
        long long *v31 = v63;
        v31[1] = v64;
        BOOL v5 = v30 >= v37;
        a2 = v35;
        if (v5) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*,false>(a1, v31, a3, a4, a5 & 1);
        a5 = 0;
        uint64_t v11 = v31 + 3;
      }
      BOOL v65 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, v31, (unsigned int (**)(void, void))a3);
      uint64_t v11 = v31 + 3;
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(v31 + 3, v35, (unsigned int (**)(void, void))a3))
      {
        break;
      }
      if (!v65) {
        goto LABEL_33;
      }
    }
    a2 = v31;
    if (!v65) {
      continue;
    }
    break;
  }
}

double std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(_OWORD *a1, _OWORD *a2, _OWORD *a3, unsigned int (**a4)(void, void))
{
  size_t v8 = *a4;
  long long v9 = a2[1];
  v60[0] = *a2;
  v60[1] = v9;
  v60[2] = a2[2];
  long long v10 = a1[1];
  v59[0] = *a1;
  v59[1] = v10;
  v59[2] = a1[2];
  char v11 = v8(v60, v59);
  uint64_t v12 = *a4;
  if (v11)
  {
    long long v13 = a3[1];
    v54[0] = *a3;
    v54[1] = v13;
    v54[2] = a3[2];
    long long v14 = a2[1];
    v53[0] = *a2;
    v53[1] = v14;
    v53[2] = a2[2];
    if (v12(v54, v53))
    {
      long long v16 = a1[1];
      long long v15 = a1[2];
      long long v17 = *a1;
      *(_OWORD *)long long v61 = v16;
      *(_OWORD *)&v61[16] = v15;
      long long v18 = *(_OWORD *)((char *)a3 + 28);
      long long v19 = a3[1];
      *a1 = *a3;
      a1[1] = v19;
      *(_OWORD *)((char *)a1 + 28) = v18;
    }
    else
    {
      long long v38 = a1[2];
      long long v40 = *a1;
      *(_OWORD *)long long v61 = a1[1];
      long long v39 = *(_OWORD *)v61;
      *(_OWORD *)&v61[16] = v38;
      long long v41 = *(_OWORD *)((char *)a2 + 28);
      long long v42 = a2[1];
      *a1 = *a2;
      a1[1] = v42;
      *(_OWORD *)((char *)a1 + 28) = v41;
      *a2 = v40;
      a2[1] = v39;
      *(_OWORD *)((char *)a2 + 28) = *(_OWORD *)&v61[12];
      uint64_t v43 = *a4;
      long long v44 = *a3;
      long long v45 = a3[2];
      v52[1] = a3[1];
      v52[2] = v45;
      long long v46 = *a2;
      long long v47 = a2[1];
      v51[2] = a2[2];
      v52[0] = v44;
      v51[0] = v46;
      v51[1] = v47;
      if (!v43(v52, v51)) {
        return result;
      }
      long long v16 = a2[1];
      long long v48 = a2[2];
      long long v17 = *a2;
      *(_OWORD *)long long v61 = v16;
      *(_OWORD *)&v61[16] = v48;
      long long v49 = *(_OWORD *)((char *)a3 + 28);
      long long v50 = a3[1];
      *a2 = *a3;
      a2[1] = v50;
      *(_OWORD *)((char *)a2 + 28) = v49;
    }
    *a3 = v17;
    a3[1] = v16;
    double result = *(double *)&v61[12];
    *(_OWORD *)((char *)a3 + 28) = *(_OWORD *)&v61[12];
  }
  else
  {
    long long v20 = a3[1];
    v58[0] = *a3;
    v58[1] = v20;
    v58[2] = a3[2];
    long long v21 = a2[1];
    v57[0] = *a2;
    v57[1] = v21;
    v57[2] = a2[2];
    if (v12(v58, v57))
    {
      long long v23 = a2[2];
      long long v25 = *a2;
      *(_OWORD *)long long v61 = a2[1];
      long long v24 = *(_OWORD *)v61;
      *(_OWORD *)&v61[16] = v23;
      long long v26 = *(_OWORD *)((char *)a3 + 28);
      long long v27 = a3[1];
      *a2 = *a3;
      a2[1] = v27;
      *(_OWORD *)((char *)a2 + 28) = v26;
      *a3 = v25;
      a3[1] = v24;
      *(_OWORD *)((char *)a3 + 28) = *(_OWORD *)&v61[12];
      long long v28 = *a4;
      long long v29 = *a2;
      long long v30 = a2[2];
      v56[1] = a2[1];
      v56[2] = v30;
      long long v31 = *a1;
      long long v32 = a1[1];
      v55[2] = a1[2];
      v56[0] = v29;
      v55[0] = v31;
      v55[1] = v32;
      if (v28(v56, v55))
      {
        long long v33 = a1[2];
        long long v35 = *a1;
        *(_OWORD *)long long v61 = a1[1];
        long long v34 = *(_OWORD *)v61;
        *(_OWORD *)&v61[16] = v33;
        long long v36 = *(_OWORD *)((char *)a2 + 28);
        long long v37 = a2[1];
        *a1 = *a2;
        a1[1] = v37;
        *(_OWORD *)((char *)a1 + 28) = v36;
        *a2 = v35;
        a2[1] = v34;
        double result = *(double *)&v61[12];
        *(_OWORD *)((char *)a2 + 28) = *(_OWORD *)&v61[12];
      }
    }
  }
  return result;
}

double std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(long long *a1, long long *a2, long long *a3, long long *a4, unsigned int (**a5)(void, void))
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a2, a3, a5);
  long long v10 = *a5;
  long long v11 = a4[1];
  v44[0] = *a4;
  v44[1] = v11;
  v44[2] = a4[2];
  long long v12 = a3[1];
  v43[0] = *a3;
  v43[1] = v12;
  v43[2] = a3[2];
  if (v10(v44, v43))
  {
    long long v14 = a3[2];
    long long v16 = *a3;
    *(_OWORD *)long long v45 = a3[1];
    long long v15 = *(_OWORD *)v45;
    *(_OWORD *)&v45[16] = v14;
    long long v17 = *(long long *)((char *)a4 + 28);
    long long v18 = a4[1];
    *a3 = *a4;
    a3[1] = v18;
    *(long long *)((char *)a3 + 28) = v17;
    *a4 = v16;
    a4[1] = v15;
    *(long long *)((char *)a4 + 28) = *(_OWORD *)&v45[12];
    long long v19 = *a5;
    long long v20 = *a3;
    long long v21 = a3[2];
    v42[1] = a3[1];
    v42[2] = v21;
    long long v22 = *a2;
    long long v23 = a2[1];
    v41[2] = a2[2];
    v42[0] = v20;
    v41[0] = v22;
    v41[1] = v23;
    if (v19(v42, v41))
    {
      long long v24 = a2[2];
      long long v26 = *a2;
      *(_OWORD *)long long v45 = a2[1];
      long long v25 = *(_OWORD *)v45;
      *(_OWORD *)&v45[16] = v24;
      long long v27 = *(long long *)((char *)a3 + 28);
      long long v28 = a3[1];
      *a2 = *a3;
      a2[1] = v28;
      *(long long *)((char *)a2 + 28) = v27;
      *a3 = v26;
      a3[1] = v25;
      *(long long *)((char *)a3 + 28) = *(_OWORD *)&v45[12];
      long long v29 = *a5;
      long long v30 = *a2;
      long long v31 = a2[2];
      v40[1] = a2[1];
      v40[2] = v31;
      long long v32 = *a1;
      long long v33 = a1[1];
      v39[2] = a1[2];
      v40[0] = v30;
      v39[0] = v32;
      v39[1] = v33;
      if (v29(v40, v39))
      {
        long long v34 = a1[2];
        long long v36 = *a1;
        *(_OWORD *)long long v45 = a1[1];
        long long v35 = *(_OWORD *)v45;
        *(_OWORD *)&v45[16] = v34;
        long long v37 = *(long long *)((char *)a2 + 28);
        long long v38 = a2[1];
        *a1 = *a2;
        a1[1] = v38;
        *(long long *)((char *)a1 + 28) = v37;
        *a2 = v36;
        a2[1] = v35;
        double result = *(double *)&v45[12];
        *(long long *)((char *)a2 + 28) = *(_OWORD *)&v45[12];
      }
    }
  }
  return result;
}

double std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(long long *a1, long long *a2, long long *a3, long long *a4, long long *a5, unsigned int (**a6)(void, void))
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a2, a3, a4, a6);
  long long v12 = *a6;
  long long v13 = a5[1];
  v58[0] = *a5;
  v58[1] = v13;
  v58[2] = a5[2];
  long long v14 = a4[1];
  v57[0] = *a4;
  v57[1] = v14;
  v57[2] = a4[2];
  if (v12(v58, v57))
  {
    long long v16 = a4[2];
    long long v18 = *a4;
    *(_OWORD *)long long v59 = a4[1];
    long long v17 = *(_OWORD *)v59;
    *(_OWORD *)&v59[16] = v16;
    long long v19 = *(long long *)((char *)a5 + 28);
    long long v20 = a5[1];
    *a4 = *a5;
    a4[1] = v20;
    *(long long *)((char *)a4 + 28) = v19;
    *a5 = v18;
    a5[1] = v17;
    *(long long *)((char *)a5 + 28) = *(_OWORD *)&v59[12];
    long long v21 = *a6;
    long long v22 = *a4;
    long long v23 = a4[2];
    v56[1] = a4[1];
    v56[2] = v23;
    long long v24 = *a3;
    long long v25 = a3[1];
    v55[2] = a3[2];
    v56[0] = v22;
    v55[0] = v24;
    v55[1] = v25;
    if (v21(v56, v55))
    {
      long long v26 = a3[2];
      long long v28 = *a3;
      *(_OWORD *)long long v59 = a3[1];
      long long v27 = *(_OWORD *)v59;
      *(_OWORD *)&v59[16] = v26;
      long long v29 = *(long long *)((char *)a4 + 28);
      long long v30 = a4[1];
      *a3 = *a4;
      a3[1] = v30;
      *(long long *)((char *)a3 + 28) = v29;
      *a4 = v28;
      a4[1] = v27;
      *(long long *)((char *)a4 + 28) = *(_OWORD *)&v59[12];
      long long v31 = *a6;
      long long v32 = *a3;
      long long v33 = a3[2];
      v54[1] = a3[1];
      v54[2] = v33;
      long long v34 = *a2;
      long long v35 = a2[1];
      v53[2] = a2[2];
      v54[0] = v32;
      v53[0] = v34;
      v53[1] = v35;
      if (v31(v54, v53))
      {
        long long v36 = a2[2];
        long long v38 = *a2;
        *(_OWORD *)long long v59 = a2[1];
        long long v37 = *(_OWORD *)v59;
        *(_OWORD *)&v59[16] = v36;
        long long v39 = *(long long *)((char *)a3 + 28);
        long long v40 = a3[1];
        *a2 = *a3;
        a2[1] = v40;
        *(long long *)((char *)a2 + 28) = v39;
        *a3 = v38;
        a3[1] = v37;
        *(long long *)((char *)a3 + 28) = *(_OWORD *)&v59[12];
        long long v41 = *a6;
        long long v42 = *a2;
        long long v43 = a2[2];
        v52[1] = a2[1];
        v52[2] = v43;
        long long v44 = *a1;
        long long v45 = a1[1];
        v51[2] = a1[2];
        v52[0] = v42;
        v51[0] = v44;
        v51[1] = v45;
        if (v41(v52, v51))
        {
          long long v46 = a1[2];
          long long v48 = *a1;
          *(_OWORD *)long long v59 = a1[1];
          long long v47 = *(_OWORD *)v59;
          *(_OWORD *)&v59[16] = v46;
          long long v49 = *(long long *)((char *)a2 + 28);
          long long v50 = a2[1];
          *a1 = *a2;
          a1[1] = v50;
          *(long long *)((char *)a1 + 28) = v49;
          *a2 = v48;
          a2[1] = v47;
          double result = *(double *)&v59[12];
          *(long long *)((char *)a2 + 28) = *(_OWORD *)&v59[12];
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(long long *a1, long long *a2, unsigned int (**a3)(void, void))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      size_t v8 = *a3;
      long long v9 = *(a2 - 2);
      v38[0] = *(a2 - 3);
      v38[1] = v9;
      v38[2] = *(a2 - 1);
      long long v10 = a1[1];
      v37[0] = *a1;
      v37[1] = v10;
      v37[2] = a1[2];
      if (v8(v38, v37))
      {
        long long v11 = a2 - 3;
        long long v12 = a1[2];
        long long v14 = *a1;
        *(_OWORD *)long long v40 = a1[1];
        long long v13 = *(_OWORD *)v40;
        *(_OWORD *)&v40[16] = v12;
        long long v15 = *(long long *)((char *)a2 - 20);
        long long v16 = *(a2 - 2);
        *a1 = *(a2 - 3);
        a1[1] = v16;
        *(long long *)((char *)a1 + 28) = v15;
        *long long v11 = v14;
        v11[1] = v13;
        *(long long *)((char *)v11 + 28) = *(_OWORD *)&v40[12];
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a2 - 3, a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a1 + 6, a2 - 3, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a1 + 6, a1 + 9, a2 - 3, a3);
      return 1;
    default:
      long long v17 = a1 + 6;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a1 + 6, a3);
      long long v18 = a1 + 9;
      if (a1 + 9 == a2) {
        return 1;
      }
      uint64_t v19 = 0;
      int v20 = 0;
      break;
  }
  while (1)
  {
    long long v21 = *a3;
    long long v22 = v18[1];
    v36[0] = *v18;
    v36[1] = v22;
    void v36[2] = v18[2];
    long long v23 = *v17;
    long long v24 = v17[2];
    v35[1] = v17[1];
    v35[2] = v24;
    v35[0] = v23;
    if (v21(v36, v35))
    {
      long long v25 = v18[1];
      long long v39 = *v18;
      *(_OWORD *)long long v40 = v25;
      *(_OWORD *)&v40[16] = v18[2];
      uint64_t v26 = v19;
      while (1)
      {
        long long v27 = (long long *)((char *)a1 + v26);
        long long v28 = *(long long *)((char *)a1 + v26 + 112);
        v27[9] = *(long long *)((char *)a1 + v26 + 96);
        v27[10] = v28;
        *(_OWORD *)((char *)v27 + 172) = *(long long *)((char *)a1 + v26 + 124);
        if (v26 == -96) {
          break;
        }
        long long v29 = *a3;
        v34[0] = v39;
        v34[1] = *(_OWORD *)v40;
        v34[2] = *(_OWORD *)&v40[16];
        long long v30 = v27[4];
        v33[0] = v27[3];
        v33[1] = v30;
        v33[2] = v27[5];
        v26 -= 48;
        if ((((uint64_t (*)(_OWORD *, _OWORD *))v29)(v34, v33) & 1) == 0)
        {
          long long v31 = (long long *)((char *)a1 + v26 + 144);
          goto LABEL_12;
        }
      }
      long long v31 = a1;
LABEL_12:
      long long v32 = *(_OWORD *)v40;
      long long *v31 = v39;
      v31[1] = v32;
      *(long long *)((char *)v31 + 28) = *(_OWORD *)&v40[12];
      if (++v20 == 8) {
        return v18 + 3 == a2;
      }
    }
    long long v17 = v18;
    v19 += 48;
    v18 += 3;
    if (v18 == a2) {
      return 1;
    }
  }
}

void sanitizeAllFrames(void **a1, void *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3 != a4)
  {
    uint64_t v7 = a3;
    long long v10 = 0;
    double v11 = (double)a5;
    double v12 = (double)a6;
    while (1)
    {
      double v14 = *(double *)v7;
      double v13 = *(double *)(v7 + 8);
      long long v15 = *(_OWORD *)(v7 + 32);
      long long v41 = *(_OWORD *)(v7 + 16);
      long long v42 = v15;
      uint64_t v16 = a2[1];
      if (a2[2] != v16) {
        break;
      }
LABEL_17:
      long long v24 = (double *)a1[2];
      if (v10 >= v24)
      {
        uint64_t v26 = (double *)*a1;
        unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * (((char *)v10 - (unsigned char *)*a1) >> 4);
        unint64_t v28 = v27 + 1;
        if (v27 + 1 > 0x555555555555555) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * (((char *)v24 - (char *)v26) >> 4);
        if (2 * v29 > v28) {
          unint64_t v28 = 2 * v29;
        }
        if (v29 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v30 = 0x555555555555555;
        }
        else {
          unint64_t v30 = v28;
        }
        if (v30) {
          unint64_t v30 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::vector<BOOL>>>>(v30);
        }
        else {
          uint64_t v31 = 0;
        }
        unint64_t v32 = v30 + 48 * v27;
        *(double *)unint64_t v32 = v14;
        *(double *)(v32 + 8) = v13;
        long long v33 = v42;
        *(_OWORD *)(v32 + 16) = v41;
        *(_OWORD *)(v32 + 32) = v33;
        if (v10 == v26)
        {
          unint64_t v37 = v30 + 48 * v27;
        }
        else
        {
          unint64_t v34 = v30 + 48 * v27;
          do
          {
            long long v35 = *((_OWORD *)v10 - 3);
            long long v36 = *((_OWORD *)v10 - 2);
            unint64_t v37 = v34 - 48;
            *(_OWORD *)(v34 - 20) = *(_OWORD *)((char *)v10 - 20);
            *(_OWORD *)(v34 - 48) = v35;
            *(_OWORD *)(v34 - 32) = v36;
            v10 -= 6;
            v34 -= 48;
          }
          while (v10 != v26);
        }
        long long v10 = (double *)(v32 + 48);
        *a1 = (void *)v37;
        a1[1] = (void *)(v32 + 48);
        a1[2] = (void *)(v30 + 48 * v31);
        if (v26) {
          operator delete(v26);
        }
      }
      else
      {
        *long long v10 = v14;
        v10[1] = v13;
        long long v25 = v42;
        *((_OWORD *)v10 + 1) = v41;
        *((_OWORD *)v10 + 2) = v25;
        v10 += 6;
      }
      a1[1] = v10;
LABEL_36:
      v7 += 48;
      if (v7 == a4) {
        return;
      }
    }
    unint64_t v17 = a2[4];
    long long v18 = (void *)(v16 + 8 * (v17 / 0xAA));
    unint64_t v19 = *v18 + 24 * (v17 % 0xAA);
    unint64_t v20 = *(void *)(v16 + 8 * ((a2[5] + v17) / 0xAA)) + 24 * ((a2[5] + v17) % 0xAA);
    while (1)
    {
      if (v19 == v20) {
        goto LABEL_17;
      }
      long long v38 = 0;
      long long v39 = 0;
      uint64_t v40 = 0;
      std::vector<CGPointWithPts>::__init_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>(&v38, *(const void **)v19, *(void *)(v19 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v19 + 8) - *(void *)v19) >> 4));
      long long v21 = v38;
      if (v38 == v39) {
        break;
      }
      while (vabdd_f64(*v21, v14) >= v11 || vabdd_f64(v21[1], v13) >= v12)
      {
        v21 += 6;
        if (v21 == v39) {
          goto LABEL_10;
        }
      }
      int v22 = 0;
      if (v38) {
        goto LABEL_11;
      }
LABEL_12:
      if (!v22) {
        goto LABEL_36;
      }
      v19 += 24;
      if (v19 - *v18 == 4080)
      {
        unint64_t v23 = v18[1];
        ++v18;
        unint64_t v19 = v23;
      }
    }
LABEL_10:
    int v22 = 1;
    if (!v38) {
      goto LABEL_12;
    }
LABEL_11:
    operator delete(v38);
    goto LABEL_12;
  }
}

void sub_1A3FC0F70(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<CGPointWithPts>::__init_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    BOOL result = std::vector<CGPointWithPts>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8 - 4);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A3FC0FFC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<CGPointWithPts>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  }
  BOOL result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::vector<BOOL>>>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

void sub_1A3FC46AC(_Unwind_Exception *a1)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

char *std::vector<CGPointWithPts>::__assign_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  long long v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 4) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 > 0x555555555555555) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x555555555555555;
    }
    else {
      unint64_t v12 = v11;
    }
    BOOL result = std::vector<CGPointWithPts>::__vallocate[abi:ne180100](v7, v12);
    double v14 = (char *)v7[1];
    double v13 = (void **)(v7 + 1);
    long long v9 = v14;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 4;
      unint64_t v19 = v9;
      unint64_t v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  double v13 = (void **)(result + 8);
  long long v15 = (unsigned char *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 4) >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * ((v15 - v9) >> 4)];
  if (v15 != v9)
  {
    BOOL result = (char *)memmove(*(void **)result, __src, v15 - v9 - 4);
    long long v9 = (char *)*v13;
  }
  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 4;
    unint64_t v19 = v9;
    unint64_t v20 = v16;
LABEL_18:
    BOOL result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *double v13 = &v9[v17];
  return result;
}

void sub_1A3FC4B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::__function::__value_func<std::vector<double> ()(double)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void InternalObservedParabola::InternalObservedParabola(InternalObservedParabola *this)
{
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 12) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((void *)this + 15) = 0;
  long long v2 = *MEMORY[0x1E4F1DAD8];
  *((_OWORD *)this + 8) = xmmword_1A410C300;
  *((_OWORD *)this + 9) = v2;
  *((_OWORD *)this + 11) = xmmword_1A410C310;
  *((_DWORD *)this + 40) = 0;
  *((_OWORD *)this + 12) = xmmword_1A410C320;
  *((_OWORD *)this + 13) = xmmword_1A410C330;
  *((_OWORD *)this + 14) = xmmword_1A410C340;
  *((_OWORD *)this + 15) = xmmword_1A410A0C0;
  *((_OWORD *)this + 16) = xmmword_1A410C350;
  *((_OWORD *)this + 17) = xmmword_1A410C330;
  *((_OWORD *)this + 18) = xmmword_1A410C340;
  *((_OWORD *)this + 19) = xmmword_1A410A0C0;
  *((_OWORD *)this + 20) = xmmword_1A410C350;
  *((_OWORD *)this + 21) = xmmword_1A410C330;
  *((_OWORD *)this + 22) = xmmword_1A410C340;
  *((_OWORD *)this + 23) = xmmword_1A410C360;
  *((_OWORD *)this + 24) = xmmword_1A410C370;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = xmmword_1A410C380;
  *((_OWORD *)this + 28) = xmmword_1A410C390;
  *((_OWORD *)this + 29) = xmmword_1A410C3A0;
  *((_OWORD *)this + 30) = xmmword_1A410C3B0;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = xmmword_1A410A0C0;
  *((_OWORD *)this + 37) = xmmword_1A410C350;
  *((_OWORD *)this + 38) = xmmword_1A410C330;
  *((_OWORD *)this + 39) = xmmword_1A410C340;
  *(void *)((char *)this + 717) = 0;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 40) = 0u;
  int v3 = 0;
  std::vector<float>::vector((void *)this + 91, 4uLL, &v3);
  *((void *)this + 94) = 0;
}

void sub_1A3FC4D70(_Unwind_Exception *a1)
{
  KalmanFilter::~KalmanFilter(v2);
  BOOL v5 = *(void **)(v1 + 104);
  if (v5)
  {
    *(void *)(v1 + 112) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(v1 + 80);
  if (v6)
  {
    *(void *)(v1 + 88) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 64) = v7;
    operator delete(v7);
  }
  uint64_t v8 = *(void **)(v1 + 8);
  if (v8)
  {
    *(void *)(v1 + 16) = v8;
    operator delete(v8);
  }

  _Unwind_Resume(a1);
}

float32x4_t KalmanFilter::updateMeasurementAndPredict(KalmanFilter *this, CGPoint a2)
{
  double y = a2.y;
  double x = a2.x;
  uint64_t v6 = (CGPoint *)*((void *)this + 61);
  unint64_t v5 = *((void *)this + 62);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = (CGPoint *)*((void *)this + 60);
    uint64_t v9 = v6 - v8;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    if (!v12) {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v13);
      uint64_t v8 = (CGPoint *)*((void *)this + 60);
      uint64_t v6 = (CGPoint *)*((void *)this + 61);
    }
    else
    {
      uint64_t v14 = 0;
    }
    long long v15 = (double *)(v13 + 16 * v9);
    unint64_t v16 = v13 + 16 * v14;
    *long long v15 = x;
    v15[1] = y;
    uint64_t v7 = (CGPoint *)(v15 + 2);
    if (v6 != v8)
    {
      do
      {
        *((CGPoint *)v15 - 1) = v6[-1];
        v15 -= 2;
        --v6;
      }
      while (v6 != v8);
      uint64_t v8 = (CGPoint *)*((void *)this + 60);
    }
    *((void *)this + 60) = v15;
    *((void *)this + 61) = v7;
    *((void *)this + 62) = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    CGPoint *v6 = a2;
    uint64_t v7 = v6 + 1;
  }
  uint64_t v17 = 0;
  *((void *)this + 61) = v7;
  long long v18 = *((_OWORD *)this + 20);
  simd_float4 v19 = *((simd_float4 *)this + 21);
  double v20 = x - *(float *)&v18;
  *((double *)this + 66) = v20;
  double v21 = y - *((float *)&v18 + 1);
  *((double *)this + 67) = v21;
  float32x4_t v23 = *(float32x4_t *)this;
  float32x4_t v22 = *((float32x4_t *)this + 1);
  float32x4_t v25 = *((float32x4_t *)this + 2);
  float32x4_t v24 = *((float32x4_t *)this + 3);
  int32x4_t v26 = vzip1q_s32(*(int32x4_t *)this, (int32x4_t)v25);
  unint64_t v27 = (const float *)((char *)this + 64);
  float32x4x4_t v127 = vld4q_f32(v27);
  float32x4x4_t v120 = v127;
  int32x4_t v28 = vzip1q_s32((int32x4_t)v22, (int32x4_t)v24);
  int32x4_t v29 = vzip1q_s32(v26, v28);
  float32x4_t v119 = *((float32x4_t *)this + 29);
  simd_float4 v30 = *((simd_float4 *)this + 22);
  v127.val[0] = (float32x4_t)*((_OWORD *)this + 23);
  v127.val[1] = (float32x4_t)*((_OWORD *)this + 24);
  v121.columns[0] = v19;
  v121.columns[1] = v30;
  v121.columns[2] = (simd_float4)v127.val[0];
  v121.columns[3] = (simd_float4)v127.val[1];
  do
  {
    *(float32x4_t *)((char *)&v122 + v17 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v23, COERCE_FLOAT(*(_OWORD *)&v121.columns[v17])), v22, *(float32x2_t *)v121.columns[v17].f32, 1), v25, (float32x4_t)v121.columns[v17], 2), v24, (float32x4_t)v121.columns[v17], 3);
    ++v17;
  }
  while (v17 != 4);
  uint64_t v31 = 0;
  int32x4_t v32 = vzip2q_s32((int32x4_t)v23, (int32x4_t)v25);
  int32x4_t v33 = vzip2q_s32((int32x4_t)v22, (int32x4_t)v24);
  int32x4_t v34 = vzip1q_s32(v32, v33);
  int32x4_t v35 = vzip2q_s32(v26, v28);
  int32x4_t v36 = vzip2q_s32(v32, v33);
  float32x4_t v37 = v122;
  float32x4_t v38 = v123;
  float32x4_t v39 = v124;
  float32x4_t v40 = v125;
  v121.columns[0] = (simd_float4)v29;
  v121.columns[1] = (simd_float4)v35;
  float32x4_t v115 = (float32x4_t)v35;
  float32x4_t v116 = (float32x4_t)v34;
  v121.columns[2] = (simd_float4)v34;
  v121.columns[3] = (simd_float4)v36;
  float32x4_t v117 = (float32x4_t)v36;
  do
  {
    *(float32x4_t *)((char *)&v122 + v31 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)&v121.columns[v31])), v38, *(float32x2_t *)v121.columns[v31].f32, 1), v39, (float32x4_t)v121.columns[v31], 2), v40, (float32x4_t)v121.columns[v31], 3);
    ++v31;
  }
  while (v31 != 4);
  uint64_t v41 = 0;
  float32x4_t v42 = vaddq_f32(v122, *((float32x4_t *)this + 12));
  float32x4_t v43 = vaddq_f32(v123, *((float32x4_t *)this + 13));
  float32x4_t v44 = vaddq_f32(v124, *((float32x4_t *)this + 14));
  float32x4_t v45 = vaddq_f32(v125, *((float32x4_t *)this + 15));
  float32x4_t v46 = *((float32x4_t *)this + 8);
  float32x4_t v47 = *((float32x4_t *)this + 9);
  float32x4_t v48 = *((float32x4_t *)this + 10);
  float32x4_t v49 = *((float32x4_t *)this + 11);
  v121.columns[0] = (simd_float4)v42;
  v121.columns[1] = (simd_float4)v43;
  v121.columns[2] = (simd_float4)v44;
  v121.columns[3] = (simd_float4)v45;
  do
  {
    *(float32x4_t *)((char *)&v122 + v41 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v46, COERCE_FLOAT(*(_OWORD *)&v121.columns[v41])), v47, *(float32x2_t *)v121.columns[v41].f32, 1), v48, (float32x4_t)v121.columns[v41], 2), v49, (float32x4_t)v121.columns[v41], 3);
    ++v41;
  }
  while (v41 != 4);
  uint64_t v50 = 0;
  float32x4_t v51 = v122;
  float32x4_t v52 = v123;
  float32x4_t v53 = v124;
  float32x4_t v54 = v125;
  int32x4_t v55 = vzip1q_s32((int32x4_t)v46, (int32x4_t)v48);
  simd_float4 v105 = (simd_float4)v49;
  simd_float4 v106 = (simd_float4)v48;
  simd_float4 v103 = (simd_float4)v47;
  simd_float4 v104 = (simd_float4)v46;
  int32x4_t v56 = vzip2q_s32((int32x4_t)v46, (int32x4_t)v48);
  int32x4_t v57 = vzip1q_s32((int32x4_t)v47, (int32x4_t)v49);
  int32x4_t v58 = vzip2q_s32((int32x4_t)v47, (int32x4_t)v49);
  int32x4_t v59 = vzip1q_s32(v55, v57);
  int32x4_t v60 = vzip2q_s32(v55, v57);
  int32x4_t v61 = vzip1q_s32(v56, v58);
  int32x4_t v62 = vzip2q_s32(v56, v58);
  v121.columns[0] = (simd_float4)v59;
  v121.columns[1] = (simd_float4)v60;
  v121.columns[2] = (simd_float4)v61;
  v121.columns[3] = (simd_float4)v62;
  do
  {
    *(float32x4_t *)((char *)&v122 + v50 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v51, COERCE_FLOAT(*(_OWORD *)&v121.columns[v50])), v52, *(float32x2_t *)v121.columns[v50].f32, 1), v53, (float32x4_t)v121.columns[v50], 2), v54, (float32x4_t)v121.columns[v50], 3);
    ++v50;
  }
  while (v50 != 4);
  float32x4_t v118 = (float32x4_t)v29;
  uint64_t v63 = 0;
  v66.columns[2] = (simd_float4)v124;
  v66.columns[3] = (simd_float4)v125;
  float32x4_t v64 = *((float32x4_t *)this + 18);
  float32x4_t v65 = *((float32x4_t *)this + 19);
  v66.columns[0] = (simd_float4)vaddq_f32(v122, *((float32x4_t *)this + 16));
  v66.columns[1] = (simd_float4)vaddq_f32(v123, *((float32x4_t *)this + 17));
  float32x4_t v111 = (float32x4_t)v59;
  float32x4_t v112 = (float32x4_t)v60;
  v121.columns[0] = (simd_float4)v59;
  v121.columns[1] = (simd_float4)v60;
  float32x4_t v113 = (float32x4_t)v61;
  float32x4_t v114 = (float32x4_t)v62;
  v121.columns[2] = (simd_float4)v61;
  v121.columns[3] = (simd_float4)v62;
  do
  {
    *(float32x4_t *)((char *)&v122 + v63 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v42, COERCE_FLOAT(*(_OWORD *)&v121.columns[v63])), v43, *(float32x2_t *)v121.columns[v63].f32, 1), v44, (float32x4_t)v121.columns[v63], 2), v45, (float32x4_t)v121.columns[v63], 3);
    ++v63;
  }
  while (v63 != 4);
  simd_float4 v107 = (simd_float4)v45;
  simd_float4 v108 = (simd_float4)v44;
  simd_float4 v109 = (simd_float4)v43;
  simd_float4 v110 = (simd_float4)v42;
  v66.columns[2] = (simd_float4)vaddq_f32((float32x4_t)v66.columns[2], v64);
  v66.columns[3] = (simd_float4)vaddq_f32((float32x4_t)v66.columns[3], v65);
  float32x4_t v101 = v122;
  float32x4_t v102 = v123;
  float32x4_t v99 = v125;
  float32x4_t v100 = v124;
  simd_float4x4 v126 = __invert_f4(v66);
  uint64_t v67 = 0;
  simd_float4x4 v121 = v126;
  do
  {
    *(float32x4_t *)((char *)&v122 + v67 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v101, COERCE_FLOAT(*(_OWORD *)&v121.columns[v67])), v102, *(float32x2_t *)v121.columns[v67].f32, 1), v100, (float32x4_t)v121.columns[v67], 2), v99, (float32x4_t)v121.columns[v67], 3);
    ++v67;
  }
  while (v67 != 4);
  uint64_t v68 = 0;
  float32x4_t v69 = v122;
  float32x4_t v70 = v123;
  float32x4_t v71 = v124;
  float32x4_t v72 = v125;
  float32x4_t v73 = *((float32x4_t *)this + 25);
  float32x4_t v74 = *((float32x4_t *)this + 26);
  float32x4_t v75 = *((float32x4_t *)this + 27);
  float32x4_t v76 = *((float32x4_t *)this + 28);
  v121.columns[0] = v104;
  v121.columns[1] = v103;
  v121.columns[2] = v106;
  v121.columns[3] = v105;
  do
  {
    *(float32x4_t *)((char *)&v122 + v68 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v69, COERCE_FLOAT(*(_OWORD *)&v121.columns[v68])), v70, *(float32x2_t *)v121.columns[v68].f32, 1), v71, (float32x4_t)v121.columns[v68], 2), v72, (float32x4_t)v121.columns[v68], 3);
    ++v68;
  }
  while (v68 != 4);
  uint64_t v77 = 0;
  float32x4_t v78 = vsubq_f32(v73, v122);
  float32x4_t v79 = vsubq_f32(v74, v123);
  float32x4_t v80 = vsubq_f32(v75, v124);
  float32x4_t v81 = vsubq_f32(v76, v125);
  v121.columns[0] = v110;
  v121.columns[1] = v109;
  v121.columns[2] = v108;
  v121.columns[3] = v107;
  do
  {
    *(float32x4_t *)((char *)&v122 + v77 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v78, COERCE_FLOAT(*(_OWORD *)&v121.columns[v77])), v79, *(float32x2_t *)v121.columns[v77].f32, 1), v80, (float32x4_t)v121.columns[v77], 2), v81, (float32x4_t)v121.columns[v77], 3);
    ++v77;
  }
  while (v77 != 4);
  float v82 = x;
  float v83 = y;
  float v84 = v20;
  float v85 = v21;
  v86.i64[0] = __PAIR64__(LODWORD(v83), LODWORD(v82));
  v86.i64[1] = __PAIR64__(LODWORD(v85), LODWORD(v84));
  float32x4_t v87 = vaddq_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v118, v82), v115, v83), v116, v84), v117, v85), vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v120.val[0], v119.f32[0]), v120.val[1], *(float32x2_t *)v119.f32, 1), v120.val[2], v119, 2), v120.val[3], v119, 3));
  int32x4_t v88 = vzip2q_s32((int32x4_t)v69, (int32x4_t)v71);
  int32x4_t v89 = vzip2q_s32((int32x4_t)v70, (int32x4_t)v72);
  float32x4_t v90 = vsubq_f32(v86, vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v111, v87.f32[0]), v112, *(float32x2_t *)v87.f32, 1), v113, v87, 2), v114, v87, 3));
  int32x4_t v91 = vzip1q_s32((int32x4_t)v69, (int32x4_t)v71);
  int32x4_t v92 = vzip1q_s32((int32x4_t)v70, (int32x4_t)v72);
  float32x4_t v93 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)vzip1q_s32(v91, v92), v90.f32[0]), (float32x4_t)vzip2q_s32(v91, v92), *(float32x2_t *)v90.f32, 1), (float32x4_t)vzip1q_s32(v88, v89), v90, 2), (float32x4_t)vzip2q_s32(v88, v89), v90, 3);
  float32x4_t v94 = v122;
  float32x4_t v95 = v123;
  float32x4_t v96 = v124;
  float32x4_t v97 = v125;
  float32x4_t result = vaddq_f32(v87, v93);
  *((float32x4_t *)this + 20) = result;
  *((float32x4_t *)this + 21) = v94;
  *((float32x4_t *)this + 22) = v95;
  *((float32x4_t *)this + 23) = v96;
  *((float32x4_t *)this + 24) = v97;
  return result;
}

uint64_t *std::__tree<std::__value_type<int,InternalObservedParabola>,std::__map_value_compare<int,std::__value_type<int,InternalObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,InternalObservedParabola>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = (uint64_t)(a1 + 1);
  unint64_t v5 = a1[1];
  uint64_t v7 = (uint64_t *)(a1 + 1);
  uint64_t v8 = (uint64_t *)(a1 + 1);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        unint64_t v5 = (uint64_t *)*v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      unint64_t v5 = (uint64_t *)v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    unint64_t v10 = operator new(0x330uLL);
    v13[0] = (uint64_t)v10;
    v13[1] = v6;
    char v14 = 0;
    v10[8] = *a3;
    bzero(v10 + 12, 0x300uLL);
    InternalObservedParabola::InternalObservedParabola((InternalObservedParabola *)(v10 + 12));
    char v14 = 1;
    *(void *)unint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = v8;
    uint64_t *v7 = (uint64_t)v10;
    uint64_t v11 = (uint64_t *)**a1;
    if (v11)
    {
      *a1 = v11;
      unint64_t v10 = (_DWORD *)*v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], (uint64_t *)v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    uint64_t v8 = (uint64_t *)v13[0];
    v13[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>>>>::reset[abi:ne180100](v13);
  }
  return v8;
}

void sub_1A3FC5530(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>>>>::reset[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t InternalObservedParabola::operator=(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)a1, *(id *)a2);
  if (a1 == a2)
  {
    long long v8 = *(_OWORD *)(a2 + 128);
    long long v9 = *(_OWORD *)(a2 + 144);
    *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 128) = v8;
    *(_OWORD *)(a1 + 144) = v9;
    memcpy((void *)(a1 + 176), (const void *)(a2 + 176), 0x1E0uLL);
    *(_OWORD *)(a1 + 704) = *(_OWORD *)(a2 + 704);
    int v10 = *(_DWORD *)(a2 + 720);
    *(unsigned char *)(a1 + 724) = *(unsigned char *)(a2 + 724);
    *(_DWORD *)(a1 + 720) = v10;
  }
  else
  {
    std::vector<CGPointWithPts>::__assign_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>((char *)(a1 + 8), *(char **)(a2 + 8), *(void *)(a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 4));
    long long v4 = *(_OWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v4;
    std::vector<CGPointWithPts>::__assign_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>((char *)(a1 + 56), *(char **)(a2 + 56), *(void *)(a2 + 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 4));
    std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>((char *)(a1 + 80), *(char **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 3);
    std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>((char *)(a1 + 104), *(char **)(a2 + 104), *(void *)(a2 + 112), (uint64_t)(*(void *)(a2 + 112) - *(void *)(a2 + 104)) >> 3);
    long long v5 = *(_OWORD *)(a2 + 128);
    long long v6 = *(_OWORD *)(a2 + 144);
    *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 128) = v5;
    *(_OWORD *)(a1 + 144) = v6;
    memcpy((void *)(a1 + 176), (const void *)(a2 + 176), 0x1E0uLL);
    std::vector<CGPoint>::__assign_with_size[abi:ne180100]<CGPoint*,CGPoint*>((char *)(a1 + 656), *(char **)(a2 + 656), *(void *)(a2 + 664), (uint64_t)(*(void *)(a2 + 664) - *(void *)(a2 + 656)) >> 4);
    std::vector<CGPoint>::__assign_with_size[abi:ne180100]<CGPoint*,CGPoint*>((char *)(a1 + 680), *(char **)(a2 + 680), *(void *)(a2 + 688), (uint64_t)(*(void *)(a2 + 688) - *(void *)(a2 + 680)) >> 4);
    *(_OWORD *)(a1 + 704) = *(_OWORD *)(a2 + 704);
    int v7 = *(_DWORD *)(a2 + 720);
    *(unsigned char *)(a1 + 724) = *(unsigned char *)(a2 + 724);
    *(_DWORD *)(a1 + 720) = v7;
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 728), *(char **)(a2 + 728), *(void *)(a2 + 736), (uint64_t)(*(void *)(a2 + 736) - *(void *)(a2 + 728)) >> 2);
  }
  *(void *)(a1 + 752) = *(void *)(a2 + 752);
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>>>>::reset[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    if (*((unsigned char *)a1 + 16)) {
      InternalObservedParabola::~InternalObservedParabola((InternalObservedParabola *)(v1 + 48));
    }
    operator delete((void *)v1);
  }
}

void KalmanFilter::~KalmanFilter(KalmanFilter *this)
{
  long long v2 = (void *)*((void *)this + 63);
  if (v2)
  {
    *((void *)this + 64) = v2;
    operator delete(v2);
  }
  int v3 = (void *)*((void *)this + 60);
  if (v3)
  {
    *((void *)this + 61) = v3;
    operator delete(v3);
  }
}

uint64_t std::function<std::vector<double> ()(double)>::operator()(double a1, uint64_t a2, uint64_t a3)
{
  double v4 = a1;
  if (!a3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, double *))(*(void *)a3 + 48))(a3, &v4);
}

void *std::__function::__value_func<std::vector<double> ()(double)>::~__value_func[abi:ne180100](void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<int,ObservedParabola>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,ObservedParabola>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<int const,ObservedParabola>,0>(v1 + 4);
    }
    operator delete(v1);
  }
}

void *std::vector<double>::vector(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<long long>::__vallocate[abi:ne180100](a1, a2);
    long long v6 = (void *)a1[1];
    int v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1A3FC58F4(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::deque<std::vector<CGPointWithPts>>::push_back(void *a1, uint64_t a2)
{
  double v4 = (char *)a1[2];
  long long v5 = (char *)a1[1];
  uint64_t v6 = v4 - v5;
  if (v4 == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 170 * ((v4 - v5) >> 3) - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 >= 0xAA)
    {
      a1[4] = v8 - 170;
      uint64_t v12 = *(void *)v5;
      int v10 = v5 + 8;
      uint64_t v11 = v12;
      a1[1] = v10;
      if ((char *)a1[3] == v4)
      {
        uint64_t v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v4 == (char *)*a1) {
            unint64_t v41 = 1;
          }
          else {
            unint64_t v41 = (uint64_t)&v4[-*a1] >> 2;
          }
          float32x4_t v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v41);
          float32x4_t v44 = &v42[8 * (v41 >> 2)];
          float32x4_t v45 = (uint64_t *)a1[1];
          double v4 = v44;
          uint64_t v46 = a1[2] - (void)v45;
          if (v46)
          {
            double v4 = &v44[v46 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v47 = 8 * (v46 >> 3);
            float32x4_t v48 = &v42[8 * (v41 >> 2)];
            do
            {
              uint64_t v49 = *v45++;
              *(void *)float32x4_t v48 = v49;
              v48 += 8;
              v47 -= 8;
            }
            while (v47);
          }
          uint64_t v50 = (char *)*a1;
          *a1 = v42;
          a1[1] = v44;
          a1[2] = v4;
          a1[3] = &v42[8 * v43];
          if (v50)
          {
            operator delete(v50);
            double v4 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v14 = v13 >> 3;
          BOOL v15 = v13 >> 3 < -1;
          uint64_t v16 = (v13 >> 3) + 2;
          if (v15) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14 + 1;
          }
          uint64_t v18 = -(v17 >> 1);
          uint64_t v19 = v17 >> 1;
          double v20 = &v10[-8 * v19];
          int64_t v21 = v4 - v10;
          if (v4 == v10)
          {
            float32x4_t v22 = v4;
          }
          else
          {
            memmove(&v10[-8 * v19], v10, v4 - v10);
            float32x4_t v22 = (char *)a1[1];
          }
          double v4 = &v20[v21];
          a1[1] = &v22[8 * v18];
          a1[2] = &v20[v21];
        }
      }
      *(void *)double v4 = v11;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      long long v5 = (char *)a1[1];
      unint64_t v9 = a1[5] + a1[4];
      goto LABEL_84;
    }
    uint64_t v23 = v6 >> 3;
    float32x4_t v24 = (char *)a1[3];
    float32x4_t v25 = (char *)*a1;
    uint64_t v26 = (uint64_t)&v24[-*a1];
    if (v6 >> 3 < (unint64_t)(v26 >> 3))
    {
      unint64_t v27 = operator new(0xFF0uLL);
      int32x4_t v28 = v27;
      if (v24 == v4)
      {
        if (v25 == v5)
        {
          if (v4 == v5) {
            unint64_t v51 = 1;
          }
          else {
            unint64_t v51 = v26 >> 2;
          }
          uint64_t v52 = 2 * v51;
          float32x4_t v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v51);
          long long v5 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
          int32x4_t v55 = (uint64_t *)a1[1];
          int32x4_t v56 = v5;
          uint64_t v57 = a1[2] - (void)v55;
          if (v57)
          {
            int32x4_t v56 = &v5[v57 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v58 = 8 * (v57 >> 3);
            int32x4_t v59 = v5;
            do
            {
              uint64_t v60 = *v55++;
              *(void *)int32x4_t v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          int32x4_t v61 = (char *)*a1;
          *a1 = v53;
          a1[1] = v5;
          a1[2] = v56;
          a1[3] = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            long long v5 = (char *)a1[1];
          }
        }
        *((void *)v5 - 1) = v28;
        int32x4_t v62 = (char *)a1[1];
        uint64_t v63 = (char *)a1[2];
        a1[1] = v62 - 8;
        uint64_t v64 = *((void *)v62 - 1);
        a1[1] = v62;
        if (v63 == (char *)a1[3])
        {
          uint64_t v65 = (uint64_t)&v62[-*a1];
          if ((unint64_t)v62 <= *a1)
          {
            if (v63 == (char *)*a1) {
              unint64_t v98 = 1;
            }
            else {
              unint64_t v98 = (uint64_t)&v63[-*a1] >> 2;
            }
            float32x4_t v99 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v98);
            float32x4_t v101 = &v99[8 * (v98 >> 2)];
            float32x4_t v102 = (uint64_t *)a1[1];
            uint64_t v63 = v101;
            uint64_t v103 = a1[2] - (void)v102;
            if (v103)
            {
              uint64_t v63 = &v101[v103 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v104 = 8 * (v103 >> 3);
              simd_float4 v105 = &v99[8 * (v98 >> 2)];
              do
              {
                uint64_t v106 = *v102++;
                *(void *)simd_float4 v105 = v106;
                v105 += 8;
                v104 -= 8;
              }
              while (v104);
            }
            simd_float4 v107 = (char *)*a1;
            *a1 = v99;
            a1[1] = v101;
            a1[2] = v63;
            a1[3] = &v99[8 * v100];
            if (v107)
            {
              operator delete(v107);
              uint64_t v63 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v66 = v65 >> 3;
            BOOL v15 = v65 >> 3 < -1;
            uint64_t v67 = (v65 >> 3) + 2;
            if (v15) {
              uint64_t v68 = v67;
            }
            else {
              uint64_t v68 = v66 + 1;
            }
            uint64_t v69 = -(v68 >> 1);
            uint64_t v70 = v68 >> 1;
            float32x4_t v71 = &v62[-8 * v70];
            int64_t v72 = v63 - v62;
            if (v63 != v62)
            {
              memmove(&v62[-8 * v70], v62, v63 - v62);
              int32x4_t v62 = (char *)a1[1];
            }
            uint64_t v63 = &v71[v72];
            a1[1] = &v62[8 * v69];
            a1[2] = &v71[v72];
          }
        }
        *(void *)uint64_t v63 = v64;
      }
      else
      {
        *(void *)double v4 = v27;
      }
      goto LABEL_82;
    }
    if (v24 == v25) {
      unint64_t v29 = 1;
    }
    else {
      unint64_t v29 = v26 >> 2;
    }
    simd_float4 v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v29);
    uint64_t v32 = v31;
    int32x4_t v33 = &v30[8 * v23];
    *(void *)&long long v34 = v30;
    *((void *)&v34 + 1) = v33;
    long long v111 = v34;
    int32x4_t v35 = operator new(0xFF0uLL);
    *(void *)&long long v36 = v33;
    *((void *)&v36 + 1) = &v30[8 * v32];
    if (v23 == v32)
    {
      uint64_t v37 = 8 * v23;
      *(void *)&long long v38 = v111;
      if (v6 >= 1)
      {
        uint64_t v39 = v37 >> 3;
        if (v39 >= -1) {
          unint64_t v40 = v39 + 1;
        }
        else {
          unint64_t v40 = v39 + 2;
        }
        v33 -= 8 * (v40 >> 1);
        *(void *)&long long v36 = v33;
        *((void *)&v38 + 1) = v33;
        goto LABEL_56;
      }
      uint64_t v73 = v37 >> 2;
      if (v4 == v5) {
        unint64_t v74 = 1;
      }
      else {
        unint64_t v74 = v73;
      }
      float32x4_t v75 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v74);
      int32x4_t v33 = &v75[8 * (v74 >> 2)];
      *(void *)&long long v38 = v75;
      *((void *)&v38 + 1) = v33;
      *(void *)&long long v36 = v33;
      *((void *)&v36 + 1) = &v75[8 * v76];
      if (!v30) {
        goto LABEL_56;
      }
      long long v108 = v36;
      long long v111 = v38;
      operator delete(v30);
      long long v36 = v108;
    }
    long long v38 = v111;
LABEL_56:
    *(void *)int32x4_t v33 = v35;
    *(void *)&long long v36 = v36 + 8;
    for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
    {
      float32x4_t v78 = (void *)*((void *)&v38 + 1);
      if (*((void *)&v38 + 1) == (void)v38)
      {
        float32x4_t v80 = (unsigned char *)v36;
        if ((unint64_t)v36 >= *((void *)&v36 + 1))
        {
          if (*((void *)&v36 + 1) == *((void *)&v38 + 1)) {
            unint64_t v85 = 1;
          }
          else {
            unint64_t v85 = (uint64_t)(*((void *)&v36 + 1) - *((void *)&v38 + 1)) >> 2;
          }
          float32x4_t v86 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v85);
          float32x4_t v79 = &v86[(2 * v85 + 6) & 0xFFFFFFFFFFFFFFF8];
          int32x4_t v88 = v79;
          uint64_t v89 = v80 - (unsigned char *)v78;
          if (v80 != (unsigned char *)v78)
          {
            int32x4_t v88 = &v79[v89 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v90 = 8 * (v89 >> 3);
            int32x4_t v91 = v79;
            int32x4_t v92 = v78;
            do
            {
              uint64_t v93 = *v92++;
              *(void *)int32x4_t v91 = v93;
              v91 += 8;
              v90 -= 8;
            }
            while (v90);
          }
          *(void *)&long long v38 = v86;
          *((void *)&v38 + 1) = v79;
          *(void *)&long long v36 = v88;
          *((void *)&v36 + 1) = &v86[8 * v87];
          if (v78)
          {
            long long v109 = v36;
            long long v113 = v38;
            operator delete(v78);
            long long v36 = v109;
            long long v38 = v113;
          }
        }
        else
        {
          uint64_t v81 = (uint64_t)(*((void *)&v36 + 1) - v36) >> 3;
          if (v81 >= -1) {
            uint64_t v82 = v81 + 1;
          }
          else {
            uint64_t v82 = v81 + 2;
          }
          uint64_t v83 = v82 >> 1;
          uint64_t v84 = v36 + 8 * (v82 >> 1);
          float32x4_t v79 = (char *)(v84 - (v36 - *((void *)&v38 + 1)));
          if ((void)v36 == *((void *)&v38 + 1))
          {
            float32x4_t v80 = (unsigned char *)*((void *)&v38 + 1);
          }
          else
          {
            uint64_t v110 = *((void *)&v36 + 1);
            uint64_t v112 = v38;
            memmove((void *)(v84 - (v36 - *((void *)&v38 + 1))), *((const void **)&v38 + 1), v36 - *((void *)&v38 + 1));
            *((void *)&v36 + 1) = v110;
            *(void *)&long long v38 = v112;
          }
          *((void *)&v38 + 1) = v79;
          *(void *)&long long v36 = &v80[8 * v83];
        }
      }
      else
      {
        float32x4_t v79 = (char *)*((void *)&v38 + 1);
      }
      uint64_t v94 = *(void *)(i - 8);
      *((void *)v79 - 1) = v94;
      *((void *)&v38 + 1) -= 8;
    }
    float32x4_t v95 = (char *)*a1;
    *(_OWORD *)a1 = v38;
    *((_OWORD *)a1 + 1) = v36;
    if (v95) {
      operator delete(v95);
    }
    goto LABEL_83;
  }
LABEL_84:
  float32x4_t v96 = (void *)(*(void *)&v5[8 * (v9 / 0xAA)] + 24 * (v9 % 0xAA));
  *float32x4_t v96 = 0;
  v96[1] = 0;
  v96[2] = 0;
  float32x4_t result = std::vector<CGPointWithPts>::__init_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>(v96, *(const void **)a2, *(void *)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4));
  ++a1[5];
  return result;
}

void sub_1A3FC5EA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11)
{
  operator delete(v11);
  if ((void)a11) {
    operator delete((void *)a11);
  }
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::classifyImage_Planar8(uint64_t a1@<X8>)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  exceptiounint64_t n = __cxa_allocate_exception(8uLL);
  *exceptiounint64_t n = 3967;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

void sub_1A3FC5F18(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::classifyImage_BGRA8888(uint64_t a1@<X8>)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  exceptiounint64_t n = __cxa_allocate_exception(8uLL);
  *exceptiounint64_t n = 3967;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

void sub_1A3FC5F74(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::classifyImage_RGBA8888(uint64_t a1@<X8>)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  exceptiounint64_t n = __cxa_allocate_exception(8uLL);
  *exceptiounint64_t n = 3967;
  __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
}

void sub_1A3FC5FD0(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::classifyDescriptorHandler(long long **this@<X0>, const vision::mod::ImageDescriptorBufferAbstract *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  memset(&v21, 0, sizeof(v21));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v21, this[1], this[2], 0xAAAAAAAAAAAAAAABLL * (((char *)this[2] - (char *)this[1]) >> 3));
  std::string::size_type size = v21.__r_.__value_.__l.__size_;
  uint64_t v6 = (long long *)v21.__r_.__value_.__r.__words[0];
  if (v21.__r_.__value_.__r.__words[0] != v21.__r_.__value_.__l.__size_)
  {
    uint64_t v8 = 0;
    do
    {
      unint64_t v9 = this[15];
      uint64_t v10 = *((void *)v9 + 5);
      uint64_t v11 = (const float *)*((void *)a2 + 7);
      uint64_t v12 = *((void *)v9 + 2);
      float v13 = cblas_sasum(v10, v11, 1);
      float v14 = cblas_snrm2(v10, v11, 1);
      BOOL v15 = (const float *)(v12 + 4 * v10 * v8);
      float v16 = cblas_sasum(v10, v15, 1);
      float v17 = cblas_snrm2(v10, v15, 1);
      float v18 = cblas_sdot(v10, v11, 1, v15, 1);
      float32x4_t v22 = v6;
      uint64_t v19 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (unsigned __int8 *)v6, &v22);
      float v20 = fmax((float)((float)((float)(v14 * v14) - (float)((float)(v13 * v13) / (float)(int)v10))* (float)((float)(v17 * v17) - (float)((float)(v16 * v16) / (float)(int)v10))), 0.000001);
      *((float *)v19 + 10) = 1.0
                           / (float)(expf((float)((float)(1.0 / sqrtf(v20))* (float)(v18 - (float)((float)(v13 * v16) / (float)(int)v10)))* -10.0)+ 1.0);
      ++v8;
      uint64_t v6 = (long long *)((char *)v6 + 24);
    }
    while (v6 != (long long *)size);
  }
  uint64_t v23 = &v21;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v23);
}

void sub_1A3FC61C8(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageClassifierGlimmer::setDescriptorProcessor(uint64_t a1, uint64_t *a2)
{
  long long v2 = *(void **)(a1 + 120);
  if (!v2)
  {
    exceptiounint64_t n = __cxa_allocate_exception(8uLL);
    uint64_t v28 = 3965;
    goto LABEL_27;
  }
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)v2[1];
  void *v2 = v6;
  v2[1] = v5;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  uint64_t v8 = *(void **)(a1 + 120);
  if (!*a2)
  {
    v8[5] = 0;
    return a1;
  }
  unint64_t v9 = (*(uint64_t (**)(void))(*(void *)*v8 + 128))();
  uint64_t v10 = *(void *)(a1 + 120);
  *(void *)(v10 + 40) = v9 >> 2;
  uint64_t v11 = (const char *)(v10 + 56);
  int v12 = *(char *)(v10 + 79);
  if (*(unsigned char *)(v10 + 48))
  {
    if (v12 < 0) {
      uint64_t v11 = *(const char **)v11;
    }
    float v13 = (unsigned char *)(v10 + 80);
    if (*(char *)(v10 + 103) < 0) {
      float v13 = *(unsigned char **)v13;
    }
    float v14 = fopen(v11, "rb");
    if (v14)
    {
      BOOL v15 = v14;
      v31.__r_.__value_.__r.__words[0] = 0;
      unint64_t v32 = 0;
      fseek(v14, 0, 0);
      unsigned __int8 v16 = BinSerializer_freadInBytes(v15, v13, &v31, &v32);
      float v17 = (void *)v31.__r_.__value_.__r.__words[0];
      if (v31.__r_.__value_.__r.__words[0] && v16 == 128)
      {
        vision::mod::ImageClassifierGlimmer::private_t::loadData((vision::mod::ImageClassifierGlimmer::private_t *)v10, v31.__r_.__value_.__l.__data_, v32, -1431655765 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3));
        free(v17);
        fclose(v15);
        return a1;
      }
      fclose(v15);
      free(v17);
      exceptiounint64_t n = __cxa_allocate_exception(8uLL);
      uint64_t v28 = 3957;
LABEL_27:
      *exceptiounint64_t n = v28;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
LABEL_25:
    exceptiounint64_t n = __cxa_allocate_exception(8uLL);
    uint64_t v28 = 3964;
    goto LABEL_27;
  }
  if (v12 < 0) {
    uint64_t v11 = *(const char **)v11;
  }
  float v18 = fopen(v11, "rb");
  if (!v18) {
    goto LABEL_25;
  }
  uint64_t v19 = v18;
  uint64_t v20 = MEMORY[0x1A6256E50]();
  fseek(v19, 0, 2);
  uint64_t v21 = MEMORY[0x1A6256E50](v19);
  fseek(v19, v20, 0);
  size_t v22 = v21 - v20;
  memset(&v31, 0, sizeof(v31));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v31, *(long long **)(a1 + 8), *(long long **)(a1 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3));
  long long v23 = *(_OWORD *)&v31.__r_.__value_.__l.__data_;
  float32x4_t v24 = malloc_type_malloc(v22, 0xAF147757uLL);
  float32x4_t v25 = v24;
  if (!v24)
  {
    fclose(v19);
    unint64_t v29 = __cxa_allocate_exception(8uLL);
    *unint64_t v29 = 3963;
    __cxa_throw(v29, MEMORY[0x1E4FBA3E0], 0);
  }
  if (fread(v24, 1uLL, v22, v19) != v22)
  {
    free(v25);
    fclose(v19);
    simd_float4 v30 = __cxa_allocate_exception(8uLL);
    *simd_float4 v30 = 3964;
    __cxa_throw(v30, MEMORY[0x1E4FBA3E0], 0);
  }
  vision::mod::ImageClassifierGlimmer::private_t::loadData((vision::mod::ImageClassifierGlimmer::private_t *)v10, v25, v22, -1431655765 * ((*((void *)&v23 + 1) - (void)v23) >> 3));
  free(v25);
  fclose(v19);
  unint64_t v32 = (unint64_t)&v31;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v32);
  return a1;
}

void sub_1A3FC6510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::private_t::loadData(vision::mod::ImageClassifierGlimmer::private_t *this, void *a2, size_t a3, int a4)
{
  uint64_t v7 = a4;
  unint64_t v8 = *((void *)this + 5) * a4;
  unint64_t v9 = (void **)((char *)this + 16);
  std::vector<float>::resize((char **)this + 2, v8);
  if (a3 == 4 * v8)
  {
    uint64_t v10 = *v9;
    memcpy(v10, a2, a3);
  }
  else
  {
    if (v8 != a3)
    {
      exceptiounint64_t n = __cxa_allocate_exception(8uLL);
      *exceptiounint64_t n = 3964;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
    uint64_t v11 = (float *)*((void *)this + 2);
    vDSP_Length v12 = *((void *)this + 5) * v7;
    vDSP_vfltu8((const unsigned __int8 *)a2, 1, v11, 1, v12);
  }
}

uint64_t vision::mod::ImageClassifierGlimmer::getDescriptorProcessor@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  long long v2 = *(uint64_t **)(this + 120);
  uint64_t v4 = *v2;
  uint64_t v3 = v2[1];
  *a2 = v4;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void vision::mod::ImageClassifierGlimmer::~ImageClassifierGlimmer(vision::mod::ImageClassifierGlimmer *this)
{
  *(void *)this = &unk_1EF752648;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  vision::mod::ImageClassifierAbstract::~ImageClassifierAbstract(this);

  JUMPOUT(0x1A62562C0);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF752648;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  vision::mod::ImageClassifierAbstract::~ImageClassifierAbstract(this);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer::private_t>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  long long v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753700;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753700;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void normalizeArray(float *a1, unsigned int a2)
{
  float v2 = *a1;
  uint64_t v3 = a2;
  uint64_t v4 = 1;
  float v5 = *a1;
  do
  {
    float v6 = a1[v4];
    if (v6 <= v2)
    {
      if (v6 < v5) {
        float v5 = a1[v4];
      }
    }
    else
    {
      float v2 = a1[v4];
    }
    ++v4;
  }
  while (a2 != v4);
  if (v5 == v2)
  {
    if (v5 != 0.0 && v2 != 1.0)
    {
      int __pattern4 = 1065353216;
      memset_pattern4(a1, &__pattern4, 4 * a2);
    }
  }
  else
  {
    float v7 = 1.0 / (float)(v2 - v5);
    do
    {
      *a1 = v7 * (float)(*a1 - v5);
      ++a1;
      --v3;
    }
    while (v3);
  }
}

void boxFilter(float *a1, unsigned int a2, unsigned int a3, int a4, float *a5)
{
  uint64_t v10 = (float *)malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  int v11 = 0;
  uint64_t v12 = a2 - (a3 >> 1);
  if (a4) {
    float v13 = v10;
  }
  else {
    float v13 = a5;
  }
  unint64_t v14 = a3 >> 1;
  int v15 = a2 - (a3 | 1) + 1;
  if (a4) {
    unsigned __int8 v16 = a5;
  }
  else {
    unsigned __int8 v16 = v10;
  }
  float v17 = 1.0 / (float)a3;
  double v18 = v17;
  if (v14 <= 1) {
    uint64_t v19 = 1;
  }
  else {
    uint64_t v19 = v14;
  }
  uint64_t v20 = a2 - (a3 & 0xFFFFFFFE);
  unsigned int v21 = a2 + (a3 >> 1) - (a3 & 0xFFFFFFFE);
  do
  {
    size_t v22 = a1;
    a1 = v16;
    unint64_t v23 = 0;
    if (a3)
    {
      unint64_t v51 = v14 + 1;
      do
      {
        float v52 = 0.0;
        unint64_t v53 = v23;
        do
          float v52 = v52 + v22[(v12 + v53++)];
        while (v53 < v14);
        uint64_t v54 = 0;
        do
          float v52 = v52 + v22[v54++];
        while (v51 != v54);
        a1[v23++] = v17 * v52;
        ++v51;
      }
      while (v23 != v19);
      uint64_t v55 = 0;
      int32x4_t v56 = v22;
      uint64_t v57 = a3 >> 1;
      unsigned int v58 = a3 | 1;
      do
      {
        float v59 = 0.0;
        if (v57 - v14 < (v14 + 1 + v57))
        {
          uint64_t v60 = v56;
          uint64_t v61 = v58;
          do
          {
            float v62 = *v60++;
            float v59 = v59 + v62;
            --v61;
          }
          while (v55 != v61);
        }
        a1[v57++] = v17 * v59;
        ++v55;
        ++v58;
        ++v56;
      }
      while (v55 != v20);
      if (a3 >= 2)
      {
        uint64_t v63 = 0;
        int v64 = v15;
        unsigned int v65 = a3 - 1;
        uint64_t v66 = 1;
        uint64_t v67 = v12;
        do
        {
          float v68 = 0.0;
          if (v67 - v12 < (unint64_t)(a3 - 1))
          {
            int v69 = v64;
            unsigned int v70 = v65;
            do
            {
              float v68 = v68 + v22[v69++];
              --v70;
            }
            while (v70);
          }
          if (v67 - v12 != -1)
          {
            uint64_t v71 = 0;
            do
              float v68 = v68 + v22[v71++];
            while (v66 != v71);
          }
          a1[v67++] = v17 * v68;
          ++v63;
          ++v66;
          --v65;
          ++v64;
        }
        while (v63 != v14);
      }
    }
    else
    {
      int v24 = v12;
      unint64_t v25 = v14 + 1;
      do
      {
        uint64_t v26 = 0;
        float v27 = 0.0;
        float v28 = 0.0;
        do
        {
          if (v26) {
            float v28 = v28 + v22[(v24 + v26)];
          }
          else {
            float v27 = v27 + v22[(v12 + v23)];
          }
          ++v26;
        }
        while (v23 + v26 < v14);
        unint64_t v29 = v25;
        simd_float4 v30 = v22;
        do
        {
          if (v29 == 1) {
            float v27 = v27 + v22[v23 + v14];
          }
          else {
            float v28 = v28 + *v30;
          }
          ++v30;
          --v29;
        }
        while (v29);
        float v31 = (v28 + v27 * 0.5) * v18;
        a1[v23++] = v31;
        ++v25;
        ++v24;
      }
      while (v23 != v19);
      unint64_t v32 = v22 + 1;
      uint64_t v33 = a3 >> 1;
      do
      {
        unint64_t v34 = (v14 + v33);
        float v35 = 0.0;
        if (v33 - v14 + 1 < v34)
        {
          long long v36 = v32;
          unsigned int v37 = (a3 & 0xFFFFFFFE) - 1;
          do
          {
            float v38 = *v36++;
            float v35 = v35 + v38;
            --v37;
          }
          while (v37);
        }
        float v39 = (v35 + (float)(v22[v33 - v14] + v22[v34]) * 0.5) * v18;
        a1[v33++] = v39;
        ++v32;
      }
      while (v21 != v33);
      if (a3 >= 2)
      {
        uint64_t v40 = 0;
        unsigned int v41 = a3;
        int v42 = v15;
        uint64_t v43 = 1;
        uint64_t v44 = v12;
        do
        {
          uint64_t v45 = v44 - v12;
          float v46 = 0.0;
          float v47 = 0.0;
          if (v44 - v12 < (unint64_t)a3)
          {
            uint64_t v48 = 0;
            do
            {
              if (v48) {
                float v46 = v46 + v22[(v42 + v48)];
              }
              else {
                float v47 = v47 + v22[(v15 + v45)];
              }
              ++v48;
            }
            while (v41 != v48);
          }
          if (v44 - v12 != -1)
          {
            uint64_t v49 = 0;
            do
            {
              if (v40 == v49) {
                float v47 = v47 + v22[v45];
              }
              else {
                float v46 = v46 + v22[v49];
              }
              ++v49;
            }
            while (v43 != v49);
          }
          float v50 = (v46 + v47 * 0.5) * v18;
          a1[v44++] = v50;
          ++v40;
          ++v43;
          ++v42;
          --v41;
        }
        while (v40 != v14);
      }
    }
    if (v11) {
      unsigned __int8 v16 = v22;
    }
    else {
      unsigned __int8 v16 = v13;
    }
    ++v11;
  }
  while (v11 != a4);
  if (v10)
  {
    free(v10);
  }
}

void findPeaks(float *a1, int a2, float *a3, _DWORD *a4, float a5, float a6)
{
  size_t v10 = 4 * a2;
  uint64_t v11 = a2;
  uint64_t v12 = (float *)malloc_type_malloc(v10, 0x100004052888210uLL);
  float v13 = (float *)malloc_type_malloc(v10, 0x100004052888210uLL);
  unint64_t v14 = v13;
  uint64_t v15 = 0;
  uint64_t v16 = (a2 - 1);
  *uint64_t v12 = (float)(a1[1] - a1[v16]) * 0.5;
  uint64_t v17 = v16 - 1;
  do
  {
    v12[v15 + 1] = (float)(a1[v15 + 2] - a1[v15]) * 0.5;
    ++v15;
  }
  while (v17 != v15);
  uint64_t v18 = 0;
  uint64_t v19 = (a2 - 2);
  v12[v16] = (float)(*a1 - a1[v19]) * 0.5;
  *float v13 = (float)(a1[1] + (float)(*a1 * -2.0)) + a1[v16];
  do
  {
    v13[v18 + 1] = (float)(a1[v18 + 2] + (float)(a1[v18 + 1] * -2.0)) + a1[v18];
    ++v18;
    --v17;
  }
  while (v17);
  int v20 = 0;
  v13[v16] = (float)(*a1 + (float)(a1[v16] * -2.0)) + a1[v19];
  float v21 = (float)a2;
  if (a6 > 0.0) {
    a5 = 0.0;
  }
  uint64_t v22 = (a2 + 1);
  uint64_t v23 = 1;
  float v24 = 0.5;
  unint64_t v25 = a3;
  float v118 = (float)a2;
  float v110 = a5;
  float v111 = a6;
  uint64_t v120 = v11;
  do
  {
    if (v23 == v11) {
      uint64_t v26 = 0;
    }
    else {
      uint64_t v26 = v23;
    }
    if (v12[v23 - 1] <= 0.0) {
      goto LABEL_211;
    }
    float v27 = v12[v26];
    if (v27 > 0.0) {
      goto LABEL_211;
    }
    if (v27 == 0.0)
    {
      int v28 = v26;
      while (1)
      {
        int v29 = v28 >= a2 ? a2 : 0;
        int v30 = v28 - v29;
        if (v12[v30] < 0.0) {
          break;
        }
        if (++v28 >= (int)v26 + a2) {
          goto LABEL_211;
        }
      }
      int v31 = v26;
      if (v26 == -1) {
        goto LABEL_211;
      }
    }
    else
    {
      int v30 = v26;
      int v31 = v23 - 1;
    }
    float v32 = v14[v23 - 1];
    if (v32 >= 0.0 && (float v33 = v14[v26], v33 <= 0.0) || v32 <= 0.0 && (float v33 = v14[v26], v33 >= 0.0))
    {
      if (v23 == 1) {
        int v34 = a2;
      }
      else {
        int v34 = v23 - 1;
      }
      int v31 = v34 - 1;
      if (v26 == v16) {
        int v30 = 0;
      }
      else {
        int v30 = v26 + 1;
      }
      if ((float)(v32 + v14[v31]) >= 0.0 || (float)(v33 + v14[v30]) >= 0.0) {
        goto LABEL_211;
      }
      if (v32 >= 0.0) {
        int v30 = v26;
      }
    }
    int v35 = 0;
    uint64_t v36 = v31;
    uint64_t v37 = v30;
    int v38 = -1;
    int v39 = v31;
    int v40 = -1;
    float v41 = (float)((float)(a1[v31] + a1[v30]) * v24) * v24;
    uint64_t v42 = 0xFFFFFFFFLL;
    uint64_t v43 = 0xFFFFFFFFLL;
    int v44 = -1;
    int v45 = -1;
    do
    {
      if (v39 >= a2) {
        int v46 = a2;
      }
      else {
        int v46 = 0;
      }
      if (v39 >= 0) {
        int v47 = -v46;
      }
      else {
        int v47 = a2;
      }
      int v48 = v47 + v39;
      int v49 = v47 + v39 - a2;
      if (v47 + v39 <= a2) {
        int v50 = 0;
      }
      else {
        int v50 = a2;
      }
      if (v48 >= 1) {
        int v51 = -v50;
      }
      else {
        int v51 = a2;
      }
      uint64_t v52 = (v48 + v51 - 1);
      float v53 = a1[v48];
      if (v53 < v41)
      {
        if (!v35)
        {
          int v45 = v52;
          int v44 = v48;
        }
        LODWORD(v43) = v52;
        LODWORD(v42) = v48;
        int v40 = v52;
        int v38 = v48;
        break;
      }
      if (v12[(int)v52] < 0.0 && v12[v48] >= 0.0)
      {
        int v40 = v52;
        int v38 = v48;
      }
      float v54 = v14[(int)v52];
      if (v35)
      {
        if (v54 >= 0.0 || (float v55 = v14[v48], v55 < 0.0) || v12[v48] >= 0.0)
        {
          int v35 = 1;
          goto LABEL_93;
        }
      }
      else if (v54 <= 0.0 || (float v55 = v14[v48], v55 > 0.0))
      {
        int v35 = 0;
        goto LABEL_93;
      }
      if (v55 != 0.0)
      {
        if (v35)
        {
          uint64_t v58 = v52;
        }
        else
        {
          int v45 = v52;
          int v44 = v48;
          uint64_t v58 = v43;
        }
        if (v35) {
          uint64_t v52 = v48;
        }
        else {
          uint64_t v52 = v42;
        }
        if (!v35) {
          goto LABEL_88;
        }
        goto LABEL_89;
      }
      while (1)
      {
        if (v48 >= a2) {
          int v56 = a2;
        }
        else {
          int v56 = 0;
        }
        if (v48 >= 0) {
          int v57 = -v56;
        }
        else {
          int v57 = a2;
        }
        uint64_t v58 = (v57 + v48);
        if (a1[(int)v58] < v41)
        {
          if (!v35)
          {
            int v45 = v57 + v48;
            int v44 = v52;
            goto LABEL_88;
          }
          goto LABEL_89;
        }
        float v59 = v14[(int)v58];
        if (!v35) {
          break;
        }
        if (v59 > 0.0)
        {
          LODWORD(v43) = v57 + v48;
          LODWORD(v42) = v52;
          if (v58 == -1) {
            goto LABEL_172;
          }
          goto LABEL_101;
        }
LABEL_74:
        if (--v48 <= v49) {
          goto LABEL_87;
        }
      }
      if (v59 >= 0.0) {
        goto LABEL_74;
      }
      int v45 = v57 + v48;
      int v44 = v52;
LABEL_87:
      uint64_t v58 = v43;
      uint64_t v52 = v42;
      if (!v35)
      {
LABEL_88:
        if (v45 != -1) {
          goto LABEL_89;
        }
LABEL_172:
        LODWORD(v16) = a2 - 1;
        goto LABEL_211;
      }
LABEL_89:
      if (v58 == -1 && v35 == 1) {
        goto LABEL_172;
      }
      if (v35)
      {
        LODWORD(v43) = v58;
        LODWORD(v42) = v52;
        break;
      }
      int v35 = 1;
      uint64_t v43 = v58;
      uint64_t v42 = v52;
LABEL_93:
      --v39;
    }
    while (v39 > v31 - a2);
LABEL_101:
    int v60 = 0;
    int v61 = v30 + a2;
    int v62 = -1;
    int v63 = v30;
    int v64 = -1;
    int v124 = -1;
    int v125 = -1;
    int v123 = -1;
    int v126 = -1;
    while (1)
    {
      int v65 = v63 >= a2 ? a2 : 0;
      int v66 = v63 >= 0 ? -v65 : a2;
      int v67 = v66 + v63;
      int v68 = v66 + v63 <= a2 ? 0 : a2;
      int v69 = v67 >= 1 ? -v68 : a2;
      int v70 = v67 + v69 - 1;
      float v71 = a1[v67];
      if (v71 < v41) {
        break;
      }
      if (v12[v70] < 0.0 && v12[v67] >= 0.0)
      {
        int v64 = v70;
        int v62 = v67;
      }
      float v72 = v14[v70];
      if (v60)
      {
        if (v72 <= 0.0 || (float v73 = v14[v67], v73 > 0.0) || v12[v67] <= 0.0)
        {
          int v60 = 1;
          goto LABEL_163;
        }
      }
      else if (v72 >= 0.0 || (float v73 = v14[v67], v73 < 0.0))
      {
        int v60 = 0;
        goto LABEL_163;
      }
      if (v73 == 0.0)
      {
        int v74 = v67 + a2;
        while (1)
        {
          int v75 = v67 >= a2 ? a2 : 0;
          int v76 = v67 >= 0 ? -v75 : a2;
          int v77 = v76 + v67;
          if (a1[v76 + v67] < v41) {
            break;
          }
          float v78 = v14[v77];
          if (v60)
          {
            if (v78 < 0.0)
            {
              int v124 = v76 + v67;
              int v125 = v70;
              if (v77 != -1) {
                goto LABEL_174;
              }
              goto LABEL_171;
            }
          }
          else if (v78 > 0.0)
          {
            int v79 = v76 + v67;
            int v123 = v70;
            int v77 = v124;
            int v70 = v125;
            goto LABEL_158;
          }
          if (++v67 >= v74)
          {
            int v77 = v124;
            int v70 = v125;
            int v79 = v126;
            if (!v60) {
              goto LABEL_158;
            }
            goto LABEL_159;
          }
        }
        int v79 = v126;
        if (!v60) {
          int v79 = v76 + v67;
        }
        int v81 = v123;
        if (!v60) {
          int v81 = v70;
        }
        int v123 = v81;
        if (!v60) {
          goto LABEL_158;
        }
      }
      else
      {
        int v79 = v126;
        if (!v60) {
          int v79 = v70;
        }
        int v80 = v123;
        if (!v60) {
          int v80 = v67;
        }
        int v123 = v80;
        if (v60) {
          int v77 = v70;
        }
        else {
          int v77 = v124;
        }
        int v70 = v125;
        if (v60)
        {
          int v70 = v67;
        }
        else
        {
LABEL_158:
          if (v79 == -1) {
            goto LABEL_171;
          }
        }
      }
LABEL_159:
      if (v77 == -1 && v60 == 1)
      {
LABEL_171:
        uint64_t v11 = v120;
        goto LABEL_172;
      }
      int v126 = v79;
      if (v60)
      {
        int v124 = v77;
        int v125 = v70;
        goto LABEL_174;
      }
      int v60 = 1;
      int v124 = v77;
      int v125 = v70;
LABEL_163:
      if (++v63 >= v61) {
        goto LABEL_174;
      }
    }
    int v82 = v126;
    if (!v60) {
      int v82 = v70;
    }
    int v125 = v67;
    int v126 = v82;
    int v83 = v123;
    if (!v60) {
      int v83 = v67;
    }
    int v123 = v83;
    int v124 = v70;
    int v62 = v67;
    int v64 = v70;
LABEL_174:
    float v84 = (float)-v12[v30] / (float)(v12[v31] - v12[v30]);
    int v121 = v20;
    LODWORD(v16) = a2 - 1;
    int v119 = v64;
    if (v31 >= v30)
    {
      int v113 = v38;
      int v114 = v42;
      uint64_t v42 = v31;
      uint64_t v116 = v30;
      int v112 = v40;
      int v86 = v45;
      int v87 = v62;
      int v88 = v44;
      float v85 = fmodf((float)(v21 + (float)(v84 * (float)(v31 - v61))) + (float)v61, v21);
      int v44 = v88;
      int v62 = v87;
      int v45 = v86;
      int v40 = v112;
      int v38 = v113;
      uint64_t v37 = v116;
      uint64_t v36 = v42;
      LODWORD(v42) = v114;
      uint64_t v22 = (a2 + 1);
      int v20 = v121;
      unint64_t v25 = a3;
      LODWORD(v16) = a2 - 1;
    }
    else
    {
      float v85 = (float)v30 + (float)(v84 * (float)(v31 - v30));
    }
    uint64_t v89 = &v25[6 * v20];
    v89[1] = v85;
    float v90 = a1[v37] + (float)(v84 * (float)(a1[v36] - a1[v37]));
    v89[5] = v90;
    if (v90 < a5)
    {
      uint64_t v11 = v120;
      goto LABEL_211;
    }
    int32x4_t v91 = &v25[6 * v20];
    float v92 = 0.5;
    if (v53 >= v41) {
      float v92 = (float)-v14[(int)v42] / (float)(v14[(int)v43] - v14[(int)v42]);
    }
    float v115 = v12[v44];
    float v117 = v12[v45];
    if ((int)v43 >= (int)v42) {
      float v93 = fmodf((float)(v21 + (float)(v92 * (float)(v43 - (v42 + a2)))) + (float)(v42 + a2), v21);
    }
    else {
      float v93 = (float)(int)v42 + (float)(v92 * (float)(v43 - v42));
    }
    float v94 = 0.5;
    if (v53 >= v41) {
      float v94 = (float)-v12[v38] / (float)(v12[v40] - v12[v38]);
    }
    if (v40 >= v38) {
      float v95 = fmodf((float)(v21 + (float)(v94 * (float)(v40 - (v38 + a2)))) + (float)(v38 + a2), v21);
    }
    else {
      float v95 = (float)v38 + (float)(v94 * (float)(v40 - v38));
    }
    if (v53 < v41) {
      float v96 = v93;
    }
    else {
      float v96 = v95;
    }
    a3[6 * v121 + 2] = v96;
    float v127 = v12[v126];
    float v97 = v12[v123];
    float v98 = 0.5;
    if (v71 >= v41) {
      float v98 = (float)-v14[v125] / (float)(v14[v124] - v14[v125]);
    }
    if (v124 >= v125) {
      float v99 = fmodf((float)(v118 + (float)(v98 * (float)(v124 - (v125 + a2)))) + (float)(v125 + a2), v118);
    }
    else {
      float v99 = (float)v125 + (float)(v98 * (float)(v124 - v125));
    }
    float v100 = 0.5;
    if (v71 >= v41) {
      float v100 = (float)-v12[v62] / (float)(v12[v119] - v12[v62]);
    }
    if (v119 >= v62)
    {
      float v21 = (float)a2;
      float v101 = fmodf((float)(v118 + (float)(v100 * (float)(v119 - (v62 + a2)))) + (float)(v62 + a2), v118);
      unint64_t v25 = a3;
      LODWORD(v16) = a2 - 1;
      uint64_t v11 = v120;
      int v20 = v121;
    }
    else
    {
      float v101 = (float)v62 + (float)(v100 * (float)(v119 - v62));
      unint64_t v25 = a3;
      LODWORD(v16) = a2 - 1;
      uint64_t v11 = v120;
      int v20 = v121;
      float v21 = (float)a2;
    }
    uint64_t v22 = (a2 + 1);
    float v102 = fabsf(v115 + (float)(v84 * (float)(v117 - v115)));
    float v103 = fabsf(v97 + (float)(v94 * (float)(v127 - v97)));
    if (v71 < v41) {
      float v101 = v99;
    }
    uint64_t v104 = &v25[6 * v121];
    float v105 = -0.0;
    if (v96 >= v101) {
      float v105 = v21;
    }
    v104[3] = v101;
    v104[4] = (float)(v101 + v105) - v96;
    if (v102 <= v103) {
      BOOL v106 = v103 < v111;
    }
    else {
      BOOL v106 = v102 < v111;
    }
    a5 = v110;
    float v24 = 0.5;
    if (!v106)
    {
      *int32x4_t v91 = 0.0;
      if (++v20 == 200)
      {
        *a4 = 200;
        goto LABEL_213;
      }
    }
LABEL_211:
    ++v23;
  }
  while (v23 != v22);
  *a4 = v20;
  if (v20)
  {
LABEL_213:
    if (v25[1] > v25[7])
    {
      long long v128 = *(_OWORD *)v25;
      uint64_t v129 = *((void *)v25 + 2);
      int v107 = v20 - 1;
      if (v20 == 1)
      {
        int v107 = 0;
      }
      else
      {
        memmove(v25, v25 + 6, 24 * (v20 - 1));
        unint64_t v25 = a3;
      }
      long long v108 = &v25[6 * v107];
      *(_OWORD *)long long v108 = v128;
      *((void *)v108 + 2) = v129;
    }
  }
  free(v12);

  free(v14);
}

void sub_1A3FC7860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char &&>,std::tuple<>>(uint64_t **a1, unsigned __int8 a2, unsigned char *a3)
{
  float v6 = a1 + 1;
  float v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        float v7 = (uint64_t **)v5;
        unsigned int v8 = *((unsigned __int8 *)v5 + 32);
        if (v8 <= a2) {
          break;
        }
        float v5 = *v7;
        float v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      float v5 = v7[1];
      if (!v5)
      {
        float v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    float v7 = a1 + 1;
LABEL_9:
    unint64_t v9 = operator new(0x40uLL);
    v9[32] = *a3;
    *((void *)v9 + 6) = 0;
    *((void *)v9 + 7) = 0;
    *((void *)v9 + 5) = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

void sub_1A3FC8460(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC8574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC87EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC887C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC8C5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC8D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC8E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC8EF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC90E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC91E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC9444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

void sub_1A3FC9554(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3FC9C54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void vision::mod::ObjectTrackerOptions::clone(vision::mod::ObjectTrackerOptions *this)
{
}

uint64_t vision::mod::ObjectTrackerAbstract::update()
{
  return 6784;
}

uint64_t vision::mod::ObjectTrackerAbstract::reset(vision::mod::ObjectTrackerAbstract *this)
{
  uint64_t result = (*(uint64_t (**)(vision::mod::ObjectTrackerAbstract *))(*(void *)this + 56))(this);
  if (result == 128)
  {
    uint64_t result = (*(uint64_t (**)(vision::mod::ObjectTrackerAbstract *))(*(void *)this + 48))(this);
    if (result == 128) {
      return 6784;
    }
  }
  return result;
}

void vision::mod::ObjectTrackerAbstract::ObjectTrackerAbstract(vision::mod::ObjectTrackerAbstract *this, vision::mod::ObjectDetectorAbstract *a2, const vision::mod::ObjectTrackerOptions *a3)
{
  *(void *)this = &unk_1EF7525F8;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = (**(uint64_t (***)(vision::mod::ObjectDetectorAbstract *))a2)(a2);
  operator new();
}

void sub_1A3FCA140(_Unwind_Exception *exception_object)
{
  if (v1) {
    MEMORY[0x1A62562C0](v1, 0x10A1C40DF6760FDLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<vision::mod::ObjectTrackerOptions *,std::shared_ptr<vision::mod::ObjectTrackerOptions>::__shared_ptr_default_delete<vision::mod::ObjectTrackerOptions,vision::mod::ObjectTrackerOptions>,std::allocator<vision::mod::ObjectTrackerOptions>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN6vision3mod20ObjectTrackerOptionsEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::__shared_ptr_pointer<vision::mod::ObjectTrackerOptions *,std::shared_ptr<vision::mod::ObjectTrackerOptions>::__shared_ptr_default_delete<vision::mod::ObjectTrackerOptions,vision::mod::ObjectTrackerOptions>,std::allocator<vision::mod::ObjectTrackerOptions>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

void std::__shared_ptr_pointer<vision::mod::ObjectTrackerOptions *,std::shared_ptr<vision::mod::ObjectTrackerOptions>::__shared_ptr_default_delete<vision::mod::ObjectTrackerOptions,vision::mod::ObjectTrackerOptions>,std::allocator<vision::mod::ObjectTrackerOptions>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A3FCA2B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCAA64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, __CVBuffer *a20,__CVBuffer *a21,__CVBuffer *a22,uint64_t a23,uint64_t a24,__CVBuffer *a25)
{
  if (a2)
  {

    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&a25);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&a20);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&a21);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&a22);

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3FCAA38);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3FCAF70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

CVPixelBufferRef NtCreatePixelBuffer(int a1, int a2, IOSurfaceRef *a3)
{
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  float v7 = (const void *)*MEMORY[0x1E4F2F2C0];
  LODWORD(valuePtr) = a1;
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, v7, v8);
  CFRelease(v8);
  unint64_t v9 = (const void *)*MEMORY[0x1E4F2F0E8];
  LODWORD(valuePtr) = a2;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, v9, v10);
  CFRelease(v10);
  uint64_t v11 = (const void *)*MEMORY[0x1E4F2F150];
  LODWORD(valuePtr) = 1111970369;
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, v11, v12);
  CFRelease(v12);
  float v13 = (const void *)*MEMORY[0x1E4F2EFE0];
  int v14 = 4 * a1 + 63;
  if (v14 <= 0) {
    int v15 = -(-v14 & 0x3F);
  }
  else {
    int v15 = v14 & 0x3F;
  }
  LODWORD(valuePtr) = v14 - v15;
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, v13, v16);
  CFRelease(v16);
  *a3 = IOSurfaceCreate(Mutable);
  CFRelease(Mutable);
  if (!*a3) {
    return 0;
  }
  uint64_t v17 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v18 = (const void *)*MEMORY[0x1E4F24D70];
  LODWORD(valuePtr) = 1111970369;
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(v17, v18, v19);
  CFRelease(v19);
  CVPixelBufferRef valuePtr = 0;
  CVReturn v20 = CVPixelBufferCreateWithIOSurface((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *a3, v17, &valuePtr);
  CVPixelBufferRef result = 0;
  if (!v20)
  {
    CFRelease(v17);
    return valuePtr;
  }
  return result;
}

uint64_t NtDestroyTracker(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_DWORD *)result == -1430532899)
    {
      if (!*(unsigned char *)(result + 4089))
      {
        espresso_plan_destroy();
        *(void *)(v1 + 16) = 0;
        espresso_context_destroy();
        *(void *)(v1 + 8) = 0;
        espresso_plan_destroy();
        *(void *)(v1 + 384) = 0;
        espresso_context_destroy();
        *(void *)(v1 + 376) = 0;
      }
      TtTrkRpnStop(*(void **)(v1 + 1104));
      CFRelease(*(CFTypeRef *)(v1 + 4080));
      CFRelease(*(CFTypeRef *)(v1 + 4064));
      CVPixelBufferRelease(*(CVPixelBufferRef *)(v1 + 4072));
      CVPixelBufferRelease(*(CVPixelBufferRef *)(v1 + 4056));
      TtTrkRpnDestroy(*(TtTrkRpnNode ***)(v1 + 1104));
      uint64_t v2 = *(void *)(v1 + 3504);
      if (v2) {
        MEMORY[0x1A62562A0](v2, 0x1000C8077774924);
      }
      JUMPOUT(0x1A62562C0);
    }
  }
  return result;
}

void *NtLockCvPixelBuffers(uint64_t a1)
{
  CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(a1 + 4056), 0);
  CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(a1 + 4072), 0);
  *(void *)(a1 + 3204) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 4056));
  CVPixelBufferRef result = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 4072));
  *(void *)(a1 + 3216) = result;
  return result;
}

uint64_t EspressoExemplarPlanExecuteSynced(uint64_t a1)
{
  uint64_t result = espresso_plan_execute_sync();
  *(_DWORD *)(a1 + 1080) = result;
  return result;
}

uint64_t EspressoInstancePlanExecuteSynced(uint64_t a1)
{
  uint64_t result = espresso_plan_execute_sync();
  *(_DWORD *)(a1 + 1080) = result;
  return result;
}

void sub_1A3FCBB34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__24241(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__24242(uint64_t a1)
{
}

void sub_1A3FCCBB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A3FCCB58);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<DetectedRectangle>>(unint64_t a1)
{
  if (a1 >= 0x924924924924925) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(28 * a1);
}

void std::__introsort<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*,false>(unint64_t a1, _OWORD *a2, uint64_t a3, char a4)
{
  while (2)
  {
    CFNumberRef v10 = (_OWORD *)((char *)a2 - 28);
    unint64_t v11 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v11;
          uint64_t v12 = (uint64_t)a2 - v11;
          unint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)((uint64_t)a2 - v11) >> 2);
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*((float *)a2 - 3) > *(float *)(v11 + 16))
                {
                  *(_OWORD *)&v103[12] = *(_OWORD *)(v11 + 12);
                  *(_OWORD *)float v103 = *(_OWORD *)v11;
                  long long v49 = *v10;
                  *(_OWORD *)(v11 + 12) = *(a2 - 1);
                  *(_OWORD *)unint64_t v11 = v49;
                  *(a2 - 1) = *(_OWORD *)&v103[12];
                  *CFNumberRef v10 = *(_OWORD *)v103;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(v11, v11 + 28, (uint64_t)a2 - 28);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(v11, v11 + 28, v11 + 56, (uint64_t)a2 - 28);
                break;
              case 5uLL:
                int v50 = (_OWORD *)(v11 + 28);
                int v51 = (_OWORD *)(v11 + 56);
                uint64_t v52 = (_OWORD *)(v11 + 84);
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(v11, v11 + 28, v11 + 56, v11 + 84);
                if (*((float *)a2 - 3) > *(float *)(v11 + 100))
                {
                  *(_OWORD *)uint64_t v104 = *v52;
                  *(_OWORD *)&v104[12] = *(_OWORD *)(v11 + 96);
                  long long v53 = *v10;
                  *(_OWORD *)(v11 + 96) = *(a2 - 1);
                  _OWORD *v52 = v53;
                  *(a2 - 1) = *(_OWORD *)&v104[12];
                  *CFNumberRef v10 = *(_OWORD *)v104;
                  if (*(float *)(v11 + 100) > *(float *)(v11 + 72))
                  {
                    *(_OWORD *)float v105 = *v51;
                    *(_OWORD *)&v105[12] = *(_OWORD *)(v11 + 68);
                    _OWORD *v51 = *v52;
                    *(_OWORD *)(v11 + 68) = *(_OWORD *)(v11 + 96);
                    _OWORD *v52 = *(_OWORD *)v105;
                    *(_OWORD *)(v11 + 96) = *(_OWORD *)&v105[12];
                    if (*(float *)(v11 + 72) > *(float *)(v11 + 44))
                    {
                      *(_OWORD *)BOOL v106 = *v50;
                      *(_OWORD *)&v106[12] = *(_OWORD *)(v11 + 40);
                      _OWORD *v50 = *v51;
                      *(_OWORD *)(v11 + 40) = *(_OWORD *)(v11 + 68);
                      _OWORD *v51 = *(_OWORD *)v106;
                      *(_OWORD *)(v11 + 68) = *(_OWORD *)&v106[12];
                      if (*(float *)(v11 + 44) > *(float *)(v11 + 16))
                      {
                        *(_OWORD *)&v107[12] = *(_OWORD *)(v11 + 12);
                        *(_OWORD *)int v107 = *(_OWORD *)v11;
                        *(_OWORD *)unint64_t v11 = *v50;
                        *(_OWORD *)(v11 + 12) = *(_OWORD *)(v11 + 40);
                        _OWORD *v50 = *(_OWORD *)v107;
                        *(_OWORD *)(v11 + 40) = *(_OWORD *)&v107[12];
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v12 <= 671)
          {
            float v54 = (_OWORD *)(v11 + 28);
            BOOL v56 = (_OWORD *)v11 == a2 || v54 == a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v11;
                do
                {
                  float v59 = v54;
                  float v60 = *(float *)(v58 + 44);
                  if (v60 > *(float *)(v58 + 16))
                  {
                    long long v108 = *v54;
                    uint64_t v61 = *(void *)(v58 + 48);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      uint64_t v63 = v11 + v62;
                      *(_OWORD *)(v63 + 28) = *(_OWORD *)(v11 + v62);
                      *(_OWORD *)(v63 + 40) = *(_OWORD *)(v11 + v62 + 12);
                      if (!v62) {
                        break;
                      }
                      v62 -= 28;
                      if (v60 <= *(float *)(v63 - 12))
                      {
                        uint64_t v64 = v11 + v62 + 28;
                        goto LABEL_84;
                      }
                    }
                    uint64_t v64 = v11;
LABEL_84:
                    *(_OWORD *)uint64_t v64 = v108;
                    *(float *)(v64 + 16) = v60;
                    *(void *)(v64 + 20) = v61;
                  }
                  float v54 = (_OWORD *)((char *)v59 + 28);
                  v57 += 28;
                  unint64_t v58 = (unint64_t)v59;
                }
                while ((_OWORD *)((char *)v59 + 28) != a2);
              }
            }
            else if (!v56)
            {
              do
              {
                unint64_t v93 = (unint64_t)v54;
                float v94 = *(float *)(a1 + 44);
                if (v94 > *(float *)(a1 + 16))
                {
                  long long v111 = *v54;
                  uint64_t v95 = *(void *)(a1 + 48);
                  do
                  {
                    *float v54 = *(_OWORD *)((char *)v54 - 28);
                    *(_OWORD *)((char *)v54 + 12) = *(v54 - 1);
                    float v96 = *((float *)v54 - 10);
                    float v54 = (_OWORD *)((char *)v54 - 28);
                  }
                  while (v94 > v96);
                  *float v54 = v111;
                  *((float *)v54 + 4) = v94;
                  *(void *)((char *)v54 + 20) = v95;
                }
                float v54 = (_OWORD *)(v93 + 28);
                a1 = v93;
              }
              while ((_OWORD *)(v93 + 28) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((_OWORD *)v11 != a2)
            {
              int64_t v65 = (v13 - 2) >> 1;
              int64_t v66 = v65;
              do
              {
                int64_t v67 = v66;
                if (v65 >= v66)
                {
                  uint64_t v68 = (2 * v66) | 1;
                  unint64_t v69 = v11 + 28 * v68;
                  if (2 * v67 + 2 < (uint64_t)v13 && *(float *)(v11 + 28 * v68 + 16) > *(float *)(v69 + 44))
                  {
                    v69 += 28;
                    uint64_t v68 = 2 * v67 + 2;
                  }
                  float v70 = *(float *)(v11 + 28 * v67 + 16);
                  if (*(float *)(v69 + 16) <= v70)
                  {
                    unint64_t v71 = v11 + 28 * v67;
                    long long v109 = *(_OWORD *)v71;
                    uint64_t v72 = *(void *)(v71 + 20);
                    do
                    {
                      float v73 = (_OWORD *)v71;
                      unint64_t v71 = v69;
                      long long v74 = *(_OWORD *)v69;
                      *(_OWORD *)((char *)v73 + 12) = *(_OWORD *)(v69 + 12);
                      *float v73 = v74;
                      if (v65 < v68) {
                        break;
                      }
                      uint64_t v75 = (2 * v68) | 1;
                      unint64_t v69 = v11 + 28 * v75;
                      uint64_t v76 = 2 * v68 + 2;
                      if (v76 < (uint64_t)v13 && *(float *)(v11 + 28 * v75 + 16) > *(float *)(v69 + 44))
                      {
                        v69 += 28;
                        uint64_t v75 = v76;
                      }
                      uint64_t v68 = v75;
                    }
                    while (*(float *)(v69 + 16) <= v70);
                    *(_OWORD *)unint64_t v71 = v109;
                    *(float *)(v71 + 16) = v70;
                    *(void *)(v71 + 20) = v72;
                  }
                }
                int64_t v66 = v67 - 1;
              }
              while (v67);
              int64_t v77 = v12 / 0x1CuLL;
              do
              {
                uint64_t v78 = 0;
                *(_OWORD *)&v110[12] = *(_OWORD *)(v11 + 12);
                *(_OWORD *)float v110 = *(_OWORD *)v11;
                unint64_t v79 = v11;
                do
                {
                  int v80 = (_OWORD *)v79;
                  uint64_t v81 = v78 + 1;
                  v79 += 28 * (v78 + 1);
                  uint64_t v82 = 2 * v78;
                  uint64_t v78 = (2 * v78) | 1;
                  int64_t v83 = v82 + 2;
                  if (v83 < v77 && *((float *)v80 + 7 * v81 + 4) > *(float *)(v79 + 44))
                  {
                    v79 += 28;
                    uint64_t v78 = v83;
                  }
                  long long v84 = *(_OWORD *)v79;
                  *(_OWORD *)((char *)v80 + 12) = *(_OWORD *)(v79 + 12);
                  *int v80 = v84;
                }
                while (v78 <= (uint64_t)((unint64_t)(v77 - 2) >> 1));
                a2 = (_OWORD *)((char *)a2 - 28);
                if ((_OWORD *)v79 == a2)
                {
                  *(_OWORD *)(v79 + 12) = *(_OWORD *)&v110[12];
                  *(_OWORD *)unint64_t v79 = *(_OWORD *)v110;
                }
                else
                {
                  long long v85 = *a2;
                  *(_OWORD *)(v79 + 12) = *(_OWORD *)((char *)a2 + 12);
                  *(_OWORD *)unint64_t v79 = v85;
                  *(_OWORD *)((char *)a2 + 12) = *(_OWORD *)&v110[12];
                  *a2 = *(_OWORD *)v110;
                  uint64_t v86 = v79 - v11 + 28;
                  if (v86 >= 29)
                  {
                    unint64_t v87 = (v86 / 0x1CuLL - 2) >> 1;
                    float v88 = *(float *)(v79 + 16);
                    if (*(float *)(v11 + 28 * v87 + 16) > v88)
                    {
                      long long v99 = *(_OWORD *)v79;
                      uint64_t v89 = *(void *)(v79 + 20);
                      do
                      {
                        float v90 = (_OWORD *)v79;
                        unint64_t v79 = v11 + 28 * v87;
                        long long v91 = *(_OWORD *)v79;
                        *(_OWORD *)((char *)v90 + 12) = *(_OWORD *)(v79 + 12);
                        *float v90 = v91;
                        if (!v87) {
                          break;
                        }
                        unint64_t v87 = (v87 - 1) >> 1;
                      }
                      while (*(float *)(v11 + 28 * v87 + 16) > v88);
                      *(_OWORD *)unint64_t v79 = v99;
                      *(float *)(v79 + 16) = v88;
                      *(void *)(v79 + 20) = v89;
                    }
                  }
                }
              }
              while (v77-- > 2);
            }
            return;
          }
          unint64_t v14 = v13 >> 1;
          int v15 = (long long *)(v11 + 28 * (v13 >> 1));
          if ((unint64_t)v12 >= 0xE01)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a1 + 28 * (v13 >> 1), (uint64_t)a2 - 28);
            uint64_t v16 = 28 * v14;
            uint64_t v17 = 28 * v14 + a1 - 28;
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1 + 28, v17, (uint64_t)a2 - 56);
            uint64_t v18 = a1 + 28 + v16;
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1 + 56, v18, (uint64_t)a2 - 84);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(v17, (uint64_t)v15, v18);
            *(_OWORD *)&v100[12] = *(_OWORD *)(a1 + 12);
            *(_OWORD *)float v100 = *(_OWORD *)a1;
            long long v19 = *v15;
            *(_OWORD *)(a1 + 12) = *(long long *)((char *)v15 + 12);
            *(_OWORD *)a1 = v19;
            *(long long *)((char *)v15 + 12) = *(_OWORD *)&v100[12];
            *int v15 = *(_OWORD *)v100;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1 + 28 * (v13 >> 1), a1, (uint64_t)a2 - 28);
          }
          --a3;
          if (a4) {
            break;
          }
          float v20 = *(float *)(a1 + 16);
          if (*(float *)(a1 - 12) > v20) {
            goto LABEL_12;
          }
          long long v98 = *(_OWORD *)a1;
          if (v20 <= *((float *)a2 - 3))
          {
            unint64_t v38 = a1 + 28;
            do
            {
              unint64_t v11 = v38;
              if (v38 >= (unint64_t)a2) {
                break;
              }
              float v39 = *(float *)(v38 + 16);
              v38 += 28;
            }
            while (v20 <= v39);
          }
          else
          {
            unint64_t v36 = a1;
            do
            {
              unint64_t v11 = v36 + 28;
              float v37 = *(float *)(v36 + 44);
              v36 += 28;
            }
            while (v20 <= v37);
          }
          int v40 = (float *)a2;
          if (v11 < (unint64_t)a2)
          {
            float v41 = (float *)a2;
            do
            {
              int v40 = v41 - 7;
              float v42 = *(v41 - 3);
              v41 -= 7;
            }
            while (v20 > v42);
          }
          uint64_t v43 = *(void *)(a1 + 20);
          while (v11 < (unint64_t)v40)
          {
            *(_OWORD *)&v102[12] = *(_OWORD *)(v11 + 12);
            *(_OWORD *)float v102 = *(_OWORD *)v11;
            long long v44 = *(_OWORD *)v40;
            *(_OWORD *)(v11 + 12) = *(_OWORD *)(v40 + 3);
            *(_OWORD *)unint64_t v11 = v44;
            *(_OWORD *)(v40 + 3) = *(_OWORD *)&v102[12];
            *(_OWORD *)int v40 = *(_OWORD *)v102;
            do
            {
              float v45 = *(float *)(v11 + 44);
              v11 += 28;
            }
            while (v20 <= v45);
            do
            {
              float v46 = *(v40 - 3);
              v40 -= 7;
            }
            while (v20 > v46);
          }
          int v47 = (long long *)(v11 - 28);
          BOOL v4 = v11 - 28 >= a1;
          BOOL v5 = v11 - 28 == a1;
          if (v11 - 28 != a1)
          {
            long long v48 = *v47;
            *(_OWORD *)(a1 + 12) = *(_OWORD *)(v11 - 16);
            *(_OWORD *)a1 = v48;
          }
          a4 = 0;
          long long *v47 = v98;
          *(float *)(v11 - 12) = v20;
          *(void *)(v11 - 8) = v43;
        }
        float v20 = *(float *)(a1 + 16);
LABEL_12:
        long long v97 = *(_OWORD *)a1;
        uint64_t v21 = *(void *)(a1 + 20);
        unint64_t v22 = a1;
        do
        {
          unint64_t v23 = v22;
          v22 += 28;
        }
        while (*(float *)(v23 + 44) > v20);
        float v24 = (float *)a2;
        if (v23 == a1)
        {
          float v27 = (float *)a2;
          while (v22 < (unint64_t)v27)
          {
            unint64_t v25 = v27 - 7;
            float v28 = *(v27 - 3);
            v27 -= 7;
            if (v28 > v20) {
              goto LABEL_22;
            }
          }
          unint64_t v25 = v27;
        }
        else
        {
          do
          {
            unint64_t v25 = v24 - 7;
            float v26 = *(v24 - 3);
            v24 -= 7;
          }
          while (v26 <= v20);
        }
LABEL_22:
        unint64_t v11 = v22;
        if (v22 < (unint64_t)v25)
        {
          int v29 = v25;
          do
          {
            *(_OWORD *)float v101 = *(_OWORD *)v11;
            *(_OWORD *)&v101[12] = *(_OWORD *)(v11 + 12);
            long long v30 = *(_OWORD *)v29;
            *(_OWORD *)(v11 + 12) = *(_OWORD *)(v29 + 3);
            *(_OWORD *)unint64_t v11 = v30;
            *(_OWORD *)(v29 + 3) = *(_OWORD *)&v101[12];
            *(_OWORD *)int v29 = *(_OWORD *)v101;
            do
            {
              float v31 = *(float *)(v11 + 44);
              v11 += 28;
            }
            while (v31 > v20);
            do
            {
              float v32 = *(v29 - 3);
              v29 -= 7;
            }
            while (v32 <= v20);
          }
          while (v11 < (unint64_t)v29);
        }
        float v33 = (long long *)(v11 - 28);
        if (v11 - 28 != a1)
        {
          long long v34 = *v33;
          *(_OWORD *)(a1 + 12) = *(_OWORD *)(v11 - 16);
          *(_OWORD *)a1 = v34;
        }
        *float v33 = v97;
        *(float *)(v11 - 12) = v20;
        *(void *)(v11 - 8) = v21;
        if (v22 >= (unint64_t)v25) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*,false>(a1, v11 - 28, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v35 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, v11 - 28);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(v11, (uint64_t)a2))
      {
        break;
      }
      if (!v35) {
        goto LABEL_33;
      }
    }
    a2 = (_OWORD *)(v11 - 28);
    if (!v35) {
      continue;
    }
    break;
  }
}

__n128 std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result.n128_u32[0] = *(_DWORD *)(a2 + 16);
  float v4 = *(float *)(a3 + 16);
  if (result.n128_f32[0] <= *(float *)(a1 + 16))
  {
    if (v4 > result.n128_f32[0])
    {
      *(_OWORD *)unint64_t v11 = *(_OWORD *)a2;
      *(_OWORD *)&v11[12] = *(_OWORD *)(a2 + 12);
      long long v6 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v6;
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v11[12];
      __n128 result = *(__n128 *)v11;
      *(_OWORD *)a3 = *(_OWORD *)v11;
      result.n128_u32[0] = *(_DWORD *)(a2 + 16);
      if (result.n128_f32[0] > *(float *)(a1 + 16))
      {
        *(_OWORD *)uint64_t v12 = *(_OWORD *)a1;
        *(_OWORD *)&v12[12] = *(_OWORD *)(a1 + 12);
        long long v7 = *(_OWORD *)(a2 + 12);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 12) = v7;
        *(_OWORD *)(a2 + 12) = *(_OWORD *)&v12[12];
        __n128 result = *(__n128 *)v12;
        *(_OWORD *)a2 = *(_OWORD *)v12;
      }
    }
  }
  else
  {
    if (v4 <= result.n128_f32[0])
    {
      *(_OWORD *)unint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)&v13[12] = *(_OWORD *)(a1 + 12);
      long long v8 = *(_OWORD *)(a2 + 12);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 12) = v8;
      *(_OWORD *)(a2 + 12) = *(_OWORD *)&v13[12];
      __n128 result = *(__n128 *)v13;
      *(_OWORD *)a2 = *(_OWORD *)v13;
      result.n128_u32[0] = *(_DWORD *)(a3 + 16);
      if (result.n128_f32[0] <= *(float *)(a2 + 16)) {
        return result;
      }
      *(_OWORD *)CFNumberRef v10 = *(_OWORD *)a2;
      *(_OWORD *)&v10[12] = *(_OWORD *)(a2 + 12);
      long long v9 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v9;
    }
    else
    {
      *(_OWORD *)CFNumberRef v10 = *(_OWORD *)a1;
      *(_OWORD *)&v10[12] = *(_OWORD *)(a1 + 12);
      long long v5 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)(a1 + 12) = v5;
    }
    *(_OWORD *)(a3 + 12) = *(_OWORD *)&v10[12];
    __n128 result = *(__n128 *)v10;
    *(_OWORD *)a3 = *(_OWORD *)v10;
  }
  return result;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a2, a3);
  result.n128_u32[0] = *(_DWORD *)(a4 + 16);
  if (result.n128_f32[0] > *(float *)(a3 + 16))
  {
    *(_OWORD *)uint64_t v12 = *(_OWORD *)a3;
    *(_OWORD *)&v12[12] = *(_OWORD *)(a3 + 12);
    long long v9 = *(_OWORD *)(a4 + 12);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 12) = v9;
    *(_OWORD *)(a4 + 12) = *(_OWORD *)&v12[12];
    __n128 result = *(__n128 *)v12;
    *(_OWORD *)a4 = *(_OWORD *)v12;
    result.n128_u32[0] = *(_DWORD *)(a3 + 16);
    if (result.n128_f32[0] > *(float *)(a2 + 16))
    {
      *(_OWORD *)unint64_t v13 = *(_OWORD *)a2;
      *(_OWORD *)&v13[12] = *(_OWORD *)(a2 + 12);
      long long v10 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v10;
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v13[12];
      __n128 result = *(__n128 *)v13;
      *(_OWORD *)a3 = *(_OWORD *)v13;
      result.n128_u32[0] = *(_DWORD *)(a2 + 16);
      if (result.n128_f32[0] > *(float *)(a1 + 16))
      {
        *(_OWORD *)unint64_t v14 = *(_OWORD *)a1;
        *(_OWORD *)&v14[12] = *(_OWORD *)(a1 + 12);
        long long v11 = *(_OWORD *)(a2 + 12);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 12) = v11;
        *(_OWORD *)(a2 + 12) = *(_OWORD *)&v14[12];
        __n128 result = *(__n128 *)v14;
        *(_OWORD *)a2 = *(_OWORD *)v14;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 2;
  BOOL result = 1;
  switch(0x6DB6DB6DB6DB6DB7 * v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 12) > *(float *)(a1 + 16))
      {
        *(_OWORD *)float v20 = *(_OWORD *)a1;
        *(_OWORD *)&v20[12] = *(_OWORD *)(a1 + 12);
        long long v6 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 28);
        *(_OWORD *)(a1 + 12) = v6;
        *(_OWORD *)(a2 - 16) = *(_OWORD *)&v20[12];
        *(_OWORD *)(a2 - 28) = *(_OWORD *)v20;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a1 + 28, a2 - 28);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a1 + 28, a1 + 56, a2 - 28);
      return 1;
    case 5:
      uint64_t v16 = (_OWORD *)(a1 + 28);
      uint64_t v17 = (_OWORD *)(a1 + 56);
      uint64_t v18 = (_OWORD *)(a1 + 84);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a1 + 28, a1 + 56, a1 + 84);
      if (*(float *)(a2 - 12) > *(float *)(a1 + 100))
      {
        *(_OWORD *)unint64_t v22 = *v18;
        *(_OWORD *)&v22[12] = *(_OWORD *)(a1 + 96);
        long long v19 = *(_OWORD *)(a2 - 16);
        *uint64_t v18 = *(_OWORD *)(a2 - 28);
        *(_OWORD *)(a1 + 96) = v19;
        *(_OWORD *)(a2 - 16) = *(_OWORD *)&v22[12];
        *(_OWORD *)(a2 - 28) = *(_OWORD *)v22;
        if (*(float *)(a1 + 100) > *(float *)(a1 + 72))
        {
          *(_OWORD *)unint64_t v23 = *v17;
          *(_OWORD *)&v23[12] = *(_OWORD *)(a1 + 68);
          _OWORD *v17 = *v18;
          *(_OWORD *)(a1 + 68) = *(_OWORD *)(a1 + 96);
          *uint64_t v18 = *(_OWORD *)v23;
          *(_OWORD *)(a1 + 96) = *(_OWORD *)&v23[12];
          if (*(float *)(a1 + 72) > *(float *)(a1 + 44))
          {
            *(_OWORD *)float v24 = *v16;
            *(_OWORD *)&v24[12] = *(_OWORD *)(a1 + 40);
            *uint64_t v16 = *v17;
            *(_OWORD *)(a1 + 40) = *(_OWORD *)(a1 + 68);
            _OWORD *v17 = *(_OWORD *)v24;
            *(_OWORD *)(a1 + 68) = *(_OWORD *)&v24[12];
            if (*(float *)(a1 + 44) > *(float *)(a1 + 16))
            {
              *(_OWORD *)unint64_t v25 = *(_OWORD *)a1;
              *(_OWORD *)&v25[12] = *(_OWORD *)(a1 + 12);
              *(_OWORD *)a1 = *v16;
              *(_OWORD *)(a1 + 12) = *(_OWORD *)(a1 + 40);
              *uint64_t v16 = *(_OWORD *)v25;
              *(_OWORD *)(a1 + 40) = *(_OWORD *)&v25[12];
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v7 = a1 + 56;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a1 + 28, a1 + 56);
      uint64_t v8 = a1 + 84;
      if (a1 + 84 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    float v11 = *(float *)(v8 + 16);
    if (v11 > *(float *)(v7 + 16))
    {
      long long v21 = *(_OWORD *)v8;
      uint64_t v12 = *(void *)(v8 + 20);
      uint64_t v13 = v9;
      while (1)
      {
        uint64_t v14 = a1 + v13;
        *(_OWORD *)(v14 + 84) = *(_OWORD *)(a1 + v13 + 56);
        *(_OWORD *)(v14 + 96) = *(_OWORD *)(a1 + v13 + 68);
        if (v13 == -56) {
          break;
        }
        v13 -= 28;
        if (v11 <= *(float *)(v14 + 44))
        {
          uint64_t v15 = a1 + v13 + 84;
          goto LABEL_13;
        }
      }
      uint64_t v15 = a1;
LABEL_13:
      *(_OWORD *)uint64_t v15 = v21;
      *(float *)(v15 + 16) = v11;
      *(void *)(v15 + 20) = v12;
      if (++v10 == 8) {
        return v8 + 28 == a2;
      }
    }
    uint64_t v7 = v8;
    v9 += 28;
    v8 += 28;
    if (v8 == a2) {
      return 1;
    }
  }
}

void sub_1A3FCE184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCE21C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNMRCDetector;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3FCE400(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void qd_trimImageBorders(char **a1)
{
  int v2 = *((_DWORD *)a1 + 4);
  int v3 = *((_DWORD *)a1 + 2);
  uint64_t v4 = a1[3];
  int v5 = (v2 + 1) >> 1;
  if (v5 >= (v3 + 1) >> 1) {
    int v5 = (v3 + 1) >> 1;
  }
  if (v5 >= 4) {
    int v6 = 4;
  }
  else {
    int v6 = v5;
  }
  uint64_t v7 = (int)v4;
  if (v5 >= 1)
  {
    uint64_t v8 = *a1;
    int v9 = v6;
    do
    {
      bzero(v8, (int)v4);
      v8 += (int)v4;
      --v9;
    }
    while (v9);
    int v10 = &(*a1)[(v3 - v6) * (uint64_t)(int)v4];
    int v11 = v6;
    do
    {
      bzero(v10, (int)v4);
      v10 += (int)v4;
      --v11;
    }
    while (v11);
  }
  int v12 = v3 - 2 * v6;
  if (v12 >= 1)
  {
    int v13 = (int)v4 / v2;
    int v14 = v12 & ~(v12 >> 31);
    uint64_t v15 = v6 * (uint64_t)(int)v4;
    uint64_t v16 = &(*a1)[v15];
    size_t v17 = v6 * v13;
    int v18 = v14;
    do
    {
      bzero(v16, v17);
      v16 += v7;
      --v18;
    }
    while (v18);
    long long v19 = &(*a1)[v15 + (v2 - v6) * v13];
    do
    {
      bzero(v19, v17);
      v19 += v7;
      --v14;
    }
    while (v14);
  }
}

void sub_1A3FCE7E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCE8AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCE924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCEA54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCF48C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  if (v11) {
    operator delete(v11);
  }
  _Unwind_Resume(a1);
}

void sub_1A3FCF5F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCF984(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCFC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCFE84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FCFF94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD00F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD03D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD059C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD0928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD0B60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD0D50(_Unwind_Exception *a1)
{
  int v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A3FD1030(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD12D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD13C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD14D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__24684(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__24685(uint64_t a1)
{
}

uint64_t *std::unique_ptr<cvml::util::model_file_cache>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *BOOL result = a2;
  if (v2)
  {
    std::mutex::~mutex((std::mutex *)(v2 + 40));
    int v3 = *(void **)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)*v3;
        std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,0>((uint64_t)(v3 + 2));
        operator delete(v3);
        int v3 = v4;
      }
      while (v4);
    }
    int v5 = *(void **)v2;
    *(void *)uint64_t v2 = 0;
    if (v5) {
      operator delete(v5);
    }
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    int v3 = *(void **)a1;
    operator delete(v3);
  }
}

void sub_1A3FD191C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A3FD19F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  std::mutex::unlock(v16);
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FD221C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, long long a13, uint64_t a14, uint64_t a15, void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,void *>>>>::reset[abi:ne180100]((uint64_t)&a23);
  if (*((void *)&a13 + 1)) {
    std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&a13 + 1));
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  std::mutex::unlock(v23);
  if (a22 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

uint64_t cvml::util::mapped_model_file::reset(uint64_t this)
{
  *(void *)(this + 8) = 0;
  return this;
}

uint64_t cvml::util::mapped_model_file::cleanup(cvml::util::mapped_model_file *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

void cvml::util::mapped_model_file::ptrFile(cvml::util::mapped_model_file *this)
{
  exceptiounint64_t n = __cxa_allocate_exception(8uLL);
}

void cvml::util::mapped_model_file::base_address(cvml::util::mapped_model_file *this)
{
  exceptiounint64_t n = __cxa_allocate_exception(8uLL);
}

void cvml::util::mapped_model_file::~mapped_model_file(cvml::util::mapped_model_file *this)
{
  *(void *)this = &unk_1EF751F90;
  *((void *)this + 1) = 0;
  JUMPOUT(0x1A62562C0);
}

{
  *(void *)this = &unk_1EF751F90;
  *((void *)this + 1) = 0;
}

uint64_t cvml::util::mapped_model_file_open::reset(uint64_t this)
{
  *(_DWORD *)(this + 16) = -1;
  *(void *)(this + 24) = 0;
  *(void *)(this + 8) = 0;
  return this;
}

uint64_t cvml::util::mapped_model_file_open::cleanup(cvml::util::mapped_model_file_open *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    size_t v3 = *((void *)this + 1);
    if (v3)
    {
      munmap(v2, v3);
      *((void *)this + 3) = 0;
    }
  }
  int v4 = *((_DWORD *)this + 4);
  if (v4 != -1)
  {
    close(v4);
    *((_DWORD *)this + 4) = -1;
  }
  int v5 = *(uint64_t (**)(cvml::util::mapped_model_file_open *))(*(void *)this + 48);

  return v5(this);
}

uint64_t cvml::util::mapped_model_file_open::advise(cvml::util::mapped_model_file_open *this, int a2)
{
  uint64_t result = *((void *)this + 3);
  if (result)
  {
    uint64_t result = madvise((void *)result, *((void *)this + 1), a2);
    if (result)
    {
      syslog(3, "Error %s when executing %s in file %s:%d\n", "::madvidse failed", "virtual void cvml::util::mapped_model_file_open::advise(int) const", "/Library/Caches/com.apple.xbs/Sources/Vision/VisionKitFramework/VN/algorithm_util/mapped_model_file.h", 155);
      __assert_rtn("syslog_assert_failed", "common_defines.h", 24, "false");
    }
  }
  return result;
}

uint64_t cvml::util::mapped_model_file_open::base_address(cvml::util::mapped_model_file_open *this)
{
  return *((void *)this + 3);
}

void cvml::util::mapped_model_file_open::~mapped_model_file_open(cvml::util::mapped_model_file_open *this)
{
  *(void *)this = &unk_1EF751F90;
  *((void *)this + 1) = 0;
  JUMPOUT(0x1A62562C0);
}

{
  *(void *)this = &unk_1EF751F90;
  *((void *)this + 1) = 0;
}

uint64_t std::__shared_ptr_emplace<cvml::util::mapped_model_file_open>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<cvml::util::mapped_model_file_open>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7533F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<cvml::util::mapped_model_file_open>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7533F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t cvml::util::mapped_model_file_fopen::reset(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  return this;
}

uint64_t cvml::util::mapped_model_file_fopen::cleanup(cvml::util::mapped_model_file_fopen *this)
{
  uint64_t v2 = (FILE *)*((void *)this + 2);
  if (v2)
  {
    fclose(v2);
    *((void *)this + 2) = 0;
  }
  size_t v3 = *(uint64_t (**)(cvml::util::mapped_model_file_fopen *))(*(void *)this + 48);

  return v3(this);
}

uint64_t cvml::util::mapped_model_file_fopen::ptrFile(cvml::util::mapped_model_file_fopen *this)
{
  return *((void *)this + 2);
}

void cvml::util::mapped_model_file_fopen::~mapped_model_file_fopen(cvml::util::mapped_model_file_fopen *this)
{
  *(void *)this = &unk_1EF751F90;
  *((void *)this + 1) = 0;
  JUMPOUT(0x1A62562C0);
}

{
  *(void *)this = &unk_1EF751F90;
  *((void *)this + 1) = 0;
}

uint64_t std::__shared_ptr_emplace<cvml::util::mapped_model_file_fopen>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<cvml::util::mapped_model_file_fopen>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753428;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<cvml::util::mapped_model_file_fopen>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753428;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A3FD2874(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD29A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t apple::vision::libraries::autotrace::actionF(uint64_t a1, __int32 a2, int8x8_t a3, int8x8_t a4)
{
  uint64_t result = apple::vision::libraries::autotrace::EPolygonList::newPolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), 50, 1);
  if (result)
  {
    int v9 = (apple::vision::libraries::autotrace::EPolygon *)result;
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtEnd((apple::vision::libraries::autotrace::EPolygon *)result);
    if (result)
    {
      int v11 = (void *)result;
      uint64_t result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v9);
      if (result)
      {
        v18.i32[0] = 0;
        v19.i32[0] = a2;
        int32x2_t v20 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vceq_s32(v19, v18), 0), a3, a4);
        *int v11 = v20;
        if (*(unsigned char *)(a1 + 40))
        {
          VNValidatedLog(4, @"%s: attempt to leave an open left end when a left end is already open", v12, v13, v14, v15, v16, v17, (uint64_t)"actionF");
          return 0;
        }
        else
        {
          v20.i32[0] = 0;
          int v21 = -858993459 * (((unint64_t)v9 - v10) >> 3);
          v19.i32[0] = a2;
          *(unsigned char *)(a1 + 40) = 1;
          *(_DWORD *)(a1 + 44) = v21;
          *(unsigned char *)(a1 + 48) = a2 == 0;
          *(int8x8_t *)uint64_t result = vbsl_s8((int8x8_t)vdup_lane_s32(vceq_s32(v19, v20), 0), a4, a3);
          BOOL v22 = a2 == 1;
          unint64_t v24 = *(void *)(a1 + 88);
          unint64_t v23 = *(void *)(a1 + 96);
          if (v24 >= v23)
          {
            uint64_t v26 = *(void *)(a1 + 80);
            uint64_t v27 = (uint64_t)(v24 - v26) >> 3;
            unint64_t v28 = v27 + 1;
            if ((unint64_t)(v27 + 1) >> 61) {
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v29 = v23 - v26;
            if (v29 >> 2 > v28) {
              unint64_t v28 = v29 >> 2;
            }
            if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v30 = v28;
            }
            float v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v30);
            float v32 = &v31[8 * v27];
            long long v34 = &v31[8 * v33];
            *(_DWORD *)float v32 = v21;
            v32[4] = v22;
            unint64_t v25 = v32 + 8;
            unint64_t v36 = *(unsigned char **)(a1 + 80);
            BOOL v35 = *(unsigned char **)(a1 + 88);
            if (v35 != v36)
            {
              do
              {
                int v37 = *((_DWORD *)v35 - 2);
                v35 -= 8;
                char v38 = v35[4];
                *((_DWORD *)v32 - 2) = v37;
                v32 -= 8;
                v32[4] = v38;
              }
              while (v35 != v36);
              BOOL v35 = *(unsigned char **)(a1 + 80);
            }
            *(void *)(a1 + 80) = v32;
            *(void *)(a1 + 88) = v25;
            *(void *)(a1 + 96) = v34;
            if (v35) {
              operator delete(v35);
            }
          }
          else
          {
            *(_DWORD *)unint64_t v24 = v21;
            *(unsigned char *)(v24 + 4) = v22;
            unint64_t v25 = (char *)(v24 + 8);
          }
          *(void *)(a1 + 88) = v25;
          return 1;
        }
      }
    }
  }
  return result;
}

char *apple::vision::libraries::autotrace::actionD(uint64_t a1, float32x2_t a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    VNValidatedLog(4, @"%s: attempt to connect to a left end when there is no left end open", a5, a6, a7, a8, a9, a10, (uint64_t)"actionD");
    return 0;
  }
  int v12 = *(_DWORD *)(a1 + 44);
  int v13 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v14 = *(void *)(a1 + 24);
  uint64_t v15 = (_DWORD *)(v14 + 40 * v12);
  if (*(unsigned char *)(a1 + 48)) {
    int v16 = v15[4];
  }
  else {
    int v16 = v15[4] + *v15 - 1;
  }
  int8x8_t v17 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(void *)(v14 + 40 * v12 + 8) + 8 * v16), a2));
  if ((v17.i32[0] | v17.i32[1]))
  {
    VNValidatedLog(4, @"%s: left end point does not match connected point", a5, a6, a7, a8, a9, a10, (uint64_t)"actionD");
    return 0;
  }
  int32x2_t v19 = (apple::vision::libraries::autotrace::EPolygon *)(v14 + 40 * v12);
  if (v13)
  {
    uint64_t result = apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v19);
    if (!result) {
      return result;
    }
  }
  else
  {
    uint64_t result = apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v19);
    if (!result) {
      return result;
    }
  }
  *(double *)uint64_t result = a3;
  *(unsigned char *)(a1 + 40) = 0;
  unint64_t v21 = *(void *)(a1 + 88);
  unint64_t v20 = *(void *)(a1 + 96);
  if (v21 >= v20)
  {
    uint64_t v23 = *(void *)(a1 + 80);
    uint64_t v24 = (uint64_t)(v21 - v23) >> 3;
    unint64_t v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v26 = v20 - v23;
    if (v26 >> 2 > v25) {
      unint64_t v25 = v26 >> 2;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    unint64_t v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v27);
    uint64_t v29 = &v28[8 * v24];
    float v31 = &v28[8 * v30];
    *(_DWORD *)uint64_t v29 = v12;
    v29[4] = v13;
    BOOL v22 = v29 + 8;
    uint64_t v33 = *(unsigned char **)(a1 + 80);
    float v32 = *(unsigned char **)(a1 + 88);
    if (v32 != v33)
    {
      do
      {
        int v34 = *((_DWORD *)v32 - 2);
        v32 -= 8;
        char v35 = v32[4];
        *((_DWORD *)v29 - 2) = v34;
        v29 -= 8;
        v29[4] = v35;
      }
      while (v32 != v33);
      float v32 = *(unsigned char **)(a1 + 80);
    }
    *(void *)(a1 + 80) = v29;
    *(void *)(a1 + 88) = v22;
    *(void *)(a1 + 96) = v31;
    if (v32) {
      operator delete(v32);
    }
  }
  else
  {
    *(_DWORD *)unint64_t v21 = v12;
    *(unsigned char *)(v21 + 4) = v13;
    BOOL v22 = (char *)(v21 + 8);
  }
  *(void *)(a1 + 88) = v22;
  return (char *)1;
}

uint64_t apple::vision::libraries::autotrace::actionE(uint64_t a1, float32x2_t a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    VNValidatedLog(4, @"%s: attempt to connect to a left end when there is no left end open", a5, a6, a7, a8, a9, a10, (uint64_t)"actionE");
    return 0;
  }
  int v12 = *(_DWORD *)(a1 + 44);
  int v13 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v14 = *(void *)(a1 + 24);
  uint64_t v15 = (_DWORD *)(v14 + 40 * v12);
  if (*(unsigned char *)(a1 + 48)) {
    int v16 = v15[4];
  }
  else {
    int v16 = v15[4] + *v15 - 1;
  }
  int8x8_t v17 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(void *)(v14 + 40 * v12 + 8) + 8 * v16), a2));
  if ((v17.i32[0] | v17.i32[1]))
  {
    VNValidatedLog(4, @"%s: left end point does not match connected point", a5, a6, a7, a8, a9, a10, (uint64_t)"actionE");
    return 0;
  }
  int32x2_t v19 = (apple::vision::libraries::autotrace::EPolygon *)(v14 + 40 * v12);
  if (v13)
  {
    uint64_t result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v19);
    if (!result) {
      return result;
    }
  }
  else
  {
    uint64_t result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v19);
    if (!result) {
      return result;
    }
  }
  *(double *)uint64_t result = a3;
  uint64_t result = 1;
  *(unsigned char *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 44) = v12;
  *(unsigned char *)(a1 + 48) = v13;
  return result;
}

uint64_t apple::vision::libraries::autotrace::actionB(uint64_t a1, float32x2_t a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*(unsigned char *)(a1 + 40))
  {
    VNValidatedLog(4, @"%s: no connection to open left end", a5, a6, a7, a8, a9, a10, (uint64_t)"actionB");
    return 0;
  }
  uint64_t v12 = *(int *)(a1 + 52);
  int v13 = (int *)(*(void *)(a1 + 56) + 8 * v12);
  *(_DWORD *)(a1 + 52) = v12 + 1;
  int v14 = *v13;
  char v15 = *((unsigned char *)v13 + 4);
  uint64_t v16 = *(void *)(a1 + 24);
  int8x8_t v17 = (_DWORD *)(v16 + 40 * *v13);
  if (v15) {
    int v18 = v17[4];
  }
  else {
    int v18 = v17[4] + *v17 - 1;
  }
  int8x8_t v19 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(void *)(v16 + 40 * v14 + 8) + 8 * v18), a2));
  if ((v19.i32[0] | v19.i32[1]))
  {
    VNValidatedLog(4, @"%s: top open end point does not match connected point", a5, a6, a7, a8, a9, a10, (uint64_t)"actionB");
    return 0;
  }
  unint64_t v21 = (apple::vision::libraries::autotrace::EPolygon *)(v16 + 40 * v14);
  if (!*((unsigned char *)v13 + 4))
  {
    uint64_t result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v21);
    if (!result) {
      return result;
    }
LABEL_14:
    *(double *)uint64_t result = a3;
    uint64_t result = 1;
    *(unsigned char *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v14;
    *(unsigned char *)(a1 + 48) = v15;
    return result;
  }
  uint64_t result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v21);
  if (result) {
    goto LABEL_14;
  }
  return result;
}

char *apple::vision::libraries::autotrace::actionC(uint64_t a1, float32x2_t a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*(unsigned char *)(a1 + 40))
  {
    VNValidatedLog(4, @"%s: no connection to open left end", a5, a6, a7, a8, a9, a10, (uint64_t)"actionC");
    return 0;
  }
  uint64_t v12 = *(int *)(a1 + 52);
  int v13 = (int *)(*(void *)(a1 + 56) + 8 * v12);
  *(_DWORD *)(a1 + 52) = v12 + 1;
  int v14 = *v13;
  char v15 = *((unsigned char *)v13 + 4);
  uint64_t v16 = *(void *)(a1 + 24);
  int8x8_t v17 = (_DWORD *)(v16 + 40 * *v13);
  if (v15) {
    int v18 = v17[4];
  }
  else {
    int v18 = v17[4] + *v17 - 1;
  }
  int8x8_t v19 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(void *)(v16 + 40 * v14 + 8) + 8 * v18), a2));
  if ((v19.i32[0] | v19.i32[1]))
  {
    VNValidatedLog(4, @"%s: top open end point does not match connected point", a5, a6, a7, a8, a9, a10, (uint64_t)"actionC");
    return 0;
  }
  unint64_t v21 = (apple::vision::libraries::autotrace::EPolygon *)(v16 + 40 * v14);
  if (*((unsigned char *)v13 + 4))
  {
    uint64_t result = apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v21);
    if (!result) {
      return result;
    }
  }
  else
  {
    uint64_t result = apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v21);
    if (!result) {
      return result;
    }
  }
  *(double *)uint64_t result = a3;
  *(unsigned char *)(a1 + 40) = 0;
  unint64_t v23 = *(void *)(a1 + 88);
  unint64_t v22 = *(void *)(a1 + 96);
  if (v23 >= v22)
  {
    uint64_t v25 = *(void *)(a1 + 80);
    uint64_t v26 = (uint64_t)(v23 - v25) >> 3;
    unint64_t v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v28 = v22 - v25;
    if (v28 >> 2 > v27) {
      unint64_t v27 = v28 >> 2;
    }
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v29 = v27;
    }
    uint64_t v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v29);
    float v31 = &v30[8 * v26];
    uint64_t v33 = &v30[8 * v32];
    *(_DWORD *)float v31 = v14;
    v31[4] = v15;
    uint64_t v24 = v31 + 8;
    char v35 = *(unsigned char **)(a1 + 80);
    int v34 = *(unsigned char **)(a1 + 88);
    if (v34 != v35)
    {
      do
      {
        int v36 = *((_DWORD *)v34 - 2);
        v34 -= 8;
        char v37 = v34[4];
        *((_DWORD *)v31 - 2) = v36;
        v31 -= 8;
        v31[4] = v37;
      }
      while (v34 != v35);
      int v34 = *(unsigned char **)(a1 + 80);
    }
    *(void *)(a1 + 80) = v31;
    *(void *)(a1 + 88) = v24;
    *(void *)(a1 + 96) = v33;
    if (v34) {
      operator delete(v34);
    }
  }
  else
  {
    *(_DWORD *)unint64_t v23 = v14;
    *(unsigned char *)(v23 + 4) = v15;
    uint64_t v24 = (char *)(v23 + 8);
  }
  *(void *)(a1 + 88) = v24;
  return (char *)1;
}

char *apple::vision::libraries::autotrace::actionA(uint64_t a1, float32x2_t a2, float32x2_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v12 = *(int *)(a1 + 52);
    uint64_t v13 = *(void *)(a1 + 56) + 8 * v12;
    *(_DWORD *)(a1 + 52) = v12 + 1;
    int v14 = *(_DWORD *)v13;
    char v15 = (unsigned char *)(v13 + 4);
    uint64_t v16 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v13 + 4))
    {
      int v17 = *(_DWORD *)(v16 + 40 * v14 + 16);
      int v18 = v17;
    }
    else
    {
      int8x8_t v19 = (_DWORD *)(v16 + 40 * v14);
      int v17 = v19[4];
      int v18 = v17 + *v19 - 1;
    }
    uint64_t v20 = v16 + 40 * v14;
    unint64_t v23 = *(char **)(v20 + 8);
    unint64_t v22 = (float32x2_t **)(v20 + 8);
    unint64_t v21 = v23;
    int8x8_t v24 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)&v23[8 * v18], a2));
    if ((v24.i32[0] | v24.i32[1]))
    {
      VNValidatedLog(4, @"%s: top open end point does not match connected point", a5, a6, a7, a8, a9, a10, (uint64_t)"actionA");
      return 0;
    }
    if (*(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(v13 + 4))
    {
      VNValidatedLog(4, @"%s: polygon front/back ends should be opposite on closure", a5, a6, a7, a8, a9, a10, (uint64_t)"actionA");
      return 0;
    }
    if (*(_DWORD *)(a1 + 44) == v14)
    {
      if (!*(unsigned char *)(a1 + 48)) {
        int v17 = v17 + *(_DWORD *)(v16 + 40 * v14) - 1;
      }
      int8x8_t v25 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)&v21[8 * v17], a3));
      if ((v25.i32[0] | v25.i32[1]))
      {
        VNValidatedLog(4, @"%s: left end point does not match connected point", a5, a6, a7, a8, a9, a10, (uint64_t)"actionA");
        return 0;
      }
      int v34 = (int *)(v16 + 40 * v14);
      uint64_t v35 = *v34;
      int v36 = (float32x2_t *)malloc_type_malloc(8 * v35, 0x100004000313F17uLL);
      if (!v36)
      {
        VNValidatedLog(4, @"%s: could not trim extract polygons point list", v37, v38, v39, v40, v41, v42, (uint64_t)"closePolygon");
        return 0;
      }
      uint64_t v43 = v36;
      uint64_t v44 = v16 + 40 * v14;
      memmove(v36, &v21[8 * *(int *)(v44 + 16)], 8 * v35);
      *(_DWORD *)(v44 + 16) = 0;
      *(_DWORD *)(v44 + 4) = v35;
      free(v21);
      *unint64_t v22 = v43;
      *(unsigned char *)(v44 + 20) = 1;
      uint64_t v45 = *v34;
      float v46 = *(float *)(a1 + 8) * *(float *)(a1 + 8);
      if ((int)v45 >= 1)
      {
        uint64_t v47 = 0;
        int v48 = 0;
        while (v47)
        {
          float32x2_t v49 = vsub_f32(v43[v47], v43[v47 - 1]);
          if (vmlas_n_f32(COERCE_FLOAT(vmul_f32(v49, v49).i32[1]), v49.f32[0], v49.f32[0]) > v46)
          {
            if (v47 != v48)
            {
              float32x2_t v50 = v43[v47];
              goto LABEL_27;
            }
            goto LABEL_28;
          }
LABEL_29:
          if (v45 == ++v47) {
            goto LABEL_38;
          }
        }
        if (v48)
        {
          float32x2_t v50 = *v43;
LABEL_27:
          v43[v48] = v50;
        }
LABEL_28:
        ++v48;
        goto LABEL_29;
      }
      int v48 = 0;
LABEL_38:
      float32x2_t v54 = vsub_f32(*v43, v43[(int)v45 - 1]);
      int32x2_t v55 = (int32x2_t)vmul_f32(v54, v54);
      int v56 = v48 - (vmlas_n_f32(*(float *)&v55.i32[1], v54.f32[0], v54.f32[0]) <= v46);
      *int v34 = v56;
      if (v56 > 2)
      {
        if (*(unsigned char *)a1)
        {
          uint64_t v57 = 0;
          v55.i32[0] = *(_DWORD *)(a1 + 4);
          float v58 = (float)(*(float *)v55.i32 * 2.0) + -2.0;
          float v59 = (float)(*(float *)v55.i32 * -3.0) + 3.0;
          float v60 = *v22;
          float32x2_t v61 = (float32x2_t)vdup_lane_s32(v55, 0);
          do
          {
            float32x2_t v62 = v60[v57];
            float32x2_t v63 = vrndm_f32(v62);
            float32x2_t v64 = vsub_f32(v62, v63);
            v60[v57++] = vadd_f32(v63, vmla_f32(vmla_f32(vmul_f32(v64, vmul_n_f32(v64, v59)), v64, vmul_f32(v64, vmul_n_f32(v64, v58))), v64, v61));
          }
          while ((int)v57 < *v34);
        }
        if (*(unsigned char *)(a1 + 144))
        {
          int64_t v65 = (int *)(a1 + 16);
          int64_t v66 = (int *)apple::vision::libraries::autotrace::EPolygonList::containsPolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), (EPolygon *)v34);
          if (v66)
          {
            do
            {
              float v73 = (apple::vision::libraries::autotrace::EPolygon *)v66;
              int v74 = v66[7];
              if (v74 == -1) {
                break;
              }
              int64_t v66 = (int *)apple::vision::libraries::autotrace::EPolygonList::containsPolygonInChildList((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v74, v67, **((double **)v34 + 1));
            }
            while (v66);
            apple::vision::libraries::autotrace::EPolygonList::insertPolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v73, (apple::vision::libraries::autotrace::EPolygon *)v34, v68, v69, v70, v71, v72);
          }
          else
          {
            int v102 = *v65;
            if (*v65 >= 1)
            {
              int v103 = 0;
              uint64_t v104 = *(void *)(a1 + 24);
              do
              {
                if ((int *)v104 != v34 && !*(unsigned char *)(v104 + 21))
                {
                  if (*(unsigned char *)(v104 + 20))
                  {
                    double v105 = **(double **)(v104 + 8);
                    if (apple::vision::libraries::autotrace::EPolygon::containsPoint((unsigned int *)v34, v105))
                    {
                      int v112 = (unsigned int *)v34;
                      do
                      {
                        int v113 = (apple::vision::libraries::autotrace::EPolygon *)v112;
                        int v114 = v112[7];
                        if (v114 == -1) {
                          break;
                        }
                        int v112 = apple::vision::libraries::autotrace::EPolygonList::containsPolygonInChildList((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v114, v106, v105);
                      }
                      while (v112);
                      apple::vision::libraries::autotrace::EPolygonList::insertPolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v113, (apple::vision::libraries::autotrace::EPolygon *)v104, v107, v108, v109, v110, v111);
                      int v102 = *v65;
                    }
                  }
                }
                ++v103;
                v104 += 40;
              }
              while (v103 < v102);
            }
          }
        }
      }
      else
      {
        apple::vision::libraries::autotrace::EPolygonList::freePolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), (apple::vision::libraries::autotrace::EPolygon *)v34);
      }
    }
    else
    {
      uint64_t v26 = (apple::vision::libraries::autotrace::EPolygon *)(v16 + 40 * v14);
      if (*(unsigned char *)(v13 + 4))
      {
        uint64_t result = apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v26);
        if (!result) {
          return result;
        }
      }
      else
      {
        uint64_t result = apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v26);
        if (!result) {
          return result;
        }
      }
      *(double *)uint64_t result = *(double *)&a3;
      if (*v15 == *(unsigned char *)(a1 + 48))
      {
        VNValidatedLog(4, @"%s: join polygons occurs at wrong ends", v28, v29, v30, v31, v32, v33, (uint64_t)"joinOpenEnds");
        return 0;
      }
      uint64_t v51 = *(void *)(a1 + 24);
      int v52 = *(_DWORD *)v13;
      if (*v15) {
        int v53 = *(_DWORD *)(v51 + 40 * v52 + 16);
      }
      else {
        int v53 = *(_DWORD *)(v51 + 40 * v52 + 16) + *(_DWORD *)(v51 + 40 * v52) - 1;
      }
      uint64_t v75 = v51 + 40 * v52;
      uint64_t v77 = *(void *)(v75 + 8);
      uint64_t v76 = (void **)(v75 + 8);
      float32x2_t v78 = *(float32x2_t *)(v77 + 8 * v53);
      int v79 = *(_DWORD *)(a1 + 44);
      if (*(unsigned char *)(a1 + 48)) {
        int v80 = *(_DWORD *)(v51 + 40 * v79 + 16);
      }
      else {
        int v80 = *(_DWORD *)(v51 + 40 * v79 + 16) + *(_DWORD *)(v51 + 40 * v79) - 1;
      }
      uint64_t v81 = v51 + 40 * v79;
      uint64_t v83 = *(void *)(v81 + 8);
      uint64_t v82 = (void **)(v81 + 8);
      int8x8_t v84 = vmvn_s8((int8x8_t)vceq_f32(v78, *(float32x2_t *)(v83 + 8 * v80)));
      if ((v84.i32[0] | v84.i32[1]))
      {
        VNValidatedLog(4, @"%s: join polygons point does not match connected point", v28, v29, v30, v31, v32, v33, (uint64_t)"joinOpenEnds");
        return 0;
      }
      int v123 = (apple::vision::libraries::autotrace::EPolygon *)(v51 + 40 * v52);
      int v85 = *(_DWORD *)(v51 + 40 * v79) + *(_DWORD *)v123;
      int v122 = v85 + 99;
      uint64_t v86 = (char *)malloc_type_malloc(8 * (v85 + 99), 0x100004000313F17uLL);
      if (!v86)
      {
        VNValidatedLog(4, @"%s: could not extend extract polygons point list", v87, v88, v89, v90, v91, v92, (uint64_t)"joinOpenEnds");
        return 0;
      }
      unint64_t v93 = v86;
      float v94 = v86 + 400;
      int v121 = v85 - 1;
      if (*v15)
      {
        uint64_t v95 = v51 + 40 * v79;
        uint64_t v97 = *(int *)(v95 + 16);
        float v96 = (_DWORD *)(v95 + 16);
        long long v98 = (int *)(v51 + 40 * v79);
        memmove(v94, (char *)*v82 + 8 * v97, 8 * *v98 - 8);
        long long v99 = (int *)(v51 + 40 * v52 + 16);
        float v100 = v98;
        float v101 = (int *)(v51 + 40 * v52);
      }
      else
      {
        memmove(v94, (char *)*v76 + 8 * *(int *)(v51 + 40 * v52 + 16), 8 * *(int *)v123 - 8);
        float v100 = (int *)(v51 + 40 * v52);
        long long v99 = (int *)(v51 + 40 * v79 + 16);
        uint64_t v76 = v82;
        long long v98 = (int *)(v51 + 40 * v79);
        float v101 = v98;
        float v96 = v99;
      }
      memmove(&v93[8 * *v100 + 392], (char *)*v76 + 8 * *v99, 8 * *v101);
      *float v96 = 50;
      *long long v98 = v121;
      *(_DWORD *)(v51 + 40 * v79 + 4) = v122;
      free(*v82);
      *uint64_t v82 = v93;
      apple::vision::libraries::autotrace::EPolygonList::freePolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v123);
      float v115 = *(_DWORD **)(a1 + 56);
      uint64_t v116 = *(void *)(a1 + 64) - (void)v115;
      if (v116)
      {
        unint64_t v117 = v116 >> 3;
        if (v117 <= 1) {
          unint64_t v117 = 1;
        }
        do
        {
          if (*v115 == v52) {
            _DWORD *v115 = v79;
          }
          v115 += 2;
          --v117;
        }
        while (v117);
      }
      float v118 = *(_DWORD **)(a1 + 80);
      uint64_t v119 = *(void *)(a1 + 88) - (void)v118;
      if (v119)
      {
        unint64_t v120 = v119 >> 3;
        if (v120 <= 1) {
          unint64_t v120 = 1;
        }
        do
        {
          if (*v118 == v52) {
            *float v118 = v79;
          }
          v118 += 2;
          --v120;
        }
        while (v120);
      }
      if (*(_DWORD *)(a1 + 44) == v52) {
        *(_DWORD *)(a1 + 44) = v79;
      }
    }
    *(unsigned char *)(a1 + 40) = 0;
    return (char *)1;
  }
  VNValidatedLog(4, @"%s: attempt to connect to a left end when there is no left end open", a5, a6, a7, a8, a9, a10, (uint64_t)"actionA");
  return 0;
}

void apple::vision::libraries::autotrace::encodePolygonData(apple::vision::libraries::autotrace *this, apple::vision::libraries::autotrace::BitmapToContourEnvironment *a2, apple::vision::libraries::autotrace::EPolygon *a3)
{
  int v4 = (apple::vision::libraries::autotrace *)((char *)this + 104);
  int v5 = (char *)malloc_type_malloc(4 * *(_DWORD *)a2 + 8, 0xB5F44F28uLL);
  int v6 = (int *)v5;
  uint64_t v7 = (float32x2_t *)*((void *)a2 + 1);
  float64x2_t v8 = (float64x2_t)vdupq_n_s64(0x4070000000000000uLL);
  uint64_t v76 = a2;
  uint64_t v9 = *(unsigned int *)a2;
  int32x2_t v10 = vmovn_s64(vcvtq_s64_f64(vrndxq_f64(vmulq_f64(vcvtq_f64_f32(*v7), v8))));
  *(_DWORD *)int v5 = v9;
  int32x2_t v77 = v10;
  *(int32x2_t *)(v5 + 4) = v10;
  int v11 = (__int16 *)(v5 + 12);
  if ((int)v9 >= 2)
  {
    uint64_t v12 = v9 - 1;
    uint64_t v13 = v7 + 1;
    int v14 = v5 + 12;
    do
    {
      float32x2_t v15 = *v13++;
      int32x2_t v16 = vmovn_s64(vcvtq_s64_f64(vrndxq_f64(vmulq_f64(vcvtq_f64_f32(v15), v8))));
      int32x2_t v17 = vsub_s32(v16, v10);
      v14[1] = v17.i16[2];
      *int v14 = v17.i16[0];
      v14 += 2;
      int32x2_t v10 = v16;
      --v12;
    }
    while (v12);
  }
  apple::vision::libraries::autotrace::BitString::writeBit(v4, 0);
  unsigned int v18 = 0x80000000;
  int v19 = 32;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, (v18 & v9) != 0);
    v18 >>= 1;
    --v19;
  }
  while (v19);
  unsigned int v20 = 0x80000000;
  int v21 = 32;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, (v20 & v77.i32[0]) != 0);
    v20 >>= 1;
    --v21;
  }
  while (v21);
  unsigned int v22 = 0x80000000;
  int v23 = 32;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, (v22 & v77.i32[1]) != 0);
    v22 >>= 1;
    --v23;
  }
  while (v23);
  unsigned int v24 = 8;
  int v25 = 4;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, v24 > 7);
    v24 >>= 1;
    --v25;
  }
  while (v25);
  int v26 = *v6;
  if (*v6 >= 2)
  {
    int v27 = 1;
    do
    {
      int v28 = v26 - 1;
      int v29 = *v11;
      if (v27 >= v26 - 1)
      {
        int v30 = 0;
        int v31 = 0;
      }
      else
      {
        int v30 = v11[2] + v29;
        int v31 = v11[3] + v11[1];
      }
      uint64_t v32 = 4294967040;
      if (v29 == -256 || v30 == -256 || v30 == -512 || (uint64_t v32 = 256, v29 == 256) || v30 == 256 || v30 == 512)
      {
        int v34 = v27;
        if (v27 < v26)
        {
          uint64_t v35 = v11;
          int v34 = v27;
          do
          {
            int v36 = *v35;
            if (v34 >= v28) {
              int v37 = 0;
            }
            else {
              int v37 = v35[2] + v36;
            }
            if (v32 == v36)
            {
              unsigned int v38 = 1;
            }
            else
            {
              unsigned int v38 = 2;
              if (v37 != v32 && v37 != 2 * v32) {
                break;
              }
            }
            v34 += v38;
            v35 += 2 * v38;
          }
          while (v34 < v26);
        }
        signed int v33 = v34 - v27;
      }
      else
      {
        uint64_t v32 = 0;
        signed int v33 = 0;
      }
      int v39 = (unsigned __int16)v11[1];
      uint64_t v40 = 4294967040;
      if (v39 == 65280 || v31 == -256 || v31 == -512 || (uint64_t v40 = 256, v39 == 256) || v31 == 256 || v31 == 512)
      {
        int v42 = v27;
        if (v27 < v26)
        {
          uint64_t v43 = v11;
          int v42 = v27;
          do
          {
            int v44 = v43[1];
            if (v42 >= v28) {
              int v45 = 0;
            }
            else {
              int v45 = v43[3] + v44;
            }
            if (v40 == v44)
            {
              unsigned int v46 = 1;
            }
            else
            {
              unsigned int v46 = 2;
              if (v45 != v40 && v45 != 2 * v40) {
                break;
              }
            }
            v42 += v46;
            v43 += 2 * v46;
          }
          while (v42 < v26);
        }
        signed int v41 = v42 - v27;
      }
      else
      {
        uint64_t v40 = 0;
        signed int v41 = 0;
      }
      if (v33 | v41)
      {
        if (v33 >= v41)
        {
          apple::vision::libraries::autotrace::encodeRunStart(v4, 0, v32, v33);
          int v67 = *v6;
          int v68 = v27;
          if (v27 < *v6)
          {
            uint64_t v69 = v11;
            int v68 = v27;
            do
            {
              uint64_t v61 = *v69;
              if (v68 >= v67 - 1) {
                int v70 = 0;
              }
              else {
                int v70 = v69[2] + v61;
              }
              if (v32 == v61)
              {
                apple::vision::libraries::autotrace::encodeRunContinuationOneSample(v4, (apple::vision::libraries::autotrace::BitString *)v69[1]);
                unsigned int v71 = 1;
              }
              else
              {
                if (v70 != v32 && v70 != 2 * v32) {
                  break;
                }
                apple::vision::libraries::autotrace::encodeRunContinuationTwoSamples(v4, (apple::vision::libraries::autotrace::BitString *)v32, v61, v69[2], v69[1], v69[3], v65, v66);
                unsigned int v71 = 2;
              }
              v68 += v71;
              v69 += 2 * v71;
              int v67 = *v6;
            }
            while (v68 < *v6);
          }
          if (v68 - v27 != v33) {
            VNValidatedLog(4, @"%s: run length doesn't match up (%d vs %d) for an x run direction %d", v61, v62, v63, v64, v65, v66, (uint64_t)"encodePolygonData");
          }
        }
        else
        {
          apple::vision::libraries::autotrace::encodeRunStart(v4, (apple::vision::libraries::autotrace::BitString *)1, v40, v41);
          int v55 = *v6;
          if (v27 < *v6)
          {
            int v56 = v11;
            int v57 = v27;
            do
            {
              uint64_t v58 = v56[1];
              if (v57 >= v55 - 1) {
                int v59 = 0;
              }
              else {
                int v59 = v56[3] + v58;
              }
              if (v40 == v58)
              {
                apple::vision::libraries::autotrace::encodeRunContinuationOneSample(v4, (apple::vision::libraries::autotrace::BitString *)*v56);
                unsigned int v60 = 1;
              }
              else
              {
                if (v59 != v40 && v59 != 2 * v40) {
                  break;
                }
                apple::vision::libraries::autotrace::encodeRunContinuationTwoSamples(v4, (apple::vision::libraries::autotrace::BitString *)v40, v58, v56[3], *v56, v56[2], v53, v54);
                unsigned int v60 = 2;
              }
              v57 += v60;
              v56 += 2 * v60;
              int v55 = *v6;
            }
            while (v57 < *v6);
          }
          signed int v33 = v41;
        }
      }
      else
      {
        apple::vision::libraries::autotrace::BitString::writeBit(v4, 0);
        int v47 = (unsigned __int16)v29 + 512;
        unsigned int v48 = 512;
        int v49 = 10;
        do
        {
          apple::vision::libraries::autotrace::BitString::writeBit(v4, (v48 & v47) != 0);
          v48 >>= 1;
          --v49;
        }
        while (v49);
        int v50 = v39 + 512;
        unsigned int v51 = 512;
        int v52 = 10;
        do
        {
          apple::vision::libraries::autotrace::BitString::writeBit(v4, (v51 & v50) != 0);
          v51 >>= 1;
          --v52;
        }
        while (v52);
        signed int v33 = 1;
      }
      v27 += v33;
      v11 += 2 * v33;
      int v26 = *v6;
    }
    while (v27 < *v6);
  }
  if (*((_DWORD *)v76 + 7) != -1)
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, 1);
    apple::vision::libraries::autotrace::BitString::writeBit(v4, 0);
    for (int i = *((_DWORD *)v76 + 7); i != -1; int i = *((_DWORD *)v74 + 6))
    {
      int v74 = (apple::vision::libraries::autotrace::BitmapToContourEnvironment *)(*((void *)this + 3) + 40 * i);
      apple::vision::libraries::autotrace::encodePolygonData(this, v74, v72);
    }
    apple::vision::libraries::autotrace::BitString::writeBit(v4, 1);
    apple::vision::libraries::autotrace::BitString::writeBit(v4, 1);
  }

  free(v6);
}

void apple::vision::libraries::autotrace::BitmapToContourEnvironment::~BitmapToContourEnvironment(apple::vision::libraries::autotrace::BitmapToContourEnvironment *this)
{
  apple::vision::libraries::autotrace::EPolygonList::term((apple::vision::libraries::autotrace::BitmapToContourEnvironment *)((char *)this + 16));
  uint64_t v2 = (void *)*((void *)this + 13);
  if (v2)
  {
    *((void *)this + 14) = v2;
    operator delete(v2);
  }
  size_t v3 = (void *)*((void *)this + 10);
  if (v3)
  {
    *((void *)this + 11) = v3;
    operator delete(v3);
  }
  int v4 = (void *)*((void *)this + 7);
  if (v4)
  {
    *((void *)this + 8) = v4;
    operator delete(v4);
  }
}

void apple::vision::libraries::autotrace::encodeRunStart(apple::vision::libraries::autotrace *this, apple::vision::libraries::autotrace::BitString *a2, int a3, unsigned int a4)
{
  int v6 = (int)a2;
  apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
  if (v6)
  {
    if (a3 == -256)
    {
      int v17 = 2;
      unsigned int v18 = 2;
      do
      {
        apple::vision::libraries::autotrace::BitString::writeBit(this, v18 > 1);
        v18 >>= 1;
        --v17;
      }
      while (v17);
      goto LABEL_21;
    }
    if (a3 == 256)
    {
      int v14 = 2;
      do
      {
        apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
        --v14;
      }
      while (v14);
      goto LABEL_21;
    }
    int v19 = @"%s: illegal direction %d in y run";
  }
  else
  {
    if (a3 == -256)
    {
      int v20 = 2;
      do
      {
        apple::vision::libraries::autotrace::BitString::writeBit(this, 0);
        --v20;
      }
      while (v20);
      goto LABEL_21;
    }
    if (a3 == 256)
    {
      int v15 = 2;
      unsigned int v16 = 2;
      do
      {
        apple::vision::libraries::autotrace::BitString::writeBit(this, v16 & 1);
        v16 >>= 1;
        --v15;
      }
      while (v15);
      goto LABEL_21;
    }
    int v19 = @"%s: illegal direction %d in x run";
  }
  VNValidatedLog(4, (uint64_t)v19, v8, v9, v10, v11, v12, v13, (uint64_t)"encodeRunStart");
LABEL_21:
  if (a4 >= 0x10)
  {
    int v24 = 4;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
      --v24;
    }
    while (v24);
    unsigned int v25 = 0x80000000;
    int v26 = 32;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, (v25 & a4) != 0);
      v25 >>= 1;
      --v26;
    }
    while (v26);
  }
  else
  {
    unsigned int v21 = a4 - 1;
    unsigned int v22 = 8;
    int v23 = 4;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, (v22 & v21) != 0);
      v22 >>= 1;
      --v23;
    }
    while (v23);
  }
}

void apple::vision::libraries::autotrace::encodeRunContinuationOneSample(apple::vision::libraries::autotrace *this, apple::vision::libraries::autotrace::BitString *a2)
{
  int v2 = (int)a2;
  apple::vision::libraries::autotrace::BitString::writeBit(this, 0);
  if (v2 >= 0) {
    unsigned int v4 = v2;
  }
  else {
    unsigned int v4 = -v2;
  }
  int v5 = 5;
  if (v4 >= 0x10)
  {
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
      --v5;
    }
    while (v5);
    int v5 = 10;
    int v6 = 512;
  }
  else
  {
    int v6 = 15;
  }
  int v7 = v6 + v2;
  unsigned int v8 = 1 << (v5 - 1);
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(this, (v8 & v7) != 0);
    v8 >>= 1;
    --v5;
  }
  while (v5);
}

void apple::vision::libraries::autotrace::encodeRunContinuationTwoSamples(apple::vision::libraries::autotrace *this, apple::vision::libraries::autotrace::BitString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a6;
  int v9 = a5;
  int v10 = a3;
  if (a4 + a3 == a2)
  {
    int v12 = 2;
    unsigned int v13 = 2;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, v13 > 1);
      v13 >>= 1;
      --v12;
    }
    while (v12);
  }
  else if (a4 + a3 == 2 * a2)
  {
    int v14 = 2;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
      --v14;
    }
    while (v14);
  }
  else
  {
    VNValidatedLog(4, @"%s: illegal two sample direction sum along run", a3, a4, a5, a6, a7, a8, (uint64_t)"encodeRunContinuationTwoSamples");
  }
  int v15 = v10 + 512;
  unsigned int v16 = 512;
  int v17 = 10;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(this, (v16 & v15) != 0);
    v16 >>= 1;
    --v17;
  }
  while (v17);
  int v18 = v9 + 512;
  unsigned int v19 = 512;
  int v20 = 10;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(this, (v19 & v18) != 0);
    v19 >>= 1;
    --v20;
  }
  while (v20);
  int v21 = v8 + 512;
  unsigned int v22 = 512;
  int v23 = 10;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(this, (v22 & v21) != 0);
    v22 >>= 1;
    --v23;
  }
  while (v23);
}

void sub_1A3FD43FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD4634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3FD47FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD48F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD49F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD4C10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD4D40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD4EDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unsigned int v16 = v13;

  _Unwind_Resume(a1);
}

void sub_1A3FD4FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD5480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD55F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3FD56DC(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3FD57D8(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3FD5910(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD599C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD5A94(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3FD5BAC(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3FD5D2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL29_asyncProcessingDispatchQueuev_block_invoke()
{
  int v2 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E4F14430], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v0 = dispatch_queue_create("com.apple.VNSession", v2);
  uint64_t v1 = (void *)_asyncProcessingDispatchQueue(void)::ourProcessingDispatchQueue;
  _asyncProcessingDispatchQueue(void)::ourProcessingDispatchQueue = (uint64_t)v0;
}

void sub_1A3FD5FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD6210(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD62B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD6368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  a9.super_class = (Class)VNSession;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A3FD6650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD6854(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD6A90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3FD7650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void *std::vector<CGPoint>::vector(void *a1, unint64_t a2, _OWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<vision::mod::DescriptorItemSideInfo>::__vallocate[abi:ne180100](a1, a2);
    int v6 = (_OWORD *)a1[1];
    int v7 = &v6[a2];
    uint64_t v8 = 16 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 16;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1A3FD78FC(_Unwind_Exception *exception_object)
{
  size_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shuffle[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<CGPoint *>,std::__wrap_iter<CGPoint *>,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((uint64_t)(a2 - a1) >= 17)
  {
    unsigned int v4 = (long long *)a1;
    unint64_t v5 = a2 - 16;
    if (a2 - 16 > a1)
    {
      uint64_t v7 = ((a2 - a1) >> 4) - 1;
      do
      {
        v11[0] = 0;
        v11[1] = v7;
        uint64_t v8 = std::uniform_int_distribution<long>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(a3, v11);
        if (v8)
        {
          long long v9 = *v4;
          long long *v4 = v4[v8];
          v4[v8] = v9;
        }
        ++v4;
        --v7;
      }
      while ((unint64_t)v4 < v5);
    }
  }
  return a2;
}

void sub_1A3FD7B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FD7CCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD7F90(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v3, 0x10B1C40765A9CC9);

  _Unwind_Resume(a1);
}

void sub_1A3FD810C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD83E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD85B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD86C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD89D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD8C80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD8F08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v11 = v10;

  _Unwind_Resume(a1);
}

void sub_1A3FD9354(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD95BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD98EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getAVDepthDataClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!AVFoundationLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x1E4F143A8];
    v4[2] = 3221225472;
    v4[3] = __AVFoundationLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E5B1E650;
    uint64_t v6 = 0;
    AVFoundationLibraryCore_frameworkLibrardouble y = _sl_dlopen();
    int v2 = (void *)v4[0];
    if (!AVFoundationLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("AVDepthData");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    int v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getAVDepthDataClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __AVFoundationLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  AVFoundationLibraryCore_frameworkLibrardouble y = result;
  return result;
}

void sub_1A3FD9D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD9E44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD9F40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FD9FA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDA0FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDA3EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDA50C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDA744(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDA82C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDA918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDABA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDAC20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDACBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDADEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDAF04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDAF74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDAFC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB020(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB06C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB0CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB118(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB188(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB1F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB2D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB3AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB40C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB458(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB794(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDB95C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDBD74(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3FDBF94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDC078(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDC104(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDCD0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDCDB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDCF1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD0F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD2B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

id _sequenceKeyComponentForArray(NSArray *a1)
{
  uint64_t v1 = a1;
  if (v1)
  {
    int v2 = (void *)[objc_alloc(MEMORY[0x1E4F1CAD0]) initWithArray:v1];
    uint64_t v3 = [v2 allObjects];
    unsigned int v4 = NSString;
    long long v5 = [v3 componentsJoinedByString:@","];
    uint64_t v6 = [v4 stringWithFormat:@"[%@]", v5];
  }
  else
  {
    uint64_t v6 = 0;
  }

  return v6;
}

void sub_1A3FDD3C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD430(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD490(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD4DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD53C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD588(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD5E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD63C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD6A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD6F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD79C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD8A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD8F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDD9A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDDA00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDDA60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDDAD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDDB40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDDBB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDDDA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDE208(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDE310(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDE3A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDE4FC(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A3FDE510(_Unwind_Exception *a1)
{
}

void sub_1A3FDE78C(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3FDE9A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDEAC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDEC10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDED5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDEE74(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v2);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v1 + 16));
  objc_exception_rethrow();
}

void sub_1A3FDEE90(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3FDEF80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDF12C(_Unwind_Exception *a1)
{
}

void sub_1A3FDF2D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDF504(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDF6F4(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A3FDF7C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDF924(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDF9C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDFA94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDFB60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDFBF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDFCA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDFE28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDFF0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FDFFAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE022C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE036C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE05B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE06C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE0768(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE080C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE0AEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE0C1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE0DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE0EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE1194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *a27,void *a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,id a40)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__39_26522(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__40_26523(uint64_t a1)
{
}

void sub_1A3FE1308(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE1604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose((const void *)(v30 - 144), 8);

  _Unwind_Resume(a1);
}

void sub_1A3FE170C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE3010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,void *a61)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE3614(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,void *a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62)
{
  if (v64) {
    operator delete(v64);
  }

  JUMPOUT(0x1A3FE35ECLL);
}

void sub_1A3FE3638()
{
  JUMPOUT(0x1A3FE3660);
}

void sub_1A3FE3648()
{
}

void sub_1A3FE3650(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,void *a55,uint64_t a56,void *a57)
{
  if (v57) {
    operator delete(v57);
  }
  if (v61) {
    operator delete(v61);
  }

  JUMPOUT(0x1A3FE35ECLL);
}

void sub_1A3FE365C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,void *a44,void *a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,void *a52,void *a53,uint64_t a54,void *a55,uint64_t a56,void *a57)
{
  JUMPOUT(0x1A3FE35ECLL);
}

void sub_1A3FE3988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE3D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE4104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE4214(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE4370(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE4718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *exc_buf, void *a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (a2)
  {

    objc_begin_catch(a1);
    JUMPOUT(0x1A3FE4684);
  }
  _Unwind_Resume(a1);
}

void sub_1A3FE4938(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE4B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE4C3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE4E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE4F4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE503C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE51C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE5324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE5580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE5C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE6720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,void *a21,void *a22,void *a23,uint64_t a24,uint64_t a25,_Unwind_Exception *exception_object,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE6974()
{
}

void sub_1A3FE6A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE6AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE6B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE6EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE7010(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A3FE713C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unsigned int v13 = v12;

  _Unwind_Resume(a1);
}

void sub_1A3FE7470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE7564(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE773C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE78E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE7A28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE7D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE8094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE83C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE8590(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE865C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE8D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<std::tuple<objc_class * {__strong},unsigned long>,CSUSceneNetV5ConfigurationRevision>,std::__map_value_compare<std::tuple<objc_class * {__strong},unsigned long>,std::__value_type<std::tuple<objc_class * {__strong},unsigned long>,CSUSceneNetV5ConfigurationRevision>,std::less<std::tuple<objc_class * {__strong},unsigned long>>,true>,std::allocator<std::__value_type<std::tuple<objc_class * {__strong},unsigned long>,CSUSceneNetV5ConfigurationRevision>>>::__emplace_unique_key_args<std::tuple<objc_class * {__strong},unsigned long>,std::piecewise_construct_t const&,std::tuple<std::tuple<objc_class * {__strong},unsigned long>&&>,std::tuple<>>(uint64_t **a1, unint64_t a2, unint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v6;
        unint64_t v8 = v6[4];
        long long v9 = v7[5];
        BOOL v10 = (unint64_t)v9 > a3;
        if (v8 != a2) {
          BOOL v10 = v8 > a2;
        }
        if (!v10) {
          break;
        }
        uint64_t v6 = *v7;
        uint64_t v11 = v7;
        if (!*v7) {
          goto LABEL_13;
        }
      }
      BOOL v12 = (unint64_t)v9 < a3;
      BOOL v13 = v8 == a2;
      BOOL v14 = v8 < a2;
      if (v13) {
        BOOL v14 = v12;
      }
      if (!v14) {
        break;
      }
      uint64_t v11 = v7 + 1;
      uint64_t v6 = v7[1];
      if (!v6) {
        goto LABEL_13;
      }
    }
  }
  else
  {
    uint64_t v11 = a1 + 1;
LABEL_13:
    int v15 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x38uLL);
    unsigned int v16 = *a4;
    int v17 = a4[1];
    *a4 = 0;
    v7[4] = v16;
    v7[5] = v17;
    v7[6] = 0;
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = v15;
    *uint64_t v11 = (uint64_t *)v7;
    int v18 = (uint64_t *)**a1;
    unsigned int v19 = (uint64_t *)v7;
    if (v18)
    {
      *a1 = v18;
      unsigned int v19 = *v11;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v19);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_1A3FE8F94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE9000(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE915C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE91F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE94E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE9714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE987C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE9958(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE9A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE9BAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE9C80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FE9F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A3FEA0F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FEA35C(_Unwind_Exception *a1)
{
  unint64_t v8 = v6;

  _Unwind_Resume(a1);
}

void sub_1A3FEA4B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FEA59C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FEA6EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FEA8D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FEA9F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FEAC50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28)
{
  _Block_object_dispose((const void *)(v29 - 136), 8);
  int v31 = *(void **)(v29 - 88);
  if (v31)
  {
    *(void *)(v29 - 80) = v31;
    operator delete(v31);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__26807(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__26808(uint64_t a1)
{
  int v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_1A3FEAE8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);

  _Block_object_dispose((const void *)(v22 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t ImageProcessing_smoothGaussian_createKernelForPlanarF(float **a1, int *a2, float a3, float a4)
{
  if (a1)
  {
    long long v5 = 0;
    uint64_t v6 = 4220;
    if (a3 <= 0.0)
    {
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v7 = 0;
      if (a4 > 0.0)
      {
        LODWORD(v6) = vcvtps_s32_f32(a3 * a4);
        *a2 = (2 * v6) | 1;
        long long v5 = (float *)malloc_type_malloc(4 * ((int)v6 + 1), 0x100004052888210uLL);
        BOOL v10 = (float *)malloc_type_malloc(4 * *a2, 0x100004052888210uLL);
        uint64_t v7 = v10;
        if (v5) {
          BOOL v11 = v10 == 0;
        }
        else {
          BOOL v11 = 1;
        }
        if (v11)
        {
          uint64_t v6 = 4219;
        }
        else
        {
          v5[(int)v6] = 1.0;
          if ((int)v6 <= 0)
          {
            v10[(int)v6] = 1.0;
          }
          else
          {
            float v12 = (float)-(int)v6;
            BOOL v13 = v5;
            uint64_t v14 = v6;
            float v15 = 1.0;
            do
            {
              float v16 = expf((float)(v12 / a3) * (float)((float)(v12 / a3) * -0.5));
              *v13++ = v16;
              float v15 = v15 + (float)(v16 * 2.0);
              float v12 = v12 + 1.0;
              --v14;
            }
            while (v14);
            v7[(int)v6] = v5[(int)v6] / v15;
            int v17 = *a2 - 1;
            int v18 = v5;
            unsigned int v19 = v7;
            do
            {
              float v20 = *v18++;
              *v19++ = v20 / v15;
              v7[v17--] = v20 / v15;
              --v6;
            }
            while (v6);
          }
          *a1 = v7;
          uint64_t v6 = 4224;
          uint64_t v7 = 0;
        }
      }
    }
  }
  else
  {
    long long v5 = 0;
    uint64_t v7 = 0;
    uint64_t v6 = 4221;
  }
  free(v5);
  free(v7);
  return v6;
}

apple::vision::libraries::autotrace::ContourToPath *apple::vision::libraries::autotrace::ContourToPath::ContourToPath(apple::vision::libraries::autotrace::ContourToPath *this, float a2)
{
  *(void *)this = 0x40A000003DA3D70ALL;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0;
  uint64_t v3 = (char *)operator new(0x4B0uLL);
  *((void *)this + 12) = v3;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((void *)this + 13) = v3;
  *((void *)this + 14) = v3 + 1200;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((_DWORD *)this + 2) = 1036831949;
  *((void *)this + 2) = CGPathCreateMutable();
  return this;
}

void sub_1A3FEB658(_Unwind_Exception *exception_object)
{
  unsigned int v4 = (void *)v1[18];
  if (v4)
  {
    v1[19] = v4;
    operator delete(v4);
  }
  long long v5 = *v2;
  if (*v2)
  {
    v1[16] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)v1[12];
  if (v6)
  {
    v1[13] = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::autoTrace(apple::vision::libraries::autotrace::ContourToPath *this, const apple::vision::libraries::autotrace::EPolygonList *a2, const apple::vision::libraries::autotrace::EPolygon *a3, uint64_t a4, uint64_t a5, float *a6, uint64_t a7, uint64_t a8)
{
  if (*(int *)a3 < 1)
  {
    float v14 = 0.0;
  }
  else
  {
    BOOL v11 = (float32x2_t *)*((void *)a3 + 1);
    float32x2_t v12 = *v11;
    float32x2_t v13 = vsub_f32(v11[*(_DWORD *)a3 - 1], *v11);
    float v14 = 0.0;
    int v15 = *(_DWORD *)a3;
    do
    {
      float32x2_t v16 = *v11++;
      float32x2_t v17 = vsub_f32(v16, v12);
      float v14 = v14 + vmul_lane_f32(vsub_f32(v17, v13), vadd_f32(v17, v13), 1).f32[0] * 0.5;
      float32x2_t v13 = v17;
      --v15;
    }
    while (v15);
  }
  if (*(_DWORD *)a3 <= *((_DWORD *)this + 10))
  {
    *((void *)this + 3) = a3;
    *((void *)this + 4) = a2;
  }
  else
  {
    apple::vision::libraries::autotrace::ContourToPath::freeAutoTraceStructures(this);
    *((void *)this + 3) = a3;
    *((void *)this + 4) = a2;
    uint64_t v18 = *(int *)a3;
    *((void *)this + 6) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((void *)this + 10) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((void *)this + 11) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((void *)this + 7) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((void *)this + 8) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    unsigned int v19 = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((void *)this + 9) = v19;
    if (!*((void *)this + 6)
      || !*((void *)this + 10)
      || !*((void *)this + 11)
      || !*((void *)this + 7)
      || !*((void *)this + 8)
      || !v19)
    {
      VNValidatedLog(4, @"%s: could not allocate auto trace structures", v20, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"installAutoTraceStructures");
      apple::vision::libraries::autotrace::ContourToPath::freeAutoTraceStructures(this);
      return 0;
    }
    *((_DWORD *)this + 10) = v18;
  }
  if (fabsf(v14) < 3.0)
  {
    CGPathMoveToPoint(*((CGMutablePathRef *)this + 2), 0, COERCE_FLOAT(**((void **)a3 + 1)), COERCE_FLOAT(HIDWORD(**((void **)a3 + 1))));
    LODWORD(v21) = *(_DWORD *)a3;
    if (*(int *)a3 >= 1)
    {
      uint64_t v22 = 0;
      uint64_t v23 = 1;
      do
      {
        LODWORD(v24) = ++v22;
        if (v23 >= (int)v21)
        {
          uint64_t v24 = v23 - (int)v21;
          if (v24 >= (int)v21) {
            v24 %= (int)v21;
          }
        }
        CGPathAddLineToPoint(*((CGMutablePathRef *)this + 2), 0, COERCE_FLOAT(*(void *)(*((void *)a3 + 1) + 8 * (int)v24)), COERCE_FLOAT(HIDWORD(*(void *)(*((void *)a3 + 1) + 8 * (int)v24))));
        uint64_t v21 = *(int *)a3;
        BOOL v173 = v23++ < v21;
      }
      while (v173);
    }
    CGPathCloseSubpath(*((CGMutablePathRef *)this + 2));
    return 1;
  }
  int v26 = (unsigned int *)*((void *)this + 3);
  int v27 = (float *)*v26;
  if (v27)
  {
    int v28 = (float *)*((void *)this + 6);
    if ((int)v27 < 1) {
      goto LABEL_35;
    }
    uint64_t v29 = 0;
    uint64_t v30 = *((void *)v26 + 1);
    do
    {
      int v31 = v29 + 1;
      if ((int)v29 + 1 >= (int)v27) {
        int v32 = (int)v27;
      }
      else {
        int v32 = 0;
      }
      float32x2_t v33 = vsub_f32(*(float32x2_t *)(v30 - 8 * v32 + 8 * v29 + 8), *(float32x2_t *)(v30 + 8 * v29));
      float v34 = atan2f(v33.f32[1], v33.f32[0]) * 0.15915;
      if (v34 < 0.0) {
        float v34 = v34 + 1.0;
      }
      v28[v29++] = v34;
    }
    while (v27 != v31);
    if ((int)v27 > 23)
    {
      if (v27 > 0x37)
      {
        apple::vision::libraries::autotrace::ContourToPath::filterAngleBuffer(v28, *((float **)this + 10), (float *)(int)v27, 3, *(float *)this);
        int v37 = (float *)*((void *)this + 10);
        float v36 = *(float *)this;
        if (v27 > 0x77)
        {
          apple::vision::libraries::autotrace::ContourToPath::filterAngleBuffer(v37, *((float **)this + 11), v27, 7, v36);
          int v37 = (float *)*((void *)this + 11);
          uint64_t v35 = (float *)*((void *)this + 7);
          float v36 = *(float *)this;
          unsigned int v38 = (float *)(int)v27;
          int v39 = 15;
        }
        else
        {
          uint64_t v35 = (float *)*((void *)this + 7);
          unsigned int v38 = (float *)(int)v27;
          int v39 = 7;
        }
      }
      else
      {
        uint64_t v35 = (float *)*((void *)this + 7);
        float v36 = *(float *)this;
        int v37 = v28;
        unsigned int v38 = v27;
        int v39 = 3;
      }
      apple::vision::libraries::autotrace::ContourToPath::filterAngleBuffer(v37, v35, v38, v39, v36);
    }
    else
    {
LABEL_35:
      memmove(*((void **)this + 7), v28, 4 * (int)v27);
    }
  }
  uint64_t v40 = (unsigned int *)*((void *)this + 3);
  uint64_t v41 = *((void *)v40 + 1);
  unint64_t v42 = *v40;
  LOBYTE(v466[0]) = 0;
  std::string __p = 0;
  v464 = 0;
  uint64_t v465 = 0;
  if ((int)v42 > 0)
  {
    uint64_t v43 = 0;
    a5 = 0;
    uint64_t v44 = 0;
    int v45 = -1;
    float32x2_t v46 = (float32x2_t)vdup_n_s32(0x3A83126Fu);
    do
    {
      uint64_t v47 = v43 + 1;
      if (v43 + 1 >= v42) {
        int v48 = v42;
      }
      else {
        int v48 = 0;
      }
      int32x2_t v49 = vcgt_f32(v46, vabd_f32(*(float32x2_t *)(v41 - 8 * v48 + 8 * v43 + 8), *(float32x2_t *)(v41 + 8 * v43)));
      if (v49.i8[0]) {
        int v50 = 1;
      }
      else {
        int v50 = -1;
      }
      if (v49.i8[4]) {
        int v51 = 0;
      }
      else {
        int v51 = v50;
      }
      if (v51 == v45)
      {
        a5 = (a5 + 1);
      }
      else
      {
        a4 = v47 + -v48;
        if (v45 == 1)
        {
          apple::vision::libraries::autotrace::ContourToPath::addVerticalLine((_DWORD *)**((unsigned int **)this + 3), *(void *)(*((void *)this + 3) + 8), v44, v47 - v48, a5, &__p, v466);
        }
        else if (!v45)
        {
          apple::vision::libraries::autotrace::ContourToPath::addHorizontalLine((_DWORD *)**((unsigned int **)this + 3), *(void *)(*((void *)this + 3) + 8), v44, v47 - v48, a5, &__p, v466);
        }
        if (LOBYTE(v466[0])) {
          goto LABEL_67;
        }
        a5 = 1;
        uint64_t v44 = v43;
        int v45 = v51;
      }
      ++v43;
    }
    while (v42 != v47);
    if (v45 == 1)
    {
      apple::vision::libraries::autotrace::ContourToPath::addVerticalLine((_DWORD *)**((unsigned int **)this + 3), *(void *)(*((void *)this + 3) + 8), v44, 0, a5, &__p, v466);
    }
    else if (!v45)
    {
      apple::vision::libraries::autotrace::ContourToPath::addHorizontalLine((_DWORD *)**((unsigned int **)this + 3), *(void *)(*((void *)this + 3) + 8), v44, 0, a5, &__p, v466);
    }
    if (LOBYTE(v466[0]))
    {
LABEL_67:
      BOOL v52 = 0;
      goto LABEL_68;
    }
    v311 = (char *)__p;
    if (v464 == __p)
    {
      if (__p) {
        operator delete(__p);
      }
      goto LABEL_71;
    }
    uint64_t v312 = 0;
    unint64_t v313 = 0;
    while (1)
    {
      apple::vision::libraries::autotrace::ContourToPath::insertPairIntoInterestingPoints((uint64_t)this, (uint64_t)&v311[v312], *(_DWORD *)&v311[v312 + 8], *(_DWORD *)&v311[v312 + 12], (uint64_t *)this + 15, v466);
      BOOL v52 = LOBYTE(v466[0]) == 0;
      if (LOBYTE(v466[0])) {
        break;
      }
      v313 += 2;
      v311 = (char *)__p;
      v312 += 16;
      if (v313 >= (v464 - (unsigned char *)__p) >> 3)
      {
        BOOL v52 = 1;
        break;
      }
    }
LABEL_68:
    if (__p) {
      operator delete(__p);
    }
    if (!v52)
    {
      VNValidatedLog(4, @"%s: failing findOrthogonalLines", v44, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"autoTrace");
      return 0;
    }
  }
LABEL_71:
  unint64_t v53 = **((unsigned int **)this + 3);
  if ((int)v53 >= 1)
  {
    uint64_t v54 = 0;
    uint64_t v55 = *((void *)this + 6);
    uint64_t v56 = *((void *)this + 10);
    do
    {
      if (v54) {
        int v57 = 0;
      }
      else {
        int v57 = v53;
      }
      int v58 = v54 + v57 - 1;
      uint64_t v59 = v54 + 1;
      if (v54 + 1 >= v53) {
        int v60 = v53;
      }
      else {
        int v60 = 0;
      }
      int v61 = v59 - v60;
      if (v58 <= 0) {
        int v62 = v53;
      }
      else {
        int v62 = 0;
      }
      float v63 = *(float *)(v55 + 4 * (v58 + v62 - 1));
      float v64 = -2.0;
      float v65 = -1.0;
      float v66 = 0.0;
      float v67 = 0.0;
      while (1)
      {
        float v68 = v63;
        float v63 = *(float *)(v55 + 4 * v58);
        float v69 = v63 - v68;
        float v70 = rintf(v63 - v68);
        float v71 = (float)(v63 - v68) - v70;
        float v72 = vabds_f32(v69, v70);
        if (v72 <= v65)
        {
          float v73 = v66;
          if (v72 <= v64)
          {
            float v71 = v67;
            float v74 = v65;
            float v72 = v64;
          }
          else
          {
            float v74 = v65;
          }
        }
        else
        {
          float v73 = v71;
          float v71 = v66;
          float v74 = v72;
          float v72 = v65;
        }
        if (v58 == v61) {
          break;
        }
        int v75 = v58 + 1;
        if (v75 >= (int)v53) {
          int v76 = v53;
        }
        else {
          int v76 = 0;
        }
        int v58 = v75 - v76;
        float v66 = v73;
        float v67 = v71;
        float v65 = v74;
        float v64 = v72;
      }
      *(float *)(v56 + 4 * v54++) = v73 + v71;
    }
    while (v59 != v53);
    unint64_t v77 = 0;
    float32x2_t v78 = (char **)((char *)this + 120);
    int32x2_t v457 = vdup_n_s32(v53 >> 1);
    int32x2_t v459 = vdup_n_s32(-(v53 >> 1));
    int8x8_t v455 = (int8x8_t)vdup_n_s32(v53);
    do
    {
      LODWORD(__p) = 0;
      v466[0] = 0.0;
      float v461 = 0.0;
      int v79 = (EPolygon *)*((void *)this + 3);
      uint64_t v80 = *(_DWORD *)v79;
      unint64_t v81 = v77 - 2;
      uint64_t v82 = v77 - 2 - v80;
      if ((uint64_t)(v77 - 2) >= v80)
      {
        if (v82 >= v80) {
          v82 %= v80;
        }
      }
      else if (v77 > 1)
      {
        LODWORD(v82) = v77 - 2;
      }
      else
      {
        LODWORD(v82) = v81 + v80;
        if ((uint64_t)(v81 + v80) < 0)
        {
          LODWORD(v82) = v77 - 2;
          if (v80) {
            uint64_t v82 = (uint64_t)(v81 + v80) % v80 + v80;
          }
        }
      }
      if (v77) {
        int v83 = 0;
      }
      else {
        int v83 = *(_DWORD *)v79;
      }
      int v84 = v77 + v83 - 1;
      unint64_t v85 = v77 + 1;
      if ((uint64_t)(v77 + 1) >= v80) {
        int v86 = *(_DWORD *)v79;
      }
      else {
        int v86 = 0;
      }
      int v87 = v85 - v86;
      uint64_t v88 = (v77 + 2);
      int v89 = v88 - v80;
      if (v88 - v80 >= v80) {
        int v89 = (v88 - v80) % v80;
      }
      if ((uint64_t)(v77 + 2) >= v80) {
        LODWORD(v88) = v89;
      }
      uint64_t v90 = *((void *)this + 10);
      float v91 = fabsf(*(float *)(v90 + 4 * (int)v82));
      float v92 = fabsf(*(float *)(v90 + 4 * v84));
      float v93 = fabsf(*(float *)(v90 + 4 * v77));
      float v94 = fabsf(*(float *)(v90 + 4 * v87));
      if (v92 == v93 && v91 < v93 && v94 < v93)
      {
        float v115 = v93 * 0.75;
        if (v91 <= v115) {
          int v116 = v84;
        }
        else {
          int v116 = v82;
        }
        if (v94 <= v115) {
          int v117 = v77;
        }
        else {
          int v117 = v85 - v86;
        }
        uint64_t v98 = *((void *)this + 6);
      }
      else
      {
        if (v92 >= v93 || v94 >= v93) {
          goto LABEL_320;
        }
        uint64_t v98 = *((void *)this + 6);
        float v99 = *(float *)(v98 + 4 * v84);
        float v100 = *(float *)(v98 + 4 * (int)v82);
        float v101 = v99 - v100;
        float v102 = rintf(v99 - v100);
        float v103 = vabds_f32(v99 - v100, v102);
        float v104 = *(float *)(v98 + 4 * v77);
        float v105 = v104 - v99;
        float v106 = rintf(v104 - v99);
        float v107 = vabds_f32(v104 - v99, v106);
        float v108 = *(float *)(v98 + 4 * v87);
        float v109 = v108 - v104;
        float v110 = rintf(v109);
        float v111 = vabds_f32(v109, v110);
        if (v111 > v107 || (int v112 = v77, v103 > v107))
        {
          if (v103 <= v111) {
            int v112 = v87;
          }
          else {
            int v112 = v84;
          }
        }
        unint64_t v113 = v77 - 3;
        uint64_t v114 = v77 - 3 - v80;
        if ((uint64_t)(v77 - 3) >= v80)
        {
          if (v114 >= v80) {
            LODWORD(v114) = v114 % v80;
          }
        }
        else
        {
          LODWORD(v114) = v77 - 3;
          if (v77 <= 2)
          {
            uint64_t v114 = v113 + v80;
            if ((uint64_t)(v113 + v80) < 0) {
              uint64_t v114 = v114 % v80 + v80;
            }
          }
        }
        float v178 = v101 - v102;
        float v179 = v105 - v106;
        if (v112 == v84)
        {
          float v180 = v100 - *(float *)(v98 + 4 * (int)v114);
          float v181 = v92 * 0.75;
          if ((float)(v178 * (float)(v180 - rintf(v180))) <= 0.0 || v91 <= v181) {
            int v116 = v84;
          }
          else {
            int v116 = v82;
          }
          if ((float)(v178 * v179) <= 0.0 || v93 <= v181) {
            int v117 = v84;
          }
          else {
            int v117 = v77;
          }
        }
        else
        {
          float v184 = v109 - v110;
          if (v77 == v112)
          {
            float v185 = v93 * 0.75;
            if ((float)(v178 * v179) <= 0.0 || v92 <= v185) {
              int v116 = v77;
            }
            else {
              int v116 = v84;
            }
            if ((float)(v179 * v184) <= 0.0 || v94 <= v185) {
              int v117 = v77;
            }
            else {
              int v117 = v87;
            }
          }
          else
          {
            if (v112 != v87) {
              goto LABEL_320;
            }
            float v188 = fabsf(*(float *)(v90 + 4 * (int)v88));
            float v189 = *(float *)(v98 + 4 * (int)v88) - v108;
            float v190 = v189 - rintf(v189);
            float v191 = v94 * 0.75;
            if ((float)(v179 * v184) <= 0.0 || v93 <= v191) {
              int v116 = v87;
            }
            else {
              int v116 = v77;
            }
            if ((float)(v184 * v190) <= 0.0 || v188 <= v191) {
              int v117 = v87;
            }
            else {
              int v117 = v88;
            }
          }
        }
      }
      if (v116 <= 0) {
        int v118 = *(_DWORD *)v79;
      }
      else {
        int v118 = 0;
      }
      float v119 = *(float *)(v98 + 4 * v116);
      float v120 = v119 - *(float *)(v98 + 4 * (v116 + v118 - 1));
      float v121 = (float)(v120 - rintf(v120)) + 0.0;
      for (int i = v116; i != v117; v119 = *(float *)(v98 + 4 * i))
      {
        int v123 = i + 1;
        if (v123 >= (int)v80) {
          int v124 = *(_DWORD *)v79;
        }
        else {
          int v124 = 0;
        }
        int i = v123 - v124;
        float v125 = *(float *)(v98 + 4 * i) - v119;
        float v121 = v121 + (float)(v125 - rintf(v125));
      }
      uint64_t v126 = v117;
      uint64_t v127 = v117 + 1;
      uint64_t v128 = v116 + v80;
      float v130 = 0.0;
      uint64_t v131 = 5;
      float v132 = 0.0;
      float v133 = 0.0;
      float v134 = 0.0;
      do
      {
        uint64_t v135 = v116 + v131 - 6;
        if (v135 >= v80)
        {
          uint64_t v129 = v116 - v80;
          uint64_t v137 = v129 + v131 - 6;
          if (v137 >= v80) {
            uint64_t v135 = v137 % v80;
          }
          else {
            LODWORD(v135) = v129 + v131 - 6;
          }
        }
        else if (v135 < 0)
        {
          uint64_t v136 = v128 + v131 - 6;
          if (v136 >= 0) {
            LODWORD(v135) = v128 + v131 - 6;
          }
          if (v136 < 0) {
            uint64_t v135 = v136 % v80 + v80;
          }
        }
        if ((int)v135 <= 0) {
          int v138 = *(_DWORD *)v79;
        }
        else {
          int v138 = 0;
        }
        float v139 = *(float *)(v98 + 4 * (int)v135);
        float v140 = *(float *)(v98 + 4 * ((int)v135 + v138 - 1));
        if (v127 >= v80)
        {
          if (v127 - v80 >= v80) {
            LODWORD(v141) = v127;
          }
          else {
            LODWORD(v141) = v127 - v80;
          }
          if (v127 - v80 >= v80) {
            uint64_t v141 = (v127 - v80) % v80;
          }
        }
        else
        {
          LODWORD(v141) = v127;
          if (v127 < 0)
          {
            uint64_t v142 = v80 + v127;
            LODWORD(v141) = v80 + v127 < 0 ? v127 : (int)v80 + (int)v127;
            if (v142 < 0) {
              uint64_t v141 = v142 % v80 + v80;
            }
          }
        }
        float v134 = v134 + (float)((float)(v139 - v140) - rintf(v139 - v140));
        if ((int)v141 <= 0) {
          int v143 = *(_DWORD *)v79;
        }
        else {
          int v143 = 0;
        }
        float v144 = *(float *)(v98 + 4 * (int)v141) - *(float *)(v98 + 4 * ((int)v141 + v143 - 1));
        float v133 = v133 + (float)(v144 - rintf(v144));
        if (v131 == 3)
        {
          float v132 = v134;
          float v130 = v133;
        }
        ++v127;
        --v131;
      }
      while (v131);
      int v145 = v116 - 4;
      uint64_t v146 = v116 - 4;
      if (v116 - 4 >= (int)v80)
      {
        uint64_t v148 = v145 - v80;
        if (v146 - v80 >= v80) {
          uint64_t v146 = v148 % v80;
        }
        else {
          v146 -= v80;
        }
      }
      else if (v116 <= 3)
      {
        uint64_t v147 = v145 + v80;
        if (v146 + v80 < 0 == __OFADD__(v146, v80)) {
          v146 += v80;
        }
        if (v147 < 0) {
          uint64_t v146 = v147 % v80 + v80;
        }
      }
      long long v149 = (apple::vision::libraries::autotrace *)apple::vision::libraries::autotrace::ContourToPath::LRLine(v79, (const EPolygon *)v146, &__p, &v461, (float *)a5, a6);
      if (v149)
      {
        float v155 = *(float *)&__p;
        float v158 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v149, *(float *)&__p, v150, v151, v152, a5, (uint64_t)a6, v153, v154);
        if (v117 >= (int)v80)
        {
          uint64_t v126 = v117 - v80 >= v80 ? (v117 - v80) % v80 : v117 - v80;
        }
        else if (v117 < 0)
        {
          uint64_t v159 = v117 + v80;
          if (v159 < 0 == __OFADD__(v117, v80)) {
            uint64_t v126 = v117 + v80;
          }
          if (v159 < 0) {
            uint64_t v126 = v159 % v80 + v80;
          }
        }
        float v160 = v461;
        long long v161 = (apple::vision::libraries::autotrace *)apple::vision::libraries::autotrace::ContourToPath::LRLine(*((EPolygon **)this + 3), (const EPolygon *)v126, v466, &v461, v156, v157);
        if (v161)
        {
          float v169 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v161, v155, v162, v163, v164, a5, (uint64_t)a6, v165, v166);
          if (vabds_f32(v155 - v466[0], rintf(v155 - v466[0])) >= 0.0625)
          {
            float v170 = fabsf(v121);
            if (v170 >= 0.0625
              && (v160 < v158 || fabsf(v134) < (float)(v170 * 0.3) || (float)(v121 * v134) < 0.0)
              && (v461 < v169 || fabsf(v133) < (float)(v170 * 0.3) || (float)(v121 * v133) < 0.0))
            {
              float v171 = v170 * 0.6;
              float v172 = fabsf(v130);
              BOOL v173 = fabsf(v132) <= v171 && v172 <= v171;
              if (v173)
              {
                long long v174 = (int *)*((void *)this + 12);
                uint64_t v175 = (int *)*((void *)this + 13);
                if (v175 == v174 || *(v175 - 2) <= v116 || *(v175 - 3) >= v116)
                {
                  unint64_t v176 = *((void *)this + 14);
                  if ((unint64_t)v175 >= v176)
                  {
                    uint64_t v194 = ((char *)v175 - (char *)v174) / 12;
                    unint64_t v195 = v194 + 1;
                    if ((unint64_t)(v194 + 1) > 0x1555555555555555) {
                      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                    }
                    v454 = v78;
                    unint64_t v196 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v176 - (void)v174) >> 2);
                    if (2 * v196 > v195) {
                      unint64_t v195 = 2 * v196;
                    }
                    if (v196 >= 0xAAAAAAAAAAAAAAALL) {
                      unint64_t v195 = 0x1555555555555555;
                    }
                    if (v195 > 0x1555555555555555) {
                      std::__throw_bad_array_new_length[abi:ne180100]();
                    }
                    uint64_t v197 = 3 * v195;
                    uint64_t v198 = (char *)operator new(12 * v195);
                    long long v199 = (int *)&v198[12 * v194];
                    *long long v199 = v116;
                    v199[1] = v117;
                    v199[2] = -100;
                    long long v200 = v199;
                    if (v175 != v174)
                    {
                      do
                      {
                        uint64_t v201 = *(void *)(v175 - 3);
                        v175 -= 3;
                        int v202 = v175[2];
                        *(void *)(v200 - 3) = v201;
                        v200 -= 3;
                        v200[2] = v202;
                      }
                      while (v175 != v174);
                      uint64_t v175 = v174;
                    }
                    long long v177 = (apple::vision::libraries::autotrace::CornerList *)(v199 + 3);
                    *((void *)this + 12) = v200;
                    *((void *)this + 13) = v199 + 3;
                    *((void *)this + 14) = &v198[4 * v197];
                    if (v175) {
                      operator delete(v175);
                    }
                    float32x2_t v78 = v454;
                  }
                  else
                  {
                    *uint64_t v175 = v116;
                    v175[1] = v117;
                    long long v177 = (apple::vision::libraries::autotrace::CornerList *)(v175 + 3);
                    v175[2] = -100;
                  }
                  *((void *)this + 13) = v177;
                  if (!apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), v177, **((unsigned int **)this + 3), v77, 0, (uint64_t)a6, v167, v168))
                  {
                    int32x2_t v203 = vsub_s32(*(int32x2_t *)((char *)v177 - 12), vdup_n_s32(v77));
                    int32x2_t v204 = vabs_s32(vadd_s32((int32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v459, v203), v455, (int8x8_t)vneg_s32((int32x2_t)vand_s8(v455, (int8x8_t)vcgt_s32(v203, v457)))), v203));
                    if (vcgt_u32((uint32x2_t)vdup_lane_s32(v204, 1), (uint32x2_t)v204).u8[0]) {
                      LODWORD(v77) = *(void *)((char *)v177 - 12);
                    }
                    else {
                      LODWORD(v77) = HIDWORD(*(void *)((char *)v177 - 12));
                    }
                  }
                  *((_DWORD *)v177 - 1) = v77;
                  uint64_t v205 = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v77, 1, v78);
                  if (!v205) {
                    goto LABEL_436;
                  }
                  long long v210 = (char *)v205;
                  if (*(_DWORD *)(v205 + 4) == 1)
                  {
                    long long v211 = (char *)*((void *)this + 15);
                    long long v212 = (char *)*((void *)this + 16);
                    uint64_t v213 = v210 - v211;
                    uint64_t v214 = (v210 - v211) >> 3;
                    uint64_t v215 = v214 - 1;
                    uint64_t v216 = (v212 - v211) >> 3;
                    if (v214 <= v216)
                    {
                      if (v213 > 7)
                      {
                        LODWORD(v217) = v214 - 1;
                      }
                      else
                      {
                        LODWORD(v217) = v216 + v215;
                        if (v216 + v215 < 0)
                        {
                          LODWORD(v217) = v214 - 1;
                          if (v212 != v211) {
                            uint64_t v217 = (v216 + v215) % v216 + v216;
                          }
                        }
                      }
                    }
                    else
                    {
                      LODWORD(v217) = v215 - v216;
                      if (v215 - v216 >= v216)
                      {
                        LODWORD(v217) = v214 - 1;
                        if (v212 != v211) {
                          uint64_t v217 = (v215 - v216) % v216;
                        }
                      }
                    }
                    uint64_t v218 = v214 + 1;
                    uint64_t v219 = v218 - v216;
                    if (v218 >= v216)
                    {
                      LODWORD(v220) = v218 - v216;
                      if (v219 >= v216)
                      {
                        LODWORD(v220) = v218;
                        if (v212 != v211) {
                          uint64_t v220 = v219 % v216;
                        }
                      }
                    }
                    else if (v213 > -9)
                    {
                      LODWORD(v220) = v218;
                    }
                    else
                    {
                      LODWORD(v220) = v216 + v218;
                      if (v216 + v218 < 0)
                      {
                        LODWORD(v220) = v218;
                        if (v212 != v211) {
                          uint64_t v220 = (v216 + v218) % v216 + v216;
                        }
                      }
                    }
                    long long v221 = &v211[8 * (int)v217];
                    long long v222 = (int *)(v221 + 4);
                    if ((v221[4] & 2) != 0)
                    {
                      long long v223 = &v211[8 * (int)v220];
                      char v225 = v223[4];
                      uint64_t v224 = (int *)(v223 + 4);
                      if ((v225 & 4) != 0)
                      {
                        long long v226 = &v211[8 * (int)v220];
                        *((_DWORD *)v210 + 1) = 0;
                        if ((int)((v53 & ((*(_DWORD *)v210 - *(_DWORD *)v221) >> 31))
                                 + *(_DWORD *)v210
                                 - *(_DWORD *)v221) >= (int)((v53 & ((*(_DWORD *)v226 - *(_DWORD *)v210) >> 31))
                                                           + *(_DWORD *)v226
                                                           - *(_DWORD *)v210))
                        {
                          int v228 = *v224;
                          if (v220)
                          {
                            *uint64_t v224 = v228 | 1;
                            *(_DWORD *)long long v226 = *((_DWORD *)v177 - 3);
                          }
                          else
                          {
                            *((_DWORD *)v210 + 1) = v228;
                            *uint64_t v224 = 0;
                          }
                        }
                        else
                        {
                          int v227 = *v222;
                          if (v210 == v211)
                          {
                            *((_DWORD *)v210 + 1) = v227;
                            *long long v222 = 0;
                          }
                          else
                          {
                            *long long v222 = v227 | 1;
                            *(_DWORD *)long long v221 = *((_DWORD *)v177 - 2);
                          }
                        }
                      }
                    }
                    if (v211 == v212)
                    {
                      long long v212 = v211;
                      long long v229 = v211;
                    }
                    else
                    {
                      long long v229 = v211;
                      while (*((_DWORD *)v229 + 1))
                      {
                        v229 += 8;
                        if (v229 == v212)
                        {
                          long long v229 = v212;
                          goto LABEL_317;
                        }
                      }
                      if (v229 != v212)
                      {
                        char v230 = v229 + 8;
                        if (v229 + 8 != v212)
                        {
                          do
                          {
                            if (*((_DWORD *)v230 + 1))
                            {
                              *(void *)long long v229 = *(void *)v230;
                              v229 += 8;
                            }
                            v230 += 8;
                          }
                          while (v230 != v212);
                          long long v211 = (char *)*((void *)this + 15);
                          long long v212 = (char *)*((void *)this + 16);
                        }
                      }
                    }
LABEL_317:
                    int64_t v231 = v229 - v211;
                    long long v232 = &v211[v231];
                    int v233 = &v211[v231 + 8];
                    int64_t v234 = v212 - v233;
                    if (v212 != v233)
                    {
                      memmove(&v211[v231], v233, v212 - v233);
                      long long v211 = *v78;
                    }
                    *((void *)this + 16) = &v232[v234];
                    qsort(v211, (&v232[v234] - v211) >> 3, 8uLL, (int (__cdecl *)(const void *, const void *))apple::vision::libraries::autotrace::ContourToPath::ipCompare);
                  }
                }
              }
            }
          }
        }
      }
LABEL_320:
      unint64_t v77 = v85;
    }
    while (v85 != v53);
  }
  qsort(*((void **)this + 12), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 13) - *((void *)this + 12)) >> 2), 0xCuLL, (int (__cdecl *)(const void *, const void *))apple::vision::libraries::autotrace::ContourToPath::cornerCompare);
  uint64_t v236 = (char *)*((void *)this + 12);
  uint64_t v235 = (char *)*((void *)this + 13);
  unint64_t v237 = 0xAAAAAAAAAAAAAAABLL * ((v235 - v236) >> 2);
  if (v237 >= 2 && v235 != v236)
  {
    unint64_t v239 = 0;
    int v240 = (int)v53 >> 1;
    do
    {
      unint64_t v241 = v239++;
      LODWORD(v242) = v239;
      if ((uint64_t)v239 >= (int)v237)
      {
        int64_t v243 = v239 - (int)v237;
        LODWORD(v242) = v239 - v237;
        if (v243 >= (int)v237)
        {
          LODWORD(v242) = v239;
          if (v237 << 32) {
            int64_t v242 = v243 % (int)v237;
          }
        }
      }
      int v244 = v242;
      long long v245 = &v236[12 * (int)v242];
      int v246 = *(_DWORD *)&v236[12 * v241];
      int v247 = *(_DWORD *)&v236[12 * v241 + 4];
      int v248 = v246 - v240;
      int v249 = v246 + v240;
      if (v246 + v240 >= v247) {
        int v250 = 0;
      }
      else {
        int v250 = v53;
      }
      int v251 = v247 - v250;
      if (v248 > v247) {
        int v252 = v247 + v53;
      }
      else {
        int v252 = v251;
      }
      int v253 = *(_DWORD *)v245;
      int v254 = *(_DWORD *)&v236[12 * v244 + 4];
      if (v249 >= *(_DWORD *)v245) {
        int v255 = 0;
      }
      else {
        int v255 = v53;
      }
      int v256 = v253 - v255;
      if (v248 > v253) {
        int v257 = v253 + v53;
      }
      else {
        int v257 = v256;
      }
      if (v249 >= v254) {
        int v258 = 0;
      }
      else {
        int v258 = v53;
      }
      int v259 = v254 - v258;
      if (v248 > v254) {
        int v260 = v254 + v53;
      }
      else {
        int v260 = v259;
      }
      if (v257 <= v252 && v260 >= v246)
      {
        int v262 = *(_DWORD *)&v236[12 * v244 + 8];
        int64_t v263 = v235 - (v245 + 12);
        if (v235 != v245 + 12) {
          memmove(v245, v245 + 12, v235 - (v245 + 12));
        }
        uint64_t v235 = &v245[v263];
        *((void *)this + 13) = &v245[v263];
        uint64_t v264 = *((void *)this + 15);
        uint64_t v265 = *((void *)this + 16) - v264;
        if (v265)
        {
          unint64_t v266 = v265 >> 3;
          if (v266 <= 1) {
            unint64_t v266 = 1;
          }
          long long v267 = (_DWORD *)(v264 + 4);
          do
          {
            if (*(v267 - 1) == v262) {
              *v267 &= ~1u;
            }
            v267 += 2;
            --v266;
          }
          while (v266);
        }
      }
      uint64_t v236 = (char *)*((void *)this + 12);
      unint64_t v237 = 0xAAAAAAAAAAAAAAABLL * ((v235 - v236) >> 2);
    }
    while (v237 > v239);
  }
  long long v269 = (char *)*((void *)this + 15);
  unint64_t v268 = (char *)*((void *)this + 16);
  if (v269 == v268)
  {
    unint64_t v268 = (char *)*((void *)this + 15);
    char v270 = v268;
  }
  else
  {
    char v270 = (char *)*((void *)this + 15);
    while (*((_DWORD *)v270 + 1))
    {
      v270 += 8;
      if (v270 == v268)
      {
        char v270 = (char *)*((void *)this + 16);
        goto LABEL_375;
      }
    }
    if (v270 != v268)
    {
      int8x8_t v271 = v270 + 8;
      if (v270 + 8 != v268)
      {
        do
        {
          if (*((_DWORD *)v271 + 1))
          {
            *(void *)char v270 = *(void *)v271;
            v270 += 8;
          }
          v271 += 8;
        }
        while (v271 != v268);
        long long v269 = (char *)*((void *)this + 15);
        unint64_t v268 = (char *)*((void *)this + 16);
      }
    }
  }
LABEL_375:
  uint64_t v272 = (uint64_t)(v270 + 8);
  int64_t v273 = v268 - (v270 + 8);
  if (v268 != v270 + 8)
  {
    memmove(v270, (const void *)v272, v268 - (v270 + 8));
    long long v269 = (char *)*((void *)this + 15);
  }
  *((void *)this + 16) = &v270[v273];
  if (&v270[v273] == v269
    && !apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(0, 64, (void *)this + 15))
  {
LABEL_436:
    VNValidatedLog(4, @"%s: failing findCorners", v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"autoTrace");
    return 0;
  }
  v466[0] = 0.0;
  float v461 = 0.0;
  uint64_t v274 = **((unsigned int **)this + 3);
  if ((int)v274 >= 1)
  {
    uint64_t v275 = 0;
    uint64_t v276 = *((void *)this + 7);
    uint64_t v277 = *((void *)this + 8);
    do
    {
      if (v275) {
        uint64_t v278 = 0;
      }
      else {
        uint64_t v278 = v274;
      }
      float v279 = *(float *)(v276 + 4 * (v278 + v275) - 4) - *(float *)(v276 + 4 * v275);
      *(float *)(v277 + 4 * v275++) = v279 - rintf(v279);
    }
    while (v274 != v275);
  }
  char v462 = 0;
  std::string __p = 0;
  v464 = 0;
  uint64_t v465 = 0;
  uint64_t v280 = *((void *)this + 15);
  uint64_t v281 = *((void *)this + 16) - v280;
  v451 = (uint64_t *)((char *)this + 120);
  if (!v281)
  {
LABEL_430:
    BOOL v310 = 1;
    goto LABEL_438;
  }
  uint64_t v282 = 0;
  int v283 = 0;
  uint64_t v284 = v281 >> 3;
  int v460 = (int)v274 >> 1;
  uint64_t v285 = 1;
  do
  {
    ++v283;
    LODWORD(v286) = v285;
    if (v284 <= v285)
    {
      if (v285 - v284 >= v284) {
        uint64_t v286 = (v285 - v284) % v284;
      }
      else {
        LODWORD(v286) = v283 - v284;
      }
    }
    if (*(unsigned char *)(v280 + v282 + 4))
    {
      uint64_t v287 = v280 + 8 * (int)v286;
      char v289 = *(unsigned char *)(v287 + 4);
      char v288 = (unsigned char *)(v287 + 4);
      if (v289)
      {
        int v290 = *(_DWORD *)(v280 + v282);
        unint64_t v291 = (int *)(v280 + 8 * (int)v286);
        int v292 = *v291;
        Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), v290, 1, (uint64_t)a6, v208, v209);
        if (!Corner) {
          goto LABEL_437;
        }
        uint64_t v272 = *((unsigned int *)Corner + 1);
        if (*v288)
        {
          uint64_t v295 = *((unsigned int *)Corner + 1);
          double v296 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v291, 1, (uint64_t)a6, v208, v209);
          uint64_t v272 = v295;
          if (!v296)
          {
LABEL_437:
            BOOL v310 = 0;
            goto LABEL_438;
          }
          int v294 = *(_DWORD *)v296;
        }
        else
        {
          int v294 = v292;
        }
        if (v292 <= v290)
        {
          int v298 = v272 - *(_DWORD *)(v280 + v282);
          if (v298 < 0) {
            int v298 = *(_DWORD *)(v280 + v282) - v272;
          }
          int v297 = v294;
          if (v298 > v460) {
            goto LABEL_409;
          }
          int v299 = v294 - *v291;
          if (v299 < 0) {
            int v299 = *v291 - v294;
          }
          if (v299 <= v460)
          {
            if (v294 <= (int)v272 - (int)v274) {
              goto LABEL_393;
            }
          }
          else
          {
LABEL_409:
            if (v294 <= (int)v272) {
              goto LABEL_393;
            }
          }
        }
        else
        {
          int v297 = v294;
          if (v294 <= (int)v272) {
            goto LABEL_393;
          }
        }
        int v300 = v297 - v272;
        if (v297 <= (int)v272) {
          int v301 = v274;
        }
        else {
          int v301 = 0;
        }
        unsigned int v302 = v301 + v300;
        if (v301 + v300 >= 1)
        {
          int v303 = v272;
          apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(this, v272, v297, v466, &v461);
          float v304 = fabsf(v466[0]);
          if (v302 > 0xF || v304 >= 0.000027778 || v461 >= 0.000027778)
          {
            if (v302 >= 0x15 && v304 > 0.0043056 && v304 < 0.027778)
            {
              float v305 = v461 / fmaxf(v304, 0.01);
              if (v305 > 0.965 && v305 < 1.17)
              {
                apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v303, 8, &__p);
                apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v297, 16, &__p);
              }
            }
          }
          else
          {
            apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v303, 2, &__p);
            apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v297, 4, &__p);
          }
        }
      }
    }
LABEL_393:
    uint64_t v280 = *((void *)this + 15);
    uint64_t v284 = (*((void *)this + 16) - v280) >> 3;
    v282 += 8;
    BOOL v173 = v284 > (unint64_t)v285++;
  }
  while (v173);
  float64x2_t v307 = (char *)__p;
  float64_t v306 = v464;
  if (v464 == __p)
  {
    BOOL v310 = 1;
    if (v464) {
      goto LABEL_439;
    }
  }
  else
  {
    uint64_t v308 = 0;
    unint64_t v309 = 0;
    while (1)
    {
      apple::vision::libraries::autotrace::ContourToPath::insertPairIntoInterestingPoints((uint64_t)this, (uint64_t)&v307[v308], *(_DWORD *)&v307[v308 + 8], *(_DWORD *)&v307[v308 + 12], v451, &v462);
      BOOL v310 = v462 == 0;
      if (v462) {
        break;
      }
      v309 += 2;
      float64x2_t v307 = (char *)__p;
      v308 += 16;
      if (v309 >= (v464 - (unsigned char *)__p) >> 3) {
        goto LABEL_430;
      }
    }
LABEL_438:
    float64_t v306 = __p;
    if (__p) {
LABEL_439:
    }
      operator delete(v306);
  }
  if (!v310)
  {
    VNValidatedLog(4, @"%s: failing findShortLinesAndShallowCurves", v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"autoTrace");
    return 0;
  }
  LOBYTE(v461) = 0;
  v466[0] = 0.0;
  uint64_t v314 = **((int **)this + 3);
  std::string __p = 0;
  v464 = 0;
  uint64_t v465 = 0;
  uint64_t v315 = *((void *)this + 15);
  uint64_t v316 = *((void *)this + 16) - v315;
  if (!v316)
  {
LABEL_641:
    BOOL v399 = 1;
    goto LABEL_642;
  }
  unint64_t v317 = 0;
  int v318 = 0;
  uint64_t v319 = v316 >> 3;
  int v452 = (int)v314 >> 1;
  int v453 = 0;
  if ((int)v314 >= 0) {
    int v320 = v314;
  }
  else {
    int v320 = v314 + 1;
  }
  int v449 = v320 >> 1;
  int v450 = -(v320 >> 1);
  float v321 = 0.0;
  float v322 = 0.0;
  while (2)
  {
    int v456 = v318;
    unint64_t v323 = v317;
    LODWORD(v324) = v317 + 1;
    unint64_t v458 = v317 + 1;
    uint64_t v325 = v317 + 1 - v319;
    if ((uint64_t)(v317 + 1) >= v319)
    {
      LODWORD(v324) = v317 + 1 - v319;
      if (v325 >= v319) {
        uint64_t v324 = v325 % v319;
      }
    }
    uint64_t v326 = (int *)(v315 + 8 * v317);
    int v327 = (int *)(v315 + 8 * (int)v324);
    int v328 = *v326;
    int v329 = *v327;
    uint64_t v330 = v315 + 8 * v323;
    char v332 = *(unsigned char *)(v330 + 4);
    float v331 = (unsigned char *)(v330 + 4);
    if (v332)
    {
      v334 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v326, 1, (uint64_t)a6, v208, v209);
      if (!v334) {
        goto LABEL_628;
      }
      int v333 = *((_DWORD *)v334 + 1);
    }
    else
    {
      int v333 = *v326;
    }
    int v335 = v329;
    if (*(unsigned char *)(v315 + 8 * (int)v324 + 4))
    {
      int v336 = v333;
      int v337 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v327, 1, (uint64_t)a6, v208, v209);
      if (!v337) {
        goto LABEL_628;
      }
      int v335 = *(_DWORD *)v337;
      int v333 = v336;
    }
    if (v329 > v328) {
      goto LABEL_463;
    }
    int v338 = v333 - *v326;
    if (v338 < 0) {
      int v338 = *v326 - v333;
    }
    if (v338 > v452) {
      goto LABEL_463;
    }
    int v339 = v335 - *v327;
    if (v339 < 0) {
      int v339 = *v327 - v335;
    }
    if (v339 > v452)
    {
LABEL_463:
      if (v335 > v333) {
        goto LABEL_464;
      }
      goto LABEL_483;
    }
    if (v335 <= v333 - (int)v314) {
      goto LABEL_483;
    }
LABEL_464:
    int v340 = v335 - v333;
    if (v335 == v333)
    {
      if (*((void *)this + 16) - *((void *)this + 15) >= 9uLL)
      {
        VNValidatedLog(4, @"%s: zero length curve in findNonOrthogonalLines at point index %d", v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"findNonOrthogonalLines");
        goto LABEL_641;
      }
    }
    else if (v340 >= 0xFFFFFFFE {
           && (int)v314 >= 101
    }
           && *((void *)this + 16) - *((void *)this + 15) >= 0x11uLL)
    {
      VNValidatedLog(4, @"%s: findNonOrthogonalLines with reversed point indexes %d and %d", v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"findNonOrthogonalLines");
      goto LABEL_641;
    }
    if (v340 <= 0) {
      int v341 = v314;
    }
    else {
      int v341 = 0;
    }
    if ((*v331 & 0xA) != 0)
    {
LABEL_483:
      unint64_t v317 = v458;
      int v318 = v456;
    }
    else
    {
      unint64_t v317 = v458;
      int v318 = v456;
      if (v341 + v340 >= 21)
      {
        int v342 = v333 + 10;
        uint64_t v343 = v333 + 10;
        if (v333 + 10 >= (int)v314)
        {
          uint64_t v345 = v342 - v314;
          if (v343 - v314 >= v314)
          {
            if (v314) {
              uint64_t v343 = v345 % v314;
            }
          }
          else
          {
            LODWORD(v343) = v343 - v314;
          }
        }
        else if (v333 <= -11)
        {
          uint64_t v344 = v342 + v314;
          if (v343 + v314 < 0 == __OFADD__(v343, v314)) {
            LODWORD(v343) = v343 + v314;
          }
          if (v344 < 0 && v314) {
            uint64_t v343 = v344 % v314 + v314;
          }
        }
        int v346 = v335 - 11;
        LODWORD(v347) = v335 - 11;
        if (v335 - 11 >= (int)v314)
        {
          if (v346 - v314 >= v314)
          {
            if (v314) {
              uint64_t v347 = (v346 - v314) % v314;
            }
          }
          else
          {
            LODWORD(v347) = v346 - v314;
          }
        }
        else if (v335 <= 10)
        {
          uint64_t v348 = v346 + v314;
          if (v348 < 0 == __OFADD__(v346, v314)) {
            LODWORD(v347) = v346 + v314;
          }
          if (v348 < 0 && v314) {
            uint64_t v347 = v348 % v314 + v314;
          }
        }
        if (v343 != v347)
        {
          char v349 = 0;
          int v350 = -1;
          do
          {
            uint64_t v351 = *((void *)this + 6);
            uint64_t v352 = v314 + (int)v343;
            uint64_t v353 = (int)v343 - v314;
            float v354 = 0.0;
            uint64_t v355 = -10;
            float v356 = *(float *)(v351 + 4 * (int)v343);
            float v357 = v356;
            do
            {
              uint64_t v358 = (int)v343 + v355;
              if (v358 >= v314)
              {
                if (v353 + v355 >= v314)
                {
                  if (v314) {
                    uint64_t v358 = (v353 + v355) % v314;
                  }
                }
                else
                {
                  LODWORD(v358) = v353 + v355;
                }
              }
              else if (v358 < 0)
              {
                uint64_t v359 = v352 + v355;
                if (v352 + v355 >= 0) {
                  LODWORD(v358) = v352 + v355;
                }
                if (v359 < 0 && v314) {
                  uint64_t v358 = v359 % v314 + v314;
                }
              }
              float v360 = *(float *)(v351 + 4 * (int)v358)
                   - rintf(*(float *)(v351 + 4 * (int)v358) - *(float *)(v351 + 4 * (int)v343));
              if (v360 > v356) {
                float v361 = v360;
              }
              else {
                float v361 = v356;
              }
              if (v360 >= v357) {
                float v356 = v361;
              }
              else {
                float v357 = v360;
              }
              float v354 = v354 + v360;
              ++v355;
            }
            while (v355 != 11);
            uint64_t v362 = 0;
            float v363 = v354 / 21.0;
            float v364 = (float)(v354 / 21.0) - (float)((float)(int)floorf((float)(v354 / 21.0) * 4.0) * 0.25);
            if (v364 > 0.125) {
              float v364 = 0.25 - v364;
            }
            float v365 = v364 * 360.0;
            do
            {
              uint64_t v366 = v362 + 2;
              if (v362 == 20)
              {
                VNValidatedLog(4, @"%s: angle %.3f not found in straightLineAngleDeltaToleranceAtAngle", v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"straightLineAngleDeltaToleranceAtAngle");
                float v373 = 12.235;
                goto LABEL_534;
              }
              unint64_t v367 = &apple::vision::libraries::autotrace::SLADT[v362];
              float v368 = *v367;
              float v369 = v367[2];
              BOOL v370 = *v367 > v365 || v365 > v369;
              uint64_t v362 = v366;
            }
            while (v370);
            float v371 = (float)(v365 - v368) / (float)(v369 - v368);
            float v372 = apple::vision::libraries::autotrace::SLADT[((v366 - 2) & 0xFFFFFFFE) + 1];
            float v373 = v372
                 + (float)(v371 * (float)(apple::vision::libraries::autotrace::SLADT[(v366 & 0xFFFFFFFE) + 1] - v372));
            if (v373 < 3.1) {
              float v373 = 3.1;
            }
LABEL_534:
            float v374 = v356 - v363;
            if ((float)(v363 - v357) > (float)(v356 - v363)) {
              float v374 = v363 - v357;
            }
            if (v374 <= v373)
            {
              if (v349)
              {
                if (v350 + 1 >= (int)v314) {
                  int v375 = v314;
                }
                else {
                  int v375 = 0;
                }
                float v376 = v363;
                float v377 = v321;
                if (v363 >= v322)
                {
                  float v376 = v322;
                  float v377 = v321;
                  if (v363 > v321)
                  {
                    float v376 = v322;
                    float v377 = v363;
                  }
                }
                uint64_t v378 = 0;
                int v379 = v350 + 1 - v375;
                while (1)
                {
                  int v380 = v378 + 2;
                  if (v378 == 6) {
                    break;
                  }
                  std::vector<int> v381 = &apple::vision::libraries::autotrace::SLGADT[v378];
                  float v382 = v381[2];
                  BOOL v383 = *v381 > v365 || v365 > v382;
                  v378 += 2;
                  if (!v383)
                  {
                    float v384 = (float)(v365 - *v381) / (float)(v382 - *v381);
                    float v385 = apple::vision::libraries::autotrace::SLGADT[((v380 - 2) & 0xFFFFFFFE) + 1];
                    float v386 = v385
                         + (float)(v384
                                 * (float)(apple::vision::libraries::autotrace::SLGADT[(v380 & 0xFFFFFFFE) + 1] - v385));
                    goto LABEL_553;
                  }
                }
                float v386 = 1.0;
                VNValidatedLog(4, @"%s: angle %.3f not found in straightLineGatheredAngleDeltaToleranceAtAngle", v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"straightLineGatheredAngleDeltaToleranceAtAngle");
LABEL_553:
                if (v343 == v379 && (float)(v377 - v376) <= v386)
                {
                  ++v318;
                  char v349 = 1;
                  int v350 = v343;
                  float v322 = v376;
                  float v321 = v377;
                }
                else
                {
                  int v387 = v453 - 10;
                  uint64_t v388 = v453 - 10;
                  if (v453 - 10 >= (int)v314)
                  {
                    uint64_t v390 = v387 - v314;
                    if (v388 - v314 >= v314)
                    {
                      if (v314) {
                        uint64_t v388 = v390 % v314;
                      }
                    }
                    else
                    {
                      LODWORD(v388) = v388 - v314;
                    }
                  }
                  else if (v453 <= 9)
                  {
                    uint64_t v389 = v387 + v314;
                    if (v388 + v314 < 0 == __OFADD__(v388, v314)) {
                      LODWORD(v388) = v388 + v314;
                    }
                    if (v389 < 0 && v314) {
                      uint64_t v388 = v389 % v314 + v314;
                    }
                  }
                  int v391 = v318 + 20 + v388;
                  uint64_t v392 = v391;
                  if (v391 >= (int)v314)
                  {
                    uint64_t v394 = v391 - v314;
                    if (v392 - v314 >= v314)
                    {
                      if (v314) {
                        uint64_t v392 = v394 % v314;
                      }
                    }
                    else
                    {
                      LODWORD(v392) = v392 - v314;
                    }
                  }
                  else if (v391 < 0)
                  {
                    uint64_t v393 = v391 + v314;
                    if (v392 + v314 < 0 == __OFADD__(v392, v314)) {
                      LODWORD(v392) = v392 + v314;
                    }
                    if (v393 < 0 && v314) {
                      uint64_t v392 = v393 % v314 + v314;
                    }
                  }
                  LODWORD(v466[0]) = v392;
                  if (apple::vision::libraries::autotrace::ContourToPath::outputLineAtIndex((uint64_t)this, v388, v318 + 20, &__p, v466, &v461))
                  {
                    int v395 = v347 - LODWORD(v466[0]);
                    if ((int)v347 - LODWORD(v466[0]) >= v449) {
                      int v396 = v314;
                    }
                    else {
                      int v396 = 0;
                    }
                    if (v395 >= v450) {
                      int v397 = -v396;
                    }
                    else {
                      int v397 = v314;
                    }
                    if (v395 + v397 < 9) {
                      goto LABEL_484;
                    }
                    uint64_t v343 = SLODWORD(v466[0]) + 9;
                    if (LODWORD(v466[0]) + 9 >= (int)v314)
                    {
                      if (v343 - v314 >= v314)
                      {
                        if (v314) {
                          uint64_t v343 = (v343 - v314) % v314;
                        }
                      }
                      else
                      {
                        LODWORD(v343) = v343 - v314;
                      }
                    }
                    else if (SLODWORD(v466[0]) <= -10)
                    {
                      uint64_t v398 = v343 + v314;
                      if (v343 + v314 < 0 == __OFADD__(v343, v314)) {
                        LODWORD(v343) = v343 + v314;
                      }
                      if (v398 < 0 && v314) {
                        uint64_t v343 = v398 % v314 + v314;
                      }
                    }
                  }
                  char v349 = 0;
                  BOOL v399 = 0;
                  if (LOBYTE(v461)) {
                    goto LABEL_642;
                  }
                }
              }
              else
              {
                int v318 = 1;
                int v350 = v343;
                int v453 = v343;
                float v322 = v363;
                float v321 = v363;
                char v349 = 1;
              }
            }
            if ((int)v343 + 1 >= (int)v314) {
              int v400 = v314;
            }
            else {
              int v400 = 0;
            }
            if (v343 != v347) {
              LODWORD(v343) = v343 + 1 - v400;
            }
          }
          while (v343 != v347);
          if (v349)
          {
            int v401 = v453 - 10;
            uint64_t v402 = v453 - 10;
            if (v453 - 10 >= (int)v314)
            {
              uint64_t v404 = v401 - v314;
              if (v402 - v314 >= v314)
              {
                if (v314) {
                  uint64_t v402 = v404 % v314;
                }
              }
              else
              {
                LODWORD(v402) = v402 - v314;
              }
            }
            else if (v453 <= 9)
            {
              uint64_t v403 = v401 + v314;
              if (v402 + v314 < 0 == __OFADD__(v402, v314)) {
                LODWORD(v402) = v402 + v314;
              }
              if (v403 < 0 && v314) {
                uint64_t v402 = v403 % v314 + v314;
              }
            }
            int v405 = v318 + 19 + v402;
            uint64_t v406 = v405;
            if (v405 >= (int)v314)
            {
              uint64_t v408 = v405 - v314;
              if (v406 - v314 >= v314)
              {
                if (v314) {
                  uint64_t v406 = v408 % v314;
                }
              }
              else
              {
                LODWORD(v406) = v406 - v314;
              }
            }
            else if (v405 < 0)
            {
              uint64_t v407 = v405 + v314;
              if (v406 + v314 < 0 == __OFADD__(v406, v314)) {
                LODWORD(v406) = v406 + v314;
              }
              if (v407 < 0 && v314) {
                uint64_t v406 = v407 % v314 + v314;
              }
            }
            LODWORD(v466[0]) = v406;
            apple::vision::libraries::autotrace::ContourToPath::outputLineAtIndex((uint64_t)this, v402, v318 + 19, &__p, v466, &v461);
            unint64_t v317 = v458;
            if (LOBYTE(v461))
            {
LABEL_628:
              BOOL v399 = 0;
              goto LABEL_642;
            }
          }
        }
      }
    }
LABEL_484:
    uint64_t v315 = *((void *)this + 15);
    uint64_t v319 = (*((void *)this + 16) - v315) >> 3;
    if (v319 > v317) {
      continue;
    }
    break;
  }
  v410 = (char *)__p;
  v409 = v464;
  if (v464 == __p)
  {
    BOOL v399 = 1;
    goto LABEL_643;
  }
  uint64_t v411 = 0;
  unint64_t v412 = 0;
  while (1)
  {
    apple::vision::libraries::autotrace::ContourToPath::insertPairIntoInterestingPoints((uint64_t)this, (uint64_t)&v410[v411], *(_DWORD *)&v410[v411 + 8], *(_DWORD *)&v410[v411 + 12], v451, &v461);
    BOOL v399 = LOBYTE(v461) == 0;
    if (LOBYTE(v461)) {
      break;
    }
    v412 += 2;
    v410 = (char *)__p;
    v411 += 16;
    if (v412 >= (v464 - (unsigned char *)__p) >> 3) {
      goto LABEL_641;
    }
  }
LABEL_642:
  v409 = __p;
LABEL_643:
  if (v409) {
    operator delete(v409);
  }
  if (v399)
  {
    if (apple::vision::libraries::autotrace::ContourToPath::findInflectionPoints(this, v272, v206, v207, a5, (uint64_t)a6, v208, v209))
    {
      if (apple::vision::libraries::autotrace::ContourToPath::cutUpCurves(this, v413, v414, v415, v416, v417, v418, v419))
      {
        if (apple::vision::libraries::autotrace::ContourToPath::coalesceStraightLines(this, v420, v421, v422, v423, v424, v425, v426))
        {
          apple::vision::libraries::autotrace::ContourToPath::extractCurveRecords(this, v427, v428, v429, v430, v431, v432, v433);
          apple::vision::libraries::autotrace::ContourToPath::computeCurveTangents(this, v434, v435, v436, v437, v438, v439, v440);
          apple::vision::libraries::autotrace::ContourToPath::computePoints(this, v441, v442, v443, v444, v445, v446, v447);
          apple::vision::libraries::autotrace::ContourToPath::findSubdividedCurves(this, v448);
          apple::vision::libraries::autotrace::ContourToPath::convertToPaths(this);
          return 1;
        }
        VNValidatedLog(4, @"%s: failing coalesceStraightLines", v428, v429, v430, v431, v432, v433, (uint64_t)"autoTrace");
      }
      else
      {
        VNValidatedLog(4, @"%s: failing cutUpCurves", v421, v422, v423, v424, v425, v426, (uint64_t)"autoTrace");
      }
    }
    else
    {
      VNValidatedLog(4, @"%s: failing findInflectionPoints", v414, v415, v416, v417, v418, v419, (uint64_t)"autoTrace");
    }
  }
  else
  {
    VNValidatedLog(4, @"%s: failing findNonOrthogonalLines", v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"autoTrace");
  }
  return 0;
}

void sub_1A3FED620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void apple::vision::libraries::autotrace::ContourToPath::~ContourToPath(CGPathRef *this)
{
  CGPathRelease(this[2]);
  apple::vision::libraries::autotrace::ContourToPath::freeAutoTraceStructures((apple::vision::libraries::autotrace::ContourToPath *)this);
  int v2 = this[18];
  if (v2)
  {
    this[19] = v2;
    operator delete(v2);
  }
  uint64_t v3 = this[15];
  if (v3)
  {
    this[16] = v3;
    operator delete(v3);
  }
  unsigned int v4 = this[12];
  if (v4)
  {
    this[13] = v4;
    operator delete(v4);
  }
}

void apple::vision::libraries::autotrace::ContourToPath::freeAutoTraceStructures(apple::vision::libraries::autotrace::ContourToPath *this)
{
  int v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    free(v2);
    *((void *)this + 6) = 0;
  }
  uint64_t v3 = (void *)*((void *)this + 10);
  if (v3)
  {
    free(v3);
    *((void *)this + 10) = 0;
  }
  unsigned int v4 = (void *)*((void *)this + 11);
  if (v4)
  {
    free(v4);
    *((void *)this + 11) = 0;
  }
  long long v5 = (void *)*((void *)this + 7);
  if (v5)
  {
    free(v5);
    *((void *)this + 7) = 0;
  }
  uint64_t v6 = (void *)*((void *)this + 8);
  if (v6)
  {
    free(v6);
    *((void *)this + 8) = 0;
  }
  uint64_t v7 = (void *)*((void *)this + 9);
  if (v7)
  {
    free(v7);
    *((void *)this + 9) = 0;
  }
  *((_DWORD *)this + 10) = 0;
}

BOOL apple::vision::libraries::autotrace::ContourToPath::findInflectionPoints(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = **((_DWORD **)this + 3);
  std::string __p = 0;
  int v79 = 0;
  uint64_t v80 = 0;
  uint64_t v9 = *((void *)this + 15);
  uint64_t v10 = *((void *)this + 16) - v9;
  if (!v10)
  {
    BOOL v65 = 1;
    goto LABEL_101;
  }
  BOOL v11 = this;
  float v74 = (void *)((char *)this + 120);
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v14 = v10 >> 3;
  do
  {
    uint64_t v15 = v13 + 1;
    uint64_t v16 = v15 - v14;
    if (v15 >= v14)
    {
      if (v16 >= v14) {
        v16 %= v14;
      }
    }
    else
    {
      LODWORD(v16) = v13 + 1;
      if (v13 <= -2)
      {
        uint64_t v16 = v14 + v15;
        if (v14 + v15 < 0) {
          uint64_t v16 = v16 % v14 + v14;
        }
      }
    }
    uint64_t v17 = v9 + 8 * v12;
    int v20 = *(_DWORD *)(v17 + 4);
    unsigned int v19 = (int *)(v17 + 4);
    char v18 = v20;
    if ((v20 & 0xA) == 0)
    {
      uint64_t v76 = v12;
      uint64_t v21 = (signed int *)(v9 + 8 * (int)v16);
      uint64_t v22 = *(unsigned int *)(v9 + 8 * v12);
      signed int v23 = *v21;
      int v24 = *v21 - v22;
      if (*v21 <= (int)v22) {
        int v25 = v8;
      }
      else {
        int v25 = 0;
      }
      int v26 = v25 + v24;
      if (v18)
      {
        int v28 = v25 + v24;
        Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)v11 + 12), *((apple::vision::libraries::autotrace::CornerList **)v11 + 13), **((unsigned int **)v11 + 3), v22, 1, a6, a7, a8);
        if (!Corner) {
          goto LABEL_91;
        }
        signed int v27 = *((_DWORD *)Corner + 1);
        int v30 = v22;
        int v26 = v28;
        while (v30 != v27)
        {
          int v31 = v30 + 1;
          if (v31 >= v8) {
            int v32 = v8;
          }
          else {
            int v32 = 0;
          }
          int v30 = v31 - v32;
          --v28;
          if (v30 == v23)
          {
            signed int v27 = v23;
            break;
          }
        }
      }
      else
      {
        signed int v27 = v22;
        int v28 = v25 + v24;
      }
      uint64_t v33 = (int)v16;
      if (v27 != v23 || v28)
      {
        uint64_t v35 = v9 + 8 * (int)v16;
        char v37 = *(unsigned char *)(v35 + 4);
        float v36 = (int *)(v35 + 4);
        if (v37)
        {
          int v75 = v36;
          uint64_t v38 = (int)v16;
          int v39 = v26;
          uint64_t v40 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v21, 1, a6, a7, a8);
          if (!v40) {
            goto LABEL_91;
          }
          if (v23 == v22)
          {
            signed int v23 = v22;
            int v26 = v39;
            uint64_t v33 = v38;
            float v36 = v75;
          }
          else
          {
            int v26 = v39;
            uint64_t v33 = v38;
            float v36 = v75;
            while (v23 != *(_DWORD *)v40)
            {
              if (v23 <= 0) {
                int v45 = v8;
              }
              else {
                int v45 = 0;
              }
              signed int v23 = v23 + v45 - 1;
              --v28;
              if (v23 == v22)
              {
                signed int v23 = v22;
                goto LABEL_49;
              }
            }
            signed int v23 = *(_DWORD *)v40;
          }
        }
LABEL_49:
        if (v28 > 3)
        {
          if (!apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v27, 8, &__p)) {
            goto LABEL_91;
          }
          LOBYTE(v47) = *(float *)(*((void *)this + 8) + 4 * v27) > 0.0;
          signed int v48 = v27;
          do
          {
            uint64_t v49 = *((void *)this + 8);
            float v50 = *(float *)(v49 + 4 * v48);
            int v51 = v47 & 1;
            if (v51 == v50 <= 0.0)
            {
              if (v48 <= 0) {
                int v53 = v8;
              }
              else {
                int v53 = 0;
              }
              float v54 = *(float *)(v49 + 4 * (v48 + v53 - 1));
              int v52 = v48 + 1;
              if (v48 + 1 >= v8) {
                int v55 = v8;
              }
              else {
                int v55 = 0;
              }
              int v47 = (float)((float)((float)(v50 + v54) + *(float *)(v49 + 4 * (v52 - v55))) * 0.33333) > 0.0;
              if (v51 != v47
                && (v8 & ((v48 - v27) >> 31)) + v48 - v27 >= 6
                && (v8 & ((v23 - v48) >> 31)) + v23 - v48 >= 6
                && (!apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v48, 16, &__p)
                 || !apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v48, 32, &__p)
                 || !apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v48, 8, &__p)))
              {
                goto LABEL_91;
              }
            }
            else
            {
              int v52 = v48 + 1;
            }
            if (v52 >= v8) {
              int v56 = v8;
            }
            else {
              int v56 = 0;
            }
            signed int v48 = v52 - v56;
          }
          while (v52 - v56 != v23);
          BOOL v11 = this;
          if (!apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v23, 16, &__p))
          {
LABEL_91:
            BOOL v65 = 0;
            goto LABEL_101;
          }
        }
        else
        {
          int v46 = *v19;
          if ((*v19 & 1) == 0)
          {
            BOOL v11 = this;
            goto LABEL_10;
          }
          int v57 = *v36;
          BOOL v58 = (v46 & 0xA) != 0 || (*v36 & 1) == 0;
          BOOL v11 = this;
          if (!v58)
          {
            if (v26 >= 3)
            {
              int *v19 = v46 | 8;
              *v36 |= 0x10u;
              goto LABEL_10;
            }
            if ((v46 & 0x10) != 0)
            {
              v57 |= 0x10u;
              *float v36 = v57;
              int v46 = *v19;
            }
            if ((v46 & 4) != 0) {
              *float v36 = v57 | 4;
            }
            goto LABEL_84;
          }
        }
      }
      else
      {
        int v34 = *v19;
        if ((*v19 & 1) == 0)
        {
          BOOL v11 = this;
          goto LABEL_10;
        }
        BOOL v11 = this;
        if ((v34 & 0xA) == 0)
        {
          uint64_t v41 = v9 + 8 * (int)v16;
          int v44 = *(_DWORD *)(v41 + 4);
          unint64_t v42 = (int *)(v41 + 4);
          int v43 = v44;
          if (v44)
          {
            if (v26 >= 3)
            {
              int *v19 = v34 | 8;
              *v42 |= 0x10u;
              goto LABEL_10;
            }
            if ((v34 & 0x10) != 0)
            {
              v43 |= 0x10u;
              *unint64_t v42 = v43;
              int v34 = *v19;
            }
            if ((v34 & 4) != 0) {
              *unint64_t v42 = v43 | 4;
            }
LABEL_84:
            uint64_t v60 = *((void *)v11 + 15);
            uint64_t v59 = (unsigned char *)*((void *)v11 + 16);
            if (((uint64_t)&v59[-v60] >> 3) - 1 == v76)
            {
              int v61 = v59 - 8;
            }
            else
            {
              int v62 = (char *)(v60 + 8 * v33);
              float v63 = v62 - 8;
              uint64_t v64 = v59 - v62;
              if (v59 != v62) {
                memmove(v62 - 8, v62, v59 - v62);
              }
              int v61 = &v63[v64];
            }
            *((void *)v11 + 16) = v61;
            --v13;
          }
        }
      }
    }
LABEL_10:
    uint64_t v12 = ++v13;
    uint64_t v9 = *((void *)v11 + 15);
    uint64_t v14 = (*((void *)v11 + 16) - v9) >> 3;
  }
  while (v14 > (unint64_t)v13);
  float v66 = v79;
  if (v79 == __p)
  {
    BOOL v65 = 1;
    if (v79) {
      goto LABEL_102;
    }
  }
  else
  {
    unint64_t v67 = ((unsigned char *)v79 - (unsigned char *)__p) >> 3;
    if (v67 <= 1) {
      unint64_t v67 = 1;
    }
    unint64_t v68 = v67 - 1;
    float v69 = (unsigned int *)((char *)__p + 4);
    do
    {
      uint64_t v70 = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(*(v69 - 1), *v69, v74);
      BOOL v65 = v70 != 0;
      BOOL v72 = v68-- != 0;
      if (!v70) {
        break;
      }
      v69 += 2;
    }
    while (v72);
LABEL_101:
    float v66 = __p;
    if (__p) {
LABEL_102:
    }
      operator delete(v66);
  }
  return v65;
}

void sub_1A3FEDC50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::cutUpCurves(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (char *)*((void *)this + 15);
  int v8 = (char *)this + 120;
  uint64_t v9 = v10;
  uint64_t v11 = **((unsigned int **)v8 - 12);
  uint64_t v12 = (char *)*((void *)v8 + 1);
  uint64_t v13 = v12 - v10;
  if (v12 - v10 == 8)
  {
    BOOL v14 = *((_DWORD *)v9 + 1) != 64 || (int)v11 < 1;
    if (!v14)
    {
      uint64_t v15 = 0;
      uint64_t v16 = *((void *)this + 7);
      while (1)
      {
        uint64_t v17 = v15 + 1;
        unsigned int v18 = v11 - 1 == v15 ? 0 : v15 + 1;
        float v19 = *(float *)(v16 + 4 * v15);
        if (v19 <= 0.5 && *(float *)(v16 + 4 * v18) >= 0.5) {
          break;
        }
        if (v19 >= 0.5 && *(float *)(v16 + 4 * v18) <= 0.5) {
          break;
        }
        ++v15;
        if (v11 == v17) {
          goto LABEL_17;
        }
      }
      *(_DWORD *)uint64_t v9 = v15;
      *((_DWORD *)v9 + 1) = 24;
    }
  }
LABEL_17:
  if (v12 == v9)
  {
    std::string __p = 0;
    uint64_t v90 = 0;
    uint64_t v82 = 1;
    uint64_t v91 = 0;
LABEL_128:
    float v71 = __p;
    if (!__p) {
      return v82;
    }
LABEL_129:
    uint64_t v90 = v71;
    operator delete(v71);
    return v82;
  }
  int v84 = v8;
  unint64_t v20 = 0;
  int v21 = v11;
  uint64_t v22 = v13 >> 3;
  do
  {
    unint64_t v23 = v20++;
    LODWORD(v24) = v20;
    uint64_t v25 = v20 - v22;
    if ((uint64_t)v20 >= v22)
    {
      LODWORD(v24) = v20 - v22;
      if (v25 >= v22) {
        uint64_t v24 = v25 % v22;
      }
    }
    if ((v9[8 * v23 + 4] & 8) != 0)
    {
      int v26 = *(_DWORD *)&v9[8 * v23];
      int v27 = *(_DWORD *)&v9[8 * (int)v24];
      BOOL v28 = __OFSUB__(v27, v26);
      int v29 = v27 - v26;
      int v30 = (v29 < 0) ^ v28 | (v29 == 0) ? v11 : 0;
      uint64_t v31 = (v30 + v29);
      if ((int)v31 >= 1)
      {
        unint64_t v32 = 0;
        uint64_t v34 = *((void *)this + 8);
        uint64_t v33 = *((void *)this + 9);
        do
        {
          uint64_t v35 = v26;
          float v36 = *(float *)(v34 + 4 * v26);
          if (v11 == v31)
          {
            uint64_t v37 = -1;
            uint64_t v38 = 1 - (int)v11;
            uint64_t v39 = (int)v11 + 1;
            a6 = ~(uint64_t)(int)v11;
            a7 = (int)v11 - 1;
            a8 = 1;
            do
            {
              uint64_t v40 = a8 + v35;
              LODWORD(v41) = a8 + v35 - v11;
              if (a8 + v35 >= (int)v11)
              {
                if (v35 + v38 >= (int)v11) {
                  uint64_t v41 = (v35 + v38) % (int)v11;
                }
              }
              else
              {
                LODWORD(v41) = a8 + v35;
                if (v40 < 0)
                {
                  if (v35 + v39 < 0) {
                    uint64_t v41 = (v35 + v39) % (int)v11 + (int)v11;
                  }
                  else {
                    LODWORD(v41) = v40 + v11;
                  }
                }
              }
              int v42 = v35 - a8;
              uint64_t v43 = v35 + v37;
              if (v35 + v37 >= (int)v11)
              {
                if (v35 + a6 >= (int)v11) {
                  uint64_t v43 = (v35 + a6) % (int)v11;
                }
                else {
                  LODWORD(v43) = v42 - v11;
                }
              }
              else if (v43 < 0)
              {
                if (v35 + a7 < 0) {
                  uint64_t v43 = (v35 + a7) % (int)v11 + (int)v11;
                }
                else {
                  LODWORD(v43) = v42 + v11;
                }
              }
              ++a8;
              --v37;
              --a7;
              float v36 = (float)(v36 + *(float *)(v34 + 4 * (int)v41)) + *(float *)(v34 + 4 * (int)v43);
              --a6;
              ++v39;
              ++v38;
            }
            while (v37 != -5);
            int v44 = 9;
          }
          else
          {
            uint64_t v45 = 1;
            a6 = -1;
            a7 = ~(uint64_t)(int)v11;
            a8 = (int)v11 - 1;
            uint64_t v46 = 1 - (int)v11;
            uint64_t v47 = (int)v11 + 1;
            int v44 = 1;
            do
            {
              if (v45 < (uint64_t)(v31 - v32))
              {
                uint64_t v48 = v26 + v45;
                if (v48 >= (int)v11)
                {
                  if (v26 + v46 >= (int)v11)
                  {
                    if (v11) {
                      uint64_t v48 = (v26 + v46) % (int)v11;
                    }
                  }
                  else
                  {
                    LODWORD(v48) = v26 + v46;
                  }
                }
                else if (v48 < 0)
                {
                  uint64_t v49 = v26 + v47;
                  if (v49 >= 0) {
                    LODWORD(v48) = v26 + v47;
                  }
                  if (v49 < 0 && v11) {
                    uint64_t v48 = v49 % (int)v11 + (int)v11;
                  }
                }
                float v36 = v36 + *(float *)(v34 + 4 * (int)v48);
                ++v44;
              }
              if (v32 >= v45)
              {
                uint64_t v50 = v26 + a6;
                if (v50 >= (int)v11)
                {
                  if (v26 + a7 >= (int)v11)
                  {
                    if (v11) {
                      uint64_t v50 = (v26 + a7) % (int)v11;
                    }
                  }
                  else
                  {
                    LODWORD(v50) = v26 + a7;
                  }
                }
                else if (v50 < 0)
                {
                  uint64_t v51 = v26 + a8;
                  if (v51 >= 0) {
                    LODWORD(v50) = v26 + a8;
                  }
                  if (v51 < 0 && v11) {
                    uint64_t v50 = v51 % (int)v11 + (int)v11;
                  }
                }
                float v36 = v36 + *(float *)(v34 + 4 * (int)v50);
                ++v44;
              }
              ++v45;
              ++v47;
              ++v46;
              --a6;
              --a8;
              --a7;
            }
            while (v45 != 5);
          }
          *(float *)(v33 + 4 * v35) = v36 / (float)v44;
          int v52 = v35 + 1;
          if (v52 >= (int)v11) {
            int v53 = v11;
          }
          else {
            int v53 = 0;
          }
          int v26 = v52 - v53;
          ++v32;
        }
        while (v32 != v31);
      }
    }
  }
  while (v20 < v22);
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  std::string __p = 0;
  uint64_t v90 = 0;
  int v85 = (int)v11 >> 1;
  uint64_t v56 = 1;
  uint64_t v91 = 0;
  do
  {
    uint64_t v57 = v55 + 1;
    uint64_t v86 = v57;
    if (v22 <= v56)
    {
      uint64_t v57 = v56 - v22;
      if (v56 - v22 >= v22) {
        v57 %= v22;
      }
    }
    BOOL v58 = &v9[8 * (int)v57];
    int v59 = *(_DWORD *)&v9[v54];
    uint64_t v60 = *(unsigned int *)v58;
    if (v9[v54 + 4])
    {
      Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *(unsigned int *)&v9[v54], 1, a6, a7, a8);
      if (!Corner) {
        goto LABEL_126;
      }
      uint64_t v62 = *((unsigned int *)Corner + 1);
      BOOL v61 = v62 == v59;
    }
    else
    {
      BOOL v61 = 1;
      uint64_t v62 = *(unsigned int *)&v9[v54];
    }
    if (v9[8 * (int)v57 + 4])
    {
      BOOL v66 = v61;
      unint64_t v67 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *(unsigned int *)v58, 1, a6, a7, a8);
      if (!v67) {
        goto LABEL_126;
      }
      uint64_t v65 = *(unsigned int *)v67;
      BOOL v64 = v65 == v60;
      BOOL v61 = v66;
    }
    else
    {
      BOOL v64 = 1;
      uint64_t v65 = v60;
    }
    if ((int)v60 > v59) {
      goto LABEL_99;
    }
    int v68 = v62 - *(_DWORD *)&v9[v54];
    if (v68 < 0) {
      int v68 = *(_DWORD *)&v9[v54] - v62;
    }
    if (v68 > v85) {
      goto LABEL_99;
    }
    int v69 = v65 - *(_DWORD *)v58;
    if (v69 < 0) {
      int v69 = *(_DWORD *)v58 - v65;
    }
    if (v69 <= v85)
    {
      if ((int)v65 <= (int)v62 - v21) {
        goto LABEL_108;
      }
    }
    else
    {
LABEL_99:
      if ((int)v65 <= (int)v62) {
        goto LABEL_108;
      }
    }
    BOOL v70 = v62 == v65 && (!v61 || !v64);
    if (!v70
      && (v9[v54 + 4] & 8) != 0
      && !apple::vision::libraries::autotrace::ContourToPath::cutUpCurve((uint64_t)this, v62, v61, v65, v64, &__p, a7, a8))
    {
LABEL_126:
      uint64_t v82 = 0;
      goto LABEL_128;
    }
LABEL_108:
    uint64_t v55 = v86;
    uint64_t v9 = (char *)*((void *)this + 15);
    uint64_t v22 = (uint64_t)(*((void *)this + 16) - (void)v9) >> 3;
    v54 += 8;
    BOOL v14 = v22 > (unint64_t)v56++;
  }
  while (v14);
  BOOL v72 = (char *)__p;
  float v71 = v90;
  if (v90 != __p)
  {
    uint64_t v73 = 0;
    unint64_t v74 = 0;
    while (1)
    {
      char v88 = 0;
      int v75 = (unsigned int *)&v72[v73];
      unsigned int v77 = *v75;
      uint64_t v76 = v75[1];
      int v78 = apple::vision::libraries::autotrace::ContourToPath::indexOfNewInterestingPointAtPointIndex(*v75, *((void *)this + 15), *((void *)this + 16), &v88);
      if (v88) {
        BOOL v79 = (v76 & 0x18) == 24;
      }
      else {
        BOOL v79 = 0;
      }
      if (!v79) {
        goto LABEL_123;
      }
      int v80 = *(_DWORD *)(*v84 + 8 * v78 + 4);
      if ((v80 & 0x18) != 8 && (v80 & 0x18) != 16) {
        break;
      }
LABEL_124:
      ++v74;
      BOOL v72 = (char *)__p;
      v73 += 8;
      if (v74 >= ((unsigned char *)v90 - (unsigned char *)__p) >> 3)
      {
        uint64_t v82 = 1;
        goto LABEL_128;
      }
    }
    if ((v80 & 4) != 0) {
      uint64_t v76 = 8;
    }
    else {
      uint64_t v76 = v76;
    }
LABEL_123:
    if (!apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v77, v76, v84)) {
      goto LABEL_126;
    }
    goto LABEL_124;
  }
  uint64_t v82 = 1;
  if (v90) {
    goto LABEL_129;
  }
  return v82;
}

void sub_1A3FEE274(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::coalesceStraightLines(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v159 = *MEMORY[0x1E4F143B8];
  float v156 = 0.0;
  uint64_t v155 = 0;
  float v154 = 0.0;
  float v149 = 0.0;
  float v150 = 0.0;
  uint64_t v9 = (char *)*((void *)this + 15);
  int v8 = (char *)*((void *)this + 16);
  if (v8 == v9) {
    return 1;
  }
  uint64_t v10 = this;
  uint64_t v11 = 0;
  int v12 = 0;
  unint64_t v13 = 0;
  BOOL v14 = (int *)*((void *)this + 3);
  uint64_t v140 = *((void *)v14 + 1);
  int v146 = *v14;
  float v153 = 0.0;
  uint64_t v152 = 0;
  float v151 = 0.0;
  BOOL v157 = 0;
  uint64_t v15 = (v8 - v9) >> 3;
  float v16 = 0.0;
  uint64_t v17 = 1;
  uint64_t v18 = 12;
  do
  {
    unint64_t v19 = v13;
    unint64_t v20 = &v9[8 * v13++];
    if ((v20[4] & 2) != 0)
    {
      LODWORD(v21) = v13;
      if (v15 > v13)
      {
        uint64_t v22 = &v9[v18];
        uint64_t v21 = v17;
        while (1)
        {
          int v23 = *(_DWORD *)v22;
          v22 += 8;
          if ((v23 & 7) != 6) {
            break;
          }
          if (v15 == ++v21)
          {
            LODWORD(v21) = v15;
            break;
          }
        }
      }
      if (v13 != v21 && v19 < v21)
      {
        unint64_t v141 = v19;
        uint64_t v142 = v13;
        unint64_t v24 = 0;
        uint64_t v25 = (v12 + v21);
        uint64_t v144 = v11;
        int v26 = v19;
        do
        {
          ++v26;
          uint64_t v27 = *((void *)this + 15);
          uint64_t v28 = *((void *)this + 16);
          uint64_t v29 = (v28 - v27) >> 3;
          LODWORD(v30) = v26;
          if (v29 <= (uint64_t)(v17 + v24))
          {
            uint64_t v31 = v17 + v24 - v29;
            LODWORD(v30) = v17 + v24 - v29;
            if (v31 >= v29)
            {
              LODWORD(v30) = v26;
              if (v28 != v27) {
                uint64_t v30 = v31 % v29;
              }
            }
          }
          int v32 = *(_DWORD *)(v27 + v11);
          int v33 = *(_DWORD *)(v27 + 8 * (int)v30) - v32;
          int v34 = (v146 & (v33 >> 31)) + v33;
          apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v148, *((const EPolygon **)this + 3), v32, v34);
          apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v148, &v157, &v153, (float *)&v152 + 1);
          if (v24 <= 0x12B)
          {
            apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((void *)this + 3) + 8), v32, v34, v157, *((float *)&v152 + 1), v35);
            v158[v24] = v36;
          }
          ++v24;
          v11 += 8;
        }
        while (v25 != v24);
        if (v25 < 0x12C)
        {
          float v38 = v158[0];
          uint64_t v11 = v144;
          if (v25 < 2)
          {
            LODWORD(v40) = 1;
            float v43 = v158[0];
            char v42 = 1;
            uint64_t v10 = this;
LABEL_41:
            if (v40 == v25)
            {
LABEL_42:
              uint64_t v9 = (char *)*((void *)v10 + 15);
              int v8 = (char *)*((void *)v10 + 16);
              uint64_t v48 = &v9[8 * v25];
              uint64_t v49 = &v48[8 * v25 - 8];
              if (v48 != v49)
              {
                int64_t v50 = v8 - v49;
                if (v8 != v49)
                {
                  memmove(v48, v49, v8 - v49);
                  uint64_t v9 = (char *)*((void *)v10 + 15);
                }
                int v8 = &v48[v50];
                *((void *)v10 + 16) = &v48[v50];
              }
              unint64_t v13 = v142;
              if ((((float)(v43 - v38) > 0.00055556) & v42) == 1)
              {
                *(_DWORD *)&v9[8 * v141 + 4] = *(_DWORD *)&v9[8 * v141 + 4] & 0xFFFFFFF5 | 8;
                LODWORD(v51) = v142;
                if (v142 >= (v8 - v9) >> 3)
                {
                  uint64_t v52 = (v8 - v9) >> 3;
                  LODWORD(v51) = v142 - v52;
                  if (v142 - v52 >= v52)
                  {
                    LODWORD(v51) = v142;
                    if (v8 != v9) {
                      uint64_t v51 = (v142 - v52) % v52;
                    }
                  }
                }
                *(_DWORD *)&v9[8 * (int)v51 + 4] = *(_DWORD *)&v9[8 * (int)v51 + 4] & 0xFFFFFFEB | 0x10;
              }
            }
            else
            {
              uint64_t v9 = (char *)*((void *)v10 + 15);
              int v8 = (char *)*((void *)v10 + 16);
              unint64_t v13 = v142;
            }
            goto LABEL_53;
          }
          float v37 = v158[0];
          uint64_t v10 = this;
        }
        else
        {
          VNValidatedLog(4, @"%s: too many straight lines in a row", a3, a4, a5, a6, a7, a8, (uint64_t)"coalesceStraightLines");
          uint64_t v10 = this;
          uint64_t v11 = v144;
          float v37 = v158[0];
          float v38 = v158[0];
        }
        uint64_t v39 = (v12 + v21);
        uint64_t v40 = 1;
        float v41 = v37;
        char v42 = 1;
        float v43 = v37;
        while (1)
        {
          float v44 = v41 - rintf(v41 - v37);
          float v41 = v158[v40];
          float v45 = v41 - rintf(v41 - v37);
          float v46 = v45 > v43 ? v45 : v43;
          if (v45 >= v38) {
            float v43 = v46;
          }
          else {
            float v38 = v45;
          }
          float v47 = (float)(v45 - v44) >= 0.0 ? 1.0 : -1.0;
          if (v40 == 1)
          {
            float v16 = v47;
          }
          else if (v16 != v47)
          {
            char v42 = 0;
          }
          if (vabds_f32(v45, v44) > 0.0097222) {
            goto LABEL_41;
          }
          if (v39 == ++v40) {
            goto LABEL_42;
          }
        }
      }
    }
LABEL_53:
    uint64_t v15 = (v8 - v9) >> 3;
    ++v17;
    --v12;
    v18 += 8;
    v11 += 8;
  }
  while (v15 > v13);
  if (v8 != v9)
  {
    uint64_t v53 = 0;
    uint64_t v54 = 0;
    uint64_t v55 = -1;
    while (2)
    {
      int v56 = v54++;
      uint64_t v57 = v54;
      if (v15 <= v55 + 2)
      {
        uint64_t v57 = v55 - v15 + 2;
        if (v57 >= v15) {
          v57 %= v15;
        }
      }
      uint64_t v58 = v57 << 32;
      int v59 = (int *)&v9[8 * (int)v57];
      int v60 = *(_DWORD *)&v9[v53];
      int v61 = *(_DWORD *)&v9[v53 + 4];
      BOOL v62 = (~v61 & 0x12) == 0 && (v146 & ((*v59 - v60) >> 31)) + *v59 - v60 <= 3;
      if (v62)
      {
        int v63 = *(_DWORD *)&v9[8 * (int)v57 + 4];
        if ((v63 & 8) != 0 && ((v63 | v61) & 1) == 0)
        {
          int v64 = v56 - 1;
          uint64_t v145 = v55 + 1;
          if (v15 >= v55 + 1)
          {
            LODWORD(v65) = v55;
            if (v55 == -1)
            {
              if (v15 - 1 < 0) {
                uint64_t v65 = (v15 - 1) % v15 + v15;
              }
              else {
                LODWORD(v65) = v15 + v64;
              }
            }
          }
          else if (v55 - v15 >= v15)
          {
            uint64_t v65 = (v55 - v15) % v15;
          }
          else
          {
            LODWORD(v65) = v64 - v15;
          }
          a3 = *(unsigned int *)&v9[8 * (int)v65];
          if ((v146 & ((v60 - (int)a3) >> 31)) + v60 - (int)a3 >= 3)
          {
            int v66 = v146;
            if (v60 > 0) {
              int v66 = 0;
            }
            apple::vision::libraries::autotrace::ContourToPath::findTangentBackwardsFrom(v10, v60 + v66 - 1, a3, &v156, (float *)&v155 + 1, &v157, &v153, (float *)&v152 + 1);
            uint64_t v67 = (v58 + 0x100000000) >> 32;
            uint64_t v68 = *((void *)v10 + 15);
            uint64_t v69 = *((void *)v10 + 16);
            uint64_t v70 = (v69 - v68) >> 3;
            if (v67 >= v70)
            {
              LODWORD(v71) = v67 - v70;
              if (v67 - v70 >= v70)
              {
                uint64_t v71 = (v58 + 0x100000000) >> 32;
                if (v69 != v68) {
                  uint64_t v71 = (v67 - v70) % v70;
                }
              }
            }
            else if (v58 + 0x100000000 < 0)
            {
              LODWORD(v71) = v70 + v67;
              if (v70 + v67 < 0)
              {
                uint64_t v71 = (v58 + 0x100000000) >> 32;
                if (v69 != v68) {
                  uint64_t v71 = (v70 + v67) % v70 + v70;
                }
              }
            }
            else
            {
              uint64_t v71 = (v58 + 0x100000000) >> 32;
            }
            a3 = *(unsigned int *)(v68 + 8 * (int)v71);
            int v72 = *v59;
            if ((v146 & (((int)a3 - v72) >> 31)) + (int)a3 - v72 >= 3)
            {
              apple::vision::libraries::autotrace::ContourToPath::findTangentForwardsFrom(v10, v72, a3, (float *)&v155, &v154, &v157, &v153, (float *)&v152 + 1);
              float v73 = atan2f(*((float *)&v155 + 1), v156) * 0.15915;
              float v74 = atan2f(v154, *(float *)&v155);
              float v75 = (float)(v74 * 0.15915) - rintf((float)(v74 * 0.15915) - v73);
              if (vabds_f32(v73, v75) <= 0.0083333)
              {
                int v76 = v146;
                if (*v59 > 0) {
                  int v76 = 0;
                }
                float32x2_t v143 = vsub_f32(*(float32x2_t *)(v140 + 8 * (*v59 + v76 - 1)), *(float32x2_t *)(v140 + 8 * *(int *)&v9[v53]));
                float v77 = atan2f(v143.f32[1], v143.f32[0]);
                if ((float)(sqrtf(vmlas_n_f32(vmuls_lane_f32(v143.f32[1], v143, 1), v143.f32[0], v143.f32[0]))
                           * sinf(fabsf((float)((float)(v77 * 0.15915) - rintf((float)(v77 * 0.15915) - v73))+ (float)((float)(v73 + v75) * -0.5))* 6.2832)) < 0.33333)
                {
                  if (v145 < (int)v57)
                  {
                    uint64_t v78 = *((void *)v10 + 16);
                    uint64_t v79 = *((void *)v10 + 15) + 8 * (int)v57;
                    int v80 = (char *)(v79 - 8);
                    unint64_t v81 = (const void *)(v79 + 8);
                    size_t v82 = v78 - (v79 + 8);
                    if (v78 == v79 + 8) {
                      goto LABEL_99;
                    }
LABEL_98:
                    memmove(v80, v81, v82);
                    goto LABEL_99;
                  }
                  if (v57
                    || (int v80 = (char *)*((void *)v10 + 15),
                        int v83 = (char *)*((void *)v10 + 16),
                        v145 != ((v83 - v80) >> 3) - 1))
                  {
                    VNValidatedLog(4, @"%s: our assumptions have failed", a3, a4, a5, a6, a7, a8, (uint64_t)"coalesceStraightLines");
                    int v80 = (char *)*((void *)v10 + 15);
                    int v83 = (char *)*((void *)v10 + 16);
                  }
                  unint64_t v81 = v80 + 16;
                  size_t v82 = v83 - (v80 + 16);
                  if (v83 != v80 + 16) {
                    goto LABEL_98;
                  }
LABEL_99:
                  *((void *)v10 + 16) = &v80[v82];
                }
              }
            }
          }
        }
      }
      uint64_t v9 = (char *)*((void *)v10 + 15);
      unint64_t v84 = *((void *)v10 + 16);
      uint64_t v15 = (uint64_t)(v84 - (void)v9) >> 3;
      unint64_t v85 = v55 + 2;
      ++v55;
      v53 += 8;
      if (v15 > v85) {
        continue;
      }
      break;
    }
    if ((char *)v84 != v9)
    {
      uint64_t v86 = 0;
      int v87 = 0;
      while (1)
      {
        uint64_t v88 = v87 + 1;
        uint64_t v89 = v88 - v15;
        if (v88 >= v15)
        {
          if (v89 >= v15) {
            v89 %= v15;
          }
        }
        else
        {
          uint64_t v89 = v87 + 1;
          if (v87 <= -2)
          {
            uint64_t v89 = v15 + v88;
            if (v15 + v88 < 0) {
              uint64_t v89 = v89 % v15 + v15;
            }
          }
        }
        uint64_t v90 = &v9[8 * v86];
        int v93 = *((_DWORD *)v90 + 1);
        float v92 = v90 + 4;
        int v91 = v93;
        if ((v93 & 8) == 0) {
          goto LABEL_144;
        }
        float v94 = (int *)&v9[8 * v86];
        uint64_t v95 = v89 << 32;
        float v96 = (int *)&v9[8 * (int)v89];
        a3 = *v96;
        int v97 = *v94;
        int v98 = (v146 & (((int)a3 - v97) >> 31)) + a3 - v97;
        if (v98 > 34) {
          goto LABEL_144;
        }
        float v99 = &v9[8 * (int)v89];
        int v102 = *((_DWORD *)v99 + 1);
        float v101 = (unsigned int *)(v99 + 4);
        int v100 = v102;
        if ((v102 & 0x10) == 0)
        {
LABEL_180:
          VNValidatedLog(4, @"%s: curve (starting at %d) not balanced", a3, a4, a5, a6, a7, a8, (uint64_t)"coalesceStraightLines");
          return 0;
        }
        if (!(v100 & 8 | v91 & 0x10)) {
          goto LABEL_144;
        }
        if ((v100 | v91)) {
          goto LABEL_144;
        }
        apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(this, v97, a3, (float *)&v152, &v151);
        float v103 = 1.0 / (float)v98;
        if (fabsf(v103 * *(float *)&v152) > 0.00027778 || (float)(v103 * v151) > 0.00027778) {
          goto LABEL_144;
        }
        if ((*v92 & 0x10) != 0) {
          break;
        }
        float v104 = this;
        if ((*(unsigned char *)v101 & 8) != 0)
        {
          int v105 = v87 - 1;
          uint64_t v106 = (uint64_t)(v84 - (void)v9) >> 3;
          if (v87 - 1 >= v106)
          {
            LODWORD(v107) = v105 - v106;
            if (v105 - v106 >= v106)
            {
              LODWORD(v107) = v87 - 1;
              if ((char *)v84 != v9) {
                uint64_t v107 = (v105 - v106) % v106;
              }
            }
          }
          else if (v87 <= 0)
          {
            LODWORD(v107) = v106 + v105;
            if (v106 + v105 < 0)
            {
              LODWORD(v107) = v87 - 1;
              if ((char *)v84 != v9) {
                uint64_t v107 = (v106 + v105) % v106 + v106;
              }
            }
          }
          else
          {
            LODWORD(v107) = v87 - 1;
          }
          int v114 = *(_DWORD *)&v9[8 * (int)v107];
          int v115 = (v146 & ((*v94 - v114) >> 31)) + *v94 - v114;
          apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(this, v114, *v94, &v150, &v149);
          float v116 = 1.0 / (float)v115;
          if (fabsf(v150 * v116) <= 0.00027778 && (float)(v116 * v149) <= 0.00027778)
          {
            *float v96 = *v94;
            unsigned int v117 = *(_DWORD *)v92;
            unsigned int v118 = *v101;
            if ((*(_DWORD *)v92 & 4) != 0)
            {
              v118 |= 4u;
              *float v101 = v118;
              unsigned int v117 = *(_DWORD *)v92;
            }
            float v104 = this;
            *float v101 = v118 & 0xFFFFFFEF | (16 * ((v117 >> 4) & 1));
            unint64_t v119 = v84 - (void)(v94 + 2);
            if ((int *)v84 != v94 + 2) {
              memmove(v94, v94 + 2, v84 - (void)(v94 + 2));
            }
            v84 -= 8;
            *((void *)this + 16) = (char *)v94 + v119;
            --v87;
            goto LABEL_145;
          }
          goto LABEL_144;
        }
LABEL_145:
        uint64_t v86 = ++v87;
        uint64_t v9 = (char *)*((void *)v104 + 15);
        uint64_t v15 = (uint64_t)(v84 - (void)v9) >> 3;
        if (v15 <= (unint64_t)v87)
        {
          if ((char *)v84 != v9)
          {
            uint64_t v120 = 0;
            uint64_t v121 = 0;
            uint64_t v122 = -8;
            uint64_t v123 = 1;
            while (1)
            {
              uint64_t v124 = v121++;
              LODWORD(v125) = v121;
              if (v15 <= v123)
              {
                uint64_t v125 = v123 - v15;
                if (v123 - v15 >= v15) {
                  v125 %= v15;
                }
              }
              uint64_t v126 = &v9[v120];
              int v127 = *(_DWORD *)&v9[v120 + 4];
              if ((v127 & 8) == 0) {
                goto LABEL_178;
              }
              uint64_t v128 = &v9[8 * (int)v125];
              int v129 = *(_DWORD *)v126;
              int v130 = (v146 & ((*(_DWORD *)v128 - v129) >> 31)) + *(_DWORD *)v128 - v129;
              if (v130 > 5) {
                goto LABEL_178;
              }
              uint64_t v131 = &v9[8 * (int)v125];
              unsigned int v134 = *((_DWORD *)v131 + 1);
              float v132 = (unsigned int *)(v131 + 4);
              unsigned int v133 = v134;
              if ((v134 & 0x10) == 0) {
                goto LABEL_180;
              }
              if (!(v133 & 8 | *(_DWORD *)&v9[v120 + 4] & 0x10) || ((v133 | v127) & 1) != 0 || v130 > 2) {
                goto LABEL_178;
              }
              if ((v127 & 0x10) != 0) {
                break;
              }
              if ((v133 & 8) != 0)
              {
                *(_DWORD *)uint64_t v128 = v129;
                if ((v127 & 4) != 0)
                {
                  v133 |= 4u;
                  unsigned int *v132 = v133;
                  int v135 = *((_DWORD *)v126 + 1) & 0x10;
                }
                else
                {
                  int v135 = 0;
                }
                unsigned int *v132 = v133 & 0xFFFFFFEF | v135;
                uint64_t v136 = v122 + v84 - (void)v9;
                if (&v9[v120 + 8] != (char *)v84)
                {
                  uint64_t v137 = &v9[8 * v123];
                  size_t v138 = v122 + v84 - (void)v9;
LABEL_176:
                  memmove(v126, v137, v138);
                }
                goto LABEL_177;
              }
LABEL_178:
              uint64_t v15 = (uint64_t)(v84 - (void)v9) >> 3;
              v120 += 8;
              v122 -= 8;
              BOOL v62 = v15 > (unint64_t)v123++;
              if (!v62) {
                return 1;
              }
            }
            if ((v127 & 4) != 0) {
              unsigned int *v132 = v133 & 0xFFFFFFEB | 4;
            }
            uint64_t v136 = v84 - (void)&v9[8 * v124] - 8;
            if (&v9[v120 + 8] != (char *)v84)
            {
              uint64_t v137 = &v9[8 * v123];
              size_t v138 = v122 + v84 - (void)v9;
              goto LABEL_176;
            }
LABEL_177:
            unint64_t v84 = (unint64_t)&v9[v120 + (v136 & 0xFFFFFFFFFFFFFFF8)];
            *((void *)v104 + 16) = v84;
            uint64_t v9 = (char *)*((void *)v104 + 15);
            goto LABEL_178;
          }
          return 1;
        }
      }
      uint64_t v108 = (v95 + 0x100000000) >> 32;
      uint64_t v109 = (uint64_t)(v84 - (void)v9) >> 3;
      if (v108 >= v109)
      {
        LODWORD(v110) = v108 - v109;
        if (v108 - v109 >= v109)
        {
          uint64_t v110 = (v95 + 0x100000000) >> 32;
          if ((char *)v84 != v9) {
            uint64_t v110 = (v108 - v109) % v109;
          }
        }
      }
      else if (v95 + 0x100000000 < 0)
      {
        LODWORD(v110) = v109 + v108;
        if (v109 + v108 < 0)
        {
          uint64_t v110 = (v95 + 0x100000000) >> 32;
          if ((char *)v84 != v9) {
            uint64_t v110 = (v109 + v108) % v109 + v109;
          }
        }
      }
      else
      {
        uint64_t v110 = (v95 + 0x100000000) >> 32;
      }
      int v111 = *(_DWORD *)&v9[8 * (int)v110];
      int v112 = (v146 & ((v111 - *v96) >> 31)) + v111 - *v96;
      apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(this, *v96, v111, &v150, &v149);
      float v113 = 1.0 / (float)v112;
      if (fabsf(v150 * v113) <= 0.00027778 && (float)(v113 * v149) <= 0.00027778)
      {
        float v104 = this;
        if (v89)
        {
          if ((int *)v84 != v96) {
            memmove(v96 - 2, &v9[8 * (int)v89], v84 - (void)v96);
          }
          v84 -= 8;
        }
        else
        {
          v84 -= 8;
        }
        *((void *)this + 16) = v84;
        --v87;
        goto LABEL_145;
      }
LABEL_144:
      float v104 = this;
      goto LABEL_145;
    }
  }
  return 1;
}

void apple::vision::libraries::autotrace::ContourToPath::extractCurveRecords(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v71 = **((_DWORD **)this + 3);
  uint64_t v9 = *((void *)this + 15);
  uint64_t v10 = *((void *)this + 16);
  uint64_t v11 = (v10 - v9) >> 3;
  if (v10 != v9)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 1;
    uint64_t v10 = *((void *)this + 15);
    while (1)
    {
      LODWORD(v15) = ++v13;
      if (v11 <= v14)
      {
        uint64_t v15 = v14 - v11;
        if (v14 - v11 >= v11) {
          v15 %= v11;
        }
      }
      float v16 = (unsigned int *)(v10 + v12);
      int v17 = *(_DWORD *)(v10 + v12 + 4);
      if ((v17 & 0xA) == 0) {
        goto LABEL_20;
      }
      if (v17)
      {
        Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v16, 0, a6, a7, a8);
        uint64_t v18 = (int *)((char *)Corner + 4);
        if (!Corner) {
          uint64_t v18 = (int *)(v10 + v12);
        }
      }
      else
      {
        uint64_t v18 = (int *)(v10 + v12);
      }
      uint64_t v20 = (int)v15;
      uint64_t v21 = (apple::vision::libraries::autotrace::CornerList *)(v10 + 8 * (int)v15);
      int v22 = *v18;
      uint64_t v23 = v10 + 8 * v20;
      char v25 = *(unsigned char *)(v23 + 4);
      unint64_t v24 = (_DWORD *)(v23 + 4);
      if (v25)
      {
        int v26 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *(unsigned int *)v21, 0, a6, a7, a8);
        if (v26) {
          uint64_t v21 = v26;
        }
      }
      if (*(_DWORD *)v21 != v22) {
        goto LABEL_20;
      }
      unsigned int v27 = v16[1];
      if ((v27 & 8) != 0) {
        break;
      }
      if ((v27 & 2) != 0)
      {
        int v28 = -5;
        int v29 = -3;
LABEL_19:
        v16[1] = v27 & v29;
        *v24 &= v28;
      }
LABEL_20:
      uint64_t v10 = *((void *)this + 15);
      unint64_t v30 = *((void *)this + 16);
      uint64_t v11 = (uint64_t)(v30 - v10) >> 3;
      v12 += 8;
      BOOL v31 = v11 > (unint64_t)v14++;
      if (!v31) {
        goto LABEL_23;
      }
    }
    int v28 = -17;
    int v29 = -9;
    goto LABEL_19;
  }
  unint64_t v30 = *((void *)this + 16);
LABEL_23:
  uint64_t v32 = (v11 - 1);
  if ((int)v32 >= 0)
  {
    uint64_t v33 = v32 + 1;
    uint64_t v34 = 8 * v32;
    unint64_t v35 = v34 ^ 0xFFFFFFFFFFFFFFF8;
    do
    {
      uint64_t v36 = *((void *)this + 15);
      uint64_t v37 = v36 + v34;
      if (!*(_DWORD *)(v36 + v34 + 4))
      {
        unint64_t v38 = v35 + v30 - v36;
        if (v37 + 8 != v30) {
          memmove((void *)v37, (const void *)(v37 + 8), v35 + v30 - v36);
        }
        unint64_t v30 = v36 + v34 + (v38 & 0xFFFFFFFFFFFFFFF8);
        *((void *)this + 16) = v30;
      }
      v34 -= 8;
      v35 += 8;
      BOOL v31 = v33-- <= 1;
    }
    while (!v31);
    uint64_t v10 = *((void *)this + 15);
  }
  uint64_t v39 = v30 - v10;
  if (v39)
  {
    unint64_t v40 = 0;
    uint64_t v41 = v39 >> 3;
    while (1)
    {
      unint64_t v42 = v40++;
      LODWORD(v43) = v40;
      uint64_t v44 = v40 - v41;
      if ((uint64_t)v40 >= v41)
      {
        LODWORD(v43) = v40 - v41;
        if (v44 >= v41) {
          uint64_t v43 = v44 % v41;
        }
      }
      float v45 = (unsigned int *)(v10 + 8 * v42);
      float v46 = v45 + 1;
      if ((v45[1] & 0xA) == 0) {
        goto LABEL_67;
      }
      if (v45[1])
      {
        float v47 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v45, 0, a6, a7, a8);
        if (v47) {
          float v45 = (unsigned int *)((char *)v47 + 4);
        }
      }
      uint64_t v48 = (apple::vision::libraries::autotrace::CornerList *)(v10 + 8 * (int)v43);
      int v49 = *v45;
      if (*((unsigned char *)v48 + 4))
      {
        int64_t v50 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *(unsigned int *)v48, 0, a6, a7, a8);
        if (v50) {
          uint64_t v48 = v50;
        }
      }
      int v51 = *(_DWORD *)v48;
      int v52 = *(_DWORD *)v48 - v49;
      if (v51 == v49) {
        goto LABEL_67;
      }
      uint64_t v53 = (_OWORD *)*((void *)this + 19);
      unint64_t v54 = *((void *)this + 20);
      if ((unint64_t)v53 >= v54)
      {
        uint64_t v56 = *((void *)this + 18);
        unint64_t v57 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v53 - v56) >> 5);
        unint64_t v58 = v57 + 1;
        if (v57 + 1 > 0x2AAAAAAAAAAAAAALL) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v54 - v56) >> 5);
        if (2 * v59 > v58) {
          unint64_t v58 = 2 * v59;
        }
        if (v59 >= 0x155555555555555) {
          unint64_t v60 = 0x2AAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v60 = v58;
        }
        if (v60) {
          unint64_t v60 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(v60);
        }
        else {
          uint64_t v61 = 0;
        }
        BOOL v62 = (_OWORD *)(v60 + 96 * v57);
        _DWORD v62[4] = 0u;
        v62[5] = 0u;
        void v62[2] = 0u;
        v62[3] = 0u;
        *BOOL v62 = 0u;
        v62[1] = 0u;
        int v64 = (char *)*((void *)this + 18);
        int v63 = (char *)*((void *)this + 19);
        uint64_t v65 = v62;
        if (v63 != v64)
        {
          do
          {
            long long v66 = *((_OWORD *)v63 - 5);
            *(v65 - 6) = *((_OWORD *)v63 - 6);
            *(v65 - 5) = v66;
            long long v67 = *((_OWORD *)v63 - 4);
            long long v68 = *((_OWORD *)v63 - 3);
            long long v69 = *((_OWORD *)v63 - 1);
            *(v65 - 2) = *((_OWORD *)v63 - 2);
            *(v65 - 1) = v69;
            *(v65 - 4) = v67;
            *(v65 - 3) = v68;
            v65 -= 6;
            v63 -= 96;
          }
          while (v63 != v64);
          int v63 = (char *)*((void *)this + 18);
        }
        uint64_t v55 = v62 + 6;
        *((void *)this + 18) = v65;
        *((void *)this + 19) = v62 + 6;
        *((void *)this + 20) = v60 + 96 * v61;
        if (v63) {
          operator delete(v63);
        }
      }
      else
      {
        v53[4] = 0u;
        v53[5] = 0u;
        v53[2] = 0u;
        _OWORD v53[3] = 0u;
        uint64_t v55 = v53 + 6;
        *uint64_t v53 = 0u;
        v53[1] = 0u;
      }
      *((void *)this + 19) = v55;
      if ((*v46 & 8) != 0) {
        break;
      }
      if ((*v46 & 2) != 0)
      {
        int v70 = 0;
LABEL_65:
        *((_DWORD *)v55 - 24) = v70;
      }
      *((_DWORD *)v55 - 23) = v42;
      *((_DWORD *)v55 - 22) = v49;
      *((_DWORD *)v55 - 11) = v43;
      *((_DWORD *)v55 - 10) = v51;
      *((_DWORD *)v55 - 1) = (v71 & (v52 >> 31)) + v52;
LABEL_67:
      uint64_t v10 = *((void *)this + 15);
      uint64_t v41 = (*((void *)this + 16) - v10) >> 3;
      if (v41 <= v40) {
        return;
      }
    }
    int v70 = 1;
    goto LABEL_65;
  }
}

void apple::vision::libraries::autotrace::ContourToPath::computeCurveTangents(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v170 = 0;
  unint64_t v169 = 0;
  uint64_t v8 = *((void *)this + 18);
  uint64_t v9 = *((void *)this + 19) - v8;
  if (v9)
  {
    uint64_t v10 = this;
    unint64_t v11 = 0;
    uint64_t v12 = (int *)*((void *)this + 3);
    uint64_t v13 = *v12;
    uint64_t v165 = *((void *)v12 + 1);
    int64_t v14 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 5);
    int v15 = (int)v13 / 8;
    if ((int)v13 / 8 <= 1) {
      int v15 = 1;
    }
    if ((int)v13 >= 48) {
      int v15 = 6;
    }
    int v154 = v15;
    float v16 = (float *)&unk_1A410B000;
    do
    {
      unint64_t v17 = v11++;
      LODWORD(v18) = v11;
      uint64_t v19 = v11 - v14;
      if ((uint64_t)v11 >= v14)
      {
        LODWORD(v18) = v11 - v14;
        if (v19 >= v14) {
          uint64_t v18 = v19 % v14;
        }
      }
      uint64_t v20 = (_DWORD *)(v8 + 96 * v17);
      int v166 = v18;
      uint64_t v21 = (_DWORD *)(v8 + 96 * (int)v18);
      uint64_t v22 = *((void *)v10 + 15);
      unint64_t v24 = v20 + 13;
      uint64_t v23 = (int)v20[13];
      uint64_t v25 = (int)v21[1];
      if (v23 == v25)
      {
        uint64_t v26 = v22 + 8 * v23;
      }
      else
      {
        uint64_t v27 = (int)v23 + 1;
        uint64_t v28 = *((void *)v10 + 16);
        uint64_t v29 = (v28 - v22) >> 3;
        if (v27 >= v29)
        {
          LODWORD(v30) = v27 - v29;
          if (v27 - v29 >= v29)
          {
            LODWORD(v30) = v23 + 1;
            if (v28 != v22) {
              uint64_t v30 = (v27 - v29) % v29;
            }
          }
        }
        else
        {
          LODWORD(v30) = v23 + 1;
          if ((int)v23 <= -2)
          {
            LODWORD(v30) = v29 + v27;
            if (v29 + v27 < 0)
            {
              LODWORD(v30) = v23 + 1;
              if (v28 != v22) {
                uint64_t v30 = (v29 + v27) % v29 + v29;
              }
            }
          }
        }
        if (v25 == v30)
        {
          if (*(unsigned char *)(v22 + 8 * v23 + 4)) {
            goto LABEL_86;
          }
          uint64_t v26 = v22 + 8 * v25;
        }
        else
        {
          uint64_t v31 = v23 + 2;
          uint64_t v32 = v23 + 2 - v29;
          if (v23 + 2 >= v29)
          {
            LODWORD(v33) = v23 + 2 - v29;
            if (v32 >= v29)
            {
              LODWORD(v33) = v23 + 2;
              if (v28 != v22) {
                uint64_t v33 = v32 % v29;
              }
            }
          }
          else if ((int)v23 > -3)
          {
            LODWORD(v33) = v23 + 2;
          }
          else
          {
            LODWORD(v33) = v29 + v31;
            if (v29 + v31 < 0)
            {
              LODWORD(v33) = v23 + 2;
              if (v28 != v22) {
                uint64_t v33 = (v29 + v31) % v29 + v29;
              }
            }
          }
          if (v25 != v33)
          {
            VNValidatedLog(4, @"%s: too many interesting points in between curves/lines", a3, a4, a5, a6, a7, a8, (uint64_t)"computeCurveTangents");
            return;
          }
          uint64_t v34 = v27 - v29;
          if (v27 >= v29)
          {
            LODWORD(v35) = v27 - v29;
            if (v34 >= v29)
            {
              LODWORD(v35) = v23 + 1;
              if (v28 != v22) {
                uint64_t v35 = v34 % v29;
              }
            }
          }
          else if ((int)v23 > -2)
          {
            LODWORD(v35) = v23 + 1;
          }
          else
          {
            LODWORD(v35) = v29 + v27;
            if (v29 + v27 < 0)
            {
              LODWORD(v35) = v23 + 1;
              if (v28 != v22) {
                uint64_t v35 = (v29 + v27) % v29 + v29;
              }
            }
          }
          uint64_t v26 = v22 + 8 * (int)v35;
        }
      }
      if (*(unsigned char *)(v26 + 4))
      {
LABEL_86:
        if (*v20)
        {
          BOOL v173 = 0;
          v168[0] = 0.0;
          uint64_t v172 = 0;
          unsigned int v171 = 0;
          uint64_t v62 = v8 + 96 * v17;
          apple::vision::libraries::autotrace::ContourToPath::findTangentBackwardsFrom(v10, *(_DWORD *)(v62 + 56), *(_DWORD *)(v62 + 8), (float *)&v172, (float *)&v171, &v173, v168, (float *)&v172 + 1);
          int v63 = HIDWORD(v172);
          *(void *)(v62 + 64) = __PAIR64__(v171, v172);
          *(unsigned char *)(v62 + 80) = v173;
          *(float *)(v62 + 84) = v168[0];
          *(_DWORD *)(v62 + 88) = v63;
          int v64 = v166;
        }
        else
        {
          unint64_t v65 = v11;
          uint64_t v66 = v8 + 96 * v17;
          if (*(int *)(v66 + 92) <= 2) {
            int v67 = 2;
          }
          else {
            int v67 = *(_DWORD *)(v66 + 92);
          }
          int v69 = *(_DWORD *)(v66 + 8);
          long long v68 = (int *)(v66 + 8);
          apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v69, v67);
          int v64 = v166;
          if (apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169))
          {
            int v71 = *v68;
            BOOL v72 = v170;
            float v73 = *(float *)&v169;
            apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((void *)v10 + 3) + 8), v71, v67, v170, *(float *)&v169, v70);
            float v75 = v74 * 6.2832;
            float v76 = *((float *)&v169 + 1);
          }
          else
          {
            uint64_t v86 = *v68;
            if ((int)v86 + 1 >= (int)v13) {
              int v87 = v13;
            }
            else {
              int v87 = 0;
            }
            float32x2_t v88 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v86 + 1 - v87)), *(float32x2_t *)(v165 + 8 * v86));
            LODWORD(v156) = *(void *)(v165 + 8 * v86);
            float v161 = v88.f32[0];
            LODWORD(v89) = HIDWORD(*(void *)(v165 + 8 * v86));
            float v90 = v88.f32[1];
            float v75 = atan2f(v88.f32[1], v88.f32[0]);
            if (v75 < 0.0)
            {
              float v91 = v75 + 6.28318531;
              float v75 = v91;
            }
            if (fabsf(v161) <= fabsf(v90))
            {
              BOOL v72 = 0;
              BOOL v170 = 0;
              float v73 = v161 / v90;
              *(float *)&unint64_t v169 = v73;
              float v76 = v156 - (float)(v73 * v89);
            }
            else
            {
              BOOL v72 = 1;
              BOOL v170 = 1;
              float v73 = v90 / v161;
              *(float *)&unint64_t v169 = v73;
              float v76 = v89 - (float)(v73 * v156);
            }
            *((float *)&v169 + 1) = v76;
          }
          unint64_t v11 = v65;
          __float2 v112 = __sincosf_stret(v75);
          uint64_t v113 = v8 + 96 * v17;
          *(void *)(v113 + 64) = __PAIR64__(LODWORD(v112.__sinval), LODWORD(v112.__cosval));
          *(unsigned char *)(v113 + 80) = v72;
          *(float *)(v113 + 84) = v76;
          *(float *)(v113 + 88) = v73;
        }
        if (*v21)
        {
          apple::vision::libraries::autotrace::ContourToPath::computeCurveStartTangentAtCorner(v10, (uint64_t)v21);
        }
        else
        {
          uint64_t v114 = v8 + 96 * v64;
          if (*(int *)(v114 + 92) <= 2) {
            int v115 = 2;
          }
          else {
            int v115 = *(_DWORD *)(v114 + 92);
          }
          int v117 = *(_DWORD *)(v114 + 8);
          float v116 = (int *)(v114 + 8);
          apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v117, v115);
          if (apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169))
          {
            int v119 = *v116;
            BOOL v120 = v170;
            LODWORD(v121) = v169;
            apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((void *)v10 + 3) + 8), v119, v115, v170, *(float *)&v169, v118);
            float v123 = v122 * 6.2832;
            float v124 = *((float *)&v169 + 1);
          }
          else
          {
            uint64_t v125 = *v116;
            if ((int)v125 + 1 >= (int)v13) {
              int v126 = v13;
            }
            else {
              int v126 = 0;
            }
            float32x2_t v127 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v125 + 1 - v126)), *(float32x2_t *)(v165 + 8 * v125));
            float v167 = v127.f32[0];
            LODWORD(v163) = *(void *)(v165 + 8 * v125);
            LODWORD(v128) = HIDWORD(*(void *)(v165 + 8 * v125));
            float v129 = v127.f32[1];
            float v123 = atan2f(v127.f32[1], v127.f32[0]);
            if (v123 < 0.0)
            {
              float v130 = v123 + 6.28318531;
              float v123 = v130;
            }
            if (fabsf(v167) <= fabsf(v129))
            {
              BOOL v120 = 0;
              BOOL v170 = 0;
              float v121 = v167 / v129;
              float v124 = v163 - (float)(v121 * v128);
            }
            else
            {
              BOOL v120 = 1;
              BOOL v170 = 1;
              float v121 = v129 / v167;
              float v124 = v128 - (float)(v121 * v163);
            }
            unint64_t v169 = __PAIR64__(LODWORD(v124), LODWORD(v121));
          }
          __float2 v131 = __sincosf_stret(v123);
          uint64_t v132 = v8 + 96 * v64;
          *(void *)(v132 + 24) = __PAIR64__(LODWORD(v131.__sinval), LODWORD(v131.__cosval));
          *(unsigned char *)(v132 + 40) = v120;
          *(float *)(v132 + 44) = v124;
          *(float *)(v132 + 48) = v121;
        }
        goto LABEL_166;
      }
      if (!*v20)
      {
        unint64_t v160 = v11;
        uint64_t v77 = v8 + 96 * v17;
        if (*(int *)(v77 + 92) <= 2) {
          int v78 = 2;
        }
        else {
          int v78 = *(_DWORD *)(v77 + 92);
        }
        int v80 = *(_DWORD *)(v77 + 8);
        uint64_t v79 = (int *)(v77 + 8);
        apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v80, v78);
        if (apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169))
        {
          LODWORD(v82) = v169;
          BOOL v155 = v170;
          apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((void *)v10 + 3) + 8), *v79, v78, v170, *(float *)&v169, v81);
          float v84 = v83 * 6.2832;
          float v85 = *((float *)&v169 + 1);
        }
        else
        {
          uint64_t v106 = *v79;
          if ((int)v106 + 1 >= (int)v13) {
            int v107 = v13;
          }
          else {
            int v107 = 0;
          }
          float32x2_t v108 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v106 + 1 - v107)), *(float32x2_t *)(v165 + 8 * v106));
          LODWORD(v151) = *(void *)(v165 + 8 * v106);
          float v152 = v108.f32[0];
          LODWORD(v109) = HIDWORD(*(void *)(v165 + 8 * v106));
          float v110 = v108.f32[1];
          float v84 = atan2f(v108.f32[1], v108.f32[0]);
          if (v84 < 0.0)
          {
            float v111 = v84 + 6.28318531;
            float v84 = v111;
          }
          if (fabsf(v152) <= fabsf(v110))
          {
            BOOL v155 = 0;
            BOOL v170 = 0;
            float v82 = v152 / v110;
            float v85 = v151 - (float)(v82 * v109);
          }
          else
          {
            BOOL v155 = 1;
            BOOL v170 = 1;
            float v82 = v110 / v152;
            float v85 = v109 - (float)(v82 * v151);
          }
          unint64_t v169 = __PAIR64__(LODWORD(v85), LODWORD(v82));
        }
        __float2 v142 = __sincosf_stret(v84);
        float32x2_t v143 = (float32x2_t *)(v8 + 96 * v17);
        v143[8] = (float32x2_t)__PAIR64__(LODWORD(v142.__sinval), LODWORD(v142.__cosval));
        v143[10].i8[0] = v155;
        v143[10].f32[1] = v85;
        v143[11].f32[0] = v82;
        apple::vision::libraries::autotrace::ContourToPath::computeCurveStartTangentAtCorner(v10, (uint64_t)v21);
        uint64_t v144 = (float32x2_t *)(v8 + 96 * v166);
        float32x2_t v146 = v144[3];
        uint64_t v145 = v144 + 3;
        float32x2_t v159 = v143[8];
        if ((float)(fabsf(acosf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v146, v159).i32[1]), v159.f32[0], v146.f32[0])))
                   * 0.15915) >= 0.013889)
        {
          unint64_t v11 = v160;
          float v16 = (float *)&unk_1A410B000;
          if (*(_DWORD *)(v8 + 96 * v17 + 56) != *(_DWORD *)(v8 + 96 * v166 + 8) && *v24 != -1) {
            *(_DWORD *)(v22 + 8 * v23 + 4) |= 1u;
          }
        }
        else
        {
          *uint64_t v145 = v159;
          uint64_t v147 = v8 + 96 * v166;
          *(unsigned char *)(v147 + 40) = v170;
          int v148 = v169;
          *(_DWORD *)(v147 + 44) = HIDWORD(v169);
          *(_DWORD *)(v147 + 48) = v148;
          unint64_t v11 = v160;
          float v16 = (float *)&unk_1A410B000;
        }
        uint64_t v10 = this;
        goto LABEL_167;
      }
      if (*v21)
      {
        uint64_t v36 = v8 + 96 * v17;
        int v37 = *(_DWORD *)(v36 + 92);
        uint64_t v38 = *(int *)(v36 + 56);
        uint64_t v39 = v8 + 96 * v166;
        int v40 = *(_DWORD *)(v39 + 92);
        uint64_t v41 = *(int *)(v39 + 8);
        int v42 = v154;
        do
        {
          if (v37 >= v42) {
            int v43 = v42;
          }
          else {
            int v43 = v37;
          }
          uint64_t v44 = v38 - v43;
          if ((int)v44 >= (int)v13)
          {
            uint64_t v46 = v44 - v13;
            if (v44 - v13 >= v13)
            {
              BOOL v47 = v13 == 0;
            }
            else
            {
              LODWORD(v44) = v44 - v13;
              BOOL v47 = 1;
            }
            if (!v47) {
              uint64_t v44 = v46 % v13;
            }
          }
          else if ((v44 & 0x80000000) != 0)
          {
            uint64_t v45 = v44 + v13;
            if (v44 + v13 < 0 == __OFADD__(v44, v13)) {
              LODWORD(v44) = v44 + v13;
            }
            if (v45 < 0 && v13) {
              uint64_t v44 = v45 % v13 + v13;
            }
          }
          if (v40 > v42) {
            int v48 = v42 + 1;
          }
          else {
            int v48 = v40;
          }
          uint64_t v49 = v41 + v48;
          if ((int)v49 >= (int)v13)
          {
            if (v49 - v13 >= v13)
            {
              if (v13) {
                uint64_t v49 = (v49 - v13) % v13;
              }
            }
            else
            {
              LODWORD(v49) = v49 - v13;
            }
          }
          else if ((v49 & 0x80000000) != 0)
          {
            uint64_t v50 = v49 + v13;
            if (v49 + v13 < 0 == __OFADD__(v49, v13)) {
              LODWORD(v49) = v49 + v13;
            }
            if (v50 < 0 && v13) {
              uint64_t v49 = v50 % v13 + v13;
            }
          }
          int v51 = v42 + 1;
          if (v51 - 1 < 3) {
            break;
          }
          float v52 = *(float *)(*((void *)v10 + 7) + 4 * (int)v49) - *(float *)(*((void *)v10 + 7) + 4 * (int)v44);
          int v42 = v51 - 2;
        }
        while (vabds_f32(v52, rintf(v52)) >= v16[1021]);
        unint64_t v53 = v11;
        if ((int)v49 <= (int)v44) {
          int v54 = v13;
        }
        else {
          int v54 = 0;
        }
        if (v54 + (int)v49 - (int)v44 <= 2) {
          int v55 = 2;
        }
        else {
          int v55 = v54 + v49 - v44;
        }
        apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v44, v55);
        if (apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169))
        {
          BOOL v57 = v170;
          LODWORD(v58) = v169;
          apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((void *)v10 + 3) + 8), v44, v55, v170, *(float *)&v169, v56);
          float v60 = v59 * 6.2832;
          float v61 = *((float *)&v169 + 1);
        }
        else
        {
          if ((int)v44 + 1 >= (int)v13) {
            int v101 = v13;
          }
          else {
            int v101 = 0;
          }
          float32x2_t v102 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v44 + 1 - v101)), *(float32x2_t *)(v165 + 8 * (int)v44));
          float v157 = v102.f32[0];
          LODWORD(v162) = *(void *)(v165 + 8 * (int)v44);
          LODWORD(v103) = HIDWORD(*(void *)(v165 + 8 * (int)v44));
          float v104 = v102.f32[1];
          float v60 = atan2f(v102.f32[1], v102.f32[0]);
          if (v60 < 0.0)
          {
            float v105 = v60 + 6.28318531;
            float v60 = v105;
          }
          if (fabsf(v157) <= fabsf(v104))
          {
            BOOL v57 = 0;
            BOOL v170 = 0;
            float v58 = v157 / v104;
            *(float *)&unint64_t v169 = v58;
            float v61 = v162 - (float)(v58 * v103);
          }
          else
          {
            BOOL v57 = 1;
            BOOL v170 = 1;
            float v58 = v104 / v157;
            *(float *)&unint64_t v169 = v58;
            float v61 = v103 - (float)(v58 * v162);
          }
          *((float *)&v169 + 1) = v61;
        }
        unint64_t v11 = v53;
        __float2 v139 = __sincosf_stret(v60);
        uint64_t v140 = v8 + 96 * v166;
        *(void *)(v140 + 24) = __PAIR64__(LODWORD(v139.__sinval), LODWORD(v139.__cosval));
        *(unsigned char *)(v140 + 40) = v57;
        *(float *)(v140 + 44) = v61;
        *(float *)(v140 + 48) = v58;
        uint64_t v141 = v8 + 96 * v17;
        *(void *)(v141 + 64) = __PAIR64__(LODWORD(v139.__sinval), LODWORD(v139.__cosval));
        *(unsigned char *)(v141 + 80) = v57;
      }
      else
      {
        uint64_t v92 = v8 + 96 * v166;
        if (*(int *)(v92 + 92) <= 2) {
          int v93 = 2;
        }
        else {
          int v93 = *(_DWORD *)(v92 + 92);
        }
        int v95 = *(_DWORD *)(v92 + 8);
        float v94 = (int *)(v92 + 8);
        apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v95, v93);
        if (apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169))
        {
          int v97 = *v94;
          BOOL v98 = v170;
          LODWORD(v58) = v169;
          apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((void *)v10 + 3) + 8), v97, v93, v170, *(float *)&v169, v96);
          float v100 = v99 * 6.2832;
          float v61 = *((float *)&v169 + 1);
        }
        else
        {
          uint64_t v133 = *v94;
          if ((int)v133 + 1 >= (int)v13) {
            int v134 = v13;
          }
          else {
            int v134 = 0;
          }
          float32x2_t v135 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v133 + 1 - v134)), *(float32x2_t *)(v165 + 8 * v133));
          float v158 = v135.f32[0];
          LODWORD(v164) = *(void *)(v165 + 8 * v133);
          LODWORD(v136) = HIDWORD(*(void *)(v165 + 8 * v133));
          float v137 = v135.f32[1];
          float v100 = atan2f(v135.f32[1], v135.f32[0]);
          if (v100 < 0.0)
          {
            float v138 = v100 + 6.28318531;
            float v100 = v138;
          }
          if (fabsf(v158) <= fabsf(v137))
          {
            BOOL v98 = 0;
            BOOL v170 = 0;
            float v58 = v158 / v137;
            float v61 = v164 - (float)(v58 * v136);
          }
          else
          {
            BOOL v98 = 1;
            BOOL v170 = 1;
            float v58 = v137 / v158;
            float v61 = v136 - (float)(v58 * v164);
          }
          unint64_t v169 = __PAIR64__(LODWORD(v61), LODWORD(v58));
        }
        __float2 v149 = __sincosf_stret(v100);
        uint64_t v150 = v8 + 96 * v166;
        *(void *)(v150 + 24) = __PAIR64__(LODWORD(v149.__sinval), LODWORD(v149.__cosval));
        *(unsigned char *)(v150 + 40) = v98;
        *(float *)(v150 + 44) = v61;
        *(float *)(v150 + 48) = v58;
        uint64_t v141 = v8 + 96 * v17;
        *(void *)(v141 + 64) = __PAIR64__(LODWORD(v149.__sinval), LODWORD(v149.__cosval));
        *(unsigned char *)(v141 + 80) = v98;
      }
      *(float *)(v141 + 84) = v61;
      *(float *)(v141 + 88) = v58;
LABEL_166:
      float v16 = (float *)&unk_1A410B000;
LABEL_167:
      uint64_t v8 = *((void *)v10 + 18);
      int64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)v10 + 19) - v8) >> 5);
    }
    while (v14 > v11);
  }
}

void apple::vision::libraries::autotrace::ContourToPath::computePoints(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *((void *)this + 18);
  uint64_t v8 = *((void *)this + 19);
  uint64_t v10 = v8 - v9;
  if (v8 != v9)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = *(void *)(*((void *)this + 3) + 8);
    int64_t v14 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 5);
    uint64_t v15 = 1;
    do
    {
      LODWORD(v16) = ++v12;
      if (v14 <= v15)
      {
        uint64_t v16 = v15 - v14;
        if (v15 - v14 >= v14) {
          v16 %= v14;
        }
      }
      int v17 = v16;
      uint64_t v18 = *((void *)this + 15);
      uint64_t v19 = *(int *)(v9 + v11 + 52);
      uint64_t v20 = v18 + 8 * v19;
      uint64_t v21 = *(int *)(v9 + 96 * v17 + 4);
      if (v19 == v21)
      {
        if (*(unsigned char *)(v20 + 4)) {
          goto LABEL_50;
        }
      }
      else
      {
        uint64_t v22 = (int)v19 + 1;
        a4 = *((void *)this + 16);
        uint64_t v23 = (a4 - v18) >> 3;
        if (v22 >= v23)
        {
          a8 = v22 - v23;
          a7 = v22 - v23;
          if (v22 - v23 >= v23)
          {
            a7 = (int)v19 + 1;
            if (a4 != v18) {
              a7 = a8 % v23;
            }
          }
        }
        else
        {
          a7 = (int)v19 + 1;
          if ((int)v19 <= -2)
          {
            a7 = v23 + v22;
            if (v23 + v22 < 0)
            {
              a8 = a7 / v23;
              a7 = a7 % v23 + v23;
              if (a4 == v18) {
                a7 = (int)v19 + 1;
              }
            }
          }
        }
        if (v21 == a7)
        {
          if (*(unsigned char *)(v18 + 8 * v19 + 4)) {
            goto LABEL_50;
          }
          if (*(unsigned char *)(v18 + 8 * v21 + 4))
          {
            uint64_t v20 = v18 + 8 * v21;
LABEL_50:
            float v35 = *(float *)(v9 + v11 + 88);
            if (*(unsigned char *)(v9 + v11 + 80)) {
              float v36 = *(float *)(v9 + v11 + 88);
            }
            else {
              float v36 = -1.0;
            }
            if (*(unsigned char *)(v9 + v11 + 80)) {
              float v35 = -1.0;
            }
            float v37 = sqrtf((float)(v35 * v35) + (float)(v36 * v36));
            if (v37 == 0.0) {
              goto LABEL_68;
            }
            uint64_t v19 = v9 + 96 * v17;
            float v38 = *(float *)(v19 + 48);
            float v39 = *(unsigned char *)(v19 + 40) ? *(float *)(v19 + 48) : -1.0;
            if (*(unsigned char *)(v19 + 40)) {
              float v38 = -1.0;
            }
            float v40 = sqrtf((float)(v38 * v38) + (float)(v39 * v39));
            if (v40 == 0.0) {
              goto LABEL_68;
            }
            int v41 = *(_DWORD *)v20;
            float v42 = 1.0 / v37;
            float v43 = v36 * (float)(1.0 / v37);
            float v44 = v35 * (float)(1.0 / v37);
            float v45 = 1.0 / v40;
            float v46 = v39 * v45;
            float v47 = v38 * v45;
            float v48 = (float)(v43 * (float)(v38 * v45)) - (float)(v44 * v46);
            if (fabsf(v48) >= 0.08)
            {
              float v50 = v42 * *(float *)(v9 + v11 + 84);
              float v51 = *(float *)(v19 + 44) * v45;
              float v52 = 1.0 / v48;
              *(float *)&unsigned int v53 = (float)((float)(v44 * v51) - (float)(v50 * v47)) * v52;
              *(float *)&unsigned int v54 = (float)((float)(v50 * v46) - (float)(v43 * v51)) * v52;
              uint64_t v55 = v9 + 96 * v17;
              *(void *)(v55 + 16) = __PAIR64__(v54, v53);
              float v56 = (void *)(v55 + 16);
              *((_DWORD *)v56 - 2) = v41;
              uint64_t v57 = *(void *)(v13 + 8 * v41);
              if ((float)((float)((float)(*((float *)&v57 + 1) - *(float *)&v54)
                                 * (float)(*((float *)&v57 + 1) - *(float *)&v54))
                         + (float)((float)(*(float *)&v57 - *(float *)&v53) * (float)(*(float *)&v57 - *(float *)&v53))) > 16.0)
                void *v56 = v57;
            }
            else
            {
              uint64_t v49 = v9 + 96 * v17;
              *(void *)(v49 + 16) = *(void *)(v13 + 8 * v41);
              *(_DWORD *)(v49 + 8) = v41;
            }
            goto LABEL_66;
          }
        }
        else
        {
          uint64_t v20 = v19 + 2;
          a8 = v19 + 2 - v23;
          if (v19 + 2 >= v23)
          {
            a7 = v19 + 2 - v23;
            if (a8 >= v23)
            {
              a7 = v19 + 2;
              if (a4 != v18)
              {
                uint64_t v20 = a8 / v23;
                a7 = a8 % v23;
              }
            }
          }
          else if ((int)v19 > -3)
          {
            a7 = v19 + 2;
          }
          else
          {
            a8 = v23 + v20;
            a7 = v23 + v20;
            if (v23 + v20 < 0)
            {
              a7 = v19 + 2;
              if (a4 != v18)
              {
                uint64_t v20 = a8 % v23;
                a7 = a8 % v23 + v23;
              }
            }
          }
          if (v21 != a7) {
            return;
          }
          uint64_t v21 = v22 - v23;
          if (v22 >= v23)
          {
            uint64_t v19 = v22 - v23;
            if (v21 >= v23)
            {
              uint64_t v19 = v22;
              if (a4 != v18) {
                uint64_t v19 = v21 % v23;
              }
            }
          }
          else if ((int)v19 > -2)
          {
            uint64_t v19 = (int)v19 + 1;
          }
          else
          {
            uint64_t v21 = v23 + v22;
            uint64_t v19 = v23 + v22;
            if (v23 + v22 < 0)
            {
              uint64_t v19 = v22;
              if (a4 != v18) {
                uint64_t v19 = v21 % v23 + v23;
              }
            }
          }
          if (*(unsigned char *)(v18 + 8 * (int)v19 + 4))
          {
            uint64_t v20 = v18 + 8 * (int)v19;
            goto LABEL_50;
          }
        }
      }
      uint64_t v24 = v9 + 96 * v17;
      float v25 = *(float *)(v24 + 48);
      if (*(unsigned char *)(v24 + 40)) {
        float v26 = *(float *)(v24 + 48);
      }
      else {
        float v26 = -1.0;
      }
      if (*(unsigned char *)(v24 + 40)) {
        float v25 = -1.0;
      }
      float v27 = sqrtf((float)(v25 * v25) + (float)(v26 * v26));
      if (v27 == 0.0)
      {
LABEL_68:
        VNValidatedLog(4, @"%s: degenerate line", v19, a4, v21, v20, a7, a8, (uint64_t)"computePoints");
        return;
      }
      uint64_t v28 = v9 + 96 * v17;
      float32x2_t v29 = *(float32x2_t *)(v13 + 8 * *(int *)(v28 + 8));
      float v30 = 1.0 / v27;
      float v31 = v26 * v30;
      float v32 = v25 * v30;
      float v33 = vmlas_n_f32(vmuls_lane_f32(v32, v29, 1), v31, v29.f32[0]) + (float)(v30 * *(float *)(v28 + 44));
      *(float *)&uint64_t v34 = v29.f32[0] - (float)(v33 * v31);
      *((float *)&v34 + 1) = v29.f32[1] - (float)(v33 * v32);
      *(void *)(v28 + 16) = v34;
LABEL_66:
      uint64_t v9 = *((void *)this + 18);
      int64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 19) - v9) >> 5);
      v11 += 96;
    }
    while (v14 > (unint64_t)v15++);
  }
}

void apple::vision::libraries::autotrace::ContourToPath::findSubdividedCurves(apple::vision::libraries::autotrace::ContourToPath *this, __n128 a2)
{
  uint64_t v3 = *((void *)this + 18);
  uint64_t v2 = *((void *)this + 19);
  if (v2 != v3)
  {
    uint64_t v5 = 0;
    int v6 = 0;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v2 - v3) >> 5);
    do
    {
      if (*(_DWORD *)(v3 + 96 * v5))
      {
        apple::vision::libraries::autotrace::ContourToPath::makeCurve(this, v6, 0, a2);
        int v8 = v6 - v7;
        uint64_t v3 = *((void *)this + 18);
        uint64_t v2 = *((void *)this + 19);
        uint64_t v9 = (v2 - v3) >> 5;
        unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * v9;
        int v6 = v8 - 1431655765 * v9;
      }
      else
      {
        unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v2 - v3) >> 5);
      }
      uint64_t v5 = ++v6;
    }
    while (v7 > v6);
    if (v2 != v3)
    {
      unint64_t v10 = 0;
      do
      {
        if (*(_DWORD *)(v3 + 96 * v10))
        {
          unint64_t v11 = v10 + 1;
        }
        else
        {
          *(void *)(v3 + 96 * v10 + 32) = *(void *)(v3 + 96 * v10 + 16);
          unint64_t v11 = v10 + 1;
          uint64_t v12 = *((void *)this + 18);
          uint64_t v13 = *((void *)this + 19);
          int64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v12) >> 5);
          LODWORD(v15) = v10 + 1;
          uint64_t v16 = v10 + 1 - v14;
          if ((uint64_t)(v10 + 1) >= v14)
          {
            LODWORD(v15) = v10 + 1 - v14;
            if (v16 >= v14)
            {
              LODWORD(v15) = v10 + 1;
              if (v13 != v12) {
                uint64_t v15 = v16 % v14;
              }
            }
          }
          *(void *)(v12 + 96 * v10 + 72) = *(void *)(v12 + 96 * (int)v15 + 16);
          uint64_t v3 = *((void *)this + 18);
          uint64_t v2 = *((void *)this + 19);
        }
        unint64_t v10 = v11;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((v2 - v3) >> 5) > v11);
    }
  }
}

void apple::vision::libraries::autotrace::ContourToPath::convertToPaths(apple::vision::libraries::autotrace::ContourToPath *this)
{
  uint64_t v1 = *((void *)this + 18);
  if (*((void *)this + 19) != v1)
  {
    long long v3 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
    long long v4 = *MEMORY[0x1E4F1DAB8];
    *(_OWORD *)&v16.c = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *(_OWORD *)&v16.tdouble x = v3;
    *(_OWORD *)&v16.a = v4;
    CGPathMoveToPoint(*((CGMutablePathRef *)this + 2), &v16, COERCE_FLOAT(*(void *)(v1 + 16)), COERCE_FLOAT(HIDWORD(*(void *)(v1 + 16))));
    uint64_t v5 = *((void *)this + 18);
    uint64_t v6 = *((void *)this + 19) - v5;
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      int64_t v9 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 5);
      uint64_t v10 = 1;
      do
      {
        LODWORD(v11) = ++v8;
        if (v9 <= v10)
        {
          uint64_t v11 = v10 - v9;
          if (v10 - v9 >= v9) {
            v11 %= v9;
          }
        }
        int v12 = v11;
        int v13 = *(_DWORD *)(v5 + v7);
        if (v13 == 1)
        {
          CGPathAddCurveToPoint(*((CGMutablePathRef *)this + 2), &v16, COERCE_FLOAT(*(void *)(v5 + v7 + 32)), COERCE_FLOAT(HIDWORD(*(void *)(v5 + v7 + 32))), COERCE_FLOAT(*(void *)(v5 + v7 + 72)), COERCE_FLOAT(HIDWORD(*(void *)(v5 + v7 + 72))), COERCE_FLOAT(*(void *)(v5 + 96 * v12 + 16)), COERCE_FLOAT(HIDWORD(*(void *)(v5 + 96 * v12 + 16))));
        }
        else if (!v13)
        {
          CGPathAddLineToPoint(*((CGMutablePathRef *)this + 2), &v16, COERCE_FLOAT(*(void *)(v5 + 96 * v12 + 16)), COERCE_FLOAT(HIDWORD(*(void *)(v5 + 96 * v12 + 16))));
        }
        uint64_t v5 = *((void *)this + 18);
        int64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 19) - v5) >> 5);
        v7 += 96;
        BOOL v14 = v9 >= (unint64_t)v10;
        BOOL v15 = v9 == v10++;
      }
      while (!v15 && v14);
    }
    CGPathCloseSubpath(*((CGMutablePathRef *)this + 2));
  }
}

void apple::vision::libraries::autotrace::ContourToPath::makeCurve(apple::vision::libraries::autotrace::ContourToPath *this, int a2, int a3, __n128 a4)
{
  int v4 = a3;
  int v5 = a2;
  uint64_t v7 = a2;
  uint64_t v8 = a2 + 1;
  uint64_t v10 = *((void *)this + 18);
  uint64_t v9 = *((void *)this + 19);
  int64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v10) >> 5);
  uint64_t v12 = v8 - v11;
  if (v8 >= v11)
  {
    _ZF = v9 == v10;
    uint64_t v13 = v12 % v11;
    if (_ZF) {
      LODWORD(v13) = a2 + 1;
    }
    if (v12 >= v11) {
      LODWORD(v12) = v13;
    }
  }
  else
  {
    LODWORD(v12) = a2 + 1;
    if (a2 <= -2)
    {
      uint64_t v12 = v11 + v8;
      if (v11 + v8 < 0)
      {
        if (v9 == v10) {
          LODWORD(v12) = a2 + 1;
        }
        else {
          LODWORD(v12) = v12 % (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v9 - v10) >> 5)) - 1431655765 * ((v9 - v10) >> 5);
        }
      }
    }
  }
  BOOL v14 = (void *)(v10 + 96 * a2);
  float32x2_t v15 = (float32x2_t)v14[3];
  float32x2_t v16 = (float32x2_t)v14[8];
  float v17 = v15.f32[1];
  float v18 = v16.f32[1];
  float v19 = vmlas_n_f32((float)-v15.f32[1] * v16.f32[0], v16.f32[1], v15.f32[0]);
  if (v19 == 0.0)
  {
    *(_DWORD *)(v10 + 96 * a2) = 0;
    return;
  }
  int v215 = a2 + 1;
  uint64_t v20 = (int *)*((void *)this + 3);
  uint64_t v21 = *((void *)v20 + 1);
  uint64_t v22 = *v20;
  uint64_t v23 = (float32x2_t *)(v10 + 96 * (int)v12);
  uint64_t v24 = v10 + 96 * a2;
  int v25 = *(_DWORD *)(v24 + 8);
  long long v212 = (int *)(v24 + 8);
  int v26 = *(_DWORD *)(v24 + 56);
  uint64_t v216 = (_DWORD *)(v24 + 56);
  uint64_t v217 = v20;
  if (v25 + 1 >= (int)v22) {
    int v27 = *v20;
  }
  else {
    int v27 = 0;
  }
  int v28 = v25 + 1 - v27;
  float v29 = 0.0;
  if (v28 != v26)
  {
    uint64_t v30 = *((void *)this + 6);
    float v31 = *(float *)(v30 + 4 * v25);
    do
    {
      float v32 = *(float *)(v30 + 4 * v28);
      float v29 = v29 + (float)((float)(v32 - v31) - rintf(v32 - v31));
      int v33 = v28 + 1;
      if (v33 >= (int)v22) {
        int v34 = v22;
      }
      else {
        int v34 = 0;
      }
      int v28 = v33 - v34;
      float v31 = v32;
    }
    while (v28 != v26);
  }
  float32x2_t v35 = (float32x2_t)v14[2];
  float32x2_t v36 = v23[2];
  BOOL v247 = 0;
  uint64_t v37 = v10 + 96 * a2;
  int v40 = *(_DWORD *)(v37 + 92);
  float v38 = (int *)(v37 + 92);
  int v39 = v40;
  if (fabsf(v29) > 0.25 && a3 <= 19 && v39 >= 2) {
    goto LABEL_108;
  }
  long long v211 = v38;
  uint64_t v218 = a2;
  float32x2_t v43 = vsub_f32(v36, v35);
  float v44 = v36.f32[1] - v35.f32[1];
  if (v39 / 4 <= 1) {
    int v45 = 1;
  }
  else {
    int v45 = v39 / 4;
  }
  int v220 = v39;
  if (3 * v39 / 4 >= v39) {
    int v46 = v39 - 1;
  }
  else {
    int v46 = 3 * v39 / 4;
  }
  if (v45 >= v46)
  {
    float32x2_t v234 = vneg_f32(v16);
    uint64_t v7 = a2;
    int v39 = v220;
    goto LABEL_76;
  }
  float v209 = v36.f32[1] - v35.f32[1];
  float v226 = (float)(v35.f32[1] + v36.f32[1]) * 0.5;
  float v227 = 0.5 * vadd_f32(v35, v36).f32[0];
  float32x2_t v234 = vneg_f32(v16);
  __asm { FMOV            V14.2S, #0.25 }
  float32x2_t v222 = vmla_f32(v35, _D14, v43);
  __asm { FMOV            V10.2S, #0.75 }
  float32x2_t v210 = v43;
  float32x2_t v223 = vmla_f32(v35, _D10, v43);
  int v51 = -1;
  float v225 = 0.0;
  float v238 = 1000000.0;
  __asm
  {
    FMOV            V11.2S, #-3.0
    FMOV            V13.2S, #3.0
  }
  float v54 = 1.0 / v19;
  float v224 = 0.0;
  __int32 v230 = v16.i32[0];
  float32x2_t v231 = v15;
  float v228 = v16.f32[1];
  float v229 = v15.f32[1];
  float32x2_t v235 = v35;
  float32x2_t v232 = v36;
  do
  {
    int v55 = v25 + v45;
    uint64_t v56 = v25 + v45;
    if (v25 + v45 >= (int)v22)
    {
      uint64_t v58 = v55 - v22;
      if (v56 - v22 >= v22)
      {
        _ZF = v22 == 0;
      }
      else
      {
        LODWORD(v56) = v56 - v22;
        _ZF = 1;
      }
      if (!_ZF) {
        uint64_t v56 = v58 % v22;
      }
    }
    else if ((v56 & 0x80000000) != 0)
    {
      uint64_t v57 = v55 + v22;
      if (v56 + v22 < 0 == __OFADD__(v56, v22)) {
        LODWORD(v56) = v56 + v22;
      }
      if (v57 < 0 && v22) {
        uint64_t v56 = v57 % v22 + v22;
      }
    }
    float v60 = (float)(COERCE_FLOAT(*(void *)(v21 + 8 * (int)v56)) - v227) * 2.6667;
    float v61 = (float)(COERCE_FLOAT(HIDWORD(*(void *)(v21 + 8 * (int)v56))) - v226) * -2.6667;
    float v62 = v54 * (float)((float)(v16.f32[0] * v61) + (float)(v60 * v18));
    float v63 = v54 * (float)((float)(v15.f32[0] * v61) + (float)(v60 * v17));
    float32x2_t v64 = vmla_n_f32(v35, v15, v62);
    float32x2_t v65 = vmla_n_f32(v36, v234, v63);
    int32x2_t v66 = vceq_f32(v35, v64);
    int8x8_t v67 = (int8x8_t)vceq_f32(v65, v36);
    float v240 = v63;
    float v242 = v62;
    if (v66.i8[0])
    {
      float32x2_t v68 = (float32x2_t)__PAIR64__(v64.u32[1], v65.u32[0]);
      if (vand_s8((int8x8_t)vdup_lane_s32(v66, 1), v67).u8[0])
      {
        float32x2_t v69 = v222;
        if (v67.i8[4]) {
          goto LABEL_57;
        }
      }
    }
    else
    {
      float32x2_t v68 = (float32x2_t)__PAIR64__(v64.u32[1], v65.u32[0]);
    }
    float32x2_t v70 = (float32x2_t)__PAIR64__(v68.u32[1], v64.u32[0]);
    v68.i32[1] = v65.i32[1];
    float32x2_t v69 = vmla_f32(v35, _D14, vmla_f32(vmul_f32(vmla_f32(vmul_f32(vsub_f32(vmla_f32(v36, _D11, vsub_f32(v68, v70)), v35), _D14), _D13, vadd_f32(vmla_f32(v35, (float32x2_t)0xC0000000C0000000, v70), v68)), _D14), _D13, vsub_f32(v70, v35)));
    if ((v66.i8[0] & 1) == 0)
    {
      float32x2_t v72 = (float32x2_t)__PAIR64__(v64.u32[1], v65.u32[0]);
LABEL_61:
      v64.i32[1] = v72.i32[1];
      v72.i32[1] = v65.i32[1];
      float32x2_t v73 = vmla_f32(v35, _D10, vmla_f32(vmul_f32(vmla_f32(vmul_f32(vsub_f32(vmla_f32(v36, _D11, vsub_f32(v72, v64)), v35), _D10), _D13, vadd_f32(vmla_f32(v35, (float32x2_t)0xC0000000C0000000, v64), v72)), _D10), _D13, vsub_f32(v64, v35)));
      goto LABEL_62;
    }
LABEL_57:
    unsigned __int8 v71 = vand_s8((int8x8_t)vdup_lane_s32(v66, 1), v67).u8[0];
    float32x2_t v72 = (float32x2_t)__PAIR64__(v64.u32[1], v65.u32[0]);
    if ((v71 & 1) == 0) {
      goto LABEL_61;
    }
    float32x2_t v73 = v223;
    if ((v67.i8[4] & 1) == 0) {
      goto LABEL_61;
    }
LABEL_62:
    float v74 = apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v25, v56, v69);
    a4.n128_f32[0] = v74
                   + apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v56, v26, v73);
    if (a4.n128_f32[0] >= v238)
    {
      float32x2_t v35 = v235;
      float32x2_t v15 = v231;
      float32x2_t v36 = v232;
      v16.i32[0] = v230;
LABEL_68:
      float v18 = v228;
      float v17 = v229;
      goto LABEL_69;
    }
    v16.i32[0] = v230;
    if (v242 < 0.0)
    {
      float32x2_t v35 = v235;
      float32x2_t v15 = v231;
      float32x2_t v36 = v232;
      goto LABEL_68;
    }
    float32x2_t v35 = v235;
    float32x2_t v15 = v231;
    float32x2_t v36 = v232;
    float v18 = v228;
    float v17 = v229;
    if (v240 >= 0.0)
    {
      int v51 = v56;
      float v238 = a4.n128_f32[0];
      float v224 = v242;
      float v225 = v240;
    }
LABEL_69:
    ++v45;
  }
  while (v46 != v45);
  if (v51 == -1)
  {
    int v5 = a2;
    uint64_t v7 = v218;
    int v4 = a3;
    int v39 = v220;
    float32x2_t v43 = v210;
    float v44 = v209;
    goto LABEL_76;
  }
  uint64_t v7 = v218;
  int v4 = a3;
  int v39 = v220;
  float32x2_t v43 = v210;
  float v44 = v209;
  if (v29 >= 3.0)
  {
    int v5 = a2;
    float v76 = v224;
    float v75 = v225;
  }
  else
  {
    int v5 = a2;
    float v76 = v224;
    float v75 = v225;
    if (v220 > 19) {
      goto LABEL_77;
    }
LABEL_76:
    float v76 = sqrtf((float)(v44 * v44) + (float)(v43.f32[0] * v43.f32[0])) / 3.0;
    float v75 = v76;
  }
LABEL_77:
  if (v4 > 19
    || (float v77 = sqrtf((float)(v44 * v44) + (float)(v43.f32[0] * v43.f32[0])),
        float v78 = 1.0 / fmaxf(v77, 0.001),
        (float)((float)((float)((float)(v18 * (float)(v44 * v78)) + (float)(v16.f32[0] * (float)(v43.f32[0] * v78)))
                      * v75)
              + (float)(v76
                      * (float)((float)(v17 * (float)(v44 * v78)) + (float)(v15.f32[0] * (float)(v43.f32[0] * v78))))) <= v77))
  {
    uint64_t v246 = 0;
    a4.n128_u64[0] = 0;
    float32x2_t v236 = vmla_n_f32(v35, v15, v76);
    float32x2_t v233 = vmla_n_f32(v36, v234, v75);
    apple::vision::libraries::autotrace::ContourToPath::goodnessOfFit(v217, v25, v39, (float *)&v246 + 1, (float *)&v246, a4, 0.0, v236, v233);
    if (*((float *)&v246 + 1) > *((float *)this + 1) && v4 <= 19 && *(float *)&v246 > *((float *)this + 2))
    {
      int v39 = *v211;
      int v25 = *v212;
      goto LABEL_108;
    }
    float v90 = (float32x2_t *)(v10 + 96 * (int)v7);
    v90[4] = v236;
    float32x2_t v91 = v233;
    goto LABEL_125;
  }
  if (v39 > 29) {
    goto LABEL_108;
  }
  float v79 = v77 / 3.0;
  float32x2_t v80 = vmla_n_f32(v35, v15, v79);
  float32x2_t v81 = vmla_n_f32(v36, v234, v79);
  int32x2_t v82 = vceq_f32(v35, v80);
  __asm
  {
    FMOV            V2.2S, #-3.0
    FMOV            V1.2S, #3.0
  }
  float32x2_t v239 = v81;
  float32x2_t v241 = v80;
  if ((v82.i8[0] & 1) == 0)
  {
    float32x2_t v86 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
    float32x2_t v87 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
LABEL_90:
    float32x2_t v92 = (float32x2_t)__PAIR64__(v87.u32[1], v80.u32[0]);
    float32x2_t v93 = (float32x2_t)__PAIR64__(v86.u32[1], v35.u32[0]);
    float32x2_t v94 = vsub_f32((float32x2_t)__PAIR64__(v87.u32[1], v80.u32[0]), (float32x2_t)__PAIR64__(v86.u32[1], v35.u32[0]));
    float32x2_t v95 = vmla_f32((float32x2_t)__PAIR64__(v86.u32[1], v35.u32[0]), (float32x2_t)0xC0000000C0000000, (float32x2_t)__PAIR64__(v87.u32[1], v80.u32[0]));
    v87.i32[1] = v81.i32[1];
    v86.i32[1] = v36.i32[1];
    float32x2_t v96 = vsub_f32(vmla_f32(v86, _D2, vsub_f32(v87, v92)), v93);
    __asm { FMOV            V6.2S, #0.25 }
    float32x2_t v89 = vmla_f32(v93, _D6, vmla_f32(vmul_f32(vmla_f32(vmul_f32(v96, _D6), _D1, vadd_f32(v95, v87)), _D6), _D1, v94));
    if (v82.i8[0]) {
      goto LABEL_91;
    }
    float32x2_t v99 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
    float32x2_t v100 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
    goto LABEL_95;
  }
  int8x8_t v85 = (int8x8_t)vceq_f32(v81, v36);
  float32x2_t v86 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
  float32x2_t v87 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
  if ((vand_s8((int8x8_t)vdup_lane_s32(v82, 1), v85).u32[0] & 1) == 0 || (v85.i8[4] & 1) == 0) {
    goto LABEL_90;
  }
  __asm { FMOV            V4.2S, #0.25 }
  float32x2_t v89 = vmla_f32(v35, _D4, v43);
LABEL_91:
  int8x8_t v98 = (int8x8_t)vceq_f32(v81, v36);
  float32x2_t v99 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
  float32x2_t v100 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
  if ((vand_s8((int8x8_t)vdup_lane_s32(v82, 1), v98).u32[0] & 1) == 0 || (v98.i8[4] & 1) == 0)
  {
LABEL_95:
    float32x2_t v102 = (float32x2_t)__PAIR64__(v100.u32[1], v80.u32[0]);
    float32x2_t v103 = (float32x2_t)__PAIR64__(v99.u32[1], v35.u32[0]);
    float32x2_t v104 = vmla_f32((float32x2_t)__PAIR64__(v99.u32[1], v35.u32[0]), (float32x2_t)0xC0000000C0000000, (float32x2_t)__PAIR64__(v100.u32[1], v80.u32[0]));
    v100.i32[1] = v81.i32[1];
    v99.i32[1] = v36.i32[1];
    float32x2_t v101 = vmla_f32(v103, (float32x2_t)0x3F0000003F000000, vmla_f32(vmul_f32(vmla_f32(vmul_f32(vsub_f32(vmla_f32(v99, _D2, vsub_f32(v100, v102)), v103), (float32x2_t)0x3F0000003F000000), _D1, vadd_f32(v104, v100)), (float32x2_t)0x3F0000003F000000), _D1, vsub_f32(v102, v103)));
    if (v82.i8[0]) {
      goto LABEL_96;
    }
    float32x2_t v243 = v101;
    float32x2_t v106 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
    float32x2_t v107 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
    goto LABEL_100;
  }
  float32x2_t v101 = vmla_f32(v35, (float32x2_t)0x3F0000003F000000, v43);
LABEL_96:
  int8x8_t v105 = (int8x8_t)vceq_f32(v81, v36);
  float32x2_t v106 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
  float32x2_t v107 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
  float32x2_t v243 = v101;
  if (vand_s8((int8x8_t)vdup_lane_s32(v82, 1), v105).u32[0] & 1) != 0 && (v105.i8[4])
  {
    __asm { FMOV            V1.2S, #0.75 }
    float32x2_t v109 = vmla_f32(v35, _D1, v43);
    goto LABEL_101;
  }
LABEL_100:
  float32x2_t v110 = (float32x2_t)__PAIR64__(v107.u32[1], v80.u32[0]);
  v35.i32[1] = v106.i32[1];
  v107.i32[1] = v81.i32[1];
  v106.i32[1] = v36.i32[1];
  __asm { FMOV            V3.2S, #0.75 }
  float32x2_t v109 = vmla_f32(v35, _D3, vmla_f32(vmul_f32(vmla_f32(vmul_f32(vsub_f32(vmla_f32(v106, _D2, vsub_f32(v107, v110)), v35), _D3), _D1, vadd_f32(vmla_f32(v35, (float32x2_t)0xC0000000C0000000, v110), v107)), _D3), _D1, vsub_f32(v110, v35)));
LABEL_101:
  float32x2_t v237 = v109;
  float v112 = apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v25, v26, v89);
  float v113 = apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v25, v26, v243);
  float v114 = apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v25, v26, v237);
  float v115 = *((float *)this + 2) * *((float *)this + 2);
  if (v112 < v115 && v113 < v115 && v114 < v115)
  {
    float v90 = (float32x2_t *)(v10 + 96 * (int)v7);
    v90[4] = v241;
    float32x2_t v91 = v239;
LABEL_125:
    v90[9] = v91;
    return;
  }
LABEL_108:
  if (v39 >= 0) {
    int v118 = v39;
  }
  else {
    int v118 = v39 + 1;
  }
  int v119 = v25 + (v118 >> 1);
  uint64_t v120 = v119;
  if (v119 >= (int)v22)
  {
    uint64_t v122 = v119 - v22;
    LODWORD(v121) = v120 - v22;
    if (v120 - v22 >= v22)
    {
      LODWORD(v121) = v120;
      if (v22) {
        uint64_t v121 = v122 % v22;
      }
    }
  }
  else if (v119 < 0)
  {
    uint64_t v123 = v119 + v22;
    LODWORD(v121) = v120 + v22;
    if (v120 + v22 < 0)
    {
      LODWORD(v121) = v120;
      if (v22) {
        uint64_t v121 = v123 % v22 + v22;
      }
    }
  }
  else
  {
    LODWORD(v121) = v25 + (v118 >> 1);
  }
  if (v25 != v121 && *v216 != v121)
  {
    int v214 = v5;
    float v124 = (_OWORD *)*((void *)this + 19);
    unint64_t v125 = *((void *)this + 20);
    if ((unint64_t)v124 < v125)
    {
      v124[4] = 0u;
      v124[5] = 0u;
      v124[2] = 0u;
      v124[3] = 0u;
      *float v124 = 0u;
      v124[1] = 0u;
      unint64_t v126 = (unint64_t)(v124 + 6);
      goto LABEL_141;
    }
    uint64_t v127 = *((void *)this + 18);
    unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v124 - v127) >> 5);
    unint64_t v129 = v128 + 1;
    if (v128 + 1 > 0x2AAAAAAAAAAAAAALL) {
      goto LABEL_200;
    }
    unint64_t v130 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v125 - v127) >> 5);
    if (2 * v130 > v129) {
      unint64_t v129 = 2 * v130;
    }
    if (v130 >= 0x155555555555555) {
      unint64_t v131 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v131 = v129;
    }
    if (v131) {
      unint64_t v131 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(v131);
    }
    else {
      uint64_t v132 = 0;
    }
    uint64_t v133 = (_OWORD *)(v131 + 96 * v128);
    unint64_t v134 = v131 + 96 * v132;
    v133[4] = 0u;
    v133[5] = 0u;
    v133[2] = 0u;
    v133[3] = 0u;
    *uint64_t v133 = 0u;
    v133[1] = 0u;
    unint64_t v126 = (unint64_t)(v133 + 6);
    float v136 = (char *)*((void *)this + 18);
    float32x2_t v135 = (char *)*((void *)this + 19);
    if (v135 != v136)
    {
      do
      {
        long long v137 = *((_OWORD *)v135 - 5);
        *(v133 - 6) = *((_OWORD *)v135 - 6);
        *(v133 - 5) = v137;
        long long v138 = *((_OWORD *)v135 - 4);
        long long v139 = *((_OWORD *)v135 - 3);
        long long v140 = *((_OWORD *)v135 - 1);
        *(v133 - 2) = *((_OWORD *)v135 - 2);
        *(v133 - 1) = v140;
        *(v133 - 4) = v138;
        *(v133 - 3) = v139;
        v133 -= 6;
        v135 -= 96;
      }
      while (v135 != v136);
      float32x2_t v135 = (char *)*((void *)this + 18);
    }
    *((void *)this + 18) = v133;
    *((void *)this + 19) = v126;
    *((void *)this + 20) = v134;
    if (v135) {
      operator delete(v135);
    }
LABEL_141:
    *((void *)this + 19) = v126;
    uint64_t v141 = *((void *)this + 18);
    __float2 v142 = (char *)(v141 + 96 * (int)v7);
    unint64_t v143 = *((void *)this + 20);
    if (v126 < v143)
    {
      if (v142 == (char *)v126)
      {
        *((void *)this + 19) = v126 + 96;
      }
      else
      {
        uint64_t v144 = v142 + 96;
        uint64_t v145 = (_OWORD *)(v126 - 96);
        float32x2_t v146 = (char *)v126;
        if (v126 >= 0x60)
        {
          float32x2_t v146 = (char *)v126;
          do
          {
            long long v147 = v145[1];
            *(_OWORD *)float32x2_t v146 = *v145;
            *((_OWORD *)v146 + 1) = v147;
            long long v148 = v145[2];
            long long v149 = v145[3];
            long long v150 = v145[5];
            *((_OWORD *)v146 + 4) = v145[4];
            *((_OWORD *)v146 + 5) = v150;
            *((_OWORD *)v146 + 2) = v148;
            *((_OWORD *)v146 + 3) = v149;
            v145 += 6;
            v146 += 96;
          }
          while ((unint64_t)v145 < v126);
        }
        *((void *)this + 19) = v146;
        if ((_OWORD *)v126 != v144)
        {
          memmove(v142 + 96, v142, v126 - (void)v144);
          float32x2_t v146 = (char *)*((void *)this + 19);
        }
        float v151 = &v142[96 * (v146 > v142)];
        long long v152 = *((_OWORD *)v151 + 1);
        *(_OWORD *)__float2 v142 = *(_OWORD *)v151;
        *((_OWORD *)v142 + 1) = v152;
        long long v153 = *((_OWORD *)v151 + 2);
        long long v154 = *((_OWORD *)v151 + 3);
        long long v155 = *((_OWORD *)v151 + 5);
        *((_OWORD *)v142 + 4) = *((_OWORD *)v151 + 4);
        *((_OWORD *)v142 + 5) = v155;
        *((_OWORD *)v142 + 2) = v153;
        *((_OWORD *)v142 + 3) = v154;
      }
      goto LABEL_177;
    }
    unint64_t v156 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v126 - v141) >> 5) + 1;
    if (v156 > 0x2AAAAAAAAAAAAAALL) {
LABEL_200:
    }
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    unint64_t v157 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v143 - v141) >> 5);
    uint64_t v158 = 2 * v157;
    if (2 * v157 <= v156) {
      uint64_t v158 = v156;
    }
    if (v157 >= 0x155555555555555) {
      unint64_t v159 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v159 = v158;
    }
    if (v159)
    {
      float v161 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(v159);
    }
    else
    {
      float v161 = 0;
      uint64_t v160 = 0;
    }
    float v162 = &v161[96 * (int)v7];
    float v163 = &v161[96 * v160];
    int v221 = v39;
    if (v160 != v7) {
      goto LABEL_169;
    }
    if (v214 >= 1)
    {
      uint64_t v164 = v7 + 2;
      int v165 = v7;
      if (v7 >= -1) {
        uint64_t v164 = v7 + 1;
      }
      v162 -= 96 * (v164 >> 1);
      goto LABEL_170;
    }
    unint64_t v166 = v214 ? 2 * v7 : 1;
    float v167 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(v166);
    float v162 = &v167[96 * (v166 >> 2)];
    float v163 = &v167[96 * v168];
    if (v161)
    {
      int v165 = v7;
      unint64_t v169 = v161;
      BOOL v170 = v163;
      operator delete(v169);
      float v163 = v170;
    }
    else
    {
LABEL_169:
      int v165 = v7;
    }
LABEL_170:
    long long v171 = *((_OWORD *)v142 + 1);
    *(_OWORD *)float v162 = *(_OWORD *)v142;
    *((_OWORD *)v162 + 1) = v171;
    long long v172 = *((_OWORD *)v142 + 2);
    long long v173 = *((_OWORD *)v142 + 3);
    long long v174 = *((_OWORD *)v142 + 5);
    *((_OWORD *)v162 + 4) = *((_OWORD *)v142 + 4);
    *((_OWORD *)v162 + 5) = v174;
    *((_OWORD *)v162 + 2) = v172;
    *((_OWORD *)v162 + 3) = v173;
    uint64_t v175 = (char *)*((void *)this + 18);
    uint64_t v7 = (uint64_t)v162;
    if (v175 != v142)
    {
      unint64_t v176 = v142;
      long long v177 = v162;
      do
      {
        long long v178 = *((_OWORD *)v176 - 5);
        *((_OWORD *)v177 - 6) = *((_OWORD *)v176 - 6);
        *((_OWORD *)v177 - 5) = v178;
        long long v179 = *((_OWORD *)v176 - 4);
        long long v180 = *((_OWORD *)v176 - 3);
        long long v181 = *((_OWORD *)v176 - 1);
        uint64_t v7 = (uint64_t)(v177 - 96);
        *((_OWORD *)v177 - 2) = *((_OWORD *)v176 - 2);
        *((_OWORD *)v177 - 1) = v181;
        *((_OWORD *)v177 - 4) = v179;
        *((_OWORD *)v177 - 3) = v180;
        v176 -= 96;
        v177 -= 96;
      }
      while (v176 != v175);
    }
    uint64_t v182 = v162 + 96;
    uint64_t v183 = (char *)*((void *)this + 19);
    int64_t v184 = v183 - v142;
    if (v183 != v142)
    {
      float v185 = v142;
      size_t v186 = v183 - v142;
      long long v187 = v163;
      memmove(v182, v185, v186);
      float v163 = v187;
    }
    float v188 = (void *)*((void *)this + 18);
    *((void *)this + 18) = v7;
    *((void *)this + 19) = &v182[v184];
    *((void *)this + 20) = v163;
    LODWORD(v7) = v165;
    int v39 = v221;
    if (v188) {
      operator delete(v188);
    }
LABEL_177:
    int v189 = v118 >> 1;
    int v190 = v39 - (v118 >> 1);
    uint64_t v191 = *((void *)this + 18);
    uint64_t v192 = v191 + 96 * (int)v7;
    *(_DWORD *)(v192 + 52) = -1;
    *(_DWORD *)(v192 + 56) = v121;
    *(_DWORD *)(v192 + 92) = v189;
    *(_DWORD *)(v192 + 100) = -1;
    *(_DWORD *)(v192 + 104) = v121;
    *(void *)(v192 + 112) = *(void *)(v21 + 8 * (int)v121);
    *(_DWORD *)(v192 + 188) = v190;
    if (v189 >= 6) {
      int v189 = 6;
    }
    int v193 = v121 - v189;
    uint64_t v194 = (int)v121 - v189;
    if (v193 >= (int)v22)
    {
      uint64_t v196 = v193 - v22;
      LODWORD(v195) = v194 - v22;
      if (v194 - v22 >= v22)
      {
        LODWORD(v195) = v194;
        if (v22) {
          uint64_t v195 = v196 % v22;
        }
      }
    }
    else if ((v194 & 0x80000000) != 0)
    {
      uint64_t v197 = v193 + v22;
      LODWORD(v195) = v194 + v22;
      if (v194 + v22 < 0)
      {
        LODWORD(v195) = v194;
        if (v22) {
          uint64_t v195 = v197 % v22 + v22;
        }
      }
    }
    else
    {
      LODWORD(v195) = v193;
    }
    if (v190 >= 7) {
      int v190 = 7;
    }
    LODWORD(v198) = v190 + v121;
    uint64_t v199 = (int)v198;
    if ((int)v198 >= (int)v22)
    {
      LODWORD(v198) = v198 - v22;
      if (v199 - v22 >= v22)
      {
        LODWORD(v198) = v199;
        if (v22) {
          uint64_t v198 = (v199 - v22) % v22;
        }
      }
    }
    else if ((v198 & 0x80000000) != 0)
    {
      LODWORD(v198) = v198 + v22;
      if (v199 + v22 < 0)
      {
        LODWORD(v198) = v199;
        if (v22) {
          uint64_t v198 = (v199 + v22) % v22 + v22;
        }
      }
    }
    uint64_t v245 = 0;
    int v200 = (v22 & (((int)v198 - (int)v195) >> 31)) + v198 - v195;
    uint64_t v201 = (apple::vision::libraries::autotrace::ATRRecord *)apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v244, *((const EPolygon **)this + 3), v195, v200);
    apple::vision::libraries::autotrace::ATRRecord::LinearRegression(v201, &v247, (float *)&v245 + 1, (float *)&v245);
    BOOL v202 = v247;
    int v203 = v245;
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((void *)this + 3) + 8), v195, v200, v247, *(float *)&v245, v204);
    __float2 v206 = __sincosf_stret(v205 * 6.2832);
    *(void *)(v192 + 120) = __PAIR64__(LODWORD(v206.__sinval), LODWORD(v206.__cosval));
    *(unsigned char *)(v192 + 136) = v202;
    int v207 = HIDWORD(v245);
    *(_DWORD *)(v192 + 140) = HIDWORD(v245);
    *(_DWORD *)(v192 + 144) = v203;
    uint64_t v208 = v191 + 96 * (int)v7;
    *(void *)(v208 + 64) = __PAIR64__(LODWORD(v206.__sinval), LODWORD(v206.__cosval));
    *(unsigned char *)(v208 + 80) = v202;
    *(_DWORD *)(v208 + 84) = v207;
    *(_DWORD *)(v208 + 88) = v203;
    apple::vision::libraries::autotrace::ContourToPath::makeCurve(this, v215, a3 + 1);
    apple::vision::libraries::autotrace::ContourToPath::makeCurve(this, v214, a3 + 1);
  }
}

void sub_1A3FF13D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(unint64_t a1)
{
  if (a1 >= 0x2AAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(96 * a1);
}

float apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(int a1, uint64_t a2, int a3, int a4, float32x2_t a5)
{
  int v5 = a3 + 1;
  float32x2_t v6 = vsub_f32(a5, *(float32x2_t *)(a2 + 8 * a3));
  float v7 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v6, v6).i32[1]), v6.f32[0], v6.f32[0]);
  while (1)
  {
    int v8 = v5 >= a1 ? a1 : 0;
    int v9 = v5 - v8;
    if (v9 == a4) {
      break;
    }
    float32x2_t v10 = vsub_f32(a5, *(float32x2_t *)(a2 + 8 * v9));
    float v11 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v10, v10).i32[1]), v10.f32[0], v10.f32[0]);
    if (v11 < v7) {
      float v7 = v11;
    }
    int v5 = v9 + 1;
  }
  return v7;
}

void apple::vision::libraries::autotrace::ContourToPath::goodnessOfFit(int *a1, int a2, int a3, float *a4, float *a5, __n128 a6, float a7, float32x2_t a8, float32x2_t a9)
{
  uint64_t v14 = *((void *)a1 + 1);
  uint64_t v15 = *a1;
  LODWORD(v16) = a3 + a2;
  uint64_t v17 = a3 + a2;
  if (a3 + a2 >= (int)v15)
  {
    uint64_t v18 = (int)v16 - v15;
    LODWORD(v16) = v16 - v15;
    if (v17 - v15 >= v15)
    {
      LODWORD(v16) = a3 + a2;
      if (v15) {
        uint64_t v16 = v18 % v15;
      }
    }
  }
  else if ((v17 & 0x80000000) != 0)
  {
    uint64_t v19 = v15 + (int)v16;
    LODWORD(v16) = v15 + v16;
    if (v15 + v17 < 0)
    {
      LODWORD(v16) = a3 + a2;
      if (v15) {
        uint64_t v16 = v19 % v15 + v15;
      }
    }
  }
  float32x2_t v20 = *(float32x2_t *)(v14 + 8 * a2);
  float32x2_t v21 = *(float32x2_t *)(v14 + 8 * (int)v16);
  if (a3 < 3) {
    goto LABEL_25;
  }
  float32x2_t v22 = vsub_f32(a8, v20);
  float32x2_t v23 = vsub_f32(v21, a9);
  __asm { FMOV            V6.2S, #3.0 }
  float32x2_t v29 = vmul_f32(vadd_f32(vmla_f32(v20, _D6, vadd_f32(a8, a9)), v21), (float32x2_t)0x3E0000003E000000);
  float32x2_t v30 = vsub_f32(vadd_f32(v23, a8), v20);
  __asm { FMOV            V4.2S, #0.25 }
  int v32 = a2 + 1 >= (int)v15 ? *a1 : 0;
  int v33 = a2 + 1 - v32;
  _D6 = *(float32x2_t *)(v14 + 8 * v33);
  float32x2_t v35 = vmul_f32(v30, _D4);
  int v36 = a3 - 2;
  int v37 = -1;
  float v38 = 1.0e12;
  do
  {
    if (v33 + 1 >= (int)v15) {
      int v39 = *a1;
    }
    else {
      int v39 = 0;
    }
    int v40 = v33 + 1 - v39;
    LODWORD(_S17) = HIDWORD(*(void *)(v14 + 8 * v40));
    LODWORD(v42) = vsub_f32(*(float32x2_t *)(v14 + 8 * v40), _D6).u32[0];
    float v43 = vmlas_n_f32((float)(_S17 - _D6.f32[1]) * (float)(_S17 - _D6.f32[1]), v42, v42);
    __asm { FMLS            S18, S17, V6.S[0] }
    float v45 = fabsf(_S18) / sqrtf(v43);
    _D6.i32[0] = vsub_f32(v29, _D6).u32[0];
    _D6.f32[0] = sqrtf(vmlas_n_f32((float)(v29.f32[1] - _D6.f32[1]) * (float)(v29.f32[1] - _D6.f32[1]), _D6.f32[0], _D6.f32[0]));
    if (!_ZF) {
      _D6.f32[0] = v45;
    }
    if (_D6.f32[0] < v38)
    {
      int v37 = v33;
      float v38 = _D6.f32[0];
    }
    _D6 = *(float32x2_t *)(v14 + 8 * v40);
    int v33 = v33 + 1 - v39;
    --v36;
  }
  while (v36);
  if (v37 == -1)
  {
LABEL_25:
    float32x2_t v50 = vsub_f32(v21, v20);
    float v48 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v50, v50).i32[1]), v50.f32[0], v50.f32[0]));
    float v49 = fmaxf(a6.n128_f32[0], a7);
  }
  else
  {
    double v51 = COERCE_DOUBLE(vmla_f32(v29, (float32x2_t)0x3F0000003F000000, v35));
    double v46 = COERCE_DOUBLE(vmla_f32(v21, (float32x2_t)0xBF000000BF000000, v23));
    __n128 v47 = apple::vision::libraries::autotrace::ContourToPath::goodnessOfFit(a1, a6, v38, COERCE_DOUBLE(vmla_f32(v20, (float32x2_t)0x3F0000003F000000, v22)), COERCE_DOUBLE(vmla_f32(v29, (float32x2_t)0xBF000000BF000000, v35)));
    v47.n128_f32[0] = v38;
    apple::vision::libraries::autotrace::ContourToPath::goodnessOfFit(a1, v47, a7, v51, v46);
    float v48 = 0.0 + 0.0;
    float v49 = fmaxf(0.0, 0.0);
  }
  *a4 = v48;
  *a5 = v49;
}

float apple::vision::libraries::autotrace::ContourToPath::computeCurveStartTangentAtCorner(apple::vision::libraries::autotrace::ContourToPath *a1, uint64_t a2)
{
  BOOL v8 = 0;
  float v7 = 0.0;
  uint64_t v6 = 0;
  unsigned int v5 = 0;
  apple::vision::libraries::autotrace::ContourToPath::findTangentForwardsFrom(a1, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 56), (float *)&v6, (float *)&v5, &v8, &v7, (float *)&v6 + 1);
  int v3 = HIDWORD(v6);
  *(void *)(a2 + 24) = __PAIR64__(v5, v6);
  *(unsigned char *)(a2 + 40) = v8;
  float result = v7;
  *(float *)(a2 + 44) = v7;
  *(_DWORD *)(a2 + 48) = v3;
  return result;
}

void apple::vision::libraries::autotrace::ContourToPath::findTangentForwardsFrom(apple::vision::libraries::autotrace::ContourToPath *this, int a2, int a3, float *a4, float *a5, BOOL *a6, float *a7, float *a8)
{
  BOOL v8 = a7;
  v126[0] = 0;
  uint64_t v125 = 0;
  uint64_t v14 = (int *)*((void *)this + 3);
  uint64_t v15 = *((void *)v14 + 1);
  uint64_t v16 = *v14;
  uint64_t v17 = a2 + 1;
  if ((int)v17 >= (int)v16) {
    int v18 = *v14;
  }
  else {
    int v18 = 0;
  }
  uint64_t v19 = v17 - v18;
  float32x2_t v20 = *(float32x2_t *)(v15 + 8 * a2);
  int8x8_t v21 = (int8x8_t)vsub_f32(*(float32x2_t *)(v15 + 8 * v19), v20);
  float v22 = fabsf(*(float *)v21.i32);
  float v23 = *(float *)&v21.i32[1];
  float v24 = fabsf(*(float *)&v21.i32[1]);
  if (v22 <= (float)(v24 * 4.0))
  {
    if (v24 <= (float)(v22 * 4.0))
    {
      int v119 = a5;
      int v37 = a6;
    }
    else
    {
      float v29 = *(float *)v21.i32;
      int v25 = a3;
      if (*(float *)v21.i32 >= 0.0)
      {
        if (v19 != a3)
        {
          int v25 = v19;
          do
          {
            int v38 = v25 + 1;
            if (v38 >= (int)v16) {
              int v39 = *v14;
            }
            else {
              int v39 = 0;
            }
            int v25 = v38 - v39;
            float v29 = COERCE_FLOAT(*(void *)(v15 + 8 * v25)) - v20.f32[0];
          }
          while (v29 <= 1.0 && v25 != a3);
        }
        if (v29 > 1.0) {
          goto LABEL_56;
        }
      }
      else
      {
        if (v19 != a3)
        {
          int v25 = v19;
          do
          {
            int v30 = v25 + 1;
            if (v30 >= (int)v16) {
              int v31 = *v14;
            }
            else {
              int v31 = 0;
            }
            int v25 = v30 - v31;
            float v29 = COERCE_FLOAT(*(void *)(v15 + 8 * v25)) - v20.f32[0];
          }
          while (v29 >= -1.0 && v25 != a3);
        }
        if (v29 < -1.0) {
          goto LABEL_56;
        }
      }
      int v119 = a5;
      int v37 = a6;
      *(float *)v21.i32 = v29;
    }
  }
  else
  {
    if (*(float *)&v21.i32[1] >= 0.0)
    {
      int v33 = a3;
      if (v19 != a3)
      {
        int v33 = v19;
        do
        {
          int v34 = v33 + 1;
          if (v34 >= (int)v16) {
            int v35 = *v14;
          }
          else {
            int v35 = 0;
          }
          int v33 = v34 - v35;
          float v23 = *(float *)(v15 + 4 + 8 * v33) - v20.f32[1];
        }
        while (v23 <= 1.0 && v33 != a3);
      }
      int v25 = v33;
      if (v23 > 1.0) {
        goto LABEL_56;
      }
    }
    else
    {
      int v25 = a3;
      if (v19 != a3)
      {
        int v25 = v19;
        do
        {
          int v26 = v25 + 1;
          if (v26 >= (int)v16) {
            int v27 = *v14;
          }
          else {
            int v27 = 0;
          }
          int v25 = v26 - v27;
          float v23 = *(float *)(v15 + 4 + 8 * v25) - v20.f32[1];
        }
        while (v23 >= -1.0 && v25 != a3);
      }
      if (v23 < -1.0)
      {
LABEL_56:
        int v41 = v25 - a2;
        if (v41 >= -1) {
          int v42 = 0;
        }
        else {
          int v42 = *v14;
        }
        int v43 = v41 + v42 + 1;
        float v44 = a4;
        float v45 = a8;
        apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v123, (const EPolygon *)v14, a2, v43);
        apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v123, v126, (float *)&v125 + 1, (float *)&v125);
        double v46 = (const EPolygon **)*((void *)this + 3);
        BOOL v47 = v126[0];
        int v48 = v125;
        apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)*(unsigned int *)v46, v46[1], a2, v43, v126[0], *(float *)&v125, v49);
        __float2 v51 = __sincosf_stret(v50 * 6.2832);
        float *v44 = v51.__cosval;
        *a5 = v51.__sinval;
        *a6 = v47;
        *BOOL v8 = *((float *)&v125 + 1);
        *(_DWORD *)float v45 = v48;
        return;
      }
    }
    int v119 = a5;
    int v37 = a6;
    *(float *)&v21.i32[1] = v23;
  }
  int v52 = (v16 & ((a3 - a2) >> 31)) + a3 - a2;
  if (v52 > 10)
  {
    int8x8_t v115 = v21;
    float v116 = a4;
    int v118 = a8;
    apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v123, (const EPolygon *)v14, a2, 10);
    apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v123, v126, (float *)&v125 + 1, (float *)&v125);
    int v53 = v126[0];
    int v54 = HIDWORD(v125);
    float v55 = *(float *)&v125;
    float v56 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine((int **)v123, v126[0], *((float *)&v125 + 1), *(float *)&v125);
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((void *)this + 3) + 8), a2, 10, v53, v55, v57);
    float v59 = v58;
    if (v56 < apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v60, v58, v61, v62, v63, v64, v65, v66, v67))
    {
      if (v52 < 0x15) {
        goto LABEL_65;
      }
      apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v121, *((const EPolygon **)this + 3), a2, 20);
      v123[2] = v121[2];
      v123[3] = v121[3];
      uint64_t v124 = v122;
      v123[0] = v121[0];
      v123[1] = v121[1];
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v123, v126, (float *)&v125 + 1, (float *)&v125);
      int v53 = v126[0];
      int v54 = HIDWORD(v125);
      float v55 = *(float *)&v125;
      float v68 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine((int **)v123, v126[0], *((float *)&v125 + 1), *(float *)&v125);
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((void *)this + 3) + 8), a2, 20, v53, v55, v69);
      float v59 = v70;
      if (v68 < apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v71, v70, v72, v73, v74, v75, v76, v77, v78))
      {
LABEL_65:
        __float2 v79 = __sincosf_stret(v59 * 6.2832);
        *float v116 = v79.__cosval;
        *int v119 = v79.__sinval;
        *int v37 = v53;
        *(_DWORD *)a7 = v54;
        *int v118 = v55;
        return;
      }
    }
    BOOL v8 = a7;
    a8 = v118;
    a4 = v116;
    int8x8_t v21 = v115;
  }
  uint64_t v80 = 0;
  int v81 = 0;
  int8x8_t v82 = 0;
  do
  {
    uint64_t v83 = v80 + a2;
    uint64_t v84 = v83 - v16;
    if (v83 >= v16)
    {
      if (v84 >= v16)
      {
        BOOL v86 = v16 == 0;
      }
      else
      {
        LODWORD(v83) = v80 + a2 - v16;
        BOOL v86 = 1;
      }
      if (!v86) {
        uint64_t v83 = v84 % v16;
      }
    }
    else if (v83 < 0)
    {
      uint64_t v85 = v83 + v16;
      if (v83 + v16 < 0 == __OFADD__(v83, v16)) {
        LODWORD(v83) = v83 + v16;
      }
      if (v85 < 0 && v16) {
        uint64_t v83 = v85 % v16 + v16;
      }
    }
    if (v83 == a3)
    {
      unsigned int v87 = 0;
    }
    else
    {
      unsigned int v88 = 0;
      uint64_t v89 = (int)v83;
      int v90 = v83;
      while (1)
      {
        int v91 = v90 + 1;
        int v92 = v90 + 1 >= (int)v16 ? v16 : 0;
        int v90 = v91 - v92;
        unsigned int v87 = v88 + 1;
        int8x8_t v21 = (int8x8_t)vsub_f32(*(float32x2_t *)(v15 + 8 * v90), *(float32x2_t *)(v15 + 8 * (int)v83));
        float v93 = fabsf(*(float *)v21.i32);
        float v94 = fabsf(*(float *)&v21.i32[1]);
        if (v93 == 2.0 || v94 == 2.0) {
          break;
        }
        BOOL v96 = v93 != 1.0;
        if (v94 == 1.0) {
          BOOL v96 = 0;
        }
        int v97 = v96 | v81;
        v81 |= v97 ^ 1;
        if (v97) {
          unsigned int v98 = -1;
        }
        else {
          unsigned int v98 = 0;
        }
        int8x8_t v82 = vbsl_s8((int8x8_t)vdup_n_s32(v98), v82, v21);
        unsigned int v88 = v87;
        if (v90 == a3) {
          goto LABEL_102;
        }
      }
      if (v90 != a3 && v88 < 4)
      {
        unsigned int v102 = 1;
        goto LABEL_106;
      }
    }
LABEL_102:
    ++v80;
  }
  while (v80 != 3);
  if ((v81 & 1) == 0)
  {
    float32x2_t v100 = *(float32x2_t *)(v15 + 8 * a2);
    float32x2_t v101 = vsub_f32(*(float32x2_t *)(v15 + 8 * v19), v100);
    LODWORD(v83) = a2;
    goto LABEL_107;
  }
  unsigned int v102 = 0;
  uint64_t v89 = (int)v83;
LABEL_106:
  float32x2_t v101 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v102), 0x1FuLL)), v21, v82);
  float32x2_t v100 = *(float32x2_t *)(v15 + 8 * v89);
LABEL_107:
  float v103 = 1.0 / fmaxf(sqrtf(vmlas_n_f32(vmuls_lane_f32(v101.f32[1], v101, 1), v101.f32[0], v101.f32[0])), 0.001);
  float v104 = v103 * v101.f32[0];
  float v105 = vmuls_lane_f32(v103, v101, 1);
  if (v87 == 2)
  {
    int v106 = v83 + 1;
    if (v106 >= (int)v16) {
      int v107 = v16;
    }
    else {
      int v107 = 0;
    }
    float32x2_t v100 = vmul_f32(vadd_f32(v100, *(float32x2_t *)(v15 + 8 * (v106 - v107))), (float32x2_t)0x3F0000003F000000);
  }
  BOOL v108 = fabsf(v104) <= fabsf(v105);
  float v109 = v104 / v105;
  uint64_t v110 = 1;
  uint64_t v111 = !v108;
  if (v108)
  {
    char v112 = 0;
  }
  else
  {
    uint64_t v110 = 0;
    float v109 = v105 / v104;
    char v112 = 1;
  }
  float32x2_t v120 = v100;
  float v113 = *(float *)((unint64_t)&v120 | (4 * v111));
  float v114 = *(float *)((unint64_t)&v120 | (4 * v110));
  *a4 = v104;
  *int v119 = v105;
  *int v37 = v112;
  *BOOL v8 = v113 - (float)(v109 * v114);
  *a8 = v109;
}

float apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(apple::vision::libraries::autotrace *this, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = 0;
  float v10 = a2 - (float)((float)(int)floorf(a2 * 4.0) * 0.25);
  if (v10 > 0.125) {
    float v10 = 0.25 - v10;
  }
  float v11 = v10 * 360.0;
  while (1)
  {
    uint64_t v12 = v9 + 2;
    if (v9 == 14) {
      break;
    }
    uint64_t v13 = &apple::vision::libraries::autotrace::SLDDT[v9];
    float v14 = *v13;
    float v15 = v13[2];
    BOOL v16 = *v13 > v11 || v11 > v15;
    uint64_t v9 = v12;
    if (!v16)
    {
      float v17 = (float)(v11 - v14) / (float)(v15 - v14);
      float v18 = apple::vision::libraries::autotrace::SLDDT[((v12 - 2) & 0xFFFFFFFE) + 1];
      return v18 + (float)(v17 * (float)(apple::vision::libraries::autotrace::SLDDT[(v12 & 0xFFFFFFFE) + 1] - v18));
    }
  }
  VNValidatedLog(4, @"%s: angle %.3f not found in straightLineDistanceDeltaToleranceAtAngle", a4, a5, a6, a7, a8, a9, (uint64_t)"straightLineDistanceDeltaToleranceAtAngle");
  return 0.099;
}

void apple::vision::libraries::autotrace::ContourToPath::findTangentBackwardsFrom(apple::vision::libraries::autotrace::ContourToPath *this, int a2, int a3, float *a4, float *a5, BOOL *a6, float *a7, float *a8)
{
  BOOL v8 = a8;
  v128[0] = 0;
  uint64_t v127 = 0;
  uint64_t v13 = (int *)*((void *)this + 3);
  uint64_t v14 = *((void *)v13 + 1);
  uint64_t v15 = *v13;
  if (a2 <= 0) {
    int v16 = *v13;
  }
  else {
    int v16 = 0;
  }
  uint64_t v17 = a2 + (uint64_t)v16 - 1;
  float32x2_t v18 = *(float32x2_t *)(v14 + 8 * a2);
  int8x8_t v19 = (int8x8_t)vsub_f32(*(float32x2_t *)(v14 + 8 * v17), v18);
  float v20 = fabsf(*(float *)v19.i32);
  float v21 = *(float *)&v19.i32[1];
  float v22 = fabsf(*(float *)&v19.i32[1]);
  if (v20 <= (float)(v22 * 4.0))
  {
    if (v22 <= (float)(v20 * 4.0))
    {
      uint64_t v121 = a7;
    }
    else
    {
      float v28 = *(float *)v19.i32;
      int v23 = a3;
      if (v17 != a3)
      {
        int v23 = a2 + v16 - 1;
        do
        {
          if (v23 <= 0) {
            int v29 = *v13;
          }
          else {
            int v29 = 0;
          }
          int v23 = v23 + v29 - 1;
          float v28 = COERCE_FLOAT(*(void *)(v14 + 8 * v23)) - v18.f32[0];
        }
        while (v28 >= -1.0 && v28 <= 1.0 && v23 != a3);
      }
      if (v28 < -1.0 || v28 > 1.0) {
        goto LABEL_42;
      }
      uint64_t v121 = a7;
      *(float *)v19.i32 = v28;
    }
  }
  else
  {
    int v23 = a3;
    if (v17 != a3)
    {
      int v23 = a2 + v16 - 1;
      do
      {
        if (v23 <= 0) {
          int v24 = *v13;
        }
        else {
          int v24 = 0;
        }
        int v23 = v23 + v24 - 1;
        float v21 = *(float *)(v14 + 4 + 8 * v23) - v18.f32[1];
      }
      while (v21 >= -1.0 && v21 <= 1.0 && v23 != a3);
    }
    if (v21 < -1.0 || v21 > 1.0)
    {
LABEL_42:
      if (a2 - v23 >= -1) {
        int v33 = 0;
      }
      else {
        int v33 = *v13;
      }
      int v34 = a2 - v23 + v33 + 1;
      int v35 = a4;
      int v36 = a6;
      int v37 = a5;
      apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v125, (const EPolygon *)v13, v23, v34);
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v125, v128, (float *)&v127 + 1, (float *)&v127);
      BOOL v38 = v128[0];
      int v39 = v127;
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((void *)this + 3) + 8), v23, v34, v128[0], *(float *)&v127, v40);
      __float2 v42 = __sincosf_stret(v41 * 6.2832);
      *int v35 = v42.__cosval;
      *int v37 = v42.__sinval;
      *int v36 = v38;
      *a7 = *((float *)&v127 + 1);
      *(_DWORD *)BOOL v8 = v39;
      return;
    }
    uint64_t v121 = a7;
    *(float *)&v19.i32[1] = v21;
  }
  int v43 = (v15 & ((a2 - a3) >> 31)) + a2 - a3;
  if (v43 > 10)
  {
    int v44 = a2 - 10;
    uint64_t v45 = a2 - 10;
    int v119 = a6;
    int v117 = a4;
    int v118 = a5;
    int8x8_t v116 = v19;
    if (a2 - 10 >= (int)v15)
    {
      uint64_t v48 = v44 - v15;
      LODWORD(v47) = v45 - v15;
      if (v45 - v15 >= v15)
      {
        LODWORD(v47) = a2 - 10;
        if (v15) {
          uint64_t v47 = v48 % v15;
        }
      }
    }
    else if (a2 > 9)
    {
      LODWORD(v47) = a2 - 10;
    }
    else
    {
      uint64_t v46 = v15 + v44;
      LODWORD(v47) = v15 + v45;
      if (v15 + v45 < 0)
      {
        LODWORD(v47) = a2 - 10;
        if (v15) {
          uint64_t v47 = v46 % v15 + v15;
        }
      }
    }
    apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v125, (const EPolygon *)v13, v47, 10);
    apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v125, v128, (float *)&v127 + 1, (float *)&v127);
    int v49 = v128[0];
    int v50 = HIDWORD(v127);
    float v51 = *(float *)&v127;
    float v52 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine((int **)v125, v128[0], *((float *)&v127 + 1), *(float *)&v127);
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((void *)this + 3) + 8), v47, 10, v49, v51, v53);
    float v55 = v54;
    if (v52 < apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v56, v54, v57, v58, v59, v60, v61, v62, v63))
    {
      _CF = v43 >= 0x15;
      uint64_t v64 = a8;
      if (!_CF) {
        goto LABEL_72;
      }
      int v65 = a2 - 20;
      uint64_t v66 = a2 - 20;
      if (a2 - 20 >= (int)v15)
      {
        uint64_t v69 = v65 - v15;
        LODWORD(v68) = v66 - v15;
        if (v66 - v15 >= v15)
        {
          LODWORD(v68) = a2 - 20;
          if (v15) {
            uint64_t v68 = v69 % v15;
          }
        }
      }
      else if (a2 > 19)
      {
        LODWORD(v68) = a2 - 20;
      }
      else
      {
        uint64_t v67 = v15 + v65;
        LODWORD(v68) = v15 + v66;
        if (v15 + v66 < 0)
        {
          LODWORD(v68) = a2 - 20;
          if (v15) {
            uint64_t v68 = v67 % v15 + v15;
          }
        }
      }
      apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v123, *((const EPolygon **)this + 3), v68, 20);
      v125[2] = v123[2];
      v125[3] = v123[3];
      uint64_t v126 = v124;
      v125[0] = v123[0];
      v125[1] = v123[1];
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v125, v128, (float *)&v127 + 1, (float *)&v127);
      int v49 = v128[0];
      int v50 = HIDWORD(v127);
      float v51 = *(float *)&v127;
      float v70 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine((int **)v125, v128[0], *((float *)&v127 + 1), *(float *)&v127);
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((void *)this + 3) + 8), v68, 20, v49, v51, v71);
      float v55 = v72;
      if (v70 < apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v73, v72, v74, v75, v76, v77, v78, v79, v80))
      {
        uint64_t v64 = a8;
LABEL_72:
        __float2 v81 = __sincosf_stret(v55 * 6.2832);
        *int v117 = v81.__cosval;
        *int v118 = v81.__sinval;
        *int v119 = v49;
        *(_DWORD *)uint64_t v121 = v50;
        *uint64_t v64 = v51;
        return;
      }
    }
    a6 = v119;
    BOOL v8 = a8;
    a4 = v117;
    a5 = v118;
    int8x8_t v19 = v116;
  }
  uint64_t v82 = 0;
  int v83 = 0;
  int8x8_t v84 = 0;
  do
  {
    uint64_t v85 = a2 - v82;
    uint64_t v86 = v85 - v15;
    if (v85 >= v15)
    {
      if (v86 >= v15)
      {
        BOOL v88 = v15 == 0;
      }
      else
      {
        LODWORD(v85) = a2 - v82 - v15;
        BOOL v88 = 1;
      }
      if (!v88) {
        uint64_t v85 = v86 % v15;
      }
    }
    else if (v85 < 0)
    {
      uint64_t v87 = v85 + v15;
      if (v85 + v15 < 0 == __OFADD__(v85, v15)) {
        LODWORD(v85) = v85 + v15;
      }
      if (v87 < 0 && v15) {
        uint64_t v85 = v87 % v15 + v15;
      }
    }
    if (v85 == a3)
    {
      unsigned int v89 = 0;
    }
    else
    {
      unsigned int v90 = 0;
      uint64_t v91 = (int)v85;
      int v92 = v85;
      while (1)
      {
        int v93 = v92 <= 0 ? v15 : 0;
        int v92 = v92 + v93 - 1;
        unsigned int v89 = v90 + 1;
        int8x8_t v19 = (int8x8_t)vsub_f32(*(float32x2_t *)(v14 + 8 * (int)v85), *(float32x2_t *)(v14 + 8 * v92));
        float v94 = fabsf(*(float *)v19.i32);
        float v95 = fabsf(*(float *)&v19.i32[1]);
        if (v94 == 2.0 || v95 == 2.0) {
          break;
        }
        BOOL v97 = v94 != 1.0;
        if (v95 == 1.0) {
          BOOL v97 = 0;
        }
        int v98 = v97 | v83;
        v83 |= v98 ^ 1;
        if (v98) {
          unsigned int v99 = -1;
        }
        else {
          unsigned int v99 = 0;
        }
        int8x8_t v84 = vbsl_s8((int8x8_t)vdup_n_s32(v99), v84, v19);
        unsigned int v90 = v89;
        if (v92 == a3) {
          goto LABEL_109;
        }
      }
      _CF = v92 == a3 || v90 >= 4;
      if (!_CF)
      {
        unsigned int v103 = 1;
        goto LABEL_113;
      }
    }
LABEL_109:
    ++v82;
  }
  while (v82 != 3);
  if ((v83 & 1) == 0)
  {
    float32x2_t v101 = *(float32x2_t *)(v14 + 8 * a2);
    float32x2_t v102 = vsub_f32(v101, *(float32x2_t *)(v14 + 8 * v17));
    LODWORD(v85) = a2;
    goto LABEL_114;
  }
  unsigned int v103 = 0;
  uint64_t v91 = (int)v85;
LABEL_113:
  float32x2_t v102 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v103), 0x1FuLL)), v19, v84);
  float32x2_t v101 = *(float32x2_t *)(v14 + 8 * v91);
LABEL_114:
  float32x2_t v104 = vmul_n_f32(v102, 1.0 / fmaxf(sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v102, v102).i32[1]), v102.f32[0], v102.f32[0])), 0.001));
  if (v89 == 2)
  {
    if ((int)v85 <= 0) {
      int v105 = v15;
    }
    else {
      int v105 = 0;
    }
    float32x2_t v101 = vmul_f32(vadd_f32(v101, *(float32x2_t *)(v14 + 8 * ((int)v85 + v105 - 1))), (float32x2_t)0x3F0000003F000000);
  }
  float32x2_t v106 = vabs_f32(v104);
  unsigned __int8 v107 = vcgt_f32(v106, (float32x2_t)vdup_lane_s32((int32x2_t)v106, 1)).u8[0];
  float32x2_t v108 = (float32x2_t)vdup_lane_s32((int32x2_t)v104, 1);
  if (v107)
  {
    uint64_t v109 = 0;
    _S2 = vdiv_f32(v108, v104).u32[0];
    BOOL v111 = 1;
  }
  else
  {
    BOOL v111 = 0;
    _S2 = vdiv_f32(v104, v108).u32[0];
    uint64_t v109 = 1;
  }
  float32x2_t v122 = v101;
  _S3 = *(_DWORD *)((unint64_t)&v122 | (4 * v109));
  *a4 = v104.f32[0];
  __asm { FMLS            S0, S3, V2.S[0] }
  *a5 = v104.f32[1];
  *a6 = v111;
  *(_DWORD *)uint64_t v121 = _S0;
  *(_DWORD *)BOOL v8 = _S2;
}

apple::vision::libraries::autotrace::CornerList *apple::vision::libraries::autotrace::CornerList::findCorner(apple::vision::libraries::autotrace::CornerList *this, apple::vision::libraries::autotrace::CornerList *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)this <= *((_DWORD *)this + 1)) {
    int v8 = 0;
  }
  else {
    int v8 = a3;
  }
  int v9 = *(_DWORD *)this - v8;
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((a2 - this) >> 2);
  int v11 = *((_DWORD *)a2 - 2);
  if (v11 < *((_DWORD *)a2 - 3) && v10 > 1) {
    int v13 = a3;
  }
  else {
    int v13 = 0;
  }
  if ((int)a4 + (int)a3 <= v13 + v11) {
    int v14 = a4 + a3;
  }
  else {
    int v14 = a4;
  }
  if ((int)a4 - (int)a3 >= v9) {
    int v14 = a4 - a3;
  }
  if ((int)v10 >= 1)
  {
    int v15 = 0;
    int v16 = (int)a3 >> 1;
    do
    {
      int v17 = ((int)v10 + v15) >> 1;
      uint64_t v18 = (uint64_t)((int)v10 + v15) >> 1;
      int8x8_t v19 = (int *)((char *)this + 12 * v17);
      if ((v10 + v15) > 1)
      {
        int v23 = *v19;
        int v24 = *((_DWORD *)this + 3 * (int)v18 + 1);
        if (*v19 + v16 >= v24) {
          int v25 = 0;
        }
        else {
          int v25 = a3;
        }
        a4 = (v24 - v25);
        a6 = (v24 + a3);
        if (*v19 - v16 > v24) {
          int v20 = v24 + a3;
        }
        else {
          int v20 = a4;
        }
      }
      else
      {
        int v20 = *((_DWORD *)this + 3 * (int)v18 + 1);
        int v21 = *v19;
        if (v20 + v16 >= *v19) {
          int v22 = 0;
        }
        else {
          int v22 = a3;
        }
        a4 = (v21 - v22);
        a6 = (v21 + a3);
        if (v20 - v16 > v21) {
          int v23 = v21 + a3;
        }
        else {
          int v23 = a4;
        }
      }
      if (v20 >= v14)
      {
        LODWORD(v10) = ((int)v10 + v15) >> 1;
        if (v23 <= v14) {
          return (apple::vision::libraries::autotrace::CornerList *)v19;
        }
      }
      else
      {
        int v15 = v17 + 1;
      }
    }
    while (v15 < (int)v10);
  }
  while (this != a2)
  {
    if (*((_DWORD *)this + 2) == v14) {
      return this;
    }
    this = (apple::vision::libraries::autotrace::CornerList *)((char *)this + 12);
  }
  if (a5) {
    VNValidatedLog(4, @"%s: find corner could not find index", a3, a4, a5, a6, a7, a8, (uint64_t)"findCorner");
  }
  return 0;
}

float apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(apple::vision::libraries::autotrace::ContourToPath *this, int a2, int a3, float *a4, float *a5)
{
  uint64_t v5 = *((void *)this + 7);
  float v6 = *(float *)(v5 + 4 * a2);
  float v7 = 0.0;
  float v8 = v6;
  float v9 = v6;
  do
  {
    float v10 = *(float *)(v5 + 4 * a2) - rintf(*(float *)(v5 + 4 * a2) - v6);
    if (v10 >= v8)
    {
      if (v10 > v9) {
        float v9 = v10;
      }
    }
    else
    {
      float v8 = v10;
    }
    float v7 = v7 + *(float *)(*((void *)this + 8) + 4 * a2);
    int v11 = a2 + 1;
    if (a2 + 1 >= **((_DWORD **)this + 3)) {
      int v12 = **((_DWORD **)this + 3);
    }
    else {
      int v12 = 0;
    }
    a2 = v11 - v12;
  }
  while (v11 - v12 != a3);
  *a4 = v7;
  float result = v9 - v8;
  *a5 = v9 - v8;
  return result;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::cutUpCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = **(int **)(a1 + 24);
  int v15 = a4 - a2;
  if (a4 == a2)
  {
    if (*(void *)(a1 + 128) - *(void *)(a1 + 120) >= 9uLL)
    {
      VNValidatedLog(4, @"%s: zero length curve in cutUpCurve at point index %d", a3, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"cutUpCurve");
      return 1;
    }
  }
  else if (v15 >= 0xFFFFFFFE {
         && (int)v14 >= 101
  }
         && *(void *)(a1 + 128) - *(void *)(a1 + 120) >= 0x11uLL)
  {
    VNValidatedLog(4, @"%s: cutUpCurve with reversed point indexes %d and %d", a3, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"cutUpCurve");
    return 1;
  }
  float v48 = 0.0;
  if (v15 <= 0) {
    int v16 = v14;
  }
  else {
    int v16 = 0;
  }
  apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange((apple::vision::libraries::autotrace::ContourToPath *)a1, a2, a4, &v48, &v47);
  if (fabsf(v48) <= 0.16667) {
    return 1;
  }
  int v17 = v16 + v15;
  uint64_t v18 = *(void *)(a1 + 72);
  float v19 = fabsf(*(float *)(v18 + 4 * (int)a2));
  unsigned int v20 = a2;
  LODWORD(v21) = a2;
  float v22 = v19;
  do
  {
    float v23 = fabsf(*(float *)(v18 + 4 * (int)v20));
    float v19 = v19 + v23;
    if (v23 <= v22) {
      uint64_t v21 = v21;
    }
    else {
      uint64_t v21 = v20;
    }
    if (v23 > v22) {
      float v22 = v23;
    }
    int v24 = v20 + 1;
    if (v24 >= (int)v14) {
      int v25 = v14;
    }
    else {
      int v25 = 0;
    }
    unsigned int v20 = v24 - v25;
  }
  while (v20 != a4);
  float v26 = v22 / (float)(v19 / (float)v17);
  BOOL v27 = v26 < 2.2 || v21 == a2;
  if (v27 || v26 <= 1.9) {
    goto LABEL_27;
  }
  LODWORD(v43) = v21 - a2;
  uint64_t v44 = (int)v21 - (int)a2;
  if ((int)v21 - (int)a2 >= (int)v14)
  {
    LODWORD(v43) = v43 - v14;
    if (v44 - v14 >= v14)
    {
      LODWORD(v43) = v21 - a2;
      if (v14) {
        uint64_t v43 = (v44 - v14) % v14;
      }
    }
  }
  else if ((v44 & 0x80000000) != 0)
  {
    LODWORD(v43) = v43 + v14;
    if (v44 + v14 < 0)
    {
      LODWORD(v43) = v21 - a2;
      if (v14) {
        uint64_t v43 = (v44 + v14) % v14 + v14;
      }
    }
  }
  if (v17 / 5 >= (int)v43 || 4 * v17 / 5 <= (int)v43)
  {
LABEL_27:
    if ((int)a2 + 1 >= (int)v14) {
      int v28 = v14;
    }
    else {
      int v28 = 0;
    }
    signed int v29 = a2 + 1 - v28;
    if (v29 == a4) {
      return 1;
    }
    signed int v30 = a2;
    while (1)
    {
      signed int v31 = v30;
      signed int v30 = v29;
      uint64_t v32 = *(void *)(a1 + 56);
      float v33 = *(float *)(v32 + 4 * v31);
      float v34 = *(float *)(v32 + 4 * v30) - rintf(*(float *)(v32 + 4 * v30) - v33);
      uint64_t v35 = ((v31 == a2) & a3) != 0 ? 8 : 24;
      if (v33 <= 0.0 && v34 >= 0.0
        || v33 >= 0.0 && v34 <= 0.0
        || (v33 <= 0.25 ? (BOOL v36 = v34 < 0.25) : (BOOL v36 = 1),
            !v36
         || (v33 >= 0.25 ? (BOOL v37 = v34 > 0.25) : (BOOL v37 = 1),
             !v37
          || (v33 <= 0.5 ? (BOOL v38 = v34 < 0.5) : (BOOL v38 = 1),
              !v38
           || (v33 >= 0.5 ? (BOOL v39 = v34 > 0.5) : (BOOL v39 = 1),
               !v39
            || (v33 <= 0.75 ? (BOOL v40 = v34 < 0.75) : (BOOL v40 = 1),
                !v40 || v33 >= 0.75 && v34 <= 0.75 || v33 <= 1.0 && v34 >= 1.0 || v33 >= 1.0 && v34 <= 1.0))))))
      {
        uint64_t result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v31, v35, a6);
        if (!result) {
          break;
        }
      }
      if (v30 + 1 >= (int)v14) {
        int v42 = v14;
      }
      else {
        int v42 = 0;
      }
      signed int v29 = v30 + 1 - v42;
      if (v29 == a4) {
        return 1;
      }
    }
  }
  else
  {
    uint64_t result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v21, 16, a6);
    if (result)
    {
      uint64_t result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v21, 8, a6);
      if (result)
      {
        uint64_t v45 = v21 == a4 ? a5 : 0;
        uint64_t result = apple::vision::libraries::autotrace::ContourToPath::cutUpCurve(a1, a2, a3, v21, v45, a6);
        if (result)
        {
          char v46 = apple::vision::libraries::autotrace::ContourToPath::cutUpCurve(a1, v21, 0, a4, a5, a6);
          uint64_t result = 0;
          if (v46) {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::indexOfNewInterestingPointAtPointIndex(int a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  *a4 = 0;
  unint64_t v5 = (a3 - a2) >> 3;
  if ((int)v5 < 1)
  {
    uint64_t result = 0;
  }
  else
  {
    LODWORD(result) = 0;
    uint64_t v7 = (a3 - a2) >> 3;
    do
    {
      int v8 = ((int)v7 + (int)result) >> 1;
      int v9 = *(_DWORD *)(a2 + 8 * v8);
      if (v9 < a1) {
        uint64_t result = (v8 + 1);
      }
      else {
        uint64_t result = result;
      }
      if (v9 >= a1) {
        LODWORD(v7) = v8;
      }
    }
    while ((int)result < (int)v7);
  }
  if (v5 > (int)result && *(_DWORD *)(a2 + 8 * (int)result) == a1)
  {
    *a4 = 1;
  }
  else if (v5 == (int)result)
  {
    return 0;
  }
  else
  {
    return result;
  }
  return result;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(unsigned int a1, uint64_t a2, void *a3)
{
  int v4 = a2;
  uint64_t v7 = (char *)*a3;
  float v6 = (char *)a3[1];
  unint64_t v8 = (uint64_t)&v6[-*a3] >> 3;
  if ((int)v8 < 1)
  {
    uint64_t v12 = 0;
  }
  else
  {
    int v9 = 0;
    uint64_t v10 = (uint64_t)&v6[-*a3] >> 3;
    do
    {
      int v11 = ((int)v10 + v9) >> 1;
      if (*(_DWORD *)&v7[8 * v11] >= (signed int)a1) {
        LODWORD(v10) = ((int)v10 + v9) >> 1;
      }
      else {
        int v9 = v11 + 1;
      }
    }
    while (v9 < (int)v10);
    uint64_t v12 = v9;
  }
  int v13 = &v7[8 * v12];
  if (v8 > v12 && *(_DWORD *)v13 == a1)
  {
    *(_DWORD *)&v7[8 * v12 + 4] |= a2;
  }
  else
  {
    unint64_t v14 = a3[2];
    if ((unint64_t)v6 >= v14)
    {
      unint64_t v19 = v8 + 1;
      if ((v8 + 1) >> 61) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v20 = v14 - (void)v7;
      if (v20 >> 2 > v19) {
        unint64_t v19 = v20 >> 2;
      }
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v19;
      }
      if (v21)
      {
        float v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v21);
      }
      else
      {
        float v23 = 0;
        uint64_t v22 = 0;
      }
      int v25 = &v23[8 * v12];
      float v26 = &v23[8 * v22];
      if (v12 == v22)
      {
        if (v12 < 1)
        {
          if (v12) {
            unint64_t v27 = 2 * v12;
          }
          else {
            unint64_t v27 = 1;
          }
          int v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v27);
          int v25 = &v28[8 * (v27 >> 2)];
          float v26 = &v28[8 * v29];
          if (v23) {
            operator delete(v23);
          }
        }
        else
        {
          v25 -= 8 * ((unint64_t)(v12 + 1) >> 1);
        }
      }
      *(_DWORD *)int v25 = a1;
      *((_DWORD *)v25 + 1) = v4;
      signed int v30 = (char *)*a3;
      signed int v31 = v25;
      if ((char *)*a3 != v13)
      {
        uint64_t v32 = v13;
        signed int v31 = v25;
        do
        {
          uint64_t v33 = *((void *)v32 - 1);
          v32 -= 8;
          *((void *)v31 - 1) = v33;
          v31 -= 8;
        }
        while (v32 != v30);
      }
      float v34 = (char *)a3[1];
      int64_t v35 = v34 - v13;
      if (v34 != v13) {
        memmove(v25 + 8, v13, v34 - v13);
      }
      BOOL v36 = (char *)*a3;
      *a3 = v31;
      a3[1] = &v25[v35 + 8];
      a3[2] = v26;
      if (v36) {
        operator delete(v36);
      }
    }
    else if (v13 == v6)
    {
      *(_DWORD *)float v6 = a1;
      *(_DWORD *)&v7[8 * v12 + 4] = a2;
      a3[1] = v6 + 8;
    }
    else
    {
      int v15 = v13 + 8;
      int v16 = v6 - 8;
      int v17 = (void *)a3[1];
      while (v16 < v6)
      {
        uint64_t v18 = *(void *)v16;
        v16 += 8;
        *v17++ = v18;
      }
      unint64_t v24 = a1 | (unint64_t)(a2 << 32);
      a3[1] = v17;
      if (v6 != v15) {
        memmove(&v6[-8 * ((v6 - v15) >> 3)], v13, v6 - v15);
      }
      *(void *)int v13 = v24;
    }
    return *a3 + 8 * v12;
  }
  return (uint64_t)v13;
}

void sub_1A3FF2D7C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL apple::vision::libraries::autotrace::ContourToPath::outputLineAtIndex(uint64_t a1, int a2, int a3, void **a4, _DWORD *a5, unsigned char *a6)
{
  int v9 = a3;
  uint64_t v12 = *(const EPolygon **)(a1 + 24);
  uint64_t v13 = *(_DWORD *)v12;
  int v133 = a2;
  int v14 = a3 + a2;
  uint64_t v15 = a3 + a2;
  if (v14 >= (int)v13)
  {
    uint64_t v17 = v14 - v13;
    if (v13) {
      uint64_t v15 = (v15 - v13) % v13;
    }
    if (v17 >= v13) {
      LODWORD(v16) = v15;
    }
    else {
      LODWORD(v16) = v17;
    }
  }
  else
  {
    LODWORD(v16) = v14;
    if (v14 < 0)
    {
      uint64_t v16 = v13 + v14;
      if (v16 < 0)
      {
        if (v13) {
          uint64_t v16 = v16 % v13 + v13;
        }
        else {
          LODWORD(v16) = v14;
        }
      }
    }
  }
  uint64_t v148 = 0;
  BOOL v149 = 0;
  apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)&v139, v12, v133, a3);
  apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)&v139, &v149, (float *)&v148 + 1, (float *)&v148);
  BOOL v18 = v149;
  float v19 = *(float *)&v148;
  float v20 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(&v139, v149, *((float *)&v148 + 1), *(float *)&v148);
  apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**(unsigned int **)(a1 + 24), *(const EPolygon **)(*(void *)(a1 + 24) + 8), v133, v9, v18, v19, v21);
  float v31 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v22, v30, v23, v24, v25, v26, v27, v28, v29);
  float v32 = v31;
  if (v9 < 51 || v20 <= v31)
  {
    int v87 = v133;
    goto LABEL_93;
  }
  int v135 = v13;
  uint64_t v132 = a5;
  BOOL v138 = 0;
  float v136 = 0.0;
  float v137 = 0.0;
  int v33 = v9 - 1;
  int v34 = v133;
  int v134 = v16;
  int v35 = v16;
  do
  {
    unsigned int v36 = v9;
    int v37 = v33;
    BOOL v38 = (uint64_t *)*((void *)v139 + 1);
    int v39 = *v139;
    int v40 = v141;
    _Q3 = vcvtq_f64_f32((float32x2_t)v38[v140]);
    float64x2_t v42 = vsubq_f64(v142, _Q3);
    float64x2_t v43 = vmlsq_f64(v143, _Q3, _Q3);
    float64x2_t v142 = v42;
    float64x2_t v143 = v43;
    _D4 = _Q3.f64[1];
    __asm { FMLS            D0, D4, V3.D[0] }
    double v144 = _D0;
    if (v140 + 1 >= v39) {
      int v50 = v39;
    }
    else {
      int v50 = 0;
    }
    int v51 = v140 + 1 - v50;
    int v52 = v141 - 1;
    int v140 = v51;
    --v141;
    float v53 = &v38[v51];
    _VF = __OFSUB__(v40, 2);
    int v54 = v40 - 2;
    if (v54 < 0 == _VF)
    {
      int v55 = 0;
      float v56 = &v38[v51];
      int v57 = v51;
      do
      {
        uint64_t v58 = *v56;
        if (v55)
        {
          uint64_t v59 = &v145;
          if (*(float *)&v58 < v145 || (uint64_t v59 = (float *)&v147, *(float *)&v58 > *(float *)&v147)) {
            *(_DWORD *)uint64_t v59 = v58;
          }
          LODWORD(v58) = HIDWORD(v58);
          if (*((float *)&v58 + 1) >= v146)
          {
            uint64_t v60 = (float *)&v147 + 1;
            if (*((float *)&v58 + 1) <= *((float *)&v147 + 1)) {
              goto LABEL_30;
            }
            goto LABEL_29;
          }
        }
        else
        {
          LODWORD(v145) = *v56;
          uint64_t v147 = v58;
          LODWORD(v58) = HIDWORD(v58);
        }
        uint64_t v60 = &v146;
LABEL_29:
        *(_DWORD *)uint64_t v60 = v58;
LABEL_30:
        int v61 = v57 + 1;
        ++v56;
        if (v57 + 1 < v39) {
          ++v57;
        }
        else {
          int v57 = 0;
        }
        if (v61 >= v39) {
          float v56 = v38;
        }
        ++v55;
      }
      while (v52 != v55);
    }
    if (v34 + 1 >= v135) {
      int v62 = v135;
    }
    else {
      int v62 = 0;
    }
    if (v54 + v51 >= v39) {
      int v63 = v39;
    }
    else {
      int v63 = 0;
    }
    _Q3 = vcvtq_f64_f32((float32x2_t)v38[v54 + v51 - v63]);
    float64x2_t v142 = vsubq_f64(v42, _Q3);
    float64x2_t v143 = vmlsq_f64(v43, _Q3, _Q3);
    _D1 = _Q3.f64[1];
    __asm { FMLS            D0, D1, V3.D[0] }
    double v144 = _D0;
    int v141 = v54;
    if (v52 >= 2)
    {
      for (int i = 0; v54 != i; ++i)
      {
        uint64_t v68 = *v53;
        if (i)
        {
          uint64_t v69 = &v145;
          if (*(float *)&v68 < v145 || (uint64_t v69 = (float *)&v147, *(float *)&v68 > *(float *)&v147)) {
            *(_DWORD *)uint64_t v69 = v68;
          }
          LODWORD(v68) = HIDWORD(v68);
          if (*((float *)&v68 + 1) >= v146)
          {
            float v70 = (float *)&v147 + 1;
            if (*((float *)&v68 + 1) <= *((float *)&v147 + 1)) {
              goto LABEL_54;
            }
            goto LABEL_53;
          }
        }
        else
        {
          LODWORD(v145) = *v53;
          uint64_t v147 = v68;
          LODWORD(v68) = HIDWORD(v68);
        }
        float v70 = &v146;
LABEL_53:
        *(_DWORD *)float v70 = v68;
LABEL_54:
        int v71 = v51 + 1;
        ++v53;
        if (v51 + 1 < v39) {
          ++v51;
        }
        else {
          int v51 = 0;
        }
        if (v71 >= v39) {
          float v53 = v38;
        }
      }
    }
    int v34 = v34 + 1 - v62;
    if (v35 <= 0) {
      int v72 = v135;
    }
    else {
      int v72 = 0;
    }
    int v35 = v35 + v72 - 1;
    v9 -= 2;
    apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)&v139, &v138, &v137, &v136);
    BOOL v73 = v138;
    float v74 = v136;
    float v75 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(&v139, v138, v137, v136);
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**(unsigned int **)(a1 + 24), *(const EPolygon **)(*(void *)(a1 + 24) + 8), v34, v36 - 2, v73, v74, v76);
    float v86 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v77, v85, v78, v79, v80, v81, v82, v83, v84);
    if (v75 <= v86) {
      break;
    }
    int v33 = v37 - 2;
  }
  while (v36 > 0x34);
  _CF = v36 >= 0x35;
  int v87 = v133;
  if (_CF)
  {
    do
    {
      uint64_t v88 = *((void *)v139 + 1);
      int v89 = *v139;
      int v90 = v141++;
      int v91 = v35;
      float v92 = v86;
      float v93 = v75;
      int v94 = v140 + v90;
      if (v94 < v89) {
        int v89 = 0;
      }
      float32x2_t v95 = *(float32x2_t *)(v88 + 8 * (v94 - v89));
      float64x2_t v96 = vcvtq_f64_f32(v95);
      float64x2_t v142 = vaddq_f64(v142, v96);
      float64x2_t v143 = vmlaq_f64(v143, v96, v96);
      double v144 = vmlad_n_f64(v144, v96.f64[1], v96.f64[0]);
      BOOL v97 = &v145;
      if (v95.f32[0] < v145 || (BOOL v97 = (float *)&v147, v95.f32[0] > *(float *)&v147)) {
        *BOOL v97 = v95.f32[0];
      }
      int v98 = &v146;
      if (v95.f32[1] < v146 || (int v98 = (float *)&v147 + 1, v95.f32[1] > *((float *)&v147 + 1))) {
        *int v98 = v95.f32[1];
      }
      if (v35 + 1 >= v135) {
        int v99 = v135;
      }
      else {
        int v99 = 0;
      }
      int v35 = v35 + 1 - v99;
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)&v139, &v138, &v137, &v136);
      BOOL v100 = v138;
      float v101 = v136;
      float v75 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(&v139, v138, v137, v136);
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**(unsigned int **)(a1 + 24), *(const EPolygon **)(*(void *)(a1 + 24) + 8), v34, v37, v100, v101, v102);
      float v86 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v103, v111, v104, v105, v106, v107, v108, v109, v110);
      ++v37;
    }
    while (v75 <= v86);
    do
    {
      int v87 = v34;
      float v32 = v92;
      float v20 = v93;
      int v134 = v91;
      int v112 = v140 - 1;
      if (v140 <= 0) {
        v112 += *v139;
      }
      uint64_t v113 = *((void *)v139 + 1);
      int v140 = v112;
      ++v141;
      float32x2_t v114 = *(float32x2_t *)(v113 + 8 * v112);
      float64x2_t v115 = vcvtq_f64_f32(v114);
      float64x2_t v142 = vaddq_f64(v142, v115);
      float64x2_t v143 = vmlaq_f64(v143, v115, v115);
      double v144 = vmlad_n_f64(v144, v115.f64[1], v115.f64[0]);
      int8x8_t v116 = &v145;
      if (v114.f32[0] < v145 || (int8x8_t v116 = (float *)&v147, v114.f32[0] > *(float *)&v147)) {
        *int8x8_t v116 = v114.f32[0];
      }
      int v117 = &v146;
      if (v114.f32[1] < v146 || (int v117 = (float *)&v147 + 1, v114.f32[1] > *((float *)&v147 + 1))) {
        *int v117 = v114.f32[1];
      }
      if (v34 <= 0) {
        int v118 = v135;
      }
      else {
        int v118 = 0;
      }
      int v34 = v34 + v118 - 1;
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)&v139, &v138, &v137, &v136);
      BOOL v119 = v138;
      float v120 = v136;
      float v93 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(&v139, v138, v137, v136);
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**(unsigned int **)(a1 + 24), *(const EPolygon **)(*(void *)(a1 + 24) + 8), v34, v37, v119, v120, v121);
      float v92 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v122, v130, v123, v124, v125, v126, v127, v128, v129);
      ++v37;
      int v91 = v35;
    }
    while (v93 <= v92);
  }
  a5 = v132;
  LODWORD(v16) = v134;
LABEL_93:
  if (v20 <= v32)
  {
    apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v87, 2, a4);
    apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v16, 4, a4);
    *a5 = v16;
  }
  BOOL result = v20 <= v32;
  *a6 = 0;
  return result;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::insertPairIntoInterestingPoints(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t *a5, unsigned char *a6)
{
  *a6 = 0;
  signed int v7 = *(_DWORD *)a2;
  uint64_t v6 = *(unsigned int *)(a2 + 4);
  BOOL v8 = (a4 & 4) == 0 || (*(_DWORD *)(a2 + 4) & 2) == 0;
  if (v7 == a3) {
    return result;
  }
  unsigned int v10 = a3;
  uint64_t v12 = result;
  int v13 = **(_DWORD **)(result + 24);
  __int16 v84 = 0;
  uint64_t v14 = a5[1];
  if (v14 == *a5) {
    goto LABEL_175;
  }
  int v80 = v13;
  unsigned int v81 = v6;
  int v15 = apple::vision::libraries::autotrace::ContourToPath::indexOfNewInterestingPointAtPointIndex(v7, *a5, v14, (unsigned char *)&v84 + 1);
  BOOL result = apple::vision::libraries::autotrace::ContourToPath::indexOfNewInterestingPointAtPointIndex(v10, *a5, a5[1], &v84);
  uint64_t v19 = v15 + 1;
  uint64_t v21 = *a5;
  uint64_t v20 = a5[1];
  uint64_t v22 = (v20 - *a5) >> 3;
  if (v19 >= v22)
  {
    LODWORD(v23) = v19 - v22;
    if (v19 - v22 >= v22)
    {
      LODWORD(v23) = v15 + 1;
      if (v20 != v21) {
        uint64_t v23 = (v19 - v22) % v22;
      }
    }
  }
  else if (v15 > -2)
  {
    LODWORD(v23) = v15 + 1;
  }
  else
  {
    LODWORD(v23) = v22 + v19;
    if (v22 + v19 < 0)
    {
      LODWORD(v23) = v15 + 1;
      if (v20 != v21) {
        uint64_t v23 = (v22 + v19) % v22 + v22;
      }
    }
  }
  uint64_t v24 = v15 - 1;
  uint64_t v25 = v24 - v22;
  if (v24 >= v22)
  {
    LODWORD(v26) = v24 - v22;
    if (v25 >= v22)
    {
      LODWORD(v26) = v15 - 1;
      if (v20 != v21) {
        uint64_t v26 = v25 % v22;
      }
    }
  }
  else if (v15 <= 0)
  {
    LODWORD(v26) = v22 + v24;
    if (v22 + v24 < 0)
    {
      LODWORD(v26) = v15 - 1;
      if (v20 != v21) {
        uint64_t v26 = (v22 + v24) % v22 + v22;
      }
    }
  }
  else
  {
    LODWORD(v26) = v15 - 1;
  }
  uint64_t v27 = v15;
  if (v15 == result)
  {
    if (!v84 || !HIBYTE(v84) && (_BYTE)v84)
    {
      uint64_t v28 = v21 + 8 * (int)v26;
      goto LABEL_33;
    }
    if (*(void *)(v12 + 128) - *(void *)(v12 + 120) == 8)
    {
      uint64_t v6 = v81;
      if (*(_DWORD *)(v21 + 8 * v15 + 4) == 64) {
        *(_DWORD *)(a2 + 4) &= ~0x40u;
      }
      goto LABEL_175;
    }
LABEL_174:
    uint64_t v6 = v81;
LABEL_175:
    BOOL result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v7, v6, a5);
    if (result)
    {
      BOOL result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v10, a4, a5);
      if (result)
      {
        uint64_t v21 = *a5;
        uint64_t v20 = a5[1];
        goto LABEL_185;
      }
    }
    *a6 = 1;
    return result;
  }
  uint64_t v29 = (_DWORD *)(v21 + 8 * v15);
  if (result != v23)
  {
    uint64_t v30 = (int)result - 1;
    uint64_t v31 = v30 - v22;
    if (v30 >= v22)
    {
      LODWORD(v32) = v30 - v22;
      if (v31 >= v22)
      {
        LODWORD(v32) = result - 1;
        if (v20 != v21) {
          uint64_t v32 = v31 % v22;
        }
      }
    }
    else if ((int)result <= 0)
    {
      LODWORD(v32) = v22 + v30;
      if (v22 + v30 < 0)
      {
        LODWORD(v32) = result - 1;
        if (v20 != v21) {
          uint64_t v32 = (v22 + v30) % v22 + v22;
        }
      }
    }
    else
    {
      LODWORD(v32) = result - 1;
    }
    uint64_t v44 = (unsigned int *)(v21 + 8 * (int)v32);
    if (HIBYTE(v84) | v84) {
      char v45 = 1;
    }
    else {
      char v45 = v8;
    }
    if ((v45 & 1) == 0)
    {
      if ((*(unsigned char *)(v21 + 8 * v27 + 4) & 2) != 0 && (*(unsigned char *)(v21 + 8 * (int)v32 + 4) & 4) != 0)
      {
        *uint64_t v29 = v7;
        unsigned int *v44 = v10;
      }
      goto LABEL_185;
    }
    if (HIBYTE(v84)) {
      BOOL v46 = v84 == 0;
    }
    else {
      BOOL v46 = 0;
    }
    char v47 = !v46 || v8;
    if ((v47 & 1) == 0)
    {
      uint64_t v6 = v81;
      if ((*(unsigned char *)(v21 + 8 * v27 + 4) & 2) == 0) {
        goto LABEL_185;
      }
      unsigned int *v44 = v10;
      goto LABEL_175;
    }
    if (HIBYTE(v84)) {
      BOOL v48 = 1;
    }
    else {
      BOOL v48 = v84 == 0;
    }
    char v49 = v48 || v8;
    if (v49)
    {
      if (HIBYTE(v84)) {
        BOOL v50 = v84 == 0;
      }
      else {
        BOOL v50 = 1;
      }
      char v51 = v50 || v8;
      if ((v51 & 1) != 0
        || (*(unsigned char *)(v21 + 8 * v27 + 4) & 2) == 0
        || (*(unsigned char *)(v21 + 8 * (int)result + 4) & 4) == 0)
      {
        goto LABEL_185;
      }
      int v52 = result;
      LODWORD(v53) = apple::vision::libraries::autotrace::wrapIndex(v7 + 1, (v20 - *a5) >> 3);
      if (v53 != v52)
      {
        uint64_t v6 = v81;
        do
        {
          uint64_t v54 = v21 + 8 * (int)v53;
          int v56 = *(_DWORD *)(v54 + 4);
          int v55 = (_DWORD *)(v54 + 4);
          if ((v56 & 0xFFFFFFF9) == 0) {
            *int v55 = 0;
          }
          uint64_t v57 = (int)v53 + 1;
          uint64_t v58 = v57 - v22;
          if (v57 >= v22)
          {
            if (v58 >= v22) {
              LODWORD(v53) = v53 + 1;
            }
            else {
              LODWORD(v53) = v57 - v22;
            }
            if (v58 >= v22 && v20 != v21) {
              uint64_t v53 = v58 % v22;
            }
          }
          else
          {
            BOOL v59 = (int)v53 <= -2;
            LODWORD(v53) = v53 + 1;
            if (v59)
            {
              uint64_t v60 = v22 + v57;
              LODWORD(v53) = v22 + v57 < 0 != __OFADD__(v22, v57) ? v57 : (int)v22 + (int)v57;
              if (v60 < 0 && v20 != v21) {
                uint64_t v53 = v60 % v22 + v22;
              }
            }
          }
        }
        while (v52 != v53);
        goto LABEL_175;
      }
    }
    else if ((*(unsigned char *)(v21 + 8 * (int)result + 4) & 4) != 0 && (*(unsigned char *)(v21 + 8 * v27 + 4) & 2) != 0)
    {
      *uint64_t v29 = v7;
      int v71 = result;
      LODWORD(v72) = apple::vision::libraries::autotrace::wrapIndex(v7 + 1, v22);
      if (v72 != v71)
      {
        uint64_t v6 = v81;
        do
        {
          uint64_t v73 = v21 + 8 * (int)v72;
          int v75 = *(_DWORD *)(v73 + 4);
          float v74 = (_DWORD *)(v73 + 4);
          if ((v75 & 0xFFFFFFF9) == 0) {
            *float v74 = 0;
          }
          uint64_t v76 = (int)v72 + 1;
          uint64_t v77 = v76 - v22;
          if (v76 >= v22)
          {
            if (v77 >= v22) {
              LODWORD(v72) = v72 + 1;
            }
            else {
              LODWORD(v72) = v76 - v22;
            }
            if (v77 >= v22 && v20 != v21) {
              uint64_t v72 = v77 % v22;
            }
          }
          else
          {
            BOOL v59 = (int)v72 <= -2;
            LODWORD(v72) = v72 + 1;
            if (v59)
            {
              uint64_t v78 = v22 + v76;
              LODWORD(v72) = v22 + v76 < 0 != __OFADD__(v22, v76) ? v76 : (int)v22 + (int)v76;
              if (v78 < 0 && v20 != v21) {
                uint64_t v72 = v78 % v22 + v22;
              }
            }
          }
        }
        while (v71 != v72);
        goto LABEL_175;
      }
    }
    goto LABEL_174;
  }
  if (HIBYTE(v84) && !(_BYTE)v84)
  {
    uint64_t v28 = v21 + 8 * v27;
LABEL_33:
    uint64_t v6 = v81;
    if ((*(unsigned char *)(v28 + 4) & 0xA) != 0) {
      goto LABEL_185;
    }
    goto LABEL_175;
  }
  if (!HIBYTE(v84) || !(_BYTE)v84)
  {
    if (!v84)
    {
      int v34 = *(_DWORD *)(v21 + 8 * v27 + 4);
      if (v34 == 1)
      {
        Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*(apple::vision::libraries::autotrace::CornerList **)(v12 + 96), *(apple::vision::libraries::autotrace::CornerList **)(v12 + 104), **(unsigned int **)(v12 + 24), *v29, 1, v16, v17, v18);
        int v36 = *v29 - v7;
        if (v80 >= 0) {
          int v37 = v80;
        }
        else {
          int v37 = v80 + 1;
        }
        int v38 = -(v37 >> 1);
        if (v36 >= v38) {
          int v39 = 0;
        }
        else {
          int v39 = v80;
        }
        int v40 = v39 + v36;
        if (v40 < 0) {
          int v40 = -v40;
        }
        int v41 = v10 - *v29;
        if (v41 >= v38) {
          int v42 = 0;
        }
        else {
          int v42 = v80;
        }
        int v43 = v42 + v41;
        if (v43 < 0) {
          int v43 = -v43;
        }
        if (v40 >= v43)
        {
          uint64_t v6 = v81;
          if (Corner) {
            unsigned int v10 = *((_DWORD *)Corner + 2);
          }
          else {
            *uint64_t v29 = v10;
          }
        }
        else
        {
          uint64_t v6 = v81;
          if (Corner) {
            signed int v7 = *((_DWORD *)Corner + 2);
          }
          else {
            *uint64_t v29 = v7;
          }
        }
        goto LABEL_175;
      }
      if ((v34 & 4) == 0 || (*(_DWORD *)(v21 + 8 * (int)v26 + 4) & 2) == 0)
      {
        uint64_t v6 = v81;
        if ((v34 & 2) != 0) {
          goto LABEL_185;
        }
        goto LABEL_175;
      }
      signed int v7 = *(_DWORD *)(v21 + 8 * (int)v26);
LABEL_172:
      *uint64_t v29 = v10;
      goto LABEL_174;
    }
    if (HIBYTE(v84) || !(_BYTE)v84) {
      goto LABEL_185;
    }
    int v61 = *(_DWORD *)(v21 + 8 * v27 + 4);
    if ((v61 & 2) == 0)
    {
      if (v61 != 1) {
        goto LABEL_185;
      }
      int v62 = apple::vision::libraries::autotrace::CornerList::findCorner(*(apple::vision::libraries::autotrace::CornerList **)(v12 + 96), *(apple::vision::libraries::autotrace::CornerList **)(v12 + 104), **(unsigned int **)(v12 + 24), *v29, 1, v16, v17, v18);
      int v63 = *v29 - v7;
      if (v80 >= 0) {
        int v64 = v80;
      }
      else {
        int v64 = v80 + 1;
      }
      int v65 = -(v64 >> 1);
      if (v63 >= v65) {
        int v66 = 0;
      }
      else {
        int v66 = v80;
      }
      int v67 = v66 + v63;
      if (v67 < 0) {
        int v67 = -v67;
      }
      int v68 = v10 - *v29;
      if (v68 >= v65) {
        int v69 = 0;
      }
      else {
        int v69 = v80;
      }
      int v70 = v69 + v68;
      if (v70 < 0) {
        int v70 = -v70;
      }
      if (v67 >= v70)
      {
        if (v62)
        {
          unsigned int v10 = *((_DWORD *)v62 + 2);
          goto LABEL_174;
        }
        goto LABEL_172;
      }
      if (v62)
      {
        signed int v7 = *((_DWORD *)v62 + 2);
        goto LABEL_174;
      }
    }
    *uint64_t v29 = v7;
    goto LABEL_174;
  }
  int v33 = *(_DWORD *)(v21 + 8 * v27 + 4);
  if (v8)
  {
    uint64_t v6 = v81;
    if ((v33 & 8) != 0) {
      goto LABEL_185;
    }
  }
  else
  {
    uint64_t v6 = v81;
    if ((v33 & 2) != 0) {
      goto LABEL_185;
    }
  }
  if ((v33 & 0xA) == 0) {
    goto LABEL_175;
  }
  while (1)
  {
LABEL_185:
    if (v21 == v20)
    {
      uint64_t v21 = v20;
      goto LABEL_187;
    }
    if (!*(_DWORD *)(v21 + 4)) {
      break;
    }
    v21 += 8;
  }
  if (v21 != v20)
  {
    uint64_t v79 = v21 + 8;
    if (v21 + 8 != v20)
    {
      do
      {
        if (*(_DWORD *)(v79 + 4))
        {
          *(void *)uint64_t v21 = *(void *)v79;
          v21 += 8;
        }
        v79 += 8;
      }
      while (v79 != v20);
      uint64_t v20 = a5[1];
    }
  }
LABEL_187:
  if (v20 != v21 + 8) {
    BOOL result = (uint64_t)memmove((void *)v21, (const void *)(v21 + 8), v20 - (v21 + 8));
  }
  a5[1] = v20 - 8;
  return result;
}

uint64_t apple::vision::libraries::autotrace::wrapIndex(uint64_t this, uint64_t a2)
{
  uint64_t v2 = this;
  uint64_t v3 = this - a2;
  if (this >= a2)
  {
    this -= a2;
    if (v3 >= a2)
    {
      this = v2;
      if (a2) {
        return v3 % a2;
      }
    }
  }
  else if (this < 0)
  {
    uint64_t v4 = a2 + this;
    this += a2;
    if (a2 + v2 < 0)
    {
      this = v2;
      if (a2) {
        return v4 % a2 + a2;
      }
    }
  }
  return this;
}

_DWORD *apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(int a1, int a2, void **a3)
{
  signed int v7 = a3[1];
  unint64_t v6 = (unint64_t)a3[2];
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((char *)v7 - (unsigned char *)*a3) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v6 - (void)*a3;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v12);
    uint64_t v14 = &v13[8 * v9];
    uint64_t v16 = &v13[8 * v15];
    *(_DWORD *)uint64_t v14 = a1;
    *((_DWORD *)v14 + 1) = a2;
    BOOL v8 = v14 + 8;
    uint64_t v18 = (char *)*a3;
    uint64_t v17 = (char *)a3[1];
    if (v17 != *a3)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      uint64_t v17 = (char *)*a3;
    }
    *a3 = v14;
    a3[1] = v8;
    a3[2] = v16;
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    _DWORD *v7 = a1;
    v7[1] = a2;
    BOOL v8 = v7 + 2;
  }
  a3[1] = v8;
  return v8 - 2;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::cornerCompare(apple::vision::libraries::autotrace::ContourToPath *this, _DWORD *a2, const void *a3)
{
  return (*(_DWORD *)this - *a2);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::ipCompare(apple::vision::libraries::autotrace::ContourToPath *this, _DWORD *a2, const void *a3)
{
  return (*(_DWORD *)this - *a2);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::LRLine(EPolygon *this, const EPolygon *a2, _DWORD *a3, float *a4, float *a5, float *a6)
{
  int v8 = (int)a2;
  BOOL v18 = 0;
  uint64_t v17 = 0;
  apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v16, this, (int)a2, 5);
  uint64_t v10 = apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v16, &v18, (float *)&v17 + 1, (float *)&v17);
  if (v10)
  {
    BOOL v11 = v18;
    float v12 = *(float *)&v17;
    *a4 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(v16, v18, *((float *)&v17 + 1), *(float *)&v17);
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)*(_DWORD *)this, *((const EPolygon **)this + 1), v8, 5, v11, v12, v13);
    *a3 = v14;
  }
  return v10;
}

_DWORD *apple::vision::libraries::autotrace::ContourToPath::addHorizontalLine(_DWORD *result, uint64_t a2, int a3, int a4, int a5, void **a6, unsigned char *a7)
{
  *a7 = 0;
  if (a5 >= 10)
  {
    int v7 = a4;
    int v8 = a4 <= 0 ? (int)result : 0;
    if (vabds_f32(*(float *)(a2 + 8 * a3 + 4), *(float *)(a2 + 8 * (a4 + v8 - 1) + 4)) < 0.001)
    {
      if (a3 >= a4)
      {
        float v15 = NAN;
      }
      else
      {
        int v10 = 0;
        float v11 = 0.0;
        int v12 = a3;
        do
        {
          float v11 = v11 + *(float *)(a2 + 4 + 8 * v12);
          ++v10;
          int v13 = v12 + 1;
          if (v13 >= (int)result) {
            int v14 = (int)result;
          }
          else {
            int v14 = 0;
          }
          int v12 = v13 - v14;
        }
        while (v12 < a4);
        float v15 = v11 / (float)v10;
      }
      float v16 = v15 + -0.023;
      float v17 = v15 + 0.023;
      uint64_t v18 = a2 + 4;
      do
      {
        if (a3 <= 0) {
          int v19 = (int)result;
        }
        else {
          int v19 = 0;
        }
        int v20 = v19 + a3;
        a3 = v20 - 1;
        float v21 = *(float *)(v18 + 8 * (v20 - 1));
      }
      while (v21 >= v16 && v21 <= v17);
      if (v20 >= (int)result) {
        int v23 = (int)result;
      }
      else {
        int v23 = 0;
      }
      int v24 = v20 - v23;
      for (float i = *(float *)(a2 + 8 * a4 + 4); i >= v16 && i <= v17; float i = *(float *)(v18 + 8 * v7))
      {
        if (v7 + 1 >= (int)result) {
          int v27 = (int)result;
        }
        else {
          int v27 = 0;
        }
        int v7 = v7 + 1 - v27;
      }
      apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v24, 2, a6);
      return apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v7, 4, a6);
    }
  }
  return result;
}

_DWORD *apple::vision::libraries::autotrace::ContourToPath::addVerticalLine(_DWORD *result, uint64_t a2, int a3, int a4, int a5, void **a6, unsigned char *a7)
{
  *a7 = 0;
  if (a5 >= 10)
  {
    int v7 = a4;
    int v8 = a4 <= 0 ? (int)result : 0;
    if (vabds_f32(COERCE_FLOAT(*(void *)(a2 + 8 * a3)), COERCE_FLOAT(*(void *)(a2 + 8 * (a4 + v8 - 1)))) < 0.001)
    {
      if (a3 >= a4)
      {
        float v15 = NAN;
      }
      else
      {
        int v10 = 0;
        float v11 = 0.0;
        int v12 = a3;
        do
        {
          float v11 = v11 + COERCE_FLOAT(*(void *)(a2 + 8 * v12));
          ++v10;
          int v13 = v12 + 1;
          if (v13 >= (int)result) {
            int v14 = (int)result;
          }
          else {
            int v14 = 0;
          }
          int v12 = v13 - v14;
        }
        while (v12 < a4);
        float v15 = v11 / (float)v10;
      }
      float v16 = v15 + -0.023;
      float v17 = v15 + 0.023;
      do
      {
        if (a3 <= 0) {
          int v18 = (int)result;
        }
        else {
          int v18 = 0;
        }
        int v19 = v18 + a3;
        a3 = v19 - 1;
        uint64_t v20 = *(void *)(a2 + 8 * (v19 - 1));
      }
      while (*(float *)&v20 >= v16 && *(float *)&v20 <= v17);
      if (v19 >= (int)result) {
        int v22 = (int)result;
      }
      else {
        int v22 = 0;
      }
      int v23 = v19 - v22;
      while (1)
      {
        uint64_t v24 = *(void *)(a2 + 8 * v7);
        if (*(float *)&v24 < v16 || *(float *)&v24 > v17) {
          break;
        }
        if (v7 + 1 >= (int)result) {
          int v26 = (int)result;
        }
        else {
          int v26 = 0;
        }
        int v7 = v7 + 1 - v26;
      }
      apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v23, 2, a6);
      return apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v7, 4, a6);
    }
  }
  return result;
}

float *apple::vision::libraries::autotrace::ContourToPath::filterAngleBuffer(float *this, float *a2, float *a3, int a4, float a5)
{
  int v5 = 0;
  unint64_t v6 = this;
  do
  {
    float v7 = *v6;
    if (v5) {
      int v8 = 0;
    }
    else {
      int v8 = (int)a3;
    }
    int v9 = v5 + v8;
    ++v5;
    int v10 = v9 - 1;
    if (v5 >= (int)a3) {
      int v11 = (int)a3;
    }
    else {
      int v11 = 0;
    }
    int v12 = v5 - v11;
    int v13 = 1;
    int v14 = a4;
    float v15 = *v6;
    do
    {
      float v16 = this[v12] - rintf(this[v12] - v7);
      if (vabds_f32(v16, v7) >= a5) {
        float v16 = -0.0;
      }
      else {
        ++v13;
      }
      float v17 = v15 + v16;
      float v18 = this[v10] - rintf(this[v10] - v7);
      if (vabds_f32(v18, v7) >= a5) {
        float v18 = -0.0;
      }
      else {
        ++v13;
      }
      float v15 = v17 + v18;
      int v19 = v12 + 1;
      if (v19 >= (int)a3) {
        int v20 = (int)a3;
      }
      else {
        int v20 = 0;
      }
      int v12 = v19 - v20;
      if (v10 <= 0) {
        int v21 = (int)a3;
      }
      else {
        int v21 = 0;
      }
      int v10 = v10 + v21 - 1;
      --v14;
    }
    while (v14);
    *a2++ = (float)(v15 / (float)v13) - floorf(v15 / (float)v13);
    ++v6;
  }
  while (v5 != a3);
  return this;
}

uint64_t cvml::util::anonymous namespace'::fileExistsAtPath(uint64_t *a1)
{
  uint64_t v2 = (void *)MEMORY[0x1A6257080]();
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = (uint64_t *)*a1;
  }
  uint64_t v4 = [NSString stringWithUTF8String:v3];
  int v5 = [MEMORY[0x1E4F28CB8] defaultManager];
  uint64_t v6 = [v5 fileExistsAtPath:v4];

  return v6;
}

void sub_1A3FF4130(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void cvml::util::anonymous namespace'::generateTemporaryFilePath(cvml::util::_anonymous_namespace_ *this)
{
  uint64_t v1 = MEMORY[0x1A6257080]();
  uint64_t v2 = NSTemporaryDirectory();
  int v20 = [MEMORY[0x1E4F28CB8] defaultManager];
  uint64_t context = (void *)v1;
  if (v2)
  {
    int v3 = 5;
    while (1)
    {
      uint64_t v4 = (void *)MEMORY[0x1A6257080]();
      int v5 = [MEMORY[0x1E4F29128] UUID];
      uint64_t v6 = [v5 UUIDString];

      if (!v6) {
        break;
      }
      float v7 = (const char *)[v6 UTF8String];
      size_t v8 = strlen(v7);
      if (v8 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      size_t v9 = v8;
      if (v8 >= 0x17)
      {
        uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v8 | 7) != 0x17) {
          uint64_t v11 = v8 | 7;
        }
        uint64_t v12 = v11 + 1;
        p_dst = (void **)operator new(v11 + 1);
        size_t v22 = v9;
        int64_t v23 = v12 | 0x8000000000000000;
        long long __dst = p_dst;
        goto LABEL_12;
      }
      HIBYTE(v23) = v8;
      p_dst = (void **)&__dst;
      if (v8) {
        goto LABEL_12;
      }
LABEL_13:
      *((unsigned char *)p_dst + v9) = 0;

      size_t v13 = v22;
      if (v23 < 0)
      {
        int v14 = __dst;
      }
      else
      {
        size_t v13 = HIBYTE(v23);
        int v14 = (void **)&__dst;
      }
      if (v13 == 11
        && (*v14 == (void *)0x494C41564E492323
          ? (BOOL v15 = *(void **)((char *)v14 + 3) == (void *)0x232344494C41564ELL)
          : (BOOL v15 = 0),
            v15))
      {
        int v17 = 4;
        if ((v23 & 0x8000000000000000) == 0) {
          goto LABEL_27;
        }
      }
      else
      {
        float v16 = [NSString stringWithFormat:@"%@%s", v2, v14, context];
        if (v16 && ([v20 fileExistsAtPath:v16] & 1) == 0)
        {
          std::string::basic_string[abi:ne180100]<0>(this, (char *)[v16 UTF8String]);
          int v17 = 1;
        }
        else
        {
          int v17 = 0;
        }

        if ((v23 & 0x8000000000000000) == 0) {
          goto LABEL_27;
        }
      }
      operator delete(__dst);
LABEL_27:
      if ((v17 | 4) != 4) {
        goto LABEL_33;
      }
      if (!--v3)
      {
        int v17 = 0;
        goto LABEL_33;
      }
    }
    HIBYTE(v23) = 11;
    p_dst = (void **)&__dst;
    size_t v9 = 11;
    float v7 = "##INVALID##";
LABEL_12:
    memmove(p_dst, v7, v9);
    goto LABEL_13;
  }
  *((unsigned char *)this + 23) = 11;
  strcpy((char *)this, "##INVALID##");
  int v17 = 1;
LABEL_33:

  if (!v17)
  {
    *((unsigned char *)this + 23) = 11;
    strcpy((char *)this, "##INVALID##");
  }
}

void sub_1A3FF4418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  _Unwind_Resume(a1);
}

uint64_t cvml::util::anonymous namespace'::moveFile(uint64_t *a1, uint64_t *a2)
{
  int v5 = (void *)MEMORY[0x1A6257080]();
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = (uint64_t *)*a2;
  }
  float v7 = [NSString stringWithUTF8String:v6];
  if (*((char *)a1 + 23) >= 0) {
    size_t v8 = a1;
  }
  else {
    size_t v8 = (uint64_t *)*a1;
  }
  size_t v9 = [NSString stringWithUTF8String:v8];
  int v10 = [MEMORY[0x1E4F28CB8] defaultManager];
  int v11 = [v10 fileExistsAtPath:v7];
  if (v11) {
    unsigned int v2 = [v10 moveItemAtPath:v7 toPath:v9 error:0];
  }

  return v11 & v2;
}

void sub_1A3FF454C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t cvml::util::anonymous namespace'::removeFile(uint64_t *a1)
{
  int v3 = (void *)MEMORY[0x1A6257080]();
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = (uint64_t *)*a1;
  }
  int v5 = [NSString stringWithUTF8String:v4];
  uint64_t v6 = [MEMORY[0x1E4F28CB8] defaultManager];
  int v7 = [v6 fileExistsAtPath:v5];
  if (v7) {
    unsigned int v1 = [v6 removeItemAtPath:v5 error:0];
  }

  return v7 & v1;
}

void sub_1A3FF461C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t cvml::util::MMapFileBackingStore::MMapFileBackingStore(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v4 = (std::string *)(a1 + 16);
  int v5 = (long long *)(a2 + 16);
  if (*(char *)(a2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v6 = *v5;
    v4->__r_.__value_.__r.__words[2] = *(void *)(a2 + 32);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v6;
  }
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  *(void *)a2 = -1;
  *(_DWORD *)(a2 + 8) = -1;
  if (*(char *)(a2 + 39) < 0) {
    operator delete(*(void **)v5);
  }
  *((unsigned char *)v5 + 32) = 0;
  *int v5 = 0u;
  v5[1] = 0u;
  return a1;
}

void cvml::util::MMapFileBackingStore::create(cvml::util::MMapFileBackingStore *this)
{
  unint64_t v8 = v33;
  if ((v33 & 0x80u) == 0)
  {
    size_t v9 = __p;
  }
  else
  {
    unint64_t v8 = (unint64_t)__p[1];
    size_t v9 = (void **)__p[0];
  }
  if (v8 == 11
    && (*v9 == (void *)0x494C41564E492323
      ? (BOOL v10 = *(void **)((char *)v9 + 3) == (void *)0x232344494C41564ELL)
      : (BOOL v10 = 0),
        v10))
  {
    uint64_t v25 = @"MMapFileBackingStore::create -- Could not generate a valid path for temporary file";
  }
  else
  {
    int v11 = open((const char *)v9, 1538, 438);
    if (v11 != -1)
    {
      int v12 = v11;
      if (lseek(v11, (off_t)this - 1, 0) == -1)
      {
        int v26 = @"MMapFileBackingStore::create -- Unable to grow file to desired capacity -- seek";
      }
      else
      {
        char __buf = 32;
        if (write(v12, &__buf, 1uLL) != 1)
        {
          VNValidatedLog(4, @"MMapFileBackingStore::create -- Unable to grow file to desired capacity -- write", v19, v20, v21, v22, v23, v24, v30);
          exceptiounint64_t n = __cxa_allocate_exception(8uLL);
          *exceptiounint64_t n = MEMORY[0x1E4FBA510] + 16;
          __cxa_throw(exception, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
        }
        if (mmap(0, (size_t)this, 3, 1, v12, 0) != (void *)-1) {
          operator new();
        }
        int v26 = @"MMapFileBackingStore::create -- Memory mapping failed for temporary file";
      }
      VNValidatedLog(4, (uint64_t)v26, v13, v14, v15, v16, v17, v18, v30);
      uint64_t v28 = __cxa_allocate_exception(8uLL);
      *uint64_t v28 = MEMORY[0x1E4FBA510] + 16;
      __cxa_throw(v28, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
    }
    uint64_t v25 = @"MMapFileBackingStore::create -- Could not open temporary file for mmaping";
  }
  VNValidatedLog(4, (uint64_t)v25, v2, v3, v4, v5, v6, v7, v30);
  uint64_t v29 = __cxa_allocate_exception(8uLL);
  *uint64_t v29 = MEMORY[0x1E4FBA510] + 16;
  __cxa_throw(v29, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
}

#error "1A3FF49FC: call analysis failed (funcsize=47)"

void cvml::util::MMapFileBackingStore::createByMappingDirectlyFromFile(const char *a1, int a2)
{
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  int v3 = open(a1, 2, 438);
  int v10 = v3;
  if (v3 != -1)
  {
    off_t v17 = lseek(v3, 0, 2);
    if (v17 == -1)
    {
      uint64_t v20 = @"MMapFileBackingStore::createByMappingDirectlyFromFile -- error seeking in provided file";
    }
    else
    {
      if (a2) {
        int v18 = 3;
      }
      else {
        int v18 = 1;
      }
      if (mmap(0, v17, v18, 1, v10, 0) != (void *)-1) {
        operator new();
      }
      uint64_t v20 = @"MMapFileBackedBuffer::createByMappingDirectlyFromFile -- Memory mapping failed for temporary file";
    }
    VNValidatedLog(4, (uint64_t)v20, v11, v12, v13, v14, v15, v16, v22);
    exceptiounint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiounint64_t n = MEMORY[0x1E4FBA510] + 16;
    __cxa_throw(exception, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
  }
  VNValidatedLog(4, @"MMapFileBackingStore::createByMappingDirectlyFromFile -- Could not open temporary file for mmaping", v4, v5, v6, v7, v8, v9, v22);
  uint64_t v19 = __cxa_allocate_exception(8uLL);
  void *v19 = MEMORY[0x1E4FBA510] + 16;
  __cxa_throw(v19, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
}

void sub_1A3FF4C48(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x1092C40A95E0729);
  _Unwind_Resume(a1);
}

#error "1A3FF4CCC: call analysis failed (funcsize=26)"

void sub_1A3FF4CDC()
{
}

uint64_t cvml::util::anonymous namespace'::writeBackingStoreToFile<cvml::util::MMapFileBackingStore>(uint64_t a1, void *a2)
{
  unint64_t v2 = a2[5];
  if (!v2) {
    return 0;
  }
  HIBYTE(v68) = 11;
  strcpy((char *)__p, "##INVALID##");
  if (v66 >= 0) {
    uint64_t v6 = v65;
  }
  else {
    uint64_t v6 = (void **)v65[0];
  }
  int v13 = open((const char *)v6, 1538, 438);
  if (v13 == -1)
  {
    if (*(char *)(a1 + 23) >= 0) {
      uint64_t v55 = a1;
    }
    else {
      uint64_t v55 = *(void *)a1;
    }
    VNValidatedLog(4, @"writeBackingStoreToFile-- Could not create file: '%s'", v7, v8, v9, v10, v11, v12, v55);
    exceptiounint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiounint64_t n = MEMORY[0x1E4FBA510] + 16;
    __cxa_throw(exception, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
  }
  for (unint64_t i = 0; i < v2; i += v16)
  {
    if (v2 - i >= 0x4000) {
      size_t v15 = 0x4000;
    }
    else {
      size_t v15 = v2 - i;
    }
    ssize_t v16 = write(v13, (const void *)(*a2 + i), v15);
    if (v16 <= 0)
    {
      VNValidatedLog(4, @"writeBackingStoreToFile-- error writing out data", v17, v18, v19, v20, v21, v22, v62);
      uint64_t v54 = __cxa_allocate_exception(8uLL);
      *uint64_t v54 = MEMORY[0x1E4FBA510] + 16;
      __cxa_throw(v54, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
    }
  }
  if (close(v13) == -1)
  {
    uint64_t v57 = @"writeBackingStoreToFile-- error closing file, file could be corrupt";
LABEL_44:
    VNValidatedLog(4, (uint64_t)v57, v23, v24, v25, v26, v27, v28, v62);
    goto LABEL_45;
  }
  if (v5)
  {
    if (SHIBYTE(v68) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v68 = v64;
    *(_OWORD *)std::string __p = v63;
    unint64_t v35 = HIBYTE(v64);
    if (v64 < 0) {
      unint64_t v35 = *((void *)&v63 + 1);
    }
    if (v35 != 11) {
      goto LABEL_25;
    }
    int v36 = __p;
    if (v64 < 0) {
      int v36 = (void **)__p[0];
    }
    int v37 = *v36;
    uint64_t v38 = *(uint64_t *)((char *)v36 + 3);
    if (v37 == (void *)0x494C41564E492323 && v38 == 0x232344494C41564ELL)
    {
      if (*(char *)(a1 + 23) >= 0) {
        uint64_t v61 = a1;
      }
      else {
        uint64_t v61 = *(void *)a1;
      }
      VNValidatedLog(4, @"writeBackingStoreToFile -- File exists at output path '%s', and we cannot safely overwrite this file", v29, v30, v31, v32, v33, v34, v61);
    }
    else
    {
LABEL_25:
        goto LABEL_26;
      if (*(char *)(a1 + 23) >= 0) {
        uint64_t v59 = a1;
      }
      else {
        uint64_t v59 = *(void *)a1;
      }
      VNValidatedLog(4, @"writeBackingStoreToFile-- File exists at output path '%s', and could not copy file to temporary directory", v40, v41, v42, v43, v44, v45, v59);
      if (SHIBYTE(v68) < 0)
      {
        __p[1] = (void *)11;
        uint64_t v60 = (char *)__p[0];
      }
      else
      {
        HIBYTE(v68) = 11;
        uint64_t v60 = (char *)__p;
      }
      strcpy(v60, "##INVALID##");
    }
LABEL_45:
    uint64_t v58 = __cxa_allocate_exception(8uLL);
    void *v58 = MEMORY[0x1E4FBA510] + 16;
    __cxa_throw(v58, MEMORY[0x1E4FBA368], MEMORY[0x1E4FBA2C8]);
  }
LABEL_26:
  {
    uint64_t v57 = @"writeBackingStoreToFile-- Could not move file from temporary directory";
    goto LABEL_44;
  }
  if (v5
  {
    VNValidatedLog(4, @"writeBackingStoreToFile -- Non critical error -- Could not remove original file after rename", v46, v47, v48, v49, v50, v51, v62);
  }
  uint64_t v52 = 1;
  if (v66 < 0) {
    operator delete(v65[0]);
  }
  if (SHIBYTE(v68) < 0) {
    operator delete(__p[0]);
  }
  return v52;
}

#error "1A3FF5100: call analysis failed (funcsize=64)"

void cvml::util::MMapFileBackingStore::~MMapFileBackingStore(cvml::util::MMapFileBackingStore *this)
{
  unint64_t v2 = *(void **)this;
  if (v2 != (void *)-1 && munmap(v2, *((void *)this + 5))) {
    VNValidatedLog(4, @"MMapFileBackingStore::destructor -- could not unmap file", v3, v4, v5, v6, v7, v8, v23);
  }
  int v9 = *((_DWORD *)this + 2);
  if (v9 != -1 && close(v9) == -1) {
    VNValidatedLog(4, @"MMapFileBackingStore::destructor -- error closing file", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*((unsigned char *)this + 48))
  {
    ssize_t v16 = (void *)((char *)this + 16);
    {
      {
        if (*((char *)this + 39) < 0) {
          ssize_t v16 = (void *)*v16;
        }
        VNValidatedLog(4, @"MMapFileBackingStore::destructor -- Could not remove temporary file '%s'", v17, v18, v19, v20, v21, v22, (uint64_t)v16);
      }
    }
  }
  if (*((char *)this + 39) < 0) {
    operator delete(*((void **)this + 2));
  }
}

uint64_t cvml::util::MMapFileBackingStore::growStorage(cvml::util::MMapFileBackingStore *this, cvml::util::MMapFileBackingStore *a2)
{
  if (a2 && *((void *)this + 5) < (unint64_t)a2) {
    cvml::util::MMapFileBackingStore::create(a2);
  }
  return 0;
}

uint64_t cvml::util::MMapFileBackingStore::writeToFile(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  size_t v5 = *(void *)(a2 + 8);
  if ((v4 & 0x80u) == 0) {
    uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  uint64_t v7 = *(unsigned __int8 *)(a1 + 39);
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(a1 + 24);
  }
  if (v6 == v7)
  {
    if (v8 >= 0) {
      int v9 = (unsigned __int8 *)(a1 + 16);
    }
    else {
      int v9 = *(unsigned __int8 **)(a1 + 16);
    }
    if ((v4 & 0x80) == 0)
    {
      if (v4)
      {
        for (unint64_t i = (unsigned __int8 *)a2; *i == *v9; ++i)
        {
          ++v9;
          if (!--v4) {
            return 0;
          }
        }
        goto LABEL_17;
      }
      return 0;
    }
    if (!memcmp(*(const void **)a2, v9, v5)) {
      return 0;
    }
  }
LABEL_17:
}

void sub_1A3FF54F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF570C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF5800(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF5898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF58F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF5944(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF5A64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF5E00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::default_delete<vision::mod::ImageAnalyzer_PCA>::operator()[abi:ne180100](uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1A62562C0);
}

void sub_1A3FF611C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3FF6238(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _knownIdentifiersForCustomClassifier(vision::mod::ImageAnalyzer_CustomClassifier *a1, long long *a2)
{
  memset(&v12, 0, sizeof(v12));
  unint64_t v2 = std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v12, (long long *)a1, a2, 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)a1) >> 3));
  uint64_t v3 = (void *)MEMORY[0x1A6257080](v2);
  id v4 = objc_alloc(MEMORY[0x1E4F1CA48]);
  size_t v5 = (void *)[v4 initWithCapacity:0xAAAAAAAAAAAAAAABLL* ((uint64_t)(v12.__r_.__value_.__l.__size_ - v12.__r_.__value_.__r.__words[0]) >> 3)];
  std::string::size_type size = v12.__r_.__value_.__l.__size_;
  for (std::string::size_type i = v12.__r_.__value_.__r.__words[0]; i != size; i += 24)
  {
    id v8 = [NSString alloc];
    std::string::size_type v9 = i;
    if (*(char *)(i + 23) < 0) {
      std::string::size_type v9 = *(void *)i;
    }
    uint64_t v10 = (NSString *)[v8 initWithUTF8String:v9];
    if (_isAcceptableClassificationIdentifier(v10, 0)) {
      [v5 addObject:v10];
    }
  }
  uint64_t v13 = &v12;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v13);

  return v5;
}

void sub_1A3FF6358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t _isAcceptableClassificationIdentifier(NSString *a1, VNDisallowedList *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  if ([(NSString *)v3 hasPrefix:@"CVML_UNKNOWN_"]) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = [(VNDisallowedList *)v4 containsIdentifier:v3] ^ 1;
  }

  return v5;
}

void sub_1A3FF6400(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF7A28(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    if (SLOBYTE(STACK[0x277]) < 0) {
      operator delete((void *)STACK[0x260]);
    }
    if (SLOBYTE(STACK[0x297]) < 0) {
      operator delete((void *)STACK[0x280]);
    }
    if (SLOBYTE(STACK[0x2D7]) < 0) {
      JUMPOUT(0x1A3FF7A94);
    }
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1A3FF7A9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55)
{
}

void sub_1A3FF7AFC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1A3FF7B04);
  }
  _Unwind_Resume(a1);
}

vision::mod::ImageAnalyzer_CustomClassifier *std::unique_ptr<vision::mod::ImageAnalyzer_CustomClassifier>::reset[abi:ne180100](vision::mod::ImageAnalyzer_CustomClassifier **a1)
{
  BOOL result = *a1;
  *a1 = 0;
  if (result)
  {
    vision::mod::ImageAnalyzer_CustomClassifier::~ImageAnalyzer_CustomClassifier(result);
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<vision::mod::ImageAnalyzer_CustomClassifier  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"NSt3__114default_deleteIN6vision3mod30ImageAnalyzer_CustomClassifierEEE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

vision::mod::ImageAnalyzer_CustomClassifier *std::__shared_ptr_pointer<vision::mod::ImageAnalyzer_CustomClassifier  *>::__on_zero_shared(uint64_t a1)
{
  BOOL result = *(vision::mod::ImageAnalyzer_CustomClassifier **)(a1 + 24);
  if (result)
  {
    vision::mod::ImageAnalyzer_CustomClassifier::~ImageAnalyzer_CustomClassifier(result);
    JUMPOUT(0x1A62562C0);
  }
  return result;
}

void std::__shared_ptr_pointer<vision::mod::ImageAnalyzer_CustomClassifier  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A3FF7CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3FF7DBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF7E40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A3FF7F5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF8468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  std::string __p = &a18;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);

  _Unwind_Resume(a1);
}

void sub_1A3FF8768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FF8954(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::shared_ptr<vision::mod::ImageAnalyzer_CustomClassifier>>::push_back[abi:ne180100](uint64_t a1, long long *a2)
{
  uint64_t v5 = *(void **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    id v8 = *(void **)a1;
    uint64_t v9 = ((uint64_t)v5 - *(void *)a1) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v4 - (void)v8;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v13 = (char *)operator new(16 * v12);
    uint64_t v14 = &v13[16 * v9];
    long long v15 = *a2;
    *(_OWORD *)uint64_t v14 = *a2;
    if (*((void *)&v15 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v15 + 1) + 8), 1uLL, memory_order_relaxed);
      id v8 = *(void **)a1;
      uint64_t v5 = *(void **)(a1 + 8);
    }
    ssize_t v16 = &v13[16 * v12];
    uint64_t v7 = v14 + 16;
    if (v5 == v8)
    {
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v7;
      *(void *)(a1 + 16) = v16;
    }
    else
    {
      do
      {
        long long v17 = *((_OWORD *)v5 - 1);
        v5 -= 2;
        *((_OWORD *)v14 - 1) = v17;
        v14 -= 16;
        *uint64_t v5 = 0;
        v5[1] = 0;
      }
      while (v5 != v8);
      id v8 = *(void **)a1;
      uint64_t v18 = *(void **)(a1 + 8);
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v7;
      *(void *)(a1 + 16) = v16;
      while (v18 != v8)
      {
        uint64_t v19 = (std::__shared_weak_count *)*(v18 - 1);
        if (v19) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v19);
        }
        v18 -= 2;
      }
    }
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    uint64_t v6 = *((void *)a2 + 1);
    *uint64_t v5 = *(void *)a2;
    v5[1] = v6;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v7 = v5 + 2;
  }
  *(void *)(a1 + 8) = v7;
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<vision::mod::ImageAnalyzer_CustomClassifier>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    unint64_t v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v5);
        }
        v3 -= 16;
      }
      while (v3 != v1);
      unint64_t v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<vision::mod::ImageAnalyzer_CustomClassifier>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753BD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<vision::mod::ImageAnalyzer_CustomClassifier>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753BD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A3FF90C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a13);

  _Block_object_dispose(&a25, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__27394(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__27395(uint64_t a1)
{
}

void sub_1A3FF9220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A3FF96C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33,void *a34,void *a35,void *a36,void *a37,void *a38)
{
  _Unwind_Resume(a1);
}

void sub_1A3FFCE14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24)
{
  _Unwind_Resume(a1);
}

void sub_1A3FFCFA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A3FFD144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,void *a34)
{
  free(a32);
  free(a34);

  _Unwind_Resume(a1);
}

void sub_1A3FFEFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,void *a34,char a35)
{
  std::__hash_table<std::__hash_value_type<std::string,std::vector<float>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<float>>>>::~__hash_table((uint64_t)&a35);
  _Unwind_Resume(a1);
}

void sub_1A3FFF4BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v11 = va_arg(va1, void **);
  uint64_t v13 = va_arg(va1, void);
  std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100]((void ***)va);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)va1);
  unint64_t v10 = *(std::__shared_weak_count **)(v8 - 112);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FFF7D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v11 = va_arg(va1, void **);
  uint64_t v13 = va_arg(va1, void);
  std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100]((void ***)va);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)va1);
  unint64_t v10 = *(std::__shared_weak_count **)(v8 - 112);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FFFAF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v11 = va_arg(va1, void **);
  uint64_t v13 = va_arg(va1, void);
  std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100]((void ***)va);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)va1);
  unint64_t v10 = *(std::__shared_weak_count **)(v8 - 112);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }

  _Unwind_Resume(a1);
}

void sub_1A3FFFEF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, long long **a3)
{
  unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    unint64_t v12 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (std::string::size_type i = *v12; i; std::string::size_type i = *(void **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v8)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  long long v15 = (void *)(a1 + 16);
  std::string::size_type i = operator new(0x40uLL);
  v28[0] = i;
  v28[1] = a1 + 16;
  *(void *)std::string::size_type i = 0;
  *((void *)i + 1) = v8;
  ssize_t v16 = *a3;
  long long v17 = **a3;
  *((void *)i + 4) = *((void *)*a3 + 2);
  *((_OWORD *)i + 1) = v17;
  *((void *)v16 + 1) = 0;
  *((void *)v16 + 2) = 0;
  *(void *)ssize_t v16 = 0;
  *((void *)i + 6) = 0;
  *((void *)i + 7) = 0;
  *((void *)i + 5) = 0;
  char v29 = 1;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    BOOL v20 = 1;
    if (v9 >= 3) {
      BOOL v20 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v9);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__rehash<true>(a1, v23);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v24 = *(void *)a1;
  uint64_t v25 = *(void **)(*(void *)a1 + 8 * v3);
  if (v25)
  {
    *(void *)std::string::size_type i = *v25;
LABEL_38:
    *uint64_t v25 = i;
    goto LABEL_39;
  }
  *(void *)std::string::size_type i = *v15;
  *long long v15 = i;
  *(void *)(v24 + 8 * v3) = v15;
  if (*(void *)i)
  {
    unint64_t v26 = *(void *)(*(void *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v26 >= v9) {
        v26 %= v9;
      }
    }
    else
    {
      v26 &= v9 - 1;
    }
    uint64_t v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_38;
  }
LABEL_39:
  v28[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v28);
  return i;
}

void sub_1A4000214(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A40005E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A4000548);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A4000818(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400092C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4000CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

void sub_1A4000E38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4001314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  }

  _Unwind_Resume(a1);
}

void sub_1A4001668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a10);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a15);
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_72c74_ZTSNSt3__110shared_ptrIN6vision3mod33ImageClassifier_HierarchicalModelEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 80);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_ea8_72c74_ZTSNSt3__110shared_ptrIN6vision3mod33ImageClassifier_HierarchicalModelEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 80);
  *(void *)(result + 72) = *(void *)(a2 + 72);
  *(void *)(result + 80) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1A4001B98(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_unfair_lock_s *a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,char *a27)
{
  a27 = &a13;
  std::vector<std::pair<std::string,BOOL>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a27);
  objc_begin_catch(a1);
  os_unfair_lock_unlock(a11 + 66);
  objc_exception_rethrow();
}

void sub_1A4001C64(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<std::vector<std::tuple<std::string,float,BOOL>> const,std::allocator<std::vector<std::tuple<std::string,float,BOOL>> const>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  std::vector<std::pair<std::string,BOOL>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void std::__shared_ptr_emplace<std::vector<std::tuple<std::string,float,BOOL>> const,std::allocator<std::vector<std::tuple<std::string,float,BOOL>> const>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7533B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<std::vector<std::tuple<std::string,float,BOOL>> const,std::allocator<std::vector<std::tuple<std::string,float,BOOL>> const>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7533B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A4001E08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40020C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose((const void *)(v34 - 160), 8);

  _Unwind_Resume(a1);
}

void sub_1A4002468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40024D0()
{
}

void sub_1A4002590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4003888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, id *a15, id *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,void *a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,id *a44,uint64_t a45,void *a46)
{
  objc_destroyWeak(a16);
  objc_destroyWeak(a15);

  _Block_object_dispose(&STACK[0x4C0], 8);
  _Block_object_dispose(&STACK[0x4E0], 8);

  _Block_object_dispose(&STACK[0x510], 8);
  objc_destroyWeak((id *)&STACK[0x540]);
  _Block_object_dispose(&STACK[0x548], 8);
  _Block_object_dispose(&STACK[0x580], 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__405(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A4003EF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40041F4()
{
}

void sub_1A4004248(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  objc_end_catch();

  JUMPOUT(0x1A4004294);
}

void sub_1A40044D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40047B4()
{
}

void sub_1A40047D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21)
{
  objc_end_catch();

  JUMPOUT(0x1A4004854);
}

void sub_1A40047EC(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A4004778);
}

void sub_1A40047F8(_Unwind_Exception *a1)
{
}

void sub_1A4004A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20)
{
  _Block_object_dispose((const void *)(v21 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1A4004D34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _recordBestClassificationObservations(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v4 = a2;
  uint64_t v5 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v15;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v15 != v6) {
          objc_enumerationMutation(v4);
        }
        unint64_t v8 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        unint64_t v9 = objc_msgSend(v8, "identifier", (void)v14);
        uint8x8_t v10 = [v3 objectForKeyedSubscript:v9];
        if (!v10 || ([v8 confidence], float v12 = v11, objc_msgSend(v10, "confidence"), v12 > v13)) {
          [v3 setObject:v8 forKeyedSubscript:v9];
        }
      }
      uint64_t v5 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }
    while (v5);
  }
}

void sub_1A4004F40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4005078(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4005124(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4005348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_1A4005F1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20,void *a21,void *a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30)
{
  vision::mod::ImageAnalyzer_Options::~ImageAnalyzer_Options((vision::mod::ImageAnalyzer_Options *)&a30);
  _Unwind_Resume(a1);
}

void _configureImageAnalyzerOptionsForSceneNetV3ObjDetNet(vision::mod::ImageAnalyzer_Options *a1)
{
  v208[0] = *MEMORY[0x1E4F143B8];
  *((_DWORD *)a1 + 113) = 1065353216;
  *((unsigned char *)a1 + 461) = 0;
  *(_OWORD *)((char *)a1 + 424) = xmmword_1A410C3E0;
  uint64_t v2 = operator new(8uLL);
  int v98 = v2;
  void *v2 = 0x3DA05BC03E1B3D08;
  uint64_t v99 = (uint64_t)(v2 + 1);
  BOOL v100 = v2 + 1;
  id v3 = (int32x2_t *)operator new(8uLL);
  float v101 = v3;
  *id v3 = vdup_n_s32(0x3DD70A3Du);
  float v102 = v3 + 1;
  unsigned int v103 = v3 + 1;
  id v4 = operator new(8uLL);
  uint64_t v104 = v4;
  void *v4 = 0x3E147AE13D92A305;
  uint64_t v105 = v4 + 1;
  uint64_t v106 = v4 + 1;
  uint64_t v5 = operator new(8uLL);
  uint64_t v107 = v5;
  *uint64_t v5 = 0x3DCAF4F13E441893;
  uint64_t v108 = v5 + 1;
  uint64_t v109 = v5 + 1;
  uint64_t v6 = (int32x2_t *)operator new(8uLL);
  uint64_t v110 = v6;
  int32x2_t *v6 = vdup_n_s32(0x3E07E282u);
  float v111 = v6 + 1;
  v112[0] = v6 + 1;
  unint64_t v7 = operator new(8uLL);
  v112[1] = v7;
  void *v7 = 0x3E3B7E913DB9C0ECLL;
  v112[2] = v7 + 1;
  v112[3] = v7 + 1;
  unint64_t v8 = operator new(8uLL);
  v112[4] = v8;
  *unint64_t v8 = 0x3E004EA53E778034;
  v112[5] = v8 + 1;
  v112[6] = v8 + 1;
  unint64_t v9 = (int32x2_t *)operator new(8uLL);
  v112[7] = v9;
  *unint64_t v9 = vdup_n_s32(0x3E2B9F56u);
  v112[8] = v9 + 1;
  v112[9] = v9 + 1;
  uint8x8_t v10 = operator new(8uLL);
  uint64_t v113 = v10;
  *uint8x8_t v10 = 0x3E6CA57A3DEAE7D5;
  v114[0] = v10 + 1;
  v114[1] = v10 + 1;
  uint64_t v197 = 0;
  uint64_t v198 = 0;
  uint64_t v196 = 0;
  std::string __p = &v196;
  LOBYTE(v170) = 0;
  uint64_t v196 = operator new(0xD8uLL);
  uint64_t v197 = v196;
  uint64_t v198 = v196 + 27;
  uint64_t v197 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>((uint64_t)&v198, (uint64_t)&v98, (uint64_t)&v115, v196);
  float v11 = operator new(8uLL);
  std::string __p = v11;
  *float v11 = 0x3E147AE13E98BAC7;
  long long v171 = v11 + 1;
  BOOL v170 = v11 + 1;
  long long v172 = 0;
  long long v174 = 0;
  long long v173 = 0;
  float v12 = (int32x2_t *)operator new(8uLL);
  long long v172 = v12;
  *float v12 = vdup_n_s32(0x3E58ADACu);
  long long v174 = v12 + 1;
  long long v173 = v12 + 1;
  uint64_t v175 = 0;
  long long v177 = 0;
  unint64_t v176 = 0;
  float v13 = operator new(8uLL);
  uint64_t v175 = v13;
  *float v13 = 0x3E9C28F63E1B3D08;
  long long v177 = v13 + 1;
  unint64_t v176 = v13 + 1;
  long long v178 = 0;
  long long v180 = 0;
  long long v179 = 0;
  long long v14 = operator new(8uLL);
  long long v178 = v14;
  *long long v14 = 0x3E3B7E913EC0AA65;
  long long v180 = v14 + 1;
  long long v179 = v14 + 1;
  long long v181 = 0;
  uint64_t v183 = 0;
  uint64_t v182 = 0;
  long long v15 = (int32x2_t *)operator new(8uLL);
  long long v181 = v15;
  *long long v15 = vdup_n_s32(0x3E88C155u);
  uint64_t v183 = v15 + 1;
  uint64_t v182 = v15 + 1;
  int64_t v184 = 0;
  size_t v186 = 0;
  float v185 = 0;
  long long v16 = operator new(8uLL);
  int64_t v184 = v16;
  *long long v16 = 0x3EC4F7663E441893;
  size_t v186 = v16 + 1;
  float v185 = v16 + 1;
  long long v187 = 0;
  int v189 = 0;
  float v188 = 0;
  long long v17 = operator new(8uLL);
  long long v187 = v17;
  void *v17 = 0x3E6CA57A3EF2F1AALL;
  int v189 = v17 + 1;
  float v188 = v17 + 1;
  int v190 = 0;
  uint64_t v192 = 0;
  uint64_t v191 = 0;
  float v18 = (int32x2_t *)operator new(8uLL);
  int v190 = v18;
  *float v18 = vdup_n_s32(0x3EAC7E28u);
  uint64_t v192 = v18 + 1;
  uint64_t v191 = v18 + 1;
  int v193 = 0;
  uint64_t v195 = 0;
  uint64_t v194 = 0;
  uint64_t v19 = operator new(8uLL);
  int v193 = v19;
  void *v19 = 0x3EF85F073E778034;
  uint64_t v195 = v19 + 1;
  uint64_t v194 = v19 + 1;
  int v200 = 0;
  uint64_t v201 = 0;
  uint64_t v199 = 0;
  *(void *)&long long v143 = &v199;
  BYTE8(v143) = 0;
  uint64_t v199 = operator new(0xD8uLL);
  int v200 = v199;
  uint64_t v201 = v199 + 27;
  int v200 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>((uint64_t)&v201, (uint64_t)&__p, (uint64_t)&v196, v199);
  BOOL v20 = operator new(8uLL);
  *(void *)&long long v143 = v20;
  *BOOL v20 = 0x3E9C28F63F1AE148;
  double v144 = v20 + 1;
  *((void *)&v143 + 1) = v20 + 1;
  float v145 = 0;
  uint64_t v147 = 0;
  float v146 = 0;
  uint64_t v21 = (int32x2_t *)operator new(8uLL);
  float v145 = v21;
  *uint64_t v21 = vdup_n_s32(0x3ED9999Au);
  uint64_t v147 = v21 + 1;
  float v146 = v21 + 1;
  uint64_t v148 = 0;
  long long v150 = 0;
  BOOL v149 = 0;
  unint64_t v22 = operator new(8uLL);
  uint64_t v148 = v22;
  *unint64_t v22 = 0x3F192A303E98BAC7;
  long long v150 = v22 + 1;
  BOOL v149 = v22 + 1;
  float v151 = 0;
  long long v153 = 0;
  long long v152 = 0;
  size_t v23 = operator new(8uLL);
  float v151 = v23;
  *size_t v23 = 0x3EC4F7663F4339C1;
  long long v153 = v23 + 1;
  long long v152 = v23 + 1;
  long long v154 = 0;
  unint64_t v156 = 0;
  long long v155 = 0;
  uint64_t v24 = (int32x2_t *)operator new(8uLL);
  long long v154 = v24;
  *uint64_t v24 = vdup_n_s32(0x3F092A30u);
  unint64_t v156 = v24 + 1;
  long long v155 = v24 + 1;
  unint64_t v157 = 0;
  unint64_t v159 = 0;
  uint64_t v158 = 0;
  uint64_t v25 = operator new(8uLL);
  unint64_t v157 = v25;
  *uint64_t v25 = 0x3F4113403EC0AA65;
  unint64_t v159 = v25 + 1;
  uint64_t v158 = v25 + 1;
  uint64_t v160 = 0;
  float v162 = 0;
  float v161 = 0;
  unint64_t v26 = operator new(8uLL);
  uint64_t v160 = v26;
  *unint64_t v26 = 0x3EF85F073F7617C2;
  float v162 = v26 + 1;
  float v161 = v26 + 1;
  float v163 = 0;
  int v165 = 0;
  uint64_t v164 = 0;
  uint64_t v27 = (int32x2_t *)operator new(8uLL);
  float v163 = v27;
  *uint64_t v27 = vdup_n_s32(0x3F2CF41Fu);
  int v165 = v27 + 1;
  uint64_t v164 = v27 + 1;
  unint64_t v166 = 0;
  uint64_t v168 = 0;
  float v167 = 0;
  uint64_t v28 = operator new(8uLL);
  unint64_t v166 = v28;
  *uint64_t v28 = 0x3F7361133EF2F1AALL;
  uint64_t v168 = v28 + 1;
  float v167 = v28 + 1;
  int v203 = 0;
  float v204 = 0;
  BOOL v202 = 0;
  int8x8_t v116 = &v202;
  LOBYTE(v117) = 0;
  BOOL v202 = operator new(0xD8uLL);
  int v203 = v202;
  float v204 = v202 + 27;
  int v203 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>((uint64_t)&v204, (uint64_t)&v143, (uint64_t)&__p, v202);
  char v29 = operator new(8uLL);
  int8x8_t v116 = (void **)v29;
  *char v29 = 0x3F192A303F9A3D71;
  int v117 = v29 + 1;
  int v118 = v29 + 1;
  BOOL v119 = 0;
  float v120 = 0;
  float v121 = 0;
  uint64_t v30 = (int32x2_t *)operator new(8uLL);
  BOOL v119 = v30;
  *uint64_t v30 = vdup_n_s32(0x3F5A0275u);
  float v120 = v30 + 1;
  float v121 = v30 + 1;
  float32x2_t v122 = 0;
  uint64_t v123 = 0;
  uint64_t v124 = 0;
  uint64_t v31 = operator new(8uLL);
  float32x2_t v122 = v31;
  void *v31 = 0x3F9B15B53F1AE148;
  uint64_t v123 = v31 + 1;
  uint64_t v124 = v31 + 1;
  uint64_t v125 = 0;
  uint64_t v126 = 0;
  uint64_t v127 = 0;
  uint64_t v32 = operator new(8uLL);
  uint64_t v125 = v32;
  void *v32 = 0x3F4113403FC2617CLL;
  uint64_t v126 = v32 + 1;
  uint64_t v127 = v32 + 1;
  uint64_t v128 = 0;
  uint64_t v129 = 0;
  float v130 = 0;
  uint64_t v33 = (int32x2_t *)operator new(8uLL);
  uint64_t v128 = v33;
  *uint64_t v33 = vdup_n_s32(0x3F89652Cu);
  uint64_t v129 = v33 + 1;
  float v130 = v33 + 1;
  unint64_t v131 = 0;
  uint64_t v132 = 0;
  int v133 = 0;
  uint64_t v34 = operator new(8uLL);
  unint64_t v131 = v34;
  *uint64_t v34 = 0x3FC374BC3F4339C1;
  uint64_t v132 = v34 + 1;
  int v133 = v34 + 1;
  int v134 = 0;
  int v135 = 0;
  float v136 = 0;
  unint64_t v35 = operator new(8uLL);
  int v134 = v35;
  *unint64_t v35 = 0x3F7361133FF4F41FLL;
  int v135 = v35 + 1;
  float v136 = v35 + 1;
  float v137 = 0;
  BOOL v138 = 0;
  long long v139 = 0;
  int v36 = (int32x2_t *)operator new(8uLL);
  float v137 = v36;
  *int v36 = vdup_n_s32(0x3FAD2BD4u);
  BOOL v138 = v36 + 1;
  long long v139 = v36 + 1;
  int v140 = 0;
  int v141 = 0;
  float64x2_t v142 = 0;
  int v37 = operator new(8uLL);
  int v140 = v37;
  *int v37 = 0x3FF64F763F7617C2;
  float64x2_t v142 = v37 + 1;
  int v141 = v37 + 1;
  __float2 v206 = 0;
  int v207 = 0;
  float v205 = 0;
  float64x2_t v96 = (void **)&v205;
  char v97 = 0;
  float v205 = operator new(0xD8uLL);
  __float2 v206 = v205;
  int v207 = v205 + 27;
  __float2 v206 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>((uint64_t)&v207, (uint64_t)&v116, (uint64_t)&v143, v205);
  uint64_t v38 = (void *)((char *)a1 + 552);
  int v39 = (uint64_t *)*((void *)a1 + 67);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a1 + 69) - (void)v39) >> 3) < 4)
  {
    std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a1 + 67);
    unint64_t v40 = 0x5555555555555556 * ((uint64_t)(*v38 - *((void *)a1 + 67)) >> 3);
    if (v40 <= 4) {
      unint64_t v40 = 4;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v38 - *((void *)a1 + 67)) >> 3) >= 0x555555555555555) {
      unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v41 = v40;
    }
    std::vector<std::vector<std::vector<float>>>::__vallocate[abi:ne180100]((void *)a1 + 67, v41);
    uint64_t v42 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>> const*,std::vector<std::vector<float>> const*,std::vector<std::vector<float>>*>((uint64_t)a1 + 552, (uint64_t *)&v196, v208, *((void **)a1 + 68));
LABEL_16:
    *((void *)a1 + 68) = v42;
    goto LABEL_25;
  }
  uint64_t v43 = (uint64_t *)*((void *)a1 + 68);
  unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * (v43 - v39);
  if (v44 < 4)
  {
    if (v43 != v39)
    {
      uint64_t v45 = 8 * (v43 - v39);
      uint64_t v46 = (uint64_t *)&v196;
      do
      {
        if (v46 != v39) {
          std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v39, *v46, v46[1], 0xAAAAAAAAAAAAAAABLL * ((v46[1] - *v46) >> 3));
        }
        v46 += 3;
        v39 += 3;
        v45 -= 24;
      }
      while (v45);
      int v39 = (uint64_t *)*((void *)a1 + 68);
    }
    uint64_t v42 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>> const*,std::vector<std::vector<float>> const*,std::vector<std::vector<float>>*>((uint64_t)a1 + 552, (uint64_t *)&(&v196)[3 * v44], v208, v39);
    goto LABEL_16;
  }
  for (uint64_t i = 0; i != 12; i += 3)
  {
    if (&v196 != (void **)v39) {
      std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(&v39[i], (uint64_t)(&v196)[i], (uint64_t)(&v196)[i + 1], 0xAAAAAAAAAAAAAAABLL * ((&v196)[i + 1] - (&v196)[i]));
    }
  }
  uint64_t v48 = (void **)(v39 + 12);
  uint64_t v49 = (void **)*((void *)a1 + 68);
  while (v49 != v48)
  {
    v49 -= 3;
    float64x2_t v96 = v49;
    std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v96);
  }
  *((void *)a1 + 68) = v48;
LABEL_25:
  for (uint64_t j = 9; j != -3; j -= 3)
  {
    float64x2_t v96 = (void **)&(&v196)[j];
    std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v96);
  }
  for (uint64_t k = 0; k != -27; k -= 3)
  {
    uint64_t v52 = (&v140)[k];
    if (v52)
    {
      (&v141)[k] = v52;
      operator delete(v52);
    }
  }
  for (uint64_t m = 0; m != -27; m -= 3)
  {
    uint64_t v54 = (&v166)[m];
    if (v54)
    {
      (&v167)[m] = v54;
      operator delete(v54);
    }
  }
  for (uint64_t n = 0; n != -27; n -= 3)
  {
    int v56 = (&v193)[n];
    if (v56)
    {
      (&v194)[n] = v56;
      operator delete(v56);
    }
  }
  for (iuint64_t i = 0; ii != -27; ii -= 3)
  {
    uint64_t v58 = (void *)v114[ii - 1];
    if (v58)
    {
      v114[ii] = v58;
      operator delete(v58);
    }
  }
  unint64_t v59 = *((void *)a1 + 54);
  uint64_t v60 = (char *)*((void *)a1 + 65);
  uint64_t v61 = *((void *)a1 + 64);
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v60[-v61] >> 3);
  unint64_t v63 = v59 - v62;
  if (v59 > v62)
  {
    uint64_t v64 = *((void *)a1 + 66);
    if (0xAAAAAAAAAAAAAAABLL * ((v64 - (uint64_t)v60) >> 3) >= v63)
    {
      bzero(*((void **)a1 + 65), 24 * ((24 * v63 - 24) / 0x18) + 24);
      *((void *)a1 + 65) = &v60[24 * ((24 * v63 - 24) / 0x18) + 24];
      goto LABEL_66;
    }
    if (v59 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * ((v64 - v61) >> 3);
    if (2 * v65 > v59) {
      unint64_t v59 = 2 * v65;
    }
    if (v65 >= 0x555555555555555) {
      unint64_t v66 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v66 = v59;
    }
    int v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v66);
    uint64_t v68 = &v67[24 * v62];
    int v70 = &v67[24 * v69];
    bzero(v68, 24 * ((24 * v63 - 24) / 0x18) + 24);
    int v71 = &v68[24 * ((24 * v63 - 24) / 0x18) + 24];
    uint64_t v72 = (void *)*((void *)a1 + 65);
    uint64_t v73 = (void *)*((void *)a1 + 64);
    if (v72 == v73)
    {
      *((void *)a1 + 64) = v68;
      *((void *)a1 + 65) = v71;
      *((void *)a1 + 66) = v70;
      if (!v72) {
        goto LABEL_66;
      }
    }
    else
    {
      do
      {
        *((void *)v68 - 3) = 0;
        *((void *)v68 - 2) = 0;
        v68 -= 24;
        *((void *)v68 + 2) = 0;
        long long v74 = *(_OWORD *)(v72 - 3);
        v72 -= 3;
        *(_OWORD *)uint64_t v68 = v74;
        *((void *)v68 + 2) = v72[2];
        *uint64_t v72 = 0;
        v72[1] = 0;
        v72[2] = 0;
      }
      while (v72 != v73);
      int v75 = (void *)*((void *)a1 + 64);
      uint64_t v72 = (void *)*((void *)a1 + 65);
      *((void *)a1 + 64) = v68;
      *((void *)a1 + 65) = v71;
      *((void *)a1 + 66) = v70;
      if (v72 != v75)
      {
        do
        {
          v72 -= 3;
          int v98 = v72;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v98);
        }
        while (v72 != v75);
        uint64_t v72 = v75;
      }
      if (!v72) {
        goto LABEL_66;
      }
    }
    operator delete(v72);
    goto LABEL_66;
  }
  if (v59 < v62)
  {
    uint64_t v76 = (char *)(v61 + 24 * v59);
    while (v60 != v76)
    {
      v60 -= 24;
      int v98 = v60;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v98);
    }
    *((void *)a1 + 65) = v76;
  }
LABEL_66:
  if (*((void *)a1 + 54))
  {
    uint64_t v77 = 0;
    unint64_t v78 = 0;
    int v94 = *(void **)(MEMORY[0x1E4FBA418] + 24);
    float32x2_t v95 = (void *)*MEMORY[0x1E4FBA418];
    do
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v98);
      char v79 = *((unsigned char *)a1 + 415);
      if (v79 >= 0) {
        int v80 = (char *)a1 + 392;
      }
      else {
        int v80 = (char *)*((void *)a1 + 49);
      }
      if (v79 >= 0) {
        uint64_t v81 = *((unsigned __int8 *)a1 + 415);
      }
      else {
        uint64_t v81 = *((void *)a1 + 50);
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v98, (uint64_t)v80, v81);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v98, (uint64_t)"_scale_", 7);
      uint64_t v82 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v82, (uint64_t)"/", 1);
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&__p, (uint64_t)&v99);
      std::vector<std::string>::resize((std::vector<std::string> *)(*((void *)a1 + 64) + v77), 2uLL);
      int v83 = SHIBYTE(v171);
      if (SHIBYTE(v171) >= 0) {
        size_t v84 = HIBYTE(v171);
      }
      else {
        size_t v84 = (size_t)v170;
      }
      std::string::basic_string[abi:ne180100]((uint64_t)&v143, v84 + 7);
      if (SHIBYTE(v144) >= 0) {
        float v85 = &v143;
      }
      else {
        float v85 = (long long *)v143;
      }
      if (v84)
      {
        if (v83 >= 0) {
          p_p = &__p;
        }
        else {
          p_p = __p;
        }
        memmove(v85, p_p, v84);
      }
      strcpy((char *)v85 + v84, "offsets");
      uint64_t v87 = *(void *)(*((void *)a1 + 64) + v77);
      if (*(char *)(v87 + 23) < 0) {
        operator delete(*(void **)v87);
      }
      long long v88 = v143;
      *(void *)(v87 + 16) = v144;
      *(_OWORD *)uint64_t v87 = v88;
      std::string::basic_string[abi:ne180100]((uint64_t)&v143, v84 + 6);
      if (SHIBYTE(v144) >= 0) {
        int v89 = &v143;
      }
      else {
        int v89 = (long long *)v143;
      }
      if (v84)
      {
        if (v83 >= 0) {
          int v90 = &__p;
        }
        else {
          int v90 = __p;
        }
        memmove(v89, v90, v84);
      }
      strcpy((char *)v89 + v84, "scores");
      uint64_t v91 = *(void *)(*((void *)a1 + 64) + v77);
      uint64_t v92 = v91 + 24;
      if (*(char *)(v91 + 47) < 0) {
        operator delete(*(void **)v92);
      }
      *(_OWORD *)uint64_t v92 = v143;
      *(void *)(v92 + 16) = v144;
      if (v83 < 0) {
        operator delete(__p);
      }
      int v98 = v95;
      *(void **)((char *)&v98 + *((void *)v95 - 3)) = v94;
      uint64_t v99 = MEMORY[0x1E4FBA470] + 16;
      if (SHIBYTE(v109) < 0) {
        operator delete(v107);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x1A6256200](v112);
      ++v78;
      v77 += 24;
    }
    while (v78 < *((void *)a1 + 54));
  }
  *((_DWORD *)a1 + 104) = 30;
  std::string::basic_string[abi:ne180100]<0>(&v98, "aircraft");
  float v93 = (uint64_t **)((char *)a1 + 560);
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1036831949;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "automobile");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1045556101;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "bicycle");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1045220557;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "bird");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1042536202;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "bottle");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1036831949;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "bus");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1045891645;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "canine");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1041865114;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "consumer_electronics");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1047233823;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "feline");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1043207291;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "fruit");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1041932222;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "vegetable");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1041932222;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "furniture");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1038174126;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "headgear");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1043207291;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "kite");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1045891645;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "fish");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1044549468;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "seafood");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1044549468;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "computer_monitor");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1042200658;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "motorcycle");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1045891645;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "musical_instrument");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1044019308;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "document");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1036831949;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "people");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1039784739;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "food");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1040187392;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "sign");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1041194025;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "watersport");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1045891645;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "train");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1046025863;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "ungulate");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1041999331;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "watercraft");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1045287666;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "flower");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1042536202;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "appliance");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1038174126;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "sports_equipment");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1038174126;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  std::string::basic_string[abi:ne180100]<0>(&v98, "tool");
  std::string __p = &v98;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v93, &v98, (_OWORD **)&__p)+ 14) = 1038174126;
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
}

void sub_1A40078AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  *(void *)(v48 + 544) = v49;
  for (uint64_t i = 72; i != -24; i -= 24)
  {
    a13 = v50 - 192 + i;
    std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  }
  uint64_t v53 = 0;
  while (1)
  {
    uint64_t v54 = *(void **)(&a48 + v53 + 192);
    if (v54)
    {
      *(void *)(&a48 + v53 + 200) = v54;
      operator delete(v54);
    }
    v53 -= 24;
    if (v53 == -216)
    {
      uint64_t v55 = 0;
      while (1)
      {
        int v56 = *(void **)((char *)&STACK[0x210] + v55 + 192);
        if (v56)
        {
          *(unint64_t *)((char *)&STACK[0x210] + v55 + 200) = (unint64_t)v56;
          operator delete(v56);
        }
        v55 -= 24;
        if (v55 == -216)
        {
          uint64_t v57 = 0;
          while (1)
          {
            uint64_t v58 = *(void **)((char *)&STACK[0x2E8] + v57 + 192);
            if (v58)
            {
              *(unint64_t *)((char *)&STACK[0x2E8] + v57 + 200) = (unint64_t)v58;
              operator delete(v58);
            }
            v57 -= 24;
            if (v57 == -216)
            {
              uint64_t v59 = 0;
              while (1)
              {
                uint64_t v60 = *(void **)((char *)&__p + v59 + 192);
                if (v60)
                {
                  *(void **)((char *)&__p + v59 + 200) = v60;
                  operator delete(v60);
                }
                v59 -= 24;
                if (v59 == -216) {
                  _Unwind_Resume(a1);
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_1A4007E70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void vision::mod::ImageAnalyzer::initHasher()
{
}

void sub_1A4007F88(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x1081C40D47BEB4BLL);
  _Unwind_Resume(a1);
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v4 = a4;
  uint8x8_t v10 = a4;
  float v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      void *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 2);
      id v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A400804C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::vector<std::string>::resize(std::vector<std::string> *this, std::vector<std::string>::size_type __sz)
{
  begiuint64_t n = this->__begin_;
  std::vector<std::string>::pointer end = this->__end_;
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)this->__begin_) >> 3);
  unint64_t v6 = __sz - v5;
  if (__sz <= v5)
  {
    if (__sz < v5)
    {
      long long v15 = &begin[__sz];
      while (end != v15)
      {
        if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(end[-1].__r_.__value_.__l.__data_);
        }
        --end;
      }
      this->__end_ = v15;
    }
  }
  else
  {
    value = this->__end_cap_.__value_;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)end) >> 3) >= v6)
    {
      size_t v16 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(this->__end_, v16);
      this->__end_ = (std::vector<std::string>::pointer)((char *)end + v16);
    }
    else
    {
      if (__sz > 0xAAAAAAAAAAAAAAALL) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      __v.__end_cap_.__value_ = (std::allocator<std::string> *)&this->__end_cap_;
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)begin) >> 3);
      std::vector<std::string>::size_type v9 = 2 * v8;
      if (2 * v8 <= __sz) {
        std::vector<std::string>::size_type v9 = __sz;
      }
      if (v8 >= 0x555555555555555) {
        unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v10 = v9;
      }
      float v11 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<CGPoint>>>(v10);
      float v12 = v11 + v5;
      __v.__first_ = v11;
      __v.__begin_ = v12;
      __v.__end_cap_.__value_ = &v11[v13];
      size_t v14 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(v12, v14);
      __v.__end_ = (std::string *)((char *)v12 + v14);
      std::vector<std::string>::__swap_out_circular_buffer(this, &__v);
      std::__split_buffer<std::string>::~__split_buffer(&__v);
    }
  }
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>> const*,std::vector<std::vector<float>> const*,std::vector<std::vector<float>>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  id v4 = a4;
  unint64_t v10 = a4;
  float v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    unint64_t v6 = a2;
    do
    {
      void *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * ((v6[1] - *v6) >> 3));
      id v4 = v11 + 3;
      v11 += 3;
      v6 += 3;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A4008290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A4008418(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40084D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4008994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1A4008AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4008B70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4008C34(_Unwind_Exception *a1)
{
  unint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A4008D30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4008E24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4008F30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4009010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40091F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  _Block_object_dispose(&a17, 8);
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a24);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__510(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__511(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void sub_1A4009464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19)
{
  std::string __p = &a16;
  std::vector<std::pair<std::string,BOOL>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  std::string __p = &a19;
  std::vector<std::pair<std::string,std::vector<BOOL>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_1A4009A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1A4009BF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4009D74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4009DFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4009F6C(_Unwind_Exception *a1)
{
  unint64_t v7 = v5;

  _Unwind_Resume(a1);
}

void sub_1A400A180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400A284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400A368(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400A468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400A544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400A89C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400A964(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400A9C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A400AA10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400AA70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A400AABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400AB1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A400AB68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400ABD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A400AC1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400AC8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A400ACF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400AD60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A400ADB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400AEEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400B2E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A400B53C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400B5F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400B6BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400B8A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400B984(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400BB20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400BD40(_Unwind_Exception *a1)
{
  unint64_t v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A400BE6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400BEC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400BF24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400BF84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A400BFD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400C0F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t computeChannelGradientForX(uint64_t result, unsigned __int16 a2)
{
  int v2 = *(_DWORD *)(result + 148);
  if (v2 >= 1)
  {
    int v3 = 0;
    uint64_t v4 = result + 8 * a2;
    unint64_t v5 = *(_WORD **)(v4 + 40);
    unint64_t v6 = *(__int16 **)(v4 + 16);
    int v7 = *(_DWORD *)(result + 144);
    do
    {
      unint64_t v8 = v6 + 1;
      *unint64_t v5 = v6[1] - *v6;
      char v9 = v5 + 1;
      if (v7 >= 3)
      {
        uint64_t v10 = 0;
        int v11 = v7 - 2;
        do
        {
          __n128 result = (unsigned __int16)v6[v10 + 2];
          v5[v10 + 1] = result - v6[v10];
          ++v10;
          --v11;
        }
        while (v11);
        unint64_t v5 = (_WORD *)((char *)v5 + v10 * 2);
        char v9 = v5 + 1;
        unint64_t v6 = (__int16 *)((char *)v6 + v10 * 2);
        unint64_t v8 = v6 + 1;
      }
      __int16 v12 = *v6;
      v6 += 2;
      v5 += 2;
      *char v9 = *v8 - v12;
      ++v3;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t computeChannelGradientForY(uint64_t result, unsigned __int16 a2)
{
  uint64_t v2 = result + 8 * a2;
  int v3 = *(__int16 **)(v2 + 16);
  int v4 = *(_DWORD *)(result + 144);
  unint64_t v5 = *(_WORD **)(v2 + 64);
  if (v4 < 1)
  {
    unint64_t v8 = v3;
  }
  else
  {
    int v6 = *(_DWORD *)(result + 144);
    int v7 = v3;
    do
    {
      unint64_t v8 = v7 + 1;
      *v5++ = v7[v4] - *v7;
      ++v7;
      --v6;
    }
    while (v6);
  }
  int v9 = *(_DWORD *)(result + 148);
  if (v9 >= 3)
  {
    int v10 = v9 - 2;
    int v11 = 1;
    do
    {
      if (v4 < 1)
      {
        unint64_t v8 = v3;
      }
      else
      {
        uint64_t v12 = 0;
        LODWORD(result) = v4;
        do
        {
          v5[v12] = v3[2 * v4 + v12] - v3[v12];
          ++v12;
          __n128 result = (result - 1);
        }
        while (result);
        unint64_t v8 = &v3[v12];
        unint64_t v5 = (_WORD *)((char *)v5 + v12 * 2);
      }
      v3 += v4;
    }
    while (v11++ != v10);
  }
  if (v4 >= 1)
  {
    size_t v14 = &v3[v4];
    do
    {
      __int16 v16 = *v14++;
      __int16 v15 = v16;
      __int16 v17 = *v8++;
      *v5++ = v15 - v17;
      --v4;
    }
    while (v4);
  }
  return result;
}

void cannyEdgeWithGradientOutput(unsigned char *a1, void *a2, char *a3, char *a4, float a5, float a6)
{
  v207[5] = *MEMORY[0x1E4F143B8];
  uint64_t v206 = 0x10000000100;
  uint64_t v12 = (char *)malloc_type_calloc(0x1C0000uLL, 1uLL, 0x44DB6DABuLL);
  v192[0] = v12;
  if (!v12) {
    __assert_rtn("initializeCannyEdgeContext", "cannyEdge.c", 261, "context->blockAddress");
  }
  __int16 v16 = v12 + 786432;
  v192[1] = v12;
  v192[2] = v12 + 786432;
  __int16 v17 = v12 + 917504;
  float v18 = v12 + 0x100000;
  v192[3] = v12 + 917504;
  v192[4] = v12 + 0x100000;
  uint64_t v199 = v12 + 1179648;
  int v200 = v12 + 1310720;
  int v193 = v12;
  uint64_t v194 = v12 + 0x20000;
  uint64_t v195 = v12 + 0x40000;
  uint64_t v196 = v12 + 393216;
  uint64_t v197 = v12 + 0x80000;
  uint64_t v198 = v12 + 655360;
  uint64_t v201 = v12 + 1441792;
  BOOL v202 = v12 + 786432;
  int v203 = v12 + 1572864;
  float v204 = v12;
  if (a3) {
    uint64_t v199 = a3;
  }
  if (a4) {
    int v200 = a4;
  }
  int v19 = 0;
  BOOL v20 = (float *)v12;
  uint64_t v205 = 0;
  do
  {
    LOBYTE(v13) = *a1;
    LOBYTE(v14) = a1[4];
    uint64_t v21 = a1 + 8;
    float v22 = (float)((float)LODWORD(v14) * 0.21868) + (float)((float)LODWORD(v13) * 0.53192);
    *(float *)&unsigned int v23 = (float)a1[8];
    *(float *)&unsigned int v24 = (float)(v22 + (float)(*(float *)&v23 * 0.015195)) / 0.7658;
    *BOOL v20 = *(float *)&v24;
    LOBYTE(v24) = a1[1];
    LOBYTE(v23) = a1[5];
    *(float *)&unsigned int v25 = (float)v23 * 0.21868;
    float v26 = *(float *)&v25 + (float)((float)v24 * 0.53192);
    LOBYTE(v25) = a1[9];
    *(float *)&unsigned int v27 = (float)v25;
    *(float *)&unsigned int v28 = (float)(v26 + (float)(*(float *)&v27 * 0.015195)) / 0.7658;
    v20[1] = *(float *)&v28;
    LOBYTE(v28) = a1[2];
    LOBYTE(v27) = a1[6];
    *(float *)&unsigned int v29 = (float)v27 * 0.21868;
    float v30 = *(float *)&v29 + (float)((float)v28 * 0.53192);
    LOBYTE(v29) = a1[10];
    *(float *)&unsigned int v31 = (float)v29;
    *(float *)&unsigned int v32 = (float)(v30 + (float)(*(float *)&v31 * 0.015195)) / 0.7658;
    v20[2] = *(float *)&v32;
    LOBYTE(v32) = *a1;
    LOBYTE(v31) = a1[4];
    *(float *)&unsigned int v33 = (float)v31 * 0.53192;
    float v34 = *(float *)&v33 + (float)((float)v32 * 0.21868);
    LOBYTE(v33) = a1[8];
    *(float *)&unsigned int v35 = (float)v33;
    float v36 = v34 + (float)(*(float *)&v35 * 0.21868);
    LOBYTE(v35) = a1[12];
    *(float *)&unsigned int v37 = (float)v35;
    *(float *)&unsigned int v38 = (float)(v36 + (float)(*(float *)&v37 * 0.015195)) / 0.98448;
    v20[3] = *(float *)&v38;
    LOBYTE(v38) = a1[1];
    LOBYTE(v37) = a1[5];
    *(float *)&unsigned int v39 = (float)v37 * 0.53192;
    float v40 = *(float *)&v39 + (float)((float)v38 * 0.21868);
    LOBYTE(v39) = a1[9];
    *(float *)&unsigned int v41 = (float)v39;
    float v42 = v40 + (float)(*(float *)&v41 * 0.21868);
    LOBYTE(v41) = a1[13];
    *(float *)&unsigned int v43 = (float)v41;
    *(float *)&unsigned int v44 = (float)(v42 + (float)(*(float *)&v43 * 0.015195)) / 0.98448;
    v20[4] = *(float *)&v44;
    LOBYTE(v44) = a1[2];
    LOBYTE(v43) = a1[6];
    *(float *)&unsigned int v45 = (float)v43 * 0.53192;
    float v46 = *(float *)&v45 + (float)((float)v44 * 0.21868);
    LOBYTE(v45) = a1[10];
    *(float *)&unsigned int v47 = (float)v45;
    float v48 = v46 + (float)(*(float *)&v47 * 0.21868);
    LOBYTE(v47) = a1[14];
    v20[5] = (float)(v48 + (float)((float)v47 * 0.015195)) / 0.98448;
    uint64_t v49 = v20 + 6;
    int v50 = 2;
    do
    {
      uint64_t v51 = 0;
      uint64_t v52 = v49;
      uint64_t v53 = v21;
      *(void *)uint64_t v49 = 0;
      v49[2] = 0.0;
      float v54 = 0.0;
      float v55 = 0.0;
      float v56 = 0.0;
      do
      {
        float v57 = gaussianKernel[v51];
        LOBYTE(v15) = a1[v51 * 4];
        *(float *)&unsigned int v58 = (float)LODWORD(v15);
        float v54 = v54 + (float)(v57 * *(float *)&v58);
        *uint64_t v49 = v54;
        LOBYTE(v58) = a1[v51 * 4 + 1];
        *(float *)&unsigned int v59 = (float)v58;
        float v55 = v55 + (float)(v57 * *(float *)&v59);
        v49[1] = v55;
        LOBYTE(v59) = a1[v51 * 4 + 2];
        float v15 = (float)v59;
        float v56 = v56 + (float)(v57 * v15);
        v49[2] = v56;
        ++v51;
      }
      while (v51 != 5);
      *uint64_t v49 = v54 / 0.99967;
      v49[1] = v55 / 0.99967;
      float v60 = v56 / 0.99967;
      v49[2] = v56 / 0.99967;
      v49 += 3;
      v21 += 4;
      a1 += 4;
    }
    while (v50++ != 253);
    LOBYTE(v60) = *(v53 - 4);
    LOBYTE(v56) = *v53;
    *(float *)&unsigned int v62 = (float)LODWORD(v56) * 0.21868;
    float v63 = *(float *)&v62 + (float)((float)LODWORD(v60) * 0.015195);
    LOBYTE(v62) = v53[4];
    *(float *)&unsigned int v64 = (float)v62;
    float v65 = v63 + (float)(*(float *)&v64 * 0.53192);
    LOBYTE(v64) = v53[8];
    *(float *)&unsigned int v66 = (float)v64;
    *(float *)&unsigned int v67 = (float)(v65 + (float)(*(float *)&v66 * 0.21868)) / 0.98448;
    _OWORD v52[3] = *(float *)&v67;
    LOBYTE(v67) = *(v53 - 3);
    LOBYTE(v66) = v53[1];
    *(float *)&unsigned int v68 = (float)v66 * 0.21868;
    float v69 = *(float *)&v68 + (float)((float)v67 * 0.015195);
    LOBYTE(v68) = v53[5];
    *(float *)&unsigned int v70 = (float)v68;
    float v71 = v69 + (float)(*(float *)&v70 * 0.53192);
    LOBYTE(v70) = v53[9];
    *(float *)&unsigned int v72 = (float)v70;
    *(float *)&unsigned int v73 = (float)(v71 + (float)(*(float *)&v72 * 0.21868)) / 0.98448;
    v52[4] = *(float *)&v73;
    LOBYTE(v73) = *(v53 - 2);
    LOBYTE(v72) = v53[2];
    *(float *)&unsigned int v74 = (float)v72 * 0.21868;
    float v75 = *(float *)&v74 + (float)((float)v73 * 0.015195);
    LOBYTE(v74) = v53[6];
    *(float *)&unsigned int v76 = (float)v74;
    float v77 = v75 + (float)(*(float *)&v76 * 0.53192);
    LOBYTE(v76) = v53[10];
    *(float *)&unsigned int v78 = (float)v76;
    *(float *)&unsigned int v79 = (float)(v77 + (float)(*(float *)&v78 * 0.21868)) / 0.98448;
    v52[5] = *(float *)&v79;
    LOBYTE(v79) = *v53;
    LOBYTE(v78) = v53[4];
    *(float *)&unsigned int v80 = (float)v78 * 0.21868;
    float v81 = *(float *)&v80 + (float)((float)v79 * 0.015195);
    LOBYTE(v80) = v53[8];
    *(float *)&unsigned int v82 = (float)v80;
    *(float *)&unsigned int v83 = (float)(v81 + (float)(*(float *)&v82 * 0.53192)) / 0.7658;
    v52[6] = *(float *)&v83;
    LOBYTE(v83) = v53[1];
    LOBYTE(v82) = v53[5];
    *(float *)&unsigned int v84 = (float)v82 * 0.21868;
    float v85 = *(float *)&v84 + (float)((float)v83 * 0.015195);
    LOBYTE(v84) = v53[9];
    *(float *)&unsigned int v86 = (float)v84;
    *(float *)&unsigned int v87 = (float)(v85 + (float)(*(float *)&v86 * 0.53192)) / 0.7658;
    v52[7] = *(float *)&v87;
    LOBYTE(v87) = v53[2];
    LOBYTE(v86) = v53[6];
    *(float *)&unsigned int v88 = (float)v86 * 0.21868;
    float v89 = *(float *)&v88 + (float)((float)v87 * 0.015195);
    LOBYTE(v88) = v53[10];
    float v14 = (float)v88;
    float v13 = (float)(v89 + (float)(v14 * 0.53192)) / 0.7658;
    v52[8] = v13;
    BOOL v20 = v52 + 9;
    a1 = v53 + 12;
    ++v19;
  }
  while (v19 != 256);
  unsigned int v90 = 0;
  int v91 = 2;
  do
  {
    int v92 = 0;
    float v93 = v12;
    v207[0] = v12 - 6144;
    v207[1] = v12 - 3072;
    int v94 = v12 + 6144;
    v12 += 3072;
    v207[2] = v93;
    v207[3] = v12;
    v207[4] = v94;
    int v95 = 257 - v90;
    if (v90 < 0xFE) {
      int v95 = 4;
    }
    float64x2_t v96 = v18;
    char v97 = v17;
    int v98 = v16;
    do
    {
      float v99 = 0.0;
      float v100 = 0.0;
      float v101 = 0.0;
      float v102 = 0.0;
      if ((int)((2 - v90) & ~((int)(2 - v90) >> 31)) < v95)
      {
        uint64_t v103 = v91 & ~(v91 >> 31);
        do
        {
          uint64_t v104 = (float *)v207[v103];
          float v105 = gaussianKernel[v103];
          float v99 = v99 + (float)(v105 * *v104);
          float v100 = v100 + (float)(v105 * v104[1]);
          float v101 = v101 + (float)(v105 * v104[2]);
          float v102 = v102 + v105;
          v207[v103++] = v104 + 3;
        }
        while (v103 < v95);
      }
      double v106 = v102;
      *v98++ = (int)(v99 * 90.0 / v106 + 0.5);
      *v97++ = (int)(v100 * 90.0 / v106 + 0.5);
      *v96++ = (int)(v101 * 90.0 / v106 + 0.5);
      ++v92;
    }
    while (v92 != 256);
    ++v90;
    v16 += 256;
    v17 += 256;
    v18 += 256;
    --v91;
  }
  while (v90 != 256);
  computeChannelGradientForX((uint64_t)v192, 0);
  computeChannelGradientForX((uint64_t)v192, 1u);
  computeChannelGradientForX((uint64_t)v192, 2u);
  computeChannelGradientForY((uint64_t)v192, 0);
  computeChannelGradientForY((uint64_t)v192, 1u);
  computeChannelGradientForY((uint64_t)v192, 2u);
  int v108 = v206;
  int v107 = HIDWORD(v206);
  if (SHIDWORD(v206) >= 1)
  {
    int v109 = 0;
    float v111 = v200;
    uint64_t v110 = v201;
    uint64_t v113 = v198;
    int v112 = v199;
    uint64_t v115 = v196;
    float32x2_t v114 = v197;
    int v117 = v194;
    int8x8_t v116 = v195;
    int v118 = v193;
    do
    {
      if (v108 >= 1)
      {
        uint64_t v119 = 0;
        int v120 = v108;
        do
        {
          __int16 v121 = *(_WORD *)&v118[v119];
          __int16 v122 = *(_WORD *)&v117[v119];
          unsigned int v123 = v121 * v121 + *(__int16 *)&v115[v119] * *(__int16 *)&v115[v119];
          unsigned int v124 = v122 * v122 + *(__int16 *)&v114[v119] * *(__int16 *)&v114[v119];
          unsigned int v125 = *(__int16 *)&v116[v119] * *(__int16 *)&v116[v119] + *(__int16 *)&v113[v119] * *(__int16 *)&v113[v119];
          if (v124 > v125)
          {
            __int16 v126 = *(_WORD *)&v114[v119];
          }
          else
          {
            __int16 v122 = *(_WORD *)&v116[v119];
            __int16 v126 = *(_WORD *)&v113[v119];
          }
          if (v123 > v125)
          {
            __int16 v127 = *(_WORD *)&v115[v119];
          }
          else
          {
            __int16 v121 = *(_WORD *)&v116[v119];
            __int16 v127 = *(_WORD *)&v113[v119];
          }
          if (v123 > v124)
          {
            __int16 v128 = v127;
          }
          else
          {
            unsigned int v123 = *(__int16 *)&v117[v119] * *(__int16 *)&v117[v119] + *(__int16 *)&v114[v119] * *(__int16 *)&v114[v119];
            __int16 v121 = v122;
            __int16 v128 = v126;
          }
          if (v123 <= v125) {
            unsigned int v123 = *(__int16 *)&v116[v119] * *(__int16 *)&v116[v119] + *(__int16 *)&v113[v119] * *(__int16 *)&v113[v119];
          }
          *(_WORD *)&v112[v119] = v121;
          *(_WORD *)&v111[v119] = v128;
          *(_WORD *)&v110[v119] = (int)sqrtf((float)(int)v123 + 0.5);
          v119 += 2;
          --v120;
        }
        while (v120);
        v118 += v119;
        v117 += v119;
        v110 += v119;
        v111 += v119;
        v112 += v119;
        v113 += v119;
        v114 += v119;
        v115 += v119;
        v116 += v119;
      }
      ++v109;
    }
    while (v109 != v107);
  }
  uint64_t v129 = v202;
  if (v108 >= 1)
  {
    uint64_t v130 = 0;
    do
    {
      v129[v130] = 0;
      int v108 = v206;
      ++v130;
    }
    while ((int)v130 < (int)v206);
    v129 += v130;
    int v107 = HIDWORD(v206);
  }
  if (v107 < 3)
  {
    unsigned int v131 = 0;
    goto LABEL_72;
  }
  unsigned int v131 = 0;
  uint64_t v132 = (uint64_t)&v201[2 * v108 + 2];
  uint64_t v133 = (uint64_t)&v200[2 * v108 + 2];
  uint64_t v134 = (uint64_t)&v199[2 * v108 + 2];
  int v135 = 1;
  do
  {
    *uint64_t v129 = 0;
    float v136 = v129 + 1;
    int v137 = v206;
    if ((int)v206 < 3) {
      goto LABEL_69;
    }
    uint64_t v138 = 0;
    do
    {
      long long v139 = (unsigned __int16 *)(v132 + 2 * v138);
      int v140 = *(__int16 *)(v134 + 2 * v138);
      int v141 = (v140 >> 31) | 1;
      int v142 = *(__int16 *)(v133 + 2 * v138);
      int v143 = (v142 >> 31) | 1;
      if (v142 >= 0) {
        LOWORD(v144) = *(_WORD *)(v133 + 2 * v138);
      }
      else {
        int v144 = -v142;
      }
      if (v140 >= 0) {
        LOWORD(v145) = *(_WORD *)(v134 + 2 * v138);
      }
      else {
        int v145 = -v140;
      }
      unsigned int v146 = (unsigned __int16)v145;
      int v147 = v143 * v137;
      if (v140 >= 0) {
        uint64_t v148 = 1;
      }
      else {
        uint64_t v148 = -1;
      }
      uint64_t v149 = 2 * v148 + 2 * v147;
      __int16 v150 = *(unsigned __int16 *)((char *)v139 - v149);
      uint64_t v151 = v147 - v141;
      if (v146 >= (unsigned __int16)v144) {
        uint64_t v151 = 0;
      }
      uint64_t v152 = 2 * v151 + 2 * v148;
      __int16 v153 = *(unsigned __int16 *)((char *)v139 + v149);
      __int16 v154 = *(unsigned __int16 *)((char *)v139 - v152);
      __int16 v155 = *(unsigned __int16 *)((char *)v139 + v152);
      uint64_t v156 = *v139;
      __int16 v157 = v154 - v156;
      LOWORD(v139) = v155 - v156;
      __int16 v158 = v150 - v154;
      __int16 v159 = v153 - v155;
      float v160 = (float)v140;
      float v161 = (float)v142;
      float v162 = (float)v141;
      int v163 = v143 * v141;
      if (v146 >= (unsigned __int16)v144)
      {
        if ((float)((float)((float)(v161 * (float)(v163 * v158)) + (float)((float)v157 * v160)) * v162) >= 0.0) {
          goto LABEL_65;
        }
        float v164 = (float)(__int16)v139;
        LODWORD(v139) = v159;
      }
      else
      {
        if ((float)((float)((float)(v161 * (float)(v163 * v157)) + (float)((float)v158 * v160)) * v162) >= 0.0) {
          goto LABEL_65;
        }
        float v164 = (float)v159;
        LODWORD(v139) = (__int16)v139;
      }
      if ((float)((float)((float)(v161 * (float)(v163 * (int)v139)) + (float)(v164 * v160)) * v162) > 0.0)
      {
LABEL_65:
        char v165 = 0;
        goto LABEL_67;
      }
      ++v131;
      ++*(_DWORD *)&v203[4 * v156];
      char v165 = 0x80;
LABEL_67:
      v129[v138 + 1] = v165;
      int v137 = v206;
      ++v138;
    }
    while ((int)v138 + 1 < (int)v206 - 1);
    v129 += v138;
    float v136 = v129 + 1;
LABEL_69:
    *float v136 = 0;
    int v108 = v206;
    v134 += 2 * (int)v206;
    v129 += 2;
    ++v135;
    v133 += 2 * (int)v206;
    v132 += 2 * (int)v206;
  }
  while (v135 < HIDWORD(v206) - 1);
LABEL_72:
  if (v108 >= 1)
  {
    uint64_t v166 = 0;
    do
    {
      v129[v166] = 0;
      int v108 = v206;
      ++v166;
    }
    while ((int)v166 < (int)v206);
  }
  unsigned int v167 = 0xFFFF;
  do
  {
    unint64_t v168 = v167 - 1;
    if (v167 < 2) {
      break;
    }
  }
  while (!*(_DWORD *)&v203[4 * v167--]);
  int v170 = 1;
  if (v168 >= 2)
  {
    unsigned int v171 = (int)((float)((float)v131 * a6) + 0.5);
    unsigned int v172 = *((_DWORD *)v203 + 1);
    if (v172 < v171)
    {
      unint64_t v173 = 2;
      do
      {
        int v170 = v173;
        if (v173 >= v168) {
          break;
        }
        v172 += *(_DWORD *)&v203[4 * v173++];
      }
      while (v172 < v171);
    }
  }
  WORD2(v205) = v170;
  HIWORD(v205) = (int)((float)((float)v170 * a5) + 0.5);
  LODWORD(v205) = 0;
  int v174 = HIDWORD(v206);
  bzero(a2, v108 * HIDWORD(v206));
  if (v174 < 3)
  {
    unsigned int v180 = 0;
  }
  else
  {
    int v175 = 1;
    do
    {
      if (v108 >= 3)
      {
        int v176 = 1;
        do
        {
          uint64_t v177 = (v176 + v175 * v108);
          int v178 = *(unsigned __int16 *)&v201[2 * v177];
          if (v178 <= SHIWORD(v205))
          {
            v202[v177] = 0;
          }
          else if (v202[v177] == 128 && v178 >= SWORD2(v205))
          {
            v202[v177] = -1;
            *((unsigned char *)a2 + v177) = -1;
            *(_DWORD *)&v204[4 * v205] = v177;
            LODWORD(v205) = v205 + 1;
          }
          ++v176;
          int v108 = v206;
        }
        while (v176 < (int)v206 - 1);
        int v174 = HIDWORD(v206);
      }
      ++v175;
    }
    while (v175 < v174 - 1);
    unsigned int v180 = v205;
  }
  while (v180)
  {
    LODWORD(v205) = --v180;
    long long v181 = v202;
    int v182 = *(_DWORD *)&v204[4 * v180];
    uint64_t v183 = (v182 - 1);
    if (v202[v183] == 128)
    {
      v202[v183] = -1;
      *((unsigned char *)a2 + v183) = -1;
      *(_DWORD *)&v204[4 * v205] = v183;
      int v108 = v206;
      unsigned int v180 = v205 + 1;
      LODWORD(v205) = v205 + 1;
      long long v181 = v202;
    }
    uint64_t v184 = (v183 - v108);
    if (v181[v184] == 128)
    {
      v181[v184] = -1;
      *((unsigned char *)a2 + v184) = -1;
      *(_DWORD *)&v204[4 * v205] = v184;
      int v108 = v206;
      unsigned int v180 = v205 + 1;
      LODWORD(v205) = v205 + 1;
      long long v181 = v202;
    }
    uint64_t v185 = (v108 + v183);
    if (v181[v185] == 128)
    {
      v181[v185] = -1;
      *((unsigned char *)a2 + v185) = -1;
      *(_DWORD *)&v204[4 * v205] = v185;
      unsigned int v180 = v205 + 1;
      LODWORD(v205) = v205 + 1;
      long long v181 = v202;
    }
    uint64_t v186 = (v182 + 1);
    if (v181[v186] == 128)
    {
      v181[v186] = -1;
      *((unsigned char *)a2 + v186) = -1;
      *(_DWORD *)&v204[4 * v205] = v186;
      unsigned int v180 = v205 + 1;
      LODWORD(v205) = v205 + 1;
      long long v181 = v202;
    }
    int v108 = v206;
    uint64_t v187 = (v186 - v206);
    if (v181[v187] == 128)
    {
      v181[v187] = -1;
      *((unsigned char *)a2 + v187) = -1;
      *(_DWORD *)&v204[4 * v205] = v187;
      int v108 = v206;
      unsigned int v180 = v205 + 1;
      LODWORD(v205) = v205 + 1;
      long long v181 = v202;
    }
    uint64_t v188 = (v108 + v186);
    if (v181[v188] == 128)
    {
      v181[v188] = -1;
      *((unsigned char *)a2 + v188) = -1;
      *(_DWORD *)&v204[4 * v205] = v188;
      int v108 = v206;
      unsigned int v180 = v205 + 1;
      LODWORD(v205) = v205 + 1;
      long long v181 = v202;
    }
    uint64_t v189 = (v108 + v182);
    if (v181[v189] == 128)
    {
      v181[v189] = -1;
      *((unsigned char *)a2 + v189) = -1;
      *(_DWORD *)&v204[4 * v205] = v189;
      int v108 = v206;
      unsigned int v180 = v205 + 1;
      LODWORD(v205) = v205 + 1;
      long long v181 = v202;
    }
    uint64_t v190 = (v182 - v108);
    if (v181[v190] == 128)
    {
      v181[v190] = -1;
      *((unsigned char *)a2 + v190) = -1;
      *(_DWORD *)&v204[4 * v205] = v190;
      int v108 = v206;
      unsigned int v180 = v205 + 1;
      LODWORD(v205) = v205 + 1;
    }
    if (v180 > HIDWORD(v206) * v108) {
      __assert_rtn("thresholdAndConnectCandidateEdges", "cannyEdge.c", 725, "context->edgeStackSize <= context->width*context->height");
    }
  }
  uint64_t v191 = v192[0];

  free(v191);
}

uint64_t BresenhamCoords(int a1, int a2, uint64_t a3)
{
  int v3 = (__int16)a1;
  unsigned int v4 = (__int16)a2 - (__int16)a1;
  int v5 = a2 >> 16;
  int v6 = a1 >> 16;
  unsigned int v7 = (a2 >> 16) - (a1 >> 16);
  if ((v4 & 0x80000000) != 0)
  {
    unsigned int v15 = (__int16)a1 - (__int16)a2;
    if ((v7 & 0x80000000) != 0)
    {
      unsigned int v34 = v4 - v7;
      if (v4 > v7)
      {
        int v35 = -2 * v4;
        int v36 = 2 * (v7 - v4);
        int v37 = v7 + 2 * v15;
        uint64_t v38 = 1 - v7;
        unsigned int v39 = (_WORD *)(a3 + 2);
        do
        {
          *(v39 - 1) = v3;
          if (v37 <= 0) {
            int v40 = v35;
          }
          else {
            int v40 = v36;
          }
          LOWORD(v3) = v3 - (v37 > 0);
          _WORD *v39 = v6;
          v39 += 2;
          v37 += v40;
          --v6;
          --v38;
        }
        while (v38);
        unsigned int v4 = (a1 >> 16) - (a2 >> 16);
        return v4 + 1;
      }
      int v52 = -2 * v7;
      int v53 = 2 * v34;
      int v54 = v4 + 2 * ((a1 >> 16) - (a2 >> 16));
      uint64_t v55 = 1 - v4;
      float v56 = (_WORD *)(a3 + 2);
      do
      {
        _WORD *v56 = v6;
        if (v54 <= 0) {
          int v57 = v52;
        }
        else {
          int v57 = v53;
        }
        LOWORD(v6) = v6 - (v54 > 0);
        *(v56 - 1) = v3;
        v54 += v57;
        --v3;
        v56 += 2;
        --v55;
      }
      while (v55);
    }
    else
    {
      if (v15 < v7)
      {
        int v16 = -2 * v4;
        int v17 = 2 * (v15 - v7);
        int v18 = v16 - v7;
        uint64_t v19 = (v5 - v6 + 1);
        BOOL v20 = (_WORD *)(a3 + 2);
        do
        {
          *(v20 - 1) = v3;
          if (v18 <= 0) {
            int v21 = v16;
          }
          else {
            int v21 = v17;
          }
          LOWORD(v3) = v3 - (v18 > 0);
          *BOOL v20 = v6;
          v20 += 2;
          v18 += v21;
          ++v6;
          --v19;
        }
        while (v19);
        goto LABEL_19;
      }
      int v41 = 2 * v7;
      int v42 = 2 * (v4 + v7);
      int v43 = v4 + 2 * v7;
      uint64_t v44 = 1 - v4;
      unsigned int v45 = (_WORD *)(a3 + 2);
      do
      {
        *unsigned int v45 = v6;
        if (v43 <= 0) {
          int v46 = v41;
        }
        else {
          int v46 = v42;
        }
        if (v43 > 0) {
          LOWORD(v6) = v6 + 1;
        }
        *(v45 - 1) = v3;
        v43 += v46;
        --v3;
        v45 += 2;
        --v44;
      }
      while (v44);
    }
LABEL_63:
    unsigned int v4 = v15;
    return v4 + 1;
  }
  if ((v7 & 0x80000000) != 0)
  {
    unsigned int v15 = (a1 >> 16) - (a2 >> 16);
    if (v15 <= v4)
    {
      int v47 = -2 * v7;
      int v48 = v47 - v4;
      uint64_t v49 = ((__int16)a2 - (__int16)a1 + 1);
      int v50 = (_WORD *)(a3 + 2);
      do
      {
        _WORD *v50 = v6;
        if (v48 <= 0) {
          int v51 = v47;
        }
        else {
          int v51 = 2 * ((a1 >> 16) - (a2 >> 16) - v4);
        }
        LOWORD(v6) = v6 - (v48 > 0);
        *(v50 - 1) = v3;
        v48 += v51;
        ++v3;
        v50 += 2;
        --v49;
      }
      while (v49);
      return v4 + 1;
    }
    int v22 = 2 * v4;
    int v23 = 2 * (v4 + v7);
    int v24 = v7 + 2 * v4;
    uint64_t v25 = 1 - v7;
    float v26 = (_WORD *)(a3 + 2);
    do
    {
      *(v26 - 1) = v3;
      if (v24 <= 0) {
        int v27 = v22;
      }
      else {
        int v27 = v23;
      }
      if (v24 > 0) {
        LOWORD(v3) = v3 + 1;
      }
      *float v26 = v6;
      v26 += 2;
      v24 += v27;
      --v6;
      --v25;
    }
    while (v25);
    goto LABEL_63;
  }
  unsigned int v8 = v7 - v4;
  if (v7 > v4)
  {
    int v9 = 2 * v4;
    int v10 = 2 * (v4 - v7);
    int v11 = v9 - v7;
    uint64_t v12 = (v5 - v6 + 1);
    float v13 = (_WORD *)(a3 + 2);
    do
    {
      *(v13 - 1) = v3;
      if (v11 <= 0) {
        int v14 = v9;
      }
      else {
        int v14 = v10;
      }
      if (v11 > 0) {
        LOWORD(v3) = v3 + 1;
      }
      *float v13 = v6;
      v13 += 2;
      v11 += v14;
      ++v6;
      --v12;
    }
    while (v12);
LABEL_19:
    unsigned int v4 = (a2 >> 16) - (a1 >> 16);
    return v4 + 1;
  }
  int v28 = 2 * v7;
  int v29 = 2 * v8;
  int v30 = v28 - v4;
  uint64_t v31 = ((__int16)a2 - (__int16)a1 + 1);
  unsigned int v32 = (_WORD *)(a3 + 2);
  do
  {
    _WORD *v32 = v6;
    if (v30 <= 0) {
      int v33 = v28;
    }
    else {
      int v33 = v29;
    }
    if (v30 > 0) {
      LOWORD(v6) = v6 + 1;
    }
    *(v32 - 1) = v3;
    v30 += v33;
    ++v3;
    v32 += 2;
    --v31;
  }
  while (v31);
  return v4 + 1;
}

void sub_1A400D3CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400D58C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400DC98(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A400DCD8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  __pa = v29;
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v30);
  }
  if (__pa) {
    operator delete(__pa);
  }
  objc_begin_catch(a1);
  JUMPOUT(0x1A400D72CLL);
}

void sub_1A400E740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,void *a23,uint64_t a24)
{
  if (__p) {
    operator delete(__p);
  }
  if (a23) {
    operator delete(a23);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  if (a16 < 0) {
    operator delete(a11);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageClassifierEspresso>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierEspresso>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7537A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierEspresso>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7537A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A400EB78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400F0B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1A400F324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400F894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_1A400FAC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400FCD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A400FEA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40100EC(_Unwind_Exception *a1)
{
}

void sub_1A40102BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40103FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void vision::mod::ImageDescriptorProcessorHyperplaneLSH::encodeHash(uint64_t a1, float *a2, uint64_t a3)
{
}

void vision::mod::ImageDescriptorProcessorHyperplaneLSH::hashFeature(const float **this, const float *__B, float *__C)
{
  if (!__B || !__C)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 3709;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  vDSP_mmul(this[3], 1, __B, 1, __C, 1, *((int *)this + 3), 1uLL, *((int *)this + 2));
  float __Ba = 0.0;
  float __Ca = 1.0;
  std::vector<float>::vector(__D, *((int *)this + 3));
  vDSP_vthrsc(__C, 1, &__Ba, &__Ca, __D[0], 1, *((int *)this + 3));
  float v6 = 1.0;
  float v7 = 0.0;
  vDSP_vclip(__D[0], 1, &v7, &v6, __C, 1, *((int *)this + 3));
  if (__D[0])
  {
    __D[1] = __D[0];
    operator delete(__D[0]);
  }
}

void sub_1A4010518(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageDescriptorProcessorHasher::getDescriptorLengthInBytes(vision::mod::ImageDescriptorProcessorHasher *this)
{
  return 4 * *((int *)this + 3);
}

double vision::mod::ImageDescriptorProcessorHyperplaneLSH::createDescriptorBuffer@<D0>(vision::mod::ImageDescriptorProcessorHyperplaneLSH *this@<X0>, vision::mod::ImageDescriptorProcessorHasher *a2@<X8>)
{
  return vision::mod::ImageDescriptorProcessorHasher::createDescriptorBuffer(a2, (uint64_t)this);
}

void vision::mod::ImageDescriptorProcessorHyperplaneLSH::~ImageDescriptorProcessorHyperplaneLSH(void **this)
{
  *this = &unk_1EF752F68;
  free(this[3]);
  this[3] = 0;

  JUMPOUT(0x1A62562C0);
}

{
  *this = &unk_1EF752F68;
  free(this[3]);
  this[3] = 0;
}

FILE *tearDownAndSignalErr(float **a1, float **a2, float **a3, __sFILE **a4, uint64_t a5)
{
  free(*a1);
  *a1 = 0;
  free(*a2);
  *a2 = 0;
  free(*a3);
  *a3 = 0;
  __n128 result = *a4;
  if (*a4)
  {
    __n128 result = (FILE *)fclose(result);
    *a4 = 0;
  }
  if ((a5 & 0x80) == 0)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = a5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  return result;
}

uint64_t vision::mod::ImageDescriptorProcessorHyperplaneLSH::ImageDescriptorProcessorHyperplaneLSH(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EF752F68;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 24) = 0;
  unsigned int v4 = (float **)(a1 + 24);
  if (*(char *)(a2 + 23) >= 0) {
    int v5 = (const char *)a2;
  }
  else {
    int v5 = *(const char **)a2;
  }
  float v6 = fopen(v5, "rb");
  int v28 = v6;
  if (!v6) {
    goto LABEL_29;
  }
  float v7 = v6;
  float v26 = 0;
  int v27 = 0;
  uint64_t v24 = 1;
  uint64_t v25 = 0;
  uint64_t v8 = BinSerializer_freadInFloat(v6, "hash_size", 1, &v27, (size_t *)&v24);
  if (v8 == 384)
  {
    *(_DWORD *)(a1 + 12) = (int)*v27;
  }
  else
  {
    tearDownAndSignalErr(&v27, &v26, &v25, &v28, v8);
    float v7 = v28;
  }
  *(_DWORD *)(a1 + 16) = 1;
  if (BinSerializer_freadInFloat(v7, "num_hashes", 1, &v26, (size_t *)&v24) == 384)
  {
    *(_DWORD *)(a1 + 16) = (int)*v26;
    uint64_t v9 = BinSerializer_freadInFloat(v7, "feat_size", 1, &v25, (size_t *)&v24);
    if (v9 == 384)
    {
      int v10 = (int)*v25;
      *(_DWORD *)(a1 + 8) = v10;
    }
    else
    {
      tearDownAndSignalErr(&v27, &v26, &v25, &v28, v9);
      int v10 = *(_DWORD *)(a1 + 8);
      float v7 = v28;
    }
    uint64_t v24 = *(int *)(a1 + 12) * (uint64_t)v10;
    uint64_t v15 = BinSerializer_freadInFloat(v7, "projection_matrix", 1, v4, (size_t *)&v24);
    if (v15 != 384) {
      tearDownAndSignalErr(&v27, &v26, &v25, &v28, v15);
    }
    int v16 = &v27;
    int v17 = &v26;
    int v18 = &v25;
    uint64_t v19 = &v28;
    goto LABEL_28;
  }
  int v11 = *(char *)(a2 + 23) >= 0 ? (const char *)a2 : *(const char **)a2;
  uint64_t v12 = fopen(v11, "rb");
  int v33 = v12;
  if (!v12)
  {
LABEL_29:
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 3701;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  float v13 = v12;
  unsigned int v32 = 0;
  int v30 = 0;
  uint64_t v31 = 0;
  uint64_t v14 = BinSerializer_freadInFloat(v12, "hash_size", 1, &v32, (size_t *)&v29);
  if (v14 == 384)
  {
    *(_DWORD *)(a1 + 12) = (int)*v32;
  }
  else
  {
    tearDownAndSignalErr(&v32, &v31, &v30, &v33, v14);
    float v13 = v33;
  }
  uint64_t v20 = BinSerializer_freadInFloat(v13, "feat_size", 1, &v30, (size_t *)&v29);
  if (v20 == 384)
  {
    int v21 = (int)*v30;
    *(_DWORD *)(a1 + 8) = v21;
  }
  else
  {
    tearDownAndSignalErr(&v32, &v31, &v30, &v33, v20);
    int v21 = *(_DWORD *)(a1 + 8);
    float v13 = v33;
  }
  uint64_t v29 = *(int *)(a1 + 12) * (uint64_t)v21;
  uint64_t v15 = BinSerializer_freadInFloat(v13, "projection_matrix", 1, v4, (size_t *)&v29);
  if (v15 != 384) {
    tearDownAndSignalErr(&v32, &v31, &v30, &v33, v15);
  }
  int v16 = &v32;
  int v17 = &v31;
  int v18 = &v30;
  uint64_t v19 = &v33;
LABEL_28:
  tearDownAndSignalErr(v16, v17, v18, v19, v15);
  return a1;
}

void sub_1A4010FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  int v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNCCCharBoxContext;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A40116F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A4011884(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4011FA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4012D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,void *a31)
{
  _Unwind_Resume(a1);
}

void sub_1A4017CDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,void *__p,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,std::less<int>,true>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, unsigned int *a3)
{
  float v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        float v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        float v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        float v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    float v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v9 + 28) = *a3;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, v9);
    return v9;
  }
  return (uint64_t *)v7;
}

uint64_t **std::__tree<std::__value_type<int,__CCCharBox>,std::__map_value_compare<int,std::__value_type<int,__CCCharBox>,std::less<int>,true>,std::allocator<std::__value_type<int,__CCCharBox>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  float v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        float v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        float v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        float v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    float v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    float v7 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v7 + 7) = *a3;
    v7[4] = 0;
    *((_WORD *)v7 + 20) = 0;
    FILE *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    FILE *v6 = (uint64_t *)v7;
    int v10 = (uint64_t *)**a1;
    int v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      int v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t **std::__tree<std::__value_type<int,unsigned char>,std::__map_value_compare<int,std::__value_type<int,unsigned char>,std::less<int>,true>,std::allocator<std::__value_type<int,unsigned char>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  float v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        float v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        float v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        float v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    float v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    float v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((unsigned char *)v7 + 32) = 0;
    FILE *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    FILE *v6 = (uint64_t *)v7;
    int v10 = (uint64_t *)**a1;
    int v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      int v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_1A40186C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A4018B1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4019040(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A401A520(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A401CD6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A401D1B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void vision::mod::LandmarkDetectorDNN_Options::~LandmarkDetectorDNN_Options(vision::mod::LandmarkDetectorDNN_Options *this)
{
  if (*((char *)this + 47) < 0) {
    operator delete(*((void **)this + 3));
  }
}

uint64_t std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::map[abi:ne180100](uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  int v3 = (uint64_t **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  unsigned int v4 = a2 + 1;
  int v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      float v6 = *(uint64_t **)(a1 + 8);
      float v7 = v3;
      if (*(uint64_t ***)a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = v3;
      if (v6)
      {
        do
        {
          float v7 = (uint64_t **)v8;
          uint64_t v8 = *(void *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          float v7 = (uint64_t **)v9[2];
          BOOL v10 = *v7 == (uint64_t *)v9;
          uint64_t v9 = v7;
        }
        while (v10);
      }
      int v11 = *((_DWORD *)v5 + 8);
      if (*((_DWORD *)v7 + 8) < v11)
      {
LABEL_8:
        if (v6) {
          uint64_t v12 = v7;
        }
        else {
          uint64_t v12 = v3;
        }
        if (v6) {
          float v13 = v7 + 1;
        }
        else {
          float v13 = v3;
        }
      }
      else
      {
        uint64_t v12 = v3;
        float v13 = v3;
        if (v6)
        {
          float v13 = v3;
          while (1)
          {
            while (1)
            {
              uint64_t v12 = (uint64_t **)v6;
              int v17 = *((_DWORD *)v6 + 8);
              if (v11 >= v17) {
                break;
              }
              float v6 = *v12;
              float v13 = v12;
              if (!*v12) {
                goto LABEL_15;
              }
            }
            if (v17 >= v11) {
              break;
            }
            float v13 = v12 + 1;
            float v6 = v12[1];
            if (!v6) {
              goto LABEL_15;
            }
          }
        }
      }
      if (!*v13)
      {
LABEL_15:
        uint64_t v14 = (char *)operator new(0x48uLL);
        *((_DWORD *)v14 + 8) = *((_DWORD *)v5 + 8);
        uint64_t v15 = (std::string *)(v14 + 40);
        if (*((char *)v5 + 63) < 0)
        {
          std::string::__init_copy_ctor_external(v15, (const std::string::value_type *)v5[5], v5[6]);
        }
        else
        {
          long long v16 = *(_OWORD *)(v5 + 5);
          *((void *)v14 + 7) = v5[7];
          *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v16;
        }
        v14[64] = *((unsigned char *)v5 + 64);
        std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v12, v13, (uint64_t *)v14);
      }
      int v18 = (void *)v5[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          int v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v5[2];
          BOOL v10 = *v19 == (void)v5;
          int v5 = v19;
        }
        while (!v10);
      }
      int v5 = v19;
    }
    while (v19 != v4);
  }
  return a1;
}

void sub_1A401D3E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*v2);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::LandmarkDetectorDNN::checkConstellation(uint64_t result, int a2)
{
  if (vision::mod::constellationTypeSize[a2] != result)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 2942;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  return result;
}

void vision::mod::ImageProcessing_Preprocessor::mapCoordinatesDestinationToSource(uint64_t a1, float *a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  Geometry2D_mallocCart2D((void *)a1, *(_DWORD *)(a3 + 16));
  float v7 = a2[32];
  float v6 = a2[33];
  float v9 = a2[34];
  float v8 = a2[35];
  float v10 = (float)(v7 * v8) - (float)(v6 * v9);
  if (fabsf(v10) < 0.00000011921)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 1902;
LABEL_27:
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  float v11 = v8 / v10;
  float v12 = (float)-v6 / v10;
  float v33 = v11;
  float v34 = v12;
  float v13 = (float)-v9 / v10;
  float v14 = v7 / v10;
  v35[0] = v13;
  v35[1] = v14;
  float v15 = a2[36];
  float v16 = a2[37];
  float v17 = v13 * v16;
  float v18 = -(float)((float)(v13 * v16) + (float)(v11 * v15));
  float v19 = v14 * v16;
  float v36 = v18;
  v37[0] = -(float)(v19 + (float)(v12 * v15));
  if (a3 == a1) {
    goto LABEL_25;
  }
  uint64_t v20 = *(float **)a3;
  if (!*(void *)a3) {
    goto LABEL_25;
  }
  int v21 = *(float **)(a3 + 8);
  if (!v21) {
    goto LABEL_25;
  }
  uint64_t v22 = 1916;
  if (!a1) {
    goto LABEL_26;
  }
  vDSP_Length v23 = *(unsigned int *)(a3 + 16);
  if ((int)v23 < 1) {
    goto LABEL_26;
  }
  uint64_t v24 = *(float **)a1;
  if (!*(void *)a1 || (uint64_t v25 = *(float **)(a1 + 8)) == 0)
  {
LABEL_25:
    uint64_t v22 = 1916;
LABEL_26:
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = v22;
    goto LABEL_27;
  }
  int v26 = *(_DWORD *)(a1 + 16);
  uint64_t v22 = 1916;
  if (v26 < 1 || v23 != v26) {
    goto LABEL_26;
  }
  if (fabsf(v11 + -1.0) > 0.0001
    || fabsf(v12) > 0.0001
    || fabsf(v13) > 0.0001
    || fabsf(v14 + -1.0) > 0.0001
    || fabsf(v18) > 0.0001
    || fabsf(-(float)(v19 + (float)(v12 * v15))) > 0.0001)
  {
    if ((int)v23 > 7)
    {
      vDSP_vfill(&v36, v24, 1, v23);
      vDSP_vfill(v37, *(float **)(a1 + 8), 1, *(int *)(a1 + 16));
      vDSP_vsma(*(const float **)a3, 1, &v33, *(const float **)a1, 1, *(float **)a1, 1, *(int *)(a1 + 16));
      vDSP_vsma(*(const float **)a3, 1, &v34, *(const float **)(a1 + 8), 1, *(float **)(a1 + 8), 1, *(int *)(a1 + 16));
      vDSP_vsma(*(const float **)(a3 + 8), 1, v35, *(const float **)a1, 1, *(float **)a1, 1, *(int *)(a1 + 16));
      vDSP_vsma(*(const float **)(a3 + 8), 1, (const float *)((unint64_t)&v33 | 0xC), *(const float **)(a1 + 8), 1, *(float **)(a1 + 8), 1, *(int *)(a1 + 16));
    }
    else
    {
      float v27 = v17 + (float)(v11 * v15);
      float v28 = v19 + (float)(v12 * v15);
      do
      {
        *v24++ = (float)((float)(v13 * *v21) + (float)(v11 * *v20)) - v27;
        float v29 = *v20++;
        float v30 = v29;
        float v31 = *v21++;
        *v25++ = (float)((float)(v14 * v31) + (float)(v12 * v30)) - v28;
        --v23;
      }
      while (v23);
    }
  }
  else
  {
    uint64_t v22 = Geometry2D_copyCart2D(a3, a1);
    if ((v22 & 0x80) == 0) {
      goto LABEL_26;
    }
  }
}

void sub_1A401D9EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A401DC90(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  std::streambuf::~streambuf();

  _Unwind_Resume(a1);
}

void sub_1A401E0B4(_Unwind_Exception *a1)
{
  std::istream::~istream();
  std::streambuf::~streambuf();

  _Unwind_Resume(a1);
}

void sub_1A401E280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  _Block_object_dispose(&a15, 8);
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__122(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__123(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t ___ZL15_newFaceIDModeliPU15__autoreleasingP7NSError_block_invoke_28828(uint64_t a1)
{
  uint64_t v2 = operator new(0x280uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = &unk_1EF753498;
  vision::mod::FaceIDModel::FaceIDModel((vision::mod::FaceIDModel *)(v2 + 3), *(_DWORD *)(a1 + 40), 1, 10000, 1, 0.1, 1, 20);
  *(void *)&long long v4 = v3;
  *((void *)&v4 + 1) = v2;
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  float v6 = *(std::__shared_weak_count **)(v5 + 56);
  *(_OWORD *)(v5 + 48) = v4;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  return 1;
}

void sub_1A401E434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A401E4C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A401E608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A401E6F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A401E7A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A401ECB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56)
{
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32(v59);

  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a51, 8);

  _Block_object_dispose((const void *)(v60 - 256), 8);
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32((void **)(v60 - 208));

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__45(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__46(uint64_t a1)
{
}

uint64_t __Block_byref_object_copy__28836(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = &unk_1EF752200;
  *(void *)(result + 56) = *(void *)(a2 + 56);
  return result;
}

void sub_1A401F0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, char a15, uint64_t a16, uint64_t a17, void **a18)
{
  a18 = (void **)&a15;
  std::vector<std::map<int,double>>::__destroy_vector::operator()[abi:ne180100](&a18);

  _Unwind_Resume(a1);
}

void sub_1A401F230(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A401F46C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  _Unwind_Resume(a1);
}

void sub_1A401F648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A401FFA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, long long a19, uint64_t a20,void *a21,uint64_t a22,void *a23,void *a24,void *a25,std::__shared_weak_count *a26,uint64_t a27,void *a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52)
{
  if (v52) {
    operator delete(v52);
  }
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a26);
  }

  _Unwind_Resume(a1);
}

void sub_1A4020480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(lock);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_1A4020580(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A4020594(_Unwind_Exception *a1)
{
}

void sub_1A4020618(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A402062C(_Unwind_Exception *a1)
{
}

void sub_1A40208B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A4020B40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__28960(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__28961(uint64_t a1)
{
}

void sub_1A4020C3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4020DBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__28989(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__28990(uint64_t a1)
{
}

void sub_1A4021138(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40212DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40213AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4021430(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40214A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4021578(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40216D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4021918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A4021A4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4021BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A4021CD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4021DEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4021E50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4021F28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4021FB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40220A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402212C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4022228(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40222CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402236C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402241C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40224C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402256C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40225FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402278C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4022974(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__29190(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__29191(uint64_t a1)
{
}

void sub_1A4022B48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4022E90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4022F98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4023084(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4023238(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40233D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _sequenceKeyComponentForArray(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    uint64_t v2 = (void *)[objc_alloc(MEMORY[0x1E4F1CAD0]) initWithArray:v1];
    uint64_t v3 = [v2 allObjects];
    long long v4 = NSString;
    uint64_t v5 = [v3 componentsJoinedByString:@","];
    float v6 = [v4 stringWithFormat:@"[%@]", v5];
  }
  else
  {
    float v6 = 0;
  }

  return v6;
}

void sub_1A40234DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4023548(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40235A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40235FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4023664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40236B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4023710(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A402375C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40237BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4023808(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4023868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40238C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402393C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40239A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4023A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4023BA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4023E40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4023FA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40240F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40241F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40243A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4024444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40244A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4024574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402465C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40246F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40247F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40248AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int *appendDequeElement(int *a1, void *__src)
{
  if (a1)
  {
    int v4 = a1[3];
    int v5 = a1[1];
    if (v4 == v5 - 1)
    {
      reallocDeque(a1, 2 * v5, 1, 0);
      int v4 = a1[3];
    }
    uint64_t v6 = v4 + 1;
    a1[3] = v6;
    memcpy((void *)(*((void *)a1 + 2) + *a1 * v6), __src, *a1);
  }
  return a1;
}

int *reallocDeque(int *a1, int a2, int a3, int a4)
{
  uint64_t v8 = (char *)malloc_type_malloc(*a1 * (uint64_t)a2, 0x1EA6628AuLL);
  float v9 = v8;
  int v10 = a1[2];
  int v11 = a1[3] - v10;
  if (a4) {
    int v12 = a3;
  }
  else {
    int v12 = 0;
  }
  int v13 = v12 + ((a2 - a3 + ~v11) >> 1);
  memcpy(&v8[v13 * *a1], (const void *)(*((void *)a1 + 2) + *a1 * v10), *a1 + *a1 * v11);
  a1[2] = v13;
  a1[3] = v13 + v11;
  float v14 = (void *)*((void *)a1 + 2);
  if (v14) {
    free(v14);
  }
  *((void *)a1 + 2) = v9;
  a1[1] = a2;
  return a1;
}

int *prependDequeElement(int *a1, void *__src)
{
  if (a1)
  {
    int v4 = a1[2];
    if (!v4)
    {
      reallocDeque(a1, 2 * a1[1], 1, 1);
      int v4 = a1[2];
    }
    uint64_t v5 = v4 - 1;
    a1[2] = v5;
    memcpy((void *)(*((void *)a1 + 2) + *a1 * v5), __src, *a1);
  }
  return a1;
}

uint64_t appendDeque(uint64_t a1, int *a2, int a3)
{
  if (a1 && a2)
  {
    int v6 = a2[3] - a2[2] + 1;
    int v7 = *(_DWORD *)(a1 + 12);
    int v8 = v7 + v6;
    if (v7 + v6 >= *(_DWORD *)(a1 + 4))
    {
      reallocDeque((int *)a1, 2 * (v6 + v7 - *(_DWORD *)(a1 + 8)) + 2, a2[3] - a2[2] + 1, 0);
      int v7 = *(_DWORD *)(a1 + 12);
      int v8 = v7 + v6;
    }
    int v9 = *(_DWORD *)a1;
    int v10 = (_WORD *)(*(void *)(a1 + 16) + v9 + v9 * v7);
    *(_DWORD *)(a1 + 12) = v8;
    uint64_t v11 = *((void *)a2 + 2);
    int v12 = *a2;
    if (a3) {
      reverseCopy(v10, (char *)(v11 + v12 * (uint64_t)a2[3]), v9, v6);
    }
    else {
      memcpy(v10, (const void *)(v11 + v12 * (uint64_t)a2[2]), v12 * (uint64_t)v6);
    }
  }
  return a1;
}

uint64_t prependDeque(uint64_t a1, int *a2, int a3)
{
  if (a1 && a2)
  {
    int v6 = a2[3] - a2[2] + 1;
    int v7 = *(_DWORD *)(a1 + 8);
    int v8 = v7 - v6;
    if (v7 - v6 < 0)
    {
      reallocDeque((int *)a1, 2 * (v6 + *(_DWORD *)(a1 + 12) - v7) + 2, a2[3] - a2[2] + 1, 1);
      int v8 = *(_DWORD *)(a1 + 8) - v6;
    }
    *(_DWORD *)(a1 + 8) = v8;
    int v9 = (_WORD *)(*(void *)(a1 + 16) + *(_DWORD *)a1 * v8);
    uint64_t v10 = *((void *)a2 + 2);
    int v11 = *a2;
    if (a3) {
      reverseCopy(v9, (char *)(v10 + v11 * (uint64_t)a2[3]), *(_DWORD *)a1, v6);
    }
    else {
      memcpy(v9, (const void *)(v10 + v11 * (uint64_t)a2[2]), v11 * (uint64_t)v6);
    }
  }
  return a1;
}

float Projections_computeMeanStdTable(float *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  *a3 = 0;
  *a4 = 0;
  if (a2 >= 1)
  {
    uint64_t v4 = (a2 + 1) - 1;
    uint64_t v5 = (float *)(a4 + 1);
    int v6 = (float *)(a3 + 1);
    do
    {
      float *v6 = *(v6 - 1) + *a1;
      ++v6;
      float v7 = *a1++;
      float result = *(v5 - 1) + (float)(v7 * v7);
      *v5++ = result;
      --v4;
    }
    while (v4);
  }
  return result;
}

void sub_1A4024ED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4025000(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4025140(void *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  objc_begin_catch(exc_buf);
  os_unfair_lock_unlock(v10);
  objc_exception_rethrow();
}

void sub_1A402517C(_Unwind_Exception *a1)
{
}

void sub_1A402538C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  _Unwind_Resume(a1);
}

void RamerDouglasPeucker(uint64_t a1, void **a2, float a3, double a4, double a5, double a6)
{
  int v6 = *(float32x2_t **)a1;
  uint64_t v7 = *(void *)(a1 + 8) - *(void *)a1;
  if ((unint64_t)v7 < 0x10) {
    return;
  }
  uint64_t v11 = v7 >> 3;
  unint64_t v12 = (v7 >> 3) - 1;
  if (v12 < 2)
  {
    uint64_t v14 = 0;
    float v16 = 0.0;
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    float32x2_t v15 = vsub_f32(v6[v12], *v6);
    *(float *)&a6 = sqrtf(vaddv_f32(vmul_f32(v15, v15)));
    float v16 = 0.0;
    int8x8_t v17 = (int8x8_t)vdup_lane_s32((int32x2_t)vmvn_s8(vorr_s8((int8x8_t)vcgt_f32(0, *(float32x2_t *)&a6), (int8x8_t)vcgt_f32(*(float32x2_t *)&a6, 0))), 0);
    *(float *)&a6 = fabsf(*(float *)&a6);
    __asm { FMOV            V5.2S, #1.0 }
    float32x2_t v23 = vdiv_f32(v15, (float32x2_t)vbsl_s8(v17, _D5, (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a6, 0)));
    uint64_t v24 = v11 - 2;
    do
    {
      float32x2_t v25 = vsub_f32(v6[v13 + 1], *v6);
      float32x2_t v26 = vsub_f32(v25, vmul_n_f32(v23, vmlas_n_f32(COERCE_FLOAT(vmul_f32(v23, v25).i32[1]), v23.f32[0], v25.f32[0])));
      float v27 = fabsf(sqrtf(vaddv_f32(vmul_f32(v26, v26))));
      if (v27 > v16) {
        uint64_t v14 = v13 + 1;
      }
      uint64_t v28 = v13 + 1;
      if (v27 > v16) {
        float v16 = v27;
      }
      ++v13;
    }
    while (v24 != v28);
  }
  if (v16 > a3)
  {
    float v100 = 0;
    uint64_t v101 = 0;
    uint64_t v102 = 0;
    char v97 = 0;
    int v98 = 0;
    uint64_t v99 = 0;
    memset(v96, 0, sizeof(v96));
    _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPKS1_EES9_EEvT_T0_m(v96, v6, (uint64_t)&v6[v14 + 1], (8 * v14 + 8) >> 3);
    uint64_t v29 = *(void *)(a1 + 8);
    float v30 = (const void *)(*(void *)a1 + 8 * v14);
    memset(__p, 0, sizeof(__p));
    _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPKS1_EES9_EEvT_T0_m(__p, v30, v29, (v29 - (uint64_t)v30) >> 3);
    RamerDouglasPeucker(v96, &v100, a3);
    RamerDouglasPeucker(__p, &v97, a3);
    float v31 = (char *)v100;
    unsigned int v32 = (char *)(v101 - 8);
    int64_t v33 = v101 - 8 - (void)v100;
    unint64_t v34 = v33 >> 3;
    uint64_t v35 = (uint64_t)a2[2];
    float v36 = (char *)*a2;
    if (v33 >> 3 <= (unint64_t)((v35 - (uint64_t)*a2) >> 3))
    {
      unsigned int v59 = (char *)a2[1];
      unint64_t v60 = (v59 - v36) >> 3;
      if (v60 < v34)
      {
        uint64_t v61 = (char *)v100 + 8 * v60;
        if (v59 != v36)
        {
          memmove(*a2, v100, v59 - v36);
          float v36 = (char *)a2[1];
        }
        int64_t v33 = v32 - v61;
        if (v32 == v61) {
          goto LABEL_52;
        }
        unsigned int v62 = v36;
        float v63 = v61;
        goto LABEL_51;
      }
    }
    else
    {
      if (v36)
      {
        a2[1] = v36;
        operator delete(v36);
        uint64_t v35 = 0;
        *a2 = 0;
        a2[1] = 0;
        a2[2] = 0;
      }
      if (v33 < 0) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v37 = v35 >> 2;
      if (v35 >> 2 <= v34) {
        uint64_t v37 = v33 >> 3;
      }
      if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v38 = v37;
      }
      std::vector<long long>::__vallocate[abi:ne180100](a2, v38);
      float v36 = (char *)a2[1];
    }
    if (v32 == v31)
    {
LABEL_52:
      unsigned int v64 = &v36[v33];
      a2[1] = v64;
      float v65 = (char *)v97;
      if (v98 - (unsigned char *)v97 >= 1)
      {
        uint64_t v66 = (v98 - (unsigned char *)v97) >> 3;
        unsigned int v67 = (char *)a2[2];
        if (v66 <= (v67 - v64) >> 3)
        {
          if (v66 <= 0)
          {
            unsigned int v79 = (char *)v97 + 8 * v66;
            unsigned int v80 = &v64[-8 * v66];
            float v81 = v64;
            if (v80 < v64)
            {
              float v81 = v64;
              do
              {
                uint64_t v82 = *(void *)v80;
                v80 += 8;
                *(void *)float v81 = v82;
                v81 += 8;
              }
              while (v80 < v64);
            }
            a2[1] = v81;
            if (v64 != &v64[8 * v66]) {
              memmove(&v64[-8 * ((-8 * v66) >> 3)], v64, -8 * v66);
            }
            if (v79 != v65) {
              memmove(v64, v65, v79 - v65);
            }
          }
          else
          {
            int64_t v73 = v98 - (unsigned char *)v97;
            if (v98 != v97) {
              memmove(v64, v97, v98 - (unsigned char *)v97);
            }
            a2[1] = &v64[v73];
          }
        }
        else
        {
          uint64_t v68 = (v64 - (unsigned char *)*a2) >> 3;
          if ((unint64_t)(v68 + v66) >> 61) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v69 = v67 - (unsigned char *)*a2;
          uint64_t v70 = v69 >> 2;
          if (v69 >> 2 <= (unint64_t)(v68 + v66)) {
            uint64_t v70 = v68 + v66;
          }
          if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v71 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v71 = v70;
          }
          if (v71) {
            unint64_t v71 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v71);
          }
          else {
            uint64_t v72 = 0;
          }
          unsigned int v83 = (void *)(v71 + 8 * v68);
          unsigned int v84 = (char *)&v83[v66];
          uint64_t v85 = 8 * v66;
          unsigned int v86 = v83;
          do
          {
            uint64_t v87 = *(void *)v65;
            v65 += 8;
            *v86++ = v87;
            v85 -= 8;
          }
          while (v85);
          unsigned int v88 = (char *)*a2;
          if (*a2 != v64)
          {
            float v89 = v64;
            do
            {
              uint64_t v90 = *((void *)v89 - 1);
              v89 -= 8;
              *--unsigned int v83 = v90;
            }
            while (v89 != v88);
          }
          unint64_t v91 = v71 + 8 * v72;
          int v92 = (char *)a2[1];
          uint64_t v93 = v92 - v64;
          if (v92 != v64) {
            memmove(v84, v64, v92 - v64);
          }
          int v94 = *a2;
          *a2 = v83;
          a2[1] = &v84[v93];
          a2[2] = (void *)v91;
          if (v94) {
            operator delete(v94);
          }
        }
      }
      if (__p[0]) {
        operator delete(__p[0]);
      }
      if (v96[0]) {
        operator delete(v96[0]);
      }
      if (v97) {
        operator delete(v97);
      }
      if (v100) {
        operator delete(v100);
      }
      return;
    }
    unsigned int v62 = v36;
    float v63 = v31;
LABEL_51:
    memmove(v62, v63, v33);
    goto LABEL_52;
  }
  unsigned int v39 = *a2;
  a2[1] = *a2;
  unint64_t v40 = (unint64_t)a2[2];
  if ((unint64_t)v39 >= v40)
  {
    uint64_t v42 = v40 - (void)v39;
    uint64_t v43 = v42 >> 2;
    if ((unint64_t)(v42 >> 2) <= 1) {
      uint64_t v43 = 1;
    }
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v44 = v43;
    }
    unsigned int v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v44);
    int v47 = &v45[8 * v46];
    *(float32x2_t *)unsigned int v45 = *v6;
    int v41 = v45 + 8;
    uint64_t v49 = (char *)*a2;
    int v48 = (char *)a2[1];
    if (v48 != *a2)
    {
      do
      {
        uint64_t v50 = *((void *)v48 - 1);
        v48 -= 8;
        *((void *)v45 - 1) = v50;
        v45 -= 8;
      }
      while (v48 != v49);
      int v48 = (char *)*a2;
    }
    *a2 = v45;
    a2[1] = v41;
    a2[2] = v47;
    if (v48) {
      operator delete(v48);
    }
  }
  else
  {
    void *v39 = *v6;
    int v41 = (char *)(v39 + 1);
  }
  a2[1] = v41;
  int v51 = *(float32x2_t **)a1;
  unint64_t v52 = (unint64_t)a2[2];
  if ((unint64_t)v41 >= v52)
  {
    uint64_t v54 = (v41 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v54 + 1) >> 61) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v55 = v52 - (void)*a2;
    uint64_t v56 = v55 >> 2;
    if (v55 >> 2 <= (unint64_t)(v54 + 1)) {
      uint64_t v56 = v54 + 1;
    }
    if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v57 = v56;
    }
    if (v57) {
      unint64_t v57 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v57);
    }
    else {
      uint64_t v58 = 0;
    }
    unsigned int v74 = (char *)(v57 + 8 * v54);
    unint64_t v75 = v57 + 8 * v58;
    *(float32x2_t *)unsigned int v74 = v51[v12];
    int v53 = v74 + 8;
    float v77 = (char *)*a2;
    unsigned int v76 = (char *)a2[1];
    if (v76 != *a2)
    {
      do
      {
        uint64_t v78 = *((void *)v76 - 1);
        v76 -= 8;
        *((void *)v74 - 1) = v78;
        v74 -= 8;
      }
      while (v76 != v77);
      unsigned int v76 = (char *)*a2;
    }
    *a2 = v74;
    a2[1] = v53;
    a2[2] = (void *)v75;
    if (v76) {
      operator delete(v76);
    }
  }
  else
  {
    *(float32x2_t *)int v41 = v51[v12];
    int v53 = v41 + 8;
  }
  a2[1] = v53;
}

void sub_1A4025A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  if (a15) {
    operator delete(a15);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void *_ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPKS1_EES9_EEvT_T0_m(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    float result = std::vector<long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      float result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A4025ACC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A4025C94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4025D6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4025EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4025F70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNContour;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A4026150(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL vision::mod::CVMLCanceller::shouldStop(vision::mod::CVMLCanceller *this, int a2)
{
  int v2 = *((_DWORD *)this + 3);
  if (v2 <= 0) {
    return *((unsigned char *)this + 8) != 0;
  }
  else {
    return v2 <= a2;
  }
}

uint64_t vision::mod::CVMLCanceller::signal(uint64_t this)
{
  *(unsigned char *)(this + 8) = 1;
  return this;
}

void std::__shared_ptr_emplace<vision::mod::ConcreteFaceprintAndAttributes>::__on_zero_shared(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 144))
  {
    if (espresso_plan_destroy())
    {
      syslog(5, "[Error] Fail to destroy the existing espresso plan");
    }
    else
    {
      *(void *)(a1 + 120) = 0;
      if (espresso_context_destroy()) {
        syslog(5, "[Error] Fail to destroy the existing espresso context");
      }
      else {
        *(void *)(a1 + 112) = 0;
      }
    }
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>>>::destroy(*(void **)(a1 + 6752));
  int v2 = *(std::__shared_weak_count **)(a1 + 6736);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(*(char **)(a1 + 6704));
  int v6 = (void **)(a1 + 6672);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v6);
  int v6 = (void **)(a1 + 6648);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v6);
  int v6 = (void **)(a1 + 6280);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v6);
  int v6 = (void **)(a1 + 6256);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v6);
  uint64_t v3 = *(void **)(a1 + 6232);
  if (v3)
  {
    *(void *)(a1 + 6240) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 6208);
  if (v4)
  {
    *(void *)(a1 + 6216) = v4;
    operator delete(v4);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void std::__tree<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__shared_ptr_emplace<vision::mod::ConcreteFaceprintAndAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753A48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::ConcreteFaceprintAndAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753A48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

double vision::mod::FaceprintAndAttributes::createDescriptorBuffer(vision::mod::FaceprintAndAttributes *this, uint64_t a2)
{
  uint64_t v4 = operator new(0x90uLL);
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = &unk_1EF7539A0;
  v4[4] = 0;
  v4[5] = 0;
  v4[9] = 0;
  v4[8] = 0;
  void v4[6] = 0;
  v4[7] = v4 + 8;
  double result = 0.0;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((unsigned char *)v4 + 112) = 0;
  v4[3] = &unk_1EF752918;
  *((_DWORD *)v4 + 32) = 1;
  v4[17] = 0;
  v4[15] = *(int *)(a2 + 76);
  *(void *)this = v4 + 3;
  *((void *)this + 1) = v4;
  return result;
}

uint64_t vision::mod::FaceprintAndAttributes::getFaceAttributesOutput(uint64_t a1, uint64_t **a2)
{
  if (*(unsigned char *)(a1 + 6620))
  {
    int v2 = *(void **)(a1 + 6672);
    uint64_t v3 = (void *)(a1 + 6680);
    if (v2 == (void *)(a1 + 6680))
    {
      uint64_t v5 = &CVML_status_ok;
    }
    else
    {
      uint64_t v5 = &CVML_status_ok;
      do
      {
        int v6 = *((_DWORD *)v2 + 14);
        uint64_t v7 = (void **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>((uint64_t)a2, &v16, v2 + 4);
        size_t v8 = (char *)*v7;
        if (!*v7)
        {
          int v9 = (uint64_t **)v7;
          size_t v8 = (char *)operator new(0x40uLL);
          uint64_t v10 = (std::string *)(v8 + 32);
          if (*((char *)v2 + 55) < 0)
          {
            std::string::__init_copy_ctor_external(v10, (const std::string::value_type *)v2[4], v2[5]);
          }
          else
          {
            long long v11 = *((_OWORD *)v2 + 2);
            *((void *)v8 + 6) = v2[6];
            *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
          }
          *((_DWORD *)v8 + 14) = 0;
          std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a2, v16, v9, (uint64_t *)v8);
        }
        *((_DWORD *)v8 + 14) = v6;
        unint64_t v12 = (void *)v2[1];
        if (v12)
        {
          do
          {
            uint64_t v13 = v12;
            unint64_t v12 = (void *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            uint64_t v13 = (void *)v2[2];
            BOOL v14 = *v13 == (void)v2;
            int v2 = v13;
          }
          while (!v14);
        }
        int v2 = v13;
      }
      while (v13 != v3);
    }
  }
  else
  {
    uint64_t v5 = &CVML_status_IOError;
  }
  return (*v5 + 128) | 0x2300;
}

void sub_1A4026594(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,float>,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<float>::shared_ptr[abi:ne180100]<float,void (*)(void *),void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1A4026624(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1A4026638(_Unwind_Exception *a1)
{
}

uint64_t **std::__tree<std::__value_type<std::string,std::shared_ptr<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<float>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, void *a2, uint64_t a3)
{
  int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  size_t v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v10 = v5 + 4;
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) == 0) {
          break;
        }
        uint64_t v5 = *v7;
        size_t v8 = v7;
        if (!*v7) {
          goto LABEL_7;
        }
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v10, a2) & 0x80) == 0) {
        return v7;
      }
      size_t v8 = v7 + 1;
      uint64_t v5 = v7[1];
      if (!v5) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    long long v11 = operator new(0x48uLL);
    v16[0] = v11;
    v16[1] = v6;
    char v17 = 0;
    unint64_t v12 = (std::string *)(v11 + 4);
    if (*(char *)(a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v12, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)&v12->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
      v11[6] = *(void *)(a3 + 16);
    }
    v11[7] = 0;
    v11[8] = 0;
    char v17 = 1;
    *long long v11 = 0;
    v11[1] = 0;
    _OWORD v11[2] = v7;
    *size_t v8 = v11;
    uint64_t v13 = (uint64_t *)**a1;
    BOOL v14 = v11;
    if (v13)
    {
      *a1 = v13;
      BOOL v14 = *v8;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v16[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>>>>::reset[abi:ne180100]((uint64_t)v16);
  }
  return (uint64_t **)v11;
}

void sub_1A402677C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferAbstract>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferAbstract>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferAbstract>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, void *a2, uint64_t a3)
{
  int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  size_t v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v10 = v5 + 4;
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) == 0) {
          break;
        }
        uint64_t v5 = *v7;
        size_t v8 = v7;
        if (!*v7) {
          goto LABEL_7;
        }
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v10, a2) & 0x80) == 0) {
        return v7;
      }
      size_t v8 = v7 + 1;
      uint64_t v5 = v7[1];
      if (!v5) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    long long v11 = operator new(0x48uLL);
    v16[0] = v11;
    v16[1] = v6;
    char v17 = 0;
    unint64_t v12 = (std::string *)(v11 + 4);
    if (*(char *)(a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v12, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)&v12->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
      v11[6] = *(void *)(a3 + 16);
    }
    v11[7] = 0;
    v11[8] = 0;
    char v17 = 1;
    *long long v11 = 0;
    v11[1] = 0;
    _OWORD v11[2] = v7;
    *size_t v8 = v11;
    uint64_t v13 = (uint64_t *)**a1;
    BOOL v14 = v11;
    if (v13)
    {
      *a1 = v13;
      BOOL v14 = *v8;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v16[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>>>>::reset[abi:ne180100]((uint64_t)v16);
  }
  return (uint64_t **)v11;
}

void sub_1A40268C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceprintAndAttributes::normalizeFacePrintData(vision::mod::FaceprintAndAttributes *this, const void *a2, int a3, float *a4, float *a5)
{
  if (a4)
  {
    if ((int)a2 < 1) {
      goto LABEL_11;
    }
    uint64_t v5 = a2;
    float v6 = 0.0;
    uint64_t v7 = a4;
    uint64_t v8 = a2;
    do
    {
      float v9 = *(float *)this;
      this = (vision::mod::FaceprintAndAttributes *)((char *)this + 4);
      *v7++ = v9;
      float v6 = v6 + v9;
      --v8;
    }
    while (v8);
    if (a3)
    {
      float v10 = v6 / (float)(int)a2;
      float v11 = 0.0;
      unint64_t v12 = a4;
      uint64_t v13 = a2;
      do
      {
        float v14 = *v12 - v10;
        *v12++ = v14;
        float v11 = v11 + (float)(v14 * v14);
        --v13;
      }
      while (v13);
      float32x2_t v15 = &CVML_status_ok;
      float v16 = sqrtf(v11);
      do
      {
        *a4 = *a4 / v16;
        ++a4;
        --v5;
      }
      while (v5);
    }
    else
    {
LABEL_11:
      float32x2_t v15 = &CVML_status_ok;
    }
  }
  else
  {
    float32x2_t v15 = &CVML_status_invalidParameter;
  }
  return (*v15 + 128) | 0x2300;
}

uint64_t std::__shared_ptr_pointer<float *,void (*)(void *),std::allocator<float>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), 0x80000001A41251B2)) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

uint64_t std::__shared_ptr_pointer<float *,void (*)(void *),std::allocator<float>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

void std::__shared_ptr_pointer<float *,void (*)(void *),std::allocator<float>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A4026CC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4026E0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40275C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4027680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40276CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402772C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4027778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40277D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4027824(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4027A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A4027C2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4027D10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4027DE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028004(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028170(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40282E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A402832C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40283A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40283F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028480(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40284D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028560(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40285B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028644(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4028698(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4028778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4028858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028920(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028CF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4028F08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029054(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029110(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40291C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029244(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40292C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029360(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029430(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40294B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40295EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402974C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029884(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029B4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029C5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4029EC8(_Unwind_Exception *a1)
{
  uint64_t v7 = v6;

  _Unwind_Resume(a1);
}

void sub_1A402A134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402A258(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402A358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402A3B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A402A404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402A464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A402A4B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402A510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A402A55C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402A64C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402A7C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402A930(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402A9E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A402AA30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402AA98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402AC98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402AD8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402AE2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402AFC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402B078(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402B1C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A402C0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A402C38C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402C67C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402C7B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402C88C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402C940(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402CA78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402CBB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402CC2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402CDE0(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(a1);
}

void sub_1A402D024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402D3AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402D710(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *__p,uint64_t a22)
{
  uint64_t v28 = v25;

  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A402DAB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *__p, uint64_t a14)
{
  _Unwind_Resume(a1);
}

void sub_1A402DC84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402DF18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A402EDD4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (a2)
  {
    apple::vision::fgbg::ConnectedComponentResult::~ConnectedComponentResult((apple::vision::fgbg::ConnectedComponentResult *)&STACK[0x210]);
    apple::vision::fgbg::ConnectedComponentResult::~ConnectedComponentResult((apple::vision::fgbg::ConnectedComponentResult *)&STACK[0x2A0]);

    objc_begin_catch(a1);
    JUMPOUT(0x1A402ED28);
  }
  _Unwind_Resume(a1);
}

void sub_1A402F64C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, void *a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25)
{
  _Unwind_Resume(a1);
}

void sub_1A402F784(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402F7D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402F82C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402F9A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A402FAD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A402FC50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A402FEF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40301A4(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(void **)(v1 + 8));
  MEMORY[0x1A62562C0](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

void sub_1A40302C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  *(void *)(v2 - 56) = va;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v2 - 56));
  vision::mod::LandmarkDetectorDNN_Options::~LandmarkDetectorDNN_Options((vision::mod::LandmarkDetectorDNN_Options *)va1);
  _Unwind_Resume(a1);
}

void sub_1A403045C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v4 - 64));
  vision::mod::LandmarkDetectorDNN_Options::~LandmarkDetectorDNN_Options((vision::mod::LandmarkDetectorDNN_Options *)va);
  _Unwind_Resume(a1);
}

void sub_1A40305DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40306BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4030E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::LandmarkDetectorDNN>::__on_zero_shared(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 264))
  {
    espresso_plan_destroy();
    espresso_context_destroy();
  }
  std::unique_ptr<vision::mod::ImageProcessing_Preprocessor>::reset[abi:ne180100]((uint64_t *)(a1 + 256), 0);
  std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(*(char **)(a1 + 192));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(a1 + 168));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(a1 + 144));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(a1 + 120));
  if (*(char *)(a1 + 111) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 88);
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<vision::mod::LandmarkDetectorDNN>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753658;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::LandmarkDetectorDNN>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753658;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A4031260(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40315D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40317D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A4031AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A4031BD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __VNIOSurfaceBackedPixelBufferAttributes_block_invoke()
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFDictionaryRef v3 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v4 = (void *)*MEMORY[0x1E4F24D20];
  values = v3;
  keys[0] = v4;
  VNIOSurfaceBackedPixelBufferAttributes::pixelBufferAttributes = (uint64_t)CFDictionaryCreate(v0, (const void **)keys, (const void **)&values, 1, v1, v2);
  if (v3) {
    CFRelease(v3);
  }
}

CGColorSpaceRef VNColorspaceForFormat(int a1, int *a2)
{
  if (a1 > 1094862673)
  {
    if (a1 <= 1278226487)
    {
      if (a1 == 1094862674)
      {
        CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
        int v4 = 8193;
        goto LABEL_21;
      }
      if (a1 == 1111970369)
      {
        CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
        int v4 = 8194;
        goto LABEL_21;
      }
      goto LABEL_18;
    }
    if (a1 == 1278226534 || a1 == 1278226488) {
      goto LABEL_15;
    }
    goto LABEL_18;
  }
  if (a1 <= 875704421)
  {
    if (a1 == 32)
    {
      CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      int v4 = 2;
      goto LABEL_21;
    }
    if (a1 != 40) {
      goto LABEL_18;
    }
LABEL_15:
    uint64_t v5 = (CFStringRef *)MEMORY[0x1E4F1DC00];
LABEL_19:
    CGColorSpaceRef result = CGColorSpaceCreateWithName(*v5);
    goto LABEL_20;
  }
  if (a1 != 875704422 && a1 != 875704438)
  {
LABEL_18:
    uint64_t v5 = (CFStringRef *)MEMORY[0x1E4F1DC98];
    goto LABEL_19;
  }
  CGColorSpaceRef result = CGColorSpaceCreateDeviceRGB();
LABEL_20:
  int v4 = 0;
LABEL_21:
  if (a2) {
    *a2 = v4;
  }
  return result;
}

uint64_t VNCVPixelBufferCreateUsingIOSurface(size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef theDict, CVPixelBufferRef *a5)
{
  if (!a5) {
    return 4294960635;
  }
  if (VNIOSurfaceBackedPixelBufferAttributes::onceToken != -1) {
    dispatch_once(&VNIOSurfaceBackedPixelBufferAttributes::onceToken, &__block_literal_global_30784);
  }
  CFDictionaryRef v10 = (const __CFDictionary *)VNIOSurfaceBackedPixelBufferAttributes::pixelBufferAttributes;
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (theDict)
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    CFIndex v13 = CFDictionaryGetCount(v10);
    theDict = CFDictionaryCreateMutableCopy(v11, v13 + Count, theDict);
    CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)_mergeKeysAndValuesIntoTargetCFMutableDictionary, theDict);
  }
  CVPixelBufferRef pixelBufferOut = 0;
  if (theDict) {
    CFDictionaryRef v14 = theDict;
  }
  else {
    CFDictionaryRef v14 = v10;
  }
  uint64_t v15 = CVPixelBufferCreate(v11, width, height, pixelFormatType, v14, &pixelBufferOut);
  if (theDict) {
    CFRelease(theDict);
  }
  if (!v15) {
    *a5 = pixelBufferOut;
  }
  return v15;
}

void _mergeKeysAndValuesIntoTargetCFMutableDictionary(const void *key, const void *value, CFMutableDictionaryRef theDict)
{
}

void sub_1A40320C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A403226C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4032330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40323AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4032450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A4032648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1A4032DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
  _Unwind_Resume(a1);
}

void sub_1A4032FA8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1A4033180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A4033244(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4033480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1A40336C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40338A0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 80), 8);

  _Unwind_Resume(a1);
}

void sub_1A403399C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4033CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A4033E9C(_Unwind_Exception *a1)
{
  uint64_t v8 = v6;

  _Unwind_Resume(a1);
}

void sub_1A40340B4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A403405CLL);
}

void sub_1A403411C()
{
}

void sub_1A4034264(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4034358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4034474(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4034678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4034990(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4034CDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4034FEC(_Unwind_Exception *a1)
{
}

void sub_1A40350EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4035280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4035370(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A403543C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40354BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4035524(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4035778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,char *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  std::string __p = &a24;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);

  _Unwind_Resume(a1);
}

void sub_1A4035998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4035AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4035E14(_Unwind_Exception *a1)
{
  CFDictionaryRef v10 = v8;

  _Unwind_Resume(a1);
}

void sub_1A4036088(_Unwind_Exception *a1)
{
  uint64_t v7 = v6;

  _Unwind_Resume(a1);
}

void sub_1A40361E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4036330(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40363CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4036544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4036B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A4036EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A40377BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,void *a43,void *a44,void *a45,void *a46,void *a47,void *a48,void *a49)
{
  _Unwind_Resume(a1);
}

void sub_1A4038078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,id a58)
{
  _Block_object_dispose(&a53, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__31152(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__31153(uint64_t a1)
{
}

void sub_1A4038408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4039288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id *a22,uint64_t a23,uint64_t a24,void *a25,void *a26,void *a27,void *a28,uint64_t a29,void *a30,void *a31,void *a32,void *a33,void *a34,void *a35,void *a36,uint64_t a37,void *a38,void *a39,void *a40,uint64_t a41,void *a42,void *a43)
{
  __cxa_guard_abort(&_ZGVZZ128__VNANFDMultiDetector_internalProcessUsingQualityOfServiceClass_options_regionOfInterest_warningRecorder_error_progressHandler__EUb_E27duplicatedObjectToBeRemoved);

  objc_destroyWeak((id *)&STACK[0x340]);
  _Block_object_dispose(&STACK[0x348], 8);
  _Block_object_dispose((const void *)(v44 - 240), 8);

  uint64_t v46 = *(void **)(v44 - 192);
  if (v46)
  {
    *(void *)(v44 - 184) = v46;
    operator delete(v46);
  }

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__115(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A40397E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4039B50()
{
}

void sub_1A4039BD0()
{
}

void sub_1A4039CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t ___Z51VNRecognizedObjectObservationsOnlySortingComparatorv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_isKindOfClass())
  {
    id v6 = &__block_literal_global_133;
    uint64_t v7 = __VNDefaultRecognizedObjectObservationsSortingComparator_block_invoke((uint64_t)&__block_literal_global_133, v4, v5);
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

void sub_1A4039D74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4039E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A4039EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A403A084(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A403A2DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1A403A760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void fftGrayMag(const DSPComplex *a1, _DWORD *a2, float *a3)
{
  id v4 = a2;
  id v6 = a2 + 0x8000;
  uint64_t v7 = a3 + 0x8000;
  unsigned int v62 = malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
  uint64_t v61 = malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
  uint64_t v8 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  float v9 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  CFDictionaryRef v10 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  unsigned int v64 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  CFAllocatorRef v11 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  float v63 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  unint64_t v12 = (DSPComplex *)malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
  bzero(v12, 0x40000uLL);
  uint64_t v13 = 0;
  do
  {
    float v14 = *(float *)((char *)&a1->real + v13) - *(float *)((char *)&a1[32640].real + v13);
    *(float *)((char *)&v12->real + v13) = v14;
    *(float *)((char *)&v12[32640].real + v13) = -v14;
    v13 += 4;
  }
  while (v13 != 1024);
  uint64_t v15 = 0;
  do
  {
    float v16 = (float *)&v12[v15];
    float v17 = a1[v15].real - a1[v15 + 127].imag;
    *float v16 = v12[v15].real + v17;
    v16[255] = v12[v15 + 127].imag - v17;
    v15 += 128;
  }
  while ((v15 * 8) != 0x40000);
  __Z.realp = v11;
  __Z.imagp = v63;
  __C.realp = v8;
  __C.imagp = v9;
  v65.realp = v10;
  v65.imagp = v64;
  vDSP_ctoz(a1, 2, &__Z, 1, 0x8000uLL);
  fftsetup = vDSP_create_fftsetup(8uLL, 0);
  vDSP_fft2d_zrop(fftsetup, &__Z, 1, 0, &__C, 1, 0, 8uLL, 8uLL, 1);
  vDSP_ctoz(v12, 2, &__Z, 1, 0x8000uLL);
  vDSP_fft2d_zrop(fftsetup, &__Z, 1, 0, &v65, 1, 0, 8uLL, 8uLL, 1);
  realp = __C.realp;
  imagp = __C.imagp;
  if (a3)
  {
    int v21 = v65.realp;
    uint64_t v22 = v65.imagp;
    *__C.realp = *__C.realp - (float)(*v65.realp * *a3);
    float *imagp = *imagp - (float)(*v22 * a3[128]);
    realp[128] = realp[128] - (float)(v21[128] * *v7);
    imagp[128] = imagp[128] - (float)(v22[128] * v7[128]);
    for (uint64_t i = 256; i != 0x8000; i += 256)
      realp[i] = realp[i] - (float)(v21[i] * a3[i]);
    uint64_t v24 = a3 + 384;
    uint64_t v25 = 0x3FFFFFFFFFFF8100;
    do
    {
      imagp[v25 + 0x8000] = imagp[v25 + 0x8000] - (float)(v22[v25 + 0x8000] * *v24);
      v24 += 256;
      v25 += 256;
    }
    while (v25 * 4);
    int v26 = 0;
    float v27 = imagp + 1;
    uint64_t v28 = v22 + 1;
    uint64_t v29 = realp + 1;
    float v30 = v21 + 1;
    float v31 = a3 + 1;
    do
    {
      for (uint64_t j = 0; j != 127; ++j)
      {
        float v33 = v31[j];
        v29[j] = v29[j] - (float)(v30[j] * v33);
        v27[j] = v27[j] - (float)(v28[j] * v33);
      }
      ++v26;
      v27 += 128;
      v28 += 128;
      v29 += 128;
      v30 += 128;
      v31 += 256;
    }
    while (v26 != 256);
  }
  _DWORD *v4 = *(_DWORD *)realp;
  unint64_t v34 = v4 + 128;
  v4[128] = *(_DWORD *)imagp;
  _DWORD *v6 = *((_DWORD *)realp + 128);
  v6[128] = *((_DWORD *)imagp + 128);
  uint64_t v35 = realp + 256;
  float v36 = (float *)(v4 + 256);
  for (uint64_t k = 65280; k != 0x8000; k -= 256)
  {
    *float v36 = sqrtf((float)(v35[128] * v35[128]) + (float)(*v35 * *v35));
    *(float *)&v4[k & 0xFFFFFF00] = sqrtf((float)(v35[128] * v35[128]) + (float)(*v35 * *v35));
    v35 += 256;
    v36 += 256;
  }
  unint64_t v38 = imagp + 256;
  unsigned int v39 = (float *)(v4 + 384);
  uint64_t v40 = 127;
  uint64_t v41 = 65408;
  do
  {
    float *v39 = sqrtf((float)(v38[128] * v38[128]) + (float)(*v38 * *v38));
    *(float *)&v4[v41 & 0xFFFFFF80] = sqrtf((float)(v38[128] * v38[128]) + (float)(*v38 * *v38));
    v38 += 256;
    v39 += 256;
    v41 -= 256;
    --v40;
  }
  while (v40);
  int v42 = 0;
  uint64_t v43 = imagp + 1;
  uint64_t v44 = realp + 1;
  unsigned int v45 = v4;
  do
  {
    uint64_t v46 = 0;
    uint64_t v47 = 255;
    do
    {
      *(float *)&v45[v46 + 1] = sqrtf((float)(v43[v46] * v43[v46]) + (float)(v44[v46] * v44[v46]));
      *(float *)&v45[v47] = sqrtf((float)(v43[v46] * v43[v46]) + (float)(v44[v46] * v44[v46]));
      ++v46;
      --v47;
    }
    while (v46 != 127);
    ++v42;
    v45 += 256;
    v43 += 128;
    v44 += 128;
  }
  while (v42 != 256);
  int v48 = 0;
  uint64_t v49 = v4;
  do
  {
    uint64_t v50 = 0;
    int v51 = v49 + 32896;
    do
    {
      long long v52 = *(_OWORD *)&v49[v50];
      *(_OWORD *)&v49[v50] = *(_OWORD *)&v51[v50];
      *(_OWORD *)&v51[v50] = v52;
      v50 += 4;
    }
    while (v50 != 128);
    v49 += 256;
    ++v48;
  }
  while (v48 != 128);
  int v53 = 0;
  uint64_t v54 = v6;
  do
  {
    for (uint64_t m = 0; m != 128; m += 4)
    {
      long long v56 = *(_OWORD *)&v34[m];
      *(_OWORD *)&v34[m] = *(_OWORD *)&v54[m];
      *(_OWORD *)&v54[m] = v56;
    }
    v34 += 256;
    v54 += 256;
    ++v53;
  }
  while (v53 != 128);
  int v57 = 0;
  uint64_t v58 = v4 + 65280;
  do
  {
    for (uint64_t n = 0; n != 128; n += 4)
    {
      long long v60 = *(_OWORD *)&v4[n + 256];
      *(_OWORD *)&v4[n + 256] = *(_OWORD *)&v58[n];
      *(_OWORD *)&v58[n] = v60;
    }
    v58 -= 256;
    ++v57;
    v4 += 256;
  }
  while (v57 != 127);
  vDSP_destroy_fftsetup(fftsetup);
  free(v12);
  free(v11);
  free(v63);
  free(v9);
  free(v8);
  free(v64);
  free(v10);
  free(v62);
  free(v61);
  v6[128] = 0;
}

float fftProject(uint64_t a1, float *a2, float *a3, float a4)
{
  id v5 = a2;
  unsigned int v7 = vcvtms_s32_f32(a4 * 126.0);
  int v8 = v7 * v7;
  bzero(a2, 0x1680uLL);
  float v9 = (char *)malloc_type_malloc(0x1680uLL, 0x100004052888210uLL);
  bzero(v9, 0x1680uLL);
  for (int i = -1; i != 127; ++i)
  {
    int v11 = vcvtms_s32_f32(sqrtf((float)(15876 - i * i)) + 0.5);
    if (v8 - i * i >= 0 && (int v12 = (int)(float)-floorf(sqrtf((float)(v8 - i * i)) + 0.5), v12 < 1))
    {
      innerLoopBlock(-v11, v12 - 1, i, (uint64_t)v5, (uint64_t)v9, a1);
      int v13 = 1 - v12;
    }
    else
    {
      int v13 = -v11;
    }
    innerLoopBlock(v13, v11, i, (uint64_t)v5, (uint64_t)v9, a1);
  }
  uint64_t v14 = 0;
  int v15 = 0;
  float v16 = 0.0;
  do
  {
    float v17 = v5[v14] / *(float *)&v9[4 * v14];
    *(float *)&v9[4 * v14] = v17;
    if (v17 > v16)
    {
      int v15 = v14;
      float v16 = v17;
    }
    ++v14;
  }
  while (v14 != 1440);
  uint64_t v18 = 5756;
  float v19 = 1.0 / v16;
  do
  {
    *v5++ = v19 * *(float *)&v9[v18];
    v18 -= 4;
  }
  while (v18 != -4);
  free(v9);
  float result = (float)(1439 - v15) * 0.125;
  *a3 = result;
  return result;
}

void innerLoopBlock(int a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a1 <= a2)
  {
    int v9 = a3 * a3;
    float v10 = (float)a3;
    uint64_t v11 = a1;
    uint64_t v12 = (a3 << 8) + 32896;
    int v13 = a2 + 1;
    while (1)
    {
      float v15 = atan2f(v10, (float)(int)v11);
      if (v15 < 0.0)
      {
        float v16 = v15 + 6.28318531;
        float v15 = v16;
      }
      uint64_t v21 = (v9 + v11 * v11);
      float v17 = (float)((float)(0.70711 / sqrtf((float)(int)v21)) * 1440.0) / 3.14159265;
      float v18 = v15 / 3.14159265 * 1440.0;
      float v19 = v18 - v17;
      float v20 = v17 + v18;
      LODWORD(v14) = vcvtms_s32_f32(v19 + 0.5);
      LODWORD(v21) = vcvtms_s32_f32(v20 + 0.5);
      if (v21 != v14) {
        break;
      }
      if (v14 <= 0x59F)
      {
        float v22 = v20 - v19;
        *(float *)(a4 + 4 * v14) = *(float *)(a4 + 4 * v14)
                                                 + (float)(*(float *)(a6 + 4 * (v11 + v12)) * v22);
LABEL_26:
        *(float *)(a5 + 4 * v14) = v22 + *(float *)(a5 + 4 * v14);
      }
LABEL_27:
      if (v13 == ++v11) {
        return;
      }
    }
    if (v21 - v14 == 1)
    {
      if (v19 >= 0.0 && (int)v14 <= 1439)
      {
        float v23 = (float)(v14 + 1) - v19;
        *(float *)(a4 + 4 * (int)v14) = *(float *)(a4 + 4 * (int)v14)
                                        + (float)(*(float *)(a6 + 4 * (v11 + v12)) * v23);
        *(float *)(a5 + 4 * (int)v14) = v23 + *(float *)(a5 + 4 * (int)v14);
      }
      if ((v21 & 0x80000000) != 0 || v20 >= 1440.0) {
        goto LABEL_27;
      }
      float v22 = (float)(v21 - 1) - v20;
      float v24 = *(float *)(a6 + 4 * (v11 + v12));
    }
    else
    {
      float v24 = *(float *)(a6 + 4 * (v11 + v12));
      int v25 = v14 + 1;
      if ((v14 & 0x80000000) == 0 && v19 < 1440.0)
      {
        float v26 = (float)v25 - v19;
        *(float *)(a4 + 4 * v14) = *(float *)(a4 + 4 * v14) + (float)(v24 * v26);
        *(float *)(a5 + 4 * v14) = v26 + *(float *)(a5 + 4 * v14);
      }
      if (v25 < (int)v21)
      {
        do
        {
          if (v25 - 1 >= -1 && v25 <= 1439)
          {
            *(float *)(a4 + 4 * v25) = v24 + *(float *)(a4 + 4 * v25);
            *(float *)(a5 + 4 * v25) = *(float *)(a5 + 4 * v25) + 1.0;
          }
          ++v25;
        }
        while (v21 != v25);
      }
      if (v21 > 0x59F) {
        goto LABEL_27;
      }
      float v22 = (float)(v21 - 1) - v20;
    }
    *(float *)(a4 + 4 * v21) = *(float *)(a4 + 4 * v21) + (float)(v24 * v22);
    uint64_t v14 = v21;
    goto LABEL_26;
  }
}

void vision::mod::GreedyClusterer::deserializeStatus(vision::mod::GreedyClusterer *this, int a2, int a3)
{
  size_t v12 = 0;
  read(a2, &v12, 8uLL);
  std::string::basic_string[abi:ne180100](__b, v12, 48);
  if (v11 >= 0) {
    id v6 = __b;
  }
  else {
    id v6 = (void **)__b[0];
  }
  read(a2, v6, v12);
  createFullPath(&__p, *((void *)this + 7), (uint64_t)__b);
  if (a3)
  {
    cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createReadOnlyFromContentsOfFile((uint64_t)&__p);
    uint64_t v7 = *((void *)this + 7);
    int v8 = *(std::__shared_weak_count **)(v7 + 80);
    *(void *)(v7 + 72) = 0;
    *(void *)(v7 + 80) = 0;
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
    std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>::reset[abi:ne180100]<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const,void>();
  }
  cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createFromContentsOfFile((uint64_t)&__p);
}

void sub_1A403B508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A403B640(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  _Unwind_Resume(exception_object);
}

BOOL vision::mod::GreedyClusterer::serializeStatus(vision::mod::GreedyClusterer *this, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  VNValidatedLog(1, @"  GreedyClusterer::serializeStatus - enter", a3, a4, a5, a6, a7, a8, v48);
  if (a2 == -1)
  {
    VNValidatedLog(4, @"  GreedyClusterer: Failed to open file - skipping serialization", v10, v11, v12, v13, v14, v15, v49);
  }
  else
  {
    vision::mod::GreedyClusterer::private_t::clusters_t::newMapFilePath(&__s, *((void *)this + 7));
    getRelativePath(&__str, *((char **)this + 7), &__s);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_s = &__s;
    }
    else {
      p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    }
    VNValidatedLog(1, @"  GreedyClusterer::serializeStatus - saving map file: %s", v16, v17, v18, v19, v20, v21, (uint64_t)p_s);
    uint64_t v23 = *((void *)this + 7);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      float v24 = &__s;
    }
    else {
      float v24 = (std::string *)__s.__r_.__value_.__r.__words[0];
    }
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)v24);
    uint64_t v31 = *(void *)(v23 + 88);
    if (v31 || (uint64_t v31 = *(void *)(v23 + 72)) != 0)
    {
      int v32 = cvml::util::MMapFileBackingStore::writeToFile(v31, (uint64_t)__p);
      char v33 = 0;
    }
    else
    {
      int v32 = 0;
      char v33 = 1;
    }
    if (v52 < 0) {
      operator delete(__p[0]);
    }
    if (v32) {
      char v34 = v33;
    }
    else {
      char v34 = 1;
    }
    if (v34)
    {
      VNValidatedLog(4, @"  GreedyClusterer: failed to save the file", v25, v26, v27, v28, v29, v30, v50);
      exceptiouint64_t n = __cxa_allocate_exception(8uLL);
      *exceptiouint64_t n = 5236;
      __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
    }
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    __p[0] = (void *)size;
    write(a2, __p, 8uLL);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_str = &__str;
    }
    else {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    write(a2, p_str, (size_t)__p[0]);
    std::string::operator=((std::string *)(*((void *)this + 7) + 24), &__str);
    write(a2, (const void *)(*((void *)this + 7) + 104), 4uLL);
    write(a2, (const void *)(*((void *)this + 7) + 112), 8uLL);
    __p[0] = (void *)((uint64_t)(*(void *)(*((void *)this + 7) + 56) - *(void *)(*((void *)this + 7) + 48)) >> 2);
    write(a2, __p, 8uLL);
    uint64_t v43 = *(void *)(*((void *)this + 7) + 48);
    if ((int)((unint64_t)(*(void *)(*((void *)this + 7) + 56) - v43) >> 2) >= 1)
    {
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      do
      {
        write(a2, (const void *)(v43 + v44), 4uLL);
        ++v45;
        uint64_t v43 = *(void *)(*((void *)this + 7) + 48);
        v44 += 4;
      }
      while (v45 < (int)((unint64_t)(*(void *)(*((void *)this + 7) + 56) - v43) >> 2));
    }
    VNValidatedLog(1, @"  GreedyClusterer::serializeStatus - done", v37, v38, v39, v40, v41, v42, v50);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
  }
  return a2 != -1;
}

void sub_1A403B8E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void vision::mod::GreedyClusterer::private_t::clusters_t::newMapFilePath(std::string *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  *(void *)uu = 0;
  uint64_t v18 = 0;
  MEMORY[0x1A6257C60](uu);
  memset(out, 0, 37);
  uuid_unparse(uu, out);
  std::string::basic_string[abi:ne180100]<0>(&v14, out);
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    id v5 = (const std::string::value_type *)a2;
  }
  else {
    id v5 = *(const std::string::value_type **)a2;
  }
  if (v4 >= 0) {
    std::string::size_type v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v6 = *(void *)(a2 + 8);
  }
  uint64_t v7 = std::string::insert(&v14, 0, v5, v6);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, ".cmap");
  if ((v13 & 0x80u) == 0) {
    int v9 = __p;
  }
  else {
    int v9 = (void **)__p[0];
  }
  if ((v13 & 0x80u) == 0) {
    std::string::size_type v10 = v13;
  }
  else {
    std::string::size_type v10 = (std::string::size_type)__p[1];
  }
  uint64_t v11 = std::string::append(&v15, (const std::string::value_type *)v9, v10);
  *a1 = *v11;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if ((char)v13 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
}

void sub_1A403BA88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void vision::mod::GreedyClusterer::~GreedyClusterer(vision::mod::GreedyClusterer *this)
{
  vision::mod::GreedyClusterer::~GreedyClusterer(this);

  JUMPOUT(0x1A62562C0);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF752300;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  CFDictionaryRef v3 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void non-virtual thunk to'vision::mod::GreedyClustererFaces::~GreedyClustererFaces(vision::mod::GreedyClustererFaces *this)
{
  vision::mod::GreedyClustererFaces::~GreedyClustererFaces((vision::mod::GreedyClustererFaces *)((char *)this - 8));

  JUMPOUT(0x1A62562C0);
}

{
  vision::mod::GreedyClustererFaces::~GreedyClustererFaces((vision::mod::GreedyClustererFaces *)((char *)this - 8));
}

void vision::mod::GreedyClustererFaces::~GreedyClustererFaces(vision::mod::GreedyClustererFaces *this)
{
  *(void *)this = &unk_1EF752498;
  uint64_t v2 = (vision::mod::GreedyClustererFaces *)((char *)this + 8);
  *((void *)this + 1) = &unk_1EF752578;
  if (*((char *)this + 207) < 0) {
    operator delete(*((void **)this + 23));
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((void **)this + 21));
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((void **)this + 18));
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((void **)this + 15));
  std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(*((void **)this + 12));
  vision::mod::GreedyClusterer::~GreedyClusterer(v2);
}

{
  uint64_t vars8;

  vision::mod::GreedyClustererFaces::~GreedyClustererFaces(this);

  JUMPOUT(0x1A62562C0);
}

uint64_t vision::mod::GreedyClustererFaces::getCountForCluster(vision::mod::GreedyClustererFaces *this, uint64_t a2)
{
  if (!vision::mod::GreedyClustererFaces::isFaceIdInClustererState(this, a2)) {
    return 0;
  }
  int v4 = (char *)this + 144;
  id v5 = (void *)*((void *)this + 18);
  if (!v5) {
    goto LABEL_12;
  }
  std::string::size_type v6 = (char *)this + 144;
  do
  {
    uint64_t v7 = v5[4];
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = v5;
    }
    else {
      int v9 = v5 + 1;
    }
    if (!v8) {
      std::string::size_type v6 = (char *)v5;
    }
    id v5 = (void *)*v9;
  }
  while (*v9);
  if (v6 == v4 || *((void *)v6 + 4) > a2) {
LABEL_12:
  }
    std::string::size_type v6 = (char *)this + 144;
  std::string::size_type v10 = (char *)*((void *)this + 17);
  if (v10 == v4) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v12 = *((void *)v6 + 5);
  do
  {
    if (*((void *)v10 + 5) == v12) {
      ++result;
    }
    unsigned __int8 v13 = (char *)*((void *)v10 + 1);
    if (v13)
    {
      do
      {
        std::string v14 = v13;
        unsigned __int8 v13 = *(char **)v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        std::string v14 = (char *)*((void *)v10 + 2);
        BOOL v15 = *(void *)v14 == (void)v10;
        std::string::size_type v10 = v14;
      }
      while (!v15);
    }
    std::string::size_type v10 = v14;
  }
  while (v14 != v4);
  return result;
}

uint64_t vision::mod::GreedyClustererFaces::isFaceIdInClustererState(vision::mod::GreedyClustererFaces *this, uint64_t a2)
{
  uint64_t v2 = (void *)*((void *)this + 18);
  if (!v2)
  {
    CFDictionaryRef v3 = "FaceId=%lld not present in clustering";
LABEL_9:
    syslog(5, v3, a2);
    return 0;
  }
  CFDictionaryRef v3 = "FaceId=%lld not present in clustering";
  while (1)
  {
    uint64_t v4 = v2[4];
    if (v4 <= a2) {
      break;
    }
LABEL_6:
    uint64_t v2 = (void *)*v2;
    if (!v2) {
      goto LABEL_9;
    }
  }
  if (v4 < a2)
  {
    ++v2;
    goto LABEL_6;
  }
  std::string::size_type v6 = (void *)*((void *)this + 15);
  if (!v6)
  {
    syslog(5, "FaceId=%lld not present in l0 clustering");
    return 0;
  }
  CFDictionaryRef v3 = "FaceId=%lld not present in l0 clustering";
  while (1)
  {
    uint64_t v7 = v6[4];
    if (v7 <= a2) {
      break;
    }
LABEL_17:
    std::string::size_type v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_9;
    }
  }
  if (v7 < a2)
  {
    ++v6;
    goto LABEL_17;
  }
  return 1;
}

uint64_t vision::mod::GreedyClustererFaces::removeIds(uint64_t **this, uint64_t *a2, uint64_t **a3)
{
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = &v43;
  uint64_t v4 = *a2;
  if (a2[1] == *a2)
  {
LABEL_40:
    vision::mod::GreedyClustererFaces::computeDeltaAfterUpdate((uint64_t)this, a3, (uint64_t *)&v42);
    float v36 = &CVML_status_ok;
  }
  else
  {
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = (uint64_t *)(v4 + 8 * v6);
      if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)this, *v7) & 1) == 0) {
        break;
      }
      uint64_t v41 = 0;
      uint64_t v8 = (uint64_t)std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(this + 14, *v7, (uint64_t **)v7)[5];
      uint64_t v41 = v8;
      std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&v42, v8, v8);
      uint64_t v9 = this[8][9];
      if (v9) {
        unint64_t v10 = *(void *)v9 + v8 * (unint64_t)*(unsigned int *)(*(void *)v9 + 16) + 24;
      }
      else {
        unint64_t v10 = 0;
      }
      --*(_DWORD *)(v10 + 8);
      uint64_t v11 = std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(this + 11, v8, &v41);
      uint64_t v12 = v11 + 5;
      unsigned __int8 v13 = (uint64_t *)std::remove[abi:ne180100]<std::__list_iterator<long long,void *>,long long>(v11[6], (uint64_t)(v11 + 5), v7);
      std::list<long long>::erase((uint64_t)v12, v13, v12);
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__erase_unique<long long>(this + 14, *v7);
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__erase_unique<long long>(this + 17, *v7);
      if (!*(_DWORD *)(v10 + 8))
      {
        std::string v14 = this[8];
        __int32 v45 = v8;
        BOOL v15 = (__int32 *)v14[7];
        uint64_t v16 = wmemchr((__int32 *)v14[6], v8, ((uint64_t)v15 - v14[6]) >> 2);
        if (v16) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v15;
        }
        uint64_t v18 = (__int32 *)v14[7];
        if (v17 == v18 || (uint64_t v19 = (void *)v14[9]) == 0)
        {
          exceptiouint64_t n = __cxa_allocate_exception(8uLL);
          *exceptiouint64_t n = 5246;
          __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
        }
        uint64_t v20 = *v19;
        if (*(_DWORD *)(*v19 + 12) > v8)
        {
          uint64_t v21 = v19[7];
          uint64_t v22 = v8 >> 6;
          uint64_t v23 = *(void *)(v21 + 8 * v22);
          if ((v23 & (1 << v8)) != 0)
          {
            *(_DWORD *)(v20 + *(void *)v20 + 4 * *(unsigned int *)(v20 + 8)) = v8;
            *(void *)(v21 + 8 * v22) = v23 & ~(1 << v8);
            ++*(_DWORD *)(v20 + 8);
          }
        }
        float v24 = std::remove[abi:ne180100]<std::__wrap_iter<unsigned int *>,unsigned int>((__int32 *)v14[6], v18, &v45);
        if ((__int32 *)v14[7] != v24) {
          v14[7] = (uint64_t)v24;
        }
        std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__erase_unique<unsigned long>(this + 11, v8);
        if (v43)
        {
          uint64_t v25 = (uint64_t *)&v43;
          uint64_t v26 = v43;
          do
          {
            uint64_t v27 = v26;
            uint64_t v28 = v25;
            uint64_t v29 = v26[4];
            uint64_t v30 = v26 + 1;
            if (v29 >= v8) {
              uint64_t v25 = v26;
            }
            else {
              ++v26;
            }
            uint64_t v26 = (uint64_t *)*v26;
          }
          while (v26);
          if (v25 != (uint64_t *)&v43)
          {
            if (v29 < v8) {
              uint64_t v27 = v28;
            }
            if (v8 >= v27[4])
            {
              uint64_t v31 = v28 + 1;
              if (v29 >= v8) {
                uint64_t v31 = v30;
              }
              int v32 = (uint64_t *)*v31;
              char v33 = v25;
              if (*v31)
              {
                do
                {
                  char v34 = (uint64_t **)v32;
                  int v32 = (uint64_t *)*v32;
                }
                while (v32);
              }
              else
              {
                do
                {
                  char v34 = (uint64_t **)v33[2];
                  BOOL v35 = *v34 == v33;
                  char v33 = (uint64_t *)v34;
                }
                while (!v35);
              }
              if (v42 == (uint64_t **)v25) {
                uint64_t v42 = v34;
              }
              --v44;
              std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v43, v25);
              operator delete(v25);
            }
          }
        }
      }
      ++v6;
      uint64_t v4 = *a2;
      if (v6 >= (a2[1] - *a2) >> 3) {
        goto LABEL_40;
      }
    }
    float v36 = &CVML_status_invalidParameter;
  }
  uint64_t v37 = (*v36 + 128) | 0x1400;
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v43);
  return v37;
}

void sub_1A403C124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

uint64_t *std::__tree<long long>::__emplace_unique_key_args<long long,long long>(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (uint64_t **)result;
  unint64_t v6 = (uint64_t **)(result + 1);
  id v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        id v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      id v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x28uLL);
    void v9[4] = a3;
    return std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

void vision::mod::GreedyClustererFaces::computeDeltaAfterUpdate(uint64_t a1, uint64_t **a2, uint64_t *a3)
{
  uint64_t v4 = a1;
  *(unsigned char *)(a1 + 80) = 1;
  id v5 = operator new(0x30uLL);
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = 0;
  unint64_t v6 = (void **)(v5 + 3);
  *id v5 = &unk_1EF753C08;
  v5[4] = 0;
  void v5[5] = 0;
  __int16 v158 = (void **)(v5 + 3);
  uint64_t v160 = (uint64_t)v5;
  atomic_fetch_add_explicit(v5 + 1, 1uLL, memory_order_relaxed);
  __p[1] = 0;
  *(void *)&long long v167 = 0;
  __p[0] = &__p[1];
  int v178 = 0;
  unint64_t v179 = 0;
  uint64_t v177 = &v178;
  uint64_t v7 = *(void **)(v4 + 136);
  uint64_t v151 = (uint64_t **)(v4 + 136);
  __int16 v157 = (void *)(v4 + 144);
  uint64_t v154 = v4;
  if (v7 == (void *)(v4 + 144)) {
    goto LABEL_112;
  }
  do
  {
    uint64_t v8 = v7[5];
    uint64_t v9 = *std::map<long long,unsigned long>::at(*(void **)(v4 + 120), v7[4]);
    unint64_t v10 = (void **)__p[1];
    uint64_t v11 = &__p[1];
    uint64_t v12 = &__p[1];
    if (__p[1])
    {
      while (1)
      {
        while (1)
        {
          uint64_t v12 = v10;
          uint64_t v13 = (uint64_t)v10[4];
          if (v8 >= v13) {
            break;
          }
          unint64_t v10 = (void **)*v12;
          uint64_t v11 = v12;
          if (!*v12) {
            goto LABEL_9;
          }
        }
        if (v13 >= v8) {
          break;
        }
        unint64_t v10 = (void **)v12[1];
        if (!v10)
        {
          uint64_t v11 = v12 + 1;
          goto LABEL_9;
        }
      }
      std::string v14 = (uint64_t *)v12;
    }
    else
    {
LABEL_9:
      std::string v14 = (uint64_t *)operator new(0x40uLL);
      v14[7] = 0;
      v14[6] = 0;
      v14[4] = v8;
      v14[5] = (uint64_t)(v14 + 6);
      *std::string v14 = 0;
      v14[1] = 0;
      v14[2] = (uint64_t)v12;
      *uint64_t v11 = v14;
      BOOL v15 = v14;
      if (*(void *)__p[0])
      {
        __p[0] = *(void **)__p[0];
        BOOL v15 = (uint64_t *)*v11;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)__p[1], v15);
      *(void *)&long long v167 = v167 + 1;
    }
    std::__tree<long long>::__emplace_unique_key_args<long long,long long>(v14 + 5, v9, v9);
    uint64_t v16 = (void *)a3[1];
    if (!v16) {
      goto LABEL_20;
    }
    while (1)
    {
      uint64_t v17 = v16[4];
      if (v9 >= v17) {
        break;
      }
LABEL_17:
      uint64_t v16 = (void *)*v16;
      if (!v16) {
        goto LABEL_20;
      }
    }
    if (v17 < v9)
    {
      ++v16;
      goto LABEL_17;
    }
    std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&v177, v8, v8);
LABEL_20:
    uint64_t v18 = (void *)v7[1];
    if (v18)
    {
      do
      {
        uint64_t v19 = v18;
        uint64_t v18 = (void *)*v18;
      }
      while (v18);
    }
    else
    {
      do
      {
        uint64_t v19 = (void *)v7[2];
        BOOL v20 = *v19 == (void)v7;
        uint64_t v7 = v19;
      }
      while (!v20);
    }
    uint64_t v7 = v19;
  }
  while (v19 != v157);
  uint64_t v21 = (void **)__p[0];
  if (__p[0] == &__p[1]) {
    goto LABEL_112;
  }
  uint64_t v152 = v4 + 8;
  while (2)
  {
    int v174 = (uint64_t *)v21[4];
    std::set<long long>::set[abi:ne180100](&v175, v21 + 5);
    uint64_t v22 = v174;
    std::set<long long>::set[abi:ne180100](&v170, &v175);
    uint64_t v23 = v178;
    if (!v178)
    {
LABEL_33:
      uint64_t v25 = v170;
      if (v170 != v171)
      {
        LODWORD(v26) = -1;
        do
        {
          uint64_t v27 = v25[4];
          if (v26 == -1)
          {
            uint64_t v26 = v25[4];
          }
          else
          {
            if ((uint64_t)v27 <= (int)v26) {
              __assert_rtn("computeInitialMergingList", "GreedyClustering.cpp", 1781, "L0 > mergingTo");
            }
            uint64_t v29 = *(char **)(v160 + 32);
            unint64_t v28 = *(void *)(v160 + 40);
            if ((unint64_t)v29 >= v28)
            {
              uint64_t v31 = (char *)*v6;
              uint64_t v32 = (v29 - (unsigned char *)*v6) >> 4;
              unint64_t v33 = v32 + 1;
              if ((unint64_t)(v32 + 1) >> 60) {
                std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v34 = v28 - (void)v31;
              if (v34 >> 3 > v33) {
                unint64_t v33 = v34 >> 3;
              }
              BOOL v91 = (unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0;
              unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
              if (!v91) {
                unint64_t v35 = v33;
              }
              if (v35)
              {
                unint64_t v35 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v35);
                uint64_t v31 = *(char **)(v160 + 24);
                uint64_t v29 = *(char **)(v160 + 32);
              }
              else
              {
                uint64_t v36 = 0;
              }
              uint64_t v37 = (void *)(v35 + 16 * v32);
              *uint64_t v37 = (int)v26;
              v37[1] = v27;
              uint64_t v38 = v37;
              if (v29 == v31)
              {
                unint64_t v6 = v158;
              }
              else
              {
                unint64_t v6 = v158;
                do
                {
                  *((_OWORD *)v38 - 1) = *((_OWORD *)v29 - 1);
                  v38 -= 2;
                  v29 -= 16;
                }
                while (v29 != v31);
                uint64_t v31 = (char *)*v158;
              }
              uint64_t v30 = v37 + 2;
              *(void *)(v160 + 24) = v38;
              *(void *)(v160 + 32) = v37 + 2;
              *(void *)(v160 + 40) = v35 + 16 * v36;
              if (v31) {
                operator delete(v31);
              }
            }
            else
            {
              *(void *)uint64_t v29 = (int)v26;
              *((void *)v29 + 1) = v27;
              uint64_t v30 = v29 + 16;
            }
            *(void *)(v160 + 32) = v30;
          }
          uint64_t v39 = v25[1];
          if (v39)
          {
            do
            {
              uint64_t v40 = (void **)v39;
              uint64_t v39 = (void *)*v39;
            }
            while (v39);
          }
          else
          {
            do
            {
              uint64_t v40 = (void **)v25[2];
              BOOL v20 = *v40 == v25;
              uint64_t v25 = v40;
            }
            while (!v20);
          }
          uint64_t v25 = v40;
        }
        while (v40 != v171);
      }
      goto LABEL_106;
    }
    while (2)
    {
      uint64_t v24 = *((void *)v23 + 4);
      if ((uint64_t)v22 < v24)
      {
LABEL_32:
        uint64_t v23 = *(char **)v23;
        if (!v23) {
          goto LABEL_33;
        }
        continue;
      }
      break;
    }
    if (v24 < (uint64_t)v22)
    {
      v23 += 8;
      goto LABEL_32;
    }
    uint64_t v41 = (std::__shared_weak_count *)operator new(0x30uLL);
    v41->__shared_weak_owners_ = 0;
    v41->__shared_owners_ = 0;
    v41->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753C08;
    v41[1].__shared_owners_ = 0;
    v41[1].__shared_weak_owners_ = 0;
    v41[1].__vftable = 0;
    float v161 = v41 + 1;
    float v162 = &v41->__vftable;
    atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
    vision::mod::GreedyClusterer::computeMergePairs(v152, &v170, &v170, (uint64_t *)&v161, 0);
    std::__shared_weak_count::__release_shared[abi:nn180100](v41);
    v165[0] = 0;
    v165[1] = 0;
    DSPSplitComplex __C = v165;
    uint64_t v42 = (uint64_t *)v41[1].__vftable;
    uint64_t shared_owners = (uint64_t *)v41[1].__shared_owners_;
    while (v42 != shared_owners)
    {
      uint64_t v45 = *v42;
      uint64_t v44 = v42[1];
      std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&__C, *v42, *v42);
      std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&__C, v44, v44);
      uint64_t v46 = (void *)a3[1];
      if (v46)
      {
        uint64_t v47 = (void *)a3[1];
        do
        {
          uint64_t v48 = v47[4];
          if (v45 >= v48)
          {
            if (v48 >= v45) {
              goto LABEL_91;
            }
            ++v47;
          }
          uint64_t v47 = (void *)*v47;
        }
        while (v47);
        do
        {
          uint64_t v49 = v46[4];
          if (v44 >= v49)
          {
            if (v49 >= v44) {
              goto LABEL_91;
            }
            ++v46;
          }
          uint64_t v46 = (void *)*v46;
        }
        while (v46);
      }
      int v51 = *(uint64_t **)(v160 + 32);
      unint64_t v50 = *(void *)(v160 + 40);
      if ((unint64_t)v51 >= v50)
      {
        int v53 = (uint64_t *)*v158;
        uint64_t v54 = ((char *)v51 - (unsigned char *)*v158) >> 4;
        unint64_t v55 = v54 + 1;
        if ((unint64_t)(v54 + 1) >> 60) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v56 = v50 - (void)v53;
        if (v56 >> 3 > v55) {
          unint64_t v55 = v56 >> 3;
        }
        BOOL v91 = (unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0;
        unint64_t v57 = 0xFFFFFFFFFFFFFFFLL;
        if (!v91) {
          unint64_t v57 = v55;
        }
        if (v57)
        {
          unint64_t v57 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v57);
          int v53 = *(uint64_t **)(v160 + 24);
          int v51 = *(uint64_t **)(v160 + 32);
        }
        else
        {
          uint64_t v58 = 0;
        }
        unsigned int v59 = (uint64_t *)(v57 + 16 * v54);
        *unsigned int v59 = v45;
        v59[1] = v44;
        long long v60 = v59;
        if (v51 != v53)
        {
          do
          {
            *((_OWORD *)v60 - 1) = *((_OWORD *)v51 - 1);
            v60 -= 2;
            v51 -= 2;
          }
          while (v51 != v53);
          int v53 = (uint64_t *)*v158;
        }
        char v52 = v59 + 2;
        *(void *)(v160 + 24) = v60;
        *(void *)(v160 + 32) = v59 + 2;
        *(void *)(v160 + 40) = v57 + 16 * v58;
        if (v53) {
          operator delete(v53);
        }
      }
      else
      {
        uint64_t *v51 = v45;
        v51[1] = v44;
        char v52 = v51 + 2;
      }
      *(void *)(v160 + 32) = v52;
LABEL_91:
      v42 += 2;
    }
    uint64_t v61 = v170;
    uint64_t v4 = v154;
    unint64_t v6 = v158;
    if (v170 != v171)
    {
      do
      {
        uint64_t v62 = (uint64_t)v61[4];
        for (int i = v165[0]; i; int i = (void *)*i)
        {
          uint64_t v64 = i[4];
          if (v62 >= v64)
          {
            if (v64 >= v62) {
              goto LABEL_99;
            }
            ++i;
          }
        }
        std::__tree<long long>::__emplace_unique_key_args<long long,long long>(a3, v62, (uint64_t)v61[4]);
LABEL_99:
        DSPSplitComplex v65 = v61[1];
        if (v65)
        {
          do
          {
            uint64_t v66 = (void **)v65;
            DSPSplitComplex v65 = (void *)*v65;
          }
          while (v65);
        }
        else
        {
          do
          {
            uint64_t v66 = (void **)v61[2];
            BOOL v20 = *v66 == v61;
            uint64_t v61 = v66;
          }
          while (!v20);
        }
        uint64_t v61 = v66;
      }
      while (v66 != v171);
    }
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v165[0]);
    std::__shared_weak_count::__release_shared[abi:nn180100](v41);
LABEL_106:
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v171[0]);
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v176);
    unsigned int v67 = (void **)v21[1];
    if (v67)
    {
      do
      {
        uint64_t v68 = v67;
        unsigned int v67 = (void **)*v67;
      }
      while (v67);
    }
    else
    {
      do
      {
        uint64_t v68 = (void **)v21[2];
        BOOL v20 = *v68 == v21;
        uint64_t v21 = v68;
      }
      while (!v20);
    }
    uint64_t v21 = v68;
    if (v68 != &__p[1]) {
      continue;
    }
    break;
  }
LABEL_112:
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v178);
  std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy((void *)__p[1]);
  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v160);
  uint64_t v69 = (atomic_ullong *)(v160 + 8);
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v160 + 8), 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v160 + 8), 1uLL, memory_order_relaxed);
  uint64_t v70 = *(void *)(v4 + 64);
  if (*(void *)(v70 + 56) != *(void *)(v70 + 48))
  {
    vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)&v174, *(_DWORD *)(v70 + 104), *(_DWORD *)(v4 + 28));
    uint64_t v71 = *(void *)(v4 + 64);
    int v178 = 0;
    unint64_t v179 = 0;
    uint64_t v177 = &v178;
    if (*(void *)(v71 + 56) != *(void *)(v71 + 48))
    {
      unint64_t v72 = 0;
      int64_t v73 = (uint64_t *)*a3;
      uint64_t v74 = v71;
      do
      {
        unsigned int v75 = *(_DWORD *)(*(void *)(v71 + 48) + 4 * v72);
        if (v75 != *(_DWORD *)(**(void **)(v74 + 72)
                              + *(unsigned int *)(**(void **)(v74 + 72) + 16) * (unint64_t)v75
                              + 24))
          __assert_rtn("getMergeableClusters", "GreedyClustering.cpp", 978, "ci == clusterID");
        if (v73 == a3 + 1 || v73[4] != v75)
        {
          std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&v177, (int)v75, (int)v75);
          uint64_t v74 = *(void *)(v4 + 64);
        }
        else
        {
          unsigned int v76 = (uint64_t *)v73[1];
          if (v76)
          {
            do
            {
              int64_t v73 = v76;
              unsigned int v76 = (uint64_t *)*v76;
            }
            while (v76);
          }
          else
          {
            do
            {
              float v77 = v73;
              int64_t v73 = (uint64_t *)v73[2];
            }
            while ((uint64_t *)*v73 != v77);
          }
        }
        ++v72;
      }
      while (v72 < (uint64_t)(*(void *)(v74 + 56) - *(void *)(v74 + 48)) >> 2);
    }
    v173[0] = (uint64_t)v6;
    v173[1] = v160;
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v160 + 8), 1uLL, memory_order_relaxed);
    vision::mod::GreedyClusterer::computeMergePairs(v4 + 8, &v177, a3, v173, 1);
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v160);
    v172[0] = (uint64_t)v6;
    v172[1] = v160;
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v160 + 8), 1uLL, memory_order_relaxed);
    vision::mod::GreedyClusterer::computeMergePairs(v4 + 8, a3, a3, v172, 0);
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v160);
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v160 + 8), 1uLL, memory_order_relaxed);
    vision::mod::GreedyClusterer::getConnectedComponents((uint64_t *)&v170, v4 + 8, *(uint64_t ***)(v160 + 24), *(uint64_t ***)(v160 + 32));
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v160);
    uint64_t v78 = *(void *)(v4 + 64);
    *(_OWORD *)std::string __p = 0u;
    long long v167 = 0u;
    long long v168 = 0u;
    uint64_t v169 = 0;
    unsigned int v79 = *(void **)(v78 + 72);
    if (v79) {
      cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createDeepCopy(v79);
    }
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 5215;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v160);
  atomic_fetch_add_explicit(v69, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(v69, 1uLL, memory_order_relaxed);
  vision::mod::GreedyClusterer::getConnectedComponents((uint64_t *)&v174, v4 + 8, *(uint64_t ***)(v160 + 24), *(uint64_t ***)(v160 + 32));
  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v160);
  float v161 = 0;
  float v162 = 0;
  unint64_t v163 = 0;
  unsigned int v80 = v174;
  __int16 v153 = v175;
  if (v174 != v175)
  {
    float v81 = (void *)(v4 + 96);
    do
    {
      __p[0] = 0;
      __p[1] = 0;
      *(void *)&long long v167 = 0;
      std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(__p, (const void *)*v80, v80[1], (v80[1] - *v80) >> 3);
      uint64_t v82 = *(void *)(v4 + 64);
      if (*(unsigned char *)(v82 + 120))
      {
        *(unsigned char *)(v82 + 120) = 0;
        uint64_t v148 = __cxa_allocate_exception(8uLL);
        *uint64_t v148 = 5219;
        __cxa_throw(v148, MEMORY[0x1E4FBA3E0], 0);
      }
      uint64_t v177 = 0;
      int v178 = 0;
      unint64_t v179 = 0;
      unsigned int v84 = (unint64_t *)__p[0];
      unsigned int v83 = (unint64_t *)__p[1];
      if (__p[0] == __p[1])
      {
        unint64_t v85 = 0;
      }
      else
      {
        unint64_t v85 = 0;
        unsigned int v86 = (unint64_t *)__p[0];
        do
        {
          if (*v81)
          {
            unint64_t v87 = *v86;
            unsigned int v88 = v81;
            float v89 = (void *)*v81;
            do
            {
              unint64_t v90 = v89[4];
              BOOL v91 = v90 >= v87;
              if (v90 >= v87) {
                int v92 = v89;
              }
              else {
                int v92 = v89 + 1;
              }
              if (v91) {
                unsigned int v88 = v89;
              }
              float v89 = (void *)*v92;
            }
            while (*v92);
            if (v88 != v81 && v87 >= v88[4]) {
              v85 += v88[7];
            }
          }
          ++v86;
        }
        while (v86 != __p[1]);
      }
      std::vector<long long>::reserve((void **)&v177, v85);
      uint64_t v156 = v80;
      for (uint64_t j = v83; v84 != v83; ++v84)
      {
        uint64_t v93 = (void *)*v81;
        if (*v81)
        {
          unint64_t v94 = *v84;
          int v95 = v81;
          do
          {
            unint64_t v96 = v93[4];
            BOOL v97 = v96 >= v94;
            if (v96 >= v94) {
              int v98 = v93;
            }
            else {
              int v98 = v93 + 1;
            }
            if (v97) {
              int v95 = v93;
            }
            uint64_t v93 = (void *)*v98;
          }
          while (*v98);
          if (v95 != v81 && v94 >= v95[4])
          {
            uint64_t v99 = v95 + 5;
            float v100 = (void *)v95[6];
            if (v100 != v95 + 5)
            {
              uint64_t v101 = v178;
              unint64_t v102 = v179;
              uint64_t v103 = (char *)v177;
              do
              {
                uint64_t v104 = v100[2];
                if ((unint64_t)v101 >= v102)
                {
                  uint64_t v106 = (v101 - v103) >> 3;
                  unint64_t v107 = v106 + 1;
                  if ((unint64_t)(v106 + 1) >> 61)
                  {
                    unint64_t v179 = v102;
                    uint64_t v177 = (char **)v103;
                    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                  }
                  if ((uint64_t)(v102 - (void)v103) >> 2 > v107) {
                    unint64_t v107 = (uint64_t)(v102 - (void)v103) >> 2;
                  }
                  if (v102 - (unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v108 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v108 = v107;
                  }
                  if (v108) {
                    unint64_t v108 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v108);
                  }
                  else {
                    uint64_t v109 = 0;
                  }
                  uint64_t v110 = (char *)(v108 + 8 * v106);
                  *(void *)uint64_t v110 = v104;
                  float v105 = v110 + 8;
                  while (v101 != v103)
                  {
                    uint64_t v111 = *((void *)v101 - 1);
                    v101 -= 8;
                    *((void *)v110 - 1) = v111;
                    v110 -= 8;
                  }
                  unint64_t v102 = v108 + 8 * v109;
                  int v178 = v105;
                  if (v103) {
                    operator delete(v103);
                  }
                  uint64_t v103 = v110;
                }
                else
                {
                  *(void *)uint64_t v101 = v104;
                  float v105 = v101 + 8;
                }
                int v178 = v105;
                float v100 = (void *)v100[1];
                uint64_t v101 = v105;
              }
              while (v100 != v99);
              unint64_t v179 = v102;
              uint64_t v177 = (char **)v103;
              unsigned int v83 = j;
            }
          }
        }
      }
      int v112 = v162;
      if ((unint64_t)v162 >= v163)
      {
        uint64_t v115 = std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>((uint64_t *)&v161, (uint64_t)&v177);
        float32x2_t v114 = v156;
        uint64_t v113 = v177;
      }
      else
      {
        *float v162 = 0;
        v112[1] = 0;
        v112[2] = 0;
        uint64_t v113 = v177;
        std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v112, v177, (uint64_t)v178, (v178 - (char *)v177) >> 3);
        float32x2_t v114 = v156;
        uint64_t v115 = (uint64_t)(v112 + 3);
      }
      float v162 = (void *)v115;
      if (v113) {
        operator delete(v113);
      }
      if (__p[0]) {
        operator delete(__p[0]);
      }
      unsigned int v80 = v114 + 3;
      uint64_t v4 = v154;
    }
    while (v80 != v153);
  }
  __p[0] = &v174;
  std::vector<vision::mod::ERTTree>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v160);
  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v160);
  unint64_t v116 = *(void *)(v160 + 24);
  int v117 = *(char **)(v160 + 32);
  unint64_t v118 = 126 - 2 * __clz((uint64_t)&v117[-v116] >> 4);
  if (v117 == (char *)v116) {
    uint64_t v119 = 0;
  }
  else {
    uint64_t v119 = v118;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *,false>(v116, v117, v119, 1);
  int v175 = 0;
  int v176 = 0;
  int v174 = (uint64_t *)&v175;
  uint64_t v120 = (uint64_t)v161;
  __int16 v121 = v162;
  while ((void *)v120 != v121)
  {
    unsigned int v123 = *(uint64_t **)v120;
    __int16 v122 = *(uint64_t **)(v120 + 8);
    if (v122 != *(uint64_t **)v120)
    {
      uint64_t v124 = *v123;
      unsigned int v125 = *(uint64_t **)v120;
      do
      {
        uint64_t v127 = *v125++;
        uint64_t v126 = v127;
        if (v127 < v124) {
          uint64_t v124 = v126;
        }
      }
      while (v125 != v122);
      do
      {
        std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v174, *v123, v123)[5] = v124;
        ++v123;
      }
      while (v123 != v122);
    }
    v120 += 24;
  }
  uint64_t v128 = *(void *)(v4 + 64);
  if (*(unsigned char *)(v128 + 120))
  {
    *(unsigned char *)(v128 + 120) = 0;
    uint64_t v149 = __cxa_allocate_exception(8uLL);
    *uint64_t v149 = 5219;
    __cxa_throw(v149, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t v129 = v174;
  if (v174 != (uint64_t *)&v175)
  {
    do
    {
      uint64_t v130 = v129[4];
      unsigned int v131 = v157;
      while (1)
      {
        unsigned int v131 = (void *)*v131;
        if (!v131) {
          break;
        }
        uint64_t v132 = v131[4];
        if (v130 >= v132)
        {
          if (v132 >= v130)
          {
            if (std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v151, v129[4], v129 + 4)[5] == v129[5])goto LABEL_229; {
            uint64_t v130 = v129[4];
            }
            break;
          }
          ++v131;
        }
      }
      uint64_t v133 = v129[5];
      uint64_t v134 = a2;
      float v136 = a2[1];
      unint64_t v135 = (unint64_t)a2[2];
      if ((unint64_t)v136 >= v135)
      {
        uint64_t v138 = *a2;
        uint64_t v139 = ((char *)v136 - (char *)*a2) >> 4;
        unint64_t v140 = v139 + 1;
        if ((unint64_t)(v139 + 1) >> 60) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v141 = v135 - (void)v138;
        if (v141 >> 3 > v140) {
          unint64_t v140 = v141 >> 3;
        }
        if ((unint64_t)v141 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v142 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v142 = v140;
        }
        if (v142)
        {
          unint64_t v142 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v142);
          uint64_t v138 = *a2;
          float v136 = a2[1];
        }
        else
        {
          uint64_t v143 = 0;
        }
        int v144 = (uint64_t *)(v142 + 16 * v139);
        *int v144 = v130;
        v144[1] = v133;
        int v145 = v144;
        if (v136 == v138)
        {
          uint64_t v134 = a2;
        }
        else
        {
          uint64_t v134 = a2;
          do
          {
            *((_OWORD *)v145 - 1) = *((_OWORD *)v136 - 1);
            v145 -= 2;
            v136 -= 2;
          }
          while (v136 != v138);
          uint64_t v138 = *a2;
        }
        int v137 = v144 + 2;
        *uint64_t v134 = v145;
        v134[1] = v144 + 2;
        v134[2] = (uint64_t *)(v142 + 16 * v143);
        if (v138) {
          operator delete(v138);
        }
      }
      else
      {
        *float v136 = v130;
        v136[1] = v133;
        int v137 = v136 + 2;
      }
      v134[1] = v137;
LABEL_229:
      unsigned int v146 = (uint64_t *)v129[1];
      if (v146)
      {
        do
        {
          int v147 = v146;
          unsigned int v146 = (uint64_t *)*v146;
        }
        while (v146);
      }
      else
      {
        do
        {
          int v147 = (uint64_t *)v129[2];
          BOOL v20 = *v147 == (void)v129;
          uint64_t v129 = v147;
        }
        while (!v20);
      }
      uint64_t v129 = v147;
    }
    while (v147 != (uint64_t *)&v175);
  }
  *(unsigned char *)(v4 + 80) = 0;
  if (v151 != &v174) {
    std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<long long,long long>,std::__tree_node<std::__value_type<long long,long long>,void *> *,long>>((uint64_t)v151, v174, &v175);
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v175);
  int v174 = (uint64_t *)&v161;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v174);
  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v160);
}

void sub_1A403D79C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char *__p,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  vision::mod::GreedyClustererWithTorso::private_t::clusters_t::~clusters_t((vision::mod::GreedyClustererWithTorso::private_t::clusters_t *)&__p);
  std::string __p = &a32;
  std::vector<vision::mod::ERTTree>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(void **)(v41 - 152));
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a39);
  std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  _Unwind_Resume(a1);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *,false>(unint64_t result, char *a2, uint64_t a3, char a4)
{
  uint64_t v9 = (unint64_t *)result;
  while (2)
  {
    unint64_t v10 = (unint64_t *)(a2 - 16);
    uint64_t v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v11;
          uint64_t v12 = a2 - (char *)v11;
          unint64_t v13 = (a2 - (char *)v11) >> 4;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unint64_t v102 = *v11;
                char v103 = -1;
                if (*v10 >= *v11) {
                  char v103 = 1;
                }
                if (*v10 == *v11)
                {
                  unint64_t v104 = *((void *)a2 - 1);
                  unint64_t v105 = v11[1];
                  BOOL v4 = v104 >= v105;
                  BOOL v106 = v104 == v105;
                  char v103 = -1;
                  if (v4) {
                    char v103 = 1;
                  }
                  if (v106) {
                    char v103 = 0;
                  }
                }
                if (v103 < 0)
                {
                  *uint64_t v11 = *v10;
                  *((void *)a2 - 2) = v102;
                  unint64_t v107 = v11[1];
                  v11[1] = *((void *)a2 - 1);
                  *((void *)a2 - 1) = v107;
                }
                break;
              case 3uLL:
                uint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v11, v11 + 2, (uint64_t *)a2 - 2);
                break;
              case 4uLL:
                uint64_t result = (unint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v11, v11 + 2, (uint64_t *)v11 + 4, (uint64_t *)a2 - 2);
                break;
              case 5uLL:
                uint64_t result = (unint64_t)std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v11, v11 + 2, (uint64_t *)v11 + 4, (uint64_t *)v11 + 6, (uint64_t *)a2 - 2);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 383)
          {
            unint64_t v108 = (char *)(v11 + 2);
            BOOL v110 = v11 == (unint64_t *)a2 || v108 == a2;
            if (a4)
            {
              if (!v110)
              {
                uint64_t v111 = 0;
                int v112 = v11;
                do
                {
                  uint64_t v113 = v108;
                  unint64_t v114 = v112[2];
                  unint64_t v115 = *v112;
                  if (v114 >= *v112) {
                    char v116 = 1;
                  }
                  else {
                    char v116 = -1;
                  }
                  if (v114 == *v112)
                  {
                    unint64_t v117 = v112[3];
                    unint64_t v118 = v112[1];
                    BOOL v119 = v117 == v118;
                    char v116 = v117 >= v118 ? 1 : -1;
                    if (v119) {
                      char v116 = 0;
                    }
                  }
                  if (v116 < 0)
                  {
                    unint64_t v120 = v112[3];
                    uint64_t v121 = v111;
                    while (1)
                    {
                      __int16 v122 = (char *)v11 + v121;
                      uint64_t v123 = *(unint64_t *)((char *)v11 + v121 + 8);
                      *((void *)v122 + 2) = v115;
                      *((void *)v122 + 3) = v123;
                      if (!v121) {
                        break;
                      }
                      unint64_t v115 = *((void *)v122 - 2);
                      if (v114 >= v115) {
                        char v124 = 1;
                      }
                      else {
                        char v124 = -1;
                      }
                      if (v114 == v115)
                      {
                        unint64_t v125 = *(unint64_t *)((char *)v11 + v121 - 8);
                        BOOL v126 = v120 == v125;
                        char v124 = v120 >= v125 ? 1 : -1;
                        if (v126) {
                          char v124 = 0;
                        }
                      }
                      v121 -= 16;
                      if ((v124 & 0x80) == 0)
                      {
                        uint64_t v127 = (unint64_t *)((char *)v11 + v121 + 16);
                        goto LABEL_234;
                      }
                    }
                    uint64_t v127 = v11;
LABEL_234:
                    *uint64_t v127 = v114;
                    v127[1] = v120;
                  }
                  unint64_t v108 = v113 + 16;
                  v111 += 16;
                  int v112 = (unint64_t *)v113;
                }
                while (v113 + 16 != a2);
              }
            }
            else if (!v110)
            {
              uint64_t v188 = v11 + 3;
              do
              {
                uint64_t v189 = v108;
                unint64_t v190 = v9[2];
                unint64_t v191 = *v9;
                if (v190 >= *v9) {
                  char v192 = 1;
                }
                else {
                  char v192 = -1;
                }
                if (v190 == *v9)
                {
                  unint64_t v193 = v9[3];
                  unint64_t v194 = v9[1];
                  BOOL v195 = v193 == v194;
                  char v192 = v193 >= v194 ? 1 : -1;
                  if (v195) {
                    char v192 = 0;
                  }
                }
                if (v192 < 0)
                {
                  unint64_t v196 = v9[3];
                  uint64_t v197 = v188;
                  do
                  {
                    *(v197 - 1) = v191;
                    *uint64_t v197 = *(v197 - 2);
                    unint64_t v191 = *(v197 - 5);
                    if (v190 >= v191) {
                      char v198 = 1;
                    }
                    else {
                      char v198 = -1;
                    }
                    if (v190 == v191)
                    {
                      unint64_t v199 = *(v197 - 4);
                      BOOL v200 = v196 == v199;
                      char v198 = v196 >= v199 ? 1 : -1;
                      if (v200) {
                        char v198 = 0;
                      }
                    }
                    v197 -= 2;
                  }
                  while (v198 < 0);
                  *(v197 - 1) = v190;
                  *uint64_t v197 = v196;
                }
                unint64_t v108 = v189 + 16;
                v188 += 2;
                uint64_t v9 = (unint64_t *)v189;
              }
              while (v189 + 16 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != (unint64_t *)a2)
            {
              int64_t v128 = (v13 - 2) >> 1;
              int64_t v129 = v128;
              do
              {
                int64_t v130 = v129;
                if (v128 >= v129)
                {
                  uint64_t v131 = (2 * v129) | 1;
                  uint64_t v132 = &v11[2 * v131];
                  if (2 * v130 + 2 < (uint64_t)v13)
                  {
                    unint64_t v133 = v132[2];
                    BOOL v134 = *v132 == v133;
                    if (*v132 >= v133) {
                      char v135 = 1;
                    }
                    else {
                      char v135 = -1;
                    }
                    if (v134)
                    {
                      unint64_t v136 = v11[2 * v131 + 1];
                      unint64_t v137 = v132[3];
                      BOOL v138 = v136 == v137;
                      char v135 = v136 >= v137 ? 1 : -1;
                      if (v138) {
                        char v135 = 0;
                      }
                    }
                    if (v135 < 0)
                    {
                      v132 += 2;
                      uint64_t v131 = 2 * v130 + 2;
                    }
                  }
                  uint64_t v139 = &v11[2 * v130];
                  unint64_t v140 = *v132;
                  unint64_t v141 = *v139;
                  if (*v132 >= *v139) {
                    char v142 = 1;
                  }
                  else {
                    char v142 = -1;
                  }
                  if (*v132 == *v139)
                  {
                    unint64_t v143 = v132[1];
                    unint64_t v144 = v11[2 * v130 + 1];
                    BOOL v145 = v143 == v144;
                    char v142 = v143 >= v144 ? 1 : -1;
                    if (v145) {
                      char v142 = 0;
                    }
                  }
                  if ((v142 & 0x80) == 0)
                  {
                    unint64_t v146 = v139[1];
                    do
                    {
                      int v147 = v139;
                      uint64_t v139 = v132;
                      *int v147 = v140;
                      v147[1] = v132[1];
                      if (v128 < v131) {
                        break;
                      }
                      uint64_t v148 = (2 * v131) | 1;
                      uint64_t v132 = &v11[2 * v148];
                      uint64_t v131 = 2 * v131 + 2;
                      if (v131 < (uint64_t)v13)
                      {
                        unint64_t v149 = v132[2];
                        BOOL v150 = *v132 == v149;
                        if (*v132 >= v149) {
                          char v151 = 1;
                        }
                        else {
                          char v151 = -1;
                        }
                        if (v150)
                        {
                          unint64_t v152 = v11[2 * v148 + 1];
                          unint64_t v153 = v132[3];
                          BOOL v154 = v152 == v153;
                          char v151 = v152 >= v153 ? 1 : -1;
                          if (v154) {
                            char v151 = 0;
                          }
                        }
                        if (v151 < 0) {
                          v132 += 2;
                        }
                        else {
                          uint64_t v131 = v148;
                        }
                      }
                      else
                      {
                        uint64_t v131 = v148;
                      }
                      unint64_t v140 = *v132;
                      if (*v132 >= v141) {
                        char v155 = 1;
                      }
                      else {
                        char v155 = -1;
                      }
                      if (*v132 == v141)
                      {
                        unint64_t v156 = v132[1];
                        BOOL v157 = v156 == v146;
                        char v155 = v156 >= v146 ? 1 : -1;
                        if (v157) {
                          char v155 = 0;
                        }
                      }
                    }
                    while ((v155 & 0x80) == 0);
                    *uint64_t v139 = v141;
                    v139[1] = v146;
                  }
                }
                int64_t v129 = v130 - 1;
              }
              while (v130);
              uint64_t v158 = (unint64_t)v12 >> 4;
              do
              {
                uint64_t v159 = 0;
                unint64_t v160 = *v11;
                unint64_t v161 = v11[1];
                uint64_t v162 = v158 - 2;
                if (v158 < 2) {
                  uint64_t v162 = v158 - 1;
                }
                uint64_t v163 = v162 >> 1;
                float v164 = v11;
                do
                {
                  uint64_t v165 = v159 + 1;
                  uint64_t v166 = &v164[2 * v159 + 2];
                  uint64_t result = 2 * v159;
                  uint64_t v167 = (2 * v159) | 1;
                  uint64_t v168 = 2 * v159 + 2;
                  if (v168 < v158)
                  {
                    uint64_t result = (unint64_t)(v166 + 2);
                    unint64_t v169 = v166[2];
                    BOOL v170 = *v166 == v169;
                    if (*v166 >= v169) {
                      char v171 = 1;
                    }
                    else {
                      char v171 = -1;
                    }
                    if (v170)
                    {
                      unint64_t v172 = v164[2 * v165 + 1];
                      unint64_t v173 = v166[3];
                      BOOL v174 = v172 == v173;
                      if (v172 >= v173) {
                        char v175 = 1;
                      }
                      else {
                        char v175 = -1;
                      }
                      if (v174) {
                        char v171 = 0;
                      }
                      else {
                        char v171 = v175;
                      }
                    }
                    if (v171 < 0)
                    {
                      v166 += 2;
                      uint64_t v167 = v168;
                    }
                  }
                  *float v164 = *v166;
                  v164[1] = v166[1];
                  float v164 = v166;
                  uint64_t v159 = v167;
                }
                while (v167 <= v163);
                if (v166 == (unint64_t *)(a2 - 16))
                {
                  *uint64_t v166 = v160;
                  v166[1] = v161;
                }
                else
                {
                  *uint64_t v166 = *((void *)a2 - 2);
                  v166[1] = *((void *)a2 - 1);
                  *((void *)a2 - 2) = v160;
                  *((void *)a2 - 1) = v161;
                  uint64_t v176 = (char *)v166 - (char *)v11 + 16;
                  if (v176 >= 17)
                  {
                    unint64_t v177 = (unint64_t)((v176 >> 4) - 2) >> 1;
                    int v178 = &v11[2 * v177];
                    unint64_t v179 = *v178;
                    unint64_t v180 = *v166;
                    if (*v178 >= *v166) {
                      char v181 = 1;
                    }
                    else {
                      char v181 = -1;
                    }
                    if (*v178 == *v166)
                    {
                      unint64_t v182 = v178[1];
                      uint64_t result = v166[1];
                      BOOL v183 = v182 == result;
                      char v181 = v182 >= result ? 1 : -1;
                      if (v183) {
                        char v181 = 0;
                      }
                    }
                    if (v181 < 0)
                    {
                      unint64_t v184 = v166[1];
                      do
                      {
                        uint64_t result = (unint64_t)v166;
                        uint64_t v166 = v178;
                        *(void *)uint64_t result = v179;
                        *(void *)(result + 8) = v178[1];
                        if (!v177) {
                          break;
                        }
                        unint64_t v177 = (v177 - 1) >> 1;
                        int v178 = &v11[2 * v177];
                        unint64_t v179 = *v178;
                        if (*v178 >= v180) {
                          uint64_t result = 1;
                        }
                        else {
                          uint64_t result = 255;
                        }
                        if (*v178 == v180)
                        {
                          unint64_t v185 = v178[1];
                          BOOL v186 = v185 == v184;
                          uint64_t result = v185 >= v184 ? 1 : 255;
                          if (v186) {
                            uint64_t result = 0;
                          }
                        }
                      }
                      while ((result & 0x80) != 0);
                      *uint64_t v166 = v180;
                      v166[1] = v184;
                    }
                  }
                }
                a2 -= 16;
              }
              while (v158-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          BOOL v15 = &v11[2 * (v13 >> 1)];
          if ((unint64_t)v12 >= 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v9, &v9[2 * (v13 >> 1)], (uint64_t *)a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v9 + 2, v15 - 2, (uint64_t *)a2 - 4);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v9 + 4, &v9[2 * v14 + 2], (uint64_t *)a2 - 6);
            uint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v15 - 2, v15, (uint64_t *)&v9[2 * v14 + 2]);
            long long v16 = *(_OWORD *)v9;
            *(_OWORD *)uint64_t v9 = *(_OWORD *)v15;
            *(_OWORD *)BOOL v15 = v16;
          }
          else
          {
            uint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(&v9[2 * (v13 >> 1)], v9, (uint64_t *)a2 - 2);
          }
          --a3;
          unint64_t v17 = *v9;
          if (a4) {
            break;
          }
          unint64_t v18 = *(v9 - 2);
          BOOL v19 = v18 == v17;
          if (v18 >= v17) {
            char v20 = 1;
          }
          else {
            char v20 = -1;
          }
          if (v19)
          {
            unint64_t v21 = *(v9 - 1);
            unint64_t v22 = v9[1];
            BOOL v23 = v21 == v22;
            char v20 = v21 >= v22 ? 1 : -1;
            if (v23) {
              char v20 = 0;
            }
          }
          if (v20 < 0) {
            break;
          }
          unint64_t v64 = v9[1];
          if (v17 >= *v10) {
            char v65 = 1;
          }
          else {
            char v65 = -1;
          }
          if (v17 == *v10)
          {
            unint64_t v66 = *((void *)a2 - 1);
            BOOL v67 = v64 == v66;
            if (v64 >= v66) {
              char v68 = 1;
            }
            else {
              char v68 = -1;
            }
            if (v67) {
              char v65 = 0;
            }
            else {
              char v65 = v68;
            }
          }
          uint64_t v69 = v9;
          if (v65 < 0)
          {
            do
            {
              uint64_t v11 = v69 + 2;
              unint64_t v74 = v69[2];
              BOOL v75 = v17 == v74;
              if (v17 >= v74) {
                char v76 = 1;
              }
              else {
                char v76 = -1;
              }
              if (v75)
              {
                unint64_t v77 = v69[3];
                BOOL v78 = v64 == v77;
                if (v64 >= v77) {
                  char v79 = 1;
                }
                else {
                  char v79 = -1;
                }
                if (v78) {
                  char v76 = 0;
                }
                else {
                  char v76 = v79;
                }
              }
              uint64_t v69 = v11;
            }
            while ((v76 & 0x80) == 0);
          }
          else
          {
            uint64_t v70 = v9 + 2;
            do
            {
              uint64_t v11 = v70;
              if (v70 >= (unint64_t *)a2) {
                break;
              }
              if (v17 >= *v70) {
                char v71 = 1;
              }
              else {
                char v71 = -1;
              }
              if (v17 == *v70)
              {
                unint64_t v72 = v70[1];
                BOOL v73 = v64 == v72;
                char v71 = v64 >= v72 ? 1 : -1;
                if (v73) {
                  char v71 = 0;
                }
              }
              v70 += 2;
            }
            while ((v71 & 0x80) == 0);
          }
          unsigned int v80 = (unint64_t *)a2;
          if (v11 < (unint64_t *)a2)
          {
            float v81 = a2;
            unsigned int v80 = (unint64_t *)a2;
            do
            {
              unint64_t v82 = *(v80 - 2);
              v80 -= 2;
              BOOL v83 = v17 == v82;
              if (v17 >= v82) {
                char v84 = 1;
              }
              else {
                char v84 = -1;
              }
              if (v83)
              {
                unint64_t v85 = *((void *)v81 - 1);
                BOOL v86 = v64 == v85;
                char v84 = v64 >= v85 ? 1 : -1;
                if (v86) {
                  char v84 = 0;
                }
              }
              float v81 = (char *)v80;
            }
            while (v84 < 0);
          }
          if (v11 < v80)
          {
            unint64_t v87 = *v11;
            unint64_t v88 = *v80;
            do
            {
              *uint64_t v11 = v88;
              *unsigned int v80 = v87;
              unint64_t v89 = v11[1];
              v11[1] = v80[1];
              v80[1] = v89;
              unint64_t v90 = v11;
              do
              {
                unint64_t v91 = v11[2];
                v11 += 2;
                unint64_t v87 = v91;
                BOOL v92 = v17 == v91;
                if (v17 >= v91) {
                  char v93 = 1;
                }
                else {
                  char v93 = -1;
                }
                if (v92)
                {
                  unint64_t v94 = v90[3];
                  BOOL v95 = v64 == v94;
                  char v93 = v64 >= v94 ? 1 : -1;
                  if (v95) {
                    char v93 = 0;
                  }
                }
                unint64_t v90 = v11;
              }
              while ((v93 & 0x80) == 0);
              unint64_t v96 = v80;
              do
              {
                unint64_t v97 = *(v80 - 2);
                v80 -= 2;
                unint64_t v88 = v97;
                BOOL v98 = v17 == v97;
                if (v17 >= v97) {
                  char v99 = 1;
                }
                else {
                  char v99 = -1;
                }
                if (v98)
                {
                  unint64_t v100 = *(v96 - 1);
                  BOOL v101 = v64 == v100;
                  char v99 = v64 >= v100 ? 1 : -1;
                  if (v101) {
                    char v99 = 0;
                  }
                }
                unint64_t v96 = v80;
              }
              while (v99 < 0);
            }
            while (v11 < v80);
          }
          BOOL v4 = v11 - 2 >= v9;
          BOOL v5 = v11 - 2 == v9;
          if (v11 - 2 != v9)
          {
            *uint64_t v9 = *(v11 - 2);
            v9[1] = *(v11 - 1);
          }
          a4 = 0;
          *(v11 - 2) = v17;
          *(v11 - 1) = v64;
        }
        unint64_t v24 = v9[1];
        uint64_t v25 = v9;
        uint64_t v26 = v9;
        do
        {
          unint64_t v28 = v26[2];
          v26 += 2;
          unint64_t v27 = v28;
          BOOL v29 = v28 == v17;
          if (v28 >= v17) {
            char v30 = 1;
          }
          else {
            char v30 = -1;
          }
          if (v29)
          {
            unint64_t v31 = v25[3];
            BOOL v32 = v31 == v24;
            char v30 = v31 >= v24 ? 1 : -1;
            if (v32) {
              char v30 = 0;
            }
          }
          uint64_t v25 = v26;
        }
        while (v30 < 0);
        unint64_t v33 = a2;
        if (v26 - 2 == v9)
        {
          uint64_t v41 = a2;
          while (v26 < (unint64_t *)v41)
          {
            uint64_t v34 = v41 - 16;
            unint64_t v42 = *((void *)v41 - 2);
            BOOL v43 = v42 == v17;
            if (v42 >= v17) {
              char v44 = 1;
            }
            else {
              char v44 = -1;
            }
            if (v43)
            {
              unint64_t v45 = *((void *)v41 - 1);
              BOOL v46 = v45 == v24;
              if (v45 >= v24) {
                char v47 = 1;
              }
              else {
                char v47 = -1;
              }
              if (v46) {
                char v44 = 0;
              }
              else {
                char v44 = v47;
              }
            }
            uint64_t v41 = v34;
            if (v44 < 0) {
              goto LABEL_64;
            }
          }
          uint64_t v34 = v41;
        }
        else
        {
          do
          {
            uint64_t v34 = v33 - 16;
            unint64_t v35 = *((void *)v33 - 2);
            BOOL v36 = v35 == v17;
            if (v35 >= v17) {
              char v37 = 1;
            }
            else {
              char v37 = -1;
            }
            if (v36)
            {
              unint64_t v38 = *((void *)v33 - 1);
              BOOL v39 = v38 == v24;
              if (v38 >= v24) {
                char v40 = 1;
              }
              else {
                char v40 = -1;
              }
              if (v39) {
                char v37 = 0;
              }
              else {
                char v37 = v40;
              }
            }
            unint64_t v33 = v34;
          }
          while ((v37 & 0x80) == 0);
        }
LABEL_64:
        if (v26 >= (unint64_t *)v34)
        {
          uint64_t v11 = v26;
        }
        else
        {
          unint64_t v48 = *(void *)v34;
          uint64_t v11 = v26;
          uint64_t v49 = (unint64_t *)v34;
          do
          {
            *uint64_t v11 = v48;
            *uint64_t v49 = v27;
            unint64_t v50 = v11[1];
            v11[1] = v49[1];
            v49[1] = v50;
            int v51 = v11;
            do
            {
              unint64_t v52 = v11[2];
              v11 += 2;
              unint64_t v27 = v52;
              BOOL v53 = v52 == v17;
              if (v52 >= v17) {
                char v54 = 1;
              }
              else {
                char v54 = -1;
              }
              if (v53)
              {
                unint64_t v55 = v51[3];
                BOOL v56 = v55 == v24;
                char v54 = v55 >= v24 ? 1 : -1;
                if (v56) {
                  char v54 = 0;
                }
              }
              int v51 = v11;
            }
            while (v54 < 0);
            unint64_t v57 = v49;
            do
            {
              unint64_t v58 = *(v49 - 2);
              v49 -= 2;
              unint64_t v48 = v58;
              BOOL v59 = v58 == v17;
              if (v58 >= v17) {
                char v60 = 1;
              }
              else {
                char v60 = -1;
              }
              if (v59)
              {
                unint64_t v61 = *(v57 - 1);
                BOOL v62 = v61 == v24;
                char v60 = v61 >= v24 ? 1 : -1;
                if (v62) {
                  char v60 = 0;
                }
              }
              unint64_t v57 = v49;
            }
            while ((v60 & 0x80) == 0);
          }
          while (v11 < v49);
        }
        if (v11 - 2 != v9)
        {
          *uint64_t v9 = *(v11 - 2);
          v9[1] = *(v11 - 1);
        }
        *(v11 - 2) = v17;
        *(v11 - 1) = v24;
        if (v26 >= (unint64_t *)v34) {
          break;
        }
LABEL_98:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *,false>(v9, v11 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v63 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v9, (char *)v11 - 16);
      uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v11, a2);
      if (result) {
        break;
      }
      if (!v63) {
        goto LABEL_98;
      }
    }
    a2 = (char *)(v11 - 2);
    if (!v63) {
      continue;
    }
    return result;
  }
}

unint64_t *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(unint64_t *result, unint64_t *a2, uint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  if (*a2 >= *result) {
    char v5 = 1;
  }
  else {
    char v5 = -1;
  }
  if (*a2 == *result)
  {
    unint64_t v6 = a2[1];
    unint64_t v7 = result[1];
    BOOL v8 = v6 >= v7;
    BOOL v9 = v6 == v7;
    char v10 = -1;
    if (v8) {
      char v10 = 1;
    }
    if (v9) {
      char v5 = 0;
    }
    else {
      char v5 = v10;
    }
  }
  unint64_t v11 = *a3;
  char v12 = -1;
  if (*a3 >= v3) {
    char v12 = 1;
  }
  if (v5 < 0)
  {
    if (v11 == v3)
    {
      unint64_t v22 = a3[1];
      unint64_t v23 = a2[1];
      BOOL v8 = v22 >= v23;
      BOOL v24 = v22 == v23;
      char v12 = -1;
      if (v8) {
        char v12 = 1;
      }
      if (v24) {
        char v12 = 0;
      }
    }
    if (v12 < 0)
    {
      *result++ = v11;
      *a3 = v4;
      unint64_t v31 = (unint64_t *)(a3 + 1);
    }
    else
    {
      *uint64_t result = v3;
      *a2 = v4;
      unint64_t v25 = result[1];
      result[1] = a2[1];
      a2[1] = v25;
      unint64_t v26 = *a2;
      char v27 = -1;
      if (*a3 >= *a2) {
        char v27 = 1;
      }
      if (*a3 == *a2)
      {
        unint64_t v28 = a3[1];
        BOOL v8 = v28 >= v25;
        BOOL v29 = v28 == v25;
        char v30 = -1;
        if (v8) {
          char v30 = 1;
        }
        if (v29) {
          char v27 = 0;
        }
        else {
          char v27 = v30;
        }
      }
      if ((v27 & 0x80) == 0) {
        return result;
      }
      *a2 = *a3;
      *a3 = v26;
      unint64_t v31 = (unint64_t *)(a3 + 1);
      uint64_t result = a2 + 1;
    }
    unint64_t v17 = v31;
    goto LABEL_51;
  }
  if (v11 == v3)
  {
    unint64_t v13 = a3[1];
    unint64_t v14 = a2[1];
    BOOL v8 = v13 >= v14;
    BOOL v15 = v13 == v14;
    char v16 = -1;
    if (v8) {
      char v16 = 1;
    }
    if (v15) {
      char v12 = 0;
    }
    else {
      char v12 = v16;
    }
  }
  if (v12 < 0)
  {
    *a2 = v11;
    *a3 = v3;
    unint64_t v17 = a2 + 1;
    uint64_t v18 = a2[1];
    a2[1] = a3[1];
    a3[1] = v18;
    unint64_t v19 = *result;
    char v20 = -1;
    if (*a2 >= *result) {
      char v20 = 1;
    }
    if (*a2 == *result)
    {
      unint64_t v21 = result[1];
      char v20 = -1;
      if (*v17 >= v21) {
        char v20 = 1;
      }
      if (*v17 == v21) {
        char v20 = 0;
      }
    }
    if (v20 < 0)
    {
      *result++ = *a2;
      *a2 = v19;
LABEL_51:
      unint64_t v32 = *result;
      *uint64_t result = *v17;
      unint64_t *v17 = v32;
    }
  }
  return result;
}

unint64_t *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(unint64_t *a1, unint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a2, a3);
  uint64_t v9 = *a3;
  char v10 = -1;
  if (*a4 >= (unint64_t)*a3) {
    char v10 = 1;
  }
  if (*a4 == *a3)
  {
    unint64_t v11 = a4[1];
    unint64_t v12 = a3[1];
    BOOL v13 = v11 >= v12;
    BOOL v14 = v11 == v12;
    char v10 = -1;
    if (v13) {
      char v10 = 1;
    }
    if (v14) {
      char v10 = 0;
    }
  }
  if (v10 < 0)
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v15 = a3[1];
    a3[1] = a4[1];
    a4[1] = v15;
    unint64_t v16 = *a2;
    char v17 = -1;
    if (*a3 >= *a2) {
      char v17 = 1;
    }
    if (*a3 == *a2)
    {
      unint64_t v18 = a3[1];
      unint64_t v19 = a2[1];
      BOOL v13 = v18 >= v19;
      BOOL v20 = v18 == v19;
      char v17 = -1;
      if (v13) {
        char v17 = 1;
      }
      if (v20) {
        char v17 = 0;
      }
    }
    if (v17 < 0)
    {
      *a2 = *a3;
      *a3 = v16;
      uint64_t v21 = a2[1];
      a2[1] = a3[1];
      a3[1] = v21;
      unint64_t v22 = *a1;
      char v23 = -1;
      if (*a2 >= *a1) {
        char v23 = 1;
      }
      if (*a2 == *a1)
      {
        unint64_t v24 = a2[1];
        unint64_t v25 = a1[1];
        BOOL v13 = v24 >= v25;
        BOOL v26 = v24 == v25;
        char v23 = -1;
        if (v13) {
          char v23 = 1;
        }
        if (v26) {
          char v23 = 0;
        }
      }
      if (v23 < 0)
      {
        *a1 = *a2;
        *a2 = v22;
        unint64_t v27 = a1[1];
        a1[1] = a2[1];
        a2[1] = v27;
      }
    }
  }
  return result;
}

unint64_t *std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(unint64_t *a1, unint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a2, a3, a4);
  uint64_t v11 = *a4;
  char v12 = -1;
  if (*a5 >= (unint64_t)*a4) {
    char v12 = 1;
  }
  if (*a5 == *a4)
  {
    unint64_t v13 = a5[1];
    unint64_t v14 = a4[1];
    BOOL v15 = v13 >= v14;
    BOOL v16 = v13 == v14;
    char v12 = -1;
    if (v15) {
      char v12 = 1;
    }
    if (v16) {
      char v12 = 0;
    }
  }
  if (v12 < 0)
  {
    *a4 = *a5;
    *a5 = v11;
    uint64_t v17 = a4[1];
    a4[1] = a5[1];
    a5[1] = v17;
    uint64_t v18 = *a3;
    char v19 = -1;
    if (*a4 >= (unint64_t)*a3) {
      char v19 = 1;
    }
    if (*a4 == *a3)
    {
      unint64_t v20 = a4[1];
      unint64_t v21 = a3[1];
      BOOL v15 = v20 >= v21;
      BOOL v22 = v20 == v21;
      char v19 = -1;
      if (v15) {
        char v19 = 1;
      }
      if (v22) {
        char v19 = 0;
      }
    }
    if (v19 < 0)
    {
      *a3 = *a4;
      *a4 = v18;
      uint64_t v23 = a3[1];
      a3[1] = a4[1];
      a4[1] = v23;
      unint64_t v24 = *a2;
      char v25 = -1;
      if (*a3 >= *a2) {
        char v25 = 1;
      }
      if (*a3 == *a2)
      {
        unint64_t v26 = a3[1];
        unint64_t v27 = a2[1];
        BOOL v15 = v26 >= v27;
        BOOL v28 = v26 == v27;
        char v25 = -1;
        if (v15) {
          char v25 = 1;
        }
        if (v28) {
          char v25 = 0;
        }
      }
      if (v25 < 0)
      {
        *a2 = *a3;
        *a3 = v24;
        uint64_t v29 = a2[1];
        a2[1] = a3[1];
        a3[1] = v29;
        unint64_t v30 = *a1;
        char v31 = -1;
        if (*a2 >= *a1) {
          char v31 = 1;
        }
        if (*a2 == *a1)
        {
          unint64_t v32 = a2[1];
          unint64_t v33 = a1[1];
          BOOL v15 = v32 >= v33;
          BOOL v34 = v32 == v33;
          char v31 = -1;
          if (v15) {
            char v31 = 1;
          }
          if (v34) {
            char v31 = 0;
          }
        }
        if (v31 < 0)
        {
          *a1 = *a2;
          *a2 = v30;
          unint64_t v35 = a1[1];
          a1[1] = a2[1];
          a2[1] = v35;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(unint64_t *a1, char *a2)
{
  uint64_t v4 = (a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *((void *)a2 - 2);
      unint64_t v7 = *a1;
      char v8 = -1;
      if (v6 >= *a1) {
        char v8 = 1;
      }
      if (v6 == *a1)
      {
        unint64_t v9 = *((void *)a2 - 1);
        unint64_t v10 = a1[1];
        BOOL v11 = v9 >= v10;
        BOOL v12 = v9 == v10;
        char v8 = -1;
        if (v11) {
          char v8 = 1;
        }
        if (v12) {
          char v8 = 0;
        }
      }
      if (v8 < 0)
      {
        *a1 = v6;
        *((void *)a2 - 2) = v7;
        unint64_t v13 = a1[1];
        a1[1] = *((void *)a2 - 1);
        *((void *)a2 - 1) = v13;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a1 + 2, (uint64_t *)a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a1 + 2, (uint64_t *)a1 + 4, (uint64_t *)a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a1 + 2, (uint64_t *)a1 + 4, (uint64_t *)a1 + 6, (uint64_t *)a2 - 2);
      return 1;
    default:
      unint64_t v14 = (char *)(a1 + 4);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a1 + 2, (uint64_t *)a1 + 4);
      BOOL v15 = (char *)(a1 + 6);
      if (a1 + 6 == (unint64_t *)a2) {
        return 1;
      }
      uint64_t v16 = 0;
      int v17 = 0;
      break;
  }
  while (1)
  {
    unint64_t v18 = *(void *)v15;
    unint64_t v19 = *(void *)v14;
    if (*(void *)v15 >= *(void *)v14) {
      char v20 = 1;
    }
    else {
      char v20 = -1;
    }
    if (*(void *)v15 == *(void *)v14)
    {
      unint64_t v21 = *((void *)v15 + 1);
      unint64_t v22 = *((void *)v14 + 1);
      BOOL v23 = v21 == v22;
      char v20 = v21 >= v22 ? 1 : -1;
      if (v23) {
        char v20 = 0;
      }
    }
    if (v20 < 0)
    {
      unint64_t v24 = *((void *)v15 + 1);
      uint64_t v25 = v16;
      while (1)
      {
        unint64_t v26 = (unint64_t *)((char *)a1 + v25);
        uint64_t v27 = *(unint64_t *)((char *)a1 + v25 + 40);
        v26[6] = v19;
        v26[7] = v27;
        if (v25 == -32) {
          break;
        }
        unint64_t v19 = v26[2];
        if (v18 >= v19) {
          char v28 = 1;
        }
        else {
          char v28 = -1;
        }
        if (v18 == v19)
        {
          unint64_t v29 = *(unint64_t *)((char *)a1 + v25 + 24);
          BOOL v30 = v24 == v29;
          char v28 = v24 >= v29 ? 1 : -1;
          if (v30) {
            char v28 = 0;
          }
        }
        v25 -= 16;
        if ((v28 & 0x80) == 0)
        {
          char v31 = (unint64_t *)((char *)a1 + v25 + 48);
          goto LABEL_38;
        }
      }
      char v31 = a1;
LABEL_38:
      unint64_t *v31 = v18;
      v31[1] = v24;
      if (++v17 == 8) {
        return v15 + 16 == a2;
      }
    }
    unint64_t v14 = v15;
    v16 += 16;
    v15 += 16;
    if (v15 == a2) {
      return 1;
    }
  }
}

void vision::mod::GreedyClusterer::getConnectedComponents(uint64_t *a1, uint64_t a2, uint64_t **a3, uint64_t **a4)
{
  v68[0] = 0;
  v68[1] = 0;
  BOOL v67 = (uint64_t *)v68;
  if (a3 != a4)
  {
    unint64_t v7 = a3;
    do
    {
      char v8 = *v7;
      unint64_t v9 = v7[1];
      uint64_t v69 = v8;
      char v65 = v9;
      unint64_t v10 = std::__tree<std::__value_type<unsigned long,std::list<unsigned long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<unsigned long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<unsigned long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v67, (unint64_t)v8, &v69);
      BOOL v11 = (uint64_t *)operator new(0x18uLL);
      _OWORD v11[2] = (uint64_t)v9;
      BOOL v12 = v10[5];
      v10 += 5;
      *BOOL v11 = (uint64_t)v12;
      v11[1] = (uint64_t)v10;
      v12[1] = (uint64_t)v11;
      *unint64_t v10 = v11;
      v10[2] = (uint64_t *)((char *)v10[2] + 1);
      unint64_t v13 = std::__tree<std::__value_type<unsigned long,std::list<unsigned long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<unsigned long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<unsigned long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v67, (unint64_t)v9, &v65);
      unint64_t v14 = (uint64_t *)operator new(0x18uLL);
      v14[2] = (uint64_t)v8;
      BOOL v15 = v13[5];
      v13 += 5;
      *unint64_t v14 = (uint64_t)v15;
      v14[1] = (uint64_t)v13;
      v15[1] = (uint64_t)v14;
      *unint64_t v13 = v14;
      uint64_t v13[2] = (uint64_t *)((char *)v13[2] + 1);
      v7 += 2;
    }
    while (v7 != a4);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v66[0] = 0;
  v66[1] = 0;
  uint64_t v64 = 0;
  char v65 = (uint64_t *)v66;
  BOOL v62 = &v62;
  std::string __p = &v62;
  uint64_t v16 = operator new(0x18uLL);
  v16[1] = &v62;
  void v16[2] = 0;
  *uint64_t v16 = &v62;
  BOOL v62 = v16;
  std::string __p = v16;
  uint64_t v64 = 1;
  uint64_t v60 = *(void *)(a2 + 56);
  if (*(unsigned char *)(v60 + 120))
  {
LABEL_61:
    *(unsigned char *)(v60 + 120) = 0;
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 5219;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  int v17 = 0;
  unint64_t v18 = 0;
  unint64_t v19 = 0;
  int v20 = 0;
LABEL_6:
  unint64_t v61 = 0;
  uint64_t v21 = v64;
  if (v64)
  {
    unint64_t v22 = (void **)__p;
    uint64_t v23 = *((void *)__p + 1);
    unint64_t v24 = *((void *)__p + 2);
    unint64_t v61 = v24;
    uint64_t v25 = *(void *)__p;
    *(void *)(v25 + 8) = v23;
    *v22[1] = v25;
    uint64_t v64 = v21 - 1;
    operator delete(v22);
    goto LABEL_37;
  }
  uint64_t v27 = (void *)a1[1];
  unint64_t v26 = a1[2];
  if ((unint64_t)v27 >= v26)
  {
    unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v27 - *a1) >> 3);
    unint64_t v30 = v29 + 1;
    if (v29 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - *a1) >> 3);
    if (2 * v31 > v30) {
      unint64_t v30 = 2 * v31;
    }
    if (v31 >= 0x555555555555555) {
      unint64_t v32 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v32 = v30;
    }
    unint64_t v72 = a1 + 2;
    if (v32)
    {
      if (v32 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v33 = (uint64_t *)operator new(24 * v32);
    }
    else
    {
      unint64_t v33 = 0;
    }
    BOOL v34 = &v33[3 * v29];
    uint64_t v69 = v33;
    v70.i64[0] = (uint64_t)v34;
    v70.i64[1] = (uint64_t)v34;
    char v71 = &v33[3 * v32];
    v34[1] = 0;
    v34[2] = 0;
    *BOOL v34 = 0;
    std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(v34, v17, (uint64_t)v18, v18 - v17);
    uint64_t v35 = v70.i64[0];
    uint64_t v28 = v70.i64[1] + 24;
    v70.i64[1] += 24;
    char v37 = (void *)*a1;
    BOOL v36 = (void *)a1[1];
    if (v36 == (void *)*a1)
    {
      int64x2_t v39 = vdupq_n_s64((unint64_t)v36);
    }
    else
    {
      do
      {
        *(void *)(v35 - 24) = 0;
        *(void *)(v35 - 16) = 0;
        v35 -= 24;
        *(void *)(v35 + 16) = 0;
        long long v38 = *(_OWORD *)(v36 - 3);
        v36 -= 3;
        *(_OWORD *)uint64_t v35 = v38;
        *(void *)(v35 + 16) = v36[2];
        *BOOL v36 = 0;
        v36[1] = 0;
        void v36[2] = 0;
      }
      while (v36 != v37);
      int64x2_t v39 = *(int64x2_t *)a1;
      uint64_t v28 = v70.i64[1];
    }
    *a1 = v35;
    a1[1] = v28;
    int64x2_t v70 = v39;
    char v40 = (uint64_t *)a1[2];
    a1[2] = (uint64_t)v71;
    char v71 = v40;
    uint64_t v69 = (uint64_t *)v39.i64[0];
    std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)&v69);
  }
  else
  {
    *uint64_t v27 = 0;
    v27[1] = 0;
    v27[2] = 0;
    std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(v27, v17, (uint64_t)v18, v18 - v17);
    uint64_t v28 = (uint64_t)(v27 + 3);
    a1[1] = (uint64_t)(v27 + 3);
  }
  a1[1] = v28;
  uint64_t v41 = *(void *)(v60 + 48);
  unint64_t v42 = (*(void *)(v60 + 56) - v41) >> 2;
  if (v42 > v20)
  {
    uint64_t v43 = v20;
LABEL_27:
    unint64_t v24 = *(int *)(v41 + 4 * v43);
    if (!v66[0]) {
      goto LABEL_36;
    }
    char v44 = v66[0];
    while (1)
    {
      unint64_t v45 = v44[4];
      if (v45 <= v24)
      {
        if (v45 >= v24)
        {
          if (++v43 != v42) {
            goto LABEL_27;
          }
          break;
        }
        ++v44;
      }
      char v44 = (void *)*v44;
      if (!v44)
      {
        int v20 = v43;
LABEL_36:
        unint64_t v61 = *(int *)(v41 + 4 * v43);
        ++v20;
        unint64_t v18 = v17;
LABEL_37:
        *((unsigned char *)std::__tree<std::__value_type<unsigned long,BOOL>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,BOOL>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,BOOL>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v65, v24, (uint64_t **)&v61)+ 40) = 1;
        if ((unint64_t)v18 >= v19)
        {
          uint64_t v46 = v18 - v17;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          if ((uint64_t)(v19 - (void)v17) >> 2 > v47) {
            unint64_t v47 = (uint64_t)(v19 - (void)v17) >> 2;
          }
          if (v19 - (unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v48 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v48 = v47;
          }
          if (v48) {
            unint64_t v48 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v48);
          }
          else {
            uint64_t v49 = 0;
          }
          unint64_t v50 = (unint64_t *)(v48 + 8 * v46);
          unint64_t *v50 = v24;
          int v51 = v50 + 1;
          while (v18 != v17)
          {
            unint64_t v52 = *--v18;
            *--unint64_t v50 = v52;
          }
          unint64_t v19 = v48 + 8 * v49;
          if (v17) {
            operator delete(v17);
          }
          int v17 = v50;
          unint64_t v18 = v51;
        }
        else
        {
          *v18++ = v24;
        }
        BOOL v53 = std::__tree<std::__value_type<unsigned long,std::list<unsigned long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<unsigned long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<unsigned long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v67, v61, (uint64_t **)&v61);
        char v54 = v53 + 5;
        for (int i = v53[6]; i != (uint64_t *)v54; int i = (uint64_t *)i[1])
        {
          BOOL v56 = (uint64_t *)i[2];
          uint64_t v69 = v56;
          if (!*((unsigned char *)std::__tree<std::__value_type<unsigned long,BOOL>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,BOOL>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,BOOL>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v65, (unint64_t)v56, &v69)+ 40))
          {
            unint64_t v57 = operator new(0x18uLL);
            v57[1] = &v62;
            v57[2] = v56;
            unint64_t v58 = v62;
            void *v57 = v62;
            v58[1] = v57;
            BOOL v62 = v57;
            ++v64;
          }
        }
        if (*(unsigned char *)(*(void *)(a2 + 56) + 120))
        {
          uint64_t v60 = *(void *)(a2 + 56);
          goto LABEL_61;
        }
        goto LABEL_6;
      }
    }
  }
  if (v17) {
    operator delete(v17);
  }
  std::__list_imp<long long>::clear(&v62);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v66[0]);
  std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(v68[0]);
}

void sub_1A403EEA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16, void *a17, uint64_t a18, uint64_t a19, void *a20)
{
}

uint64_t **std::__tree<std::__value_type<unsigned long,std::list<unsigned long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<unsigned long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<unsigned long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  unint64_t v6 = a1 + 1;
  char v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        char v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      char v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = a1 + 1;
LABEL_9:
    unint64_t v9 = (uint64_t *)v7;
    unint64_t v7 = (uint64_t **)operator new(0x40uLL);
    v7[4] = *a3;
    v7[5] = (uint64_t *)(v7 + 5);
    v7[6] = (uint64_t *)(v7 + 5);
    v7[7] = 0;
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    void *v6 = (uint64_t *)v7;
    unint64_t v10 = (uint64_t *)**a1;
    BOOL v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      BOOL v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t **std::__tree<std::__value_type<unsigned long,BOOL>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,BOOL>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,BOOL>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  unint64_t v6 = a1 + 1;
  char v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        char v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      char v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = a1 + 1;
LABEL_9:
    unint64_t v9 = (uint64_t *)v7;
    unint64_t v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = *a3;
    *((unsigned char *)v7 + 40) = 0;
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    void *v6 = (uint64_t *)v7;
    unint64_t v10 = (uint64_t *)**a1;
    BOOL v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      BOOL v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void vision::mod::GreedyClusterer::computeMergePairs(uint64_t a1, void *a2, void *a3, uint64_t *a4, int a5)
{
  uint64_t v5 = *(void *)(a1 + 56);
  if (*(void *)(v5 + 56) != *(void *)(v5 + 48))
  {
    uint64_t v9 = a1;
    vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v57, *(_DWORD *)(v5 + 104), *(_DWORD *)(a1 + 20));
    BOOL v12 = (void *)*a2;
    unint64_t v10 = a2 + 1;
    BOOL v11 = v12;
    if (v12 != v10)
    {
      float v13 = *(float *)(*(void *)(v9 + 24) + 12);
      unint64_t v14 = a3 + 1;
      char v54 = v10;
      int v56 = a5;
      while (1)
      {
        BOOL v15 = (void *)*a3;
        if ((void *)*a3 != v14) {
          break;
        }
LABEL_48:
        unint64_t v52 = (void *)v11[1];
        if (v52)
        {
          do
          {
            BOOL v53 = v52;
            unint64_t v52 = (void *)*v52;
          }
          while (v52);
        }
        else
        {
          do
          {
            BOOL v53 = (void *)v11[2];
            BOOL v19 = *v53 == (void)v11;
            BOOL v11 = v53;
          }
          while (!v19);
        }
        BOOL v11 = v53;
        if (v53 == v54) {
          goto LABEL_54;
        }
      }
      uint64_t v16 = v11[4];
      unsigned int v17 = v16;
      while (1)
      {
        uint64_t v18 = v15[4];
        BOOL v19 = v18 <= v16 && a5 == 0;
        if (!v19)
        {
          uint64_t v20 = *(void *)(v9 + 56);
          uint64_t v21 = *(uint64_t **)(v20 + 72);
          if (v21)
          {
            uint64_t v22 = *v21;
            uint64_t v23 = v22 + 24;
            unsigned int v24 = *(_DWORD *)(v22 + 16);
            unint64_t v25 = v22 + 24 + v18 * (unint64_t)v24;
            if (*(_DWORD *)(v25 + 8))
            {
              uint64_t v26 = v23 + v17 * (unint64_t)v24;
              if (*(float *)(v25 + 12) >= *(float *)(v26 + 12)) {
                float v27 = *(float *)(v26 + 12);
              }
              else {
                float v27 = *(float *)(v25 + 12);
              }
LABEL_17:
              vDSP_Length v28 = *(int *)(v20 + 104);
              __C[0] = 0.0;
              vDSP_dotpr((const float *)(v26 + 16), 1, (const float *)(v25 + 16), 1, __C, v28);
              if ((float)((float)((float)(__C[0] + 1.0) * -0.5) + 1.0) < (float)(v13 * v27))
              {
                uint64_t v29 = **(void **)(*(void *)(v9 + 56) + 72);
                uint64_t v30 = v29 + 24;
                LODWORD(v29) = *(_DWORD *)(v29 + 16);
                unint64_t v31 = *(void *)(v30 + v18 * (unint64_t)v29);
                unint64_t v32 = *(void *)(v30 + v17 * (unint64_t)v29);
                if (v31 >= v32) {
                  unint64_t v33 = v32;
                }
                else {
                  unint64_t v33 = v31;
                }
                if (v31 <= v32) {
                  unint64_t v34 = v32;
                }
                else {
                  unint64_t v34 = v31;
                }
                uint64_t v35 = *a4;
                char v37 = *(unint64_t **)(*a4 + 8);
                unint64_t v36 = *(void *)(*a4 + 16);
                if ((unint64_t)v37 >= v36)
                {
                  uint64_t v39 = v9;
                  char v40 = a4;
                  uint64_t v41 = *(unint64_t **)v35;
                  uint64_t v42 = ((uint64_t)v37 - *(void *)v35) >> 4;
                  unint64_t v43 = v42 + 1;
                  if ((unint64_t)(v42 + 1) >> 60) {
                    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                  }
                  uint64_t v44 = v36 - (void)v41;
                  if (v44 >> 3 > v43) {
                    unint64_t v43 = v44 >> 3;
                  }
                  BOOL v45 = (unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0;
                  unint64_t v46 = 0xFFFFFFFFFFFFFFFLL;
                  if (!v45) {
                    unint64_t v46 = v43;
                  }
                  if (v46)
                  {
                    unint64_t v46 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v46);
                    uint64_t v41 = *(unint64_t **)v35;
                    char v37 = *(unint64_t **)(v35 + 8);
                  }
                  else
                  {
                    uint64_t v47 = 0;
                  }
                  unint64_t v48 = (unint64_t *)(v46 + 16 * v42);
                  *unint64_t v48 = v33;
                  v48[1] = v34;
                  uint64_t v49 = v48;
                  a4 = v40;
                  if (v37 == v41)
                  {
                    uint64_t v9 = v39;
                    unsigned int v17 = v16;
                  }
                  else
                  {
                    unsigned int v17 = v16;
                    do
                    {
                      *((_OWORD *)v49 - 1) = *((_OWORD *)v37 - 1);
                      v49 -= 2;
                      v37 -= 2;
                    }
                    while (v37 != v41);
                    uint64_t v41 = *(unint64_t **)v35;
                    uint64_t v9 = v39;
                  }
                  long long v38 = v48 + 2;
                  *(void *)uint64_t v35 = v49;
                  *(void *)(v35 + 8) = v48 + 2;
                  *(void *)(v35 + 16) = v46 + 16 * v47;
                  a5 = v56;
                  if (v41) {
                    operator delete(v41);
                  }
                }
                else
                {
                  *char v37 = v33;
                  v37[1] = v34;
                  long long v38 = v37 + 2;
                  unsigned int v17 = v16;
                }
                *(void *)(v35 + 8) = v38;
              }
            }
          }
          else if (MEMORY[8])
          {
            uint64_t v26 = 0;
            unint64_t v25 = 0;
            float v27 = MEMORY[0xC];
            goto LABEL_17;
          }
        }
        unint64_t v50 = (void *)v15[1];
        if (v50)
        {
          do
          {
            int v51 = v50;
            unint64_t v50 = (void *)*v50;
          }
          while (v50);
        }
        else
        {
          do
          {
            int v51 = (void *)v15[2];
            BOOL v19 = *v51 == (void)v15;
            BOOL v15 = v51;
          }
          while (!v19);
        }
        BOOL v15 = v51;
        if (v51 == v14) {
          goto LABEL_48;
        }
      }
    }
LABEL_54:
    vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v57);
  }
}

void sub_1A403F3DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)va);
  _Unwind_Resume(a1);
}

int *std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*,false>(int *result, int *a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = ((char *)a2 - (char *)v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                if (*(a2 - 1) > v10[1])
                {
                  int v44 = *v10;
                  *unint64_t v10 = *(a2 - 2);
                  *(a2 - 2) = v44;
                  int v45 = v10[1];
                  v10[1] = *(a2 - 1);
                  *(a2 - 1) = v45;
                }
                break;
              case 3uLL:
                BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v10, v10 + 2, a2 - 2);
                break;
              case 4uLL:
                BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v10, v10 + 2, v10 + 4, a2 - 2);
                break;
              case 5uLL:
                BOOL result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v10, v10 + 2, v10 + 4, v10 + 6, a2 - 2);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            unint64_t v46 = v10 + 2;
            BOOL v48 = v10 == a2 || v46 == a2;
            if (a4)
            {
              if (!v48)
              {
                uint64_t v49 = 0;
                unint64_t v50 = v10;
                do
                {
                  int v51 = v50[3];
                  int v52 = v50[1];
                  unint64_t v50 = v46;
                  if (v51 > v52)
                  {
                    int v53 = *v46;
                    int v54 = v50[1];
                    uint64_t v55 = v49;
                    while (1)
                    {
                      int v56 = (char *)v10 + v55;
                      int v57 = *(int *)((char *)v10 + v55 + 4);
                      *((_DWORD *)v56 + 2) = *(int *)((char *)v10 + v55);
                      *((_DWORD *)v56 + 3) = v57;
                      if (!v55) {
                        break;
                      }
                      v55 -= 8;
                      if (*((_DWORD *)v56 - 1) >= v54)
                      {
                        unint64_t v58 = (int *)((char *)v10 + v55 + 8);
                        goto LABEL_82;
                      }
                    }
                    unint64_t v58 = v10;
LABEL_82:
                    int *v58 = v53;
                    v58[1] = v54;
                  }
                  unint64_t v46 = v50 + 2;
                  v49 += 8;
                }
                while (v50 + 2 != a2);
              }
            }
            else if (!v48)
            {
              unint64_t v90 = v10 + 1;
              do
              {
                int v91 = v9[3];
                int v92 = v9[1];
                uint64_t v9 = v46;
                if (v91 > v92)
                {
                  uint64_t v93 = *(void *)v46;
                  uint64_t v94 = HIDWORD(*(void *)v9);
                  BOOL v95 = v90;
                  do
                  {
                    int v96 = *v95;
                    v95[1] = *(v95 - 1);
                    v95[2] = v96;
                    int v97 = *(v95 - 2);
                    v95 -= 2;
                  }
                  while (v97 < (int)v94);
                  v95[1] = v93;
                  v95[2] = v94;
                }
                unint64_t v46 = v9 + 2;
                v90 += 2;
              }
              while (v9 + 2 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v59 = (v12 - 2) >> 1;
              int64_t v60 = v59;
              do
              {
                int64_t v61 = v60;
                if (v59 >= v60)
                {
                  uint64_t v62 = (2 * v60) | 1;
                  BOOL v63 = &v10[2 * v62];
                  if (2 * v61 + 2 < (uint64_t)v12)
                  {
                    int v64 = v63[1];
                    int v65 = v63[3];
                    v63 += 2 * (v64 > v65);
                    if (v64 > v65) {
                      uint64_t v62 = 2 * v61 + 2;
                    }
                  }
                  unint64_t v66 = &v10[2 * v61];
                  if (v63[1] <= v66[1])
                  {
                    int v67 = *v66;
                    int v68 = v66[1];
                    do
                    {
                      uint64_t v69 = v66;
                      unint64_t v66 = v63;
                      int *v69 = *v63;
                      v69[1] = v63[1];
                      if (v59 < v62) {
                        break;
                      }
                      uint64_t v70 = (2 * v62) | 1;
                      BOOL v63 = &v10[2 * v70];
                      uint64_t v71 = 2 * v62 + 2;
                      if (v71 < (uint64_t)v12)
                      {
                        int v72 = v63[1];
                        int v73 = v63[3];
                        v63 += 2 * (v72 > v73);
                        if (v72 > v73) {
                          uint64_t v70 = v71;
                        }
                      }
                      BOOL result = (int *)v63[1];
                      uint64_t v62 = v70;
                    }
                    while ((int)result <= v68);
                    *unint64_t v66 = v67;
                    v66[1] = v68;
                  }
                }
                int64_t v60 = v61 - 1;
              }
              while (v61);
              uint64_t v74 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v75 = 0;
                uint64_t v76 = *(void *)v10;
                unint64_t v77 = v10;
                do
                {
                  BOOL v78 = &v77[2 * v75 + 2];
                  uint64_t v79 = (2 * v75) | 1;
                  uint64_t v80 = 2 * v75 + 2;
                  if (v80 < v74)
                  {
                    int v81 = v78[1];
                    int v82 = v78[3];
                    v78 += 2 * (v81 > v82);
                    if (v81 > v82) {
                      uint64_t v79 = v80;
                    }
                  }
                  *unint64_t v77 = *v78;
                  v77[1] = v78[1];
                  unint64_t v77 = v78;
                  uint64_t v75 = v79;
                }
                while (v79 <= (uint64_t)((unint64_t)(v74 - 2) >> 1));
                if (v78 == a2 - 2)
                {
                  *(void *)BOOL v78 = v76;
                }
                else
                {
                  *BOOL v78 = *(a2 - 2);
                  v78[1] = *(a2 - 1);
                  *((void *)a2 - 1) = v76;
                  uint64_t v83 = (char *)v78 - (char *)v10 + 8;
                  if (v83 >= 9)
                  {
                    unint64_t v84 = (unint64_t)((v83 >> 3) - 2) >> 1;
                    unint64_t v85 = &v10[2 * v84];
                    if (v85[1] > v78[1])
                    {
                      int v86 = *v78;
                      int v87 = v78[1];
                      do
                      {
                        unint64_t v88 = v78;
                        BOOL v78 = v85;
                        *unint64_t v88 = *v85;
                        v88[1] = v85[1];
                        if (!v84) {
                          break;
                        }
                        unint64_t v84 = (v84 - 1) >> 1;
                        unint64_t v85 = &v10[2 * v84];
                      }
                      while (v85[1] > v87);
                      *BOOL v78 = v86;
                      v78[1] = v87;
                    }
                  }
                }
                a2 -= 2;
              }
              while (v74-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = &v10[2 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v9, &v9[2 * (v12 >> 1)], a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v9 + 2, v14 - 2, a2 - 4);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v9 + 4, &v9[2 * v13 + 2], a2 - 6);
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v14 - 2, v14, &v9[2 * v13 + 2]);
            uint64_t v15 = *(void *)v9;
            *(void *)uint64_t v9 = *(void *)v14;
            *(void *)unint64_t v14 = v15;
          }
          else
          {
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(&v9[2 * (v12 >> 1)], v9, a2 - 2);
          }
          --a3;
          if ((a4 & 1) != 0 || *(v9 - 1) > v9[1]) {
            break;
          }
          uint64_t v31 = *(void *)v9;
          uint64_t v32 = HIDWORD(*(void *)v9);
          if (*(a2 - 1) >= (int)v32)
          {
            uint64_t v35 = v9 + 2;
            do
            {
              unint64_t v10 = v35;
              if (v35 >= a2) {
                break;
              }
              int v36 = v35[1];
              v35 += 2;
            }
            while (v36 >= (int)v32);
          }
          else
          {
            unint64_t v33 = v9;
            do
            {
              unint64_t v10 = v33 + 2;
              int v34 = v33[3];
              v33 += 2;
            }
            while (v34 >= (int)v32);
          }
          char v37 = a2;
          if (v10 < a2)
          {
            long long v38 = a2;
            do
            {
              char v37 = v38 - 2;
              int v39 = *(v38 - 1);
              v38 -= 2;
            }
            while (v39 < (int)v32);
          }
          while (v10 < v37)
          {
            int v40 = *v10;
            *unint64_t v10 = *v37;
            *char v37 = v40;
            int v41 = v10[1];
            v10[1] = v37[1];
            v37[1] = v41;
            do
            {
              int v42 = v10[3];
              v10 += 2;
            }
            while (v42 >= (int)v32);
            do
            {
              int v43 = *(v37 - 1);
              v37 -= 2;
            }
            while (v43 < (int)v32);
          }
          BOOL v4 = v10 - 2 >= v9;
          BOOL v5 = v10 - 2 == v9;
          if (v10 - 2 != v9)
          {
            *uint64_t v9 = *(v10 - 2);
            v9[1] = *(v10 - 1);
          }
          a4 = 0;
          *(v10 - 2) = v31;
          *(v10 - 1) = v32;
        }
        uint64_t v16 = *(void *)v9;
        uint64_t v17 = HIDWORD(*(void *)v9);
        uint64_t v18 = v9;
        do
        {
          BOOL v19 = v18;
          v18 += 2;
        }
        while (v19[3] > (int)v17);
        uint64_t v20 = a2;
        if (v19 == v9)
        {
          uint64_t v23 = a2;
          while (v18 < v23)
          {
            uint64_t v21 = v23 - 2;
            int v24 = *(v23 - 1);
            v23 -= 2;
            if (v24 > (int)v17) {
              goto LABEL_22;
            }
          }
          uint64_t v21 = v23;
        }
        else
        {
          do
          {
            uint64_t v21 = v20 - 2;
            int v22 = *(v20 - 1);
            v20 -= 2;
          }
          while (v22 <= (int)v17);
        }
LABEL_22:
        unint64_t v10 = v18;
        if (v18 < v21)
        {
          unint64_t v25 = v21;
          do
          {
            int v26 = *v10;
            *unint64_t v10 = *v25;
            *unint64_t v25 = v26;
            int v27 = v10[1];
            v10[1] = v25[1];
            v25[1] = v27;
            do
            {
              int v28 = v10[3];
              v10 += 2;
            }
            while (v28 > (int)v17);
            do
            {
              int v29 = *(v25 - 1);
              v25 -= 2;
            }
            while (v29 <= (int)v17);
          }
          while (v10 < v25);
        }
        if (v10 - 2 != v9)
        {
          *uint64_t v9 = *(v10 - 2);
          v9[1] = *(v10 - 1);
        }
        *(v10 - 2) = v16;
        *(v10 - 1) = v17;
        if (v18 >= v21) {
          break;
        }
LABEL_33:
        BOOL result = (int *)std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*,false>(v9, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v9, v10 - 2);
      BOOL result = (int *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v10, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 2;
    if (!v30) {
      continue;
    }
    return result;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(int *a1, int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(a2 - 1) > a1[1])
      {
        int v6 = *a1;
        *a1 = *(a2 - 2);
        *(a2 - 2) = v6;
        int v7 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      unint64_t v8 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a1 + 4);
      uint64_t v9 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    if (v9[1] > v8[1])
    {
      int v12 = *v9;
      int v13 = v9[1];
      uint64_t v14 = v10;
      while (1)
      {
        uint64_t v15 = (int *)((char *)a1 + v14);
        int v16 = *(int *)((char *)a1 + v14 + 20);
        v15[6] = *(int *)((char *)a1 + v14 + 16);
        v15[7] = v16;
        if (v14 == -16) {
          break;
        }
        v14 -= 8;
        if (v15[3] >= v13)
        {
          uint64_t v17 = (int *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      uint64_t v17 = a1;
LABEL_12:
      int *v17 = v12;
      v17[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    unint64_t v8 = v9;
    v10 += 8;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

void *std::set<long long>::set[abi:ne180100](void *a1, void *a2)
{
  a1[1] = 0;
  unint64_t v3 = a1 + 1;
  a1[2] = 0;
  *a1 = a1 + 1;
  uint64_t v4 = a2 + 1;
  BOOL v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      int v6 = (uint64_t **)std::__tree<long long>::__find_equal<long long>(a1, v3, &v14, &v13, v5[4]);
      if (!*v6)
      {
        int v7 = v6;
        unint64_t v8 = (uint64_t *)operator new(0x28uLL);
        v8[4] = v5[4];
        std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)a1, v14, v7, v8);
      }
      uint64_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v11 = *v10 == (void)v5;
          BOOL v5 = v10;
        }
        while (!v11);
      }
      BOOL v5 = v10;
    }
    while (v10 != v4);
  }
  return a1;
}

void sub_1A403FDC8(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

void *std::__tree<long long>::__find_equal<long long>(void *a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  BOOL v5 = a1 + 1;
  if (a1 + 1 == a2 || (uint64_t v6 = a2[4], v6 > a5))
  {
    uint64_t v7 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v9 = a2;
LABEL_18:
      if (v7)
      {
        *a3 = v9;
        return v9 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v7)
    {
      unint64_t v8 = (void *)*a2;
      do
      {
        uint64_t v9 = v8;
        unint64_t v8 = (void *)v8[1];
      }
      while (v8);
    }
    else
    {
      int v12 = a2;
      do
      {
        uint64_t v9 = (void *)v12[2];
        BOOL v13 = *v9 == (void)v12;
        int v12 = v9;
      }
      while (v13);
    }
    if (v9[4] < a5) {
      goto LABEL_18;
    }
    uint64_t v14 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v15 = v14;
          uint64_t v16 = v14[4];
          if (v16 <= a5) {
            break;
          }
          uint64_t v14 = (void *)*v15;
          BOOL v5 = v15;
          if (!*v15) {
            goto LABEL_43;
          }
        }
        if (v16 >= a5) {
          break;
        }
        BOOL v5 = v15 + 1;
        uint64_t v14 = (void *)v15[1];
      }
      while (v14);
      goto LABEL_43;
    }
LABEL_42:
    uint64_t v15 = a1 + 1;
LABEL_43:
    *a3 = v15;
    return v5;
  }
  if (v6 >= a5)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  uint64_t v10 = a2[1];
  if (v10)
  {
    BOOL v11 = (void *)a2[1];
    do
    {
      a4 = v11;
      BOOL v11 = (void *)*v11;
    }
    while (v11);
  }
  else
  {
    uint64_t v17 = a2;
    do
    {
      a4 = (void *)v17[2];
      BOOL v13 = *a4 == (void)v17;
      uint64_t v17 = a4;
    }
    while (!v13);
  }
  if (a4 != v5 && a4[4] <= a5)
  {
    uint64_t v18 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v15 = v18;
          uint64_t v19 = v18[4];
          if (v19 <= a5) {
            break;
          }
          uint64_t v18 = (void *)*v15;
          BOOL v5 = v15;
          if (!*v15) {
            goto LABEL_43;
          }
        }
        if (v19 >= a5) {
          break;
        }
        BOOL v5 = v15 + 1;
        uint64_t v18 = (void *)v15[1];
      }
      while (v18);
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  if (v10)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void std::__shared_ptr_emplace<std::vector<std::pair<unsigned long,unsigned long>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<std::pair<unsigned long,unsigned long>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753C08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<std::vector<std::pair<unsigned long,unsigned long>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753C08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t vision::mod::GreedyClustererFaces::cancelLongRunning(uint64_t this)
{
  *(unsigned char *)(*(void *)(this + 64) + 120) = 1;
  return this;
}

uint64_t vision::mod::GreedyClustererFaces::getAverageDescriptorsOfClusters(vision::mod::GreedyClustererFaces *a1, uint64_t **a2, uint64_t a3)
{
  v19[0] = 0;
  v19[1] = 0;
  uint64_t v18 = v19;
  uint64_t v6 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *, void ***))(*(void *)a1 + 112))(a1, &v18);
  if (v6 == 5248)
  {
    uint64_t v7 = *a2;
    unint64_t v8 = a2[1];
    if (*a2 == v8)
    {
LABEL_7:
      uint64_t v6 = 5248;
    }
    else
    {
      uint64_t v6 = 5243;
      while (1)
      {
        uint64_t v9 = *v7;
        uint64_t v10 = malloc_type_malloc(4 * *(int *)(*((void *)a1 + 8) + 104), 0x100004052888210uLL);
        if (!v10) {
          break;
        }
        if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, v9) & 1) == 0)
        {
          free(v10);
          uint64_t v6 = 5244;
          break;
        }
        vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, v9, (uint64_t)&v18, v10);
        BOOL v11 = operator new(8uLL);
        *BOOL v11 = v9;
        v14[1] = v11 + 1;
        v14[2] = v11 + 1;
        v14[0] = v11;
        uint64_t v12 = *(int *)(*((void *)a1 + 8) + 104);
        vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)v15, v14, v10, 4 * v12, 1, 1);
        int v16 = 1;
        uint64_t v17 = 0;
        v15[0] = &unk_1EF752918;
        v15[12] = (void *)(v12 & 0x3FFFFFFFFFFFFFFFLL);
        operator delete(v11);
        (*(void (**)(uint64_t, void **))(*(void *)a3 + 40))(a3, v15);
        v15[0] = &unk_1EF752918;
        free(v17);
        vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(v15);
        if (++v7 == v8) {
          goto LABEL_7;
        }
      }
    }
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v19[0]);
  return v6;
}

void sub_1A40401E8(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*(void **)(v1 - 104));
  _Unwind_Resume(a1);
}

void vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)a1, a2) & 1) == 0)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    uint64_t v17 = 5244;
    goto LABEL_20;
  }
  if (!a4)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    uint64_t v17 = 5245;
LABEL_20:
    *exceptiouint64_t n = v17;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  memset(a4, 48, 4 * *(int *)(a1[8] + 104));
  unint64_t v8 = (void *)a1[18];
  if (!v8) {
    goto LABEL_13;
  }
  uint64_t v9 = a1 + 18;
  do
  {
    uint64_t v10 = v8[4];
    BOOL v11 = v10 < a2;
    if (v10 >= a2) {
      uint64_t v12 = v8;
    }
    else {
      uint64_t v12 = v8 + 1;
    }
    if (!v11) {
      uint64_t v9 = v8;
    }
    unint64_t v8 = (void *)*v12;
  }
  while (*v12);
  if (v9 == a1 + 18 || v9[4] > a2) {
LABEL_13:
  }
    uint64_t v9 = a1 + 18;
  uint64_t v13 = v9[5];
  uint64_t v32 = v13;
  uint64_t v14 = *(void **)(a3 + 8);
  if (!v14)
  {
LABEL_19:
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    uint64_t v17 = 5224;
    goto LABEL_20;
  }
  while (1)
  {
    uint64_t v15 = v14[4];
    if (v13 >= v15) {
      break;
    }
LABEL_18:
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      goto LABEL_19;
    }
  }
  if (v15 < v13)
  {
    ++v14;
    goto LABEL_18;
  }
  uint64_t v18 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)a3, v13, &v32);
  uint64_t v20 = (uint64_t *)v18[5];
  uint64_t v19 = (uint64_t *)v18[6];
  float __B = 1.0 / (float)(unint64_t)(v19 - v20);
  if (v19 != v20)
  {
    uint64_t v21 = a1 + 15;
    do
    {
      int v22 = (void *)*v21;
      if (!*v21) {
        goto LABEL_33;
      }
      uint64_t v23 = *v20;
      int v24 = a1 + 15;
      do
      {
        uint64_t v25 = v22[4];
        BOOL v26 = v25 < v23;
        if (v25 >= v23) {
          int v27 = v22;
        }
        else {
          int v27 = v22 + 1;
        }
        if (!v26) {
          int v24 = v22;
        }
        int v22 = (void *)*v27;
      }
      while (*v27);
      if (v24 == v21 || v23 < v24[4]) {
LABEL_33:
      }
        int v24 = a1 + 15;
      uint64_t v28 = a1[8];
      uint64_t v29 = *(void *)(v28 + 88);
      if (v29) {
        unint64_t v30 = *(void *)v29
      }
            + *((unsigned int *)v24 + 10) * (unint64_t)*(unsigned int *)(*(void *)v29 + 16)
            + 24;
      else {
        unint64_t v30 = 0;
      }
      vDSP_vadd((const float *)(v30 + 16), 1, (const float *)a4, 1, (float *)a4, 1, *(int *)(v28 + 104));
      ++v20;
    }
    while (v20 != v19);
  }
  vDSP_vsmul((const float *)a4, 1, &__B, (float *)a4, 1, *(int *)(a1[8] + 104));
}

uint64_t vision::mod::GreedyClustererFaces::descriptorLength(vision::mod::GreedyClustererFaces *this)
{
  uint64_t v1 = *((void *)this + 8);
  if (v1) {
    return *(int *)(v1 + 104);
  }
  else {
    return 0;
  }
}

void vision::mod::GreedyClustererFaces::getIdsForCluster(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)a1, a2) & 1) == 0)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 5244;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  unint64_t v8 = a1 + 18;
  unint64_t v9 = *std::map<long long,unsigned long>::at((void *)a1[18], a2);
  std::vector<long long>::reserve((void **)a3, a1[19] + 1);
  if (a4)
  {
    uint64_t v10 = std::__hash_table<std::__hash_value_type<long long,long long>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,long long>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,long long>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,long long>>>::__equal_range_multi<long long>(a4, v9);
    if (v10 != v11)
    {
      uint64_t v12 = v10;
      uint64_t v13 = v11;
      uint64_t v14 = *(void **)(a3 + 8);
      do
      {
        unint64_t v15 = *(void *)(a3 + 16);
        if ((unint64_t)v14 >= v15)
        {
          uint64_t v17 = *(void **)a3;
          uint64_t v18 = ((uint64_t)v14 - *(void *)a3) >> 3;
          unint64_t v19 = v18 + 1;
          if ((unint64_t)(v18 + 1) >> 61) {
            goto LABEL_49;
          }
          uint64_t v20 = v15 - (void)v17;
          if (v20 >> 2 > v19) {
            unint64_t v19 = v20 >> 2;
          }
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v21 = v19;
          }
          if (v21)
          {
            unint64_t v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v21);
            uint64_t v17 = *(void **)a3;
            uint64_t v14 = *(void **)(a3 + 8);
          }
          else
          {
            uint64_t v22 = 0;
          }
          uint64_t v23 = (void *)(v21 + 8 * v18);
          *uint64_t v23 = v12[3];
          int v16 = v23 + 1;
          while (v14 != v17)
          {
            uint64_t v24 = *--v14;
            *--uint64_t v23 = v24;
          }
          *(void *)a3 = v23;
          *(void *)(a3 + 8) = v16;
          *(void *)(a3 + 16) = v21 + 8 * v22;
          if (v17) {
            operator delete(v17);
          }
        }
        else
        {
          *uint64_t v14 = v12[3];
          int v16 = v14 + 1;
        }
        *(void *)(a3 + 8) = v16;
        uint64_t v12 = (void *)*v12;
        uint64_t v14 = v16;
      }
      while (v12 != v13);
    }
  }
  else
  {
    uint64_t v25 = (void *)a1[17];
    if (v25 != v8)
    {
      do
      {
        if (v25[5] == v9)
        {
          int v27 = *(void **)(a3 + 8);
          unint64_t v26 = *(void *)(a3 + 16);
          if ((unint64_t)v27 >= v26)
          {
            uint64_t v29 = *(void **)a3;
            uint64_t v30 = ((uint64_t)v27 - *(void *)a3) >> 3;
            unint64_t v31 = v30 + 1;
            if ((unint64_t)(v30 + 1) >> 61) {
LABEL_49:
            }
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            uint64_t v32 = v26 - (void)v29;
            if (v32 >> 2 > v31) {
              unint64_t v31 = v32 >> 2;
            }
            if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v33 = v31;
            }
            if (v33)
            {
              unint64_t v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v33);
              uint64_t v29 = *(void **)a3;
              int v27 = *(void **)(a3 + 8);
            }
            else
            {
              uint64_t v34 = 0;
            }
            uint64_t v35 = (void *)(v33 + 8 * v30);
            *uint64_t v35 = v25[4];
            uint64_t v28 = v35 + 1;
            while (v27 != v29)
            {
              uint64_t v36 = *--v27;
              *--uint64_t v35 = v36;
            }
            *(void *)a3 = v35;
            *(void *)(a3 + 8) = v28;
            *(void *)(a3 + 16) = v33 + 8 * v34;
            if (v29) {
              operator delete(v29);
            }
          }
          else
          {
            *int v27 = v25[4];
            uint64_t v28 = v27 + 1;
          }
          *(void *)(a3 + 8) = v28;
        }
        char v37 = (void *)v25[1];
        if (v37)
        {
          do
          {
            long long v38 = v37;
            char v37 = (void *)*v37;
          }
          while (v37);
        }
        else
        {
          do
          {
            long long v38 = (void *)v25[2];
            BOOL v39 = *v38 == (void)v25;
            uint64_t v25 = v38;
          }
          while (!v39);
        }
        uint64_t v25 = v38;
      }
      while (v38 != v8);
    }
  }
}

void vision::mod::GreedyClustererFaces::getAllClustersFromState(vision::mod::GreedyClustererFaces *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v30 = (uint64_t *)v31;
  unint64_t v3 = (char *)*((void *)this + 17);
  uint64_t v4 = (char *)this + 144;
  if (v3 != (char *)this + 144)
  {
    do
    {
      uint64_t v5 = *((void *)v3 + 4);
      uint64_t v28 = *((void *)v3 + 5);
      uint64_t v6 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v30, v28, &v28);
      uint64_t v7 = v6;
      unint64_t v9 = (char *)v6[6];
      unint64_t v8 = v6[7];
      if ((unint64_t)v9 >= v8)
      {
        BOOL v11 = (char *)v6[5];
        uint64_t v12 = (v9 - v11) >> 3;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v8 - (void)v11;
        if (v14 >> 2 > v13) {
          unint64_t v13 = v14 >> 2;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
          BOOL v11 = (char *)v7[5];
          unint64_t v9 = (char *)v7[6];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = (void *)(v15 + 8 * v12);
        void *v17 = v5;
        uint64_t v10 = v17 + 1;
        while (v9 != v11)
        {
          uint64_t v18 = *((void *)v9 - 1);
          v9 -= 8;
          *--uint64_t v17 = v18;
        }
        v7[5] = (uint64_t)v17;
        v7[6] = (uint64_t)v10;
        v7[7] = v15 + 8 * v16;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(void *)unint64_t v9 = v5;
        uint64_t v10 = v9 + 8;
      }
      v7[6] = (uint64_t)v10;
      unint64_t v19 = (char *)*((void *)v3 + 1);
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          unint64_t v19 = *(char **)v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (char *)*((void *)v3 + 2);
          BOOL v21 = *(void *)v20 == (void)v3;
          unint64_t v3 = v20;
        }
        while (!v21);
      }
      unint64_t v3 = v20;
    }
    while (v20 != v4);
    uint64_t v22 = v30;
    if (v30 != (uint64_t *)v31)
    {
      do
      {
        uint64_t v23 = (const void *)v22[5];
        uint64_t v28 = v22[4];
        memset(__p, 0, sizeof(__p));
        std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(__p, v23, v22[6], (v22[6] - (uint64_t)v23) >> 3);
        unint64_t v24 = a2[1];
        if (v24 >= a2[2])
        {
          uint64_t v25 = std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>(a2, (uint64_t)__p);
        }
        else
        {
          std::vector<std::vector<long long>>::__construct_one_at_end[abi:ne180100]<std::vector<long long> const&>((uint64_t)a2, (uint64_t)__p);
          uint64_t v25 = v24 + 24;
        }
        a2[1] = v25;
        if (__p[0]) {
          operator delete(__p[0]);
        }
        unint64_t v26 = (uint64_t *)v22[1];
        if (v26)
        {
          do
          {
            int v27 = v26;
            unint64_t v26 = (uint64_t *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            int v27 = (uint64_t *)v22[2];
            BOOL v21 = *v27 == (void)v22;
            uint64_t v22 = v27;
          }
          while (!v21);
        }
        uint64_t v22 = v27;
      }
      while (v27 != (uint64_t *)v31);
    }
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v31[0]);
}

void sub_1A40408D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
}

void vision::mod::GreedyClustererFaces::getClusters(vision::mod::GreedyClustererFaces *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v30 = (uint64_t *)v31;
  unint64_t v3 = (char *)*((void *)this + 17);
  uint64_t v4 = (char *)this + 144;
  if (v3 != (char *)this + 144)
  {
    do
    {
      uint64_t v5 = *((void *)v3 + 4);
      uint64_t v28 = *((void *)v3 + 5);
      uint64_t v6 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v30, v28, &v28);
      uint64_t v7 = v6;
      unint64_t v9 = (char *)v6[6];
      unint64_t v8 = v6[7];
      if ((unint64_t)v9 >= v8)
      {
        BOOL v11 = (char *)v6[5];
        uint64_t v12 = (v9 - v11) >> 3;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v8 - (void)v11;
        if (v14 >> 2 > v13) {
          unint64_t v13 = v14 >> 2;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
          BOOL v11 = (char *)v7[5];
          unint64_t v9 = (char *)v7[6];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = (void *)(v15 + 8 * v12);
        void *v17 = v5;
        uint64_t v10 = v17 + 1;
        while (v9 != v11)
        {
          uint64_t v18 = *((void *)v9 - 1);
          v9 -= 8;
          *--uint64_t v17 = v18;
        }
        v7[5] = (uint64_t)v17;
        v7[6] = (uint64_t)v10;
        v7[7] = v15 + 8 * v16;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(void *)unint64_t v9 = v5;
        uint64_t v10 = v9 + 8;
      }
      v7[6] = (uint64_t)v10;
      unint64_t v19 = (char *)*((void *)v3 + 1);
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          unint64_t v19 = *(char **)v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (char *)*((void *)v3 + 2);
          BOOL v21 = *(void *)v20 == (void)v3;
          unint64_t v3 = v20;
        }
        while (!v21);
      }
      unint64_t v3 = v20;
    }
    while (v20 != v4);
    uint64_t v22 = v30;
    if (v30 != (uint64_t *)v31)
    {
      do
      {
        uint64_t v23 = (const void *)v22[5];
        uint64_t v28 = v22[4];
        memset(__p, 0, sizeof(__p));
        std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(__p, v23, v22[6], (v22[6] - (uint64_t)v23) >> 3);
        unint64_t v24 = a2[1];
        if (v24 >= a2[2])
        {
          uint64_t v25 = std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>(a2, (uint64_t)__p);
        }
        else
        {
          std::vector<std::vector<long long>>::__construct_one_at_end[abi:ne180100]<std::vector<long long> const&>((uint64_t)a2, (uint64_t)__p);
          uint64_t v25 = v24 + 24;
        }
        a2[1] = v25;
        if (__p[0]) {
          operator delete(__p[0]);
        }
        unint64_t v26 = (uint64_t *)v22[1];
        if (v26)
        {
          do
          {
            int v27 = v26;
            unint64_t v26 = (uint64_t *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            int v27 = (uint64_t *)v22[2];
            BOOL v21 = *v27 == (void)v22;
            uint64_t v22 = v27;
          }
          while (!v21);
        }
        uint64_t v22 = v27;
      }
      while (v27 != (uint64_t *)v31);
    }
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v31[0]);
}

void sub_1A4040B30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
}

double vision::mod::GreedyClustererFaces::getClusteredIds(uint64_t a1, uint64_t a2)
{
  allKeys<long long,unsigned long>((char **)&v5, (void *)(a1 + 112));
  unint64_t v3 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v3;
    operator delete(v3);
  }
  double result = *(double *)&v5;
  *(_OWORD *)a2 = v5;
  *(void *)(a2 + 16) = v6;
  return result;
}

uint64_t vision::mod::GreedyClustererFaces::getMaximumFaceId(vision::mod::GreedyClustererFaces *this)
{
  uint64_t v1 = (void *)*((void *)this + 17);
  uint64_t v2 = (char *)this + 144;
  if (v1 == (void *)((char *)this + 144)) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    if (result <= v1[4]) {
      uint64_t result = v1[4];
    }
    uint64_t v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        long long v5 = v4;
        uint64_t v4 = (void *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        long long v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        uint64_t v1 = v5;
      }
      while (!v6);
    }
    uint64_t v1 = v5;
  }
  while (v5 != (void *)v2);
  return result;
}

uint64_t vision::mod::GreedyClustererFaces::getClusterIdForFaceId(vision::mod::GreedyClustererFaces *this, uint64_t a2)
{
  if (vision::mod::GreedyClustererFaces::isFaceIdInClustererState(this, a2)) {
    return *std::map<long long,unsigned long>::at(*((void **)this + 18), a2);
  }
  else {
    return -1;
  }
}

uint64_t vision::mod::GreedyClustererFaces::computeClusterMapL1(uint64_t a1, uint64_t **a2)
{
  uint64_t v2 = *(void **)(a1 + 136);
  unint64_t v3 = (void *)(a1 + 144);
  if (v2 != (void *)(a1 + 144))
  {
    do
    {
      long long v22 = *((_OWORD *)v2 + 2);
      long long v5 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, *((uint64_t *)&v22 + 1), (uint64_t *)&v22 + 1);
      BOOL v6 = v5;
      unint64_t v8 = (char *)v5[6];
      unint64_t v7 = v5[7];
      if ((unint64_t)v8 >= v7)
      {
        uint64_t v10 = (char *)v5[5];
        uint64_t v11 = (v8 - v10) >> 3;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v7 - (void)v10;
        if (v13 >> 2 > v12) {
          unint64_t v12 = v13 >> 2;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v14);
          uint64_t v10 = (char *)v6[5];
          unint64_t v8 = (char *)v6[6];
        }
        else
        {
          uint64_t v15 = 0;
        }
        uint64_t v16 = (void *)(v14 + 8 * v11);
        *uint64_t v16 = v22;
        unint64_t v9 = v16 + 1;
        while (v8 != v10)
        {
          uint64_t v17 = *((void *)v8 - 1);
          v8 -= 8;
          *--uint64_t v16 = v17;
        }
        v6[5] = (uint64_t)v16;
        v6[6] = (uint64_t)v9;
        v6[7] = v14 + 8 * v15;
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        *(void *)unint64_t v8 = v22;
        unint64_t v9 = v8 + 8;
      }
      v6[6] = (uint64_t)v9;
      uint64_t v18 = (void *)v2[1];
      if (v18)
      {
        do
        {
          unint64_t v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          unint64_t v19 = (void *)v2[2];
          BOOL v20 = *v19 == (void)v2;
          uint64_t v2 = v19;
        }
        while (!v20);
      }
      uint64_t v2 = v19;
    }
    while (v19 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::getDistanceBetweenLevel1ClustersContaining(vision::mod::GreedyClustererFaces *a1, uint64_t a2, uint64_t **a3, uint64_t a4, char **a5)
{
  if (!vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, a2)) {
    return 5244;
  }
  unint64_t v10 = *(int *)(*((void *)a1 + 8) + 104);
  v22[0] = 0;
  std::vector<float>::vector(v23, v10, v22);
  vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, a2, a4, v23[0]);
  int v11 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *))(*(void *)a1 + 168))(a1);
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v22, v11, 2);
  std::vector<float>::resize(a5, a3[1] - *a3);
  unint64_t v12 = *a3;
  uint64_t v13 = a3[1];
  if (*a3 == v13)
  {
    uint64_t v15 = &CVML_status_ok;
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v15 = &CVML_status_invalidParameter;
    while (1)
    {
      uint64_t v16 = *v12;
      if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, *v12) & 1) == 0) {
        break;
      }
      unint64_t v17 = *(int *)(*((void *)a1 + 8) + 104);
      float __C = 0.0;
      std::vector<float>::vector(__B, v17, &__C);
      vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, v16, a4, __B[0]);
      vDSP_Length v18 = *(int *)(*((void *)a1 + 8) + 104);
      float __C = 0.0;
      vDSP_dotpr((const float *)v23[0], 1, __B[0], 1, &__C, v18);
      *(float *)&(*a5)[v14] = (float)((float)(__C + 1.0) * -0.5) + 1.0;
      if (__B[0])
      {
        __B[1] = __B[0];
        operator delete(__B[0]);
      }
      ++v12;
      v14 += 4;
      if (v12 == v13)
      {
        uint64_t v15 = &CVML_status_ok;
        break;
      }
    }
  }
  uint64_t v20 = *v15;
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v22);
  if (v23[0])
  {
    v23[1] = v23[0];
    operator delete(v23[0]);
  }
  return (v20 + 128) | 0x1400;
}

void sub_1A4040FA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a13);
  uint64_t v15 = *(void **)(v13 - 128);
  if (v15)
  {
    *(void *)(v13 - 120) = v15;
    operator delete(v15);
  }
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::getDistanceBetweenLevel0ClustersContaining(vision::mod::GreedyClustererFaces *this, uint64_t a2, uint64_t a3, float *a4)
{
  if (!vision::mod::GreedyClustererFaces::isFaceIdInClustererState(this, a2)
    || !vision::mod::GreedyClustererFaces::isFaceIdInClustererState(this, a3))
  {
    return 5244;
  }
  uint64_t v8 = *((void *)this + 8);
  unint64_t v9 = std::map<long long,unsigned long>::at(*((void **)this + 15), a2);
  uint64_t v10 = *(void *)(v8 + 88);
  if (v10) {
    unint64_t v11 = *(void *)v10 + *(unsigned int *)v9 * (unint64_t)*(unsigned int *)(*(void *)v10 + 16) + 24;
  }
  else {
    unint64_t v11 = 0;
  }
  uint64_t v13 = *((void *)this + 8);
  uint64_t v14 = std::map<long long,unsigned long>::at(*((void **)this + 15), a3);
  uint64_t v15 = *(void *)(v13 + 88);
  if (v15) {
    unint64_t v16 = *(void *)v15 + *(unsigned int *)v14 * (unint64_t)*(unsigned int *)(*(void *)v15 + 16) + 24;
  }
  else {
    unint64_t v16 = 0;
  }
  int v17 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *))(*(void *)this + 168))(this);
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v19, v17, 2);
  int v18 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *))(*(void *)this + 168))(this);
  float __C = 0.0;
  vDSP_dotpr((const float *)(v11 + 16), 1, (const float *)(v16 + 16), 1, &__C, v18);
  *a4 = (float)((float)(__C + 1.0) * -0.5) + 1.0;
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v19);
  return 5248;
}

void sub_1A4041170(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)va);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::getLevel0FacesToClusterContaining(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)a1, a2))
  {
    uint64_t v6 = *(void *)(a1 + 64);
    unint64_t v7 = std::map<long long,unsigned long>::at(*(void **)(a1 + 120), a2);
    uint64_t v8 = std::map<unsigned long,std::list<long long>>::at(*(void **)(a1 + 96), *(void *)(**(void **)(v6 + 88)+ *(unsigned int *)v7 * (unint64_t)*(unsigned int *)(**(void **)(v6 + 88) + 16)+ 24));
    if (v8 != a3) {
      std::list<long long>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<long long,void *>,std::__list_const_iterator<long long,void *>>(a3, v8[1], (uint64_t)v8);
    }
    unint64_t v9 = &CVML_status_ok;
  }
  else
  {
    unint64_t v9 = &CVML_status_invalidParameter;
  }
  return (*v9 + 128) | 0x1400;
}

uint64_t vision::mod::GreedyClustererFaces::computeClusterLookupMapL1(uint64_t a1, uint64_t **a2)
{
  uint64_t v2 = *(void **)(a1 + 136);
  unint64_t v3 = (void *)(a1 + 144);
  if (v2 != (void *)(a1 + 144))
  {
    do
    {
      long long v5 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, v2[4], v2 + 4);
      uint64_t v6 = v5;
      uint64_t v8 = (char *)v5[6];
      unint64_t v7 = v5[7];
      if ((unint64_t)v8 >= v7)
      {
        uint64_t v10 = (char *)v5[5];
        uint64_t v11 = (v8 - v10) >> 3;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v7 - (void)v10;
        if (v13 >> 2 > v12) {
          unint64_t v12 = v13 >> 2;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v14);
          uint64_t v10 = (char *)v6[5];
          uint64_t v8 = (char *)v6[6];
        }
        else
        {
          uint64_t v15 = 0;
        }
        unint64_t v16 = (void *)(v14 + 8 * v11);
        *unint64_t v16 = v2[5];
        unint64_t v9 = v16 + 1;
        while (v8 != v10)
        {
          uint64_t v17 = *((void *)v8 - 1);
          v8 -= 8;
          *--unint64_t v16 = v17;
        }
        v6[5] = (uint64_t)v16;
        v6[6] = (uint64_t)v9;
        v6[7] = v14 + 8 * v15;
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        *(void *)uint64_t v8 = v2[5];
        unint64_t v9 = v8 + 8;
      }
      v6[6] = (uint64_t)v9;
      int v18 = (void *)v2[1];
      if (v18)
      {
        do
        {
          unint64_t v19 = v18;
          int v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          unint64_t v19 = (void *)v2[2];
          BOOL v20 = *v19 == (void)v2;
          uint64_t v2 = v19;
        }
        while (!v20);
      }
      uint64_t v2 = v19;
    }
    while (v19 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::computeClusterMapL0(uint64_t a1, uint64_t **a2)
{
  uint64_t v2 = *(void **)(a1 + 88);
  unint64_t v3 = (void *)(a1 + 96);
  if (v2 != (void *)(a1 + 96))
  {
    do
    {
      for (int i = (void *)v2[6]; i != v2 + 5; int i = (void *)i[1])
      {
        uint64_t v23 = v2[4];
        uint64_t v6 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, v23, &v23);
        unint64_t v7 = v6;
        unint64_t v9 = (char *)v6[6];
        unint64_t v8 = v6[7];
        if ((unint64_t)v9 >= v8)
        {
          uint64_t v11 = (char *)v6[5];
          uint64_t v12 = (v9 - v11) >> 3;
          unint64_t v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 61) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v14 = v8 - (void)v11;
          if (v14 >> 2 > v13) {
            unint64_t v13 = v14 >> 2;
          }
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v15 = v13;
          }
          if (v15)
          {
            unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
            uint64_t v11 = (char *)v7[5];
            unint64_t v9 = (char *)v7[6];
          }
          else
          {
            uint64_t v16 = 0;
          }
          uint64_t v17 = (void *)(v15 + 8 * v12);
          void *v17 = i[2];
          uint64_t v10 = v17 + 1;
          while (v9 != v11)
          {
            uint64_t v18 = *((void *)v9 - 1);
            v9 -= 8;
            *--uint64_t v17 = v18;
          }
          v7[5] = (uint64_t)v17;
          v7[6] = (uint64_t)v10;
          v7[7] = v15 + 8 * v16;
          if (v11) {
            operator delete(v11);
          }
        }
        else
        {
          *(void *)unint64_t v9 = i[2];
          uint64_t v10 = v9 + 8;
        }
        v7[6] = (uint64_t)v10;
      }
      unint64_t v19 = (void *)v2[1];
      if (v19)
      {
        do
        {
          BOOL v20 = v19;
          unint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          BOOL v20 = (void *)v2[2];
          BOOL v21 = *v20 == (void)v2;
          uint64_t v2 = v20;
        }
        while (!v21);
      }
      uint64_t v2 = v20;
    }
    while (v20 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::computeClusterLookupMapL0(uint64_t a1, uint64_t **a2)
{
  uint64_t v2 = *(void **)(a1 + 112);
  unint64_t v3 = (void *)(a1 + 120);
  if (v2 != (void *)(a1 + 120))
  {
    do
    {
      long long v5 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, v2[4], v2 + 4);
      uint64_t v6 = v5;
      uint64_t v7 = v2[5];
      unint64_t v9 = (char *)v5[6];
      unint64_t v8 = v5[7];
      if ((unint64_t)v9 >= v8)
      {
        uint64_t v11 = (char *)v5[5];
        uint64_t v12 = (v9 - v11) >> 3;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61) {
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v8 - (void)v11;
        if (v14 >> 2 > v13) {
          unint64_t v13 = v14 >> 2;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
          uint64_t v11 = (char *)v6[5];
          unint64_t v9 = (char *)v6[6];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = (void *)(v15 + 8 * v12);
        void *v17 = v7;
        uint64_t v10 = v17 + 1;
        while (v9 != v11)
        {
          uint64_t v18 = *((void *)v9 - 1);
          v9 -= 8;
          *--uint64_t v17 = v18;
        }
        v6[5] = (uint64_t)v17;
        v6[6] = (uint64_t)v10;
        v6[7] = v15 + 8 * v16;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(void *)unint64_t v9 = v7;
        uint64_t v10 = v9 + 8;
      }
      v6[6] = (uint64_t)v10;
      unint64_t v19 = (void *)v2[1];
      if (v19)
      {
        do
        {
          BOOL v20 = v19;
          unint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          BOOL v20 = (void *)v2[2];
          BOOL v21 = *v20 == (void)v2;
          uint64_t v2 = v20;
        }
        while (!v21);
      }
      uint64_t v2 = v20;
    }
    while (v20 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::anomalyForGroup(vision::mod::GreedyClustererFaces *a1, uint64_t **a2, uint64_t a3, _DWORD *a4)
{
  if (vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, a3))
  {
    unint64_t v9 = *a2;
    unint64_t v8 = a2[1];
    if (v8 != *a2)
    {
      uint64_t v10 = (void *)((char *)a1 + 144);
      if (*((void *)a1 + 18))
      {
        while (1)
        {
          uint64_t v11 = *v9;
          uint64_t v12 = (void *)*((void *)a1 + 18);
          while (1)
          {
            uint64_t v13 = v12[4];
            if (v11 >= v13) {
              break;
            }
LABEL_8:
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_42;
            }
          }
          if (v13 < v11) {
            break;
          }
          if (++v9 == v8)
          {
            v70[0] = 0;
            v70[1] = 0;
            uint64_t v69 = (uint64_t *)v70;
            uint64_t v14 = (void *)*((void *)a1 + 17);
            if (v14 != v10)
            {
              do
              {
                v64[0] = *((_OWORD *)v14 + 2);
                unint64_t v15 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v69, *((uint64_t *)&v64[0] + 1), (uint64_t *)v64 + 1);
                uint64_t v16 = v15;
                uint64_t v18 = (char *)v15[6];
                unint64_t v17 = v15[7];
                if ((unint64_t)v18 >= v17)
                {
                  BOOL v20 = (char *)v15[5];
                  uint64_t v21 = (v18 - v20) >> 3;
                  unint64_t v22 = v21 + 1;
                  if ((unint64_t)(v21 + 1) >> 61) {
                    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                  }
                  uint64_t v23 = v17 - (void)v20;
                  if (v23 >> 2 > v22) {
                    unint64_t v22 = v23 >> 2;
                  }
                  if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v24 = v22;
                  }
                  if (v24)
                  {
                    unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v24);
                    BOOL v20 = (char *)v16[5];
                    uint64_t v18 = (char *)v16[6];
                  }
                  else
                  {
                    uint64_t v25 = 0;
                  }
                  unint64_t v26 = (void *)(v24 + 8 * v21);
                  *unint64_t v26 = *(void *)&v64[0];
                  unint64_t v19 = v26 + 1;
                  while (v18 != v20)
                  {
                    uint64_t v27 = *((void *)v18 - 1);
                    v18 -= 8;
                    *--unint64_t v26 = v27;
                  }
                  v16[5] = (uint64_t)v26;
                  v16[6] = (uint64_t)v19;
                  v16[7] = v24 + 8 * v25;
                  if (v20) {
                    operator delete(v20);
                  }
                }
                else
                {
                  *(void *)uint64_t v18 = *(void *)&v64[0];
                  unint64_t v19 = v18 + 8;
                }
                v16[6] = (uint64_t)v19;
                uint64_t v28 = (void *)v14[1];
                if (v28)
                {
                  do
                  {
                    uint64_t v29 = v28;
                    uint64_t v28 = (void *)*v28;
                  }
                  while (v28);
                }
                else
                {
                  do
                  {
                    uint64_t v29 = (void *)v14[2];
                    BOOL v30 = *v29 == (void)v14;
                    uint64_t v14 = v29;
                  }
                  while (!v30);
                }
                uint64_t v14 = v29;
              }
              while (v29 != v10);
            }
            unint64_t v31 = operator new(8uLL);
            void *v31 = a3;
            v57[1] = v31 + 1;
            v57[2] = v31 + 1;
            v57[0] = v31;
            uint64_t v32 = malloc_type_malloc(4 * *(int *)(*((void *)a1 + 8) + 104), 0x100004052888210uLL);
            unint64_t v33 = *(int *)(*((void *)a1 + 8) + 104);
            vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)v64, (void **)v57, v32, v33, 1, 1);
            int v67 = 1;
            int v68 = 0;
            *(void *)&v64[0] = &unk_1EF752918;
            unint64_t v66 = v33 >> 2;
            operator delete(v31);
            if (!v65)
            {
              uint64_t v45 = 5243;
              goto LABEL_63;
            }
            int v67 = 2;
            vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, a3, (uint64_t)&v69, v65);
            std::vector<std::pair<float,unsigned long>>::vector((char **)&__p, a2[1] - *a2);
            uint64_t v34 = *a2;
            uint64_t v35 = a2[1];
            if (*a2 == v35)
            {
              unint64_t v37 = 0;
LABEL_47:
              unint64_t v47 = 126 - 2 * __clz((v63 - (unsigned char *)__p) >> 4);
              if (v63 == __p) {
                uint64_t v48 = 0;
              }
              else {
                uint64_t v48 = v47;
              }
              std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *,false>((uint64_t)__p, (unint64_t)v63, v48, 1);
              uint64_t v49 = a2[1];
              unint64_t v50 = __p;
              uint64_t v51 = (char *)v49 - (char *)*a2;
              if (v49 == *a2)
              {
                uint64_t v45 = 5248;
                goto LABEL_59;
              }
              uint64_t v52 = 0;
              unint64_t v53 = 0;
              unint64_t v54 = v51 >> 3;
              if (v54 <= 1) {
                unint64_t v54 = 1;
              }
              uint64_t v55 = 8;
              uint64_t v45 = 5248;
              while (1)
              {
                v53 += *(void *)((char *)__p + v55);
                if (v53 >= v37 >> 1) {
                  break;
                }
                ++v52;
                v55 += 16;
                if (v54 == v52) {
                  goto LABEL_59;
                }
              }
              *a4 = *((_DWORD *)__p + 4 * v52);
              uint64_t v45 = 5248;
            }
            else
            {
              int v36 = 0;
              unint64_t v37 = 0;
              while (1)
              {
                uint64_t v38 = *v34;
                BOOL v39 = operator new(8uLL);
                void *v39 = v38;
                v56[1] = v39 + 1;
                v56[2] = v39 + 1;
                v56[0] = v39;
                int v40 = malloc_type_malloc(4 * *(int *)(*((void *)a1 + 8) + 104), 0x100004052888210uLL);
                unint64_t v41 = *(int *)(*((void *)a1 + 8) + 104);
                vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)v57, v56, v40, v41, 1, 1);
                int v60 = 1;
                int64_t v61 = 0;
                v57[0] = &unk_1EF752918;
                unint64_t v59 = v41 >> 2;
                operator delete(v39);
                int v60 = 2;
                int v42 = v58;
                if (v58)
                {
                  vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, v38, (uint64_t)&v69, v58);
                  float v43 = vision::mod::ImageDescriptorBufferFloat32::computeDistanceFrom((vision::mod::ImageDescriptorBufferFloat32 *)v57, (const vision::mod::ImageDescriptorBufferAbstract *)v64);
                  *((float *)__p + 4 * v36) = v43;
                  uint64_t v44 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *, uint64_t))(*(void *)a1 + 200))(a1, v38);
                  *((void *)__p + 2 * v36 + 1) = v44;
                  v37 += v44;
                  ++v36;
                }
                v57[0] = &unk_1EF752918;
                free(v61);
                vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(v57);
                if (!v42) {
                  break;
                }
                if (++v34 == v35) {
                  goto LABEL_47;
                }
              }
              unint64_t v50 = __p;
              uint64_t v45 = 5243;
LABEL_59:
              if (!v50)
              {
LABEL_63:
                *(void *)&v64[0] = &unk_1EF752918;
                free(v68);
                vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract((void **)v64);
                std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v70[0]);
                return v45;
              }
            }
            BOOL v63 = v50;
            operator delete(v50);
            goto LABEL_63;
          }
        }
        ++v12;
        goto LABEL_8;
      }
LABEL_42:
      syslog(5, "FaceId=%lld not present in clustering", a3);
    }
  }
  return 5244;
}

void sub_1A4041B3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,void *a33)
{
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32(&a33);
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*(void **)(v33 - 104));
  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = (_DWORD *)(a2 - 16);
    unint64_t v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v11;
          uint64_t v12 = a2 - v11;
          unint64_t v13 = (uint64_t)(a2 - v11) >> 4;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                float v43 = *(float *)v11;
                if (*(float *)v10 < *(float *)v11)
                {
                  *(_DWORD *)unint64_t v11 = *v10;
                  *(float *)(a2 - 16) = v43;
                  uint64_t v44 = *(void *)(v11 + 8);
                  *(void *)(v11 + 8) = *(void *)(a2 - 8);
                  *(void *)(a2 - 8) = v44;
                }
                break;
              case 3uLL:
                uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v11, v11 + 16, a2 - 16);
                break;
              case 4uLL:
                uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v11, v11 + 16, v11 + 32, a2 - 16);
                break;
              case 5uLL:
                uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v11, v11 + 16, v11 + 32, v11 + 48);
                float v45 = *(float *)(v11 + 48);
                if (*(float *)v10 < v45)
                {
                  *(_DWORD *)(v11 + 48) = *v10;
                  *(float *)(a2 - 16) = v45;
                  uint64_t v46 = *(void *)(v11 + 56);
                  *(void *)(v11 + 56) = *(void *)(a2 - 8);
                  *(void *)(a2 - 8) = v46;
                  float v47 = *(float *)(v11 + 48);
                  float v48 = *(float *)(v11 + 32);
                  if (v47 < v48)
                  {
                    *(float *)(v11 + 32) = v47;
                    *(float *)(v11 + 48) = v48;
                    uint64_t v49 = *(void *)(v11 + 40);
                    uint64_t v50 = *(void *)(v11 + 56);
                    *(void *)(v11 + 40) = v50;
                    *(void *)(v11 + 56) = v49;
                    float v51 = *(float *)(v11 + 16);
                    if (v47 < v51)
                    {
                      *(float *)(v11 + 16) = v47;
                      *(float *)(v11 + 32) = v51;
                      uint64_t v52 = *(void *)(v11 + 24);
                      *(void *)(v11 + 24) = v50;
                      *(void *)(v11 + 40) = v52;
                      float v53 = *(float *)v11;
                      if (v47 < *(float *)v11)
                      {
                        *(float *)unint64_t v11 = v47;
                        *(float *)(v11 + 16) = v53;
                        uint64_t v54 = *(void *)(v11 + 8);
                        *(void *)(v11 + 8) = v50;
                        *(void *)(v11 + 24) = v54;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 383)
          {
            unint64_t v55 = v11 + 16;
            BOOL v57 = v11 == a2 || v55 == a2;
            if (a4)
            {
              if (!v57)
              {
                uint64_t v58 = 0;
                unint64_t v59 = v11;
                do
                {
                  unint64_t v60 = v55;
                  float v61 = *(float *)(v59 + 16);
                  float v62 = *(float *)v59;
                  if (v61 < *(float *)v59)
                  {
                    uint64_t v63 = *(void *)(v59 + 24);
                    uint64_t v64 = v58;
                    while (1)
                    {
                      uint64_t v65 = v11 + v64;
                      *(float *)(v65 + 16) = v62;
                      *(void *)(v65 + 24) = *(void *)(v11 + v64 + 8);
                      if (!v64) {
                        break;
                      }
                      float v62 = *(float *)(v65 - 16);
                      v64 -= 16;
                      if (v61 >= v62)
                      {
                        uint64_t v66 = v11 + v64 + 16;
                        goto LABEL_85;
                      }
                    }
                    uint64_t v66 = v11;
LABEL_85:
                    *(float *)uint64_t v66 = v61;
                    *(void *)(v66 + 8) = v63;
                  }
                  unint64_t v55 = v60 + 16;
                  v58 += 16;
                  unint64_t v59 = v60;
                }
                while (v60 + 16 != a2);
              }
            }
            else if (!v57)
            {
              int v97 = (float *)(v11 + 24);
              do
              {
                unint64_t v98 = v55;
                float v99 = *(float *)(v9 + 16);
                float v100 = *(float *)v9;
                if (v99 < *(float *)v9)
                {
                  uint64_t v101 = *(void *)(v9 + 24);
                  unint64_t v102 = v97;
                  do
                  {
                    char v103 = v102;
                    *(v102 - 2) = v100;
                    uint64_t v104 = *((void *)v102 - 2);
                    v102 -= 4;
                    *(void *)char v103 = v104;
                    float v100 = *(v103 - 10);
                  }
                  while (v99 < v100);
                  *(v102 - 2) = v99;
                  *(void *)unint64_t v102 = v101;
                }
                unint64_t v55 = v98 + 16;
                v97 += 4;
                unint64_t v9 = v98;
              }
              while (v98 + 16 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v67 = (v13 - 2) >> 1;
              int64_t v68 = v67;
              do
              {
                int64_t v69 = v68;
                if (v67 >= v68)
                {
                  uint64_t v70 = (2 * v68) | 1;
                  unint64_t v71 = v11 + 16 * v70;
                  if (2 * v69 + 2 < (uint64_t)v13 && *(float *)v71 < *(float *)(v71 + 16))
                  {
                    v71 += 16;
                    uint64_t v70 = 2 * v69 + 2;
                  }
                  unint64_t v72 = v11 + 16 * v69;
                  float v73 = *(float *)v72;
                  float v74 = *(float *)v71;
                  float v75 = *(float *)v72;
                  if (*(float *)v71 >= *(float *)v72)
                  {
                    uint64_t v76 = *(void *)(v72 + 8);
                    do
                    {
                      unint64_t v77 = v72;
                      unint64_t v72 = v71;
                      *(float *)unint64_t v77 = v74;
                      *(void *)(v77 + 8) = *(void *)(v71 + 8);
                      if (v67 < v70) {
                        break;
                      }
                      uint64_t v78 = 2 * v70;
                      uint64_t v70 = (2 * v70) | 1;
                      unint64_t v71 = v11 + 16 * v70;
                      uint64_t v79 = v78 + 2;
                      if (v79 < (uint64_t)v13)
                      {
                        uint64_t result = v71 + 16;
                        if (*(float *)v71 < *(float *)(v71 + 16))
                        {
                          v71 += 16;
                          uint64_t v70 = v79;
                        }
                      }
                      float v74 = *(float *)v71;
                    }
                    while (*(float *)v71 >= v75);
                    *(float *)unint64_t v72 = v73;
                    *(void *)(v72 + 8) = v76;
                  }
                }
                int64_t v68 = v69 - 1;
              }
              while (v69);
              uint64_t v80 = (unint64_t)v12 >> 4;
              do
              {
                uint64_t v81 = 0;
                float v82 = *(float *)v11;
                uint64_t v83 = *(void *)(v11 + 8);
                unint64_t v84 = v11;
                do
                {
                  unint64_t v85 = v84;
                  v84 += 16 * v81 + 16;
                  uint64_t v86 = 2 * v81;
                  uint64_t v81 = (2 * v81) | 1;
                  uint64_t v87 = v86 + 2;
                  if (v87 < v80 && *(float *)v84 < *(float *)(v84 + 16))
                  {
                    v84 += 16;
                    uint64_t v81 = v87;
                  }
                  *(_DWORD *)unint64_t v85 = *(_DWORD *)v84;
                  *(void *)(v85 + 8) = *(void *)(v84 + 8);
                }
                while (v81 <= (uint64_t)((unint64_t)(v80 - 2) >> 1));
                if (v84 == a2 - 16)
                {
                  *(float *)unint64_t v84 = v82;
                  *(void *)(v84 + 8) = v83;
                }
                else
                {
                  *(_DWORD *)unint64_t v84 = *(_DWORD *)(a2 - 16);
                  *(void *)(v84 + 8) = *(void *)(a2 - 8);
                  *(float *)(a2 - 16) = v82;
                  *(void *)(a2 - 8) = v83;
                  uint64_t v88 = v84 - v11 + 16;
                  if (v88 >= 17)
                  {
                    unint64_t v89 = (((unint64_t)v88 >> 4) - 2) >> 1;
                    unint64_t v90 = v11 + 16 * v89;
                    float v91 = *(float *)v84;
                    float v92 = *(float *)v90;
                    float v93 = *(float *)v84;
                    if (*(float *)v90 < *(float *)v84)
                    {
                      uint64_t v94 = *(void *)(v84 + 8);
                      do
                      {
                        unint64_t v95 = v84;
                        unint64_t v84 = v90;
                        *(float *)unint64_t v95 = v92;
                        *(void *)(v95 + 8) = *(void *)(v90 + 8);
                        if (!v89) {
                          break;
                        }
                        unint64_t v89 = (v89 - 1) >> 1;
                        unint64_t v90 = v11 + 16 * v89;
                        float v92 = *(float *)v90;
                      }
                      while (*(float *)v90 < v93);
                      *(float *)unint64_t v84 = v91;
                      *(void *)(v84 + 8) = v94;
                    }
                  }
                }
                a2 -= 16;
              }
              while (v80-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          uint64_t v15 = v11 + 16 * (v13 >> 1);
          if ((unint64_t)v12 >= 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9, v9 + 16 * (v13 >> 1), a2 - 16);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9 + 16, v15 - 16, a2 - 32);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9 + 32, v9 + 16 + 16 * v14, a2 - 48);
            uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v15 - 16, v15, v9 + 16 + 16 * v14);
            float v16 = *(float *)v9;
            *(_DWORD *)unint64_t v9 = *(_DWORD *)v15;
            *(float *)uint64_t v15 = v16;
            uint64_t v17 = *(void *)(v9 + 8);
            *(void *)(v9 + 8) = *(void *)(v15 + 8);
            *(void *)(v15 + 8) = v17;
          }
          else
          {
            uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9 + 16 * (v13 >> 1), v9, a2 - 16);
          }
          --a3;
          if (a4) {
            break;
          }
          float v18 = *(float *)v9;
          uint64_t v19 = *(void *)(v9 + 8);
          float v20 = *(float *)v9;
          if (*(float *)(v9 - 16) < *(float *)v9) {
            goto LABEL_13;
          }
          if (v20 >= *(float *)v10)
          {
            unint64_t v35 = v9 + 16;
            do
            {
              unint64_t v11 = v35;
              if (v35 >= a2) {
                break;
              }
              v35 += 16;
            }
            while (v20 >= *(float *)v11);
          }
          else
          {
            unint64_t v11 = v9;
            do
            {
              float v34 = *(float *)(v11 + 16);
              v11 += 16;
            }
            while (v20 >= v34);
          }
          unint64_t v36 = a2;
          if (v11 < a2)
          {
            unint64_t v36 = a2;
            do
            {
              float v37 = *(float *)(v36 - 16);
              v36 -= 16;
            }
            while (v20 < v37);
          }
          if (v11 < v36)
          {
            float v38 = *(float *)v11;
            float v39 = *(float *)v36;
            do
            {
              *(float *)unint64_t v11 = v39;
              *(float *)unint64_t v36 = v38;
              uint64_t v40 = *(void *)(v11 + 8);
              *(void *)(v11 + 8) = *(void *)(v36 + 8);
              *(void *)(v36 + 8) = v40;
              do
              {
                float v41 = *(float *)(v11 + 16);
                v11 += 16;
                float v38 = v41;
              }
              while (v20 >= v41);
              do
              {
                float v42 = *(float *)(v36 - 16);
                v36 -= 16;
                float v39 = v42;
              }
              while (v20 < v42);
            }
            while (v11 < v36);
          }
          BOOL v4 = v11 - 16 >= v9;
          BOOL v5 = v11 - 16 == v9;
          if (v11 - 16 != v9)
          {
            *(_DWORD *)unint64_t v9 = *(_DWORD *)(v11 - 16);
            *(void *)(v9 + 8) = *(void *)(v11 - 8);
          }
          a4 = 0;
          *(float *)(v11 - 16) = v18;
          *(void *)(v11 - 8) = v19;
        }
        float v18 = *(float *)v9;
        uint64_t v19 = *(void *)(v9 + 8);
        float v20 = *(float *)v9;
LABEL_13:
        unint64_t v21 = v9;
        do
        {
          unint64_t v22 = v21;
          float v23 = *(float *)(v21 + 16);
          v21 += 16;
          float v24 = v23;
        }
        while (v20 > v23);
        uint64_t v25 = (float *)a2;
        if (v22 == v9)
        {
          uint64_t v25 = (float *)a2;
          do
          {
            if (v21 >= (unint64_t)v25) {
              break;
            }
            float v27 = *(v25 - 4);
            v25 -= 4;
          }
          while (v20 <= v27);
        }
        else
        {
          do
          {
            float v26 = *(v25 - 4);
            v25 -= 4;
          }
          while (v20 <= v26);
        }
        if (v21 >= (unint64_t)v25)
        {
          unint64_t v11 = v21;
        }
        else
        {
          float v28 = *v25;
          unint64_t v11 = v21;
          uint64_t v29 = v25;
          do
          {
            *(float *)unint64_t v11 = v28;
            *uint64_t v29 = v24;
            uint64_t v30 = *(void *)(v11 + 8);
            *(void *)(v11 + 8) = *((void *)v29 + 1);
            *((void *)v29 + 1) = v30;
            do
            {
              float v31 = *(float *)(v11 + 16);
              v11 += 16;
              float v24 = v31;
            }
            while (v20 > v31);
            do
            {
              float v32 = *(v29 - 4);
              v29 -= 4;
              float v28 = v32;
            }
            while (v20 <= v32);
          }
          while (v11 < (unint64_t)v29);
        }
        if (v11 - 16 != v9)
        {
          *(_DWORD *)unint64_t v9 = *(_DWORD *)(v11 - 16);
          *(void *)(v9 + 8) = *(void *)(v11 - 8);
        }
        *(float *)(v11 - 16) = v18;
        *(void *)(v11 - 8) = v19;
        if (v21 >= (unint64_t)v25) {
          break;
        }
LABEL_34:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *,false>(v9, v11 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v33 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9, v11 - 16);
      uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v11, a2);
      if (result) {
        break;
      }
      if (!v33) {
        goto LABEL_34;
      }
    }
    a2 = v11 - 16;
    if (!v33) {
      continue;
    }
    return result;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      float v6 = *(float *)a1;
      if (*(float *)(a2 - 16) < *(float *)a1)
      {
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 16);
        *(float *)(a2 - 16) = v6;
        uint64_t v7 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a2 - 16);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a1 + 32, a1 + 48);
      float v19 = *(float *)(a1 + 48);
      if (*(float *)(a2 - 16) < v19)
      {
        *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 - 16);
        *(float *)(a2 - 16) = v19;
        uint64_t v20 = *(void *)(a1 + 56);
        *(void *)(a1 + 56) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v20;
        float v21 = *(float *)(a1 + 48);
        float v22 = *(float *)(a1 + 32);
        if (v21 < v22)
        {
          *(float *)(a1 + 32) = v21;
          *(float *)(a1 + 48) = v22;
          uint64_t v23 = *(void *)(a1 + 40);
          uint64_t v24 = *(void *)(a1 + 56);
          *(void *)(a1 + 40) = v24;
          *(void *)(a1 + 56) = v23;
          float v25 = *(float *)(a1 + 16);
          if (v21 < v25)
          {
            *(float *)(a1 + 16) = v21;
            *(float *)(a1 + 32) = v25;
            uint64_t v26 = *(void *)(a1 + 24);
            *(void *)(a1 + 24) = v24;
            *(void *)(a1 + 40) = v26;
            float v27 = *(float *)a1;
            if (v21 < *(float *)a1)
            {
              *(float *)a1 = v21;
              *(float *)(a1 + 16) = v27;
              uint64_t v28 = *(void *)(a1 + 8);
              *(void *)(a1 + 8) = v24;
              *(void *)(a1 + 24) = v28;
            }
          }
        }
      }
      return 1;
    default:
      unint64_t v8 = (float *)(a1 + 32);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a1 + 32);
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    float v12 = *(float *)v9;
    float v13 = *(float *)v9;
    float v14 = *v8;
    if (*(float *)v9 < *v8)
    {
      uint64_t v15 = *(void *)(v9 + 8);
      uint64_t v16 = v10;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        *(float *)(v17 + 48) = v14;
        *(void *)(v17 + 56) = *(void *)(a1 + v16 + 40);
        if (v16 == -32) {
          break;
        }
        float v14 = *(float *)(v17 + 16);
        v16 -= 16;
        if (v13 >= v14)
        {
          uint64_t v18 = a1 + v16 + 48;
          goto LABEL_13;
        }
      }
      uint64_t v18 = a1;
LABEL_13:
      *(float *)uint64_t v18 = v12;
      *(void *)(v18 + 8) = v15;
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    unint64_t v8 = (float *)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2) {
      return 1;
    }
  }
}

void vision::mod::GreedyClustererFaces::serialize(vision::mod::GreedyClustererFaces *this@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, void *a8@<X8>)
{
  VNValidatedLog(1, @"  GreedyClustererFaces::serialize - enter", a2, a3, a4, a5, a6, a7, v54);
  uint64_t v10 = *((void *)this + 8);
  if (*(void *)(v10 + 72) || *(void *)(v10 + 88))
  {
    vision::mod::GreedyClusterer::private_t::clusters_t::newMapFilePath(&__s, v10);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_s = &__s;
    }
    else {
      p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    }
    VNValidatedLog(1, @"  GreedyClustererFaces::serialize - cachefile: %s", v11, v12, v13, v14, v15, v16, (uint64_t)p_s);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v18 = &__s;
    }
    else {
      uint64_t v18 = (std::string *)__s.__r_.__value_.__r.__words[0];
    }
    int v25 = open((const char *)v18, 1537, 438);
    if (v25 == -1)
    {
      VNValidatedLog(4, @"  GreedyClustererFaces::serialize - error creating new map file for serialization", v19, v20, v21, v22, v23, v24, v55);
      *a8 = 0;
      a8[1] = 0;
    }
    else
    {
      vision::mod::GreedyClusterer::serializeStatus((vision::mod::GreedyClustererFaces *)((char *)this + 8), v25, v19, v20, v21, v22, v23, v24);
      __buf.__r_.__value_.__r.__words[0] = *((void *)this + 16);
      write(v25, &__buf, 8uLL);
      uint64_t v26 = (vision::mod::GreedyClustererFaces *)*((void *)this + 14);
      if (v26 != (vision::mod::GreedyClustererFaces *)((char *)this + 120))
      {
        do
        {
          write(v25, (char *)v26 + 32, 8uLL);
          write(v25, (char *)v26 + 40, 8uLL);
          float v27 = (vision::mod::GreedyClustererFaces *)*((void *)v26 + 1);
          if (v27)
          {
            do
            {
              uint64_t v28 = v27;
              float v27 = *(vision::mod::GreedyClustererFaces **)v27;
            }
            while (v27);
          }
          else
          {
            do
            {
              uint64_t v28 = (vision::mod::GreedyClustererFaces *)*((void *)v26 + 2);
              BOOL v29 = *(void *)v28 == (void)v26;
              uint64_t v26 = v28;
            }
            while (!v29);
          }
          uint64_t v26 = v28;
        }
        while (v28 != (vision::mod::GreedyClustererFaces *)((char *)this + 120));
      }
      __buf.__r_.__value_.__r.__words[0] = *((void *)this + 19);
      write(v25, &__buf, 8uLL);
      uint64_t v30 = (vision::mod::GreedyClustererFaces *)*((void *)this + 17);
      if (v30 != (vision::mod::GreedyClustererFaces *)((char *)this + 144))
      {
        do
        {
          write(v25, (char *)v30 + 32, 8uLL);
          write(v25, (char *)v30 + 40, 8uLL);
          float v31 = (vision::mod::GreedyClustererFaces *)*((void *)v30 + 1);
          if (v31)
          {
            do
            {
              float v32 = v31;
              float v31 = *(vision::mod::GreedyClustererFaces **)v31;
            }
            while (v31);
          }
          else
          {
            do
            {
              float v32 = (vision::mod::GreedyClustererFaces *)*((void *)v30 + 2);
              BOOL v29 = *(void *)v32 == (void)v30;
              uint64_t v30 = v32;
            }
            while (!v29);
          }
          uint64_t v30 = v32;
        }
        while (v32 != (vision::mod::GreedyClustererFaces *)((char *)this + 144));
      }
      close(v25);
      std::string::size_type size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
      if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = __s.__r_.__value_.__l.__size_;
      }
      std::allocate_shared[abi:ne180100]<std::vector<unsigned char>,std::allocator<std::vector<unsigned char>>,unsigned long,void>(&v58, size + 53);
      uint64_t v34 = *(void *)v58;
      unint64_t v35 = *(void **)v58;
      *unint64_t v35 = 0x2714C1457E25;
      unint64_t v36 = (unsigned __int8 *)(v35 + 3);
      if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float v37 = &__s;
      }
      else {
        float v37 = (std::string *)__s.__r_.__value_.__r.__words[0];
      }
      if (calculateChecksumMD5ForFile((const char *)v37, v36))
      {
        createFullPath(&__buf, *((void *)this + 8), *((void *)this + 8) + 24);
        if ((__buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_buf = &__buf;
        }
        else {
          p_buf = (std::string *)__buf.__r_.__value_.__r.__words[0];
        }
        if ((calculateChecksumMD5ForFile((const char *)p_buf, (unsigned __int8 *)(v34 + 8)) & 1) == 0) {
          VNValidatedLog(4, @"  GreedyClustererFaces::serialize - error calculating checksum for cluster data file", v45, v46, v47, v48, v49, v50, v55);
        }
        getRelativePath(&__str, *((char **)this + 8), &__s);
        int v51 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          p_str = &__str;
        }
        else
        {
          int v51 = __str.__r_.__value_.__r.__words[1];
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)(v34 + 40) = v51;
        memcpy((void *)(v34 + 44), p_str, (v51 + 1));
        std::string::operator=((std::string *)((char *)this + 184), &__str);
        *(_OWORD *)a8 = v58;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__buf.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        VNValidatedLog(4, @"  GreedyClustererFaces::serialize - error calculating checksum for cluster data file", v38, v39, v40, v41, v42, v43, v55);
        *a8 = 0;
        a8[1] = 0;
        if (*((void *)&v58 + 1)) {
          std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v58 + 1));
        }
      }
    }
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    float v53 = operator new(0x30uLL);
    v53[1] = 0;
    v53[2] = 0;
    *float v53 = &unk_1EF753C78;
    v53[4] = 0;
    v53[5] = 0;
    a8[1] = v53;
    _OWORD v53[3] = 0;
    *a8 = v53 + 3;
  }
}

void sub_1A4042958(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a24);
  }
  if (*(char *)(v24 - 49) < 0) {
    operator delete(*(void **)(v24 - 72));
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(uint64_t a1, uint64_t a2, void **a3, uint64_t **a4)
{
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v68, *(_DWORD *)(*(void *)(a1 + 64) + 104), *(_DWORD *)(a1 + 28));
  unint64_t v7 = *(int *)(*(void *)(a1 + 64) + 104);
  LODWORD(v62) = 0;
  std::vector<float>::vector(__A, v7, &v62);
  unint64_t v8 = *(int *)(*(void *)(a1 + 64) + 104);
  LODWORD(v62) = 0;
  std::vector<float>::vector(__B, v8, &v62);
  unint64_t v9 = *(void *)(a1 + 152);
  if (v9)
  {
    if (v9 >> 60) {
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v9);
    unint64_t v60 = &v10[16 * v11];
    uint64_t v12 = v10;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v60 = 0;
  }
  uint64_t v13 = *(void *)(a1 + 64);
  if (*(unsigned char *)(v13 + 120))
  {
    *(unsigned char *)(v13 + 120) = 0;
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 5219;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace((void *)a1, a2, (uint64_t)a4, __A[0]);
  unint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 200))(a1, a2);
  uint64_t v59 = a2;
  float v15 = 0.0;
  if (v14 <= 0xA) {
    float v15 = (float)((float)((float)((float)v14 + -1.0) / -10.0) + 1.0) * 0.05;
  }
  uint64_t v16 = *a4;
  if (*a4 != (uint64_t *)(a4 + 1))
  {
    double v17 = *(float *)(*(void *)(a1 + 32) + 8) * 1.1;
    unint64_t v18 = (unint64_t)v12;
    while (1)
    {
      uint64_t v19 = (const void *)v16[5];
      uint64_t v62 = v16[4];
      uint64_t v64 = 0;
      uint64_t v65 = 0;
      uint64_t v63 = 0;
      std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(&v63, v19, v16[6], (v16[6] - (uint64_t)v19) >> 3);
      uint64_t v20 = v63;
      if (v64 == v63)
      {
        uint64_t v20 = v64;
      }
      else
      {
        uint64_t v21 = *(void *)(a1 + 64);
        if (*(unsigned char *)(v21 + 120))
        {
          *(unsigned char *)(v21 + 120) = 0;
          BOOL v57 = __cxa_allocate_exception(8uLL);
          void *v57 = 5219;
          __cxa_throw(v57, MEMORY[0x1E4FBA3E0], 0);
        }
        uint64_t v22 = v62;
        vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace((void *)a1, v62, (uint64_t)a4, __B[0]);
        vDSP_Length v23 = *(int *)(*(void *)(a1 + 64) + 104);
        __C[0] = 0.0;
        vDSP_dotpr(__A[0], 1, __B[0], 1, __C, v23);
        float v24 = (float)((float)(__C[0] + 1.0) * -0.5) + 1.0;
        if (v17 > (float)(v15 + v24))
        {
          if (v18 >= (unint64_t)v60)
          {
            uint64_t v28 = (uint64_t)(v18 - (void)v12) >> 4;
            unint64_t v29 = v28 + 1;
            if ((unint64_t)(v28 + 1) >> 60) {
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            }
            if ((v60 - v12) >> 3 > v29) {
              unint64_t v29 = (v60 - v12) >> 3;
            }
            if ((unint64_t)(v60 - v12) >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v30 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v30 = v29;
            }
            if (v30) {
              unint64_t v30 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v30);
            }
            else {
              uint64_t v31 = 0;
            }
            unint64_t v32 = v30 + 16 * v28;
            *(void *)unint64_t v32 = v22;
            *(float *)(v32 + 8) = v24;
            if ((unsigned char *)v18 == v12)
            {
              uint64_t v34 = (unsigned char *)(v30 + 16 * v28);
            }
            else
            {
              unint64_t v33 = v30 + 16 * v28;
              do
              {
                uint64_t v34 = (unsigned char *)(v33 - 16);
                *(_OWORD *)(v33 - 16) = *(_OWORD *)(v18 - 16);
                v18 -= 16;
                v33 -= 16;
              }
              while ((unsigned char *)v18 != v12);
            }
            unint64_t v60 = (char *)(v30 + 16 * v31);
            unint64_t v18 = v32 + 16;
            if (v12) {
              operator delete(v12);
            }
            uint64_t v12 = v34;
          }
          else
          {
            *(void *)unint64_t v18 = v22;
            *(float *)(v18 + 8) = v24;
            v18 += 16;
          }
          uint64_t v20 = v63;
          if (!v63) {
            goto LABEL_18;
          }
LABEL_17:
          uint64_t v64 = v20;
          operator delete(v20);
          goto LABEL_18;
        }
      }
      if (v20) {
        goto LABEL_17;
      }
LABEL_18:
      int v25 = (uint64_t *)v16[1];
      if (v25)
      {
        do
        {
          uint64_t v26 = (uint64_t **)v25;
          int v25 = (uint64_t *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          uint64_t v26 = (uint64_t **)v16[2];
          BOOL v27 = *v26 == v16;
          uint64_t v16 = (uint64_t *)v26;
        }
        while (!v27);
      }
      uint64_t v16 = (uint64_t *)v26;
      if (v26 == a4 + 1) {
        goto LABEL_45;
      }
    }
  }
  unint64_t v18 = (unint64_t)v12;
LABEL_45:
  unint64_t v35 = 126 - 2 * __clz((uint64_t)(v18 - (void)v12) >> 4);
  if ((unsigned char *)v18 == v12) {
    uint64_t v36 = 0;
  }
  else {
    uint64_t v36 = v35;
  }
  std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *,false>((float *)v12, v18, v36, 1);
  uint64_t v37 = v59;
  if ((unsigned char *)v18 != v12)
  {
    uint64_t v38 = (uint64_t *)v12;
    do
    {
      uint64_t v62 = *v38;
      uint64_t v39 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a4, v62, &v62);
      uint64_t v40 = *std::map<long long,unsigned long>::at(*(void **)(a1 + 144), *v38);
      if (v40 != *std::map<long long,unsigned long>::at(*(void **)(a1 + 144), v37))
      {
        float v41 = 1.0 - *((float *)v38 + 2);
        uint64_t v42 = *(void *)v39[5];
        uint64_t v43 = LODWORD(v41);
        uint64_t v45 = a3[1];
        unint64_t v44 = (unint64_t)a3[2];
        if ((unint64_t)v45 >= v44)
        {
          uint64_t v47 = ((char *)v45 - (unsigned char *)*a3) >> 4;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 60) {
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v49 = v44 - (void)*a3;
          if (v49 >> 3 > v48) {
            unint64_t v48 = v49 >> 3;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v50 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50) {
            unint64_t v50 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v50);
          }
          else {
            uint64_t v51 = 0;
          }
          uint64_t v52 = (void *)(v50 + 16 * v47);
          void *v52 = v42;
          v52[1] = v43;
          uint64_t v54 = (char *)*a3;
          float v53 = (char *)a3[1];
          uint64_t v55 = v52;
          if (v53 == *a3)
          {
            uint64_t v37 = v59;
          }
          else
          {
            uint64_t v37 = v59;
            do
            {
              *((_OWORD *)v55 - 1) = *((_OWORD *)v53 - 1);
              v55 -= 2;
              v53 -= 16;
            }
            while (v53 != v54);
            float v53 = (char *)*a3;
          }
          uint64_t v46 = v52 + 2;
          *a3 = v55;
          a3[1] = v52 + 2;
          a3[2] = (void *)(v50 + 16 * v51);
          if (v53) {
            operator delete(v53);
          }
        }
        else
        {
          *uint64_t v45 = v42;
          v45[1] = LODWORD(v41);
          uint64_t v46 = v45 + 2;
          uint64_t v37 = v59;
        }
        a3[1] = v46;
      }
      v38 += 2;
    }
    while (v38 != (uint64_t *)v18);
  }
  if (v12) {
    operator delete(v12);
  }
  if (__B[0])
  {
    __B[1] = __B[0];
    operator delete(__B[0]);
  }
  if (__A[0])
  {
    __A[1] = __A[0];
    operator delete(__A[0]);
  }
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v68);
  return 5248;
}

void sub_1A4042F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,char a23)
{
  if (v23) {
    operator delete(v23);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a23);
  _Unwind_Resume(a1);
}

float *std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *,false>(float *result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = (unint64_t)v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = (float *)v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = (uint64_t)(a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                float v44 = *(float *)(a2 - 8);
                float v45 = *(float *)(v10 + 8);
                if (v44 < v45)
                {
                  uint64_t v46 = *(void *)v10;
                  *(void *)unint64_t v10 = *(void *)(a2 - 16);
                  *(void *)(a2 - 16) = v46;
                  *(float *)(v10 + 8) = v44;
                  *(float *)(a2 - 8) = v45;
                }
                break;
              case 3uLL:
                BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)v10, (float *)(v10 + 16), (float *)(a2 - 16));
                break;
              case 4uLL:
                BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)v10, (float *)(v10 + 16), (float *)(v10 + 32), a2 - 16);
                break;
              case 5uLL:
                BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)v10, (float *)(v10 + 16), (float *)(v10 + 32), v10 + 48);
                float v47 = *(float *)(a2 - 8);
                float v48 = *(float *)(v10 + 56);
                if (v47 < v48)
                {
                  uint64_t v49 = *(void *)(v10 + 48);
                  *(void *)(v10 + 48) = *(void *)(a2 - 16);
                  *(void *)(a2 - 16) = v49;
                  *(float *)(v10 + 56) = v47;
                  *(float *)(a2 - 8) = v48;
                  float v50 = *(float *)(v10 + 56);
                  float v51 = *(float *)(v10 + 40);
                  if (v50 < v51)
                  {
                    uint64_t v52 = *(void *)(v10 + 32);
                    uint64_t v53 = *(void *)(v10 + 48);
                    *(void *)(v10 + 32) = v53;
                    *(void *)(v10 + 48) = v52;
                    *(float *)(v10 + 40) = v50;
                    *(float *)(v10 + 56) = v51;
                    float v54 = *(float *)(v10 + 24);
                    if (v50 < v54)
                    {
                      uint64_t v55 = *(void *)(v10 + 16);
                      *(void *)(v10 + 16) = v53;
                      *(void *)(v10 + 32) = v55;
                      *(float *)(v10 + 24) = v50;
                      *(float *)(v10 + 40) = v54;
                      float v56 = *(float *)(v10 + 8);
                      if (v50 < v56)
                      {
                        uint64_t v57 = *(void *)v10;
                        *(void *)unint64_t v10 = v53;
                        *(void *)(v10 + 16) = v57;
                        *(float *)(v10 + 8) = v50;
                        *(float *)(v10 + 24) = v56;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 383)
          {
            unint64_t v58 = v10 + 16;
            BOOL v60 = v10 == a2 || v58 == a2;
            if (a4)
            {
              if (!v60)
              {
                uint64_t v61 = 0;
                unint64_t v62 = v10;
                do
                {
                  unint64_t v63 = v58;
                  float v64 = *(float *)(v62 + 24);
                  if (v64 < *(float *)(v62 + 8))
                  {
                    uint64_t v65 = *(void *)(v62 + 16);
                    uint64_t v66 = v61;
                    while (1)
                    {
                      uint64_t v67 = v10 + v66;
                      *(void *)(v67 + 16) = *(void *)(v10 + v66);
                      *(_DWORD *)(v67 + 24) = *(_DWORD *)(v10 + v66 + 8);
                      if (!v66) {
                        break;
                      }
                      v66 -= 16;
                      if (v64 >= *(float *)(v67 - 8))
                      {
                        uint64_t v68 = v10 + v66 + 16;
                        goto LABEL_84;
                      }
                    }
                    uint64_t v68 = v10;
LABEL_84:
                    *(void *)uint64_t v68 = v65;
                    *(float *)(v68 + 8) = v64;
                  }
                  unint64_t v58 = v63 + 16;
                  v61 += 16;
                  unint64_t v62 = v63;
                }
                while (v63 + 16 != a2);
              }
            }
            else if (!v60)
            {
              unint64_t v95 = v10 + 8;
              do
              {
                int v96 = (float *)v58;
                float v97 = v9[6];
                if (v97 < v9[2])
                {
                  uint64_t v98 = *((void *)v9 + 2);
                  unint64_t v99 = v95;
                  do
                  {
                    *(void *)(v99 + 8) = *(void *)(v99 - 8);
                    *(_DWORD *)(v99 + 16) = *(_DWORD *)v99;
                    float v100 = *(float *)(v99 - 16);
                    v99 -= 16;
                  }
                  while (v97 < v100);
                  *(void *)(v99 + 8) = v98;
                  *(float *)(v99 + 16) = v97;
                }
                unint64_t v58 = (unint64_t)(v96 + 4);
                v95 += 16;
                unint64_t v9 = v96;
              }
              while (v96 + 4 != (float *)a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v69 = (v12 - 2) >> 1;
              int64_t v70 = v69;
              do
              {
                int64_t v71 = v70;
                if (v69 >= v70)
                {
                  uint64_t v72 = (2 * v70) | 1;
                  unint64_t v73 = v10 + 16 * v72;
                  if (2 * v71 + 2 < (uint64_t)v12 && *(float *)(v73 + 8) < *(float *)(v73 + 24))
                  {
                    v73 += 16;
                    uint64_t v72 = 2 * v71 + 2;
                  }
                  unint64_t v74 = v10 + 16 * v71;
                  float v75 = *(float *)(v74 + 8);
                  if (*(float *)(v73 + 8) >= v75)
                  {
                    uint64_t v76 = *(void *)v74;
                    do
                    {
                      unint64_t v77 = v74;
                      unint64_t v74 = v73;
                      *(void *)unint64_t v77 = *(void *)v73;
                      *(_DWORD *)(v77 + 8) = *(_DWORD *)(v73 + 8);
                      if (v69 < v72) {
                        break;
                      }
                      uint64_t v78 = 2 * v72;
                      uint64_t v72 = (2 * v72) | 1;
                      unint64_t v73 = v10 + 16 * v72;
                      uint64_t v79 = v78 + 2;
                      if (v79 < (uint64_t)v12 && *(float *)(v73 + 8) < *(float *)(v73 + 24))
                      {
                        v73 += 16;
                        uint64_t v72 = v79;
                      }
                    }
                    while (*(float *)(v73 + 8) >= v75);
                    *(void *)unint64_t v74 = v76;
                    *(float *)(v74 + 8) = v75;
                  }
                }
                int64_t v70 = v71 - 1;
              }
              while (v71);
              uint64_t v80 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v81 = 0;
                uint64_t v82 = *(void *)v10;
                int v83 = *(_DWORD *)(v10 + 8);
                unint64_t v84 = v10;
                do
                {
                  unint64_t v85 = v84;
                  v84 += 16 * v81 + 16;
                  uint64_t v86 = 2 * v81;
                  uint64_t v81 = (2 * v81) | 1;
                  uint64_t v87 = v86 + 2;
                  if (v87 < v80 && *(float *)(v84 + 8) < *(float *)(v84 + 24))
                  {
                    v84 += 16;
                    uint64_t v81 = v87;
                  }
                  *(void *)unint64_t v85 = *(void *)v84;
                  *(_DWORD *)(v85 + 8) = *(_DWORD *)(v84 + 8);
                }
                while (v81 <= (uint64_t)((unint64_t)(v80 - 2) >> 1));
                if (v84 == a2 - 16)
                {
                  *(void *)unint64_t v84 = v82;
                  *(_DWORD *)(v84 + 8) = v83;
                }
                else
                {
                  *(void *)unint64_t v84 = *(void *)(a2 - 16);
                  *(_DWORD *)(v84 + 8) = *(_DWORD *)(a2 - 8);
                  *(void *)(a2 - 16) = v82;
                  *(_DWORD *)(a2 - 8) = v83;
                  uint64_t v88 = v84 - v10 + 16;
                  if (v88 >= 17)
                  {
                    unint64_t v89 = (((unint64_t)v88 >> 4) - 2) >> 1;
                    unint64_t v90 = v10 + 16 * v89;
                    float v91 = *(float *)(v84 + 8);
                    if (*(float *)(v90 + 8) < v91)
                    {
                      uint64_t v92 = *(void *)v84;
                      do
                      {
                        unint64_t v93 = v84;
                        unint64_t v84 = v90;
                        *(void *)unint64_t v93 = *(void *)v90;
                        *(_DWORD *)(v93 + 8) = *(_DWORD *)(v90 + 8);
                        if (!v89) {
                          break;
                        }
                        unint64_t v89 = (v89 - 1) >> 1;
                        unint64_t v90 = v10 + 16 * v89;
                      }
                      while (*(float *)(v90 + 8) < v91);
                      *(void *)unint64_t v84 = v92;
                      *(float *)(v84 + 8) = v91;
                    }
                  }
                }
                a2 -= 16;
              }
              while (v80-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = (float *)(v10 + 16 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v9, &v9[4 * (v12 >> 1)], (float *)(a2 - 16));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v9 + 4, v14 - 4, (float *)(a2 - 32));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v9 + 8, &v9[4 * v13 + 4], (float *)(a2 - 48));
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v14 - 4, v14, &v9[4 * v13 + 4]);
            uint64_t v15 = *(void *)v9;
            *(void *)unint64_t v9 = *(void *)v14;
            *(void *)unint64_t v14 = v15;
            int v16 = *((_DWORD *)v9 + 2);
            _OWORD v9[2] = v14[2];
            *((_DWORD *)v14 + 2) = v16;
          }
          else
          {
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(&v9[4 * (v12 >> 1)], v9, (float *)(a2 - 16));
          }
          --a3;
          uint64_t v17 = *(void *)v9;
          if (a4) {
            break;
          }
          float v18 = v9[2];
          float v19 = v18;
          if (*(v9 - 2) < v18) {
            goto LABEL_13;
          }
          if (v18 >= *(float *)(a2 - 8))
          {
            unint64_t v35 = v9 + 4;
            do
            {
              unint64_t v10 = (unint64_t)v35;
              if ((unint64_t)v35 >= a2) {
                break;
              }
              float v36 = v35[2];
              v35 += 4;
            }
            while (v18 >= v36);
          }
          else
          {
            unint64_t v33 = v9;
            do
            {
              unint64_t v10 = (unint64_t)(v33 + 4);
              float v34 = v33[6];
              v33 += 4;
            }
            while (v18 >= v34);
          }
          unint64_t v37 = a2;
          if (v10 < a2)
          {
            unint64_t v38 = a2;
            do
            {
              unint64_t v37 = v38 - 16;
              float v39 = *(float *)(v38 - 8);
              v38 -= 16;
            }
            while (v18 < v39);
          }
          while (v10 < v37)
          {
            uint64_t v40 = *(void *)v10;
            *(void *)unint64_t v10 = *(void *)v37;
            *(void *)unint64_t v37 = v40;
            int v41 = *(_DWORD *)(v10 + 8);
            *(_DWORD *)(v10 + 8) = *(_DWORD *)(v37 + 8);
            *(_DWORD *)(v37 + 8) = v41;
            do
            {
              float v42 = *(float *)(v10 + 24);
              v10 += 16;
            }
            while (v18 >= v42);
            do
            {
              float v43 = *(float *)(v37 - 8);
              v37 -= 16;
            }
            while (v18 < v43);
          }
          BOOL v4 = v10 - 16 >= (unint64_t)v9;
          BOOL v5 = v10 - 16 == (void)v9;
          if ((float *)(v10 - 16) != v9)
          {
            *(void *)unint64_t v9 = *(void *)(v10 - 16);
            _OWORD v9[2] = *(float *)(v10 - 8);
          }
          a4 = 0;
          *(void *)(v10 - 16) = v17;
          *(float *)(v10 - 8) = v18;
        }
        float v18 = v9[2];
        float v19 = v18;
LABEL_13:
        uint64_t v20 = v9;
        do
        {
          uint64_t v21 = v20;
          v20 += 4;
        }
        while (v19 > v21[6]);
        unint64_t v22 = a2;
        if (v21 == v9)
        {
          unint64_t v25 = a2;
          while ((unint64_t)v20 < v25)
          {
            unint64_t v23 = v25 - 16;
            float v26 = *(float *)(v25 - 8);
            v25 -= 16;
            if (v19 > v26) {
              goto LABEL_23;
            }
          }
          unint64_t v23 = v25;
        }
        else
        {
          do
          {
            unint64_t v23 = v22 - 16;
            float v24 = *(float *)(v22 - 8);
            v22 -= 16;
          }
          while (v19 <= v24);
        }
LABEL_23:
        unint64_t v10 = (unint64_t)v20;
        if ((unint64_t)v20 < v23)
        {
          unint64_t v27 = v23;
          do
          {
            uint64_t v28 = *(void *)v10;
            *(void *)unint64_t v10 = *(void *)v27;
            *(void *)unint64_t v27 = v28;
            int v29 = *(_DWORD *)(v10 + 8);
            *(_DWORD *)(v10 + 8) = *(_DWORD *)(v27 + 8);
            *(_DWORD *)(v27 + 8) = v29;
            do
            {
              float v30 = *(float *)(v10 + 24);
              v10 += 16;
            }
            while (v19 > v30);
            do
            {
              float v31 = *(float *)(v27 - 8);
              v27 -= 16;
            }
            while (v19 <= v31);
          }
          while (v10 < v27);
        }
        if ((float *)(v10 - 16) != v9)
        {
          *(void *)unint64_t v9 = *(void *)(v10 - 16);
          _OWORD v9[2] = *(float *)(v10 - 8);
        }
        *(void *)(v10 - 16) = v17;
        *(float *)(v10 - 8) = v18;
        if ((unint64_t)v20 >= v23) {
          break;
        }
LABEL_34:
        BOOL result = (float *)std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *,false>(v9, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v32 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((uint64_t)v9, v10 - 16);
      BOOL result = (float *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v10, a2);
      if (result) {
        break;
      }
      if (!v32) {
        goto LABEL_34;
      }
    }
    a2 = v10 - 16;
    if (!v32) {
      continue;
    }
    return result;
  }
}

float *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(float *result, float *a2, float *a3)
{
  uint64_t v3 = *(void *)a2;
  float v4 = a2[2];
  float v5 = result[2];
  float v6 = a3[2];
  if (v4 >= v5)
  {
    if (v6 < v4)
    {
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v3;
      a2[2] = v6;
      a3[2] = v4;
      float v8 = a2[2];
      float v9 = result[2];
      if (v8 < v9)
      {
        uint64_t v10 = *(void *)result;
        *(void *)BOOL result = *(void *)a2;
        *(void *)a2 = v10;
        result[2] = v8;
        a2[2] = v9;
      }
    }
  }
  else
  {
    uint64_t v7 = *(void *)result;
    if (v6 >= v4)
    {
      *(void *)BOOL result = v3;
      *(void *)a2 = v7;
      result[2] = v4;
      a2[2] = v5;
      float v11 = a3[2];
      if (v11 >= v5) {
        return result;
      }
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v7;
      a2[2] = v11;
    }
    else
    {
      *(void *)BOOL result = *(void *)a3;
      *(void *)a3 = v7;
      result[2] = v6;
    }
    a3[2] = v5;
  }
  return result;
}

float *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(a1, a2, a3);
  float v9 = *(float *)(a4 + 8);
  float v10 = a3[2];
  if (v9 < v10)
  {
    uint64_t v11 = *(void *)a3;
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v11;
    a3[2] = v9;
    *(float *)(a4 + 8) = v10;
    float v12 = a3[2];
    float v13 = a2[2];
    if (v12 < v13)
    {
      uint64_t v14 = *(void *)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v14;
      a2[2] = v12;
      a3[2] = v13;
      float v15 = a2[2];
      float v16 = a1[2];
      if (v15 < v16)
      {
        uint64_t v17 = *(void *)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v17;
        a1[2] = v15;
        a2[2] = v16;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      float v6 = *(float *)(a2 - 8);
      float v7 = *(float *)(a1 + 8);
      if (v6 < v7)
      {
        uint64_t v8 = *(void *)a1;
        *(void *)a1 = *(void *)(a2 - 16);
        *(void *)(a2 - 16) = v8;
        *(float *)(a1 + 8) = v6;
        *(float *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)a1, (float *)(a1 + 16), (float *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)a1, (float *)(a1 + 16), (float *)(a1 + 32), a2 - 16);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)a1, (float *)(a1 + 16), (float *)(a1 + 32), a1 + 48);
      float v18 = *(float *)(a2 - 8);
      float v19 = *(float *)(a1 + 56);
      if (v18 < v19)
      {
        uint64_t v20 = *(void *)(a1 + 48);
        *(void *)(a1 + 48) = *(void *)(a2 - 16);
        *(void *)(a2 - 16) = v20;
        *(float *)(a1 + 56) = v18;
        *(float *)(a2 - 8) = v19;
        float v21 = *(float *)(a1 + 56);
        float v22 = *(float *)(a1 + 40);
        if (v21 < v22)
        {
          uint64_t v23 = *(void *)(a1 + 32);
          uint64_t v24 = *(void *)(a1 + 48);
          *(void *)(a1 + 32) = v24;
          *(void *)(a1 + 48) = v23;
          *(float *)(a1 + 40) = v21;
          *(float *)(a1 + 56) = v22;
          float v25 = *(float *)(a1 + 24);
          if (v21 < v25)
          {
            uint64_t v26 = *(void *)(a1 + 16);
            *(void *)(a1 + 16) = v24;
            *(void *)(a1 + 32) = v26;
            *(float *)(a1 + 24) = v21;
            *(float *)(a1 + 40) = v25;
            float v27 = *(float *)(a1 + 8);
            if (v21 < v27)
            {
              uint64_t v28 = *(void *)a1;
              *(void *)a1 = v24;
              *(void *)(a1 + 16) = v28;
              *(float *)(a1 + 8) = v21;
              *(float *)(a1 + 24) = v27;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v9 = a1 + 32;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)a1, (float *)(a1 + 16), (float *)(a1 + 32));
      uint64_t v10 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    float v13 = *(float *)(v10 + 8);
    if (v13 < *(float *)(v9 + 8))
    {
      uint64_t v14 = *(void *)v10;
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        *(void *)(v16 + 48) = *(void *)(a1 + v15 + 32);
        *(_DWORD *)(v16 + 56) = *(_DWORD *)(a1 + v15 + 40);
        if (v15 == -32) {
          break;
        }
        v15 -= 16;
        if (v13 >= *(float *)(v16 + 24))
        {
          uint64_t v17 = a1 + v15 + 48;
          goto LABEL_13;
        }
      }
      uint64_t v17 = a1;
LABEL_13:
      *(void *)uint64_t v17 = v14;
      *(float *)(v17 + 8) = v13;
      if (++v12 == 8) {
        return v10 + 16 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2) {
      return 1;
    }
  }
}

uint64_t vision::mod::GreedyClustererFaces::affinityForFace(vision::mod::GreedyClustererFaces *a1, uint64_t *a2, void *a3, uint64_t a4)
{
  if (!vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, (uint64_t)a2)
  {
    return 5244;
  }
  {
    {
      memset(__p, 0, sizeof(__p));
      vision::mod::descriptorBufferUnpackedScores(&v10, a3, (uint64_t)__p, 128);
      uint64_t v9 = vision::mod::GreedyClustererFaces::affinityForFaceInternal((uint64_t)a1, a2, v10, a4);
      if (v11) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v11);
      }
      if (__p[0]) {
        operator delete(__p[0]);
      }
      return v9;
    }
    return 5244;
  }

  return vision::mod::GreedyClustererFaces::affinityForFaceInternal((uint64_t)a1, a2, a3, a4);
}

void sub_1A4043D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a11);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::GreedyClustererFaces::affinityForFaceInternal(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  unint64_t v33 = a2;
  if (!vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)a1, (uint64_t)a2))return 5244; {
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v32, *(_DWORD *)(*(void *)(a1 + 64) + 104), *(_DWORD *)(a1 + 28));
  }
  unint64_t v8 = (unint64_t)std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 112), (uint64_t)a2, &v33)[5];
  if (v8 >= (uint64_t)(*(void *)(*(void *)(a1 + 64) + 56) - *(void *)(*(void *)(a1 + 64) + 48)) >> 2)
  {
    uint64_t v14 = &CVML_status_inconsistentState;
  }
  else
  {
    unint64_t v9 = (*(uint64_t (**)(void *))(*a3 + 104))(a3);
    uint64_t v10 = *(void *)(a1 + 64);
    if (*(_DWORD *)(v10 + 104) == v9 >> 2)
    {
      uint64_t v11 = *(void *)(v10 + 72);
      if (v11) {
        unint64_t v12 = *(void *)v11 + v8 * (unint64_t)*(unsigned int *)(*(void *)v11 + 16) + 24;
      }
      else {
        unint64_t v12 = 0;
      }
      std::vector<float>::reserve((void **)a4, a3[9]);
      if (a3[9])
      {
        unint64_t v15 = 0;
        uint64_t v16 = (const float *)(v12 + 16);
        uint64_t v14 = &CVML_status_ok;
        do
        {
          uint64_t v17 = (const float *)(a3[7] + 4 * (a3[8] >> 2) * v15);
          vDSP_Length v18 = *(int *)(*(void *)(a1 + 64) + 104);
          float __C = 0.0;
          vDSP_dotpr(v17, 1, v16, 1, &__C, v18);
          float v19 = 1.0 - (float)((float)((float)(__C + 1.0) * -0.5) + 1.0);
          float v21 = *(float **)(a4 + 8);
          unint64_t v20 = *(void *)(a4 + 16);
          if ((unint64_t)v21 >= v20)
          {
            uint64_t v23 = *(float **)a4;
            uint64_t v24 = ((uint64_t)v21 - *(void *)a4) >> 2;
            unint64_t v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 62) {
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v26 = v20 - (void)v23;
            if (v26 >> 1 > v25) {
              unint64_t v25 = v26 >> 1;
            }
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v27 = v25;
            }
            if (v27)
            {
              unint64_t v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v27);
              uint64_t v23 = *(float **)a4;
              float v21 = *(float **)(a4 + 8);
            }
            else
            {
              uint64_t v28 = 0;
            }
            int v29 = (float *)(v27 + 4 * v24);
            *int v29 = v19;
            float v22 = v29 + 1;
            while (v21 != v23)
            {
              int v30 = *((_DWORD *)v21-- - 1);
              *((_DWORD *)v29-- - 1) = v30;
            }
            *(void *)a4 = v29;
            *(void *)(a4 + 8) = v22;
            *(void *)(a4 + 16) = v27 + 4 * v28;
            if (v23) {
              operator delete(v23);
            }
          }
          else
          {
            *float v21 = v19;
            float v22 = v21 + 1;
          }
          *(void *)(a4 + 8) = v22;
          ++v15;
        }
        while (a3[9] > v15);
      }
      else
      {
        uint64_t v14 = &CVML_status_ok;
      }
    }
    else
    {
      uint64_t v14 = &CVML_status_invalidParameter;
    }
  }
  uint64_t v31 = *v14;
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v32);
  return (v31 + 128) | 0x1400;
}

void sub_1A4043FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t vision::mod::GreedyClustererFaces::remove()
{
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::update(uint64_t a1, void *lpsrc, uint64_t **a3)
{
  {
    float v36 = 0;
    unint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    return vision::mod::GreedyClustererFaces::updateInternal(a1, lpsrc, &v36, &v33, a3);
  }
  float v36 = 0;
  unint64_t v37 = 0;
  uint64_t v38 = 0;
  vision::mod::descriptorBufferUnpackedScores(&v31, lpsrc, (uint64_t)&v36, 128);
  unint64_t v8 = v36;
  unint64_t v9 = v37;
  if (v36 != v37)
  {
    __asm
    {
      FMOV            V3.2S, #1.0
      FMOV            V4.2D, #-2.0
      FMOV            V5.2D, #3.0
    }
    uint64_t v17 = v36;
    do
    {
      *(float *)&double v7 = *v17;
      float v18 = 1.0;
      if (*v17 >= -0.5)
      {
        float32x2_t v19 = vdiv_f32(vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v7, 0), (float32x2_t)0xBF7EB852BF79999ALL), (float32x2_t)0x3BA3D7003C9374A0);
        float32x2_t v20 = (float32x2_t)vbic_s8((int8x8_t)v19, (int8x8_t)vcltz_f32(v19));
        float32x2_t v21 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v20, _D3), (int8x8_t)_D3, (int8x8_t)v20);
        float32x2_t v22 = vmla_f32(_D3, (float32x2_t)0xBEB2B020BE99999ALL, vcvt_f32_f64(vmulq_f64(vmlaq_f64(_Q5, _Q4, vcvtq_f64_f32(v21)), vcvtq_f64_f32(vmul_f32(v21, v21)))));
        float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, _D3), (int8x8_t)_D3, (int8x8_t)v22);
        float v24 = (float)(*(float *)&v7 + -0.96) / 0.01;
        if (v24 < 0.0) {
          float v24 = 0.0;
        }
        if (v24 > 1.0) {
          float v24 = 1.0;
        }
        float v25 = (v24 * -2.0 + 3.0) * (float)(v24 * v24);
        float v26 = (float)(v25 * 0.349) + 0.651;
        if (v26 > 1.0) {
          float v26 = 1.0;
        }
        double v7 = (float)(v26 * vmul_lane_f32(v23, v23, 1).f32[0]) * 1.25 / 1.1;
        float v18 = v7;
      }
      *v17++ = v18;
    }
    while (v17 != v9);
  }
  unint64_t v27 = v31;
  char v28 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 8))(*(void *)(a1 + 32));
  if (v8 == v9) {
    char v29 = 1;
  }
  else {
    char v29 = v28;
  }
  if ((v29 & 1) == 0) {
    memset_pattern16(v8, &unk_1A410C510, (((char *)v9 - (char *)v8 - 4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t updated = vision::mod::GreedyClustererFaces::updateInternal(a1, v27, &v36, &v33, a3);
  if (v32) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v32);
  }
  if (v8) {
    operator delete(v8);
  }
  return updated;
}

void sub_1A4044310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (v14) {
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::GreedyClustererFaces::updateInternal(uint64_t a1, unint64_t *lpsrc, void *a3, void *a4, uint64_t **a5)
{
  unint64_t v7 = *lpsrc;
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 5244;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if (lpsrc[9] != (uint64_t)(lpsrc[2] - lpsrc[1]) >> 3)
  {
    syslog(5, "wrong number of descriptors id in descriptor buffer");
    unint64_t v7 = *lpsrc;
  }
  char v124 = 0;
  uint64_t v125 = 0;
  uint64_t v123 = (uint64_t *)&v124;
  if (!v8)
  {
    syslog(5, "GreedyClusterer::addDescriptors must be called with a ImageDescriptorBufferFloat32 buffer");
LABEL_99:
    BOOL v106 = __cxa_allocate_exception(8uLL);
    uint64_t v107 = 5244;
    goto LABEL_101;
  }
  if (v8[26] != *(_DWORD *)(a1 + 28))
  {
    syslog(5, "For consistency, GreedyClusterer::addDescriptors must be called with a ImageDescriptorBufferFloat32 having the same distance mode as GreedyClusterer::distance_mode");
    goto LABEL_99;
  }
  unint64_t v120 = (float *)lpsrc[7];
  unint64_t v9 = *((int *)lpsrc + 16);
  int v10 = (*(uint64_t (**)(unint64_t *))(v7 + 104))(lpsrc);
  if (!v120)
  {
    BOOL v106 = __cxa_allocate_exception(8uLL);
    uint64_t v107 = 5245;
LABEL_101:
    *BOOL v106 = v107;
    __cxa_throw(v106, MEMORY[0x1E4FBA3E0], 0);
  }
  int v11 = v10;
  unint64_t v12 = lpsrc[9];
  float v13 = (std::__shared_weak_count *)operator new(0x30uLL);
  v13->__shared_owners_ = 0;
  v13->__shared_weak_owners_ = 0;
  v13->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753CE8;
  std::vector<unsigned long>::vector(&v13[1].__vftable, v12);
  unint64_t v14 = (unint64_t)v11 >> 2;
  uint64_t v15 = *(void *)(a1 + 64);
  int v16 = *(_DWORD *)(v15 + 104);
  BOOL v17 = v16 == v14 || v16 == 0;
  int v112 = v13;
  if (!v17)
  {
    unint64_t v108 = __cxa_allocate_exception(8uLL);
    *unint64_t v108 = 5244;
    __cxa_throw(v108, MEMORY[0x1E4FBA3E0], 0);
  }
  BOOL v110 = lpsrc;
  *(_DWORD *)(v15 + 104) = v14;
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v126, (unint64_t)v11 >> 2, *(_DWORD *)(a1 + 28));
  uint64_t v18 = *(void *)(a1 + 64);
  if (!*(void *)(v18 + 72) && !*(void *)(v18 + 88))
  {
    if (*(_DWORD *)(v18 + 104) == 128)
    {
      if (cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::create(528)) {
        vision::mod::GreedyClustererWithTorso::private_t::clusters_t::set_cluster_map_vector();
      }
      uint64_t v109 = __cxa_allocate_exception(8uLL);
      void *v109 = 5246;
      __cxa_throw(v109, MEMORY[0x1E4FBA3E0], 0);
    }
    __assert_rtn("addDescriptors", "GreedyClustering.cpp", 692, "elementSize == ELEMENT_SIZE");
  }
  unint64_t v119 = (unint64_t)v11 >> 2;
  if (!v12) {
    goto LABEL_80;
  }
  unint64_t v19 = 0;
  float v20 = *(float *)(*(void *)(a1 + 32) + 8) * *(float *)(a1 + 16);
  float32x2_t v21 = v120;
  unint64_t v116 = v9 >> 2;
  uint64_t v115 = (int)(v9 >> 2);
  int64x2_t v122 = vdupq_n_s64(2uLL);
  unint64_t v114 = v12;
  do
  {
    float v22 = 1.0;
    if (v19 < (uint64_t)(a3[1] - *a3) >> 2) {
      float v22 = *(float *)(*a3 + 4 * v19);
    }
    if (v19 >= (uint64_t)(a4[1] - *a4) >> 2) {
      int v23 = 1;
    }
    else {
      int v23 = *(_DWORD *)(*a4 + 4 * v19);
    }
    int v121 = v23;
    float v30 = v22
        * (***(float (****)(void, uint64_t, unint64_t))(a1 + 32))(*(void *)(a1 + 32), (uint64_t)&v120[v19 * v115], v116);
    uint64_t v31 = *(void *)(a1 + 64);
    uint64_t v33 = *(unsigned int **)(v31 + 48);
    BOOL v32 = *(unsigned int **)(v31 + 56);
    if (v33 == v32) {
      goto LABEL_44;
    }
    float v34 = 0.0;
    unsigned int v35 = -1;
    do
    {
      unsigned int v36 = *v33;
      uint64_t v37 = *(void *)(*(void *)(a1 + 64) + 72);
      if (v37)
      {
        unint64_t v38 = *(void *)v37 + *(unsigned int *)(*(void *)v37 + 16) * (unint64_t)v36;
        if (*(int *)(v38 + 32) < 1) {
          goto LABEL_37;
        }
        unint64_t v39 = v38 + 24;
      }
      else
      {
        if (MEMORY[8] < 1) {
          goto LABEL_37;
        }
        unint64_t v39 = 0;
      }
      LODWORD(__C[0]) = 0;
      vDSP_dotpr((const float *)(v39 + 16), 1, &v120[v19 * v115], 1, (float *)__C, (int)v119);
      float v40 = (float)((float)(*(float *)__C + 1.0) * -0.5) + 1.0;
      if (v40 < v20 && (v40 < v34 || v35 == -1))
      {
        float v34 = (float)((float)(*(float *)__C + 1.0) * -0.5) + 1.0;
        unsigned int v35 = v36;
      }
LABEL_37:
      ++v33;
    }
    while (v33 != v32);
    uint64_t v31 = *(void *)(a1 + 64);
    if ((v35 & 0x80000000) == 0)
    {
      unint64_t v42 = **(void **)(v31 + 72) + *(unsigned int *)(**(void **)(v31 + 72) + 16) * (unint64_t)v35;
      int v43 = *(_DWORD *)(v42 + 32);
      double v44 = (double)v121 + (double)v43;
      double v45 = (double)v121 / v44;
      double v46 = (double)v43 / v44;
      unint64_t v12 = v114;
      if ((int)v119 >= 1)
      {
        float v47 = (float *)(v42 + 40);
        float v48 = v21;
        uint64_t v49 = ((unint64_t)v11 >> 2);
        do
        {
          float v50 = *v48++;
          float v51 = v45 * v50 + *v47 * v46;
          *v47++ = v51;
          --v49;
        }
        while (v49);
      }
      unint64_t v52 = v42 + 24;
      *(_DWORD *)(v52 + 8) = v43 + v121;
      float v53 = v45 * v30 + *(float *)(v52 + 12) * v46;
      *(float *)(v52 + 12) = v53;
      unint64_t v54 = *(void *)v52;
      goto LABEL_79;
    }
    unint64_t v12 = v114;
LABEL_44:
    uint64_t v55 = *(cvml::util::MMapFileBackingStore **)(v31 + 72);
    if (!v55) {
      goto LABEL_94;
    }
    uint64_t v56 = *(void *)v55;
    int v57 = *(_DWORD *)(*(void *)v55 + 8);
    if (v57) {
      goto LABEL_58;
    }
    unint64_t v58 = *(unsigned int *)(v56 + 12);
    if (v58) {
      unint64_t v59 = (2 * v58);
    }
    else {
      unint64_t v59 = 256;
    }
    if (v59 <= v58
      || (unsigned int v113 = *(_DWORD *)(v56 + 16),
          unint64_t v60 = v59 * (unint64_t)v113,
          !cvml::util::MMapFileBackingStore::growStorage(v55, (cvml::util::MMapFileBackingStore *)(v60 + 24 + 4 * v59))))
    {
      VNValidatedLog(4, @"BackedBuffer<BackingStore>::allocateElement -- could not allocate new element because grow failed", v24, v25, v26, v27, v28, v29, (uint64_t)&v124);
LABEL_94:
      uint64_t v104 = __cxa_allocate_exception(8uLL);
      *uint64_t v104 = 5246;
      __cxa_throw(v104, MEMORY[0x1E4FBA3E0], 0);
    }
    uint64_t v61 = 0;
    uint64_t v62 = *(void *)v55;
    unint64_t v63 = (4 * v59 - 4 * v58 - 4) >> 2;
    uint64_t v64 = (v63 + 2) & 0x7FFFFFFFFFFFFFFELL;
    uint64x2_t v65 = (uint64x2_t)vdupq_n_s64(v63);
    uint64_t v66 = (_DWORD *)(*(void *)v55 + v60 + 28);
    int v67 = -2;
    int64x2_t v68 = (int64x2_t)xmmword_1A4104940;
    do
    {
      int32x2_t v69 = vmovn_s64((int64x2_t)vcgeq_u64(v65, (uint64x2_t)v68));
      if (v69.i8[0]) {
        *(v66 - 1) = v59 + v67 + 1;
      }
      if (v69.i8[4]) {
        *uint64_t v66 = v59 + (v61 ^ 0xFFFFFFFE);
      }
      v61 += 2;
      int64x2_t v68 = vaddq_s64(v68, v122);
      v67 -= 2;
      v66 += 2;
    }
    while (v64 != v61);
    *(void *)uint64_t v62 = v60 + 24;
    *(_DWORD *)(v62 + 12) = v59;
    *(_DWORD *)(v62 + 16) = v113;
    *(_DWORD *)(v62 + 8) = v59 - v58;
    std::vector<BOOL>::resize((uint64_t)v55 + 56, v59, 0);
    uint64_t v56 = *(void *)v55;
    int v57 = *(_DWORD *)(*(void *)v55 + 8);
    unint64_t v12 = v114;
LABEL_58:
    unsigned int v70 = v57 - 1;
    *(_DWORD *)(v56 + 8) = v70;
    unint64_t v54 = *(unsigned int *)(v56 + *(void *)v56 + 4 * v70);
    *(void *)(*((void *)v55 + 7) + ((v54 >> 3) & 0x1FFFFFF8)) |= 1 << v54;
    if (v54 == -1) {
      goto LABEL_94;
    }
    int64_t v71 = *(void **)(a1 + 64);
    uint64_t v72 = (uint64_t *)v71[9];
    if (!v72)
    {
      char v103 = __cxa_allocate_exception(8uLL);
      *char v103 = 5246;
      __cxa_throw(v103, MEMORY[0x1E4FBA3E0], 0);
    }
    uint64_t v73 = *v72;
    unsigned int v74 = *(_DWORD *)(v73 + 16);
    if ((int)v119 >= 1)
    {
      uint64_t v75 = 0;
      do
      {
        *(float *)(v73 + v74 * (unint64_t)v54 + 40 + v75 * 4) = v21[v75];
        ++v75;
      }
      while (((unint64_t)v11 >> 2) != v75);
    }
    uint64_t v76 = v73 + v74 * (unint64_t)v54;
    *(void *)(v76 + 24) = v54;
    v76 += 24;
    *(float *)(v76 + 12) = v30;
    *(_DWORD *)(v76 + 8) = v121;
    uint64_t v78 = (char *)v71[7];
    unint64_t v77 = v71[8];
    if ((unint64_t)v78 >= v77)
    {
      uint64_t v80 = (char *)v71[6];
      uint64_t v81 = (v78 - v80) >> 2;
      unint64_t v82 = v81 + 1;
      if ((unint64_t)(v81 + 1) >> 62) {
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v83 = v77 - (void)v80;
      if (v83 >> 1 > v82) {
        unint64_t v82 = v83 >> 1;
      }
      BOOL v84 = (unint64_t)v83 >= 0x7FFFFFFFFFFFFFFCLL;
      unint64_t v85 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v84) {
        unint64_t v85 = v82;
      }
      if (v85)
      {
        unint64_t v85 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v85);
        uint64_t v80 = (char *)v71[6];
        uint64_t v78 = (char *)v71[7];
      }
      else
      {
        uint64_t v86 = 0;
      }
      uint64_t v87 = (_DWORD *)(v85 + 4 * v81);
      *uint64_t v87 = v54;
      uint64_t v79 = v87 + 1;
      while (v78 != v80)
      {
        int v88 = *((_DWORD *)v78 - 1);
        v78 -= 4;
        *--uint64_t v87 = v88;
      }
      v71[6] = v87;
      v71[7] = v79;
      v71[8] = v85 + 4 * v86;
      if (v80) {
        operator delete(v80);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v78 = v54;
      uint64_t v79 = v78 + 4;
    }
    v71[7] = v79;
LABEL_79:
    *((void *)&v13[1].~__shared_weak_count + v19++) = v54;
    v21 += v115;
  }
  while (v19 != v12);
LABEL_80:
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v126);
  unint64_t v89 = (uint64_t *)v13[1].__vftable;
  uint64_t shared_owners = (uint64_t *)v13[1].__shared_owners_;
  if (v89 != shared_owners)
  {
    do
    {
      float v91 = operator new(0x28uLL);
      uint64_t v92 = *v89;
      v91[4] = *v89;
      unint64_t v93 = std::__tree<long long>::__find_equal<long long>(&v123, &v124, v126, __C, v92);
      if (*v93)
      {
        operator delete(v91);
      }
      else
      {
        uint64_t v94 = v126[0];
        *float v91 = 0;
        v91[1] = 0;
        void v91[2] = v94;
        *unint64_t v93 = v91;
        if (*v123)
        {
          uint64_t v123 = (uint64_t *)*v123;
          float v91 = (void *)*v93;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v124, v91);
        ++v125;
      }
      ++v89;
    }
    while (v89 != shared_owners);
    unint64_t v95 = v13[1].__vftable;
    if ((std::__shared_weak_count_vtbl *)v13[1].__shared_owners_ != v95)
    {
      unint64_t v96 = 0;
      do
      {
        v126[0] = *(uint64_t **)(v110[1] + 8 * v96);
        float v97 = v126[0];
        uint64_t v98 = (uint64_t *)*((void *)&v95->~__shared_weak_count + v96);
        __C[0] = (uint64_t)v98;
        unint64_t v99 = std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a1 + 88), (unint64_t)v98, __C);
        float v100 = operator new(0x18uLL);
        v100[2] = v97;
        uint64_t v101 = v99[5];
        v99 += 5;
        *float v100 = v101;
        v100[1] = v99;
        *(void *)(v101 + 8) = v100;
        *unint64_t v99 = (uint64_t)v100;
        ++v99[2];
        std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 112), (uint64_t)v97, v126)[5] = v98;
        ++v96;
        unint64_t v95 = v112[1].__vftable;
      }
      while (v96 < (v112[1].__shared_owners_ - (uint64_t)v95) >> 3);
    }
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v112);
  vision::mod::GreedyClustererFaces::computeDeltaAfterUpdate(a1, a5, (uint64_t *)&v123);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v124);
  return 5248;
}

void sub_1A4044CB4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,char a33)
{
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a33);
  std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  if (a2 == 1)
  {
    uint64_t v35 = *(void *)__cxa_begin_catch(a1);
    __cxa_end_catch();
    if (v35 == 5248) {
      JUMPOUT(0x1A4044B24);
    }
    JUMPOUT(0x1A4044B38);
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a31);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<unsigned long>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<unsigned long>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753CE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<std::vector<unsigned long>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753CE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::allocate_shared[abi:ne180100]<vision::mod::GreedyClustererFaces,std::allocator<vision::mod::GreedyClustererFaces>,char const*&,std::shared_ptr<std::vector<unsigned char>> &,BOOL &,std::shared_ptr<apple::vision::GreedyClusteringParamsWrapper> const&,void>(void *a1, char *a2, uint64_t **a3, char a4, uint64_t *a5)
{
  unint64_t v9 = operator new(0xF0uLL);
  v9[1] = 0;
  _OWORD v9[2] = 0;
  *unint64_t v9 = &unk_1EF753690;
  v9[3] = &unk_1EF752220;
  uint64_t v10 = vision::mod::GreedyClusterer::GreedyClusterer((uint64_t)(v9 + 4), a2, a5);
  v9[26] = 0;
  v9[3] = &unk_1EF752498;
  void v9[4] = &unk_1EF752578;
  v9[15] = 0;
  uint64_t v15 = (vision::mod::GreedyClusterer *)v10;
  v9[14] = v9 + 15;
  v9[16] = 0;
  v9[18] = 0;
  v9[17] = v9 + 18;
  v9[21] = 0;
  v9[20] = v9 + 21;
  v9[19] = 0;
  v9[24] = 0;
  v9[25] = 0;
  v9[22] = 0;
  v9[23] = v9 + 24;
  v9[27] = 0;
  v9[28] = 0;
  *((unsigned char *)v9 + 232) = 0;
  memset(&__s, 0, sizeof(__s));
  memset(&v20, 0, sizeof(v20));
  int v19 = -1;
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  uint64_t v14 = vision::mod::GreedyClustererFaces::pasreAndVerifyClustererState((uint64_t)__p, **a3, &__s, &v20, &v19, v11, v12, v13);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (v14 == 5248) {
    vision::mod::GreedyClusterer::deserializeStatus(v15, v19, a4 != 0);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  *a1 = v9 + 3;
  a1[1] = v9;
}

void sub_1A40451E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void **a11, void **a12, vision::mod::GreedyClusterer *a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (*(char *)(v35 + 231) < 0) {
    operator delete(*v33);
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*a10);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*a11);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*v34);
  std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(*a12);
  vision::mod::GreedyClusterer::~GreedyClusterer(a13);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v35);
  operator delete(v37);
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<vision::mod::GreedyClustererFaces,std::allocator<vision::mod::GreedyClustererFaces>,char const*&,std::shared_ptr<apple::vision::GreedyClusteringParamsWrapper> const&,void>(void *a1, char *a2, uint64_t *a3)
{
  float v6 = operator new(0xF0uLL);
  v6[1] = 0;
  v6[2] = 0;
  void *v6 = &unk_1EF753690;
  v6[3] = &unk_1EF752220;
  uint64_t result = vision::mod::GreedyClusterer::GreedyClusterer((uint64_t)(v6 + 4), a2, a3);
  v6[3] = &unk_1EF752498;
  v6[4] = &unk_1EF752578;
  v6[15] = 0;
  v6[14] = v6 + 15;
  v6[18] = 0;
  v6[16] = 0;
  v6[17] = v6 + 18;
  v6[21] = 0;
  v6[19] = 0;
  v6[20] = v6 + 21;
  v6[25] = 0;
  v6[26] = 0;
  v6[24] = 0;
  v6[22] = 0;
  v6[23] = v6 + 24;
  v6[27] = 0;
  v6[28] = 0;
  *((unsigned char *)v6 + 232) = 1;
  *a1 = v6 + 3;
  a1[1] = v6;
  return result;
}

void sub_1A40453A8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClusterer::GreedyClusterer(uint64_t a1, char *a2, uint64_t *a3)
{
  *(void *)a1 = &unk_1EF752300;
  *(void *)(a1 + 8) = 0x13F000000;
  *(unsigned char *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 2;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(unsigned char *)(a1 + 72) = 0;
  if (!*a3)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 5245;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  float v6 = (char *)operator new(0x98uLL);
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)float v6 = &unk_1EF753578;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_OWORD *)(v6 + 120) = 0u;
  *(_OWORD *)(v6 + 136) = 0u;
  *(_OWORD *)(v6 + 24) = 0u;
  *(void *)(a1 + 56) = v6 + 24;
  *(void *)(a1 + 64) = v6;
  if (a2)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, a2);
    uint64_t v7 = *(void *)(a1 + 56);
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    long long v8 = *(_OWORD *)__p;
    *(void *)(v7 + 16) = v19;
    *(_OWORD *)uint64_t v7 = v8;
    unint64_t v9 = *(uint64_t **)(a1 + 56);
    if (*((char *)v9 + 23) < 0)
    {
      unint64_t v9 = (uint64_t *)*v9;
      uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
    }
    else
    {
      uint64_t v10 = *((unsigned __int8 *)v9 + 23);
    }
    if (*((unsigned char *)v9 + v10 - 1) != 47)
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "/");
      uint64_t v11 = v19 >= 0 ? (const std::string::value_type *)__p : (const std::string::value_type *)__p[0];
      uint64_t v12 = v19 >= 0 ? (void *)HIBYTE(v19) : __p[1];
      std::string::append(*(std::string **)(a1 + 56), v11, (std::string::size_type)v12);
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  uint64_t v14 = *a3;
  uint64_t v13 = a3[1];
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 32);
  *(void *)(a1 + 24) = v14;
  *(void *)(a1 + 32) = v13;
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v15);
  }
  return a1;
}

void sub_1A4045584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  BOOL v17 = (std::__shared_weak_count *)v15[8];
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  }
  char v18 = (std::__shared_weak_count *)v15[6];
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  uint64_t v19 = (std::__shared_weak_count *)v15[4];
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v19);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClusterer::private_t>::__on_zero_shared(uint64_t a1)
{
  vision::mod::GreedyClustererWithTorso::private_t::clusters_t::~clusters_t((vision::mod::GreedyClustererWithTorso::private_t::clusters_t *)(a1 + 72));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<vision::mod::GreedyClusterer::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753578;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClusterer::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753578;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<vision::mod::GreedyClustererFaces>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<vision::mod::GreedyClustererFaces>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753690;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClustererFaces>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753690;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t vision::mod::GreedyClustererFaces::pasreAndVerifyClustererState(uint64_t a1, uint64_t a2, std::string *a3, std::string *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 != -1052410331)
  {
    float v40 = @"  Clusterer - couldn't find sanity value\n";
LABEL_25:
    VNValidatedLog(4, (uint64_t)v40, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v52);
    uint64_t v41 = -2;
    return (v41 + 128) | 0x1400;
  }
  if (*(_DWORD *)(a2 + 4) != 10004)
  {
    uint64_t v52 = *(unsigned int *)(a2 + 4);
    float v40 = CFSTR("  Clusterer - versions mismatch (serialized: %d, current: %d");
    goto LABEL_25;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)(a2 + 44));
  createFullPath(&__str, a1, (uint64_t)__p);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  char v20 = verifyChecksumMD5ForFile((const char *)p_str, (void *)(a2 + 24));
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float32x2_t v21 = &__str;
  }
  else {
    float32x2_t v21 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if (v20)
  {
    int v28 = open((const char *)v21, 0);
    int v29 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
    if (v28 != -1)
    {
      float v30 = (std::string *)__str.__r_.__value_.__r.__words[0];
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float v30 = &__str;
      }
      VNValidatedLog(1, @"  GreedyClustererFaces: Opening '%s'", v22, v23, v24, v25, v26, v27, (uint64_t)v30);
      __leuint64_t n = 0;
      read(v28, &__len, 8uLL);
      std::string::basic_string[abi:ne180100](__p, __len, 48);
      if (v56 >= 0) {
        uint64_t v31 = __p;
      }
      else {
        uint64_t v31 = (void **)__p[0];
      }
      read(v28, v31, __len);
      createFullPath(&v53, a1, (uint64_t)__p);
      if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        BOOL v32 = &v53;
      }
      else {
        BOOL v32 = (std::string *)v53.__r_.__value_.__r.__words[0];
      }
      if (verifyChecksumMD5ForFile((const char *)v32, (void *)(a2 + 8)))
      {
        *a5 = v28;
        lseek(v28, 0, 0);
        std::string::operator=(a3, &__str);
        std::string::operator=(a4, &v53);
        unint64_t v39 = &CVML_status_ok;
      }
      else
      {
        float v51 = &v53;
        if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          float v51 = (std::string *)v53.__r_.__value_.__r.__words[0];
        }
        VNValidatedLog(4, @"  Clusterer - data checksum mismatch for file: %s", v33, v34, v35, v36, v37, v38, (uint64_t)v51);
        close(v28);
        unint64_t v39 = &CVML_status_internalError;
      }
      uint64_t v41 = *v39;
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v53.__r_.__value_.__l.__data_);
      }
      if (v56 < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_39;
    }
    std::string::size_type v43 = __str.__r_.__value_.__r.__words[0];
    __error();
    float v50 = &__str;
    if (v29 < 0) {
      float v50 = (std::string *)v43;
    }
    VNValidatedLog(4, @"  GreedyClustererFaces: Failed to open '%s': errno=%d", v44, v45, v46, v47, v48, v49, (uint64_t)v50);
  }
  else
  {
    VNValidatedLog(4, @"  Clusterer - data checksum mismatch for file: %s", v14, v15, v16, v17, v18, v19, (uint64_t)v21);
  }
  uint64_t v41 = -2;
LABEL_39:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return (v41 + 128) | 0x1400;
}

void sub_1A40459F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A4045B08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4045B6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4045BC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4045D90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4045E70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4045F20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4046018(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4046094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40461A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40462E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404643C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }

  _Unwind_Resume(a1);
}

BOOL _addRelationshipsToHierarchicalModel(uint64_t **a1, void *a2, void *a3)
{
  id v5 = a2;
  if ([v5 count])
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    +[VNEspressoModelClassifier convertRelationships:v5 toStdRelationships:&v18];
    memset(&v17, 0, sizeof(v17));
    float v6 = v18;
    uint64_t v7 = v19;
    long long v8 = &CVML_status_ok;
    while (v6 != v7)
    {
      unint64_t v9 = *a1;
      if (!std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::find<std::string>(*a1, (unsigned __int8 *)v6))
      {
        std::string::operator=(&v17, v6);
        long long v8 = &CVML_status_invalidParameter;
        break;
      }
      vision::mod::ImageClassfier_Graph::addParentChildRelation(v9, (unsigned __int8 *)v6, (unsigned __int8 *)&v6[1]);
      v6 += 2;
    }
    uint64_t v11 = (*(_DWORD *)v8 + 0x80);
    BOOL v10 = v11 == 128;
    if (a3 && v11 != 128)
    {
      uint64_t v12 = NSString;
      if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v13 = &v17;
      }
      else {
        uint64_t v13 = (std::string *)v17.__r_.__value_.__r.__words[0];
      }
      uint64_t v14 = [NSString stringWithCString:v13 encoding:4];
      uint64_t v15 = [v12 stringWithFormat:@"The classification identifier '%@' does not exist in the hierarchy", v14];

      *a3 = +[VNError errorWithCode:14 message:v15];
    }
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
    v17.__r_.__value_.__r.__words[0] = (std::string::size_type)&v18;
    std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);
  }
  else
  {
    BOOL v10 = 1;
  }

  return v10;
}

void sub_1A404660C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  std::string __p = &a17;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);

  _Unwind_Resume(a1);
}

void sub_1A40466F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40467D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40468BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A4046978(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4046B98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t VNNSDataStreambuf::underflow(VNNSDataStreambuf *this)
{
  return 0xFFFFFFFFLL;
}

void VNNSDataStreambuf::~VNNSDataStreambuf(id *this)
{
  std::streambuf::~streambuf();

  JUMPOUT(0x1A62562C0);
}

{
  uint64_t vars8;

  std::streambuf::~streambuf();
}

uint64_t VNNSMutableDataStreambuf::overflow(id *this, int a2)
{
  if (a2 == -1) {
    return 0;
  }
  unsigned __int8 v2 = a2;
  unint64_t v4 = [this[8] length];
  unint64_t v5 = (unint64_t)this[10];
  if (v5 >= v4)
  {
    [this[8] setLength:(v5 & 0xFFFFFFFFFFFFFFE0) + 32];
    uint64_t v6 = [this[8] mutableBytes];
    this[9] = (id)v6;
    if (v6) {
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v6 = (uint64_t)this[9];
    if (v6)
    {
LABEL_4:
      *((unsigned char *)this[10] + v6) = v2;
      this[10] = (char *)this[10] + 1;
      return v2;
    }
  }
  return 0xFFFFFFFFLL;
}

void VNNSMutableDataStreambuf::~VNNSMutableDataStreambuf(id *this)
{
  std::streambuf::~streambuf();

  JUMPOUT(0x1A62562C0);
}

{
  uint64_t vars8;

  std::streambuf::~streambuf();
}

void VNNSDataStreambuf::VNNSDataStreambuf(VNNSDataStreambuf *this, NSData *a2)
{
  uint64_t v3 = a2;
  std::streambuf::basic_streambuf();
  *(void *)this = &unk_1EF751E90;
  unint64_t v4 = v3;
  *((void *)this + 8) = v4;
  uint64_t v5 = [(NSData *)v4 bytes];
  uint64_t v6 = [*((id *)this + 8) length];
  *((void *)this + 2) = v5;
  *((void *)this + 3) = v5;
  *((void *)this + 4) = v5 + v6;
}

void sub_1A4046E20(_Unwind_Exception *a1)
{
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void VNNSMutableDataStreambuf::VNNSMutableDataStreambuf(VNNSMutableDataStreambuf *this)
{
  unsigned __int8 v2 = (void *)std::streambuf::basic_streambuf();
  void *v2 = &unk_1EF751F10;
  v2[9] = 0;
  v2[10] = 0;
  v2[8] = 0;
  uint64_t v3 = [objc_alloc(MEMORY[0x1E4F1CA58]) initWithCapacity:1024];
  unint64_t v4 = (void *)*((void *)this + 8);
  *((void *)this + 8) = v3;
}

void sub_1A4046EB8(_Unwind_Exception *a1)
{
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void sub_1A404799C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4047AE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4047E20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4047F74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4048070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404817C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4048214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40482E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40484B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404860C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4048828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1A4048A7C(_Unwind_Exception *a1)
{
  long long v8 = v6;

  _Unwind_Resume(a1);
}

void sub_1A4048B48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4048D24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4048E54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4049024(_Unwind_Exception *a1)
{
}

void sub_1A4049044(void *a1)
{
}

void sub_1A40490E4(void *a1)
{
}

void sub_1A40490F0(_Unwind_Exception *a1)
{
}

void sub_1A40491E0(void *a1)
{
}

void sub_1A40491EC(_Unwind_Exception *a1)
{
}

void sub_1A404931C(void *a1)
{
}

void sub_1A40493E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40494C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40496A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4049780(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4049864(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4049A38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4049B04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4049BBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4049C6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4049DE0(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A4049EF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404A120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404A25C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404A354(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404A430(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404A4FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404A5C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404A688(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404A92C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404AA64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404AB5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404ADF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404B20C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404B3A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404B49C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404B740(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t tplTrackerResampler_lumaDownscale8N(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  if (!a6) {
    return 6780;
  }
  unint64_t v13 = 8 * a6;
  double v14 = log2((double)(v13 * v13));
  if (v13 > a5) {
    return 6784;
  }
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unsigned int v18 = v14;
  uint64_t v19 = *a1 + a2 + a1[3] * a3;
  if (a4 / v13 <= 1) {
    uint64_t v20 = 1;
  }
  else {
    uint64_t v20 = a4 / v13;
  }
  uint64_t v21 = a5 / v13;
  if (a5 / v13 <= 1) {
    uint64_t v21 = 1;
  }
  uint64_t result = 6784;
  do
  {
    if (v13 <= a4)
    {
      uint64_t v22 = 0;
      uint64_t v23 = v19;
      do
      {
        uint64_t v24 = 0;
        uint64_t v25 = a1[3];
        uint64_t v26 = (unsigned __int8 *)(v23 + v16 * v25);
        unsigned int v27 = 1 << v18 >> 1;
        do
        {
          int v28 = v26;
          unint64_t v29 = v13;
          do
          {
            int v30 = *v28++;
            v27 += v30;
            --v29;
          }
          while (v29);
          ++v24;
          v26 += v25;
        }
        while (v24 != v13);
        *(unsigned char *)(a7 + v22++) = v27 >> v18;
        v23 += v13;
      }
      while (v22 != v20);
    }
    a7 += a4 / v13;
    ++v17;
    v16 += v13;
  }
  while (v17 != v21);
  return result;
}

uint64_t tplTrackerResampler_chromaDownscale8N(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a6) {
    return 6780;
  }
  unint64_t v16 = 8 * a6;
  double v17 = log2((double)(v16 * v16));
  if (v16 > a5) {
    return 6784;
  }
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  unint64_t v21 = a4 / v16;
  unsigned int v22 = v17;
  uint64_t v23 = *a1 + a1[3] * a3 + 2 * a2;
  if (a4 / v16 <= 1) {
    uint64_t v24 = 1;
  }
  else {
    uint64_t v24 = a4 / v16;
  }
  uint64_t v25 = a5 / v16;
  if (a5 / v16 <= 1) {
    uint64_t v25 = 1;
  }
  uint64_t v26 = 16 * a6;
  uint64_t result = 6784;
  do
  {
    if (v16 <= a4)
    {
      uint64_t v27 = 0;
      uint64_t v28 = v23;
      do
      {
        uint64_t v29 = 0;
        uint64_t v30 = a1[3];
        uint64_t v31 = v28 + v19 * v30;
        unsigned int v32 = 1 << v22 >> 1;
        unsigned int v33 = v32;
        do
        {
          uint64_t v34 = 0;
          unint64_t v35 = v16;
          do
          {
            v33 += *(unsigned __int8 *)(v31 + v34);
            v32 += *(unsigned __int8 *)(v31 + v34 + 1);
            v34 += 2;
            --v35;
          }
          while (v35);
          ++v29;
          v31 += v30;
        }
        while (v29 != v16);
        *(unsigned char *)(a7 + v27) = v33 >> v22;
        *(unsigned char *)(a8 + v27++) = v32 >> v22;
        v28 += v26;
      }
      while (v27 != v24);
    }
    a7 += v21;
    a8 += v21;
    ++v20;
    v19 += v16;
  }
  while (v20 != v25);
  return result;
}

uint64_t revertSegmentCoordinateSystem(uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(_DWORD **)(result + 40);
  if ((a3 & 0x10000) != 0 && a2 >= 1)
  {
    unint64_t v4 = (_WORD *)v3 + 1;
    int v5 = a2;
    do
    {
      _WORD *v4 = -*v4;
      v4 += 2;
      --v5;
    }
    while (v5);
  }
  if ((a3 & 0x100) != 0 && a2 >= 1)
  {
    int v6 = a2;
    uint64_t v7 = v3;
    do
    {
      _WORD *v7 = -*v7;
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  if ((a3 & 1) != 0 && a2 >= 1)
  {
    do
    {
      HIDWORD(v8) = *v3;
      LODWORD(v8) = *v3;
      *v3++ = v8 >> 16;
      --a2;
    }
    while (a2);
  }
  float v9 = *(float *)(result + 20);
  float v10 = *(float *)(result + 24);
  float v11 = *(float *)(result + 28);
  if ((*(void *)&a3 & 0x10000) != 0)
  {
    float v11 = -v11;
    float v9 = -v9;
  }
  if ((a3 & 0x100) != 0)
  {
    float v11 = -v11;
    float v10 = -v10;
  }
  if (a3) {
    float v12 = v9;
  }
  else {
    float v12 = v10;
  }
  if (a3) {
    float v9 = v10;
  }
  *(float *)(result + 20) = v9;
  *(float *)(result + 24) = v12;
  *(float *)(result + 28) = v11;
  return result;
}

unsigned __int16 *findDiff(unsigned __int16 *result, int a2, char a3, _WORD *a4, _WORD *a5)
{
  int v5 = *result;
  int v6 = result[1];
  if (a3)
  {
    if (a2 < 2)
    {
      LODWORD(v8) = 1;
    }
    else
    {
      uint64_t v7 = result + 2;
      uint64_t v8 = 1;
      while (1)
      {
        int v9 = *v7;
        v7 += 2;
        if (v5 != v9) {
          break;
        }
        if (a2 == ++v8)
        {
          LODWORD(v8) = a2;
          break;
        }
      }
    }
    if (v8 == a2) {
      LOWORD(v8) = 0;
    }
    *a4 = v8;
    if ((a3 & 2) == 0)
    {
LABEL_3:
      if (!a5) {
        return result;
      }
      goto LABEL_23;
    }
  }
  else if ((a3 & 2) == 0)
  {
    goto LABEL_3;
  }
  if (a2 < 2)
  {
    LODWORD(v11) = 1;
  }
  else
  {
    float v10 = result + 3;
    uint64_t v11 = 1;
    while (1)
    {
      int v12 = *v10;
      v10 += 2;
      if (v6 != v12) {
        break;
      }
      if (a2 == ++v11)
      {
        LODWORD(v11) = a2;
        break;
      }
    }
  }
  if (v11 == a2) {
    LOWORD(v11) = 0;
  }
  a4[1] = v11;
  if (a5)
  {
LABEL_23:
    if (a3)
    {
      if (a2 < 2)
      {
        LODWORD(v14) = 1;
      }
      else
      {
        unint64_t v13 = &result[2 * a2 - 2];
        uint64_t v14 = 1;
        while (1)
        {
          int v15 = *v13;
          v13 -= 2;
          if (v5 != v15) {
            break;
          }
          if (a2 == ++v14)
          {
            LODWORD(v14) = a2;
            break;
          }
        }
      }
      __int16 v16 = v14 - 1;
      if (v14 == a2) {
        __int16 v16 = 0;
      }
      *a5 = v16;
    }
    if ((a3 & 2) != 0)
    {
      if (a2 < 2)
      {
        LODWORD(v18) = 1;
      }
      else
      {
        double v17 = &result[2 * a2 - 1];
        uint64_t v18 = 1;
        while (1)
        {
          int v19 = *v17;
          v17 -= 2;
          if (v6 != v19) {
            break;
          }
          if (a2 == ++v18)
          {
            LODWORD(v18) = a2;
            break;
          }
        }
      }
      __int16 v20 = v18 - 1;
      if (v18 == a2) {
        __int16 v20 = 0;
      }
      a5[1] = v20;
    }
  }
  return result;
}

void splitSegmentIntoStraightSegments(uint64_t *a1, uint64_t a2, unint64_t a3, int *a4, float a5)
{
  int v5 = *((_DWORD *)a1 + 3);
  if (v5 >= 6)
  {
    int v8 = a3;
    float v10 = a1;
    uint64_t v11 = a1[5];
    unint64_t v12 = HIDWORD(a3);
    if (SHIDWORD(a3) <= 1) {
      LODWORD(v12) = 1;
    }
    if ((int)v12 >= v5 - 2) {
      unsigned int v13 = v5 - 2;
    }
    else {
      unsigned int v13 = v12;
    }
    uint64_t v14 = allocSegments(a4, 1);
    *(void *)uint64_t v14 = *v10;
    *float v10 = v14;
    *(_DWORD *)(v14 + 12) = v5 - v13;
    int v15 = (__int16 *)(v11 + 4 * v13);
    *(void *)(v14 + 40) = v15;
    *((_DWORD *)v10 + 3) = v13 + 1;
    unint64_t v16 = straightLineWLSQ((__int16 *)v10[5], v13 + 1);
    uint64_t v18 = v17;
    float v19 = *(float *)&v17;
    *((float *)v10 + 5) = Lsq2Leq(a2);
    *((_DWORD *)v10 + 6) = v20;
    *((_DWORD *)v10 + 7) = v21;
    *((_DWORD *)v10 + 4) = v8;
    if (v19 > a5)
    {
      splitSegmentIntoStraightSegments(v10, v16, v18, a4, a5);
      int v15 = *(__int16 **)(v14 + 40);
    }
    unint64_t v22 = straightLineWLSQ(v15, *(_DWORD *)(v14 + 12));
    uint64_t v24 = v23;
    float v25 = *(float *)&v23;
    *(float *)(v14 + 20) = Lsq2Leq(v22);
    *(_DWORD *)(v14 + 24) = v26;
    *(_DWORD *)(v14 + 28) = v27;
    *(_DWORD *)(v14 + 16) = v24;
    if (v25 > a5) {
      splitSegmentIntoStraightSegments(v14, v22, v24, a4, a5);
    }
    do
    {
      uint64_t v28 = v10;
      float v10 = (uint64_t *)*v10;
    }
    while (v10 != (uint64_t *)v14);
    int v29 = *((_DWORD *)v28 + 3) + *(_DWORD *)(v14 + 12) - 1;
    unint64_t v30 = straightLineWLSQ((__int16 *)v28[5], v29);
    if (v31 <= a5)
    {
      *((_DWORD *)v28 + 3) = v29;
      *((float *)v28 + 4) = v31;
      *((float *)v28 + 5) = Lsq2Leq(v30);
      *((_DWORD *)v28 + 6) = v32;
      *((_DWORD *)v28 + 7) = v33;
      *uint64_t v28 = *(void *)v14;
      *(unsigned char *)(v14 + 8) = 0;
    }
  }
}

uint64_t mergeSegments(float *a1, uint64_t a2, float a3)
{
  uint64_t v4 = a2;
  v38[1] = *MEMORY[0x1E4F143B8];
  v38[0] = (a2 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (float *)((char *)v38 - v6);
  if (v8 < 2) {
    return v4;
  }
  int v9 = 0;
  do
  {
    uint64_t v10 = (v4 - 2);
    if ((int)v4 < 2) {
      return v4;
    }
    int v11 = v4 - 1;
    unint64_t v12 = (__int16 *)*((void *)a1 + 5);
    float v13 = a1[5];
    float v14 = a1[6];
    float v15 = a1[7];
    unint64_t v16 = v7;
    uint64_t v17 = (v4 - 1);
    uint64_t v18 = a1;
    do
    {
      uint64_t v18 = *(float **)v18;
      int v19 = *v12;
      int v20 = v12[1];
      unint64_t v12 = (__int16 *)*((void *)v18 + 5);
      int v21 = &v12[2 * *((int *)v18 + 3)];
      float v22 = (float)(v14 * (float)*(v21 - 1)) + (float)(v13 * (float)*(v21 - 2));
      float v23 = v18[5];
      float v14 = v18[6];
      float v24 = v15 + v22;
      float v25 = v18[7];
      float v26 = fabsf(v24);
      float v27 = fabsf(v25 + (float)((float)(v14 * (float)v20) + (float)(v23 * (float)v19)));
      if (v26 <= v27) {
        float v26 = v27;
      }
      *v16++ = v26;
      float v15 = v25;
      float v13 = v23;
      --v17;
    }
    while (v17);
    int v28 = 0;
    int v29 = 0;
    int v30 = 1;
    float v31 = (uint64_t *)a1;
    while (v28 != v10)
    {
      int v32 = &v7[v28];
      float v33 = v32[1];
      if (*v32 > v33) {
        float v34 = v32[1];
      }
      else {
        float v34 = *v32;
      }
      if (v34 > a3)
      {
        float v31 = (uint64_t *)*v31;
LABEL_20:
        int v35 = 2;
        goto LABEL_21;
      }
      ++v29;
      if (*v32 <= v33)
      {
        mergeSegment(v31);
        goto LABEL_20;
      }
      mergeSegment((uint64_t *)*v31);
      float v31 = (uint64_t *)*v31;
      int v35 = 3;
LABEL_21:
      float v31 = (uint64_t *)*v31;
      v28 += v35;
LABEL_22:
      if (v28 < v11 && v30++ < v11) {
        continue;
      }
      goto LABEL_26;
    }
    if (v7[v10] > a3)
    {
      float v31 = 0;
      int v28 = v4;
      goto LABEL_22;
    }
    ++v29;
    mergeSegment(v31);
LABEL_26:
    uint64_t v4 = (v4 - v29);
    if (!v29) {
      break;
    }
    if (v4 == 1) {
      break;
    }
    ++v9;
  }
  while (v9 != LODWORD(v38[0]));
  return v4;
}

void mergeSegment(uint64_t *a1)
{
  uint64_t v1 = (uint64_t *)*a1;
  if (!*a1) {
    __assert_rtn("mergeSegment", "SegmentUtilities.c", 453, "sPtr2 != NULL");
  }
  int v3 = *((_DWORD *)a1 + 3) + *((_DWORD *)v1 + 3) - 1;
  *((_DWORD *)a1 + 3) = v3;
  *a1 = *v1;
  *((unsigned char *)v1 + 8) = 0;
  unint64_t v4 = straightLineLSQ((__int16 *)a1[5], v3);
  *((_DWORD *)a1 + 4) = v5;
  *((float *)a1 + 5) = Lsq2Leq(v4);
  *((_DWORD *)a1 + 6) = v6;
  *((_DWORD *)a1 + 7) = v7;
}

void sub_1A404C2CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404C404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404C92C(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1A404C8B4);
  }
  _Unwind_Resume(exc_buf);
}

void sub_1A404D114(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1A404D09CLL);
  }
  _Unwind_Resume(exc_buf);
}

void sub_1A404EC78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404ECE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A404F19C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A404F4AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404F5DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404F68C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404F75C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404F84C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404F8B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404F934(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404FA1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404FAA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A404FAEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404FBA8(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A404FCCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404FD90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404FE44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404FEFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A404FFB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40500C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40501F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4050310(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4050678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40507D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40508AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4050998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A40509E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4050A44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4050A90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4050B94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4050BF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4050C40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4050F08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A4051064(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40511E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40512AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40517F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *a27)
{
  _Unwind_Resume(a1);
}

void sub_1A40519EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4051E08(void *a1)
{
}

void sub_1A4051E3C()
{
  if (v0) {
    JUMPOUT(0x1A4051E44);
  }
  JUMPOUT(0x1A4051E48);
}

void *lockedPixelBufferToImageBuffer<Pixel_UHVH>(void *a1, CVPixelBufferRef pixelBuffer)
{
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  size_t Height = CVPixelBufferGetHeight(pixelBuffer);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
  uint64_t result = CVPixelBufferGetBaseAddress(pixelBuffer);
  *a1 = result;
  a1[1] = Height;
  a1[2] = Width;
  a1[3] = BytesPerRow;
  return result;
}

uint64_t ___Z21convertAndResizeImageI10Pixel_UFVFS0_EvRKN5apple6vision11ImageBufferIT_S4_EERKNS3_IT0_S8_EE_block_invoke(uint64_t result, unint64_t a2)
{
  float v2 = *(float *)(result + 72) * (float)a2;
  uint64_t v3 = (int)vcvtms_s32_f32(v2);
  uint64_t v4 = *(void *)(result + 32);
  if (v4 >= v3 + 1) {
    uint64_t v4 = v3 + 1;
  }
  uint64_t v5 = *(void *)(result + 56);
  if (v5 >= 1)
  {
    float v6 = v2 - floorf(v2);
    int v7 = *(uint64_t **)(result + 40);
    unint64_t v8 = (unint64_t)v7[3] >> 3;
    uint64_t v9 = *v7;
    uint64_t v10 = v9 + 8 * v8 * v3;
    uint64_t v11 = v9 + 8 * v4 * v8;
    uint64_t v12 = *(void *)(result + 64);
    float v13 = (float *)(**(void **)(result + 48) + 8 * a2 * (*(void *)(*(void *)(result + 48) + 24) >> 3) + 4);
    float v14 = 0.0;
    do
    {
      float v15 = v14 - floorf(v14);
      signed int v16 = vcvtms_s32_f32(v14);
      if (v12 >= v16 + 1) {
        uint64_t v17 = v16 + 1;
      }
      else {
        uint64_t v17 = v12;
      }
      uint64_t v18 = (float *)(v10 + 8 * v16);
      int v19 = (float *)(v10 + 8 * v17);
      int v20 = (float *)(v11 + 8 * v16);
      int v21 = (float *)(v11 + 8 * v17);
      float v22 = *v18 + (float)(v15 * (float)(*v19 - *v18));
      float v23 = v20[1];
      float v24 = v21[1];
      float v25 = v18[1] + (float)(v15 * (float)(v19[1] - v18[1]));
      *(v13 - 1) = (float)(v22 + (float)(v6 * (float)((float)(*v20 + (float)(v15 * (float)(*v21 - *v20))) - v22)))
                 * *(float *)(result + 80);
      *float v13 = *(float *)(result + 84)
           * (float)(v25 + (float)(v6 * (float)((float)(v23 + (float)(v15 * (float)(v24 - v23))) - v25)));
      v13 += 2;
      float v14 = v14 + *(float *)(result + 76);
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t ___Z21convertAndResizeImageI10Pixel_UFVF10Pixel_UHVHEvRKN5apple6vision11ImageBufferIT_S5_EERKNS4_IT0_S9_EE_block_invoke(uint64_t result, unint64_t a2)
{
  float v2 = *(float *)(result + 72) * (float)a2;
  uint64_t v3 = (int)vcvtms_s32_f32(v2);
  uint64_t v4 = *(void *)(result + 32);
  if (v4 >= v3 + 1) {
    uint64_t v4 = v3 + 1;
  }
  uint64_t v5 = *(void *)(result + 56);
  if (v5 >= 1)
  {
    float v6 = v2 - floorf(v2);
    int v7 = *(uint64_t **)(result + 40);
    unint64_t v8 = (unint64_t)v7[3] >> 3;
    uint64_t v9 = *v7;
    uint64_t v10 = v9 + 8 * v8 * v3;
    uint64_t v11 = v9 + 8 * v4 * v8;
    uint64_t v12 = *(void *)(result + 64);
    float v14 = *(float *)(result + 80);
    float v13 = *(float *)(result + 84);
    float v15 = *(float *)(result + 76);
    signed int v16 = (_WORD *)(**(void **)(result + 48) + 4 * a2 * (*(void *)(*(void *)(result + 48) + 24) >> 2) + 2);
    float v17 = 0.0;
    do
    {
      signed int v18 = vcvtms_s32_f32(v17);
      float v19 = v17 - floorf(v17);
      if (v12 >= v18 + 1) {
        uint64_t v20 = v18 + 1;
      }
      else {
        uint64_t v20 = v12;
      }
      int v21 = (float *)(v10 + 8 * v18);
      float v22 = (float *)(v11 + 8 * v18);
      float v23 = (float *)(v10 + 8 * v20);
      float v24 = (float *)(v11 + 8 * v20);
      float v25 = v22[1];
      float v26 = v24[1];
      float v27 = *v21 + (float)(v19 * (float)(*v23 - *v21));
      float v28 = v21[1] + (float)(v19 * (float)(v23[1] - v21[1]));
      _S6 = (float)(v27 + (float)(v6 * (float)((float)(*v22 + (float)(v19 * (float)(*v24 - *v22))) - v27))) * v14;
      __asm { FCVT            H6, S6 }
      *(v16 - 1) = LOWORD(_S6);
      _S5 = v13 * (float)(v28 + (float)(v6 * (float)((float)(v25 + (float)(v19 * (float)(v26 - v25))) - v28)));
      __asm { FCVT            H5, S5 }
      *signed int v16 = LOWORD(_S5);
      float v17 = v17 + v15;
      v16 += 2;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t ___Z21convertAndResizeImageI10Pixel_UHVH10Pixel_UFVFEvRKN5apple6vision11ImageBufferIT_S5_EERKNS4_IT0_S9_EE_block_invoke(uint64_t result, unint64_t a2)
{
  float v2 = *(float *)(result + 72) * (float)a2;
  uint64_t v3 = (int)vcvtms_s32_f32(v2);
  uint64_t v4 = *(void *)(result + 32);
  if (v4 >= v3 + 1) {
    uint64_t v4 = v3 + 1;
  }
  uint64_t v5 = *(void *)(result + 56);
  if (v5 >= 1)
  {
    float v6 = v2 - floorf(v2);
    int v7 = *(uint64_t **)(result + 40);
    unint64_t v8 = (unint64_t)v7[3] >> 2;
    uint64_t v9 = *v7;
    uint64_t v10 = v9 + 4 * v8 * v3;
    uint64_t v11 = v9 + 4 * v4 * v8;
    uint64_t v12 = *(void *)(result + 64);
    float v13 = (float *)(**(void **)(result + 48) + 8 * a2 * (*(void *)(*(void *)(result + 48) + 24) >> 3) + 4);
    float v14 = 0.0;
    do
    {
      float v15 = v14 - floorf(v14);
      signed int v16 = vcvtms_s32_f32(v14);
      if (v12 >= v16 + 1) {
        uint64_t v17 = v16 + 1;
      }
      else {
        uint64_t v17 = v12;
      }
      signed int v18 = (__int16 *)(v10 + 4 * v16);
      float v19 = (__int16 *)(v10 + 4 * v17);
      uint64_t v20 = (_WORD *)(v11 + 4 * v16);
      int v21 = (__int16 *)(v11 + 4 * v17);
      _H3 = *v18;
      __asm { FCVT            S3, H3 }
      _H4 = *v19;
      __asm { FCVT            S4, H4 }
      float v30 = _S3 + (float)(v15 * (float)(_S4 - _S3));
      LOWORD(_S4) = *v20;
      __asm { FCVT            S4, H4 }
      _H5 = *v21;
      __asm { FCVT            S5, H5 }
      float v34 = v30 + (float)(v6 * (float)((float)(_S4 + (float)(v15 * (float)(_S5 - _S4))) - v30));
      LOWORD(_S4) = v18[1];
      __asm { FCVT            S4, H4 }
      LOWORD(_S5) = v19[1];
      __asm { FCVT            S5, H5 }
      float v37 = _S4 + (float)(v15 * (float)(_S5 - _S4));
      LOWORD(_S5) = v20[1];
      __asm { FCVT            S5, H5 }
      _H6 = v21[1];
      __asm { FCVT            S6, H6 }
      *(v13 - 1) = v34 * *(float *)(result + 80);
      *float v13 = *(float *)(result + 84)
           * (float)(v37 + (float)(v6 * (float)((float)(_S5 + (float)(v15 * (float)(_S6 - _S5))) - v37)));
      v13 += 2;
      float v14 = v14 + *(float *)(result + 76);
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t ___Z21convertAndResizeImageI10Pixel_UHVHS0_EvRKN5apple6vision11ImageBufferIT_S4_EERKNS3_IT0_S8_EE_block_invoke(uint64_t result, unint64_t a2)
{
  float v2 = *(float *)(result + 72) * (float)a2;
  uint64_t v3 = (int)vcvtms_s32_f32(v2);
  uint64_t v4 = *(void *)(result + 32);
  if (v4 >= v3 + 1) {
    uint64_t v4 = v3 + 1;
  }
  uint64_t v5 = *(void *)(result + 56);
  if (v5 >= 1)
  {
    float v6 = v2 - floorf(v2);
    int v7 = *(uint64_t **)(result + 40);
    unint64_t v8 = (unint64_t)v7[3] >> 2;
    uint64_t v9 = *v7;
    uint64_t v10 = v9 + 4 * v8 * v3;
    uint64_t v11 = v9 + 4 * v4 * v8;
    uint64_t v12 = *(void *)(result + 64);
    float v14 = *(float *)(result + 80);
    float v13 = *(float *)(result + 84);
    float v15 = *(float *)(result + 76);
    signed int v16 = (_WORD *)(**(void **)(result + 48) + 4 * a2 * (*(void *)(*(void *)(result + 48) + 24) >> 2) + 2);
    float v17 = 0.0;
    do
    {
      signed int v18 = vcvtms_s32_f32(v17);
      float v19 = v17 - floorf(v17);
      if (v12 >= v18 + 1) {
        uint64_t v20 = v18 + 1;
      }
      else {
        uint64_t v20 = v12;
      }
      int v21 = (__int16 *)(v10 + 4 * v18);
      float v22 = (__int16 *)(v10 + 4 * v20);
      float v23 = (__int16 *)(v11 + 4 * v18);
      float v24 = (__int16 *)(v11 + 4 * v20);
      _H6 = *v21;
      __asm { FCVT            S6, H6 }
      _H7 = *v22;
      __asm { FCVT            S7, H7 }
      _H16 = *v23;
      float v34 = _S6 + (float)(v19 * (float)(_S7 - _S6));
      __asm { FCVT            S7, H16 }
      _H16 = *v24;
      __asm { FCVT            S16, H16 }
      _H17 = v21[1];
      float v39 = _S7 + (float)(v19 * (float)(_S16 - _S7));
      __asm { FCVT            S16, H17 }
      _H17 = v22[1];
      __asm { FCVT            S17, H17 }
      float v43 = _S16 + (float)(v19 * (float)(_S17 - _S16));
      LOWORD(_S17) = v23[1];
      __asm { FCVT            S17, H17 }
      _H18 = v24[1];
      __asm { FCVT            S18, H18 }
      _S6 = (float)(v34 + (float)(v6 * (float)(v39 - v34))) * v14;
      __asm { FCVT            H6, S6 }
      *(v16 - 1) = LOWORD(_S6);
      _S5 = v13 * (float)(v43 + (float)(v6 * (float)((float)(_S17 + (float)(v19 * (float)(_S18 - _S17))) - v43)));
      __asm { FCVT            H5, S5 }
      *signed int v16 = LOWORD(_S5);
      float v17 = v17 + v15;
      v16 += 2;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_1A40524E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40528F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A4052E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

id getVCPRequestFrameWidthPropertyKey(void)
{
  uint64_t v5 = 0;
  float v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v0 = (void **)getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr;
  uint64_t v8 = getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr;
  if (!getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)VideoProcessingLibrary();
    v6[3] = (uint64_t)dlsym(v1, "VCPRequestFrameWidthPropertyKey");
    getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr = v6[3];
    int v0 = (void **)v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (!v0)
  {
    dlerror();
    uint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v5, 8);
    _Unwind_Resume(v4);
  }
  float v2 = *v0;

  return v2;
}

id getVCPRequestFrameHeightPropertyKey(void)
{
  uint64_t v5 = 0;
  float v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v0 = (void **)getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr;
  uint64_t v8 = getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr;
  if (!getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)VideoProcessingLibrary();
    v6[3] = (uint64_t)dlsym(v1, "VCPRequestFrameHeightPropertyKey");
    getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr = v6[3];
    int v0 = (void **)v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (!v0)
  {
    dlerror();
    uint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v5, 8);
    _Unwind_Resume(v4);
  }
  float v2 = *v0;

  return v2;
}

id getVCPRequestMotionFlowComputationAccuracyPropertyKey(void)
{
  uint64_t v5 = 0;
  float v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v0 = (void **)getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLoc(void)::ptr;
  uint64_t v8 = getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLoc(void)::ptr;
  if (!getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)MediaAnalysisLibrary();
    v6[3] = (uint64_t)dlsym(v1, "VCPRequestMotionFlowComputationAccuracyPropertyKey");
    getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLoc(void)::ptr = v6[3];
    int v0 = (void **)v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (!v0)
  {
    dlerror();
    uint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v5, 8);
    _Unwind_Resume(v4);
  }
  float v2 = *v0;

  return v2;
}

id getVCPRequestForceCPUPropertyKey(void)
{
  uint64_t v5 = 0;
  float v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v0 = (void **)getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr;
  uint64_t v8 = getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr;
  if (!getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)VideoProcessingLibrary();
    v6[3] = (uint64_t)dlsym(v1, "VCPRequestForceCPUPropertyKey");
    getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr = v6[3];
    int v0 = (void **)v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (!v0)
  {
    dlerror();
    uint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v5, 8);
    _Unwind_Resume(v4);
  }
  float v2 = *v0;

  return v2;
}

id getVCPMotionFlowRequestClass(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  int v0 = (void *)getVCPMotionFlowRequestClass(void)::softClass;
  uint64_t v7 = getVCPMotionFlowRequestClass(void)::softClass;
  if (!getVCPMotionFlowRequestClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL28getVCPMotionFlowRequestClassv_block_invoke;
    v3[3] = &unk_1E5B20220;
    v3[4] = &v4;
    ___ZL28getVCPMotionFlowRequestClassv_block_invoke((uint64_t)v3);
    int v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_1A4053428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class ___ZL28getVCPMotionFlowRequestClassv_block_invoke(uint64_t a1)
{
  MediaAnalysisLibrary();
  Class result = objc_getClass("VCPMotionFlowRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getVCPMotionFlowRequestClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    return (Class)MediaAnalysisLibrary();
  }
  return result;
}

uint64_t MediaAnalysisLibrary(void)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!MediaAnalysisLibraryCore(char **)::frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = ___ZL24MediaAnalysisLibraryCorePPc_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E5B1F640;
    uint64_t v5 = 0;
    MediaAnalysisLibraryCore(char **)::frameworkLibrardouble y = _sl_dlopen();
    id v1 = (void *)v3[0];
    uint64_t v0 = MediaAnalysisLibraryCore(char **)::frameworkLibrary;
    if (MediaAnalysisLibraryCore(char **)::frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      id v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return MediaAnalysisLibraryCore(char **)::frameworkLibrary;
}

uint64_t ___ZL24MediaAnalysisLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  MediaAnalysisLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

void *___ZL41getVCPRequestForceCPUPropertyKeySymbolLocv_block_invoke_32739(uint64_t a1)
{
  float v2 = (void *)VideoProcessingLibrary();
  uint64_t result = dlsym(v2, "VCPRequestForceCPUPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL26VideoProcessingLibraryCorePPc_block_invoke_32743()
{
  uint64_t result = _sl_dlopen();
  VideoProcessingLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

void *___ZL62getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLocv_block_invoke(uint64_t a1)
{
  float v2 = (void *)MediaAnalysisLibrary();
  uint64_t result = dlsym(v2, "VCPRequestMotionFlowComputationAccuracyPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                        + 24);
  return result;
}

void *___ZL44getVCPRequestFrameHeightPropertyKeySymbolLocv_block_invoke_32748(uint64_t a1)
{
  float v2 = (void *)VideoProcessingLibrary();
  uint64_t result = dlsym(v2, "VCPRequestFrameHeightPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getVCPRequestFrameWidthPropertyKeySymbolLocv_block_invoke_32751(uint64_t a1)
{
  float v2 = (void *)VideoProcessingLibrary();
  uint64_t result = dlsym(v2, "VCPRequestFrameWidthPropertyKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1A4053E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A4053F88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A405405C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054138(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40541DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054258(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40542D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054350(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40543CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054448(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40544C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054540(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40545BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054638(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40546B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40549AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054B54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054D1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4054E04(_Unwind_Exception *a1)
{
  long long v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A4054E7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A405509C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4055274(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4055320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A40553D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A4055494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A4055554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A4055608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A4055710(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  float v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1A40557EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A40558B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A4055970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A4055A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A4055AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A4055BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4055D40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t vision::mod::readBinSerializedModelValues(char *a1, unint64_t *a2, void *a3)
{
  if (!a1)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    uint64_t v10 = 381;
    goto LABEL_10;
  }
  uint64_t v6 = fopen(a1, "rb");
  if (!v6)
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, a1);
    if (v12 < 0) {
      operator delete(__p);
    }
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    uint64_t v10 = 373;
LABEL_10:
    *exceptiouint64_t n = v10;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  uint64_t v7 = v6;
  vision::mod::readBinSerializedModelValues(v6, 0, a2, a3);

  return fclose(v7);
}

void vision::mod::readBinSerializedModelValues(FILE *a1, const char *a2, unint64_t *a3, void *a4)
{
  if (!a1)
  {
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    *exceptiouint64_t n = 381;
    __cxa_throw(exception, MEMORY[0x1E4FBA3E0], 0);
  }
  if (a2)
  {
    std::string::basic_string[abi:ne180100]<0>(&v40, "::");
    std::string::size_type v8 = strlen(a2);
    uint64_t v9 = std::string::insert(&v40, 0, a2, v8);
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t v42 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v41 = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(v41, "");
  }
  if (*a3)
  {
    unint64_t v11 = 0;
    do
    {
      char v12 = *(const void **)(a3[1] + 8 * v11);
      if (v42 >= 0) {
        size_t v13 = HIBYTE(v42);
      }
      else {
        size_t v13 = (size_t)v41[1];
      }
      size_t v14 = strlen(*(const char **)(a3[1] + 8 * v11));
      std::string::basic_string[abi:ne180100]((uint64_t)&v40, v13 + v14);
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float v15 = &v40;
      }
      else {
        float v15 = (std::string *)v40.__r_.__value_.__r.__words[0];
      }
      if (v13)
      {
        if (v42 >= 0) {
          signed int v16 = v41;
        }
        else {
          signed int v16 = (void **)v41[0];
        }
        memmove(v15, v16, v13);
      }
      float v17 = (char *)v15 + v13;
      if (v14) {
        memmove(v17, v12, v14);
      }
      v17[v14] = 0;
      if (!std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a4, (unsigned __int8 *)&v40))
      {
        __p.__r_.__value_.__r.__words[0] = 0;
        float v39 = 0;
        if (fseek(a1, 0, 0) == -1)
        {
          int v35 = __cxa_allocate_exception(8uLL);
          *int v35 = 373;
          __cxa_throw(v35, MEMORY[0x1E4FBA3E0], 0);
        }
        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          signed int v18 = &v40;
        }
        else {
          signed int v18 = (std::string *)v40.__r_.__value_.__r.__words[0];
        }
        if (BinSerializer_freadInFloat(a1, v18, 1, &v39, (size_t *)&__p) == 128) {
          operator new();
        }
      }
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      ++v11;
    }
    while (v11 < *a3);
  }
  if (a3[2])
  {
    unint64_t v19 = 0;
    do
    {
      uint64_t v20 = *(const void **)(a3[3] + 8 * v19);
      if (v42 >= 0) {
        size_t v21 = HIBYTE(v42);
      }
      else {
        size_t v21 = (size_t)v41[1];
      }
      size_t v22 = strlen(*(const char **)(a3[3] + 8 * v19));
      std::string::basic_string[abi:ne180100]((uint64_t)&v40, v21 + v22);
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float v23 = &v40;
      }
      else {
        float v23 = (std::string *)v40.__r_.__value_.__r.__words[0];
      }
      if (v21)
      {
        if (v42 >= 0) {
          float v24 = v41;
        }
        else {
          float v24 = (void **)v41[0];
        }
        memmove(v23, v24, v21);
      }
      float v25 = (char *)v23 + v21;
      if (v22) {
        memmove(v25, v20, v22);
      }
      v25[v22] = 0;
      if (!std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a4, (unsigned __int8 *)&v40))
      {
        __p.__r_.__value_.__r.__words[0] = 0;
        float v39 = 0;
        if (fseek(a1, 0, 0) == -1)
        {
          uint64_t v36 = __cxa_allocate_exception(8uLL);
          *uint64_t v36 = 373;
          __cxa_throw(v36, MEMORY[0x1E4FBA3E0], 0);
        }
        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          float v26 = &v40;
        }
        else {
          float v26 = (std::string *)v40.__r_.__value_.__r.__words[0];
        }
        if (BinSerializer_freadInBytes(a1, v26, &v39, (size_t *)&__p) == 128) {
          operator new();
        }
      }
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      ++v19;
    }
    while (v19 < a3[2]);
  }
  if (a3[4])
  {
    uint64_t v27 = 0;
    unint64_t v28 = 0;
    do
    {
      int v29 = *(char **)(a3[5] + 8 * v28);
      if (a2)
      {
        if (v29)
        {
          std::string::basic_string[abi:ne180100]<0>(&__p, v29);
          if (v42 >= 0) {
            float v30 = v41;
          }
          else {
            float v30 = (void **)v41[0];
          }
          if (v42 >= 0) {
            std::string::size_type v31 = HIBYTE(v42);
          }
          else {
            std::string::size_type v31 = (std::string::size_type)v41[1];
          }
          int v32 = std::string::insert(&__p, 0, (const std::string::value_type *)v30, v31);
          long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
          v40.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v33;
          v32->__r_.__value_.__l.__size_ = 0;
          v32->__r_.__value_.__r.__words[2] = 0;
          v32->__r_.__value_.__r.__words[0] = 0;
          if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            float v34 = &v40;
          }
          else {
            float v34 = (std::string *)v40.__r_.__value_.__r.__words[0];
          }
          vision::mod::readBinSerializedModelValues(a1, v34, a3[6] + v27, a4);
          if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v40.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          vision::mod::readBinSerializedModelValues(a1, a2, a3[6] + v27, a4);
        }
      }
      else
      {
        vision::mod::readBinSerializedModelValues(a1, v29, a3[6] + v27, a4);
      }
      ++v28;
      v27 += 56;
    }
    while (v28 < a3[4]);
  }
  if (SHIBYTE(v42) < 0) {
    operator delete(v41[0]);
  }
}

void sub_1A4056358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A405636C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v25);
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    JUMPOUT(0x1A405642CLL);
  }
  JUMPOUT(0x1A4056430);
}

void sub_1A40563A4(void *a1)
{
  __cxa_begin_catch(a1);
  free(v1);
  __cxa_rethrow();
}

void sub_1A40563B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    JUMPOUT(0x1A4056408);
  }
  JUMPOUT(0x1A4056420);
}

void sub_1A40563C8()
{
}

void sub_1A40563E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    JUMPOUT(0x1A4056408);
  }
  if (a28 < 0) {
    JUMPOUT(0x1A405642CLL);
  }
  JUMPOUT(0x1A4056430);
}

void sub_1A4056410()
{
}

uint64_t std::__shared_ptr_pointer<unsigned char *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_1,std::allocator<unsigned char>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"ZN6vision3mod28readBinSerializedModelValuesEP7__sFILEPKcRKNS0_26BinSerializedModelFileInfoERNS0_11ModelValuesEbE3$_1"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::__shared_ptr_pointer<unsigned char *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_1,std::allocator<unsigned char>>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_pointer<unsigned char *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_1,std::allocator<unsigned char>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

uint64_t std::__shared_ptr_pointer<float *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_0,std::allocator<float>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(void *)(a2 + 8), (uint64_t)"ZN6vision3mod28readBinSerializedModelValuesEP7__sFILEPKcRKNS0_26BinSerializedModelFileInfoERNS0_11ModelValuesEbE3$_0"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::__shared_ptr_pointer<float *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_0,std::allocator<float>>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_pointer<float *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_0,std::allocator<float>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void sub_1A405661C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40566DC(_Unwind_Exception *a1)
{
}

void sub_1A40566FC(void *a1)
{
}

void sub_1A4056A48(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A40569FCLL);
}

void sub_1A4056C50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4056D74(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A4056D30);
}

void sub_1A4056EC4(void *exc_buf)
{
}

void sub_1A40570D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A4057394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40574D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A405765C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4057730(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40577D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4057894(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4057A48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4057BF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4057D68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _Unwind_Resume(a1);
}

void sub_1A4057ED0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4058058(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A405812C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40581D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void vision::mod::Face3D::~Face3D(vision::mod::Face3D *this)
{
  uint64_t v2 = *((void *)this + 6);
  if (v2) {
    MEMORY[0x1A62562A0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  long long v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void sub_1A4058B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  _Unwind_Resume(a1);
}

void sub_1A4058D34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4058E08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4058EA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4058FBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A405907C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Projections_computeShiftBruteForce(uint64_t a1, int a2, void *a3, uint64_t a4, int a5, void *a6, int a7, float *a8, float *a9)
{
  size_t v13 = a9;
  if (a2 <= a5) {
    int v14 = a5;
  }
  else {
    int v14 = a2;
  }
  size_t v15 = 8 * v14;
  uint64_t v78 = (float *)malloc_type_malloc(v15, 0x100004052888210uLL);
  signed int v16 = (float *)malloc_type_malloc(v15, 0x100004052888210uLL);
  *signed int v16 = 3.4028e38;
  int v17 = 1 - a2;
  uint64_t v79 = a8;
  float v18 = *a8;
  float v19 = 0.0;
  if (*a8 >= (float)(1 - a2))
  {
    float v21 = (float)(a5 - 1);
    uint64_t v20 = v78;
    if (v18 <= v21)
    {
      float v22 = v18 - (float)v17;
      float v23 = v21 - v18;
      if (v22 > v23) {
        float v23 = v22;
      }
      float v19 = 0.0 / v23;
    }
  }
  else
  {
    uint64_t v20 = v78;
  }
  if (v17 >= a5)
  {
    int v63 = 0;
    float v60 = 3.4028e38;
  }
  else
  {
    uint64_t v24 = 0;
    uint64_t v25 = (a5 + a2 - 1);
    int v26 = a2 - 1;
    int v72 = a7;
    int v73 = a5 - 1;
    int v27 = -a2;
    int32x2_t v28 = vdup_n_s32(0x7F7FFFFFu);
    __asm { FMOV            V11.2S, #1.0 }
    int v34 = a2 - 1;
    int v71 = a5 + a2 - 2;
    int v35 = v71;
    do
    {
      int v36 = v27 + v24 + 1;
      int v37 = v17 & ~(v17 >> 31);
      if (v35 >= v26) {
        int v38 = v26;
      }
      else {
        int v38 = v35;
      }
      int v39 = v27 + v24 + v38 - v37 + 2;
      if (v39 >= a7)
      {
        unsigned int v42 = v37 + v34;
        int v43 = v73;
        if (v73 >= (int)v24) {
          int v43 = v24;
        }
        int v82 = v43;
        unsigned int v80 = v42;
        unsigned int v81 = v36 & ~(v36 >> 31);
        float v44 = *v79;
        __C[0] = 0.0;
        uint64_t v45 = v16;
        uint64_t v46 = v25;
        int v47 = v17;
        vDSP_dotpr((const float *)(a1 + 4 * v42), 1, (const float *)(a4 + 4 * v81), 1, __C, v39);
        int v17 = v47;
        uint64_t v25 = v46;
        a7 = v72;
        signed int v16 = v45;
        uint64_t v20 = v78;
        __C[0] = __C[0] / (float)v39;
        float v48 = (float)(*(float *)(*a3 + 4 * (v38 + 1)) - *(float *)(*a3 + 4 * (int)v80)) / (float)v39;
        *(float *)v49.i32 = (float)((float)((float)(*(float *)(a3[1] + 4 * (v38 + 1))
                                                  - *(float *)(a3[1] + 4 * (int)v80))
                                          / (float)v39)
                                  - (float)(v48 * v48))
                          + 0.0;
        float32x2_t v50 = (float32x2_t)vdup_lane_s32(v49, 0);
        int8x8_t v51 = (int8x8_t)vceqz_f32(v50);
        int8x8_t v52 = (int8x8_t)vcgt_s32((int32x2_t)v50, v28);
        float32x2_t v53 = vrsqrte_f32(v50);
        float32x2_t v54 = (float32x2_t)vorr_s8(v52, v51);
        float32x2_t v55 = vmul_f32((float32x2_t)v49, (float32x2_t)vbsl_s8((int8x8_t)v54, _D11, (int8x8_t)vmul_f32(v53, vrsqrts_f32(v53, vmul_n_f32(v53, *(float *)v49.i32)))));
        *(float *)v52.i32 = (float)(int)(v82 - v81 + 1);
        v53.f32[0] = (float)(*(float *)(*a6 + 4 * (v82 + 1)) - *(float *)(*a6 + 4 * v81)) / *(float *)v52.i32;
        v54.f32[0] = (float)((float)((float)(*(float *)(a6[1] + 4 * (v82 + 1)) - *(float *)(a6[1] + 4 * v81))
                                   / *(float *)v52.i32)
                           - (float)(v53.f32[0] * v53.f32[0]))
                   + 0.0;
        float32x2_t v56 = (float32x2_t)vdup_lane_s32((int32x2_t)v54, 0);
        int8x8_t v57 = (int8x8_t)vceqz_f32(v56);
        int8x8_t v58 = (int8x8_t)vcgt_s32((int32x2_t)v56, v28);
        float32x2_t v59 = vrsqrte_f32(v56);
        v54.f32[0] = vmul_f32(v55, vmul_f32(v54, (float32x2_t)vbsl_s8(vorr_s8(v58, v57), _D11, (int8x8_t)vmul_f32(v59, vrsqrts_f32(v59, vmul_n_f32(v59, v54.f32[0])))))).f32[0];
        float v40 = (float)(v27 + v24 + 1);
        float v41 = (float)((float)((float)(v54.f32[0] - __C[0]) + (float)(v48 * v53.f32[0]))
                    / (float)(v54.f32[0] + v54.f32[0]))
            + (float)(v19 * vabds_f32(v44, v40));
      }
      else
      {
        float v40 = (float)v36;
        float v41 = 3.4028e38;
      }
      v20[v24] = v40;
      v16[v24++] = v41;
      ++v17;
      --v35;
      --v34;
    }
    while (v25 != v24);
    float v60 = *v16;
    size_t v13 = a9;
    if (v25 < 2)
    {
      int v63 = 0;
    }
    else
    {
      char v61 = 0;
      int v62 = 0;
      int v63 = 0;
      float v64 = 3.4028e38;
      uint64_t v65 = 1;
LABEL_23:
      uint64_t v66 = &v16[v65];
      do
      {
        float v67 = *v66;
        if (v60 > *v66)
        {
          int v63 = (int)v20[v65];
          float v60 = *v66;
        }
        uint64_t v68 = v65 + 1;
        if (v65 < v71 && v64 > v67 && *(v66 - 1) > v67 && v66[1] > v67)
        {
          int v62 = (int)v20[v65];
          char v61 = 1;
          ++v65;
          float v64 = *v66;
          if (v68 != v25) {
            goto LABEL_23;
          }
          *uint64_t v79 = (float)v62;
          *a9 = v67;
          goto LABEL_42;
        }
        ++v66;
        ++v65;
      }
      while (v25 != v68);
      if (v61) {
        goto LABEL_41;
      }
    }
  }
  int v62 = v63;
  float v64 = v60;
LABEL_41:
  *uint64_t v79 = (float)v62;
  *size_t v13 = v64;
  if (v20)
  {
LABEL_42:
    unsigned int v70 = v16;
    free(v20);
    signed int v16 = v70;
  }

  free(v16);
}

void sub_1A405A438(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *exc_bufa, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  if (a2)
  {

    objc_begin_catch(a1);
    JUMPOUT(0x1A405A158);
  }
  _Unwind_Resume(a1);
}

void sub_1A405B12C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24)
{
  if (__p) {
    operator delete(__p);
  }
  MEMORY[0x1A62562A0](v24, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_1A405B4B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A405BB78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20,void *a21,void *a22,uint64_t a23,void *a24)
{
  _Unwind_Resume(a1);
}

void sub_1A405BD8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A405C128(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A405C3D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A405C57C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_WORD *reverseCopy(_WORD *__dst, char *__src, int a3, int a4)
{
  int v4 = a4;
  uint64_t v6 = __dst;
  switch(a3)
  {
    case 1:
      if (a4 >= 1)
      {
        do
        {
          char v7 = *__src--;
          *(unsigned char *)uint64_t v6 = v7;
          uint64_t v6 = (_WORD *)((char *)v6 + 1);
          --v4;
        }
        while (v4);
      }
      break;
    case 2:
      if (a4 >= 1)
      {
        do
        {
          __int16 v8 = *(_WORD *)__src;
          __src -= 2;
          *v6++ = v8;
          --v4;
        }
        while (v4);
      }
      break;
    case 4:
      if (a4 >= 1)
      {
        do
        {
          int v11 = *(_DWORD *)__src;
          __src -= 4;
          *(_DWORD *)uint64_t v6 = v11;
          v6 += 2;
          --v4;
        }
        while (v4);
      }
      break;
    case 8:
      if (a4 >= 1)
      {
        do
        {
          uint64_t v12 = *(void *)__src;
          __src -= 8;
          *(void *)uint64_t v6 = v12;
          v6 += 4;
          --v4;
        }
        while (v4);
      }
      break;
    default:
      if (a4 >= 1)
      {
        size_t v9 = a3;
        uint64_t v10 = -(uint64_t)a3;
        do
        {
          long long __dst = memcpy(v6, __src, v9);
          uint64_t v6 = (_WORD *)((char *)v6 + v9);
          __src += v10;
          --v4;
        }
        while (v4);
      }
      break;
  }
  return __dst;
}

void saveImage(const char *a1, uint64_t a2)
{
  CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceRGB();
  uint64_t v5 = CGDataProviderCreateWithData(0, *(const void **)a2, *(void *)(a2 + 16) * *(void *)(a2 + 24), 0);
  unsigned int v6 = *(_DWORD *)(a2 + 32) - 2;
  if (v6 > 5) {
    CGBitmapInfo v7 = 0;
  }
  else {
    CGBitmapInfo v7 = dword_1A41245C4[v6];
  }
  __int16 v8 = CGImageCreate(*(void *)(a2 + 8), *(void *)(a2 + 16), 8uLL, 0x20uLL, *(void *)(a2 + 24), DeviceRGB, v7, v5, 0, 0, kCGRenderingIntentDefault);
  CFIndex v9 = strlen(a1);
  CFURLRef v10 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)a1, v9, 0);
  if (v10)
  {
    CFURLRef v11 = v10;
    uint64_t v12 = CGImageDestinationCreateWithURL(v10, @"public.png", 1uLL, 0);
    if (v12)
    {
      size_t v13 = v12;
      CGImageDestinationAddImage(v12, v8, 0);
      CGImageDestinationFinalize(v13);
      CFRelease(v13);
    }
    CFRelease(v11);
  }
  CGDataProviderRelease(v5);
  CGImageRelease(v8);

  CGColorSpaceRelease(DeviceRGB);
}

void saveY(const char *a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  if (v2 == 4 || v2 == 1)
  {
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    if (v2 == 1 || v2 == 4)
    {
      uint64_t v6 = *(void *)(a2 + 8);
      uint64_t v7 = *(void *)(a2 + 16);
      v20[1] = v6;
      v20[2] = v7;
      unint64_t v8 = (4 * v6 + 12) & 0xFFFFFFFFFFFFFFF0;
      v20[3] = v8;
      LODWORD(v21) = 2;
      if (v8 * v7)
      {
        CFURLRef v10 = malloc_type_calloc(v8 * v7, 1uLL, 0x100004077774924uLL);
        v20[0] = v10;
        if (v10)
        {
          CFURLRef v11 = v10;
          if ((int)v7 > 0)
          {
            int v12 = 0;
            size_t v13 = *(char **)a2;
            if ((int)v6 <= 1) {
              int v14 = 1;
            }
            else {
              int v14 = v6;
            }
            size_t v15 = (char *)v10;
            do
            {
              int v16 = v14;
              int v17 = v15;
              float v18 = v13;
              if ((int)v6 >= 1)
              {
                do
                {
                  char *v17 = *v18;
                  v17[1] = *v18;
                  char v19 = *v18++;
                  v17[2] = v19;
                  v17[3] = -1;
                  v17 += 4;
                  --v16;
                }
                while (v16);
              }
              ++v12;
              v13 += *(void *)(a2 + 24);
              v15 += v8;
            }
            while (v12 < (int)v7);
          }
          saveImage(a1, (uint64_t)v20);
          free(v11);
        }
        else
        {
          printf("convertYUV420ToRGBA8888: failed to allocate %lu bytes\n");
        }
      }
      else
      {
        printf("convertYUV420ToRGBA8888: invalid dst size of %lu x %lu\n");
      }
    }
    else
    {
      puts("convertYUV420ToRGBA8888: src must be YUV420 format!");
    }
  }
}

const char *saveCVPixelBuffer(const char *result, CVPixelBufferRef pixelBuffer)
{
  if (pixelBuffer)
  {
    int v2 = pixelBuffer;
    uint64_t v3 = result;
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
    CVPixelBufferLockBaseAddress(v2, 1uLL);
    if (PixelFormatType > 1111970368)
    {
      switch(PixelFormatType)
      {
        case 1111970369:
          int v34 = 7;
          break;
        case 1278226488:
          LODWORD(v41) = 4;
          size_t Width = CVPixelBufferGetWidth(v2);
          size_t Height = CVPixelBufferGetHeight(v2);
          BaseAddress = CVPixelBufferGetBaseAddress(v2);
          uint64_t v42 = 0;
          size_t BytesPerRow = CVPixelBufferGetBytesPerRow(v2);
          saveY(v3, (uint64_t)&BaseAddress);
          return (const char *)CVPixelBufferUnlockBaseAddress(v2, 1uLL);
        case 1380401729:
          int v34 = 2;
          break;
        default:
          return (const char *)CVPixelBufferUnlockBaseAddress(v2, 1uLL);
      }
    }
    else
    {
      if (PixelFormatType != 32)
      {
        if (PixelFormatType == 875704422 || PixelFormatType == 875704438)
        {
          size_t v5 = CVPixelBufferGetWidth(v2);
          unint64_t v6 = CVPixelBufferGetHeight(v2);
          BaseAddressOfPlane = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(v2, 0);
          unint64_t v8 = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(v2, 1uLL);
          int v35 = v2;
          size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v2, 0);
          uint64_t v42 = 0;
          size_t Width = v5;
          size_t Height = v6;
          uint64_t v10 = 4 * v5;
          size_t BytesPerRow = 4 * v5;
          uint64_t v41 = 2;
          int v36 = (char *)malloc_type_calloc(4 * v5, v6, 0xF81350A0uLL);
          BaseAddress = v36;
          if (v6)
          {
            LODWORD(v11) = 0;
            int v12 = v36 + 7;
            v13.i64[0] = 0x10000000100;
            v13.i64[1] = 0x10000000100;
            v14.i64[0] = 0xFF000000FFLL;
            v14.i64[1] = 0xFF000000FFLL;
            size_t v15 = v5;
            do
            {
              if (v15)
              {
                unsigned int v16 = 2;
                int v17 = v12;
                size_t v18 = BytesPerRowOfPlane;
                uint64_t v19 = 1;
                do
                {
                  int v20 = v8[v19] - 128;
                  unsigned int v21 = 717 * v20 + 256;
                  int v22 = v8[v19 - 1] - 128;
                  unsigned int v23 = -176 * v22 - 365 * v20;
                  unsigned int v24 = 904 * v22 + 256;
                  v25.i32[0] = BaseAddressOfPlane[v18];
                  v25.i32[1] = BaseAddressOfPlane[v18 + 1];
                  v26.u64[1] = (unint64_t)vshl_n_s32(v25, 9uLL);
                  v26.i32[0] = BaseAddressOfPlane[v19 - 1] << 9;
                  v26.i32[1] = BaseAddressOfPlane[v19] << 9;
                  v27.i32[0] = (int)(v24 + v26.i32[0]) >> 9;
                  v27.i32[1] = (int)(v24 + v26.i32[1]) >> 9;
                  v27.u64[1] = (unint64_t)vshr_n_s32(vadd_s32(vdup_n_s32(v24), (int32x2_t)v26.u64[1]), 9uLL);
                  int32x4_t v28 = vminq_s32(vmaxq_s32(vshrq_n_s32(vaddq_s32(vdupq_n_s32(v21), v26), 9uLL), (int32x4_t)0), v14);
                  int32x4_t v29 = vminq_s32(vmaxq_s32(vshrq_n_s32(vaddq_s32(vaddq_s32(vdupq_n_s32(v23), v13), v26), 9uLL), (int32x4_t)0), v14);
                  int32x4_t v30 = vminq_s32(vmaxq_s32(v27, (int32x4_t)0), v14);
                  *(v17 - 7) = v28.i8[0];
                  *(v17 - 6) = v29.i8[0];
                  *(v17 - 5) = v30.i8[0];
                  *(v17 - 4) = -1;
                  size_t v31 = v16 - 1;
                  if (v5 > v31)
                  {
                    *(v17 - 3) = v28.i8[4];
                    *(v17 - 2) = v29.i8[4];
                    *(v17 - 1) = v30.i8[4];
                    unsigned char *v17 = -1;
                  }
                  if (v6 > (v11 | 1))
                  {
                    int v32 = &v17[v10];
                    v17[v10 - 7] = v28.i8[8];
                    v17[v10 - 6] = v29.i8[8];
                    v17[v10 - 5] = v30.i8[8];
                    v17[v10 - 4] = -1;
                    if (v5 > v31)
                    {
                      *(v32 - 3) = v28.i8[12];
                      *(v32 - 2) = v29.i8[12];
                      *(v32 - 1) = v30.i8[12];
                      unsigned char *v32 = -1;
                    }
                  }
                  BOOL v33 = v5 > v16;
                  v16 += 2;
                  v18 += 2;
                  v17 += 8;
                  v19 += 2;
                }
                while (v33);
                size_t v15 = v5;
              }
              unint64_t v11 = (v11 + 2);
              BaseAddressOfPlane += 2 * BytesPerRowOfPlane;
              v8 += BytesPerRowOfPlane;
              v12 += 8 * v5;
            }
            while (v6 > v11);
          }
          saveImage(v3, (uint64_t)&BaseAddress);
          if (v36) {
            free(v36);
          }
          int v2 = v35;
        }
        return (const char *)CVPixelBufferUnlockBaseAddress(v2, 1uLL);
      }
      int v34 = 3;
    }
    LODWORD(v41) = v34;
    size_t Width = CVPixelBufferGetWidth(v2);
    size_t Height = CVPixelBufferGetHeight(v2);
    BaseAddress = CVPixelBufferGetBaseAddress(v2);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(v2);
    saveImage(v3, (uint64_t)&BaseAddress);
    return (const char *)CVPixelBufferUnlockBaseAddress(v2, 1uLL);
  }
  return result;
}

void saveVImage(const char *a1, unsigned __int8 **a2, int a3)
{
  long long v26 = 0u;
  memset(v25, 0, sizeof(v25));
  if (a3 <= 1278226533)
  {
    if (a3 == 32)
    {
      int v5 = 3;
    }
    else
    {
      if (a3 != 1111970369)
      {
        if (a3 == 1278226488)
        {
          LODWORD(v26) = 1;
          *(int8x16_t *)((char *)v25 + 8) = vextq_s8(*(int8x16_t *)(a2 + 1), *(int8x16_t *)(a2 + 1), 8uLL);
          *(void *)&v25[0] = *a2;
          *((void *)&v25[1] + 1) = a2[3];
          saveY(a1, (uint64_t)v25);
        }
        return;
      }
      int v5 = 7;
    }
LABEL_12:
    LODWORD(v26) = v5;
    *(int8x16_t *)((char *)v25 + 8) = vextq_s8(*(int8x16_t *)(a2 + 1), *(int8x16_t *)(a2 + 1), 8uLL);
    *(void *)&v25[0] = *a2;
    *((void *)&v25[1] + 1) = a2[3];
    saveImage(a1, (uint64_t)v25);
    return;
  }
  switch(a3)
  {
    case 1278226534:
      LODWORD(v26) = 1;
      size_t v6 = (size_t)a2[1];
      uint64_t v7 = a2[2];
      *((void *)&v25[0] + 1) = v7;
      *(void *)&v25[1] = v6;
      *((void *)&v25[1] + 1) = (unint64_t)(v7 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v8 = malloc_type_calloc(*((size_t *)&v25[1] + 1), v6, 0x333A50DuLL);
      CFIndex v9 = v8;
      *(void *)&v25[0] = v8;
      *((void *)&v26 + 1) = 0;
      if (v6)
      {
        uint64_t v10 = 0;
        uint64_t v11 = (uint64_t)*a2;
        int v12 = v8;
        do
        {
          if (v7)
          {
            for (int i = 0; i != v7; ++i)
            {
              double v14 = fmax(*(float *)(v11 + 4 * i), 0.0);
              if (v14 > 1.0) {
                double v14 = 1.0;
              }
              i[(void)v12] = (int)(v14 * 255.0 + 0.5);
            }
          }
          ++v10;
          v12 += (unint64_t)(v7 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          v11 += (uint64_t)a2[3];
        }
        while (v10 != v6);
      }
      saveY(a1, (uint64_t)v25);
      size_t v15 = v9;
      break;
    case 1280061496:
      LODWORD(v26) = 1;
      int8x16_t v16 = *(int8x16_t *)(a2 + 1);
      *(int8x16_t *)((char *)v25 + 8) = vextq_s8(v16, v16, 8uLL);
      *((void *)&v25[1] + 1) = a2[3];
      uint64_t v17 = v16.i64[0];
      size_t v18 = malloc_type_calloc(*((size_t *)&v25[1] + 1), v16.u64[0], 0x4AD6B520uLL);
      uint64_t v19 = v18;
      *(void *)&v25[0] = v18;
      *((void *)&v26 + 1) = 0;
      uint64_t v20 = *((void *)&v25[1] + 1) * v17;
      if (*((void *)&v25[1] + 1) * v17)
      {
        unsigned int v21 = *a2;
        int v22 = v18;
        do
        {
          if (*v21++) {
            char v24 = -1;
          }
          else {
            char v24 = 0;
          }
          *v22++ = v24;
          --v20;
        }
        while (v20);
      }
      saveY(a1, (uint64_t)v25);
      size_t v15 = v19;
      break;
    case 1380401729:
      int v5 = 2;
      goto LABEL_12;
    default:
      return;
  }

  free(v15);
}

BOOL _isPlaneSubsampled(const __CFDictionary *a1)
{
  uint64_t v10 = 1;
  uint64_t valuePtr = 1;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F24ED0]);
  if (Value)
  {
    CFNumberRef v3 = Value;
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v3)) {
      CFNumberGetValue(v3, kCFNumberLongType, &valuePtr);
    }
  }
  CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F24EE8]);
  if (v5 && (CFNumberRef v6 = v5, v7 = CFNumberGetTypeID(), v7 == CFGetTypeID(v6)))
  {
    CFNumberGetValue(v6, kCFNumberLongType, &v10);
    BOOL v8 = v10 > 1;
  }
  else
  {
    BOOL v8 = 0;
  }
  return valuePtr > 1 || v8;
}

void VNAlignRectToSubsampledCVPixelBufferConstraint(float64x2_t *a1, CVPixelBufferRef pixelBuffer)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  CFDictionaryRef v6 = CVPixelFormatDescriptionCreateWithPixelFormatType(v4, PixelFormatType);
  if (!v6) {
    return;
  }
  CFDictionaryRef v7 = v6;
  if (!CVPixelBufferIsPlanar(pixelBuffer))
  {
    BOOL isPlaneSubsampled = _isPlaneSubsampled(v7);
    CFRelease(v7);
    if (!isPlaneSubsampled) {
      return;
    }
    goto LABEL_13;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v7, (const void *)*MEMORY[0x1E4F24EE0]);
  if (Value)
  {
    CFArrayRef v9 = Value;
    CFIndex Count = CFArrayGetCount(Value);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      CFIndex v12 = 0;
      LOBYTE(v13) = 0;
      do
      {
        ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, v12);
        BOOL v13 = v13 || _isPlaneSubsampled(ValueAtIndex);
        ++v12;
      }
      while (v11 != v12);
      CFRelease(v7);
      if (!v13) {
        return;
      }
LABEL_13:
      int32x2_t v16 = vadd_s32(vmovn_s64(vcvtq_s64_f64(a1[1])), (int32x2_t)0x100000001);
      int32x2_t v17 = vmovn_s64(vcvtq_s64_f64(*a1));
      v18.i64[0] = (int)(v17.i32[0] & 0xFFFFFFFE);
      v18.i64[1] = (int)(v17.i32[1] & 0xFFFFFFFE);
      float64x2_t v19 = vcvtq_f64_s64(v18);
      v18.i64[0] = (int)(v16.i32[0] & 0xFFFFFFFE);
      v18.i64[1] = (int)(v16.i32[1] & 0xFFFFFFFE);
      *a1 = v19;
      a1[1] = vcvtq_f64_s64(v18);
      return;
    }
  }

  CFRelease(v7);
}

id VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(uint64_t a1, void *a2, void *a3)
{
  CFNumberRef v5 = (objc_class *)MEMORY[0x1E4F1C9E8];
  id v6 = a3;
  id v7 = a2;
  id v8 = [v5 alloc];
  CFArrayRef v9 = objc_msgSend(v8, "initWithObjectsAndKeys:", v7, *MEMORY[0x1E4F28568], v6, *MEMORY[0x1E4F28A50], 0);

  uint64_t v10 = VNEntityIdentificationModelErrorWithUserInfo(a1, v9);

  return v10;
}

id VNEntityIdentificationModelErrorWithUserInfo(uint64_t a1, void *a2)
{
  CFNumberRef v3 = (objc_class *)MEMORY[0x1E4F28C58];
  id v4 = a2;
  CFNumberRef v5 = (void *)[[v3 alloc] initWithDomain:@"com.apple.vis.VNEntityIdentificationModel" code:a1 userInfo:v4];

  return v5;
}

id VNEntityIdentificationModelErrorForUnknownEntityUniqueIdentifier(uint64_t a1)
{
  id v1 = [NSString stringWithFormat:@"unknown entity (%@)", a1];
  int v2 = VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(7, v1, 0);

  return v2;
}

void sub_1A405E3A0(_Unwind_Exception *a1)
{
}

void sub_1A405E730(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1A405F624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose((const void *)(v32 - 152), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__33723(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__33724(uint64_t a1)
{
}

void ___writeVersion1EntityAndObservations_block_invoke(void *a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  id v6 = a2;
  id v7 = (void *)MEMORY[0x1A6257080]();
  id v8 = (void *)[objc_alloc(MEMORY[0x1E4F28DB0]) initRequiringSecureCoding:1];
  [v8 setOutputFormat:200];
  objc_msgSend(v8, "vn_encodeEntityUniqueIdentifier:forKey:", a1[4], @"E");
  [v8 encodeObject:v6 forKey:@"O"];
  [v8 finishEncoding];
  CFArrayRef v9 = [v8 encodedData];
  uint64_t v10 = (CC_MD5_CTX *)a1[8];
  CFIndex v11 = (void *)a1[5];
  uint64_t v12 = *(void *)(a1[6] + 8);
  double v14 = *(void **)(v12 + 40);
  BOOL v13 = (id *)(v12 + 40);
  obuint64_t j = v14;
  id v15 = v9;
  id v16 = v11;
  unint64_t v17 = [v15 length];
  if (HIDWORD(v17))
  {
    int64x2_t v18 = NSString;
    float64x2_t v19 = VNPersonsModelIOStringForTag(1160466208);
    uint64_t v20 = [v18 stringWithFormat:@"tag %@ has a data overflow to %lu bytes", v19, v17];
    VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, v20, 0);
    obuint64_t j = (id)objc_claimAutoreleasedReturnValue();

    objc_storeStrong(v13, obj);
LABEL_4:
    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 0;
    *a5 = 1;
    goto LABEL_5;
  }
  id v21 = v15;
  char v22 = VNEntityIdentificationModelIOWriteTaggedBufferToOutputStream(1160466208, (const void *)[v21 bytes], v17, v16, v10, &obj);

  objc_storeStrong(v13, obj);
  if ((v22 & 1) == 0) {
    goto LABEL_4;
  }
LABEL_5:
}

void sub_1A405FACC(_Unwind_Exception *a1)
{
}

void sub_1A406033C(_Unwind_Exception *a1)
{
}

id VNEntityIdentificationModelErrorForReadOnlyModelWithLocalizedDescription(void *a1)
{
  uint64_t v1 = (objc_class *)MEMORY[0x1E4F1C9E8];
  id v2 = a1;
  id v3 = [v1 alloc];
  id v4 = objc_msgSend(v3, "initWithObjectsAndKeys:", v2, *MEMORY[0x1E4F28568], 0);

  CFNumberRef v5 = VNEntityIdentificationModelErrorWithUserInfo(6, v4);

  return v5;
}

uint64_t VNEntityIdentificationModelApplyTagValue(void *a1, uint64_t a2, objc_class *a3, void *a4, void *a5, uint64_t a6)
{
  id v11 = a4;
  id v12 = a5;
  BOOL v13 = NSNumber;
  id v14 = a1;
  id v15 = [v13 numberWithUnsignedInt:a2];
  id v16 = [v14 objectForKeyedSubscript:v15];

  if (!v16) {
    goto LABEL_4;
  }
  if (objc_opt_isKindOfClass())
  {
    [v11 setValue:v16 forKeyPath:v12];
LABEL_4:
    a6 = 1;
    goto LABEL_7;
  }
  if (a6)
  {
    unint64_t v17 = NSString;
    int64x2_t v18 = VNPersonsModelIOStringForTag(a2);
    float64x2_t v19 = (objc_class *)objc_opt_class();
    uint64_t v20 = NSStringFromClass(v19);
    id v21 = NSStringFromClass(a3);
    char v22 = [v17 stringWithFormat:@"model data object %@ is a %@, not the expected %@", v18, v20, v21];

    VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(3, v22, 0);
    *(void *)a6 = (id)objc_claimAutoreleasedReturnValue();

    a6 = 0;
  }
LABEL_7:

  return a6;
}

uint64_t _readTaggedObjectOfClass(void *a1, uint64_t a2, uint64_t a3, void *a4, CC_MD5_CTX *a5, void *a6)
{
  id v11 = a1;
  id v12 = a4;
  id v13 = v11;
  LODWORD(v31) = 0;
  if (!VNEntityIdentificationModelIOReadUInt32FromInputStream(v13, &v31, a5, a6))
  {

    id v17 = 0;
LABEL_13:
    uint64_t v19 = 0;
    goto LABEL_14;
  }
  id v14 = objc_alloc(MEMORY[0x1E4F1CA58]);
  id v15 = (id) [v14 initWithLength:v31];
  id v16 = (const void *)[v15 mutableBytes];
  if (v16)
  {
    if (VNEntityIdentificationModelIOReadBufferFromInputStream(v13, v31, v16, a5, a6))
    {
      id v17 = v15;
      goto LABEL_9;
    }
  }
  else if (a6)
  {
    +[VNError errorForMemoryAllocationFailure];
    id v17 = 0;
    *a6 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_9;
  }
  id v17 = 0;
LABEL_9:

  if (!v17) {
    goto LABEL_13;
  }
  uint64_t v31 = 0;
  uint64_t v32 = &v31;
  uint64_t v33 = 0x3032000000;
  int v34 = __Block_byref_object_copy__33723;
  int v35 = __Block_byref_object_dispose__33724;
  id v36 = 0;
  uint64_t v23 = MEMORY[0x1E4F143A8];
  uint64_t v24 = 3221225472;
  int32x2_t v25 = ___readTaggedObjectOfClass_block_invoke;
  long long v26 = &unk_1E5B1F930;
  id v17 = v17;
  int v30 = a2;
  int32x4_t v28 = &v31;
  uint64_t v29 = a3;
  id v27 = v17;
  int64x2_t v18 = _Block_copy(&v23);
  uint64_t v19 = VNExecuteBlock(v18, (uint64_t)a6);
  if (v19)
  {
    uint64_t v20 = v32[5];
    id v21 = objc_msgSend(NSNumber, "numberWithUnsignedInt:", a2, v23, v24, v25, v26);
    [v12 setObject:v20 forKeyedSubscript:v21];
  }
  _Block_object_dispose(&v31, 8);

LABEL_14:
  return v19;
}

void sub_1A4061738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL ___readTaggedObjectOfClass_block_invoke(uint64_t a1, void *a2)
{
  id v4 = (void *)[objc_alloc(MEMORY[0x1E4F28DC0]) initForReadingFromData:*(void *)(a1 + 32) error:a2];
  CFNumberRef v5 = v4;
  if (v4)
  {
    [v4 setRequiresSecureCoding:1];
    [v5 setDecodingFailurePolicy:1];
    if (*(_DWORD *)(a1 + 56) == 1953326188) {
      [v5 setClass:objc_opt_class() forClassName:@"VNEntityIdentificationModelTrainedModel"];
    }
    id v6 = (Class *)(a1 + 48);
    id v7 = (void *)[objc_alloc(MEMORY[0x1E4F1CAD0]) initWithObjects:a1 + 48 count:1];
    uint64_t v8 = *MEMORY[0x1E4F284E8];
    id v20 = 0;
    uint64_t v9 = [v5 decodeTopLevelObjectOfClasses:v7 forKey:v8 error:&v20];
    id v10 = v20;
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
    id v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v9;

    uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    BOOL v14 = v13 != 0;
    if (a2 && !v13)
    {
      if (v10)
      {
        *a2 = v10;
      }
      else
      {
        id v15 = NSString;
        id v16 = NSStringFromClass(*v6);
        id v17 = [v15 stringWithFormat:@"could not decode object of class %@", v16];
        VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, v17, 0);
        id v18 = objc_claimAutoreleasedReturnValue();
        *a2 = v18;
      }
    }
  }
  else
  {
    BOOL v14 = 0;
  }

  return v14;
}

id VNEntityIdentificationModelErrorForUnsupportedAlgorithm(void *a1)
{
  uint64_t v1 = (objc_class *)NSString;
  id v2 = a1;
  id v3 = [v1 alloc];
  id v4 = (objc_class *)objc_opt_class();

  CFNumberRef v5 = NSStringFromClass(v4);
  id v6 = (void *)[v3 initWithFormat:@"unsupported algorithm %@", v5];

  id v7 = VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(11, v6, 0);

  return v7;
}

#error "1A4062050: call analysis failed (funcsize=22)"

void sub_1A40625EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4062740(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40629F8(_Unwind_Exception *a1)
{
  id v7 = v6;

  _Unwind_Resume(a1);
}

void sub_1A4062D00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4063204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A40633F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4063864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class ___ZL30getABPKSkeletonDefinitionClassv_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = MEMORY[0x1E4F143A8];
    v4[2] = 3221225472;
    v4[3] = ___ZL32AltruisticBodyPoseKitLibraryCorePPc_block_invoke_34060;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E5B1FA38;
    uint64_t v6 = 0;
    AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrardouble y = _sl_dlopen();
    id v2 = (void *)v4[0];
    if (!AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("ABPKSkeletonDefinition");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    id v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getABPKSkeletonDefinitionClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL32AltruisticBodyPoseKitLibraryCorePPc_block_invoke_34060()
{
  uint64_t result = _sl_dlopen();
  AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

void sub_1A4063BE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4063C9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4063D44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4063DF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4063F68(_Unwind_Exception *a1)
{
  long long v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A4064088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40640F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A4064800(_Unwind_Exception *a1)
{
}

void sub_1A4065184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36)
{
  _Unwind_Resume(a1);
}

void sub_1A40653F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4065708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4065D74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p)
{
  uint64_t v24 = *(void **)(v22 - 112);
  if (v24)
  {
    *(void *)(v22 - 104) = v24;
    operator delete(v24);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<espresso_buffer_t>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753380;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A62562C0);
}

void std::__shared_ptr_emplace<espresso_buffer_t>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF753380;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A4065FEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4066070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNShotflowNetwork;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A4066150(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4066234(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4066338(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40664BC(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A4066598(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A40667BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4066A34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4066B24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4066BE4(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A4066CD0(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A4066DAC(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A4066E74(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A4067128(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4067218(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A406730C(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A40673E8(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A40674C8(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A40675C0(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A40678E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4067A34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4068024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v28);
  std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  std::__shared_weak_count::__release_shared[abi:nn180100](v26);
  std::__shared_weak_count::__release_shared[abi:nn180100](v25);
  std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A4068190(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A406829C(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A40683FC(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A406874C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A40688A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A4068DC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v25);
  std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A4068F54(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A40692B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A406940C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A406992C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v25);
  std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A4069B08(_Unwind_Exception *a1)
{
  MEMORY[0x1A62562C0](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A4069FB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A406A11C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A406A818(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  std::__shared_weak_count::__release_shared[abi:nn180100](v19);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A406A994(_Unwind_Exception *a1)
{
}

void sub_1A406AB64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL QuadDetect(const vImage_Buffer *a1, uint64_t a2, void *a3, void *a4, int *a5)
{
  uint64_t v891 = *MEMORY[0x1E4F143B8];
  vImagePixelCount height = a1->height;
  vImagePixelCount width = a1->width;
  vImagePixelCount v9 = height * width;
  *(_OWORD *)v866 = 0u;
  long long v867 = 0u;
  float v10 = *(float *)(a2 + 4) * 3.14159265 / 180.0;
  *(float *)(a2 + 76) = sinf(v10);
  float v11 = *(float *)(a2 + 24);
  if (*(float *)(a2 + 40) >= v11) {
    float v12 = *(float *)(a2 + 24);
  }
  else {
    float v12 = *(float *)(a2 + 40);
  }
  *(float *)(a2 + 40) = v12;
  float v13 = (float)(90.0 - v12) * 3.14159265 / 180.0;
  *(float *)(a2 + 80) = fabsf(sinf(v13));
  float v14 = (float)(90.0 - v11) * 3.14159265 / 180.0;
  float v15 = sinf(v14);
  float v16 = *(float *)(a2 + 12) + 1.0;
  *(float *)(a2 + 84) = fabsf(v15);
  *(float *)(a2 + 88) = v16;
  float v17 = *(float *)(a2 + 44);
  float v18 = v12 * 3.14159265 / 180.0;
  float v19 = (float)((float)(v17 * cosf(v18)) * 12.566)
      / (float)((float)((float)(v17 + 1.0) + (float)(v17 + 1.0)) * (float)((float)(v17 + 1.0) + (float)(v17 + 1.0)));
  vImagePixelCount v808 = width;
  size_t v810 = height * width;
  __NR = (void *)height;
  if ((int)height >= (int)width) {
    int v20 = width;
  }
  else {
    int v20 = height;
  }
  float v21 = *(float *)(a2 + 64) * (float)v20;
  *(float *)(a2 + 92) = v19;
  *(float *)(a2 + 96) = v21;
  float v22 = *(float *)(a2 + 28);
  *(float *)(a2 + 100) = floorf(v21 * *(float *)(a2 + 32));
  *(_DWORD *)(a2 + 104) = 1094713344;
  uint64_t v804 = a2;
  *(float *)(a2 + 108) = v22 * v22;
  uint64_t size = 4 * v9;
  __E = (float *)malloc_type_malloc(4 * v9, 0x100004052888210uLL);
  vImagePixelCount v23 = a1->height;
  vImagePixelCount v24 = a1->width;
  int v878 = v23 * v24;
  int32x2_t v25 = (char *)malloc_type_malloc(4 * v23 * v24, 0xC428C5D6uLL);
  destA.vImagePixelCount width = v24;
  destA.rowBytes = v24;
  destA.vImagePixelCount height = v23;
  destA.int data = v25;
  destR.vImagePixelCount width = v24;
  destR.rowBytes = v24;
  destR.vImagePixelCount height = v23;
  destR.int data = &v25[v23 * v24];
  destG.vImagePixelCount width = v24;
  destG.rowBytes = v24;
  destG.vImagePixelCount height = v23;
  destG.int data = &v25[2 * v23 * v24];
  destB.vImagePixelCount width = v24;
  destB.rowBytes = v24;
  destB.vImagePixelCount height = v23;
  destB.int data = &v25[3 * v23 * v24];
  vImageConvert_ARGB8888toPlanar8(a1, &destA, &destR, &destG, &destB, 0);
  long long v26 = (char *)malloc_type_malloc(12 * v23 * v24, 0x100004052888210uLL);
  dest.vImagePixelCount width = v24;
  dest.rowBytes = 4 * v24;
  dest.vImagePixelCount height = v23;
  dest.int data = v26;
  src.vImagePixelCount width = v24;
  src.rowBytes = 4 * v24;
  src.vImagePixelCount height = v23;
  src.int data = &v26[4 * v23 * v24];
  v880.vImagePixelCount width = v24;
  v880.rowBytes = 4 * v24;
  v880.vImagePixelCount height = v23;
  v880.int data = &v26[8 * v23 * v24];
  vImageConvert_Planar8toPlanarF(&destG, &dest, 255.0, 0.0, 0);
  vImageConvert_Planar8toPlanarF(&destR, &src, 255.0, 0.0, 0);
  vImageConvert_Planar8toPlanarF(&destA, &v880, 255.0, 0.0, 0);
  HIDWORD(v862) = 1112806349;
  __vImage_Buffer src = 3256219162;
  long long kernel = xmmword_1A410C460;
  long long v885 = xmmword_1A410C470;
  LODWORD(v886) = 1108735514;
  id v27 = (char *)malloc_type_malloc(12 * v23 * v24, 0x100004052888210uLL);
  v873.vImagePixelCount width = v24;
  v873.rowBytes = 4 * v24;
  v873.vImagePixelCount height = v23;
  v873.int data = v27;
  v872.vImagePixelCount width = v24;
  v872.rowBytes = 4 * v24;
  v872.vImagePixelCount height = v23;
  v872.int data = &v27[4 * v23 * v24];
  v871.vImagePixelCount width = v24;
  v871.rowBytes = 4 * v24;
  v871.vImagePixelCount height = v23;
  v871.int data = &v27[8 * v23 * v24];
  vImageConvolve_PlanarF(&dest, &v873, 0, 0, 0, (const float *)&kernel, 3u, 3u, 0.0, 4u);
  vImageConvolve_PlanarF(&src, &v872, 0, 0, 0, (const float *)&kernel, 3u, 3u, 0.0, 4u);
  vImageConvolve_PlanarF(&v880, &v871, 0, 0, 0, (const float *)&kernel, 3u, 3u, 0.0, 4u);
  vDSP_vmaxmg((const float *)v873.data, 1, (const float *)v872.data, 1, (float *)v873.data, 1, v23 * v24);
  vDSP_vmaxmg((const float *)v873.data, 1, (const float *)v871.data, 1, (float *)v873.data, 1, v23 * v24);
  vvnintf((float *)v873.data, (const float *)v873.data, &v878);
  *(_OWORD *)v881 = xmmword_1A410C480;
  *(_OWORD *)&v881[16] = xmmword_1A410C490;
  int v882 = 1108735514;
  int32x4_t v28 = (char *)malloc_type_malloc(12 * v23 * v24, 0x100004052888210uLL);
  v870.vImagePixelCount width = v24;
  v870.rowBytes = 4 * v24;
  v870.vImagePixelCount height = v23;
  v870.int data = v28;
  v869.vImagePixelCount width = v24;
  v869.rowBytes = 4 * v24;
  v869.vImagePixelCount height = v23;
  v869.int data = &v28[4 * v23 * v24];
  v868.vImagePixelCount width = v24;
  v868.rowBytes = 4 * v24;
  v868.int data = &v28[8 * v23 * v24];
  v868.vImagePixelCount height = v23;
  vImageConvolve_PlanarF(&dest, &v870, 0, 0, 0, (const float *)v881, 3u, 3u, 0.0, 4u);
  vImageConvolve_PlanarF(&src, &v869, 0, 0, 0, (const float *)v881, 3u, 3u, 0.0, 4u);
  vImageConvolve_PlanarF(&v880, &v868, 0, 0, 0, (const float *)v881, 3u, 3u, 0.0, 4u);
  vDSP_vmaxmg((const float *)v870.data, 1, (const float *)v869.data, 1, (float *)v870.data, 1, v23 * v24);
  vDSP_vmaxmg((const float *)v870.data, 1, (const float *)v868.data, 1, (float *)v870.data, 1, v23 * v24);
  vvnintf((float *)v870.data, (const float *)v870.data, &v878);
  vDSP_vmma((const float *)v873.data, 1, (const float *)v873.data, 1, (const float *)v870.data, 1, (const float *)v870.data, 1, __E, 1, v23 * v24);
  if (v25) {
    free(v25);
  }
  if (v26) {
    free(v26);
  }
  if (v27) {
    free(v27);
  }
  if (v28) {
    free(v28);
  }
  destG.vImagePixelCount width = v808;
  destG.vImagePixelCount height = height;
  destG.rowBytes = 4 * v808;
  uint64_t v29 = malloc_type_malloc(size, 0x100004052888210uLL);
  uint64_t v30 = 0;
  destG.int data = v29;
  float v31 = 0.0;
  do
  {
    float v32 = expf((float)((float)((float)(int)v30 * 2.5) * 0.5)* (float)((float)((float)((float)(int)v30 * 2.5) * 0.5) * -0.5));
    *(float *)&v881[4 * v30 + 8] = v32;
    float v31 = v31 + (float)(v32 * 2.0);
    ++v30;
  }
  while (v30 != 3);
  for (uint64_t i = 8; i != 20; i += 4)
    *(float *)&v881[i] = (float)(1.0 / (float)(v31 + -1.0)) * *(float *)&v881[i];
  uint64_t v34 = 0;
  *(int32x2_t *)v881 = vrev64_s32(*(int32x2_t *)&v881[12]);
  p_long long kernel = &kernel;
  do
  {
    uint64_t v36 = 0;
    float v37 = *(float *)&v881[4 * v34];
    do
    {
      *(float *)((char *)p_kernel + v36) = v37 * *(float *)&v881[v36];
      v36 += 4;
    }
    while (v36 != 20);
    p_long long kernel = (long long *)((char *)p_kernel + 20);
    ++v34;
  }
  while (v34 != 5);
  vDSP_f5x5(__E, height, v808, (const float *)&kernel, (float *)v29);
  LODWORD(destA.data) = v810;
  vvsqrtf((float *)destG.data, (const float *)destG.data, (const int *)&destA);
  vvsqrtf((float *)destG.data, (const float *)destG.data, (const int *)&destA);
  destB.vImagePixelCount width = v808;
  destB.vImagePixelCount height = height;
  destB.rowBytes = 2 * v808;
  sizea = (char *)malloc_type_malloc(2 * v810, 0x1000040BDFB0063uLL);
  destB.int data = sizea;
  dest.vImagePixelCount width = v808;
  dest.vImagePixelCount height = height;
  dest.rowBytes = 2 * v808;
  int v38 = (char *)malloc_type_malloc(2 * v810, 0x1000040BDFB0063uLL);
  dest.int data = v38;
  src.vImagePixelCount width = v808;
  src.vImagePixelCount height = height;
  src.rowBytes = 2 * v808;
  int v39 = (char *)malloc_type_malloc(2 * v810, 0x1000040BDFB0063uLL);
  src.int data = v39;
  vImagePixelCount v40 = destG.width;
  vImagePixelCount v41 = destG.height;
  vDSP_Length v42 = destG.height * destG.width;
  LODWORD(v880.data) = LODWORD(destG.height) * LODWORD(destG.width);
  long long kernel = xmmword_1A410C460;
  long long v885 = xmmword_1A410C470;
  LODWORD(v886) = 1108735514;
  int v43 = malloc_type_malloc(4 * destG.height * destG.width, 0x100004052888210uLL);
  destA.vImagePixelCount width = v40;
  destA.rowBytes = 4 * v40;
  destA.vImagePixelCount height = v41;
  destA.int data = v43;
  float v44 = (float *)malloc_type_malloc(4 * v42, 0x100004052888210uLL);
  vImageConvolve_PlanarF(&destG, &destA, 0, 0, 0, (const float *)&kernel, 3u, 3u, 0.0, 4u);
  vvintf((float *)destA.data, (const float *)destA.data, (const int *)&v880);
  vDSP_vfixr16((const float *)destA.data, 1, (__int16 *)v38, 1, v42);
  *(_OWORD *)v881 = xmmword_1A410C480;
  *(_OWORD *)&v881[16] = xmmword_1A410C490;
  int v882 = 1108735514;
  uint64_t v45 = malloc_type_malloc(4 * v42, 0x100004052888210uLL);
  destR.vImagePixelCount width = v40;
  destR.rowBytes = 4 * v40;
  destR.vImagePixelCount height = v41;
  destR.int data = v45;
  vImageConvolve_PlanarF(&destG, &destR, 0, 0, 0, (const float *)v881, 3u, 3u, 0.0, 4u);
  vvintf((float *)destR.data, (const float *)destR.data, (const int *)&v880);
  vDSP_vfixr16((const float *)destR.data, 1, (__int16 *)v39, 1, v42);
  vDSP_vdist((const float *)destA.data, 1, (const float *)destR.data, 1, v44, 1, v42);
  vDSP_vfixru16(v44, 1, (unsigned __int16 *)sizea, 1, v42);
  if (v43) {
    free(v43);
  }
  if (v44) {
    free(v44);
  }
  if (v45) {
    free(v45);
  }
  qd_trimImageBorders((char **)&destB);
  qd_trimImageBorders((char **)&dest);
  qd_trimImageBorders((char **)&src);
  uint64_t v46 = (char *)malloc_type_malloc(v810, 0x100004077774924uLL);
  int v47 = v46;
  if ((int)__NR >= 4) {
    int v48 = 4;
  }
  else {
    int v48 = (int)__NR;
  }
  int v49 = v808;
  size_t v50 = v48 * (uint64_t)(int)v808;
  bzero(v46, v50);
  int v51 = __NR - v48;
  bzero(&v47[((int)__NR - v48) * (uint64_t)(int)v808], v50);
  v792 = v47;
  if (v48 < (int)__NR - v48)
  {
    int8x8_t v52 = &v47[v50];
    size_t v53 = (int)v808;
    float32x2_t v54 = &v47[v50 + (int)v808 - v48];
    int v55 = (int)__NR;
    if ((int)__NR >= 4) {
      int v55 = 4;
    }
    int v56 = v48;
    do
    {
      if ((int)__NR >= 1)
      {
        uint64_t v57 = 0;
        do
        {
          v52[v57] = 0;
          v54[v57++] = 0;
        }
        while (v55 != v57);
      }
      ++v56;
      v52 += (int)v808;
      v54 += (int)v808;
    }
    while (v56 != v51);
    uint64_t v58 = v48 + v48 * (uint64_t)(int)v808;
    uint64_t v59 = 2 * v58;
    uint64_t v60 = 2 * (int)v808;
    char v61 = &v47[v58];
    uint64_t v62 = (uint64_t)&sizea[v60 - 2];
    int v63 = sizea + 2;
    float v64 = &sizea[-v60];
    int v65 = v48;
    while (v48 >= (int)v808 - v48)
    {
LABEL_68:
      ++v65;
      v61 += (int)v808;
      v39 += v60;
      v38 += v60;
      v62 += v60;
      v63 += v60;
      v64 += v60;
      if (v65 == v51)
      {
        int v49 = v808;
        goto LABEL_71;
      }
    }
    uint64_t v66 = 0;
    float v67 = v64;
    uint64_t v68 = v63;
    uint64_t v69 = v62;
    unsigned int v70 = v38;
    int v71 = v39;
    while (1)
    {
      unsigned int v72 = *(unsigned __int16 *)&v68[v59 - 2];
      if (*(_WORD *)&v68[v59 - 2]) {
        break;
      }
      BOOL v80 = 0;
LABEL_67:
      v61[v66++] = v80;
      v71 += 2;
      v70 += 2;
      v69 += 2;
      v68 += 2;
      v67 += 2;
      if (v808 - 2 * v48 == v66) {
        goto LABEL_68;
      }
    }
    unsigned int v73 = *(__int16 *)&v70[v59];
    float v74 = (float)-v73 / (float)v72;
    int v75 = *(__int16 *)&v71[v59];
    float v76 = (float)v75 / (float)v72;
    if ((v73 & 0x80000000) != 0)
    {
      if ((v75 & 0x80000000) == 0)
      {
        if ((signed int)-v73 < v75)
        {
          float v77 = (float)(v76 * (float)(int)(*(__int16 *)&v67[v59] - v72))
              + (float)((float)(*(__int16 *)&v67[v59 + 2] - *(__int16 *)&v67[v59]) * v74);
          int v78 = *(__int16 *)(v69 + v59 + 2);
          int v79 = *(__int16 *)(v69 + v59) - v78;
          goto LABEL_52;
        }
        float v77 = (float)(v76 * (float)(*(__int16 *)&v67[v59 + 2] - *(__int16 *)&v68[v59]))
            + (float)((float)(int)(*(__int16 *)&v68[v59] - v72) * v74);
        int v83 = *(__int16 *)&v68[v59 - 4];
        int v84 = *(__int16 *)(v69 + v59);
        int v79 = v83 - v72;
LABEL_59:
        int v81 = v84 - v83;
        goto LABEL_64;
      }
      if (v75 <= v73)
      {
        float v77 = (float)(v76 * (float)(int)(v72 - *(__int16 *)(v69 + v59 + 2)))
            + (float)((float)(*(__int16 *)(v69 + v59 + 4) - *(__int16 *)(v69 + v59 + 2)) * v74);
        int v82 = *(__int16 *)&v67[v59];
        int v79 = *(__int16 *)&v67[v59 - 2] - v82;
        goto LABEL_63;
      }
      float v77 = (float)(v76 * (float)(*(__int16 *)&v68[v59] - *(__int16 *)(v69 + v59 + 4)))
          + (float)((float)(int)(*(__int16 *)&v68[v59] - v72) * v74);
      int v85 = *(__int16 *)&v68[v59 - 4];
      int v86 = *(__int16 *)&v67[v59 - 2];
      int v79 = v85 - v72;
    }
    else
    {
      if ((v75 & 0x80000000) == 0)
      {
        if (v73 < v75)
        {
          float v77 = (float)(v76 * (float)(int)(*(__int16 *)&v67[v59] - v72))
              + (float)((float)(*(__int16 *)&v67[v59] - *(__int16 *)&v67[v59 - 2]) * v74);
          int v78 = *(__int16 *)(v69 + v59 + 2);
          int v79 = v78 - *(__int16 *)(v69 + v59 + 4);
LABEL_52:
          int v81 = v78 - v72;
LABEL_64:
          BOOL v80 = 0;
          if (v77 <= 0.0)
          {
            float v87 = (float)(v76 * (float)v81) + (float)((float)v79 * v74);
            if (v87 <= 0.0) {
              BOOL v80 = v87 != 0.0;
            }
          }
          goto LABEL_67;
        }
        float v77 = (float)(v76 * (float)(*(__int16 *)&v67[v59 - 2] - *(__int16 *)&v68[v59 - 4]))
            + (float)((float)(int)(v72 - *(__int16 *)&v68[v59 - 4]) * v74);
        int v83 = *(__int16 *)&v68[v59];
        int v84 = *(__int16 *)(v69 + v59 + 4);
        int v79 = v72 - v83;
        goto LABEL_59;
      }
      if ((int)v73 < -v75)
      {
        float v77 = (float)(v76 * (float)(int)(v72 - *(__int16 *)(v69 + v59 + 2)))
            + (float)((float)(*(__int16 *)(v69 + v59 + 2) - *(__int16 *)(v69 + v59)) * v74);
        int v82 = *(__int16 *)&v67[v59];
        int v79 = v82 - *(__int16 *)&v67[v59 + 2];
LABEL_63:
        int v81 = v72 - v82;
        goto LABEL_64;
      }
      float v77 = (float)(v76 * (float)(*(__int16 *)&v68[v59 - 4] - *(__int16 *)(v69 + v59)))
          + (float)((float)(int)(v72 - *(__int16 *)&v68[v59 - 4]) * v74);
      int v85 = *(__int16 *)&v68[v59];
      int v86 = *(__int16 *)&v67[v59 + 2];
      int v79 = v72 - v85;
    }
    int v81 = v85 - v86;
    goto LABEL_64;
  }
  size_t v53 = (int)v808;
LABEL_71:
  int v88 = (char *)malloc_type_malloc(v810, 0x100004077774924uLL);
  unint64_t v89 = (char *)malloc_type_malloc(v810, 0x100004077774924uLL);
  bzero(v89, v53);
  v791 = v89;
  v796 = v88;
  if ((int)__NR < 4)
  {
    bzero(v89, v53);
    bzero(v88, v53);
    unint64_t v105 = v88;
  }
  else
  {
    int v90 = __NR - 2;
    float v91 = v89;
    uint64_t v92 = (v49 - 1);
    int v93 = 1;
    uint64_t v94 = v792;
    do
    {
      if (v93 == 1) {
        size_t v95 = v53;
      }
      else {
        size_t v95 = 0;
      }
      unint64_t v96 = &v94[v95];
      float v97 = &v91[v95];
      *float v97 = 0;
      if (v92 < 2)
      {
        unsigned int v103 = 1;
      }
      else
      {
        uint64_t v98 = v96 + 2;
        int v99 = (8 * (v96[-v53 + 1] & 1)) & 0xC8 | (16 * (v96[1] & 1)) & 0xD8 | (32 * (v96[v53 + 1] & 1)) | v96[-v53] & 1 | (2 * (*v96 & 1)) & 0xFB | (4 * (v96[v53] & 1));
        float v100 = v97 + 1;
        uint64_t v101 = v92 - 1;
        do
        {
          unsigned int v102 = ((*v98 & 1) << 7) | ((v98[-v53] & 1) << 6) | ((v98[v53] & 1) << 8) | v99;
          *v100++ = qdthin1[v102];
          int v99 = v102 >> 3;
          ++v98;
          --v101;
        }
        while (v101);
        unsigned int v103 = v49 - 1;
      }
      uint64_t v94 = &v96[v53];
      v97[v103] = 0;
      float v91 = &v97[v53];
      ++v93;
    }
    while (v93 != v90);
    bzero(v91, v53);
    bzero(v796, v53);
    int v104 = 1;
    unint64_t v105 = v796;
    BOOL v106 = v89;
    do
    {
      if (v104 == 1) {
        size_t v107 = v53;
      }
      else {
        size_t v107 = 0;
      }
      unint64_t v108 = &v106[v107];
      uint64_t v109 = &v105[v107];
      char *v109 = 0;
      if (v92 < 2)
      {
        unsigned int v115 = 1;
      }
      else
      {
        BOOL v110 = v108 + 2;
        int v111 = (8 * (v108[-v53 + 1] & 1)) & 0xC8 | (16 * (v108[1] & 1)) & 0xD8 | (32 * (v108[v53 + 1] & 1)) | v108[-v53] & 1 | (2 * (*v108 & 1)) & 0xFB | (4 * (v108[v53] & 1));
        int v112 = v109 + 1;
        uint64_t v113 = v92 - 1;
        do
        {
          unsigned int v114 = ((*v110 & 1) << 7) | ((v110[-v53] & 1) << 6) | ((v110[v53] & 1) << 8) | v111;
          *v112++ = qdthin2[v114];
          int v111 = v114 >> 3;
          ++v110;
          --v113;
        }
        while (v113);
        unsigned int v115 = v49 - 1;
      }
      BOOL v106 = &v108[v53];
      v109[v115] = 0;
      unint64_t v105 = &v109[v53];
      ++v104;
    }
    while (v104 != v90);
  }
  bzero(v105, v53);
  *(void *)&v881[16] = v808;
  *(void *)&v881[8] = __NR;
  *(void *)&v881[24] = v808;
  unint64_t v116 = (char *)malloc_type_malloc(v810, 0x100004077774924uLL);
  *(void *)v881 = v116;
  int v117 = *(_DWORD *)&v881[24];
  bzero(v116, v53);
  if ((int)__NR >= 4)
  {
    uint64_t v118 = (v808 - 1);
    int v119 = 1;
    unint64_t v120 = v796;
    do
    {
      if (v119 == 1) {
        size_t v121 = v53;
      }
      else {
        size_t v121 = 0;
      }
      int64x2_t v122 = &v120[v121];
      if (v119 == 1) {
        uint64_t v123 = v117;
      }
      else {
        uint64_t v123 = 0;
      }
      char v124 = &v116[v123];
      *char v124 = 0;
      if (v118 < 2)
      {
        unsigned int v130 = 1;
      }
      else
      {
        uint64_t v125 = v122 + 2;
        int v126 = (8 * (v122[-v53 + 1] & 1)) & 0xC8 | (16 * (v122[1] & 1)) & 0xD8 | (32 * (v122[v53 + 1] & 1)) | v122[-v53] & 1 | (2 * (*v122 & 1)) & 0xFB | (4 * (v122[v53] & 1));
        uint64_t v127 = v124 + 1;
        uint64_t v128 = v118 - 1;
        do
        {
          unsigned int v129 = ((*v125 & 1) << 7) | ((v125[-v53] & 1) << 6) | ((v125[v53] & 1) << 8) | v126;
          *v127++ = triplet[v129];
          int v126 = v129 >> 3;
          ++v125;
          --v128;
        }
        while (v128);
        unsigned int v130 = v808 - 1;
      }
      unint64_t v120 = &v122[v53];
      v124[v130] = 0;
      unint64_t v116 = &v124[v117];
      _ZF = v119++ == __NR - 3;
    }
    while (!_ZF);
  }
  bzero(v116, v53);
  destR.int data = 0;
  destR.vImagePixelCount width = (vImagePixelCount)malloc_type_calloc(0x4000uLL, 0x28uLL, 0x102004082217F83uLL);
  destR.vImagePixelCount height = 0;
  int v858 = *(_DWORD *)(v804 + 36);
  int v131 = *(_DWORD *)&v881[16];
  int v132 = *(_DWORD *)&v881[8];
  size_t v838 = *(void *)v881;
  size_t v133 = *(int *)&v881[16];
  v843 = malloc_type_calloc(4uLL, *(int *)&v881[16], 0x3E277EDEuLL);
  size_t v815 = v133;
  BOOL v134 = malloc_type_calloc(4uLL, v133, 0x310C36A0uLL);
  char v135 = (char *)malloc_type_malloc(24 * ((v131 >> 1) + 1), 0x108004098BBCF0FuLL);
  int v819 = v131 >> 1;
  size_t v136 = (uint64_t)((v131 >> 1) + 8) >> 3;
  unint64_t v137 = malloc_type_calloc(v136, 1uLL, 0x100004077774924uLL);
  sizeb = (unsigned __int8 *)malloc_type_calloc(v136, 1uLL, 0x100004077774924uLL);
  BOOL v138 = (unsigned __int8 *)malloc_type_calloc(v136, 1uLL, 0x100004077774924uLL);
  unint64_t v832 = (unint64_t)v137;
  size_t v818 = v136;
  memset(v137, 255, v136);
  uint64_t v139 = malloc_type_calloc(0x4000uLL, 8uLL, 0x2004093837F09uLL);
  if ((v131 & 0x80000000) == 0)
  {
    int v140 = ((v131 >> 1) & ~(v131 >> 31)) + 1;
    unint64_t v141 = v135;
    do
    {
      if (v141)
      {
        void *v141 = 0x2000000004;
        v141[2] = malloc_type_malloc(0x80uLL, 0xE36368ECuLL);
        v141[1] = 0xF00000010;
      }
      v141 += 3;
      --v140;
    }
    while (v140);
  }
  LODWORD(kernel) = 0;
  __uint64_t n = (size_t)v139;
  int v817 = v131;
  LODWORD(v142) = 0;
  if (v132 >= 3)
  {
    int v828 = 0;
    unint64_t v143 = (v131 - 1);
    uint64_t v812 = 4 * v131;
    size_t v826 = ((v131 >> 4) & ~(v131 >> 31)) + 1;
    if ((int)v818 <= 1) {
      unsigned int v144 = 1;
    }
    else {
      unsigned int v144 = v818;
    }
    int v811 = v132 - 2;
    uint64_t v854 = 192 * v144;
    int v834 = 1;
    unint64_t v833 = (v131 - 1);
    while (1)
    {
      unint64_t v146 = v843;
      BOOL v145 = sizeb;
      v843 = v134;
      sizeb = v138;
      size_t v147 = v838 + v815;
      v838 += v815;
      v830 = v145;
      v821 = v146;
      if (v131 >= 3) {
        break;
      }
LABEL_232:
      bzero(v821, v812);
      if ((v131 & 0x80000000) == 0)
      {
        uint64_t v213 = 0;
        int v214 = v830;
        int v215 = (unsigned char *)v832;
        uint64_t v216 = sizeb;
        int v217 = v858;
        do
        {
          int v218 = *v214;
          unint64_t v862 = (unint64_t)(v214 + 1);
          __vImage_Buffer src = (unint64_t)(v216 + 1);
          char v219 = v218 & ~*v216;
          if ((v218 & (*v216 ^ 0xFF)) == 0) {
            goto LABEL_347;
          }
          if (v218 & ~*v216)
          {
            uint64_t v220 = (uint64_t)&v135[v213];
            if (v135) {
              int v221 = *(_DWORD *)(v220 + 12) - *(_DWORD *)(v220 + 8) + 1;
            }
            else {
              int v221 = 0;
            }
            if (v221 >= v217)
            {
              if ((int)v142 >= 0x3FFF) {
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 276, "cidcnt < MAX_CONTOURS");
              }
              uint64_t v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              vImagePixelCount v222 = destR.width;
              vImagePixelCount v223 = destR.width + 40 * v142;
              *(_DWORD *)(v223 + 4) = v221;
              *(unsigned char *)vImagePixelCount v223 = 1;
              *(_DWORD *)(v223 + 12) = 0;
              *(void *)(v223 + 24) = 0;
              float v224 = malloc_type_malloc(4 * (v221 + 2), 0x100004052888210uLL);
              *(void *)(v223 + 16) = v224;
              float v225 = (int **)(v223 + 16);
              if (v135 && (int v226 = *(_DWORD *)&v135[v213 + 8], v226 <= *(_DWORD *)&v135[v213 + 12])) {
                float v227 = (const void *)(*(void *)&v135[v213 + 16] + *(int *)&v135[v213] * (uint64_t)v226);
              }
              else {
                float v227 = 0;
              }
              memcpy(v224, v227, 4 * v221);
              int v228 = (*v225)[v221 - 1];
              int v229 = **v225;
              int v230 = (__int16)v229 - (__int16)v228;
              if (v230 < 0) {
                int v230 = (__int16)v228 - (__int16)v229;
              }
              if (v230 > 1)
              {
                BOOL v232 = 0;
              }
              else
              {
                int v231 = (v229 >> 16) - (v228 >> 16);
                if (v231 < 0) {
                  int v231 = -v231;
                }
                BOOL v232 = v231 < 2;
              }
              *(unsigned char *)(v222 + 40 * v142 + 8) = v232;
            }
            else
            {
              eraseContourPixels(v220, *(uint64_t *)v881, *(int *)&v881[24]);
            }
            *v215 |= 1u;
            if (v135)
            {
              float32x2_t v233 = &v135[v213];
              int v234 = *(int *)&v135[v213 + 4] >> 1;
              *((_DWORD *)v233 + 2) = v234;
              *((_DWORD *)v233 + 3) = v234 - 1;
            }
          }
          if ((v219 & 2) != 0)
          {
            float32x2_t v235 = &v135[v213];
            int v236 = *(_DWORD *)&v135[v213 + 36] - *(_DWORD *)&v135[v213 + 32] + 1;
            if (v236 >= v217)
            {
              if ((int)v142 >= 0x3FFF) {
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 277, "cidcnt < MAX_CONTOURS");
              }
              uint64_t v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              vImagePixelCount v237 = destR.width;
              vImagePixelCount v238 = destR.width + 40 * v142;
              *(_DWORD *)(v238 + 4) = v236;
              *(unsigned char *)vImagePixelCount v238 = 1;
              *(_DWORD *)(v238 + 12) = 0;
              *(void *)(v238 + 24) = 0;
              float32x2_t v239 = malloc_type_malloc(4 * (v236 + 2), 0x100004052888210uLL);
              float v240 = 0;
              *(void *)(v238 + 16) = v239;
              float32x2_t v241 = (int **)(v238 + 16);
              int v242 = *((_DWORD *)v235 + 8);
              if (v242 <= *((_DWORD *)v235 + 9)) {
                float v240 = (const void *)(*(void *)&v135[v213 + 40] + *(int *)&v135[v213 + 24] * (uint64_t)v242);
              }
              memcpy(v239, v240, 4 * v236);
              int v243 = (*v241)[v236 - 1];
              int v244 = **v241;
              int v245 = (__int16)v244 - (__int16)v243;
              if (v245 < 0) {
                int v245 = (__int16)v243 - (__int16)v244;
              }
              if (v245 > 1)
              {
                BOOL v247 = 0;
              }
              else
              {
                int v246 = (v244 >> 16) - (v243 >> 16);
                if (v246 < 0) {
                  int v246 = -v246;
                }
                BOOL v247 = v246 < 2;
              }
              *(unsigned char *)(v237 + 40 * v142 + 8) = v247;
              int v217 = v858;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v213 + 24], *(uint64_t *)v881, *(int *)&v881[24]);
            }
            *v215 |= 2u;
            int v248 = *(int *)&v135[v213 + 28] >> 1;
            *((_DWORD *)v235 + 8) = v248;
            *((_DWORD *)v235 + 9) = v248 - 1;
          }
          if ((v219 & 4) != 0)
          {
            int v249 = &v135[v213];
            int v250 = *(_DWORD *)&v135[v213 + 60] - *(_DWORD *)&v135[v213 + 56] + 1;
            if (v250 >= v217)
            {
              if ((int)v142 >= 0x3FFF) {
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 278, "cidcnt < MAX_CONTOURS");
              }
              uint64_t v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              vImagePixelCount v251 = destR.width;
              vImagePixelCount v252 = destR.width + 40 * v142;
              *(_DWORD *)(v252 + 4) = v250;
              *(unsigned char *)vImagePixelCount v252 = 1;
              *(_DWORD *)(v252 + 12) = 0;
              *(void *)(v252 + 24) = 0;
              int v253 = malloc_type_malloc(4 * (v250 + 2), 0x100004052888210uLL);
              int v254 = 0;
              *(void *)(v252 + 16) = v253;
              int v255 = (int **)(v252 + 16);
              int v256 = *((_DWORD *)v249 + 14);
              if (v256 <= *((_DWORD *)v249 + 15)) {
                int v254 = (const void *)(*(void *)&v135[v213 + 64] + *(int *)&v135[v213 + 48] * (uint64_t)v256);
              }
              memcpy(v253, v254, 4 * v250);
              int v257 = (*v255)[v250 - 1];
              int v258 = **v255;
              int v259 = (__int16)v258 - (__int16)v257;
              if (v259 < 0) {
                int v259 = (__int16)v257 - (__int16)v258;
              }
              if (v259 > 1)
              {
                BOOL v261 = 0;
              }
              else
              {
                int v260 = (v258 >> 16) - (v257 >> 16);
                if (v260 < 0) {
                  int v260 = -v260;
                }
                BOOL v261 = v260 < 2;
              }
              *(unsigned char *)(v251 + 40 * v142 + 8) = v261;
              int v217 = v858;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v213 + 48], *(uint64_t *)v881, *(int *)&v881[24]);
            }
            *v215 |= 4u;
            int v262 = *(int *)&v135[v213 + 52] >> 1;
            *((_DWORD *)v249 + 14) = v262;
            *((_DWORD *)v249 + 15) = v262 - 1;
          }
          if ((v219 & 8) != 0)
          {
            int64_t v263 = &v135[v213];
            int v264 = *(_DWORD *)&v135[v213 + 84] - *(_DWORD *)&v135[v213 + 80] + 1;
            if (v264 >= v217)
            {
              if ((int)v142 >= 0x3FFF) {
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 279, "cidcnt < MAX_CONTOURS");
              }
              uint64_t v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              vImagePixelCount v265 = destR.width;
              vImagePixelCount v266 = destR.width + 40 * v142;
              *(_DWORD *)(v266 + 4) = v264;
              *(unsigned char *)vImagePixelCount v266 = 1;
              *(_DWORD *)(v266 + 12) = 0;
              *(void *)(v266 + 24) = 0;
              long long v267 = malloc_type_malloc(4 * (v264 + 2), 0x100004052888210uLL);
              unint64_t v268 = 0;
              *(void *)(v266 + 16) = v267;
              long long v269 = (int **)(v266 + 16);
              int v270 = *((_DWORD *)v263 + 20);
              if (v270 <= *((_DWORD *)v263 + 21)) {
                unint64_t v268 = (const void *)(*(void *)&v135[v213 + 88] + *(int *)&v135[v213 + 72] * (uint64_t)v270);
              }
              memcpy(v267, v268, 4 * v264);
              int v271 = (*v269)[v264 - 1];
              int v272 = **v269;
              int v273 = (__int16)v272 - (__int16)v271;
              if (v273 < 0) {
                int v273 = (__int16)v271 - (__int16)v272;
              }
              if (v273 > 1)
              {
                BOOL v275 = 0;
              }
              else
              {
                int v274 = (v272 >> 16) - (v271 >> 16);
                if (v274 < 0) {
                  int v274 = -v274;
                }
                BOOL v275 = v274 < 2;
              }
              *(unsigned char *)(v265 + 40 * v142 + 8) = v275;
              int v217 = v858;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v213 + 72], *(uint64_t *)v881, *(int *)&v881[24]);
            }
            *v215 |= 8u;
            int v276 = *(int *)&v135[v213 + 76] >> 1;
            *((_DWORD *)v263 + 20) = v276;
            *((_DWORD *)v263 + 21) = v276 - 1;
          }
          if ((v219 & 0x10) != 0)
          {
            uint64_t v277 = &v135[v213];
            int v278 = *(_DWORD *)&v135[v213 + 108] - *(_DWORD *)&v135[v213 + 104] + 1;
            if (v278 >= v217)
            {
              if ((int)v142 >= 0x3FFF) {
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 280, "cidcnt < MAX_CONTOURS");
              }
              uint64_t v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              vImagePixelCount v279 = destR.width;
              vImagePixelCount v280 = destR.width + 40 * v142;
              *(_DWORD *)(v280 + 4) = v278;
              *(unsigned char *)vImagePixelCount v280 = 1;
              *(_DWORD *)(v280 + 12) = 0;
              *(void *)(v280 + 24) = 0;
              uint64_t v281 = malloc_type_malloc(4 * (v278 + 2), 0x100004052888210uLL);
              uint64_t v282 = 0;
              *(void *)(v280 + 16) = v281;
              int v283 = (int **)(v280 + 16);
              int v284 = *((_DWORD *)v277 + 26);
              if (v284 <= *((_DWORD *)v277 + 27)) {
                uint64_t v282 = (const void *)(*(void *)&v135[v213 + 112] + *(int *)&v135[v213 + 96] * (uint64_t)v284);
              }
              memcpy(v281, v282, 4 * v278);
              int v285 = (*v283)[v278 - 1];
              int v286 = **v283;
              int v287 = (__int16)v286 - (__int16)v285;
              if (v287 < 0) {
                int v287 = (__int16)v285 - (__int16)v286;
              }
              if (v287 > 1)
              {
                BOOL v289 = 0;
              }
              else
              {
                int v288 = (v286 >> 16) - (v285 >> 16);
                if (v288 < 0) {
                  int v288 = -v288;
                }
                BOOL v289 = v288 < 2;
              }
              *(unsigned char *)(v279 + 40 * v142 + 8) = v289;
              int v217 = v858;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v213 + 96], *(uint64_t *)v881, *(int *)&v881[24]);
            }
            *v215 |= 0x10u;
            int v290 = *(int *)&v135[v213 + 100] >> 1;
            *((_DWORD *)v277 + 26) = v290;
            *((_DWORD *)v277 + 27) = v290 - 1;
          }
          if ((v219 & 0x20) != 0)
          {
            unint64_t v291 = &v135[v213];
            int v292 = *(_DWORD *)&v135[v213 + 132] - *(_DWORD *)&v135[v213 + 128] + 1;
            if (v292 >= v217)
            {
              if ((int)v142 >= 0x3FFF) {
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 281, "cidcnt < MAX_CONTOURS");
              }
              uint64_t v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              vImagePixelCount v293 = destR.width;
              vImagePixelCount v294 = destR.width + 40 * v142;
              *(_DWORD *)(v294 + 4) = v292;
              *(unsigned char *)vImagePixelCount v294 = 1;
              *(_DWORD *)(v294 + 12) = 0;
              *(void *)(v294 + 24) = 0;
              uint64_t v295 = malloc_type_malloc(4 * (v292 + 2), 0x100004052888210uLL);
              double v296 = 0;
              *(void *)(v294 + 16) = v295;
              int v297 = (int **)(v294 + 16);
              int v298 = *((_DWORD *)v291 + 32);
              if (v298 <= *((_DWORD *)v291 + 33)) {
                double v296 = (const void *)(*(void *)&v135[v213 + 136] + *(int *)&v135[v213 + 120] * (uint64_t)v298);
              }
              memcpy(v295, v296, 4 * v292);
              int v299 = (*v297)[v292 - 1];
              int v300 = **v297;
              int v301 = (__int16)v300 - (__int16)v299;
              if (v301 < 0) {
                int v301 = (__int16)v299 - (__int16)v300;
              }
              if (v301 > 1)
              {
                BOOL v303 = 0;
              }
              else
              {
                int v302 = (v300 >> 16) - (v299 >> 16);
                if (v302 < 0) {
                  int v302 = -v302;
                }
                BOOL v303 = v302 < 2;
              }
              *(unsigned char *)(v293 + 40 * v142 + 8) = v303;
              int v217 = v858;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v213 + 120], *(uint64_t *)v881, *(int *)&v881[24]);
            }
            *v215 |= 0x20u;
            int v304 = *(int *)&v135[v213 + 124] >> 1;
            *((_DWORD *)v291 + 32) = v304;
            *((_DWORD *)v291 + 33) = v304 - 1;
          }
          if ((v219 & 0x40) != 0)
          {
            float v305 = &v135[v213];
            int v306 = *(_DWORD *)&v135[v213 + 156] - *(_DWORD *)&v135[v213 + 152] + 1;
            if (v306 >= v217)
            {
              if ((int)v142 >= 0x3FFF) {
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 282, "cidcnt < MAX_CONTOURS");
              }
              uint64_t v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              vImagePixelCount v307 = destR.width;
              vImagePixelCount v308 = destR.width + 40 * v142;
              *(_DWORD *)(v308 + 4) = v306;
              *(unsigned char *)vImagePixelCount v308 = 1;
              *(_DWORD *)(v308 + 12) = 0;
              *(void *)(v308 + 24) = 0;
              unint64_t v309 = malloc_type_malloc(4 * (v306 + 2), 0x100004052888210uLL);
              BOOL v310 = 0;
              *(void *)(v308 + 16) = v309;
              v311 = (int **)(v308 + 16);
              int v312 = *((_DWORD *)v305 + 38);
              if (v312 <= *((_DWORD *)v305 + 39)) {
                BOOL v310 = (const void *)(*(void *)&v135[v213 + 160] + *(int *)&v135[v213 + 144] * (uint64_t)v312);
              }
              memcpy(v309, v310, 4 * v306);
              int v313 = (*v311)[v306 - 1];
              int v314 = **v311;
              int v315 = (__int16)v314 - (__int16)v313;
              if (v315 < 0) {
                int v315 = (__int16)v313 - (__int16)v314;
              }
              if (v315 > 1)
              {
                BOOL v317 = 0;
              }
              else
              {
                int v316 = (v314 >> 16) - (v313 >> 16);
                if (v316 < 0) {
                  int v316 = -v316;
                }
                BOOL v317 = v316 < 2;
              }
              *(unsigned char *)(v307 + 40 * v142 + 8) = v317;
              int v217 = v858;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v213 + 144], *(uint64_t *)v881, *(int *)&v881[24]);
            }
            *v215 |= 0x40u;
            int v318 = *(int *)&v135[v213 + 148] >> 1;
            *((_DWORD *)v305 + 38) = v318;
            *((_DWORD *)v305 + 39) = v318 - 1;
          }
          if (v219 < 0)
          {
            uint64_t v319 = &v135[v213];
            int v320 = *(_DWORD *)&v135[v213 + 180] - *(_DWORD *)&v135[v213 + 176] + 1;
            if (v320 >= v217)
            {
              if ((int)v142 >= 0x3FFF) {
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 283, "cidcnt < MAX_CONTOURS");
              }
              uint64_t v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              vImagePixelCount v321 = destR.width;
              vImagePixelCount v322 = destR.width + 40 * v142;
              *(_DWORD *)(v322 + 4) = v320;
              *(unsigned char *)vImagePixelCount v322 = 1;
              *(_DWORD *)(v322 + 12) = 0;
              *(void *)(v322 + 24) = 0;
              unint64_t v323 = malloc_type_malloc(4 * (v320 + 2), 0x100004052888210uLL);
              uint64_t v324 = 0;
              *(void *)(v322 + 16) = v323;
              uint64_t v325 = (int **)(v322 + 16);
              int v326 = *((_DWORD *)v319 + 44);
              if (v326 <= *((_DWORD *)v319 + 45)) {
                uint64_t v324 = (const void *)(*(void *)&v135[v213 + 184] + *(int *)&v135[v213 + 168] * (uint64_t)v326);
              }
              memcpy(v323, v324, 4 * v320);
              int v327 = (*v325)[v320 - 1];
              int v328 = **v325;
              int v329 = (__int16)v328 - (__int16)v327;
              if (v329 < 0) {
                int v329 = (__int16)v327 - (__int16)v328;
              }
              if (v329 > 1)
              {
                BOOL v331 = 0;
              }
              else
              {
                int v330 = (v328 >> 16) - (v327 >> 16);
                if (v330 < 0) {
                  int v330 = -v330;
                }
                BOOL v331 = v330 < 2;
              }
              uint64_t v216 = (unsigned char *)__src;
              int v214 = (unsigned __int8 *)v862;
              *(unsigned char *)(v321 + 40 * v142 + 8) = v331;
              int v217 = v858;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v213 + 168], *(uint64_t *)v881, *(int *)&v881[24]);
              uint64_t v216 = (unsigned char *)__src;
              int v214 = (unsigned __int8 *)v862;
            }
            *v215 |= 0x80u;
            int v332 = *(int *)&v135[v213 + 172] >> 1;
            *((_DWORD *)v319 + 44) = v332;
            *((_DWORD *)v319 + 45) = v332 - 1;
          }
          else
          {
LABEL_347:
            uint64_t v216 = (unsigned char *)__src;
            int v214 = (unsigned __int8 *)v862;
          }
          v213 += 192;
          ++v215;
        }
        while (v854 != v213);
      }
      unint64_t v333 = (unint64_t)v830;
      bzero(v830, v818);
      BOOL v138 = v830;
      v334 = v821;
      uint64_t v139 = (void *)__n;
      BOOL v134 = v821;
      _ZF = v834++ == v811;
      int v131 = v817;
      unint64_t v143 = v833;
      if (_ZF) {
        goto LABEL_367;
      }
    }
    uint64_t v148 = 1;
    unint64_t v149 = v134;
    do
    {
      if (*(unsigned char *)(v147 + v148))
      {
        uint64_t v150 = v148 + 1;
        int v151 = *((_DWORD *)v146 + v148) + *((_DWORD *)v146 + v148 - 1) + *((_DWORD *)v146 + v148 + 1);
      }
      else
      {
        int v151 = 0;
        uint64_t v150 = v148 + 1;
      }
      v134[v148] = v151;
      uint64_t v148 = v150;
    }
    while (v150 != v143);
    uint64_t v152 = 1;
    while (1)
    {
      if (*(unsigned char *)(v147 + v152))
      {
        unint64_t v153 = &v149[v152];
        uint64_t v154 = *v153;
        int v155 = *(v153 - 1);
        LOWORD(kernel) = v152;
        WORD1(kernel) = v834;
        if (v154)
        {
          if (v155)
          {
            if (v154 != v155)
            {
              if ((int)v154 <= v155) {
                int v170 = v155;
              }
              else {
                int v170 = v154;
              }
              if ((int)v154 >= v155) {
                LODWORD(v154) = v155;
              }
              char v171 = (int *)v139[(int)v154];
              int v172 = *(_DWORD *)(*((void *)v171 + 2) + *v171 * (uint64_t)v171[3]);
              int v173 = (__int16)v172 - (__int16)kernel;
              if (v173 < 0) {
                int v173 = (__int16)kernel - (__int16)v172;
              }
              if (v173 > 1) {
                goto LABEL_187;
              }
              int v174 = (v172 >> 16) - ((int)kernel >> 16);
              if (v174 < 0) {
                int v174 = -v174;
              }
              if (v174 >= 2)
              {
LABEL_187:
                int v184 = *(_DWORD *)(*((void *)v171 + 2) + *v171 * (uint64_t)v171[2]);
                int v185 = (__int16)v184 - (__int16)kernel;
                if (v185 < 0) {
                  int v185 = (__int16)kernel - (__int16)v184;
                }
                if (v185 > 1) {
                  goto LABEL_939;
                }
                int v186 = (v184 >> 16) - ((int)kernel >> 16);
                if (v186 < 0) {
                  int v186 = -v186;
                }
                if (v186 >= 2) {
LABEL_939:
                }
                  __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 155, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[mnid]), pix)");
                int v175 = 0;
              }
              else
              {
                int v175 = 1;
              }
              uint64_t v187 = (int *)v139[v170];
              int v188 = *(_DWORD *)(*((void *)v187 + 2) + *v187 * (uint64_t)v187[3]);
              int v189 = (__int16)v188 - (__int16)kernel;
              if (v189 < 0) {
                int v189 = (__int16)kernel - (__int16)v188;
              }
              if (v189 > 1) {
                goto LABEL_201;
              }
              int v190 = (v188 >> 16) - ((int)kernel >> 16);
              if (v190 < 0) {
                int v190 = -v190;
              }
              if (v190 >= 2)
              {
LABEL_201:
                int v192 = *(_DWORD *)(*((void *)v187 + 2) + *v187 * (uint64_t)v187[2]);
                int v193 = (__int16)v192 - (__int16)kernel;
                if (v193 < 0) {
                  int v193 = (__int16)kernel - (__int16)v192;
                }
                if (v193 > 1) {
                  goto LABEL_940;
                }
                int v194 = (v192 >> 16) - ((int)kernel >> 16);
                if (v194 < 0) {
                  int v194 = ((int)kernel >> 16) - (v192 >> 16);
                }
                if (v194 >= 2) {
LABEL_940:
                }
                  __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 163, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[nid]), pix)");
                int v191 = 0;
              }
              else
              {
                int v191 = 2;
              }
              switch(v191 | v175)
              {
                case 1:
                  appended = appendDequeElement(v171, &kernel);
                  uint64_t v205 = (int *)v139[v170];
                  int v206 = 0;
                  goto LABEL_224;
                case 2:
                  BOOL v195 = prependDequeElement(v171, &kernel);
                  unint64_t v196 = (int *)v139[v170];
                  int v197 = 0;
                  goto LABEL_222;
                case 3:
                  appended = appendDequeElement(v171, &kernel);
                  uint64_t v205 = (int *)v139[v170];
                  int v206 = 1;
LABEL_224:
                  appendDeque((uint64_t)appended, v205, v206);
                  goto LABEL_225;
                default:
                  BOOL v195 = prependDequeElement(v171, &kernel);
                  unint64_t v196 = (int *)v139[v170];
                  int v197 = 1;
LABEL_222:
                  prependDeque((uint64_t)v195, v196, v197);
LABEL_225:
                  int v207 = -1431655765 * ((v139[v170] - (void)v135) >> 3);
                  unint64_t v143 = v833;
                  *(unsigned char *)(v832 + (v207 >> 3)) |= 1 << (v207 & 7);
                  uint64_t v208 = (int *)v139[v170];
                  size_t v147 = v838;
                  if (v208)
                  {
                    int v209 = v208[1] >> 1;
                    uint64_t v208[2] = v209;
                    v208[3] = v209 - 1;
                  }
                  v830[(uint64_t)(0xAAAAAAAAAAAAAAABLL * (((char *)v208 - v135) >> 3)) >> 3] &= ~(1 << ((-85 * (((char *)v208 - v135) >> 3)) & 7));
                  int64_t v210 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v139[v170] - (void)v135) >> 3);
                  sizeb[v210 >> 3] &= ~(1 << (v210 & 7));
                  v139[v170] = 0;
                  v843[v152] = v154;
                  unint64_t v149 = v843;
                  LODWORD(v210) = -1431655765 * ((v139[(int)v154] - (void)v135) >> 3);
                  sizeb[(int)v210 >> 3] |= 1 << (v210 & 7);
                  long long v211 = v843;
                  unint64_t v212 = v833;
                  do
                  {
                    if (*v211 == v170) {
                      *long long v211 = v154;
                    }
                    ++v211;
                    --v212;
                  }
                  while (v212);
                  break;
              }
              goto LABEL_231;
            }
            unint64_t v156 = (int *)v139[v154];
            int v157 = *(_DWORD *)(*((void *)v156 + 2) + *v156 * (uint64_t)v156[3]);
            int v158 = (__int16)v157 - (__int16)kernel;
            if (v158 < 0) {
              int v158 = (__int16)kernel - (__int16)v157;
            }
            if (v158 > 1) {
              goto LABEL_136;
            }
            int v159 = (v157 >> 16) - ((int)kernel >> 16);
            if (v159 < 0) {
              int v159 = -v159;
            }
            if (v159 > 1)
            {
LABEL_136:
              int v160 = *(_DWORD *)(*((void *)v156 + 2) + *v156 * (uint64_t)v156[2]);
              int v161 = (__int16)v160 - (__int16)kernel;
              if (v161 < 0) {
                int v161 = (__int16)kernel - (__int16)v160;
              }
              unint64_t v149 = v843;
              if (v161 > 1) {
                goto LABEL_938;
              }
              int v162 = (v160 >> 16) - ((int)kernel >> 16);
              if (v162 < 0) {
                int v162 = ((int)kernel >> 16) - (v160 >> 16);
              }
              if (v162 >= 2) {
LABEL_938:
              }
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 202, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[mid]), pix)");
              goto LABEL_184;
            }
LABEL_157:
            appendDequeElement(v156, &kernel);
            unint64_t v149 = v843;
          }
          else
          {
            unint64_t v156 = (int *)v139[v154];
            int v167 = *(_DWORD *)(*((void *)v156 + 2) + *v156 * (uint64_t)v156[3]);
            int v168 = (__int16)v167 - (__int16)kernel;
            if (v168 < 0) {
              int v168 = (__int16)kernel - (__int16)v167;
            }
            if (v168 <= 1)
            {
              int v169 = (v167 >> 16) - ((int)kernel >> 16);
              if (v169 < 0) {
                int v169 = -v169;
              }
              if (v169 <= 1) {
                goto LABEL_157;
              }
            }
            int v180 = *(_DWORD *)(*((void *)v156 + 2) + *v156 * (uint64_t)v156[2]);
            int v181 = (__int16)v180 - (__int16)kernel;
            if (v181 < 0) {
              int v181 = (__int16)kernel - (__int16)v180;
            }
            unint64_t v149 = v843;
            if (v181 > 1) {
              goto LABEL_937;
            }
            int v182 = (v180 >> 16) - ((int)kernel >> 16);
            if (v182 < 0) {
              int v182 = ((int)kernel >> 16) - (v180 >> 16);
            }
            if (v182 >= 2) {
LABEL_937:
            }
              __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 215, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[mid]), pix)");
LABEL_184:
            prependDequeElement(v156, &kernel);
          }
          int v183 = -1431655765 * ((v139[v154] - (void)v135) >> 3);
          sizeb[v183 >> 3] |= 1 << (v183 & 7);
LABEL_186:
          size_t v147 = v838;
          unint64_t v143 = v833;
          goto LABEL_231;
        }
        if (v155)
        {
          uint64_t v163 = (int *)v139[v155];
          int v164 = *(_DWORD *)(*((void *)v163 + 2) + *v163 * (uint64_t)v163[3]);
          int v165 = (__int16)v164 - (__int16)kernel;
          if (v165 < 0) {
            int v165 = (__int16)kernel - (__int16)v164;
          }
          if (v165 > 1) {
            goto LABEL_170;
          }
          int v166 = (v164 >> 16) - ((int)kernel >> 16);
          if (v166 < 0) {
            int v166 = -v166;
          }
          if (v166 > 1)
          {
LABEL_170:
            int v176 = *(_DWORD *)(*((void *)v163 + 2) + *v163 * (uint64_t)v163[2]);
            int v177 = (__int16)v176 - (__int16)kernel;
            if (v177 < 0) {
              int v177 = (__int16)kernel - (__int16)v176;
            }
            if (v177 > 1) {
              goto LABEL_936;
            }
            int v178 = (v176 >> 16) - ((int)kernel >> 16);
            if (v178 < 0) {
              int v178 = ((int)kernel >> 16) - (v176 >> 16);
            }
            if (v178 >= 2) {
LABEL_936:
            }
              __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 229, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[pid]), pix)");
            prependDequeElement(v163, &kernel);
          }
          else
          {
            appendDequeElement(v163, &kernel);
          }
          int v179 = -1431655765 * ((v139[v155] - (void)v135) >> 3);
          sizeb[v179 >> 3] |= 1 << (v179 & 7);
          v843[v152] = v155;
          unint64_t v149 = v843;
          goto LABEL_186;
        }
        if (v828 > 16382)
        {
          LODWORD(v862) = 0;
          int v453 = v821;
          v822 = v843;
          v454 = v830;
          unint64_t v831 = (unint64_t)sizeb;
          goto LABEL_504;
        }
        uint64_t v198 = 0;
        ++v828;
        unint64_t v149 = v843;
        while (1)
        {
          unsigned int v199 = *(unsigned __int8 *)(v832 + v198);
          if (*(unsigned char *)(v832 + v198)) {
            break;
          }
          if (v826 == ++v198) {
            goto LABEL_953;
          }
        }
        int v200 = 8 * v198;
        if ((v199 & 1) == 0)
        {
          do
          {
            char v201 = v199;
            ++v200;
            v199 >>= 1;
          }
          while ((v201 & 2) == 0);
        }
        if (v200 > v819 || v200 == -1) {
LABEL_953:
        }
          __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 250, "loc != -1");
        *(unsigned char *)(v832 + (v200 >> 3)) &= ~(1 << (v200 & 7));
        BOOL v202 = (int *)&v135[24 * v200];
        v139[v828] = v202;
        appendDequeElement(v202, &kernel);
        unint64_t v143 = v833;
        size_t v147 = v838;
        int v203 = -1431655765 * ((v139[v828] - (void)v135) >> 3);
        sizeb[v203 >> 3] |= 1 << (v203 & 7);
        v843[v152] = v828;
      }
LABEL_231:
      if (++v152 == v143) {
        goto LABEL_232;
      }
    }
  }
  v334 = v134;
  unint64_t v333 = (unint64_t)v138;
LABEL_367:
  v822 = v334;
  unint64_t v831 = v333;
  LODWORD(v862) = 1;
  if (v131 < 0)
  {
    int v453 = v843;
    v454 = sizeb;
  }
  else
  {
    uint64_t v335 = 0;
    uint64_t v336 = 0;
    if ((int)v818 <= 1) {
      unsigned int v337 = 1;
    }
    else {
      unsigned int v337 = v818;
    }
    __vImage_Buffer src = 192 * v337;
    int v338 = v858;
    do
    {
      unsigned __int8 v339 = sizeb[v336];
      if (!v339) {
        goto LABEL_485;
      }
      if (sizeb[v336])
      {
        uint64_t v340 = (uint64_t)&v135[v335];
        if (v135) {
          int v341 = *(_DWORD *)(v340 + 12) - *(_DWORD *)(v340 + 8) + 1;
        }
        else {
          int v341 = 0;
        }
        if (v341 >= v338)
        {
          if ((int)v142 >= 0x3FFF) {
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 303, "cidcnt < MAX_CONTOURS");
          }
          uint64_t v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          vImagePixelCount v342 = destR.width;
          vImagePixelCount v343 = destR.width + 40 * v142;
          *(_DWORD *)(v343 + 4) = v341;
          *(unsigned char *)vImagePixelCount v343 = 1;
          *(_DWORD *)(v343 + 12) = 0;
          *(void *)(v343 + 24) = 0;
          uint64_t v344 = malloc_type_malloc(4 * (v341 + 2), 0x100004052888210uLL);
          *(void *)(v343 + 16) = v344;
          uint64_t v345 = (int **)(v343 + 16);
          if (v135 && (int v346 = *(_DWORD *)&v135[v335 + 8], v346 <= *(_DWORD *)&v135[v335 + 12])) {
            uint64_t v347 = (const void *)(*(void *)&v135[v335 + 16] + *(int *)&v135[v335] * (uint64_t)v346);
          }
          else {
            uint64_t v347 = 0;
          }
          memcpy(v344, v347, 4 * v341);
          int v348 = (*v345)[v341 - 1];
          int v349 = **v345;
          int v350 = (__int16)v349 - (__int16)v348;
          if (v350 < 0) {
            int v350 = (__int16)v348 - (__int16)v349;
          }
          if (v350 > 1)
          {
            BOOL v352 = 0;
          }
          else
          {
            int v351 = (v349 >> 16) - (v348 >> 16);
            if (v351 < 0) {
              int v351 = -v351;
            }
            BOOL v352 = v351 < 2;
          }
          int v338 = v858;
          *(unsigned char *)(v342 + 40 * v142 + 8) = v352;
        }
        else
        {
          eraseContourPixels(v340, *(uint64_t *)v881, *(int *)&v881[24]);
        }
        *(unsigned char *)(v832 + v336) |= 1u;
        if (v135)
        {
          uint64_t v353 = &v135[v335];
          int v354 = *(int *)&v135[v335 + 4] >> 1;
          *((_DWORD *)v353 + 2) = v354;
          *((_DWORD *)v353 + 3) = v354 - 1;
        }
      }
      if ((v339 & 2) != 0)
      {
        uint64_t v355 = &v135[v335];
        int v356 = *(_DWORD *)&v135[v335 + 36] - *(_DWORD *)&v135[v335 + 32] + 1;
        if (v356 >= v338)
        {
          if ((int)v142 >= 0x3FFF) {
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 304, "cidcnt < MAX_CONTOURS");
          }
          uint64_t v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          vImagePixelCount v357 = destR.width;
          vImagePixelCount v358 = destR.width + 40 * v142;
          *(_DWORD *)(v358 + 4) = v356;
          *(unsigned char *)vImagePixelCount v358 = 1;
          *(_DWORD *)(v358 + 12) = 0;
          *(void *)(v358 + 24) = 0;
          uint64_t v359 = malloc_type_malloc(4 * (v356 + 2), 0x100004052888210uLL);
          float v360 = 0;
          *(void *)(v358 + 16) = v359;
          float v361 = (int **)(v358 + 16);
          int v362 = *((_DWORD *)v355 + 8);
          if (v362 <= *((_DWORD *)v355 + 9)) {
            float v360 = (const void *)(*(void *)&v135[v335 + 40] + *(int *)&v135[v335 + 24] * (uint64_t)v362);
          }
          memcpy(v359, v360, 4 * v356);
          int v363 = (*v361)[v356 - 1];
          int v364 = **v361;
          int v365 = (__int16)v364 - (__int16)v363;
          if (v365 < 0) {
            int v365 = (__int16)v363 - (__int16)v364;
          }
          if (v365 > 1)
          {
            BOOL v367 = 0;
          }
          else
          {
            int v366 = (v364 >> 16) - (v363 >> 16);
            if (v366 < 0) {
              int v366 = -v366;
            }
            BOOL v367 = v366 < 2;
          }
          *(unsigned char *)(v357 + 40 * v142 + 8) = v367;
          int v338 = v858;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v335 + 24], *(uint64_t *)v881, *(int *)&v881[24]);
        }
        *(unsigned char *)(v832 + v336) |= 2u;
        int v368 = *(int *)&v135[v335 + 28] >> 1;
        *((_DWORD *)v355 + 8) = v368;
        *((_DWORD *)v355 + 9) = v368 - 1;
      }
      if ((v339 & 4) != 0)
      {
        float v369 = &v135[v335];
        int v370 = *(_DWORD *)&v135[v335 + 60] - *(_DWORD *)&v135[v335 + 56] + 1;
        if (v370 >= v338)
        {
          if ((int)v142 >= 0x3FFF) {
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 305, "cidcnt < MAX_CONTOURS");
          }
          uint64_t v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          vImagePixelCount v371 = destR.width;
          vImagePixelCount v372 = destR.width + 40 * v142;
          *(_DWORD *)(v372 + 4) = v370;
          *(unsigned char *)vImagePixelCount v372 = 1;
          *(_DWORD *)(v372 + 12) = 0;
          *(void *)(v372 + 24) = 0;
          float v373 = malloc_type_malloc(4 * (v370 + 2), 0x100004052888210uLL);
          float v374 = 0;
          *(void *)(v372 + 16) = v373;
          int v375 = (int **)(v372 + 16);
          int v376 = *((_DWORD *)v369 + 14);
          if (v376 <= *((_DWORD *)v369 + 15)) {
            float v374 = (const void *)(*(void *)&v135[v335 + 64] + *(int *)&v135[v335 + 48] * (uint64_t)v376);
          }
          memcpy(v373, v374, 4 * v370);
          int v377 = (*v375)[v370 - 1];
          int v378 = **v375;
          int v379 = (__int16)v378 - (__int16)v377;
          if (v379 < 0) {
            int v379 = (__int16)v377 - (__int16)v378;
          }
          if (v379 > 1)
          {
            BOOL v381 = 0;
          }
          else
          {
            int v380 = (v378 >> 16) - (v377 >> 16);
            if (v380 < 0) {
              int v380 = -v380;
            }
            BOOL v381 = v380 < 2;
          }
          *(unsigned char *)(v371 + 40 * v142 + 8) = v381;
          int v338 = v858;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v335 + 48], *(uint64_t *)v881, *(int *)&v881[24]);
        }
        *(unsigned char *)(v832 + v336) |= 4u;
        int v382 = *(int *)&v135[v335 + 52] >> 1;
        *((_DWORD *)v369 + 14) = v382;
        *((_DWORD *)v369 + 15) = v382 - 1;
      }
      if ((v339 & 8) != 0)
      {
        BOOL v383 = &v135[v335];
        int v384 = *(_DWORD *)&v135[v335 + 84] - *(_DWORD *)&v135[v335 + 80] + 1;
        if (v384 >= v338)
        {
          if ((int)v142 >= 0x3FFF) {
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 306, "cidcnt < MAX_CONTOURS");
          }
          uint64_t v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          vImagePixelCount v385 = destR.width;
          vImagePixelCount v386 = destR.width + 40 * v142;
          *(_DWORD *)(v386 + 4) = v384;
          *(unsigned char *)vImagePixelCount v386 = 1;
          *(_DWORD *)(v386 + 12) = 0;
          *(void *)(v386 + 24) = 0;
          int v387 = malloc_type_malloc(4 * (v384 + 2), 0x100004052888210uLL);
          uint64_t v388 = 0;
          *(void *)(v386 + 16) = v387;
          uint64_t v389 = (int **)(v386 + 16);
          int v390 = *((_DWORD *)v383 + 20);
          if (v390 <= *((_DWORD *)v383 + 21)) {
            uint64_t v388 = (const void *)(*(void *)&v135[v335 + 88] + *(int *)&v135[v335 + 72] * (uint64_t)v390);
          }
          memcpy(v387, v388, 4 * v384);
          int v391 = (*v389)[v384 - 1];
          int v392 = **v389;
          int v393 = (__int16)v392 - (__int16)v391;
          if (v393 < 0) {
            int v393 = (__int16)v391 - (__int16)v392;
          }
          if (v393 > 1)
          {
            BOOL v395 = 0;
          }
          else
          {
            int v394 = (v392 >> 16) - (v391 >> 16);
            if (v394 < 0) {
              int v394 = -v394;
            }
            BOOL v395 = v394 < 2;
          }
          *(unsigned char *)(v385 + 40 * v142 + 8) = v395;
          int v338 = v858;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v335 + 72], *(uint64_t *)v881, *(int *)&v881[24]);
        }
        *(unsigned char *)(v832 + v336) |= 8u;
        int v396 = *(int *)&v135[v335 + 76] >> 1;
        *((_DWORD *)v383 + 20) = v396;
        *((_DWORD *)v383 + 21) = v396 - 1;
      }
      if ((v339 & 0x10) != 0)
      {
        int v397 = &v135[v335];
        int v398 = *(_DWORD *)&v135[v335 + 108] - *(_DWORD *)&v135[v335 + 104] + 1;
        if (v398 >= v338)
        {
          if ((int)v142 >= 0x3FFF) {
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 307, "cidcnt < MAX_CONTOURS");
          }
          uint64_t v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          vImagePixelCount v399 = destR.width;
          vImagePixelCount v400 = destR.width + 40 * v142;
          *(_DWORD *)(v400 + 4) = v398;
          *(unsigned char *)vImagePixelCount v400 = 1;
          *(_DWORD *)(v400 + 12) = 0;
          *(void *)(v400 + 24) = 0;
          int v401 = malloc_type_malloc(4 * (v398 + 2), 0x100004052888210uLL);
          uint64_t v402 = 0;
          *(void *)(v400 + 16) = v401;
          uint64_t v403 = (int **)(v400 + 16);
          int v404 = *((_DWORD *)v397 + 26);
          if (v404 <= *((_DWORD *)v397 + 27)) {
            uint64_t v402 = (const void *)(*(void *)&v135[v335 + 112] + *(int *)&v135[v335 + 96] * (uint64_t)v404);
          }
          memcpy(v401, v402, 4 * v398);
          int v405 = (*v403)[v398 - 1];
          int v406 = **v403;
          int v407 = (__int16)v406 - (__int16)v405;
          if (v407 < 0) {
            int v407 = (__int16)v405 - (__int16)v406;
          }
          if (v407 > 1)
          {
            BOOL v409 = 0;
          }
          else
          {
            int v408 = (v406 >> 16) - (v405 >> 16);
            if (v408 < 0) {
              int v408 = -v408;
            }
            BOOL v409 = v408 < 2;
          }
          *(unsigned char *)(v399 + 40 * v142 + 8) = v409;
          int v338 = v858;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v335 + 96], *(uint64_t *)v881, *(int *)&v881[24]);
        }
        *(unsigned char *)(v832 + v336) |= 0x10u;
        int v410 = *(int *)&v135[v335 + 100] >> 1;
        *((_DWORD *)v397 + 26) = v410;
        *((_DWORD *)v397 + 27) = v410 - 1;
      }
      if ((v339 & 0x20) != 0)
      {
        uint64_t v411 = &v135[v335];
        int v412 = *(_DWORD *)&v135[v335 + 132] - *(_DWORD *)&v135[v335 + 128] + 1;
        if (v412 >= v338)
        {
          if ((int)v142 >= 0x3FFF) {
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 308, "cidcnt < MAX_CONTOURS");
          }
          uint64_t v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          vImagePixelCount v413 = destR.width;
          vImagePixelCount v414 = destR.width + 40 * v142;
          *(_DWORD *)(v414 + 4) = v412;
          *(unsigned char *)vImagePixelCount v414 = 1;
          *(_DWORD *)(v414 + 12) = 0;
          *(void *)(v414 + 24) = 0;
          uint64_t v415 = malloc_type_malloc(4 * (v412 + 2), 0x100004052888210uLL);
          uint64_t v416 = 0;
          *(void *)(v414 + 16) = v415;
          uint64_t v417 = (int **)(v414 + 16);
          int v418 = *((_DWORD *)v411 + 32);
          if (v418 <= *((_DWORD *)v411 + 33)) {
            uint64_t v416 = (const void *)(*(void *)&v135[v335 + 136] + *(int *)&v135[v335 + 120] * (uint64_t)v418);
          }
          memcpy(v415, v416, 4 * v412);
          int v419 = (*v417)[v412 - 1];
          int v420 = **v417;
          int v421 = (__int16)v420 - (__int16)v419;
          if (v421 < 0) {
            int v421 = (__int16)v419 - (__int16)v420;
          }
          if (v421 > 1)
          {
            BOOL v423 = 0;
          }
          else
          {
            int v422 = (v420 >> 16) - (v419 >> 16);
            if (v422 < 0) {
              int v422 = -v422;
            }
            BOOL v423 = v422 < 2;
          }
          *(unsigned char *)(v413 + 40 * v142 + 8) = v423;
          int v338 = v858;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v335 + 120], *(uint64_t *)v881, *(int *)&v881[24]);
        }
        *(unsigned char *)(v832 + v336) |= 0x20u;
        int v424 = *(int *)&v135[v335 + 124] >> 1;
        *((_DWORD *)v411 + 32) = v424;
        *((_DWORD *)v411 + 33) = v424 - 1;
      }
      if ((v339 & 0x40) != 0)
      {
        uint64_t v425 = &v135[v335];
        int v426 = *(_DWORD *)&v135[v335 + 156] - *(_DWORD *)&v135[v335 + 152] + 1;
        if (v426 >= v338)
        {
          if ((int)v142 >= 0x3FFF) {
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 309, "cidcnt < MAX_CONTOURS");
          }
          uint64_t v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          vImagePixelCount v427 = destR.width;
          vImagePixelCount v428 = destR.width + 40 * v142;
          *(_DWORD *)(v428 + 4) = v426;
          *(unsigned char *)vImagePixelCount v428 = 1;
          *(_DWORD *)(v428 + 12) = 0;
          *(void *)(v428 + 24) = 0;
          uint64_t v429 = malloc_type_malloc(4 * (v426 + 2), 0x100004052888210uLL);
          uint64_t v430 = 0;
          *(void *)(v428 + 16) = v429;
          uint64_t v431 = (int **)(v428 + 16);
          int v432 = *((_DWORD *)v425 + 38);
          if (v432 <= *((_DWORD *)v425 + 39)) {
            uint64_t v430 = (const void *)(*(void *)&v135[v335 + 160] + *(int *)&v135[v335 + 144] * (uint64_t)v432);
          }
          memcpy(v429, v430, 4 * v426);
          int v433 = (*v431)[v426 - 1];
          int v434 = **v431;
          int v435 = (__int16)v434 - (__int16)v433;
          if (v435 < 0) {
            int v435 = (__int16)v433 - (__int16)v434;
          }
          if (v435 > 1)
          {
            BOOL v437 = 0;
          }
          else
          {
            int v436 = (v434 >> 16) - (v433 >> 16);
            if (v436 < 0) {
              int v436 = -v436;
            }
            BOOL v437 = v436 < 2;
          }
          *(unsigned char *)(v427 + 40 * v142 + 8) = v437;
          int v338 = v858;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v335 + 144], *(uint64_t *)v881, *(int *)&v881[24]);
        }
        *(unsigned char *)(v832 + v336) |= 0x40u;
        int v438 = *(int *)&v135[v335 + 148] >> 1;
        *((_DWORD *)v425 + 38) = v438;
        *((_DWORD *)v425 + 39) = v438 - 1;
      }
      if ((v339 & 0x80) != 0)
      {
        uint64_t v439 = &v135[v335];
        int v440 = *(_DWORD *)&v135[v335 + 180] - *(_DWORD *)&v135[v335 + 176] + 1;
        if (v440 >= v338)
        {
          if ((int)v142 >= 0x3FFF) {
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 310, "cidcnt < MAX_CONTOURS");
          }
          uint64_t v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          vImagePixelCount v441 = destR.width;
          vImagePixelCount v442 = destR.width + 40 * v142;
          *(_DWORD *)(v442 + 4) = v440;
          *(unsigned char *)vImagePixelCount v442 = 1;
          *(_DWORD *)(v442 + 12) = 0;
          *(void *)(v442 + 24) = 0;
          uint64_t v443 = malloc_type_malloc(4 * (v440 + 2), 0x100004052888210uLL);
          uint64_t v444 = 0;
          *(void *)(v442 + 16) = v443;
          uint64_t v445 = (int **)(v442 + 16);
          int v446 = *((_DWORD *)v439 + 44);
          if (v446 <= *((_DWORD *)v439 + 45)) {
            uint64_t v444 = (const void *)(*(void *)&v135[v335 + 184] + *(int *)&v135[v335 + 168] * (uint64_t)v446);
          }
          memcpy(v443, v444, 4 * v440);
          int v447 = (*v445)[v440 - 1];
          int v448 = **v445;
          int v449 = (__int16)v448 - (__int16)v447;
          if (v449 < 0) {
            int v449 = (__int16)v447 - (__int16)v448;
          }
          if (v449 > 1)
          {
            BOOL v451 = 0;
          }
          else
          {
            int v450 = (v448 >> 16) - (v447 >> 16);
            if (v450 < 0) {
              int v450 = -v450;
            }
            BOOL v451 = v450 < 2;
          }
          uint64_t v139 = (void *)__n;
          *(unsigned char *)(v441 + 40 * v142 + 8) = v451;
          int v338 = v858;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v335 + 168], *(uint64_t *)v881, *(int *)&v881[24]);
          uint64_t v139 = (void *)__n;
        }
        *(unsigned char *)(v832 + v336) |= 0x80u;
        int v452 = *(int *)&v135[v335 + 172] >> 1;
        *((_DWORD *)v439 + 44) = v452;
        *((_DWORD *)v439 + 45) = v452 - 1;
      }
      else
      {
LABEL_485:
        uint64_t v139 = (void *)__n;
      }
      ++v336;
      v335 += 192;
    }
    while (__src != v335);
    LODWORD(v862) = 1;
    int v453 = v843;
    v454 = sizeb;
    int v131 = v817;
  }
LABEL_504:
  if (v453) {
    free(v453);
  }
  if (v822) {
    free(v822);
  }
  if (v832) {
    free((void *)v832);
  }
  if (v454) {
    free(v454);
  }
  if (v831) {
    free((void *)v831);
  }
  if (v139) {
    free(v139);
  }
  if (v135)
  {
    if ((v131 & 0x80000000) == 0)
    {
      uint64_t v455 = (v819 & ~(v819 >> 31)) + 1;
      int v456 = (void **)(v135 + 16);
      do
      {
        if (*v456) {
          free(*v456);
        }
        v456 += 3;
        --v455;
      }
      while (v455);
    }
    free(v135);
  }
  if ((v862 & 1) == 0)
  {
    if (__E) {
      free(__E);
    }
    if (destG.data)
    {
      free(destG.data);
      destG.int data = 0;
    }
    if (destB.data) {
      free(destB.data);
    }
    if (dest.data) {
      free(dest.data);
    }
    if (src.data) {
      free(src.data);
    }
    if (v792) {
      free(v792);
    }
    if (v796) {
      free(v796);
    }
    if (v791) {
      free(v791);
    }
    if (*(void *)v881)
    {
      free(*(void **)v881);
      *(void *)v881 = 0;
    }
    releaseContourDatabaseMemory((uint64_t)&destR);
    BOOL v475 = 0;
    *a5 = 0;
    return v475;
  }
  int data = (int)destR.data;
  vImagePixelCount v458 = destR.width;
  int v459 = LODWORD(destR.data) + 1;
  unint64_t v460 = LODWORD(destR.data) + 1;
  float v461 = (vDSP_Length *)malloc_type_malloc(8 * v460, 0x100004000313F17uLL);
  char v462 = (const unsigned __int16 *)malloc_type_malloc(2 * v459, 0x1000040BDFB0063uLL);
  v463 = (float *)malloc_type_malloc(4 * v459, 0x100004052888210uLL);
  float v464 = *(float *)(v804 + 100);
  *char v462 = 0;
  *float v461 = 0;
  if (data < 1)
  {
    unint64_t v465 = 0;
  }
  else
  {
    LODWORD(v465) = 0;
    signed int v466 = vcvtms_s32_f32(v464);
    v467 = (_DWORD **)(v458 + 56);
    uint64_t v468 = 1;
    do
    {
      signed int v469 = *((_DWORD *)v467 - 3);
      if (v469 <= v466) {
        unint64_t v465 = v465;
      }
      else {
        unint64_t v465 = (v465 + 1);
      }
      v462[v468] = v469;
      int v470 = (*v467)[v469 - 1];
      int v471 = **v467;
      int v472 = (__int16)v471 - (__int16)v470;
      if (v472 < 0) {
        int v472 = (__int16)v470 - (__int16)v471;
      }
      if (v472 > 1)
      {
        BOOL v474 = 0;
      }
      else
      {
        int v473 = (v471 >> 16) - (v470 >> 16);
        if (v473 < 0) {
          int v473 = -v473;
        }
        BOOL v474 = v473 < 2;
      }
      *((unsigned char *)v467 - 8) = v474;
      v461[v468] = v468;
      ++v468;
      v467 += 5;
    }
    while (v460 != v468);
  }
  vDSP_vfltu16(v462, 1, v463, 1, v460);
  vDSP_vsorti(v463, v461, 0, v460, -1);
  if ((data & 0x80000000) == 0)
  {
    uint64_t v476 = v460;
    v477 = v461;
    v478 = (unsigned __int16 *)v462;
    do
    {
      uint64_t v479 = *v477++;
      *v478++ = v479;
      --v476;
    }
    while (v476);
  }
  destR.vImagePixelCount height = (vImagePixelCount)v462;
  HIDWORD(destR.data) = v465;
  if (v463) {
    free(v463);
  }
  free(v461);
  v866[1] = __NR;
  *(void *)&long long v867 = v808;
  *((void *)&v867 + 1) = 2 * v808;
  v866[0] = malloc_type_calloc(v810, 2uLL, 0x1000040BDFB0063uLL);
  SelfClosureContourHeal((uint64_t)&destR, *(uint64_t *)v881, *(uint64_t *)&v881[16], (uint64_t)v866[0], 1);
  uint64_t v480 = *(void *)&v881[16];
  uint64_t v481 = *(void *)v881;
  v482 = v866[0];
  vImagePixelCount v483 = destR.width;
  uint64_t data_high = HIDWORD(destR.data);
  vImagePixelCount v803 = destR.height;
  LODWORD(v873.data) = 0;
  LODWORD(v872.data) = 0;
  if (SHIDWORD(destR.data) >= 1)
  {
    uint64_t v484 = 0;
    v485 = 0;
    int v486 = vcvtms_s32_f32(*(float *)(v804 + 100));
    float v487 = *(float *)(v804 + 88);
    uint64_t v794 = *(void *)&v881[16] << 32;
    v795 = (char *)v866[0];
    int v793 = *(_DWORD *)&v881[16];
    vImagePixelCount v800 = destR.width;
    int v799 = v486;
    while (*(unsigned char *)(v483 + 40 * *(__int16 *)(v803 + 2 * v484) + 8)
         || !*(unsigned char *)(v483 + 40 * *(__int16 *)(v803 + 2 * v484)))
    {
LABEL_698:
      if (++v484 == data_high)
      {
        uint64_t v481 = *(void *)v881;
        uint64_t v480 = *(void *)&v881[16];
        v482 = v866[0];
        goto LABEL_700;
      }
    }
    __int16 v798 = *(_WORD *)(v803 + 2 * v484);
    vImagePixelCount v488 = v483 + 40 * v798;
    v859 = (const void **)(v488 + 16);
    v835 = (unsigned int *)(v488 + 4);
    int v489 = 1;
    uint64_t v801 = v484;
    while (1)
    {
      int v490 = v489;
      v491 = *v859;
      LODWORD(v862) = v490;
      if (v490)
      {
        v492 = *v859;
        uint64_t v493 = 1;
      }
      else
      {
        uint64_t v494 = (int)*v835;
        v492 = &v491[v494 - 1];
        uint64_t v493 = v494 - 2;
      }
      __vImage_Buffer src = *v492;
      LODWORD(destA.data) = *v492;
      HIDWORD(destA.data) = v491[v493];
      __int16 v495 = testJoin((__int16 *)&destA, (uint64_t)v866[0], v867, &v873);
      if (v495)
      {
        vImagePixelCount v496 = v483 + 40 * v495;
        uint64_t v497 = *(int *)(v496 + 4);
        v855 = (int *)(v496 + 4);
        if ((int)v497 > v486)
        {
          vImagePixelCount v498 = v483 + 40 * v495;
          v499 = *(unsigned __int16 **)(v498 + 16);
          v839 = (char **)(v498 + 16);
          v820 = (unsigned char *)v498;
          if (__PAIR64__(WORD1(v873.data), LOWORD(v873.data)) == __PAIR64__(v499[1], *v499))
          {
            LODWORD(v880.data) = *(_DWORD *)v499;
            uint64_t v500 = 1;
          }
          else
          {
            v501 = &v499[2 * v497 - 2];
            if (__PAIR64__(WORD1(v873.data), LOWORD(v873.data)) != __PAIR64__(v501[1], *v501)) {
              __assert_rtn("AdjacentContourHeal", "Contours.c", 603, "PCOORD_EQUAL(joinPoint, LAST_PCOORD(cPtrN))");
            }
            LODWORD(v880.data) = *(_DWORD *)v501;
            uint64_t v500 = v497 - 2;
          }
          HIDWORD(v880.data) = *(_DWORD *)&v499[2 * v500];
          if (testJoin((__int16 *)&v880, (uint64_t)v866[0], v867, &v872) == v798)
          {
            v823 = (void *)(int)*v835;
            unint64_t v832 = *v855;
            size_t data_low = LODWORD(v873.data);
            unint64_t v805 = v805 & 0xFFFFFFFF00000000 | __src;
            unint64_t v806 = v806 & 0xFFFFFFFF00000000 | LODWORD(v873.data);
            unsigned int v503 = healCenters(v805, (int)v873.data, (uint64_t)&kernel);
            if (v503) {
              break;
            }
          }
        }
      }
LABEL_697:
      int v489 = 0;
      if ((v862 & 1) == 0) {
        goto LABEL_698;
      }
    }
    v504 = *v839;
    size_t sizec = data_low;
    if (v862)
    {
      if (*(unsigned __int16 *)v504 != (unsigned __int16)data_low || *((unsigned __int16 *)v504 + 1) != WORD1(data_low))
      {
        uint64_t v505 = *v855 - 1;
        if (*(unsigned __int16 *)&v504[4 * v505] != (unsigned __int16)data_low
          || *(unsigned __int16 *)&v504[4 * v505 + 2] != WORD1(data_low))
        {
          __assert_rtn("AdjacentContourHeal", "Contours.c", 635, "PCOORD_EQUAL(joinPoint, LAST_PCOORD(cPtrN))");
        }
LABEL_590:
        LODWORD(v833) = 0;
        goto LABEL_591;
      }
    }
    else
    {
      uint64_t v506 = *v855 - 1;
      if (*(unsigned __int16 *)&v504[4 * v506] != (unsigned __int16)data_low
        || *(unsigned __int16 *)&v504[4 * v506 + 2] != WORD1(data_low))
      {
        if (*(unsigned __int16 *)v504 != (unsigned __int16)data_low
          || *((unsigned __int16 *)v504 + 1) != WORD1(data_low))
        {
          __assert_rtn("AdjacentContourHeal", "Contours.c", 641, "PCOORD_EQUAL(joinPoint, FIRST_PCOORD(cPtrN))");
        }
        goto LABEL_590;
      }
    }
    LODWORD(v833) = 1;
LABEL_591:
    uint64_t v507 = 0;
    uint64_t v807 = (int)v832 - 1;
    uint64_t v809 = (int)v823 - 1;
    uint64_t v816 = 4 * v807;
    unint64_t v831 = 4 * v809;
    uint64_t v827 = 4 * ((int)v832 + (int)v823 + 2);
    vDSP_Length __NRa = 4 * (int)v832;
    uint64_t __na = 4 * (void)v823;
    size_t v844 = v503;
    while (1)
    {
      v508 = (__int16 *)&kernel + 2 * v507;
      uint64_t v509 = *v508;
      int v510 = v508[1];
      uint64_t v511 = v481;
      v512 = (unsigned char *)(v509 + v481 + (v510 - 1) * (uint64_t)(int)v480 - 1);
      unint64_t v465 = v465 & 0xFFFFFFFF00000000 | __src;
      unint64_t v460 = v460 & 0xFFFFFFFF00000000 | sizec;
      uint64_t v513 = v480;
      int v514 = heal(v512, v480, v465, v460, (uint64_t)&kernel, v507);
      if ((v514 & 0x80000000) == 0)
      {
        int v515 = v514;
        switch(v514)
        {
          case 0:
            v516 = (__int16 *)malloc_type_malloc(4 * ((int)v832 + (int)v823 + 3), 0x100004052888210uLL);
            v485 = v516;
            if (v862)
            {
              v517 = *v839;
              if (v833)
              {
                if ((int)v832 >= 1)
                {
                  v518 = &v517[4 * *v855 - 4];
                  int v519 = v832;
                  v520 = v516;
                  do
                  {
                    int v521 = *(_DWORD *)v518;
                    v518 -= 4;
                    *v520++ = v521;
                    --v519;
                  }
                  while (v519);
                }
              }
              else
              {
                memcpy(v516, v517, __NRa);
              }
              v568 = &v485[2 * (int)v832];
              *(_DWORD *)v568 = *(_DWORD *)v508;
              v542 = v568 + 2;
              v543 = (char *)*v859;
              size_t v569 = 4 * (void)v823;
              goto LABEL_648;
            }
            memcpy(v516, *v859, __na);
            v541 = &v485[2 * (void)v823];
            *(_DWORD *)v541 = *(_DWORD *)v508;
            v542 = v541 + 2;
            v543 = *v839;
            if (!v833)
            {
              size_t v569 = 4 * (int)v832;
LABEL_648:
              memcpy(v542, v543, v569);
              goto LABEL_649;
            }
            int v544 = v832;
            if ((int)v832 >= 1)
            {
              v545 = &v543[4 * *v855 - 4];
              uint64_t v546 = 4 * (void)v823 + 4;
              do
              {
                int v547 = *(_DWORD *)v545;
                v545 -= 4;
                *(_DWORD *)((char *)v485 + v546) = v547;
                v546 += 4;
                --v544;
              }
              while (v544);
            }
LABEL_649:
            int v522 = v832 + v823 + 3;
LABEL_657:
            uint64_t v576 = *v835;
            if ((int)v576 <= 1)
            {
              int v583 = 0;
            }
            else
            {
              int v577 = 0;
              v578 = (__int16 *)((char *)*v859 + 6);
              __int16 v579 = *(_WORD *)*v859;
              uint64_t v580 = v576 - 1;
              do
              {
                int v581 = *(v578 - 1);
                __int16 v582 = *(v578 - 1);
                v577 += (v579 - v581) * *v578;
                v578 += 2;
                __int16 v579 = v582;
                --v580;
              }
              while (v580);
              int v583 = v577 + (v581 - *(__int16 *)*v859) * *((__int16 *)*v859 + 1);
            }
            if (v583 < 0) {
              int v583 = -v583;
            }
            uint64_t v584 = *v855;
            if ((int)v584 < 2)
            {
              int v591 = 0;
            }
            else
            {
              int v585 = 0;
              v586 = (__int16 *)(*v839 + 6);
              __int16 v587 = *(_WORD *)*v839;
              uint64_t v588 = v584 - 1;
              do
              {
                int v589 = *(v586 - 1);
                __int16 v590 = *(v586 - 1);
                v585 += (v587 - v589) * *v586;
                v586 += 2;
                __int16 v587 = v590;
                --v588;
              }
              while (v588);
              int v591 = v585 + (v589 - *(__int16 *)*v839) * *((__int16 *)*v839 + 1);
            }
            uint64_t v592 = (v522 - 2);
            if (v591 < 0) {
              int v591 = -v591;
            }
            if (v522 < 4)
            {
              int v599 = 0;
            }
            else
            {
              int v593 = 0;
              v594 = v485 + 3;
              __int16 v595 = *v485;
              uint64_t v596 = v592 - 1;
              do
              {
                int v597 = *(v594 - 1);
                __int16 v598 = *(v594 - 1);
                v593 += (v595 - v597) * *v594;
                v594 += 2;
                __int16 v595 = v598;
                --v596;
              }
              while (v596);
              int v599 = v593 + (v597 - *v485) * v485[1];
            }
            if (v599 < 0) {
              int v599 = -v599;
            }
            if (v583 <= v591) {
              int v583 = v591;
            }
            if ((float)(v487 * (float)v599) >= (float)v583)
            {
              uint64_t v600 = v522 - 3;
              if (v862) {
                uint64_t v600 = 0;
              }
              v601 = &v485[2 * v600];
              uint64_t v602 = v601[1];
              uint64_t v603 = *v601;
              uint64_t v604 = v794 * SWORD1(__src);
              *(_WORD *)&v795[2 * (__int16)__src + (v604 >> 31)] = 0;
              uint64_t v605 = v794 * SWORD1(sizec);
              *(_WORD *)&v795[2 * (__int16)sizec + (v605 >> 31)] = 0;
              *(_WORD *)&v795[2 * v603 + ((v794 * v602) >> 31)] = v798;
              *(unsigned char *)(v511 + v509 + v510 * (uint64_t)v793) = 1;
              if (v515 == 1)
              {
                uint64_t v606 = (__int16)__src;
                uint64_t v607 = v604 >> 32;
                uint64_t v480 = v513;
                uint64_t v481 = v511;
                vImagePixelCount v483 = v800;
                uint64_t v484 = v801;
                int v486 = v799;
              }
              else
              {
                uint64_t v606 = (__int16)sizec;
                uint64_t v607 = v605 >> 32;
                vImagePixelCount v483 = v800;
                uint64_t v484 = v801;
                int v486 = v799;
                if (v515 == 3)
                {
                  *(unsigned char *)(v511 + (__int16)__src + (v604 >> 32)) = 0;
                  uint64_t v480 = v513;
                  uint64_t v481 = v511;
                }
                else
                {
                  _ZF = v515 == 2;
                  uint64_t v480 = v513;
                  uint64_t v481 = v511;
                  if (!_ZF)
                  {
LABEL_694:
                    if (*v859) {
                      free((void *)*v859);
                    }
                    *v859 = v485;
                    unsigned int *v835 = v592;
                    unsigned char *v820 = 0;
                    goto LABEL_697;
                  }
                }
              }
              *(unsigned char *)(v481 + v606 + v607) = 0;
              goto LABEL_694;
            }
            if (v485)
            {
              free(v485);
              v485 = 0;
            }
            break;
          case 1:
            v523 = (__int16 *)malloc_type_malloc(v827, 0x100004052888210uLL);
            v485 = v523;
            if (v862)
            {
              v524 = *v839;
              if (v833)
              {
                if ((int)v832 >= 1)
                {
                  v525 = (int *)&v524[4 * *v855 - 4];
                  int v526 = v832;
                  v527 = v523;
                  do
                  {
                    int v528 = *v525--;
                    *v527++ = v528;
                    --v526;
                  }
                  while (v526);
                }
              }
              else
              {
                memcpy(v523, v524, __NRa);
              }
              v570 = &v485[2 * (int)v832];
              *(_DWORD *)v570 = *(_DWORD *)v508;
              v549 = v570 + 2;
              v550 = (char *)*v859 + 4;
              size_t v571 = 4 * ((int)v823 - 1);
              goto LABEL_652;
            }
            memcpy(v523, *v859, v831);
            v548 = &v485[2 * v809];
            *(_DWORD *)v548 = *(_DWORD *)v508;
            v549 = v548 + 2;
            v550 = *v839;
            if (!v833)
            {
              size_t v571 = 4 * (int)v832;
              goto LABEL_652;
            }
            int v551 = v832;
            if ((int)v832 >= 1)
            {
              v552 = (int *)&v550[2 * *v855 - 2];
              unint64_t v553 = v831 + 4;
              do
              {
                int v554 = *v552--;
                *(_DWORD *)((char *)v485 + v553) = v554;
                v553 += 4;
                --v551;
              }
              while (v551);
            }
            goto LABEL_653;
          case 2:
            v529 = (__int16 *)malloc_type_malloc(v827, 0x100004052888210uLL);
            v485 = v529;
            if (v862)
            {
              v530 = *v839;
              if (v833)
              {
                if ((int)v832 >= 2)
                {
                  v531 = (int *)&v530[4 * *v855 - 4];
                  int v532 = v832 - 1;
                  v533 = v529;
                  do
                  {
                    int v534 = *v531--;
                    *v533++ = v534;
                    --v532;
                  }
                  while (v532);
                }
              }
              else
              {
                memcpy(v529, v530, v816);
              }
              v572 = &v485[2 * v807];
              *(_DWORD *)v572 = *(_DWORD *)v508;
              v549 = v572 + 2;
              v550 = *v859;
              size_t v571 = 4 * (void)v823;
              goto LABEL_652;
            }
            memcpy(v529, *v859, __na);
            v555 = &v485[2 * (void)v823];
            *(_DWORD *)v555 = *(_DWORD *)v508;
            v549 = v555 + 2;
            v556 = *v839;
            if (!v833)
            {
              v550 = v556 + 4;
              size_t v571 = 4 * v807;
LABEL_652:
              memcpy(v549, v550, v571);
              goto LABEL_653;
            }
            if ((int)v832 >= 2)
            {
              v557 = (int *)&v556[4 * *v855 - 8];
              uint64_t v558 = 4 * (void)v823 + 4;
              int v559 = v832 - 1;
              do
              {
                int v560 = *v557--;
                *(_DWORD *)((char *)v485 + v558) = v560;
                v558 += 4;
                --v559;
              }
              while (v559);
            }
LABEL_653:
            int v522 = v832 + v823 + 2;
            goto LABEL_657;
          case 3:
            v535 = (__int16 *)malloc_type_malloc(4 * ((int)v832 + (int)v823 + 1), 0x100004052888210uLL);
            v485 = v535;
            if (v862)
            {
              v536 = *v839;
              if (v833)
              {
                if ((int)v832 >= 2)
                {
                  v537 = (int *)&v536[4 * *v855 - 4];
                  int v538 = v832 - 1;
                  v539 = v535;
                  do
                  {
                    int v540 = *v537--;
                    *v539++ = v540;
                    --v538;
                  }
                  while (v538);
                }
              }
              else
              {
                memcpy(v535, v536, v816);
              }
              v573 = &v485[2 * v807];
              *(_DWORD *)v573 = *(_DWORD *)v508;
              v562 = v573 + 2;
              v574 = (char *)*v859 + 4;
              size_t v575 = 4 * ((int)v823 - 1);
              goto LABEL_655;
            }
            memcpy(v535, *v859, v831);
            v561 = &v485[2 * v809];
            *(_DWORD *)v561 = *(_DWORD *)v508;
            v562 = v561 + 2;
            v563 = *v839;
            if (!v833)
            {
              v574 = v563 + 4;
              size_t v575 = 4 * v807;
LABEL_655:
              memcpy(v562, v574, v575);
              goto LABEL_656;
            }
            if ((int)v832 >= 2)
            {
              v564 = (int *)&v563[4 * *v855 - 8];
              unint64_t v565 = v831 + 4;
              int v566 = v832 - 1;
              do
              {
                int v567 = *v564--;
                *(_DWORD *)((char *)v485 + v565) = v567;
                v565 += 4;
                --v566;
              }
              while (v566);
            }
LABEL_656:
            int v522 = v832 + v823 + 1;
            goto LABEL_657;
          default:
            int v522 = 0;
            goto LABEL_657;
        }
      }
      uint64_t v480 = v513;
      ++v507;
      uint64_t v481 = v511;
      if (v507 == v844)
      {
        vImagePixelCount v483 = v800;
        uint64_t v484 = v801;
        int v486 = v799;
        goto LABEL_697;
      }
    }
  }
LABEL_700:
  SelfClosureContourHeal((uint64_t)&destR, v481, v480, (uint64_t)v482, 0);
  v880.int data = (void *)0x800000000001;
  v880.vImagePixelCount height = (vImagePixelCount)malloc_type_calloc(0x8000uLL, 0x30uLL, 0x1020040D9DE8CEBuLL);
  int v856 = (int)destR.data;
  if (SLODWORD(destR.data) < 1) {
    goto LABEL_829;
  }
  int v608 = 1;
  vImagePixelCount v609 = destR.width;
  vImagePixelCount v610 = destR.width;
  while (2)
  {
    int v611 = *(unsigned __int8 *)(v610 + 40);
    v610 += 40;
    if (!v611) {
      goto LABEL_756;
    }
    float v612 = *(float *)v804;
    float v613 = *(float *)(v804 + 8);
    long long kernel = 0uLL;
    *((void *)&kernel + 1) = malloc_type_calloc(8uLL, 8uLL, 0x100004000313F17uLL);
    DWORD1(kernel) = 8 * (*((void *)&kernel + 1) != 0);
    uint64_t v614 = *(unsigned int *)(v609 + 44);
    if ((int)v614 <= 1) {
      __assert_rtn("splitIntoMonotonicSpans", "SegmentUtilities.c", 85, "cPtr->nPnts > 1");
    }
    vImagePixelCount v860 = v610;
    LODWORD(v862) = v608;
    int v615 = (unsigned __int16)v608 | ((unsigned __int16)v608 << 16);
    int v616 = *(unsigned __int8 *)(v609 + 48);
    uint64_t v617 = (v614 - 1);
    if (*(unsigned char *)(v609 + 48)) {
      unsigned int v618 = *(_DWORD *)(v609 + 44);
    }
    else {
      unsigned int v618 = v614 - 1;
    }
    __vImage_Buffer src = v609;
    v619 = *(_WORD **)(v609 + 56);
    v620 = (unsigned __int16 *)malloc_type_malloc(4 * v618, 0x100004052888210uLL);
    v621 = (char *)v620;
    uint64_t v622 = 0;
    do
    {
      v623 = (__int16 *)&v620[v622];
      __int16 *v623 = v619[v622 + 2] - v619[v622];
      v623[1] = v619[v622 + 3] - v619[v622 + 1];
      v622 += 2;
    }
    while (2 * (v614 - 1) != v622);
    if (v616)
    {
      v624 = &v619[2 * v617];
      v625 = (__int16 *)&v620[2 * v617];
      __int16 *v625 = *v619 - *v624;
      v625[1] = v619[1] - v624[1];
      v626 = &v873;
    }
    else
    {
      v626 = 0;
    }
    LODWORD(destA.data) = 0;
    LODWORD(v873.data) = 0;
    int v627 = (__int16)*v620;
    if (v627 < 0) {
      int v627 = -v627;
    }
    int v628 = (unsigned __int16)v627;
    BOOL v629 = (unsigned __int16)v627 == 1;
    int v630 = (__int16)v620[1];
    if (v630 < 0) {
      int v630 = -v630;
    }
    int v631 = (unsigned __int16)v630;
    findDiff(v620, v618, v629 | (2 * ((unsigned __int16)v630 == 1)), &destA, v626);
    _ZF = v628 == 1 && LOWORD(destA.data) == 0;
    if (_ZF || v631 == 1 && !WORD1(destA.data))
    {
      if (v616) {
        __assert_rtn("splitIntoMonotonicSpans", "SegmentUtilities.c", 130, "!closedP");
      }
      addSpan((int *)&kernel, v614 << 32);
      goto LABEL_724;
    }
    int sized = v616;
    unsigned int v666 = SWORD1(v873.data);
    int v667 = SLOWORD(v873.data) + SLOWORD(destA.data);
    int v668 = SWORD1(v873.data) + SWORD1(destA.data);
    BOOL v669 = v667 < v668;
    if (v667 >= v668)
    {
      if (SLOWORD(v873.data) >= 1)
      {
        unsigned int v671 = SLOWORD(v873.data);
        v846 = (char *)malloc_type_malloc(4 * v618, 0x100004052888210uLL);
        uint64_t v836 = 4 * v671;
        v841 = (char *)malloc_type_malloc(4 * ((int)v614 + 1), 0x100004052888210uLL);
        memcpy(&v846[v836], v621, 4 * (int)(v618 - v671));
        memcpy(v846, &v621[4 * (v618 - v671)], v836);
        memcpy(&v841[v836], v619, 4 * (int)(v614 - v671));
        memcpy(v841, &v619[2 * (int)(v614 - v671)], v836);
        *(void *)(__src + 56) = v841;
        free(v619);
        free(v621);
        v621 = v846;
        v619 = v841;
      }
    }
    else
    {
      if (SWORD1(v873.data) >= 1)
      {
        int v840 = SWORD1(v873.data) + SWORD1(destA.data);
        v670 = (char *)malloc_type_malloc(4 * v618, 0x100004052888210uLL);
        unint64_t v833 = (unint64_t)malloc_type_malloc(4 * ((int)v614 + 1), 0x100004052888210uLL);
        uint64_t v845 = 4 * v666;
        memcpy(&v670[v845], v621, 4 * (int)(v618 - v666));
        memcpy(v670, &v621[4 * (v618 - v666)], v845);
        memcpy((void *)(v833 + v845), v619, 4 * (int)(v614 - v666));
        memcpy((void *)v833, &v619[2 * (int)(v614 - v666)], v845);
        *(void *)(__src + 56) = v833;
        free(v619);
        free(v621);
        int v668 = v840;
        v621 = v670;
        v619 = (_WORD *)v833;
      }
      int v667 = v668;
    }
    if (sized) {
      *(_DWORD *)&v619[2 * v614] = *(_DWORD *)v619;
    }
    char v672 = 0;
    int v673 = 0;
    while (1)
    {
      int v674 = v667 - v673;
      if (v669)
      {
        if (v667 > v673)
        {
          int v675 = 0;
          int v676 = -1;
          int v677 = -1;
          v678 = &v621[4 * v673];
          while (1)
          {
            int v680 = *(__int16 *)v678;
            v678 += 4;
            int v679 = v680;
            if (v680 < 0 && v677 == -1) {
              int v677 = v675;
            }
            if (v676 == -1 && v679 > 0) {
              int v676 = v675;
            }
            if ((v677 & 0x80000000) == 0 && (v676 & 0x80000000) == 0) {
              break;
            }
            if (v674 == ++v675) {
              goto LABEL_803;
            }
          }
LABEL_804:
          if (v677 > v676) {
            int v676 = v677;
          }
          int v667 = v676 + v673;
          goto LABEL_807;
        }
      }
      else if (v667 > v673)
      {
        int v683 = 0;
        int v676 = -1;
        int v677 = -1;
        v684 = &v621[4 * v673 + 2];
        while (1)
        {
          int v686 = *(__int16 *)v684;
          v684 += 4;
          int v685 = v686;
          if (v686 < 0 && v677 == -1) {
            int v677 = v683;
          }
          if (v676 == -1 && v685 > 0) {
            int v676 = v683;
          }
          if ((v677 & 0x80000000) == 0 && (v676 & 0x80000000) == 0) {
            goto LABEL_804;
          }
          if (v674 == ++v683) {
            goto LABEL_803;
          }
        }
      }
      if ((v672 & 1) == 0)
      {
LABEL_803:
        char v672 = 0;
        goto LABEL_808;
      }
      int v667 = v673 - 1;
LABEL_807:
      char v672 = 1;
LABEL_808:
      if (v618 == v667) {
        break;
      }
      addSpan((int *)&kernel, v673 | ((unint64_t)(v667 - v673) << 32));
      if ((int)v618 < v667) {
        __assert_rtn("splitIntoMonotonicSpans", "SegmentUtilities.c", 268, "idx <= monoLength");
      }
      v689 = (unsigned __int16 *)&v621[4 * v667];
      int v690 = (__int16)*v689;
      if (v690 < 0) {
        int v690 = -v690;
      }
      BOOL v691 = (unsigned __int16)v690 == 1;
      int v692 = (__int16)v689[1];
      if (v692 < 0) {
        int v692 = -v692;
      }
      int v693 = (unsigned __int16)v692;
      LODWORD(destA.data) = 0;
      findDiff(v689, v618 - v667, v691 | (2 * ((unsigned __int16)v692 == 1)), &destA, 0);
      signed int v694 = SLOWORD(destA.data);
      if (v691 && LOWORD(destA.data) == 0) {
        signed int v694 = v618 - v667;
      }
      signed int v695 = SWORD1(destA.data);
      if (WORD1(destA.data)) {
        BOOL v696 = 0;
      }
      else {
        BOOL v696 = v693 == 1;
      }
      if (v696) {
        signed int v695 = v618 - v667;
      }
      BOOL v669 = v694 < v695;
      if (v694 > v695) {
        signed int v695 = v694;
      }
      int v673 = v667;
      BOOL v649 = (int)v618 <= v667;
      v667 += v695;
      if (v649) {
        goto LABEL_724;
      }
    }
    addSpan((int *)&kernel, v673 | ((unint64_t)(v618 - v673 + 1) << 32));
    if (v621) {
LABEL_724:
    }
      free(v621);
    unint64_t v633 = __src;
    unint64_t v634 = *(void *)(__src + 56);
    unint64_t v635 = kernel;
    uint64_t v636 = allocSegments((int *)&v880, kernel);
    v637 = (int *)*((void *)&kernel + 1);
    *(_DWORD *)(__src + 52) = v635;
    *(void *)(__src + 64) = v636;
    uint64_t v638 = v636;
    v639 = v637;
    if ((int)v635 >= 2)
    {
      int v640 = v635 - 1;
      v639 = v637;
      uint64_t v638 = v636;
      do
      {
        *(_DWORD *)(v638 + 12) = v639[1] + 1;
        *(void *)(v638 + 40) = v634 + 4 * *v639;
        uint64_t v638 = *(void *)v638;
        v639 += 2;
        --v640;
      }
      while (v640);
    }
    *(_DWORD *)(v638 + 12) = v639[1];
    *(void *)(v638 + 40) = v634 + 4 * *v639;
    int v641 = 0;
    if (v636)
    {
      do
      {
        v642 = *(int **)(v636 + 40);
        int v643 = *(_DWORD *)(v636 + 12);
        int v644 = v642[v643 - 1];
        int v645 = (__int16)v644 - (__int16)*v642;
        int v646 = (v644 >> 16) - (*v642 >> 16);
        if (v646 >= 0) {
          unsigned int v647 = v646;
        }
        else {
          unsigned int v647 = -v646;
        }
        if (v645 >= 0) {
          unsigned int v648 = v645;
        }
        else {
          unsigned int v648 = -v645;
        }
        BOOL v649 = v647 > v648;
        BOOL v650 = v647 > v648;
        if (v649) {
          unsigned int v651 = v646;
        }
        else {
          unsigned int v651 = v645;
        }
        if (v649) {
          int v646 = v645;
        }
        uint64_t v652 = v646 & 0x10000 | v650 | (v651 >> 31 << 8);
        applyCoordTransform(v652, (uint64_t)v642, v643);
        uint64_t v653 = *(void *)v636;
        unint64_t v654 = straightLineWLSQ(*(__int16 **)(v636 + 40), *(_DWORD *)(v636 + 12));
        unint64_t v656 = v655;
        float v657 = *(float *)&v655;
        *(_DWORD *)(v636 + 16) = v655;
        *(float *)(v636 + 20) = Lsq2Leq(v654);
        *(_DWORD *)(v636 + 24) = v658;
        *(_DWORD *)(v636 + 28) = v659;
        if (v612 < v657) {
          splitSegmentIntoStraightSegments((uint64_t *)v636, v654, v656, (int *)&v880, v612);
        }
        if (v653 == v636)
        {
          int v663 = 0;
        }
        else
        {
          int v660 = -1;
          v661 = (void *)v636;
          do
          {
            int v662 = v660;
            v661 = (void *)*v661;
            ++v660;
          }
          while (v661 != (void *)v653);
          if (v660)
          {
            int v663 = mergeSegments((float *)v636, (v662 + 2), v613);
            if (v663 >= 2)
            {
              for (int j = 1; j != v663; ++j)
              {
                unint64_t v634 = v634 & 0xFFFFFFFFFF000000 | v652;
                revertSegmentCoordinateSystem(v636, *(_DWORD *)(v636 + 12) - 1, v634);
                *(_DWORD *)(v636 + 32) = v615;
                uint64_t v636 = *(void *)v636;
              }
            }
          }
          else
          {
            int v663 = 1;
          }
        }
        uint64_t v665 = v636;
        unint64_t v635 = v635 & 0xFFFFFFFFFF000000 | v652;
        revertSegmentCoordinateSystem(v636, *(_DWORD *)(v636 + 12), v635);
        *(_DWORD *)(v636 + 32) = v615;
        v641 += v663;
        uint64_t v636 = v653;
      }
      while (v653);
      unint64_t v633 = __src;
      *(void *)(__src + 72) = v665;
      v637 = (int *)*((void *)&kernel + 1);
    }
    *(_DWORD *)(v633 + 52) = v641;
    int v608 = v862;
    vImagePixelCount v610 = v860;
    if (v637) {
      free(v637);
    }
LABEL_756:
    vImagePixelCount v609 = v610;
    _ZF = v608++ == v856;
    if (!_ZF) {
      continue;
    }
    break;
  }
LABEL_829:
  int v697 = *(_DWORD *)&v881[8] + *(_DWORD *)&v881[16];
  AnnealContours((uint64_t)&destR, (_DWORD *)v804, *(_DWORD *)&v881[8] + *(_DWORD *)&v881[16]);
  MergeContours((uint64_t)&destR, v804, v697, (uint64_t)&v880, (uint64_t)v881, (uint64_t)v866, 0);
  AnnealContours((uint64_t)&destR, (_DWORD *)v804, v697);
  MergeContours((uint64_t)&destR, v804, v697, (uint64_t)&v880, (uint64_t)v881, (uint64_t)v866, 1);
  AnnealContours((uint64_t)&destR, (_DWORD *)v804, v697);
  MergeContours((uint64_t)&destR, v804, v697, (uint64_t)&v880, (uint64_t)v881, (uint64_t)v866, 1);
  AnnealContours((uint64_t)&destR, (_DWORD *)v804, v697);
  uint64_t v698 = HIDWORD(destR.data);
  float v699 = *(float *)(v804 + 104);
  v700 = malloc_type_malloc(4 * v697, 0x100004052888210uLL);
  int v701 = *(_DWORD *)(v804 + 76);
  LODWORD(destA.data) = *(_DWORD *)(v804 + 8);
  HIDWORD(destA.data) = v701;
  destA.vImagePixelCount height = *(unsigned int *)(v804 + 16);
  destA.vImagePixelCount width = (vImagePixelCount)v700;
  *(void *)&long long kernel = 0;
  long long v885 = 0u;
  long long v889 = 0u;
  long long v890 = 0u;
  long long v887 = 0u;
  long long v888 = 0u;
  long long v886 = 0u;
  *((void *)&kernel + 1) = v881;
  *(void *)&long long v885 = v866;
  v829 = v700;
  *(void *)&long long v888 = v700;
  if ((int)v698 >= 1)
  {
    uint64_t v702 = 0;
    unsigned int v703 = llroundf(v699);
    unsigned int v704 = v703 * v703;
    uint64_t v842 = v698;
    int v837 = v703 * v703;
    do
    {
      vImagePixelCount v705 = destR.width;
      int v706 = *(__int16 *)(destR.height + 2 * v702);
      v707 = (unsigned char *)(destR.width + 40 * *(__int16 *)(destR.height + 2 * v702));
      if (*v707)
      {
        vImagePixelCount v708 = destR.width + 40 * *(__int16 *)(destR.height + 2 * v702);
        int v710 = *(unsigned __int8 *)(v708 + 8);
        v709 = (unsigned char *)(v708 + 8);
        if (!v710)
        {
          vImagePixelCount v711 = destR.width + 40 * *(__int16 *)(destR.height + 2 * v702);
          uint64_t v714 = *(void *)(v711 + 32);
          v712 = (uint64_t *)(v711 + 32);
          v713 = (uint64_t *)v714;
          v715 = *(__int16 **)(*(v712 - 1) + 40);
          int v716 = *v715;
          int v717 = v715[1];
          uint64_t v718 = *(void *)(v714 + 40) + 4 * *(int *)(v714 + 12);
          int v719 = *(__int16 *)(v718 - 4);
          int v720 = *(__int16 *)(v718 - 2);
          if ((v716 - v719) * (v716 - v719) + (v717 - v720) * (v717 - v720) <= v704)
          {
            __int16 v847 = v719;
            __int16 sizee = v720;
            unint64_t v721 = (unsigned __int16)v719 | ((unint64_t)(unsigned __int16)v720 << 16);
            __int16 v861 = v716;
            __int16 v857 = v717;
            unint64_t v722 = (unsigned __int16)v716 | ((unint64_t)(unsigned __int16)v717 << 16);
            unint64_t v862 = v721 | v862 & 0xFFFFFFFF00000000;
            __vImage_Buffer src = v722 | __src & 0xFFFFFFFF00000000;
            if (checkBridgeCrossing((uint64_t)&kernel, (unsigned __int16)v719 | ((unsigned __int16)v720 << 16), (unsigned __int16)v716 | ((unsigned __int16)v717 << 16)))
            {
              unint64_t v831 = v831 & 0xFFFFFFFF00000000 | ((unint64_t)(unsigned __int16)v706 << 16);
              unint64_t v832 = v721 | v832 & 0xFFFFFFFF00000000;
              unint64_t v833 = v722 | v833 & 0xFFFFFFFF00000000;
              uint64_t BridgeSegment = createBridgeSegment((int *)&v880, (unsigned __int16)v706 << 16, v721, v722);
              uint64_t *v713 = BridgeSegment;
              uint64_t *v712 = BridgeSegment;
              ++*(_DWORD *)(v705 + 40 * v706 + 12);
              unsigned char *v709 = 1;
              uint64_t v724 = *(unsigned int *)(BridgeSegment + 12);
              if ((int)v724 >= 1)
              {
                uint64_t v725 = *(void *)v881;
                uint64_t v726 = *(void *)&v881[24] << 32;
                v727 = (__int16 *)(*(void *)(BridgeSegment + 40) + 2);
                do
                {
                  *(unsigned char *)(v725 + *(v727 - 1) + ((v726 * *v727) >> 32)) = 1;
                  v727 += 2;
                  --v724;
                }
                while (v724);
              }
              v728 = (char *)v866[0];
              uint64_t v729 = *((void *)&v867 + 1);
              *(_WORD *)((char *)v866[0] + 2 * v847 + *((void *)&v867 + 1) * sizee) = 0;
              *(_WORD *)&v728[2 * v861 + v729 * v857] = 0;
              AnnealContour((uint64_t)v707, (uint64_t)&destA);
            }
            uint64_t v698 = v842;
            unsigned int v704 = v837;
          }
        }
      }
      ++v702;
    }
    while (v702 != v698);
  }
  if (v829) {
    free(v829);
  }
  v730 = (float *)malloc_type_malloc(32 * SHIDWORD(destR.data), 0x1000040E0EAB150uLL);
  int v731 = Contours2Quads((uint64_t)&destR, (float *)v804, (uint64_t *)v881, (uint64_t)v730, HIDWORD(destR.data));
  unsigned int v732 = v731;
  if (v731 < 2)
  {
    int v753 = v731;
    v777 = a3;
    v778 = a5;
    if (v731 == 1)
    {
      v779 = v730 + 1;
      float v780 = 0.0;
      for (uint64_t k = 1; k != 5; ++k)
      {
        float v780 = v780 + (float)((float)(*(v779 - 1) * v730[2 * (k & 3) + 1]) - (float)(v730[2 * (k & 3)] * *v779));
        v779 += 2;
      }
      canonicalizeQuad((uint64_t)v730, v780);
      int v753 = 1;
    }
  }
  else
  {
    v733 = (char *)malloc_type_malloc(32 * v731, 0x1000040E0EAB150uLL);
    v734 = (vDSP_Length *)malloc_type_malloc(8 * v732, 0x100004000313F17uLL);
    v735 = (float *)malloc_type_malloc(4 * v732, 0x100004052888210uLL);
    v736 = (float32x2_t *)malloc_type_calloc(v732, 8uLL, 0x100004000313F17uLL);
    v737 = malloc_type_malloc(v732, 0x100004077774924uLL);
    v863 = (int *)malloc_type_malloc(4 * v732, 0x100004052888210uLL);
    vDSP_Length v738 = 0;
    v739 = v730 + 1;
    __asm { FMOV            V9.2S, #0.25 }
    __srca = v730;
    do
    {
      float v744 = 0.0;
      v745 = v739;
      for (uint64_t m = 1; m != 5; ++m)
      {
        float v744 = v744 + (float)((float)(*(v745 - 1) * v730[2 * (m & 3) + 1]) - (float)(v730[2 * (m & 3)] * *v745));
        v745 += 2;
      }
      canonicalizeQuad((uint64_t)v730, v744);
      uint64_t v747 = 0;
      v735[v738] = fabsf(v744);
      v734[v738] = v738;
      v737[v738] = 1;
      float32x2_t v748 = 0;
      do
      {
        float32x2_t v748 = vadd_f32(v748, *(float32x2_t *)&v730[v747]);
        v747 += 2;
      }
      while (v747 != 6);
      v736[v738] = vmul_f32(v748, _D9);
      v749 = &v733[32 * v738];
      long long v750 = *(_OWORD *)v730;
      long long v751 = *((_OWORD *)v730 + 1);
      v730 += 8;
      *(_OWORD *)v749 = v750;
      *((_OWORD *)v749 + 1) = v751;
      ++v738;
      v739 += 8;
    }
    while (v738 != v732);
    vDSP_vsorti(v735, v734, 0, v732, -1);
    signed int v752 = 0;
    int v753 = 0;
    v730 = __srca;
    do
    {
      vDSP_Length v754 = v734[v752];
      if (v737[v754])
      {
        v755 = (float32x4_t *)&v733[32 * v754];
        if (++v752 >= (int)v732) {
          goto LABEL_866;
        }
        int v756 = 0;
        v757 = (float *)&v736[v754];
        uint64_t v758 = v752;
        uint64_t v759 = (uint64_t)&v733[32 * v754 + 4];
        while (1)
        {
          vDSP_Length v760 = v734[v758];
          if (v737[v760])
          {
            if ((float)((float)((float)(v757[1] - v736[v760].f32[1]) * (float)(v757[1] - v736[v760].f32[1]))
                       + (float)((float)(*v757 - v736[v760].f32[0]) * (float)(*v757 - v736[v760].f32[0]))) <= 100.0)
              break;
          }
LABEL_860:
          if (v732 == ++v758) {
            goto LABEL_861;
          }
        }
        uint64_t v761 = 0;
        v762 = &v733[32 * v760];
        while (1)
        {
          float v763 = *(float *)(v759 + v761 - 4) - *(float *)&v762[v761];
          if ((float)((float)((float)(*(float *)(v759 + v761) - *(float *)&v762[v761 + 4])
                             * (float)(*(float *)(v759 + v761) - *(float *)&v762[v761 + 4]))
                     + (float)(v763 * v763)) > 100.0)
            break;
          v761 += 8;
          if (v761 == 24)
          {
            v863[v756++] = v758;
            goto LABEL_860;
          }
        }
LABEL_861:
        if (v756)
        {
          float32x4_t v765 = *v755;
          float32x4_t v764 = v755[1];
          if (v756 <= 0)
          {
            float32x4_t v772 = (float32x4_t)vuzp1q_s32((int32x4_t)v765, (int32x4_t)v764);
            float32x4_t v771 = (float32x4_t)vuzp2q_s32((int32x4_t)v765, (int32x4_t)v764);
          }
          else
          {
            uint64_t v766 = v756;
            v767 = v863;
            do
            {
              uint64_t v768 = *v767++;
              vDSP_Length v769 = v734[v768];
              v737[v769] = 0;
              v770 = (float32x4_t *)&v733[32 * v769];
              float32x4_t v764 = vaddq_f32(v770[1], v764);
              float32x4_t v765 = vaddq_f32(*v770, v765);
              --v766;
            }
            while (v766);
            float32x4_t v771 = (float32x4_t)vuzp2q_s32((int32x4_t)v765, (int32x4_t)v764);
            float32x4_t v772 = (float32x4_t)vuzp1q_s32((int32x4_t)v765, (int32x4_t)v764);
          }
          float v775 = 1.0 / (float)(v756 + 1);
          v892.val[0] = vmulq_n_f32(v772, v775);
          v892.val[1] = vmulq_n_f32(v771, v775);
          v776 = &__srca[8 * v753];
          vst2q_f32(v776, v892);
        }
        else
        {
LABEL_866:
          float32x4_t v773 = v755[1];
          v774 = (float32x4_t *)&__srca[8 * v753];
          float32x4_t *v774 = *v755;
          v774[1] = v773;
        }
        ++v753;
      }
      else
      {
        ++v752;
      }
    }
    while (v752 < (int)v732);
    if (v733) {
      free(v733);
    }
    v777 = a3;
    if (v734) {
      free(v734);
    }
    v778 = a5;
    if (v735) {
      free(v735);
    }
    if (v736) {
      free(v736);
    }
    if (v737) {
      free(v737);
    }
    if (v863) {
      free(v863);
    }
  }
  if (v753 >= *(_DWORD *)(v804 + 72)) {
    int v782 = *(_DWORD *)(v804 + 72);
  }
  else {
    int v782 = v753;
  }
  memcpy(v777, v730, 32 * v782);
  BOOL v475 = v782 > 0;
  if (v782 >= 1) {
    memset_pattern16(a4, &unk_1A410C510, 4 * v782);
  }
  int *v778 = v782;
  if (v730) {
    free(v730);
  }
  if (__E) {
    free(__E);
  }
  if (destG.data)
  {
    free(destG.data);
    destG.int data = 0;
  }
  if (destB.data) {
    free(destB.data);
  }
  if (dest.data) {
    free(dest.data);
  }
  if (src.data) {
    free(src.data);
  }
  if (v792) {
    free(v792);
  }
  if (v796) {
    free(v796);
  }
  if (v791) {
    free(v791);
  }
  if (*(void *)v881)
  {
    free(*(void **)v881);
    *(void *)v881 = 0;
  }
  if (v866[0])
  {
    free(v866[0]);
    v866[0] = 0;
  }
  releaseContourDatabaseMemory((uint64_t)&destR);
  v783 = (void *)v880.height;
  if (v880.height)
  {
    int v784 = (int)v880.data;
    if (SLODWORD(v880.data) >= 2)
    {
      v785 = (void **)(v880.height + 88);
      int v786 = 1;
      do
      {
        if (*((unsigned char *)v785 - 32) && *((__int16 *)v785 - 4) <= 0 && *v785)
        {
          free(*v785);
          *v785 = 0;
          int v784 = (int)v880.data;
        }
        ++v786;
        v785 += 6;
      }
      while (v786 < v784);
      v783 = (void *)v880.height;
    }
    free(v783);
  }
  return v475;
}