void sub_100731310(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_100731324(_Unwind_Exception *a1)
{
}

void sub_10073133C()
{
}

uint64_t sub_100731350(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_1007313B4()
{
  return 0;
}

uint64_t sub_1007313BC()
{
  return 0;
}

uint64_t sub_1007313C4()
{
  return 0;
}

void sub_1007313CC()
{
}

void sub_100731448()
{
}

uint64_t sub_10073146C(uint64_t a1, uint64_t a2)
{
  v4 = sub_1007315F8((uint64_t *)a1, a2);
  sub_100731664((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  v5 = *(void **)(a2 + 24);
  v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      v10 = (void *)v5[1];
      v11 = v10;
      v12 = v5;
      if (v10)
      {
        do
        {
          v13 = v11;
          v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          v16 = v10;
          v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          v5 = v16;
        }
        while (!v14);
      }
      v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          v7 = v18;
        }
        while (!v14);
      }
      v5 = v16;
      v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_1007315D0(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1007315F8(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_100731650(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100731664(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1007316B4(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1007316CC(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100731738(&v2);
}

void sub_100731724(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100731738(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1007317A8(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_1007317BC(_Unwind_Exception *a1)
{
}

void sub_1007317D4()
{
}

uint64_t sub_1007317E8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100731850()
{
  return 0;
}

uint64_t sub_100731858()
{
  return 0;
}

uint64_t sub_100731860()
{
  return 0;
}

uint64_t sub_100731868(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_10073193C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10073195C(void *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  uint64_t v8 = (int *)*a1;
  v6 = (int *)(a1 + 1);
  v7 = v8;
  if (v8 != v6)
  {
    do
    {
      sub_100731AC8(v7 + 7, &value);
      xpc_array_append_value(v5, value);
      xpc_release(value);
      uint64_t v9 = (int *)*((void *)v7 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          uint64_t v9 = *(int **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (int *)*((void *)v7 + 2);
          BOOL v11 = *(void *)v10 == (void)v7;
          v7 = v10;
        }
        while (!v11);
      }
      v7 = v10;
    }
    while (v10 != v6);
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_100731A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_100731AC8(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v17 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v17 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = xpc_null_create();
LABEL_8:
    xpc_object_t v17 = v6;
    goto LABEL_9;
  }
  xpc_retain(v5);
LABEL_9:
  xpc_release(v5);
  int v7 = *a1;
  uint64_t v8 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v15, (ctu::rest::detail *)v7, v8, v9);
  v13 = &v17;
  BOOL v14 = "first";
  sub_100035E70((uint64_t)&v13, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  if (!*((unsigned char *)a1 + 5) || (xpc_object_t v11 = xpc_BOOL_create(*((unsigned char *)a1 + 4))) == 0) {
    xpc_object_t v11 = xpc_null_create();
  }
  v13 = &v17;
  BOOL v14 = "second";
  sub_100035E70((uint64_t)&v13, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v10 = v17;
  *a2 = v17;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v17);
}

void sub_100731C78(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_100731C90(void *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  uint64_t v8 = (void *)*a1;
  xpc_object_t v6 = a1 + 1;
  int v7 = v8;
  if (v8 != v6)
  {
    do
    {
      sub_100732164((uint64_t)(v7 + 4), &value);
      xpc_array_append_value(v5, value);
      xpc_release(value);
      uint64_t v9 = (void *)v7[1];
      if (v9)
      {
        do
        {
          xpc_object_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          xpc_object_t v10 = (void *)v7[2];
          BOOL v11 = *v10 == (void)v7;
          int v7 = v10;
        }
        while (!v11);
      }
      int v7 = v10;
    }
    while (v10 != v6);
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_100731DD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100731DFC(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 152));
  v3 = (void **)(a1 + 120);
  sub_100047F64(&v3);
  v3 = (void **)(a1 + 96);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_100731E90(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(__dst + 48, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *((_OWORD *)__dst + 3) = v6;
  }
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84(__dst + 72, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v7 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)(__dst + 72) = v7;
  }
  *((void *)__dst + 12) = 0;
  *((void *)__dst + 13) = 0;
  *((void *)__dst + 14) = 0;
  sub_1000302C0(__dst + 96, *((long long **)a2 + 12), *((long long **)a2 + 13), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 13) - *((void *)a2 + 12)) >> 3));
  *((void *)__dst + 15) = 0;
  *((void *)__dst + 16) = 0;
  *((void *)__dst + 17) = 0;
  sub_1000302C0(__dst + 120, *((long long **)a2 + 15), *((long long **)a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 16) - *((void *)a2 + 15)) >> 3));
  *((_DWORD *)__dst + 36) = *((_DWORD *)a2 + 36);
  sub_100058198((const void **)__dst + 19, (const void **)a2 + 19);
  return __dst;
}

void sub_100731FF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (*(char *)(v10 + 71) < 0) {
    operator delete(*v12);
  }
  if (*(char *)(v10 + 47) < 0) {
    operator delete(*v11);
  }
  if (*(char *)(v10 + 23) < 0) {
    operator delete(*(void **)v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100732068(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1007320C0((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t sub_1007320C0(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 176));
  v3 = (void **)(a1 + 144);
  sub_100047F64(&v3);
  v3 = (void **)(a1 + 120);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100732164(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v14 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v14 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v14 = v6;
LABEL_9:
  xpc_release(v5);
  write_rest_value();
  uint64_t v10 = &v14;
  BOOL v11 = "first";
  sub_100035E70((uint64_t)&v10, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  sub_100594668(a1 + 24, &v8);
  uint64_t v10 = &v14;
  BOOL v11 = "second";
  sub_100035E70((uint64_t)&v10, &v8, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  xpc_object_t v7 = v14;
  *a2 = v14;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v14);
}

void sub_1007322DC(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1007322F4(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1007322F4(a1, *a2);
    sub_1007322F4(a1, a2[1]);
    sub_1007320C0((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t sub_100732350()
{
  __cxa_atexit((void (*)(void *))sub_10072B500, &xmmword_101B0D5F0, (void *)&_mh_execute_header);

  return sub_100C624B8((uint64_t)&unk_101B0D5D2, (uint64_t)sub_10072B530);
}

uint64_t sub_1007323B8()
{
  return 0;
}

uint64_t sub_1007323C0(uint64_t a1, uint64_t a2)
{
  int v5 = 0;
  if (!sub_100FECA8C(a2, &v5) || !sub_100FECBAC(a2, (int *)(a1 + 24))) {
    return 0;
  }

  return sub_100FECB30(a2, (int *)(a1 + 20));
}

uint64_t sub_10073243C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)__p = 0u;
  long long v9 = 0u;
  LODWORD(__p[0]) = *(_DWORD *)a2;
  uint64_t v10 = 0;
  __p[1] = 0;
  long long v9 = 0uLL;
  sub_10078E66C((uint64_t)__p, *(_DWORD *)(a1 + 24));
  sub_10078E5C4((uint64_t)__p, *(_DWORD *)(a1 + 20));
  if (v9 >= 0) {
    unsigned int v4 = HIBYTE(v9);
  }
  else {
    unsigned int v4 = v9;
  }
  sub_10078E718(a2, v4);
  if (v9 >= 0) {
    int v5 = (const std::string::value_type *)&__p[1];
  }
  else {
    int v5 = (const std::string::value_type *)__p[1];
  }
  if (v9 >= 0) {
    std::string::size_type v6 = HIBYTE(v9);
  }
  else {
    std::string::size_type v6 = v9;
  }
  std::string::append((std::string *)(a2 + 8), v5, v6);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[1]);
  }
  return 1;
}

void sub_1007324FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10073251C(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v10 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)__p = 0u;
  memset(v6, 0, sizeof(v6));
  sub_10004DE24((uint64_t)v6);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v6 + 8, &v4);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v4;
  *(void *)(a2 + 16) = v5;
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return 1;
}

void sub_1007326A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1007326C0()
{
}

void sub_100732720()
{
}

const char *sub_100732784()
{
  return "indexed-date";
}

void sub_100732794()
{
}

void sub_1007327A8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100732898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  long long v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007328F0(void *a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v2, (Registry *)a1[10]);
  ctu::RestModule::connect();
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100732E2C(a1 + 32, (uint64_t)(a1 + 30));
  sub_100732EEC((uint64_t)a1);
  v4[0] = off_101A014C0;
  v4[1] = a1;
  v4[3] = v4;
  (*(void (**)(void *, void *))(*a1 + 160))(a1, v4);
  sub_100278CB4(v4);
  sub_100732F84(a1);
}

void sub_1007329E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100278CB4((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100732A10(uint64_t a1, NSObject **a2, uint64_t a3, uint64_t a4, void *a5, char a6, char a7)
{
  *sub_10027763C((void *)a1, a2, a3) = off_101A01008;
  long long v13 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UNSPECIFIED, 0);
  *(void *)(a1 + 96) = dispatch_queue_create_with_target_V2("NECellularUsagePolicyStoreInterface", v13, *a2);
  *(void *)a1 = off_101A01008;
  *(_WORD *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 122) = 0;
  *(unsigned char *)(a1 + 123) = a6;
  *(unsigned char *)(a1 + 124) = a7;
  *(unsigned char *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  uint64_t v14 = a5[1];
  *(void *)(a1 + 224) = *a5;
  *(void *)(a1 + 232) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "NECellularUsagePolicyStoreInterface");
  dispatch_object_t v18 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  long long v15 = *(NSObject **)(a1 + 32);
  xpc_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v18) {
    dispatch_release(v18);
  }
  if (v20 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 280) = 0;
  *(unsigned char *)(a1 + 288) = 0;
  sub_1000F0058(a1 + 296, a4);
  return a1;
}

void sub_100732B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  sub_10030AB98((void *)(v17 + 256));
  char v20 = *(std::__shared_weak_count **)(v17 + 248);
  if (v20) {
    sub_10004D2C8(v20);
  }
  v21 = *(std::__shared_weak_count **)(v17 + 232);
  if (v21) {
    sub_10004D2C8(v21);
  }

  sub_10073DEE8(v18);
  v22 = *(NSObject **)(v17 + 96);
  if (v22) {
    dispatch_release(v22);
  }
  sub_1002775BC((void *)v17);
  _Unwind_Resume(a1);
}

void *sub_100732C18(uint64_t a1)
{
  *(void *)a1 = off_101A01008;
  sub_10003B34C((void *)(a1 + 296));
  sub_10030AB98((void *)(a1 + 256));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 248);
  if (v2) {
    sub_10004D2C8(v2);
  }
  v3 = *(std::__shared_weak_count **)(a1 + 232);
  if (v3) {
    sub_10004D2C8(v3);
  }

  sub_10073DEE8(a1 + 144);
  long long v4 = *(NSObject **)(a1 + 96);
  if (v4) {
    dispatch_release(v4);
  }

  return sub_1002775BC((void *)a1);
}

void sub_100732CC0(uint64_t a1)
{
  sub_100732C18(a1);

  operator delete();
}

void sub_100732CF8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (a2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315138;
      uint64_t v8 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I NEStarted: success = TRUE, reason = %s", (uint8_t *)&v7, 0xCu);
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    int v7 = 136315138;
    uint64_t v8 = a3;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "NEStarted: success = FALSE, reason = %s", (uint8_t *)&v7, 0xCu);
  }
  if (!*(unsigned char *)(a1 + 288))
  {
    *(unsigned char *)(a1 + 288) = 1;
    uint64_t v6 = *(void *)(a1 + 280);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, a1 + 288);
    }
  }
}

uint64_t sub_100732E2C(void *a1, uint64_t a2)
{
  v4[0] = off_101A01440;
  v4[1] = a2;
  v4[3] = v4;
  sub_100318874(v4, a1);
  sub_10030AB98(v4);
  uint64_t result = a1[3];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 48))(result, a1 + 4);
  }
  return result;
}

id sub_100732EEC(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NEConfigurationManager);
  v3 = *(void **)(a1 + 216);
  *(void *)(a1 + 216) = v2;

  long long v4 = *(void **)(a1 + 216);
  uint64_t v5 = *(void *)(a1 + 24);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100739F00;
  v7[3] = &unk_101A01208;
  v7[4] = a1;
  return [v4 setChangedQueue:v5 andHandler:v7];
}

void sub_100732F84(void *a1)
{
  id v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (long long v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  p_shared_weak_owners = &v4->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v4);
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  int v7 = (os_log_t *)(a1 + 5);
  long long v13 = _NSConcreteStackBlock;
  uint64_t v14 = 3321888768;
  long long v15 = sub_10073CEB4;
  long long v16 = &unk_101A012E0;
  uint64_t v17 = a1;
  uint64_t v18 = v3;
  uint64_t v19 = v5;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  char v20 = a1 + 5;
  uint64_t v21 = v3;
  v22 = v5;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  uint64_t v8 = os_state_add_handler();
  a1[13] = v8;
  if (!v8)
  {
    long long v9 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not add in memory configuration state capture handler", buf, 2u);
    }
  }
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  uint64_t v10 = os_state_add_handler();
  a1[14] = v10;
  if (!v10)
  {
    long long v11 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Could not add on disk configuration state capture handler", buf, 2u);
    }
  }
  std::__shared_weak_count::__release_weak(v5);
  std::__shared_weak_count::__release_weak(v5);
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  std::__shared_weak_count::__release_weak(v5);
  std::__shared_weak_count::__release_weak(v5);
}

void sub_100733194(void *a1, int a2, uint64_t a3, int a4)
{
  uint64_t v6 = a1[6];
  uint64_t v7 = *(void *)(a1[4] + 8);
  if (!*(unsigned char *)(v7 + 24))
  {
    *(unsigned char *)(v7 + 24) = 1;
    sub_100732CF8(v6, a2, a3);
  }
  uint64_t v8 = *(void *)(a1[5] + 8);
  if (!*(unsigned char *)(v8 + 24))
  {
    *(unsigned char *)(v8 + 24) = 1;
    if (*(void *)(v6 + 200)) {
      ne_session_cancel();
    }
  }
  if (a4)
  {
    if (*(void *)(v6 + 200))
    {
      ne_session_release();
      *(void *)(v6 + 200) = 0;
    }
  }
}

void sub_10073321C(void *a1, int a2)
{
  long long v4 = *(NSObject **)(a1[6] + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I NEStarted: status = %d", (uint8_t *)v6, 8u);
  }
  switch(a2)
  {
    case 1:
      if (*(unsigned char *)(*(void *)(a1[5] + 8) + 24))
      {
        uint64_t v5 = *(void (**)(void))(a1[4] + 16);
        goto LABEL_8;
      }
      ne_session_start();
      break;
    case 2:
    case 5:
      *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
      break;
    case 3:
      uint64_t v5 = *(void (**)(void))(a1[4] + 16);
LABEL_8:
      v5();
      break;
    default:
      return;
  }
}

void sub_100733370(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v9[0] = 67109120;
    v9[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I NEStarted: event = %d", (uint8_t *)v9, 8u);
  }
  if (a2 == 2)
  {
    uint64_t v7 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I NEStarted: cancelled", (uint8_t *)v9, 2u);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else if (a2 == 1)
  {
    uint64_t v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I NEStarted: changed", (uint8_t *)v9, 2u);
    }
    if (*(void *)(v4 + 200)) {
      ne_session_get_status();
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I NEStarted: event unknown", (uint8_t *)v9, 2u);
    }
  }
}

void *sub_10073351C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 192);
  v3[0] = off_101A01540;
  v3[1] = a1;
  v3[3] = v3;
  sub_1007335B8(a1, v1, (uint64_t)v3);
  return sub_100278CB4(v3);
}

void sub_1007335A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100278CB4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1007335B8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = v5;
  if (*(unsigned char *)(a1 + 121))
  {
    uint64_t v7 = *(char **)(a1 + 152);
    uint64_t v8 = *(char **)(a1 + 160);
    uint64_t v9 = v8 - v7;
    if (v8 == v7) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = 16 * (v8 - v7) - 1;
    }
    unint64_t v11 = *(void *)(a1 + 176);
    if (v10 != *(void *)(a1 + 184) + v11) {
      goto LABEL_42;
    }
    BOOL v12 = v11 >= 0x80;
    unint64_t v13 = v11 - 128;
    if (v12)
    {
      *(void *)(a1 + 176) = v13;
      uint64_t v16 = *(void *)v7;
      uint64_t v14 = v7 + 8;
      uint64_t v15 = v16;
      *(void *)(a1 + 152) = v14;
      if (v8 == *(char **)(a1 + 168))
      {
        unint64_t v17 = *(void *)(a1 + 144);
        uint64_t v18 = (uint64_t)&v14[-v17];
        if ((unint64_t)v14 <= v17)
        {
          uint64_t v51 = (uint64_t)&v8[-v17];
          BOOL v50 = v51 == 0;
          uint64_t v52 = v51 >> 2;
          if (v50) {
            unint64_t v53 = 1;
          }
          else {
            unint64_t v53 = v52;
          }
          v54 = (char *)sub_100048350(v53);
          v56 = &v54[8 * (v53 >> 2)];
          v57 = *(uint64_t **)(a1 + 152);
          uint64_t v8 = v56;
          uint64_t v58 = *(void *)(a1 + 160) - (void)v57;
          if (v58)
          {
            uint64_t v8 = &v56[v58 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v59 = 8 * (v58 >> 3);
            v60 = &v54[8 * (v53 >> 2)];
            do
            {
              uint64_t v61 = *v57++;
              *(void *)v60 = v61;
              v60 += 8;
              v59 -= 8;
            }
            while (v59);
          }
          v62 = *(void **)(a1 + 144);
          *(void *)(a1 + 144) = v54;
          *(void *)(a1 + 152) = v56;
          *(void *)(a1 + 160) = v8;
          *(void *)(a1 + 168) = &v54[8 * v55];
          if (v62)
          {
            operator delete(v62);
            uint64_t v8 = *(char **)(a1 + 160);
          }
        }
        else
        {
          uint64_t v19 = v18 >> 3;
          BOOL v20 = v18 >> 3 < -1;
          uint64_t v21 = (v18 >> 3) + 2;
          if (v20) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = v19 + 1;
          }
          uint64_t v23 = -(v22 >> 1);
          uint64_t v24 = v22 >> 1;
          v25 = &v14[-8 * v24];
          int64_t v26 = v8 - v14;
          if (v8 != v14)
          {
            memmove(&v14[-8 * v24], v14, v8 - v14);
            uint64_t v8 = *(char **)(a1 + 152);
          }
          v27 = &v8[8 * v23];
          uint64_t v8 = &v25[v26];
          *(void *)(a1 + 152) = v27;
          *(void *)(a1 + 160) = &v25[v26];
        }
      }
      *(void *)uint64_t v8 = v15;
    }
    else
    {
      uint64_t v35 = v9 >> 3;
      v36 = *(char **)(a1 + 168);
      v37 = *(char **)(a1 + 144);
      if (v9 >> 3 >= (unint64_t)((v36 - v37) >> 3))
      {
        if (v36 == v37) {
          unint64_t v40 = 1;
        }
        else {
          unint64_t v40 = (v36 - v37) >> 2;
        }
        v41 = (char *)sub_100048350(v40);
        uint64_t v43 = v42;
        uint64_t v121 = a3;
        v44 = operator new(0x1000uLL);
        v45 = &v41[8 * v35];
        v46 = &v41[8 * v43];
        if (v35 == v43)
        {
          uint64_t v47 = 8 * v35;
          if (v9 < 1)
          {
            v88 = v44;
            uint64_t v89 = v47 >> 2;
            if (v8 == v7) {
              unint64_t v90 = 1;
            }
            else {
              unint64_t v90 = v89;
            }
            v91 = (char *)sub_100048350(v90);
            v45 = &v91[8 * (v90 >> 2)];
            v46 = &v91[8 * v92];
            if (v41) {
              operator delete(v41);
            }
            v41 = v91;
            v44 = v88;
          }
          else
          {
            uint64_t v48 = v47 >> 3;
            if (v48 >= -1) {
              unint64_t v49 = v48 + 1;
            }
            else {
              unint64_t v49 = v48 + 2;
            }
            v45 -= 8 * (v49 >> 1);
          }
        }
        *(void *)v45 = v44;
        uint64_t v8 = v45 + 8;
        for (uint64_t i = *(void *)(a1 + 160); i != *(void *)(a1 + 152); i -= 8)
        {
          if (v45 == v41)
          {
            if (v8 >= v46)
            {
              if (v46 == v41) {
                unint64_t v98 = 1;
              }
              else {
                unint64_t v98 = (v46 - v41) >> 2;
              }
              v99 = (char *)sub_100048350(v98);
              v101 = v99;
              v45 = &v99[(2 * v98 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v102 = v8 - v41;
              BOOL v50 = v8 == v41;
              uint64_t v8 = v45;
              if (!v50)
              {
                uint64_t v8 = &v45[v102 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v103 = 8 * (v102 >> 3);
                v104 = v45;
                v105 = v41;
                do
                {
                  uint64_t v106 = *(void *)v105;
                  v105 += 8;
                  *(void *)v104 = v106;
                  v104 += 8;
                  v103 -= 8;
                }
                while (v103);
              }
              v46 = &v99[8 * v100];
              if (v41) {
                operator delete(v41);
              }
              v41 = v101;
            }
            else
            {
              uint64_t v94 = (v46 - v8) >> 3;
              if (v94 >= -1) {
                uint64_t v95 = v94 + 1;
              }
              else {
                uint64_t v95 = v94 + 2;
              }
              uint64_t v96 = v95 >> 1;
              v45 = &v41[8 * (v95 >> 1)];
              v97 = v41;
              if (v8 != v41)
              {
                memmove(v45, v41, v8 - v41);
                v97 = v8;
              }
              uint64_t v8 = &v97[8 * v96];
            }
          }
          uint64_t v107 = *(void *)(i - 8);
          *((void *)v45 - 1) = v107;
          v45 -= 8;
        }
        v108 = *(void **)(a1 + 144);
        *(void *)(a1 + 144) = v41;
        *(void *)(a1 + 152) = v45;
        *(void *)(a1 + 160) = v8;
        *(void *)(a1 + 168) = v46;
        a3 = v121;
        if (v108)
        {
          operator delete(v108);
          uint64_t v8 = *(char **)(a1 + 160);
        }
        goto LABEL_41;
      }
      v38 = operator new(0x1000uLL);
      v39 = v38;
      if (v36 == v8)
      {
        if (v7 == v37)
        {
          if (v8 == v7) {
            unint64_t v66 = 1;
          }
          else {
            unint64_t v66 = (v36 - v7) >> 2;
          }
          v67 = (char *)sub_100048350(v66);
          uint64_t v7 = &v67[(2 * v66 + 6) & 0xFFFFFFFFFFFFFFF8];
          v69 = *(uint64_t **)(a1 + 152);
          v70 = v7;
          uint64_t v71 = *(void *)(a1 + 160) - (void)v69;
          if (v71)
          {
            v70 = &v7[v71 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v72 = 8 * (v71 >> 3);
            v73 = &v67[(2 * v66 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v74 = *v69++;
              *(void *)v73 = v74;
              v73 += 8;
              v72 -= 8;
            }
            while (v72);
          }
          v75 = *(void **)(a1 + 144);
          *(void *)(a1 + 144) = v67;
          *(void *)(a1 + 152) = v7;
          *(void *)(a1 + 160) = v70;
          *(void *)(a1 + 168) = &v67[8 * v68];
          if (v75)
          {
            operator delete(v75);
            uint64_t v7 = *(char **)(a1 + 152);
          }
        }
        *((void *)v7 - 1) = v39;
        v76 = *(char **)(a1 + 152);
        v77 = *(char **)(a1 + 160);
        *(void *)(a1 + 152) = v76 - 8;
        uint64_t v78 = *((void *)v76 - 1);
        *(void *)(a1 + 152) = v76;
        if (v77 == *(char **)(a1 + 168))
        {
          unint64_t v79 = *(void *)(a1 + 144);
          uint64_t v80 = (uint64_t)&v76[-v79];
          if ((unint64_t)v76 <= v79)
          {
            uint64_t v109 = (uint64_t)&v77[-v79];
            BOOL v50 = v109 == 0;
            uint64_t v110 = v109 >> 2;
            if (v50) {
              unint64_t v111 = 1;
            }
            else {
              unint64_t v111 = v110;
            }
            v112 = (char *)sub_100048350(v111);
            v114 = &v112[8 * (v111 >> 2)];
            v115 = *(uint64_t **)(a1 + 152);
            v77 = v114;
            uint64_t v116 = *(void *)(a1 + 160) - (void)v115;
            if (v116)
            {
              v77 = &v114[v116 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v117 = 8 * (v116 >> 3);
              v118 = &v112[8 * (v111 >> 2)];
              do
              {
                uint64_t v119 = *v115++;
                *(void *)v118 = v119;
                v118 += 8;
                v117 -= 8;
              }
              while (v117);
            }
            v120 = *(void **)(a1 + 144);
            *(void *)(a1 + 144) = v112;
            *(void *)(a1 + 152) = v114;
            *(void *)(a1 + 160) = v77;
            *(void *)(a1 + 168) = &v112[8 * v113];
            if (v120)
            {
              operator delete(v120);
              v77 = *(char **)(a1 + 160);
            }
          }
          else
          {
            uint64_t v81 = v80 >> 3;
            BOOL v20 = v80 >> 3 < -1;
            uint64_t v82 = (v80 >> 3) + 2;
            if (v20) {
              uint64_t v83 = v82;
            }
            else {
              uint64_t v83 = v81 + 1;
            }
            uint64_t v84 = -(v83 >> 1);
            uint64_t v85 = v83 >> 1;
            v86 = &v76[-8 * v85];
            int64_t v87 = v77 - v76;
            if (v77 != v76)
            {
              memmove(&v76[-8 * v85], v76, v77 - v76);
              v76 = *(char **)(a1 + 152);
            }
            v77 = &v86[v87];
            *(void *)(a1 + 152) = &v76[8 * v84];
            *(void *)(a1 + 160) = &v86[v87];
          }
        }
        *(void *)v77 = v78;
      }
      else
      {
        *(void *)uint64_t v8 = v38;
      }
    }
    uint64_t v8 = (char *)(*(void *)(a1 + 160) + 8);
    *(void *)(a1 + 160) = v8;
LABEL_41:
    uint64_t v7 = *(char **)(a1 + 152);
LABEL_42:
    if (v8 == v7)
    {
      uint64_t v64 = 0;
    }
    else
    {
      unint64_t v63 = *(void *)(a1 + 184) + *(void *)(a1 + 176);
      uint64_t v64 = *(void *)&v7[(v63 >> 4) & 0xFFFFFFFFFFFFFF8] + 32 * (v63 & 0x7F);
    }
    sub_1007424C0(v64, a3);
    ++*(void *)(a1 + 184);
    v65 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I Save operation already in progress, will retry after it finishes", buf, 2u);
    }
    goto LABEL_47;
  }
  *(unsigned char *)(a1 + 121) = 1;
  v28 = [v5 name];
  v29 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v128 = v28;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Performing save operation on ne configuration: %{public}@", buf, 0xCu);
  }
  id v30 = [v6 copy];
  v31 = *(void **)(a1 + 216);
  uint64_t v32 = *(void *)(a1 + 24);
  v122[0] = _NSConcreteStackBlock;
  v122[1] = 3321888768;
  v122[2] = sub_100737FE0;
  v122[3] = &unk_101A011A0;
  uint64_t v125 = a1;
  id v33 = v28;
  id v123 = v33;
  sub_1007424C0((uint64_t)v126, a3);
  id v34 = v30;
  id v124 = v34;
  [v31 saveConfiguration:v34 withCompletionQueue:v32 handler:v122];

  sub_100278CB4(v126);
LABEL_47:
}

void sub_100733C44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  operator delete(v17);
  if (v16) {
    operator delete(v16);
  }

  _Unwind_Resume(a1);
}

void *sub_100733CC0(void *result)
{
  uint64_t v1 = (void *)result[26];
  if (v1)
  {
    v2[0] = off_101A015C0;
    v2[1] = result;
    v2[3] = v2;
    sub_1007335B8((uint64_t)result, v1, (uint64_t)v2);
    return sub_100278CB4(v2);
  }
  return result;
}

void sub_100733D4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100278CB4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100733D60()
{
}

void sub_100733DCC(void *a1, uint64_t a2, void *a3)
{
  __dst = a1;
  id v3 = a3;
  unint64_t v4 = 0;
  id v5 = 0;
  uint64_t v6 = 0;
  v27 = 0;
  v28 = 0;
  uint64_t v7 = (char *)&qword_1014E7E98;
  v29 = 0;
  do
  {
    uint64_t v8 = *(void *)v7;
    if ((objc_msgSend(v3, "supportsCellularBehavior:", *(void *)v7, __dst) & 1) == 0)
    {
      if (v8 == 1) {
        char v9 = 2;
      }
      else {
        char v9 = v8 != 2;
      }
      if (v6 >= v5)
      {
        unint64_t v11 = &v6[-v4];
        uint64_t v12 = (uint64_t)&v6[-v4 + 1];
        if (v12 < 0) {
          sub_1000D8578();
        }
        if (2 * (uint64_t)&v5[-v4] > (unint64_t)v12) {
          uint64_t v12 = 2 * (void)&v5[-v4];
        }
        if ((unint64_t)&v5[-v4] >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v13 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v13 = v12;
        }
        if (v13) {
          uint64_t v14 = (char *)operator new(v13);
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v15 = &v11[(void)v14];
        uint64_t v16 = &v11[(void)v14];
        char *v16 = v9;
        uint64_t v10 = v16 + 1;
        if (v6 != (char *)v4)
        {
          unint64_t v17 = &v6[~v4];
          do
          {
            char v18 = *--v6;
            (v17--)[(void)v14] = v18;
          }
          while (v6 != (char *)v4);
          uint64_t v15 = v14;
        }
        id v5 = &v14[v13];
        v27 = v15;
        v29 = &v14[v13];
        if (v4) {
          operator delete((void *)v4);
        }
        unint64_t v4 = (unint64_t)v15;
      }
      else
      {
        char *v6 = v9;
        uint64_t v10 = v6 + 1;
      }
      v28 = v10;
      uint64_t v6 = v10;
    }
    v7 += 8;
  }
  while (v7 != "26NECellularUsagePolicyStore");
  char v19 = (***(uint64_t (****)(void, id))(a2 + 64))(*(void *)(a2 + 64), v3);
  char v20 = (***(uint64_t (****)(void, id))(a2 + 48))(*(void *)(a2 + 48), v3);
  id v21 = [v3 matchSigningIdentifier];
  uint64_t v22 = (char *)[v21 UTF8String];

  sub_100058DB0(__p, v22);
  sub_10073DBF0(__dst, (long long *)__p, v19, v20, (uint64_t)&v27);
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  if (v27) {
    operator delete(v27);
  }
}

void sub_100733FF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }

  _Unwind_Resume(a1);
}

void *sub_100734054(void *a1, uint64_t a2, long long *a3)
{
  char v6 = (*(uint64_t (**)(void))(**(void **)(a2 + 64) + 16))(*(void *)(a2 + 64));
  char v7 = (*(uint64_t (**)(void))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48));
  memset(v9, 0, sizeof(v9));
  return sub_10073DBF0(a1, a3, v6, v7, (uint64_t)v9);
}

void *sub_100734100(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000DC0E0((uint64_t)v7, a2);
  v6[0] = off_101A01640;
  v6[3] = v6;
  (*(void (**)(uint64_t, void *, uint64_t, void *))(*(void *)a1 + 48))(a1, v7, a3, v6);
  sub_1000E04E4(v6);
  return sub_1000DBB60(v7);
}

void sub_1007341C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1000E04E4((uint64_t *)va);
  sub_1000DBB60((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void sub_1007341EC(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = sub_1007346D4(a1);
  if (!v8)
  {
    uint64_t v42 = a1;
    sub_1000DC0E0((uint64_t)v43, a2);
    char v44 = a3;
    sub_10073EB40((uint64_t)v45, a4);
    uint64_t v48 = 0;
    unint64_t v11 = operator new(0x58uLL);
    void *v11 = off_101A016C0;
    v11[1] = a1;
    sub_1000DC178((uint64_t)(v11 + 2), (uint64_t)v43);
    *((unsigned char *)v11 + 48) = v44;
    if (v46)
    {
      if (v46 == v45)
      {
        v11[10] = v11 + 7;
        (*(void (**)(void *))(v45[0] + 24))(v45);
        goto LABEL_33;
      }
      uint64_t v12 = &v46;
      v11[10] = v46;
    }
    else
    {
      uint64_t v12 = v11 + 10;
    }
    void *v12 = 0;
LABEL_33:
    uint64_t v48 = v11;
    (*(void (**)(uint64_t, void *))(*(void *)a1 + 160))(a1, v47);
    sub_100278CB4(v47);
    sub_1000E04E4(v45);
    sub_1000DBB60(v43);
    goto LABEL_34;
  }
  if (a3)
  {
    id v10 = +[NEPathController copyAggregatePathRules];
  }
  else
  {
    size_t v13 = [v8 pathController];
    id v10 = [v13 pathRules];
  }
  if ([v10 count])
  {
    uint64_t v25 = a2;
    char v26 = v8;
    v36 = 0;
    uint64_t v37 = 0;
    uint64_t v35 = &v36;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    id v14 = v10;
    id v15 = [v14 countByEnumeratingWithState:&v31 objects:v41 count:16];
    if (v15)
    {
      uint64_t v16 = *(void *)v32;
      do
      {
        for (uint64_t i = 0; i != v15; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v32 != v16) {
            objc_enumerationMutation(v14);
          }
          char v18 = *(void **)(*((void *)&v31 + 1) + 8 * i);
          if (([v18 isDefaultPathRule] & 1) == 0)
          {
            *(_OWORD *)__p = 0u;
            long long v30 = 0u;
            *(_OWORD *)v27 = 0u;
            long long v28 = 0u;
            sub_100733DCC(v27, a1, v18);
            uint64_t v19 = *(void *)(a4 + 24);
            if (!v19) {
              sub_10007B600();
            }
            if (((*(uint64_t (**)(uint64_t, void **))(*(void *)v19 + 48))(v19, v27) & 1) == 0)
            {
              uint64_t v40 = 0;
              char v20 = (uint64_t **)sub_100046ED4((uint64_t)&v35, &v40, v27);
              if (!*v20)
              {
                uint64_t v39 = 0;
                v38[0] = operator new(0x60uLL);
                v38[1] = &v36;
                LOBYTE(v39) = 0;
                sub_1000D8424((void *)(v38[0] + 32), (long long *)v27);
                LOBYTE(v39) = 1;
                uint64_t v21 = v40;
                uint64_t v22 = (uint64_t *)v38[0];
                *(void *)v38[0] = 0;
                v22[1] = 0;
                v22[2] = v21;
                *char v20 = v22;
                if (*v35)
                {
                  uint64_t v35 = (uint64_t **)*v35;
                  uint64_t v22 = *v20;
                }
                sub_100046C90(v36, v22);
                ++v37;
                v38[0] = 0;
                sub_1000DC414((uint64_t)v38, 0);
              }
            }
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            if (SBYTE7(v28) < 0) {
              operator delete(v27[0]);
            }
          }
        }
        id v15 = [v14 countByEnumeratingWithState:&v31 objects:v41 count:16];
      }
      while (v15);
    }

    uint64_t v8 = v26;
    sub_1000DC1F8(v25, (uint64_t)&v35, 1);
    uint64_t v23 = v36;
    uint64_t v24 = (void **)&v35;
  }
  else
  {
    v27[1] = 0;
    *(void *)&long long v28 = 0;
    v27[0] = &v27[1];
    sub_1000DC1F8(a2, (uint64_t)v27, 1);
    uint64_t v23 = (uint64_t *)v27[1];
    uint64_t v24 = v27;
  }
  sub_1000DC24C((uint64_t)v24, v23);

LABEL_34:
}

void sub_1007345F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

id sub_1007346D4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 124) && *(unsigned char *)(a1 + 123))
  {
    uint64_t v3 = (id *)(a1 + 208);
    id v2 = *(void **)(a1 + 208);
    if (v2)
    {
      unint64_t v4 = [v2 pathController];

      if (!v4)
      {
        id v5 = objc_alloc_init((Class)NEPathController);
        [v5 setEnabled:1];
        [*v3 setPathController:v5];
        uint64_t v6 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v14 = 0;
          uint64_t v7 = "#I Existing mirroring network extension cellular data usage configuration was missing path controller, setting a new one";
          uint64_t v8 = (uint8_t *)&v14;
LABEL_11:
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, v8, 2u);
          goto LABEL_12;
        }
        goto LABEL_12;
      }
    }
  }
  else
  {
    uint64_t v3 = (id *)(a1 + 192);
    char v9 = *(void **)(a1 + 192);
    if (v9)
    {
      id v10 = [v9 pathController];

      if (!v10)
      {
        id v5 = objc_alloc_init((Class)NEPathController);
        [v5 setEnabled:1];
        [*v3 setPathController:v5];
        uint64_t v6 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v13 = 0;
          uint64_t v7 = "#I Existing network extension cellular data usage configuration was missing path controller, setting a new one";
          uint64_t v8 = (uint8_t *)&v13;
          goto LABEL_11;
        }
LABEL_12:
      }
    }
  }
  id v11 = *v3;

  return v11;
}

void sub_100734820(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100734834()
{
  sub_100058DB0(&__p, "/cc/prefs-nb/ne_config_state");
  ctu::RestModule::getPropertyOnce();
  if (v1 < 0) {
    operator delete(__p);
  }
}

void sub_1007348E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100734904(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_null)
  {
    sub_100058DB0(&__p, "/cc/prefs-nb/ne_config_state");
    xpc_object_t object = xpc_BOOL_create(*(unsigned char *)(a1 + 40));
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    ctu::RestModule::setProperty();
    xpc_release(object);
    if (v8 < 0) {
      operator delete(__p);
    }
    unint64_t v4 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 40)) {
        id v5 = "true";
      }
      else {
        id v5 = "false";
      }
      *(_DWORD *)buf = 136315138;
      id v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I A new ne config was created in this build: %s", buf, 0xCu);
    }
  }
}

void sub_100734A2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100734A78(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  char v8 = sub_1007346D4(a1);
  if (v8)
  {
    sub_1000E725C((uint64_t)v11, a3);
    sub_100734C98(a1, a2, (uint64_t)v11, a4);
    sub_1000E0D60(v11);
  }
  else
  {
    uint64_t v12 = a1;
    sub_1000EDA4C(v13, (uint64_t)a2);
    sub_1000E725C((uint64_t)v14, a3);
    char v15 = a4;
    unint64_t v17 = 0;
    char v9 = operator new(0x50uLL);
    uint64_t v10 = v12;
    *char v9 = off_101A01740;
    v9[1] = v10;
    sub_1000EDA4C(v9 + 2, (uint64_t)v13);
    sub_1000EC8E8((uint64_t)(v9 + 5), (uint64_t)v14);
    *((unsigned char *)v9 + 72) = v15;
    unint64_t v17 = v9;
    (*(void (**)(uint64_t, void *))(*(void *)a1 + 160))(a1, v16);
    sub_100278CB4(v16);
    sub_1000E0D60(v14);
    sub_1000D9674((uint64_t)v13, (char *)v13[1]);
  }
}

void sub_100734BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  sub_100278CB4((uint64_t *)va1);
  sub_100734C60((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t sub_100734C60(uint64_t a1)
{
  return a1;
}

void sub_100734C98(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (a2[2])
  {
    v29 = 0;
    uint64_t v30 = 0;
    long long v28 = &v29;
    uint64_t v7 = a2 + 1;
    uint64_t v6 = (void *)*a2;
    if ((void *)*a2 != a2 + 1)
    {
      char v8 = (os_log_t *)(a1 + 40);
      do
      {
        uint64_t v9 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          asString((uint64_t)(v6 + 4), &__p);
          uint64_t v10 = v27 >= 0 ? &__p : (void **)__p;
          *(_DWORD *)buf = 136446210;
          v41 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Adding CU Policy: %{public}s", buf, 0xCu);
          if (SHIBYTE(v27) < 0) {
            operator delete(__p);
          }
        }
        __p = 0;
        char v26 = 0;
        uint64_t v27 = 0;
        sub_1002777D8((void *)a1, (uint64_t)(v6 + 4), a4, (uint64_t)&__p);
        sub_100735504((os_log_t *)(a1 + 40), (uint64_t)&v28, &__p);
        sub_10005CD2C((uint64_t)&__p, v26);
        uint64_t v11 = (void *)v6[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = v11;
            uint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            uint64_t v12 = (void *)v6[2];
            BOOL v13 = *v12 == (void)v6;
            uint64_t v6 = v12;
          }
          while (!v13);
        }
        uint64_t v6 = v12;
      }
      while (v12 != v7);
    }
    if (sub_100277550(&v28))
    {
      char v26 = 0;
      uint64_t v27 = 0;
      __p = &v26;
      sub_1000D2234(a3, (uint64_t)&__p, 1);
      sub_10005CD2C((uint64_t)&__p, v26);
    }
    else
    {
      uint64_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p) = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Policy changed. Saving NE configuration next", (uint8_t *)&__p, 2u);
      }
      uint64_t v16 = sub_100735420(a1, a4, v15);
      uint64_t v31 = a1;
      sub_1000EDA4C(v32, (uint64_t)a2);
      sub_1000DB02C((uint64_t *)&v33, (uint64_t)&v28);
      sub_1000E725C((uint64_t)v36, a3);
      char v37 = a4;
      uint64_t v39 = 0;
      unint64_t v17 = operator new(0x68uLL);
      uint64_t v18 = v31;
      void *v17 = off_101A01840;
      v17[1] = v18;
      sub_1000EDA4C(v17 + 2, (uint64_t)v32);
      uint64_t v20 = (uint64_t)v33;
      uint64_t v19 = v34;
      v17[6] = v34;
      uint64_t v21 = (char *)(v17 + 6);
      v17[5] = v20;
      uint64_t v22 = v35;
      v17[7] = v35;
      if (v22)
      {
        *((void *)v19 + 2) = v21;
        long long v33 = &v34;
        long long v34 = 0;
        uint64_t v35 = 0;
      }
      else
      {
        v17[5] = v21;
      }
      sub_1000EC8E8((uint64_t)(v17 + 8), (uint64_t)v36);
      *((unsigned char *)v17 + 96) = v37;
      uint64_t v39 = v17;
      sub_1007335B8(a1, v16, (uint64_t)v38);
      sub_100278CB4(v38);
      sub_1000E0D60(v36);
      sub_10005CD2C((uint64_t)&v33, v34);
      sub_1000D9674((uint64_t)v32, (char *)v32[1]);
    }
  }
  else
  {
    v29 = 0;
    uint64_t v30 = 0;
    long long v28 = &v29;
    sub_1000D2234(a3, (uint64_t)&v28, 1);
  }
  sub_10005CD2C((uint64_t)&v28, v29);
}

void sub_100734FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v11 = va_arg(va1, void);
  BOOL v13 = va_arg(va1, char *);
  uint64_t v14 = va_arg(va1, void);
  sub_100278CB4((void *)(v9 - 144));
  sub_10073582C((uint64_t)va1);

  sub_10005CD2C((uint64_t)va, v13);
  _Unwind_Resume(a1);
}

void sub_1007350A4(void **a1, void *a2, uint64_t *a3, int a4)
{
  char v4 = a4;
  char v8 = sub_100735420((uint64_t)a1, a4, a3);
  if (!v8)
  {
    v30[1] = a1;
    sub_1000C6BDC(v31, (uint64_t)a2);
    sub_10073F338((uint64_t)v32, (uint64_t)a3);
    char v34 = v4;
    v36 = 0;
    uint64_t v25 = operator new(0x50uLL);
    void *v25 = off_101A017C0;
    v25[1] = a1;
    sub_1000C6BDC(v25 + 2, (uint64_t)v31);
    if (v33)
    {
      if (v33 == v32)
      {
        v25[8] = v25 + 5;
        (*(void (**)(void *))(v32[0] + 24))(v32);
        goto LABEL_26;
      }
      char v26 = &v33;
      v25[8] = v33;
    }
    else
    {
      char v26 = v25 + 8;
    }
    *char v26 = 0;
LABEL_26:
    *((unsigned char *)v25 + 72) = v34;
    v36 = v25;
    (*((void (**)(void **, void *))*a1 + 20))(a1, v35);
    sub_100278CB4(v35);
    sub_1000EDB30(v32);
    sub_10005CD2C((uint64_t)v31, (char *)v31[1]);
    goto LABEL_27;
  }
  uint64_t v27 = 0;
  long long v28 = 0;
  unint64_t v29 = 0;
  uint64_t v12 = (void *)*a2;
  uint64_t v10 = a2 + 1;
  uint64_t v11 = v12;
  if (v12 != v10)
  {
    do
    {
      BOOL v13 = v11 + 4;
      uint64_t v14 = v11 + 4;
      if (*((char *)v11 + 55) < 0) {
        uint64_t v14 = (void *)*v13;
      }
      uint64_t v15 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14, v27);
      uint64_t v16 = [v8 pathController];
      id v17 = [v16 copyPathRuleBySigningIdentifier:v15];
      BOOL v18 = v17 == 0;

      if (!v18)
      {
        uint64_t v19 = v28;
        if ((unint64_t)v28 >= v29)
        {
          uint64_t v21 = (unsigned char *)sub_100048008(&v27, (long long *)v11 + 2);
        }
        else
        {
          if (*((char *)v11 + 55) < 0)
          {
            sub_10004FC84(v28, (void *)v11[4], v11[5]);
          }
          else
          {
            long long v20 = *(_OWORD *)v13;
            *((void *)v28 + 2) = v11[6];
            *uint64_t v19 = v20;
          }
          uint64_t v21 = (char *)v19 + 24;
        }
        long long v28 = v21;
      }

      uint64_t v22 = (void *)v11[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          uint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (void *)v11[2];
          BOOL v24 = *v23 == (void)v11;
          uint64_t v11 = v23;
        }
        while (!v24);
      }
      uint64_t v11 = v23;
    }
    while (v23 != v10);
  }
  sub_1007354B4(a3[3], (uint64_t)&v27, 1);
  v30[0] = (void **)&v27;
  sub_100047F64(v30);
LABEL_27:
}

void sub_100735374(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

id sub_100735420(uint64_t a1, int a2, id a3)
{
  if (a2 == 2)
  {
    sub_1007346D4(a1);
    id v4 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    if (a2 == 1)
    {
      uint64_t v3 = *(void **)(a1 + 208);
    }
    else
    {
      if (a2) {
        goto LABEL_9;
      }
      uint64_t v3 = *(void **)(a1 + 192);
    }
    id v4 = v3;
  }
  a3 = v4;
LABEL_9:

  return a3;
}

uint64_t sub_10073547C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1007354B4(uint64_t a1, uint64_t a2, char a3)
{
  char v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, a2, &v4);
}

void sub_100735504(os_log_t *a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3 + 1;
  char v4 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    uint64_t v7 = (uint64_t *)(a2 + 8);
    do
    {
      char v8 = v4 + 4;
      uint64_t v21 = 0;
      uint64_t v9 = (uint64_t **)sub_100046ED4(a2, &v21, (void **)v4 + 4);
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v7 == v10)
        {
          uint64_t v16 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
          {
            if (*((char *)v4 + 55) < 0) {
              char v8 = (void *)*v8;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = v8;
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "failed to insert change for %{public}s", buf, 0xCu);
          }
        }
        else
        {
          *(_OWORD *)buf = 0u;
          long long v25 = 0u;
          uint64_t v11 = (uint64_t *)v10[1];
          uint64_t v12 = v10;
          if (v11)
          {
            do
            {
              BOOL v13 = v11;
              uint64_t v11 = (uint64_t *)*v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              BOOL v13 = (uint64_t *)v12[2];
              BOOL v14 = *v13 == (void)v12;
              uint64_t v12 = v13;
            }
            while (!v14);
          }
          if (*(uint64_t **)a2 == v10) {
            *(void *)a2 = v13;
          }
          uint64_t v15 = *(uint64_t **)(a2 + 8);
          --*(void *)(a2 + 16);
          sub_10005EE6C(v15, v10);
          if (*((char *)v10 + 55) < 0)
          {
            sub_10004FC84(buf, (void *)v10[4], v10[5]);
          }
          else
          {
            *(_OWORD *)buf = *((_OWORD *)v10 + 2);
            *(void *)&long long v25 = v10[6];
          }
          DWORD2(v25) = *((_DWORD *)v10 + 14);
          char v23 = 0;
          uint64_t v21 = &v23;
          char v22 = 1;
          sub_1000C6EE8((uint64_t)&v21, (void **)v10);
          if (*((unsigned __int8 *)v4 + 56) != BYTE8(v25))
          {
            BYTE8(v25) = *((unsigned char *)v4 + 56);
            BYTE10(v25) ^= 1u;
          }
          if (*((unsigned __int8 *)v4 + 57) != BYTE9(v25))
          {
            BYTE9(v25) = *((unsigned char *)v4 + 57);
            BYTE11(v25) ^= 1u;
          }
          uint64_t v21 = 0;
          id v17 = (uint64_t **)sub_100046ED4(a2, &v21, (void **)buf);
          if (!*v17)
          {
            BOOL v18 = operator new(0x40uLL);
            v18[2] = *(_OWORD *)buf;
            *((void *)v18 + 6) = v25;
            *(void *)&long long v25 = 0;
            memset(buf, 0, sizeof(buf));
            *((_DWORD *)v18 + 14) = DWORD2(v25);
            sub_100046C38((uint64_t **)a2, (uint64_t)v21, v17, (uint64_t *)v18);
          }
          if (SBYTE7(v25) < 0) {
            operator delete(*(void **)buf);
          }
        }
      }
      else
      {
        memset(buf, 0, sizeof(buf));
        *(void *)&long long v25 = 0;
        sub_1000DB1A0(a2, (uint64_t)(v4 + 4), buf);
        sub_100046C38((uint64_t **)a2, (uint64_t)v21, v9, *(uint64_t **)buf);
      }
      uint64_t v19 = (void *)v4[1];
      if (v19)
      {
        do
        {
          long long v20 = v19;
          uint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          long long v20 = (void *)v4[2];
          BOOL v14 = *v20 == (void)v4;
          char v4 = v20;
        }
        while (!v14);
      }
      char v4 = v20;
    }
    while (v20 != v3);
  }
}

void sub_1007357E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, char a13, int a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  a18 = 0;
  a12 = &a18;
  a13 = 1;
  sub_1000C6EE8((uint64_t)&a12, v24);
  _Unwind_Resume(a1);
}

uint64_t sub_10073582C(uint64_t a1)
{
  return a1;
}

void sub_100735870(void *a1, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    if (*((void *)a2 + 1))
    {
LABEL_3:
      uint64_t v6 = sub_1007346D4((uint64_t)a1);
      if (v6)
      {
        *(_OWORD *)__p = 0u;
        long long v15 = 0u;
        *(_OWORD *)uint64_t v12 = 0u;
        long long v13 = 0u;
        (*(void (**)(void **__return_ptr, void *, long long *, uint64_t))(*a1 + 192))(v12, a1, a2, 1);
        sub_1000D8E0C(a3, (uint64_t)v12, 1);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if ((SBYTE7(v13) & 0x80000000) == 0) {
          goto LABEL_24;
        }
        uint64_t v7 = v12[0];
      }
      else
      {
        uint64_t v16 = a1;
        if (*((char *)a2 + 23) < 0)
        {
          sub_10004FC84(&v17, *(void **)a2, *((void *)a2 + 1));
        }
        else
        {
          long long v17 = *a2;
          uint64_t v18 = *((void *)a2 + 2);
        }
        sub_1000EE0FC((uint64_t)v19, a3);
        uint64_t v21 = 0;
        uint64_t v9 = operator new(0x48uLL);
        uint64_t v10 = v16;
        *uint64_t v9 = off_101A018C0;
        v9[1] = v10;
        uint64_t v11 = v9 + 2;
        if (SHIBYTE(v18) < 0)
        {
          sub_10004FC84(v11, (void *)v17, *((unint64_t *)&v17 + 1));
        }
        else
        {
          *(_OWORD *)uint64_t v11 = v17;
          v9[4] = v18;
        }
        sub_1000D90C8((uint64_t)(v9 + 5), (uint64_t)v19);
        uint64_t v21 = v9;
        (*(void (**)(void *, void *))(*a1 + 160))(a1, v20);
        sub_100278CB4(v20);
        sub_1000EA288(v19);
        if ((SHIBYTE(v18) & 0x80000000) == 0) {
          goto LABEL_24;
        }
        uint64_t v7 = (void *)v17;
      }
      operator delete(v7);
LABEL_24:

      return;
    }
  }
  else if (*((unsigned char *)a2 + 23))
  {
    goto LABEL_3;
  }
  char v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E Bundle ID is empty", (uint8_t *)v12, 2u);
  }
  sub_100734054(v12, (uint64_t)a1, a2);
  sub_1000D8E0C(a3, (uint64_t)v12, 0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (SBYTE7(v13) < 0) {
    operator delete(v12[0]);
  }
}

void sub_100735AF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  operator delete(v25);
  sub_1000D2CE0((uint64_t)&a18);

  _Unwind_Resume(a1);
}

void sub_100735B78(void *a1, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    if (*((void *)a2 + 1))
    {
LABEL_3:
      uint64_t v6 = sub_1007346D4((uint64_t)a1);
      if (v6)
      {
        *(_OWORD *)__p = 0u;
        long long v15 = 0u;
        *(_OWORD *)uint64_t v12 = 0u;
        long long v13 = 0u;
        (*(void (**)(void **__return_ptr, void *, long long *, void))(*a1 + 192))(v12, a1, a2, 0);
        sub_1000D8E0C(a3, (uint64_t)v12, 1);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if ((SBYTE7(v13) & 0x80000000) == 0) {
          goto LABEL_24;
        }
        uint64_t v7 = v12[0];
      }
      else
      {
        uint64_t v16 = a1;
        if (*((char *)a2 + 23) < 0)
        {
          sub_10004FC84(&v17, *(void **)a2, *((void *)a2 + 1));
        }
        else
        {
          long long v17 = *a2;
          uint64_t v18 = *((void *)a2 + 2);
        }
        sub_1000EE0FC((uint64_t)v19, a3);
        uint64_t v21 = 0;
        uint64_t v9 = operator new(0x48uLL);
        uint64_t v10 = v16;
        *uint64_t v9 = off_101A01940;
        v9[1] = v10;
        uint64_t v11 = v9 + 2;
        if (SHIBYTE(v18) < 0)
        {
          sub_10004FC84(v11, (void *)v17, *((unint64_t *)&v17 + 1));
        }
        else
        {
          *(_OWORD *)uint64_t v11 = v17;
          v9[4] = v18;
        }
        sub_1000D90C8((uint64_t)(v9 + 5), (uint64_t)v19);
        uint64_t v21 = v9;
        (*(void (**)(void *, void *))(*a1 + 160))(a1, v20);
        sub_100278CB4(v20);
        sub_1000EA288(v19);
        if ((SHIBYTE(v18) & 0x80000000) == 0) {
          goto LABEL_24;
        }
        uint64_t v7 = (void *)v17;
      }
      operator delete(v7);
LABEL_24:

      return;
    }
  }
  else if (*((unsigned char *)a2 + 23))
  {
    goto LABEL_3;
  }
  char v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E Bundle ID is empty", (uint8_t *)v12, 2u);
  }
  sub_100734054(v12, (uint64_t)a1, a2);
  sub_1000D8E0C(a3, (uint64_t)v12, 0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (SBYTE7(v13) < 0) {
    operator delete(v12[0]);
  }
}

void sub_100735DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  operator delete(v25);
  sub_1000D2CE0((uint64_t)&a18);

  _Unwind_Resume(a1);
}

void sub_100735E80(uint64_t a1, void *a2)
{
  if (a2[2])
  {
    char v4 = sub_1007346D4(a1);
    if (v4)
    {
      uint64_t v6 = (void *)*a2;
      if ((void *)*a2 != a2 + 1)
      {
        do
        {
          (*(void (**)(uint64_t, void *))(*(void *)a1 + 184))(a1, v6 + 4);
          uint64_t v7 = (void *)v6[1];
          if (v7)
          {
            do
            {
              char v8 = v7;
              uint64_t v7 = (void *)*v7;
            }
            while (v7);
          }
          else
          {
            do
            {
              char v8 = (void *)v6[2];
              BOOL v9 = *v8 == (void)v6;
              uint64_t v6 = v8;
            }
            while (!v9);
          }
          uint64_t v6 = v8;
        }
        while (v8 != a2 + 1);
      }
      uint64_t v14 = a1;
      uint64_t v10 = v15;
      sub_1000C6BDC(v15, (uint64_t)a2);
      uint64_t v19 = 0;
      uint64_t v11 = operator new(0x28uLL);
      void *v11 = off_101A01A40;
      v11[1] = a1;
      sub_1000C6BDC(v11 + 2, (uint64_t)v15);
      uint64_t v19 = v11;
      sub_1007335B8(a1, v4, (uint64_t)v18);
      sub_100278CB4(v18);
      uint64_t v12 = &v14;
    }
    else
    {
      uint64_t v16 = a1;
      uint64_t v10 = v17;
      sub_1000C6BDC(v17, (uint64_t)a2);
      uint64_t v21 = 0;
      long long v13 = operator new(0x28uLL);
      void *v13 = off_101A019C0;
      v13[1] = a1;
      sub_1000C6BDC(v13 + 2, (uint64_t)v17);
      uint64_t v21 = v13;
      (*(void (**)(uint64_t, void *))(*(void *)a1 + 160))(a1, v20);
      sub_100278CB4(v20);
      uint64_t v12 = &v16;
    }
    sub_10005CD2C((uint64_t)v10, (char *)v12[2]);
  }
}

void sub_100736094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char *a16)
{
  sub_100278CB4((void *)(v18 - 88));
  sub_10005CD2C(v17, a16);

  _Unwind_Resume(a1);
}

void *sub_100736110(void **a1, uint64_t a2, uint64_t a3)
{
  v7[0] = off_101A01AC0;
  v7[3] = v7;
  sub_1000E725C((uint64_t)v6, a3);
  sub_1007361E4(a1, a2, 0, (uint64_t)v7, (uint64_t)v6);
  sub_1000E0D60(v6);
  return sub_100740A5C(v7);
}

void sub_1007361C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1000E0D60((uint64_t *)va);
  sub_100740A5C((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void sub_1007361E4(void **a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v41 = sub_1007346D4((uint64_t)a1);
  if (v41)
  {
    id v8 = objc_alloc((Class)NSMutableArray);
    BOOL v9 = [v41 pathController];
    uint64_t v10 = [v9 pathRules];
    id v11 = [v8 initWithArray:v10];

    uint64_t v48 = 0;
    uint64_t v49 = 0;
    uint64_t v47 = &v48;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    id v12 = v11;
    id v13 = [v12 countByEnumeratingWithState:&v43 objects:v64 count:16];
    id v42 = v12;
    if (v13)
    {
      uint64_t v14 = *(void *)v44;
      do
      {
        for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v44 != v14) {
            objc_enumerationMutation(v12);
          }
          uint64_t v16 = *(void **)(*((void *)&v43 + 1) + 8 * i);
          id v17 = [v16 wifiBehavior];
          uint64_t v18 = *(void *)(a4 + 24);
          __p[0] = v17;
          if (!v18) {
            sub_10007B600();
          }
          if (((*(uint64_t (**)(uint64_t, void **))(*(void *)v18 + 48))(v18, __p) & 1) != 0
            && (*(unsigned int (**)(void *, void *, uint64_t))(*a1[6] + 8))(a1[6], v16, a2))
          {
            id v19 = [v16 matchSigningIdentifier];
            long long v20 = (char *)[v19 UTF8String];
            id v21 = [v16 cellularBehavior];
            if (v21 == (id)1) {
              char v22 = 2;
            }
            else {
              char v22 = v21 != (id)2;
            }
            uint64_t v52 = 0;
            char v23 = (char *)operator new(0x40uLL);
            BOOL v50 = v23;
            uint64_t v51 = &v48;
            LOBYTE(v52) = 0;
            sub_100058DB0(__p, v20);
            BOOL v24 = v23 + 32;
            if (SHIBYTE(v54) < 0)
            {
              sub_10004FC84(v24, __p[0], (unint64_t)__p[1]);
              int v25 = SHIBYTE(v54);
              v23[56] = v22;
              v23[57] = a2;
              *((_WORD *)v23 + 29) = 256;
              if (v25 < 0) {
                operator delete(__p[0]);
              }
            }
            else
            {
              *(_OWORD *)BOOL v24 = *(_OWORD *)__p;
              *((void *)v23 + 6) = v54;
              v23[56] = v22;
              v23[57] = a2;
              *((_WORD *)v23 + 29) = 256;
            }
            LOBYTE(v52) = 1;
            __p[0] = 0;
            id v12 = v42;
            char v26 = (uint64_t **)sub_100046ED4((uint64_t)&v47, __p, (void **)v50 + 4);
            if (*v26)
            {
              uint64_t v27 = (void **)v50;
              BOOL v50 = 0;
              if (v27) {
                sub_1000C6EE8((uint64_t)&v51, v27);
              }
            }
            else
            {
              long long v28 = __p[0];
              unint64_t v29 = (uint64_t *)v50;
              *(void *)BOOL v50 = 0;
              v29[1] = 0;
              v29[2] = (uint64_t)v28;
              *char v26 = v29;
              if (*v47)
              {
                uint64_t v47 = (uint64_t **)*v47;
                unint64_t v29 = *v26;
              }
              sub_100046C90(v48, v29);
              ++v49;
            }
          }
        }
        id v13 = [v12 countByEnumeratingWithState:&v43 objects:v64 count:16];
      }
      while (v13);
    }

    if (!sub_100277550(&v47) || a3)
    {
      uint64_t v31 = [v41 pathController];
      [v31 setPathRules:v42];

      uint64_t v55 = a1;
      char v56 = a2;
      sub_100740BB4((uint64_t)v57, a4);
      sub_1000DB02C((uint64_t *)&v58, (uint64_t)&v47);
      sub_1000E725C((uint64_t)v61, a5);
      unint64_t v63 = 0;
      id v12 = v42;
      long long v32 = operator new(0x70uLL);
      long long v33 = v55;
      *long long v32 = off_101A01C50;
      v32[1] = v33;
      *((unsigned char *)v32 + 16) = v56;
      sub_100740F8C((uint64_t)(v32 + 3), (uint64_t)v57);
      uint64_t v35 = (uint64_t)v58;
      char v34 = v59;
      v32[8] = v59;
      v36 = (char *)(v32 + 8);
      v32[7] = v35;
      uint64_t v37 = v60;
      v32[9] = v60;
      if (v37)
      {
        *((void *)v34 + 2) = v36;
        uint64_t v58 = &v59;
        uint64_t v59 = 0;
        uint64_t v60 = 0;
      }
      else
      {
        v32[7] = v36;
      }
      sub_1000EC8E8((uint64_t)(v32 + 10), (uint64_t)v61);
      unint64_t v63 = v32;
      sub_1007335B8((uint64_t)a1, v41, (uint64_t)v62);
      sub_100278CB4(v62);
      sub_1000E0D60(v61);
      sub_10005CD2C((uint64_t)&v58, v59);
      sub_100740A5C(v57);
    }
    else
    {
      __p[1] = 0;
      uint64_t v54 = 0;
      __p[0] = &__p[1];
      sub_1000D2234(a5, (uint64_t)__p, 1);
      sub_10005CD2C((uint64_t)__p, (char *)__p[1]);
    }
    sub_10005CD2C((uint64_t)&v47, (char *)v48);
  }
  else
  {
    v65 = a1;
    char v66 = a2;
    sub_100740BB4((uint64_t)v67, a4);
    char v68 = a3;
    sub_1000E725C((uint64_t)v69, a5);
    uint64_t v71 = 0;
    uint64_t v30 = operator new(0x60uLL);
    *uint64_t v30 = off_101A01BD0;
    v30[1] = a1;
    *((unsigned char *)v30 + 16) = v66;
    sub_100740F8C((uint64_t)(v30 + 3), (uint64_t)v67);
    *((unsigned char *)v30 + 56) = v68;
    sub_1000EC8E8((uint64_t)(v30 + 8), (uint64_t)v69);
    uint64_t v71 = v30;
    ((void (*)(void **, void *))(*a1)[20])(a1, v70);
    sub_100278CB4(v70);
    sub_1000E0D60(v69);
    sub_100740A5C(v67);
  }
}

void sub_100736790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, int a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,char *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  _Unwind_Resume(a1);
}

void *sub_1007368FC(void **a1, uint64_t a2, uint64_t a3)
{
  v7[0] = off_101A01B50;
  v7[3] = v7;
  sub_1000E725C((uint64_t)v6, a3);
  sub_1007361E4(a1, a2, 0, (uint64_t)v7, (uint64_t)v6);
  sub_1000E0D60(v6);
  return sub_100740A5C(v7);
}

void sub_1007369AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1000E0D60((uint64_t *)va);
  sub_100740A5C((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007369D0(uint64_t a1)
{
  return a1;
}

void *sub_100736A10(uint64_t a1, uint64_t a2)
{
  sub_1000E725C((uint64_t)v4, a2);
  sub_100736AA0(a1, 0, (uint64_t)v4);
  return sub_1000E0D60(v4);
}

void sub_100736A84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E0D60((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100736AA0(uint64_t a1, int a2, uint64_t a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 80));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v7;
  id v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  uint64_t v41 = a3;
  if (v11)
  {
    uint64_t v13 = v11[3];
    id v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  id v12 = 0;
  char v14 = 1;
LABEL_9:
  char v15 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 72))(v13);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (v15)
  {
    long long v43 = sub_1007346D4(a1);
    if (v43)
    {
      id v16 = objc_alloc((Class)NSMutableArray);
      id v17 = [v43 pathController];
      uint64_t v18 = [v17 pathRules];
      id v19 = [v16 initWithArray:v18];

      v53[0] = 0;
      v53[1] = 0;
      *(void *)buf = v53;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      id v20 = v19;
      id v21 = [v20 countByEnumeratingWithState:&v48 objects:v60 count:16];
      if (v21)
      {
        uint64_t v22 = *(void *)v49;
        do
        {
          for (uint64_t i = 0; i != v21; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v49 != v22) {
              objc_enumerationMutation(v20);
            }
            BOOL v24 = *(void **)(*((void *)&v48 + 1) + 8 * i);
            if (![v24 cellularBehavior]
              && (*(unsigned int (**)(void, void *, void))(**(void **)(a1 + 48) + 8))(*(void *)(a1 + 48), v24, 0))
            {
              id v25 = [v24 matchSigningIdentifier];
              char v26 = (char *)[v25 UTF8String];
              id v27 = [v24 cellularBehavior];
              char v28 = v27 != (id)2;
              if (v27 == (id)1) {
                char v28 = 2;
              }
              LOBYTE(v44) = v28;
              __int16 v47 = 0;
              char v46 = 1;
              sub_10074184C((uint64_t **)buf, v26, (char *)&v44, (char *)&v47 + 1, (char *)&v47, &v46);
            }
          }
          id v21 = [v20 countByEnumeratingWithState:&v48 objects:v60 count:16];
        }
        while (v21);
      }

      if (!sub_100277550(buf) || a2)
      {
        char v34 = [v43 pathController];
        [v34 setPathRules:v20];

        *(void *)&long long v54 = a1;
        sub_1000DB02C((uint64_t *)&v54 + 1, (uint64_t)buf);
        sub_1000E725C((uint64_t)v57, v41);
        uint64_t v59 = 0;
        uint64_t v35 = (char *)operator new(0x48uLL);
        v36 = v35;
        *(void *)uint64_t v35 = off_101A01D50;
        *(_OWORD *)(v35 + 8) = v54;
        uint64_t v37 = v55;
        uint64_t v38 = v56;
        *((void *)v35 + 3) = v55;
        uint64_t v39 = v35 + 24;
        *((void *)v35 + 4) = v38;
        if (v38)
        {
          *((void *)v37 + 2) = v39;
          *((void *)&v54 + 1) = &v55;
          uint64_t v55 = 0;
          uint64_t v56 = 0;
        }
        else
        {
          *((void *)v35 + 2) = v39;
        }
        sub_1000EC8E8((uint64_t)(v35 + 40), (uint64_t)v57);
        uint64_t v59 = v36;
        sub_1007335B8(a1, v43, (uint64_t)v58);
        sub_100278CB4(v58);
        sub_1000E0D60(v57);
        unint64_t v29 = v55;
        uint64_t v30 = (char *)&v54 + 8;
      }
      else
      {
        v45[0] = 0;
        v45[1] = 0;
        long long v44 = v45;
        sub_1000D2234(v41, (uint64_t)&v44, 1);
        unint64_t v29 = (char *)v45[0];
        uint64_t v30 = (char *)&v44;
      }
      sub_10005CD2C((uint64_t)v30, v29);
      sub_10005CD2C((uint64_t)buf, v53[0]);
    }
    else
    {
      uint64_t v61 = a1;
      char v62 = a2;
      sub_1000E725C((uint64_t)v63, v41);
      v65 = 0;
      long long v32 = operator new(0x38uLL);
      uint64_t v33 = v61;
      *long long v32 = off_101A01CD0;
      v32[1] = v33;
      *((unsigned char *)v32 + 16) = v62;
      sub_1000EC8E8((uint64_t)(v32 + 3), (uint64_t)v63);
      v65 = v32;
      (*(void (**)(uint64_t, void *))(*(void *)a1 + 160))(a1, v64);
      sub_100278CB4(v64);
      sub_1000E0D60(v63);
    }
  }
  else
  {
    uint64_t v31 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#N Skipped fixing policies on a non special SKU device", buf, 2u);
    }
  }
}

void sub_100736FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,char *a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  sub_100278CB4(&a37);
  sub_1000D5548((uint64_t)&a29);
  sub_10005CD2C((uint64_t)&a25, a26);

  _Unwind_Resume(a1);
}

void sub_1007370D0(void *a1, uint64_t a2)
{
  uint64_t v5 = sub_1007346D4((uint64_t)a1);
  uint64_t v6 = v5;
  if (v5)
  {
    uint64_t v7 = [v5 pathController];
    id v8 = [v7 pathRules];

    long long v26 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v23 = 0u;
    id v9 = v8;
    id v10 = [v9 countByEnumeratingWithState:&v23 objects:v29 count:16];
    if (v10)
    {
      uint64_t v11 = *(void *)v24;
      while (2)
      {
        for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v24 != v11) {
            objc_enumerationMutation(v9);
          }
          uint64_t v13 = *(void **)(*((void *)&v23 + 1) + 8 * i);
          if ([v13 isDefaultPathRule])
          {
            *(_OWORD *)__p = 0u;
            long long v22 = 0u;
            *(_OWORD *)id v19 = 0u;
            long long v20 = 0u;
            sub_100733DCC(v19, (uint64_t)a1, v13);
            char v14 = a1[5];
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              asString((uint64_t)v19, v17);
              char v15 = v18 >= 0 ? v17 : (void **)v17[0];
              *(_DWORD *)buf = 136446210;
              char v28 = v15;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Returning default behavior for ne configuration: %{public}s", buf, 0xCu);
              if (v18 < 0) {
                operator delete(v17[0]);
              }
            }
            sub_1000D8E0C(a2, (uint64_t)v19, 1);
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            if (SBYTE7(v20) < 0) {
              operator delete(v19[0]);
            }

            goto LABEL_25;
          }
        }
        id v10 = [v9 countByEnumeratingWithState:&v23 objects:v29 count:16];
        if (v10) {
          continue;
        }
        break;
      }
    }

    *(_OWORD *)__p = 0u;
    long long v22 = 0u;
    *(_OWORD *)id v19 = 0u;
    long long v20 = 0u;
    sub_1000D8E0C(a2, (uint64_t)v19, 0);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (SBYTE7(v20) < 0) {
      operator delete(v19[0]);
    }
LABEL_25:
  }
  else
  {
    uint64_t v30 = a1;
    sub_1000EE0FC((uint64_t)v31, a2);
    uint64_t v33 = 0;
    id v16 = operator new(0x30uLL);
    void *v16 = off_101A01DD0;
    v16[1] = a1;
    sub_1000D90C8((uint64_t)(v16 + 2), (uint64_t)v31);
    uint64_t v33 = v16;
    (*(void (**)(void *, void *))(*a1 + 160))(a1, v32);
    sub_100278CB4(v32);
    sub_1000EA288(v31);
  }
}

void sub_1007373C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000CB908((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_100737450(void *a1, void *a2, uint64_t a3)
{
  uint64_t v7 = sub_1007346D4((uint64_t)a1);
  if (v7)
  {
    v20[0] = 0;
    v20[1] = 0;
    id v19 = (uint64_t *)v20;
    id v10 = (void *)*a2;
    id v8 = a2 + 1;
    id v9 = v10;
    if (v10 != v8)
    {
      do
      {
        *(_OWORD *)__p = 0u;
        long long v18 = 0u;
        *(_OWORD *)char v15 = 0u;
        long long v16 = 0u;
        (*(void (**)(void **__return_ptr, void *, void *, void))(*a1 + 192))(v15, a1, v9 + 4, 0);
        sub_1000DC300(&v19, v15, (long long *)v15);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if (SBYTE7(v16) < 0) {
          operator delete(v15[0]);
        }
        uint64_t v11 = (void *)v9[1];
        if (v11)
        {
          do
          {
            id v12 = v11;
            uint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            id v12 = (void *)v9[2];
            BOOL v13 = *v12 == (void)v9;
            id v9 = v12;
          }
          while (!v13);
        }
        id v9 = v12;
      }
      while (v12 != v8);
    }
    sub_1000DC1F8(a3, (uint64_t)&v19, 1);
    sub_1000DC24C((uint64_t)&v19, v20[0]);
  }
  else
  {
    v20[2] = a1;
    sub_1000C6BDC(v21, (uint64_t)a2);
    sub_1000DC0E0((uint64_t)v22, a3);
    long long v24 = 0;
    char v14 = operator new(0x48uLL);
    *char v14 = off_101A01E50;
    v14[1] = a1;
    sub_1000C6BDC(v14 + 2, (uint64_t)v21);
    sub_1000DC178((uint64_t)(v14 + 5), (uint64_t)v22);
    long long v24 = v14;
    (*(void (**)(void *, void *))(*a1 + 160))(a1, v23);
    sub_100278CB4(v23);
    sub_1000DBB60(v22);
    sub_10005CD2C((uint64_t)v21, (char *)v21[1]);
  }
}

void sub_100737688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  sub_100278CB4((void *)(v13 - 104));
  sub_10073770C((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t sub_10073770C(uint64_t a1)
{
  return a1;
}

void sub_100737744(uint64_t a1@<X0>, long long *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (*((char *)a2 + 23) >= 0) {
    id v8 = (uint64_t *)a2;
  }
  else {
    id v8 = *(uint64_t **)a2;
  }
  id v9 = +[NSString stringWithUTF8String:v8];
  if (a3)
  {
    id v10 = +[NEPathController copyAggregatePathRules];
  }
  else
  {
    uint64_t v11 = sub_1007346D4(a1);
    id v12 = [v11 pathController];
    id v10 = [v12 pathRules];
  }
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  sub_100734054((void *)a4, a1, a2);
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  id v13 = v10;
  id v14 = [v13 countByEnumeratingWithState:&v37 objects:v41 count:16];
  if (!v14) {
    goto LABEL_41;
  }
  uint64_t v15 = *(void *)v38;
  while (2)
  {
    for (uint64_t i = 0; i != v14; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v38 != v15) {
        objc_enumerationMutation(v13);
      }
      id v17 = *(void **)(*((void *)&v37 + 1) + 8 * i);
      long long v18 = [v17 matchSigningIdentifier];
      unsigned int v19 = [v18 isEqualToString:v9];

      if (v19)
      {
        sub_100733DCC(&__str, a1, v17);
        std::string::operator=((std::string *)a4, &__str);
        *(_WORD *)(a4 + 24) = v33;
        if (&__str == (std::string *)a4)
        {
LABEL_37:
          *(_WORD *)(a4 + 56) = v36;
          if (__p)
          {
            uint64_t v35 = (char *)__p;
            operator delete(__p);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          goto LABEL_41;
        }
        long long v20 = *(char **)(a4 + 32);
        id v21 = (char *)__p;
        long long v22 = v35;
        size_t v23 = v35 - (unsigned char *)__p;
        unint64_t v24 = *(void *)(a4 + 48);
        if (v24 - (unint64_t)v20 >= v35 - (unsigned char *)__p)
        {
          id v27 = *(unsigned char **)(a4 + 40);
          size_t v28 = v27 - v20;
          if (v27 - v20 < v23)
          {
            unint64_t v29 = (char *)__p + v28;
            if (v27 != v20)
            {
              memmove(*(void **)(a4 + 32), __p, v28);
              long long v20 = *(char **)(a4 + 40);
            }
            if (v22 != v29) {
              memmove(v20, v29, v22 - v29);
            }
            uint64_t v30 = &v20[v22 - v29];
            goto LABEL_36;
          }
        }
        else
        {
          if (v20)
          {
            *(void *)(a4 + 40) = v20;
            operator delete(v20);
            unint64_t v24 = 0;
            *(void *)(a4 + 32) = 0;
            *(void *)(a4 + 40) = 0;
            *(void *)(a4 + 48) = 0;
          }
          if ((v23 & 0x8000000000000000) != 0) {
            sub_1000D8578();
          }
          uint64_t v25 = 2 * v24;
          if (2 * v24 <= v23) {
            uint64_t v25 = v23;
          }
          if (v24 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v26 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v26 = v25;
          }
          sub_1000D8534((void *)(a4 + 32), v26);
          long long v20 = *(char **)(a4 + 40);
        }
        if (v22 != v21) {
          memmove(v20, v21, v23);
        }
        uint64_t v30 = &v20[v23];
LABEL_36:
        *(void *)(a4 + 40) = v30;
        goto LABEL_37;
      }
    }
    id v14 = [v13 countByEnumeratingWithState:&v37 objects:v41 count:16];
    if (v14) {
      continue;
    }
    break;
  }
LABEL_41:
}

void sub_100737A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100737ACC(void *result, uint64_t a2, unsigned char *a3)
{
  if (*(void *)(a2 + 40))
  {
    uint64_t v5 = result;
    memset(v18, 0, sizeof(v18));
    sub_1007424C0((uint64_t)v18, *(void *)(*(void *)(a2 + 8) + ((*(void *)(a2 + 32) >> 4) & 0xFFFFFFFFFFFFFF8))+ 32 * (*(void *)(a2 + 32) & 0x7FLL));
    uint64_t v6 = (std::__shared_weak_count *)v5[2];
    if (!v6 || (v7 = v5[1], (id v8 = std::__shared_weak_count::lock(v6)) == 0)) {
      sub_100088B9C();
    }
    id v9 = v8;
    p_shared_weak_owners = &v8->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v8);
    dispatch_time_t v11 = dispatch_time(0, 1000000000);
    id v12 = v5[3];
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3321888768;
    v14[2] = sub_100737CF8;
    v14[3] = &unk_101A01168;
    void v14[4] = v7;
    uint64_t v15 = v9;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    long long v16 = a3;
    sub_1007424C0((uint64_t)v17, (uint64_t)v18);
    v17[4] = a2;
    dispatch_after(v11, v12, v14);
    sub_100278CB4((void *)(*(void *)(*(void *)(a2 + 8) + ((*(void *)(a2 + 32) >> 4) & 0xFFFFFFFFFFFFFF8))
                           + 32 * (*(void *)(a2 + 32) & 0x7FLL)));
    int64x2_t v13 = vaddq_s64(*(int64x2_t *)(a2 + 32), (int64x2_t)xmmword_10144F900);
    *(int64x2_t *)(a2 + 32) = v13;
    if (v13.i64[0] >= 0x100uLL)
    {
      operator delete(**(void ***)(a2 + 8));
      *(void *)(a2 + 8) += 8;
      *(void *)(a2 + 32) -= 128;
    }
    sub_100278CB4(v17);
    if (v15) {
      std::__shared_weak_count::__release_weak(v15);
    }
    std::__shared_weak_count::__release_weak(v9);
    return sub_100278CB4(v18);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

void sub_100737CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  std::__shared_weak_count::__release_weak(v21);
  sub_100278CB4(&a21);
  _Unwind_Resume(a1);
}

void sub_100737CF8(uint64_t a1)
{
  uint64_t v10 = 0;
  dispatch_time_t v11 = 0;
  id v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2 && (v3 = std::__shared_weak_count::lock(v2), (dispatch_time_t v11 = v3) != 0))
  {
    char v4 = v3;
    uint64_t v5 = *(const void **)(a1 + 32);
    id v12 = 0;
    int64x2_t v13 = 0;
    if (v5)
    {
      if (v6)
      {
        id v12 = v6;
        int64x2_t v13 = v4;
        uint64_t v7 = (void **)&v10;
        goto LABEL_8;
      }
    }
  }
  else
  {
    id v12 = 0;
    int64x2_t v13 = 0;
  }
  uint64_t v7 = &v12;
LABEL_8:
  void *v7 = 0;
  v7[1] = 0;
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v8 = v12;
  if (v12)
  {
    **(unsigned char **)(a1 + 48) = 0;
    sub_100737E2C(*(void *)(a1 + 80), 1);
    if (!**(unsigned char **)(a1 + 48))
    {
      if (*(void *)(*(void *)(a1 + 88) + 40)) {
        sub_100737ACC(v8);
      }
    }
  }
  id v9 = v13;
  if (v13)
  {
    sub_10004D2C8(v9);
  }
}

void sub_100737E14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100737E2C(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

uint64_t sub_100737E7C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_1007424C0(a1 + 56, a2 + 56);
}

void sub_100737EC0(_Unwind_Exception *exception_object)
{
  char v3 = *(std::__shared_weak_count **)(v1 + 40);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100737ED8(uint64_t a1)
{
  sub_100278CB4((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100737F24(uint64_t a1, uint64_t a2)
{
  char v4 = sub_1007346D4(a1);
  sub_1007424C0((uint64_t)v5, a2);
  sub_1007335B8(a1, v4, (uint64_t)v5);
  sub_100278CB4(v5);
}

void sub_100737FB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100278CB4((uint64_t *)va);

  _Unwind_Resume(a1);
}

void sub_100737FE0(uint64_t a1, void *a2)
{
  id v3 = a2;
  char v4 = v3;
  uint64_t v5 = *(void *)(a1 + 48);
  if (!v3 || [v3 code] == (id)5 || objc_msgSend(v4, "code") == (id)9)
  {
    uint64_t v6 = [*(id *)(a1 + 40) name];
    sub_1007424C0((uint64_t)v11, a1 + 56);
    int64x2_t v13 = 0;
    uint64_t v7 = operator new(0x30uLL);
    void *v7 = off_101A01FD0;
    v7[1] = v5;
    sub_1007424C0((uint64_t)(v7 + 2), (uint64_t)v11);
    int64x2_t v13 = v7;
    sub_1007385B0((void *)v5, v6, (uint64_t)v12);
    sub_100060644(v12);
    sub_100278CB4(v11);
  }
  else
  {
    id v8 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      uint64_t v19 = v10;
      __int16 v20 = 2112;
      id v21 = v4;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to save the network extension configuration: %@ error: %@", buf, 0x16u);
    }
    sub_100737ACC((void *)v5, v5 + 144, (unsigned char *)(v5 + 121));
    if ([v4 code] == (id)20)
    {
      sub_1007382B8(v5, (uint64_t)"size limit exceeded");
      uint64_t v14 = v5;
      sub_1007424C0((uint64_t)v15, a1 + 56);
      id v17 = 0;
      id v9 = operator new(0x30uLL);
      *id v9 = off_101A01ED0;
      v9[1] = v5;
      sub_1007424C0((uint64_t)(v9 + 2), (uint64_t)v15);
      id v17 = v9;
      (*(void (**)(uint64_t, void *))(*(void *)v5 + 96))(v5, v16);
      sub_1000E0D60(v16);
      sub_100278CB4(v15);
    }
    else
    {
      sub_100737E2C(*(void *)(a1 + 80), 0);
    }
  }
}

void sub_100738234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  sub_1000E0D60((uint64_t *)va);
  sub_100278CB4(v16);

  _Unwind_Resume(a1);
}

void sub_1007382B8(uint64_t a1, uint64_t a2)
{
  if (qword_101B0D620 != -1) {
    dispatch_once(&qword_101B0D620, &stru_101A013B0);
  }
  if (byte_101B0D618)
  {
    id v4 = objc_alloc_init((Class)SDRDiagnosticReporter);
    uint64_t v5 = [v4 signatureWithDomain:@"Telephony" type:@"Assert" subType:@"NE Config" subtypeContext:@"Duplicate Config" detectedProcess:@"Commcenter" triggerThresholdValues:0];
    id v6 = objc_alloc_init((Class)NSMutableDictionary);
    [v6 setObject:&__kCFBooleanFalse forKey:kSymptomDiagnosticActionGetNetworkInfo];
    [v6 setObject:&__kCFBooleanFalse forKey:kSymptomDiagnosticActionCrashAndSpinLogs];
    [v6 setObject:&__kCFBooleanTrue forKey:kSymptomDiagnosticActionDiagnosticExtensions];
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"AutoBugCapture - Assert, NE Config (%s)", a2];
    uint64_t v16 = kSymptomDiagnosticKeyPayloadDEParameters;
    v13[1] = v7;
    CFStringRef v14 = @"com.apple.DiagnosticExtensions.Cellular";
    v12[0] = @"CellularExtensionCommandKey";
    v12[1] = @"CellularExtensionDumpReasonKey";
    v13[0] = @"dump_attach";
    id v8 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:2];
    uint64_t v15 = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    id v17 = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:&v17 forKeys:&v16 count:1];

    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10073DA9C;
    v11[3] = &unk_101A01348;
    void v11[4] = a1;
    [v4 snapshotWithSignature:v5 delay:0 events:v10 payload:v6 actions:v11 reply:0.0];
  }
}

void sub_100738550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007385B0(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = +[NSString stringWithUTF8String:"com.apple.commcenter.ne.cellularusage"];
  id v7 = +[NSString stringWithUTF8String:"com.apple.commcenter.ne.cellularusage.mirror"];
  if ([v5 isEqualToString:v6])
  {
    id v8 = (id *)(a1 + 24);
LABEL_5:
    id v9 = [*v8 identifier];
    goto LABEL_9;
  }
  if ([v5 isEqualToString:v7])
  {
    id v8 = (id *)(a1 + 26);
    goto LABEL_5;
  }
  uint64_t v10 = a1[5];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138543362;
    id v23 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No config named %{public}@", buf, 0xCu);
  }
  id v9 = 0;
LABEL_9:
  dispatch_time_t v11 = (void *)a1[27];
  uint64_t v12 = a1[3];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3321888768;
  v16[2] = sub_100738838;
  void v16[3] = &unk_101A011D8;
  __int16 v20 = a1;
  sub_1000DFC90((uint64_t)v21, a3);
  id v13 = v5;
  id v17 = v13;
  id v14 = v6;
  id v18 = v14;
  id v15 = v7;
  id v19 = v15;
  [v11 loadConfigurationWithID:v9 withCompletionQueue:v12 handler:v16];

  sub_100060644(v21);
}

void sub_1007387C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  sub_100060644(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100738824(uint64_t a1, uint64_t a2)
{
  return sub_1007424C0(a1 + 56, a2 + 56);
}

void *sub_100738830(uint64_t a1)
{
  return sub_100278CB4((void *)(a1 + 56));
}

void sub_100738838(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 56);
  *(unsigned char *)(v7 + 122) = 0;
  if (v6)
  {
    id v8 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v22 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Error occured loading configuration: %@", buf, 0xCu);
    }
    sub_1000607A8(a1 + 64, 0);
    goto LABEL_5;
  }
  if (v5)
  {
    id v9 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      id v22 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Reloaded network extension configuration: %{public}@", buf, 0xCu);
    }
    goto LABEL_16;
  }
  int v11 = *(unsigned __int8 *)(v7 + 121);
  uint64_t v12 = *(NSObject **)(v7 + 40);
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (!v11)
  {
    if (v13)
    {
      id v15 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      id v22 = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Reloading NEConfiguration deleted from under us: %{public}@", buf, 0xCu);
    }
    sub_100738B90(v7, (uint64_t)[*(id *)(a1 + 32) UTF8String], 1);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
LABEL_16:
    buf[0] = 0;
    if ([*(id *)(a1 + 32) isEqualToString:*(void *)(a1 + 40)])
    {
      uint64_t v16 = (id *)(v7 + 192);
    }
    else
    {
      if (![*(id *)(a1 + 32) isEqualToString:*(void *)(a1 + 48)]) {
        goto LABEL_22;
      }
      uint64_t v16 = (id *)(v7 + 208);
    }
    sub_100738DF8(v7, v5, v16, buf);
    if (buf[0])
    {
      sub_1000DFC90((uint64_t)v18, a1 + 64);
      __int16 v20 = 0;
      id v17 = operator new(0x30uLL);
      void *v17 = off_101A02050;
      v17[1] = v7;
      sub_1000DFC90((uint64_t)(v17 + 2), (uint64_t)v18);
      __int16 v20 = v17;
      (*(void (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, v19);
      sub_1000E0D60(v19);
      sub_100060644(v18);
      goto LABEL_5;
    }
LABEL_22:
    sub_100733D60();
  }
  if (v13)
  {
    id v14 = *(void **)(a1 + 32);
    *(_DWORD *)buf = 138543362;
    id v22 = v14;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Did not reload network extension configuration: %{public}@.  Save is in progress, will try again when next save loads the config", buf, 0xCu);
  }
  *(unsigned char *)(v7 + 122) = 1;
  sub_1000607A8(a1 + 64, 0);
  id v5 = 0;
LABEL_5:
}

void sub_100738B2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100738B90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = +[NSString stringWithUTF8String:a2];
  id v6 = [objc_alloc((Class)NEConfiguration) initWithName:v5 grade:2];
  uint64_t v7 = [v6 pathController];

  if (v7)
  {
    id v8 = [v6 pathController];
    [v8 setEnabled:a3];
  }
  else
  {
    id v8 = objc_alloc_init((Class)NEPathController);
    [v8 setEnabled:a3];
    [v6 setPathController:v8];
  }

  id v9 = v6;
  id v11 = objc_alloc((Class)NSMutableArray);
  uint64_t v12 = [v9 pathController];
  BOOL v13 = [v12 pathRules];
  id v14 = [v11 initWithArray:v13];

  id v15 = [objc_alloc((Class)NEPathRule) initDefaultPathRule];
  (*(void (**)(void, id, void))(**(void **)(a1 + 64) + 8))(*(void *)(a1 + 64), v15, byte_101B13D98);
  (*(void (**)(void, id, void))(**(void **)(a1 + 48) + 8))(*(void *)(a1 + 48), v15, byte_101B13ED8);
  [v14 addObject:v15];
  uint64_t v16 = [v9 pathController];
  [v16 setPathRules:v14];

  return v9;
}

void sub_100738D7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100738DF8(uint64_t a1, void *a2, id *a3, unsigned char *a4)
{
  id v8 = a2;
  if (a4) {
    *a4 = 0;
  }
  if (a3)
  {
    if (*a3 && ([*a3 isEqual:v8] & 1) == 0)
    {
      id v9 = *a3;
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        id v17 = v9;
        id v18 = [v9 name];
        uint64_t v16 = [v9 identifier];
        id v19 = [v16 UUIDString];
        id v11 = *a3;
        uint64_t v12 = [v8 name];
        BOOL v13 = [v8 identifier];
        id v14 = [v13 UUIDString];
        *(_DWORD *)buf = 138544642;
        id v21 = v18;
        __int16 v22 = 2114;
        id v23 = v19;
        __int16 v24 = 2048;
        id v25 = v11;
        __int16 v26 = 2114;
        id v27 = v12;
        __int16 v28 = 2114;
        unint64_t v29 = v14;
        __int16 v30 = 2048;
        id v31 = v8;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Overriding old NE Config %{public}@ %{public}@ at %p with new config %{public}@ %{public}@ at %p", buf, 0x3Eu);

        id v9 = v17;
      }
      sub_1007382B8(a1, (uint64_t)"already set");
      if (a4) {
        *a4 = 1;
      }
    }
    objc_storeStrong(a3, a2);
  }
  else
  {
    id v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "Failed to pass in an output location for setting the configuration", buf, 2u);
    }
  }
}

void sub_100739030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007390AC(uint64_t a1, uint64_t a2)
{
  return sub_1000DFC90(a1 + 64, a2 + 64);
}

void *sub_1007390B8(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 64));
}

uint64_t sub_1007390C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!v3 || ([v3 isDefaultPathRule] & 1) != 0)
  {
LABEL_15:
    uint64_t v18 = 0;
    goto LABEL_16;
  }
  id v5 = [v4 matchSigningIdentifier];
  id v6 = (char *)[v5 UTF8String];

  if (!v6)
  {
    id v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Rule has no signing identifier", (uint8_t *)__p, 2u);
    }
    goto LABEL_15;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 80));
  id v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v9;
  BOOL v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_18:
    std::mutex::unlock(v8);
    id v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_10;
    }
LABEL_19:
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v34 = 0;
    sub_100058DB0(__p, v6);
    if ((*(uint64_t (**)(uint64_t, void **))(*(void *)v15 + 128))(v15, __p))
    {
      uint64_t v21 = 0;
LABEL_36:
      uint64_t v18 = v21 ^ [v4 isIdentifierExternal];
      if (v18 == 1) {
        [v4 setIsIdentifierExternal:v21];
      }
      if (SHIBYTE(v34) < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_40;
    }
    id v31 = 0;
    v32[0] = 0;
    v32[1] = 0;
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 224) + 72))(&v31);
    LOBYTE(v35) = 0;
    if (v32 != sub_1000D85D4(v31, v32, (unsigned __int8 **)__p))
    {
      uint64_t v21 = 1;
LABEL_35:
      sub_10005CD2C((uint64_t)&v31, v32[0]);
      goto LABEL_36;
    }
    __int16 v22 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 80));
    id v23 = v22;
    if ((v24 & 0x8000000000000000) != 0)
    {
      id v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v26 = 5381;
      do
      {
        unint64_t v24 = v26;
        unsigned int v27 = *v25++;
        uint64_t v26 = (33 * v26) ^ v27;
      }
      while (v27);
    }
    std::mutex::lock(v22);
    unint64_t v35 = v24;
    __int16 v28 = sub_10004D37C(&v23[1].__m_.__sig, &v35);
    if (v28)
    {
      uint64_t v21 = v28[3];
      unint64_t v29 = (std::__shared_weak_count *)v28[4];
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v23);
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        char v30 = 0;
LABEL_31:
        if (v21) {
          uint64_t v21 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v21 + 48))(v21, __p);
        }
        if ((v30 & 1) == 0) {
          sub_10004D2C8(v29);
        }
        goto LABEL_35;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v23);
    unint64_t v29 = 0;
    char v30 = 1;
    goto LABEL_31;
  }
  uint64_t v15 = v13[3];
  id v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_18;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (v15) {
    goto LABEL_19;
  }
LABEL_10:
  id v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not get SB services", (uint8_t *)__p, 2u);
  }
  uint64_t v18 = 0;
LABEL_40:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
LABEL_16:

  return v18;
}

void sub_100739440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, char *a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  sub_10005CD2C((uint64_t)&a10, a11);
  if (a18 < 0) {
    operator delete(__p);
  }
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v19);
  }

  _Unwind_Resume(a1);
}

id sub_1007394C8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v3 = +[NSString stringWithUTF8String:a2];
    id v4 = [objc_alloc((Class)NEPathRule) initWithSigningIdentifier:v3];
    sub_1007390C0(a1, v4);
  }
  else
  {
    id v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not create NE rule with nil bundle ID", v7, 2u);
    }
    id v4 = 0;
  }

  return v4;
}

void sub_100739598(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1007395B4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    a2 = *(void *)a2;
  }
  id v3 = sub_1007394C8(a1, a2);
  (*(void (**)(void, void *))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), v3);
  (*(void (**)(void, void *))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), v3);

  return v3;
}

void sub_10073965C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10073966C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, int a5)
{
  v67 = sub_100735420(a1, a5, v8);
  unint64_t v63 = [v67 name];
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    *(void *)&uint8_t buf[4] = v63;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Current NEConfiguration: %{public}@", buf, 0xCu);
  }
  id v10 = objc_alloc((Class)NSMutableArray);
  uint64_t v11 = [v67 pathController];
  unsigned int v12 = [v11 pathRules];
  id v64 = [v10 initWithArray:v12];

  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 80));
  id v14 = ServiceMap;
  if (v15 < 0)
  {
    char v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v15;
  id v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  if (v19)
  {
    uint64_t v21 = v19[3];
    __int16 v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v60 = v20;
      sub_10004D2C8(v20);
      char v22 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v14);
  uint64_t v60 = 0;
  char v22 = 1;
LABEL_11:
  char v68 = 0;
  v69[0] = 0;
  v69[1] = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(buf, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)buf = *(_OWORD *)a3;
    *(void *)&long long v75 = *(void *)(a3 + 16);
  }
  sub_1000EA30C((uint64_t)&v68, (void **)buf, 1);
  if (SBYTE7(v75) < 0) {
    operator delete(*(void **)buf);
  }
  id v23 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 80));
  unint64_t v24 = v23;
  if (v25 < 0)
  {
    uint64_t v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(v23);
  *(void *)buf = v25;
  unint64_t v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
  char v62 = v22;
  if (!v29)
  {
    uint64_t v31 = 0;
    goto LABEL_23;
  }
  uint64_t v31 = v29[3];
  char v30 = (std::__shared_weak_count *)v29[4];
  if (!v30)
  {
LABEL_23:
    std::mutex::unlock(v24);
    char v30 = 0;
    char v32 = 1;
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v24);
  atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v30);
  char v32 = 0;
LABEL_24:
  int v33 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 16))(v31);
  if (v21) {
    int v35 = v33;
  }
  else {
    int v35 = 0;
  }
  if (v35 == 1)
  {
    *(_OWORD *)buf = 0u;
    long long v75 = 0u;
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v21 + 48))(buf, v21, a3);
    if (BYTE8(v75))
    {
      sub_1000F29CC((uint64_t **)&v68, (void **)buf, (uint64_t)buf);
      if (v36)
      {
        long long v37 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          if (a4 > 2) {
            long long v38 = "???";
          }
          else {
            long long v38 = off_101A02608[(char)a4];
          }
          long long v39 = *(uint8_t **)buf;
          if ((SBYTE7(v75) & 0x80u) == 0) {
            long long v39 = buf;
          }
          *(_DWORD *)v70 = 136446466;
          uint64_t v71 = v39;
          __int16 v72 = 2082;
          v73 = v38;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Will set counterpart rule for %{public}s with value %{public}s", v70, 0x16u);
        }
      }
      if (BYTE8(v75) && SBYTE7(v75) < 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  long long v40 = (uint64_t *)v68;
  if (v68 == v69) {
    goto LABEL_75;
  }
  char v41 = 0;
  *(void *)&long long v34 = 136446210;
  long long v59 = v34;
  do
  {
    if (*((char *)v40 + 55) < 0)
    {
      if (!v40[5]) {
        goto LABEL_63;
      }
LABEL_48:
      id v42 = objc_msgSend(v67, "pathController", v59);
      id v43 = objc_alloc((Class)NSString);
      long long v44 = v40 + 4;
      if (*((char *)v40 + 55) < 0)
      {
        char v46 = (uint64_t *)v40[4];
        uint64_t v45 = v40[5];
      }
      else
      {
        uint64_t v45 = *((unsigned __int8 *)v40 + 55);
        char v46 = v40 + 4;
      }
      id v47 = [v43 initWithBytesNoCopy:v46 length:v45 encoding:4 freeWhenDone:0];
      id v48 = [v42 copyPathRuleBySigningIdentifier:v47];

      if (v48)
      {
        int v49 = (*(uint64_t (**)(void, id, uint64_t))(*(void *)*a2 + 8))(*a2, v48, a4);
        if (((sub_1007390C0(a1, v48) | v49) & 1) == 0)
        {
LABEL_62:

          goto LABEL_63;
        }
        [v64 removeObject:v48];
      }
      else
      {
        sub_1007395B4(a1, (uint64_t)(v40 + 4));
        id v48 = (id)objc_claimAutoreleasedReturnValue();
        (*(void (**)(void))(*(void *)*a2 + 8))();
      }
      unsigned __int8 v50 = [v48 isIdentifierExternal];
      if (v21) {
        char v51 = v50;
      }
      else {
        char v51 = 1;
      }
      if ((v51 & 1) != 0 || (*(unsigned int (**)(uint64_t, uint64_t *))(*(void *)v21 + 128))(v21, v40 + 4))
      {
        [v64 addObject:v48];
        char v41 = 1;
      }
      else
      {
        uint64_t v52 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        {
          if (*((char *)v40 + 55) < 0) {
            long long v44 = (void *)*v44;
          }
          *(_DWORD *)buf = v59;
          *(void *)&uint8_t buf[4] = v44;
          _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%{public}s is not an installed bundle or external identifier", buf, 0xCu);
        }
      }
      goto LABEL_62;
    }
    if (*((unsigned char *)v40 + 55)) {
      goto LABEL_48;
    }
LABEL_63:
    unint64_t v53 = (char *)v40[1];
    if (v53)
    {
      do
      {
        long long v54 = (char **)v53;
        unint64_t v53 = *(char **)v53;
      }
      while (v53);
    }
    else
    {
      do
      {
        long long v54 = (char **)v40[2];
        BOOL v55 = *v54 == (char *)v40;
        long long v40 = (uint64_t *)v54;
      }
      while (!v55);
    }
    long long v40 = (uint64_t *)v54;
  }
  while (v54 != v69);
  if (v41)
  {
    uint64_t v56 = [v67 pathController];
    [v56 setPathRules:v64];

    uint64_t v57 = 1;
    goto LABEL_76;
  }
LABEL_75:
  uint64_t v57 = 0;
LABEL_76:
  sub_10005CD2C((uint64_t)&v68, v69[0]);
  if ((v62 & 1) == 0) {
    sub_10004D2C8(v60);
  }

  return v57;
}

void sub_100739D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, int a14, char a15, void *a16, void *a17, uint64_t a18, uint64_t a19, void *a20,char a21,char *a22)
{
  sub_10005CD2C((uint64_t)&a21, a22);
  if ((a15 & 1) == 0) {
    sub_10004D2C8(a12);
  }

  _Unwind_Resume(a1);
}

id sub_100739E40(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    id v3 = a2;
  }
  else {
    id v3 = (uint64_t *)*a2;
  }
  id v4 = +[NSString stringWithUTF8String:v3];
  if (*(unsigned char *)(a1 + 124) && *(unsigned char *)(a1 + 123))
  {
    id v5 = [*(id *)(a1 + 208) pathController];
    id v6 = [v5 removePathRuleBySigningIdentifier:v4];
  }
  else
  {
    id v5 = [*(id *)(a1 + 192) pathController];
    id v6 = [v5 removePathRuleBySigningIdentifier:v4];
  }
  id v7 = v6;

  return v7;
}

void sub_100739EE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100739F00(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v17 objects:v24 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v18;
    while (2)
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v7) {
          objc_enumerationMutation(v5);
        }
        uint64_t v9 = *(void *)(*((void *)&v17 + 1) + 8 * i);
        id v10 = sub_1007346D4((uint64_t)v4);
        uint64_t v11 = v10;
        if (v10)
        {
          unsigned int v12 = objc_msgSend(v10, "identifier", (void)v17);
          unsigned int v13 = [v12 isEqual:v9];

          if (v13)
          {
            id v14 = v4[5];
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v15 = [v11 name];
              *(_DWORD *)buf = 138543362;
              id v23 = v15;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Handling ne configuration change notification for %{public}@", buf, 0xCu);
            }
            char v16 = [v11 name];
            v21[0] = off_101A02150;
            v21[1] = v4;
            uint64_t v21[3] = v21;
            sub_1007385B0(v4, v16, (uint64_t)v21);
            sub_100060644(v21);

            goto LABEL_14;
          }
        }
      }
      id v6 = [v5 countByEnumeratingWithState:&v17 objects:v24 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
LABEL_14:
}

void sub_10073A0F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10073A150(uint64_t a1, uint64_t a2)
{
  id v4 = sub_1007346D4(a1);
  if (v4)
  {
    sub_100737E2C(*(void *)(a2 + 24), 2);
  }
  else
  {
    id v5 = *(void **)(a1 + 216);
    uint64_t v6 = *(void *)(a1 + 24);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3321888768;
    v7[2] = sub_10073A27C;
    v7[3] = &unk_101A01228;
    void v7[4] = a1;
    sub_1007424C0((uint64_t)v8, a2);
    [v5 loadConfigurationsWithCompletionQueue:v6 handler:v7];
    sub_100278CB4(v8);
  }
}

void sub_10073A254(_Unwind_Exception *a1)
{
  sub_100278CB4(v2);

  _Unwind_Resume(a1);
}

void sub_10073A27C(uint64_t a1, void *a2, void *a3)
{
  id v47 = a2;
  id v5 = a3;
  uint64_t v6 = *(void *)(a1 + 32);
  id v46 = v5;
  if (!v5)
  {
    uint64_t v45 = sub_1007346D4(v6);
    if (v45)
    {
      sub_100737E2C(*(void *)(a1 + 64), 2);
LABEL_46:

      goto LABEL_47;
    }
    uint64_t v44 = a1;
    id v8 = +[NSString stringWithUTF8String:"com.apple.commcenter.ne.cellularusage"];
    int v49 = +[NSString stringWithUTF8String:"com.apple.commcenter.ne.cellularusage.mirror"];
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    id obj = v47;
    id v9 = [obj countByEnumeratingWithState:&v50 objects:v58 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v51;
      uint64_t v11 = (id *)(v6 + 192);
      unsigned int v12 = (id *)(v6 + 208);
      do
      {
        for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v51 != v10) {
            objc_enumerationMutation(obj);
          }
          id v14 = *(void **)(*((void *)&v50 + 1) + 8 * i);
          uint64_t v15 = [v14 name];
          unsigned int v16 = [v15 isEqualToString:v8];

          if (v16)
          {
            sub_100738DF8(v6, v14, (id *)(v6 + 192), 0);
            long long v17 = [*v11 pathController];
            [v17 setEnabled:0];

            long long v18 = *(NSObject **)(v6 + 40);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              id v19 = *v11;
              *(_DWORD *)buf = 134217984;
              id v60 = v19;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Found existing network extension cellular data usage configuration (%p)", buf, 0xCu);
            }
          }
          if (*(unsigned char *)(v6 + 123))
          {
            long long v20 = [v14 name];
            unsigned int v21 = [v20 isEqualToString:v49];

            if (v21)
            {
              sub_100738DF8(v6, v14, (id *)(v6 + 208), 0);
              char v22 = [*v12 pathController];
              [v22 setEnabled:0];

              id v23 = *(NSObject **)(v6 + 40);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                id v24 = *v12;
                *(_DWORD *)buf = 134217984;
                id v60 = v24;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Found existing mirroring network extension cellular data usage configuration (%p)", buf, 0xCu);
              }
            }
          }
        }
        id v9 = [obj countByEnumeratingWithState:&v50 objects:v58 count:16];
      }
      while (v9);
    }

    uint64_t v25 = (id *)(v6 + 208);
    if (!*(void *)(v6 + 208))
    {
      if (*(unsigned char *)(v6 + 123))
      {
        int v35 = sub_100738B90(v6, (uint64_t)"com.apple.commcenter.ne.cellularusage.mirror", 0);
        sub_100738DF8(v6, v35, (id *)(v6 + 208), 0);

        *(unsigned char *)(v6 + 120) = 1;
        char v36 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          id v37 = *v25;
          *(_DWORD *)buf = 134217984;
          id v60 = v37;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Created new mirrored network extension cellular data usage configuration (%p)", buf, 0xCu);
        }
      }
    }
    uint64_t v26 = (id *)(v6 + 192);
    if (!*(void *)(v6 + 192))
    {
      uint64_t v27 = sub_100738B90(v6, (uint64_t)"com.apple.commcenter.ne.cellularusage", 0);
      sub_100738DF8(v6, v27, (id *)(v6 + 192), 0);

      *(unsigned char *)(v6 + 120) = 1;
      unsigned int v28 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        id v29 = *v26;
        *(_DWORD *)buf = 134217984;
        id v60 = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Created new custom network extension cellular data usage configuration (%p)", buf, 0xCu);
      }
    }
    if (*(unsigned char *)(v6 + 124) && *(unsigned char *)(v6 + 123))
    {
      char v30 = [*v25 pathController];
      [v30 setEnabled:1];

      sub_100734834();
      uint64_t v31 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        char v32 = "#I Current configuration is set to mirrored config";
LABEL_31:
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v32, buf, 2u);
      }
    }
    else
    {
      int v33 = [*v26 pathController];
      [v33 setEnabled:1];

      sub_100734834();
      uint64_t v31 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        char v32 = "#I Current configuration is set to custom config";
        goto LABEL_31;
      }
    }
    if (*(unsigned char *)(v6 + 136)) {
      BOOL v34 = *(void *)(v6 + 128) < 2uLL;
    }
    else {
      BOOL v34 = 1;
    }
    long long v38 = sub_10073AA48(v6, obj);
    id v39 = [v38 count];
    *(void *)(v6 + 128) = v39;
    *(unsigned char *)(v6 + 136) = 1;
    if ((unint64_t)v39 <= 1 || !v34) {
      sub_100733D60();
    }
    char v41 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      id v60 = v39;
      _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "There are %lu NE configs. Merging", buf, 0xCu);
    }
    sub_1007382B8(v6, (uint64_t)"create");
    uint64_t v54 = v6;
    sub_1007424C0((uint64_t)v55, v44 + 40);
    uint64_t v57 = 0;
    id v42 = operator new(0x30uLL);
    uint64_t v43 = v54;
    *id v42 = off_101A021D0;
    v42[1] = v43;
    sub_1007424C0((uint64_t)(v42 + 2), (uint64_t)v55);
    uint64_t v57 = v42;
    sub_10073AC44(v6, v38, (uint64_t)v56);
    sub_1000E0D60(v56);
    sub_100278CB4(v55);

    goto LABEL_46;
  }
  uint64_t v7 = *(NSObject **)(v6 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    id v60 = v46;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to load network extension configurations error: %@", buf, 0xCu);
  }
  sub_100737E2C(*(void *)(a1 + 64), 0);
LABEL_47:
}

void sub_10073A934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

id sub_10073AA48(uint64_t a1, void *a2)
{
  id v15 = a2;
  id v4 = "com.apple.commcenter.ne.cellularusage";
  if (*(unsigned char *)(a1 + 124) && *(unsigned char *)(a1 + 123)) {
    id v4 = "com.apple.commcenter.ne.cellularusage.mirror";
  }
  id v5 = objc_opt_new();
  uint64_t v6 = +[NSString stringWithUTF8String:v4];
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v7 = v15;
  id v8 = [v7 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v9) {
          objc_enumerationMutation(v7);
        }
        uint64_t v11 = *(void **)(*((void *)&v16 + 1) + 8 * i);
        unsigned int v12 = [v11 name];
        unsigned __int8 v13 = [v12 isEqualToString:v6];

        if (v13) {
          [v5 addObject:v11];
        }
      }
      id v8 = [v7 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v8);
  }

  return v5;
}

void sub_10073ABF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_10073AC44(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v43 = a3;
  id v44 = a2;
  uint64_t v56 = a1;
  long long v53 = sub_1007346D4(a1);
  if (v53)
  {
    id v46 = objc_opt_new();
    v69[0] = 0;
    v69[1] = 0;
    char v68 = v69;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    id obj = v44;
    id v52 = [obj countByEnumeratingWithState:&v64 objects:v90 count:16];
    if (v52)
    {
      uint64_t v51 = *(void *)v65;
      uint64_t v45 = (os_log_t *)(a1 + 40);
      do
      {
        for (uint64_t i = 0; i != v52; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v65 != v51) {
            objc_enumerationMutation(obj);
          }
          id v4 = *(void **)(*((void *)&v64 + 1) + 8 * i);
          id v5 = objc_msgSend(v4, "identifier", v43);
          uint64_t v6 = [v53 identifier];
          unsigned __int8 v7 = [v5 isEqual:v6];

          if ((v7 & 1) == 0)
          {
            [v46 addObject:v4];
            uint64_t v61 = 0;
            char v62 = 0;
            uint64_t v63 = 0;
            int v49 = [v4 pathController];
            id v8 = [v49 pathRules];
            id v54 = v53;
            id v50 = v8;
            char v62 = 0;
            uint64_t v63 = 0;
            uint64_t v61 = &v62;
            id v9 = objc_alloc((Class)NSMutableArray);
            uint64_t v10 = [v54 pathController];
            uint64_t v11 = [v10 pathRules];
            id v57 = [v9 initWithArray:v11];

            long long v80 = 0u;
            long long v81 = 0u;
            long long v78 = 0u;
            long long v79 = 0u;
            id v58 = v50;
            id v12 = [v58 countByEnumeratingWithState:&v78 objects:&buf count:16];
            if (v12)
            {
              uint64_t v59 = *(void *)v79;
              do
              {
                id v60 = v12;
                for (j = 0; j != v60; j = (char *)j + 1)
                {
                  if (*(void *)v79 != v59) {
                    objc_enumerationMutation(v58);
                  }
                  id v14 = *(void **)(*((void *)&v78 + 1) + 8 * (void)j);
                  if (([v14 isDefaultPathRule] & 1) == 0)
                  {
                    long long v76 = 0u;
                    long long v77 = 0u;
                    long long v75 = 0u;
                    long long v74 = 0u;
                    id v16 = v57;
                    id v17 = [v16 countByEnumeratingWithState:&v74 objects:v91 count:16];
                    if (v17)
                    {
                      uint64_t v18 = *(void *)v75;
                      while (2)
                      {
                        for (k = 0; k != v17; k = (char *)k + 1)
                        {
                          if (*(void *)v75 != v18) {
                            objc_enumerationMutation(v16);
                          }
                          long long v20 = *(void **)(*((void *)&v74 + 1) + 8 * (void)k);
                          unsigned int v21 = [v14 matchSigningIdentifier];
                          char v22 = [v20 matchSigningIdentifier];
                          unsigned __int8 v23 = [v21 isEqualToString:v22];

                          if (v23)
                          {
                            uint64_t v25 = v16;
                            goto LABEL_28;
                          }
                        }
                        id v17 = [v16 countByEnumeratingWithState:&v74 objects:v91 count:16];
                        if (v17) {
                          continue;
                        }
                        break;
                      }
                    }

                    id v24 = [v14 matchSigningIdentifier];
                    uint64_t v25 = sub_1007394C8(v56, (uint64_t)[v24 UTF8String]);

                    objc_msgSend(v25, "setCellularBehavior:", objc_msgSend(v14, "cellularBehavior"));
                    objc_msgSend(v25, "setWifiBehavior:", objc_msgSend(v14, "wifiBehavior"));
                    objc_msgSend(v25, "setIsIdentifierExternal:", objc_msgSend(v14, "isIdentifierExternal"));
                    [v16 addObject:v25];
                    id v26 = [v14 matchSigningIdentifier];
                    uint64_t v27 = (char *)[v26 UTF8String];
                    id v28 = [v14 cellularBehavior];
                    char v29 = v28 != (id)2;
                    if (v28 == (id)1) {
                      char v29 = 2;
                    }
                    char v73 = v29;
                    id v30 = [v14 wifiBehavior];
                    char v31 = v30 != (id)2;
                    if (v30 == (id)1) {
                      char v31 = 2;
                    }
                    char v72 = v31;
                    char v71 = 1;
                    char v70 = 1;
                    sub_10074184C((uint64_t **)&v61, v27, &v73, &v72, &v71, &v70);

LABEL_28:
                  }
                }
                id v12 = [v58 countByEnumeratingWithState:&v78 objects:&buf count:16];
              }
              while (v12);
            }

            char v32 = [v54 pathController];
            [v32 setPathRules:v57];

            sub_100735504(v45, (uint64_t)&v68, &v61);
            sub_10005CD2C((uint64_t)&v61, v62);
          }
        }
        id v52 = [obj countByEnumeratingWithState:&v64 objects:v90 count:16];
      }
      while (v52);
    }

    int v33 = *(NSObject **)(v56 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      id v34 = [v46 count];
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Will remove %lu duplicate configurations", (uint8_t *)&buf, 0xCu);
    }
    *(void *)&long long v82 = v56;
    *((void *)&v82 + 1) = v53;
    id v83 = [v46 count];
    sub_1000DB02C((uint64_t *)&v84, (uint64_t)&v68);
    sub_1000E725C((uint64_t)v87, v43);
    uint64_t v89 = 0;
    int v35 = (char *)operator new(0x58uLL);
    char v36 = v35;
    *(void *)int v35 = off_101A02300;
    long long v37 = v82;
    *((void *)&v82 + 1) = 0;
    *(_OWORD *)(v35 + 8) = v37;
    uint64_t v38 = (uint64_t)v84;
    *((void *)v35 + 3) = v83;
    *((void *)v35 + 4) = v38;
    id v39 = v85;
    uint64_t v40 = v86;
    *((void *)v35 + 5) = v85;
    char v41 = v35 + 40;
    *((void *)v35 + 6) = v40;
    if (v40)
    {
      *((void *)v39 + 2) = v41;
      uint64_t v84 = &v85;
      uint64_t v85 = 0;
      uint64_t v86 = 0;
    }
    else
    {
      *((void *)v35 + 4) = v41;
    }
    sub_1000EC8E8((uint64_t)(v35 + 56), (uint64_t)v87);
    uint64_t v89 = v36;
    sub_10073B664(v56, v46, (uint64_t)v88);
    sub_100060644(v88);
    sub_1000E0D60(v87);
    sub_10005CD2C((uint64_t)&v84, v85);

    sub_10005CD2C((uint64_t)&v68, v69[0]);
  }
  else
  {
    id v42 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(*(os_log_t *)(v56 + 40), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I NE configuration is not set", (uint8_t *)&buf, 2u);
    }
    *((void *)&buf + 1) = 0;
    uint64_t v93 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    sub_1000D2234(v43, (uint64_t)&buf, 0);
    sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
  }
}

void sub_10073B360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,char *a40)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10073B53C(uint64_t a1, uint64_t a2)
{
  return sub_1007424C0(a1 + 40, a2 + 40);
}

void *sub_10073B548(uint64_t a1)
{
  return sub_100278CB4((void *)(a1 + 40));
}

void *sub_10073B550(uint64_t a1, uint64_t a2)
{
  sub_10033571C((uint64_t)v6, a2);
  id v8 = 0;
  id v3 = operator new(0x30uLL);
  void *v3 = off_101A02250;
  v3[1] = a1;
  sub_1003357B4((uint64_t)(v3 + 2), (uint64_t)v6);
  id v8 = v3;
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 160))(a1, v7);
  sub_100278CB4(v7);
  return sub_1000F25E0(v6);
}

void sub_10073B638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100278CB4((uint64_t *)va);
  sub_1000F25E0(v6);
  _Unwind_Resume(a1);
}

void sub_10073B664(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if ([v5 count])
  {
    uint64_t v6 = [v5 firstObject];
    unsigned __int8 v7 = *(void **)(a1 + 216);
    uint64_t v8 = *(void *)(a1 + 24);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3321888768;
    v10[2] = sub_10073B7E8;
    v10[3] = &unk_101A01260;
    uint64_t v13 = a1;
    id v9 = v6;
    id v11 = v9;
    sub_1000DFC90((uint64_t)v14, a3);
    id v12 = v5;
    [v7 removeConfiguration:v9 withCompletionQueue:v8 handler:v10];

    sub_100060644(v14);
  }
  else
  {
    sub_1000607A8(a3, 1);
  }
}

void sub_10073B7A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  sub_100060644(v16);
  _Unwind_Resume(a1);
}

void sub_10073B7E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 48);
  id v5 = *(NSObject **)(v4 + 40);
  if (v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(v4 + 40), OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = [*(id *)(a1 + 32) identifier];
      *(_DWORD *)long long buf = 138412546;
      id v11 = v8;
      __int16 v12 = 2112;
      id v13 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to remove configuration: %@ error: %@", buf, 0x16u);
    }
    sub_1000607A8(a1 + 56, 0);
  }
  else
  {
    if (os_log_type_enabled(*(os_log_t *)(v4 + 40), OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = [*(id *)(a1 + 32) name];
      *(_DWORD *)long long buf = 138412290;
      id v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Configuration %@ removed", buf, 0xCu);
    }
    [*(id *)(a1 + 40) removeObject:*(void *)(a1 + 32)];
    uint64_t v7 = *(void *)(a1 + 40);
    sub_1000DFC90((uint64_t)v9, a1 + 56);
    sub_10073B664(v4, v7, v9);
    sub_100060644(v9);
  }
}

void sub_10073B964(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10073B994(uint64_t a1, uint64_t a2)
{
  return sub_1000DFC90(a1 + 56, a2 + 56);
}

void *sub_10073B9A0(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 56));
}

uint64_t sub_10073B9A8(uint64_t a1)
{
  return a1;
}

void *sub_10073B9E8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 216);
  uint64_t v3 = *(void *)(a1 + 24);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3321888768;
  v5[2] = sub_10073BAD0;
  v5[3] = &unk_101A01290;
  void v5[4] = a1;
  sub_1000E725C((uint64_t)v6, a2);
  [v2 loadConfigurationsWithCompletionQueue:v3 handler:v5];
  return sub_1000E0D60(v6);
}

void sub_10073BAB4(_Unwind_Exception *a1)
{
  sub_1000E0D60(v1);
  _Unwind_Resume(a1);
}

void sub_10073BAD0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 32);
  if (v6)
  {
    uint64_t v8 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to load network extension configuration error: %@", (uint8_t *)&buf, 0xCu);
    }
    *((void *)&buf + 1) = 0;
    uint64_t v13 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    sub_1000D2234(a1 + 40, (uint64_t)&buf, 0);
    sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
  }
  else
  {
    id v9 = sub_10073AA48(*(void *)(a1 + 32), v5);
    if ((unint64_t)[v9 count] > 1)
    {
      sub_1000E725C((uint64_t)v11, a1 + 40);
      sub_10073AC44(v7, v9, (uint64_t)v11);
      sub_1000E0D60(v11);
    }
    else
    {
      uint64_t v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = [v9 count];
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Found %lu commcenter NE config and no duplicate", (uint8_t *)&buf, 0xCu);
      }
      *((void *)&buf + 1) = 0;
      uint64_t v13 = 0;
      *(void *)&long long buf = (char *)&buf + 8;
      sub_1000D2234(a1 + 40, (uint64_t)&buf, 1);
      sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
    }
  }
}

void sub_10073BC9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10073BD00(uint64_t a1, uint64_t a2)
{
  return sub_1000E725C(a1 + 40, a2 + 40);
}

void *sub_10073BD0C(uint64_t a1)
{
  return sub_1000E0D60((void *)(a1 + 40));
}

void sub_10073BD14(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = sub_1007346D4(a1);
  id v5 = v4;
  if (v4)
  {
    id v6 = [v4 pathController];
    if (a2) {
      [v6 setCellularFallbackFlags:0];
    }
    else {
      [v6 setCellularFallbackFlags:1];
    }

    uint64_t v7 = v8;
    v8[0] = off_101A02480;
    v8[1] = a1;
    v8[2] = a2;
    v8[3] = v8;
    sub_1007335B8(a1, v5, (uint64_t)v8);
  }
  else
  {
    uint64_t v7 = v9;
    v9[0] = off_101A02400;
    v9[1] = a1;
    _DWORD v9[2] = a2;
    void v9[3] = v9;
    (*(void (**)(uint64_t, void *))(*(void *)a1 + 160))(a1, v9);
  }
  sub_100278CB4(v7);
}

void sub_10073BE5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_10073BEA0(Registry **a1, uint64_t **a2, uint64_t a3)
{
  sub_1000E725C((uint64_t)v6, a3);
  sub_10073BF3C(a1, a2, 0, (uint64_t)v6);
  return sub_1000E0D60(v6);
}

void sub_10073BF20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E0D60((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_10073BF3C(Registry **a1, uint64_t **a2, int a3, uint64_t a4)
{
  uint64_t v59 = a4;
  uint64_t v62 = (uint64_t)a1;
  uint64_t v61 = sub_1007346D4((uint64_t)a1);
  if (!v61)
  {
    uint64_t v86 = a1;
    sub_1000C6BDC(v87, (uint64_t)a2);
    char v88 = a3;
    sub_1000E725C((uint64_t)v89, v59);
    v91 = 0;
    long long v19 = operator new(0x50uLL);
    *long long v19 = off_101A02500;
    v19[1] = a1;
    sub_1000C6BDC(v19 + 2, (uint64_t)v87);
    *((unsigned char *)v19 + 40) = v88;
    sub_1000EC8E8((uint64_t)(v19 + 6), (uint64_t)v89);
    v91 = v19;
    (*((void (**)(Registry **, void *))*a1 + 20))(a1, v90);
    sub_100278CB4(v90);
    sub_1000E0D60(v89);
    sub_10005CD2C((uint64_t)v87, (char *)v87[1]);
    goto LABEL_80;
  }
  id v6 = objc_alloc((Class)NSMutableArray);
  uint64_t v7 = [v61 pathController];
  uint64_t v8 = [v7 pathRules];
  id v57 = [v6 initWithArray:v8];

  *(_OWORD *)&v71.__r_.__value_.__l.__data_ = 0uLL;
  char v70 = &v71;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1[10]);
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    __int16 v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v11;
  id v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
  if (!v15)
  {
    uint64_t v16 = 0;
    goto LABEL_10;
  }
  uint64_t v16 = v15[3];
  id v17 = (std::__shared_weak_count *)v15[4];
  if (!v17)
  {
LABEL_10:
    std::mutex::unlock(v10);
    id v17 = 0;
    char v18 = 1;
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v18 = 0;
LABEL_11:
  if (v16)
  {
    long long v20 = *a2;
    if (*a2 != (uint64_t *)(a2 + 1))
    {
      do
      {
        sub_100046BAC((uint64_t **)&v70, (void **)v20 + 4, (uint64_t)(v20 + 4));
        memset(__p, 0, sizeof(__p));
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t *))(*(void *)v16 + 48))(__p, v16, v20 + 4);
        if (LOBYTE(__p[3]))
        {
          sub_1000F29CC((uint64_t **)&v70, __p, (uint64_t)__p);
          if (LOBYTE(__p[3]))
          {
            if (SHIBYTE(__p[2]) < 0) {
              operator delete(__p[0]);
            }
          }
        }
        unsigned int v21 = (uint64_t *)v20[1];
        if (v21)
        {
          do
          {
            char v22 = (uint64_t **)v21;
            unsigned int v21 = (uint64_t *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            char v22 = (uint64_t **)v20[2];
            BOOL v23 = *v22 == v20;
            long long v20 = (uint64_t *)v22;
          }
          while (!v23);
        }
        long long v20 = (uint64_t *)v22;
      }
      while (v22 != a2 + 1);
    }
  }
  else if (&v70 != (std::string **)a2)
  {
    sub_1000EA390((uint64_t **)&v70, *a2, a2 + 1);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  id v24 = v57;
  id v25 = [v24 countByEnumeratingWithState:&v66 objects:v85 count:16];
  if (v25)
  {
    uint64_t v26 = *(void *)v67;
    do
    {
      for (uint64_t i = 0; i != v25; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v67 != v26) {
          objc_enumerationMutation(v24);
        }
        id v28 = *(void **)(*((void *)&v66 + 1) + 8 * i);
        memset(__p, 0, 24);
        objc_msgSend(v28, "matchSigningIdentifier", v57, context, v59);
        id v29 = objc_claimAutoreleasedReturnValue();
        sub_100058DB0(__p, (char *)[v29 UTF8String]);

        if (&v71 != (std::string *)sub_100046F68((uint64_t)&v70, __p)) {
          sub_1000E9358((uint64_t **)&v70, __p);
        }
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
      }
      id v25 = [v24 countByEnumeratingWithState:&v66 objects:v85 count:16];
    }
    while (v25);
  }

  if (v71.__r_.__value_.__l.__size_ || (a3 & 1) != 0)
  {
    uint64_t v32 = (*(uint64_t (**)(void))(**(void **)(v62 + 64) + 16))(*(void *)(v62 + 64));
    uint64_t v33 = (*(uint64_t (**)(void))(**(void **)(v62 + 48) + 16))(*(void *)(v62 + 48));
    id v34 = *(NSObject **)(v62 + 40);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      if (v32 > 2) {
        int v35 = "???";
      }
      else {
        int v35 = off_101A02608[(char)v32];
      }
      if (v33 > 2) {
        char v36 = "???";
      }
      else {
        char v36 = off_101A02608[(char)v33];
      }
      sub_1000E8F34(v70, &v71, ", ", 2uLL, (std::string *)&v71.__r_.__value_.__r.__words[2]);
      long long v37 = (std::string::value_type *)v71.__r_.__value_.__r.__words[2];
      if (v73 >= 0) {
        long long v37 = &v71.__r_.__value_.__s.__data_[16];
      }
      uint64_t v38 = "false";
      LODWORD(__p[0]) = 136315906;
      if (a3) {
        uint64_t v38 = "true";
      }
      *(void **)((char *)__p + 4) = (void *)v35;
      WORD2(__p[1]) = 2080;
      *(void **)((char *)&__p[1] + 6) = (void *)v36;
      HIWORD(__p[2]) = 2082;
      __p[3] = v37;
      __int16 v83 = 2080;
      uint64_t v84 = v38;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Adding cell policy %s and wifi policy %s for bundle ids: %{public}s is retry: %s", (uint8_t *)__p, 0x2Au);
      if (SHIBYTE(v73) < 0) {
        operator delete((void *)v71.__r_.__value_.__r.__words[2]);
      }
    }
    long long v64 = 0;
    uint64_t v65 = 0;
    uint64_t v63 = &v64;
    id v39 = (uint64_t *)v70;
    if (v70 != &v71)
    {
      do
      {
        uint64_t v40 = sub_1007395B4(v62, (uint64_t)(v39 + 4));
        (*(void (**)(void, void *, uint64_t))(**(void **)(v62 + 48) + 8))(*(void *)(v62 + 48), v40, v33);
        (*(void (**)(void, void *, uint64_t))(**(void **)(v62 + 64) + 8))(*(void *)(v62 + 64), v40, v32);
        [v24 addObject:v40];
        uint64_t v73 = 0;
        char v41 = (char *)operator new(0x40uLL);
        v71.__r_.__value_.__r.__words[2] = (std::string::size_type)v41;
        char v72 = &v64;
        LOBYTE(v73) = 0;
        if (*((char *)v39 + 55) < 0)
        {
          sub_10004FC84(__p, (void *)v39[4], v39[5]);
        }
        else
        {
          *(_OWORD *)__p = *((_OWORD *)v39 + 2);
          __p[2] = (void *)v39[6];
        }
        id v42 = v41 + 32;
        if (SHIBYTE(__p[2]) < 0)
        {
          sub_10004FC84(v42, __p[0], (unint64_t)__p[1]);
          int v43 = SHIBYTE(__p[2]);
          v41[56] = v32;
          v41[57] = v33;
          *((_WORD *)v41 + 29) = 257;
          if (v43 < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          *(_OWORD *)id v42 = *(_OWORD *)__p;
          *((void **)v41 + 6) = __p[2];
          v41[56] = v32;
          v41[57] = v33;
          *((_WORD *)v41 + 29) = 257;
        }
        LOBYTE(v73) = 1;
        __p[0] = 0;
        id v44 = (uint64_t **)sub_100046ED4((uint64_t)&v63, __p, (void **)(v71.__r_.__value_.__r.__words[2] + 32));
        if (*v44)
        {
          uint64_t v45 = (void **)v71.__r_.__value_.__r.__words[2];
          v71.__r_.__value_.__r.__words[2] = 0;
          if (v45) {
            sub_1000C6EE8((uint64_t)&v72, v45);
          }
        }
        else
        {
          id v46 = __p[0];
          id v47 = (uint64_t *)v71.__r_.__value_.__r.__words[2];
          *(void *)v71.__r_.__value_.__r.__words[2] = 0;
          v47[1] = 0;
          v47[2] = (uint64_t)v46;
          void *v44 = v47;
          if (*v63)
          {
            uint64_t v63 = (uint64_t **)*v63;
            id v47 = *v44;
          }
          sub_100046C90(v64, v47);
          ++v65;
        }

        id v48 = (std::string *)v39[1];
        if (v48)
        {
          do
          {
            int v49 = v48;
            id v48 = (std::string *)v48->__r_.__value_.__r.__words[0];
          }
          while (v48);
        }
        else
        {
          do
          {
            int v49 = (std::string *)v39[2];
            BOOL v23 = v49->__r_.__value_.__r.__words[0] == (void)v39;
            id v39 = (uint64_t *)v49;
          }
          while (!v23);
        }
        id v39 = (uint64_t *)v49;
      }
      while (v49 != &v71);
    }
    id v50 = objc_msgSend(v61, "pathController", v57);
    [v50 setPathRules:v24];

    uint64_t v74 = v62;
    sub_1000C6BDC(v75, (uint64_t)a2);
    sub_1000DB02C((uint64_t *)&v76, (uint64_t)&v63);
    sub_1000E725C((uint64_t)v79, v59);
    long long v81 = 0;
    uint64_t v51 = operator new(0x60uLL);
    uint64_t v52 = v74;
    *uint64_t v51 = off_101A02580;
    v51[1] = v52;
    sub_1000C6BDC(v51 + 2, (uint64_t)v75);
    uint64_t v54 = (uint64_t)v76;
    long long v53 = v77;
    v51[6] = v77;
    BOOL v55 = v51 + 6;
    v51[5] = v54;
    uint64_t v56 = v78;
    v51[7] = v78;
    if (v56)
    {
      *((void *)v53 + 2) = v55;
      long long v76 = &v77;
      long long v77 = 0;
      uint64_t v78 = 0;
    }
    else
    {
      v51[5] = v55;
    }
    sub_1000EC8E8((uint64_t)(v51 + 8), (uint64_t)v79);
    long long v81 = v51;
    sub_1007335B8(v62, v61, (uint64_t)v80);
    sub_100278CB4(v80);
    sub_1000E0D60(v79);
    sub_10005CD2C((uint64_t)&v76, v77);
    sub_10005CD2C((uint64_t)v75, (char *)v75[1]);
    id v30 = (char *)v64;
    char v31 = (void **)&v63;
  }
  else
  {
    __p[1] = 0;
    __p[2] = 0;
    __p[0] = &__p[1];
    sub_1000D2234(v59, (uint64_t)__p, 1);
    id v30 = (char *)__p[1];
    char v31 = __p;
  }
  sub_10005CD2C((uint64_t)v31, v30);
  sub_10005CD2C((uint64_t)&v70, v71.__r_.__value_.__l.__data_);

LABEL_80:
}

void sub_10073C85C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, void *a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,char *a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,char a55)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10073CA70(uint64_t a1)
{
  return a1;
}

uint64_t sub_10073CAA8(uint64_t a1)
{
  return a1;
}

void sub_10073CAEC(uint64_t a1)
{
  sub_10014F76C(*(void *)(a1 + 48), (os_log_t *)(a1 + 40));
  sub_100058DB0(&__p, "/cc/prefs-nb/ne_config_state");
  ctu::RestModule::getPropertyOnce();
  if (v15 < 0) {
    operator delete(__p);
  }
  int v2 = *(unsigned __int8 *)(a1 + 136);
  uint64_t v3 = *(NSObject **)(a1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4) {
      goto LABEL_9;
    }
    id v5 = *(const char **)(a1 + 128);
    *(_DWORD *)long long buf = 134217984;
    id v17 = v5;
    id v6 = "#I CommCenter ne config count: %lu";
    uint64_t v7 = v3;
    uint32_t v8 = 12;
  }
  else
  {
    if (!v4) {
      goto LABEL_9;
    }
    *(_WORD *)long long buf = 0;
    id v6 = "#I CommCenter ne config count not set";
    uint64_t v7 = v3;
    uint32_t v8 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
LABEL_9:
  id v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = "true";
    if (*(unsigned char *)(a1 + 124)) {
      uint64_t v11 = "true";
    }
    else {
      uint64_t v11 = "false";
    }
    if (!*(unsigned char *)(a1 + 123)) {
      uint64_t v10 = "false";
    }
    *(_DWORD *)long long buf = 136315394;
    id v17 = v11;
    __int16 v18 = 2080;
    long long v19 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Mirroring is enabled: %s and device is gizmo: %s", buf, 0x16u);
    id v9 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v12 = *(const char **)(a1 + 184);
    *(_DWORD *)long long buf = 134217984;
    id v17 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Pending save callbacks: %lu", buf, 0xCu);
    id v9 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 121)) {
      uint64_t v13 = "true";
    }
    else {
      uint64_t v13 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    id v17 = v13;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Save currently in progress: %s", buf, 0xCu);
  }
}

void sub_10073CD7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10073CDA0(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  xpc_type_t type = xpc_get_type(*a2);
  id v5 = *(NSObject **)(v3 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (type == (xpc_type_t)&_xpc_type_null)
  {
    if (!v6) {
      return;
    }
    LOWORD(v13) = 0;
    uint64_t v10 = "#I ne_config_state_rest_resource is null";
    uint64_t v11 = v5;
    uint32_t v12 = 2;
  }
  else
  {
    if (!v6) {
      return;
    }
    int v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, v7);
    id v9 = "false";
    if (v8) {
      id v9 = "true";
    }
    int v13 = 136315138;
    unsigned int v14 = v9;
    uint64_t v10 = "#I ne_config_state_rest_resource is non-null value: %s";
    uint64_t v11 = v5;
    uint32_t v12 = 12;
  }
  _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v13, v12);
}

char *sub_10073CEB4(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    BOOL v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      BOOL v7 = v6;
      if (a1[5])
      {
        int v8 = *(_DWORD *)(a2 + 16);
        if (v8 == 3)
        {
          id v9 = sub_1007346D4(v5);
          uint64_t v10 = *(NSObject **)(v5 + 40);
          BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
          if (v9)
          {
            if (v11)
            {
              uint32_t v12 = [v9 identifier];
              int v22 = 138412290;
              BOOL v23 = v12;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Configuration identifier: %@", (uint8_t *)&v22, 0xCu);
            }
            int v13 = [v9 pathController];
            BOOL v14 = v13 == 0;

            char v15 = *(NSObject **)(v5 + 40);
            if (!v14)
            {
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v16 = [v9 pathController];
                unsigned int v17 = [v16 isEnabled];
                __int16 v18 = "false";
                if (v17) {
                  __int16 v18 = "true";
                }
                int v22 = 136315138;
                BOOL v23 = v18;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Path controller enabled: %s", (uint8_t *)&v22, 0xCu);
              }
              long long v19 = sub_10073D178((uint64_t)(a1 + 7), "In memory NE configuration", v9);
              goto LABEL_23;
            }
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v22) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No path controller defined", (uint8_t *)&v22, 2u);
            }
          }
          else if (v11)
          {
            LOWORD(v22) = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Configuration is nil", (uint8_t *)&v22, 2u);
          }
          long long v19 = 0;
LABEL_23:

          goto LABEL_24;
        }
        long long v20 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = 67109120;
          LODWORD(v23) = v8;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Skipping state handler for %d", (uint8_t *)&v22, 8u);
        }
      }
      long long v19 = 0;
LABEL_24:
      sub_10004D2C8(v7);
      return v19;
    }
  }
  return 0;
}

void sub_10073D13C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

char *sub_10073D178(uint64_t a1, char *a2, void *a3)
{
  id v27 = a3;
  BOOL v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    uint64_t v26 = v5;
    id v25 = std::__shared_weak_count::lock(v6);
    if (v25)
    {
      if (*(void *)(a1 + 8))
      {
        id v28 = +[NSMutableDictionary dictionary];
        long long v32 = 0u;
        long long v33 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        BOOL v7 = [v27 pathController];
        BOOL v23 = (NSObject ***)a1;
        __source = a2;
        int v8 = [v7 pathRules];

        id v9 = [v8 countByEnumeratingWithState:&v30 objects:v38 count:16];
        if (v9)
        {
          uint64_t v10 = *(void *)v31;
          do
          {
            for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v31 != v10) {
                objc_enumerationMutation(v8);
              }
              uint32_t v12 = *(void **)(*((void *)&v30 + 1) + 8 * i);
              int v13 = +[NSMutableDictionary dictionary];
              if ([v12 cellularBehavior])
              {
                if ([v12 cellularBehavior] == (id)1) {
                  CFStringRef v14 = @"Deny";
                }
                else {
                  CFStringRef v14 = @"Allow In Roaming";
                }
              }
              else
              {
                CFStringRef v14 = @"Allow";
              }
              [v13 setObject:v14 forKeyedSubscript:@"Cellular"];
              if ([v12 wifiBehavior])
              {
                if ([v12 wifiBehavior] == (id)1) {
                  CFStringRef v15 = @"Deny";
                }
                else {
                  CFStringRef v15 = @"Allow In Roaming";
                }
              }
              else
              {
                CFStringRef v15 = @"Allow";
              }
              [v13 setObject:v15 forKeyedSubscript:@"Wi-Fi"];
              uint64_t v16 = [v12 matchSigningIdentifier];
              [v28 setObject:v13 forKeyedSubscript:v16];
            }
            id v9 = [v8 countByEnumeratingWithState:&v30 objects:v38 count:16];
          }
          while (v9);
        }

        id v29 = 0;
        unsigned int v17 = +[NSPropertyListSerialization dataWithPropertyList:v28 format:200 options:0 error:&v29];
        id v18 = v29;
        if (v17)
        {
          long long v19 = (char *)malloc_type_calloc(1uLL, (size_t)[v17 length] + 200, 0x64683D12uLL);
          *(_DWORD *)long long v19 = 1;
          *((_DWORD *)v19 + 1) = [v17 length];
          strlcpy(v19 + 136, __source, 0x40uLL);
          id v20 = v17;
          memcpy(v19 + 200, [v20 bytes], (size_t)objc_msgSend(v20, "length"));
        }
        else
        {
          unsigned int v21 = **v23;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315394;
            int v35 = __source;
            __int16 v36 = 2114;
            id v37 = v18;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not convert %s to serialized data: %{public}@", buf, 0x16u);
          }
          long long v19 = 0;
        }
      }
      else
      {
        long long v19 = 0;
      }
      sub_10004D2C8(v25);
    }
    else
    {
      long long v19 = 0;
    }
    uint64_t v5 = v26;
  }
  else
  {
    long long v19 = 0;
  }

  return v19;
}

void sub_10073D4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, void *a14, void *a15)
{
  sub_10004D2C8(a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10073D594(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(result + 56) = *(_OWORD *)(a2 + 56);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(result + 72) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10073D5D0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_10073D620(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v20 = 0;
  unsigned int v21 = &v20;
  uint64_t v22 = 0x2020000000;
  uint64_t v23 = 0;
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    BOOL v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      BOOL v7 = v6;
      if (*(void *)(a1 + 40))
      {
        int v8 = *(_DWORD *)(a2 + 16);
        if (v8 == 3)
        {
          id v9 = dispatch_semaphore_create(0);
          uint64_t v10 = v9;
          BOOL v11 = *(void **)(v3 + 216);
          v16[0] = _NSConcreteStackBlock;
          v16[1] = 3321888768;
          v16[2] = sub_10073D868;
          void v16[3] = &unk_101A01318;
          void v16[4] = &v20;
          v16[5] = v3;
          long long v17 = *(_OWORD *)(a1 + 56);
          uint32_t v12 = *(std::__shared_weak_count **)(a1 + 72);
          id v18 = v12;
          if (v12) {
            atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          dispatch_object_t object = v9;
          if (v9) {
            dispatch_retain(v9);
          }
          [v11 loadConfigurationsWithCompletionQueue:&_dispatch_main_q handler:v16];
          dispatch_semaphore_wait(v10, 0xFFFFFFFFFFFFFFFFLL);
          uint64_t v13 = v21[3];
          if (object) {
            dispatch_release(object);
          }
          if (v18) {
            std::__shared_weak_count::__release_weak(v18);
          }
          if (v10) {
            dispatch_release(v10);
          }
          goto LABEL_20;
        }
        CFStringRef v14 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          int v25 = v8;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Skipping state handler for %d", buf, 8u);
        }
      }
      uint64_t v13 = v21[3];
LABEL_20:
      sub_10004D2C8(v7);
      goto LABEL_21;
    }
    uint64_t v13 = v21[3];
  }
  else
  {
    uint64_t v13 = 0;
  }
LABEL_21:
  _Block_object_dispose(&v20, 8);
  return v13;
}

void sub_10073D824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, dispatch_object_t object, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (v20) {
    dispatch_release(v20);
  }
  sub_10004D2C8(v19);
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_10073D868(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 40);
  if (v6)
  {
    int v8 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v12 = 138412290;
      id v13 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to load network extension configuration error: %@", (uint8_t *)&v12, 0xCu);
    }
  }
  else
  {
    id v9 = sub_10073AA48(*(void *)(a1 + 40), v5);
    uint64_t v10 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 134217984;
      id v13 = [v9 count];
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Found %lu commcenter NE configs on disk", (uint8_t *)&v12, 0xCu);
    }
    BOOL v11 = [v9 firstObject];
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_10073D178(a1 + 48, "On disk NE configuration", v11);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
}

void sub_10073D9E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10073DA14(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v2 = *(void *)(a2 + 64);
  *(void *)(a1 + 64) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(NSObject **)(a2 + 72);
  *(void *)(a1 + 72) = v3;
  if (v3) {
    dispatch_retain(v3);
  }
}

void sub_10073DA4C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 72);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_10073DA9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  BOOL v4 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [v3 objectForKeyedSubscript:kSymptomDiagnosticReplySuccess];
    unsigned int v6 = [v5 BOOLValue];
    uint64_t v7 = "false";
    if (v6) {
      uint64_t v7 = "true";
    }
    int v8 = 136315138;
    id v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I sent abc snapshot %s", (uint8_t *)&v8, 0xCu);
  }
}

void sub_10073DB8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10073DBB0(uint64_t a1)
{
  if (*(void *)(a1 + 104))
  {
    os_state_remove_handler();
    *(void *)(a1 + 104) = 0;
  }
  uint64_t result = *(void *)(a1 + 112);
  if (result)
  {
    uint64_t result = os_state_remove_handler();
    *(void *)(a1 + 112) = 0;
  }
  return result;
}

void *sub_10073DBF0(void *__dst, long long *a2, char a3, char a4, uint64_t a5)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__dst = v9;
  }
  __dst[4] = 0;
  *((unsigned char *)__dst + 24) = a3;
  *((unsigned char *)__dst + 25) = a4;
  __dst[5] = 0;
  __dst[6] = 0;
  sub_1000D84B8(__dst + 4, *(const void **)a5, *(void *)(a5 + 8), *(void *)(a5 + 8) - *(void *)a5);
  *((_WORD *)__dst + 28) = 0;
  BOOL v11 = (unsigned char *)__dst[4];
  uint64_t v10 = (unsigned char *)__dst[5];
  if (v11 != v10)
  {
    *((unsigned char *)__dst + 56) = 1;
    while (*v11 != 1)
    {
      if (++v11 == v10)
      {
        BOOL v11 = v10;
        break;
      }
    }
    if (v11 != v10) {
      *((unsigned char *)__dst + 57) = 1;
    }
  }
  return __dst;
}

void sub_10073DCB8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10073DCD4(id a1)
{
  uint64_t v1 = NSClassFromString(@"SDRDiagnosticReporter");
  byte_101B0D618 = v1 != 0;
}

void sub_10073DD18(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10073DDE4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10073DEBC);
  __cxa_rethrow();
}

void sub_10073DE0C(_Unwind_Exception *a1)
{
}

void sub_10073DE24(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10073DE5C(uint64_t a1)
{
}

uint64_t sub_10073DE78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10073DEBC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10073DEE8(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  id v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    BOOL v4 = (void *)(a1 + 40);
    id v3 = *(void ***)(a1 + 8);
  }
  else
  {
    BOOL v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    unsigned int v6 = &v2[v5 >> 7];
    uint64_t v7 = (char *)*v6 + 32 * (v5 & 0x7F);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 4) & 0xFFFFFFFFFFFFFF8))
       + 32 * ((*(void *)(a1 + 40) + v5) & 0x7F);
    if (v7 != (char *)v8)
    {
      do
      {
        uint64_t v7 = (char *)(sub_100278CB4(v7) + 4);
        if (v7 - (unsigned char *)*v6 == 4096)
        {
          long long v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      uint64_t v2 = *(void ***)(a1 + 8);
      id v3 = *(void ***)(a1 + 16);
    }
  }
  void *v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      id v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 64;
    goto LABEL_14;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 128;
LABEL_14:
    *(void *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      id v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10073E038()
{
}

void *sub_10073E04C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A01440;
  result[1] = v3;
  return result;
}

uint64_t sub_10073E094(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A01440;
  a2[1] = v2;
  return result;
}

void sub_10073E0C0(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/ne_configuration_started");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_10073E170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_10073E1B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10073E1F8()
{
}

void sub_10073E208()
{
}

void *sub_10073E21C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A014C0;
  result[1] = v3;
  return result;
}

uint64_t sub_10073E264(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A014C0;
  a2[1] = v2;
  return result;
}

void sub_10073E290(uint64_t a1, char *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  BOOL v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (v2 > 2) {
      char v5 = "???";
    }
    else {
      char v5 = off_101A025F0[v2];
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I NEConfiguration created with result: %s", (uint8_t *)&buf, 0xCu);
  }
  if (v2 != 2)
  {
    sub_100732CF8(v3, 0, (uint64_t)"cannot create NEConfiguration");
    return;
  }
  unsigned int v6 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I NEStarted: waiting period begins", (uint8_t *)&buf, 2u);
  }
  id v7 = *(id *)(v3 + 208);
  uint64_t v8 = *(void **)(v3 + 208);
  if (v8
    && ([v8 pathController], (long long v9 = objc_claimAutoreleasedReturnValue()) != 0)
    && ([*(id *)(v3 + 208) pathController],
        unint64_t v10 = objc_claimAutoreleasedReturnValue(),
        unsigned __int8 v11 = [v10 hasNonDefaultRules],
        v10,
        v9,
        (v11 & 1) != 0))
  {
    id v12 = v7;
  }
  else
  {
    id v12 = *(id *)(v3 + 192);
  }
  if (v12)
  {
    id v13 = [v12 pathController];

    if (v13)
    {
      uint64_t v14 = [v12 pathController];
      unsigned __int8 v15 = [v14 hasNonDefaultRules];

      if (v15)
      {
        v39[0] = 0;
        v39[1] = 0;
        uint64_t v16 = [v12 identifier];
        [v16 getUUIDBytes:v39];

        uint64_t v17 = ne_session_create();
        *(void *)(v3 + 200) = v17;
        if (v17)
        {
          v31[0] = 0;
          v31[1] = v31;
          v31[2] = 0x2020000000;
          char v32 = 0;
          v29[0] = 0;
          v29[1] = v29;
          v29[2] = 0x2020000000;
          char v30 = 0;
          v27[0] = 0;
          v27[1] = v27;
          v27[2] = 0x2020000000;
          char v28 = 0;
          *(void *)&long long buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3221225472;
          id v34 = sub_100733194;
          int v35 = &unk_101A010D8;
          id v37 = v29;
          uint64_t v38 = v3;
          __int16 v36 = v27;
          v23[0] = _NSConcreteStackBlock;
          v23[1] = 3221225472;
          v23[2] = sub_10073321C;
          void v23[3] = &unk_101A01100;
          int v25 = v31;
          uint64_t v26 = v3;
          id v18 = objc_retainBlock(&buf);
          id v24 = v18;
          unsigned int v21 = objc_retainBlock(v23);
          uint64_t v22 = v18;
          ne_session_set_event_handler();
          ne_session_get_status();

          _Block_object_dispose(v27, 8);
          _Block_object_dispose(v29, 8);
          _Block_object_dispose(v31, 8);
        }
        else
        {
          sub_100732CF8(v3, 0, (uint64_t)"cannot create ne_session");
        }
        goto LABEL_24;
      }
      long long v19 = "config.pathController does not have non-default rules";
    }
    else
    {
      long long v19 = "config.pathController is empty";
    }
    sub_100732CF8(v3, v13 != 0, (uint64_t)v19);
  }
  else
  {
    sub_100732CF8(v3, 0, (uint64_t)"config is empty");
  }
LABEL_24:

  if (*(unsigned char *)(v3 + 120))
  {
    sub_10073351C(v3);
  }
  else
  {
    uint64_t v20 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Config does not need to be re-saved. Initialization is done.", (uint8_t *)&buf, 2u);
    }
  }
}

void sub_10073E704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);

  _Unwind_Resume(a1);
}

uint64_t sub_10073E7A8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10073E7E8()
{
}

void sub_10073E7F8()
{
}

void *sub_10073E80C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A01540;
  result[1] = v3;
  return result;
}

uint64_t sub_10073E854(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A01540;
  a2[1] = v2;
  return result;
}

void *sub_10073E880(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (*a2 == 1) {
    return sub_10073351C((uint64_t)v2);
  }
  else {
    return sub_100733CC0(v2);
  }
}

uint64_t sub_10073E898(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10073E8D8()
{
}

void sub_10073E8E8()
{
}

void *sub_10073E8FC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A015C0;
  result[1] = v3;
  return result;
}

uint64_t sub_10073E944(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A015C0;
  a2[1] = v2;
  return result;
}

void *sub_10073E970(void *result, unsigned char *a2)
{
  if (*a2 == 1) {
    return sub_100733CC0((void *)result[1]);
  }
  return result;
}

uint64_t sub_10073E988(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10073E9C8()
{
}

void sub_10073E9D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)a1 + 320);
  if (v1)
  {
    (*(void (**)(uint64_t))(*(void *)v1 + 48))(v1);
    operator delete();
  }
  sub_10007B600();
}

void sub_10073EA50()
{
}

void sub_10073EA78()
{
}

void *sub_10073EA8C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A01640;
  return result;
}

void sub_10073EAC4(uint64_t a1, void *a2)
{
  *a2 = off_101A01640;
}

uint64_t sub_10073EAEC()
{
  return 0;
}

uint64_t sub_10073EAF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10073EB34()
{
}

uint64_t sub_10073EB40(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_10073EBD8(void *a1)
{
  *a1 = off_101A016C0;
  sub_1000E04E4(a1 + 7);
  sub_1000DBB60(a1 + 2);
  return a1;
}

void sub_10073EC24(void *a1)
{
  *a1 = off_101A016C0;
  sub_1000E04E4(a1 + 7);
  sub_1000DBB60(a1 + 2);

  operator delete();
}

void *sub_10073EC90(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A016C0;
  sub_10073EF34((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10073ECE4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10073ECF8(uint64_t a1, void *a2)
{
  *a2 = off_101A016C0;
  return sub_10073EF34((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_10073ED24(uint64_t a1)
{
  sub_1000E04E4((void *)(a1 + 56));

  return sub_1000DBB60((void *)(a1 + 16));
}

void sub_10073ED60(void *a1)
{
  sub_1000E04E4(a1 + 7);
  sub_1000DBB60(a1 + 2);

  operator delete(a1);
}

void sub_10073EDA4(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    sub_1000DC0E0((uint64_t)&v6, a1 + 16);
    int v4 = *(unsigned __int8 *)(a1 + 48);
    sub_10073EB40((uint64_t)v5, a1 + 56);
    (*(void (**)(uint64_t, void ***, BOOL, void *))(*(void *)v3 + 48))(v3, &v6, v4 != 0, v5);
    sub_1000E04E4(v5);
    sub_1000DBB60(&v6);
  }
  else
  {
    v7[0] = 0;
    v7[1] = 0;
    unsigned int v6 = v7;
    sub_1000DC1F8(a1 + 16, (uint64_t)&v6, 0);
    sub_1000DC24C((uint64_t)&v6, v7[0]);
  }
}

void sub_10073EEA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *a15)
{
}

uint64_t sub_10073EEE8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10073EF28()
{
}

uint64_t sub_10073EF34(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  sub_1000DC0E0(a1 + 8, a2 + 8);
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  sub_10073EB40(a1 + 48, a2 + 48);
  return a1;
}

void sub_10073EF8C(_Unwind_Exception *a1)
{
  sub_1000DBB60(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10073EFA0(uint64_t a1)
{
  *(void *)a1 = off_101A01740;
  sub_1000E0D60((void *)(a1 + 40));
  sub_1000D9674(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

void sub_10073EFF0(uint64_t a1)
{
  *(void *)a1 = off_101A01740;
  sub_1000E0D60((void *)(a1 + 40));
  sub_1000D9674(a1 + 16, *(char **)(a1 + 24));

  operator delete();
}

void *sub_10073F060(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  *uint64_t v2 = off_101A01740;
  sub_10073F2B4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10073F0B4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10073F0C8(uint64_t a1, void *a2)
{
  *a2 = off_101A01740;
  return sub_10073F2B4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10073F0F4(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 40));
  uint64_t v2 = *(char **)(a1 + 24);

  sub_1000D9674(a1 + 16, v2);
}

void sub_10073F134(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 40));
  sub_1000D9674(a1 + 16, *(char **)(a1 + 24));

  operator delete((void *)a1);
}

void sub_10073F17C(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    sub_1000E725C((uint64_t)&v4, a1 + 40);
    sub_100734C98(v3, (void *)(a1 + 16), (uint64_t)&v4, *(unsigned __int8 *)(a1 + 72));
    sub_1000E0D60(&v4);
  }
  else
  {
    v5[0] = 0;
    v5[1] = 0;
    int v4 = v5;
    sub_1000D2234(a1 + 40, (uint64_t)&v4, 0);
    sub_10005CD2C((uint64_t)&v4, v5[0]);
  }
}

void sub_10073F238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10073F268(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10073F2A8()
{
}

uint64_t sub_10073F2B4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 32;
  *(void *)a1 = *(void *)a2;
  uint64_t v5 = a1 + 32;
  sub_1000EDA4C((uint64_t *)(a1 + 8), a2 + 8);
  sub_1000E725C(v5, v4);
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  return a1;
}

void sub_10073F320(_Unwind_Exception *a1)
{
  sub_1000D9674(v2, *(char **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_10073F338(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_10073F3D0(uint64_t a1)
{
  *(void *)a1 = off_101A017C0;
  sub_1000EDB30((void *)(a1 + 40));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

void sub_10073F420(uint64_t a1)
{
  *(void *)a1 = off_101A017C0;
  sub_1000EDB30((void *)(a1 + 40));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete();
}

void *sub_10073F490(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  *uint64_t v2 = off_101A017C0;
  sub_10073F700((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10073F4E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10073F4F8(uint64_t a1, void *a2)
{
  *a2 = off_101A017C0;
  return sub_10073F700((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10073F524(uint64_t a1)
{
  sub_1000EDB30((void *)(a1 + 40));
  uint64_t v2 = *(char **)(a1 + 24);

  sub_10005CD2C(a1 + 16, v2);
}

void sub_10073F564(uint64_t a1)
{
  sub_1000EDB30((void *)(a1 + 40));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete((void *)a1);
}

void sub_10073F5AC(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    sub_10073F338((uint64_t)v5, a1 + 40);
    (*(void (**)(uint64_t, uint64_t, void *, void))(*(void *)v3 + 152))(v3, a1 + 16, v5, *(unsigned __int8 *)(a1 + 72));
    sub_1000EDB30(v5);
  }
  else
  {
    memset(v5, 0, 24);
    sub_1007354B4(*(void *)(a1 + 64), (uint64_t)v5, 0);
    uint64_t v4 = (void **)v5;
    sub_100047F64(&v4);
  }
}

void sub_10073F684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_10073F6B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10073F6F4()
{
}

uint64_t sub_10073F700(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 32;
  *(void *)a1 = *(void *)a2;
  uint64_t v5 = a1 + 32;
  sub_1000C6BDC((uint64_t *)(a1 + 8), a2 + 8);
  sub_10073F338(v5, v4);
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  return a1;
}

void sub_10073F76C(_Unwind_Exception *a1)
{
  sub_10005CD2C(v2, *(char **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_10073F784(uint64_t a1)
{
  *(void *)a1 = off_101A01840;
  sub_1000E0D60((void *)(a1 + 64));
  sub_10005CD2C(a1 + 40, *(char **)(a1 + 48));
  sub_1000D9674(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

void sub_10073F7E0(uint64_t a1)
{
  *(void *)a1 = off_101A01840;
  sub_1000E0D60((void *)(a1 + 64));
  sub_10005CD2C(a1 + 40, *(char **)(a1 + 48));
  sub_1000D9674(a1 + 16, *(char **)(a1 + 24));

  operator delete();
}

void *sub_10073F85C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x68uLL);
  *uint64_t v2 = off_101A01840;
  sub_10073FAB8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10073F8B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10073F8C4(uint64_t a1, void *a2)
{
  *a2 = off_101A01840;
  return sub_10073FAB8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10073F8F0(uint64_t a1)
{
}

void sub_10073F8F8(void *a1)
{
  sub_10073FB5C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10073F934(uint64_t a1, unsigned char *a2)
{
  int v3 = *a2;
  if (v3 == 2)
  {
    uint64_t v6 = a1 + 64;
    sub_1000D2234(v6, a1 + 40, 1);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v3 == 1)
    {
      sub_1000E725C((uint64_t)v7, a1 + 64);
      sub_100734C98(v4, (void *)(a1 + 16), (uint64_t)v7, *(unsigned __int8 *)(a1 + 96));
      sub_1000E0D60(v7);
    }
    else if (!*a2)
    {
      uint64_t v5 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E Failed to delete the policies from the NEConfiguration", v7, 2u);
      }
    }
  }
}

void sub_10073FA50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10073FA6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10073FAAC()
{
}

uint64_t sub_10073FAB8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 32;
  *(void *)a1 = *(void *)a2;
  uint64_t v5 = (uint64_t *)(a1 + 32);
  sub_1000EDA4C((uint64_t *)(a1 + 8), a2 + 8);
  sub_1000DB02C(v5, v4);
  sub_1000E725C(a1 + 56, a2 + 56);
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a2 + 88);
  return a1;
}

void sub_10073FB30(_Unwind_Exception *a1)
{
  sub_10005CD2C(v3, *(char **)(v1 + 40));
  sub_1000D9674(v2, *(char **)(v1 + 16));
  _Unwind_Resume(a1);
}

void sub_10073FB5C(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 56));
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));
  uint64_t v2 = *(char **)(a1 + 16);

  sub_1000D9674(a1 + 8, v2);
}

uint64_t sub_10073FBA8(uint64_t a1)
{
  *(void *)a1 = off_101A018C0;
  sub_1000EA288((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_10073FBFC(uint64_t a1)
{
  *(void *)a1 = off_101A018C0;
  sub_1000EA288((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_10073FC70(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A018C0;
  sub_10073FF10((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10073FCC4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10073FCD8(uint64_t a1, void *a2)
{
  *a2 = off_101A018C0;
  return sub_10073FF10((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10073FD04(uint64_t a1)
{
}

void sub_10073FD0C(void *a1)
{
  sub_10073FFA0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10073FD48(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*a2 == 2)
  {
    if (*(char *)(a1 + 39) < 0)
    {
      sub_10004FC84(v5, *(void **)(a1 + 16), *(void *)(a1 + 24));
    }
    else
    {
      *(_OWORD *)uint64_t v5 = *(_OWORD *)(a1 + 16);
      uint64_t v6 = *(void *)(a1 + 32);
    }
    sub_1000EE0FC((uint64_t)v7, a1 + 40);
    (*(void (**)(uint64_t, void **, void *))(*(void *)v3 + 56))(v3, v5, v7);
    sub_1000EA288(v7);
    if (SHIBYTE(v6) < 0)
    {
      uint64_t v4 = v5[0];
      goto LABEL_11;
    }
  }
  else
  {
    sub_100734054(v7, v3, (long long *)(a1 + 16));
    sub_1000D8E0C(a1 + 40, (uint64_t)v7, 0);
    if (__p)
    {
      unint64_t v10 = __p;
      operator delete(__p);
    }
    if (v8 < 0)
    {
      uint64_t v4 = (void *)v7[0];
LABEL_11:
      operator delete(v4);
    }
  }
}

void sub_10073FE6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10073FEC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10073FF04()
{
}

uint64_t sub_10073FF10(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_1000EE0FC(a1 + 32, a2 + 32);
  return a1;
}

void sub_10073FF84(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10073FFA0(uint64_t a1)
{
  sub_1000EA288((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

uint64_t sub_10073FFF0(uint64_t a1)
{
  *(void *)a1 = off_101A01940;
  sub_1000EA288((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100740044(uint64_t a1)
{
  *(void *)a1 = off_101A01940;
  sub_1000EA288((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1007400B8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A01940;
  sub_100740358((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10074010C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100740120(uint64_t a1, void *a2)
{
  *a2 = off_101A01940;
  return sub_100740358((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10074014C(uint64_t a1)
{
}

void sub_100740154(void *a1)
{
  sub_10073FFA0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100740190(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*a2 == 2)
  {
    if (*(char *)(a1 + 39) < 0)
    {
      sub_10004FC84(v5, *(void **)(a1 + 16), *(void *)(a1 + 24));
    }
    else
    {
      *(_OWORD *)uint64_t v5 = *(_OWORD *)(a1 + 16);
      uint64_t v6 = *(void *)(a1 + 32);
    }
    sub_1000EE0FC((uint64_t)v7, a1 + 40);
    (*(void (**)(uint64_t, void **, void *))(*(void *)v3 + 64))(v3, v5, v7);
    sub_1000EA288(v7);
    if (SHIBYTE(v6) < 0)
    {
      long long v4 = v5[0];
      goto LABEL_11;
    }
  }
  else
  {
    sub_100734054(v7, v3, (long long *)(a1 + 16));
    sub_1000D8E0C(a1 + 40, (uint64_t)v7, 0);
    if (__p)
    {
      unint64_t v10 = __p;
      operator delete(__p);
    }
    if (v8 < 0)
    {
      long long v4 = (void *)v7[0];
LABEL_11:
      operator delete(v4);
    }
  }
}

void sub_1007402B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10074030C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10074034C()
{
}

uint64_t sub_100740358(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_1000EE0FC(a1 + 32, a2 + 32);
  return a1;
}

void sub_1007403CC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007403E8(uint64_t a1)
{
  *(void *)a1 = off_101A019C0;
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

void sub_100740430(uint64_t a1)
{
  *(void *)a1 = off_101A019C0;
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete();
}

void *sub_100740498(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A019C0;
  v2[1] = v3;
  sub_1000C6BDC(v2 + 2, a1 + 16);
  return v2;
}

void sub_1007404F0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100740504(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A019C0;
  a2[1] = v2;
  return sub_1000C6BDC(a2 + 2, a1 + 16);
}

void sub_100740534(uint64_t a1)
{
}

void sub_100740544(char **a1)
{
  sub_10005CD2C((uint64_t)(a1 + 2), a1[3]);

  operator delete(a1);
}

uint64_t sub_100740584(uint64_t result, unsigned char *a2)
{
  if (*a2 == 2) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(result + 8) + 80))(*(void *)(result + 8), result + 16);
  }
  return result;
}

uint64_t sub_1007405C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100740604()
{
}

uint64_t sub_100740610(uint64_t a1)
{
  *(void *)a1 = off_101A01A40;
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

void sub_100740658(uint64_t a1)
{
  *(void *)a1 = off_101A01A40;
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete();
}

void *sub_1007406C0(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A01A40;
  v2[1] = v3;
  sub_1000C6BDC(v2 + 2, a1 + 16);
  return v2;
}

void sub_100740718(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10074072C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A01A40;
  a2[1] = v2;
  return sub_1000C6BDC(a2 + 2, a1 + 16);
}

void sub_10074075C(uint64_t a1)
{
}

void sub_10074076C(char **a1)
{
  sub_10005CD2C((uint64_t)(a1 + 2), a1[3]);

  operator delete(a1);
}

void sub_1007407AC(uint64_t a1, unsigned char *a2)
{
  int v3 = *a2;
  long long v4 = *(void **)(a1 + 8);
  if (v3 == 2)
  {
    id v7 = v4[5];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000E8F34(*(std::string **)(a1 + 16), (std::string *)(a1 + 24), ", ", 2uLL, &__p);
      char v8 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &__p
         : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)long long buf = 136446210;
      unsigned __int8 v11 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Successfully deleted rules for app: %{public}s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  else if (v3 == 1)
  {
    uint64_t v6 = *(void (**)(void))(*v4 + 80);
    v6();
  }
  else if (!*a2)
  {
    uint64_t v5 = v4[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E Failed to delete the policies from the NEConfiguration", (uint8_t *)&__p, 2u);
    }
  }
}

uint64_t sub_100740944(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100740984()
{
}

void sub_100740994()
{
}

void *sub_1007409A8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A01AC0;
  return result;
}

void sub_1007409E0(uint64_t a1, void *a2)
{
  *a2 = off_101A01AC0;
}

uint64_t sub_100740A08()
{
  return 1;
}

uint64_t sub_100740A10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100740A50()
{
}

void *sub_100740A5C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100740AE4()
{
}

void *sub_100740AF8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A01B50;
  return result;
}

void sub_100740B30(uint64_t a1, void *a2)
{
  *a2 = off_101A01B50;
}

BOOL sub_100740B58(uint64_t a1, void *a2)
{
  return *a2 != 1;
}

uint64_t sub_100740B68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100740BA8()
{
}

uint64_t sub_100740BB4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100740C4C(void *a1)
{
  *a1 = off_101A01BD0;
  sub_1000E0D60(a1 + 8);
  sub_100740A5C(a1 + 3);
  return a1;
}

void sub_100740C98(void *a1)
{
  *a1 = off_101A01BD0;
  sub_1000E0D60(a1 + 8);
  sub_100740A5C(a1 + 3);

  operator delete();
}

void *sub_100740D04(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x60uLL);
  *uint64_t v2 = off_101A01BD0;
  sub_10074100C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100740D58(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100740D6C(uint64_t a1, void *a2)
{
  *a2 = off_101A01BD0;
  return sub_10074100C((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void *sub_100740D98(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 64));

  return sub_100740A5C((void *)(a1 + 24));
}

void sub_100740DD4(void *a1)
{
  sub_1000E0D60(a1 + 8);
  sub_100740A5C(a1 + 3);

  operator delete(a1);
}

void sub_100740E18(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2)
  {
    uint64_t v3 = *(void ***)(a1 + 8);
    uint64_t v4 = *(unsigned __int8 *)(a1 + 16);
    int v5 = *(unsigned __int8 *)(a1 + 56);
    sub_100740BB4((uint64_t)&v7, a1 + 24);
    sub_1000E725C((uint64_t)v6, a1 + 64);
    sub_1007361E4(v3, v4, v5 != 0, (uint64_t)&v7, (uint64_t)v6);
    sub_1000E0D60(v6);
    sub_100740A5C(&v7);
  }
  else
  {
    v8[0] = 0;
    v8[1] = 0;
    id v7 = v8;
    sub_1000D2234(a1 + 64, (uint64_t)&v7, 0);
    sub_10005CD2C((uint64_t)&v7, v8[0]);
  }
}

void sub_100740F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, char *a15)
{
}

uint64_t sub_100740F40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100740F80()
{
}

uint64_t sub_100740F8C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t sub_10074100C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  sub_100740BB4(a1 + 16, (uint64_t)(a2 + 2));
  *(unsigned char *)(a1 + 48) = *((unsigned char *)a2 + 48);
  sub_1000E725C(a1 + 56, (uint64_t)(a2 + 7));
  return a1;
}

void sub_100741070(_Unwind_Exception *a1)
{
  sub_100740A5C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100741084(uint64_t a1)
{
  *(void *)a1 = off_101A01C50;
  sub_1000E0D60((void *)(a1 + 80));
  sub_10005CD2C(a1 + 56, *(char **)(a1 + 64));
  sub_100740A5C((void *)(a1 + 24));
  return a1;
}

void sub_1007410DC(uint64_t a1)
{
  *(void *)a1 = off_101A01C50;
  sub_1000E0D60((void *)(a1 + 80));
  sub_10005CD2C(a1 + 56, *(char **)(a1 + 64));
  sub_100740A5C((void *)(a1 + 24));

  operator delete();
}

void *sub_100741154(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x70uLL);
  *uint64_t v2 = off_101A01C50;
  sub_100741494((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1007411A8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007411BC(uint64_t a1, void *a2)
{
  *a2 = off_101A01C50;
  return sub_100741494((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void *sub_1007411E8(uint64_t a1)
{
  return sub_100741528(a1 + 8);
}

void sub_1007411F0(void *a1)
{
  sub_100741528((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10074122C(uint64_t a1, unsigned char *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (v3 == 2)
  {
    id v7 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v8 = *(char *)(a1 + 16);
      if (v8 > 2) {
        long long v9 = "???";
      }
      else {
        long long v9 = off_101A02608[v8];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Successfully updated WiFi data usage policy to: %s", (uint8_t *)&buf, 0xCu);
    }
    sub_1000D2234(a1 + 80, a1 + 56, 1);
  }
  else if (v3 == 1)
  {
    uint64_t v6 = *(unsigned __int8 *)(a1 + 16);
    sub_100740BB4((uint64_t)&buf, a1 + 24);
    sub_1000E725C((uint64_t)v12, a1 + 80);
    sub_1007361E4((void **)v4, v6, 1, (uint64_t)&buf, (uint64_t)v12);
    sub_1000E0D60(v12);
    sub_100740A5C(&buf);
  }
  else if (!*a2)
  {
    int v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      unint64_t v10 = *(char *)(a1 + 16);
      if (v10 > 2) {
        unsigned __int8 v11 = "???";
      }
      else {
        unsigned __int8 v11 = off_101A02608[v10];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to update updated WiFi data usage policy to: %s", (uint8_t *)&buf, 0xCu);
    }
    *((void *)&buf + 1) = 0;
    uint64_t v14 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    sub_1000D2234(a1 + 80, (uint64_t)&buf, 0);
    sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
  }
}

void sub_100741408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

uint64_t sub_100741448(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100741488()
{
}

uint64_t sub_100741494(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  sub_100740BB4(a1 + 16, (uint64_t)(a2 + 2));
  sub_1000DB02C((uint64_t *)(a1 + 48), (uint64_t)(a2 + 6));
  sub_1000E725C(a1 + 72, (uint64_t)(a2 + 9));
  return a1;
}

void sub_100741500(_Unwind_Exception *a1)
{
  sub_10005CD2C(v3, *(char **)(v2 + 56));
  sub_100740A5C(v1);
  _Unwind_Resume(a1);
}

void *sub_100741528(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 72));
  sub_10005CD2C(a1 + 48, *(char **)(a1 + 56));

  return sub_100740A5C((void *)(a1 + 16));
}

void *sub_100741570(void *a1)
{
  *a1 = off_101A01CD0;
  sub_1000E0D60(a1 + 3);
  return a1;
}

void sub_1007415B4(void *a1)
{
  *a1 = off_101A01CD0;
  sub_1000E0D60(a1 + 3);

  operator delete();
}

void *sub_100741618(uint64_t a1)
{
  uint64_t v2 = operator new(0x38uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A01CD0;
  v2[1] = v3;
  *((unsigned char *)v2 + 16) = *(unsigned char *)(a1 + 16);
  sub_1000E725C((uint64_t)(v2 + 3), a1 + 24);
  return v2;
}

void sub_10074167C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100741690(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A01CD0;
  uint64_t v2 = *(void *)(a1 + 8);
  *(unsigned char *)(a2 + 16) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 8) = v2;
  return sub_1000E725C(a2 + 24, a1 + 24);
}

void *sub_1007416CC(uint64_t a1)
{
  return sub_1000E0D60((void *)(a1 + 24));
}

void sub_1007416D4(void *a1)
{
  sub_1000E0D60(a1 + 3);

  operator delete(a1);
}

void sub_100741710(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    BOOL v3 = *(unsigned char *)(a1 + 16) != 0;
    sub_1000E725C((uint64_t)&v4, a1 + 24);
    sub_100736AA0(v2, v3, (uint64_t)&v4);
    sub_1000E0D60(&v4);
  }
  else
  {
    v5[0] = 0;
    v5[1] = 0;
    uint64_t v4 = v5;
    sub_1000D2234(a1 + 24, (uint64_t)&v4, 0);
    sub_10005CD2C((uint64_t)&v4, v5[0]);
  }
}

void sub_1007417D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100741800(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100741840()
{
}

void sub_10074184C(uint64_t **a1, char *a2, char *a3, char *a4, char *a5, char *a6)
{
  id v12 = a1 + 1;
  uint64_t v22 = 0;
  id v13 = (char *)operator new(0x40uLL);
  unsigned int v21 = v12;
  sub_100058DB0(__p, a2);
  uint64_t v14 = v13 + 32;
  char v15 = *a3;
  char v16 = *a4;
  char v17 = *a5;
  char v18 = *a6;
  if (SHIBYTE(v24) < 0)
  {
    sub_10004FC84(v14, __p[0], (unint64_t)__p[1]);
    int v19 = SHIBYTE(v24);
    v13[56] = v15;
    v13[57] = v16;
    v13[58] = v17;
    v13[59] = v18;
    if (v19 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v14 = *(_OWORD *)__p;
    *((void *)v13 + 6) = v24;
    v13[56] = v15;
    v13[57] = v16;
    v13[58] = v17;
    v13[59] = v18;
  }
  LOBYTE(v22) = 1;
  __p[0] = 0;
  uint64_t v20 = (uint64_t **)sub_100046ED4((uint64_t)a1, __p, (void **)v13 + 4);
  if (*v20)
  {
    if (v13) {
      sub_1000C6EE8((uint64_t)&v21, (void **)v13);
    }
  }
  else
  {
    sub_100046C38(a1, (uint64_t)__p[0], v20, (uint64_t *)v13);
  }
}

void sub_100741994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1000C6EE8(v17, v18);
  _Unwind_Resume(a1);
}

uint64_t sub_1007419E0(uint64_t a1)
{
  *(void *)a1 = off_101A01D50;
  sub_1000E0D60((void *)(a1 + 40));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

void sub_100741A30(uint64_t a1)
{
  *(void *)a1 = off_101A01D50;
  sub_1000E0D60((void *)(a1 + 40));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete();
}

void *sub_100741AA0(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A01D50;
  sub_100741D8C(v2 + 1, v1);
  return v2;
}

void sub_100741AF4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100741B08(uint64_t a1, void *a2)
{
  *a2 = off_101A01D50;
  return sub_100741D8C(a2 + 1, (void *)(a1 + 8));
}

void sub_100741B34(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 40));
  uint64_t v2 = *(char **)(a1 + 24);

  sub_10005CD2C(a1 + 16, v2);
}

void sub_100741B74(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 40));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete((void *)a1);
}

void sub_100741BBC(uint64_t a1, unsigned char *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (v3 == 2)
  {
    uint64_t v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Successfully fixed WiFi data usage policy", (uint8_t *)&v7, 2u);
    }
    sub_1000D2234(a1 + 40, a1 + 16, 1);
  }
  else if (v3 == 1)
  {
    sub_1000E725C((uint64_t)&v7, a1 + 40);
    sub_100736AA0(v4, 1, (uint64_t)&v7);
    sub_1000E0D60(&v7);
  }
  else if (!*a2)
  {
    int v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v7) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to fix WiFi data usage policy to", (uint8_t *)&v7, 2u);
    }
    v8[0] = 0;
    v8[1] = 0;
    id v7 = v8;
    sub_1000D2234(a1 + 40, (uint64_t)&v7, 0);
    sub_10005CD2C((uint64_t)&v7, v8[0]);
  }
}

void sub_100741D10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100741D40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100741D80()
{
}

void *sub_100741D8C(void *a1, void *a2)
{
  *a1 = *a2;
  uint64_t v4 = (uint64_t)(a1 + 4);
  sub_1000DB02C(a1 + 1, (uint64_t)(a2 + 1));
  sub_1000E725C(v4, (uint64_t)(a2 + 4));
  return a1;
}

void sub_100741DE4(_Unwind_Exception *a1)
{
  sub_10005CD2C(v2, *(char **)(v1 + 16));
  _Unwind_Resume(a1);
}

void *sub_100741DFC(void *a1)
{
  *a1 = off_101A01DD0;
  sub_1000EA288(a1 + 2);
  return a1;
}

void sub_100741E40(void *a1)
{
  *a1 = off_101A01DD0;
  sub_1000EA288(a1 + 2);

  operator delete();
}

void *sub_100741EA4(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A01DD0;
  v2[1] = v3;
  sub_1000EE0FC((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100741EFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100741F10(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A01DD0;
  a2[1] = v2;
  return sub_1000EE0FC((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100741F40(uint64_t a1)
{
  return sub_1000EA288((void *)(a1 + 16));
}

void sub_100741F48(void *a1)
{
  sub_1000EA288(a1 + 2);

  operator delete(a1);
}

void sub_100741F84(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    sub_1000EE0FC((uint64_t)v3, a1 + 16);
    (*(void (**)(uint64_t, void **))(*(void *)v2 + 104))(v2, v3);
    sub_1000EA288(v3);
  }
  else
  {
    *(_OWORD *)std::string __p = 0u;
    long long v6 = 0u;
    *(_OWORD *)uint64_t v3 = 0u;
    long long v4 = 0u;
    sub_1000D8E0C(a1 + 16, (uint64_t)v3, 0);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (SBYTE7(v4) < 0) {
      operator delete(v3[0]);
    }
  }
}

void sub_100742064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17)
{
}

uint64_t sub_1007420A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007420E8()
{
}

uint64_t sub_1007420F4(uint64_t a1)
{
  *(void *)a1 = off_101A01E50;
  sub_1000DBB60((void *)(a1 + 40));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

void sub_100742144(uint64_t a1)
{
  *(void *)a1 = off_101A01E50;
  sub_1000DBB60((void *)(a1 + 40));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete();
}

void *sub_1007421B4(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A01E50;
  sub_100742450(v2 + 1, v1);
  return v2;
}

void sub_100742208(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10074221C(uint64_t a1, void *a2)
{
  *a2 = off_101A01E50;
  return sub_100742450(a2 + 1, (void *)(a1 + 8));
}

void sub_100742248(uint64_t a1)
{
  sub_1000DBB60((void *)(a1 + 40));
  uint64_t v2 = *(char **)(a1 + 24);

  sub_10005CD2C(a1 + 16, v2);
}

void sub_100742288(uint64_t a1)
{
  sub_1000DBB60((void *)(a1 + 40));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete((void *)a1);
}

void sub_1007422D0(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    sub_1000C6BDC(v4, a1 + 16);
    sub_1000DC0E0((uint64_t)&v5, a1 + 40);
    (*(void (**)(uint64_t, uint64_t *, void ***))(*(void *)v3 + 32))(v3, v4, &v5);
    sub_1000DBB60(&v5);
    sub_10005CD2C((uint64_t)v4, (char *)v4[1]);
  }
  else
  {
    v6[0] = 0;
    v6[1] = 0;
    int v5 = v6;
    sub_1000DC1F8(a1 + 40, (uint64_t)&v5, 0);
    sub_1000DC24C((uint64_t)&v5, v6[0]);
  }
}

void sub_1007423C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_100742404(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100742444()
{
}

void *sub_100742450(void *a1, void *a2)
{
  *a1 = *a2;
  uint64_t v4 = (uint64_t)(a1 + 4);
  sub_1000C6BDC(a1 + 1, (uint64_t)(a2 + 1));
  sub_1000DC0E0(v4, (uint64_t)(a2 + 4));
  return a1;
}

void sub_1007424A8(_Unwind_Exception *a1)
{
  sub_10005CD2C(v2, *(char **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_1007424C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100742558(void *a1)
{
  *a1 = off_101A01ED0;
  sub_100278CB4(a1 + 2);
  return a1;
}

void sub_10074259C(void *a1)
{
  *a1 = off_101A01ED0;
  sub_100278CB4(a1 + 2);

  operator delete();
}

void *sub_100742600(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A01ED0;
  v2[1] = v3;
  sub_1007424C0((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100742658(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10074266C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A01ED0;
  a2[1] = v2;
  return sub_1007424C0((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_10074269C(uint64_t a1)
{
  return sub_100278CB4((void *)(a1 + 16));
}

void sub_1007426A4(void *a1)
{
  sub_100278CB4(a1 + 2);

  operator delete(a1);
}

void *sub_1007426E0(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  int v4 = *a3;
  int v5 = *(void **)(a1 + 8);
  long long v6 = v5[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = "";
    if (!v4) {
      id v7 = "un";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Removing duplicate configs was %ssuccessful", buf, 0xCu);
  }
  if (!v4) {
    return (void *)sub_100737E2C(*(void *)(a1 + 40), 0);
  }
  unint64_t v8 = (void *)v5[24];
  v5[24] = 0;

  long long v9 = (void *)v5[26];
  v5[26] = 0;

  sub_1007424C0((uint64_t)v12, a1 + 16);
  char v15 = 0;
  unint64_t v10 = operator new(0x28uLL);
  void *v10 = off_101A01F40;
  sub_1007424C0((uint64_t)(v10 + 1), (uint64_t)v12);
  char v15 = v10;
  (*(void (**)(void *, uint8_t *))(*v5 + 160))(v5, buf);
  sub_100278CB4(buf);
  return sub_100278CB4(v12);
}

void sub_100742850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

uint64_t sub_10074288C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A01FB0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007428CC()
{
  return &off_101A01FB0;
}

void *sub_1007428D8(void *a1)
{
  *a1 = off_101A01F40;
  sub_100278CB4(a1 + 1);
  return a1;
}

void sub_10074291C(void *a1)
{
  *a1 = off_101A01F40;
  sub_100278CB4(a1 + 1);

  operator delete();
}

void *sub_100742980(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A01F40;
  sub_1007424C0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1007429D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007429E8(uint64_t a1, void *a2)
{
  *a2 = off_101A01F40;
  return sub_1007424C0((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100742A14(uint64_t a1)
{
  return sub_100278CB4((void *)(a1 + 8));
}

void sub_100742A1C(void *a1)
{
  sub_100278CB4(a1 + 1);

  operator delete(a1);
}

uint64_t sub_100742A58(uint64_t a1)
{
  return sub_100737E2C(*(void *)(a1 + 32), 0);
}

uint64_t sub_100742A64(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A01FA0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100742AA4()
{
  return &off_101A01FA0;
}

void *sub_100742AB0(void *a1)
{
  *a1 = off_101A01FD0;
  sub_100278CB4(a1 + 2);
  return a1;
}

void sub_100742AF4(void *a1)
{
  *a1 = off_101A01FD0;
  sub_100278CB4(a1 + 2);

  operator delete();
}

void *sub_100742B58(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A01FD0;
  v2[1] = v3;
  sub_1007424C0((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100742BB0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100742BC4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A01FD0;
  a2[1] = v2;
  return sub_1007424C0((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100742BF4(uint64_t a1)
{
  return sub_100278CB4((void *)(a1 + 16));
}

void sub_100742BFC(void *a1)
{
  sub_100278CB4(a1 + 2);

  operator delete(a1);
}

uint64_t sub_100742C38(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  sub_100737ACC((void *)v4, v4 + 144, (unsigned char *)(v4 + 121));
  int v5 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    long long v6 = "true";
    if (!v3) {
      long long v6 = "false";
    }
    int v10 = 136315138;
    unsigned __int8 v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Loaded configuration due to save operation result: %s", (uint8_t *)&v10, 0xCu);
  }
  if (v3)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    char v8 = 2;
  }
  else
  {
    if (*(unsigned char *)(v4 + 122) && *(unsigned char *)(v4 + 121))
    {
      uint64_t result = sub_100737E2C(*(void *)(a1 + 40), 2);
      *(unsigned char *)(v4 + 122) = 0;
      return result;
    }
    uint64_t v7 = *(void *)(a1 + 40);
    char v8 = 0;
  }
  return sub_100737E2C(v7, v8);
}

uint64_t sub_100742D58(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A02030)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100742D98()
{
  return &off_101A02030;
}

void *sub_100742DA4(void *a1)
{
  *a1 = off_101A02050;
  sub_100060644(a1 + 2);
  return a1;
}

void sub_100742DE8(void *a1)
{
  *a1 = off_101A02050;
  sub_100060644(a1 + 2);

  operator delete();
}

void *sub_100742E4C(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A02050;
  v2[1] = v3;
  sub_1000DFC90((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100742EA4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100742EB8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A02050;
  a2[1] = v2;
  return sub_1000DFC90((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100742EE8(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 16));
}

void sub_100742EF0(void *a1)
{
  sub_100060644(a1 + 2);

  operator delete(a1);
}

void *sub_100742F2C(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  int v4 = *a3;
  int v5 = *(void **)(a1 + 8);
  long long v6 = v5[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "";
    if (!v4) {
      uint64_t v7 = "un";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Removing duplicate configs was %ssuccessful", buf, 0xCu);
  }
  if (!v4) {
    return (void *)sub_1000607A8(a1 + 16, 0);
  }
  char v8 = (void *)v5[24];
  v5[24] = 0;

  long long v9 = (void *)v5[26];
  v5[26] = 0;

  sub_1000DFC90((uint64_t)v12, a1 + 16);
  char v15 = 0;
  int v10 = operator new(0x28uLL);
  void *v10 = off_101A020C0;
  sub_1000DFC90((uint64_t)(v10 + 1), (uint64_t)v12);
  char v15 = v10;
  (*(void (**)(void *, uint8_t *))(*v5 + 160))(v5, buf);
  sub_100278CB4(buf);
  return sub_100060644(v12);
}

void sub_10074309C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

uint64_t sub_1007430D8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A02130)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100743118()
{
  return &off_101A02130;
}

void *sub_100743124(void *a1)
{
  *a1 = off_101A020C0;
  sub_100060644(a1 + 1);
  return a1;
}

void sub_100743168(void *a1)
{
  *a1 = off_101A020C0;
  sub_100060644(a1 + 1);

  operator delete();
}

void *sub_1007431CC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A020C0;
  sub_1000DFC90((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100743220(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100743234(uint64_t a1, void *a2)
{
  *a2 = off_101A020C0;
  return sub_1000DFC90((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100743260(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 8));
}

void sub_100743268(void *a1)
{
  sub_100060644(a1 + 1);

  operator delete(a1);
}

uint64_t sub_1007432A4(uint64_t a1, unsigned char *a2)
{
  return sub_1000607A8(a1 + 8, *a2 == 2);
}

uint64_t sub_1007432B8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A02120)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007432F8()
{
  return &off_101A02120;
}

void sub_100743308()
{
}

void *sub_10074331C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A02150;
  result[1] = v3;
  return result;
}

uint64_t sub_100743364(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A02150;
  a2[1] = v2;
  return result;
}

void sub_100743390(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*a2) {
      int v4 = "true";
    }
    else {
      int v4 = "false";
    }
    int v5 = 136315138;
    long long v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Loaded configuration due to change notification: %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_10074344C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A021B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10074348C()
{
  return &off_101A021B0;
}

void *sub_100743498(void *a1)
{
  *a1 = off_101A021D0;
  sub_100278CB4(a1 + 2);
  return a1;
}

void sub_1007434DC(void *a1)
{
  *a1 = off_101A021D0;
  sub_100278CB4(a1 + 2);

  operator delete();
}

void *sub_100743540(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A021D0;
  v2[1] = v3;
  sub_1007424C0((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100743598(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007435AC(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A021D0;
  a2[1] = v2;
  return sub_1007424C0((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_1007435DC(uint64_t a1)
{
  return sub_100278CB4((void *)(a1 + 16));
}

void sub_1007435E4(void *a1)
{
  sub_100278CB4(a1 + 2);

  operator delete(a1);
}

void *sub_100743620(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  int v4 = *a3;
  int v5 = *(void **)(a1 + 8);
  long long v6 = v5[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "";
    if (!v4) {
      uint64_t v7 = "un";
    }
    int v11 = 136315138;
    id v12 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Removing duplicate configs was %ssuccessful", (uint8_t *)&v11, 0xCu);
  }
  if (!v4) {
    return (void *)sub_100737E2C(*(void *)(a1 + 40), 0);
  }
  char v8 = (void *)v5[24];
  v5[24] = 0;

  long long v9 = (void *)v5[26];
  v5[26] = 0;

  sub_1007424C0((uint64_t)&v11, a1 + 16);
  (*(void (**)(void *, int *))(*v5 + 160))(v5, &v11);
  return sub_100278CB4(&v11);
}

void sub_100743750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10074376C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A02230)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007437AC()
{
  return &off_101A02230;
}

void *sub_1007437B8(void *a1)
{
  *a1 = off_101A02250;
  sub_1000F25E0(a1 + 2);
  return a1;
}

void sub_1007437FC(void *a1)
{
  *a1 = off_101A02250;
  sub_1000F25E0(a1 + 2);

  operator delete();
}

void *sub_100743860(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A02250;
  v2[1] = v3;
  sub_10033571C((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_1007438B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007438CC(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A02250;
  a2[1] = v2;
  return sub_10033571C((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_1007438FC(uint64_t a1)
{
  return sub_1000F25E0((void *)(a1 + 16));
}

void sub_100743904(void *a1)
{
  sub_1000F25E0(a1 + 2);

  operator delete(a1);
}

void *sub_100743940(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/prefs-nb/ne_config_state");
  int v5 = _NSConcreteStackBlock;
  uint64_t v6 = 3321888768;
  uint64_t v7 = sub_100743AAC;
  char v8 = &unk_101A022B0;
  sub_10033571C((uint64_t)v9, a1 + 16);
  ctu::RestModule::getPropertyOnce();
  if (v4 < 0) {
    operator delete(__p);
  }
  return sub_1000F25E0(v9);
}

void sub_100743A2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_1000F25E0(v14);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100743A60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100743AA0()
{
}

uint64_t sub_100743AAC(uint64_t a1, xpc *a2)
{
  if (xpc_get_type(*(xpc_object_t *)a2) == (xpc_type_t)&_xpc_type_null) {
    __int16 v5 = 0;
  }
  else {
    __int16 v5 = xpc::dyn_cast_or_default(a2, 0, v4) | 0x100;
  }

  return sub_100335978(a1 + 32, v5);
}

uint64_t sub_100743B18(uint64_t a1, uint64_t a2)
{
  return sub_10033571C(a1 + 32, a2 + 32);
}

void *sub_100743B24(uint64_t a1)
{
  return sub_1000F25E0((void *)(a1 + 32));
}

uint64_t sub_100743B2C(uint64_t a1)
{
  *(void *)a1 = off_101A02300;
  sub_1000E0D60((void *)(a1 + 56));
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  return a1;
}

void sub_100743B84(uint64_t a1)
{
  *(void *)a1 = off_101A02300;
  sub_1000E0D60((void *)(a1 + 56));
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  operator delete();
}

void *sub_100743BFC(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A02300;
  sub_100743E60(v2 + 1, v1);
  return v2;
}

void sub_100743C50(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100743C64(uint64_t a1, void *a2)
{
  *a2 = off_101A02300;
  return sub_100743E60(a2 + 1, (void *)(a1 + 8));
}

void sub_100743C90(uint64_t a1)
{
}

void sub_100743C98(void *a1)
{
  sub_100743EE8((uint64_t)a1 + 8);

  operator delete(a1);
}

void *sub_100743CD4(void *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = a1[1];
  __int16 v5 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = "false";
    uint64_t v7 = a1[3];
    if (v3) {
      uint64_t v6 = "true";
    }
    *(_DWORD *)int v10 = 134218242;
    *(void *)&void v10[4] = v7;
    *(_WORD *)&v10[12] = 2080;
    *(void *)&v10[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Redundant configurations count: %lu removed result: %s", v10, 0x16u);
  }
  sub_1000D2234((uint64_t)(a1 + 7), (uint64_t)(a1 + 4), v3 != 0);
  char v8 = (void *)a1[2];
  *(void *)int v10 = off_101A02370;
  *(void *)&v10[8] = v4;
  int v11 = v10;
  sub_1007335B8(v4, v8, (uint64_t)v10);
  return sub_100278CB4(v10);
}

void sub_100743DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100743E14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100743E54()
{
}

void *sub_100743E60(void *a1, void *a2)
{
  uint64_t v4 = (void *)a2[1];
  *a1 = *a2;
  id v5 = v4;
  uint64_t v6 = a2[2];
  a1[1] = v5;
  a1[2] = v6;
  sub_1000DB02C(a1 + 3, (uint64_t)(a2 + 3));
  sub_1000E725C((uint64_t)(a1 + 6), (uint64_t)(a2 + 6));
  return a1;
}

void sub_100743EC0(_Unwind_Exception *a1)
{
  sub_10005CD2C(v2, *(char **)(v1 + 32));

  _Unwind_Resume(a1);
}

void sub_100743EE8(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 48));
  sub_10005CD2C(a1 + 24, *(char **)(a1 + 32));
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100743F34()
{
}

void *sub_100743F48(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A02370;
  result[1] = v3;
  return result;
}

uint64_t sub_100743F90(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A02370;
  a2[1] = v2;
  return result;
}

void sub_100743FBC(uint64_t a1, unsigned char *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (*a2)
  {
    if (v2 == 1)
    {
      uint64_t v4 = *(NSObject **)(v3 + 40);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      __int16 v8 = 0;
      id v5 = "#N Not retrying config save when removing duplicates";
      uint64_t v6 = (uint8_t *)&v8;
      goto LABEL_10;
    }
    if (v2 == 2)
    {
      uint64_t v4 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v10 = 0;
        id v5 = "#I Successfully saved config when removing duplicate configs";
        uint64_t v6 = (uint8_t *)&v10;
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
      }
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to save merged configuration", buf, 2u);
    }
  }
}

uint64_t sub_1007440A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007440E8()
{
}

void sub_1007440F8()
{
}

__n128 sub_10074410C(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = off_101A02400;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100744158(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A02400;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100744188(uint64_t result, unsigned char *a2)
{
  if (*a2 == 2) {
    return (*(uint64_t (**)(void, void))(**(void **)(result + 8) + 88))(*(void *)(result + 8), *(unsigned __int8 *)(result + 16));
  }
  return result;
}

uint64_t sub_1007441C8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100744208()
{
}

void sub_100744218()
{
}

__n128 sub_10074422C(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = off_101A02480;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100744278(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A02480;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007442A8(uint64_t a1, unsigned char *a2)
{
  int v2 = *(void **)(a1 + 8);
  if (*a2 == 1)
  {
    uint64_t v4 = *(void (**)(void))(*v2 + 88);
    v4();
  }
  else if (!*a2)
  {
    uint64_t v3 = v2[5];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E Failed to update cellular fallback flags", v5, 2u);
    }
  }
}

uint64_t sub_100744364(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007443A4()
{
}

uint64_t sub_1007443B0(uint64_t a1)
{
  *(void *)a1 = off_101A02500;
  sub_1000E0D60((void *)(a1 + 48));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

void sub_100744400(uint64_t a1)
{
  *(void *)a1 = off_101A02500;
  sub_1000E0D60((void *)(a1 + 48));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete();
}

void *sub_100744470(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x50uLL);
  *int v2 = off_101A02500;
  sub_1007446D8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1007444C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007444D8(uint64_t a1, void *a2)
{
  *a2 = off_101A02500;
  return sub_1007446D8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100744504(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 48));
  int v2 = *(char **)(a1 + 24);

  sub_10005CD2C(a1 + 16, v2);
}

void sub_100744544(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 48));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete((void *)a1);
}

void sub_10074458C(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2)
  {
    uint64_t v3 = *(Registry ***)(a1 + 8);
    BOOL v4 = *(unsigned char *)(a1 + 40) != 0;
    sub_1000E725C((uint64_t)&v5, a1 + 48);
    sub_10073BF3C(v3, (uint64_t **)(a1 + 16), v4, (uint64_t)&v5);
    sub_1000E0D60(&v5);
  }
  else
  {
    v6[0] = 0;
    v6[1] = 0;
    id v5 = v6;
    sub_1000D2234(a1 + 48, (uint64_t)&v5, 0);
    sub_10005CD2C((uint64_t)&v5, v6[0]);
  }
}

void sub_10074465C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10074468C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007446CC()
{
}

uint64_t sub_1007446D8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  sub_1000C6BDC((uint64_t *)(a1 + 8), a2 + 8);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  sub_1000E725C(a1 + 40, a2 + 40);
  return a1;
}

void sub_100744730(_Unwind_Exception *a1)
{
  sub_10005CD2C(v2, *(char **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_100744748(uint64_t a1)
{
  *(void *)a1 = off_101A02580;
  sub_1000E0D60((void *)(a1 + 64));
  sub_10005CD2C(a1 + 40, *(char **)(a1 + 48));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

void sub_1007447A4(uint64_t a1)
{
  *(void *)a1 = off_101A02580;
  sub_1000E0D60((void *)(a1 + 64));
  sub_10005CD2C(a1 + 40, *(char **)(a1 + 48));
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));

  operator delete();
}

void *sub_100744820(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x60uLL);
  *uint64_t v2 = off_101A02580;
  sub_100744ACC(v2 + 1, v1);
  return v2;
}

void sub_100744874(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100744888(uint64_t a1, void *a2)
{
  *a2 = off_101A02580;
  return sub_100744ACC(a2 + 1, (void *)(a1 + 8));
}

void sub_1007448B4(uint64_t a1)
{
}

void sub_1007448BC(void *a1)
{
  sub_100744B68((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1007448F8(uint64_t a1, unsigned char *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (v3 == 2)
  {
    uint64_t v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Successfully added rule for apps which no rule present in the config", (uint8_t *)&v7, 2u);
    }
    sub_1000D2234(a1 + 64, a1 + 40, 1);
  }
  else if (v3 == 1)
  {
    sub_1000E725C((uint64_t)&v7, a1 + 64);
    sub_10073BF3C((Registry **)v4, (uint64_t **)(a1 + 16), 1, (uint64_t)&v7);
    sub_1000E0D60(&v7);
  }
  else if (!*a2)
  {
    id v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v7) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to update default cellular behavior", (uint8_t *)&v7, 2u);
    }
    v8[0] = 0;
    v8[1] = 0;
    uint64_t v7 = v8;
    sub_1000D2234(a1 + 64, (uint64_t)&v7, 0);
    sub_10005CD2C((uint64_t)&v7, v8[0]);
  }
}

void sub_100744A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100744A80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100744AC0()
{
}

void *sub_100744ACC(void *a1, void *a2)
{
  uint64_t v4 = (uint64_t)(a2 + 4);
  *a1 = *a2;
  id v5 = a1 + 4;
  sub_1000C6BDC(a1 + 1, (uint64_t)(a2 + 1));
  sub_1000DB02C(v5, v4);
  sub_1000E725C((uint64_t)(a1 + 7), (uint64_t)(a2 + 7));
  return a1;
}

void sub_100744B3C(_Unwind_Exception *a1)
{
  sub_10005CD2C(v3, *(char **)(v1 + 40));
  sub_10005CD2C(v2, *(char **)(v1 + 16));
  _Unwind_Resume(a1);
}

void sub_100744B68(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 56));
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));
  uint64_t v2 = *(char **)(a1 + 16);

  sub_10005CD2C(a1 + 8, v2);
}

void sub_100744BB4(void **a1)
{
  *a1 = off_101A02640;
  uint64_t v2 = (void ***)(a1 + 1);
  uint64_t v3 = a1 + 2;
  sub_100465E6C(&v3);
  sub_100110A40(v2, 0);
  PB::Base::~Base((PB::Base *)a1);
}

void sub_100744C24(void **a1)
{
  sub_100744BB4(a1);

  operator delete();
}

void sub_100744C5C()
{
}

void sub_100744D60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004660D8((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100744DA4(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  id v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  char v6 = *(unsigned char *)(a1 + 48);
  if (v6)
  {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 40));
    char v6 = *(unsigned char *)(a1 + 48);
  }
  if ((v6 & 2) != 0) {
    PB::TextFormatter::format(this, "result", *(unsigned char *)(a1 + 44));
  }
  uint64_t v7 = *(uint64_t **)(a1 + 16);
  __int16 v8 = *(uint64_t **)(a1 + 24);
  while (v7 != v8)
  {
    uint64_t v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, this, "updatedSubscription");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100744E8C(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_26;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_21:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_26:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        sub_100745204();
      case 3u:
        *(unsigned char *)(a1 + 48) |= 2u;
        unint64_t v23 = *((void *)this + 1);
        if (v23 >= *((void *)this + 2))
        {
          BOOL v26 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v24 = v23 + 1;
          int v25 = *(unsigned __int8 *)(*(void *)this + v23);
          *((void *)this + 1) = v24;
          BOOL v26 = v25 != 0;
        }
        *(unsigned char *)(a1 + 44) = v26;
        goto LABEL_21;
      case 4u:
        *(unsigned char *)(a1 + 48) |= 1u;
        unint64_t v27 = *((void *)this + 1);
        unint64_t v28 = *((void *)this + 2);
        uint64_t v29 = *(void *)this;
        if (v27 <= 0xFFFFFFFFFFFFFFF5 && v27 + 10 <= v28)
        {
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v32 = 0;
          do
          {
            unint64_t v33 = v27 + 1;
            *((void *)this + 1) = v27 + 1;
            char v34 = *(unsigned char *)(v29 + v27);
            v32 |= (unint64_t)(v34 & 0x7F) << v30;
            if ((v34 & 0x80) == 0) {
              goto LABEL_51;
            }
            v30 += 7;
            unint64_t v27 = v33;
            BOOL v14 = v31++ > 8;
          }
          while (!v14);
LABEL_47:
          LODWORD(v32) = 0;
          goto LABEL_51;
        }
        char v35 = 0;
        unsigned int v36 = 0;
        uint64_t v32 = 0;
        if (v28 <= v27) {
          unint64_t v28 = *((void *)this + 1);
        }
        break;
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v28 == v27)
      {
        LODWORD(v32) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_51;
      }
      unint64_t v37 = v27 + 1;
      char v38 = *(unsigned char *)(v29 + v27);
      *((void *)this + 1) = v37;
      v32 |= (unint64_t)(v38 & 0x7F) << v35;
      if ((v38 & 0x80) == 0) {
        break;
      }
      v35 += 7;
      unint64_t v27 = v37;
      BOOL v14 = v36++ > 8;
      if (v14) {
        goto LABEL_47;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v32) = 0;
    }
LABEL_51:
    *(_DWORD *)(a1 + 40) = v32;
    goto LABEL_21;
  }
  int v4 = 0;
  return v4 == 0;
}

void sub_100745204()
{
}

void sub_100745334(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004660D8((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100745378(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  id v5 = *(const PB::Base ***)(v3 + 16);
  char v6 = *(const PB::Base ***)(v3 + 24);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 2u);
  }
  char v8 = *(unsigned char *)(v3 + 48);
  if ((v8 & 2) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 44), 3u);
    char v8 = *(unsigned char *)(v3 + 48);
  }
  if (v8)
  {
    unsigned int v9 = *(_DWORD *)(v3 + 40);
    return PB::Writer::writeVarInt(this, v9, 4u);
  }
  return result;
}

void sub_100745424()
{
}

void sub_1007454E8(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10074551C(uint64_t a1, void *a2, dispatch_object_t *a3)
{
  char v6 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, "reg.mdl.cmn");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v13);
  ctu::OsLogLogger::OsLogLogger(v6, (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  *(void *)a1 = off_101A02690;
  *(void *)(a1 + 16) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 24) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "RegistrationDeviceState");
  unsigned int v10 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  char v8 = (capabilities::ct *)v10;
  if (v10) {
    dispatch_release(v10);
  }
  if (v12 < 0) {
    operator delete(__p);
  }
  *(_DWORD *)(a1 + 48) = 8;
  *(void *)(a1 + 56) = 300000;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 105) = capabilities::ct::supportsVoiceCall(v8) ^ 1;
  *(_WORD *)(a1 + 106) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  return a1;
}

void sub_10074568C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  sub_10003B34C((void *)v17 + 9);
  uint64_t v20 = *((void *)v17 + 8);
  *((void *)v17 + 8) = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  unsigned int v21 = (std::__shared_weak_count *)*((void *)v17 + 5);
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v22 = (std::__shared_weak_count *)*((void *)v17 + 3);
  if (v22) {
    sub_10004D2C8(v22);
  }
  ctu::OsLogLogger::~OsLogLogger(v18);
  RegistrationDeviceStateInterface::~RegistrationDeviceStateInterface(v17);
  _Unwind_Resume(a1);
}

void sub_100745758(void *a1)
{
  *a1 = off_101A02690;
  int v2 = (std::__shared_weak_count *)a1[16];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10003B34C(a1 + 9);
  uint64_t v3 = a1[8];
  a1[8] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }
  id v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  RegistrationDeviceStateInterface::~RegistrationDeviceStateInterface((RegistrationDeviceStateInterface *)a1);
}

void sub_100745810(void *a1)
{
  sub_100745758(a1);

  operator delete();
}

void sub_100745848(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  id v5 = *(std::__shared_weak_count **)(a1 + 128);
  *(void *)(a1 + 120) = v4;
  *(void *)(a1 + 128) = v3;
  if (v5) {
    sub_10004D2C8(v5);
  }
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(a1 + 16));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100058DB0(&__p, "/cc/props/airplane_mode");
  char v6 = operator new(0x28uLL);
  void *v6 = off_101A02840;
  v6[1] = a1 + 49;
  _DWORD v6[2] = a1;
  v6[3] = sub_1007459AC;
  void v6[4] = 0;
  v11[3] = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p);
  }
}

void sub_100745964(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1007459AC(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 49);
  if (v2 != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = "false";
      if (a2) {
        char v6 = "true";
      }
      else {
        char v6 = "false";
      }
      if (v2) {
        id v5 = "true";
      }
      int v7 = 136315394;
      char v8 = v6;
      __int16 v9 = 2080;
      char v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I User initiated airplane mode changing from %s to %s", (uint8_t *)&v7, 0x16u);
    }
  }
}

uint64_t sub_100745A88(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 32));
}

void sub_100745A90(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 48) != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id v5 = 136315394;
      *(void *)&void v5[4] = asString();
      *(_WORD *)&v5[12] = 2080;
      *(void *)&v5[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Operating mode is changing from %s to %s", v5, 0x16u);
    }
    *(unsigned char *)(a1 + 48) = a2;
    if (!a2)
    {
      *(void *)id v5 = 0;
      *(void *)&v5[8] = 0;
      gettimeofday((timeval *)v5, 0);
      *(void *)(a1 + 112) = 1000 * *(void *)v5 + *(int *)&v5[8] / 0x3E8uLL;
    }
  }
}

uint64_t sub_100745BAC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 48);
}

void sub_100745BB4(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 104);
  if (v2 != a2)
  {
    id v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      char v6 = "true";
      if (v2) {
        int v7 = "true";
      }
      else {
        int v7 = "false";
      }
      if (!a2) {
        char v6 = "false";
      }
      int v8 = 136315394;
      __int16 v9 = v7;
      __int16 v10 = 2080;
      unint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Call active changing from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(a1 + 104) = a2;
    sub_100745CA0(a1);
  }
}

void sub_100745CA0(uint64_t a1)
{
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1))
  {
    if (*(unsigned char *)(a1 + 104))
    {
      int v2 = *(NSObject **)(a1 + 8);
      if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v3 = "#I ECBM active, but call outstanding; will start timer after calls end";
      uint64_t v4 = v2;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v3, buf, 2u);
      return;
    }
    uint64_t v6 = *(void *)(a1 + 64);
    int v7 = *(NSObject **)(a1 + 8);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (!v8) {
        return;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v3 = "#I ECBM timer already active; doing nothing";
      uint64_t v4 = v7;
      goto LABEL_11;
    }
    if (v8)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I ECBM timer started", buf, 2u);
    }
    uint64_t v9 = *(void *)(a1 + 56);
    global_queue = dispatch_get_global_queue(0, 0);
    *(_OWORD *)long long buf = 0u;
    long long v25 = 0u;
    sub_1000F0058((uint64_t)buf, a1 + 72);
    Registry::getTimerService(&v19, *(Registry **)(a1 + 16));
    uint64_t v11 = v19;
    sub_100058DB0(__p, "ECBMTimer");
    dispatch_object_t object = global_queue;
    if (global_queue) {
      dispatch_retain(global_queue);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_10074606C;
    aBlock[3] = &unk_101A02740;
    sub_1000F0058((uint64_t)v23, (uint64_t)buf);
    char v15 = _Block_copy(aBlock);
    sub_100118A44(v11, (uint64_t)__p, 1, 1000 * v9, &object, &v15);
    uint64_t v12 = v21;
    uint64_t v21 = 0;
    uint64_t v13 = *(void *)(a1 + 64);
    *(void *)(a1 + 64) = v12;
    if (v13)
    {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      uint64_t v14 = v21;
      uint64_t v21 = 0;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
    }
    if (v15) {
      _Block_release(v15);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    if (v20) {
      sub_10004D2C8(v20);
    }
    sub_10003B34C(v23);
    sub_10003B34C(buf);
  }
  else
  {
    id v5 = *(void (**)(uint64_t))(*(void *)a1 + 104);
    v5(a1);
  }
}

void sub_100745FC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100746054(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 51);
}

void *sub_10074605C(uint64_t a1, uint64_t a2)
{
  return sub_1003351AC((void *)(a1 + 72), a2);
}

uint64_t sub_100746064(uint64_t result, uint64_t a2)
{
  *(void *)(result + 56) = a2;
  return result;
}

uint64_t sub_10074606C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 56);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

void sub_10074609C(uint64_t a1, int a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 88))(a1) != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = "false";
      if (a2) {
        id v5 = "true";
      }
      int v6 = 136315138;
      int v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting ECBM active = %s ", (uint8_t *)&v6, 0xCu);
    }
    *(unsigned char *)(a1 + 51) = a2;
    sub_100745CA0(a1);
  }
}

void sub_100746194(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  if (v1)
  {
    uint64_t v3 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Cancelling ECBM timer", v4, 2u);
      uint64_t v1 = *(void *)(a1 + 64);
      *(void *)(a1 + 64) = 0;
      if (!v1) {
        return;
      }
    }
    else
    {
      *(void *)(a1 + 64) = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

void sub_100746244(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 50) != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = "false";
      if (a2) {
        id v5 = "true";
      }
      int v6 = 136315138;
      int v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting baseband alive state to: %s", (uint8_t *)&v6, 0xCu);
    }
    *(unsigned char *)(a1 + 50) = a2;
  }
}

uint64_t sub_100746314(uint64_t result, int a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(result + 106);
  if (v3 != a2)
  {
    uint64_t v6 = result;
    int v7 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v8 = "true";
      if (v3) {
        uint64_t v9 = "true";
      }
      else {
        uint64_t v9 = "false";
      }
      if (!a2) {
        BOOL v8 = "false";
      }
      int v10 = 136315394;
      uint64_t v11 = v9;
      __int16 v12 = 2080;
      uint64_t v13 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Baseband ON state is changing from %s to %s", (uint8_t *)&v10, 0x16u);
      int v3 = *(unsigned __int8 *)(v6 + 106);
    }
    if (!v3)
    {
      (*(void (**)(uint64_t, void))(*(void *)v6 + 152))(v6, 0);
      (*(void (**)(void, uint64_t, void))(**(void **)(v6 + 120) + 64))(*(void *)(v6 + 120), 3, 0);
    }
    *(unsigned char *)(v6 + 106) = a2;
    uint64_t result = *(void *)(a3 + 24);
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
    }
  }
  return result;
}

uint64_t sub_100746494(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 106);
}

void sub_10074649C(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 107);
  if (v2 != a2)
  {
    id v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "true";
      if (v2) {
        int v7 = "true";
      }
      else {
        int v7 = "false";
      }
      if (!a2) {
        uint64_t v6 = "false";
      }
      int v8 = 136315394;
      uint64_t v9 = v7;
      __int16 v10 = 2080;
      uint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Already sent baseband online request changing from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(a1 + 107) = a2;
  }
}

uint64_t sub_100746580(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 107);
}

unint64_t sub_100746588(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    int v2 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v4.tv_sec) = 136315138;
      *(__darwin_time_t *)((char *)&v4.tv_sec + 4) = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Invalid Operating mode : %s", (uint8_t *)&v4, 0xCu);
    }
    return 0;
  }
  else
  {
    v4.tv_sec = 0;
    *(void *)&v4.tv_usec = 0;
    gettimeofday(&v4, 0);
    return 1000 * v4.tv_sec + v4.tv_usec / 0x3E8uLL - *(void *)(a1 + 112);
  }
}

void sub_100746684(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136315138;
    uint64_t v11 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Operating mode: %s", (uint8_t *)&v10, 0xCu);
    int v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 49)) {
      int v3 = "true";
    }
    else {
      int v3 = "false";
    }
    int v10 = 136315138;
    uint64_t v11 = (uint64_t)v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I User initiated airplane mode: %s", (uint8_t *)&v10, 0xCu);
    int v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 50)) {
      timeval v4 = "true";
    }
    else {
      timeval v4 = "false";
    }
    int v10 = 136315138;
    uint64_t v11 = (uint64_t)v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Baseband alive: %s", (uint8_t *)&v10, 0xCu);
    int v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 51)) {
      id v5 = "true";
    }
    else {
      id v5 = "false";
    }
    int v10 = 136315138;
    uint64_t v11 = (uint64_t)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ECBM Active: %s", (uint8_t *)&v10, 0xCu);
    int v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 104)) {
      uint64_t v6 = "true";
    }
    else {
      uint64_t v6 = "false";
    }
    int v10 = 136315138;
    uint64_t v11 = (uint64_t)v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Call active: %s", (uint8_t *)&v10, 0xCu);
    int v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 105)) {
      int v7 = "true";
    }
    else {
      int v7 = "false";
    }
    int v10 = 136315138;
    uint64_t v11 = (uint64_t)v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Data only: %s", (uint8_t *)&v10, 0xCu);
    int v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 106)) {
      int v8 = "true";
    }
    else {
      int v8 = "false";
    }
    int v10 = 136315138;
    uint64_t v11 = (uint64_t)v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Baseband on: %s", (uint8_t *)&v10, 0xCu);
    int v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 107)) {
      uint64_t v9 = "true";
    }
    else {
      uint64_t v9 = "false";
    }
    int v10 = 136315138;
    uint64_t v11 = (uint64_t)v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Already sent baseband online: %s", (uint8_t *)&v10, 0xCu);
  }
}

void sub_100746978(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007469E0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100746A1C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100746A54(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100746A84(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100746ACC()
{
}

__n128 sub_100746AE0(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  *(void *)int v2 = off_101A02840;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100746B34(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A02840;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100746B6C(void *a1, xpc *this, BOOL a3)
{
  timeval v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100746C08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100746C48()
{
}

const char *sub_100746C54(unsigned int a1)
{
  if (a1 > 0x1F) {
    return "???";
  }
  else {
    return off_101A028B0[(char)a1];
  }
}

const char *sub_100746C7C(char a1)
{
  if ((a1 + 1) > 0x1Fu) {
    return "???";
  }
  else {
    return off_101A029B0[(char)(a1 + 1)];
  }
}

const char *sub_100746CAC(int a1)
{
  HIDWORD(v2) = a1;
  LODWORD(v2) = a1;
  unsigned int v1 = v2 >> 4;
  if (v1 > 8) {
    return "notificationEvent(error)";
  }
  else {
    return off_101A02AB0[v1];
  }
}

uint64_t sub_100746CD4(uint64_t a1, std::string *a2)
{
  if (!*(_DWORD *)(a1 + 8)) {
    return 1;
  }
  int DataAt = DERDecoderGetDataAt();
  BOOL v4 = DataAt == 0;
  if (DataAt)
  {
    int v5 = DataAt;
    sub_100746E04();
    uint64_t v6 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v5 + 1) > 8) {
        uint64_t v7 = "DERDecoderError(Unknown)";
      }
      else {
        uint64_t v7 = off_101A02BA0[v5 + 1];
      }
      *(_DWORD *)long long buf = 136315138;
      int v10 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Get data failure (ServiceProviderName): %s", buf, 0xCu);
    }
  }
  else
  {
    sub_10006E5EC(a2, 0, 0, 0);
  }
  return v4;
}

void sub_100746E04()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D630, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D630))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D628, kCtLoggingSystemName, "vinyl.helper");
    __cxa_guard_release(&qword_101B0D630);
  }
}

void sub_100746E84(_Unwind_Exception *a1)
{
}

BOOL sub_100746E9C()
{
  int v0 = DERDecoderInitialize();
  if (v0)
  {
    unsigned int v1 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "vinyl.helper");
    unint64_t v2 = *(NSObject **)&v14[4];
    ctu::OsLogContext::~OsLogContext(v1);
    BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_INFO);
    if (!result) {
      return result;
    }
    if ((v0 + 1) > 8) {
      BOOL v4 = "DERDecoderError(Unknown)";
    }
    else {
      BOOL v4 = off_101A02BA0[v0 + 1];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)uint64_t v14 = v4;
    int v8 = "Intialization failed (smdpSigned2): %s";
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, v8, buf, 0xCu);
    return 0;
  }
  int v5 = DERDecoderParseSequence();
  if (v5)
  {
    uint64_t v6 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "vinyl.helper");
    unint64_t v2 = *(NSObject **)&v14[4];
    ctu::OsLogContext::~OsLogContext(v6);
    BOOL result = os_log_type_enabled(v2, OS_LOG_TYPE_INFO);
    if (!result) {
      return result;
    }
    if ((v5 + 1) > 8) {
      uint64_t v7 = "DERDecoderError(Unknown)";
    }
    else {
      uint64_t v7 = off_101A02BA0[v5 + 1];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)uint64_t v14 = v7;
    int v8 = "Parse sequence failed (smdpSigned2): %s";
    goto LABEL_17;
  }
  int DataWithTag = DERDecoderGetDataWithTag();
  if (DataWithTag)
  {
    sub_100746E04();
    int v10 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if ((DataWithTag + 1) > 8) {
      uint64_t v11 = "DERDecoderError(Unknown)";
    }
    else {
      uint64_t v11 = off_101A02BA0[DataWithTag + 1];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)uint64_t v14 = v11;
    __int16 v12 = "Get data failure (CCRequiredFlag): %s";
    goto LABEL_24;
  }
  sub_100746E04();
  int v10 = qword_101B0D628;
  BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)uint64_t v14 = "kDERDecoderErrorNone";
    __int16 v12 = "Invalid length (CCRequiredFlag): %s";
LABEL_24:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v12, buf, 0xCu);
    return 0;
  }
  return result;
}

BOOL sub_100747164(uint64_t a1, uint64_t a2)
{
  v21[0] = 0;
  v21[1] = 0;
  uint64_t v22 = 0;
  ctu::base64::encode();
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v20 = 0;
  ctu::base64::encode();
  int v5 = +[NSString stringWithFormat:@"%s", v21];
  uint64_t v6 = +[NSString stringWithFormat:@"%s", __p];
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v8 = a1 + 48;
  uint64_t v7 = v9;
  if (*(char *)(v8 + 23) >= 0) {
    uint64_t v7 = v8;
  }
  int v10 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v5, @"euiccChallenge", v6, @"euiccInfo1", +[NSString stringWithFormat:@"%s", v7], @"smdpAddress", 0);
  id v23 = 0;
  id v11 = sub_100747394((uint64_t)v10, &v23);
  if (v11)
  {
    sub_100746E04();
    __int16 v12 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "JSON encoding failure (initiateAuthenticationReq)", buf, 2u);
    }
  }
  else
  {
    id v13 = v23;
    uint64_t v14 = (char *)[v23 bytes];
    char v15 = *(char **)(a2 + 8);
    unsigned int v16 = (char *)[v13 length];
    sub_10016A4CC(a2, v15, v14, &v16[(void)v14], (int64_t)v16);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
  return v11 == 0;
}

void sub_100747354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

id sub_100747394(uint64_t a1, void *a2)
{
  id v8 = 0;
  int v3 = +[NSJSONSerialization dataWithJSONObject:a1 options:0 error:&v8];
  if (!v8)
  {
    *a2 = objc_msgSend(objc_msgSend(objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", v3, 4), "stringByReplacingOccurrencesOfString:withString:", @"\\/", @"/"), "dataUsingEncoding:", 4);
    if (!v8) {
      return 0;
    }
  }
  sub_100746E04();
  BOOL v4 = qword_101B0D628;
  BOOL v5 = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
  id result = v8;
  if (v5)
  {
    id v7 = objc_msgSend(objc_msgSend(v8, "description"), "UTF8String");
    *(_DWORD *)long long buf = 136315138;
    id v10 = v7;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error: %s", buf, 0xCu);
    return v8;
  }
  return result;
}

uint64_t sub_1007474C4(void *a1, uint64_t a2, uint64_t a3)
{
  id v7 = +[NSData dataWithBytes:*a1 length:a1[1] - *a1];
  uint64_t v34 = 0;
  id v8 = +[NSJSONSerialization JSONObjectWithData:v7 options:0 error:&v34];
  if (v34
    || (uint64_t v9 = v8,
        (+[CTCellularPlanDictionaryValidator validate:v8] & 1) == 0))
  {
    sub_100746E04();
    uint64_t v12 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
LABEL_7:
      uint64_t v10 = 4;
      goto LABEL_8;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    id v23 = "Decoding failure (initiateAuthenticationRsp";
    unint64_t v24 = v12;
    uint32_t v25 = 2;
LABEL_36:
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v23, (uint8_t *)&buf, v25);
    goto LABEL_7;
  }
  uint64_t v10 = sub_100747AB4(v9);
  if (v10)
  {
    sub_100746E04();
    id v11 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Header status failure (initiateAuthenticationRsp)", (uint8_t *)&buf, 2u);
    }
    goto LABEL_8;
  }
  id v14 = [v9 objectForKey:@"transactionId"];
  if ((+[CTCellularPlanStringValidator validate:v14] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v26 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v27 = [@"transactionId" UTF8String];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
    id v23 = "Missing Key: %s (initiateAuthenticationRsp)";
    goto LABEL_47;
  }
  id v15 = [v9 objectForKey:@"serverSigned1"];
  if ((+[CTCellularPlanStringValidator validate:v15] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v26 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v28 = [@"serverSigned1" UTF8String];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
    id v23 = "Missing Key: %s (initiateAuthenticationRsp)";
    goto LABEL_47;
  }
  id v16 = [v9 objectForKey:@"serverSignature1"];
  if ((+[CTCellularPlanStringValidator validate:v16] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v26 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v29 = [@"serverSignature1" UTF8String];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
    id v23 = "Missing Key: %s (initiateAuthenticationRsp)";
    goto LABEL_47;
  }
  id v17 = [v9 objectForKey:@"euiccCiPKIdToBeUsed"];
  if ((+[CTCellularPlanStringValidator validate:v17] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v26 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v30 = [@"euiccCiPKIdToBeUsed" UTF8String];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
    id v23 = "Missing Key: %s (initiateAuthenticationRsp)";
    goto LABEL_47;
  }
  id v18 = [v9 objectForKey:@"serverCertificate"];
  if ((+[CTCellularPlanStringValidator validate:v18] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v26 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v31 = [@"serverCertificate" UTF8String];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v31;
    id v23 = "Missing Key: %s (initiateAuthenticationRsp)";
LABEL_47:
    unint64_t v24 = v26;
    uint32_t v25 = 12;
    goto LABEL_36;
  }
  sub_100058DB0(&buf, (char *)[v14 UTF8String]);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(std::string *)a2 = buf;
  sub_100058DB0(__p, (char *)[v15 UTF8String]);
  ctu::base64::decode();
  uint64_t v19 = *(void **)(a3 + 24);
  if (v19)
  {
    *(void *)(a3 + 32) = v19;
    operator delete(v19);
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = 0;
  }
  *(std::string *)(a3 + 24) = buf;
  memset(&buf, 0, sizeof(buf));
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, (char *)[v16 UTF8String]);
  ctu::base64::decode();
  uint64_t v20 = *(void **)(a3 + 48);
  if (v20)
  {
    *(void *)(a3 + 56) = v20;
    operator delete(v20);
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)(a3 + 64) = 0;
  }
  *(std::string *)(a3 + 48) = buf;
  memset(&buf, 0, sizeof(buf));
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, (char *)[v17 UTF8String]);
  ctu::base64::decode();
  uint64_t v21 = *(void **)(a3 + 72);
  if (v21)
  {
    *(void *)(a3 + 80) = v21;
    operator delete(v21);
    *(void *)(a3 + 72) = 0;
    *(void *)(a3 + 80) = 0;
    *(void *)(a3 + 88) = 0;
  }
  *(std::string *)(a3 + 72) = buf;
  memset(&buf, 0, sizeof(buf));
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, (char *)[v18 UTF8String]);
  ctu::base64::decode();
  uint64_t v22 = *(void **)(a3 + 96);
  if (v22)
  {
    *(void *)(a3 + 104) = v22;
    operator delete(v22);
    *(void *)(a3 + 96) = 0;
    *(void *)(a3 + 104) = 0;
    *(void *)(a3 + 112) = 0;
  }
  *(std::string *)(a3 + 96) = buf;
  memset(&buf, 0, sizeof(buf));
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  sub_100748144(&buf, *(void *)(a3 + 24), *(void *)(a3 + 32));
  if (*(char *)(a3 + 23) < 0) {
    operator delete(*(void **)a3);
  }
  uint64_t v10 = 0;
  *(std::string *)a3 = buf;
LABEL_8:
  return v10;
}

void sub_100747A84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100747AB4(void *a1)
{
  id v1 = [a1 objectForKeyedSubscript:@"header"];
  if (!+[CTCellularPlanDictionaryValidator validate:v1])return 4; {
  id v2 = [v1 objectForKeyedSubscript:@"functionExecutionStatus"];
  }
  if (!+[CTCellularPlanDictionaryValidator validate:v2])return 4; {
  id v3 = [v2 objectForKeyedSubscript:@"status"];
  }
  if (!+[CTCellularPlanStringValidator validate:v3])return 4; {
  if (![v3 caseInsensitiveCompare:@"Executed-Success"])
  }
    return 0;
  if ([v3 caseInsensitiveCompare:@"Failed"])
  {
    if ([v3 caseInsensitiveCompare:@"Executed-WithWarning"])
    {
      if ([v3 caseInsensitiveCompare:@"Expired"])
      {
        sub_100746E04();
        BOOL v4 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          int v11 = 136315138;
          id v12 = [v3 UTF8String];
          _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Unknown header status (%s)", (uint8_t *)&v11, 0xCu);
        }
        return 7;
      }
      uint64_t v5 = 3;
    }
    else
    {
      uint64_t v5 = 1;
    }
  }
  else
  {
    uint64_t v5 = 2;
  }
  id v7 = [v2 objectForKeyedSubscript:@"statusCodeData"];
  if (+[CTCellularPlanDictionaryValidator validate:v7])
  {
    id v8 = [v7 objectForKeyedSubscript:@"subjectCode"];
    id v9 = [v7 objectForKeyedSubscript:@"reasonCode"];
    if (+[CTCellularPlanStringValidator validate:v8])
    {
      if (+[CTCellularPlanStringValidator validate:v9])
      {
        if ([v8 isEqualToString:@"8.1"])
        {
          if ([v9 isEqualToString:@"6.1"]) {
            return 8;
          }
        }
        else if ([v8 isEqualToString:@"8.1.1"])
        {
          if ([v9 isEqualToString:@"3.8"]) {
            return 9;
          }
        }
        else if ([v8 isEqualToString:@"8.1.2"])
        {
          if ([v9 isEqualToString:@"6.1"]) {
            return 10;
          }
          if ([v9 isEqualToString:@"6.3"]) {
            return 11;
          }
        }
        else if ([v8 isEqualToString:@"8.1.3"])
        {
          if ([v9 isEqualToString:@"6.1"]) {
            return 12;
          }
          if ([v9 isEqualToString:@"6.3"]) {
            return 13;
          }
        }
        else if ([v8 isEqualToString:@"8.2"])
        {
          if ([v9 isEqualToString:@"1.2"]) {
            return 14;
          }
          if ([v9 isEqualToString:@"3.7"]) {
            return 15;
          }
        }
        else if ([v8 isEqualToString:@"8.2.1"])
        {
          if ([v9 isEqualToString:@"1.2"]) {
            return 16;
          }
        }
        else if ([v8 isEqualToString:@"8.2.5"])
        {
          if ([v9 isEqualToString:@"4.3"]) {
            return 17;
          }
        }
        else if ([v8 isEqualToString:@"8.2.6"])
        {
          if (([v9 isEqualToString:@"3.8"] & 1) != 0
            || ([v9 isEqualToString:@"3.9"] & 1) != 0)
          {
            return 18;
          }
        }
        else if ([v8 isEqualToString:@"8.2.7"])
        {
          if ([v9 isEqualToString:@"3.8"]) {
            return 19;
          }
          if ([v9 isEqualToString:@"6.4"]) {
            return 20;
          }
          if ([v9 isEqualToString:@"8.2"]) {
            return 21;
          }
        }
        else if ([v8 isEqualToString:@"8.8"])
        {
          if ([v9 isEqualToString:@"4.2"]) {
            return 22;
          }
        }
        else if ([v8 isEqualToString:@"8.8.1"])
        {
          if ([v9 isEqualToString:@"3.8"]) {
            return 23;
          }
        }
        else if ([v8 isEqualToString:@"8.8.2"])
        {
          if ([v9 isEqualToString:@"3.1"]) {
            return 24;
          }
        }
        else if ([v8 isEqualToString:@"8.8.3"])
        {
          if ([v9 isEqualToString:@"3.1"]) {
            return 25;
          }
        }
        else if ([v8 isEqualToString:@"8.8.4"])
        {
          if ([v9 isEqualToString:@"3.7"]) {
            return 26;
          }
        }
        else if ([v8 isEqualToString:@"8.8.5"])
        {
          if ([v9 isEqualToString:@"3.9"]) {
            return 27;
          }
          if ([v9 isEqualToString:@"4.10"]) {
            return 28;
          }
          if ([v9 isEqualToString:@"6.4"]) {
            return 29;
          }
        }
        else if ([v8 isEqualToString:@"8.10.1"])
        {
          if ([v9 isEqualToString:@"3.9"]) {
            return 30;
          }
        }
        else if ([v8 isEqualToString:@"8.11.1"] {
               && ([v9 isEqualToString:@"3.9"] & 1) != 0)
        }
        {
          return 31;
        }
        sub_100746E04();
        uint64_t v10 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          int v11 = 136315394;
          id v12 = [v8 UTF8String];
          __int16 v13 = 2080;
          id v14 = [v9 UTF8String];
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Unknown subject code (%s), reason code (%s)", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }
  return v5;
}

void sub_100748144(std::string *a1, int a2, int a3)
{
  *(_DWORD *)&v12[8] = 0;
  *(void *)id v12 = (a3 - a2);
  int v4 = DERDecoderInitialize();
  if (v4)
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_DEFAULT))
    {
      if ((v4 + 1) > 8) {
        uint64_t v6 = "DERDecoderError(Unknown)";
      }
      else {
        uint64_t v6 = off_101A02BA0[v4 + 1];
      }
      *(_DWORD *)std::string buf = 136315138;
      id v14 = v6;
      id v9 = "#E Intialization failed (serverSigned): %s";
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v9, buf, 0xCu);
    }
  }
  else
  {
    int v7 = DERDecoderParseSequence();
    if (v7)
    {
      sub_100746E04();
      uint64_t v5 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_DEFAULT))
      {
        if ((v7 + 1) > 8) {
          id v8 = "DERDecoderError(Unknown)";
        }
        else {
          id v8 = off_101A02BA0[v7 + 1];
        }
        *(_DWORD *)std::string buf = 136315138;
        id v14 = v8;
        id v9 = "#E Parse sequence failed (ServerSigned): %s";
        goto LABEL_20;
      }
    }
    else
    {
      int DataWithTag = DERDecoderGetDataWithTag();
      if (!DataWithTag)
      {
        a1->__r_.__value_.__r.__words[0] = 0;
        a1->__r_.__value_.__l.__size_ = 0;
        a1->__r_.__value_.__r.__words[2] = 0;
        sub_10006E5EC(a1, *(std::string::value_type **)&v12[4], *(std::string::value_type **)&v12[4], 0);
        return;
      }
      sub_100746E04();
      uint64_t v5 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_DEFAULT))
      {
        if ((DataWithTag + 1) > 8) {
          int v11 = "DERDecoderError(Unknown)";
        }
        else {
          int v11 = off_101A02BA0[DataWithTag + 1];
        }
        *(_DWORD *)std::string buf = 136315138;
        id v14 = v11;
        id v9 = "#E Get data failure (serverAddress): %s";
        goto LABEL_20;
      }
    }
  }
  sub_100058DB0(a1, "");
}

void sub_10074838C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1007483B0(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v19 = 0;
  ctu::base64::encode();
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = (uint64_t *)*a1;
  }
  int v7 = +[NSString stringWithFormat:@"%s", v6];
  if (v19 >= 0) {
    id v8 = __p;
  }
  else {
    id v8 = (void **)__p[0];
  }
  id v9 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v7, @"transactionId", +[NSString stringWithFormat:@"%s", v8], @"authenticateServerResponse", 0);
  id v20 = 0;
  id v10 = sub_100747394((uint64_t)v9, &v20);
  if (v10)
  {
    sub_100746E04();
    int v11 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "JSON encoding failure (authenticateClientReq)", buf, 2u);
    }
  }
  else
  {
    id v12 = v20;
    __int16 v13 = (char *)[v20 bytes];
    id v14 = *(char **)(a3 + 8);
    id v15 = (char *)[v12 length];
    sub_10016A4CC(a3, v14, v13, &v15[(void)v13], (int64_t)v15);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  return v10 == 0;
}

void sub_100748540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100748568(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  v23[7] = 0;
  uint64_t v24 = 0;
  *(void *)&v23[5] = (a2 - a1);
  if (a2 == a1)
  {
    id v8 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "vinyl.helper");
    id v9 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext(v8);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_INFO)) {
      return 2;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v10 = 2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Empty Buffer (storeMetadataRequest)", buf, 2u);
  }
  else
  {
    int v4 = DERDecoderInitialize();
    if (v4)
    {
      uint64_t v5 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "vinyl.helper");
      uint64_t v6 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        if ((v4 + 1) > 8) {
          int v7 = "DERDecoderError(Unknown)";
        }
        else {
          int v7 = off_101A02BA0[v4 + 1];
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        id v14 = "Intialization failed (storeMetadataRequest): %s";
LABEL_24:
        id v18 = buf;
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, v14, v18, 0xCu);
        return 2;
      }
      return 2;
    }
    int v11 = DERDecoderParseSequence();
    if (v11)
    {
      id v12 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "vinyl.helper");
      uint64_t v6 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext(v12);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        if ((v11 + 1) > 8) {
          __int16 v13 = "DERDecoderError(Unknown)";
        }
        else {
          __int16 v13 = off_101A02BA0[v11 + 1];
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v13;
        id v14 = "Intialization failed (storeMetadataRequest): %s";
        goto LABEL_24;
      }
      return 2;
    }
    *(_OWORD *)std::string buf = 0uLL;
    *(void *)id v23 = 0;
    *(void *)&v23[2] = 0;
    v22[0] = 0;
    v22[1] = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    unsigned int v15 = DERDecoderParseSequence();
    if (v15 >= 2)
    {
      id v16 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v27, kCtLoggingSystemName, "vinyl.helper");
      uint64_t v6 = *(NSObject **)&v28[4];
      ctu::OsLogContext::~OsLogContext(v16);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        if (v15 + 1 > 8) {
          id v17 = "DERDecoderError(Unknown)";
        }
        else {
          id v17 = off_101A02AF8[v15 + 1];
        }
        *(_DWORD *)id v27 = 136315138;
        *(void *)id v28 = v17;
        id v14 = "Parse sequence failed (metadata): %s";
        id v18 = v27;
        goto LABEL_25;
      }
      return 2;
    }
    if (!sub_1007489B4()
      || !sub_100746CD4((uint64_t)v23, (std::string *)(a3 + 64))
      || !sub_100748B64((uint64_t)v22, (unsigned char *)(a3 + 88)))
    {
      return 2;
    }
    return 0;
  }
  return v10;
}

BOOL sub_1007489B4()
{
  int v5 = 0;
  int v4 = 0;
  if (DERDecoderGetDataAt())
  {
    sub_100746E04();
    int v0 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v3) = 0;
    id v2 = "Get data failure (Iccid)";
  }
  else
  {
    sub_100746E04();
    int v0 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v3) = 0;
    id v2 = "Invalid length (Iccid)";
  }
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, v2, (uint8_t *)&v3, 2u);
  return 0;
}

BOOL sub_100748B64(uint64_t a1, unsigned char *a2)
{
  if (!*(_DWORD *)(a1 + 8))
  {
    *a2 = 0;
    return 1;
  }
  int DataAt = DERDecoderGetDataAt();
  if (DataAt)
  {
    int v3 = DataAt;
    sub_100746E04();
    uint64_t v4 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if ((v3 + 1) > 8) {
      uint64_t v6 = "DERDecoderError(Unknown)";
    }
    else {
      uint64_t v6 = off_101A02BA0[v3 + 1];
    }
    *(_DWORD *)std::string buf = 136315138;
    id v12 = v6;
    id v8 = "Get data failure (Metadata Profile Class): %s";
    id v9 = v4;
    uint32_t v10 = 12;
  }
  else
  {
    sub_100746E04();
    uint64_t v7 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)std::string buf = 67109120;
    LODWORD(v12) = 0;
    id v8 = "Invalid length (Profile Class): %d";
    id v9 = v7;
    uint32_t v10 = 8;
  }
  _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v8, buf, v10);
  return 0;
}

uint64_t sub_100748D40(uint64_t a1, uint64_t a2)
{
  int v3 = DERDecoderParseSequence();
  if (v3)
  {
    sub_100746E04();
    uint64_t v4 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v3 + 1) > 8) {
        int v5 = "DERDecoderError(Unknown)";
      }
      else {
        int v5 = off_101A02BA0[v3 + 1];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v5;
      uint32_t v10 = "Parse failure (ProfileOwner): %s";
LABEL_28:
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, v10, (uint8_t *)&buf, 0xCu);
      return 0;
    }
    return 0;
  }
  int DataAt = DERDecoderGetDataAt();
  if (DataAt)
  {
    sub_100746E04();
    uint64_t v4 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((DataAt + 1) > 8) {
        int v11 = "DERDecoderError(Unknown)";
      }
      else {
        int v11 = off_101A02BA0[DataAt + 1];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v11;
      uint32_t v10 = "Get data failure (MCC/MNC): %s";
      goto LABEL_28;
    }
    return 0;
  }
  uint64_t v14 = 0;
  long long buf = 0uLL;
  sub_1001E7940(&buf, 0, 0, 0);
  if (*(char *)(a2 + 119) < 0)
  {
    **(unsigned char **)(a2 + 96) = 0;
    *(void *)(a2 + 104) = 0;
  }
  else
  {
    *(unsigned char *)(a2 + 96) = 0;
    *(unsigned char *)(a2 + 119) = 0;
  }
  if (*(char *)(a2 + 143) < 0)
  {
    **(unsigned char **)(a2 + 120) = 0;
    *(void *)(a2 + 128) = 0;
  }
  else
  {
    *(unsigned char *)(a2 + 120) = 0;
    *(unsigned char *)(a2 + 143) = 0;
  }
  if (subscriber::sDecodeMccMnc())
  {
    uint64_t v7 = 1;
  }
  else
  {
    sub_100746E04();
    id v9 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)id v12 = 136315138;
      *(void *)&void v12[4] = "kDERDecoderErrorNone";
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Decoding failure (MCC/MNC): %s", v12, 0xCu);
    }
    uint64_t v7 = 0;
  }
  if ((void)buf)
  {
    *((void *)&buf + 1) = buf;
    operator delete((void *)buf);
  }
  return v7;
}

void sub_10074917C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)(v1 - 64);
  if (v3)
  {
    *(void *)(v1 - 56) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1007491B4()
{
  int DataAt = DERDecoderGetDataAt();
  if (DataAt)
  {
    int v1 = DataAt;
    sub_100746E04();
    uint64_t v2 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (result)
    {
      if ((v1 + 1) > 8) {
        uint64_t v4 = "DERDecoderError(Unknown)";
      }
      else {
        uint64_t v4 = off_101A02BA0[v1 + 1];
      }
      *(_DWORD *)long long buf = 136315138;
      uint32_t v10 = v4;
      uint64_t v6 = "Get data failure (PPR IDs): %s";
      uint64_t v7 = v2;
      uint32_t v8 = 12;
      goto LABEL_10;
    }
  }
  else
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v10) = 0;
      uint64_t v6 = "Invalid length (PPR Id): %d";
      uint64_t v7 = v5;
      uint32_t v8 = 8;
LABEL_10:
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1007493A8(uint64_t *a1)
{
  memset(&v14[4], 0, 56);
  int v1 = *((_DWORD *)a1 + 2);
  uint64_t v2 = *a1;
  int v13 = 0;
  *(void *)uint64_t v14 = (v1 - v2);
  uint32_t v10 = 0;
  int v11 = 0;
  uint64_t v12 = 0;
  std::string __p = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  memset(&__str, 0, sizeof(__str));
  if (sub_1007497AC())
  {
    sub_100746E04();
    int v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Missing Notification Metadata (finalResult)", buf, 2u);
    }
    uint64_t v4 = 1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(__p);
  }
  if (v10)
  {
    int v11 = v10;
    operator delete(v10);
  }
  return v4;
}

void sub_100749758(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a22) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007497AC()
{
  int v0 = DERDecoderInitialize();
  if (v0)
  {
    int v1 = v0;
    sub_100746E04();
    uint64_t v2 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v1 + 1) > 8) {
        int v3 = "DERDecoderError(Unknown)";
      }
      else {
        int v3 = off_101A02BA0[v1 + 1];
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v14 = v3;
      int v11 = "Initialize failure (ProfileInstallationResult): %s";
LABEL_18:
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, v11, buf, 0xCu);
    }
  }
  else
  {
    int v4 = DERDecoderParseSequence();
    if (v4)
    {
      int v5 = v4;
      sub_100746E04();
      uint64_t v2 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v5 + 1) > 8) {
          uint64_t v6 = "DERDecoderError(Unknown)";
        }
        else {
          uint64_t v6 = off_101A02BA0[v5 + 1];
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v14 = v6;
        int v11 = "Parse failure (ProfileInstallationResult): %s";
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v7 = 1;
      int v8 = DERDecoderParseSequence();
      if (!v8) {
        return v7;
      }
      int v9 = v8;
      sub_100746E04();
      uint64_t v2 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v9 + 1) > 8) {
          uint32_t v10 = "DERDecoderError(Unknown)";
        }
        else {
          uint32_t v10 = off_101A02BA0[v9 + 1];
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v14 = v10;
        int v11 = "Parse failure (ProfileInstallationResult): %s";
        goto LABEL_18;
      }
    }
  }
  return 0;
}

BOOL sub_100749B8C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned char *a5, unsigned char *a6)
{
  *a6 = 0;
  int v10 = DERDecoderParseSequence();
  if (v10)
  {
    sub_100746E04();
    int v11 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if ((v10 + 1) > 8) {
      int v13 = "DERDecoderError(Unknown)";
    }
    else {
      int v13 = off_101A02BA0[v10 + 1];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v13;
    uint64_t v14 = "Parse failure (NotificationMetadata): %s";
    goto LABEL_16;
  }
  if (DERDecoderGetDataAt())
  {
    sub_100746E04();
    int v11 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "kDERDecoderErrorNone";
    uint64_t v14 = "Get data failure (SequenceNumber): %s";
    goto LABEL_16;
  }
  sub_10006E4A8(a2, 0, 0, 0);
  if (DERDecoderGetDataAt())
  {
    sub_100746E04();
    int v11 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "kDERDecoderErrorNone";
    uint64_t v14 = "Get data failure (Event): %s";
    goto LABEL_16;
  }
  sub_100746E04();
  unsigned int v15 = qword_101B0D628;
  if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid length (Event): %d", buf, 8u);
  }
  *a5 = 0;
  if (DERDecoderGetDataAt())
  {
    sub_100746E04();
    int v11 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "kDERDecoderErrorNone";
      uint64_t v14 = "Get data failure (URL): %s";
LABEL_16:
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
      return 0;
    }
  }
  else
  {
    sub_10003ECB8((std::string *)a3, 0, 0);
    unint64_t v16 = sub_100195000((uint64_t *)a3, "://", 0);
    if (v16 != -1)
    {
      sub_1000D95C8(buf, (void *)(v16 + 3), -(uint64_t)(v16 + 3));
      if (*(char *)(a3 + 23) < 0) {
        operator delete(*(void **)a3);
      }
      *(_OWORD *)a3 = *(_OWORD *)buf;
      *(void *)(a3 + 16) = v18;
    }
    std::locale::locale((std::locale *)buf);
    sub_100754E78((std::string *)a3, (const std::locale *)buf);
    std::locale::~locale((std::locale *)buf);
    if (*(char *)(a4 + 23) < 0)
    {
      **(unsigned char **)a4 = 0;
      *(void *)(a4 + 8) = 0;
    }
    else
    {
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 23) = 0;
    }
    return 1;
  }
  return result;
}

void sub_10074A048(_Unwind_Exception *a1)
{
  std::locale::~locale((std::locale *)(v1 - 96));
  _Unwind_Resume(a1);
}

uint64_t sub_10074A064(void *a1, uint64_t a2, unsigned __int8 *a3, void *a4)
{
  uint64_t v43 = 0;
  id v9 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:", +[NSData dataWithBytes:*a1 length:a1[1] - *a1], 0, &v43);
  if (v43
    || (int v10 = v9,
        (+[CTCellularPlanDictionaryValidator validate:v9] & 1) == 0))
  {
    sub_100746E04();
    uint64_t v13 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
LABEL_7:
      uint64_t v11 = 4;
      goto LABEL_8;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v24 = "Decode failure (authenticateClientRsp)";
    goto LABEL_19;
  }
  uint64_t v11 = sub_100747AB4(v10);
  if (v11)
  {
    sub_100746E04();
    uint64_t v12 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Header status (authenicateClientRsp)", buf, 2u);
    }
    goto LABEL_8;
  }
  id v15 = [v10 objectForKey:@"transactionId"];
  if ((+[CTCellularPlanStringValidator validate:v15] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v27 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v28 = [@"transactionId" UTF8String];
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v28;
    uint64_t v24 = "Missing Key: %s (authenticateClientRsp)";
    goto LABEL_31;
  }
  id v16 = [v10 objectForKey:@"smdpSigned2"];
  if ((+[CTCellularPlanStringValidator validate:v16] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v27 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v29 = [@"smdpSigned2" UTF8String];
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v29;
    uint64_t v24 = "Missing Key: %s (authenticateClientRsp)";
    goto LABEL_31;
  }
  id v17 = [v10 objectForKey:@"smdpSignature2"];
  if ((+[CTCellularPlanStringValidator validate:v17] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v27 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v30 = [@"smdpSignature2" UTF8String];
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v30;
    uint64_t v24 = "Missing Key: %s (authenticateClientRsp)";
    goto LABEL_31;
  }
  id v18 = [v10 objectForKey:@"smdpCertificate"];
  if ((+[CTCellularPlanStringValidator validate:v18] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v27 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v31 = [@"smdpCertificate" UTF8String];
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v31;
    uint64_t v24 = "Missing Key: %s (authenticateClientRsp)";
    goto LABEL_31;
  }
  id v19 = [v10 objectForKeyedSubscript:@"profileMetadata"];
  if ((+[CTCellularPlanStringValidator validate:v19] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v27 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v32 = [@"profileMetadata" UTF8String];
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v32;
    uint64_t v24 = "Missing Key: %s (authenticateClientRsp)";
LABEL_31:
    uint64_t v25 = v27;
    uint32_t v26 = 12;
    goto LABEL_20;
  }
  sub_100058DB0(__p, (char *)[v19 UTF8String]);
  ctu::base64::decode();
  uint64_t v20 = (void *)a4[39];
  if (v20)
  {
    a4[40] = v20;
    operator delete(v20);
    a4[39] = 0;
    a4[40] = 0;
    a4[41] = 0;
  }
  uint64_t v21 = *(void *)buf;
  a4[39] = *(void *)buf;
  uint64_t v22 = *(void *)&buf[8];
  *((_OWORD *)a4 + 20) = *(_OWORD *)&buf[8];
  memset(buf, 0, sizeof(buf));
  if (v42 < 0)
  {
    operator delete(__p[0]);
    uint64_t v21 = a4[39];
    uint64_t v23 = a4[40];
  }
  else
  {
    uint64_t v23 = v22;
  }
  int v33 = sub_100748568(v21, v23, (uint64_t)(a4 + 12));
  if (v33 == 1)
  {
    uint64_t v11 = 6;
    goto LABEL_8;
  }
  if (v33 == 2)
  {
    sub_100746E04();
    uint64_t v13 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v24 = "Decoding Failure (ProfileMetadata)";
LABEL_19:
    uint64_t v25 = v13;
    uint32_t v26 = 2;
LABEL_20:
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, v24, buf, v26);
    goto LABEL_7;
  }
  sub_100058DB0(buf, (char *)[v15 UTF8String]);
  BOOL v34 = sub_10001D294(a3, buf);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  if (v34)
  {
    sub_100058DB0(__p, (char *)[v16 UTF8String]);
    ctu::base64::decode();
    char v35 = (void *)*a4;
    if (*a4)
    {
      a4[1] = v35;
      operator delete(v35);
      *a4 = 0;
      a4[1] = 0;
      a4[2] = 0;
    }
    *(_OWORD *)a4 = *(_OWORD *)buf;
    a4[2] = *(void *)&buf[16];
    memset(buf, 0, sizeof(buf));
    if (v42 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, (char *)[v17 UTF8String]);
    ctu::base64::decode();
    unsigned int v36 = (void *)a4[3];
    if (v36)
    {
      a4[4] = v36;
      operator delete(v36);
      a4[3] = 0;
      a4[4] = 0;
      a4[5] = 0;
    }
    *(_OWORD *)(a4 + 3) = *(_OWORD *)buf;
    a4[5] = *(void *)&buf[16];
    memset(buf, 0, sizeof(buf));
    if (v42 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, (char *)[v18 UTF8String]);
    ctu::base64::decode();
    unint64_t v37 = (void *)a4[9];
    if (v37)
    {
      a4[10] = v37;
      operator delete(v37);
      a4[9] = 0;
      a4[10] = 0;
      a4[11] = 0;
    }
    *(_OWORD *)(a4 + 9) = *(_OWORD *)buf;
    a4[11] = *(void *)&buf[16];
    memset(buf, 0, sizeof(buf));
    if (v42 < 0) {
      operator delete(__p[0]);
    }
    if (!sub_100746E9C())
    {
LABEL_58:
      uint64_t v11 = 0;
      goto LABEL_8;
    }
    uint64_t v38 = *(unsigned __int8 *)(a2 + 23);
    if ((v38 & 0x80u) != 0) {
      uint64_t v38 = *(void *)(a2 + 8);
    }
    if (v38)
    {
      if ((sub_10074A770((uint64_t)a3, (const void **)a2, (uint64_t)a4) & 1) == 0)
      {
        uint64_t v11 = 19;
        goto LABEL_8;
      }
      goto LABEL_58;
    }
    sub_100746E04();
    uint64_t v40 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Missing Data (Confirmation Code)", buf, 2u);
    }
    uint64_t v11 = 21;
  }
  else
  {
    sub_100746E04();
    id v39 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "TransactionId mismatch (authenticateClientRsp)", buf, 2u);
    }
    uint64_t v11 = 5;
  }
LABEL_8:
  return v11;
}

void sub_10074A740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10074A770(uint64_t a1, const void **a2, uint64_t a3)
{
  std::string __p = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  ctu::parse_hex();
  md = 0;
  __dst = 0;
  uint64_t v18 = 0;
  sub_10008E4E8(&md, 0x20uLL);
  int v5 = *((char *)a2 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  if (v5 >= 0) {
    CC_LONG v7 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    CC_LONG v7 = *((_DWORD *)a2 + 2);
  }
  if (!CC_SHA256(v6, v7, md))
  {
    sub_100746E04();
    uint64_t v11 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    *(_WORD *)id v15 = 0;
LABEL_27:
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Encoding failure (Confirmation Code)", v15, 2u);
    goto LABEL_20;
  }
  sub_10005C748((uint64_t)&md, (char *)__dst, (char *)__p, v20, v20 - (unsigned char *)__p);
  int v8 = *(unsigned char **)(a3 + 48);
  id v9 = *(unsigned char **)(a3 + 56);
  uint64_t v10 = v9 - v8;
  if ((unint64_t)(v9 - v8) > 0x21)
  {
    if (v10 != 34)
    {
      *(void *)(a3 + 56) = v8 + 34;
      goto LABEL_16;
    }
  }
  else
  {
    sub_10011FDF0((unint64_t *)(a3 + 48), 34 - v10);
    int v8 = *(unsigned char **)(a3 + 48);
    id v9 = *(unsigned char **)(a3 + 56);
  }
  if (v9 == v8) {
LABEL_28:
  }
    sub_1002058CC();
LABEL_16:
  *int v8 = 4;
  uint64_t v12 = *(void *)(a3 + 48);
  if ((unint64_t)(*(void *)(a3 + 56) - v12) <= 1) {
    goto LABEL_28;
  }
  *(unsigned char *)(v12 + 1) = 32;
  if (CC_SHA256(md, (int)__dst - (int)md, (unsigned __int8 *)(*(void *)(a3 + 48) + 2)))
  {
    uint64_t v13 = 1;
    goto LABEL_21;
  }
  sub_100746E04();
  uint64_t v11 = qword_101B0D628;
  if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v15 = 0;
    goto LABEL_27;
  }
LABEL_20:
  uint64_t v13 = 0;
LABEL_21:
  if (md)
  {
    __dst = md;
    operator delete(md);
  }
  if (__p)
  {
    uint64_t v20 = (char *)__p;
    operator delete(__p);
  }
  return v13;
}

void sub_10074A93C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10074A97C(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v19 = 0;
  ctu::base64::encode();
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = (uint64_t *)*a1;
  }
  CC_LONG v7 = +[NSString stringWithFormat:@"%s", v6];
  if (v19 >= 0) {
    int v8 = __p;
  }
  else {
    int v8 = (void **)__p[0];
  }
  id v9 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v7, @"transactionId", +[NSString stringWithFormat:@"%s", v8], @"prepareDownloadResponse", 0);
  id v20 = 0;
  id v10 = sub_100747394((uint64_t)v9, &v20);
  if (v10)
  {
    sub_100746E04();
    uint64_t v11 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "JSON encoding failure (getBoundProfilePackageReq)", buf, 2u);
    }
  }
  else
  {
    id v12 = v20;
    uint64_t v13 = (char *)[v20 bytes];
    uint64_t v14 = *(char **)(a3 + 8);
    id v15 = (char *)[v12 length];
    sub_10016A4CC(a3, v14, v13, &v15[(void)v13], (int64_t)v15);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  return v10 == 0;
}

void sub_10074AB0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10074AB34(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v26 = 0;
  id v7 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:", +[NSData dataWithBytes:*a1 length:a1[1] - *a1], 0, &v26);
  if (v26
    || (int v8 = v7,
        (+[CTCellularPlanDictionaryValidator validate:v7] & 1) == 0))
  {
    sub_100746E04();
    uint64_t v11 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
LABEL_7:
      uint64_t v9 = 4;
      goto LABEL_8;
    }
    *(_WORD *)long long buf = 0;
    id v17 = "Decode failure (getBoundProfilePackageRsp)";
    uint64_t v18 = v11;
    uint32_t v19 = 2;
LABEL_20:
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
    goto LABEL_7;
  }
  uint64_t v9 = sub_100747AB4(v8);
  if (v9)
  {
    sub_100746E04();
    id v10 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Header status error (getBoundProfilePackageRsp)", buf, 2u);
    }
    goto LABEL_8;
  }
  id v13 = [v8 objectForKey:@"transactionId"];
  if ((+[CTCellularPlanStringValidator validate:v13] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v20 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v21 = [@"transactionId" UTF8String];
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v21;
    id v17 = "Missing Key: %s (getBoundProfilePackageRsp)";
    goto LABEL_25;
  }
  id v14 = [v8 objectForKey:@"boundProfilePackage"];
  if ((+[CTCellularPlanStringValidator validate:v14] & 1) == 0)
  {
    sub_100746E04();
    uint64_t v20 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v22 = [@"boundProfilePackage" UTF8String];
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v22;
    id v17 = "Missing Key: %s (getBoundProfilePackageRsp)";
LABEL_25:
    uint64_t v18 = v20;
    uint32_t v19 = 12;
    goto LABEL_20;
  }
  sub_100058DB0(buf, (char *)[v13 UTF8String]);
  BOOL v15 = sub_10001D294(a2, buf);
  if (SHIBYTE(v28) < 0) {
    operator delete(*(void **)buf);
  }
  if (v15)
  {
    sub_100058DB0(&__p, (char *)[v14 UTF8String]);
    ctu::base64::decode();
    id v16 = *(void **)a3;
    if (*(void *)a3)
    {
      *(void *)(a3 + 8) = v16;
      operator delete(v16);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
    }
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(void *)(a3 + 16) = v28;
    uint64_t v28 = 0;
    memset(buf, 0, sizeof(buf));
    if (v25 < 0) {
      operator delete(__p);
    }
    uint64_t v9 = 0;
  }
  else
  {
    sub_100746E04();
    uint64_t v23 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Transaction id mismatch (getBoundProfilePackageRsp)", buf, 2u);
    }
    uint64_t v9 = 5;
  }
LABEL_8:
  return v9;
}

void sub_10074AE94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10074AEB8(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v19 = 0;
  ctu::base64::encode();
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = (uint64_t *)*a1;
  }
  id v7 = +[NSString stringWithFormat:@"%s", v6];
  if (v19 >= 0) {
    int v8 = __p;
  }
  else {
    int v8 = (void **)__p[0];
  }
  uint64_t v9 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v7, @"transactionId", +[NSString stringWithFormat:@"%s", v8], @"cancelSessionResponse", 0);
  id v20 = 0;
  id v10 = sub_100747394((uint64_t)v9, &v20);
  if (v10)
  {
    sub_100746E04();
    uint64_t v11 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "JSON encoding failure (encodeInitiateAuthenticationData)", buf, 2u);
    }
  }
  else
  {
    id v12 = v20;
    id v13 = (char *)[v20 bytes];
    id v14 = *(char **)(a3 + 8);
    BOOL v15 = (char *)[v12 length];
    sub_10016A4CC(a3, v14, v13, &v15[(void)v13], (int64_t)v15);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  return v10 == 0;
}

void sub_10074B048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10074B070(void *a1)
{
  uint64_t v10 = 0;
  id v3 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:", +[NSData dataWithBytes:*a1 length:a1[1] - *a1], 0, &v10);
  if (v10
    || (int v4 = v3,
        (+[CTCellularPlanDictionaryValidator validate:v3] & 1) == 0))
  {
    sub_100746E04();
    int v8 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Decode failure (cancelSessionServerRsp)", buf, 2u);
    }
    uint64_t v5 = 4;
  }
  else
  {
    uint64_t v5 = sub_100747AB4(v4);
    if (v5)
    {
      sub_100746E04();
      uint64_t v6 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        id v7 = sub_100746C54(v5);
        *(_DWORD *)long long buf = 136315138;
        id v12 = v7;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "%s (cancelSessionrsp)", buf, 0xCu);
      }
    }
  }
  return v5;
}

BOOL sub_10074B1E8(uint64_t a1, uint64_t a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v14 = 0;
  ctu::base64::encode();
  int v4 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", +[NSString stringWithFormat:@"%s", __p], @"pendingNotification", 0);
  id v15 = 0;
  id v5 = sub_100747394((uint64_t)v4, &v15);
  if (v5)
  {
    sub_100746E04();
    uint64_t v6 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "JSON encoding failure (handleNotificationServerReq)", buf, 2u);
    }
  }
  else
  {
    id v7 = v15;
    int v8 = (char *)[v15 bytes];
    uint64_t v9 = *(char **)(a2 + 8);
    uint64_t v10 = (char *)[v7 length];
    sub_10016A4CC(a2, v9, v8, &v10[(void)v8], (int64_t)v10);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  return v5 == 0;
}

void sub_10074B340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10074B368(void *a1, int a2)
{
  if (a2)
  {
    uint64_t __src = 0x709F5A095C0B2DBFLL;
    int v6 = -1214934640;
    __int16 v7 = -7783;
    uint64_t v2 = (char *)&v8;
    unint64_t v3 = 14;
  }
  else
  {
    uint64_t __src = 0x709F5A085C0A2DBFLL;
    int v6 = -1214934640;
    LOBYTE(v7) = -103;
    uint64_t v2 = (char *)&v7 + 1;
    unint64_t v3 = 13;
  }
  return sub_10006E4A8(a1, (char *)&__src, v2, v3);
}

uint64_t sub_10074B41C(uint64_t *a1)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  unsigned int v19 = v2 - *a1;
  uint64_t v18 = 0;
  if (v2 == v1)
  {
    sub_100746E04();
    int v4 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      __int16 v7 = (const char *)(a1[1] - *a1);
      *(_DWORD *)long long buf = 134217984;
      uint64_t v26 = v7;
      __int16 v8 = "Invalid parameter size: %lu";
LABEL_33:
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, v8, buf, 0xCu);
    }
  }
  else
  {
    int v3 = DERDecoderInitialize();
    if (v3)
    {
      sub_100746E04();
      int v4 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v3 + 1) > 8) {
          id v5 = "DERDecoderError(Unknown)";
        }
        else {
          id v5 = off_101A02BA0[v3 + 1];
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v26 = v5;
        __int16 v8 = "Initialize failure (ProfileInfoListRsp): %s";
        goto LABEL_33;
      }
    }
    else
    {
      int v9 = DERDecoderParseSequence();
      if (v9)
      {
        sub_100746E04();
        int v4 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v9 + 1) > 8) {
            uint64_t v10 = "DERDecoderError(Unknown)";
          }
          else {
            uint64_t v10 = off_101A02BA0[v9 + 1];
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v26 = v10;
          __int16 v8 = "Parse failure (ProfileInfoListRsp): %s";
          goto LABEL_33;
        }
      }
      else
      {
        int DataAt = DERDecoderGetDataAt();
        if (!DataAt)
        {
          if (v19 >= 3)
          {
            int v14 = DERDecoderInitialize();
            if (v14)
            {
              sub_100746E04();
              int v4 = qword_101B0D628;
              if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
              {
                if ((v14 + 1) > 8) {
                  id v15 = "DERDecoderError(Unknown)";
                }
                else {
                  id v15 = off_101A02BA0[v14 + 1];
                }
                *(_DWORD *)long long buf = 136315138;
                uint64_t v26 = v15;
                __int16 v8 = "Initialize failure (ProfileInfoListItems): %s";
                goto LABEL_33;
              }
              return 1;
            }
            int Count = DERDecoderGetCount();
            if (Count)
            {
              sub_100746E04();
              int v4 = qword_101B0D628;
              if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
              {
                if ((Count + 1) > 8) {
                  id v17 = "DERDecoderError(Unknown)";
                }
                else {
                  id v17 = off_101A02BA0[Count + 1];
                }
                *(_DWORD *)long long buf = 136315138;
                uint64_t v26 = v17;
                __int16 v8 = "Get count failure (ProfileInfoListItems): %s";
                goto LABEL_33;
              }
              return 1;
            }
          }
          return 0;
        }
        sub_100746E04();
        int v4 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((DataAt + 1) > 8) {
            id v12 = "DERDecoderError(Unknown)";
          }
          else {
            id v12 = off_101A02BA0[DataAt + 1];
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v26 = v12;
          __int16 v8 = "Get data failure (ProfileInfoList): %s";
          goto LABEL_33;
        }
      }
    }
  }
  return 1;
}

uint64_t sub_10074C04C(uint64_t *a1)
{
  unint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v3 = v4;
  unint64_t v5 = *(void *)(result - 8);
  if (v5 >= v4)
  {
    unint64_t v7 = 0x84BDA12F684BDA13 * ((uint64_t)(v5 - *a1) >> 3);
    unint64_t v8 = v7 + 1;
    if (v7 + 1 > 0x12F684BDA12F684) {
      sub_10006A748();
    }
    unint64_t v9 = 0x84BDA12F684BDA13 * ((uint64_t)(v3 - *a1) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x97B425ED097B42) {
      unint64_t v10 = 0x12F684BDA12F684;
    }
    else {
      unint64_t v10 = v8;
    }
    v13[4] = result;
    if (v10) {
      uint64_t v11 = (char *)sub_1000C5FD0(result, v10);
    }
    else {
      uint64_t v11 = 0;
    }
    id v12 = &v11[216 * v7];
    v13[0] = v11;
    v13[1] = v12;
    uint64_t v13[3] = &v11[216 * v10];
    *(_OWORD *)id v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *((_OWORD *)v12 + 3) = 0u;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 5) = 0u;
    *((_OWORD *)v12 + 6) = 0u;
    *((_OWORD *)v12 + 7) = 0u;
    *((_OWORD *)v12 + 8) = 0u;
    *((_OWORD *)v12 + 9) = 0u;
    *((_OWORD *)v12 + 10) = 0u;
    *((_OWORD *)v12 + 11) = 0u;
    *((_OWORD *)v12 + 12) = 0u;
    *((void *)v12 + 26) = 0;
    void v13[2] = v12 + 216;
    sub_1003F229C(a1, v13);
    uint64_t v6 = a1[1];
    uint64_t result = sub_1003F2414((uint64_t)v13);
  }
  else
  {
    *(void *)(v5 + 208) = 0;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)unint64_t v5 = 0u;
    uint64_t v6 = v5 + 216;
    a1[1] = v5 + 216;
  }
  a1[1] = v6;
  return result;
}

void sub_10074C198(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003F2414((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_10074C1AC(uint64_t a1, std::string *a2)
{
  int v3 = DERDecoderParseSequence();
  if (v3)
  {
    int v4 = v3;
    sub_100746E04();
    unint64_t v5 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if ((v4 + 1) > 8) {
      unint64_t v7 = "DERDecoderError(Unknown)";
    }
    else {
      unint64_t v7 = off_101A02BA0[v4 + 1];
    }
    *(_DWORD *)long long buf = 136315138;
    id v13 = v7;
    uint64_t v11 = "Parse failure (PropDataImei): %s";
  }
  else
  {
    int DataAt = DERDecoderGetDataAt();
    if (!DataAt)
    {
      sub_10006E5EC(a2, 0, 0, 0);
      return 1;
    }
    int v9 = DataAt;
    sub_100746E04();
    unint64_t v5 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if ((v9 + 1) > 8) {
      unint64_t v10 = "DERDecoderError(Unknown)";
    }
    else {
      unint64_t v10 = off_101A02BA0[v9 + 1];
    }
    *(_DWORD *)long long buf = 136315138;
    id v13 = v10;
    uint64_t v11 = "Get data failure (IMEI): %s";
  }
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v11, buf, 0xCu);
  return 0;
}

uint64_t sub_10074C354(void *a1)
{
  if (a1[1] == *a1)
  {
    sub_100746E04();
    uint64_t v2 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = a1[1] - *a1;
      int buf = 134217984;
      *(void *)buf_4 = v5;
      uint64_t v6 = "Invalid parameter size: %lu";
LABEL_17:
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&buf, 0xCu);
    }
  }
  else
  {
    int v1 = DERDecoderInitialize();
    if (v1)
    {
      sub_100746E04();
      uint64_t v2 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v1 + 1) > 8) {
          int v3 = "DERDecoderError(Unknown)";
        }
        else {
          int v3 = off_101A02BA0[v1 + 1];
        }
        int buf = 136315138;
        *(void *)buf_4 = v3;
        uint64_t v6 = "Initialize failure (GetRatResponse): %s";
        goto LABEL_17;
      }
    }
    else
    {
      int v7 = DERDecoderParseSequence();
      if (!v7) {
        return 0;
      }
      sub_100746E04();
      uint64_t v2 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v7 + 1) > 8) {
          unint64_t v8 = "DERDecoderError(Unknown)";
        }
        else {
          unint64_t v8 = off_101A02BA0[v7 + 1];
        }
        int buf = 136315138;
        *(void *)buf_4 = v8;
        uint64_t v6 = "Parse failure (GetRatResponse): %s";
        goto LABEL_17;
      }
    }
  }
  return 1;
}

void sub_10074D0EC(void ***a1)
{
  uint64_t v2 = *a1;
  int v3 = a1[1];
  while (v3 != v2)
  {
    v3 -= 4;
    int v4 = v3;
    sub_10016A9A4(&v4);
  }
  a1[1] = v2;
}

int64x2_t *sub_10074D140(int64x2_t *result)
{
  int v1 = result;
  unint64_t v2 = result[1].u64[0];
  unint64_t v3 = result->u64[1];
  if (v3 >= v2)
  {
    uint64_t v5 = result->i64[0];
    uint64_t v6 = (uint64_t)(v3 - result->i64[0]) >> 5;
    unint64_t v7 = v6 + 1;
    if ((unint64_t)(v6 + 1) >> 59) {
      sub_10006A748();
    }
    if ((uint64_t)(v2 - v5) >> 4 > v7) {
      unint64_t v7 = (uint64_t)(v2 - v5) >> 4;
    }
    if (v2 - v5 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v8 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v8 = v7;
    }
    uint64_t v18 = result + 1;
    if (v8)
    {
      if (v8 >> 59) {
        sub_10006A7CC();
      }
      int v9 = (char *)operator new(32 * v8);
    }
    else
    {
      int v9 = 0;
    }
    unint64_t v10 = &v9[32 * v6];
    uint64_t v11 = &v9[32 * v8];
    *(_OWORD *)unint64_t v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    unint64_t v4 = (unint64_t)(v10 + 32);
    v16.i64[1] = (uint64_t)(v10 + 32);
    id v17 = v11;
    if (v3 == v5)
    {
      int64x2_t v14 = vdupq_n_s64(v3);
    }
    else
    {
      do
      {
        id v12 = v10;
        *((void *)v10 - 3) = 0;
        *((void *)v10 - 2) = 0;
        long long v13 = *(_OWORD *)(v3 - 32);
        v3 -= 32;
        *((_OWORD *)v10 - 2) = v13;
        v10 -= 32;
        *((void *)v12 - 2) = *(void *)(v3 + 16);
        *(void *)unint64_t v3 = 0;
        *(void *)(v3 + 8) = 0;
        *(void *)(v3 + 16) = 0;
        LOWORD(v12) = *(_WORD *)(v3 + 24);
        v10[26] = *(unsigned char *)(v3 + 26);
        *((_WORD *)v10 + 12) = (_WORD)v12;
      }
      while (v3 != v5);
      int64x2_t v14 = *v1;
      unint64_t v2 = v1[1].u64[0];
      unint64_t v4 = v16.u64[1];
      uint64_t v11 = v17;
    }
    v1->i64[0] = (uint64_t)v10;
    v1->i64[1] = v4;
    int64x2_t v16 = v14;
    v1[1].i64[0] = (uint64_t)v11;
    id v17 = (char *)v2;
    uint64_t v15 = v14.i64[0];
    BOOL result = (int64x2_t *)sub_100754EE0((uint64_t)&v15);
  }
  else
  {
    *(_OWORD *)unint64_t v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    unint64_t v4 = v3 + 32;
  }
  v1->i64[1] = v4;
  return result;
}

uint64_t sub_10074D288(long long ***a1, uint64_t a2, _WORD *a3)
{
  int v3 = *(unsigned __int8 *)(a2 + 90);
  int v4 = *(unsigned __int8 *)(a2 + 91);
  if (v4 | v3)
  {
    uint64_t v5 = *a1;
    id v60 = a1[1];
    if (v60 != *a1)
    {
      BOOL v62 = v3 == 0;
      BOOL v7 = v4 == 0;
      unint64_t v8 = (unsigned __int8 **)(a2 + 96);
      uint64_t v61 = (unsigned __int8 **)(a2 + 120);
      id v58 = (unsigned __int8 **)(a2 + 144);
      id v57 = (unsigned __int8 **)(a2 + 168);
      while (1)
      {
        BOOL v63 = v7;
        unint64_t v10 = *v5;
        int v9 = v5[1];
        if (*v5 == v9) {
          goto LABEL_115;
        }
        do
        {
          if (*((char *)v10 + 23) < 0)
          {
            sub_10004FC84(__s1, *(void **)v10, *((void *)v10 + 1));
          }
          else
          {
            long long v11 = *v10;
            uint64_t v65 = *((void *)v10 + 2);
            *(_OWORD *)__s1 = v11;
          }
          if (*((char *)v10 + 47) < 0)
          {
            sub_10004FC84(&v66, *((void **)v10 + 3), *((void *)v10 + 4));
          }
          else
          {
            long long v12 = *(long long *)((char *)v10 + 24);
            uint64_t v67 = *((void *)v10 + 5);
            long long v66 = v12;
          }
          if (*((char *)v10 + 71) < 0)
          {
            sub_10004FC84(&v68, *((void **)v10 + 6), *((void *)v10 + 7));
          }
          else
          {
            long long v13 = v10[3];
            uint64_t v69 = *((void *)v10 + 8);
            long long v68 = v13;
          }
          if (*((char *)v10 + 95) < 0)
          {
            sub_10004FC84(&__p, *((void **)v10 + 9), *((void *)v10 + 10));
          }
          else
          {
            long long v14 = *(long long *)((char *)v10 + 72);
            uint64_t v71 = *((void *)v10 + 11);
            long long __p = v14;
          }
          uint64_t v15 = HIBYTE(v65);
          if (v65 >= 0) {
            int64x2_t v16 = (void *)HIBYTE(v65);
          }
          else {
            int64x2_t v16 = __s1[1];
          }
          if (v16 == (void *)3)
          {
            id v17 = __s1;
            if (v65 < 0) {
              id v17 = (void **)__s1[0];
            }
            int v18 = *(unsigned __int16 *)v17;
            int v19 = *((unsigned __int8 *)v17 + 2);
            if (v18 == 15934 && v19 == 62)
            {
              uint64_t v21 = HIBYTE(v67);
              if (v67 < 0) {
                uint64_t v21 = *((void *)&v66 + 1);
              }
              if (v21 == 3)
              {
                uint64_t v22 = v67 >= 0 ? (unsigned __int16 *)&v66 : (unsigned __int16 *)v66;
                int v23 = *v22;
                int v24 = *((unsigned __int8 *)v22 + 2);
                if (v23 == 15934 && v24 == 62)
                {
LABEL_113:
                  BOOL v54 = 1;
                  goto LABEL_102;
                }
              }
            }
          }
          uint64_t v26 = (void *)*(unsigned __int8 *)(a2 + 119);
          int v27 = (char)v26;
          if ((char)v26 < 0) {
            uint64_t v26 = *(void **)(a2 + 104);
          }
          if (v16 != v26) {
            goto LABEL_101;
          }
          if (v27 >= 0) {
            uint64_t v28 = (unsigned __int8 *)v8;
          }
          else {
            uint64_t v28 = *v8;
          }
          if (v65 < 0)
          {
            if (memcmp(__s1[0], v28, (size_t)__s1[1])) {
              goto LABEL_101;
            }
          }
          else if (HIBYTE(v65))
          {
            id v29 = __s1;
            while (*(unsigned __int8 *)v29 == *v28)
            {
              id v29 = (void **)((char *)v29 + 1);
              ++v28;
              if (!--v15) {
                goto LABEL_51;
              }
            }
            goto LABEL_101;
          }
LABEL_51:
          uint64_t v30 = HIBYTE(v67);
          if (v67 >= 0) {
            uint64_t v31 = HIBYTE(v67);
          }
          else {
            uint64_t v31 = *((void *)&v66 + 1);
          }
          uint64_t v32 = *(unsigned __int8 *)(a2 + 143);
          int v33 = (char)v32;
          if ((v32 & 0x80u) != 0) {
            uint64_t v32 = *(void *)(a2 + 128);
          }
          if (v31 != v32) {
            goto LABEL_101;
          }
          if (v33 >= 0) {
            BOOL v34 = (unsigned __int8 *)v61;
          }
          else {
            BOOL v34 = *v61;
          }
          if (v67 < 0)
          {
            if (memcmp((const void *)v66, v34, *((size_t *)&v66 + 1))) {
              goto LABEL_101;
            }
          }
          else if (HIBYTE(v67))
          {
            char v35 = &v66;
            while (*(unsigned __int8 *)v35 == *v34)
            {
              char v35 = (long long *)((char *)v35 + 1);
              ++v34;
              if (!--v30) {
                goto LABEL_67;
              }
            }
            goto LABEL_101;
          }
LABEL_67:
          uint64_t v36 = HIBYTE(v69);
          if (v69 >= 0) {
            uint64_t v37 = HIBYTE(v69);
          }
          else {
            uint64_t v37 = *((void *)&v68 + 1);
          }
          uint64_t v38 = *(unsigned __int8 *)(a2 + 167);
          int v39 = (char)v38;
          if ((v38 & 0x80u) != 0) {
            uint64_t v38 = *(void *)(a2 + 152);
          }
          if (v37 != v38) {
            goto LABEL_101;
          }
          if (v39 >= 0) {
            uint64_t v40 = (unsigned __int8 *)v58;
          }
          else {
            uint64_t v40 = *v58;
          }
          if (v69 < 0)
          {
            if (memcmp((const void *)v68, v40, *((size_t *)&v68 + 1))) {
              goto LABEL_101;
            }
          }
          else if (HIBYTE(v69))
          {
            char v41 = &v68;
            while (*(unsigned __int8 *)v41 == *v40)
            {
              char v41 = (long long *)((char *)v41 + 1);
              ++v40;
              if (!--v36) {
                goto LABEL_83;
              }
            }
LABEL_101:
            BOOL v54 = 0;
            goto LABEL_102;
          }
LABEL_83:
          if (v71 >= 0) {
            uint64_t v42 = HIBYTE(v71);
          }
          else {
            uint64_t v42 = *((void *)&__p + 1);
          }
          uint64_t v43 = *(unsigned __int8 *)(a2 + 191);
          int v44 = (char)v43;
          if ((v43 & 0x80u) != 0) {
            uint64_t v43 = *(void *)(a2 + 176);
          }
          if (v42 != v43) {
            goto LABEL_101;
          }
          if (v44 >= 0) {
            uint64_t v45 = (unsigned __int8 *)v57;
          }
          else {
            uint64_t v45 = *v57;
          }
          if (v71 < 0)
          {
            BOOL v54 = memcmp((const void *)__p, v45, *((size_t *)&__p + 1)) == 0;
          }
          else
          {
            if (!HIBYTE(v71)) {
              goto LABEL_113;
            }
            uint64_t v46 = HIBYTE(v71) - 1;
            p_p = &__p;
            do
            {
              int v49 = *(unsigned __int8 *)p_p;
              p_p = (long long *)((char *)p_p + 1);
              int v48 = v49;
              int v51 = *v45++;
              int v50 = v51;
              BOOL v53 = v46-- != 0;
              BOOL v54 = v48 == v50;
            }
            while (v48 == v50 && v53);
          }
LABEL_102:
          if (SHIBYTE(v71) < 0) {
            operator delete((void *)__p);
          }
          if (SHIBYTE(v69) < 0) {
            operator delete((void *)v68);
          }
          if (SHIBYTE(v67) < 0) {
            operator delete((void *)v66);
          }
          if (SHIBYTE(v65) < 0) {
            operator delete(__s1[0]);
          }
          if (v54) {
            goto LABEL_115;
          }
          v10 += 6;
        }
        while (v10 != v9);
        unint64_t v10 = v9;
LABEL_115:
        BOOL v7 = v63;
        if (v10 != v5[1])
        {
          if (v62)
          {
            BOOL v62 = 1;
          }
          else
          {
            BOOL v62 = *((unsigned __int8 *)v5 + 26) == *(unsigned __int8 *)(a2 + 90);
            if (!(*(unsigned __int8 *)a3 | *((unsigned __int8 *)v5 + 24))) {
              *a3 = 1;
            }
          }
          if (v63)
          {
            BOOL v7 = 1;
          }
          else
          {
            BOOL v7 = *((unsigned __int8 *)v5 + 25) == *(unsigned __int8 *)(a2 + 91);
            if (!(*(unsigned __int8 *)a3 | *((unsigned __int8 *)v5 + 24))) {
              *a3 = 1;
            }
          }
        }
        if (v7 && v62)
        {
          LOBYTE(v7) = 1;
          BOOL v62 = 1;
          goto LABEL_131;
        }
        v5 += 4;
        if (v5 == v60)
        {
LABEL_131:
          char v55 = v7 && v62;
          return v55 & 1;
        }
      }
    }
    char v55 = 0;
  }
  else
  {
    char v55 = 1;
  }
  return v55 & 1;
}

void sub_10074D794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10074D7E0(uint64_t *a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  int v48 = 0;
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unsigned int v47 = v5 - *a1;
  if (v5 == v4)
  {
    sub_100746E04();
    uint64_t v8 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      std::string::size_type v11 = a1[1] - *a1;
      LODWORD(v53.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = v11;
      long long v12 = "Invalid parameter size: %lu";
LABEL_62:
      int v33 = v8;
      uint32_t v34 = 12;
      goto LABEL_63;
    }
  }
  else
  {
    int v7 = DERDecoderInitialize();
    if (v7)
    {
      sub_100746E04();
      uint64_t v8 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v7 + 1) > 8) {
          int v9 = "DERDecoderError(Unknown)";
        }
        else {
          int v9 = off_101A02BA0[v7 + 1];
        }
        LODWORD(v53.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
        long long v12 = "Initialize failure (EuiccInfo1Rsp): %s";
        goto LABEL_62;
      }
    }
    else
    {
      int v13 = DERDecoderParseSequence();
      if (v13)
      {
        sub_100746E04();
        uint64_t v8 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v13 + 1) > 8) {
            long long v14 = "DERDecoderError(Unknown)";
          }
          else {
            long long v14 = off_101A02BA0[v13 + 1];
          }
          LODWORD(v53.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
          long long v12 = "Parse failure (EuiccInfo1Rsp): %s";
          goto LABEL_62;
        }
      }
      else
      {
        int DataWithTag = DERDecoderGetDataWithTag();
        if (!DataWithTag)
        {
          if (v47 == 3)
          {
            ctu::hex((uint64_t *)&v44, (ctu *)*v48, v15);
            sub_10055B020(".", &v44, &v45);
            ctu::hex((uint64_t *)v42, (ctu *)v48[1], v18);
            if ((v43 & 0x80u) == 0) {
              int v19 = v42;
            }
            else {
              int v19 = (void **)v42[0];
            }
            if ((v43 & 0x80u) == 0) {
              std::string::size_type v20 = v43;
            }
            else {
              std::string::size_type v20 = (std::string::size_type)v42[1];
            }
            uint64_t v21 = std::string::append(&v45, (const std::string::value_type *)v19, v20);
            long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
            v46.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v22;
            v21->__r_.__value_.__l.__size_ = 0;
            v21->__r_.__value_.__r.__words[2] = 0;
            v21->__r_.__value_.__r.__words[0] = 0;
            sub_10055B020(".", &v46, &v53);
            ctu::hex((uint64_t *)__p, (ctu *)v48[2], v23);
            if ((v41 & 0x80u) == 0) {
              int v24 = __p;
            }
            else {
              int v24 = (void **)__p[0];
            }
            if ((v41 & 0x80u) == 0) {
              std::string::size_type v25 = v41;
            }
            else {
              std::string::size_type v25 = (std::string::size_type)__p[1];
            }
            uint64_t v26 = std::string::append(&v53, (const std::string::value_type *)v24, v25);
            std::string::size_type v27 = v26->__r_.__value_.__r.__words[0];
            v54[0] = v26->__r_.__value_.__l.__size_;
            *(void *)((char *)v54 + 7) = *(std::string::size_type *)((char *)&v26->__r_.__value_.__r.__words[1] + 7);
            char v28 = HIBYTE(v26->__r_.__value_.__r.__words[2]);
            v26->__r_.__value_.__l.__size_ = 0;
            v26->__r_.__value_.__r.__words[2] = 0;
            v26->__r_.__value_.__r.__words[0] = 0;
            if (*(char *)(a2 + 23) < 0) {
              operator delete(*(void **)a2);
            }
            uint64_t v29 = v54[0];
            *(void *)a2 = v27;
            *(void *)(a2 + 8) = v29;
            *(void *)(a2 + 15) = *(void *)((char *)v54 + 7);
            *(unsigned char *)(a2 + 23) = v28;
            if ((char)v41 < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v53.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v46.__r_.__value_.__l.__data_);
            }
            if ((char)v43 < 0) {
              operator delete(v42[0]);
            }
            if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v45.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v44.__r_.__value_.__l.__data_);
            }
            int v30 = DERDecoderGetDataWithTag();
            if (v30)
            {
              sub_100746E04();
              uint64_t v8 = qword_101B0D628;
              if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
              {
                if ((v30 + 1) > 8) {
                  uint64_t v31 = "DERDecoderError(Unknown)";
                }
                else {
                  uint64_t v31 = off_101A02BA0[v30 + 1];
                }
                LODWORD(v53.__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = (std::string::size_type)v31;
                long long v12 = "Get data failure (EuiccCiPkIdForSigningTag): %s";
                goto LABEL_62;
              }
              return 1;
            }
            if (v47)
            {
              if (!DERDecoderInitialize())
              {
                LODWORD(v46.__r_.__value_.__l.__data_) = 0;
                int Count = DERDecoderGetCount();
                if (Count || !LODWORD(v46.__r_.__value_.__l.__data_))
                {
                  sub_100746E04();
                  uint64_t v8 = qword_101B0D628;
                  if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
                    return 1;
                  }
                  if ((Count + 1) > 8) {
                    int v39 = "DERDecoderError(Unknown)";
                  }
                  else {
                    int v39 = off_101A02B40[Count + 1];
                  }
                  LODWORD(v53.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = (std::string::size_type)v39;
                  long long v12 = "Get count failure (EuiccCiPkIdForSigningTag): %s";
                  goto LABEL_62;
                }
                int DataAt = DERDecoderGetDataAt();
                if (!DataAt)
                {
                  sub_1003F0208(a3, v47);
                  sub_10006E4A8(a3, v48, &v48[v47], v47);
                  return 0;
                }
                sub_100746E04();
                uint64_t v8 = qword_101B0D628;
                if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
                {
                  if ((DataAt + 1) > 8) {
                    uint64_t v38 = "DERDecoderError(Unknown)";
                  }
                  else {
                    uint64_t v38 = off_101A02BA0[DataAt + 1];
                  }
                  LODWORD(v53.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
                  long long v12 = "Get data failure (EuiccCiPkIdForSigning): %s";
                  goto LABEL_62;
                }
                return 1;
              }
              sub_100746E04();
              uint64_t v32 = qword_101B0D628;
              if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
                return 1;
              }
              LODWORD(v53.__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(v53.__r_.__value_.__r.__words[0]) = v47;
              long long v12 = "Initialize failure (EuiccCiPkIdForSigning): %d";
            }
            else
            {
              sub_100746E04();
              uint64_t v32 = qword_101B0D628;
              if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
                return 1;
              }
              LODWORD(v53.__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(v53.__r_.__value_.__r.__words[0]) = v47;
              long long v12 = "Missing (EuiccCiPkIdForSigningSequence): %d";
            }
          }
          else
          {
            sub_100746E04();
            uint64_t v32 = qword_101B0D628;
            if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
              return 1;
            }
            LODWORD(v53.__r_.__value_.__l.__data_) = 67109120;
            HIDWORD(v53.__r_.__value_.__r.__words[0]) = v47;
            long long v12 = "Invalid length (svn): %d";
          }
          int v33 = v32;
          uint32_t v34 = 8;
LABEL_63:
          _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v53, v34);
          return 1;
        }
        sub_100746E04();
        uint64_t v8 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((DataWithTag + 1) > 8) {
            id v17 = "DERDecoderError(Unknown)";
          }
          else {
            id v17 = off_101A02BA0[DataWithTag + 1];
          }
          LODWORD(v53.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
          long long v12 = "Get data failure (SvnTag): %s";
          goto LABEL_62;
        }
      }
    }
  }
  return 1;
}

void sub_10074DE84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v44 - 73) < 0) {
    operator delete(*(void **)(v44 - 96));
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10074DF20(void *a1, void *a2)
{
  *(_DWORD *)&v18[8] = 0;
  uint64_t v3 = a1[1];
  *(void *)unsigned __int8 v18 = v3 - *a1;
  if (v3 == *a1)
  {
    sub_100746E04();
    uint64_t v6 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      int v9 = (const char *)(a1[1] - *a1);
      *(_DWORD *)int buf = 134217984;
      std::string::size_type v20 = v9;
      unint64_t v10 = "Invalid parameter size: %lu";
LABEL_23:
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v10, buf, 0xCu);
    }
  }
  else
  {
    int v4 = DERDecoderInitialize();
    if (v4)
    {
      int v5 = v4;
      sub_100746E04();
      uint64_t v6 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v5 + 1) > 8) {
          int v7 = "DERDecoderError(Unknown)";
        }
        else {
          int v7 = off_101A02BA0[v5 + 1];
        }
        *(_DWORD *)int buf = 136315138;
        std::string::size_type v20 = v7;
        unint64_t v10 = "Initialize failure (EuiccChallengeRsp): %s";
        goto LABEL_23;
      }
    }
    else
    {
      int v11 = DERDecoderParseSequence();
      if (v11)
      {
        int v12 = v11;
        sub_100746E04();
        uint64_t v6 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v12 + 1) > 8) {
            int v13 = "DERDecoderError(Unknown)";
          }
          else {
            int v13 = off_101A02BA0[v12 + 1];
          }
          *(_DWORD *)int buf = 136315138;
          std::string::size_type v20 = v13;
          unint64_t v10 = "Parse failure (EuiccChallengeRsp): %s";
          goto LABEL_23;
        }
      }
      else
      {
        int DataAt = DERDecoderGetDataAt();
        if (!DataAt)
        {
          sub_10006E4A8(a2, *(char **)&v18[4], (char *)(*(void *)&v18[4] + *(unsigned int *)v18), *(unsigned int *)v18);
          return 0;
        }
        int v15 = DataAt;
        sub_100746E04();
        uint64_t v6 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v15 + 1) > 8) {
            int64x2_t v16 = "DERDecoderError(Unknown)";
          }
          else {
            int64x2_t v16 = off_101A02BA0[v15 + 1];
          }
          *(_DWORD *)int buf = 136315138;
          std::string::size_type v20 = v16;
          unint64_t v10 = "Get data failure (EuiccChallengeRsp): %s";
          goto LABEL_23;
        }
      }
    }
  }
  return 1;
}

uint64_t sub_10074E1A8(uint64_t a1, void *a2)
{
  int v4 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  int v5 = v4;
  if (v4) {
    *((_DWORD *)v4 + 3) = 0;
  }
  uint64_t v6 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  int v7 = v6;
  if (v6) {
    *((_DWORD *)v6 + 3) = 0;
  }
  uint64_t v67 = 0;
  __dst = 0;
  uint64_t v69 = 0;
  uint64_t __src = 0;
  unsigned int v65 = 0;
  uint64_t v8 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  int v9 = v8;
  if (v8) {
    *((_DWORD *)v8 + 3) = 0;
  }
  if (!v7)
  {
    sub_100746E04();
    uint64_t v12 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    LOWORD(__p[0]) = 0;
    int v13 = "nullptr (ContextParams)";
LABEL_13:
    long long v14 = v12;
    uint32_t v15 = 2;
LABEL_80:
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v13, (uint8_t *)__p, v15);
LABEL_19:
    char v18 = 0;
    if (!v9) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  unint64_t v10 = (void *)(a1 + 120);
  if (*(char *)(a1 + 143) < 0)
  {
    uint64_t v11 = *(void *)(a1 + 128);
    if (v11)
    {
      unint64_t v10 = (void *)*v10;
      goto LABEL_17;
    }
  }
  else
  {
    LODWORD(v11) = *(unsigned __int8 *)(a1 + 143);
    if (*(unsigned char *)(a1 + 143)) {
      goto LABEL_17;
    }
  }
  unint64_t v10 = 0;
LABEL_17:
  unsigned int v16 = sub_1004632FC(v8, 2, 0, v10, v11, 0);
  if (v16)
  {
    sub_100746E04();
    uint64_t v17 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    if (v16 > 3) {
      unsigned int v47 = "DEREncoderError(Unknown)";
    }
    else {
      unsigned int v47 = off_101A02B88[v16 - 1];
    }
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)v47;
    int v13 = "Failed to add data (MatchingId): %s";
    long long v14 = v17;
    uint32_t v15 = 12;
    goto LABEL_80;
  }
  unsigned __int8 v23 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  int v24 = v23;
  if (!v23)
  {
    sub_100746E04();
    uint64_t v12 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    LOWORD(__p[0]) = 0;
    int v13 = "NULL Result (DeviceInfo)";
    goto LABEL_13;
  }
  *((_DWORD *)v23 + 3) = 0;
  memset(__p, 0, 24);
  sub_10005C928(__p, *(const void **)(a1 + 144), *(void *)(a1 + 152), *(void *)(a1 + 152) - *(void *)(a1 + 144));
  uint64_t v26 = __p[1];
  std::string::size_type v25 = __p[0];
  if (__p[0] != __p[1])
  {
    do
    {
      unsigned char *v25 = (*v25 >> 4) | (16 * *v25);
      ++v25;
    }
    while (v25 != v26);
    std::string::size_type v25 = __p[0];
  }
  unsigned int v27 = sub_1004632FC(v24, 2, 0, v25, 4u, 0);
  if (v27)
  {
    sub_100746E04();
    char v28 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v27 > 3) {
        id v60 = "DEREncoderError(Unknown)";
      }
      else {
        id v60 = off_101A02B88[v27 - 1];
      }
      *(_DWORD *)int buf = 136315138;
      v74[0] = v60;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Add data failure (Tac): %s", buf, 0xCu);
    }
    char v29 = 0;
  }
  else
  {
    uint64_t v36 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
    uint64_t v37 = v36;
    if (v36)
    {
      uint64_t v38 = 0;
      *((_DWORD *)v36 + 3) = 0;
      int v39 = (unsigned __int8 *)(a1 + 168);
      unsigned __int8 v71 = 0;
      unsigned __int16 v70 = 0;
      do
      {
        if (*(unsigned __int16 *)v39 != v70 || v39[2] != v71)
        {
          unsigned int v41 = sub_1004632FC(v37, 2, v38, v39, 3u, 0);
          if (v41)
          {
            sub_100746E04();
            uint64_t v52 = qword_101B0D628;
            if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
              goto LABEL_63;
            }
            if (v41 > 3) {
              long long v64 = "DEREncoderError(Unknown)";
            }
            else {
              long long v64 = off_101A02B88[v41 - 1];
            }
            *(_DWORD *)int buf = 67109378;
            LODWORD(v74[0]) = v38;
            WORD2(v74[0]) = 2080;
            *(void *)((char *)v74 + 6) = v64;
            uint64_t v49 = "Add data failure (DeviceCapabilities: %d): %s";
            uint64_t v50 = v52;
            uint32_t v51 = 18;
            goto LABEL_114;
          }
        }
        ++v38;
        v39 += 3;
      }
      while (v38 != 11);
      char v29 = 1;
      unsigned int v42 = sub_100463720(v37, v24, 2, 1u);
      if (!v42) {
        goto LABEL_64;
      }
      unsigned int v43 = v42;
      sub_100746E04();
      uint64_t v44 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if (v43 > 3) {
          std::string v45 = "DEREncoderError(Unknown)";
        }
        else {
          std::string v45 = off_101A02B88[v43 - 1];
        }
        *(_DWORD *)int buf = 136315138;
        v74[0] = v45;
        uint64_t v49 = "Add data failure (DeviceCapabilities): %s";
        uint64_t v50 = v44;
        uint32_t v51 = 12;
        goto LABEL_114;
      }
    }
    else
    {
      sub_100746E04();
      uint64_t v48 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int buf = 0;
        uint64_t v49 = "NULL Result (DeviceCapabilities)";
        uint64_t v50 = v48;
        uint32_t v51 = 2;
LABEL_114:
        _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, v49, buf, v51);
      }
    }
LABEL_63:
    char v29 = 0;
LABEL_64:
    if (v37) {
      sub_100463290(v37);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if ((v29 & 1) == 0) {
    goto LABEL_75;
  }
  unsigned int v53 = sub_100463720(v24, v9, 2, 1u);
  if (v53)
  {
    unsigned int v54 = v53;
    sub_100746E04();
    char v55 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v54 > 3) {
        uint64_t v56 = "DEREncoderError(Unknown)";
      }
      else {
        uint64_t v56 = off_101A02B88[v54 - 1];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v56;
      uint64_t v61 = "Add data failure (ContextParams): %s";
LABEL_109:
      _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, v61, (uint8_t *)__p, 0xCu);
      goto LABEL_75;
    }
    goto LABEL_75;
  }
  unsigned int v57 = sub_100463720(v9, v7, 2, 0);
  if (v57)
  {
    unsigned int v58 = v57;
    sub_100746E04();
    char v55 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v58 > 3) {
        BOOL v63 = "DEREncoderError(Unknown)";
      }
      else {
        BOOL v63 = off_101A02B88[v58 - 1];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v63;
      uint64_t v61 = "Add data failure (AuthenticateServerReq): %s";
      goto LABEL_109;
    }
LABEL_75:
    char v18 = 0;
    goto LABEL_76;
  }
  char v18 = 1;
LABEL_76:
  sub_100463290(v24);
  if (v9) {
LABEL_20:
  }
    sub_100463290(v9);
LABEL_21:
  if ((v18 & 1) == 0) {
    goto LABEL_95;
  }
  unsigned int v19 = sub_100463664(v7, &__src, &v65);
  if (v19)
  {
    unsigned int v20 = v19;
    sub_100746E04();
    uint64_t v21 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v20 > 3) {
        long long v22 = "DEREncoderError(Unknown)";
      }
      else {
        long long v22 = off_101A02B88[v20 - 1];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v22;
      uint64_t v59 = "Buffer creation failure (AuthenticateServerReq): %s";
LABEL_94:
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v59, (uint8_t *)__p, 0xCu);
      goto LABEL_95;
    }
    goto LABEL_95;
  }
  int64x2_t v30 = vaddq_s64(vaddq_s64(*(int64x2_t *)(a1 + 24), *(int64x2_t *)(a1 + 48)), vaddq_s64(*(int64x2_t *)(a1 + 72), *(int64x2_t *)(a1 + 96)));
  sub_100240658((unint64_t *)&v67, vsubq_s64(vdupq_laneq_s64(v30, 1), v30).u64[0] + v65);
  sub_10005C748((uint64_t)&v67, (char *)__dst, *(char **)(a1 + 24), *(char **)(a1 + 32), *(void *)(a1 + 32) - *(void *)(a1 + 24));
  sub_10005C748((uint64_t)&v67, (char *)__dst, *(char **)(a1 + 48), *(char **)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
  sub_10005C748((uint64_t)&v67, (char *)__dst, *(char **)(a1 + 72), *(char **)(a1 + 80), *(void *)(a1 + 80) - *(void *)(a1 + 72));
  sub_10005C748((uint64_t)&v67, (char *)__dst, *(char **)(a1 + 96), *(char **)(a1 + 104), *(void *)(a1 + 104) - *(void *)(a1 + 96));
  sub_100754F40((uint64_t)&v67, (char *)__dst, (char *)__src, (char *)__src + v65, v65);
  free(__src);
  unsigned int v31 = sub_1004632FC(v5, 2, 0x38u, v67, (int)__dst - (int)v67, 1);
  if (v31)
  {
    sub_100746E04();
    uint64_t v21 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v31 > 3) {
        uint64_t v32 = "DEREncoderError(Unknown)";
      }
      else {
        uint64_t v32 = off_101A02B88[v31 - 1];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v32;
      uint64_t v59 = "Add data failure (AuthenticateServerReq): %s";
      goto LABEL_94;
    }
LABEL_95:
    uint64_t v46 = 0;
    goto LABEL_96;
  }
  unsigned int v33 = sub_100463664(v5, &__src, &v65);
  if (v33)
  {
    unsigned int v34 = v33;
    sub_100746E04();
    uint64_t v21 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v34 > 3) {
        char v35 = "DEREncoderError(Unknown)";
      }
      else {
        char v35 = off_101A02B88[v34 - 1];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v35;
      uint64_t v59 = "Buffer creation failure (AuthenticateServerReq): %s";
      goto LABEL_94;
    }
    goto LABEL_95;
  }
  a2[1] = *a2;
  if (__src)
  {
    sub_10006E4A8(a2, (char *)__src, (char *)__src + v65, v65);
    free(__src);
  }
  uint64_t v46 = 1;
LABEL_96:
  if (v67)
  {
    __dst = v67;
    operator delete(v67);
  }
  if (v7) {
    sub_100463290(v7);
  }
  if (v5) {
    sub_100463290(v5);
  }
  return v46;
}

void sub_10074EAAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16)
{
  if (v20) {
    sub_100463290(v20);
  }
  if (a15)
  {
    operator delete(a15);
    if (!v19)
    {
LABEL_5:
      if (!v18) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  else if (!v19)
  {
    goto LABEL_5;
  }
  sub_100463290(v19);
  if (!v18)
  {
LABEL_7:
    if (__p)
    {
      operator delete(__p);
      if (!v17)
      {
LABEL_9:
        if (!v16) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
    }
    else if (!v17)
    {
      goto LABEL_9;
    }
    sub_100463290(v17);
    if (!v16) {
LABEL_11:
    }
      _Unwind_Resume(exception_object);
LABEL_10:
    sub_100463290(v16);
    goto LABEL_11;
  }
LABEL_6:
  sub_100463290(v18);
  goto LABEL_7;
}

uint64_t sub_10074EB90(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8) == *(void *)a1)
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      uint64_t v6 = "Empty Response";
      int v7 = v5;
      uint32_t v8 = 2;
LABEL_24:
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    }
  }
  else
  {
    int v1 = DERDecoderInitialize();
    if (v1)
    {
      int v2 = v1;
      sub_100746E04();
      uint64_t v3 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v2 + 1) > 8) {
          int v4 = "DERDecoderError(Unknown)";
        }
        else {
          int v4 = off_101A02BA0[v2 + 1];
        }
        *(_DWORD *)int buf = 136315138;
        uint64_t v17 = v4;
        uint64_t v6 = "Initialize failure (AuthenticateServerRsp): %s";
LABEL_23:
        int v7 = v3;
        uint32_t v8 = 12;
        goto LABEL_24;
      }
    }
    else
    {
      int v9 = DERDecoderParseSequence();
      if (v9)
      {
        int v10 = v9;
        sub_100746E04();
        uint64_t v3 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v10 + 1) > 8) {
            uint64_t v11 = "DERDecoderError(Unknown)";
          }
          else {
            uint64_t v11 = off_101A02BA0[v10 + 1];
          }
          *(_DWORD *)int buf = 136315138;
          uint64_t v17 = v11;
          uint64_t v6 = "Parse failure (AuthenticateServerRsp): %s";
          goto LABEL_23;
        }
      }
      else
      {
        int DataAt = DERDecoderGetDataAt();
        if (!DataAt) {
          return 0;
        }
        int v13 = DataAt;
        sub_100746E04();
        uint64_t v3 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v13 + 1) > 8) {
            long long v14 = "DERDecoderError(Unknown)";
          }
          else {
            long long v14 = off_101A02BA0[v13 + 1];
          }
          *(_DWORD *)int buf = 136315138;
          uint64_t v17 = v14;
          uint64_t v6 = "Get data failure (AuthenticateServerRsp): %s";
          goto LABEL_23;
        }
      }
    }
  }
  return 1;
}

uint64_t sub_10074F130(char **a1, void *a2)
{
  int v4 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  uint64_t v5 = v4;
  if (v4) {
    *((_DWORD *)v4 + 3) = 0;
  }
  long long __p = 0;
  __dst = 0;
  uint64_t v29 = 0;
  uint64_t __src = 0;
  unsigned int v25 = 0;
  uint64_t v6 = a1[1];
  if (*a1 == v6)
  {
    sub_100746E04();
    uint64_t v16 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    *(_WORD *)int buf = 0;
    uint64_t v17 = "Missing payload (SmdpSigned2)";
LABEL_18:
    char v18 = v16;
    uint32_t v19 = 2;
LABEL_31:
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
    goto LABEL_32;
  }
  int v7 = a1[3];
  uint32_t v8 = a1[4];
  if (v7 == v8)
  {
    sub_100746E04();
    uint64_t v16 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    *(_WORD *)int buf = 0;
    uint64_t v17 = "Missing payload (SmdpSignature2)";
    goto LABEL_18;
  }
  int v10 = a1[9];
  int v9 = a1[10];
  if (v10 == v9)
  {
    sub_100746E04();
    uint64_t v16 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    *(_WORD *)int buf = 0;
    uint64_t v17 = "Missing payload (SmdpCertificate)";
    goto LABEL_18;
  }
  sub_100240658((unint64_t *)&__p, &a1[7][(void)v9 + &v8[(void)v6] - &v7[(void)*a1 + (unint64_t)v10]] - a1[6]);
  sub_10005C748((uint64_t)&__p, (char *)__dst, *a1, a1[1], a1[1] - *a1);
  sub_10005C748((uint64_t)&__p, (char *)__dst, a1[3], a1[4], a1[4] - a1[3]);
  uint64_t v11 = a1[6];
  uint64_t v12 = a1[7];
  if (v11 != v12) {
    sub_10005C748((uint64_t)&__p, (char *)__dst, v11, v12, v12 - v11);
  }
  sub_10005C748((uint64_t)&__p, (char *)__dst, a1[9], a1[10], a1[10] - a1[9]);
  unsigned int v13 = sub_1004632FC(v5, 2, 0x21u, __p, (int)__dst - (int)__p, 1);
  if (v13)
  {
    sub_100746E04();
    uint64_t v14 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v13 > 3) {
        uint32_t v15 = "DEREncoderError(Unknown)";
      }
      else {
        uint32_t v15 = off_101A02B88[v13 - 1];
      }
      *(_DWORD *)int buf = 136315138;
      unsigned int v31 = v15;
      uint64_t v17 = "Add data failure (PrepareDownloadReq): %s";
LABEL_30:
      char v18 = v14;
      uint32_t v19 = 12;
      goto LABEL_31;
    }
    goto LABEL_32;
  }
  unsigned int v20 = sub_100463664(v5, &__src, &v25);
  if (v20)
  {
    unsigned int v21 = v20;
    sub_100746E04();
    uint64_t v14 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v21 > 3) {
        long long v22 = "DEREncoderError(Unknown)";
      }
      else {
        long long v22 = off_101A02B88[v21 - 1];
      }
      *(_DWORD *)int buf = 136315138;
      unsigned int v31 = v22;
      uint64_t v17 = "Buffer creation failure (PrepareDownloadReq): %s";
      goto LABEL_30;
    }
LABEL_32:
    uint64_t v23 = 0;
    goto LABEL_33;
  }
  a2[1] = *a2;
  if (__src)
  {
    sub_10006E4A8(a2, (char *)__src, (char *)__src + v25, v25);
    free(__src);
  }
  uint64_t v23 = 1;
LABEL_33:
  if (__p)
  {
    __dst = __p;
    operator delete(__p);
  }
  if (v5) {
    sub_100463290(v5);
  }
  return v23;
}

void sub_10074F47C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (v13) {
    sub_100463290(v13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10074F4C8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8) == *(void *)a1)
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      uint64_t v6 = "Empty Response";
      int v7 = v5;
      uint32_t v8 = 2;
LABEL_24:
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    }
  }
  else
  {
    int v1 = DERDecoderInitialize();
    if (v1)
    {
      int v2 = v1;
      sub_100746E04();
      uint64_t v3 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v2 + 1) > 8) {
          int v4 = "DERDecoderError(Unknown)";
        }
        else {
          int v4 = off_101A02BA0[v2 + 1];
        }
        *(_DWORD *)int buf = 136315138;
        uint64_t v17 = v4;
        uint64_t v6 = "Initialize failure (PrepareDownloadRsp): %s";
LABEL_23:
        int v7 = v3;
        uint32_t v8 = 12;
        goto LABEL_24;
      }
    }
    else
    {
      int v9 = DERDecoderParseSequence();
      if (v9)
      {
        int v10 = v9;
        sub_100746E04();
        uint64_t v3 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v10 + 1) > 8) {
            uint64_t v11 = "DERDecoderError(Unknown)";
          }
          else {
            uint64_t v11 = off_101A02BA0[v10 + 1];
          }
          *(_DWORD *)int buf = 136315138;
          uint64_t v17 = v11;
          uint64_t v6 = "Parse failure (PrepareDownloadRsp): %s";
          goto LABEL_23;
        }
      }
      else
      {
        int DataAt = DERDecoderGetDataAt();
        if (!DataAt) {
          return 0;
        }
        int v13 = DataAt;
        sub_100746E04();
        uint64_t v3 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v13 + 1) > 8) {
            uint64_t v14 = "DERDecoderError(Unknown)";
          }
          else {
            uint64_t v14 = off_101A02BA0[v13 + 1];
          }
          *(_DWORD *)int buf = 136315138;
          uint64_t v17 = v14;
          uint64_t v6 = "Get data failure (PrepareDownloadRsp): %s";
          goto LABEL_23;
        }
      }
    }
  }
  return 1;
}

uint64_t sub_10074FA50(void *a1, uint64_t a2)
{
  *(_DWORD *)&v19[8] = 0;
  uint64_t v3 = a1[1];
  *(void *)uint32_t v19 = v3 - *a1;
  if (v3 != *a1)
  {
    int v4 = DERDecoderInitialize();
    if (v4)
    {
      sub_100746E04();
      uint64_t v5 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v4 + 1) > 8) {
          uint64_t v6 = "DERDecoderError(Unknown)";
        }
        else {
          uint64_t v6 = off_101A02BA0[v4 + 1];
        }
        *(_DWORD *)int buf = 136315138;
        *(void *)&uint8_t buf[4] = v6;
        uint64_t v14 = "Initialize failure (BoundProfilePackageRsp): %s";
LABEL_31:
        uint64_t v16 = v5;
        uint32_t v17 = 12;
        goto LABEL_32;
      }
    }
    else
    {
      int v7 = DERDecoderParseSequence();
      if (v7)
      {
        sub_100746E04();
        uint64_t v5 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v7 + 1) > 8) {
            uint32_t v8 = "DERDecoderError(Unknown)";
          }
          else {
            uint32_t v8 = off_101A02BA0[v7 + 1];
          }
          *(_DWORD *)int buf = 136315138;
          *(void *)&uint8_t buf[4] = v8;
          uint64_t v14 = "Parse failure (BoundProfilePackageRsp): %s";
          goto LABEL_31;
        }
      }
      else
      {
        int v9 = DERDecoderParseSequence();
        if (v9)
        {
          sub_100746E04();
          uint64_t v5 = qword_101B0D628;
          if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
          {
            if ((v9 + 1) > 8) {
              int v10 = "DERDecoderError(Unknown)";
            }
            else {
              int v10 = off_101A02BA0[v9 + 1];
            }
            *(_DWORD *)int buf = 136315138;
            *(void *)&uint8_t buf[4] = v10;
            uint64_t v14 = "Parse failure (BoundProfilePackage): %s";
            goto LABEL_31;
          }
        }
        else
        {
          int DataAt = DERDecoderGetDataAt();
          if (DataAt)
          {
            sub_100746E04();
            uint64_t v5 = qword_101B0D628;
            if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
            {
              if ((DataAt + 1) > 8) {
                int v13 = "DERDecoderError(Unknown)";
              }
              else {
                int v13 = off_101A02BA0[DataAt + 1];
              }
              *(_DWORD *)int buf = 136315138;
              *(void *)&uint8_t buf[4] = v13;
              uint64_t v14 = "Get data failure (InitiateSecureChannel): %s";
              goto LABEL_31;
            }
          }
          else
          {
            ctu::hex((uint64_t *)buf, *(ctu **)&v19[4], (const void *)*(unsigned int *)v19, v11);
            if (*(char *)(a2 + 23) < 0) {
              operator delete(*(void **)a2);
            }
            *(_OWORD *)a2 = *(_OWORD *)buf;
            *(void *)(a2 + 16) = v21;
            sub_100746E04();
            uint64_t v15 = qword_101B0D628;
            if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)int buf = 0;
              uint64_t v14 = "Missing sequence item (Seq87)";
              uint64_t v16 = v15;
              uint32_t v17 = 2;
LABEL_32:
              _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v14, buf, v17);
            }
          }
        }
      }
    }
  }
  return 0;
}

void sub_1007501C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 - 80);
  if (v3)
  {
    *(void *)(v1 - 72) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100750204(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8) == *(void *)a1)
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      int v7 = "Empty Response";
      uint32_t v8 = v5;
      uint32_t v9 = 2;
LABEL_13:
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v7, buf, v9);
    }
    return 1;
  }
  if (!sub_1007497AC()) {
    return 1;
  }
  int DataAt = DERDecoderGetDataAt();
  if (DataAt)
  {
    int v2 = DataAt;
    sub_100746E04();
    uint64_t v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v2 + 1) > 8) {
        int v4 = "DERDecoderError(Unknown)";
      }
      else {
        int v4 = off_101A02BA0[v2 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      unint64_t v11 = v4;
      int v7 = "Get data  failure (FinalResult): %s";
      uint32_t v8 = v3;
      uint32_t v9 = 12;
      goto LABEL_13;
    }
    return 1;
  }
  return 0;
}

BOOL sub_100750718(uint64_t a1, char a2, uint64_t a3)
{
  long long __p = 0;
  long long v12 = 0uLL;
  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v4 = *(void *)(a1 + 8);
  }
  if (v4 == 32)
  {
    *(_DWORD *)int buf = -2146090561;
    uint8_t buf[4] = 16;
    sub_10006E4A8((void *)a3, buf, &buf[5], 5uLL);
    ctu::parse_hex();
    int v7 = *(char **)(a3 + 8);
    long long __p = *(void **)buf;
    long long v12 = *(_OWORD *)&buf[8];
    sub_10005C748(a3, v7, *(char **)buf, *(char **)&buf[8], *(void *)&buf[8] - *(void *)buf);
    *(_WORD *)int buf = 385;
    buf[2] = a2;
    sub_10006E4A8(&__p, buf, &buf[3], 3uLL);
    sub_10005C748(a3, *(char **)(a3 + 8), (char *)__p, (char *)v12, v12 - (void)__p);
    if (__p)
    {
      *(void *)&long long v12 = __p;
      operator delete(__p);
    }
  }
  else
  {
    sub_100746E04();
    uint32_t v8 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(unsigned __int8 *)(a1 + 23);
      if ((v10 & 0x80u) != 0) {
        uint64_t v10 = *(void *)(a1 + 8);
      }
      *(_DWORD *)int buf = 134217984;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Add data failure (TransactionId): %lu", buf, 0xCu);
    }
  }
  return v4 == 32;
}

void sub_1007508BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007508EC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8) == *(void *)a1)
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      uint64_t v6 = "Empty Response";
      int v7 = v5;
      uint32_t v8 = 2;
LABEL_24:
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    }
  }
  else
  {
    int v1 = DERDecoderInitialize();
    if (v1)
    {
      int v2 = v1;
      sub_100746E04();
      uint64_t v3 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v2 + 1) > 8) {
          uint64_t v4 = "DERDecoderError(Unknown)";
        }
        else {
          uint64_t v4 = off_101A02BA0[v2 + 1];
        }
        *(_DWORD *)int buf = 136315138;
        uint32_t v17 = v4;
        uint64_t v6 = "Initialize failure (CancelSessionRsp): %s";
LABEL_23:
        int v7 = v3;
        uint32_t v8 = 12;
        goto LABEL_24;
      }
    }
    else
    {
      int v9 = DERDecoderParseSequence();
      if (v9)
      {
        int v10 = v9;
        sub_100746E04();
        uint64_t v3 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v10 + 1) > 8) {
            unint64_t v11 = "DERDecoderError(Unknown)";
          }
          else {
            unint64_t v11 = off_101A02BA0[v10 + 1];
          }
          *(_DWORD *)int buf = 136315138;
          uint32_t v17 = v11;
          uint64_t v6 = "Parse failure (CancelSessionRsp): %s";
          goto LABEL_23;
        }
      }
      else
      {
        int DataAt = DERDecoderGetDataAt();
        if (!DataAt) {
          return 0;
        }
        int v13 = DataAt;
        sub_100746E04();
        uint64_t v3 = qword_101B0D628;
        if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
        {
          if ((v13 + 1) > 8) {
            uint64_t v14 = "DERDecoderError(Unknown)";
          }
          else {
            uint64_t v14 = off_101A02BA0[v13 + 1];
          }
          *(_DWORD *)int buf = 136315138;
          uint32_t v17 = v14;
          uint64_t v6 = "Get data failure (CancelSessionRsp): %s";
          goto LABEL_23;
        }
      }
    }
  }
  return 1;
}

uint64_t sub_100750C78(uint64_t a1, const void **a2, unint64_t *a3)
{
  uint64_t v6 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  int v7 = v6;
  if (v6) {
    *((_DWORD *)v6 + 3) = 0;
  }
  uint64_t __src = 0;
  unsigned int v35 = 0;
  uint64_t v32 = 0;
  unsigned int v33 = 0;
  uint64_t v34 = 0;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a1;
    uint64_t v31 = *(void *)(a1 + 16);
  }
  subscriber::encodeIccid();
  if (SHIBYTE(v31) < 0) {
    operator delete(__p[0]);
  }
  if (v32 == v33)
  {
    sub_100746E04();
    int v9 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      unint64_t v11 = (const char *)*(unsigned __int8 *)(a1 + 23);
      if ((char)v11 < 0) {
        unint64_t v11 = *(const char **)(a1 + 8);
      }
      *(_DWORD *)int buf = 134217984;
      uint64_t v38 = v11;
      long long v12 = "Invalid ICCID length: %lu";
      goto LABEL_45;
    }
    goto LABEL_46;
  }
  unsigned int v8 = sub_1004632FC(v7, 1, 0x1Au, v32, (int)v33 - (int)v32, 0);
  if (v8)
  {
    sub_100746E04();
    int v9 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v8 > 3) {
        int v10 = "DEREncoderError(Unknown)";
      }
      else {
        int v10 = off_101A02B88[v8 - 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint64_t v38 = v10;
      long long v12 = "Add data failure (ICCID): %s";
LABEL_45:
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v12, buf, 0xCu);
      goto LABEL_46;
    }
    goto LABEL_46;
  }
  int v13 = *((char *)a2 + 23);
  if (v13 >= 0) {
    uint64_t v14 = a2;
  }
  else {
    uint64_t v14 = *a2;
  }
  if (v13 >= 0) {
    unsigned int v15 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    unsigned int v15 = *((_DWORD *)a2 + 2);
  }
  unsigned int v16 = sub_1004632FC(v7, 2, 0x10u, v14, v15, 0);
  if (v16)
  {
    sub_100746E04();
    int v9 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v16 > 3) {
        uint32_t v17 = "DEREncoderError(Unknown)";
      }
      else {
        uint32_t v17 = off_101A02B88[v16 - 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint64_t v38 = v17;
      long long v12 = "Add data failure (Nickname): %s";
      goto LABEL_45;
    }
LABEL_46:
    uint64_t v26 = 0;
    goto LABEL_47;
  }
  char v18 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  uint32_t v19 = v18;
  if (v18) {
    *((_DWORD *)v18 + 3) = 0;
  }
  unsigned int v20 = sub_100463720(v7, v18, 2, 0x29u);
  if (v20)
  {
    unsigned int v21 = v20;
    sub_100746E04();
    long long v22 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_35;
    }
    if (v21 > 3) {
      uint64_t v23 = "DEREncoderError(Unknown)";
    }
    else {
      uint64_t v23 = off_101A02B88[v21 - 1];
    }
    *(_DWORD *)int buf = 136315138;
    uint64_t v38 = v23;
    char v28 = "Add data failure (SetNicknameRequest): %s";
    goto LABEL_58;
  }
  unsigned int v24 = sub_100463664(v19, &__src, &v35);
  if (v24)
  {
    unsigned int v25 = v24;
    sub_100746E04();
    long long v22 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_35;
    }
    if (v25 > 3) {
      uint64_t v29 = "DEREncoderError(Unknown)";
    }
    else {
      uint64_t v29 = off_101A02B88[v25 - 1];
    }
    *(_DWORD *)int buf = 136315138;
    uint64_t v38 = v29;
    char v28 = "Buffer creation failure (SetNicknameRequest): %s";
LABEL_58:
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, v28, buf, 0xCu);
LABEL_35:
    uint64_t v26 = 0;
    if (!v19) {
      goto LABEL_47;
    }
    goto LABEL_36;
  }
  a3[1] = *a3;
  if (__src)
  {
    sub_1003F0208(a3, v35);
    sub_10006E4A8(a3, (char *)__src, (char *)__src + v35, v35);
    free(__src);
  }
  uint64_t v26 = 1;
  if (v19) {
LABEL_36:
  }
    sub_100463290(v19);
LABEL_47:
  if (v32)
  {
    unsigned int v33 = v32;
    operator delete(v32);
  }
  if (v7) {
    sub_100463290(v7);
  }
  return v26;
}

void sub_10075108C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16)
{
  if (v17) {
    sub_100463290(v17);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v16) {
    sub_100463290(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007510F8(uint64_t a1)
{
  *(_DWORD *)&v15[8] = 0;
  *(void *)unsigned int v15 = *(_DWORD *)(a1 + 8) - *(void *)a1;
  if (!*(_DWORD *)v15)
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      return 1;
    }
    *(_WORD *)int buf = 0;
    uint64_t v6 = "Empty Response";
    int v7 = v5;
    uint32_t v8 = 2;
    goto LABEL_28;
  }
  int v1 = DERDecoderInitialize();
  if (v1)
  {
    int v2 = v1;
    sub_100746E04();
    uint64_t v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v2 + 1) > 8) {
        uint64_t v4 = "DERDecoderError(Unknown)";
      }
      else {
        uint64_t v4 = off_101A02BA0[v2 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint32_t v17 = v4;
      uint64_t v6 = "Initialize failure (SetNicknameRsp): %s";
LABEL_27:
      int v7 = v3;
      uint32_t v8 = 12;
      goto LABEL_28;
    }
    return 1;
  }
  int v9 = DERDecoderParseSequence();
  if (!v9)
  {
    DERDecoderGetDataAt();
    if (*(_DWORD *)v15 == 1)
    {
      uint64_t result = **(unsigned char **)&v15[4];
      if (!**(unsigned char **)&v15[4]) {
        return result;
      }
      if (result == 127) {
        return 30;
      }
      if (result == 1) {
        return 25;
      }
      sub_100746E04();
      uint64_t v13 = qword_101B0D628;
      if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
        return 1;
      }
      int v14 = **(unsigned char **)&v15[4];
      *(_DWORD *)int buf = 67109120;
      LODWORD(v17) = v14;
      uint64_t v6 = "Invalid data (SetNicknameRsp Result): %d";
    }
    else
    {
      sub_100746E04();
      uint64_t v13 = qword_101B0D628;
      if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
        return 1;
      }
      *(_DWORD *)int buf = 67109120;
      LODWORD(v17) = *(_DWORD *)v15;
      uint64_t v6 = "Invalid length (SetNicknameRsp Result): %d";
    }
    int v7 = v13;
    uint32_t v8 = 8;
LABEL_28:
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    return 1;
  }
  int v10 = v9;
  sub_100746E04();
  uint64_t v3 = qword_101B0D628;
  if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
  {
    if ((v10 + 1) > 8) {
      unint64_t v11 = "DERDecoderError(Unknown)";
    }
    else {
      unint64_t v11 = off_101A02BA0[v10 + 1];
    }
    *(_DWORD *)int buf = 136315138;
    uint32_t v17 = v11;
    uint64_t v6 = "Parse failure (SetNicknameRsp): %s";
    goto LABEL_27;
  }
  return 1;
}

BOOL sub_1007513C0(uint64_t a1, int a2, char a3, uint64_t a4)
{
  uint64_t v50 = 0;
  uint32_t v51 = 0;
  uint64_t v52 = 0;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a1;
    uint64_t v49 = *(void *)(a1 + 16);
  }
  subscriber::encodeIccid();
  if (SHIBYTE(v49) < 0) {
    operator delete(__p[0]);
  }
  uint32_t v8 = (char *)v50;
  int v9 = v51;
  if (v50 != v51)
  {
    buf[0] = -65;
    if (a2) {
      char v10 = 49;
    }
    else {
      char v10 = 50;
    }
    buf[1] = v10;
    *(_DWORD *)&buf[2] = 1510776849;
    buf[6] = 10;
    sub_10006E4A8((void *)a4, buf, &buf[7], 7uLL);
    sub_10005C748(a4, *(char **)(a4 + 8), (char *)v50, v51, v51 - (unsigned char *)v50);
    long long v12 = *(unsigned char **)(a4 + 8);
    unint64_t v11 = *(void *)(a4 + 16);
    if ((unint64_t)v12 >= v11)
    {
      unint64_t v16 = *(void *)a4;
      uint32_t v17 = &v12[-*(void *)a4];
      unint64_t v18 = (unint64_t)(v17 + 1);
      if ((uint64_t)(v17 + 1) < 0) {
        sub_10006A748();
      }
      unint64_t v19 = v11 - v16;
      if (2 * v19 > v18) {
        unint64_t v18 = 2 * v19;
      }
      if (v19 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v20 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v20 = v18;
      }
      if (v20) {
        unsigned int v21 = operator new(v20);
      }
      else {
        unsigned int v21 = 0;
      }
      long long v22 = &v21[v20];
      v17[(void)v21] = -127;
      uint64_t v13 = &v17[(void)v21 + 1];
      if (v12 == (unsigned char *)v16)
      {
        unsigned int v21 = &v17[(void)v21];
      }
      else
      {
        uint64_t v23 = &v12[~v16];
        do
        {
          char v24 = *--v12;
          (v23--)[(void)v21] = v24;
        }
        while (v12 != (unsigned char *)v16);
        long long v12 = *(unsigned char **)a4;
      }
      *(void *)a4 = v21;
      *(void *)(a4 + 8) = v13;
      *(void *)(a4 + 16) = v22;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      unsigned char *v12 = -127;
      uint64_t v13 = v12 + 1;
    }
    *(void *)(a4 + 8) = v13;
    unint64_t v25 = *(void *)(a4 + 16);
    if ((unint64_t)v13 < v25)
    {
      unsigned char *v13 = 1;
      uint64_t v26 = v13 + 1;
      goto LABEL_50;
    }
    unint64_t v27 = *(void *)a4;
    char v28 = &v13[-*(void *)a4];
    unint64_t v29 = (unint64_t)(v28 + 1);
    if ((uint64_t)(v28 + 1) < 0) {
      sub_10006A748();
    }
    unint64_t v30 = v25 - v27;
    if (2 * v30 > v29) {
      unint64_t v29 = 2 * v30;
    }
    if (v30 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v31 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v31 = v29;
    }
    if (v31) {
      uint64_t v32 = operator new(v31);
    }
    else {
      uint64_t v32 = 0;
    }
    unsigned int v33 = (char *)v32 + v31;
    v28[(void)v32] = 1;
    uint64_t v26 = &v28[(void)v32 + 1];
    if (v13 == (unsigned char *)v27)
    {
      *(void *)a4 = &v28[(void)v32];
      *(void *)(a4 + 8) = v26;
      *(void *)(a4 + 16) = v33;
    }
    else
    {
      uint64_t v34 = &v13[~v27];
      do
      {
        char v35 = *--v13;
        (v34--)[(void)v32] = v35;
      }
      while (v13 != (unsigned char *)v27);
      uint64_t v13 = *(unsigned char **)a4;
      *(void *)a4 = v32;
      *(void *)(a4 + 8) = v26;
      *(void *)(a4 + 16) = v33;
      if (!v13)
      {
LABEL_50:
        *(void *)(a4 + 8) = v26;
        unint64_t v36 = *(void *)(a4 + 16);
        if ((unint64_t)v26 >= v36)
        {
          unint64_t v38 = *(void *)a4;
          int v39 = &v26[-*(void *)a4];
          unint64_t v40 = (unint64_t)(v39 + 1);
          if ((uint64_t)(v39 + 1) < 0) {
            sub_10006A748();
          }
          unint64_t v41 = v36 - v38;
          if (2 * v41 > v40) {
            unint64_t v40 = 2 * v41;
          }
          if (v41 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v42 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v42 = v40;
          }
          if (v42) {
            unsigned int v43 = operator new(v42);
          }
          else {
            unsigned int v43 = 0;
          }
          uint64_t v44 = (char *)v43 + v42;
          v39[(void)v43] = a3;
          uint64_t v37 = (uint64_t)&v39[(void)v43 + 1];
          if (v26 == (unsigned char *)v38)
          {
            *(void *)a4 = &v39[(void)v43];
            *(void *)(a4 + 8) = v37;
            *(void *)(a4 + 16) = v44;
          }
          else
          {
            std::string v45 = &v26[~v38];
            do
            {
              char v46 = *--v26;
              (v45--)[(void)v43] = v46;
            }
            while (v26 != (unsigned char *)v38);
            uint64_t v26 = *(unsigned char **)a4;
            *(void *)a4 = v43;
            *(void *)(a4 + 8) = v37;
            *(void *)(a4 + 16) = v44;
            if (!v26) {
              goto LABEL_68;
            }
          }
          operator delete(v26);
        }
        else
        {
          *uint64_t v26 = a3;
          uint64_t v37 = (uint64_t)(v26 + 1);
        }
LABEL_68:
        *(void *)(a4 + 8) = v37;
        goto LABEL_69;
      }
    }
    operator delete(v13);
    goto LABEL_50;
  }
  sub_100746E04();
  int v14 = qword_101B0D628;
  if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = *(unsigned __int8 *)(a1 + 23);
    if ((v15 & 0x80u) != 0) {
      uint64_t v15 = *(void *)(a1 + 8);
    }
    *(_DWORD *)int buf = 134217984;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid ICCID length: %lu", buf, 0xCu);
  }
LABEL_69:
  if (v50)
  {
    uint32_t v51 = (char *)v50;
    operator delete(v50);
  }
  return v8 != v9;
}

void sub_1007517C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10075180C(uint64_t a1, uint64_t a2)
{
  unint64_t v11 = 0;
  long long v12 = 0;
  uint64_t v13 = 0;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a1;
    uint64_t v10 = *(void *)(a1 + 16);
  }
  subscriber::encodeIccid();
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v4 = (char *)v11;
  uint64_t v5 = v12;
  if (v11 == v12)
  {
    sub_100746E04();
    uint64_t v6 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 23) < 0) {
        uint64_t v8 = *(void *)(a1 + 8);
      }
      else {
        uint64_t v8 = *(unsigned __int8 *)(a1 + 23);
      }
      *(_DWORD *)int buf = 134217984;
      uint64_t v15 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Invalid ICCID length (encodeDeleteProfileReq): %lu", buf, 0xCu);
    }
  }
  else
  {
    *(_DWORD *)int buf = 1510749119;
    LOBYTE(v15) = 10;
    sub_10006E4A8((void *)a2, (char *)buf, (char *)&v15 + 1, 5uLL);
    sub_10005C748(a2, *(char **)(a2 + 8), (char *)v11, v12, v12 - (unsigned char *)v11);
  }
  if (v11)
  {
    long long v12 = (char *)v11;
    operator delete(v11);
  }
  return v4 != v5;
}

void sub_100751988(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007519C8(uint64_t a1, int a2)
{
  *(_DWORD *)&v21[8] = 0;
  *(void *)unsigned int v21 = *(_DWORD *)(a1 + 8) - *(void *)a1;
  if (!*(_DWORD *)v21)
  {
    sub_100746E04();
    uint64_t v7 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      uint64_t v8 = "Empty Response";
      int v9 = v7;
      uint32_t v10 = 2;
LABEL_34:
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v8, buf, v10);
      goto LABEL_35;
    }
    goto LABEL_35;
  }
  int v3 = DERDecoderInitialize();
  if (v3)
  {
    int v4 = v3;
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v4 + 1) > 8) {
        uint64_t v6 = "DERDecoderError(Unknown)";
      }
      else {
        uint64_t v6 = off_101A02BA0[v4 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint64_t v23 = v6;
      uint64_t v8 = "Initialize failure (ProfileResponse): %s";
LABEL_33:
      int v9 = v5;
      uint32_t v10 = 12;
      goto LABEL_34;
    }
    goto LABEL_35;
  }
  int v11 = DERDecoderParseSequence();
  if (v11)
  {
    int v12 = v11;
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v12 + 1) > 8) {
        uint64_t v13 = "DERDecoderError(Unknown)";
      }
      else {
        uint64_t v13 = off_101A02BA0[v12 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint64_t v23 = v13;
      uint64_t v8 = "Parse failure (ProfileResponse: %s";
      goto LABEL_33;
    }
LABEL_35:
    LOBYTE(v17) = 1;
    return v17;
  }
  int DataWithTag = DERDecoderGetDataWithTag();
  if (DataWithTag)
  {
    int v15 = DataWithTag;
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v15 + 1) > 8) {
        unint64_t v16 = "DERDecoderError(Unknown)";
      }
      else {
        unint64_t v16 = off_101A02BA0[v15 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint64_t v23 = v16;
      uint64_t v8 = "Get data with tag failure (ProfileResult: %s)";
      goto LABEL_33;
    }
    goto LABEL_35;
  }
  int v17 = **(unsigned char **)&v21[4];
  switch(**(unsigned char **)&v21[4])
  {
    case 0:
      return v17;
    case 1:
      LOBYTE(v17) = 25;
      break;
    case 2:
      if (a2 == 1) {
        LOBYTE(v17) = 26;
      }
      else {
        LOBYTE(v17) = 27;
      }
      break;
    case 3:
      LOBYTE(v17) = 28;
      break;
    case 4:
      if (a2) {
        goto LABEL_29;
      }
      LOBYTE(v17) = 29;
      break;
    default:
      if (v17 != 127)
      {
LABEL_29:
        sub_100746E04();
        uint64_t v18 = qword_101B0D628;
        if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
          goto LABEL_35;
        }
        int v19 = **(unsigned char **)&v21[4];
        *(_DWORD *)int buf = 67109120;
        LODWORD(v23) = v19;
        uint64_t v8 = "Invalid data (ProfileResult): %d";
        int v9 = v18;
        uint32_t v10 = 8;
        goto LABEL_34;
      }
      LOBYTE(v17) = 30;
      break;
  }
  return v17;
}

uint64_t sub_100751D1C(uint64_t *a1)
{
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v24 = 0;
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  int v23 = v2 - *a1;
  int v21 = 0;
  int v22 = 0;
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v20 = 0;
  memset(&__str, 0, sizeof(__str));
  long long __p = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  __int16 v13 = 0;
  if (v2 == v1)
  {
    sub_100746E04();
    int v4 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = (const char *)(a1[1] - *a1);
      int buf = 134217984;
      unint64_t v30 = v7;
      uint64_t v8 = "Invalid parameter size: %lu";
LABEL_17:
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&buf, 0xCu);
    }
  }
  else
  {
    int v3 = DERDecoderInitialize();
    if (v3)
    {
      sub_100746E04();
      int v4 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v3 + 1) > 8) {
          uint64_t v5 = "DERDecoderError(Unknown)";
        }
        else {
          uint64_t v5 = off_101A02BA0[v3 + 1];
        }
        int buf = 136315138;
        unint64_t v30 = v5;
        uint64_t v8 = "Initialize failure (NotificationListRsp): %s";
        goto LABEL_17;
      }
    }
    else
    {
      int v9 = DERDecoderParseSequence();
      if (!v9)
      {
        uint64_t v11 = 0;
        goto LABEL_19;
      }
      sub_100746E04();
      int v4 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v9 + 1) > 8) {
          uint32_t v10 = "DERDecoderError(Unknown)";
        }
        else {
          uint32_t v10 = off_101A02BA0[v9 + 1];
        }
        int buf = 136315138;
        unint64_t v30 = v10;
        uint64_t v8 = "Parse failure (NotificationListRsp): %s";
        goto LABEL_17;
      }
    }
  }
  uint64_t v11 = 1;
LABEL_19:
  if (SHIBYTE(v16) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (v18)
  {
    int v19 = v18;
    operator delete(v18);
  }
  return v11;
}

void sub_1007523D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a27) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

void sub_100752444(void *a1, _OWORD *a2)
{
  uint64_t v2 = (char *)a2;
  int v4 = (char *)*a1;
  unint64_t v5 = a1[1];
  uint64_t v6 = (uint64_t)a2 - *a1;
  int64_t v7 = 0xCCCCCCCCCCCCCCCDLL * (v6 >> 4);
  int v9 = a1 + 2;
  unint64_t v8 = a1[2];
  if (v5 >= v8)
  {
    unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - (void)v4) >> 4) + 1;
    if (v16 > 0x333333333333333) {
      sub_10006A748();
    }
    unint64_t v17 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v8 - (void)v4) >> 4);
    if (2 * v17 > v16) {
      unint64_t v16 = 2 * v17;
    }
    if (v17 >= 0x199999999999999) {
      unint64_t v18 = 0x333333333333333;
    }
    else {
      unint64_t v18 = v16;
    }
    BOOL v62 = v9;
    if (v18) {
      unint64_t v18 = (unint64_t)sub_1007551D4(v18);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v20 = (_OWORD *)(v18 + 16 * (v6 >> 4));
    uint64_t v59 = (char *)v18;
    *(void *)&long long v60 = v20;
    *((void *)&v60 + 1) = v20;
    uint64_t v61 = (char *)(v18 + 80 * v19);
    int v21 = v20;
    if (v7 == v19)
    {
      if (v6 < 1)
      {
        if (v4 == v2) {
          unint64_t v37 = 1;
        }
        else {
          unint64_t v37 = 0x999999999999999ALL * (v6 >> 4);
        }
        *((void *)&v65 + 1) = v9;
        unint64_t v38 = (char *)sub_1007551D4(v37);
        uint64_t v40 = v60;
        if (*((void *)&v60 + 1) == (void)v60)
        {
          int64x2_t v45 = vdupq_n_s64(v60);
          uint64_t v41 = (uint64_t)&v38[80 * (v37 >> 2)];
        }
        else
        {
          uint64_t v41 = (uint64_t)&v38[80 * (v37 >> 2) + *((void *)&v60 + 1) - v60];
          size_t v42 = &v38[80 * (v37 >> 2)];
          do
          {
            *(void *)size_t v42 = 0;
            *((void *)v42 + 1) = 0;
            *((void *)v42 + 2) = 0;
            *(_OWORD *)size_t v42 = *(_OWORD *)v40;
            *((void *)v42 + 2) = *(void *)(v40 + 16);
            *(void *)uint64_t v40 = 0;
            *(void *)(v40 + 8) = 0;
            *(void *)(v40 + 16) = 0;
            long long v43 = *(_OWORD *)(v40 + 24);
            *((void *)v42 + 5) = *(void *)(v40 + 40);
            *(_OWORD *)(v42 + 24) = v43;
            *(void *)(v40 + 32) = 0;
            *(void *)(v40 + 40) = 0;
            *(void *)(v40 + 24) = 0;
            long long v44 = *(_OWORD *)(v40 + 48);
            *((void *)v42 + 8) = *(void *)(v40 + 64);
            *((_OWORD *)v42 + 3) = v44;
            *(void *)(v40 + 56) = 0;
            *(void *)(v40 + 64) = 0;
            *(void *)(v40 + 48) = 0;
            *((_WORD *)v42 + 36) = *(_WORD *)(v40 + 72);
            v42 += 80;
            v40 += 80;
          }
          while (v42 != (char *)v41);
          int64x2_t v45 = (int64x2_t)v60;
        }
        char v46 = v61;
        BOOL v63 = v59;
        uint64_t v59 = v38;
        *(void *)&long long v60 = &v38[80 * (v37 >> 2)];
        int64x2_t v64 = v45;
        *((void *)&v60 + 1) = v41;
        uint64_t v61 = &v38[80 * v39];
        *(void *)&long long v65 = v46;
        sub_10075521C((uint64_t)&v63);
        int v21 = (_OWORD *)*((void *)&v60 + 1);
        uint64_t v20 = (_OWORD *)v60;
      }
      else
      {
        uint64_t v22 = v7 + 2;
        if (v7 >= -1) {
          uint64_t v22 = v7 + 1;
        }
        v20 -= 5 * (v22 >> 1);
        int v21 = v20;
      }
    }
    _OWORD *v21 = 0u;
    v21[1] = 0u;
    uint64_t v21[3] = 0u;
    void v21[4] = 0u;
    v21[2] = 0u;
    unsigned int v47 = v21 + 5;
    *((void *)&v60 + 1) = v47;
    uint64_t v48 = (char *)*a1;
    if ((char *)*a1 != v2)
    {
      unint64_t v49 = 0;
      do
      {
        uint64_t v50 = &v20[v49 / 0x10];
        uint32_t v51 = &v2[v49];
        *((void *)v50 - 10) = 0;
        *((void *)v50 - 9) = 0;
        *((void *)v50 - 8) = 0;
        *(v50 - 5) = *(_OWORD *)&v2[v49 - 80];
        *((void *)v50 - 8) = *(void *)&v2[v49 - 64];
        *((void *)v51 - 10) = 0;
        *((void *)v51 - 9) = 0;
        *((void *)v51 - 8) = 0;
        long long v52 = *(_OWORD *)&v2[v49 - 56];
        *((void *)v50 - 5) = *(void *)&v2[v49 - 40];
        *(_OWORD *)((char *)v50 - 56) = v52;
        *((void *)v51 - 6) = 0;
        *((void *)v51 - 5) = 0;
        *((void *)v51 - 7) = 0;
        long long v53 = *(_OWORD *)&v2[v49 - 32];
        *((void *)v50 - 2) = *(void *)&v2[v49 - 16];
        *(v50 - 2) = v53;
        *((void *)v51 - 3) = 0;
        *((void *)v51 - 2) = 0;
        *((void *)v51 - 4) = 0;
        *((_WORD *)v50 - 4) = *(_WORD *)&v2[v49 - 8];
        v49 -= 80;
      }
      while (&v2[v49] != v48);
      unsigned int v47 = (_OWORD *)*((void *)&v60 + 1);
      uint64_t v20 = (_OWORD *)((char *)v20 + v49);
    }
    *(void *)&long long v60 = v20;
    unsigned int v54 = (char *)a1[1];
    if (v54 != v2)
    {
      do
      {
        *(void *)unsigned int v47 = 0;
        *((void *)v47 + 1) = 0;
        *((void *)v47 + 2) = 0;
        *unsigned int v47 = *(_OWORD *)v2;
        *((void *)v47 + 2) = *((void *)v2 + 2);
        *(void *)uint64_t v2 = 0;
        *((void *)v2 + 1) = 0;
        *((void *)v2 + 2) = 0;
        long long v55 = *(_OWORD *)(v2 + 24);
        *((void *)v47 + 5) = *((void *)v2 + 5);
        *(_OWORD *)((char *)v47 + 24) = v55;
        *((void *)v2 + 4) = 0;
        *((void *)v2 + 5) = 0;
        *((void *)v2 + 3) = 0;
        long long v56 = *((_OWORD *)v2 + 3);
        *((void *)v47 + 8) = *((void *)v2 + 8);
        void v47[3] = v56;
        *((void *)v2 + 7) = 0;
        *((void *)v2 + 8) = 0;
        *((void *)v2 + 6) = 0;
        *((_WORD *)v47 + 36) = *((_WORD *)v2 + 36);
        v47 += 5;
        v2 += 80;
      }
      while (v2 != v54);
      uint64_t v20 = (_OWORD *)v60;
      uint64_t v2 = (char *)a1[1];
    }
    unsigned int v57 = (char *)*a1;
    *a1 = v20;
    a1[1] = v47;
    unsigned int v58 = (char *)a1[2];
    a1[2] = v61;
    *((void *)&v60 + 1) = v2;
    uint64_t v61 = v58;
    uint64_t v59 = v57;
    *(void *)&long long v60 = v57;
    sub_10075521C((uint64_t)&v59);
  }
  else if (a2 == (_OWORD *)v5)
  {
    a2[3] = 0uLL;
    a2[4] = 0uLL;
    a2[1] = 0uLL;
    a2[2] = 0uLL;
    *a2 = 0uLL;
    a1[1] = a2 + 5;
  }
  else
  {
    long long v65 = 0uLL;
    memset(v66, 0, sizeof(v66));
    uint64_t v67 = 0;
    long long v68 = a1 + 2;
    uint32_t v10 = a2 + 5;
    unint64_t v11 = v5 - 80;
    if (v5 < 0x50)
    {
      unint64_t v13 = v5;
    }
    else
    {
      unint64_t v12 = v5 - 80;
      unint64_t v13 = v5;
      do
      {
        *(void *)unint64_t v13 = 0;
        *(void *)(v13 + 8) = 0;
        *(void *)(v13 + 16) = 0;
        *(_OWORD *)unint64_t v13 = *(_OWORD *)v12;
        *(void *)(v13 + 16) = *(void *)(v12 + 16);
        *(void *)unint64_t v12 = 0;
        *(void *)(v12 + 8) = 0;
        *(void *)(v12 + 16) = 0;
        long long v14 = *(_OWORD *)(v12 + 24);
        *(void *)(v13 + 40) = *(void *)(v12 + 40);
        *(_OWORD *)(v13 + 24) = v14;
        *(void *)(v12 + 32) = 0;
        *(void *)(v12 + 40) = 0;
        *(void *)(v12 + 24) = 0;
        long long v15 = *(_OWORD *)(v12 + 48);
        *(void *)(v13 + 64) = *(void *)(v12 + 64);
        *(_OWORD *)(v13 + 48) = v15;
        *(void *)(v12 + 56) = 0;
        *(void *)(v12 + 64) = 0;
        *(void *)(v12 + 48) = 0;
        *(_WORD *)(v13 + 72) = *(_WORD *)(v12 + 72);
        v13 += 80;
        v12 += 80;
      }
      while (v12 < v5);
    }
    a1[1] = v13;
    if ((_OWORD *)v5 != v10)
    {
      uint64_t v23 = 0;
      uint64_t v24 = -16 * ((uint64_t)(v5 - (void)v10) >> 4);
      do
      {
        uint64_t v25 = v11 + v23;
        uint64_t v26 = v5 + v23;
        sub_10005C9A4(v5 + v23 - 80, (__n128 *)(v11 + v23 - 80));
        uint64_t v27 = (void **)(v5 + v23 - 56);
        if (*(char *)(v5 + v23 - 33) < 0) {
          operator delete(*v27);
        }
        long long v28 = *(_OWORD *)(v25 - 56);
        *(void *)(v26 - 40) = *(void *)(v25 - 40);
        *(_OWORD *)uint64_t v27 = v28;
        *(unsigned char *)(v25 - 33) = 0;
        *(unsigned char *)(v25 - 56) = 0;
        unint64_t v29 = (void **)(v26 - 32);
        if (*(char *)(v26 - 9) < 0) {
          operator delete(*v29);
        }
        uint64_t v30 = v11 + v23;
        long long v31 = *(_OWORD *)(v11 + v23 - 32);
        *(void *)(v26 - 16) = *(void *)(v11 + v23 - 16);
        *(_OWORD *)unint64_t v29 = v31;
        *(unsigned char *)(v30 - 9) = 0;
        *(unsigned char *)(v30 - 32) = 0;
        *(_WORD *)(v5 + v23 - 8) = *(_WORD *)(v11 + v23 - 8);
        v23 -= 80;
      }
      while (v24 != v23);
    }
    uint64_t v32 = *(void **)v2;
    if (*(void *)v2)
    {
      *((void *)v2 + 1) = v32;
      operator delete(v32);
      *(void *)uint64_t v2 = 0;
      *((void *)v2 + 1) = 0;
      *((void *)v2 + 2) = 0;
    }
    *(void *)uint64_t v2 = 0;
    *((void *)v2 + 1) = 0;
    *((void *)v2 + 2) = 0;
    BOOL v63 = 0;
    int64x2_t v64 = 0uLL;
    unsigned int v33 = (void **)&v4[80 * v7 + 24];
    if (v2[47] < 0) {
      operator delete(*v33);
    }
    long long v34 = v65;
    *(void *)&v4[80 * v7 + 40] = *(void *)&v66[0];
    *(_OWORD *)unsigned int v33 = v34;
    BYTE7(v66[0]) = 0;
    LOBYTE(v65) = 0;
    char v35 = (void **)&v4[80 * v7 + 48];
    if (v2[71] < 0) {
      operator delete(*v35);
    }
    long long v36 = *(_OWORD *)((char *)v66 + 8);
    *(void *)&v4[80 * v7 + 64] = *((void *)&v66[1] + 1);
    *(_OWORD *)char v35 = v36;
    HIBYTE(v66[1]) = 0;
    BYTE8(v66[0]) = 0;
    *(_WORD *)&v4[80 * v7 + 72] = 0;
    sub_10075516C((uint64_t)&v63);
  }
}

void sub_1007529AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_1007529C0(char **a1, uint64_t a2)
{
  int v4 = *a1;
  int v3 = a1[1];
  if (v3 == *a1)
  {
    sub_100746E04();
    uint64_t v6 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      int64_t v8 = a1[1] - *a1;
      int v9 = 134217984;
      int64_t v10 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Invalid parameter size (VinylReceiptId): %lu", (uint8_t *)&v9, 0xCu);
    }
  }
  else
  {
    LOWORD(v9) = 11199;
    BYTE2(v9) = (_BYTE)v3 - (_BYTE)v4 + 4;
    HIBYTE(v9) = -96;
    LOBYTE(v10) = (_BYTE)v3 - (_BYTE)v4 + 2;
    BYTE1(v10) = 0x80;
    BYTE2(v10) = (_BYTE)v3 - (_BYTE)v4;
    sub_10006E4A8((void *)a2, (char *)&v9, (char *)&v10 + 3, 7uLL);
    sub_10005C748(a2, *(char **)(a2 + 8), *a1, a1[1], a1[1] - *a1);
  }
  return v3 != v4;
}

uint64_t sub_100752AF0(void *a1, void *a2)
{
  *(_DWORD *)&v22[8] = 0;
  uint64_t v3 = a1[1];
  *(void *)uint64_t v22 = v3 - *a1;
  if (v3 == *a1)
  {
    sub_100746E04();
    unint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = a1[1] - *a1;
      *(_DWORD *)int buf = 134217984;
      v24[0] = v8;
      int v9 = "Invalid parameter size: %lu";
LABEL_33:
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
    }
    return 1;
  }
  int v4 = DERDecoderInitialize();
  if (v4)
  {
    sub_100746E04();
    unint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v4 + 1) > 8) {
        uint64_t v6 = "DERDecoderError(Unknown)";
      }
      else {
        uint64_t v6 = off_101A02BA0[v4 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      v24[0] = v6;
      int v9 = "Initialize failure (GetNotificationRsp): %s";
      goto LABEL_33;
    }
    return 1;
  }
  int v10 = DERDecoderParseSequence();
  if (v10)
  {
    sub_100746E04();
    unint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v10 + 1) > 8) {
        unint64_t v11 = "DERDecoderError(Unknown)";
      }
      else {
        unint64_t v11 = off_101A02BA0[v10 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      v24[0] = v11;
      int v9 = "Parse failure (GetNotificationRsp): %s";
      goto LABEL_33;
    }
    return 1;
  }
  int DataAt = DERDecoderGetDataAt();
  if (DataAt)
  {
    sub_100746E04();
    unint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((DataAt + 1) > 8) {
        unint64_t v13 = "DERDecoderError(Unknown)";
      }
      else {
        unint64_t v13 = off_101A02BA0[DataAt + 1];
      }
      *(_DWORD *)int buf = 136315138;
      v24[0] = v13;
      int v9 = "Get data failure (GetNotificationRsp): %s";
      goto LABEL_33;
    }
    return 1;
  }
  if (*(_DWORD *)v22 < 3u) {
    return 0;
  }
  int v15 = DERDecoderInitialize();
  if (v15)
  {
    sub_100746E04();
    unint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v15 + 1) > 8) {
        unint64_t v16 = "DERDecoderError(Unknown)";
      }
      else {
        unint64_t v16 = off_101A02BA0[v15 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      v24[0] = v16;
      int v9 = "Initialize failure (GetNotification): %s";
      goto LABEL_33;
    }
    return 1;
  }
  int EncodingAt = DERDecoderGetEncodingAt();
  if (!EncodingAt)
  {
    sub_10006E4A8(a2, *(char **)&v22[4], (char *)(*(void *)&v22[4] + *(unsigned int *)v22), *(unsigned int *)v22);
    return 0;
  }
  unint64_t v18 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "vinyl.helper");
  uint64_t v19 = *(NSObject **)((char *)v24 + 4);
  ctu::OsLogContext::~OsLogContext(v18);
  uint64_t v14 = 1;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
  {
    if ((EncodingAt + 1) > 8) {
      uint64_t v20 = "DERDecoderError(Unknown)";
    }
    else {
      uint64_t v20 = off_101A02BA0[EncodingAt + 1];
    }
    *(_DWORD *)int buf = 136315138;
    v24[0] = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Get encoding failure (GetNotificaiton): %s", buf, 0xCu);
  }
  return v14;
}

BOOL sub_100752FBC(char **a1, uint64_t a2)
{
  int v4 = *a1;
  uint64_t v3 = a1[1];
  if (v3 == *a1)
  {
    sub_100746E04();
    uint64_t v6 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      int64_t v8 = a1[1] - *a1;
      int v9 = 134217984;
      int64_t v10 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Invalid parameter size (VinylReceiptId): %lu", (uint8_t *)&v9, 0xCu);
    }
  }
  else
  {
    LOWORD(v9) = 12479;
    BYTE2(v9) = (_BYTE)v3 - (_BYTE)v4 + 2;
    HIBYTE(v9) = 0x80;
    LOBYTE(v10) = (_BYTE)v3 - (_BYTE)v4;
    sub_10006E4A8((void *)a2, (char *)&v9, (char *)&v10 + 1, 5uLL);
    sub_10005C748(a2, *(char **)(a2 + 8), *a1, a1[1], a1[1] - *a1);
  }
  return v3 != v4;
}

uint64_t sub_1007530DC(uint64_t a1)
{
  *(_DWORD *)&v17[8] = 0;
  *(void *)unint64_t v17 = *(_DWORD *)(a1 + 8) - *(void *)a1;
  if (!*(_DWORD *)v17)
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      uint64_t v6 = "Empty Response";
      int64_t v7 = v5;
      uint32_t v8 = 2;
LABEL_26:
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
      goto LABEL_27;
    }
    goto LABEL_27;
  }
  int v1 = DERDecoderInitialize();
  if (v1)
  {
    int v2 = v1;
    sub_100746E04();
    uint64_t v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v2 + 1) > 8) {
        int v4 = "DERDecoderError(Unknown)";
      }
      else {
        int v4 = off_101A02BA0[v2 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint64_t v19 = v4;
      uint64_t v6 = "Initialize failure (RemoveNotificationRsp): %s";
LABEL_25:
      int64_t v7 = v3;
      uint32_t v8 = 12;
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  int v9 = DERDecoderParseSequence();
  if (v9)
  {
    int v10 = v9;
    sub_100746E04();
    uint64_t v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v10 + 1) > 8) {
        unint64_t v11 = "DERDecoderError(Unknown)";
      }
      else {
        unint64_t v11 = off_101A02BA0[v10 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint64_t v19 = v11;
      uint64_t v6 = "Parse failure (RemoveNotificationRsp): %s";
      goto LABEL_25;
    }
LABEL_27:
    LOBYTE(v15) = 1;
    return v15;
  }
  int DataWithTag = DERDecoderGetDataWithTag();
  if (DataWithTag)
  {
    int v13 = DataWithTag;
    sub_100746E04();
    uint64_t v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v13 + 1) > 8) {
        uint64_t v14 = "DERDecoderError(Unknown)";
      }
      else {
        uint64_t v14 = off_101A02BA0[v13 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint64_t v19 = v14;
      uint64_t v6 = "Get data with tag failure (RemoveNotificationResult): %s";
      goto LABEL_25;
    }
    goto LABEL_27;
  }
  unsigned int v15 = 0x90800u >> (8 * **(unsigned char **)&v17[4]);
  if (**(unsigned char **)&v17[4] > 2u) {
    LOBYTE(v15) = 1;
  }
  return v15;
}

uint64_t sub_100753368(uint64_t a1)
{
  *(_DWORD *)&v18[8] = 0;
  *(void *)unint64_t v18 = *(_DWORD *)(a1 + 8) - *(void *)a1;
  if (!*(_DWORD *)v18)
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      return 1;
    }
    *(_WORD *)int buf = 0;
    uint64_t v6 = "Empty Response";
    int64_t v7 = v5;
    uint32_t v8 = 2;
    goto LABEL_34;
  }
  int v1 = DERDecoderInitialize();
  if (v1)
  {
    int v2 = v1;
    sub_100746E04();
    uint64_t v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v2 + 1) > 8) {
        int v4 = "DERDecoderError(Unknown)";
      }
      else {
        int v4 = off_101A02BA0[v2 + 1];
      }
      *(_DWORD *)int buf = 136315138;
      uint64_t v20 = v4;
      uint64_t v6 = "Initialize failure (MemoryResetRsp): %s";
LABEL_33:
      int64_t v7 = v3;
      uint32_t v8 = 12;
      goto LABEL_34;
    }
    return 1;
  }
  int v9 = DERDecoderParseSequence();
  if (!v9)
  {
    int DataWithTag = DERDecoderGetDataWithTag();
    if (DataWithTag)
    {
      int v13 = DataWithTag;
      sub_100746E04();
      uint64_t v3 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if ((v13 + 1) > 8) {
          uint64_t v14 = "DERDecoderError(Unknown)";
        }
        else {
          uint64_t v14 = off_101A02BA0[v13 + 1];
        }
        *(_DWORD *)int buf = 136315138;
        uint64_t v20 = v14;
        uint64_t v6 = "Get data with tag failure (MemoryResetResult): %s";
        goto LABEL_33;
      }
      return 1;
    }
    if (*(_DWORD *)v18 == 1)
    {
      uint64_t result = **(unsigned char **)&v18[4];
      if (!**(unsigned char **)&v18[4]) {
        return result;
      }
      if (result == 127) {
        return 30;
      }
      if (result == 1) {
        return 8;
      }
      sub_100746E04();
      uint64_t v16 = qword_101B0D628;
      if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
        return 1;
      }
      int v17 = **(unsigned char **)&v18[4];
      *(_DWORD *)int buf = 67109120;
      LODWORD(v20) = v17;
      uint64_t v6 = "Invalid data (MemoryResetResult): %d";
    }
    else
    {
      sub_100746E04();
      uint64_t v16 = qword_101B0D628;
      if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
        return 1;
      }
      *(_DWORD *)int buf = 67109120;
      LODWORD(v20) = *(_DWORD *)v18;
      uint64_t v6 = "Invalid length (MemoryResetResult): %d";
    }
    int64_t v7 = v16;
    uint32_t v8 = 8;
LABEL_34:
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    return 1;
  }
  int v10 = v9;
  sub_100746E04();
  uint64_t v3 = qword_101B0D628;
  if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
  {
    if ((v10 + 1) > 8) {
      unint64_t v11 = "DERDecoderError(Unknown)";
    }
    else {
      unint64_t v11 = off_101A02BA0[v10 + 1];
    }
    *(_DWORD *)int buf = 136315138;
    uint64_t v20 = v11;
    uint64_t v6 = "Parse failure (MemoryResetRsp): %s";
    goto LABEL_33;
  }
  return 1;
}

BOOL sub_10075369C(char **a1, uint64_t a2)
{
  int64_t v3 = a1[1] - *a1;
  if (v3 == 16)
  {
    int v8 = 268702256;
    sub_10006E4A8((void *)a2, (char *)&v8, (char *)&v9, 4uLL);
    sub_10005C748(a2, *(char **)(a2 + 8), *a1, a1[1], a1[1] - *a1);
  }
  else
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      int64_t v7 = a1[1] - *a1;
      int v8 = 134217984;
      int64_t v9 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid length (transactionId): %lu", (uint8_t *)&v8, 0xCu);
    }
  }
  return v3 == 16;
}

BOOL sub_1007537AC(uint64_t a1)
{
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v12 = 0;
  unsigned int v11 = *(_DWORD *)(a1 + 8) - *(void *)a1;
  if (v11 < 3) {
    return 1;
  }
  int v10 = 0;
  int v2 = DERDecoderInitialize();
  if (v2)
  {
    sub_100746E04();
    int64_t v3 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if ((v2 + 1) > 8) {
      int v4 = "DERDecoderError(Unknown)";
    }
    else {
      int v4 = off_101A02BA0[v2 + 1];
    }
    int buf = 136315138;
    *(void *)buf_4 = v4;
    int64_t v9 = "Initialize failure (GetSessionData): %s";
    goto LABEL_22;
  }
  int v5 = DERDecoderParseSequence();
  if (v5)
  {
    sub_100746E04();
    int64_t v3 = qword_101B0D628;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if ((v5 + 1) > 8) {
      uint64_t v6 = "DERDecoderError(Unknown)";
    }
    else {
      uint64_t v6 = off_101A02BA0[v5 + 1];
    }
    int buf = 136315138;
    *(void *)buf_4 = v6;
    int64_t v9 = "Parse failure (GetSessionData): %s";
    goto LABEL_22;
  }
  int Count = DERDecoderGetCount();
  if (!Count) {
    return 1;
  }
  sub_100746E04();
  int64_t v3 = qword_101B0D628;
  BOOL result = os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR);
  if (result)
  {
    if ((Count + 1) > 8) {
      int v8 = "DERDecoderError(Unknown)";
    }
    else {
      int v8 = off_101A02BA0[Count + 1];
    }
    int buf = 136315138;
    *(void *)buf_4 = v8;
    int64_t v9 = "Count failure (SessionInfo): %s";
LABEL_22:
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&buf, 0xCu);
    return 0;
  }
  return result;
}

void sub_100753E04(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 209) < 0) {
    operator delete(*(void **)(v1 - 232));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100753E3C(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v6 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  int64_t v7 = v6;
  if (v6) {
    *((_DWORD *)v6 + 3) = 0;
  }
  uint64_t __src = 0;
  unsigned int v33 = 0;
  uint64_t v8 = *(void *)(a1 + 8);
  if (v8 == *(void *)a1 || *(void *)(a2 + 8) == *(void *)a2)
  {
    sub_100746E04();
    uint64_t v12 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      uint64_t v19 = "Missing signing info (LPA signing key or device info)";
      uint64_t v20 = v12;
      uint32_t v21 = 2;
LABEL_44:
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
  unsigned int v9 = sub_1004632FC(v6, 0, 4u, *(const void **)a1, (int)v8 - *(_DWORD *)a1, 0);
  if (v9)
  {
    sub_100746E04();
    uint64_t v10 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v9 > 3) {
        unsigned int v11 = "DEREncoderError(Unknown)";
      }
      else {
        unsigned int v11 = off_101A02B88[v9 - 1];
      }
      *(_DWORD *)int buf = 136315138;
      long long v36 = v11;
      uint64_t v19 = "Add data failure (eUicciPKId): %s";
LABEL_43:
      uint64_t v20 = v10;
      uint32_t v21 = 12;
      goto LABEL_44;
    }
    goto LABEL_10;
  }
  char v32 = 11;
  unsigned int v15 = sub_1004632FC(v7, 0, 4u, &v32, 1u, 0);
  if (v15)
  {
    sub_100746E04();
    uint64_t v10 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v15 > 3) {
        uint64_t v16 = "DEREncoderError(Unknown)";
      }
      else {
        uint64_t v16 = off_101A02B88[v15 - 1];
      }
      *(_DWORD *)int buf = 136315138;
      long long v36 = v16;
      uint64_t v19 = "Add data failure (SigningMode): %s";
      goto LABEL_43;
    }
LABEL_10:
    uint64_t v13 = 0;
    goto LABEL_11;
  }
  unsigned int v17 = sub_1004632FC(v7, 0, 0x10u, *(const void **)a2, *(_DWORD *)(a2 + 8) - *(void *)a2, 1);
  if (v17)
  {
    sub_100746E04();
    uint64_t v10 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if (v17 > 3) {
        unint64_t v18 = "DEREncoderError(Unknown)";
      }
      else {
        unint64_t v18 = off_101A02B88[v17 - 1];
      }
      *(_DWORD *)int buf = 136315138;
      long long v36 = v18;
      uint64_t v19 = "Add data failure (DeviceInfoMetadata): %s";
      goto LABEL_43;
    }
    goto LABEL_10;
  }
  uint64_t v22 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  uint64_t v23 = v22;
  if (v22) {
    *((_DWORD *)v22 + 3) = 0;
  }
  unsigned int v24 = sub_100463720(v7, v22, 0, 0x10u);
  if (v24)
  {
    unsigned int v25 = v24;
    sub_100746E04();
    uint64_t v26 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    if (v25 > 3) {
      uint64_t v27 = "DEREncoderError(Unknown)";
    }
    else {
      uint64_t v27 = off_101A02B88[v25 - 1];
    }
    *(_DWORD *)int buf = 136315138;
    long long v36 = v27;
    uint64_t v30 = "Add sequence from encoder failure (payload): %s";
    goto LABEL_51;
  }
  unsigned int v28 = sub_100463664(v23, &__src, &v33);
  if (v28)
  {
    unsigned int v29 = v28;
    sub_100746E04();
    uint64_t v26 = qword_101B0D628;
    if (!os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    if (v29 > 3) {
      long long v31 = "DEREncoderError(Unknown)";
    }
    else {
      long long v31 = off_101A02B88[v29 - 1];
    }
    *(_DWORD *)int buf = 136315138;
    long long v36 = v31;
    uint64_t v30 = "Buffer creation failure (EncodeBirchSignPayload): %s";
LABEL_51:
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, v30, buf, 0xCu);
LABEL_31:
    uint64_t v13 = 0;
    if (!v23) {
      goto LABEL_11;
    }
    goto LABEL_32;
  }
  a3[1] = *a3;
  if (__src)
  {
    sub_1003F0208(a3, v33);
    sub_10006E4A8(a3, (char *)__src, (char *)__src + v33, v33);
    free(__src);
  }
  uint64_t v13 = 1;
  if (v23) {
LABEL_32:
  }
    sub_100463290(v23);
LABEL_11:
  if (v7) {
    sub_100463290(v7);
  }
  return v13;
}

void sub_100754270(_Unwind_Exception *exception_object)
{
  if (v2) {
    sub_100463290(v2);
  }
  if (v1) {
    sub_100463290(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1007542B8(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  BOOL v63 = 0;
  int64x2_t v64 = 0;
  uint64_t v65 = 0;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a1;
    uint64_t v62 = *(void *)(a1 + 16);
  }
  subscriber::encodeIccid();
  if (SHIBYTE(v62) < 0) {
    operator delete(__p[0]);
  }
  unsigned int v58 = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    int64_t v7 = (char *)a2;
  }
  else {
    int64_t v7 = *(char **)a2;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a2 + 8);
  }
  sub_10075526C(&v58, v7, &v7[v8], v8);
  if (v63 != v64)
  {
    unsigned int v9 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
    uint64_t v10 = v9;
    if (v9) {
      *((_DWORD *)v9 + 3) = 0;
    }
    unsigned int v11 = sub_1004632FC(v9, 1, 0x1Au, v63, (int)v64 - (int)v63, 0);
    if (v11)
    {
      sub_100746E04();
      uint64_t v12 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if (v11 > 3) {
          unsigned int v29 = "DEREncoderError(Unknown)";
        }
        else {
          unsigned int v29 = off_101A02B88[v11 - 1];
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v29;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Add data failure (ICCID): %s", (uint8_t *)&buf, 0xCu);
      }
      BOOL v13 = 0;
LABEL_59:
      if (v10) {
        sub_100463290(v10);
      }
      goto LABEL_61;
    }
    unsigned int v15 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
    uint64_t v16 = v15;
    if (v15) {
      *((_DWORD *)v15 + 3) = 0;
    }
    unsigned int v17 = sub_100463720(v10, v15, 2, 0);
    if (v17)
    {
      unsigned int v18 = v17;
      sub_100746E04();
      uint64_t v19 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if (v18 > 3) {
          char v35 = "DEREncoderError(Unknown)";
        }
        else {
          char v35 = off_101A02B88[v18 - 1];
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v35;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Add data failure outer (ICCID): %s", (uint8_t *)&buf, 0xCu);
      }
      BOOL v13 = 0;
LABEL_57:
      if (v16) {
        sub_100463290(v16);
      }
      goto LABEL_59;
    }
    uint64_t v20 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
    uint32_t v21 = v20;
    if (v20) {
      *((_DWORD *)v20 + 3) = 0;
    }
    unsigned int v22 = sub_1004632FC(v20, 2, 0, v58, (int)v59 - (int)v58, 0);
    if (v22)
    {
      sub_100746E04();
      uint64_t v23 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if (v22 > 3) {
          uint64_t v39 = "DEREncoderError(Unknown)";
        }
        else {
          uint64_t v39 = off_101A02B88[v22 - 1];
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v39;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Add data failure (IMEI): %s", (uint8_t *)&buf, 0xCu);
      }
      BOOL v13 = 0;
LABEL_55:
      if (v21) {
        sub_100463290(v21);
      }
      goto LABEL_57;
    }
    unsigned int v24 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
    unsigned int v25 = v24;
    if (v24) {
      *((_DWORD *)v24 + 3) = 0;
    }
    unsigned int v26 = sub_100463720(v21, v24, 3, 1u);
    if (v26)
    {
      unsigned int v27 = v26;
      sub_100746E04();
      unsigned int v28 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if (v27 > 3) {
          long long v44 = "DEREncoderError(Unknown)";
        }
        else {
          long long v44 = off_101A02B88[v27 - 1];
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v44;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Add data failure outer (IMEI): %s", (uint8_t *)&buf, 0xCu);
      }
      BOOL v13 = 0;
LABEL_53:
      if (v25) {
        sub_100463290(v25);
      }
      goto LABEL_55;
    }
    long long buf = 0uLL;
    uint64_t v69 = 0;
    unsigned int v57 = 0;
    unsigned int v56 = 0;
    unsigned int v31 = sub_100463664(v16, &v57, &v56);
    if (v31)
    {
      unsigned int v32 = v31;
      sub_100746E04();
      unsigned int v33 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if (v32 > 3) {
          long long v34 = "DEREncoderError(Unknown)";
        }
        else {
          long long v34 = off_101A02B88[v32 - 1];
        }
        *(_DWORD *)long long v66 = 136315138;
        uint64_t v67 = v34;
        unint64_t v49 = "Buffer creation failure outer (ICCID): %s";
LABEL_100:
        _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, v49, v66, 0xCu);
        goto LABEL_50;
      }
      goto LABEL_50;
    }
    uint64_t __src = 0;
    unsigned int v54 = 0;
    unsigned int v36 = sub_100463664(v25, &__src, &v54);
    if (v36)
    {
      unsigned int v37 = v36;
      sub_100746E04();
      unsigned int v33 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if (v37 > 3) {
          uint64_t v50 = "DEREncoderError(Unknown)";
        }
        else {
          uint64_t v50 = off_101A02B88[v37 - 1];
        }
        *(_DWORD *)long long v66 = 136315138;
        uint64_t v67 = v50;
        unint64_t v49 = "Buffer creation failure outer (IMEI): %s";
        goto LABEL_100;
      }
LABEL_50:
      BOOL v13 = 0;
      goto LABEL_51;
    }
    *((void *)&buf + 1) = buf;
    sub_1003F0208((unint64_t *)&buf, v54 + v56);
    if (v57)
    {
      sub_10006E4A8(&buf, (char *)v57, (char *)v57 + v56, v56);
      free(v57);
    }
    if (__src)
    {
      sub_100754F40((uint64_t)&buf, *((char **)&buf + 1), (char *)__src, (char *)__src + v54, v54);
      free(__src);
    }
    uint64_t v40 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
    uint64_t v41 = v40;
    if (v40) {
      *((_DWORD *)v40 + 3) = 0;
    }
    unsigned int v42 = sub_1004632FC(v40, 3, 0x29u, (const void *)buf, DWORD2(buf) - (int)buf, 1);
    if (v42)
    {
      sub_100746E04();
      long long v43 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if (v42 > 3) {
          uint32_t v51 = "DEREncoderError(Unknown)";
        }
        else {
          uint32_t v51 = off_101A02B88[v42 - 1];
        }
        *(_DWORD *)long long v66 = 136315138;
        uint64_t v67 = v51;
        _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Add data failure outermost (ICCID+IMEI): %s", v66, 0xCu);
      }
      BOOL v13 = 0;
      if (!v41) {
        goto LABEL_51;
      }
      goto LABEL_93;
    }
    long long v53 = 0;
    unsigned int v52 = 0;
    unsigned int v45 = sub_100463664(v41, &v53, &v52);
    BOOL v13 = v45 == 0;
    if (v45)
    {
      unsigned int v46 = v45;
      sub_100746E04();
      unsigned int v47 = qword_101B0D628;
      if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
      {
        if (v46 > 3) {
          uint64_t v48 = "DEREncoderError(Unknown)";
        }
        else {
          uint64_t v48 = off_101A02B88[v46 - 1];
        }
        *(_DWORD *)long long v66 = 136315138;
        uint64_t v67 = v48;
        _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Buffer creation failure outermost (ICCID+IMEI): %s", v66, 0xCu);
        if (!v41)
        {
LABEL_51:
          if ((void)buf)
          {
            *((void *)&buf + 1) = buf;
            operator delete((void *)buf);
          }
          goto LABEL_53;
        }
LABEL_93:
        sub_100463290(v41);
        goto LABEL_51;
      }
    }
    else
    {
      a3[1] = *a3;
      if (v53)
      {
        sub_1003F0208(a3, v52);
        sub_10006E4A8(a3, (char *)v53, (char *)v53 + v52, v52);
        free(v53);
      }
    }
    if (!v41) {
      goto LABEL_51;
    }
    goto LABEL_93;
  }
  sub_100746E04();
  uint64_t v14 = qword_101B0D628;
  if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
  {
    uint64_t v30 = *(unsigned __int8 *)(a1 + 23);
    if ((v30 & 0x80u) != 0) {
      uint64_t v30 = *(void *)(a1 + 8);
    }
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v30;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid ICCID length: %lu", (uint8_t *)&buf, 0xCu);
  }
  BOOL v13 = 0;
LABEL_61:
  if (v58)
  {
    uint64_t v59 = v58;
    operator delete(v58);
  }
  if (v63)
  {
    int64x2_t v64 = v63;
    operator delete(v63);
  }
  return v13;
}

void sub_100754AD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26)
{
  if (v30) {
    sub_100463290(v30);
  }
  unsigned int v33 = *(void **)v31;
  if (*(void *)v31)
  {
    *(void *)(v31 + 8) = v33;
    operator delete(v33);
    if (!v29)
    {
LABEL_5:
      if (!v28) {
        goto LABEL_6;
      }
      goto LABEL_11;
    }
  }
  else if (!v29)
  {
    goto LABEL_5;
  }
  sub_100463290(v29);
  if (!v28)
  {
LABEL_6:
    if (!v27) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
LABEL_11:
  sub_100463290(v28);
  if (!v27)
  {
LABEL_7:
    if (!v26)
    {
LABEL_14:
      if (__p) {
        operator delete(__p);
      }
      if (a25) {
        operator delete(a25);
      }
      _Unwind_Resume(exception_object);
    }
LABEL_13:
    sub_100463290(v26);
    goto LABEL_14;
  }
LABEL_12:
  sub_100463290(v27);
  if (!v26) {
    goto LABEL_14;
  }
  goto LABEL_13;
}

uint64_t sub_100754BE4(uint64_t a1)
{
  *(_DWORD *)&v19[8] = 0;
  *(void *)uint64_t v19 = *(_DWORD *)(a1 + 8) - *(void *)a1;
  if (!*(_DWORD *)v19)
  {
    sub_100746E04();
    uint64_t v5 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      int v6 = "Empty Response";
      int64_t v7 = v5;
      uint32_t v8 = 2;
LABEL_26:
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
      goto LABEL_27;
    }
    goto LABEL_27;
  }
  int v1 = DERDecoderInitialize();
  if (v1)
  {
    int v2 = v1;
    sub_100746E04();
    uint64_t v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v2 + 1) > 8) {
        int v4 = "DERDecoderError(Unknown)";
      }
      else {
        int v4 = off_101A02BA0[v2 + 1];
      }
      *(_DWORD *)long long buf = 136315138;
      uint32_t v21 = v4;
      int v6 = "Initialize failure (SetProprietaryDataRsp): %s";
LABEL_25:
      int64_t v7 = v3;
      uint32_t v8 = 12;
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  int v9 = DERDecoderParseSequence();
  if (v9)
  {
    int v10 = v9;
    sub_100746E04();
    uint64_t v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v10 + 1) > 8) {
        unsigned int v11 = "DERDecoderError(Unknown)";
      }
      else {
        unsigned int v11 = off_101A02BA0[v10 + 1];
      }
      *(_DWORD *)long long buf = 136315138;
      uint32_t v21 = v11;
      int v6 = "Parse failure (SetProprietaryDataRsp: %s";
      goto LABEL_25;
    }
LABEL_27:
    LOBYTE(v17) = 1;
    return v17;
  }
  int DataWithTag = DERDecoderGetDataWithTag();
  if (DataWithTag)
  {
    int v13 = DataWithTag;
    sub_100746E04();
    uint64_t v3 = qword_101B0D628;
    if (os_log_type_enabled((os_log_t)qword_101B0D628, OS_LOG_TYPE_ERROR))
    {
      if ((v13 + 1) > 8) {
        uint64_t v14 = "DERDecoderError(Unknown)";
      }
      else {
        uint64_t v14 = off_101A02BA0[v13 + 1];
      }
      *(_DWORD *)long long buf = 136315138;
      uint32_t v21 = v14;
      int v6 = "Get data with tag failure (SetProprietaryDataRsp: %s)";
      goto LABEL_25;
    }
    goto LABEL_27;
  }
  unsigned int v15 = **(unsigned char **)&v19[4];
  BOOL v16 = v15 > 3;
  unsigned int v17 = 0x131E1900u >> (8 * v15);
  if (v16) {
    LOBYTE(v17) = 30;
  }
  return v17;
}

void sub_100754E78(std::string *a1, const std::locale *a2)
{
  LODWORD(v3.__locale_) = 0x4000;
  std::locale::locale(&v4, a2);
  sub_10013EC28(a1, &v3);
  std::locale::~locale(&v4);
}

void sub_100754ECC(_Unwind_Exception *a1)
{
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100754EE0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    std::locale v4 = (void **)(i - 32);
    *(void *)(a1 + 16) = v4;
    int v6 = v4;
    sub_10016A9A4(&v6);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100754F40(uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  if (a5 < 1) {
    return;
  }
  int v10 = *(unsigned char **)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    unsigned int v11 = *(char **)a1;
    uint64_t v12 = (uint64_t)&v10[a5 - *(void *)a1];
    if (v12 < 0) {
      sub_10006A748();
    }
    int v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - (void)v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15) {
      BOOL v16 = (char *)operator new(v15);
    }
    else {
      BOOL v16 = 0;
    }
    unsigned int v26 = &v13[(void)v16];
    memcpy(&v13[(void)v16], __src, a5);
    if (v11 == __dst)
    {
      unsigned int v27 = &v13[(void)v16];
    }
    else
    {
      do
      {
        v13[(void)v16 - 1] = v13[(void)(v11 - 1)];
        --v13;
      }
      while (v13);
      int v10 = *(unsigned char **)(a1 + 8);
      unsigned int v27 = v16;
    }
    unsigned int v28 = &v26[a5];
    unsigned int v29 = &v16[v15];
    if (v10 != __dst) {
      memmove(v28, __dst, v10 - __dst);
    }
    uint64_t v30 = *(char **)a1;
    *(void *)a1 = v27;
    *(void *)(a1 + 8) = &v28[v10 - __dst];
    *(void *)(a1 + 16) = v29;
    if (v30)
    {
      operator delete(v30);
    }
    return;
  }
  uint64_t v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    unsigned int v18 = &__src[a5];
    uint64_t v20 = *(unsigned char **)(a1 + 8);
LABEL_17:
    uint32_t v21 = &__dst[a5];
    unsigned int v22 = &v20[-a5];
    uint64_t v23 = v20;
    if (&v20[-a5] < v10)
    {
      unsigned int v24 = (char *)(&v10[a5] - v20);
      uint64_t v23 = v20;
      do
      {
        char v25 = *v22++;
        *v23++ = v25;
        --v24;
      }
      while (v24);
    }
    *(void *)(a1 + 8) = v23;
    if (v20 != v21) {
      memmove(&__dst[a5], __dst, v20 - v21);
    }
    if (v18 != __src)
    {
      memmove(__dst, __src, v18 - __src);
    }
    return;
  }
  unsigned int v18 = &__src[v17];
  int64_t v19 = a4 - &__src[v17];
  if (a4 != &__src[v17]) {
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  }
  uint64_t v20 = &v10[v19];
  *(void *)(a1 + 8) = &v10[v19];
  if (v17 >= 1) {
    goto LABEL_17;
  }
}

void sub_10075516C(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  int v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

void *sub_1007551D4(unint64_t a1)
{
  if (a1 >= 0x333333333333334) {
    sub_10006A7CC();
  }
  return operator new(80 * a1);
}

uint64_t sub_10075521C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 80;
    sub_10075516C(i - 80);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_10075526C(void *result, char *__src, char *a3, unint64_t a4)
{
  int v6 = __src;
  int64_t v7 = result;
  unint64_t v8 = result[2];
  uint64_t v9 = (unsigned char *)*result;
  if (v8 - *result >= a4)
  {
    unint64_t v14 = (unsigned char *)result[1];
    if (v14 - v9 >= a4)
    {
      size_t v18 = a3 - __src;
      if (a3 != __src) {
        BOOL result = memmove((void *)*result, __src, v18);
      }
      uint64_t v12 = &v9[v18];
    }
    else
    {
      size_t v15 = &__src[v14 - v9];
      if (v14 != v9)
      {
        BOOL result = memmove((void *)*result, __src, v14 - v9);
        uint64_t v9 = (unsigned char *)v7[1];
      }
      uint64_t v12 = v9;
      if (v15 != a3)
      {
        uint64_t v12 = v9;
        BOOL v16 = v9;
        do
        {
          char v17 = *v15++;
          *v16++ = v17;
          ++v12;
        }
        while (v15 != a3);
      }
    }
  }
  else
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      sub_10006A748();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    BOOL result = sub_10005C9F8(v7, v11);
    uint64_t v12 = (unsigned char *)v7[1];
    while (v6 != a3)
    {
      char v13 = *v6++;
      *v12++ = v13;
    }
  }
  v7[1] = v12;
  return result;
}

void sub_1007553A4()
{
}

void sub_1007553FC()
{
}

void *sub_100755420(void *a1)
{
  int v2 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "abm");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, &__p);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_101A02BF8;
  uint64_t v3 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  a1[4] = dispatch_queue_create("CommCenterAbmClient", v3);
  sub_100058DB0(&__p, "CommCenter");
  abm::client::CreateManager();
  if (v6 < 0) {
    operator delete(__p.var0);
  }
  return a1;
}

void sub_10075552C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  size_t v18 = *((void *)v15 + 4);
  if (v18) {
    dispatch_release(v18);
  }
  int64_t v19 = (std::__shared_weak_count *)*((void *)v15 + 3);
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  ctu::OsLogLogger::~OsLogLogger(v16);
  AppleBasebandManagerClientInterface::~AppleBasebandManagerClientInterface(v15);
  _Unwind_Resume(a1);
}

void sub_1007555A0(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 48);
  int v2 = v1;
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  abm::client::EventsOn();
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_1007555F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100755608(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 48);
  int v2 = v1;
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  abm::client::EventsOff();
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100755658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100755670(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    uint64_t v5 = *(void *)(a2 + 16);
  }
  uint64_t isSupported = abm::trace::isSupported();
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
  return isSupported;
}

void sub_1007556E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007556FC(uint64_t a1, char *a2, NSObject **a3, uint64_t a4)
{
  char v6 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v10 = *(void *)(a1 + 40);
  size_t v11 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, a2);
  uint64_t v12 = _NSConcreteStackBlock;
  uint64_t v13 = 1174405120;
  unint64_t v14 = sub_10075586C;
  size_t v15 = &unk_101A02C38;
  int64_t v7 = *a3;
  dispatch_object_t object = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  sub_100755E40((uint64_t)v17, a4);
  abm::client::RegisterEventHandler();
  if (v9 < 0) {
    operator delete(__p);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10065D5AC(v17);
  if (object) {
    dispatch_release(object);
  }
}

void sub_100755820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,dispatch_object_t object)
{
  sub_10065D5AC(v22);
  if (object) {
    dispatch_release(object);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(a1);
}

void sub_10075586C(uint64_t a1, xpc_object_t object, NSObject *a3)
{
  if (object)
  {
    xpc_object_t v5 = object;
    xpc_retain(object);
    if (!a3) {
      goto LABEL_4;
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    if (!a3)
    {
LABEL_4:
      sub_100755E40((uint64_t)v6, a1 + 40);
      xpc_object_t v7 = v5;
      if (v5) {
        xpc_retain(v5);
      }
      else {
        xpc_object_t v7 = xpc_null_create();
      }
      dispatch_object_t objecta = a3;
      if (a3)
      {
        dispatch_retain(a3);
        dispatch_group_t group = a3;
        dispatch_retain(a3);
        if (group) {
          dispatch_group_enter(group);
        }
      }
      else
      {
        dispatch_group_t group = 0;
      }
      operator new();
    }
  }
  dispatch_retain(a3);
  goto LABEL_4;
}

void sub_100755A10(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100755A5C(uint64_t a1, uint64_t a2)
{
  std::locale v4 = *(NSObject **)(a2 + 32);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  return sub_100755E40(a1 + 40, a2 + 40);
}

void sub_100755A9C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(NSObject **)(v1 + 32);
  if (v3) {
    dispatch_release(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100755AB4(uint64_t a1)
{
  sub_10065D5AC((void *)(a1 + 40));
  int v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_release(v2);
  }
}

BOOL sub_100755B00(uint64_t a1, char *a2)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 40);
  unint64_t v8 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&v5, a2);
  abm::client::PerformCommand();
  int v3 = v9;
  if (v11 < 0) {
    operator delete(__p);
  }
  if (v6 < 0) {
    operator delete(v5);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  return v3 == 0;
}

void sub_100755B9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100755BCC(void *a1)
{
  *a1 = off_101A02BF8;
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = a1[4];
  if (v3) {
    dispatch_release(v3);
  }
  std::locale v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  AppleBasebandManagerClientInterface::~AppleBasebandManagerClientInterface((AppleBasebandManagerClientInterface *)a1);
}

void sub_100755C48(void *a1)
{
  *a1 = off_101A02BF8;
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = a1[4];
  if (v3) {
    dispatch_release(v3);
  }
  std::locale v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  AppleBasebandManagerClientInterface::~AppleBasebandManagerClientInterface((AppleBasebandManagerClientInterface *)a1);

  operator delete();
}

void sub_100755CD8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100755D58(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100755D94(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100755DCC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100755DFC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100755E40(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_100755ED8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    int v2 = *(NSObject **)(v1 + 48);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 48);
      if (v3) {
        dispatch_release(v3);
      }
    }
    std::locale v4 = *(NSObject **)(v1 + 40);
    if (v4) {
      dispatch_release(v4);
    }
    xpc_release(*(xpc_object_t *)(v1 + 32));
    *(void *)(v1 + 32) = 0;
    sub_10065D5AC((void *)v1);
    operator delete();
  }
  return result;
}

uint64_t *sub_100755F58(void *a1)
{
  char v6 = a1;
  int v2 = (void *)a1[4];
  xpc_object_t v8 = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t v8 = xpc_null_create();
  }
  uint64_t v3 = a1[5];
  dispatch_object_t object = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  uint64_t v4 = a1[3];
  if (!v4) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, xpc_object_t *, dispatch_object_t *))(*(void *)v4 + 48))(v4, &v8, &object);
  if (object) {
    dispatch_release(object);
  }
  xpc_release(v8);
  return sub_100755ED8((uint64_t *)&v6);
}

void sub_100756010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, xpc_object_t a12)
{
  if (object) {
    dispatch_release(object);
  }
  xpc_release(a12);
  sub_100755ED8(&a10);
  _Unwind_Resume(a1);
}

void sub_100756040(__CFUserNotification *a1, char a2)
{
  if ((__CFUserNotification *)qword_101B0D640 == a1)
  {
    if ((a2 & 3) != 1)
    {
      if ((a2 & 3) == 0)
      {
        long long v32 = 0u;
        long long v33 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v25 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        *(_OWORD *)buffer = 0u;
        CFStringRef ResponseValue = CFUserNotificationGetResponseValue(a1, kCFUserNotificationTextFieldValuesKey, 0);
        CFStringGetCString(ResponseValue, buffer, 256, 0x8000100u);
        CFIndex Length = CFStringGetLength(ResponseValue);
        uint64_t v4 = (Registry *)strlen(buffer);
        if (Length != (int)v4)
        {
LABEL_23:
          CFRelease((CFTypeRef)qword_101B0D640);
          return;
        }
        Registry::get((uint64_t *)&v15, v4);
        ServiceMap = (std::mutex *)Registry::getServiceMap(v15);
        char v6 = ServiceMap;
        if ((v7 & 0x8000000000000000) != 0)
        {
          xpc_object_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v9 = 5381;
          do
          {
            unint64_t v7 = v9;
            unsigned int v10 = *v8++;
            uint64_t v9 = (33 * v9) ^ v10;
          }
          while (v10);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v17 = v7;
        char v11 = sub_10004D37C(&v6[1].__m_.__sig, &v17);
        if (v11)
        {
          uint64_t v13 = v11[3];
          uint64_t v12 = (std::__shared_weak_count *)v11[4];
          if (v12)
          {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v6);
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v12);
            char v14 = 0;
LABEL_17:
            if (v16) {
              sub_10004D2C8(v16);
            }
            if (v13) {
              (*(void (**)(uint64_t, char *, uint64_t))(*(void *)v13 + 352))(v13, buffer, 6);
            }
            if ((v14 & 1) == 0) {
              sub_10004D2C8(v12);
            }
            goto LABEL_23;
          }
        }
        else
        {
          uint64_t v13 = 0;
        }
        std::mutex::unlock(v6);
        uint64_t v12 = 0;
        char v14 = 1;
        goto LABEL_17;
      }
      CFUserNotificationCancel(a1);
      a1 = (__CFUserNotification *)qword_101B0D640;
    }
    CFRelease(a1);
  }
}

void sub_100756288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13 = v11;
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007562CC(Registry *a1, char a2)
{
  uint64_t v3 = (__CFUserNotification *)a1;
  long long v33 = 0;
  long long v34 = 0;
  Registry::get((uint64_t *)&v33, a1);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v33);
  xpc_object_t v5 = ServiceMap;
  if (v6 < 0)
  {
    unint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buffer = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buffer);
  if (v10)
  {
    uint64_t v12 = v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
  char v13 = 1;
LABEL_9:
  if ((__CFUserNotification *)qword_101B0D648 != v3) {
    goto LABEL_23;
  }
  if ((a2 & 3) == 1) {
    goto LABEL_22;
  }
  if ((a2 & 3) != 0)
  {
    CFUserNotificationCancel(v3);
    uint64_t v3 = (__CFUserNotification *)qword_101B0D648;
LABEL_22:
    CFRelease(v3);
    goto LABEL_23;
  }
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  *(_OWORD *)buffer = 0u;
  CFStringRef ResponseValue = CFUserNotificationGetResponseValue(v3, kCFUserNotificationTextFieldValuesKey, 0);
  CFStringRef v15 = ResponseValue;
  if (ResponseValue) {
    CFStringGetCString(ResponseValue, buffer, 256, 0x8000100u);
  }
  if (CFStringGetLength(v15) != 26)
  {
    if (++dword_101B0D63C == 10)
    {
      CFRelease((CFTypeRef)qword_101B0D648);
      char v35 = 0;
      uint64_t v26 = kAkeyLocalizationTable;
      (*(void (**)(__CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v35, v12, kAkeyLocalizationTable, @"Security", 1);
      long long v32 = 0;
      (*(void (**)(__CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v32, v12, v26, @"Too many retries of AKEY.", 1);
      qword_101B0D648 = _CreateSimpleUserNotification(0x78u, v35, v32);
    }
    else
    {
      char v35 = 0;
      uint64_t v27 = kAkeyLocalizationTable;
      (*(void (**)(__CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v35, v12, kAkeyLocalizationTable, @"Authentication Key", 1);
      long long v32 = 0;
      (*(void (**)(__CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v32, v12, v27, @"Incorrect key", 1);
      long long v31 = 0;
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v31, v12, v27, @"Key", 1);
      long long v30 = 0;
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v30, v12, v27, @"OK", 1);
      long long v29 = 0;
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v29, v12, v27, @"Cancel", 1);
      qword_101B0D648 = (uint64_t)sub_10037351C(0x78u, v35, v32, v31, 4, 0, v30, v29);
      RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, (CFUserNotificationRef)qword_101B0D648, (CFUserNotificationCallBack)sub_1007562CC, 0);
      if (RunLoopSource)
      {
        CFRunLoopAddSource((CFRunLoopRef)qword_101B13DE0, RunLoopSource, kCFRunLoopDefaultMode);
        CFRelease(RunLoopSource);
      }
      else
      {
        CFUserNotificationCancel((CFUserNotificationRef)qword_101B0D648);
        CFRelease((CFTypeRef)qword_101B0D648);
      }
      sub_1000558F4((const void **)&v29);
      sub_1000558F4((const void **)&v30);
      sub_1000558F4((const void **)&v31);
    }
    sub_1000558F4((const void **)&v32);
    sub_1000558F4((const void **)&v35);
    goto LABEL_23;
  }
  BOOL v16 = (std::mutex *)Registry::getServiceMap(v33);
  unint64_t v17 = v16;
  if (v18 < 0)
  {
    long long v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  char v35 = (__CFString *)v18;
  long long v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&v35);
  if (!v22)
  {
    uint64_t v24 = 0;
    goto LABEL_33;
  }
  uint64_t v24 = v22[3];
  long long v23 = (std::__shared_weak_count *)v22[4];
  if (!v23)
  {
LABEL_33:
    std::mutex::unlock(v17);
    long long v23 = 0;
    char v25 = 1;
    goto LABEL_34;
  }
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v17);
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v23);
  char v25 = 0;
LABEL_34:
  if (v24) {
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)v24 + 360))(v24, buffer, 26);
  }
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  CFRelease((CFTypeRef)qword_101B0D648);
LABEL_23:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (v34) {
    sub_10004D2C8(v34);
  }
}

void sub_100756858(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  xpc_object_t v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  unint64_t v7 = va_arg(va2, const void *);
  va_copy(va3, va2);
  unsigned int v9 = va_arg(va3, const void *);
  va_copy(va4, va3);
  char v11 = va_arg(va4, const void *);
  uint64_t v13 = va_arg(va4, void);
  char v14 = va_arg(va4, std::__shared_weak_count *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_1000558F4((const void **)va3);
  sub_1000558F4((const void **)va4);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(a1);
}

void sub_100756924(__CFUserNotification *a1, char a2)
{
  if ((__CFUserNotification *)qword_101B0D650 == a1)
  {
    if ((a2 & 3) != 1)
    {
      if ((a2 & 3) == 0)
      {
        int v2 = a1;
        if (CFUserNotificationGetResponseValue(a1, kCFUserNotificationTextFieldValuesKey, 0))
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v27 = 0;
          *(_OWORD *)uint64_t v24 = 0u;
          uint64_t v25 = 0;
          uint64_t v3 = ctu::cf::assign();
          qword_101B0D650 = sub_10075711C(v3);
          if (SHIBYTE(v25) < 0) {
            operator delete(v24[0]);
          }
        }
        goto LABEL_42;
      }
      Registry::get((uint64_t *)__p, (Registry *)a1);
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p[0]);
      CFStringRef v15 = ServiceMap;
      if (v16 < 0)
      {
        unint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v18 = 5381;
        do
        {
          uint64_t v16 = v18;
          unsigned int v19 = *v17++;
          uint64_t v18 = (33 * v18) ^ v19;
        }
        while (v19);
      }
      std::mutex::lock(ServiceMap);
      v24[0] = (void *)v16;
      uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)v24);
      if (v20)
      {
        uint64_t v21 = v20[3];
        long long v22 = (std::__shared_weak_count *)v20[4];
        if (v22)
        {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v15);
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v22);
          char v23 = 0;
LABEL_31:
          if (__p[1]) {
            sub_10004D2C8((std::__shared_weak_count *)__p[1]);
          }
          if (v21)
          {
            sub_100058DB0(__p, "");
            (*(void (**)(uint64_t, void **))(*(void *)v21 + 368))(v21, __p);
            if (SHIBYTE(v27) < 0) {
              operator delete(__p[0]);
            }
            sub_100058DB0(__p, "");
            (*(void (**)(uint64_t, void **))(*(void *)v21 + 376))(v21, __p);
            if (SHIBYTE(v27) < 0) {
              operator delete(__p[0]);
            }
          }
          if ((v23 & 1) == 0) {
            sub_10004D2C8(v22);
          }
          CFUserNotificationCancel((CFUserNotificationRef)qword_101B0D650);
LABEL_41:
          int v2 = (__CFUserNotification *)qword_101B0D650;
LABEL_42:
          CFRelease(v2);
          return;
        }
      }
      else
      {
        uint64_t v21 = 0;
      }
      std::mutex::unlock(v15);
      long long v22 = 0;
      char v23 = 1;
      goto LABEL_31;
    }
    Registry::get((uint64_t *)__p, (Registry *)a1);
    uint64_t v4 = (std::mutex *)Registry::getServiceMap((Registry *)__p[0]);
    xpc_object_t v5 = v4;
    if (v6 < 0)
    {
      unint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        uint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(v4);
    v24[0] = (void *)v6;
    unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v24);
    if (v10)
    {
      uint64_t v11 = v10[3];
      uint64_t v12 = (std::__shared_weak_count *)v10[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v13 = 0;
LABEL_20:
        if (__p[1]) {
          sub_10004D2C8((std::__shared_weak_count *)__p[1]);
        }
        if (v11)
        {
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, void **))(*(void *)v11 + 368))(v11, __p);
          if (SHIBYTE(v27) < 0) {
            operator delete(__p[0]);
          }
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, void **))(*(void *)v11 + 376))(v11, __p);
          if (SHIBYTE(v27) < 0) {
            operator delete(__p[0]);
          }
        }
        if ((v13 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_41;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    std::mutex::unlock(v5);
    uint64_t v12 = 0;
    char v13 = 1;
    goto LABEL_20;
  }
}

void sub_10075700C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,__int16 a28,char a29,char a30)
{
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFUserNotification *sub_10075711C(Registry *a1)
{
  unint64_t v17 = 0;
  uint64_t v18 = 0;
  Registry::get((uint64_t *)&v17, a1);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v17);
  int v2 = ServiceMap;
  if (v3 < 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      uint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unsigned int v19 = (void *)v3;
  unint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, (unint64_t *)&v19);
  if (v7)
  {
    uint64_t v9 = v7[3];
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  uint64_t v8 = 0;
  char v10 = 1;
LABEL_9:
  unsigned int v19 = 0;
  uint64_t v11 = kAcctLocalizationTable;
  (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v9 + 16))(&v19, v9, kAcctLocalizationTable, @"Mobile Phone Number", 1);
  uint64_t v16 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v9 + 16))(&v16, v9, v11, @"Enter your mobile phone number", 1);
  CFStringRef v15 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v9 + 16))(&v15, v9, v11, @"XXX-XXX-XXXX", 1);
  uint64_t v12 = sub_10037351C(0x78u, v19, v16, v15, 4, 0, (void *)qword_101B0D660, (void *)qword_101B0D668);
  RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v12, (CFUserNotificationCallBack)sub_100756924, 0);
  if (RunLoopSource)
  {
    CFRunLoopAddSource((CFRunLoopRef)qword_101B13DE0, RunLoopSource, kCFRunLoopDefaultMode);
    CFRelease(RunLoopSource);
  }
  else
  {
    CFUserNotificationCancel(v12);
    CFRelease(v12);
    uint64_t v12 = 0;
  }
  sub_1000558F4((const void **)&v15);
  sub_1000558F4((const void **)&v16);
  sub_1000558F4((const void **)&v19);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  return v12;
}

void sub_100757388(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  unint64_t v7 = va_arg(va2, const void *);
  uint64_t v9 = va_arg(va2, void);
  char v10 = va_arg(va2, std::__shared_weak_count *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

void sub_1007573F0(__CFUserNotification *a1, char a2)
{
  if ((__CFUserNotification *)qword_101B0D650 == a1)
  {
    if ((a2 & 3) != 1)
    {
      if ((a2 & 3) == 0)
      {
        if (CFUserNotificationGetResponseValue(a1, kCFUserNotificationTextFieldValuesKey, 0))
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v25 = 0;
          ctu::cf::assign();
          uint64_t v23 = 0;
          *(_OWORD *)long long v22 = 0u;
          if (SHIBYTE(v23) < 0) {
            operator delete(v22[0]);
          }
        }
LABEL_43:
        CFRelease((CFTypeRef)qword_101B0D650);
        qword_101B0D650 = 0;
        return;
      }
      Registry::get((uint64_t *)__p, (Registry *)a1);
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p[0]);
      char v13 = ServiceMap;
      if (v14 < 0)
      {
        CFStringRef v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v16 = 5381;
        do
        {
          uint64_t v14 = v16;
          unsigned int v17 = *v15++;
          uint64_t v16 = (33 * v16) ^ v17;
        }
        while (v17);
      }
      std::mutex::lock(ServiceMap);
      v22[0] = (void *)v14;
      uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v22);
      if (v18)
      {
        uint64_t v19 = v18[3];
        uint64_t v20 = (std::__shared_weak_count *)v18[4];
        if (v20)
        {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v13);
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v20);
          char v21 = 0;
LABEL_31:
          if (__p[1]) {
            sub_10004D2C8((std::__shared_weak_count *)__p[1]);
          }
          if (v19)
          {
            sub_100058DB0(__p, "");
            (*(void (**)(uint64_t, void **))(*(void *)v19 + 368))(v19, __p);
            if (SHIBYTE(v25) < 0) {
              operator delete(__p[0]);
            }
            sub_100058DB0(__p, "");
            (*(void (**)(uint64_t, void **))(*(void *)v19 + 376))(v19, __p);
            if (SHIBYTE(v25) < 0) {
              operator delete(__p[0]);
            }
          }
          if ((v21 & 1) == 0) {
            sub_10004D2C8(v20);
          }
          CFUserNotificationCancel((CFUserNotificationRef)qword_101B0D650);
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v13);
      uint64_t v20 = 0;
      char v21 = 1;
      goto LABEL_31;
    }
    Registry::get((uint64_t *)__p, (Registry *)a1);
    int v2 = (std::mutex *)Registry::getServiceMap((Registry *)__p[0]);
    char v3 = v2;
    if (v4 < 0)
    {
      uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v6 = 5381;
      do
      {
        uint64_t v4 = v6;
        unsigned int v7 = *v5++;
        uint64_t v6 = (33 * v6) ^ v7;
      }
      while (v7);
    }
    std::mutex::lock(v2);
    v22[0] = (void *)v4;
    uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)v22);
    if (v8)
    {
      uint64_t v9 = v8[3];
      char v10 = (std::__shared_weak_count *)v8[4];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v3);
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        char v11 = 0;
LABEL_20:
        if (__p[1]) {
          sub_10004D2C8((std::__shared_weak_count *)__p[1]);
        }
        if (v9)
        {
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, void **))(*(void *)v9 + 368))(v9, __p);
          if (SHIBYTE(v25) < 0) {
            operator delete(__p[0]);
          }
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, void **))(*(void *)v9 + 376))(v9, __p);
          if (SHIBYTE(v25) < 0) {
            operator delete(__p[0]);
          }
        }
        if ((v11 & 1) == 0) {
          sub_10004D2C8(v10);
        }
        goto LABEL_43;
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    std::mutex::unlock(v3);
    char v10 = 0;
    char v11 = 1;
    goto LABEL_20;
  }
}

void sub_10075787C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  char v23 = v21;
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void QMICDMASettingsHandler::create()
{
}

void sub_100757A30(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  dispatch_release(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

uint64_t QMICDMASettingsHandler::QMICDMASettingsHandler(uint64_t a1, void *a2, dispatch_object_t *a3, uint64_t *a4)
{
  *(void *)a1 = off_101A02D88;
  *(void *)(a1 + 48) = off_101A02E68;
  uint64_t v8 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v22, kCtLoggingSystemName, "set.cdma.qmi");
  if (v8)
  {
    dispatch_retain(v8);
    uint64_t v9 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    dispatch_retain(v8);
    dispatch_retain(v8);
    char v10 = dispatch_queue_create_with_target_V2("QMICDMASettingsHandler", v9, v8);
  }
  else
  {
    char v11 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    char v10 = dispatch_queue_create("QMICDMASettingsHandler", v11);
  }
  uint64_t v12 = v10;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  if (v12) {
    dispatch_release(v12);
  }
  if (v8)
  {
    dispatch_release(v8);
    dispatch_release(v8);
    dispatch_release(v8);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v29, &v22);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v29);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v29);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  if (v8) {
    dispatch_release(v8);
  }
  *(void *)a1 = off_101A02D88;
  *(void *)(a1 + 48) = off_101A02E68;
  *(void *)(a1 + 56) = *a2;
  uint64_t v13 = a2[1];
  *(void *)(a1 + 64) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *a4;
  CFStringRef v15 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  (*(void (**)(OsLogContext *__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v14 + 16))(&v22, v14, &object);
  *(OsLogContext *)(a1 + 72) = v22;
  v22.var0 = 0;
  v22.var1.fRef = 0;
  if (object) {
    dispatch_release(object);
  }
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 88), *(os_log_s **)(a1 + 40));
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 152));
  *(unsigned char *)(a1 + 288) = 0;
  *(_WORD *)(a1 + 295) = -1;
  *(_DWORD *)(a1 + 304) = -1;
  *(_WORD *)(a1 + 308) = -1;
  *(unsigned char *)(a1 + 310) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = 0;
  sub_100058DB0((void *)(a1 + 328), "");
  *(unsigned char *)(a1 + 416) = 0;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  sub_100058DB0(&__p, "QMICDMASettingsHandler");
  uint64_t v16 = *(NSObject **)(a1 + 24);
  dispatch_object_t v25 = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  unsigned int v17 = *a3;
  dispatch_object_t v24 = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  ctu::RestModule::RestModule();
  if (v24) {
    dispatch_release(v24);
  }
  if (v25) {
    dispatch_release(v25);
  }
  if (v27 < 0) {
    operator delete(__p);
  }
  sub_10035D650((uint64_t *)(a1 + 440), (uint64_t)&rest::kDefaultRegistrationStatuses);
  *(unsigned char *)(a1 + 464) = 0;
  int v29 = 1;
  char v30 = 0;
  sub_10021D5C8((uint64_t)&v22, &v29, 1);
  uint64_t v18 = a1 + 480;
  fRef = v22.var1.fRef;
  *(void *)(a1 + 472) = v22.var0;
  *(void *)(a1 + 480) = fRef;
  uint64_t v20 = v23;
  *(void *)(a1 + 488) = v23;
  if (v20)
  {
    *((void *)fRef + 2) = v18;
    v22.var0 = (char *)&v22.var1;
    v22.var1.fRef = 0;
    uint64_t v23 = 0;
    fRef = 0;
  }
  else
  {
    *(void *)(a1 + 472) = v18;
  }
  sub_1000346F8((uint64_t)&v22, fRef);
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  *(void *)(a1 + 496) = a1 + 504;
  sub_100313408((uint64_t *)(a1 + 520), (uint64_t)&kDefaultBasebandServiceProvisionedStates);
  *(_WORD *)(a1 + 293) = 0;
  *(_DWORD *)(a1 + 289) = 0;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  return a1;
}

void sub_100757EA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t object, dispatch_object_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  long long v41 = v26;
  sub_100088048(v30, *v31);
  sub_1000346F8(v29, *v41);
  sub_1000346F8(v28, *(void **)(v22 + 448));
  long long v33 = *(std::__shared_weak_count **)(v22 + 432);
  if (v33) {
    sub_10004D2C8(v33);
  }
  long long v34 = *(std::__shared_weak_count **)(v22 + 408);
  if (v34) {
    std::__shared_weak_count::__release_weak(v34);
  }
  if (*(char *)(v22 + 399) < 0) {
    operator delete(*(void **)(v22 + 376));
  }
  if (*(char *)(v22 + 375) < 0) {
    operator delete(*(void **)(v22 + 352));
  }
  if (*(char *)(v22 + 351) < 0) {
    operator delete(*v27);
  }
  sub_100057D78((const void **)(v22 + 320));
  sub_100087E24(v25);
  char v35 = *(std::__shared_weak_count **)(v22 + 144);
  if (v35) {
    sub_10004D2C8(v35);
  }
  unsigned int v36 = *(std::__shared_weak_count **)(v22 + 128);
  if (v36) {
    sub_10004D2C8(v36);
  }
  long long v37 = *(std::__shared_weak_count **)(v22 + 112);
  if (v37) {
    sub_10004D2C8(v37);
  }
  long long v38 = *(std::__shared_weak_count **)(v22 + 96);
  if (v38) {
    sub_10004D2C8(v38);
  }
  long long v39 = *(std::__shared_weak_count **)(v22 + 80);
  if (v39) {
    sub_10004D2C8(v39);
  }
  long long v40 = *(std::__shared_weak_count **)(v22 + 64);
  if (v40) {
    sub_10004D2C8(v40);
  }
  ctu::OsLogLogger::~OsLogLogger(v24);
  sub_100087E88(v23);
  CDMASettingsInterface::~CDMASettingsInterface((CDMASettingsInterface *)v22);
  _Unwind_Resume(a1);
}

void sub_100757FF8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x100757FCCLL);
}

void sub_10075800C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  sub_100087E88(v2);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  if (v3) {
    dispatch_release(v3);
  }
  JUMPOUT(0x100757FE8);
}

void sub_100758048(uint64_t a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100758148(uint64_t a1, uint64_t *a2, NSObject **a3)
{
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  v9[0] = xpc_null_create();
  v9[1] = xpc_null_create();
  _DWORD v9[2] = xpc_null_create();
  void v9[3] = xpc_null_create();
  uint64_t v7 = *a3;
  uint64_t v8 = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(v7);
    sub_1007582A4(a1, v6, v5, (uint64_t)v9, &v8);
  }
  sub_1007582A4(a1, v6, v5, (uint64_t)v9, &v8);
}

void sub_1007582A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, NSObject **a5)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(void *)a4) {
    xpc_retain(*(xpc_object_t *)a4);
  }
  else {
    xpc_null_create();
  }
  if (*(void *)(a4 + 8)) {
    xpc_retain(*(xpc_object_t *)(a4 + 8));
  }
  else {
    xpc_null_create();
  }
  if (*(void *)(a4 + 16)) {
    xpc_retain(*(xpc_object_t *)(a4 + 16));
  }
  else {
    xpc_null_create();
  }
  uint64_t v8 = *(void **)(a4 + 24);
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_null_create();
  }
  uint64_t v9 = *a5;
  if (*a5)
  {
    dispatch_retain(v9);
    dispatch_group_enter(v9);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (v10)
  {
    if (std::__shared_weak_count::lock(v10)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1007584CC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_group_leave(v2);
    int v3 = *(NSObject **)(a1 + 56);
    if (v3) {
      dispatch_release(v3);
    }
  }
  xpc_release(*(xpc_object_t *)(a1 + 48));
  *(void *)(a1 + 48) = 0;
  xpc_release(*(xpc_object_t *)(a1 + 40));
  *(void *)(a1 + 40) = 0;
  xpc_release(*(xpc_object_t *)(a1 + 32));
  *(void *)(a1 + 32) = 0;
  xpc_release(*(xpc_object_t *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_100758554(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100758634(uint64_t a1)
{
  *(void *)a1 = off_101A02D88;
  *(void *)(a1 + 48) = off_101A02E68;
  qmi::ClientRouter::stop();
  uint64_t v2 = *(QMIVirtualClient **)(a1 + 104);
  if (v2) {
    QMIVirtualClient::disconnect(v2);
  }
  int v3 = *(QMIVirtualClient **)(a1 + 120);
  if (v3) {
    QMIVirtualClient::disconnect(v3);
  }
  uint64_t v4 = *(QMIVirtualClient **)(a1 + 136);
  if (v4) {
    QMIVirtualClient::disconnect(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 616);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 600);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 584);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 568);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 552);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_1000346F8(a1 + 520, *(void **)(a1 + 528));
  sub_100088048(a1 + 496, *(void **)(a1 + 504));
  sub_1000346F8(a1 + 472, *(void **)(a1 + 480));
  sub_1000346F8(a1 + 440, *(void **)(a1 + 448));
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 432);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 408);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  if (*(char *)(a1 + 399) < 0) {
    operator delete(*(void **)(a1 + 376));
  }
  if (*(char *)(a1 + 375) < 0) {
    operator delete(*(void **)(a1 + 352));
  }
  if (*(char *)(a1 + 351) < 0) {
    operator delete(*(void **)(a1 + 328));
  }
  sub_100057D78((const void **)(a1 + 320));
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 144);
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 128);
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 112);
  if (v14) {
    sub_10004D2C8(v14);
  }
  CFStringRef v15 = *(std::__shared_weak_count **)(a1 + 96);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(a1 + 80);
  if (v16) {
    sub_10004D2C8(v16);
  }
  unsigned int v17 = *(std::__shared_weak_count **)(a1 + 64);
  if (v17) {
    sub_10004D2C8(v17);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CDMASettingsInterface::~CDMASettingsInterface((CDMASettingsInterface *)a1);
}

void sub_100758834(uint64_t a1)
{
}

void sub_10075883C(uint64_t a1)
{
  sub_100758634(a1);

  operator delete();
}

void sub_100758874(uint64_t a1)
{
  sub_100758634(a1 - 48);

  operator delete();
}

void sub_1007588B0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1007589B0(uint64_t a1, uint64_t a2)
{
}

void sub_1007589B8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100758AB8(uint64_t a1, uint64_t a2)
{
}

void sub_100758AC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

BOOL sub_100758AC8(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, int a6)
{
  return sub_100F60D60(*(void *)(a1 + 592), a2, a3, a4, a5, a6);
}

void sub_100758AD0(uint64_t a1, unsigned int a2, int a3, CSIPhoneNumber *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
}

void sub_100758AD8(uint64_t a1, int a2)
{
}

BOOL sub_100758AE0(uint64_t a1, int a2, unsigned char *a3)
{
  return sub_100571328(*(void *)(a1 + 608), a2, a3);
}

void sub_100758AE8(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
}

uint64_t sub_100758AF0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned char *a5, unsigned char *a6, unsigned char *a7)
{
  v16[0] = a1;
  v16[1] = a3;
  v16[2] = a4;
  void v16[3] = a5;
  void v16[4] = a6;
  v16[5] = a7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100758CA4(a1, a3, a4, a5, a6, a7);
    }
    BOOL v14 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v14 = 1;
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  v17[2] = sub_100762210;
  uint64_t v17[3] = &unk_101A038C0;
  void v17[4] = a1 + 8;
  void v17[5] = v16;
  uint64_t v18 = v17;
  CFStringRef v15 = *(NSObject **)(a1 + 24);
  char v24 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v14)
  {
    uint64_t v20 = sub_10005A1D8;
    char v21 = &unk_101A038E0;
    uint64_t v22 = &v24;
    uint64_t v23 = &v18;
    dispatch_sync(v15, block);
  }
  else
  {
    uint64_t v20 = sub_10005AF3C;
    char v21 = &unk_101A03900;
    uint64_t v22 = &v24;
    uint64_t v23 = &v18;
    dispatch_async_and_wait(v15, block);
  }
  return v24 != 0;
}

uint64_t sub_100758CA4(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned char *a4, unsigned char *a5, unsigned char *a6)
{
  uint64_t v8 = a1;
  BOOL v9 = *(unsigned char *)(a1 + 288) != 0;
  if (!*(unsigned char *)(a1 + 288))
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      buf.var0 = 67109120;
      buf.var1 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E Phone number not read yet; MDN not yet attempted: MDN read attempted yet=%d #pnr",
        (uint8_t *)&buf,
        8u);
    }
    int v12 = 0;
    *a6 = 0;
    goto LABEL_82;
  }
  *a4 = 1;
  if (*((char *)a2 + 23) < 0)
  {
    a2[1] = 0;
    a2 = (uint64_t *)*a2;
  }
  else
  {
    *((unsigned char *)a2 + 23) = 0;
  }
  *(unsigned char *)a2 = 0;
  CSIPhoneNumber::getFullNumber((uint64_t *)&buf.var0, (CSIPhoneNumber *)(a1 + 152));
  *((_DWORD *)&buf.var2.__r_.__value_.var0.var1 + 4) = 1;
  std::string::operator=((std::string *)a3, (const std::string *)&buf);
  *(_DWORD *)(a3 + 24) = *((_DWORD *)&buf.var2.__r_.__value_.var0.var1 + 4);
  if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
    operator delete(*(void **)&buf.var0);
  }
  *a5 = 0;
  *a6 = 1;
  uint64_t v13 = *(unsigned __int8 *)(a3 + 23);
  if ((v13 & 0x80u) != 0) {
    uint64_t v13 = *(void *)(a3 + 8);
  }
  if (v13)
  {
    theArray[0] = 0;
    (*(void (**)(CSIPhoneNumber *__return_ptr))(**(void **)(v8 + 560) + 40))(&buf);
    sub_100044D6C(theArray, (CFTypeRef *)&buf);
    sub_1000577C4((const void **)&buf);
    if (theArray[0]) {
      BOOL v14 = sub_100083F10;
    }
    else {
      BOOL v14 = 0;
    }
    if (v14)
    {
      uint64_t v79 = 0;
      long long v77 = 0u;
      long long v78 = 0u;
      *(_OWORD *)long long v75 = 0u;
      *(_OWORD *)long long v76 = 0u;
      long long v74 = 0u;
      memset(&buf, 0, sizeof(buf));
      CSIPhoneNumber::CSIPhoneNumber();
      CFIndex Count = CFArrayGetCount(theArray[0]);
      if (Count >= 1)
      {
        CFIndex v16 = 0;
        BOOL v61 = v9;
        while (1)
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v70 = 0;
          CFArrayGetValueAtIndex(theArray[0], v16);
          memset(v72, 0, 24);
          ctu::cf::assign();
          *(_OWORD *)OsLogContext __p = *(_OWORD *)v72;
          uint64_t v70 = *(void *)&v72[16];
          uint64_t v17 = *(void *)&v72[8];
          if (v72[23] >= 0) {
            uint64_t v17 = v72[23];
          }
          if (!v17)
          {
            char v27 = *(NSObject **)(v8 + 40);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)char v72 = 0;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Prefix is empty? in carrier bundle", v72, 2u);
            }
            LODWORD(v6) = 4;
            goto LABEL_65;
          }
          uint64_t v18 = v8;
          CSIPhoneNumber::getBaseNumber((uint64_t *)v72, &buf);
          char v19 = v72[23];
          uint64_t v20 = *(void **)v72;
          if (v72[23] >= 0) {
            char v21 = v72;
          }
          else {
            char v21 = *(unsigned char **)v72;
          }
          if (v70 >= 0) {
            uint64_t v22 = __p;
          }
          else {
            uint64_t v22 = (void **)__p[0];
          }
          if (v70 >= 0) {
            int64_t v23 = HIBYTE(v70);
          }
          else {
            int64_t v23 = (int64_t)__p[1];
          }
          if (v23)
          {
            if (v72[23] >= 0) {
              uint64_t v24 = v72[23];
            }
            else {
              uint64_t v24 = *(void *)&v72[8];
            }
            uint64_t v25 = &v21[v24];
            if (v24 >= v23)
            {
              uint64_t v62 = v21;
              BOOL v63 = *(void **)v72;
              int v29 = *(char *)v22;
              uint64_t v30 = v21;
              do
              {
                uint64_t v31 = v24 - v23;
                if (v31 == -1) {
                  break;
                }
                long long v32 = memchr(v30, v29, v31 + 1);
                if (!v32) {
                  break;
                }
                uint64_t v26 = v32;
                if (!memcmp(v32, v22, v23)) {
                  goto LABEL_47;
                }
                uint64_t v30 = v26 + 1;
                uint64_t v24 = v25 - (v26 + 1);
              }
              while (v24 >= v23);
              uint64_t v26 = v25;
LABEL_47:
              BOOL v9 = v61;
              char v21 = v62;
              uint64_t v20 = v63;
            }
            else
            {
              uint64_t v26 = &v21[v24];
            }
            if (v26 == v25) {
              uint64_t v28 = -1;
            }
            else {
              uint64_t v28 = v26 - v21;
            }
          }
          else
          {
            uint64_t v28 = 0;
          }
          uint64_t v8 = v18;
          if (v19 < 0)
          {
            operator delete(v20);
            if (!v28)
            {
LABEL_55:
              long long v33 = *(NSObject **)(v18 + 40);
              if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
              {
                CSIPhoneNumber::getBaseNumber((uint64_t *)v72, &buf);
                long long v34 = v72;
                if (v72[23] < 0) {
                  long long v34 = *(unsigned char **)v72;
                }
                char v35 = __p;
                if (v70 < 0) {
                  char v35 = (void **)__p[0];
                }
                *(_DWORD *)__dst = 136315394;
                *(void *)&__dst[4] = v34;
                *(_WORD *)&__dst[12] = 2080;
                *(void *)&__dst[14] = v35;
                _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Number %s matches the prefix %s", __dst, 0x16u);
                if ((v72[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v72);
                }
              }
              memset(v72, 0, sizeof(v72));
              std::string::operator=((std::string *)a3, (const std::string *)v72);
              *(_DWORD *)(a3 + 24) = *(_DWORD *)&v72[24];
              if ((v72[23] & 0x80000000) != 0) {
                operator delete(*(void **)v72);
              }
              LODWORD(v6) = 2;
              goto LABEL_65;
            }
          }
          else if (!v28)
          {
            goto LABEL_55;
          }
          LODWORD(v6) = 0;
LABEL_65:
          if (SHIBYTE(v70) < 0) {
            operator delete(__p[0]);
          }
          if ((v6 | 4) == 4 && ++v16 != Count) {
            continue;
          }
          break;
        }
      }
      if (SHIBYTE(v77) < 0) {
        operator delete(v76[1]);
      }
      if (SHIBYTE(v76[0]) < 0) {
        operator delete(v75[0]);
      }
      if (SBYTE7(v74) < 0) {
        operator delete(*(void **)&buf.var2.__r_.var0);
      }
      if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
      }
    }
    sub_100044D00((const void **)theArray);
  }
  uint64_t v36 = *(unsigned __int8 *)(a3 + 23);
  if ((v36 & 0x80u) != 0) {
    uint64_t v36 = *(void *)(a3 + 8);
  }
  if (v36)
  {
LABEL_81:
    int v12 = 1;
LABEL_82:
    long long v37 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      asString();
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
        p_CSIPhoneNumber buf = &buf;
      }
      else {
        p_CSIPhoneNumber buf = *(CSIPhoneNumber **)&buf.var0;
      }
      *(_DWORD *)char v72 = 136315394;
      *(void *)&v72[4] = p_buf;
      *(_WORD *)&v72[12] = 1024;
      *(_DWORD *)&v72[14] = v12;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Returning phone number '%s'; was read=%d #pnr",
        v72,
        0x12u);
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        operator delete(*(void **)&buf.var0);
      }
    }
    LOBYTE(v6) = v9;
    return v6 & 1;
  }
  uint64_t v40 = *(void *)(v8 + 504);
  if (!v40) {
    goto LABEL_100;
  }
  uint64_t v41 = v8 + 504;
  do
  {
    int v42 = *(_DWORD *)(v40 + 32);
    BOOL v43 = v42 < 1;
    if (v42 >= 1) {
      long long v44 = (uint64_t *)v40;
    }
    else {
      long long v44 = (uint64_t *)(v40 + 8);
    }
    if (!v43) {
      uint64_t v41 = v40;
    }
    uint64_t v40 = *v44;
  }
  while (*v44);
  if (v41 != v8 + 504 && *(int *)(v41 + 32) < 2)
  {
    if (BasicSimInfo::getSimTypeForCard() - 3 > 1) {
      goto LABEL_81;
    }
    long long v68 = 0;
    *(void *)&buf.var0 = CFPreferencesCopyValue(@"CDMANetworkPhoneNumber", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_100225AE0(&v68, (CFTypeRef *)&buf);
    uint64_t v67 = 0;
    *(void *)&buf.var0 = CFPreferencesCopyValue(@"CDMANetworkPhoneNumberICCID", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_100225AE0(&v67, (CFTypeRef *)&buf);
    long long v46 = v68 ? sub_1000810B8 : 0;
    if (v46 && (v67 ? (long long v47 = sub_1000810B8) : (long long v47 = 0), v47))
    {
      memset(__dst, 0, 24);
      if (*(char *)(v41 + 135) < 0)
      {
        sub_10004FC84(__dst, *(void **)(v41 + 112), *(void *)(v41 + 120));
      }
      else
      {
        *(_OWORD *)__dst = *(_OWORD *)(v41 + 112);
        *(void *)&__dst[16] = *(void *)(v41 + 128);
      }
      uint64_t v51 = __dst[23];
      if ((__dst[23] & 0x80u) != 0) {
        uint64_t v51 = *(void *)&__dst[8];
      }
      if (v51)
      {
        memset(&buf, 0, 24);
        ctu::cf::assign();
        *(_OWORD *)char v72 = *(_OWORD *)&buf.var0;
        *(void *)&v72[16] = buf.var2.__r_.__value_.var0.var1.__size_;
        BOOL v52 = sub_10001D294(__dst, v72);
        if ((v72[23] & 0x80000000) != 0) {
          operator delete(*(void **)v72);
        }
        if (v52)
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v70 = 0;
          ctu::cf::assign();
          *(_OWORD *)theArray = *(_OWORD *)__p;
          uint64_t v66 = v70;
          CSIPhoneNumber::CSIPhoneNumber();
          CSIPhoneNumber::getFullNumber((uint64_t *)v72, &buf);
          *(_DWORD *)&v72[24] = 3;
          std::string::operator=((std::string *)a3, (const std::string *)v72);
          *(_DWORD *)(a3 + 24) = *(_DWORD *)&v72[24];
          if ((v72[23] & 0x80000000) != 0) {
            operator delete(*(void **)v72);
          }
          sub_100087E24((uint64_t)&buf);
          if (SHIBYTE(v66) < 0) {
            operator delete(theArray[0]);
          }
          long long v53 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v6 = &buf;
            asString();
            unsigned int v54 = buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0 ? &buf : *(CSIPhoneNumber **)&buf.var0;
            *(_DWORD *)char v72 = 136315138;
            *(void *)&v72[4] = v54;
            _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Retrieved the CDMA Network phone number %s from persistent storage #pnr", v72, 0xCu);
            if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
              operator delete(*(void **)&buf.var0);
            }
          }
          int v49 = 0;
        }
        else
        {
          unsigned int v56 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.var0) = 0;
            _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Cannot validate the number as the ICCIDs are not matching, clearing out cache #pnr", (uint8_t *)&buf, 2u);
          }
          CFPreferencesSetValue(@"CDMANetworkPhoneNumber", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
          CFPreferencesSetValue(@"CDMANetworkPhoneNumberICCID", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
          unsigned int v57 = *(std::__shared_weak_count **)(v8 + 408);
          if (v57)
          {
            unsigned int v58 = std::__shared_weak_count::lock(v57);
            if (v58)
            {
              uint64_t v59 = v58;
              uint64_t v60 = *(void *)(v8 + 400);
              if (v60) {
                (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*(void *)v60 + 304))(v60, 1, 1, "getPhoneNumber_sync");
              }
              sub_10004D2C8(v59);
            }
          }
          int v49 = 1;
          LOBYTE(v6) = 1;
        }
      }
      else
      {
        long long v55 = *(NSObject **)(v8 + 40);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Cached ICCID is available, but ICCID from subscriber is not available yet #pnr", (uint8_t *)&buf, 2u);
        }
        LOBYTE(v6) = 0;
        *a6 = 0;
        int v49 = 1;
      }
      if ((char)__dst[23] < 0) {
        operator delete(*(void **)__dst);
      }
    }
    else
    {
      long long v48 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I Could not retrieve cached CDMA phone number, bailing out #pnr", (uint8_t *)&buf, 2u);
      }
      int v49 = 1;
      LOBYTE(v6) = 1;
    }
    sub_1000558F4(&v67);
    sub_1000558F4(&v68);
    if (!v49) {
      goto LABEL_81;
    }
  }
  else
  {
LABEL_100:
    long long v45 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      uint64_t v50 = subscriber::asString();
      buf.var0 = 136315138;
      *(void *)&buf.var1 = v50;
      _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Missing slot (%s) info to get phone number", (uint8_t *)&buf, 0xCu);
    }
    LOBYTE(v6) = 1;
  }
  return v6 & 1;
}

void sub_1007596E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,const void *a22,const void *a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  sub_10004D2C8(v50);
  if (a36 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a22);
  sub_1000558F4(&a23);
  _Unwind_Resume(a1);
}

void sub_100759838(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_10009DB3C((uint64_t)&v6, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100759984(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = a1;
  v7[1] = a3;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1007627E0(v7);
    }
    BOOL v5 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v5 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100762AD0;
  v8[3] = &unk_101A03920;
  void v8[4] = a1 + 8;
  v8[5] = v7;
  BOOL v9 = v8;
  uint64_t v6 = *(NSObject **)(a1 + 24);
  char v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v5)
  {
    uint64_t v11 = sub_10005A1D8;
    int v12 = &unk_101A038E0;
    uint64_t v13 = &v15;
    BOOL v14 = &v9;
    dispatch_sync(v6, block);
  }
  else
  {
    uint64_t v11 = sub_10005AF3C;
    int v12 = &unk_101A03900;
    uint64_t v13 = &v15;
    BOOL v14 = &v9;
    dispatch_async_and_wait(v6, block);
  }
  return v15 != 0;
}

void sub_100759AF8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 295);
    int v4 = *(unsigned __int8 *)(a1 + 296);
    int v16 = 67109376;
    int v17 = v3;
    __int16 v18 = 1024;
    int v19 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fAccolc=%d, fPrev=%d", (uint8_t *)&v16, 0xEu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(unsigned __int16 *)(a1 + 304);
    int v16 = 67109120;
    int v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fRxDiversity=%d", (uint8_t *)&v16, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(unsigned __int16 *)(a1 + 306);
    int v16 = 67109120;
    int v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fTxAntennaConfig=%d", (uint8_t *)&v16, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(unsigned __int16 *)(a1 + 308);
    int v16 = 67109120;
    int v17 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fARTDConfig=%d", (uint8_t *)&v16, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(unsigned __int8 *)(a1 + 297);
    int v9 = *(unsigned __int8 *)(a1 + 299);
    int v10 = *(unsigned __int8 *)(a1 + 300);
    int v11 = *(unsigned __int16 *)(a1 + 302);
    int v16 = 67109888;
    int v17 = v8;
    __int16 v18 = 1024;
    int v19 = v9;
    __int16 v20 = 1024;
    int v21 = v10;
    __int16 v22 = 1024;
    int v23 = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I legacy f1xRxDiversity=%d, fEvdoRxDiversity=%d, fWcdmaRxDiversity=%d, fRxAntennaConfig=%d", (uint8_t *)&v16, 0x1Au);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = *(unsigned __int8 *)(a1 + 298);
    int v13 = *(unsigned __int8 *)(a1 + 301);
    int v16 = 67109376;
    int v17 = v12;
    __int16 v18 = 1024;
    int v19 = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I legacy fC2KTxDiversity=%d, fWcdmaTxDiversity=%d", (uint8_t *)&v16, 0xEu);
  }
  uint64_t v14 = *(void *)(a1 + 592);
  if (v14) {
    sub_100F61AF8(v14);
  }
  uint64_t v15 = *(void *)(a1 + 608);
  if (v15) {
    sub_100571904(v15);
  }
}

void sub_100759D6C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 520);
  int v3 = (void *)(a1 + 528);
  if (v2 != (void *)(a1 + 528))
  {
    int v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      int v7 = *((_DWORD *)v2 + 7);
      if (!*v5) {
        break;
      }
      int v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 28);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          int v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 7)) {
        break;
      }
      int v12 = v2 + 4;
      if (*((unsigned __int8 *)v8 + 32) != *((unsigned __int8 *)v2 + 32)) {
        goto LABEL_14;
      }
LABEL_20:
      int v16 = (void *)v2[1];
      if (v16)
      {
        do
        {
          int v17 = v16;
          int v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          int v17 = (void *)v2[2];
          BOOL v18 = *v17 == (void)v2;
          uint64_t v2 = v17;
        }
        while (!v18);
      }
      uint64_t v2 = v17;
      if (v17 == v3) {
        return;
      }
    }
    int v12 = v2 + 4;
LABEL_14:
    if (subscriber::isValidSimSlot())
    {
      int v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = subscriber::asString();
        uint64_t v15 = asString();
        *(_DWORD *)CSIPhoneNumber buf = 136315394;
        uint64_t v20 = v14;
        __int16 v21 = 2080;
        uint64_t v22 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Baseband service provisioned state [%s]: %s", buf, 0x16u);
      }
      if (*v12 == 2)
      {
        subscriber::simSlotAsSubType();
        sub_10075A0B8(a1);
      }
    }
    goto LABEL_20;
  }
}

void sub_100759F30(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  int v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v15);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
LABEL_9:
  char v12 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 160))(v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (v12)
  {
    subscriber::simSlotAsSubType();
    sub_10075A0B8(a1);
  }
  int v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Device is not service provisioned, not sending MDN request", v14, 2u);
  }
}

void sub_10075A09C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10075A0B8(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Sending MDN request to baseband", buf, 2u);
  }
  memset(v2, 0, sizeof(v2));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v2, 0x24u);
  qmi::ClientRouter::get();
  operator new();
}

void sub_10075A2C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_10004D2C8(v19);
  sub_10075CF58(v18);
}

uint64_t sub_10075A338(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8) == 2 && *(_DWORD *)(a2 + 4) != 3)
  {
    uint64_t v3 = result;
    subscriber::simSlotAsSubType();
    sub_10075A0B8(v3);
  }
  return result;
}

uint64_t sub_10075A394(uint64_t result)
{
  if (!*(unsigned char *)(result + 464))
  {
    *(void *)(result + 302) = -1;
    *(void *)(result + 295) = -1;
  }
  return result;
}

double sub_10075A3B4(uint64_t a1, char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  unint64_t v3 = *((void *)a2 + 1);
  if (a2[23] >= 0)
  {
    unint64_t v4 = a2[23];
  }
  else
  {
    a2 = *(char **)a2;
    unint64_t v4 = v3;
  }
  sub_10012CD04(&v7, a2, &a2[v4], v4);
  int v5 = (void **)(v2 + 328);
  if (*(char *)(v2 + 351) < 0) {
    operator delete(*v5);
  }
  double result = *(double *)&v7;
  *(_OWORD *)int v5 = v7;
  *(void *)(v2 + 344) = v8;
  return result;
}

__n128 sub_10075A424(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10075A440(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

std::string *sub_10075A454(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2);
}

std::string *sub_10075A464(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2);
}

void sub_10075A474(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Clearing off the cached phone number and setting MDN requested to false", (uint8_t *)&v8, 2u);
  }
  CSIPhoneNumber::CSIPhoneNumber(&v8);
  *(void *)(a1 + 152) = *(void *)&v8.var0;
  unint64_t v3 = (void **)(a1 + 160);
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*v3);
  }
  *(_OWORD *)unint64_t v3 = *(_OWORD *)v8.var2.__r_.__value_.var0.var0.__data_;
  *(void *)(a1 + 176) = *((void *)&v8.var2.__r_.__value_.var0.var1 + 2);
  *((unsigned char *)&v8.var2.__r_.__value_.var0.var1 + 23) = 0;
  v8.var2.__r_.__value_.var0.var0.__data_[0] = 0;
  unint64_t v4 = (void **)(a1 + 184);
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*v4);
  }
  *(_OWORD *)unint64_t v4 = *(_OWORD *)&v8.var2.__r_.var0;
  *(void *)(a1 + 200) = v9;
  HIBYTE(v9) = 0;
  LOBYTE(v8.var2.__r_.var0) = 0;
  *(_DWORD *)(a1 + 208) = v10;
  *(unsigned char *)(a1 + 212) = v11;
  int v5 = (void **)(a1 + 216);
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*v5);
  }
  *(_OWORD *)int v5 = __p;
  *(void *)(a1 + 232) = v13;
  HIBYTE(v13) = 0;
  LOBYTE(__p) = 0;
  uint64_t v6 = (_OWORD *)(a1 + 240);
  if (*(char *)(a1 + 263) < 0)
  {
    operator delete(*(void **)(a1 + 240));
    int v7 = SHIBYTE(v13);
    _OWORD *v6 = v14;
    *(void *)(a1 + 256) = v15;
    HIBYTE(v15) = 0;
    LOBYTE(v14) = 0;
    *(_OWORD *)(a1 + 264) = v16;
    *(unsigned char *)(a1 + 280) = v17;
    if (v7 < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    _OWORD *v6 = v14;
    *(void *)(a1 + 256) = v15;
    HIBYTE(v15) = 0;
    LOBYTE(v14) = 0;
    *(unsigned char *)(a1 + 280) = v17;
    *(_OWORD *)(a1 + 264) = v16;
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(*(void **)&v8.var2.__r_.var0);
  }
  if (*((char *)&v8.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(v8.var2.__r_.__value_.var0.var1.__data_);
  }
  *(unsigned char *)(a1 + 288) = 0;
}

void sub_10075A63C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075A71C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075A810(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 472);
  unint64_t v3 = (void *)(a1 + 480);
  if (v2 != (void *)(a1 + 480))
  {
    int v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      int v7 = *((_DWORD *)v2 + 7);
      if (!*v5) {
        break;
      }
      CSIPhoneNumber v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 28);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          char v11 = (uint64_t *)v6;
        }
        else {
          char v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          CSIPhoneNumber v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 7)) {
        break;
      }
      int v12 = *((unsigned __int8 *)v2 + 32);
      if (*((unsigned __int8 *)v8 + 32) != v12) {
        goto LABEL_14;
      }
LABEL_22:
      uint64_t v15 = (void *)v2[1];
      if (v15)
      {
        do
        {
          long long v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          long long v16 = (void *)v2[2];
          BOOL v17 = *v16 == (void)v2;
          uint64_t v2 = v16;
        }
        while (!v17);
      }
      uint64_t v2 = v16;
      if (v16 == v3) {
        return;
      }
    }
    int v12 = *((unsigned __int8 *)v2 + 32);
LABEL_14:
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (v7 == 1)
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (v12) {
          long long v14 = "true";
        }
        else {
          long long v14 = "false";
        }
        *(_DWORD *)CSIPhoneNumber buf = 136315138;
        __int16 v21 = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I SMS Online changed to %s", buf, 0xCu);
      }
      sub_10075AA14(a1);
    }
    else if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      if (v12) {
        uint64_t v18 = "true";
      }
      else {
        uint64_t v18 = "false";
      }
      uint64_t v19 = subscriber::asString();
      *(_DWORD *)CSIPhoneNumber buf = 136315394;
      __int16 v21 = v18;
      __int16 v22 = 2080;
      uint64_t v23 = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Ignoring SMS online status change (%s): %s", buf, 0x16u);
    }
    goto LABEL_22;
  }
}

void sub_10075AA14(uint64_t a1)
{
  *(_OWORD *)__int16 v22 = 0u;
  long long v23 = 0u;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v21 = 0;
  char v17 = 0;
  sub_100758CA4(a1, (uint64_t *)__p, (uint64_t)v22, &v19, &v18, &v17);
  uint64_t v2 = *(void *)(a1 + 448);
  if (!v2) {
    goto LABEL_12;
  }
  uint64_t v3 = a1 + 448;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < 1;
    if (v4 >= 1) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == a1 + 448 || *(int *)(v3 + 28) > 1) {
LABEL_12:
  }
    unsigned int v7 = -4;
  else {
    unsigned int v7 = *(_DWORD *)(v3 + 32) - 4;
  }
  if (v17)
  {
    uint64_t v8 = *(void *)(a1 + 480);
    if (!v8) {
      goto LABEL_25;
    }
    uint64_t v9 = a1 + 480;
    do
    {
      int v10 = *(_DWORD *)(v8 + 28);
      BOOL v11 = v10 < 1;
      if (v10 >= 1) {
        int v12 = (uint64_t *)v8;
      }
      else {
        int v12 = (uint64_t *)(v8 + 8);
      }
      if (!v11) {
        uint64_t v9 = v8;
      }
      uint64_t v8 = *v12;
    }
    while (*v12);
    if (v9 == a1 + 480 || *(int *)(v9 + 28) > 1) {
LABEL_25:
    }
      BOOL v13 = 0;
    else {
      BOOL v13 = *(unsigned __int8 *)(v9 + 32) != 0;
    }
    BOOL v14 = v7 < 2 && v13;
  }
  else
  {
    BOOL v14 = 0;
  }
  int v15 = *(unsigned __int8 *)(a1 + 416);
  if (v15 != v14)
  {
    long long v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CSIPhoneNumber buf = 67109376;
      int v25 = v15;
      __int16 v26 = 1024;
      BOOL v27 = v14;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Phone number registration state has changed from %d to %d", buf, 0xEu);
    }
    *(unsigned char *)(a1 + 416) = v14;
    (*(void (**)(void, uint64_t, BOOL))(**(void **)(a1 + 72) + 320))(*(void *)(a1 + 72), 1, v14);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v23) < 0) {
    operator delete(v22[0]);
  }
}

void sub_10075AC14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10075AC44(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_10075AD3C(uint64_t a1, char a2, char a3)
{
  *(unsigned char *)(a1 + 310) = a2;
  *(unsigned char *)(a1 + 311) = a3;
  unsigned int v7 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 544) + 16))(&v7);
  uint64_t v6 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 544) + 16))(&v6);
  qword_101B0D640 = (uint64_t)sub_10037351C(0x78u, v7, &stru_101AC1B28, v6, 4, 1, (void *)qword_101B0D660, (void *)qword_101B0D668);
  RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, (CFUserNotificationRef)qword_101B0D640, (CFUserNotificationCallBack)sub_100756040, 0);
  if (RunLoopSource)
  {
    CFRunLoopAddSource((CFRunLoopRef)qword_101B13DE0, RunLoopSource, kCFRunLoopDefaultMode);
    CFRelease(RunLoopSource);
  }
  else
  {
    CFUserNotificationCancel((CFUserNotificationRef)qword_101B0D640);
    CFRelease((CFTypeRef)qword_101B0D640);
  }
  sub_1000558F4((const void **)&v6);
  return sub_1000558F4((const void **)&v7);
}

void sub_10075AEA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_10075AEC8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v8 = a2;
  int v7 = a3;
  v6[0] = &v7;
  v6[1] = (int *)a1;
  _DWORD v6[2] = (int *)&v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      sub_100763FF8(v6);
      return;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_100764A98;
  block[3] = &unk_101A03AD8;
  block[4] = a1 + 8;
  block[5] = v6;
  BOOL v5 = *(NSObject **)(a1 + 24);
  if (v4) {
    dispatch_sync(v5, block);
  }
  else {
    dispatch_async_and_wait(v5, block);
  }
}

void sub_10075AFA4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075B0FC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075B254(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075B388(void *a1, int a2, uint64_t a3)
{
  uint64_t v4 = a1[13];
  if (*(unsigned char *)(v4 + 72) && *(void *)(v4 + 56))
  {
    int v7 = a1[5];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CSIPhoneNumber buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I WRITE NV ITEM: %d", buf, 8u);
    }
    *(_OWORD *)long long __p = 0u;
    long long v24 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x5556u);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 0x40000000;
    v20[2] = sub_10075B8A0;
    void v20[3] = &unk_101A02F08;
    int v21 = a2;
    v20[4] = a3;
    __int16 v22 = 1;
    uint64_t v8 = (const void **)__p[1];
    if (__p[1] != (void *)v24)
    {
      while (*((unsigned char *)*v8 + 8) != 1)
      {
        if (++v8 == (const void **)v24) {
          goto LABEL_14;
        }
      }
    }
    if (v8 == (const void **)v24) {
LABEL_14:
    }
      operator new();
    if (!v10) {
      __cxa_bad_cast();
    }
    sub_10075B8A0((uint64_t)v20, (uint64_t)v10 + 16);
    BOOL v11 = (std::__shared_weak_count *)a1[2];
    if (!v11 || (v12 = a1[13], v13 = a1[1], (BOOL v14 = std::__shared_weak_count::lock(v11)) == 0)) {
      sub_100088B9C();
    }
    int v15 = v14;
    atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 0x40000000;
    _OWORD v18[2] = sub_10075B8C0;
    void v18[3] = &unk_101A02F28;
    void v18[4] = a1;
    char v19 = 0;
    if (!*(unsigned char *)(v12 + 72) || !*(void *)(v12 + 56)) {
      __TUAssertTrigger();
    }
    uint64_t v25 = v12 + 40;
    uint64_t v26 = QMIServiceMsg::create((QMIServiceMsg *)__p, v16);
    int v27 = 25000;
    uint64_t v28 = 0;
    int v29 = 0;
    *(void *)CSIPhoneNumber buf = _NSConcreteStackBlock;
    uint64_t v32 = 1174405120;
    long long v33 = sub_100766870;
    long long v34 = &unk_101A03C70;
    uint64_t v36 = v13;
    long long v37 = v15;
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    char v35 = v18;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_1007649C0;
    aBlock[3] = &unk_101A03AB8;
    void aBlock[4] = buf;
    char v17 = _Block_copy(aBlock);
    int v29 = v17;
    if (v26)
    {
      qmi::Client::send();
      char v17 = v29;
    }
    if (v17) {
      _Block_release(v17);
    }
    if (v37) {
      std::__shared_weak_count::__release_weak(v37);
    }
    std::__shared_weak_count::__release_weak(v15);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  else
  {
    uint64_t v9 = a1[5];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I No DMS Client to write NV item", buf, 2u);
    }
  }
}

void sub_10075B848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  uint64_t v21 = va_arg(va1, void);
  long long v16 = *(std::__shared_weak_count **)(v14 - 96);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  sub_10075CFC0((uint64_t)va1);
  std::__shared_weak_count::__release_weak(v13);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void *sub_10075B8A0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 40);
  return sub_10006E4A8((void *)(a2 + 8), *(char **)(a1 + 32), (char *)(*(void *)(a1 + 32) + *(unsigned __int16 *)(a1 + 44)), *(unsigned __int16 *)(a1 + 44));
}

void sub_10075B8C0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075BA00(void *a1, int a2)
{
  uint64_t v3 = a1[13];
  if (*(unsigned char *)(v3 + 72) && *(void *)(v3 + 56))
  {
    BOOL v5 = a1[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I READ NV ITEM", buf, 2u);
    }
    *(_OWORD *)long long __p = 0u;
    long long v21 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x5557u);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 0x40000000;
    _OWORD v18[2] = sub_10075BEB4;
    void v18[3] = &unk_101A02F48;
    int v19 = a2;
    uint64_t v6 = (const void **)__p[1];
    if (__p[1] != (void *)v21)
    {
      while (*((unsigned char *)*v6 + 8) != 1)
      {
        if (++v6 == (const void **)v21) {
          goto LABEL_14;
        }
      }
    }
    if (v6 == (const void **)v21) {
LABEL_14:
    }
      operator new();
    if (!v8) {
      __cxa_bad_cast();
    }
    sub_10075BEB4((uint64_t)v18, v8 + 3);
    uint64_t v9 = (std::__shared_weak_count *)a1[2];
    if (!v9 || (v10 = a1[13], uint64_t v11 = a1[1], (v12 = std::__shared_weak_count::lock(v9)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v13 = v12;
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = sub_10075BEC0;
    void v16[3] = &unk_101A02F68;
    void v16[4] = a1;
    int v17 = a2;
    if (!*(unsigned char *)(v10 + 72) || !*(void *)(v10 + 56)) {
      __TUAssertTrigger();
    }
    uint64_t v29 = v10 + 40;
    uint64_t v30 = QMIServiceMsg::create((QMIServiceMsg *)__p, v14);
    int v31 = 25000;
    uint64_t v32 = 0;
    long long v33 = 0;
    *(void *)CSIPhoneNumber buf = _NSConcreteStackBlock;
    uint64_t v23 = 1174405120;
    long long v24 = sub_100766CB4;
    uint64_t v25 = &unk_101A03CF8;
    uint64_t v27 = v11;
    uint64_t v28 = v13;
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v26 = v16;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_1007649C0;
    aBlock[3] = &unk_101A03AB8;
    void aBlock[4] = buf;
    int v15 = _Block_copy(aBlock);
    long long v33 = v15;
    if (v30)
    {
      qmi::Client::send();
      int v15 = v33;
    }
    if (v15) {
      _Block_release(v15);
    }
    if (v28) {
      std::__shared_weak_count::__release_weak(v28);
    }
    std::__shared_weak_count::__release_weak(v13);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  else
  {
    int v7 = a1[5];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I No DMS Client present to read NV", buf, 2u);
    }
  }
}

void sub_10075BE70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31)
{
  if (a31) {
    std::__shared_weak_count::__release_weak(a31);
  }
  sub_10075CFC0(v32 - 160);
  std::__shared_weak_count::__release_weak(v31);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_10075BEB4(uint64_t result, _DWORD *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void sub_10075BEC0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075C000(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v8 = a2;
  int v7 = a3;
  v6[0] = a1;
  v6[1] = &v8;
  _DWORD v6[2] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      sub_100767240((uint64_t)v6);
      return;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_1007678FC;
  block[3] = &unk_101A03E18;
  block[4] = a1 + 8;
  block[5] = v6;
  BOOL v5 = *(NSObject **)(a1 + 24);
  if (v4) {
    dispatch_sync(v5, block);
  }
  else {
    dispatch_async_and_wait(v5, block);
  }
}

void sub_10075C0DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075C210(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075C344(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  v6[0] = a1;
  v6[1] = (uint64_t)&v7;
  _DWORD v6[2] = (uint64_t)&v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      sub_100768160(v6);
      return;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_100768648;
  block[3] = &unk_101A03E88;
  block[4] = a1 + 8;
  block[5] = v6;
  BOOL v5 = *(NSObject **)(a1 + 24);
  if (v4) {
    dispatch_sync(v5, block);
  }
  else {
    dispatch_async_and_wait(v5, block);
  }
}

void sub_10075C41C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  v6[0] = &v8;
  v6[1] = &v7;
  _DWORD v6[2] = a1;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      sub_100768650((uint64_t)v6);
      return;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_100769A74;
  block[3] = &unk_101A03EA8;
  block[4] = a1 + 8;
  block[5] = v6;
  BOOL v5 = *(NSObject **)(a1 + 24);
  if (v4) {
    dispatch_sync(v5, block);
  }
  else {
    dispatch_async_and_wait(v5, block);
  }
}

void *sub_10075C4F4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  __n128 result = sub_10006E4A8((void *)a2, (char *)(v3 + 289), (char *)(v3 + 295), 6uLL);
  *(unsigned char *)(a2 + 24) = *(unsigned char *)(v3 + 295);
  return result;
}

void sub_10075C534(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075C668(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075C79C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10075C8D0(uint64_t result, _WORD *a2)
{
  *a2 = *(_WORD *)(result + 32);
  return result;
}

void sub_10075C8DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10075CA10(uint64_t result, _WORD *a2)
{
  *a2 = *(_WORD *)(result + 32);
  return result;
}

void sub_10075CA1C(uint64_t a1, QMIServiceMsg *a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (!*(unsigned char *)(a1 + 72) || !*(void *)(a1 + 56)) {
    __TUAssertTrigger();
  }
  uint64_t v16 = a1 + 40;
  uint64_t v17 = QMIServiceMsg::create(a2, a2);
  int v18 = 25000;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_10076A874;
  void v12[3] = &unk_101A040B8;
  uint64_t v10 = (std::__shared_weak_count *)a3[1];
  void v12[4] = *a3;
  uint64_t v13 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = a4;
  uint64_t v15 = a5;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1007649C0;
  aBlock[3] = &unk_101A03AB8;
  void aBlock[4] = v12;
  uint64_t v11 = _Block_copy(aBlock);
  uint64_t v20 = v11;
  if (v17)
  {
    qmi::Client::send();
    uint64_t v11 = v20;
  }
  if (v11) {
    _Block_release(v11);
  }
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
}

void sub_10075CB80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  sub_10075CFC0((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void sub_10075CBA4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10075CCD8(uint64_t result, _WORD *a2)
{
  *a2 = *(_WORD *)(result + 32);
  return result;
}

void sub_10075CCE4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10075CE18(uint64_t result, _WORD *a2)
{
  *a2 = *(_WORD *)(result + 32);
  return result;
}

void sub_10075CE24(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075CF58(uint64_t a1)
{
  if (*(void *)(a1 + 8)) {
    qmi::Client::send();
  }
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    _Block_release(v2);
  }

  operator delete();
}

uint64_t sub_10075CFC0(uint64_t a1)
{
  if (*(void *)(a1 + 8)) {
    qmi::Client::send();
  }
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10075D008(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10075D0D4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10075D1AC);
  __cxa_rethrow();
}

void sub_10075D0FC(_Unwind_Exception *a1)
{
}

void sub_10075D114(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10075D14C(uint64_t a1)
{
}

uint64_t sub_10075D168(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10075D1AC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_10075D1D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void **)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 53));
  uint64_t v4 = v2[72];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  uint64_t v5 = v2[74];
  if (v5) {
    ctu::RestModule::disconnect((ctu::RestModule *)(v5 + 88));
  }
  uint64_t v6 = v2[76];
  if (v6) {
    ctu::RestModule::disconnect((ctu::RestModule *)(v6 + 72));
  }
  sub_100088C88(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_10075D2A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_10075D2C4(uint64_t **a1)
{
  uint64_t v32 = *a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", (uint8_t *)&buf, 2u);
  }
  uint64_t v4 = v32[1];
  uint64_t v3 = v32[2];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 408);
  *(void *)(v1 + 400) = v4;
  *(void *)(v1 + 408) = v3;
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 56));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&buf);
  if (v12)
  {
    uint64_t v13 = v12[3];
    uint64_t v14 = (std::__shared_weak_count *)v12[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v14 = 0;
LABEL_15:
  *(void *)(v1 + 544) = v13;
  uint64_t v15 = *(std::__shared_weak_count **)(v1 + 552);
  *(void *)(v1 + 552) = v14;
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 56));
  uint64_t v17 = v16;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  *(void *)&long long buf = v18;
  __int16 v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&buf);
  if (v22)
  {
    uint64_t v23 = v22[3];
    long long v24 = (std::__shared_weak_count *)v22[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  std::mutex::unlock(v17);
  long long v24 = 0;
LABEL_25:
  *(void *)(v1 + 560) = v23;
  uint64_t v25 = *(std::__shared_weak_count **)(v1 + 568);
  *(void *)(v1 + 568) = v24;
  if (v25) {
    sub_10004D2C8(v25);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_10075F2DC;
  aBlock[3] = &unk_101A03140;
  void aBlock[4] = v1 + 8;
  void aBlock[5] = sub_100759F30;
  aBlock[6] = 0;
  uint64_t v26 = _Block_copy(aBlock);
  uint64_t v27 = *(std::__shared_weak_count **)(v1 + 16);
  if (v27)
  {
    uint64_t v28 = std::__shared_weak_count::lock(v27);
    if (v28)
    {
      uint64_t v29 = *(NSObject **)(v1 + 24);
      dispatch_object_t object = v29;
      int v31 = v28;
      if (v26)
      {
        uint64_t v30 = _Block_copy(v26);
        uint64_t v29 = object;
      }
      else
      {
        uint64_t v30 = 0;
      }
      uint64_t v36 = v30;
      dispatch_retain(v29);
      long long __p = 0u;
      v45[0] = 0u;
      sub_10075FCBC(v37, v29, v30);
      sub_10075FCBC((NSObject **)v38, v37[0], v37[1]);
      sub_10075FCBC(v41, v38[0], v38[1]);
      long long v39 = 0;
      sub_10075FCBC(v42, v41[0], v41[1]);
      sub_10075FCBC(v43, v42[0], v42[1]);
      sub_10075FCBC((NSObject **)v33, v43[0], v43[1]);
      sub_10075FCBC((NSObject **)&buf, v33[0], v33[1]);
      sub_10075FCBC(&v40, buf, *((void **)&buf + 1));
      sub_100760698((uint64_t)&buf);
      sub_100760698((uint64_t)v33);
      sub_100760698((uint64_t)v43);
      long long v39 = &off_101A03338;
      sub_100760698((uint64_t)v42);
      sub_100760698((uint64_t)v41);
      long long buf = 0u;
      long long v47 = 0u;
      sub_100760254((uint64_t)&buf, (uint64_t *)&v39);
      sub_100760254((uint64_t)&v39, (uint64_t *)v45 + 1);
      sub_100760254((uint64_t)v45 + 8, (uint64_t *)&buf);
      sub_100760314((uint64_t *)&buf);
      sub_100760314((uint64_t *)&v39);
      sub_100760698((uint64_t)v38);
      sub_100760698((uint64_t)v37);
      atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10075EC98(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void **a39)
{
  if (a2)
  {
    sub_100163C60(&a39);
    operator delete();
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075ECC8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  if (a2)
  {
    sub_100163BC8((uint64_t)&a57);
    if (a39) {
      (*(void (**)(uint64_t))(*(void *)a39 + 8))(a39);
    }
    std::__shared_weak_count::__release_weak(a15);
    JUMPOUT(0x10075F27CLL);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075ED18(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_10016267C(a12);
    __cxa_rethrow();
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075ED38(uint64_t a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v2);
    JUMPOUT(0x10075F274);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075ED50(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_100695D20(v2);
    __cxa_rethrow();
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075ED70(uint64_t a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v2);
    JUMPOUT(0x10075F25CLL);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075ED9C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24,xpc_object_t object,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,xpc_object_t a42,uint64_t a43,uint64_t a44,uint64_t a45,xpc_object_t a46,uint64_t a47,uint64_t a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x10075F1E0);
}

void sub_10075EE84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49)
{
}

void sub_10075EEA8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,dispatch_object_t object,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50)
{
  if (object) {
    dispatch_release(object);
  }
  if (!a50) {
    JUMPOUT(0x10075F1F0);
  }
  JUMPOUT(0x10075F1ECLL);
}

void sub_10075EEC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46)
{
  if (!a46) {
    JUMPOUT(0x10075F1F0);
  }
  JUMPOUT(0x10075F1ECLL);
}

void sub_10075EED4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60)
{
  if (a54 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x10075F1F0);
}

void sub_10075EF24(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075EF64(uint64_t a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    JUMPOUT(0x10075F1B0);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075EF78(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_10075FAC8(v2);
    __cxa_rethrow();
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075EF98(uint64_t a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v2);
    *(void *)uint64_t v3 = off_1019A5688;
    sub_100160AF8((atomic_uint **)(v3 + 16));
    JUMPOUT(0x10075F270);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075EFB4(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10075EFBCLL);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075EFD8(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10075EFE0);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075F01C(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10075F27CLL);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075F028(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10075F030);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075F060(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10075F068);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075F088(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,xpc_object_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,dispatch_object_t object,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a2) {
    JUMPOUT(0x10075F1ACLL);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075F1B8(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10075F234);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075F1DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, std::__shared_weak_count *a6, char a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v11 = va_arg(va1, void);
  if ((a7 & 1) == 0) {
    sub_10004D2C8(a6);
  }
  sub_10075F294((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  JUMPOUT(0x10075F22CLL);
}

void sub_10075F208(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10075F274);
  }
  JUMPOUT(0x10075F22CLL);
}

void sub_10075F214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t *sub_10075F294(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_1007584CC(v2);
    operator delete();
  }
  return a1;
}

uint64_t sub_10075F2DC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10075F328(uint64_t a1)
{
  sub_100760314((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

uint64_t sub_10075F368(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_10075F3A8(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_10075F3E8(uint64_t *a1, void *a2, uint64_t **a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  uint64_t v7 = *a3;
  uint64_t v8 = (uint64_t *)sub_10075F368(*a1);
  uint64_t result = sub_10075FC7C(*v8);
  if ((uint64_t *)result != v7)
  {
    unsigned int v10 = 0;
    unsigned int v11 = a4 - 1;
    uint64_t v12 = v7;
    unsigned int v35 = v11;
    do
    {
      uint64_t v13 = v12[2];
      sub_10075F3A8(v13);
      uint64_t v14 = *(uint64_t **)(v13 + 32);
      if (v14 && sub_100163358(v14) && *(unsigned char *)(v13 + 24))
      {
        *(unsigned char *)(v13 + 24) = 0;
        sub_100163448((atomic_uint **)v13, a2);
      }
      if (*(unsigned char *)(sub_10075F3A8(v12[2]) + 24))
      {
        uint64_t v7 = (uint64_t *)v12[1];
      }
      else
      {
        uint64_t v15 = *(void *)sub_10075F368(*a1);
        sub_10075FC7C(v15);
        uint64_t v16 = sub_10075F3A8(v12[2]);
        if (v12 == (uint64_t *)v15) {
          __assert_rtn("erase", "slot_groups.hpp", 148, "it != _list.end()");
        }
        uint64_t v17 = (uint64_t *)(v15 + 32);
        uint64_t v18 = *(void **)(v15 + 32);
        if (!v18) {
          goto LABEL_41;
        }
        uint64_t v19 = v16 + 64;
        long long v38 = (uint64_t **)(v15 + 24);
        uint64_t v20 = (uint64_t *)(v15 + 32);
        do
        {
          BOOL v21 = sub_100162ED8(v15 + 48, (uint64_t)(v18 + 4), v19);
          __int16 v22 = v18 + 1;
          if (!v21)
          {
            __int16 v22 = v18;
            uint64_t v20 = v18;
          }
          uint64_t v18 = (void *)*v22;
        }
        while (*v22);
        if (v20 == v17) {
LABEL_41:
        }
          __assert_rtn("erase", "slot_groups.hpp", 150, "map_it != _group_map.end()");
        if (!sub_1001634F8(v15, (uint64_t)(v20 + 4), v19)) {
          __assert_rtn("erase", "slot_groups.hpp", 151, "weakly_equivalent(map_it->first, key)");
        }
        if ((uint64_t *)v20[6] == v12)
        {
          uint64_t v37 = v12[1];
          uint64_t v23 = (void *)*v17;
          uint64_t v24 = v15;
          if (*v17)
          {
            uint64_t v25 = (uint64_t *)(v15 + 32);
            do
            {
              BOOL v26 = sub_100162ED8(v15 + 48, v19, (uint64_t)(v23 + 4));
              uint64_t v27 = v23 + 1;
              if (v26)
              {
                uint64_t v27 = v23;
                uint64_t v25 = v23;
              }
              uint64_t v23 = (void *)*v27;
            }
            while (*v27);
            uint64_t v24 = v15;
            if (v25 != v17) {
              uint64_t v24 = v25[6];
            }
          }
          if (v37 == v24)
          {
            sub_1000F5B04(v38, v20);
            operator delete(v20);
            unsigned int v11 = v35;
          }
          else
          {
            uint64_t v39 = 0;
            uint64_t v28 = (void **)sub_100162E38((uint64_t)v38, &v39, v19);
            uint64_t v29 = *v28;
            unsigned int v11 = v35;
            if (!*v28)
            {
              uint64_t v30 = (uint64_t **)v28;
              uint64_t v29 = operator new(0x38uLL);
              int v31 = *(_DWORD *)(v19 + 8);
              v29[4] = *(void *)v19;
              *((_DWORD *)v29 + 10) = v31;
              v29[6] = 0;
              sub_100046C38(v38, v39, v30, v29);
            }
            v29[6] = v37;
          }
        }
        uint64_t v32 = *v12;
        uint64_t v7 = (uint64_t *)v12[1];
        *(void *)(v32 + 8) = v7;
        *(void *)v12[1] = v32;
        --*(void *)(v15 + 16);
        sub_10000A740((atomic_uint **)v12 + 3);
        operator delete(v12);
      }
      ++v10;
      long long v33 = (uint64_t *)sub_10075F368(*a1);
      uint64_t result = sub_10075FC7C(*v33);
      BOOL v34 = v7 != (uint64_t *)result && v11 >= v10;
      uint64_t v12 = v7;
    }
    while (v34);
  }
  a1[2] = (uint64_t)v7;
  return result;
}

void sub_10075F70C()
{
}

uint64_t sub_10075F720(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10075F784()
{
  return 0;
}

uint64_t sub_10075F78C()
{
  return 0;
}

uint64_t sub_10075F794()
{
  return 0;
}

void sub_10075F7A0()
{
}

uint64_t sub_10075F7B4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10005D144(*(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10075F818()
{
  return 0;
}

uint64_t sub_10075F820()
{
  return 0;
}

uint64_t sub_10075F828()
{
  return 0;
}

uint64_t sub_10075F830(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_10075F874(uint64_t a1)
{
  sub_10075FBAC(a1);

  operator delete();
}

BOOL sub_10075F8AC(uint64_t a1)
{
  long long v8 = 0u;
  memset(v7, 0, sizeof(v7));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v7, v2);
  uint64_t v3 = *(_DWORD ***)(a1 + 32);
  if (v3)
  {
    for (uint64_t i = *v3; i != *(_DWORD **)(sub_10075F830((uint64_t)v3) + 8); i += 6)
    {
      memset(v9, 0, sizeof(v9));
      sub_100060B10(i, (uint64_t)v9);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v7);
        }
        sub_1000624B4((uint64_t)v9);
        break;
      }
      sub_1000624B4((uint64_t)v9);
      uint64_t v3 = *(_DWORD ***)(a1 + 32);
    }
  }
  int v5 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v8 + 1));
  sub_10000A5F8(v7);
  return v5 != 0;
}

void sub_10075F9D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 64);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10075FA14(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_10075FA40(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_10075FA6C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

uint64_t sub_10075FAC8(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100760314((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_10075FB28()
{
}

uint64_t sub_10075FB3C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100760314((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_10075FB94()
{
  return 0;
}

uint64_t sub_10075FB9C()
{
  return 0;
}

uint64_t sub_10075FBA4()
{
  return 0;
}

uint64_t sub_10075FBAC(uint64_t a1)
{
  *(void *)a1 = off_101A03230;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_10075FC20()
{
}

uint64_t sub_10075FC34(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10075FC64()
{
  return 0;
}

uint64_t sub_10075FC6C()
{
  return 0;
}

uint64_t sub_10075FC74()
{
  return 0;
}

uint64_t sub_10075FC7C(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

NSObject **sub_10075FCBC(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t sub_10075FD0C(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_10075FCBC((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100760698(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_10075FDE4(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 8);
  if (v1 && (uint64_t v2 = _Block_copy(v1)) != 0 && (v3 = _Block_copy(v2), (v4 = v3) != 0))
  {
    uint64_t v5 = _Block_copy(v3);
    uint64_t v6 = v5;
    if (v5)
    {
      long long v7 = _Block_copy(v5);
      long long v8 = v7;
      if (v7)
      {
        uint64_t v9 = _Block_copy(v7);
        unsigned int v10 = v9;
        if (v9)
        {
          unsigned int v11 = _Block_copy(v9);
          uint64_t v12 = v11;
          if (v11)
          {
            *(void *)&long long v14 = _Block_copy(v11);
            _Block_release(v12);
          }
          else
          {
            *(void *)&long long v14 = 0;
          }
          _Block_release(v10);
        }
        else
        {
          *(void *)&long long v14 = 0;
        }
        _Block_release(v8);
      }
      else
      {
        *(void *)&long long v14 = 0;
      }
      uint64_t v13 = off_101A03378;
      _Block_release(v6);
    }
    else
    {
      uint64_t v13 = off_101A03378;
      *(void *)&long long v14 = 0;
    }
    _Block_release(v4);
  }
  else
  {
    uint64_t v13 = off_101A03378;
    *(void *)&long long v14 = 0;
  }
  operator new();
}

void sub_100760024()
{
}

uint64_t sub_100760074(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (!*v1)
  {
    std::runtime_error::runtime_error(&v5, "call to empty boost::function");
    v5.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v5);
  }
  (*(void (**)(void *, void))((*v1 & 0xFFFFFFFFFFFFFFFELL) + 8))(v1 + 1, **(unsigned int **)(a1 + 40));
  uint64_t v3 = *(uint64_t **)(a1 + 32);
  if (v3)
  {
    sub_100760314(v3);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

void sub_100760154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_100760168(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      long long v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

uint64_t sub_100760244(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_100760254(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_1007602F0(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_100760300(_Unwind_Exception *a1)
{
}

uint64_t *sub_100760314(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_100760368(void *a1)
{
  *a1 = off_101A033A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1007603B4(void *a1)
{
  *a1 = off_101A033A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100760420(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_1007604D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1007604E8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100760508()
{
}

void *sub_100760574(void *a1)
{
  *a1 = off_101A033F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1007605C0(void *a1)
{
  *a1 = off_101A033F8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_10076062C()
{
}

uint64_t sub_100760698(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_1007606D8()
{
}

__n128 sub_1007606EC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A03438;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100760740(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A03438;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100760778(uint64_t *a1, xpc_object_t *a2)
{
  sub_100026EC0(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1007607F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100760834()
{
}

void sub_100760844()
{
}

__n128 sub_100760858(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A034B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007608AC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A034B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007608E4(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[1];
  uint64_t result = read_rest_value();
  int v4 = *v2;
  int v5 = ((unint64_t)&_mh_execute_header & 0x101FFFFFFFFLL) == 2;
  *uint64_t v2 = v5;
  if (v4 != v5)
  {
    uint64_t v6 = (uint64_t (*)(void *))a1[3];
    uint64_t v7 = a1[4];
    long long v8 = (void *)(a1[2] + (v7 >> 1));
    if (v7) {
      uint64_t v6 = *(uint64_t (**)(void *))(*v8 + v6);
    }
    return v6(v8);
  }
  return result;
}

uint64_t sub_10076098C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007609CC()
{
}

void sub_1007609DC()
{
}

__n128 sub_1007609F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A03538;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100760A44(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A03538;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100760A7C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  unsigned int v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100760B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100760B54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100760B94()
{
}

void sub_100760BA4()
{
}

__n128 sub_100760BB8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A035B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100760C0C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A035B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100760C44(void *a1)
{
  uint64_t v6 = &_mh_execute_header;
  int v7 = 0;
  rest::read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, const mach_header_64 **))a1[2];
  uint64_t v3 = a1[3];
  int v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, const mach_header_64 **))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_100760CD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100760D10()
{
}

void sub_100760D20()
{
}

__n128 sub_100760D34(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A03638;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100760D88(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A03638;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100760DC0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  unsigned int v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10031B0B4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100760E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100760E98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100760ED8()
{
}

void sub_100760EE8()
{
}

void *sub_100760EFC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A036B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100760F44(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A036B8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100760F70(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  BOOL v2 = os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I DMS client started", buf, 2u);
  }
  uint64_t result = capabilities::ct::supportsGemini((capabilities::ct *)v2);
  if (result)
  {
    *(_OWORD *)long long __p = 0u;
    long long v8 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x54u);
    int v4 = dms::convertSubscriptionType();
    int v5 = (const void **)__p[1];
    if (__p[1] != (void *)v8)
    {
      while (*((unsigned char *)*v5 + 8) != 1)
      {
        if (++v5 == (const void **)v8) {
          goto LABEL_11;
        }
      }
    }
    if (v5 != (const void **)v8)
    {
      if (v6)
      {
        void v6[3] = v4;
        qmi::ClientRouter::get();
        operator new();
      }
      __cxa_bad_cast();
    }
LABEL_11:
    operator new();
  }
  return result;
}

void sub_1007612F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_10004D2C8(v19);
  sub_10075CF58(v18);
}

uint64_t sub_100761358(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A03728)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100761398()
{
  return &off_101A03728;
}

void *sub_1007613A4(void *a1)
{
  BOOL v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10076142C()
{
}

void *sub_100761440(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A03748;
  result[1] = v3;
  return result;
}

uint64_t sub_100761488(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A03748;
  a2[1] = v2;
  return result;
}

void sub_1007614B4(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I DMS client stopped", v2, 2u);
  }
}

uint64_t sub_100761518(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A037A8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100761558()
{
  return &off_101A037A8;
}

void sub_100761568()
{
}

uint64_t sub_10076157C()
{
  return sub_10006E100();
}

_DWORD **sub_100761584(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006E108((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void sub_1007615E0()
{
}

void sub_100761644(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4))
  {
    char v3 = *(NSObject **)(**(void **)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = qmi::asString();
      int v5 = *(_DWORD *)(a2 + 4);
      int v6 = 136315394;
      uint64_t v7 = v4;
      __int16 v8 = 1024;
      int v9 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t sub_100761714(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100761730(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100761740(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A03858;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100761760(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A03858;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007617BC(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    long long __p = 0;
    int v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p, v6 - (unsigned char *)__p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x54u);
    if (__p)
    {
      int v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x54u);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_100761880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void sub_1007618C0(uint64_t **a1)
{
  uint64_t v1 = **a1;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v1 + 544) + 16))(&v7);
  uint64_t v2 = (const void *)qword_101B0D660;
  qword_101B0D660 = v7;
  uint64_t v7 = 0;
  __int16 v8 = v2;
  sub_1000558F4(&v8);
  sub_1000558F4((const void **)&v7);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v1 + 544) + 16))(&v7);
  char v3 = (const void *)qword_101B0D668;
  qword_101B0D668 = v7;
  uint64_t v7 = 0;
  __int16 v8 = v3;
  sub_1000558F4(&v8);
  sub_1000558F4((const void **)&v7);
  qmi::ClientRouter::start();
  uint64_t v4 = *(void *)(v1 + 576);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *(void *)(v1 + 592);
  if (v5) {
    sub_100F601D0(v5);
  }
  uint64_t v6 = *(void *)(v1 + 608);
  if (v6) {
    sub_10057089C(v6);
  }
  operator delete();
}

void sub_100761A34()
{
}

uint64_t *sub_100761A60(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v32 = a1;
  long long v33 = v1;
  uint64_t v2 = *v1;
  int v3 = sub_100762114(v1[1]);
  switch(v3)
  {
    case 226:
      uint64_t v14 = *(void *)(v2 + 136);
      if (*(unsigned char *)(v14 + 72) && *(void *)(v14 + 56))
      {
        long long v34 = 0u;
        long long v35 = 0u;
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v34, 0x6603u);
        uint64_t v15 = *(std::__shared_weak_count **)(v2 + 16);
        if (!v15
          || (v16 = *(void *)(v2 + 136), uint64_t v17 = *(void *)(v2 + 8), (v18 = std::__shared_weak_count::lock(v15)) == 0))
        {
          sub_100088B9C();
        }
        uint64_t v19 = v18;
        atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        if (!*(unsigned char *)(v16 + 72) || !*(void *)(v16 + 56)) {
          __TUAssertTrigger();
        }
        uint64_t v44 = v16 + 40;
        uint64_t v45 = QMIServiceMsg::create((QMIServiceMsg *)&v34, v20);
        int v46 = 25000;
        uint64_t v47 = 0;
        long long v48 = 0;
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v37 = 1174405120;
        long long v38 = sub_10076A1FC;
        uint64_t v39 = &unk_101A03F98;
        uint64_t v40 = v17;
        uint64_t v41 = v19;
        atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        int v42 = sub_10075C79C;
        uint64_t v43 = 0;
        aBlock = _NSConcreteStackBlock;
        uint64_t v50 = 0x40000000;
        uint64_t v51 = sub_1007649C0;
        BOOL v52 = &unk_101A03AB8;
        long long v53 = buf;
        BOOL v21 = _Block_copy(&aBlock);
        long long v48 = v21;
        if (v45)
        {
          qmi::Client::send();
          BOOL v21 = v48;
        }
        if (v21) {
          _Block_release(v21);
        }
        if (v41) {
          std::__shared_weak_count::__release_weak(v41);
        }
        std::__shared_weak_count::__release_weak(v19);
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v34);
      }
      else
      {
        __int16 v22 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Invalid BSP Client", buf, 2u);
        }
      }
      uint64_t v23 = *(void *)(v2 + 136);
      if (*(unsigned char *)(v23 + 72) && *(void *)(v23 + 56))
      {
        long long v34 = 0u;
        long long v35 = 0u;
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v34, 8u);
        uint64_t v24 = *(std::__shared_weak_count **)(v2 + 16);
        if (!v24
          || (v25 = *(void *)(v2 + 136), uint64_t v26 = *(void *)(v2 + 8), (v27 = std::__shared_weak_count::lock(v24)) == 0))
        {
          sub_100088B9C();
        }
        uint64_t v28 = v27;
        atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v27);
        if (!*(unsigned char *)(v25 + 72) || !*(void *)(v25 + 56)) {
          __TUAssertTrigger();
        }
        uint64_t v44 = v25 + 40;
        uint64_t v45 = QMIServiceMsg::create((QMIServiceMsg *)&v34, v29);
        int v46 = 25000;
        uint64_t v47 = 0;
        long long v48 = 0;
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v37 = 1174405120;
        long long v38 = sub_100769EB8;
        uint64_t v39 = &unk_101A03F48;
        uint64_t v40 = v26;
        uint64_t v41 = v28;
        atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        int v42 = sub_10075C668;
        uint64_t v43 = 0;
        aBlock = _NSConcreteStackBlock;
        uint64_t v50 = 0x40000000;
        uint64_t v51 = sub_1007649C0;
        BOOL v52 = &unk_101A03AB8;
        long long v53 = buf;
        uint64_t v30 = _Block_copy(&aBlock);
        long long v48 = v30;
        if (v45)
        {
          qmi::Client::send();
          uint64_t v30 = v48;
        }
        if (v30) {
          _Block_release(v30);
        }
        if (v41) {
          std::__shared_weak_count::__release_weak(v41);
        }
        std::__shared_weak_count::__release_weak(v28);
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v34);
      }
      else
      {
        uint64_t v4 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v5 = "#I Invalid BSP Client";
          goto LABEL_53;
        }
      }
      break;
    case 3:
      QMIVirtualClient::disableNasServingSystemIndications((QMIVirtualClient *)v1[1], (const OsLogLogger *)(v2 + 40));
      uint64_t v6 = *(void *)(v2 + 120);
      if (*(unsigned char *)(v6 + 72) && *(void *)(v6 + 56))
      {
        long long v34 = 0u;
        long long v35 = 0u;
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v34, 0x2Cu);
        uint64_t v7 = *(std::__shared_weak_count **)(v2 + 16);
        if (!v7
          || (uint64_t v8 = *(void *)(v2 + 120), v9 = *(void *)(v2 + 8), (v10 = std::__shared_weak_count::lock(v7)) == 0))
        {
          sub_100088B9C();
        }
        unsigned int v11 = v10;
        atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        if (!*(unsigned char *)(v8 + 72) || !*(void *)(v8 + 56)) {
          __TUAssertTrigger();
        }
        uint64_t v44 = v8 + 40;
        uint64_t v45 = QMIServiceMsg::create((QMIServiceMsg *)&v34, v12);
        int v46 = 25000;
        uint64_t v47 = 0;
        long long v48 = 0;
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v37 = 1174405120;
        long long v38 = sub_100767EA8;
        uint64_t v39 = &unk_101A03E38;
        uint64_t v40 = v9;
        uint64_t v41 = v11;
        atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        int v42 = sub_10075C210;
        uint64_t v43 = 0;
        aBlock = _NSConcreteStackBlock;
        uint64_t v50 = 0x40000000;
        uint64_t v51 = sub_1007649C0;
        BOOL v52 = &unk_101A03AB8;
        long long v53 = buf;
        uint64_t v13 = _Block_copy(&aBlock);
        long long v48 = v13;
        if (v45)
        {
          qmi::Client::send();
          uint64_t v13 = v48;
        }
        if (v13) {
          _Block_release(v13);
        }
        if (v41) {
          std::__shared_weak_count::__release_weak(v41);
        }
        std::__shared_weak_count::__release_weak(v11);
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v34);
      }
      sub_10075BA00((void *)v2, 6);
      sub_10075BA00((void *)v2, 1018);
      sub_10075BA00((void *)v2, 58002);
      sub_10075BA00((void *)v2, 818);
      sub_10075BA00((void *)v2, 3851);
      sub_10075BA00((void *)v2, 58001);
      break;
    case 2:
      uint64_t v4 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v5 = "#I Not issuing the MSISDN request now, will be issued after the technology switch";
LABEL_53:
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 2u);
      }
      break;
  }
  sub_1000E1A60((uint64_t *)&v33);
  return sub_100046B58((uint64_t *)&v32);
}

void sub_100762078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,char a25)
{
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }
  sub_10075CFC0((uint64_t)&a25);
  std::__shared_weak_count::__release_weak(v25);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  sub_1000E1A60(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100762114(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 72) || !*(void *)(a1 + 56)) {
    __TUAssertTrigger();
  }

  return qmi::Client::getSvcType(a1 + 40);
}

uint64_t *sub_100762164(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *v1;
  if (sub_100762114(v1[1]) == 2)
  {
    int v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I QMI Driver went down, setting MSISDN read to be false", buf, 2u);
    }
    sub_10075A474(v2);
  }
  sub_1000E1A60((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1007621F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100762210(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  return sub_100758CA4(*(void *)v1, *(uint64_t **)(v1 + 8), *(void *)(v1 + 16), *(unsigned char **)(v1 + 24), *(unsigned char **)(v1 + 32), *(unsigned char **)(v1 + 40));
}

uint64_t *sub_100762224(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v31 = a1;
  uint64_t v32 = v1;
  uint64_t v2 = *(void **)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 504);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = (int *)(v2 + 63);
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < 1;
    if (v5 >= 1) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = (int *)v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == (int *)(v2 + 63) || v4[8] >= 2)
  {
LABEL_11:
    uint64_t v8 = v2[5];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Missing slot (%s) info to set phone number", buf, 0xCu);
    }
    goto LABEL_13;
  }
  if (BasicSimInfo::getSimTypeForCard() - 3 > 1) {
    goto LABEL_13;
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v40 = 0;
  if (*((char *)v4 + 135) < 0)
  {
    sub_10004FC84(buf, *((void **)v4 + 14), *((void *)v4 + 15));
  }
  else
  {
    *(_OWORD *)long long buf = *((_OWORD *)v4 + 7);
    uint64_t v40 = *((void *)v4 + 16);
  }
  uint64_t v10 = HIBYTE(v40);
  if (v40 < 0) {
    uint64_t v10 = *(void *)&buf[8];
  }
  if (!v10)
  {
    uint64_t v27 = v2[5];
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_63;
    }
    LOWORD(__p[0]) = 0;
    uint64_t v28 = "#I Device has an RUIM, but no ICCID?";
    goto LABEL_62;
  }
  unsigned int v11 = (CSIPhoneNumber *)(v1 + 8);
  CSIPhoneNumber::getFullNumber((uint64_t *)__p, v11);
  if (v35 < 0)
  {
    uint64_t v30 = __p[1];
    operator delete(__p[0]);
    if (v30)
    {
LABEL_23:
      uint64_t v12 = v2[5];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        CSIPhoneNumber::getFullNumber((uint64_t *)__p, v11);
        uint64_t v13 = v35 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long v38 = 136315138;
        *(void *)&v38[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Saving the Network retrieved CDMA number %s into persistent storage #pnr", v38, 0xCu);
        if (v35 < 0) {
          operator delete(__p[0]);
        }
      }
      CSIPhoneNumber::getFullNumber((uint64_t *)__p, v11);
      if (v35 >= 0) {
        uint64_t v15 = __p;
      }
      else {
        uint64_t v15 = (void **)__p[0];
      }
      CFPropertyListRef v36 = 0;
      uint64_t v37 = 0;
      if (ctu::cf::convert_copy((ctu::cf *)&v37, (const __CFString **)v15, (const char *)0x8000100, kCFAllocatorDefault, v14))
      {
        CFPropertyListRef v16 = v36;
        CFPropertyListRef v36 = v37;
        *(void *)long long v38 = v16;
        sub_1000558F4((const void **)v38);
      }
      CFPropertyListRef value = v36;
      CFPropertyListRef v36 = 0;
      sub_1000558F4(&v36);
      if (v35 < 0) {
        operator delete(__p[0]);
      }
      if (v40 >= 0) {
        uint64_t v18 = (const __CFString **)buf;
      }
      else {
        uint64_t v18 = *(const __CFString ***)buf;
      }
      uint64_t v37 = 0;
      *(void *)long long v38 = 0;
      if (ctu::cf::convert_copy((ctu::cf *)v38, v18, (const char *)0x8000100, kCFAllocatorDefault, v17))
      {
        uint64_t v19 = (void *)v37;
        uint64_t v37 = *(const void **)v38;
        __p[0] = v19;
        sub_1000558F4((const void **)__p);
      }
      uint64_t v20 = v37;
      CFPropertyListRef v36 = v37;
      uint64_t v37 = 0;
      sub_1000558F4(&v37);
      if (value) {
        BOOL v21 = sub_1000810B8;
      }
      else {
        BOOL v21 = 0;
      }
      if (v21 && (v20 ? (__int16 v22 = sub_1000810B8) : (__int16 v22 = 0), v22))
      {
        CFPreferencesSetValue(@"CDMANetworkPhoneNumber", value, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        CFPreferencesSetValue(@"CDMANetworkPhoneNumberICCID", v36, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        sub_1003F2A04();
        uint64_t v23 = (std::__shared_weak_count *)v2[51];
        if (v23)
        {
          uint64_t v24 = std::__shared_weak_count::lock(v23);
          if (v24)
          {
            uint64_t v25 = v24;
            uint64_t v26 = v2[50];
            if (v26) {
              (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*(void *)v26 + 304))(v26, 1, 1, "setPhoneNumber");
            }
            sub_10004D2C8(v25);
          }
        }
      }
      else
      {
        uint64_t v29 = v2[5];
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Could not save the CDMA phone number", (uint8_t *)__p, 2u);
        }
      }
      sub_1000558F4(&v36);
      sub_1000558F4(&value);
      goto LABEL_63;
    }
  }
  else if (v35)
  {
    goto LABEL_23;
  }
  uint64_t v27 = v2[5];
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    uint64_t v28 = "#I Number is empty, not persisting it";
LABEL_62:
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v28, (uint8_t *)__p, 2u);
  }
LABEL_63:
  if (SHIBYTE(v40) < 0) {
    operator delete(*(void **)buf);
  }
LABEL_13:
  sub_100762758(&v32);
  return sub_100046B58((uint64_t *)&v31);
}

void sub_1007626C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, const void *a20,__int16 a21,char a22,char a23)
{
  sub_10004D2C8(v23);
  sub_1000558F4(&a20);
  sub_1000558F4(&a12);
  if (*(char *)(v24 - 41) < 0) {
    operator delete(*(void **)(v24 - 64));
  }
  sub_100762758(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100762758(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 119) < 0) {
      operator delete(*(void **)(v1 + 96));
    }
    if (*(char *)(v1 + 95) < 0) {
      operator delete(*(void **)(v1 + 72));
    }
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

BOOL sub_1007627E0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  long long __p = 0uLL;
  uint64_t v33 = 0;
  CSIPhoneNumber::getFullNumber((uint64_t *)&__p, (CSIPhoneNumber *)(v2 + 152));
  if (v33 >= 0) {
    uint64_t v3 = HIBYTE(v33);
  }
  else {
    uint64_t v3 = *((void *)&__p + 1);
  }
  if (v3)
  {
    std::operator+<char>();
    if (SHIBYTE(v33) < 0) {
      operator delete((void *)__p);
    }
    long long __p = *(_OWORD *)v20;
    uint64_t v33 = *(void *)&v20[16];
    CSIPhoneNumber::CSIPhoneNumber();
    uint64_t v4 = a1[1];
    *(void *)uint64_t v4 = *(void *)v20;
    int v5 = (void **)(v4 + 8);
    if (*(char *)(v4 + 31) < 0) {
      operator delete(*v5);
    }
    long long v6 = *(_OWORD *)&v20[8];
    *(void *)(v4 + 24) = v21;
    *(_OWORD *)int v5 = v6;
    HIBYTE(v21) = 0;
    v20[8] = 0;
    uint64_t v7 = (void **)(v4 + 32);
    if (*(char *)(v4 + 55) < 0) {
      operator delete(*v7);
    }
    long long v8 = v22;
    *(void *)(v4 + 48) = v23;
    *(_OWORD *)uint64_t v7 = v8;
    HIBYTE(v23) = 0;
    LOBYTE(v22) = 0;
    char v9 = v25;
    *(_DWORD *)(v4 + 56) = v24;
    *(unsigned char *)(v4 + 60) = v9;
    uint64_t v10 = (void **)(v4 + 64);
    if (*(char *)(v4 + 87) < 0) {
      operator delete(*v10);
    }
    long long v11 = v26;
    *(void *)(v4 + 80) = v27;
    *(_OWORD *)uint64_t v10 = v11;
    HIBYTE(v27) = 0;
    LOBYTE(v26) = 0;
    uint64_t v12 = (_OWORD *)(v4 + 88);
    if (*(char *)(v4 + 111) < 0)
    {
      operator delete(*(void **)(v4 + 88));
      long long v15 = v28;
      *(void *)(v4 + 104) = v29;
      _OWORD *v12 = v15;
      HIBYTE(v29) = 0;
      LOBYTE(v28) = 0;
      char v16 = v31;
      *(_OWORD *)(v4 + 112) = v30;
      *(unsigned char *)(v4 + 128) = v16;
    }
    else
    {
      long long v13 = v28;
      *(void *)(v4 + 104) = v29;
      _OWORD *v12 = v13;
      HIBYTE(v29) = 0;
      LOBYTE(v28) = 0;
      char v14 = v31;
      *(_OWORD *)(v4 + 112) = v30;
      *(unsigned char *)(v4 + 128) = v14;
    }
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)v22);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(*(void **)&v20[8]);
    }
    CFAllocatorRef v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      CSIPhoneNumber::getFullNumber((uint64_t *)v20, (CSIPhoneNumber *)a1[1]);
      uint64_t v18 = v20[23] >= 0 ? v20 : *(unsigned char **)v20;
      *(_DWORD *)long long buf = 136315138;
      char v35 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I VoiceMailNumber = %s", buf, 0xCu);
      if ((v20[23] & 0x80000000) != 0) {
        operator delete(*(void **)v20);
      }
    }
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)__p);
  }
  return v3 != 0;
}

void sub_100762AA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100762AD0(uint64_t a1)
{
  return sub_1007627E0(*(uint64_t **)(a1 + 40));
}

void sub_100762AD8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = (std::__shared_weak_count *)v2[2];
  if (v3)
  {
    uint64_t v5 = *v2;
    long long v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (v2[1])
      {
        uint64_t v7 = *(void *)(a2 + 16);
        if (v7) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
        }
        long long v8 = *(std::__shared_weak_count **)(v5 + 16);
        if (v8)
        {
          if (std::__shared_weak_count::lock(v8)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

uint64_t sub_100762C54(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100762C70(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100762C80(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A03980;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100762CA0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A03980;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100762CF4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100762D08(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    long long __p = 0;
    long long v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p, v6 - (unsigned char *)__p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x24u);
    if (__p)
    {
      long long v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x24u);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_100762DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t *sub_100762E0C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v43 = a1;
  uint64_t v44 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 20);
  if (v3 == 16)
  {
    uint64_t v10 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.var0) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I QMI Error not provisioned", (uint8_t *)&buf, 2u);
    }
    CSIPhoneNumber::CSIPhoneNumber(&buf);
    *(void *)(v2 + 152) = *(void *)&buf.var0;
    long long v11 = (void **)(v2 + 160);
    if (*(char *)(v2 + 183) < 0) {
      operator delete(*v11);
    }
    *(_OWORD *)long long v11 = *(_OWORD *)buf.var2.__r_.__value_.var0.var0.__data_;
    *(void *)(v2 + 176) = *((void *)&buf.var2.__r_.__value_.var0.var1 + 2);
    *((unsigned char *)&buf.var2.__r_.__value_.var0.var1 + 23) = 0;
    buf.var2.__r_.__value_.var0.var0.__data_[0] = 0;
    uint64_t v12 = (void **)(v2 + 184);
    if (*(char *)(v2 + 207) < 0) {
      operator delete(*v12);
    }
    *(_OWORD *)uint64_t v12 = *(_OWORD *)&buf.var2.__r_.var0;
    *(void *)(v2 + 200) = v56;
    HIBYTE(v56) = 0;
    LOBYTE(buf.var2.__r_.var0) = 0;
    *(_DWORD *)(v2 + 208) = v57;
    *(unsigned char *)(v2 + 212) = v58;
    long long v13 = (void **)(v2 + 216);
    if (*(char *)(v2 + 239) < 0) {
      operator delete(*v13);
    }
    *(_OWORD *)long long v13 = __p;
    *(void *)(v2 + 232) = v60;
    HIBYTE(v60) = 0;
    LOBYTE(__p) = 0;
    char v14 = (_OWORD *)(v2 + 240);
    if (*(char *)(v2 + 263) < 0)
    {
      operator delete(*(void **)(v2 + 240));
      int v16 = SHIBYTE(v60);
      *char v14 = v61;
      *(void *)(v2 + 256) = v62;
      HIBYTE(v62) = 0;
      LOBYTE(v61) = 0;
      *(_OWORD *)(v2 + 264) = v63;
      *(unsigned char *)(v2 + 280) = v64;
      if (v16 < 0) {
        operator delete((void *)__p);
      }
    }
    else
    {
      *char v14 = v61;
      *(void *)(v2 + 256) = v62;
      HIBYTE(v62) = 0;
      LOBYTE(v61) = 0;
      *(unsigned char *)(v2 + 280) = v64;
      *(_OWORD *)(v2 + 264) = v63;
    }
    if (SHIBYTE(v56) < 0) {
      operator delete(*(void **)&buf.var2.__r_.var0);
    }
    if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
    }
LABEL_72:
    *(unsigned char *)(v2 + 288) = 1;
    memset(&buf, 0, 24);
    CSIPhoneNumber::getFullNumber((uint64_t *)&buf.var0, (CSIPhoneNumber *)(v2 + 152));
    CFPropertyListRef v36 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      p_CSIPhoneNumber buf = &buf;
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        p_CSIPhoneNumber buf = *(CSIPhoneNumber **)&buf.var0;
      }
      LODWORD(v65) = 136315138;
      *(void *)((char *)&v65 + 4) = p_buf;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Device Phone number is '%s'", (uint8_t *)&v65, 0xCu);
    }
    long long v38 = *(std::__shared_weak_count **)(v2 + 408);
    if (v38)
    {
      uint64_t v39 = std::__shared_weak_count::lock(v38);
      if (v39)
      {
        uint64_t v40 = v39;
        uint64_t v41 = *(void *)(v2 + 400);
        if (v41) {
          (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*(void *)v41 + 304))(v41, 1, 1, "handleMsisdnResponse_sync");
        }
        sub_10004D2C8(v40);
      }
    }
    if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
      operator delete(*(void **)&buf.var0);
    }
    goto LABEL_83;
  }
  if (!v3)
  {
    uint64_t v4 = (qmi::MessageBase *)(v1 + 16);
    v50[0] = _NSConcreteStackBlock;
    v50[1] = 0x40000000;
    uint64_t v51 = sub_10075A3B4;
    BOOL v52 = &unk_101A02E98;
    uint64_t v53 = v2;
    TlvValue = (capabilities::ct *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)(v1 + 16));
    uint64_t v7 = TlvValue;
    if (!TlvValue) {
      goto LABEL_29;
    }
    int v8 = v6;
    *(void *)&long long v65 = TlvValue;
    memset(&buf, 0, 24);
    sub_10006E26C((std::string::value_type **)&v65, v6, (std::string *)&buf);
    uint64_t v9 = v65;
    if ((void)v65) {
      TlvValue = (capabilities::ct *)((uint64_t (*)(void *, CSIPhoneNumber *))v51)(v50, &buf);
    }
    if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0)
    {
      operator delete(*(void **)&buf.var0);
      if (v9) {
        goto LABEL_29;
      }
    }
    else if (v9)
    {
      goto LABEL_29;
    }
    TlvValue = (capabilities::ct *)qmi::MessageBase::sParsingErrorHandler(*(unsigned __int16 *)v4, 16, v7, v8);
LABEL_29:
    *(void *)&long long v65 = 0;
    *((void *)&v65 + 1) = &v65;
    uint64_t v66 = 0x4002000000;
    uint64_t v67 = sub_10075A424;
    long long v68 = sub_10075A440;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    uint64_t v71 = 0;
    if (capabilities::ct::useLegacyPhoneNumberSelectionMethod(TlvValue))
    {
      uint64_t v45 = _NSConcreteStackBlock;
      uint64_t v46 = 0x40000000;
      uint64_t v47 = sub_10075A454;
      long long v48 = &unk_101A02EC0;
      int v49 = &v65;
      CFAllocatorRef v17 = (std::string::value_type *)qmi::MessageBase::findTlvValue(v4);
      uint64_t v19 = v17;
      if (!v17) {
        goto LABEL_55;
      }
      int v20 = v18;
      unsigned int v54 = v17;
      memset(&buf, 0, 24);
      sub_10006E2EC(&v54, v18, (std::string *)&buf);
      uint64_t v21 = v54;
      if (v54) {
        v47((uint64_t)&v45, (const std::string *)&buf);
      }
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        operator delete(*(void **)&buf.var0);
      }
      if (v21) {
        goto LABEL_45;
      }
      char v22 = qmi::MessageBase::sParsingErrorHandler(*(unsigned __int16 *)v4, 49, v19, v20);
    }
    else
    {
      uint64_t v45 = _NSConcreteStackBlock;
      uint64_t v46 = 0x40000000;
      uint64_t v47 = sub_10075A464;
      long long v48 = &unk_101A02EE8;
      int v49 = &v65;
      uint64_t v23 = (std::string::value_type *)qmi::MessageBase::findTlvValue(v4);
      char v25 = v23;
      if (!v23) {
        goto LABEL_55;
      }
      int v26 = v24;
      unsigned int v54 = v23;
      memset(&buf, 0, 24);
      sub_10006E1EC(&v54, v24, (std::string *)&buf);
      uint64_t v27 = v54;
      if (v54) {
        v47((uint64_t)&v45, (const std::string *)&buf);
      }
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        operator delete(*(void **)&buf.var0);
      }
      if (v27) {
        goto LABEL_45;
      }
      char v22 = qmi::MessageBase::sParsingErrorHandler(*(unsigned __int16 *)v4, 1, v25, v26);
    }
    if (v22)
    {
LABEL_45:
      if (*(char *)(*((void *)&v65 + 1) + 63) < 0)
      {
        if (*(void *)(*((void *)&v65 + 1) + 48)) {
          goto LABEL_47;
        }
      }
      else if (*(unsigned char *)(*((void *)&v65 + 1) + 63))
      {
LABEL_47:
        CSIPhoneNumber::CSIPhoneNumber();
        *(void *)(v2 + 152) = *(void *)&buf.var0;
        long long v28 = (void **)(v2 + 160);
        if (*(char *)(v2 + 183) < 0) {
          operator delete(*v28);
        }
        *(_OWORD *)long long v28 = *(_OWORD *)buf.var2.__r_.__value_.var0.var0.__data_;
        *(void *)(v2 + 176) = *((void *)&buf.var2.__r_.__value_.var0.var1 + 2);
        *((unsigned char *)&buf.var2.__r_.__value_.var0.var1 + 23) = 0;
        buf.var2.__r_.__value_.var0.var0.__data_[0] = 0;
        uint64_t v29 = (void **)(v2 + 184);
        if (*(char *)(v2 + 207) < 0) {
          operator delete(*v29);
        }
        *(_OWORD *)uint64_t v29 = *(_OWORD *)&buf.var2.__r_.var0;
        *(void *)(v2 + 200) = v56;
        HIBYTE(v56) = 0;
        LOBYTE(buf.var2.__r_.var0) = 0;
        *(_DWORD *)(v2 + 208) = v57;
        *(unsigned char *)(v2 + 212) = v58;
        long long v30 = (void **)(v2 + 216);
        if (*(char *)(v2 + 239) < 0) {
          operator delete(*v30);
        }
        *(_OWORD *)long long v30 = __p;
        *(void *)(v2 + 232) = v60;
        HIBYTE(v60) = 0;
        LOBYTE(__p) = 0;
        char v31 = (_OWORD *)(v2 + 240);
        if (*(char *)(v2 + 263) < 0)
        {
          operator delete(*(void **)(v2 + 240));
          int v35 = SHIBYTE(v60);
          _OWORD *v31 = v61;
          *(void *)(v2 + 256) = v62;
          HIBYTE(v62) = 0;
          LOBYTE(v61) = 0;
          *(_OWORD *)(v2 + 264) = v63;
          *(unsigned char *)(v2 + 280) = v64;
          if (v35 < 0) {
            operator delete((void *)__p);
          }
        }
        else
        {
          _OWORD *v31 = v61;
          *(void *)(v2 + 256) = v62;
          HIBYTE(v62) = 0;
          LOBYTE(v61) = 0;
          *(unsigned char *)(v2 + 280) = v64;
          *(_OWORD *)(v2 + 264) = v63;
        }
        if (SHIBYTE(v56) < 0) {
          operator delete(*(void **)&buf.var2.__r_.var0);
        }
        if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
          operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
        }
        char v33 = 1;
LABEL_68:
        _Block_object_dispose(&v65, 8);
        if (SHIBYTE(v71) < 0)
        {
          operator delete(v69);
          if ((v33 & 1) == 0) {
            goto LABEL_83;
          }
        }
        else if ((v33 & 1) == 0)
        {
          goto LABEL_83;
        }
        goto LABEL_72;
      }
      uint64_t v32 = *(NSObject **)(v2 + 40);
      char v33 = 0;
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_68;
      }
      LOWORD(buf.var0) = 0;
      long long v34 = "#I CDMA phone number is present, but is empty; dropping.";
LABEL_60:
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v34, (uint8_t *)&buf, 2u);
      char v33 = 0;
      goto LABEL_68;
    }
LABEL_55:
    uint64_t v32 = *(NSObject **)(v2 + 40);
    char v33 = 0;
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_68;
    }
    LOWORD(buf.var0) = 0;
    long long v34 = "#I No CDMA phone number is present";
    goto LABEL_60;
  }
  long long v15 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    buf.var0 = 67109378;
    buf.var1 = v3;
    *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_ = 2080;
    *(char **)((char *)&buf.var2.__r_.__value_.var0.var1.__data_ + 2) = (char *)qmi::asString();
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E Error in response with code = 0x%x (%s), Not handling this error", (uint8_t *)&buf, 0x12u);
  }
LABEL_83:
  sub_1007636C0(&v44);
  return sub_100046B58((uint64_t *)&v43);
}

void sub_10076363C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose((const void *)(v28 - 160), 8);
  if (*(char *)(v28 - 97) < 0) {
    operator delete(*(void **)(v28 - 120));
  }
  sub_1007636C0(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_1007636C0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    qmi::MessageBase::~MessageBase((qmi::MessageBase *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100763710(uint64_t **a1)
{
  uint64_t v1 = **a1;
  v28[0] = 0;
  v28[1] = 0;
  uint64_t v29 = 0;
  *(_OWORD *)int v26 = 0u;
  long long v27 = 0u;
  __int16 v25 = 0;
  char v24 = 0;
  char v2 = sub_100758CA4(v1, (uint64_t *)v28, (uint64_t)v26, (unsigned char *)&v25 + 1, &v25, &v24);
  int v3 = *(NSObject **)(v1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if ((v2 & 1) == 0)
  {
    if (v4)
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Not Sending out kPhoneNumberRegistrationState event, phone number not ready", (uint8_t *)&buf, 2u);
    }
LABEL_44:
    if (SBYTE7(v27) < 0) {
      operator delete(v26[0]);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete(v28[0]);
    }
    operator delete();
  }
  if (v4)
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Sending out kPhoneNumberRegistrationState event", (uint8_t *)&buf, 2u);
  }
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v23 = 0;
  if (SBYTE7(v27) < 0)
  {
    sub_10004FC84(__dst, v26[0], (unint64_t)v26[1]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)v26;
    uint64_t v23 = v27;
  }
  CFPropertyListRef value = 0;
  if (v23 >= 0) {
    uint64_t v5 = __dst;
  }
  else {
    uint64_t v5 = (void **)__dst[0];
  }
  int v20 = 0;
  CFPropertyListRef value = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v5, 0x8000100u);
  *(void *)&long long buf = CFPreferencesCopyValue(@"PhoneNumber", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100225AE0(&v20, (CFTypeRef *)&buf);
  CFPropertyListRef v6 = value;
  if (v20) {
    uint64_t v7 = sub_1000810B8;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7)
  {
    if (value ? sub_1000810B8 : 0)
    {
      if (CFEqual(v20, value))
      {
        uint64_t v9 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Phone number has not changed, so not sending any change notification", (uint8_t *)&buf, 2u);
        }
        goto LABEL_31;
      }
      CFPropertyListRef v6 = value;
    }
  }
  CFPreferencesSetValue(@"PhoneNumber", v6, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_1003F2A04();
  (*(void (**)(void, uint64_t))(**(void **)(v1 + 72) + 328))(*(void *)(v1 + 72), 1);
  uint64_t v10 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    long long buf = 0uLL;
    uint64_t v31 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __p = buf;
    uint64_t v19 = v31;
    long long v11 = (void **)__dst[0];
    uint64_t v12 = (void **)buf;
    if (v31 >= 0) {
      uint64_t v12 = __p;
    }
    if (v23 >= 0) {
      long long v11 = __dst;
    }
    *(_DWORD *)uint64_t v32 = 136315394;
    char v33 = v12;
    __int16 v34 = 2080;
    int v35 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Sent out Phone Number Changed notification, old: %s, new: %s", v32, 0x16u);
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_31:
  (*(void (**)(void, uint64_t))(**(void **)(v1 + 72) + 312))(*(void *)(v1 + 72), 1);
  long long v13 = *(std::__shared_weak_count **)(v1 + 408);
  if (v13)
  {
    char v14 = std::__shared_weak_count::lock(v13);
    if (v14)
    {
      uint64_t v15 = *(void *)(v1 + 400);
      if (v15)
      {
        int v16 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Updating phone_numbers rest property", (uint8_t *)&buf, 2u);
        }
        long long buf = 0uLL;
        uint64_t v31 = 0;
        (*(void (**)(uint64_t, uint64_t, long long *, void **, void **, uint64_t))(*(void *)v15 + 432))(v15, 1, &buf, v26, v26, 1);
        if (SHIBYTE(v31) < 0) {
          operator delete((void *)buf);
        }
        goto LABEL_41;
      }
    }
  }
  else
  {
    char v14 = 0;
  }
  CFAllocatorRef v17 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not get SettingsInterface to update phone numbers REST property", (uint8_t *)&buf, 2u);
    if (!v14)
    {
LABEL_42:
      sub_10075AA14(v1);
      sub_1000558F4(&v20);
      sub_1000558F4(&value);
      if (SHIBYTE(v23) < 0) {
        operator delete(__dst[0]);
      }
      goto LABEL_44;
    }
  }
  else if (!v14)
  {
    goto LABEL_42;
  }
LABEL_41:
  sub_10004D2C8(v14);
  goto LABEL_42;
}

void sub_100763C04(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (*(char *)(v38 - 89) < 0) {
    operator delete(*(void **)(v38 - 112));
  }
  sub_10004D2C8(v37);
  sub_1000558F4(&a15);
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  operator delete();
}

void sub_100763CC4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (!subscriber::isSimAbsent()) {
LABEL_25:
  }
    operator delete();
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 56));
  BOOL v4 = ServiceMap;
  if (v5 < 0)
  {
    CFPropertyListRef v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11)
      {
LABEL_8:
        long long v13 = *(NSObject **)(v2 + 40);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_23;
        }
        *(_WORD *)long long buf = 0;
        char v14 = "#N No ActivationInterface to determine if UIM is required";
        uint64_t v15 = v13;
        goto LABEL_22;
      }
LABEL_12:
      int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 64))(v11);
      CFAllocatorRef v17 = *(NSObject **)(v2 + 40);
      BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      if (v16)
      {
        if (v18)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Baseband requires UIM, and clearing off the Phone Number in CDMA", buf, 2u);
        }
        sub_10075A474(v2);
        uint64_t v19 = *(std::__shared_weak_count **)(v2 + 408);
        if (v19)
        {
          int v20 = std::__shared_weak_count::lock(v19);
          if (v20)
          {
            uint64_t v21 = v20;
            uint64_t v22 = *(void *)(v2 + 400);
            if (v22) {
              (*(void (**)(uint64_t, void, uint64_t, const char *))(*(void *)v22 + 304))(v22, *((unsigned int *)v1 + 2), 1, "handleSimState");
            }
            sub_10004D2C8(v21);
          }
        }
        goto LABEL_23;
      }
      if (!v18)
      {
LABEL_23:
        if ((v12 & 1) == 0) {
          sub_10004D2C8(v10);
        }
        goto LABEL_25;
      }
      *(_WORD *)long long buf = 0;
      char v14 = "#I UIM is not required for device";
      uint64_t v15 = v17;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, buf, 2u);
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (!v11) {
    goto LABEL_8;
  }
  goto LABEL_12;
}

void sub_100763F18()
{
  sub_10004D2C8(v1);
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

void sub_100763F70(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_10075AD3C(**a1, *((unsigned char *)*a1 + 8), *((unsigned char *)*a1 + 9));
  operator delete();
}

void sub_100763FCC()
{
}

void sub_100763FF8(int **a1)
{
  char v2 = a1[1];
  if (**a1 != 6) {
    __TUAssertTrigger();
  }
  uint64_t v3 = *((void *)v2 + 13);
  if (*(unsigned char *)(v3 + 72) && *(void *)(v3 + 56))
  {
    memcpy((char *)v2 + 289, *(const void **)a1[2], **a1);
    char v4 = *((unsigned char *)v2 + 310);
    char v5 = *((unsigned char *)v2 + 311);
    *(_OWORD *)long long __p = 0u;
    long long v21 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x3Bu);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 0x40000000;
    v19[2] = sub_100764480;
    void v19[3] = &unk_101A039E8;
    CFPropertyListRef v6 = *a1;
    void v19[4] = a1[2];
    v19[5] = v6;
    uint64_t v7 = (const void **)__p[1];
    if (__p[1] != (void *)v21)
    {
      while (*((unsigned char *)*v7 + 8) != 1)
      {
        if (++v7 == (const void **)v21) {
          goto LABEL_12;
        }
      }
    }
    if (v7 == (const void **)v21) {
LABEL_12:
    }
      operator new();
    if (!v8) {
      __cxa_bad_cast();
    }
    sub_100764480((uint64_t)v19, v8 + 2);
    uint64_t v9 = (std::__shared_weak_count *)*((void *)v2 + 2);
    if (!v9
      || (v10 = *((void *)v2 + 13), uint64_t v11 = *((void *)v2 + 1), (v12 = std::__shared_weak_count::lock(v9)) == 0))
    {
      sub_100088B9C();
    }
    long long v13 = v12;
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = sub_10076449C;
    void v16[3] = &unk_101A03A08;
    void v16[4] = v2;
    char v17 = v4;
    char v18 = v5;
    if (!*(unsigned char *)(v10 + 72) || !*(void *)(v10 + 56)) {
      __TUAssertTrigger();
    }
    uint64_t v24 = v10 + 40;
    uint64_t v25 = QMIServiceMsg::create((QMIServiceMsg *)__p, v14);
    int v26 = 25000;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 1174405120;
    void v22[2] = sub_1007648D0;
    v22[3] = &unk_101A03A80;
    v22[5] = v11;
    uint64_t v23 = v13;
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    void v22[4] = v16;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_1007649C0;
    aBlock[3] = &unk_101A03AB8;
    void aBlock[4] = v22;
    uint64_t v15 = _Block_copy(aBlock);
    uint64_t v28 = v15;
    if (v25)
    {
      qmi::Client::send();
      uint64_t v15 = v28;
    }
    if (v15) {
      _Block_release(v15);
    }
    if (v23) {
      std::__shared_weak_count::__release_weak(v23);
    }
    std::__shared_weak_count::__release_weak(v13);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_10076443C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a32) {
    std::__shared_weak_count::__release_weak(a32);
  }
  sub_10075CFC0(v33 - 176);
  std::__shared_weak_count::__release_weak(v32);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a21);
  _Unwind_Resume(a1);
}

void *sub_100764480(uint64_t a1, void *a2)
{
  return sub_10076479C(a2, **(char ***)(a1 + 32), (char *)(**(void **)(a1 + 32) + **(int **)(a1 + 40)), **(int **)(a1 + 40));
}

void sub_10076449C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  char v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void *sub_1007645DC(void *a1)
{
  *a1 = off_101A03A50;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_10076462C(void *a1)
{
  *a1 = off_101A03A50;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_10076469C(uint64_t a1)
{
  return sub_10006E36C((void *)(a1 + 16));
}

void *sub_1007646A4(uint64_t a1, void **a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  char v4 = (char *)*a2;
  uint64_t v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  uint64_t result = sub_10006E37C(a2, a1 + 16);
  uint64_t v7 = (char *)*a2 - v5;
  char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void sub_100764700()
{
}

void sub_100764778()
{
}

void *sub_10076479C(void *result, char *__src, char *a3, unint64_t a4)
{
  CFPropertyListRef v6 = __src;
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  uint64_t v9 = (unsigned char *)*result;
  if (v8 - *result >= a4)
  {
    char v14 = (unsigned char *)result[1];
    size_t v15 = v14 - v9;
    if (v14 - v9 >= a4)
    {
      size_t v19 = a3 - __src;
      if (v19) {
        uint64_t result = memmove((void *)*result, __src, v19);
      }
      char v12 = &v9[v19];
    }
    else
    {
      int v16 = &__src[v15];
      if (v14 != v9)
      {
        uint64_t result = memmove((void *)*result, __src, v15);
        uint64_t v9 = (unsigned char *)v7[1];
      }
      char v12 = v9;
      if (v16 != a3)
      {
        char v12 = v9;
        char v17 = v9;
        do
        {
          char v18 = *v16++;
          *v17++ = v18;
          ++v12;
        }
        while (v16 != a3);
      }
    }
  }
  else
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      uint64_t v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      sub_10006A748();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    uint64_t result = sub_10005C9F8(v7, v11);
    char v12 = (unsigned char *)v7[1];
    while (v6 != a3)
    {
      char v13 = *v6++;
      *v12++ = v13;
    }
  }
  v7[1] = v12;
  return result;
}

void sub_1007648D0(void *a1, void *a2)
{
  char v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      CFPropertyListRef v6 = v5;
      if (a1[5])
      {
        uint64_t v7 = a1[4];
        uint64_t v8 = a2[1];
        v10[0] = *a2;
        v10[1] = v8;
        uint64_t v9 = a2[2];
        v10[2] = v9;
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        qmi::MessageBase::validateMsgId((qmi::MessageBase *)v10, 0x3Bu);
        (*(void (**)(uint64_t, void *))(v7 + 16))(v7, v10);
        qmi::MessageBase::~MessageBase((qmi::MessageBase *)v10);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100764974(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100764994(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007649B0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1007649C0(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    long long __p = 0;
    CFPropertyListRef v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p, v6 - (unsigned char *)__p);
    if (__p)
    {
      CFPropertyListRef v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_100764A6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100764A98(uint64_t a1)
{
}

uint64_t *sub_100764AA0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v3 = a1;
  uint64_t v4 = v1;
  std::string::operator=((std::string *)(*(void *)v1 + 352), (const std::string *)(v1 + 8));
  sub_1001102C4(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100764AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100764B04(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v30 = a1;
  uint64_t v31 = v1;
  uint64_t v2 = *(void *)v1;
  char v3 = (std::string *)(*(void *)v1 + 376);
  std::string::operator=(v3, (const std::string *)(v1 + 8));
  uint64_t v4 = *(unsigned __int8 *)(v2 + 375);
  if (*(char *)(v2 + 375) < 0) {
    unint64_t v5 = *(void *)(v2 + 360);
  }
  else {
    unint64_t v5 = *(unsigned __int8 *)(v2 + 375);
  }
  if (*(char *)(v2 + 399) < 0) {
    unint64_t v6 = *(void *)(v2 + 384);
  }
  else {
    unint64_t v6 = *(unsigned __int8 *)(v2 + 399);
  }
  uint64_t v7 = *(void *)(v2 + 104);
  if (!*(unsigned char *)(v7 + 72)
    || !*(void *)(v7 + 56)
    || (v5 ? (BOOL v8 = v5 > 0xF) : (BOOL v8 = 1), !v8 ? (v9 = v6 == 0) : (v9 = 1), !v9 ? (v10 = v6 > 0xC) : (v10 = 1), v10))
  {
    char v12 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I setServiceProvisioningMIN - invalid arguments, unable to send provisioning information to baseband", buf, 2u);
    }
    goto LABEL_79;
  }
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  long long v62 = 0uLL;
  if ((v4 & 0x80) != 0) {
    uint64_t v4 = *(void *)(v2 + 360);
  }
  sub_10011FDF0((unint64_t *)&v43, v4 + 2);
  *(unsigned char *)uint64_t v43 = 0;
  LODWORD(v11) = *(char *)(v2 + 375);
  if ((v11 & 0x80000000) != 0) {
    uint64_t v11 = *(void *)(v2 + 360);
  }
  *((unsigned char *)v43 + 1) = v11;
  if ((*(char *)(v2 + 375) & 0x80000000) == 0)
  {
    char v13 = (const void *)(v2 + 352);
    size_t v14 = *(unsigned __int8 *)(v2 + 375);
    if (!*(unsigned char *)(v2 + 375)) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  char v13 = *(const void **)(v2 + 352);
  size_t v14 = *(void *)(v2 + 360);
  if (v14) {
LABEL_30:
  }
    memmove((char *)v43 + 2, v13, v14);
LABEL_31:
  uint64_t v40 = 0;
  size_t v41 = 0;
  uint64_t v42 = 0;
  sub_100058DB0(&v40, "310");
  if (v42 >= 0) {
    size_t v15 = HIBYTE(v42);
  }
  else {
    size_t v15 = v41;
  }
  if (v15)
  {
    if (v42 >= 0) {
      int v16 = &v40;
    }
    else {
      int v16 = v40;
    }
    memcpy((char *)&v62 + 1, v16, v15);
  }
  if (*(char *)(v2 + 399) < 0)
  {
    char v3 = *(std::string **)(v2 + 376);
    size_t v17 = *(void *)(v2 + 384);
    if (!v17) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  size_t v17 = *(unsigned __int8 *)(v2 + 399);
  if (*(unsigned char *)(v2 + 399)) {
LABEL_41:
  }
    memcpy((char *)&v62 - v6 + 16, v3, v17);
LABEL_42:
  *(_OWORD *)long long __p = 0u;
  long long v39 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x555Bu);
  v32[0] = _NSConcreteStackBlock;
  v32[1] = 1174405120;
  uint64_t v33 = sub_100765370;
  __int16 v34 = &unk_101A03AF8;
  CFPropertyListRef v36 = 0;
  uint64_t v37 = 0;
  int v35 = 0;
  sub_10005C928(&v35, v43, (uint64_t)v44, v44 - (unsigned char *)v43);
  char v18 = (const void **)__p[1];
  if (__p[1] != (void *)v39)
  {
    while (*((unsigned char *)*v18 + 8) != 17)
    {
      if (++v18 == (const void **)v39) {
        goto LABEL_49;
      }
    }
  }
  if (v18 == (const void **)v39) {
LABEL_49:
  }
    operator new();
  if (!v19) {
    __cxa_bad_cast();
  }
  v33(v32, v19 + 2);
  v60[0] = _NSConcreteStackBlock;
  v60[1] = 0x40000000;
  v60[2] = sub_1007654AC;
  v60[3] = &unk_101A03B28;
  long long v61 = v62;
  int v20 = (const void **)__p[1];
  if (__p[1] != (void *)v39)
  {
    while (*((unsigned char *)*v20 + 8) != 18)
    {
      if (++v20 == (const void **)v39) {
        goto LABEL_61;
      }
    }
  }
  if (v20 == (const void **)v39) {
LABEL_61:
  }
    operator new();
  if (!v21) {
    __cxa_bad_cast();
  }
  sub_1007654AC((uint64_t)v60, v21 + 2);
  uint64_t v22 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v22
    || (uint64_t v23 = *(void *)(v2 + 104), v24 = *(void *)(v2 + 8), (v25 = std::__shared_weak_count::lock(v22)) == 0))
  {
    sub_100088B9C();
  }
  int v26 = v25;
  atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v25);
  if (!*(unsigned char *)(v23 + 72) || !*(void *)(v23 + 56)) {
    __TUAssertTrigger();
  }
  uint64_t v54 = v23 + 40;
  uint64_t v55 = QMIServiceMsg::create((QMIServiceMsg *)__p, v27);
  int v56 = 25000;
  uint64_t v57 = 0;
  char v58 = 0;
  *(void *)long long buf = _NSConcreteStackBlock;
  uint64_t v47 = 1174405120;
  long long v48 = sub_100765844;
  int v49 = &unk_101A03BE8;
  uint64_t v50 = v24;
  uint64_t v51 = v26;
  atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  BOOL v52 = sub_10075B254;
  uint64_t v53 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1007649C0;
  aBlock[3] = &unk_101A03AB8;
  void aBlock[4] = buf;
  uint64_t v28 = _Block_copy(aBlock);
  char v58 = v28;
  if (v55)
  {
    qmi::Client::send();
    uint64_t v28 = v58;
  }
  if (v28) {
    _Block_release(v28);
  }
  if (v51) {
    std::__shared_weak_count::__release_weak(v51);
  }
  std::__shared_weak_count::__release_weak(v26);
  if (v35)
  {
    CFPropertyListRef v36 = v35;
    operator delete(v35);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  if (SHIBYTE(v42) < 0) {
    operator delete(v40);
  }
  if (v43)
  {
    uint64_t v44 = v43;
    operator delete(v43);
  }
LABEL_79:
  sub_1001102C4(&v31);
  return sub_100046B58((uint64_t *)&v30);
}

void sub_1007652B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,std::__shared_weak_count *a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  if (a37) {
    std::__shared_weak_count::__release_weak(a37);
  }
  sub_10075CFC0((uint64_t)&a41);
  std::__shared_weak_count::__release_weak(v41);
  if (__p)
  {
    a17 = (uint64_t)__p;
    operator delete(__p);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a19);
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a29)
  {
    a30 = (uint64_t)a29;
    operator delete(a29);
  }
  sub_1001102C4(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void *sub_100765370(void *result, void **a2)
{
  char v3 = (char *)result[4];
  uint64_t v4 = (unsigned char *)result[5];
  unint64_t v5 = v4 - v3;
  unint64_t v6 = (unint64_t)a2[2];
  uint64_t v7 = (char *)*a2;
  if (v6 - (unint64_t)*a2 < v4 - v3)
  {
    if (v7)
    {
      a2[1] = v7;
      operator delete(v7);
      unint64_t v6 = 0;
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
    }
    if ((v5 & 0x8000000000000000) != 0) {
      sub_10006A748();
    }
    uint64_t v8 = 2 * v6;
    if (2 * v6 <= v5) {
      uint64_t v8 = v4 - v3;
    }
    if (v6 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v9 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v9 = v8;
    }
    uint64_t result = sub_10005C9F8(a2, v9);
    uint64_t v7 = (char *)a2[1];
    goto LABEL_17;
  }
  BOOL v10 = a2[1];
  size_t v11 = v10 - v7;
  if (v10 - v7 >= v5)
  {
LABEL_17:
    if (v4 != v3) {
      uint64_t result = memmove(v7, v3, v4 - v3);
    }
    char v13 = &v7[v5];
    goto LABEL_20;
  }
  char v12 = &v3[v11];
  if (v10 != v7)
  {
    uint64_t result = memmove(*a2, v3, v11);
    uint64_t v7 = (char *)a2[1];
  }
  if (v4 != v12) {
    uint64_t result = memmove(v7, v12, v4 - v12);
  }
  char v13 = &v7[v4 - v12];
LABEL_20:
  a2[1] = v13;
  return result;
}

void *sub_10076547C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v2 = (void *)(a1 + 32);
  _OWORD v2[2] = 0;
  return sub_10005C928(v2, *(const void **)(a2 + 32), *(void *)(a2 + 40), *(void *)(a2 + 40) - *(void *)(a2 + 32));
}

void sub_100765494(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
}

void *sub_1007654AC(uint64_t a1, void *a2)
{
  return sub_10006E4A8(a2, (char *)(a1 + 32), (char *)(a1 + 48), 0x10uLL);
}

void *sub_1007654C4(void *a1)
{
  *a1 = off_101A03B70;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100765514(void *a1)
{
  *a1 = off_101A03B70;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_100765584(uint64_t a1)
{
  return sub_10006E36C((void *)(a1 + 16));
}

void *sub_10076558C(uint64_t a1, void **a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (char *)*a2;
  uint64_t v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  uint64_t result = sub_10006E37C(a2, a1 + 16);
  uint64_t v7 = (char *)*a2 - v5;
  char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void sub_1007655E8()
{
}

void sub_100765660()
{
}

void *sub_100765684(void *a1)
{
  *a1 = off_101A03BC0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1007656D4(void *a1)
{
  *a1 = off_101A03BC0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_100765744(uint64_t a1)
{
  return sub_10006E36C((void *)(a1 + 16));
}

void *sub_10076574C(uint64_t a1, void **a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (char *)*a2;
  uint64_t v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  uint64_t result = sub_10006E37C(a2, a1 + 16);
  uint64_t v7 = (char *)*a2 - v5;
  char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void sub_1007657A8()
{
}

void sub_100765820()
{
}

void sub_100765844(void *a1, uint64_t a2)
{
  char v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        uint64_t v8 = (void (*)(void *, uint64_t))a1[6];
        uint64_t v9 = a1[7];
        BOOL v10 = (void *)(v7 + (v9 >> 1));
        if (v9) {
          uint64_t v8 = *(void (**)(void *, uint64_t))(*v10 + v8);
        }
        v8(v10, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1007658F8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10076590C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100765928(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t *sub_100765938(_DWORD **a1)
{
  uint64_t v1 = *a1;
  BOOL v10 = a1;
  size_t v11 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = v1[3];
  uint64_t v4 = *(NSObject **)(*(void *)v1 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I There was an error sending the provisioning data to the baseband", buf, 2u);
    }
    *(void *)long long buf = 0;
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 544) + 16))(buf);
    alertMessage[0] = 0;
    (*(void (**)(CFStringRef *__return_ptr))(**(void **)(v2 + 544) + 16))(alertMessage);
    if (*(void *)buf) {
      unint64_t v6 = sub_1000810B8;
    }
    else {
      unint64_t v6 = 0;
    }
    if (v6 && (alertMessage[0] ? (uint64_t v7 = sub_1000810B8) : (uint64_t v7 = 0), v7))
    {
      CFUserNotificationDisplayNotice(0.0, 2uLL, 0, 0, 0, *(CFStringRef *)buf, alertMessage[0], (CFStringRef)qword_101B0D660);
    }
    else
    {
      uint64_t v8 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v12 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E handleServiceProvisioningResponse - Invalid values for user notification, bailing", v12, 2u);
      }
    }
    sub_1000558F4((const void **)alertMessage);
    sub_1000558F4((const void **)buf);
  }
  else
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Resetting Baseband after succesfully setting provisioning data", buf, 2u);
    }
    sub_100058DB0(alertMessage, "Resetting Baseband after succesfully setting provisioning data ");
    rest::ResetPayload::ResetPayload();
    sub_1004BC4DC();
    if (v16 < 0) {
      operator delete(*(void **)buf);
    }
    if (v14 < 0) {
      operator delete((void *)alertMessage[0]);
    }
  }
  sub_100765BE8((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100765B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

uint64_t *sub_100765BE8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    qmi::MessageBase::~MessageBase((qmi::MessageBase *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_100765C38(Registry *a1)
{
  uint64_t v1 = *(void *)a1;
  int v26 = a1;
  uint64_t v27 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 12);
  if (v3)
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v3;
      LOWORD(v39) = 2080;
      *(void *)((char *)&v39 + 2) = qmi::asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Error in response with code = 0x%x (%s)", buf, 0x12u);
      int v3 = *(_DWORD *)(v1 + 12);
    }
    if (v3 == 59)
    {
      *(void *)long long buf = 0;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 544) + 16))(buf);
      aBlock[0] = 0;
      (*(void (**)(const void **__return_ptr))(**(void **)(v2 + 544) + 16))(aBlock);
      qword_101B0D658 = _CreateSimpleUserNotification(0x78u, *(const __CFString **)buf, (const __CFString *)aBlock[0]);
LABEL_17:
      sub_1000558F4(aBlock);
      sub_1000558F4((const void **)buf);
      goto LABEL_18;
    }
    if (v3 == 34)
    {
      *(void *)long long buf = 0;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 544) + 16))(buf);
      aBlock[0] = 0;
      (*(void (**)(const void **__return_ptr))(**(void **)(v2 + 544) + 16))(aBlock);
      qword_101B0D640 = (uint64_t)sub_10037351C(0x78u, *(void **)buf, &stru_101AC1B28, (void *)aBlock[0], 4, 1, (void *)qword_101B0D660, (void *)qword_101B0D668);
      RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, (CFUserNotificationRef)qword_101B0D640, (CFUserNotificationCallBack)sub_100756040, 0);
      if (RunLoopSource)
      {
        CFRunLoopAddSource((CFRunLoopRef)qword_101B13DE0, RunLoopSource, kCFRunLoopDefaultMode);
        CFRelease(RunLoopSource);
      }
      else
      {
        CFUserNotificationCancel((CFUserNotificationRef)qword_101B0D640);
        CFRelease((CFTypeRef)qword_101B0D640);
      }
      goto LABEL_17;
    }
  }
  else
  {
    if (*(unsigned char *)(v1 + 32))
    {
      dword_101B0D63C = 0;
      *(void *)long long buf = 0;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 544) + 16))(buf);
      aBlock[0] = 0;
      (*(void (**)(const void **__return_ptr))(**(void **)(v2 + 544) + 16))(aBlock);
      uint64_t v32 = 0;
      (*(void (**)(void **__return_ptr))(**(void **)(v2 + 544) + 16))(&v32);
      qword_101B0D648 = (uint64_t)sub_10037351C(0x78u, *(void **)buf, (void *)aBlock[0], v32, 4, 0, (void *)qword_101B0D660, (void *)qword_101B0D668);
      unint64_t v6 = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, (CFUserNotificationRef)qword_101B0D648, (CFUserNotificationCallBack)sub_1007562CC, 0);
      if (v6)
      {
        CFRunLoopAddSource((CFRunLoopRef)qword_101B13DE0, v6, kCFRunLoopDefaultMode);
        CFRelease(v6);
      }
      else
      {
        CFUserNotificationCancel((CFUserNotificationRef)qword_101B0D648);
        CFRelease((CFTypeRef)qword_101B0D648);
      }
      *(unsigned char *)(v2 + 310) = 0;
      sub_1000558F4((const void **)&v32);
      goto LABEL_17;
    }
    if (*(unsigned char *)(v1 + 33))
    {
      qword_101B0D650 = (uint64_t)sub_10075711C(a1);
      *(unsigned char *)(v2 + 310) = 0;
    }
    else
    {
      CFDictionaryRef v8 = *(const __CFDictionary **)(v2 + 320);
      if (v8) {
        uint64_t v9 = sub_100080778;
      }
      else {
        uint64_t v9 = 0;
      }
      if (v9)
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v8, @"kCTBasebandAccessOverloadClass");
        if (Value)
        {
          int valuePtr = 0;
          CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
          uint64_t v11 = *(void *)(v2 + 120);
          if (*(unsigned char *)(v11 + 72) && *(void *)(v11 + 56))
          {
            int v12 = valuePtr;
            char v13 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v12;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I sendSetAccolcReq_sync = %d", buf, 8u);
            }
            *(_OWORD *)long long __p = 0u;
            long long v31 = 0u;
            qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x2Du);
            v29[0] = _NSConcreteStackBlock;
            v29[1] = 0x40000000;
            v29[2] = sub_10075C4F4;
            void v29[3] = &unk_101A02F88;
            v29[4] = v2;
            char v14 = (const void **)__p[1];
            if (__p[1] != (void *)v31)
            {
              while (*((unsigned char *)*v14 + 8) != 1)
              {
                if (++v14 == (const void **)v31) {
                  goto LABEL_37;
                }
              }
            }
            if (v14 == (const void **)v31) {
LABEL_37:
            }
              operator new();
            if (!v16) {
              __cxa_bad_cast();
            }
            sub_10075C4F4((uint64_t)v29, (uint64_t)v16 + 16);
            size_t v17 = *(std::__shared_weak_count **)(v2 + 16);
            if (!v17
              || (uint64_t v18 = *(void *)(v2 + 120),
                  uint64_t v19 = *(void *)(v2 + 8),
                  (int v20 = std::__shared_weak_count::lock(v17)) == 0))
            {
              sub_100088B9C();
            }
            long long v21 = v20;
            atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v20);
            if (!*(unsigned char *)(v18 + 72) || !*(void *)(v18 + 56)) {
              __TUAssertTrigger();
            }
            uint64_t v32 = (void *)(v18 + 40);
            uint64_t v33 = QMIServiceMsg::create((QMIServiceMsg *)__p, v22);
            int v34 = 25000;
            uint64_t v35 = 0;
            CFPropertyListRef v36 = 0;
            *(void *)long long buf = _NSConcreteStackBlock;
            *(void *)&long long v39 = 1174405120;
            *((void *)&v39 + 1) = sub_100769C44;
            uint64_t v40 = &unk_101A03F18;
            uint64_t v41 = v19;
            uint64_t v42 = v21;
            atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            uint64_t v43 = sub_10075C534;
            uint64_t v44 = 0;
            aBlock[0] = _NSConcreteStackBlock;
            aBlock[1] = (const void *)0x40000000;
            aBlock[2] = sub_1007649C0;
            aBlock[3] = &unk_101A03AB8;
            void aBlock[4] = buf;
            uint64_t v23 = _Block_copy(aBlock);
            CFPropertyListRef v36 = v23;
            if (v33)
            {
              qmi::Client::send();
              uint64_t v23 = v36;
            }
            if (v23) {
              _Block_release(v23);
            }
            if (v42) {
              std::__shared_weak_count::__release_weak(v42);
            }
            std::__shared_weak_count::__release_weak(v21);
            qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
          }
          else
          {
            size_t v15 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I sendSetAccolcReq_sync cannot send yet", buf, 2u);
            }
          }
          ++*(_DWORD *)(v2 + 312);
        }
        CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 320), @"kCTBasebandProtocolRevision");
        if (v24)
        {
          *(_DWORD *)long long buf = 0;
          CFNumberGetValue(v24, kCFNumberIntType, buf);
          *(unsigned char *)(v2 + 296) = buf[0];
          sub_10075B388((void *)v2, 6, v2 + 296);
          ++*(_DWORD *)(v2 + 312);
        }
        uint64_t v25 = *(void *)(v2 + 320);
        *(void *)(v2 + 320) = 0;
        *(void *)long long buf = v25;
        sub_100057D78((const void **)buf);
      }
      (*(void (**)(void, uint64_t))(**(void **)(v2 + 72) + 272))(*(void *)(v2 + 72), 1);
    }
  }
LABEL_18:
  sub_100766658(&v27);
  return sub_100046B58((uint64_t *)&v26);
}

void sub_1007665A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  CFNumberRef v24 = *(std::__shared_weak_count **)(v22 - 120);
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  sub_10075CFC0((uint64_t)&a21);
  std::__shared_weak_count::__release_weak(v21);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  sub_100766658(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100766658(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    qmi::MessageBase::~MessageBase((qmi::MessageBase *)(v1 + 8));
    operator delete();
  }
  return result;
}

void *sub_1007666A8(void *a1)
{
  *a1 = off_101A03C40;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1007666F8(void *a1)
{
  *a1 = off_101A03C40;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_100766768(uint64_t a1)
{
  return sub_10006E3D0(a1 + 16);
}

void *sub_100766770(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006E3E0((_DWORD **)a2, a1 + 16);
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void sub_1007667CC()
{
}

void sub_10076684C()
{
}

void sub_100766870(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (a1[5]) {
        (*(void (**)(void))(a1[4] + 16))();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1007668F0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100766904(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 12);
  if (v3)
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v3;
      __int16 v18 = 2080;
      uint64_t v19 = qmi::asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I NVWRITE was not successful: errorcode = 0x%x (%s)", buf, 0x12u);
    }
  }
  else if (*(unsigned char *)(v1 + 32))
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Resetting Baseband after succesful NV WRITE", buf, 2u);
    }
    sub_100058DB0(&__p, "Resetting Baseband after successful NV Write");
    rest::ResetPayload::ResetPayload();
    sub_1004BC4DC();
    if (v20 < 0) {
      operator delete(*(void **)buf);
    }
    if (v16 < 0) {
      operator delete(__p);
    }
  }
  int v6 = *(_DWORD *)(v2 + 312);
  BOOL v7 = __OFSUB__(v6, 1);
  int v8 = v6 - 1;
  if (v8 < 0 == v7)
  {
    *(_DWORD *)(v2 + 312) = v8;
    if (!v8)
    {
      uint64_t v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Resetting Baseband after all NV WRITEs", buf, 2u);
      }
      sub_100058DB0(&v13, "Resetting Baseband after successful NV Write");
      rest::ResetPayload::ResetPayload();
      sub_1004BC4DC();
      if (v20 < 0) {
        operator delete(*(void **)buf);
      }
      if (v14 < 0) {
        operator delete(v13);
      }
    }
  }
  sub_100766B84(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100766B0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_100766B84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100766B84(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    qmi::MessageBase::~MessageBase((qmi::MessageBase *)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100766BD8()
{
}

uint64_t sub_100766BEC()
{
  return sub_10006E100();
}

_DWORD **sub_100766BF4(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006E108((_DWORD **)a2, (_DWORD *)(a1 + 12));
  BOOL v7 = (char *)(*a2 - v5);
  *(unsigned char *)uint64_t v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void sub_100766C50()
{
}

void sub_100766CB4(void *a1, void *a2)
{
  char v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      if (a1[5])
      {
        uint64_t v7 = a1[4];
        uint64_t v8 = a2[1];
        v10[0] = *a2;
        v10[1] = v8;
        uint64_t v9 = a2[2];
        v10[2] = v9;
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        qmi::MessageBase::validateMsgId((qmi::MessageBase *)v10, 0x5557u);
        (*(void (**)(uint64_t, void *))(v7 + 16))(v7, v10);
        qmi::MessageBase::~MessageBase((qmi::MessageBase *)v10);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100766D58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_100766D78(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v23 = a1;
  uint64_t v24 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 12);
  if (!v3)
  {
    uint64_t v5 = (unsigned __int16 *)(v1 + 8);
    uint64_t v33 = 0;
    int v34 = &v33;
    uint64_t v35 = 0x2000000000;
    int v36 = -1;
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v39 = 0x40000000;
    uint64_t v40 = (uint64_t (*)(uint64_t, uint64_t *))sub_100767214;
    uint64_t v41 = &unk_101A03D30;
    uint64_t v42 = &v33;
    TlvCFNumberRef Value = qmi::MessageBase::findTlvValue((qmi::MessageBase *)(v1 + 8));
    uint64_t v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      v25[0] = TlvValue;
      LODWORD(v29) = sub_10006E19C(v25, v7);
      if (v25[0]) {
        v40((uint64_t)buf, &v29);
      }
      else {
        qmi::MessageBase::sParsingErrorHandler(*v5, 1, v8, v9);
      }
    }
    uint64_t v29 = 0;
    long long v30 = &v29;
    uint64_t v31 = 0x2000000000;
    char v32 = 0;
    v25[0] = (unint64_t)_NSConcreteStackBlock;
    v25[1] = 0x40000000;
    int v26 = sub_100767228;
    uint64_t v27 = &unk_101A03D58;
    uint64_t v28 = &v29;
    BOOL v10 = (char *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)(v1 + 8));
    uint64_t v12 = v10;
    if (!v10) {
      goto LABEL_35;
    }
    int v13 = v11;
    uint64_t v37 = v10;
    *(void *)uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    sub_10006E11C(&v37, v11, v43);
    char v14 = v37;
    if (v37) {
      v26((uint64_t)v25, (unsigned char **)v43);
    }
    if (*(void *)v43)
    {
      uint64_t v44 = *(void **)v43;
      operator delete(*(void **)v43);
    }
    int v15 = v14 ? 1 : qmi::MessageBase::sParsingErrorHandler(*v5, 16, v12, v13);
    if (*((_DWORD *)v34 + 6) || !v15) {
      goto LABEL_35;
    }
    int v16 = *(_DWORD *)(v1 + 32);
    if (v16 <= 3850)
    {
      switch(v16)
      {
        case 6:
          *(unsigned char *)(v2 + 296) = *((unsigned char *)v30 + 24);
          break;
        case 818:
          *(unsigned char *)(v2 + 299) = *((unsigned char *)v30 + 24);
          break;
        case 1018:
          *(unsigned char *)(v2 + 297) = *((unsigned char *)v30 + 24);
          break;
      }
      goto LABEL_35;
    }
    switch(v16)
    {
      case 3851:
        int v20 = *((unsigned __int8 *)v30 + 24);
        *(unsigned char *)(v2 + 300) = v20;
        __int16 v18 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v43 = 67109120;
          *(_DWORD *)&void v43[4] = v20;
          uint64_t v19 = "#I QMI_DMS_WCDMARxDIVERSITY: %u";
LABEL_34:
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, v43, 8u);
        }
        break;
      case 58001:
        int v21 = *((unsigned __int8 *)v30 + 24);
        *(unsigned char *)(v2 + 301) = v21;
        __int16 v18 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v43 = 67109120;
          *(_DWORD *)&void v43[4] = v21;
          uint64_t v19 = "#I QMI_DMS_WCDMATxDIVERSITY: %u";
          goto LABEL_34;
        }
        break;
      case 58002:
        int v17 = *((unsigned __int8 *)v30 + 24);
        *(unsigned char *)(v2 + 298) = v17;
        __int16 v18 = *(NSObject **)(v2 + 40);
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          break;
        }
        *(_DWORD *)uint64_t v43 = 67109120;
        *(_DWORD *)&void v43[4] = v17;
        uint64_t v19 = "#I QMI_DMS_C2KTxDIVERSITY: %u";
        goto LABEL_34;
      default:
        break;
    }
LABEL_35:
    _Block_object_dispose(&v29, 8);
    _Block_object_dispose(&v33, 8);
    goto LABEL_36;
  }
  uint64_t v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I NVREAD was not successful: errorcode = 0x%x", buf, 8u);
  }
LABEL_36:
  sub_1007671C4(&v24);
  return sub_100046B58((uint64_t *)&v23);
}

void sub_100767170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  uint64_t v22 = *(void **)(v20 - 112);
  if (v22)
  {
    *(void *)(v20 - 104) = v22;
    operator delete(v22);
  }
  _Block_object_dispose(&a16, 8);
  _Block_object_dispose(&a20, 8);
  sub_1007671C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1007671C4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    qmi::MessageBase::~MessageBase((qmi::MessageBase *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100767214(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t sub_100767228(uint64_t result, unsigned char **a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = **a2;
  return result;
}

void sub_100767240(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void *)(*(void *)a1 + 104);
  if (*(unsigned char *)(v2 + 72) && *(void *)(v2 + 56))
  {
    *(_OWORD *)long long __p = 0u;
    long long v16 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x5559u);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    void v13[2] = sub_10076764C;
    uint64_t v13[3] = &unk_101A03D78;
    long long v14 = *(_OWORD *)(a1 + 8);
    uint64_t v4 = (const void **)__p[1];
    if (__p[1] != (void *)v16)
    {
      while (*((unsigned char *)*v4 + 8) != 1)
      {
        if (++v4 == (const void **)v16) {
          goto LABEL_10;
        }
      }
    }
    if (v4 == (const void **)v16) {
LABEL_10:
    }
      operator new();
    if (!v5) {
      __cxa_bad_cast();
    }
    sub_10076764C((uint64_t)v13, (uint64_t)v5 + 16);
    int v6 = (std::__shared_weak_count *)v1[2];
    if (!v6 || (v7 = v1[13], uint64_t v8 = v1[1], (v9 = std::__shared_weak_count::lock(v6)) == 0)) {
      sub_100088B9C();
    }
    BOOL v10 = v9;
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
    if (!*(unsigned char *)(v7 + 72) || !*(void *)(v7 + 56)) {
      __TUAssertTrigger();
    }
    uint64_t v21 = v7 + 40;
    uint64_t v22 = QMIServiceMsg::create((QMIServiceMsg *)__p, v11);
    int v23 = 25000;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 1174405120;
    v17[2] = sub_100767834;
    uint64_t v17[3] = &unk_101A03DE8;
    void v17[4] = v8;
    __int16 v18 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v19 = sub_10075C0DC;
    uint64_t v20 = 0;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_1007649C0;
    aBlock[3] = &unk_101A03AB8;
    void aBlock[4] = v17;
    uint64_t v12 = _Block_copy(aBlock);
    uint64_t v25 = v12;
    if (v22)
    {
      qmi::Client::send();
      uint64_t v12 = v25;
    }
    if (v12) {
      _Block_release(v12);
    }
    if (v18) {
      std::__shared_weak_count::__release_weak(v18);
    }
    std::__shared_weak_count::__release_weak(v10);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_100767608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,char a27)
{
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }
  sub_10075CFC0((uint64_t)&a27);
  std::__shared_weak_count::__release_weak(v27);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  _Unwind_Resume(a1);
}

void *sub_10076764C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a2 = 0;
  return sub_10076479C((void *)(a2 + 8), **(char ***)(a1 + 32), (char *)(**(void **)(a1 + 32) + **(int **)(a1 + 40)), **(int **)(a1 + 40));
}

void *sub_10076766C(void *a1)
{
  *a1 = off_101A03DC0;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1007676BC(void *a1)
{
  *a1 = off_101A03DC0;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_10076772C(uint64_t a1)
{
  return sub_10006E43C(a1 + 16);
}

void *sub_100767734(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = (unsigned char *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006E44C((unsigned char **)a2, a1 + 16);
  uint64_t v7 = (unsigned char *)(*a2 - v5);
  unsigned char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void sub_100767790()
{
}

void sub_100767810()
{
}

void sub_100767834(void *a1, uint64_t a2)
{
  char v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        uint64_t v8 = (void (*)(void *, uint64_t))a1[6];
        uint64_t v9 = a1[7];
        BOOL v10 = (void *)(v7 + (v9 >> 1));
        if (v9) {
          uint64_t v8 = *(void (**)(void *, uint64_t))(*v10 + v8);
        }
        v8(v10, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1007678E8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1007678FC(uint64_t a1)
{
}

uint64_t *sub_100767904(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 12);
  if (v3)
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v3;
      __int16 v16 = 2080;
      uint64_t v17 = qmi::asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Error in response with code = 0x%x (%s)", buf, 0x12u);
      int v3 = *(_DWORD *)(v1 + 12);
    }
    if (v3 == 41 && (++dword_101B0D63C, dword_101B0D63C != 10))
    {
      *(void *)long long buf = 0;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 544) + 16))(buf);
      __p[0] = 0;
      (*(void (**)(void **__return_ptr))(**(void **)(v2 + 544) + 16))(__p);
      long long v14 = 0;
      (*(void (**)(__CFString **__return_ptr))(**(void **)(v2 + 544) + 16))(&v14);
      qword_101B0D648 = (uint64_t)sub_10037351C(0x78u, *(void **)buf, __p[0], v14, 4, 0, (void *)qword_101B0D660, (void *)qword_101B0D668);
      RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, (CFUserNotificationRef)qword_101B0D648, (CFUserNotificationCallBack)sub_1007562CC, 0);
      if (RunLoopSource)
      {
        CFRunLoopAddSource((CFRunLoopRef)qword_101B13DE0, RunLoopSource, kCFRunLoopDefaultMode);
        CFRelease(RunLoopSource);
      }
      else
      {
        CFUserNotificationCancel((CFUserNotificationRef)qword_101B0D648);
        CFRelease((CFTypeRef)qword_101B0D648);
      }
      sub_1000558F4((const void **)&v14);
    }
    else
    {
      *(void *)long long buf = 0;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 544) + 16))(buf);
      __p[0] = 0;
      (*(void (**)(void **__return_ptr))(**(void **)(v2 + 544) + 16))(__p);
      qword_101B0D648 = _CreateSimpleUserNotification(0x78u, *(const __CFString **)buf, (const __CFString *)__p[0]);
    }
    sub_1000558F4((const void **)__p);
    int v6 = (const void **)buf;
  }
  else
  {
    long long v14 = 0;
    (*(void (**)(__CFString **__return_ptr))(**(void **)(v2 + 544) + 16))(&v14);
    CFStringRef v13 = 0;
    (*(void (**)(const __CFString **__return_ptr))(**(void **)(v2 + 544) + 16))(&v13);
    qword_101B0D648 = _CreateSimpleUserNotification(0x78u, v14, v13);
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Resetting Baseband after succesfully setting AKEY", buf, 2u);
    }
    sub_100058DB0(__p, "Resetting Baseband after succesfully setting AKEY ");
    rest::ResetPayload::ResetPayload();
    sub_1004BC4DC();
    if (v18 < 0) {
      operator delete(*(void **)buf);
    }
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    sub_1000558F4((const void **)&v13);
    int v6 = (const void **)&v14;
  }
  sub_1000558F4(v6);
  sub_100765BE8(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100767DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, const void *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_100767EA8(void *a1, void *a2)
{
  int v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        uint64_t v9 = (void (*)(void *, void *))a1[6];
        uint64_t v8 = a1[7];
        uint64_t v10 = (void *)(v7 + (v8 >> 1));
        if (v8) {
          uint64_t v9 = *(void (**)(void *, void *))(*v10 + v9);
        }
        uint64_t v11 = a2[1];
        v13[0] = *a2;
        v13[1] = v11;
        uint64_t v12 = a2[2];
        void v13[2] = v12;
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
        }
        qmi::MessageBase::validateMsgId((qmi::MessageBase *)v13, 0x2Cu);
        v9(v10, v13);
        qmi::MessageBase::~MessageBase((qmi::MessageBase *)v13);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100767F88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_100767FA8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 12);
  if (v3)
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v3;
      LOWORD(v16) = 2080;
      *(void *)((char *)&v16 + 2) = qmi::asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Error in response with code = 0x%x (%s)", buf, 0x12u);
    }
  }
  else
  {
    uint64_t v5 = (unsigned __int16 *)(v1 + 8);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&long long v16 = 0x40000000;
    *((void *)&v16 + 1) = sub_100768150;
    uint64_t v17 = &unk_101A03E68;
    uint64_t v18 = v2;
    TlvCFNumberRef Value = qmi::MessageBase::findTlvValue((qmi::MessageBase *)(v1 + 8));
    uint64_t v8 = TlvValue;
    if (TlvValue)
    {
      int v9 = v7;
      uint64_t v14 = TlvValue;
      char v13 = sub_10006EA28((unint64_t *)&v14, v7);
      if (v14) {
        (*((void (**)(uint8_t *, char *))&v16 + 1))(buf, &v13);
      }
      else {
        qmi::MessageBase::sParsingErrorHandler(*v5, 1, v8, v9);
      }
    }
  }
  sub_100765BE8(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100768134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100768150(uint64_t result, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(result + 32) + 295) = *a2;
  return result;
}

const void **sub_100768160(uint64_t *a1)
{
  uint64_t v2 = *a1;
  CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (theDict) {
    int v3 = sub_1000C06D0;
  }
  else {
    int v3 = 0;
  }
  if (v3)
  {
    int v4 = *(unsigned __int8 *)(v2 + 295);
    if (v4 == 255) {
      int v4 = -1;
    }
    int valuePtr = v4;
    value[0] = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    int v5 = *(unsigned __int8 *)(v2 + 296);
    if (v5 == 255) {
      int v5 = -1;
    }
    int v34 = v5;
    uint64_t v33 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v34);
    CFDictionarySetValue(theDict, @"kCTBasebandAccessOverloadClass", value[0]);
    CFDictionarySetValue(theDict, @"kCTBasebandProtocolRevision", v33);
    if (*(unsigned char *)(v2 + 297)) {
      CFStringRef v6 = @"kCTBasebandDiversityUnknown";
    }
    else {
      CFStringRef v6 = @"kCTBasebandDiversityOff";
    }
    if (*(unsigned char *)(v2 + 297) == 1) {
      CFStringRef v7 = @"kCTBasebandDiversityOn";
    }
    else {
      CFStringRef v7 = v6;
    }
    CFDictionarySetValue(theDict, @"kCTBasebandRx1xDiversity", v7);
    if (*(unsigned char *)(v2 + 298)) {
      CFStringRef v8 = @"kCTBasebandDiversityUnknown";
    }
    else {
      CFStringRef v8 = @"kCTBasebandDiversityOff";
    }
    if (*(unsigned char *)(v2 + 298) == 1) {
      CFStringRef v9 = @"kCTBasebandDiversityOn";
    }
    else {
      CFStringRef v9 = v8;
    }
    CFDictionarySetValue(theDict, @"kCTBasebandTxC2KDiversity", v9);
    if (*(unsigned char *)(v2 + 299)) {
      CFStringRef v10 = @"kCTBasebandDiversityUnknown";
    }
    else {
      CFStringRef v10 = @"kCTBasebandDiversityOff";
    }
    if (*(unsigned char *)(v2 + 299) == 1) {
      CFStringRef v11 = @"kCTBasebandDiversityOn";
    }
    else {
      CFStringRef v11 = v10;
    }
    CFDictionarySetValue(theDict, @"kCTBasebandRxDODiversity", v11);
    if (*(unsigned char *)(v2 + 300)) {
      CFStringRef v12 = @"kCTBasebandDiversityUnknown";
    }
    else {
      CFStringRef v12 = @"kCTBasebandDiversityOff";
    }
    if (*(unsigned char *)(v2 + 300) == 3) {
      CFStringRef v13 = @"kCTBasebandDiversityOn";
    }
    else {
      CFStringRef v13 = v12;
    }
    CFDictionarySetValue(theDict, @"kCTBasebandRxWCDMADiversity", v13);
    if (*(unsigned char *)(v2 + 301)) {
      CFStringRef v14 = @"kCTBasebandDiversityUnknown";
    }
    else {
      CFStringRef v14 = @"kCTBasebandDiversityOff";
    }
    if (*(unsigned char *)(v2 + 301) == 1) {
      CFStringRef v15 = @"kCTBasebandDiversityOn";
    }
    else {
      CFStringRef v15 = v14;
    }
    CFDictionarySetValue(theDict, @"kCTBasebandTxWCDMADiversity", v15);
    if (*(_WORD *)(v2 + 302) == 1) {
      long long v16 = kCTBasebandRxAntennaConfigSecondary;
    }
    else {
      long long v16 = kCTBasebandRxAntennaConfigDefault;
    }
    if (*(_WORD *)(v2 + 302)) {
      uint64_t v17 = (const void **)v16;
    }
    else {
      uint64_t v17 = (const void **)kCTBasebandRxAntennaConfigPrimary;
    }
    CFDictionarySetValue(theDict, @"kCTBasebandRxAntennaConfig", *v17);
    if (*(_WORD *)(v2 + 304) == 1) {
      uint64_t v18 = kCTBasebandRxDiversityEnabled;
    }
    else {
      uint64_t v18 = kCTBasebandRxDiversityUnknown;
    }
    if (*(_WORD *)(v2 + 304)) {
      uint64_t v19 = (const void **)v18;
    }
    else {
      uint64_t v19 = (const void **)kCTBasebandRxDiversityDisabled;
    }
    CFDictionarySetValue(theDict, @"kCTBasebandRxDiversity", *v19);
    uint64_t v20 = kCTBasebandTxAntennaConfig0;
    switch(*(_WORD *)(v2 + 306))
    {
      case 0:
        break;
      case 1:
        uint64_t v20 = kCTBasebandTxAntennaConfig1;
        break;
      case 2:
        goto LABEL_58;
      case 3:
        uint64_t v20 = kCTBasebandTxAntennaConfig3;
        break;
      case 4:
        uint64_t v20 = kCTBasebandTxAntennaConfig4;
        break;
      default:
        if (*(_WORD *)(v2 + 306) == 255) {
          uint64_t v20 = kCTBasebandTxAntennaConfigUnsupported;
        }
        else {
LABEL_58:
        }
          uint64_t v20 = kCTBasebandTxAntennaConfigUnknown;
        break;
    }
    CFDictionarySetValue(theDict, @"kCTBasebandTxAntennaConfig", *v20);
    unint64_t v22 = *(__int16 *)(v2 + 308);
    if (v22 > 2) {
      int v23 = kCTBasebandARTDUnknown;
    }
    else {
      int v23 = off_101A041B8[v22];
    }
    CFDictionarySetValue(theDict, @"kCTBasebandARTDConfig", *v23);
    CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, theDict, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    theCFDataRef Data = Data;
    if (Data) {
      uint64_t v25 = sub_10008324C;
    }
    else {
      uint64_t v25 = 0;
    }
    if (v25)
    {
      int Length = CFDataGetLength(Data);
      **(_DWORD **)a1[1] = Length;
      if (vm_allocate(mach_task_self_, *(vm_address_t **)a1[2], Length, 1))
      {
        uint64_t v27 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v31 = 0;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I _CTSettingsCopyBasebandSettings - couldn't allocate memory for destination buffer", v31, 2u);
        }
      }
      else
      {
        uint64_t v28 = **(void ***)a1[2];
        BytePtr = CFDataGetBytePtr(theData);
        memcpy(v28, BytePtr, **(int **)a1[1]);
      }
    }
    sub_100030068((const void **)&theData);
    sub_1000570E8((const void **)&v33);
    sub_1000570E8((const void **)value);
  }
  else
  {
    uint64_t v21 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(value[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#E _CTSettingsCopyBasebandSettings - failed to create baseband settings dictionary!", (uint8_t *)value, 2u);
    }
    **(_DWORD **)a1[1] = 0;
  }
  return sub_10005717C((const void **)&theDict);
}

void sub_1007685E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v5 = va_arg(va2, const void *);
  uint64_t v7 = va_arg(va2, void);
  va_copy(va3, va2);
  CFStringRef v8 = va_arg(va3, const void *);
  uint64_t v10 = va_arg(va3, void);
  uint64_t v11 = va_arg(va3, void);
  sub_100030068((const void **)va);
  sub_1000570E8((const void **)va1);
  sub_1000570E8((const void **)va2);
  sub_10005717C((const void **)va3);
  _Unwind_Resume(a1);
}

const void **sub_100768648(uint64_t a1)
{
  return sub_100768160(*(uint64_t **)(a1 + 40));
}

const void **sub_100768650(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  CFDataRef v2 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, **(const UInt8 ***)a1, **(void **)(a1 + 8), kCFAllocatorNull);
  *(void *)&long long aBlock = v2;
  CFDictionaryRef theDict = 0;
  if (v2) {
    int v3 = sub_10008324C;
  }
  else {
    int v3 = 0;
  }
  if (v3)
  {
    CFPropertyListFormat format = kCFPropertyListXMLFormat_v1_0;
    CFTypeRef v74 = CFPropertyListCreateWithData(kCFAllocatorDefault, v2, 0, &format, 0);
    *(void *)long long buf = 0;
    int v4 = (const void **)sub_100084068(buf, &v74);
    CFDictionaryRef theDict = *(CFDictionaryRef *)buf;
    *(void *)long long buf = 0;
    sub_100057D78(v4);
  }
  sub_100030068((const void **)&aBlock);
  if (theDict) {
    int v5 = sub_100080778;
  }
  else {
    int v5 = 0;
  }
  if (!v5) {
    return sub_100057D78((const void **)&theDict);
  }
  uint64_t v6 = 0;
  char v7 = 1;
  do
  {
    char v8 = v7;
    if (CFDictionaryContainsKey(theDict, *((const void **)&unk_101B0D638 + v6 + 7)))
    {
      CFStringRef v12 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I SPC required for setting baseband settings", buf, 2u);
      }
      sub_100058140((const void **)(v1 + 320), (const void **)&theDict);
      sub_10075AD3C(v1, 0, 0);
      return sub_100057D78((const void **)&theDict);
    }
    char v7 = 0;
    uint64_t v6 = 1;
  }
  while ((v8 & 1) != 0);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"kCTBasebandRxDiversity");
  CFStringRef v10 = Value;
  if (Value)
  {
    if (CFStringCompare(Value, @"kCTBasebandRxDiversityDisabled", 0))
    {
      if (CFStringCompare(v10, @"kCTBasebandRxDiversityEnabled", 0))
      {
        int v11 = *(unsigned __int16 *)(v1 + 304);
      }
      else
      {
        int v11 = 1;
        *(_WORD *)(v1 + 304) = 1;
      }
    }
    else
    {
      int v11 = 0;
      *(_WORD *)(v1 + 304) = 0;
    }
    uint64_t v13 = *(void *)(v1 + 136);
    if (*(unsigned char *)(v13 + 72) && *(void *)(v13 + 56))
    {
      CFStringRef v14 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I sendSetRxDiversityEnable_sync = %d", buf, 8u);
      }
      *(_OWORD *)long long __p = 0u;
      long long v80 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 9u);
      CFTypeRef v74 = _NSConcreteStackBlock;
      uint64_t v75 = 0x40000000;
      long long v76 = sub_10075C8D0;
      long long v77 = &unk_101A02FA8;
      __int16 v78 = v11;
      CFStringRef v15 = (const void **)__p[1];
      if (__p[1] != (void *)v80)
      {
        while (*((unsigned char *)*v15 + 8) != 1)
        {
          if (++v15 == (const void **)v80) {
            goto LABEL_35;
          }
        }
      }
      if (v15 == (const void **)v80) {
LABEL_35:
      }
        operator new();
      if (!v17) {
        __cxa_bad_cast();
      }
      sub_10075C8D0((uint64_t)&v74, v17 + 5);
      uint64_t v18 = *(std::__shared_weak_count **)(v1 + 16);
      if (!v18
        || (uint64_t v19 = *(void *)(v1 + 136), v20 = *(void *)(v1 + 8), (v21 = std::__shared_weak_count::lock(v18)) == 0))
      {
        sub_100088B9C();
      }
      unint64_t v22 = v21;
      atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      if (!*(unsigned char *)(v19 + 72) || !*(void *)(v19 + 56)) {
        __TUAssertTrigger();
      }
      CFPropertyListFormat format = v19 + 40;
      uint64_t v82 = QMIServiceMsg::create((QMIServiceMsg *)__p, v23);
      int v83 = 25000;
      uint64_t v84 = 0;
      uint64_t v85 = 0;
      *(void *)long long buf = _NSConcreteStackBlock;
      uint64_t v90 = 1174405120;
      v91 = sub_10076A5C4;
      uint64_t v92 = &unk_101A04038;
      uint64_t v93 = v20;
      uint64_t v94 = v22;
      atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v95 = sub_10075C8DC;
      uint64_t v96 = 0;
      *(void *)&long long aBlock = _NSConcreteStackBlock;
      *((void *)&aBlock + 1) = 0x40000000;
      *(void *)&long long v87 = sub_1007649C0;
      *((void *)&v87 + 1) = &unk_101A03AB8;
      char v88 = buf;
      uint64_t v24 = _Block_copy(&aBlock);
      uint64_t v85 = v24;
      if (v82)
      {
        qmi::Client::send();
        uint64_t v24 = v85;
      }
      if (v24) {
        _Block_release(v24);
      }
      if (v94) {
        std::__shared_weak_count::__release_weak(v94);
      }
      std::__shared_weak_count::__release_weak(v22);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
    }
    else
    {
      long long v16 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I sendSetRxDiversityEnable_sync cannot send yet", buf, 2u);
      }
    }
  }
  CFStringRef v25 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCTBasebandTxAntennaConfig");
  CFStringRef v26 = v25;
  if (v25)
  {
    if (CFStringCompare(v25, @"kCTBasebandTxAntennaConfig0", 0))
    {
      if (CFStringCompare(v26, @"kCTBasebandTxAntennaConfig1", 0))
      {
        if (CFStringCompare(v26, @"kCTBasebandTxAntennaConfig3", 0))
        {
          if (CFStringCompare(v26, @"kCTBasebandTxAntennaConfig4", 0))
          {
            int v27 = *(unsigned __int16 *)(v1 + 306);
LABEL_59:
            uint64_t v28 = *(void *)(v1 + 136);
            if (*(unsigned char *)(v28 + 72) && *(void *)(v28 + 56))
            {
              uint64_t v29 = *(NSObject **)(v1 + 40);
              if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v27;
                _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I sendSetAntennaConfig_sync = %d", buf, 8u);
              }
              long long aBlock = 0u;
              long long v87 = 0u;
              qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&aBlock, 7u);
              *(void *)long long buf = _NSConcreteStackBlock;
              uint64_t v90 = 0x40000000;
              v91 = sub_10075CA10;
              uint64_t v92 = &unk_101A02FC8;
              LOWORD(v93) = v27;
              long long v30 = (const void **)*((void *)&aBlock + 1);
              if (*((void *)&aBlock + 1) != (void)v87)
              {
                while (*((unsigned char *)*v30 + 8) != 16)
                {
                  if (++v30 == (const void **)v87) {
                    goto LABEL_72;
                  }
                }
              }
              if (v30 == (const void **)v87) {
LABEL_72:
              }
                operator new();
              if (!v32) {
                __cxa_bad_cast();
              }
              sub_10075CA10((uint64_t)buf, v32 + 5);
              uint64_t v33 = *(std::__shared_weak_count **)(v1 + 16);
              if (!v33
                || (uint64_t v34 = *(void *)(v1 + 136),
                    CFPropertyListFormat v35 = *(void *)(v1 + 8),
                    (int v36 = std::__shared_weak_count::lock(v33)) == 0))
              {
                sub_100088B9C();
              }
              uint64_t v37 = v36;
              CFPropertyListFormat format = v35;
              uint64_t v82 = (uint64_t)v36;
              atomic_fetch_add_explicit(&v36->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v36);
              sub_10075CA1C(v34, (QMIServiceMsg *)&aBlock, &format, (uint64_t)sub_10075CBA4, 0);
              std::__shared_weak_count::__release_weak(v37);
              qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&aBlock);
            }
            else
            {
              uint64_t v31 = *(NSObject **)(v1 + 40);
              if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I sendSetAntennaConfig_sync cannot send yet", buf, 2u);
              }
            }
            goto LABEL_76;
          }
          int v27 = 4;
        }
        else
        {
          int v27 = 3;
        }
      }
      else
      {
        int v27 = 1;
      }
      *(_WORD *)(v1 + 306) = v27;
      goto LABEL_59;
    }
    int v27 = 0;
    *(_WORD *)(v1 + 306) = 0;
    goto LABEL_59;
  }
LABEL_76:
  CFStringRef v38 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCTBasebandARTDConfig");
  CFStringRef v39 = v38;
  if (v38)
  {
    if (CFStringCompare(v38, @"kCTBasebandARTDDisabled", 0))
    {
      if (CFStringCompare(v39, @"kCTBasebandARTDEnabled", 0))
      {
        int v40 = *(unsigned __int16 *)(v1 + 308);
      }
      else
      {
        int v40 = 1;
        *(_WORD *)(v1 + 308) = 1;
      }
    }
    else
    {
      int v40 = 0;
      *(_WORD *)(v1 + 308) = 0;
    }
    uint64_t v41 = *(void *)(v1 + 136);
    if (*(unsigned char *)(v41 + 72) && *(void *)(v41 + 56))
    {
      uint64_t v42 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v40;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I sendSetARTDConfig_sync = %d", buf, 8u);
      }
      long long aBlock = 0u;
      long long v87 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&aBlock, 7u);
      *(void *)long long buf = _NSConcreteStackBlock;
      uint64_t v90 = 0x40000000;
      v91 = sub_10075CCD8;
      uint64_t v92 = &unk_101A02FE8;
      LOWORD(v93) = v40;
      uint64_t v43 = (const void **)*((void *)&aBlock + 1);
      if (*((void *)&aBlock + 1) != (void)v87)
      {
        while (*((unsigned char *)*v43 + 8) != 17)
        {
          if (++v43 == (const void **)v87) {
            goto LABEL_95;
          }
        }
      }
      if (v43 == (const void **)v87) {
LABEL_95:
      }
        operator new();
      if (!v45) {
        __cxa_bad_cast();
      }
      sub_10075CCD8((uint64_t)buf, v45 + 5);
      uint64_t v46 = *(std::__shared_weak_count **)(v1 + 16);
      if (!v46
        || (uint64_t v47 = *(void *)(v1 + 136), v48 = *(void *)(v1 + 8), (v49 = std::__shared_weak_count::lock(v46)) == 0))
      {
        sub_100088B9C();
      }
      uint64_t v50 = v49;
      CFPropertyListFormat format = v48;
      uint64_t v82 = (uint64_t)v49;
      atomic_fetch_add_explicit(&v49->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v49);
      sub_10075CA1C(v47, (QMIServiceMsg *)&aBlock, &format, (uint64_t)sub_10075CCE4, 0);
      std::__shared_weak_count::__release_weak(v50);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&aBlock);
    }
    else
    {
      uint64_t v44 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I sendSetARTDConfig_sync cannot send yet", buf, 2u);
      }
    }
  }
  CFStringRef v51 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCTBasebandRxAntennaConfig");
  CFStringRef v52 = v51;
  if (v51)
  {
    if (CFStringCompare(v51, @"kCTBasebandRxAntennaConfigPrimary", 0))
    {
      if (CFStringCompare(v52, @"kCTBasebandRxAntennaConfigSecondary", 0))
      {
        int v53 = *(unsigned __int16 *)(v1 + 302);
      }
      else
      {
        int v53 = 1;
        *(_WORD *)(v1 + 302) = 1;
      }
    }
    else
    {
      int v53 = 0;
      *(_WORD *)(v1 + 302) = 0;
    }
    uint64_t v54 = *(void *)(v1 + 136);
    if (*(unsigned char *)(v54 + 72) && *(void *)(v54 + 56))
    {
      uint64_t v55 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v53;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I sendSetRxAntennaConfig_sync = %d", buf, 8u);
      }
      *(_OWORD *)long long __p = 0u;
      long long v80 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x6602u);
      CFTypeRef v74 = _NSConcreteStackBlock;
      uint64_t v75 = 0x40000000;
      long long v76 = sub_10075CE18;
      long long v77 = &unk_101A03008;
      __int16 v78 = v53;
      int v56 = (const void **)__p[1];
      if (__p[1] != (void *)v80)
      {
        while (*((unsigned char *)*v56 + 8) != 1)
        {
          if (++v56 == (const void **)v80) {
            goto LABEL_118;
          }
        }
      }
      if (v56 == (const void **)v80) {
LABEL_118:
      }
        operator new();
      if (!v58) {
        __cxa_bad_cast();
      }
      sub_10075CE18((uint64_t)&v74, v58 + 5);
      uint64_t v59 = *(std::__shared_weak_count **)(v1 + 16);
      if (!v59
        || (v60 = *(void *)(v1 + 136), uint64_t v61 = *(void *)(v1 + 8), (v62 = std::__shared_weak_count::lock(v59)) == 0))
      {
        sub_100088B9C();
      }
      long long v63 = v62;
      atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v62);
      if (!*(unsigned char *)(v60 + 72) || !*(void *)(v60 + 56)) {
        __TUAssertTrigger();
      }
      CFPropertyListFormat format = v60 + 40;
      uint64_t v82 = QMIServiceMsg::create((QMIServiceMsg *)__p, v64);
      int v83 = 25000;
      uint64_t v84 = 0;
      uint64_t v85 = 0;
      *(void *)long long buf = _NSConcreteStackBlock;
      uint64_t v90 = 1174405120;
      v91 = sub_10076AD0C;
      uint64_t v92 = &unk_101A04188;
      uint64_t v93 = v61;
      uint64_t v94 = v63;
      atomic_fetch_add_explicit(&v63->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v95 = sub_10075CE24;
      uint64_t v96 = 0;
      *(void *)&long long aBlock = _NSConcreteStackBlock;
      *((void *)&aBlock + 1) = 0x40000000;
      *(void *)&long long v87 = sub_1007649C0;
      *((void *)&v87 + 1) = &unk_101A03AB8;
      char v88 = buf;
      long long v65 = _Block_copy(&aBlock);
      uint64_t v85 = v65;
      if (v82)
      {
        qmi::Client::send();
        long long v65 = v85;
      }
      if (v65) {
        _Block_release(v65);
      }
      if (v94) {
        std::__shared_weak_count::__release_weak(v94);
      }
      std::__shared_weak_count::__release_weak(v63);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
    }
    else
    {
      uint64_t v57 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I sendSetRxAntennaConfig_sync cannot send yet", buf, 2u);
      }
    }
  }
  CFStringRef v66 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCTBasebandRx1xDiversity");
  if (v66)
  {
    *(unsigned char *)(v1 + 297) = CFEqual(v66, @"kCTBasebandDiversityOn");
    ++*(_DWORD *)(v1 + 312);
    sub_10075B388((void *)v1, 1018, v1 + 297);
  }
  CFStringRef v67 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCTBasebandTxC2KDiversity");
  if (v67)
  {
    *(unsigned char *)(v1 + 298) = CFEqual(v67, @"kCTBasebandDiversityOn");
    ++*(_DWORD *)(v1 + 312);
    sub_10075B388((void *)v1, 58002, v1 + 298);
  }
  CFStringRef v68 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCTBasebandRxDODiversity");
  if (v68)
  {
    *(unsigned char *)(v1 + 299) = CFEqual(v68, @"kCTBasebandDiversityOn");
    ++*(_DWORD *)(v1 + 312);
    sub_10075B388((void *)v1, 818, v1 + 299);
  }
  CFStringRef v69 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCTBasebandRxWCDMADiversity");
  if (v69)
  {
    if (CFStringCompare(v69, @"kCTBasebandDiversityOn", 0)) {
      char v70 = 0;
    }
    else {
      char v70 = 3;
    }
    *(unsigned char *)(v1 + 300) = v70;
    ++*(_DWORD *)(v1 + 312);
    sub_10075B388((void *)v1, 3851, v1 + 300);
  }
  CFStringRef v71 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCTBasebandTxWCDMADiversity");
  if (v71)
  {
    *(unsigned char *)(v1 + 301) = CFEqual(v71, @"kCTBasebandDiversityOn");
    ++*(_DWORD *)(v1 + 312);
    sub_10075B388((void *)v1, 58001, v1 + 301);
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_1007699A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  int v23 = *(std::__shared_weak_count **)(v21 - 120);
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
  sub_10075CFC0((uint64_t)&a20);
  std::__shared_weak_count::__release_weak(v20);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  sub_100057D78(&a9);
  _Unwind_Resume(a1);
}

const void **sub_100769A74(uint64_t a1)
{
  return sub_100768650(*(void *)(a1 + 40));
}

void *sub_100769A7C(void *a1)
{
  *a1 = off_101A03EF0;
  CFDataRef v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100769ACC(void *a1)
{
  *a1 = off_101A03EF0;
  CFDataRef v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_100769B3C(uint64_t a1)
{
  return sub_10006EA78((void *)(a1 + 16));
}

void *sub_100769B44(uint64_t a1, void **a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (char *)*a2;
  uint64_t v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  uint64_t result = sub_10006EA88(a2, a1 + 16);
  char v7 = (char *)*a2 - v5;
  char *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void sub_100769BA0()
{
}

void sub_100769C20()
{
}

void sub_100769C44(void *a1, uint64_t a2)
{
  char v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        char v8 = (void (*)(void *, uint64_t))a1[6];
        uint64_t v9 = a1[7];
        CFStringRef v10 = (void *)(v7 + (v9 >> 1));
        if (v9) {
          char v8 = *(void (**)(void *, uint64_t))(*v10 + v8);
        }
        v8(v10, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100769CF8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100769D0C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFStringRef v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 12);
  if (v3)
  {
    int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Error in response with code = 0x%x", buf, 8u);
    }
  }
  int v5 = *(_DWORD *)(v2 + 312);
  BOOL v6 = __OFSUB__(v5, 1);
  int v7 = v5 - 1;
  if (v7 < 0 == v6)
  {
    *(_DWORD *)(v2 + 312) = v7;
    if (!v7)
    {
      char v8 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Resetting Baseband after all NV WRITEs", buf, 2u);
      }
      sub_100058DB0(&__p, "Resetting Baseband after successful NV Write");
      rest::ResetPayload::ResetPayload();
      sub_1004BC4DC();
      if (v15 < 0) {
        operator delete(*(void **)buf);
      }
      if (v13 < 0) {
        operator delete(__p);
      }
    }
  }
  sub_100765BE8(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100769E6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  sub_100765BE8(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100769EB8(void *a1, void *a2)
{
  int v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        uint64_t v9 = (void (*)(void *, void *))a1[6];
        uint64_t v8 = a1[7];
        CFStringRef v10 = (void *)(v7 + (v8 >> 1));
        if (v8) {
          uint64_t v9 = *(void (**)(void *, void *))(*v10 + v9);
        }
        uint64_t v11 = a2[1];
        v13[0] = *a2;
        v13[1] = v11;
        uint64_t v12 = a2[2];
        void v13[2] = v12;
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
        }
        qmi::MessageBase::validateMsgId((qmi::MessageBase *)v13, 8u);
        v9(v10, v13);
        qmi::MessageBase::~MessageBase((qmi::MessageBase *)v13);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100769F98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_100769FB8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 12);
  if (v3)
  {
    int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v20[0]) = 67109120;
      HIDWORD(v20[0]) = v3;
      int v5 = "#E Error in response with code = 0x%x";
      BOOL v6 = (uint8_t *)v20;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, v6, 8u);
    }
  }
  else
  {
    uint64_t v7 = (unsigned __int16 *)(v1 + 8);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 0x40000000;
    uint64_t v21 = (uint64_t (*)(uint64_t, int *))sub_10076A1E4;
    unint64_t v22 = &unk_101A03F78;
    uint64_t v23 = v2;
    TlvCFStringRef Value = qmi::MessageBase::findTlvValue((qmi::MessageBase *)(v1 + 8));
    uint64_t v10 = TlvValue;
    if (TlvValue)
    {
      int v11 = v9;
      *(void *)long long buf = TlvValue;
      unint64_t v12 = sub_10006EDBC((_WORD **)buf, v9);
      int v18 = v12;
      __int16 v19 = WORD2(v12);
      if (*(void *)buf) {
        v21((uint64_t)v20, &v18);
      }
      else {
        qmi::MessageBase::sParsingErrorHandler(*v7, 1, v10, v11);
      }
    }
    int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(unsigned __int16 *)(v2 + 306);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Get: Antenna Config: fTxAntennaConfig = 0x%x", buf, 8u);
      int v4 = *(NSObject **)(v2 + 40);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = *(unsigned __int16 *)(v2 + 308);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v14;
      int v5 = "#I Get: Antenna Config: fARTDConfig = %x";
      BOOL v6 = buf;
      goto LABEL_12;
    }
  }
  sub_100765BE8(&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_10076A1C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_100765BE8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10076A1E4(uint64_t result, _WORD *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  *(_WORD *)(v2 + 306) = *a2;
  *(_WORD *)(v2 + 308) = a2[2];
  return result;
}

void sub_10076A1FC(void *a1, void *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        int v9 = (void (*)(void *, void *))a1[6];
        uint64_t v8 = a1[7];
        uint64_t v10 = (void *)(v7 + (v8 >> 1));
        if (v8) {
          int v9 = *(void (**)(void *, void *))(*v10 + v9);
        }
        uint64_t v11 = a2[1];
        v13[0] = *a2;
        v13[1] = v11;
        uint64_t v12 = a2[2];
        void v13[2] = v12;
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
        }
        qmi::MessageBase::validateMsgId((qmi::MessageBase *)v13, 0x6603u);
        v9(v10, v13);
        qmi::MessageBase::~MessageBase((qmi::MessageBase *)v13);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10076A2DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_10076A2FC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 12);
  if (v3)
  {
    int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v17[0]) = 67109120;
      HIDWORD(v17[0]) = v3;
      int v5 = "#E Error in response with code = 0x%x";
      BOOL v6 = (uint8_t *)v17;
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, v6, 8u);
    }
  }
  else
  {
    uint64_t v7 = (unsigned __int16 *)(v1 + 8);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    int v18 = sub_10076A4D4;
    __int16 v19 = &unk_101A03FC8;
    uint64_t v20 = v2;
    TlvCFStringRef Value = qmi::MessageBase::findTlvValue((qmi::MessageBase *)(v1 + 8));
    uint64_t v10 = TlvValue;
    if (TlvValue)
    {
      int v11 = v9;
      *(void *)long long buf = TlvValue;
      __int16 v16 = sub_10006ECF8((unint64_t *)buf, v9);
      if (*(void *)buf) {
        v18((uint64_t)v17, &v16);
      }
      else {
        qmi::MessageBase::sParsingErrorHandler(*v7, 1, v10, v11);
      }
    }
    int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(unsigned __int16 *)(v2 + 302);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v12;
      int v5 = "#I Get: RX Antenna Config: 0x%x";
      BOOL v6 = buf;
      goto LABEL_10;
    }
  }
  sub_100765BE8(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_10076A4B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_100765BE8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10076A4D4(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(void *)(result + 32) + 302) = *a2;
  return result;
}

void sub_10076A4E8()
{
}

uint64_t sub_10076A4FC()
{
  return sub_10006ECDC();
}

_WORD **sub_10076A504(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006ECE4((_WORD **)a2, (_WORD *)(a1 + 10));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void sub_10076A560()
{
}

void sub_10076A5C4(void *a1, uint64_t a2)
{
  char v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        uint64_t v8 = (void (*)(void *, uint64_t))a1[6];
        uint64_t v9 = a1[7];
        uint64_t v10 = (void *)(v7 + (v9 >> 1));
        if (v9) {
          uint64_t v8 = *(void (**)(void *, uint64_t))(*v10 + v8);
        }
        v8(v10, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10076A678(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10076A68C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = *((_DWORD *)*a1 + 3);
  int v4 = *(NSObject **)(v2 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (!v5) {
      goto LABEL_7;
    }
    *(_DWORD *)long long buf = 67109120;
    int v9 = v3;
    BOOL v6 = "#E Error in response with code = 0x%x";
  }
  else
  {
    if (!v5) {
      goto LABEL_7;
    }
    int v7 = *(unsigned __int16 *)(v2 + 304);
    *(_DWORD *)long long buf = 67109120;
    int v9 = v7;
    BOOL v6 = "#I Set: Rx Diversity: 0x%x";
  }
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, buf, 8u);
LABEL_7:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)(v1 + 1));
  operator delete();
}

void sub_10076A798()
{
}

uint64_t sub_10076A7AC()
{
  return sub_10006ECDC();
}

_WORD **sub_10076A7B4(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006ECE4((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void sub_10076A810()
{
}

void sub_10076A874(void *a1, uint64_t a2)
{
  char v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        uint64_t v8 = (void (*)(void *, uint64_t))a1[6];
        uint64_t v9 = a1[7];
        uint64_t v10 = (void *)(v7 + (v9 >> 1));
        if (v9) {
          uint64_t v8 = *(void (**)(void *, uint64_t))(*v10 + v8);
        }
        v8(v10, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10076A928(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10076A93C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = *((_DWORD *)*a1 + 3);
  int v4 = *(NSObject **)(v2 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (!v5) {
      goto LABEL_7;
    }
    *(_DWORD *)long long buf = 67109120;
    int v9 = v3;
    BOOL v6 = "#E Error in response with code = 0x%x";
  }
  else
  {
    if (!v5) {
      goto LABEL_7;
    }
    int v7 = *(unsigned __int16 *)(v2 + 306);
    *(_DWORD *)long long buf = 67109120;
    int v9 = v7;
    BOOL v6 = "#I Set: Antenna Config: 0x%x";
  }
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, buf, 8u);
LABEL_7:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)(v1 + 1));
  operator delete();
}

void sub_10076AA48()
{
}

uint64_t sub_10076AA5C()
{
  return sub_10006ECDC();
}

_WORD **sub_10076AA64(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006ECE4((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void sub_10076AAC0()
{
}

void sub_10076AB24(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = *((_DWORD *)*a1 + 3);
  int v4 = *(NSObject **)(v2 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (!v5) {
      goto LABEL_7;
    }
    *(_DWORD *)long long buf = 67109120;
    int v9 = v3;
    BOOL v6 = "#E Error in response with code = 0x%x";
  }
  else
  {
    if (!v5) {
      goto LABEL_7;
    }
    int v7 = *(unsigned __int16 *)(v2 + 308);
    *(_DWORD *)long long buf = 67109120;
    int v9 = v7;
    BOOL v6 = "#I Set: ARTD Config: 0x%x";
  }
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, buf, 8u);
LABEL_7:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)(v1 + 1));
  operator delete();
}

void sub_10076AC30()
{
}

uint64_t sub_10076AC44()
{
  return sub_10006ECDC();
}

_WORD **sub_10076AC4C(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_WORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006ECE4((_WORD **)a2, (_WORD *)(a1 + 10));
  int v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void sub_10076ACA8()
{
}

void sub_10076AD0C(void *a1, uint64_t a2)
{
  char v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        uint64_t v8 = (void (*)(void *, uint64_t))a1[6];
        uint64_t v9 = a1[7];
        uint64_t v10 = (void *)(v7 + (v9 >> 1));
        if (v9) {
          uint64_t v8 = *(void (**)(void *, uint64_t))(*v10 + v8);
        }
        v8(v10, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10076ADC0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10076ADD4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = *((_DWORD *)*a1 + 3);
  int v4 = *(NSObject **)(v2 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (!v5) {
      goto LABEL_7;
    }
    *(_DWORD *)long long buf = 67109120;
    int v9 = v3;
    BOOL v6 = "#E Error in response with code = 0x%x";
  }
  else
  {
    if (!v5) {
      goto LABEL_7;
    }
    int v7 = *(unsigned __int16 *)(v2 + 302);
    *(_DWORD *)long long buf = 67109120;
    int v9 = v7;
    BOOL v6 = "#I Set: RX Antenna Config: 0x%x";
  }
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, buf, 8u);
LABEL_7:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)(v1 + 1));
  operator delete();
}

uint64_t sub_10076AEDC()
{
  qword_101B0D670 = @"kCTBasebandAccessOverloadClass";
  qword_101B0D678 = @"kCTBasebandProtocolRevision";
  qword_101B0D660 = 0;
  __cxa_atexit((void (*)(void *))sub_10075603C, &qword_101B0D660, (void *)&_mh_execute_header);
  qword_101B0D668 = 0;

  return __cxa_atexit((void (*)(void *))sub_10075603C, &qword_101B0D668, (void *)&_mh_execute_header);
}

void sub_10076B0D8()
{
}

void sub_10076B4C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10076BA5C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10076BA78(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    return;
  }
  int v3 = *(_DWORD *)(a2 + 16);
  if (v3 != 2)
  {
    if (v3 != 1) {
      return;
    }
    if (a3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
    }
    int v4 = (std::__shared_weak_count *)a1[1];
    *a1 = a2;
    a1[1] = a3;
    if (!v4) {
      return;
    }
LABEL_11:
    sub_10004D2C8(v4);
    return;
  }
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  int v4 = (std::__shared_weak_count *)a1[3];
  a1[2] = a2;
  a1[3] = a3;
  if (v4) {
    goto LABEL_11;
  }
}

void sub_10076BDF4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10076BFC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  sub_10003B34C((void *)(v19 - 56));
  if (a12) {
    sub_10004D2C8(a12);
  }

  if (a19 < 0) {
    operator delete(__p);
  }
  objc_destroyWeak((id *)(v19 - 64));
  _Unwind_Resume(a1);
}

void sub_10076C0C0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10076C1DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10076C51C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10076C588(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  BOOL v5 = v4;
  if (v3 && [v4 length])
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_1007752B4;
    void v6[3] = &unk_101A04440;
    int v7 = v3;
    id v8 = v5;
    nw_framer_async(v7, v6);
  }
}

void sub_10076C654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10076D2C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, void *a14, uint64_t a15, void *a16, void *a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (a12) {
    sub_10004D2C8(a12);
  }

  _Unwind_Resume(a1);
}

void sub_10076D49C(void *a1, void *a2)
{
  id v3 = a2;
  id v9 = v3;
  if (v3)
  {
    id v4 = v3;
    id v5 = [v4 bytes];
    id v6 = v4;
    id v7 = [v6 bytes];
    id v8 = (char *)[v6 length];
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    sub_1001E7940(a1, v5, (uint64_t)&v8[(void)v7], &v8[(void)v7] - (char *)v5);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_10076D548(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10076D558(uint64_t a1)
{
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  uint64_t v2 = *(id **)(a1 + 8);
  id v3 = **(void ***)a1;
  if (v2)
  {
    id obj = *v2;
    sub_100E34AD8(v3, &obj, (uint64_t)v20);
    objc_storeStrong(v2, obj);
  }
  else
  {
    sub_100E34AD8(v3, 0, (uint64_t)v20);
  }
  if ((_BYTE)v21 && !**(void **)(a1 + 8))
  {
    uint64_t v11 = **(void **)(a1 + 32);
    if (*(_DWORD *)(v11 + 16) == 1)
    {
      unint64_t v12 = *(unsigned __int8 *)(v11 + 24);
      uint64_t v13 = **(void **)(a1 + 16);
      if (v12 > 2)
      {
        __int16 v16 = sub_100200FB4(*(id **)(v13 + 32));
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = sub_100BC87FC(WORD4(v20[0]));
          int v18 = sub_10093AA58(HIDWORD(v20[0]));
          *(_DWORD *)long long buf = 134218498;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v23 = 2080;
          uint64_t v24 = v17;
          __int16 v25 = 2080;
          CFStringRef v26 = v18;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid bucket index: %zu, for service: %s, message type: %s", buf, 0x20u);
        }
      }
      else
      {
        *(unsigned char *)(v13 + v12 + 80) = 0;
      }
    }
    *(void *)long long buf = **(void **)(a1 + 48);
    if ((_BYTE)v21) {
      operator new();
    }
    sub_10016C840();
  }
  id v4 = sub_100200FB4(*(id **)(**(void **)(a1 + 16) + 32));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = **(const char ***)(a1 + 8);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "Unable to parse emergency start";
    __int16 v23 = 2112;
    uint64_t v24 = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: %@", buf, 0x16u);
  }

  id v5 = **(void ***)(a1 + 16);
  id v6 = [**(id **)(a1 + 24) msgId];
  uint64_t v7 = *(void *)(a1 + 32);
  NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
  id v8 = +[NSString stringWithUTF8String:"Unable to parse emergency start"];
  uint64_t v28 = v8;
  id v9 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
  uint64_t v10 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
  [v5 deliverNackWithMsgId:v6 toFramer:v7 error:v10];

  return sub_100775310((uint64_t)v20);
}

void sub_10076DA50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100775310((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10076DAEC(uint64_t a1)
{
  uint64_t v21 = 0;
  memset(&v20, 0, 80);
  uint64_t v2 = *(id **)(a1 + 8);
  id v3 = **(void ***)a1;
  if (v2)
  {
    id obj = *v2;
    sub_100E34418(v3, &obj, &v20);
    objc_storeStrong(v2, obj);
  }
  else
  {
    sub_100E34418(v3, 0, &v20);
  }
  if ((_BYTE)v21 && !**(void **)(a1 + 8))
  {
    uint64_t v11 = **(void **)(a1 + 32);
    if (*(_DWORD *)(v11 + 16) == 1)
    {
      unint64_t v12 = *(unsigned __int8 *)(v11 + 24);
      uint64_t v13 = **(void **)(a1 + 16);
      if (v12 > 2)
      {
        __int16 v16 = sub_100200FB4(*(id **)(v13 + 32));
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = sub_100BC87FC(v20.n128_u16[4]);
          int v18 = sub_10093AA58(v20.n128_u32[3]);
          *(_DWORD *)long long buf = 134218498;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v23 = 2080;
          uint64_t v24 = v17;
          __int16 v25 = 2080;
          CFStringRef v26 = v18;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid bucket index: %zu, for service: %s, message type: %s", buf, 0x20u);
        }
      }
      else
      {
        *(unsigned char *)(v13 + v12 + 80) = 0;
      }
    }
    *(void *)long long buf = **(void **)(a1 + 48);
    if ((_BYTE)v21) {
      operator new();
    }
    sub_10016C840();
  }
  id v4 = sub_100200FB4(*(id **)(**(void **)(a1 + 16) + 32));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = **(const char ***)(a1 + 8);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "Unable to parse emergency text";
    __int16 v23 = 2112;
    uint64_t v24 = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: %@", buf, 0x16u);
  }

  id v5 = **(void ***)(a1 + 16);
  id v6 = [**(id **)(a1 + 24) msgId];
  uint64_t v7 = *(void *)(a1 + 32);
  NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
  id v8 = +[NSString stringWithUTF8String:"Unable to parse emergency text"];
  uint64_t v28 = v8;
  id v9 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
  uint64_t v10 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
  [v5 deliverNackWithMsgId:v6 toFramer:v7 error:v10];

  return sub_100775414((uint64_t)&v20);
}

void sub_10076DFF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100775414((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10076E094(uint64_t a1)
{
  long long v21 = 0u;
  memset(v20, 0, sizeof(v20));
  uint64_t v2 = *(id **)(a1 + 8);
  id v3 = **(void ***)a1;
  if (v2)
  {
    id obj = *v2;
    sub_100E3513C(v3, &obj, (uint64_t)v20);
    objc_storeStrong(v2, obj);
  }
  else
  {
    sub_100E3513C(v3, 0, (uint64_t)v20);
  }
  if (BYTE8(v21) && !**(void **)(a1 + 8))
  {
    uint64_t v11 = **(void **)(a1 + 32);
    if (*(_DWORD *)(v11 + 16) == 1)
    {
      unint64_t v12 = *(unsigned __int8 *)(v11 + 24);
      uint64_t v13 = **(void **)(a1 + 16);
      if (v12 > 2)
      {
        __int16 v16 = sub_100200FB4(*(id **)(v13 + 32));
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = sub_100BC87FC(WORD4(v20[0]));
          int v18 = sub_10093AA58(HIDWORD(v20[0]));
          *(_DWORD *)long long buf = 134218498;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v23 = 2080;
          uint64_t v24 = v17;
          __int16 v25 = 2080;
          CFStringRef v26 = v18;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid bucket index: %zu, for service: %s, message type: %s", buf, 0x20u);
        }
      }
      else
      {
        *(unsigned char *)(v13 + v12 + 80) = 0;
      }
    }
    *(void *)long long buf = **(void **)(a1 + 48);
    if (BYTE8(v21)) {
      operator new();
    }
    sub_10016C840();
  }
  id v4 = sub_100200FB4(*(id **)(**(void **)(a1 + 16) + 32));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = **(const char ***)(a1 + 8);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "Unable to parse find my message";
    __int16 v23 = 2112;
    uint64_t v24 = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: %@", buf, 0x16u);
  }

  id v5 = **(void ***)(a1 + 16);
  id v6 = [**(id **)(a1 + 24) msgId];
  uint64_t v7 = *(void *)(a1 + 32);
  NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
  id v8 = +[NSString stringWithUTF8String:"Unable to parse find my message"];
  uint64_t v28 = v8;
  id v9 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
  uint64_t v10 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
  [v5 deliverNackWithMsgId:v6 toFramer:v7 error:v10];

  return sub_10077551C((uint64_t)v20);
}

void sub_10076E584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10077551C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10076E620(uint64_t a1)
{
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  uint64_t v2 = *(id **)(a1 + 8);
  id v3 = **(void ***)a1;
  if (v2)
  {
    id obj = *v2;
    sub_100E35E18(v3, &obj, (uint64_t)v20);
    objc_storeStrong(v2, obj);
  }
  else
  {
    sub_100E35E18(v3, 0, (uint64_t)v20);
  }
  if ((_BYTE)v21 && !**(void **)(a1 + 8))
  {
    uint64_t v11 = **(void **)(a1 + 32);
    if (*(_DWORD *)(v11 + 16) == 1)
    {
      unint64_t v12 = *(unsigned __int8 *)(v11 + 24);
      uint64_t v13 = **(void **)(a1 + 16);
      if (v12 > 2)
      {
        __int16 v16 = sub_100200FB4(*(id **)(v13 + 32));
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = sub_100BC87FC(WORD4(v20[0]));
          int v18 = sub_10093AA58(HIDWORD(v20[0]));
          *(_DWORD *)long long buf = 134218498;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v23 = 2080;
          uint64_t v24 = v17;
          __int16 v25 = 2080;
          CFStringRef v26 = v18;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid bucket index: %zu, for service: %s, message type: %s", buf, 0x20u);
        }
      }
      else
      {
        *(unsigned char *)(v13 + v12 + 80) = 0;
      }
    }
    *(void *)long long buf = **(void **)(a1 + 48);
    if ((_BYTE)v21) {
      operator new();
    }
    sub_10016C840();
  }
  id v4 = sub_100200FB4(*(id **)(**(void **)(a1 + 16) + 32));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = **(const char ***)(a1 + 8);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "Unable to parse roadside start";
    __int16 v23 = 2112;
    uint64_t v24 = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: %@", buf, 0x16u);
  }

  id v5 = **(void ***)(a1 + 16);
  id v6 = [**(id **)(a1 + 24) msgId];
  uint64_t v7 = *(void *)(a1 + 32);
  NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
  id v8 = +[NSString stringWithUTF8String:"Unable to parse roadside start"];
  uint64_t v28 = v8;
  id v9 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
  uint64_t v10 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
  [v5 deliverNackWithMsgId:v6 toFramer:v7 error:v10];

  return sub_100775618((uint64_t)v20);
}

void sub_10076EB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100775618((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10076EC00(uint64_t a1)
{
  uint64_t v21 = 0;
  memset(&v20, 0, 80);
  uint64_t v2 = *(id **)(a1 + 8);
  id v3 = **(void ***)a1;
  if (v2)
  {
    id obj = *v2;
    sub_100E35688(v3, &obj, &v20);
    objc_storeStrong(v2, obj);
  }
  else
  {
    sub_100E35688(v3, 0, &v20);
  }
  if ((_BYTE)v21 && !**(void **)(a1 + 8))
  {
    uint64_t v11 = **(void **)(a1 + 32);
    if (*(_DWORD *)(v11 + 16) == 1)
    {
      unint64_t v12 = *(unsigned __int8 *)(v11 + 24);
      uint64_t v13 = **(void **)(a1 + 16);
      if (v12 > 2)
      {
        __int16 v16 = sub_100200FB4(*(id **)(v13 + 32));
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = sub_100BC87FC(v20.n128_u16[4]);
          int v18 = sub_10093AA58(v20.n128_u32[3]);
          *(_DWORD *)long long buf = 134218498;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v23 = 2080;
          uint64_t v24 = v17;
          __int16 v25 = 2080;
          CFStringRef v26 = v18;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid bucket index: %zu, for service: %s, message type: %s", buf, 0x20u);
        }
      }
      else
      {
        *(unsigned char *)(v13 + v12 + 80) = 0;
      }
    }
    *(void *)long long buf = **(void **)(a1 + 48);
    if ((_BYTE)v21) {
      operator new();
    }
    sub_10016C840();
  }
  id v4 = sub_100200FB4(*(id **)(**(void **)(a1 + 16) + 32));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = **(const char ***)(a1 + 8);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "Unable to parse roadside text";
    __int16 v23 = 2112;
    uint64_t v24 = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: %@", buf, 0x16u);
  }

  id v5 = **(void ***)(a1 + 16);
  id v6 = [**(id **)(a1 + 24) msgId];
  uint64_t v7 = *(void *)(a1 + 32);
  NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
  id v8 = +[NSString stringWithUTF8String:"Unable to parse roadside text"];
  uint64_t v28 = v8;
  id v9 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
  uint64_t v10 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
  [v5 deliverNackWithMsgId:v6 toFramer:v7 error:v10];

  return sub_100775734((uint64_t)&v20);
}

void sub_10076F100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100775734((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10076F19C(uint64_t a1)
{
  long long v21 = 0u;
  memset(v20, 0, sizeof(v20));
  uint64_t v2 = *(id **)(a1 + 8);
  id v3 = **(void ***)a1;
  if (v2)
  {
    id obj = *v2;
    sub_100E368A8(v3, &obj, v20);
    objc_storeStrong(v2, obj);
  }
  else
  {
    sub_100E368A8(v3, 0, v20);
  }
  if (BYTE8(v21) && !**(void **)(a1 + 8))
  {
    uint64_t v11 = **(void **)(a1 + 32);
    if (*(_DWORD *)(v11 + 16) == 1)
    {
      unint64_t v12 = *(unsigned __int8 *)(v11 + 24);
      uint64_t v13 = **(void **)(a1 + 16);
      if (v12 > 2)
      {
        __int16 v16 = sub_100200FB4(*(id **)(v13 + 32));
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = sub_100BC87FC(WORD4(v20[0]));
          int v18 = sub_10093AA58(HIDWORD(v20[0]));
          *(_DWORD *)long long buf = 134218498;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v23 = 2080;
          uint64_t v24 = v17;
          __int16 v25 = 2080;
          CFStringRef v26 = v18;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid bucket index: %zu, for service: %s, message type: %s", buf, 0x20u);
        }
      }
      else
      {
        *(unsigned char *)(v13 + v12 + 80) = 0;
      }
    }
    *(void *)long long buf = **(void **)(a1 + 48);
    if (BYTE8(v21)) {
      operator new();
    }
    sub_10016C840();
  }
  id v4 = sub_100200FB4(*(id **)(**(void **)(a1 + 16) + 32));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = **(const char ***)(a1 + 8);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "Unable to parse iMessageLite text";
    __int16 v23 = 2112;
    uint64_t v24 = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: %@", buf, 0x16u);
  }

  id v5 = **(void ***)(a1 + 16);
  id v6 = [**(id **)(a1 + 24) msgId];
  uint64_t v7 = *(void *)(a1 + 32);
  NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
  id v8 = +[NSString stringWithUTF8String:"Unable to parse iMessageLite text"];
  uint64_t v28 = v8;
  id v9 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
  uint64_t v10 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
  [v5 deliverNackWithMsgId:v6 toFramer:v7 error:v10];

  return sub_10077583C((uint64_t)v20);
}

void sub_10076F6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10077583C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10076F750(uint64_t a1)
{
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  uint64_t v2 = *(id **)(a1 + 8);
  id v3 = **(void ***)a1;
  if (v2)
  {
    id obj = *v2;
    sub_100E37938(v3, &obj, v20);
    objc_storeStrong(v2, obj);
  }
  else
  {
    sub_100E37938(v3, 0, v20);
  }
  if ((_BYTE)v21 && !**(void **)(a1 + 8))
  {
    uint64_t v11 = **(void **)(a1 + 32);
    if (*(_DWORD *)(v11 + 16) == 1)
    {
      unint64_t v12 = *(unsigned __int8 *)(v11 + 24);
      uint64_t v13 = **(void **)(a1 + 16);
      if (v12 > 2)
      {
        __int16 v16 = sub_100200FB4(*(id **)(v13 + 32));
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = sub_100BC87FC(WORD4(v20[0]));
          int v18 = sub_10093AA58(HIDWORD(v20[0]));
          *(_DWORD *)long long buf = 134218498;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v23 = 2080;
          uint64_t v24 = v17;
          __int16 v25 = 2080;
          CFStringRef v26 = v18;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid bucket index: %zu, for service: %s, message type: %s", buf, 0x20u);
        }
      }
      else
      {
        *(unsigned char *)(v13 + v12 + 80) = 0;
      }
    }
    *(void *)long long buf = **(void **)(a1 + 48);
    if ((_BYTE)v21) {
      operator new();
    }
    sub_10016C840();
  }
  id v4 = sub_100200FB4(*(id **)(**(void **)(a1 + 16) + 32));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = **(const char ***)(a1 + 8);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "Unable to parse satSMS text";
    __int16 v23 = 2112;
    uint64_t v24 = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: %@", buf, 0x16u);
  }

  id v5 = **(void ***)(a1 + 16);
  id v6 = [**(id **)(a1 + 24) msgId];
  uint64_t v7 = *(void *)(a1 + 32);
  NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
  id v8 = +[NSString stringWithUTF8String:"Unable to parse satSMS text"];
  uint64_t v28 = v8;
  id v9 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
  uint64_t v10 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
  [v5 deliverNackWithMsgId:v6 toFramer:v7 error:v10];

  return sub_100775944((uint64_t)v20);
}

void sub_10076FC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100775944((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10076FD14(uint64_t a1)
{
  long long v21 = 0u;
  memset(v20, 0, sizeof(v20));
  uint64_t v2 = *(id **)(a1 + 8);
  id v3 = **(void ***)a1;
  if (v2)
  {
    id obj = *v2;
    sub_100E37128(v3, &obj, (uint64_t)v20);
    objc_storeStrong(v2, obj);
  }
  else
  {
    sub_100E37128(v3, 0, (uint64_t)v20);
  }
  if (BYTE8(v21) && !**(void **)(a1 + 8))
  {
    uint64_t v11 = **(void **)(a1 + 32);
    if (*(_DWORD *)(v11 + 16) == 1)
    {
      unint64_t v12 = *(unsigned __int8 *)(v11 + 24);
      uint64_t v13 = **(void **)(a1 + 16);
      if (v12 > 2)
      {
        __int16 v16 = sub_100200FB4(*(id **)(v13 + 32));
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = sub_100BC87FC(WORD4(v20[0]));
          int v18 = sub_10093AA58(HIDWORD(v20[0]));
          *(_DWORD *)long long buf = 134218498;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v23 = 2080;
          uint64_t v24 = v17;
          __int16 v25 = 2080;
          CFStringRef v26 = v18;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid bucket index: %zu, for service: %s, message type: %s", buf, 0x20u);
        }
      }
      else
      {
        *(unsigned char *)(v13 + v12 + 80) = 0;
      }
    }
    *(void *)long long buf = **(void **)(a1 + 48);
    if (BYTE8(v21)) {
      operator new();
    }
    sub_10016C840();
  }
  id v4 = sub_100200FB4(*(id **)(**(void **)(a1 + 16) + 32));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = **(const char ***)(a1 + 8);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "Unable to parse iMessageLiteFetch";
    __int16 v23 = 2112;
    uint64_t v24 = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: %@", buf, 0x16u);
  }

  id v5 = **(void ***)(a1 + 16);
  id v6 = [**(id **)(a1 + 24) msgId];
  uint64_t v7 = *(void *)(a1 + 32);
  NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
  id v8 = +[NSString stringWithUTF8String:"Unable to parse iMessageLiteFetch"];
  uint64_t v28 = v8;
  id v9 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
  uint64_t v10 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
  [v5 deliverNackWithMsgId:v6 toFramer:v7 error:v10];

  return sub_100775A50((uint64_t)v20);
}

void sub_100770204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100775A50((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1007703D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100770620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id location, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100770AC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,id location,uint64_t a26,void *a27)
{
  objc_destroyWeak(v29);
  objc_destroyWeak(v28);
  sub_100771AB8(v27);

  objc_destroyWeak(&location);
  objc_destroyWeak((id *)(v30 - 120));
  sub_100771AB8(v30 - 96);
  objc_destroyWeak((id *)(v30 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_100770B28(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = nw_framer_copy_remote_endpoint(v3);
  id v5 = sub_100200FB4(*(id **)(a1 + 40));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Start for: %@, endpoint: %@", buf, 0x16u);
  }

  if (!v4)
  {
    uint64_t v10 = sub_100200FB4(*(id **)(a1 + 40));
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v3;
    uint64_t v17 = "No endpoint found for framer: %@";
    goto LABEL_22;
  }
  hostname = (char *)nw_endpoint_get_hostname(v4);
  if (!hostname)
  {
    uint64_t v10 = sub_100200FB4(*(id **)(a1 + 40));
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v3;
    uint64_t v17 = "No hostname found for framer: %@";
LABEL_22:
    int v18 = v10;
    uint32_t v19 = 12;
LABEL_23:
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
    goto LABEL_63;
  }
  uint64_t v7 = (const std::string *)sub_100058DB0(buf, hostname);
  int v8 = sub_100772300(v7);
  int v9 = v8;
  if ((buf[23] & 0x80000000) == 0)
  {
    if (v8) {
      goto LABEL_7;
    }
    goto LABEL_25;
  }
  operator delete(*(void **)buf);
  if (!v9)
  {
LABEL_25:
    uint64_t v10 = sub_100200FB4(*(id **)(a1 + 40));
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = hostname;
    uint64_t v17 = "Unsupported framer type in framer: %@, for hostname: %s";
    int v18 = v10;
    uint32_t v19 = 22;
    goto LABEL_23;
  }
LABEL_7:
  uint64_t v10 = nw_framer_copy_parameters(v3);
  if (v10)
  {
    int port = nw_endpoint_get_port(v4);
    unsigned int pid = nw_parameters_get_pid();
    sub_100772354();
    uint64_t v13 = (unsigned __int16 *)qword_101B0D688;
    if (qword_101B0D688 == qword_101B0D690)
    {
      unsigned __int8 v14 = 0;
    }
    else
    {
      unsigned __int8 v14 = 0;
      do
      {
        int v15 = *v13;
        if ((v15 & port) != 0)
        {
          unsigned int v16 = v15 == 8 ? 1 : 2 * (v15 == 1);
          if (v16 > v14) {
            unsigned __int8 v14 = v16;
          }
        }
        ++v13;
      }
      while (v13 != (unsigned __int16 *)qword_101B0D690);
    }
    unsigned int v47 = pid;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v55 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
    unint64_t v22 = ServiceMap;
    if (v23 < 0)
    {
      uint64_t v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v23;
    uint64_t v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
    int v46 = v9;
    if (v27)
    {
      uint64_t v29 = v27[3];
      uint64_t v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
LABEL_39:
        if (v29)
        {
          (*(void (**)(unsigned char *__return_ptr, uint64_t, void))(*(void *)v29 + 24))(buf, v29, v47);
          if (SHIBYTE(v55) < 0) {
            operator delete(__p[0]);
          }
          *(_OWORD *)long long __p = *(_OWORD *)buf;
          uint64_t v55 = *(void *)&buf[16];
        }
        if ((v30 & 1) == 0) {
          sub_10004D2C8(v28);
        }
        uint64_t v31 = sub_100200FB4(*(id **)(a1 + 40));
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          if (v14 > 2u) {
            char v32 = "???";
          }
          else {
            char v32 = off_101A047F0[(char)v14];
          }
          uint64_t v33 = (void **)__p[0];
          if (v55 >= 0) {
            uint64_t v33 = __p;
          }
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = v33;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v47;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = v32;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Highest QoS priority service supported by client: %s (%d) is: %s", buf, 0x1Cu);
        }

        uint64_t v34 = v3;
        CFPropertyListFormat v35 = v34;
        if (v34 && v47 != -1)
        {
          int v36 = (char *)operator new(0x50uLL);
          *((void *)v36 + 1) = 0;
          *((void *)v36 + 2) = 0;
          *(void *)int v36 = off_101A04560;
          uint64_t v37 = v35;
          *((_WORD *)v36 + 12) = 0;
          CFStringRef v38 = v37;
          *((void *)v36 + 4) = v38;
          *((_DWORD *)v36 + 10) = v46;
          *((_DWORD *)v36 + 11) = v47;
          v36[48] = v14;
          CFStringRef v39 = v36 + 56;
          if (SHIBYTE(v55) < 0)
          {
            sub_10004FC84(v39, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)CFStringRef v39 = *(_OWORD *)__p;
            *((void *)v36 + 9) = v55;
          }

          uint64_t v41 = *(void **)(a1 + 48);
          objc_copyWeak((id *)buf, (id *)(a1 + 32));
          *(_WORD *)&uint8_t buf[8] = port;
          *(void *)&uint8_t buf[16] = v36 + 24;
          *(void *)&unsigned char buf[24] = v36;
          id v42 = v41;
          operator new();
        }

        int v40 = sub_100200FB4(*(id **)(a1 + 40));
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v35;
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Invalid framer: %@", buf, 0xCu);
        }

        if (SHIBYTE(v55) < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_63;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    uint64_t v28 = 0;
    char v30 = 1;
    goto LABEL_39;
  }
  __n128 v20 = sub_100200FB4(*(id **)(a1 + 40));
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "No params found for framer: %@", buf, 0xCu);
  }

  uint64_t v10 = 0;
LABEL_63:

  input_handler[0] = _NSConcreteStackBlock;
  input_handler[1] = 3321888768;
  input_handler[2] = sub_100771400;
  input_handler[3] = &unk_101A041D0;
  objc_copyWeak(v52, (id *)(a1 + 72));
  uint64_t v43 = *(void **)(a1 + 88);
  v52[1] = *(id *)(a1 + 80);
  id v53 = v43;
  nw_framer_set_input_handler(v3, input_handler);
  nw_framer_set_output_handler(v3, &stru_101A04220);
  cleanup_handler[0] = _NSConcreteStackBlock;
  cleanup_handler[1] = 3321888768;
  cleanup_handler[2] = sub_100771590;
  cleanup_handler[3] = &unk_101A04240;
  objc_copyWeak(v49, (id *)(a1 + 96));
  uint64_t v44 = *(void **)(a1 + 112);
  v49[1] = *(id *)(a1 + 104);
  id v50 = v44;
  nw_framer_set_cleanup_handler(v3, cleanup_handler);
  nw_framer_write_output(v3, (const uint8_t *)"s2i11StewieAgent", 3uLL);

  objc_destroyWeak(v49);
  objc_destroyWeak(v52);

  return 1;
}

void sub_1007712D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v33);
  operator delete(v37);

  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100771400(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (nw_framer_parse_input(v3, 1uLL, 0xFFFFFFFFuLL, 0, &stru_101A045A0))
  {
    id v4 = (id *)(a1 + 32);
    id v5 = *(void **)(a1 + 48);
    objc_copyWeak(v8, v4);
    v8[1] = v3;
    id v6 = v5;
    operator new();
  }

  return 0;
}

void sub_1007714FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100771510(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  id v4 = *(void **)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  id result = v4;
  *(void *)(a1 + 48) = result;
  return result;
}

void sub_100771550(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);

  objc_destroyWeak(v1);
}

void sub_100771590(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v16 = v3;
  id v4 = nw_framer_copy_remote_endpoint(v3);
  id v5 = sub_100200FB4(*(id **)(a1 + 40));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2112;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Cleanup for: %@, endpoint: %@", (uint8_t *)&buf, 0x16u);
  }

  if (v4)
  {
    id v6 = nw_framer_copy_parameters(v3);
    if (v6)
    {
      hostname = (char *)nw_endpoint_get_hostname(v4);
      if (hostname)
      {
        sub_100058DB0(&buf, hostname);
        int v8 = sub_100772300(&buf);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        int v15 = v8;
        if (v8)
        {
          uint16_t port = nw_endpoint_get_port(v4);
          int pid = nw_parameters_get_pid();
          int v9 = *(NSObject **)(a1 + 48);
          v12[0] = &port;
          v12[1] = a1 + 32;
          void v12[2] = &pid;
          void v12[3] = &v15;
          void v12[4] = &v16;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)_NSConcreteStackBlock;
          buf.__r_.__value_.__l.__size_ = 3221225472;
          buf.__r_.__value_.__r.__words[2] = (std::string::size_type)sub_100776108;
          int v18 = &unk_1019A1BF8;
          uint32_t v19 = v12;
          dispatch_sync(v9, &buf);
          goto LABEL_21;
        }
        uint64_t v11 = sub_100200FB4(*(id **)(a1 + 40));
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412546;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)hostname;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Unsupported framer type in framer: %@, for hostname: %s", (uint8_t *)&buf, 0x16u);
        }
      }
      else
      {
        uint64_t v11 = sub_100200FB4(*(id **)(a1 + 40));
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No hostname found for framer: %@", (uint8_t *)&buf, 0xCu);
        }
      }

      goto LABEL_21;
    }
    uint64_t v10 = sub_100200FB4(*(id **)(a1 + 40));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No params found for framer: %@", (uint8_t *)&buf, 0xCu);
    }

    id v6 = 0;
  }
  else
  {
    id v6 = sub_100200FB4(*(id **)(a1 + 40));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "No endpoint found for framer: %@", (uint8_t *)&buf, 0xCu);
    }
  }
LABEL_21:
}

void sub_1007718DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100771930(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  id v4 = *(void **)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  id result = v4;
  *(void *)(a1 + 48) = result;
  return result;
}

void sub_100771970(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);

  objc_destroyWeak(v1);
}

id sub_1007719AC(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  id v4 = *(void **)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  id v5 = v4;
  uint64_t v7 = *(void *)(a2 + 56);
  uint64_t v6 = *(void *)(a2 + 64);
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v7;
  *(void *)(a1 + 64) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  objc_copyWeak((id *)(a1 + 72), (id *)(a2 + 72));
  int v8 = *(void **)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v8;
  objc_copyWeak((id *)(a1 + 96), (id *)(a2 + 96));
  int v9 = *(void **)(a2 + 112);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  id result = v9;
  *(void *)(a1 + 112) = result;
  return result;
}

void sub_100771A3C(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 72);
  id v3 = (id *)(a1 + 96);

  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  id v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }

  objc_destroyWeak((id *)(a1 + 32));
}

uint64_t sub_100771AB8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }

  objc_destroyWeak((id *)a1);
  return a1;
}

void sub_100772174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  _Unwind_Resume(a1);
}

void sub_10077224C(void *a1)
{
  id v1 = a1;
  nw_parameters_get_pid();
  *(void *)uu = 0;
  uint64_t v3 = 0;
  nw_parameters_get_e_proc_uuid();
  if (!uuid_is_null(uu)) {
}
  }

void sub_1007722E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100772300(const std::string *a1)
{
  if (!std::string::compare(a1, "dataclientOne")) {
    return 1;
  }
  else {
    return 2 * (std::string::compare(a1, "dataclientTwo") == 0);
  }
}

void sub_100772354()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D680, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101B0D680))
    {
      uint64_t v0 = 0x20001000080001;
      int v1 = 131076;
      sub_1007761F4(&v0, 6);
      __cxa_atexit((void (*)(void *))sub_10077628C, &qword_101B0D688, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D680);
    }
  }
}

void sub_100772418(_Unwind_Exception *a1)
{
}

void sub_1007727D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100772CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  _Unwind_Resume(a1);
}

void sub_100772D9C(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v7 = WeakRetained;
  if (WeakRetained) {
    [WeakRetained startFlowForClient:v8 assign:v5];
  }
}

void sub_100772E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100772E38(uint64_t a1, void *a2)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained) {
    [WeakRetained stopFlowForClient:v5];
  }
}

void sub_100772E9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100773450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,void *a61,uint64_t a62,int a63)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  if (a66 < 0) {
    operator delete(a61);
  }
  if (a72 < 0) {
    operator delete(a67);
  }

  _Unwind_Resume(a1);
}

void sub_1007739FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10077401C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007742A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)StewieNWAgent;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void *sub_100774810(void *a1, uint64_t a2, id *a3)
{
  *a1 = &off_101A04370;
  uint64_t v6 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v10, kCtLoggingSystemName, "stw.agt");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v10);
  ctu::OsLogLogger::OsLogLogger(v6, (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
  *a1 = off_101A04300;
  uint64_t v7 = [StewieNWAgent alloc];
  id v8 = sub_100200FB4(a3);
  a1[2] = [(StewieNWAgent *)v7 initWithRegistry:a2 queue:v8];

  return a1;
}

void sub_10077490C(_Unwind_Exception *a1)
{
  ctu::OsLogLogger::~OsLogLogger(v1);
  _Unwind_Resume(a1);
}

id sub_100774954(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 16);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v6 = *a2;
  uint64_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  id v4 = [v2 startWithDelegate:&v6];
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  return v4;
}

void sub_1007749B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  _Unwind_Resume(exception_object);
}

id sub_1007749C8(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 16) updateStewieState:a2];
}

id sub_1007749D4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 16) readyForNextProtocolMessage:a2];
}

uint64_t sub_1007749E0(uint64_t a1)
{
  *(void *)a1 = off_101A04300;
  uint64_t v2 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = 0;

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_100774A40(uint64_t a1)
{
  sub_1007749E0(a1);

  operator delete();
}

void sub_100774A78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v12 = 0;
  id v8 = sub_100E38224(a2, (uint64_t)&v12);
  id v9 = v12;
  OsLogContext v10 = v9;
  if (!v8 || v9)
  {
    uint64_t v11 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      unsigned __int8 v14 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to deliver incoming text message, error: %@", buf, 0xCu);
    }
  }
  else
  {
    [*(id *)(a1 + 16) deliverIncomingMessage:v8 toService:*(unsigned __int16 *)(a2 + 8) ackContext:a3 srcTransport:a4];
  }
}

void sub_100774B90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100774BB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v12 = 0;
  id v8 = sub_100E38328(a2, (uint64_t)&v12);
  id v9 = v12;
  OsLogContext v10 = v9;
  if (!v8 || v9)
  {
    uint64_t v11 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      unsigned __int8 v14 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to deliver incoming text message, error: %@", buf, 0xCu);
    }
  }
  else
  {
    [*(id *)(a1 + 16) deliverIncomingMessage:v8 toService:*(unsigned __int16 *)(a2 + 8) ackContext:a3 srcTransport:a4];
  }
}

void sub_100774CC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100774CE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v15 = 0;
  id v8 = sub_100E38418(a2, (uint64_t)&v15);
  id v9 = v15;
  OsLogContext v10 = v9;
  if (!v8 || v9)
  {
    uint64_t v11 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p[0]) = 138412290;
      *(void **)((char *)__p + 4) = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to deliver incoming (iMessageLite) StewieCarrierPigeonSummaryMessage, error: %@", (uint8_t *)__p, 0xCu);
    }
  }
  else
  {
    id v14 = 0;
    uint64_t v11 = sub_100E38544(a2, (uint64_t)&v14);
    id v12 = v14;
    OsLogContext v10 = v12;
    if (!v11 || v12)
    {
      uint64_t v13 = sub_100200FB4((id *)(a1 + 8));
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__p[0]) = 138412290;
        *(void **)((char *)__p + 4) = v10;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to deliver incoming (SatSms) StewieCarrierPigeonSummaryMessage, error: %@", (uint8_t *)__p, 0xCu);
      }
    }
    else
    {
      memset(__p, 0, sizeof(__p));
      sub_10005C928(__p, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
      [*(id *)(a1 + 16) deliverIncomingMessage:v8 toService:16 ackContext:a3 srcTransport:a4];
      [*(id *)(a1 + 16) deliverIncomingMessage:v11 toService:32 ackContext:__p srcTransport:a4];
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      OsLogContext v10 = 0;
    }
  }
}

void sub_100774EC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  _Unwind_Resume(a1);
}

void sub_100774F18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v12 = 0;
  id v8 = sub_100E38590(a2, (uint64_t)&v12);
  id v9 = v12;
  OsLogContext v10 = v9;
  if (!v8 || v9)
  {
    uint64_t v11 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      id v14 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to deliver incoming iMessageLite text message, error: %@", buf, 0xCu);
    }
  }
  else
  {
    [*(id *)(a1 + 16) deliverIncomingMessage:v8 toService:*(unsigned __int16 *)(a2 + 8) ackContext:a3 srcTransport:a4];
  }
}

void sub_100775030(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100775050(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v12 = 0;
  id v8 = sub_100E386D4(a2, (uint64_t)&v12);
  id v9 = v12;
  OsLogContext v10 = v9;
  if (!v8 || v9)
  {
    uint64_t v11 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      id v14 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to deliver incoming satSms text message, error: %@", buf, 0xCu);
    }
  }
  else
  {
    [*(id *)(a1 + 16) deliverIncomingMessage:v8 toService:*(unsigned __int16 *)(a2 + 8) ackContext:a3 srcTransport:a4];
  }
}

void sub_100775168(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100775188(uint64_t a1, CFUUIDRef *a2, uint64_t a3, uint64_t a4, id *a5, uint64_t a6)
{
  id v11 = *a5;
  CFStringRef v12 = CFUUIDCreateString(kCFAllocatorDefault, *a2);
  [*(id *)(a1 + 16) deliverAckWithMsgId:v12 toService:a3 success:a4 clientMetaData:v11 srcTransport:a6];
  sub_1000558F4((const void **)&v12);
}

void sub_10077521C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);

  _Unwind_Resume(a1);
}

id sub_10077523C(uint64_t a1)
{
  return [*(id *)(a1 + 16) handleDumpState];
}

double sub_10077524C@<D0>(uint64_t a1@<X0>, id *a2@<X1>, _OWORD *a3@<X8>)
{
  if (!*a2) {
    __TUAssertTrigger();
  }
  sub_1007769E8(a1, a2, v7);
  double result = v7[0];
  *a3 = *(_OWORD *)v7;
  return result;
}

void sub_1007752B4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 32);
  uint64_t v3 = (const uint8_t *)[*(id *)(a1 + 40) bytes];
  id v4 = [*(id *)(a1 + 40) length];

  nw_framer_write_output(v2, v3, (size_t)v4);
}

uint64_t sub_100775310(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    *(void *)a1 = off_1019BDAD8;
    *(void *)a1 = off_1019BDAD8;
    *(void *)(a1 + 16) = &unk_1019BDB80;
    if (*(unsigned char *)(a1 + 56))
    {
      uint64_t v2 = *(void **)(a1 + 32);
      if (v2)
      {
        *(void *)(a1 + 40) = v2;
        operator delete(v2);
      }
    }
  }
  return a1;
}

uint64_t sub_100775414(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80))
  {
    *(void *)a1 = off_1019BDE00;
    *(void *)a1 = off_1019BDE00;
    *(void *)(a1 + 16) = &unk_1019BDEA8;
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(void **)(a1 + 32);
    if (v3)
    {
      *(void *)(a1 + 40) = v3;
      operator delete(v3);
    }
  }
  return a1;
}

uint64_t sub_10077551C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    *(void *)a1 = off_1019ADF38;
    *(void *)a1 = off_1019ADF38;
    *(void *)(a1 + 16) = &unk_1019ADFE0;
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      *(void *)(a1 + 40) = v2;
      operator delete(v2);
    }
  }
  return a1;
}

uint64_t sub_100775618(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96))
  {
    *(void *)a1 = off_101A90E78;
    *(void *)a1 = off_101A90E78;
    *(void *)(a1 + 16) = &unk_101A90F20;
    if (*(unsigned char *)(a1 + 88))
    {
      uint64_t v2 = *(void **)(a1 + 64);
      if (v2)
      {
        *(void *)(a1 + 72) = v2;
        operator delete(v2);
      }
    }
    if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
  }
  return a1;
}

uint64_t sub_100775734(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80))
  {
    *(void *)a1 = off_101A911A0;
    *(void *)a1 = off_101A911A0;
    *(void *)(a1 + 16) = &unk_101A91248;
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(void **)(a1 + 32);
    if (v3)
    {
      *(void *)(a1 + 40) = v3;
      operator delete(v3);
    }
  }
  return a1;
}

uint64_t sub_10077583C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 104))
  {
    *(void *)a1 = off_1019D2820;
    *(void *)a1 = off_1019D2820;
    *(void *)(a1 + 16) = &unk_1019D28C8;
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(void **)(a1 + 64);
    if (v3)
    {
      *(void *)(a1 + 72) = v3;
      operator delete(v3);
    }
  }
  return a1;
}

uint64_t sub_100775944(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96))
  {
    *(void *)a1 = off_1019D3190;
    *(void *)a1 = off_1019D3190;
    *(void *)(a1 + 16) = &unk_1019D3238;
    uint64_t v2 = *(void **)(a1 + 72);
    if (v2)
    {
      *(void *)(a1 + 80) = v2;
      operator delete(v2);
    }
    if (*(char *)(a1 + 63) < 0) {
      operator delete(*(void **)(a1 + 40));
    }
  }
  return a1;
}

uint64_t sub_100775A50(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    *(void *)a1 = off_1019D2CA8;
    *(void *)a1 = off_1019D2CA8;
    *(void *)(a1 + 16) = &unk_1019D2D50;
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      *(void *)(a1 + 40) = v2;
      operator delete(v2);
    }
  }
  return a1;
}

void sub_100775B4C(uint64_t a1)
{
  uint64_t v9 = 0;
  OsLogContext v10 = &v9;
  uint64_t v11 = 0x3032000000;
  CFStringRef v12 = sub_100775CF8;
  uint64_t v13 = sub_100775D08;
  id v14 = 0;
  uint64_t v2 = *(NSObject **)(a1 + 32);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  id v8[2] = sub_100775D10;
  v8[3] = &unk_101A04468;
  void v8[4] = &v9;
  nw_framer_parse_input(v2, 1uLL, 0xFFFFFFFFuLL, 0, v8);
  BOOL v3 = nw_framer_parse_input(*(nw_framer_t *)(a1 + 32), 1uLL, 0xFFFFFFFFuLL, 0, &stru_101A044A8);
  id v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = (void *)v10[5];
  id v17 = v4;
  id v16 = v6;
  BOOL v15 = v3;
  uint64_t v7 = *(void *)(v5 + 24);
  if (!v7) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, id *, id *, BOOL *))(*(void *)v7 + 48))(v7, &v17, &v16, &v15);

  _Block_object_dispose(&v9, 8);
}

void sub_100775CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id a19)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100775CF8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100775D08(uint64_t a1)
{
}

uint64_t sub_100775D10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  if (a2)
  {
    if (a3)
    {
      uint64_t v6 = +[NSData dataWithBytes:a2 length:a3];
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
      id v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;

      return a3;
    }
  }
  return result;
}

unint64_t sub_100775D70(id a1, char *a2, unint64_t a3, BOOL a4)
{
  return 0;
}

uint64_t sub_100775D78(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100775D94(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100775DA4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A04510;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100775DC4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A04510;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100775E18(uint64_t a1)
{
  return sub_100776964((void *)(a1 + 24));
}

void sub_100775E24(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A04560;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100775E44(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A04560;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100775E98(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(void **)(a1 + 32);
}

uint64_t *sub_100775EE0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    objc_destroyWeak((id *)v1);
    operator delete();
  }
  return result;
}

uint64_t *sub_100775F3C(uint64_t a1)
{
  uint64_t v10 = a1;
  sub_100772354();
  uint64_t v2 = (unsigned __int16 *)qword_101B0D688;
  uint64_t v3 = qword_101B0D690;
  if (qword_101B0D688 != qword_101B0D690)
  {
    char v4 = 0;
    do
    {
      while (1)
      {
        uint64_t v5 = *v2;
        if (((unsigned __int16)v5 & *(_WORD *)(a1 + 8)) == 0) {
          break;
        }
        id WeakRetained = objc_loadWeakRetained((id *)a1);
        [WeakRetained addStewieClient:v5 stewieFramer:a1 + 16];

        ++v2;
        char v4 = 1;
        if (v2 == (unsigned __int16 *)v3) {
          goto LABEL_9;
        }
      }
      ++v2;
    }
    while (v2 != (unsigned __int16 *)v3);
    if ((v4 & 1) == 0) {
      return sub_100775EE0(&v10);
    }
LABEL_9:
    id v7 = objc_loadWeakRetained((id *)a1);
    [v7 addStewieFramer:a1 + 16];

    id v8 = objc_loadWeakRetained((id *)a1);
    [v8 getDataIfRequired];
  }
  return sub_100775EE0(&v10);
}

void sub_100776020(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100775EE0((uint64_t *)va);
  _Unwind_Resume(a1);
}

unint64_t sub_100776048(id a1, char *a2, unint64_t a3, BOOL a4)
{
  return 0;
}

id **sub_100776050(id **result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {

    objc_destroyWeak(v1);
    operator delete();
  }
  return result;
}

id **sub_1007760A8(uint64_t a1)
{
  char v4 = (id *)a1;
  id WeakRetained = objc_loadWeakRetained((id *)a1);
  [WeakRetained handleFramerHasData:*(void *)(a1 + 8)];

  return sub_100776050(&v4);
}

void sub_1007760F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100776050((id **)va);
  _Unwind_Resume(a1);
}

void sub_100776108(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_100772354();
  uint64_t v2 = (unsigned __int16 *)qword_101B0D688;
  uint64_t v3 = qword_101B0D690;
  while (v2 != (unsigned __int16 *)v3)
  {
    uint64_t v4 = *v2;
    if ((**(_WORD **)v1 & (unsigned __int16)v4) != 0)
    {
      id WeakRetained = objc_loadWeakRetained(*(id **)(v1 + 8));
      [WeakRetained removeStewieClient:v4 clientPid:**(unsigned int **)(v1 + 16) framerType:**(unsigned int **)(v1 + 24)];
    }
    ++v2;
  }
  id v6 = objc_loadWeakRetained(*(id **)(v1 + 8));
  [v6 removeStewieFramer:**(void **)(v1 + 32)];

  id v7 = objc_loadWeakRetained(*(id **)(v1 + 8));
  [v7 getDataIfRequired];
}

void sub_1007761D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void *sub_1007761F4(void *result, uint64_t a2)
{
  qword_101B0D688 = 0;
  qword_101B0D690 = 0;
  qword_101B0D698 = 0;
  if (a2)
  {
    if (a2 < 0) {
      sub_10006A748();
    }
    uint64_t v3 = result;
    size_t v4 = 2 * a2;
    qword_101B0D688 = (uint64_t)operator new(2 * a2);
    qword_101B0D690 = qword_101B0D688;
    uint64_t v5 = qword_101B0D688 + 2 * a2;
    qword_101B0D698 = v5;
    uint64_t result = memmove((void *)qword_101B0D688, v3, v4);
    qword_101B0D690 = v5;
  }
  return result;
}

void sub_100776268(_Unwind_Exception *exception_object)
{
  if (qword_101B0D688)
  {
    qword_101B0D690 = qword_101B0D688;
    operator delete((void *)qword_101B0D688);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10077628C(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1007762C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A045D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007762E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A045D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100776334(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

uint64_t sub_100776388(uint64_t a1)
{
  return a1;
}

void sub_1007763B4(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 8));

  operator delete();
}

id *sub_100776400(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 8);
  uint64_t v2 = (id *)operator new(0x10uLL);
  *uint64_t v2 = off_101A04620;
  objc_copyWeak(v2 + 1, v1);
  return v2;
}

void sub_100776454(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A04620;
  objc_copyWeak((id *)(a2 + 8), (id *)(a1 + 8));
}

void sub_100776480(uint64_t a1)
{
}

void sub_100776488(id *a1)
{
  objc_destroyWeak(a1 + 1);

  operator delete(a1);
}

void sub_1007764C4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 8));
  [WeakRetained handleDataPathIdle];
}

void sub_10077650C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100776520(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A04680)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100776560()
{
  return &off_101A04680;
}

uint64_t sub_10077656C(uint64_t a1)
{
  return a1;
}

void sub_1007765A0(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 16));

  operator delete();
}

void *sub_1007765F4(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A046A0;
  *((void *)v2 + 1) = *(id *)(a1 + 8);
  objc_copyWeak((id *)v2 + 2, (id *)(a1 + 16));
  return v2;
}

void sub_100776658(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A046A0;
  *(void *)(a2 + 8) = *(id *)(a1 + 8);

  objc_copyWeak((id *)(a2 + 16), (id *)(a1 + 16));
}

void sub_1007766BC(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_1007766F8(id *a1)
{
  objc_destroyWeak(a1 + 2);

  operator delete(a1);
}

void sub_10077673C(uint64_t a1, id *a2, void **a3, char *a4)
{
  uint64_t v5 = *a3;
  char v6 = *a4;
  id v7 = *a2;
  id v8 = v5;
  uint64_t v9 = *(void **)(a1 + 8);
  objc_copyWeak(v11, (id *)(a1 + 16));
  v11[1] = v7;
  v11[2] = v8;
  char v12 = v6;
  id v10 = v9;
  operator new();
}

uint64_t sub_100776854(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A04710)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100776894()
{
  return &off_101A04710;
}

id **sub_1007768A0(id **result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {

    objc_destroyWeak(v1);
    operator delete();
  }
  return result;
}

id **sub_100776900(uint64_t a1)
{
  size_t v4 = (id *)a1;
  id WeakRetained = objc_loadWeakRetained((id *)a1);
  [WeakRetained handleDataFromFramer:*(void *)(a1 + 8) data:*(void *)(a1 + 16) hasData:*(unsigned __int8 *)(a1 + 24)];

  return sub_1007768A0(&v4);
}

void sub_10077694C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_1007768A0((id **)va);
  _Unwind_Resume(a1);
}

void *sub_100776964(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1007769E8@<X0>(uint64_t a1@<X1>, id *a2@<X2>, void *a3@<X8>)
{
  char v6 = operator new(0x30uLL);
  uint64_t result = sub_100776A4C(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_100776A38(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100776A4C(void *a1, uint64_t a2, id *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A04730;
  sub_100774810(a1 + 3, a2, a3);
  return a1;
}

void sub_100776A94(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100776AA8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A04730;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100776AC8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A04730;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100776B1C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 80))();
}

void *sub_100776B44(void *a1)
{
  *a1 = off_101A04850;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100776B90(void *a1)
{
  *a1 = off_101A04850;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

uint64_t sub_100776BFC(uint64_t a1, void **a2, uint64_t *a3, _DWORD *a4, uint64_t a5)
{
  if (!*(void *)(a5 + 24)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    sub_1008C22B0(a3);
    sub_100777EB8((uint64_t)v15, a5);
    BOOL v9 = v16 != 0;
    if (v16)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D6A0, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_101B0D6A0))
      {
        sub_100637AF8(&v18, "Content-Type", "application/json");
        sub_1002369E0((uint64_t)&unk_101B0D6B0, &v18, 1);
        sub_1001085D8((uint64_t)&v18);
        __cxa_atexit((void (*)(void *))sub_1007772B4, &unk_101B0D6B0, (void *)&_mh_execute_header);
        __cxa_guard_release(&qword_101B0D6A0);
      }
      sub_1007780F0((uint64_t)v17, (uint64_t)v15);
      uint32_t v19 = 0;
      id v10 = operator new(0x28uLL);
      void *v10 = off_101A04910;
      sub_1007780F0((uint64_t)(v10 + 1), (uint64_t)v17);
      uint32_t v19 = v10;
      sub_1007772E0(v6, a2, (uint64_t)&unk_101B0D6B0, (char *)&__p, a4, (uint64_t)&v18);
      sub_10077920C(&v18);
      sub_100777F50(v17);
    }
    sub_100777F50(v15);
    if (v13 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    v14[0] = 0;
    v14[272] = 0;
    sub_100776E68(a5, (uint64_t)v14, 0);
    sub_100777C48((uint64_t)v14);
    return 1;
  }
  return v9;
}

void sub_100776DE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_1001085D8(v16 - 104);
  __cxa_guard_abort(&qword_101B0D6A0);
  sub_100777F50((void *)(v16 - 168));
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100776E68(uint64_t a1, uint64_t a2, int a3)
{
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)v3 + 48))(v3, a2, &v5);
}

uint64_t sub_100776EBC(uint64_t a1, void **a2, uint64_t *a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a5 + 24);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    sub_1008C22B0(a3);
    sub_100777FD4((uint64_t)v17, a5);
    if (v17[3])
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D6A8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_101B0D6A8))
      {
        sub_100637AF8(&v19, "Content-Type", "application/json");
        sub_1002369E0((uint64_t)&unk_101B0D6C8, &v19, 1);
        sub_1001085D8((uint64_t)&v19);
        __cxa_atexit((void (*)(void *))sub_1007772B4, &unk_101B0D6C8, (void *)&_mh_execute_header);
        __cxa_guard_release(&qword_101B0D6A8);
      }
      sub_100779290((uint64_t)v18, (uint64_t)v17);
      __n128 v20 = 0;
      uint64_t v11 = operator new(0x28uLL);
      void *v11 = off_101A049A0;
      sub_100779290((uint64_t)(v11 + 1), (uint64_t)v18);
      __n128 v20 = v11;
      BOOL v12 = sub_1007772E0(v7, a2, (uint64_t)&unk_101B0D6C8, (char *)&__p, a4, (uint64_t)&v19);
      sub_10077920C(&v19);
      sub_10077806C(v18);
    }
    else
    {
      BOOL v12 = 0;
    }
    sub_10077806C(v17);
    if (v15 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    v16[0] = 0;
    v16[160] = 0;
    sub_10077712C(v6, (uint64_t)v16, 0);
    sub_10030D32C((uint64_t)v16);
    return 1;
  }
  return v12;
}

void sub_1007770AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_1001085D8(v16 - 104);
  __cxa_guard_abort(&qword_101B0D6A8);
  sub_10077806C((void *)(v16 - 168));
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10077712C(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 48))(a1, a2, &v4);
}

uint64_t entitlements::WebServiceDelegate::impl::impl(uint64_t a1, NSObject **a2, void *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "cp.tr.http");
  sub_100777228((void *)a1, a2, &v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *(void *)(a1 + 40) = *a3;
  uint64_t v6 = a3[1];
  *(void *)(a1 + 48) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  return a1;
}

void sub_100777214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100777228(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  int v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100777290(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1007772B4(uint64_t a1)
{
  return a1;
}

BOOL sub_1007772E0(uint64_t a1, void **a2, uint64_t a3, char *a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(a6 + 24);
  if (!v6) {
    return v6 != 0;
  }
  int v13 = *(_DWORD *)(a1 + 56) + 1;
  *(_DWORD *)(a1 + 56) = v13;
  id v14 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      char v15 = a2;
    }
    else {
      char v15 = *a2;
    }
    if (a4[23] >= 0) {
      uint64_t v16 = a4;
    }
    else {
      uint64_t v16 = *(char **)a4;
    }
    *(_DWORD *)std::string buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = v13;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v15;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I -----> web service request [%d]. url:%{public}s data:%s", buf, 0x1Cu);
  }
  int v38 = v13;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 40));
  long long v18 = ServiceMap;
  if ((v19 & 0x8000000000000000) != 0)
  {
    __n128 v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      unint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v45 = v19;
  uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, &v45);
  CFStringRef v39 = a5;
  uint64_t v40 = a3;
  if (v23)
  {
    uint64_t v25 = v23[3];
    uint64_t v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v18);
  uint64_t v24 = 0;
  char v26 = 1;
LABEL_18:
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)a2;
    uint64_t v44 = a2[2];
  }
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, void **, uint64_t))(*(void *)v25 + 16))(buf, v25, 3, __dst, v40);
  long long v27 = *(_OWORD *)buf;
  *(void *)std::string buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  uint64_t v28 = *(std::__shared_weak_count **)(a1 + 72);
  *(_OWORD *)(a1 + 64) = v27;
  if (v28)
  {
    sub_10004D2C8(v28);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (SHIBYTE(v44) < 0)
  {
    operator delete(__dst[0]);
    if (v26) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if ((v26 & 1) == 0) {
LABEL_26:
  }
    sub_10004D2C8(v24);
LABEL_27:
  (*(void (**)(void, void))(**(void **)(a1 + 64) + 8))(*(void *)(a1 + 64), *(void *)(a1 + 16));
  uint64_t v29 = *(void *)(a1 + 64);
  int v30 = a4[23];
  if (v30 >= 0) {
    uint64_t v31 = a4;
  }
  else {
    uint64_t v31 = *(char **)a4;
  }
  if (v30 >= 0) {
    size_t v32 = a4[23];
  }
  else {
    size_t v32 = *((void *)a4 + 1);
  }
  memset(buf, 0, 24);
  sub_10012C7D0((char *)buf, v31, &v31[v32], v32);
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v29 + 56))(v29, buf);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  LODWORD(v33) = *v39;
  (*(void (**)(void, double))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64), (double)v33);
  (*(void (**)(void, void))(**(void **)(a1 + 64) + 224))(*(void *)(a1 + 64), *v39);
  uint64_t v34 = *(void *)(a1 + 64);
  sub_100058DB0(buf, "com.apple.CommCenter.CellularPlanProvisioning");
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v34 + 160))(v34, buf);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v35 = *(void *)(a1 + 64);
  v46[0] = _NSConcreteStackBlock;
  v46[1] = 3321888768;
  v46[2] = sub_100777824;
  v46[3] = &unk_101A04870;
  v46[4] = a1;
  sub_100779A8C((uint64_t)v47, a6);
  int v48 = v38;
  (*(void (**)(uint64_t, void *))(*(void *)v35 + 16))(v35, v46);
  uint64_t v36 = *(void *)(a1 + 64);
  __p[1] = 0;
  uint64_t v42 = 0;
  __p[0] = 0;
  (*(void (**)(uint64_t, void **))(*(void *)v36 + 40))(v36, __p);
  if (SHIBYTE(v42) < 0) {
    operator delete(__p[0]);
  }
  sub_10077920C(v47);
  return v6 != 0;
}

void sub_100777788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(exception_object);
}

void sub_100777824(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  if (*a2)
  {
    if ((*(unsigned int (**)(void))(*(void *)*a2 + 16))(*a2) == 1)
    {
      if ((*(unsigned int (**)(void))(*(void *)*a2 + 24))() == 200)
      {
        long long __p = 0;
        id v17 = 0;
        uint64_t v18 = 0;
        (*(void (**)(void **__return_ptr))(*(void *)*a2 + 48))(&__p);
        int v5 = v3[4];
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          int v6 = *(_DWORD *)(a1 + 72);
          p_p = &__p;
          if (v18 < 0) {
            p_p = __p;
          }
          int v14 = 67109378;
          LODWORD(v15[0]) = v6;
          WORD2(v15[0]) = 2080;
          *(void *)((char *)v15 + 6) = p_p;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I <----- web service response [%d]. %s", (uint8_t *)&v14, 0x12u);
        }
        sub_100777BDC(*(void *)(a1 + 64), 1, (uint64_t)&__p, 3);
        OsLogContext v8 = (std::__shared_weak_count *)v3[9];
        v3[8] = 0;
        v3[9] = 0;
        if (v8) {
          sub_10004D2C8(v8);
        }
        if (SHIBYTE(v18) < 0) {
          operator delete(__p);
        }
        return;
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "cp.tr.http");
      uint64_t v11 = v17;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))();
        LODWORD(__p) = 67240192;
        HIDWORD(__p) = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "HTTP Response Code: %{public}d", (uint8_t *)&__p, 8u);
      }
      sub_100058DB0(&__p, "");
      sub_100777BDC(*(void *)(a1 + 64), 0, (uint64_t)&__p, 3);
    }
    else
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "cp.tr.http");
      BOOL v9 = v17;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        (*(void (**)(void))(*(void *)*a2 + 16))();
        ctu::Http::asString();
        id v10 = v18 >= 0 ? &__p : (void **)__p;
        int v14 = 136446210;
        v15[0] = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "HTTP Error: %{public}s", (uint8_t *)&v14, 0xCu);
        if (SHIBYTE(v18) < 0) {
          operator delete(__p);
        }
      }
      sub_100058DB0(&__p, "");
      sub_100777BDC(*(void *)(a1 + 64), 0, (uint64_t)&__p, 1);
    }
  }
  else
  {
    sub_100058DB0(&__p, "");
    sub_100777BDC(*(void *)(a1 + 64), 0, (uint64_t)&__p, 1);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(__p);
  }
  int v13 = (std::__shared_weak_count *)v3[9];
  v3[8] = 0;
  v3[9] = 0;
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_100777BAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100777BDC(uint64_t a1, char a2, uint64_t a3, int a4)
{
  char v6 = a2;
  int v5 = a4;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t, int *))(*(void *)a1 + 48))(a1, &v6, a3, &v5);
}

uint64_t sub_100777C34(uint64_t a1, uint64_t a2)
{
  return sub_100779A8C(a1 + 40, a2 + 40);
}

void *sub_100777C40(uint64_t a1)
{
  return sub_10077920C((void *)(a1 + 40));
}

uint64_t sub_100777C48(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 272))
  {
    sub_100777CB4(a1 + 184);
    sub_1005ADA04(a1 + 80);
    if (*(unsigned char *)(a1 + 72) && *(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(unsigned char *)(a1 + 32) && *(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

uint64_t sub_100777CB4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80))
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

void sub_100777D10(NSObject **a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  char v6 = operator new(0x68uLL);
  sub_100777D8C(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 3, (uint64_t)(v6 + 3));
}

void sub_100777D78(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100777D8C(void *a1, NSObject **a2, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A048C0;
  entitlements::WebServiceDelegate::impl::impl((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_100777DD4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100777DE8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A048C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100777E08(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A048C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100777E5C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 7));

  return sub_100087E88(a1 + 3);
}

uint64_t sub_100777EB8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100777F50(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100777FD4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_10077806C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1007780F0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void *sub_100778170(void *a1)
{
  *a1 = off_101A04910;
  sub_100777F50(a1 + 1);
  return a1;
}

void sub_1007781B4(void *a1)
{
  *a1 = off_101A04910;
  sub_100777F50(a1 + 1);

  operator delete();
}

void *sub_100778218(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A04910;
  sub_100777EB8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10077826C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100778280(uint64_t a1, void *a2)
{
  *a2 = off_101A04910;
  return sub_100777EB8((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_1007782AC(uint64_t a1)
{
  return sub_100777F50((void *)(a1 + 8));
}

void sub_1007782B4(void *a1)
{
  sub_100777F50(a1 + 1);

  operator delete(a1);
}

uint64_t sub_1007782F0(uint64_t result, unsigned char *a2, uint64_t a3, int *a4)
{
  if (*(void *)(result + 32))
  {
    uint64_t v4 = result + 8;
    int v5 = *a4;
    if (*a2)
    {
      uint64_t v55 = 0;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v38 = 0u;
      sub_1008C0FA8(a3, &v38);
      char v6 = (const char *)kCtLoggingSystemName;
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.http");
      uint64_t v7 = *(NSObject **)&v57[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67240448;
        *(_DWORD *)uint64_t v57 = 1;
        *(_WORD *)&void v57[4] = 1026;
        *(_DWORD *)&v57[6] = v5;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "success: %{public}d, EventCause: %{public}d", buf, 0xEu);
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
      OsLogContext v8 = *(NSObject **)&v57[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "<----- web service response: {", buf, 2u);
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
      BOOL v9 = *(NSObject **)&v57[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        if (BYTE1(v38)) {
          id v10 = (const char *)entitlements::asString();
        }
        else {
          id v10 = "None";
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)uint64_t v57 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "\tPreflightState: %{public}s", buf, 0xCu);
      }
      if ((_BYTE)v40)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        uint64_t v11 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          if (!(_BYTE)v40) {
            sub_10016C840();
          }
          int v12 = (char *)&v38 + 8;
          if (v39 < 0) {
            int v12 = (char *)*((void *)&v38 + 1);
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)uint64_t v57 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "\tIccid: %s", buf, 0xCu);
        }
      }
      if (BYTE12(v40))
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        int v13 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          if (!BYTE12(v40)) {
            sub_10016C840();
          }
          *(_DWORD *)std::string buf = 67240192;
          *(_DWORD *)uint64_t v57 = DWORD2(v40);
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "\tReasonCode: %{public}d", buf, 8u);
        }
      }
      if (BYTE8(v42))
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        int v14 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          if (!BYTE8(v42)) {
            sub_10016C840();
          }
          char v15 = &v41;
          if (SBYTE7(v42) < 0) {
            char v15 = (long long *)v41;
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v57 = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "\tReasonCodeUrl: %{public}s", buf, 0xCu);
        }
      }
      if ((_BYTE)v49)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        uint64_t v16 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "\tTermsAndConditions: {", buf, 2u);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        id v17 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          if (!(_BYTE)v49) {
            sub_10016C840();
          }
          uint64_t v18 = BYTE7(v44);
          if (SBYTE7(v44) < 0) {
            uint64_t v18 = *((void *)&v43 + 1);
          }
          if (v18) {
            unint64_t v19 = "Present";
          }
          else {
            unint64_t v19 = "Empty";
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v57 = v19;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "\t\tMainText: %{public}s", buf, 0xCu);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        __n128 v20 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          if (!(_BYTE)v49) {
            sub_10016C840();
          }
          uint64_t v21 = (char *)&v44 + 8;
          if (v45 < 0) {
            uint64_t v21 = (char *)*((void *)&v44 + 1);
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v57 = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "\t\tUserChoiceUrl: %{public}s", buf, 0xCu);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        unsigned int v22 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          if (!(_BYTE)v49) {
            sub_10016C840();
          }
          uint64_t v23 = &v46;
          if (SBYTE7(v47) < 0) {
            uint64_t v23 = (long long *)v46;
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v57 = v23;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "\t\tAccpetPostData: %{public}s", buf, 0xCu);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        char v24 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          if (!(_BYTE)v49) {
            sub_10016C840();
          }
          uint64_t v25 = (char *)&v47 + 8;
          if (v48 < 0) {
            uint64_t v25 = (char *)*((void *)&v47 + 1);
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v57 = v25;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "\t\tRejectPostData: %{public}s", buf, 0xCu);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        char v26 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "\t}", buf, 2u);
        }
      }
      if (BYTE8(v54))
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        long long v27 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "\tOtpContent: {", buf, 2u);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        uint64_t v28 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          if (!BYTE8(v54)) {
            sub_10016C840();
          }
          uint64_t v29 = (char *)&v49 + 8;
          if (v50 < 0) {
            uint64_t v29 = (char *)*((void *)&v49 + 1);
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v57 = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "\t\tLastFourNumbers: %{public}s", buf, 0xCu);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        int v30 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          if (!BYTE8(v54)) {
            sub_10016C840();
          }
          uint64_t v31 = &v51;
          if (SBYTE7(v52) < 0) {
            uint64_t v31 = (long long *)v51;
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v57 = v31;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "\t\tOtpUrl: %{public}s", buf, 0xCu);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        size_t v32 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          if (!BYTE8(v54)) {
            sub_10016C840();
          }
          unint64_t v33 = (char *)&v52 + 8;
          if (v53 < 0) {
            unint64_t v33 = (char *)*((void *)&v52 + 1);
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v57 = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "\t\tOtpPostData: %{public}s", buf, 0xCu);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        uint64_t v34 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          if (!BYTE8(v54)) {
            sub_10016C840();
          }
          uint64_t v35 = entitlements::asString();
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v57 = v35;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "\t\tOtpState: %{public}s", buf, 0xCu);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
        uint64_t v36 = *(NSObject **)&v57[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "\t}", buf, 2u);
        }
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v6, "cp.tr.http");
      uint64_t v37 = *(NSObject **)&v57[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "}", buf, 2u);
      }
      sub_100778E10(buf, (uint64_t)&v38);
      sub_100776E68(v4, (uint64_t)buf, v5);
      sub_100777C48((uint64_t)buf);
    }
    else
    {
      LOBYTE(v38) = 0;
      LOBYTE(v55) = 0;
      sub_100776E68(result + 8, (uint64_t)&v38, v5);
    }
    return sub_100777C48((uint64_t)&v38);
  }
  return result;
}

void sub_100778D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100778DBC()
{
}

uint64_t sub_100778DC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100778E04()
{
}

unsigned char *sub_100778E10(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[272] = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    sub_100778E68((uint64_t)a1, a2);
    a1[272] = 1;
  }
  return a1;
}

void sub_100778E54(_Unwind_Exception *a1)
{
  sub_100777C48(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100778E68(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  sub_1000593FC(a1 + 8, (long long *)(a2 + 8));
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  sub_1000593FC(a1 + 48, (long long *)(a2 + 48));
  sub_100778F3C((char *)(a1 + 80), a2 + 80);
  sub_1007790C4((char *)(a1 + 184), a2 + 184);
  return a1;
}

void sub_100778EE8(_Unwind_Exception *a1)
{
  sub_1005ADA04(v4);
  if (v2[72] && v2[71] < 0) {
    operator delete(*v3);
  }
  if (v2[32])
  {
    if (v2[31] < 0) {
      operator delete(*v1);
    }
  }
  _Unwind_Resume(a1);
}

char *sub_100778F3C(char *__dst, uint64_t a2)
{
  void *__dst = 0;
  __dst[96] = 0;
  if (*(unsigned char *)(a2 + 96))
  {
    sub_100778F94(__dst, (long long *)a2);
    __dst[96] = 1;
  }
  return __dst;
}

void sub_100778F80(_Unwind_Exception *a1)
{
  sub_1005ADA04(v1);
  _Unwind_Resume(a1);
}

char *sub_100778F94(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(__dst + 48, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *((_OWORD *)__dst + 3) = v6;
  }
  uint64_t v7 = __dst + 72;
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84(v7, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v8 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)uint64_t v7 = v8;
  }
  return __dst;
}

void sub_100779078(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1007790C4(char *__dst, uint64_t a2)
{
  void *__dst = 0;
  __dst[80] = 0;
  if (*(unsigned char *)(a2 + 80))
  {
    sub_10077911C(__dst, (long long *)a2);
    __dst[80] = 1;
  }
  return __dst;
}

void sub_100779108(_Unwind_Exception *a1)
{
  sub_100777CB4(v1);
  _Unwind_Resume(a1);
}

char *sub_10077911C(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  long long v6 = __dst + 48;
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(v6, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v7 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *(_OWORD *)long long v6 = v7;
  }
  __dst[72] = *((unsigned char *)a2 + 72);
  return __dst;
}

void sub_1007791D8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10077920C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100779290(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void *sub_100779310(void *a1)
{
  *a1 = off_101A049A0;
  sub_10077806C(a1 + 1);
  return a1;
}

void sub_100779354(void *a1)
{
  *a1 = off_101A049A0;
  sub_10077806C(a1 + 1);

  operator delete();
}

void *sub_1007793B8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A049A0;
  sub_100777FD4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10077940C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100779420(uint64_t a1, void *a2)
{
  *a2 = off_101A049A0;
  return sub_100777FD4((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_10077944C(uint64_t a1)
{
  return sub_10077806C((void *)(a1 + 8));
}

void sub_100779454(void *a1)
{
  sub_10077806C(a1 + 1);

  operator delete(a1);
}

uint64_t sub_100779490(uint64_t a1, unsigned char *a2, uint64_t a3, int *a4)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    int v6 = *a4;
    if (*a2)
    {
      uint64_t v33 = 0;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      sub_1008C2158(a3, &v23);
      long long v7 = (const char *)kCtLoggingSystemName;
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.http");
      long long v8 = *(NSObject **)&v35[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "<----- web service response: {", buf, 2u);
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v7, "cp.tr.http");
      BOOL v9 = *(NSObject **)&v35[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = entitlements::asString();
        *(_DWORD *)std::string buf = 136446210;
        *(void *)uint64_t v35 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "TransferState: %{public}s", buf, 0xCu);
      }
      if ((_BYTE)v25)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v7, "cp.tr.http");
        uint64_t v11 = *(NSObject **)&v35[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          if (!(_BYTE)v25) {
            sub_10016C840();
          }
          int v12 = (char *)&v23 + 8;
          if (v24 < 0) {
            int v12 = (char *)*((void *)&v23 + 1);
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)uint64_t v35 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Iccid: %s", buf, 0xCu);
        }
      }
      if ((_BYTE)v27)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v7, "cp.tr.http");
        int v13 = *(NSObject **)&v35[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          if (!(_BYTE)v27) {
            sub_10016C840();
          }
          int v14 = (char *)&v25 + 8;
          if (v26 < 0) {
            int v14 = (char *)*((void *)&v25 + 1);
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v35 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "IccidState: %{public}s", buf, 0xCu);
        }
      }
      if ((_BYTE)v29)
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v7, "cp.tr.http");
        char v15 = *(NSObject **)&v35[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          if (!(_BYTE)v29) {
            sub_10016C840();
          }
          uint64_t v16 = (char *)&v27 + 8;
          if (v28 < 0) {
            uint64_t v16 = (char *)*((void *)&v27 + 1);
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)uint64_t v35 = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "AltSmdpFqdn: %{public}s", buf, 0xCu);
        }
      }
      if (BYTE9(v29))
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v7, "cp.tr.http");
        id v17 = *(NSObject **)&v35[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          if (!BYTE9(v29)) {
            sub_10016C840();
          }
          *(_DWORD *)std::string buf = 67240192;
          *(_DWORD *)uint64_t v35 = BYTE8(v29);
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "UseDS: %{public}d", buf, 8u);
        }
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v7, "cp.tr.http");
      uint64_t v18 = *(NSObject **)&v35[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v19 = &v30;
        if (SBYTE7(v31) < 0) {
          unint64_t v19 = (long long *)v30;
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)uint64_t v35 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "ReasonCode: %{public}s", buf, 0xCu);
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v7, "cp.tr.http");
      __n128 v20 = *(NSObject **)&v35[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = (char *)&v31 + 8;
        if (v32 < 0) {
          uint64_t v21 = (char *)*((void *)&v31 + 1);
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)uint64_t v35 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "ReasonCodeUrl: %{public}s", buf, 0xCu);
      }
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v7, "cp.tr.http");
      unsigned int v22 = *(NSObject **)&v35[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "}", buf, 2u);
      }
      sub_10030E6AC(buf, (uint64_t)&v23);
      sub_10077712C(*(void *)(a1 + 32), (uint64_t)buf, v6);
      sub_10030D32C((uint64_t)buf);
    }
    else
    {
      LOBYTE(v23) = 0;
      LOBYTE(v33) = 0;
      sub_10077712C(result, (uint64_t)&v23, v6);
    }
    return sub_10030D32C((uint64_t)&v23);
  }
  return result;
}

void sub_1007799D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100779A38()
{
}

uint64_t sub_100779A40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100779A80()
{
}

uint64_t sub_100779A8C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_100779B24(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100779B94()
{
}

uint64_t sub_100779BB8(uint64_t a1, long long *a2, int a3, uint64_t a4, uint64_t *a5)
{
  *(void *)a1 = &off_101A04A20;
  *(void *)(a1 + 8) = 0;
  uint64_t v9 = a1 + 16;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)v9, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v10 = *a2;
    *(void *)(v9 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v9 = v10;
  }
  *(_DWORD *)(a1 + 40) = a3;
  uint64_t v12 = *a5;
  uint64_t v11 = a5[1];
  *(void *)(a1 + 48) = a4;
  *(void *)(a1 + 56) = v12;
  *(void *)(a1 + 64) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

uint64_t sub_100779C54(uint64_t a1)
{
  *(void *)a1 = &off_101A04A20;
  if (*(void *)(a1 + 8))
  {
    CPRecordStoreDestroy();
    *(void *)(a1 + 8) = 0;
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

const void **sub_100779CCC(const void **result)
{
  if (!result[1])
  {
    uint64_t v1 = result;
    int v6 = 0;
    long long v7 = 0;
    uint64_t v2 = result + 2;
    if (ctu::cf::convert_copy())
    {
      uint64_t v3 = v6;
      int v6 = v7;
      *(void *)std::string buf = v3;
      sub_1000558F4((const void **)buf);
      uint64_t v4 = CPRecordStoreCreateWithPath();
      v1[1] = (const void *)v4;
      if (v4)
      {
        CPRecordStoreGetDatabase();
        CPSqliteDatabaseSetPropertiesEnabled();
        CPSqliteDatabaseSetCorruptionHandler();
      }
      else
      {
        long long v5 = *(NSObject **)v1[6];
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          if (*((char *)v1 + 39) < 0) {
            uint64_t v2 = (void *)*v2;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v2;
          _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Cannot open store at location %s", buf, 0xCu);
        }
      }
    }
    return sub_1000558F4(&v6);
  }
  return result;
}

void sub_100779E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100779E28(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 1;
  }
  if (!*(void *)(v2 + 8)) {
    return 1;
  }
  CFStringRef v3 = *(const __CFString **)a1;
  CFStringRef v12 = CFStringCreateWithCString(kCFAllocatorDefault, "/var/mobile/Library/LASD", 0x8000100u);
  LODWORD(v3) = CFStringHasPrefix(v3, v12);
  sub_1000558F4((const void **)&v12);
  if (!v3) {
    return 1;
  }
  xpc_object_t v18 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v18 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_12;
    }
  }
  if (xpc_get_type(v5) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = xpc_null_create();
LABEL_12:
    xpc_object_t v18 = v6;
    goto LABEL_13;
  }
  xpc_retain(v5);
LABEL_13:
  xpc_release(v5);
  id v17 = *(__CFString **)a1;
  if (v17) {
    CFRetain(v17);
  }
  uint64_t v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 112));
  ctu::cf_to_xpc((uint64_t *)&v14, (ctu *)v17, v7);
  CFStringRef v12 = (const __CFString *)&v18;
  int v13 = "dbPath";
  sub_100035E70((uint64_t)&v12, &v14, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v14);
  xpc_object_t v14 = 0;
  ctu::cf_to_xpc((uint64_t *)&v10, v16, v8);
  CFStringRef v12 = (const __CFString *)&v18;
  int v13 = "dbVersion";
  sub_100035E70((uint64_t)&v12, &v10, &v11);
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_release(v10);
  xpc_object_t v10 = 0;
  analytics_send_event();
  CPSqliteDatabaseDelete();
  sub_1000570E8((const void **)&v16);
  sub_1000558F4((const void **)&v17);
  xpc_release(v18);
  return 1;
}

void sub_10077A028(_Unwind_Exception *a1)
{
  sub_1000558F4((const void **)(v1 - 48));
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_10077A074(uint64_t a1, void *a2, uint64_t a3)
{
  if (*a2) {
    CFStringRef v3 = sub_1000810B8;
  }
  else {
    CFStringRef v3 = 0;
  }
  if (a3 && v3)
  {
    if (*(void *)(a1 + 8))
    {
      uint64_t Database = CPRecordStoreGetDatabase();
      if (Database)
      {
        *(_WORD *)(Database + 116) |= 2u;
        if (CPSqliteDatabaseConnectionForReading())
        {
          uint64_t v7 = CPSqliteConnectionStatementForSQL();
          if (v7)
          {
            (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v7);
            CPSqliteStatementReset();
            CPSqliteDatabaseReleaseSqliteConnection();
          }
        }
      }
    }
    else
    {
      long long v8 = **(NSObject ***)(a1 + 48);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = sub_10077A1E8(*(_DWORD *)(a1 + 40));
        int v10 = 136315138;
        xpc_object_t v11 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No store found for type %s", (uint8_t *)&v10, 0xCu);
      }
    }
  }
}

const char *sub_10077A1E8(int a1)
{
  int v1 = a1 - 1;
  uint64_t result = "gsm";
  switch(v1)
  {
    case 0:
      uint64_t result = "umts";
      break;
    case 1:
      uint64_t result = "cdma";
      break;
    case 2:
    case 4:
    case 5:
    case 6:
      goto LABEL_6;
    case 3:
      uint64_t result = "lte";
      break;
    case 7:
      return result;
    default:
      if ("gsm" == 16)
      {
        uint64_t result = "scdma";
      }
      else if ("gsm" == 32)
      {
        uint64_t result = "nr";
      }
      else
      {
LABEL_6:
        uint64_t result = "unknown";
      }
      break;
  }
  return result;
}

CFStringRef sub_10077A294(int a1)
{
  CFStringRef result = @"Unknown";
  switch(a1)
  {
    case 1:
      CFStringRef result = @"UMTS";
      break;
    case 2:
      CFStringRef result = @"C2K";
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      return result;
    case 4:
      CFStringRef result = @"LTE";
      break;
    case 8:
      CFStringRef result = @"GSM";
      break;
    default:
      if (a1 == 16)
      {
        CFStringRef result = @"TDSCDMA";
      }
      else if (a1 == 32)
      {
        CFStringRef result = @"NR";
      }
      break;
  }
  return result;
}

CFStringRef sub_10077A344(uint64_t a1, int a2)
{
  if (a2 == 3) {
    return @"select mcc, mnc, arfcn, max(numpoints) as maxpoints from LasdGsmBoxes, LasdGsmBoxesRT where LasdGsmBoxes.id = LasdGsmBoxesRT.id and LasdGsmBoxesRT.minlat <= (%f + 0.5) and LasdGsmBoxesRT.maxlat >= (%f - 0.5) and LasdGsmBoxesRT.minlong <= (%f + 0.5) and LasdGsmBoxesRT.maxlong >= (%f - 0.5) group by mcc, mnc order by maxpoints desc;";
  }
  else {
    return @"select mcc, mnc, arfcn, max(numpoints) as maxpoints from LasdGsmBoxes, LasdGsmBoxesRT where LasdGsmBoxes.id = LasdGsmBoxesRT.id and LasdGsmBoxesRT.minlat <= (%f) and LasdGsmBoxesRT.maxlat >= (%f) and LasdGsmBoxesRT.minlong <= (%f) and LasdGsmBoxesRT.maxlong >= (%f) group by mcc, mnc order by maxpoints desc;";
  }
}

CFStringRef sub_10077A360()
{
  return @"select distinct mcc, mnc, arfcn from LasdGsmList where mcc = %d;";
}

CFStringRef sub_10077A36C()
{
  return @"select distinct mcc, mnc, arfcn from LasdGsmList where mcc = %d and mnc = %d;";
}

const void **sub_10077A378@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, void *a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  sub_100779CCC((const void **)a1);
  uint64_t v19 = 0;
  __n128 v20 = &v19;
  uint64_t v21 = 0x3002000000;
  unsigned int v22 = sub_10077A5BC;
  long long v23 = sub_10077A5D0;
  long long v24 = 0;
  CFStringRef v10 = (const __CFString *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, a2);
  CFTypeRef cf = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v10, *(void *)&a4, *(void *)&a4, *(void *)&a5, *(void *)&a5);
  if (cf) {
    xpc_object_t v11 = sub_1000810B8;
  }
  else {
    xpc_object_t v11 = 0;
  }
  if (v11)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    int v13 = (const void *)v20[5];
    void v20[5] = (uint64_t)Mutable;
    long long v25 = v13;
    sub_1000440D4(&v25);
    if (v20[5] ? sub_100289354 : 0)
    {
      CFTypeRef v17 = cf;
      if (cf) {
        CFRetain(cf);
      }
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 0x40000000;
      v16[2] = sub_10077A5D8;
      void v16[3] = &unk_101A04A90;
      void v16[4] = &v19;
      sub_10077A074(a1, &v17, (uint64_t)v16);
      sub_1000558F4(&v17);
    }
  }
  if (*(void *)(a1 + 8))
  {
    CPRecordStoreDestroy();
    *(void *)(a1 + 8) = 0;
  }
  sub_100062708(a3, (CFTypeRef)v20[5]);
  sub_1000558F4(&cf);
  _Block_object_dispose(&v19, 8);
  return sub_1000440D4(&v24);
}

void sub_10077A578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  CFStringRef v12 = va_arg(va1, const void *);
  va_copy(va2, va1);
  xpc_object_t v14 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Block_object_dispose(va2, 8);
  sub_1000440D4(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10077A5BC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = 0;
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

const void **sub_10077A5D0(uint64_t a1)
{
  return sub_1000440D4((const void **)(a1 + 40));
}

uint64_t sub_10077A5D8(uint64_t a1, uint64_t a2)
{
  return _CPSqliteStatementSendResults(a2, sub_10077A5FC, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
}

uint64_t sub_10077A5FC(uint64_t a1, const __CFArray *a2)
{
  keys = 0;
  CFStringRef v37 = 0;
  CFStringRef v38 = 0;
  values = 0;
  CFNumberRef v34 = 0;
  CFMutableArrayRef v35 = 0;
  int v4 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 0);
  int v32 = v4;
  int v5 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 1);
  int v31 = v5;
  int v30 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 2);
  CFIndex Count = CFArrayGetCount(a2);
  if (Count < 1) {
    goto LABEL_20;
  }
  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, Count - 1);
  if (!ValueAtIndex) {
    goto LABEL_20;
  }
  CFDictionaryRef v8 = ValueAtIndex;
  CFStringRef Value = CFDictionaryGetValue(ValueAtIndex, @"MCC");
  if (Value)
  {
    CFStringRef v10 = Value;
    CFTypeID v11 = CFGetTypeID(Value);
    CFNumberRef v12 = v11 == CFNumberGetTypeID() ? (const __CFNumber *)v10 : 0;
  }
  else
  {
    CFNumberRef v12 = 0;
  }
  CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(v8, @"MNC");
  if (!v13
    || (CFNumberRef v14 = v13, v15 = CFGetTypeID(v13), TypeID = CFNumberGetTypeID(), !v12)
    || v15 != TypeID
    || (LODWORD(valuePtr) = 0,
        LODWORD(v28) = 0,
        CFNumberGetValue(v12, kCFNumberIntType, &valuePtr),
        CFNumberGetValue(v14, kCFNumberIntType, &v28),
        v4 != valuePtr)
    || v5 != v28)
  {
LABEL_20:
    CFNumberRef valuePtr = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v32);
    CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v31);
    CFMutableArrayRef theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    keys = @"MCC";
    CFStringRef v37 = @"MNC";
    values = valuePtr;
    CFNumberRef v34 = v28;
    CFStringRef v38 = @"UARFCN";
    CFMutableArrayRef v35 = theArray;
    CFNumberRef v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v30);
    CFArrayAppendValue(theArray, v26);
    CFDictionaryRef v22 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryRef v25 = v22;
    if (v22) {
      long long v23 = sub_100080778;
    }
    else {
      long long v23 = 0;
    }
    if (v23) {
      CFArrayAppendValue(a2, v22);
    }
    sub_100057D78((const void **)&v25);
    sub_1000570E8((const void **)&v26);
    sub_1000440D4((const void **)&theArray);
    sub_1000570E8((const void **)&v28);
    goto LABEL_26;
  }
  CFTypeRef v17 = (__CFArray *)CFDictionaryGetValue(v8, @"UARFCN");
  xpc_object_t v18 = v17;
  if (v17)
  {
    CFTypeID v19 = CFGetTypeID(v17);
    if (v19 == CFArrayGetTypeID())
    {
      CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v30);
      CFNumberRef valuePtr = v20;
      if (v20) {
        uint64_t v21 = sub_100081E58;
      }
      else {
        uint64_t v21 = 0;
      }
      if (v21) {
        CFArrayAppendValue(v18, v20);
      }
LABEL_26:
      sub_1000570E8((const void **)&valuePtr);
    }
  }
  return 0;
}

void sub_10077A900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_10077A964@<X0>(uint64_t a1@<X0>, CFArrayRef *a2@<X2>, void *a3@<X8>)
{
  uint64_t v41 = 0;
  long long v42 = &v41;
  uint64_t v43 = 0x3002000000;
  long long v44 = sub_10077A5BC;
  long long v45 = sub_10077A5D0;
  CFMutableArrayRef Mutable = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  sub_100779CCC((const void **)a1);
  if (*a2) {
    xpc_object_t v6 = sub_100083F10;
  }
  else {
    xpc_object_t v6 = 0;
  }
  if (v6)
  {
    CFIndex Count = CFArrayGetCount(*a2);
    if (Count)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*a2, 0);
      long long v40 = ValueAtIndex;
      if (ValueAtIndex) {
        CFRetain(ValueAtIndex);
      }
      uint64_t v33 = a3;
      long long v39 = 0;
      sub_1000842D0(&v39, &v40);
      CFStringRef v38 = 0;
      sub_10004EFE4(&v38, &v40);
      if (Count >= 1)
      {
        for (CFIndex i = 0; Count != i; ++i)
        {
          CFTypeRef cf = 0;
          if (v39) {
            CFStringRef v10 = sub_100081E58;
          }
          else {
            CFStringRef v10 = 0;
          }
          if (v10)
          {
            CFNumberRef v11 = (const __CFNumber *)CFArrayGetValueAtIndex(*a2, i);
            CFNumberRef v12 = v11;
            if (v11)
            {
              CFTypeID v13 = CFGetTypeID(v11);
              if (v13 == CFNumberGetTypeID()) {
                CFNumberRef v14 = v12;
              }
              else {
                CFNumberRef v14 = 0;
              }
            }
            else
            {
              CFNumberRef v14 = 0;
            }
            WORD2(valuePtr) = 0;
            CFNumberGetValue(v14, kCFNumberSInt16Type, (char *)&valuePtr + 4);
            CFStringRef v23 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            CFStringRef v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v23, SWORD2(valuePtr));
          }
          else
          {
            if (v38) {
              CFTypeID v15 = sub_100080778;
            }
            else {
              CFTypeID v15 = 0;
            }
            if (!v15) {
              goto LABEL_39;
            }
            CFDictionaryRef v16 = (const __CFDictionary *)CFArrayGetValueAtIndex(*a2, i);
            CFDictionaryRef v17 = v16;
            if (v16)
            {
              CFTypeID v18 = CFGetTypeID(v16);
              if (v18 != CFDictionaryGetTypeID()) {
                CFDictionaryRef v17 = 0;
              }
            }
            uint64_t valuePtr = 0;
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v17, @"MCC");
            CFNumberRef v20 = Value;
            if (Value)
            {
              CFTypeID v21 = CFGetTypeID(Value);
              if (v21 == CFNumberGetTypeID()) {
                CFNumberRef v22 = v20;
              }
              else {
                CFNumberRef v22 = 0;
              }
            }
            else
            {
              CFNumberRef v22 = 0;
            }
            CFNumberGetValue(v22, kCFNumberIntType, (char *)&valuePtr + 4);
            CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(v17, @"MNC");
            CFNumberRef v26 = v25;
            if (v25)
            {
              CFTypeID v27 = CFGetTypeID(v25);
              if (v27 == CFNumberGetTypeID()) {
                CFNumberRef v28 = v26;
              }
              else {
                CFNumberRef v28 = 0;
              }
            }
            else
            {
              CFNumberRef v28 = 0;
            }
            CFNumberGetValue(v28, kCFNumberIntType, &valuePtr);
            CFStringRef v29 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
            CFStringRef v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v29, HIDWORD(valuePtr), valuePtr);
          }
          CFTypeRef v30 = cf;
          CFTypeRef cf = v24;
          long long v47 = v30;
          sub_1000558F4(&v47);
LABEL_39:
          if (cf) {
            int v31 = sub_1000810B8;
          }
          else {
            int v31 = 0;
          }
          if (v31)
          {
            CFTypeRef v35 = cf;
            if (cf) {
              CFRetain(cf);
            }
            v34[0] = _NSConcreteStackBlock;
            v34[1] = 0x40000000;
            v34[2] = sub_10077AE0C;
            v34[3] = &unk_101A04AB8;
            v34[4] = &v41;
            sub_10077A074(a1, &v35, (uint64_t)v34);
            sub_1000558F4(&v35);
          }
          sub_1000558F4(&cf);
        }
      }
      sub_100057D78(&v38);
      sub_1000570E8(&v39);
      sub_1000577C4(&v40);
      a3 = v33;
    }
  }
  if (*(void *)(a1 + 8))
  {
    CPRecordStoreDestroy();
    *(void *)(a1 + 8) = 0;
  }
  sub_100062708(a3, (CFTypeRef)v42[5]);
  _Block_object_dispose(&v41, 8);
  return sub_1000440D4((const void **)&Mutable);
}

void sub_10077AD7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26,char a27)
{
}

uint64_t sub_10077AE0C(uint64_t a1, uint64_t a2)
{
  return _CPSqliteStatementSendResults(a2, sub_10077A5FC, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
}

CFStringRef sub_10077AE30(uint64_t a1, int a2)
{
  if (a2 == 3) {
    return @"select mcc, mnc, arfcn, max(numpoints) as maxpoints from LasdUmtsBoxes, LasdUmtsBoxesRT where LasdUmtsBoxes.id = LasdUmtsBoxesRT.id and LasdUmtsBoxesRT.minlat <= (%f + 0.5) and LasdUmtsBoxesRT.maxlat >= (%f - 0.5) and LasdUmtsBoxesRT.minlong <= (%f + 0.5) and LasdUmtsBoxesRT.maxlong >= (%f - 0.5) group by mcc, mnc, arfcn order by maxpoints desc;";
  }
  else {
    return @"select mcc, mnc, arfcn, max(numpoints) as maxpoints from LasdUmtsBoxes, LasdUmtsBoxesRT where LasdUmtsBoxes.id = LasdUmtsBoxesRT.id and LasdUmtsBoxesRT.minlat <= (%f) and LasdUmtsBoxesRT.maxlat >= (%f) and LasdUmtsBoxesRT.minlong <= (%f) and LasdUmtsBoxesRT.maxlong >= (%f) group by mcc, mnc, arfcn order by maxpoints desc;";
  }
}

CFStringRef sub_10077AE4C()
{
  return @"select distinct mcc, mnc, arfcn from LasdUmtsList where mcc = %d;";
}

CFStringRef sub_10077AE58()
{
  return @"select distinct mcc, mnc, arfcn from LasdUmtsList where mcc = %d and mnc = %d;";
}

CFStringRef sub_10077AE64(uint64_t a1, int a2)
{
  if (a2 == 3) {
    return @"select mcc, mnc, arfcn, max(numpoints) as maxpoints from LasdScdmaBoxes, LasdScdmaBoxesRT where LasdScdmaBoxes.id = LasdScdmaBoxesRT.id and LasdScdmaBoxesRT.minlat <= (%f + 0.5) and LasdScdmaBoxesRT.maxlat >= (%f - 0.5) and LasdScdmaBoxesRT.minlong <= (%f + 0.5) and LasdScdmaBoxesRT.maxlong >= (%f - 0.5) group by mcc, mnc, arfcn order by maxpoints desc;";
  }
  else {
    return @"select mcc, mnc, arfcn, max(numpoints) as maxpoints from LasdScdmaBoxes, LasdScdmaBoxesRT where LasdScdmaBoxes.id = LasdScdmaBoxesRT.id and LasdScdmaBoxesRT.minlat <= (%f) and LasdScdmaBoxesRT.maxlat >= (%f) and LasdScdmaBoxesRT.minlong <= (%f) and LasdScdmaBoxesRT.maxlong >= (%f) group by mcc, mnc, arfcn order by maxpoints desc;";
  }
}

CFStringRef sub_10077AE80()
{
  return @"select distinct mcc, mnc, arfcn from LasdScdmaList where mcc = %d;";
}

CFStringRef sub_10077AE8C()
{
  return @"select distinct mcc, mnc, arfcn from LasdScdmaList where mcc = %d and mnc = %d;";
}

uint64_t sub_10077AE98(uint64_t a1, __CFArray *a2)
{
  int valuePtr = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 0);
  int v16 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 1);
  int v15 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 2);
  int v4 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 3);
  int v14 = v4;
  if (v15 < 0)
  {
    int v15 = 0xFFFF;
    if ((v4 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_15:
    int v14 = 0xFFFF;
    goto LABEL_3;
  }
  if (v4 < 0) {
    goto LABEL_15;
  }
LABEL_3:
  CFNumberRef v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v16);
  CFNumberRef v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v15);
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v14);
  CFNumberRef v10 = v5;
  values[0] = v13;
  values[1] = v12;
  values[2] = v11;
  values[3] = v5;
  if (v13 && v12 && v11 && v5)
  {
    CFArrayRef v6 = CFArrayCreate(kCFAllocatorDefault, (const void **)values, 4, &kCFTypeArrayCallBacks);
    CFArrayRef v9 = v6;
    if (v6) {
      uint64_t v7 = sub_100083F10;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7) {
      CFArrayAppendValue(a2, v6);
    }
    sub_100044D00((const void **)&v9);
  }
  sub_1000570E8((const void **)&v10);
  sub_1000570E8((const void **)&v11);
  sub_1000570E8((const void **)&v12);
  sub_1000570E8((const void **)&v13);
  return 0;
}

void sub_10077B048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13)
{
}

const void **sub_10077B0A4@<X0>(uint64_t a1@<X0>, int a2@<W2>, void *a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  CFDictionaryRef v33 = 0;
  sub_100779CCC((const void **)a1);
  if (a2 == 3) {
    CFStringRef v10 = @"select bandclass, channel, sectorid, max(numpoints) as maxpoints from LasdEvdoBoxes, LasdEvdoBoxesRT where LasdEvdoBoxes.id = LasdEvdoBoxesRT.id and LasdEvdoBoxesRT.minlat <= (%f + 0.5) and LasdEvdoBoxesRT.maxlat >= (%f - 0.5) and LasdEvdoBoxesRT.minlong <= (%f + 0.5) and LasdEvdoBoxesRT.maxlong >= (%f - 0.5) group by bandclass, channel, sectorid order by maxpoints desc;";
  }
  else {
    CFStringRef v10 = @"select bandclass, channel, sectorid, max(numpoints) as maxpoints from LasdEvdoBoxes, LasdEvdoBoxesRT where LasdEvdoBoxes.id = LasdEvdoBoxesRT.id and LasdEvdoBoxesRT.minlat <= (%f) and LasdEvdoBoxesRT.maxlat >= (%f) and LasdEvdoBoxesRT.minlong <= (%f) and LasdEvdoBoxesRT.maxlong >= (%f) group by bandclass, channel, sectorid order by maxpoints desc;";
  }
  CFStringRef v32 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v10, *(void *)&a4, *(void *)&a4, *(void *)&a5, *(void *)&a5);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFTypeRef cf = Mutable;
  if (v32) {
    CFNumberRef v12 = sub_1000810B8;
  }
  else {
    CFNumberRef v12 = 0;
  }
  if (v12)
  {
    if (Mutable ? sub_100289354 : 0)
    {
      CFStringRef v30 = v32;
      if (v32)
      {
        CFRetain(v32);
        CFMutableArrayRef Mutable = cf;
      }
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 1174405120;
      v28[2] = sub_10077B4B8;
      v28[3] = &unk_101A04B98;
      CFStringRef v29 = Mutable;
      if (Mutable) {
        CFRetain(Mutable);
      }
      sub_10077A074(a1, &v30, (uint64_t)v28);
      sub_1000558F4((const void **)&v30);
      sub_1000440D4(&v29);
    }
  }
  CFStringRef v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"select bandclass, channel, sid, nid, max(numpoints) as maxpoints from Lasd1XBoxes, Lasd1XBoxesRT where Lasd1XBoxes.id = Lasd1XBoxesRT.id and Lasd1XBoxesRT.minlat <= (%f) and Lasd1XBoxesRT.maxlat >= (%f) and Lasd1XBoxesRT.minlong <= (%f) and Lasd1XBoxesRT.maxlong >= (%f) group by bandclass, channel, sid, nid order by maxpoints desc;",
          *(void *)&a4,
          *(void *)&a4,
          *(void *)&a5,
          *(void *)&a5);
  CFStringRef v15 = v32;
  CFStringRef v32 = v14;
  keys[0] = (void *)v15;
  sub_1000558F4((const void **)keys);
  int v16 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFTypeRef v27 = v16;
  if (v32) {
    CFDictionaryRef v17 = sub_1000810B8;
  }
  else {
    CFDictionaryRef v17 = 0;
  }
  if (v17)
  {
    if (v16 ? sub_100289354 : 0)
    {
      CFStringRef v26 = v32;
      if (v32)
      {
        CFRetain(v32);
        int v16 = v27;
      }
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 1174405120;
      void v24[2] = sub_10077B6E4;
      v24[3] = &unk_101A04BC8;
      CFNumberRef v25 = v16;
      if (v16) {
        CFRetain(v16);
      }
      sub_10077A074(a1, &v26, (uint64_t)v24);
      sub_1000558F4((const void **)&v26);
      sub_1000440D4(&v25);
    }
  }
  if (cf) {
    CFTypeID v19 = sub_100289354;
  }
  else {
    CFTypeID v19 = 0;
  }
  if (v19)
  {
    if (v27 ? sub_100289354 : 0)
    {
      keys[0] = @"EVDO";
      keys[1] = @"1X";
      values[0] = (void *)cf;
      values[1] = (void *)v27;
      CFDictionaryRef v21 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionaryRef v22 = v33;
      CFDictionaryRef v33 = v21;
      CFDictionaryRef v34 = v22;
      sub_100057D78((const void **)&v34);
    }
  }
  if (*(void *)(a1 + 8))
  {
    CPRecordStoreDestroy();
    *(void *)(a1 + 8) = 0;
  }
  sub_100062708(a3, v33);
  sub_1000440D4(&v27);
  sub_1000440D4(&cf);
  sub_1000558F4((const void **)&v32);
  return sub_100057D78((const void **)&v33);
}

void sub_10077B41C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,int a29,__int16 a30,char a31,char a32)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10077B4B8(uint64_t a1, uint64_t a2)
{
  return _CPSqliteStatementSendResults(a2, sub_10077B4D4, *(void *)(a1 + 32));
}

uint64_t sub_10077B4D4(uint64_t a1, __CFArray *a2)
{
  int valuePtr = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 0);
  int v16 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 1);
  int v4 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 8), 2);
  sqlite3_column_text(*(sqlite3_stmt **)(a1 + 8), 2);
  CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v16);
  if (v4) {
    __TUAssertTrigger();
  }
  if (v4 >= 0) {
    int v5 = v4;
  }
  else {
    int v5 = v4 + 1;
  }
  CFMutableArrayRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, (uint64_t)v5 >> 1);
  uint64_t v7 = Mutable;
  if (Mutable)
  {
    CFDataGetMutableBytePtr(Mutable);
    unsigned int v8 = TelephonyUtilHexToBin();
    CFDataSetLength(v7, v8);
  }
  CFNumberRef v13 = v7;
  values[0] = v15;
  values[1] = v14;
  values[2] = v7;
  if (v15 && v14 && v7)
  {
    CFArrayRef v9 = CFArrayCreate(kCFAllocatorDefault, (const void **)values, 3, &kCFTypeArrayCallBacks);
    CFArrayRef v12 = v9;
    if (v9) {
      CFStringRef v10 = sub_100083F10;
    }
    else {
      CFStringRef v10 = 0;
    }
    if (v10) {
      CFArrayAppendValue(a2, v9);
    }
    sub_100044D00((const void **)&v12);
  }
  sub_100030068((const void **)&v13);
  sub_1000570E8((const void **)&v14);
  sub_1000570E8((const void **)&v15);
  return 0;
}

void sub_10077B684(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  CFStringRef v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v5 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, const void *);
  sub_100044D00((const void **)va);
  sub_100030068((const void **)va1);
  sub_1000570E8((const void **)va2);
  sub_1000570E8((const void **)va3);
  _Unwind_Resume(a1);
}

const void **sub_10077B6D0(uint64_t a1, uint64_t a2)
{
  return sub_100687E80((const void **)(a1 + 32), (const void **)(a2 + 32));
}

const void **sub_10077B6DC(uint64_t a1)
{
  return sub_1000440D4((const void **)(a1 + 32));
}

uint64_t sub_10077B6E4(uint64_t a1, uint64_t a2)
{
  return _CPSqliteStatementSendResults(a2, sub_10077AE98, *(void *)(a1 + 32));
}

const void **sub_10077B700@<X0>(void *a1@<X8>)
{
  uint64_t v2 = 0;
  *a1 = 0;
  return sub_100044D00(&v2);
}

CFStringRef sub_10077B72C(uint64_t a1, int a2)
{
  if (a2 == 3) {
    return @"select mcc, mnc, earfcn, bandinfo, bandwidth, deployment_type, max(numpoints) as maxpoints from LasdLteBoxes, LasdLteBoxesRT where LasdLteBoxes.id = LasdLteBoxesRT.id and LasdLteBoxesRT.minlat <= (%f + 0.5) and LasdLteBoxesRT.maxlat >= (%f - 0.5) and LasdLteBoxesRT.minlong <= (%f + 0.5) and LasdLteBoxesRT.maxlong >= (%f - 0.5) group by mcc, mnc, earfcn order by maxpoints desc;";
  }
  else {
    return @"select mcc, mnc, earfcn, bandinfo, bandwidth, deployment_type, max(numpoints) as maxpoints from LasdLteBoxes, LasdLteBoxesRT where LasdLteBoxes.id = LasdLteBoxesRT.id and LasdLteBoxesRT.minlat <= (%f) and LasdLteBoxesRT.maxlat >= (%f) and LasdLteBoxesRT.minlong <= (%f) and LasdLteBoxesRT.maxlong >= (%f) group by mcc, mnc, earfcn order by maxpoints desc;";
  }
}

CFStringRef sub_10077B748(uint64_t a1, int a2)
{
  if (a2 == 3) {
    return @"select mcc, mnc, earfcn, bandinfo, bandwidth, max(numpoints) as maxpoints from LasdLteBoxes, LasdLteBoxesRT where LasdLteBoxes.id = LasdLteBoxesRT.id and LasdLteBoxesRT.minlat <= (%f + 0.5) and LasdLteBoxesRT.maxlat >= (%f - 0.5) and LasdLteBoxesRT.minlong <= (%f + 0.5) and LasdLteBoxesRT.maxlong >= (%f - 0.5) group by mcc, mnc, earfcn order by maxpoints desc;";
  }
  else {
    return @"select mcc, mnc, earfcn, bandinfo, bandwidth, max(numpoints) as maxpoints from LasdLteBoxes, LasdLteBoxesRT where LasdLteBoxes.id = LasdLteBoxesRT.id and LasdLteBoxesRT.minlat <= (%f) and LasdLteBoxesRT.maxlat >= (%f) and LasdLteBoxesRT.minlong <= (%f) and LasdLteBoxesRT.maxlong >= (%f) group by mcc, mnc, earfcn order by maxpoints desc;";
  }
}

const void **sub_10077B764@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>, double a5@<D0>, double a6@<D1>)
{
  uint64_t v29 = 0;
  CFStringRef v30 = &v29;
  uint64_t v31 = 0x3002000000;
  CFStringRef v32 = sub_10077A5BC;
  CFDictionaryRef v33 = sub_10077A5D0;
  CFDictionaryRef v34 = 0;
  sub_100779CCC((const void **)a1);
  if ((*(unsigned int (**)(void))(**(void **)a2 + 80))())
  {
    CFStringRef v12 = (const __CFString *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, a3);
    CFTypeRef cf = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v12, *(void *)&a5, *(void *)&a5, *(void *)&a6, *(void *)&a6);
    if (cf) {
      CFNumberRef v13 = sub_1000810B8;
    }
    else {
      CFNumberRef v13 = 0;
    }
    if (!v13) {
      goto LABEL_25;
    }
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFNumberRef v15 = (const void *)v30[5];
    v30[5] = (uint64_t)Mutable;
    CFTypeRef v35 = v15;
    sub_1000440D4(&v35);
    if (!(v30[5] ? sub_100289354 : 0)) {
      goto LABEL_25;
    }
    CFTypeRef v27 = cf;
    if (cf) {
      CFRetain(cf);
    }
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 0x40000000;
    v26[2] = sub_10077BB2C;
    v26[3] = &unk_101A04C40;
    v26[4] = &v29;
    sub_10077A074(a1, &v27, (uint64_t)v26);
    CFDictionaryRef v17 = &v27;
  }
  else
  {
    CFStringRef v18 = (const __CFString *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, a3);
    CFTypeRef cf = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v18, *(void *)&a5, *(void *)&a5, *(void *)&a6, *(void *)&a6);
    if (cf) {
      CFTypeID v19 = sub_1000810B8;
    }
    else {
      CFTypeID v19 = 0;
    }
    if (!v19) {
      goto LABEL_25;
    }
    CFMutableArrayRef v20 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFDictionaryRef v21 = (const void *)v30[5];
    v30[5] = (uint64_t)v20;
    CFTypeRef v35 = v21;
    sub_1000440D4(&v35);
    if (!(v30[5] ? sub_100289354 : 0)) {
      goto LABEL_25;
    }
    CFTypeRef v25 = cf;
    if (cf) {
      CFRetain(cf);
    }
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    void v24[2] = sub_10077BE54;
    v24[3] = &unk_101A04C68;
    void v24[4] = &v29;
    sub_10077A074(a1, &v25, (uint64_t)v24);
    CFDictionaryRef v17 = &v25;
  }
  sub_1000558F4(v17);
LABEL_25:
  sub_1000558F4(&cf);
  if (*(void *)(a1 + 8))
  {
    CPRecordStoreDestroy();
    *(void *)(a1 + 8) = 0;
  }
  sub_100062708(a4, (CFTypeRef)v30[5]);
  _Block_object_dispose(&v29, 8);
  return sub_1000440D4(&v34);
}

void sub_10077BAD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  CFNumberRef v13 = va_arg(va1, const void *);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Block_object_dispose((const void *)(v11 - 120), 8);
  sub_1000440D4(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10077BB2C(uint64_t a1, uint64_t a2)
{
  return _CPSqliteStatementSendResults(a2, sub_10077BB50, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
}

uint64_t sub_10077BB50(uint64_t a1, __CFArray *a2)
{
  int valuePtr = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 0);
  int v25 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 1);
  int v24 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 2);
  int v23 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 3);
  int v22 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 4);
  int v21 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 5);
  CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v25);
  CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v24);
  CFNumberRef v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v23);
  CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v22);
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v21);
  CFNumberRef v15 = v4;
  if (v20) {
    int v5 = sub_100081E58;
  }
  else {
    int v5 = 0;
  }
  if (v5)
  {
    if (v19 ? sub_100081E58 : 0)
    {
      if (v18 ? sub_100081E58 : 0)
      {
        if (v17 ? sub_100081E58 : 0)
        {
          if (v16 ? sub_100081E58 : 0)
          {
            if (v4 ? sub_100081E58 : 0)
            {
              values[0] = v20;
              values[1] = v19;
              values[2] = v18;
              values[3] = v17;
              values[4] = v16;
              values[5] = v4;
              CFArrayRef v11 = CFArrayCreate(kCFAllocatorDefault, (const void **)values, 6, &kCFTypeArrayCallBacks);
              CFArrayRef v14 = v11;
              if (v11) {
                CFStringRef v12 = sub_100083F10;
              }
              else {
                CFStringRef v12 = 0;
              }
              if (a2 && v12) {
                CFArrayAppendValue(a2, v11);
              }
              sub_100044D00((const void **)&v14);
            }
          }
        }
      }
    }
  }
  sub_1000570E8((const void **)&v15);
  sub_1000570E8((const void **)&v16);
  sub_1000570E8((const void **)&v17);
  sub_1000570E8((const void **)&v18);
  sub_1000570E8((const void **)&v19);
  sub_1000570E8((const void **)&v20);
  return 0;
}

void sub_10077BDD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va6, a2);
  va_start(va5, a2);
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  CFStringRef v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v5 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, const void *);
  va_copy(va4, va3);
  CFArrayRef v9 = va_arg(va4, const void *);
  va_copy(va5, va4);
  CFArrayRef v11 = va_arg(va5, const void *);
  va_copy(va6, va5);
  CFNumberRef v13 = va_arg(va6, const void *);
  sub_100044D00((const void **)va);
  sub_1000570E8((const void **)va1);
  sub_1000570E8((const void **)va2);
  sub_1000570E8((const void **)va3);
  sub_1000570E8((const void **)va4);
  sub_1000570E8((const void **)va5);
  sub_1000570E8((const void **)va6);
  _Unwind_Resume(a1);
}

void sub_10077BE44()
{
}

void sub_10077BE4C()
{
}

uint64_t sub_10077BE54(uint64_t a1, uint64_t a2)
{
  return _CPSqliteStatementSendResults(a2, sub_10077BE78, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
}

uint64_t sub_10077BE78(uint64_t a1, __CFArray *a2)
{
  int valuePtr = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 0);
  int v22 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 1);
  int v21 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 2);
  int v20 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 3);
  int v19 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 4);
  CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFNumberRef v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v22);
  CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v21);
  CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v20);
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v19);
  CFNumberRef v14 = v4;
  if (v18) {
    int v5 = sub_100081E58;
  }
  else {
    int v5 = 0;
  }
  if (v5)
  {
    if (v17 ? sub_100081E58 : 0)
    {
      if (v16 ? sub_100081E58 : 0)
      {
        if (v15 ? sub_100081E58 : 0)
        {
          if (v4 ? sub_100081E58 : 0)
          {
            values[0] = v18;
            values[1] = v17;
            values[2] = v16;
            values[3] = v15;
            values[4] = v4;
            CFArrayRef v10 = CFArrayCreate(kCFAllocatorDefault, (const void **)values, 5, &kCFTypeArrayCallBacks);
            CFArrayRef v13 = v10;
            if (v10) {
              CFArrayRef v11 = sub_100083F10;
            }
            else {
              CFArrayRef v11 = 0;
            }
            if (a2 && v11) {
              CFArrayAppendValue(a2, v10);
            }
            sub_100044D00((const void **)&v13);
          }
        }
      }
    }
  }
  sub_1000570E8((const void **)&v14);
  sub_1000570E8((const void **)&v15);
  sub_1000570E8((const void **)&v16);
  sub_1000570E8((const void **)&v17);
  sub_1000570E8((const void **)&v18);
  return 0;
}

void sub_10077C0B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va5, a2);
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  CFStringRef v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v5 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, const void *);
  va_copy(va4, va3);
  CFArrayRef v9 = va_arg(va4, const void *);
  va_copy(va5, va4);
  CFArrayRef v11 = va_arg(va5, const void *);
  sub_100044D00((const void **)va);
  sub_1000570E8((const void **)va1);
  sub_1000570E8((const void **)va2);
  sub_1000570E8((const void **)va3);
  sub_1000570E8((const void **)va4);
  sub_1000570E8((const void **)va5);
  _Unwind_Resume(a1);
}

void sub_10077C118()
{
}

const void **sub_10077C120@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, CFArrayRef *a3@<X2>, void *a4@<X8>)
{
  uint64_t v44 = 0;
  long long v45 = &v44;
  uint64_t v46 = 0x3002000000;
  long long v47 = sub_10077A5BC;
  long long v48 = sub_10077A5D0;
  CFMutableArrayRef Mutable = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  sub_100779CCC((const void **)a1);
  if (*a3) {
    unsigned int v8 = sub_100083F10;
  }
  else {
    unsigned int v8 = 0;
  }
  if (v8)
  {
    CFIndex Count = CFArrayGetCount(*a3);
    if (Count)
    {
      uint64_t v43 = 0;
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*a3, 0);
      uint64_t v43 = ValueAtIndex;
      if (ValueAtIndex) {
        CFRetain(ValueAtIndex);
      }
      long long v42 = 0;
      sub_1000842D0(&v42, &v43);
      uint64_t v41 = 0;
      sub_10004EFE4(&v41, &v43);
      int v11 = (*(uint64_t (**)(void))(**(void **)a2 + 80))();
      CFStringRef v12 = @"select distinct mcc, mnc, earfcn, bandinfo, bandwidth from LasdLTEList where mcc = %d and mnc = %d;";
      if (v11) {
        CFStringRef v12 = @"select distinct mcc, mnc, earfcn, bandinfo, bandwidth, deployment_type from LasdLTEList where mcc = %d and mnc = %d;";
      }
      CFStringRef format = v12;
      if (v11) {
        CFStringRef v13 = @"select distinct mcc, mnc, earfcn, bandinfo, bandwidth, deployment_type from LasdLTEList where mcc = %d;";
      }
      else {
        CFStringRef v13 = @"select distinct mcc, mnc, earfcn, bandinfo, bandwidth from LasdLTEList where mcc = %d;";
      }
      if (Count >= 1)
      {
        for (CFIndex i = 0; Count != i; ++i)
        {
          CFTypeRef cf = 0;
          if (v42) {
            CFNumberRef v15 = sub_100081E58;
          }
          else {
            CFNumberRef v15 = 0;
          }
          if (v15)
          {
            CFNumberRef v16 = (const __CFNumber *)CFArrayGetValueAtIndex(*a3, i);
            CFNumberRef v17 = v16;
            if (v16)
            {
              CFTypeID v18 = CFGetTypeID(v16);
              if (v18 == CFNumberGetTypeID()) {
                CFNumberRef v19 = v17;
              }
              else {
                CFNumberRef v19 = 0;
              }
            }
            else
            {
              CFNumberRef v19 = 0;
            }
            WORD2(valuePtr) = 0;
            CFNumberGetValue(v19, kCFNumberSInt16Type, (char *)&valuePtr + 4);
            CFStringRef v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v13, SWORD2(valuePtr));
          }
          else
          {
            if (v41) {
              int v20 = sub_100080778;
            }
            else {
              int v20 = 0;
            }
            if (!v20) {
              goto LABEL_44;
            }
            CFDictionaryRef v21 = (const __CFDictionary *)CFArrayGetValueAtIndex(*a3, i);
            CFDictionaryRef v22 = v21;
            if (v21)
            {
              CFTypeID v23 = CFGetTypeID(v21);
              if (v23 != CFDictionaryGetTypeID()) {
                CFDictionaryRef v22 = 0;
              }
            }
            uint64_t valuePtr = 0;
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v22, @"MCC");
            CFNumberRef v25 = Value;
            if (Value)
            {
              CFTypeID v26 = CFGetTypeID(Value);
              if (v26 == CFNumberGetTypeID()) {
                CFNumberRef v27 = v25;
              }
              else {
                CFNumberRef v27 = 0;
              }
            }
            else
            {
              CFNumberRef v27 = 0;
            }
            CFNumberGetValue(v27, kCFNumberIntType, (char *)&valuePtr + 4);
            CFNumberRef v29 = (const __CFNumber *)CFDictionaryGetValue(v22, @"MNC");
            CFNumberRef v30 = v29;
            if (v29)
            {
              CFTypeID v31 = CFGetTypeID(v29);
              if (v31 == CFNumberGetTypeID()) {
                CFNumberRef v32 = v30;
              }
              else {
                CFNumberRef v32 = 0;
              }
            }
            else
            {
              CFNumberRef v32 = 0;
            }
            CFNumberGetValue(v32, kCFNumberIntType, &valuePtr);
            CFStringRef v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, format, HIDWORD(valuePtr), valuePtr);
          }
          CFTypeRef v33 = cf;
          CFTypeRef cf = v28;
          long long v50 = v33;
          sub_1000558F4(&v50);
LABEL_44:
          if (cf) {
            CFDictionaryRef v34 = sub_1000810B8;
          }
          else {
            CFDictionaryRef v34 = 0;
          }
          if (v34)
          {
            CFTypeRef v38 = cf;
            if (cf) {
              CFRetain(cf);
            }
            v37[0] = _NSConcreteStackBlock;
            v37[1] = 0x40000000;
            dispatch_object_t v37[2] = sub_10077C5E4;
            v37[3] = &unk_101A04C90;
            v37[4] = &v44;
            sub_10077A074(a1, &v38, (uint64_t)v37);
            sub_1000558F4(&v38);
          }
          sub_1000558F4(&cf);
        }
      }
      sub_100057D78(&v41);
      sub_1000570E8(&v42);
      sub_1000577C4(&v43);
    }
  }
  if (*(void *)(a1 + 8))
  {
    CPRecordStoreDestroy();
    *(void *)(a1 + 8) = 0;
  }
  sub_100062708(a4, (CFTypeRef)v45[5]);
  _Block_object_dispose(&v44, 8);
  return sub_1000440D4((const void **)&Mutable);
}

void sub_10077C54C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,const void *a24,const void *a25,const void *a26,char a27)
{
}

uint64_t sub_10077C5E4(uint64_t a1, uint64_t a2)
{
  return _CPSqliteStatementSendResults(a2, sub_10077BE78, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
}

CFStringRef sub_10077C608(uint64_t a1, int a2)
{
  if (a2 == 3) {
    return @"select mcc, mnc, nrarfcn, bandinfo, bandwidth, scs, gscn, max(numpoints) as maxpoints from LasdNRBoxes, LasdNRBoxesRT where LasdNRBoxes.id = LasdNRBoxesRT.id and LasdNRBoxesRT.minlat <= (%f + 0.5) and LasdNRBoxesRT.maxlat >= (%f - 0.5) and LasdNRBoxesRT.minlong <= (%f + 0.5) and LasdNRBoxesRT.maxlong >= (%f - 0.5) group by mcc, mnc, nrarfcn order by maxpoints desc;";
  }
  else {
    return @"select mcc, mnc, nrarfcn, bandinfo, bandwidth, scs, gscn, max(numpoints) as maxpoints from LasdNRBoxes, LasdNRBoxesRT where LasdNRBoxes.id = LasdNRBoxesRT.id and LasdNRBoxesRT.minlat <= (%f) and LasdNRBoxesRT.maxlat >= (%f) and LasdNRBoxesRT.minlong <= (%f) and LasdNRBoxesRT.maxlong >= (%f) group by mcc, mnc, nrarfcn order by maxpoints desc;";
  }
}

const void **sub_10077C624@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, void *a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  uint64_t v19 = 0;
  int v20 = &v19;
  uint64_t v21 = 0x3002000000;
  CFDictionaryRef v22 = sub_10077A5BC;
  CFTypeID v23 = sub_10077A5D0;
  int v24 = 0;
  sub_100779CCC((const void **)a1);
  CFStringRef v10 = (const __CFString *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, a2);
  CFTypeRef cf = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v10, *(void *)&a4, *(void *)&a4, *(void *)&a5, *(void *)&a5);
  if (cf) {
    int v11 = sub_1000810B8;
  }
  else {
    int v11 = 0;
  }
  if (v11)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFStringRef v13 = (const void *)v20[5];
    void v20[5] = (uint64_t)Mutable;
    CFNumberRef v25 = v13;
    sub_1000440D4(&v25);
    if (v20[5] ? sub_100289354 : 0)
    {
      CFTypeRef v17 = cf;
      if (cf) {
        CFRetain(cf);
      }
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 0x40000000;
      v16[2] = sub_10077C86C;
      void v16[3] = &unk_101A04CF0;
      void v16[4] = &v19;
      sub_10077A074(a1, &v17, (uint64_t)v16);
      sub_1000558F4(&v17);
    }
  }
  if (*(void *)(a1 + 8))
  {
    CPRecordStoreDestroy();
    *(void *)(a1 + 8) = 0;
  }
  sub_100062708(a3, (CFTypeRef)v20[5]);
  sub_1000558F4(&cf);
  _Block_object_dispose(&v19, 8);
  return sub_1000440D4(&v24);
}

void sub_10077C824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  CFStringRef v12 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFNumberRef v14 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Block_object_dispose(va2, 8);
  sub_1000440D4(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10077C86C(uint64_t a1, uint64_t a2)
{
  return _CPSqliteStatementSendResults(a2, sub_10077C890, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
}

uint64_t sub_10077C890(uint64_t a1, __CFArray *a2)
{
  int valuePtr = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 0);
  int v28 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 1);
  int v27 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 2);
  int v26 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 3);
  int v25 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 4);
  int v24 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 5);
  int v23 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 8), 6);
  CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFNumberRef v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v28);
  CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v27);
  CFNumberRef v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v26);
  CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v25);
  CFNumberRef v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v24);
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v23);
  CFNumberRef v16 = v4;
  if (v22) {
    int v5 = sub_100081E58;
  }
  else {
    int v5 = 0;
  }
  if (v5)
  {
    if (v21 ? sub_100081E58 : 0)
    {
      if (v20 ? sub_100081E58 : 0)
      {
        if (v19 ? sub_100081E58 : 0)
        {
          if (v18 ? sub_100081E58 : 0)
          {
            if (v17 ? sub_100081E58 : 0)
            {
              if (v4 ? sub_100081E58 : 0)
              {
                values[0] = v22;
                values[1] = v21;
                values[2] = v20;
                values[3] = v19;
                values[4] = v18;
                values[5] = v17;
                values[6] = v4;
                CFArrayRef v12 = CFArrayCreate(kCFAllocatorDefault, (const void **)values, 7, &kCFTypeArrayCallBacks);
                CFArrayRef v15 = v12;
                if (v12) {
                  CFStringRef v13 = sub_100083F10;
                }
                else {
                  CFStringRef v13 = 0;
                }
                if (a2 && v13) {
                  CFArrayAppendValue(a2, v12);
                }
                sub_100044D00((const void **)&v15);
              }
            }
          }
        }
      }
    }
  }
  sub_1000570E8((const void **)&v16);
  sub_1000570E8((const void **)&v17);
  sub_1000570E8((const void **)&v18);
  sub_1000570E8((const void **)&v19);
  sub_1000570E8((const void **)&v20);
  sub_1000570E8((const void **)&v21);
  sub_1000570E8((const void **)&v22);
  return 0;
}

void sub_10077CB68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16)
{
}

void sub_10077CBDC()
{
}

void sub_10077CBE4()
{
}

void sub_10077CBEC()
{
}

const void **sub_10077CBF4@<X0>(uint64_t a1@<X0>, CFArrayRef *a2@<X2>, void *a3@<X8>)
{
  uint64_t v39 = 0;
  long long v40 = &v39;
  uint64_t v41 = 0x3002000000;
  long long v42 = sub_10077A5BC;
  uint64_t v43 = sub_10077A5D0;
  CFMutableArrayRef Mutable = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  sub_100779CCC((const void **)a1);
  if (*a2) {
    CFArrayRef v6 = sub_100083F10;
  }
  else {
    CFArrayRef v6 = 0;
  }
  if (v6)
  {
    CFIndex Count = CFArrayGetCount(*a2);
    if (Count)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*a2, 0);
      CFTypeRef v38 = ValueAtIndex;
      if (ValueAtIndex) {
        CFRetain(ValueAtIndex);
      }
      CFTypeID v31 = a3;
      CFStringRef v37 = 0;
      sub_1000842D0(&v37, &v38);
      uint64_t v36 = 0;
      sub_10004EFE4(&v36, &v38);
      if (Count >= 1)
      {
        for (CFIndex i = 0; Count != i; ++i)
        {
          CFTypeRef cf = 0;
          if (v37) {
            CFStringRef v10 = sub_100081E58;
          }
          else {
            CFStringRef v10 = 0;
          }
          if (v10)
          {
            CFNumberRef v11 = (const __CFNumber *)CFArrayGetValueAtIndex(*a2, i);
            CFNumberRef v12 = v11;
            if (v11)
            {
              CFTypeID v13 = CFGetTypeID(v11);
              if (v13 == CFNumberGetTypeID()) {
                CFNumberRef v14 = v12;
              }
              else {
                CFNumberRef v14 = 0;
              }
            }
            else
            {
              CFNumberRef v14 = 0;
            }
            WORD2(valuePtr) = 0;
            CFNumberGetValue(v14, kCFNumberSInt16Type, (char *)&valuePtr + 4);
            CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"select distinct mcc, mnc, nrarfcn, bandinfo, bandwidth, scs, gscn from LasdNRList where mcc = %d;",
                    SWORD2(valuePtr));
          }
          else
          {
            if (v36) {
              CFArrayRef v15 = sub_100080778;
            }
            else {
              CFArrayRef v15 = 0;
            }
            if (!v15) {
              goto LABEL_39;
            }
            CFDictionaryRef v16 = (const __CFDictionary *)CFArrayGetValueAtIndex(*a2, i);
            CFDictionaryRef v17 = v16;
            if (v16)
            {
              CFTypeID v18 = CFGetTypeID(v16);
              if (v18 != CFDictionaryGetTypeID()) {
                CFDictionaryRef v17 = 0;
              }
            }
            uint64_t valuePtr = 0;
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v17, @"MCC");
            CFNumberRef v20 = Value;
            if (Value)
            {
              CFTypeID v21 = CFGetTypeID(Value);
              if (v21 == CFNumberGetTypeID()) {
                CFNumberRef v22 = v20;
              }
              else {
                CFNumberRef v22 = 0;
              }
            }
            else
            {
              CFNumberRef v22 = 0;
            }
            CFNumberGetValue(v22, kCFNumberIntType, (char *)&valuePtr + 4);
            CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(v17, @"MNC");
            CFNumberRef v25 = v24;
            if (v24)
            {
              CFTypeID v26 = CFGetTypeID(v24);
              if (v26 == CFNumberGetTypeID()) {
                CFNumberRef v27 = v25;
              }
              else {
                CFNumberRef v27 = 0;
              }
            }
            else
            {
              CFNumberRef v27 = 0;
            }
            CFNumberGetValue(v27, kCFNumberIntType, &valuePtr);
            CFStringRef v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"select distinct mcc, mnc, nrarfcn, bandinfo, bandwidth, scs, gscn from LasdNRList where mcc = %d and mnc = %d;",
                    HIDWORD(valuePtr),
                    valuePtr);
          }
          CFTypeRef v28 = cf;
          CFTypeRef cf = v23;
          long long v45 = v28;
          sub_1000558F4(&v45);
LABEL_39:
          if (cf) {
            CFNumberRef v29 = sub_1000810B8;
          }
          else {
            CFNumberRef v29 = 0;
          }
          if (v29)
          {
            CFTypeRef v33 = cf;
            if (cf) {
              CFRetain(cf);
            }
            v32[0] = _NSConcreteStackBlock;
            v32[1] = 0x40000000;
            void v32[2] = sub_10077D05C;
            void v32[3] = &unk_101A04D18;
            uint8_t v32[4] = &v39;
            sub_10077A074(a1, &v33, (uint64_t)v32);
            sub_1000558F4(&v33);
          }
          sub_1000558F4(&cf);
        }
      }
      sub_100057D78(&v36);
      sub_1000570E8(&v37);
      sub_1000577C4(&v38);
      a3 = v31;
    }
  }
  if (*(void *)(a1 + 8))
  {
    CPRecordStoreDestroy();
    *(void *)(a1 + 8) = 0;
  }
  sub_100062708(a3, (CFTypeRef)v40[5]);
  _Block_object_dispose(&v39, 8);
  return sub_1000440D4((const void **)&Mutable);
}

void sub_10077CFCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26,char a27)
{
}

uint64_t sub_10077D05C(uint64_t a1, uint64_t a2)
{
  return _CPSqliteStatementSendResults(a2, sub_10077C890, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
}

void sub_10077D080(void *a1, void *a2)
{
  CFNumberRef v4 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "loc.db");
  void *v4 = 0;
  v4[1] = 0;
  *((_DWORD *)v4 + 4) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v15, (const OsLogContext *)&__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&v15);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v15);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *a1 = off_101A04D48;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = *a2;
  uint64_t v6 = a2[1];
  a1[9] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D6E0, memory_order_acquire) & 1) == 0)
  {
    int v5 = (capabilities::ct *)__cxa_guard_acquire(&qword_101B0D6E0);
    if (v5)
    {
      sub_100058DB0(&qword_101B0D6E8, "/var/wireless/Library/LASD/");
      __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B0D6E8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D6E0);
    }
  }
  if (capabilities::ct::supportsLASDGSMDatabase(v5))
  {
    if (byte_101B0D6FF >= 0) {
      size_t v7 = byte_101B0D6FF;
    }
    else {
      size_t v7 = qword_101B0D6F0;
    }
    memset(&v15, 0, sizeof(v15));
    unsigned int v8 = &v15;
    sub_1000C140C((uint64_t)&v15, v7 + 1);
    if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      unsigned int v8 = (std::string *)v15.__r_.__value_.__r.__words[0];
    }
    if (v7)
    {
      if (byte_101B0D6FF >= 0) {
        CFArrayRef v9 = &qword_101B0D6E8;
      }
      else {
        CFArrayRef v9 = (uint64_t *)qword_101B0D6E8;
      }
      memmove(v8, v9, v7);
    }
    *(_WORD *)((char *)&v8->__r_.__value_.__l.__data_ + v7) = 47;
    CFStringRef v10 = std::string::append(&v15, "lasdgsm.db", 0xAuLL);
    std::string __p = *v10;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
    operator new();
  }
  if (byte_101B0D6FF >= 0) {
    size_t v11 = byte_101B0D6FF;
  }
  else {
    size_t v11 = qword_101B0D6F0;
  }
  memset(&v15, 0, sizeof(v15));
  CFNumberRef v12 = &v15;
  sub_1000C140C((uint64_t)&v15, v11 + 1);
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    CFNumberRef v12 = (std::string *)v15.__r_.__value_.__r.__words[0];
  }
  if (v11)
  {
    if (byte_101B0D6FF >= 0) {
      CFTypeID v13 = &qword_101B0D6E8;
    }
    else {
      CFTypeID v13 = (uint64_t *)qword_101B0D6E8;
    }
    memmove(v12, v13, v11);
  }
  *(_WORD *)((char *)&v12->__r_.__value_.__l.__data_ + v11) = 47;
  CFNumberRef v14 = std::string::append(&v15, "lasdumts.db", 0xBuLL);
  std::string __p = *v14;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  operator new();
}

void sub_10077DA50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  __cxa_guard_abort(&qword_101B0D6E0);
  CFNumberRef v24 = (std::__shared_weak_count *)*((void *)v21 + 9);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_10077EE24((void ***)&__p);
  sub_1006C7390(v22);
  LocationDatabaseInterface::~LocationDatabaseInterface(v21);
  _Unwind_Resume(a1);
}

unint64_t *sub_10077DD50(unint64_t *result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  unint64_t v6 = result[2];
  size_t v7 = (void *)result[1];
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = *result;
    uint64_t v10 = (uint64_t)((uint64_t)v7 - *result) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v12 = v6 - v9;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    uint64_t v22 = result + 2;
    if (v13 >> 60) {
      sub_10006A7CC();
    }
    CFNumberRef v14 = (char *)operator new(16 * v13);
    std::string v15 = &v14[16 * v10];
    *(void *)std::string v15 = a2;
    *((void *)v15 + 1) = a3;
    if (a3)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
      unint64_t v9 = *v5;
      size_t v7 = (void *)v5[1];
    }
    unsigned int v8 = v15 + 16;
    if (v7 == (void *)v9)
    {
      int64x2_t v17 = vdupq_n_s64(v9);
    }
    else
    {
      do
      {
        long long v16 = *((_OWORD *)v7 - 1);
        v7 -= 2;
        *((_OWORD *)v15 - 1) = v16;
        v15 -= 16;
        void *v7 = 0;
        v7[1] = 0;
      }
      while (v7 != (void *)v9);
      int64x2_t v17 = *(int64x2_t *)v5;
    }
    unint64_t *v5 = (unint64_t)v15;
    v5[1] = (unint64_t)v8;
    int64x2_t v20 = v17;
    unint64_t v18 = v5[2];
    v5[2] = (unint64_t)&v14[16 * v13];
    unint64_t v21 = v18;
    uint64_t v19 = v17.i64[0];
    CFStringRef result = (unint64_t *)sub_10019E528((uint64_t)&v19);
  }
  else
  {
    void *v7 = a2;
    v7[1] = a3;
    if (a3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
    }
    unsigned int v8 = v7 + 2;
  }
  v5[1] = (unint64_t)v8;
  return result;
}

void sub_10077DE8C(uint64_t a1)
{
  *(void *)a1 = off_101A04D48;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFNumberRef v4 = (void **)(a1 + 40);
  sub_10077EE24(&v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));
  CFStringRef v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  LocationDatabaseInterface::~LocationDatabaseInterface((LocationDatabaseInterface *)a1);
}

void sub_10077DF18(uint64_t a1)
{
  sub_10077DE8C(a1);

  operator delete();
}

void sub_10077DF50(uint64_t a1@<X0>, std::string::size_type *a2@<X2>, void *a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  void (****v25)(std::string *__return_ptr, double, double);
  int v26;
  void (***v27)(std::string *__return_ptr, double, double);
  void (***v28)(std::string *__return_ptr, double, double);
  CFStringRef v29;
  const void **v31;
  std::string v32;
  std::string v33;
  std::string v34;
  std::string v35;
  void *__p[2];
  std::string::size_type v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  unsigned char buf[22];
  unsigned char *v41;
  long long v42;
  _OWORD v43[2];
  uint64_t vars8;

  uint64_t v10 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  std::string::size_type v12 = *a2;
  unint64_t v11 = (std::__shared_weak_count *)a2[1];
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  memset(v43, 0, sizeof(v43));
  long long v42 = 0u;
  unint64_t v13 = *(NSObject **)(a1 + 32);
  os_signpost_id_t v14 = os_signpost_id_generate(v13);
  if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    std::string v15 = *(NSObject **)(a1 + 32);
    if (os_signpost_enabled(v15))
    {
      *(_DWORD *)std::string buf = 134218240;
      *(double *)&uint8_t buf[4] = a4;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(double *)&buf[14] = a5;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_INTERVAL_BEGIN, v14, "LASDQuery", "lat=%{signpost.description:attribute}f lon=%{signpost.description:attribute}f", buf, 0x16u);
    }
  }
  *(void *)std::string buf = off_101A05228;
  uint64_t v41 = buf;
  *(void *)&long long v42 = v14;
  *((void *)&v42 + 1) = os_retain(v13);
  sub_1000336E8((uint64_t)v43, (uint64_t)buf);
  sub_100033A10(buf);
  CFTypeRef v38 = 0;
  uint64_t v39 = 0;
  std::to_string(&v33, a4);
  long long v16 = std::string::insert(&v33, 0, "LASD query ", 0xBuLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v34.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  unint64_t v18 = std::string::append(&v34, " ", 1uLL);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v32, a5);
  if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64x2_t v20 = &v32;
  }
  else {
    int64x2_t v20 = (std::string *)v32.__r_.__value_.__r.__words[0];
  }
  if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v32.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v32.__r_.__value_.__l.__size_;
  }
  uint64_t v22 = std::string::append(&v35, (const std::string::value_type *)v20, size);
  long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  CFStringRef v37 = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  *(_OWORD *)std::string buf = v42;
  sub_1000336E8((uint64_t)&buf[16], (uint64_t)v43);
  long long v42 = 0uLL;
  sub_100033AF4(v43);
  Registry::createXpcJetsamAssertion();
  sub_1000339DC((uint64_t *)buf);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v34.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
  CFNumberRef v25 = *(void (*****)(std::string *__return_ptr, double, double))(a1 + 40);
  if (v25 == *(void (*****)(std::string *__return_ptr, double, double))(a1 + 48))
  {
    CFTypeID v31 = (const void **)&kCFBooleanFalse;
  }
  else
  {
    CFTypeID v26 = 0;
    do
    {
      v33.__r_.__value_.__r.__words[0] = 0;
      CFNumberRef v27 = *v25;
      v35.__r_.__value_.__r.__words[0] = v12;
      v35.__r_.__value_.__l.__size_ = (std::string::size_type)v11;
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (**v27)(&v33, a4, a5);
      if (v35.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)v35.__r_.__value_.__l.__size_);
      }
      CFTypeRef v28 = *v25;
      CFNumberRef v29 = sub_10077A294(*((_DWORD *)*v25 + 10));
      if (v29)
      {
        if (v33.__r_.__value_.__r.__words[0] ? sub_100080934 : 0)
        {
          CFDictionaryAddValue((CFMutableDictionaryRef)v34.__r_.__value_.__l.__data_, v29, v33.__r_.__value_.__l.__data_);
          CFTypeRef v28 = *v25;
        }
      }
      v26 |= (*(uint64_t (**)(std::string::size_type, void))(*(void *)v12 + 56))(v12, *((unsigned int *)v28 + 10));
      sub_1000577C4((const void **)&v33.__r_.__value_.__l.__data_);
      v25 += 2;
    }
    while (v25 != *(void (*****)(std::string *__return_ptr, double, double))(a1 + 48));
    CFTypeID v31 = (const void **)&kCFBooleanTrue;
    CFMutableArrayRef Mutable = (__CFDictionary *)v34.__r_.__value_.__r.__words[0];
    if ((v26 & 1) == 0) {
      CFTypeID v31 = (const void **)&kCFBooleanFalse;
    }
  }
  CFDictionaryAddValue(Mutable, @"Bootstrap", *v31);
  sub_100062708(a3, v34.__r_.__value_.__l.__data_);
  sub_10005717C((const void **)&v34.__r_.__value_.__l.__data_);
  if (v39) {
    sub_10004D2C8(v39);
  }
  sub_1000339DC((uint64_t *)&v42);
  if (v11) {
    sub_10004D2C8(v11);
  }

  os_unfair_lock_unlock(v10);
}

void sub_10077E3C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,std::__shared_weak_count *a43,char a44)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10005717C((const void **)&a21);
  if (a43) {
    sub_10004D2C8(a43);
  }
  sub_1000339DC((uint64_t *)(v45 - 176));
  if (v44) {
    sub_10004D2C8(v44);
  }
  sub_10006A6AC(exception_object);
}

void sub_10077E4F4(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  CFNumberRef v4 = *(const void ****)(a1 + 40);
  CFStringRef v3 = *(const void ****)(a1 + 48);
  while (v4 != v3)
  {
    sub_100779CCC(*v4);
    v4 += 2;
  }

  os_unfair_lock_unlock(v2);
}

void sub_10077E55C(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  CFNumberRef v4 = *(uint64_t **)(a1 + 40);
  CFStringRef v3 = *(uint64_t **)(a1 + 48);
  while (v4 != v3)
  {
    uint64_t v5 = *v4;
    if (*(void *)(*v4 + 8))
    {
      CPRecordStoreDestroy();
      *(void *)(v5 + 8) = 0;
    }
    v4 += 2;
  }

  os_unfair_lock_unlock(v2);
}

void sub_10077E5D0(uint64_t a1@<X0>, uint64_t *a2@<X1>, const void **a3@<X2>, void *a4@<X8>)
{
  unsigned int v8 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v10 = *a2;
  unint64_t v9 = (std::__shared_weak_count *)a2[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058198((const void **)&theDict, a3);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (CFDictionaryContainsKey(theDict, @"FetchType"))
  {
    CFTypeRef cf = 0;
    *(void *)std::string buf = CFDictionaryGetValue(theDict, @"Parameters");
    sub_100044D6C(&cf, (CFTypeRef *)buf);
    if (cf) {
      unint64_t v11 = sub_100083F10;
    }
    else {
      unint64_t v11 = 0;
    }
    if (v11)
    {
      std::string::size_type v12 = *(uint64_t **)(a1 + 40);
      unint64_t v13 = *(uint64_t **)(a1 + 48);
      if (v12 == v13)
      {
        int64x2_t v20 = (const void **)&kCFBooleanFalse;
      }
      else
      {
        int v14 = 0;
        do
        {
          CFTypeRef v28 = 0;
          uint64_t v15 = *v12;
          *(void *)std::string buf = v10;
          CFTypeID v26 = v9;
          if (v9) {
            atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v24 = cf;
          if (cf) {
            CFRetain(cf);
          }
          (*(void (**)(const void **__return_ptr, uint64_t, uint8_t *, CFTypeRef *))(*(void *)v15 + 8))(&v27, v15, buf, &v24);
          sub_100044D6C(&v28, &v27);
          sub_1000577C4(&v27);
          sub_100044D00(&v24);
          if (v26) {
            sub_10004D2C8(v26);
          }
          long long v16 = v28;
          if (v28) {
            long long v17 = sub_100083F10;
          }
          else {
            long long v17 = 0;
          }
          if (v17)
          {
            unint64_t v18 = Mutable;
            CFStringRef v19 = sub_10077A294(*(_DWORD *)(*v12 + 40));
            CFDictionaryAddValue(v18, v19, v16);
          }
          v14 |= (*(uint64_t (**)(uint64_t, void))(*(void *)v10 + 56))(v10, *(unsigned int *)(*v12 + 40));
          sub_100044D00(&v28);
          v12 += 2;
        }
        while (v12 != v13);
        int64x2_t v20 = (const void **)&kCFBooleanTrue;
        if ((v14 & 1) == 0) {
          int64x2_t v20 = (const void **)&kCFBooleanFalse;
        }
      }
      CFDictionaryAddValue(Mutable, @"Bootstrap", *v20);
      sub_10004EFE4(a4, (CFTypeRef *)&Mutable);
    }
    else
    {
      uint64_t v22 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N No parameters to copy frequency info", buf, 2u);
      }
      sub_10004EFE4(a4, (CFTypeRef *)&Mutable);
    }
    sub_100044D00(&cf);
  }
  else
  {
    unint64_t v21 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N No kLocFetchType key to copy frequency info", buf, 2u);
    }
    sub_10004EFE4(a4, (CFTypeRef *)&Mutable);
  }
  sub_10005717C((const void **)&Mutable);
  sub_100057D78((const void **)&theDict);
  if (v9) {
    sub_10004D2C8(v9);
  }
  os_unfair_lock_unlock(v8);
}

void sub_10077E8F8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, const void *a16)
{
  sub_100044D00(&a15);
  sub_10005717C(&a16);
  sub_100057D78(&a9);
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10006A6AC(a1);
}

void sub_10077E980(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  CFStringRef v3 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = a1 + 40;
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(v6 + 8);
    memset(&v16, 0, sizeof(v16));
    uint64_t v7 = v5 - v4;
    if (v5 == v4)
    {
      uint64_t v10 = &v16;
    }
    else
    {
      int v8 = *(_DWORD *)(*(void *)v4 + 40);
      unint64_t v9 = "gsm";
      switch(v8)
      {
        case 1:
          unint64_t v9 = "umts";
          break;
        case 2:
          unint64_t v9 = "cdma";
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_9;
        case 4:
          unint64_t v9 = "lte";
          break;
        case 8:
          break;
        default:
          if (v8 == 16)
          {
            unint64_t v9 = "scdma";
          }
          else if (v8 == 32)
          {
            unint64_t v9 = "nr";
          }
          else
          {
LABEL_9:
            unint64_t v9 = "unknown";
          }
          break;
      }
      uint64_t v15 = v5 - v4;
      sub_10003ED78(&v16, v9);
      for (uint64_t i = v4 + 16; i != v5; i += 16)
      {
        char v20 = 1;
        strcpy(__s, ",");
        std::string::append(&v16, __s, 1uLL);
        if (v20 < 0) {
          operator delete(*(void **)__s);
        }
        int v12 = *(_DWORD *)(*(void *)i + 40);
        unint64_t v13 = "gsm";
        switch(v12)
        {
          case 1:
            unint64_t v13 = "umts";
            break;
          case 2:
            unint64_t v13 = "cdma";
            break;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_22;
          case 4:
            unint64_t v13 = "lte";
            break;
          case 8:
            break;
          default:
            if (v12 == 16)
            {
              unint64_t v13 = "scdma";
            }
            else if (v12 == 32)
            {
              unint64_t v13 = "nr";
            }
            else
            {
LABEL_22:
              unint64_t v13 = "unknown";
            }
            break;
        }
        size_t v14 = strlen(v13);
        std::string::append(&v16, v13, v14);
      }
      uint64_t v7 = v15;
      uint64_t v10 = &v16;
      if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v10 = (std::string *)v16.__r_.__value_.__r.__words[0];
      }
    }
    *(_DWORD *)__s = 134218242;
    *(void *)&__s[4] = v7 >> 4;
    __int16 v18 = 2082;
    CFStringRef v19 = v10;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %ld databases configured: %{public}s", __s, 0x16u);
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
  }
  os_unfair_lock_unlock(v2);
}

void sub_10077EC34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10006A6AC(exception_object);
}

void sub_10077ECC0(uint64_t a1)
{
  sub_100779C54(a1);

  operator delete();
}

void sub_10077ECFC(uint64_t a1)
{
  sub_100779C54(a1);

  operator delete();
}

void sub_10077ED38(uint64_t a1)
{
  sub_100779C54(a1);

  operator delete();
}

void sub_10077ED74(uint64_t a1)
{
  sub_100779C54(a1);

  operator delete();
}

void sub_10077EDB0(uint64_t a1)
{
  sub_100779C54(a1);

  operator delete();
}

void sub_10077EDEC(uint64_t a1)
{
  sub_100779C54(a1);

  operator delete();
}

void sub_10077EE24(void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
        if (v6) {
          sub_10004D2C8(v6);
        }
        v4 -= 16;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10077EEAC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10077EF2C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10077EF68(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10077EFA0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10077EFD0(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void sub_10077F018(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10077F050(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_10077F080(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10077F0C8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10077F100(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_10077F130(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10077F178(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10077F1B0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_10077F1E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10077F228(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10077F260(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_10077F290(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10077F2D8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10077F310(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_10077F340(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10077F388(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10077F3C0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_10077F3F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10077F438()
{
}

void *sub_10077F44C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A05228;
  return result;
}

void sub_10077F484(uint64_t a1, void *a2)
{
  *a2 = off_101A05228;
}

void sub_10077F4AC(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "LASDQuery", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_10077F524(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10077F564()
{
}

uint64_t sub_10077F578(capabilities::ct *a1)
{
  uint64_t v5 = a1;
  if (*((void *)a1 + 4))
  {
    if (dispatch_workloop_is_current()) {
      return sub_10077F6EC(a1);
    }
    BOOL v3 = *((void *)a1 + 4) == 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_100780444;
  void v6[3] = &unk_10199E4C0;
  void v6[4] = (char *)a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = v6;
  uint64_t v4 = *((void *)a1 + 3);
  char v13 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  if (v3)
  {
    unint64_t v9 = sub_10005A214;
    uint64_t v10 = &unk_10199E470;
    unint64_t v11 = &v13;
    int v12 = &v7;
    dispatch_sync(v4, block);
  }
  else
  {
    unint64_t v9 = sub_10005AF78;
    uint64_t v10 = &unk_10199E470;
    unint64_t v11 = &v13;
    int v12 = &v7;
    dispatch_async_and_wait(v4, block);
  }
  return v13 != 0;
}

uint64_t sub_10077F6EC(capabilities::ct *a1)
{
  if ((capabilities::ct::supportsWidgetMode(a1) & 1) == 0)
  {
    uint64_t v5 = *((void *)a1 + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Tinker not supported for device...", buf, 2u);
    }
    return 0;
  }
  uint64_t v2 = (uint64_t (***)(void))*((void *)a1 + 8);
  if (!v2)
  {
    uint64_t v6 = *((void *)a1 + 5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Missing Tinker Delegate...", v7, 2u);
    }
    return 0;
  }
  BOOL v3 = **v2;

  return v3();
}

BOOL sub_10077F7E8(uint64_t a1)
{
  uint64_t v5 = a1;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return *(_DWORD *)(a1 + 128) == 1;
    }
    BOOL v3 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_100780450;
  void v6[3] = &unk_10199E4C0;
  void v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = v6;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  char v13 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  if (v3)
  {
    unint64_t v9 = sub_10005A214;
    uint64_t v10 = &unk_10199E470;
    unint64_t v11 = &v13;
    int v12 = &v7;
    dispatch_sync(v4, block);
  }
  else
  {
    unint64_t v9 = sub_10005AF78;
    uint64_t v10 = &unk_10199E470;
    unint64_t v11 = &v13;
    int v12 = &v7;
    dispatch_async_and_wait(v4, block);
  }
  return v13 != 0;
}

uint64_t sub_10077F960(capabilities::ct *a1)
{
  uint64_t v2 = (capabilities::ct *)sub_10077F6EC(a1);
  int v3 = (int)v2;
  if (capabilities::ct::supportsWidgetMode(v2))
  {
    uint64_t v4 = *((void *)a1 + 8);
    if (v4)
    {
      int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 8))(v4);
      uint64_t v6 = (void *)((char *)a1 + 96);
      uint64_t v15 = 1;
      std::string v16 = (void *)((char *)a1 + 96);
      if (v5) {
        int v7 = 1;
      }
      else {
        int v7 = 2;
      }
      goto LABEL_11;
    }
    unint64_t v9 = *((void *)a1 + 5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Missing Tinker Delegate...", buf, 2u);
    }
  }
  else
  {
    int v8 = *((void *)a1 + 5);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Tinker not supported for device...", buf, 2u);
    }
  }
  uint64_t v6 = (void *)((char *)a1 + 96);
  uint64_t v15 = 1;
  std::string v16 = (void *)((char *)a1 + 96);
  int v7 = 2;
LABEL_11:
  if (v3) {
    int v10 = 1;
  }
  else {
    int v10 = 2;
  }
  unint64_t v11 = *((void *)a1 + 5);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = rest::asString();
    uint64_t v13 = rest::asString();
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v18 = v12;
    __int16 v19 = 2080;
    uint64_t v20 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Tinker supported: %s Tinker mode: %s", buf, 0x16u);
    uint64_t v6 = v16;
  }
  *((_DWORD *)v6 + 8) = v7;
  *((_DWORD *)v6 + 9) = v10;
  return sub_100780468((uint64_t)&v15);
}

void sub_10077FB24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10077FB38(void *a1, void *a2, dispatch_object_t *a3, void *a4)
{
  *a1 = off_101A05318;
  int v8 = a1 + 1;
  unint64_t v9 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v21, kCtLoggingSystemName, "tkr");
  if (v9) {
    dispatch_retain(v9);
  }
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  unint64_t v11 = dispatch_queue_create_with_target_V2("TinkerController", initially_inactive, v9);
  dispatch_set_qos_class_floor(v11, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v11);
  *int v8 = 0;
  v8[1] = 0;
  a1[3] = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  a1[4] = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  if (v11) {
    dispatch_release(v11);
  }
  if (v9) {
    dispatch_release(v9);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v22, &v21);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v22);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v22);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (v9) {
    dispatch_release(v9);
  }
  *a1 = off_101A05318;
  sub_100058DB0(&__p, "TinkerController");
  uint64_t v12 = a1[3];
  uint64_t v18 = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  xpc_object_t object = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v18) {
    dispatch_release(v18);
  }
  if (v20 < 0) {
    operator delete(__p);
  }
  a1[8] = *a4;
  uint64_t v13 = a4[1];
  a1[9] = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  a1[10] = *a2;
  uint64_t v14 = a2[1];
  a1[11] = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = rest::kDefaultWidgetStatus;
  a1[15] = 0;
  a1[16] = v15;
  return a1;
}

void sub_10077FD50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  WidgetControllerInterface::~WidgetControllerInterface(v19);
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

void sub_10077FDE0()
{
  v1[0] = off_101A053F0;
  v1[3] = v1;
  inactive = dispatch_workloop_create_inactive("TinkerController");
  sub_100136200((uint64_t)v1, (uint64_t)inactive);
  dispatch_activate(inactive);
  sub_1001362D0(v1);
  operator new();
}

void sub_10077FF2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (v12) {
    dispatch_release(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10077FFA4(uint64_t a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1007800A4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100780184(uint64_t a1, int a2, ServiceStage *this)
{
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void *sub_100780298(void *a1)
{
  *a1 = off_101A05318;
  sub_1007803C0(a1 + 12);
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  WidgetControllerInterface::~WidgetControllerInterface((WidgetControllerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_10078031C(void *a1)
{
  *a1 = off_101A05318;
  sub_1007803C0(a1 + 12);
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  WidgetControllerInterface::~WidgetControllerInterface((WidgetControllerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  operator delete();
}

void *sub_1007803C0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100780444(uint64_t a1)
{
  return sub_10077F6EC(**(capabilities::ct ***)(a1 + 40));
}

BOOL sub_100780450(uint64_t a1)
{
  return *(_DWORD *)(**(void **)(a1 + 40) + 128) == 1;
}

uint64_t sub_100780468(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_1007804D0()
{
}

void *sub_1007804E4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A053F0;
  return result;
}

void sub_10078051C(uint64_t a1, void *a2)
{
  *a2 = off_101A053F0;
}

void sub_100780544(uint64_t a1, dispatch_workloop_t *a2)
{
}

uint64_t sub_100780550(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100780590()
{
}

void sub_10078059C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100780668(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100780740);
  __cxa_rethrow();
}

void sub_100780690(_Unwind_Exception *a1)
{
}

void sub_1007806A8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007806E0(uint64_t a1)
{
}

uint64_t sub_1007806FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100780740(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_10078076C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void **)v1;
  Registry::createRestModuleOneTimeUseConnection(&v10, *(Registry **)(*(void *)v1 + 80));
  ctu::RestModule::connect();
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v3 = v2 + 12;
  v12[0] = off_101A054D0;
  v12[1] = v2 + 6;
  uint64_t v13 = v12;
  if (v12 != v2 + 12)
  {
    uint64_t v4 = (void *)v2[15];
    if (v4 == v3)
    {
      __p[1] = v2 + 6;
      uint64_t v15 = 0;
      uint64_t v13 = 0;
      __p[0] = off_101A054D0;
      (*(void (**)(void *, void *))(*v3 + 24))(v2 + 12, v12);
      (*(void (**)(void))(*(void *)v2[15] + 32))(v2[15]);
      v2[15] = 0;
      uint64_t v13 = v12;
      (*((void (**)(void **, void *))__p[0] + 3))(__p, v2 + 12);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      v2[12] = off_101A054D0;
      v2[13] = v2 + 6;
      uint64_t v13 = v4;
    }
    v2[15] = v3;
  }
  sub_1007803C0(v12);
  uint64_t v5 = v2[15];
  if (v5) {
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 48))(v5, v2 + 16);
  }
  sub_100058DB0(__p, "/cc/events/new_nanoregistry_device_configured");
  uint64_t v6 = operator new(0x20uLL);
  void *v6 = off_101A05560;
  v6[1] = v2;
  _DWORD v6[2] = sub_10077F95C;
  void v6[3] = 0;
  uint64_t v13 = v6;
  ctu::RestModule::observeEvent();
  sub_10003F600(v12);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  sub_100088C88(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_1007809FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100780A68()
{
}

void *sub_100780A7C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A054D0;
  result[1] = v3;
  return result;
}

uint64_t sub_100780AC4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A054D0;
  a2[1] = v2;
  return result;
}

void sub_100780AF0()
{
  xpc_object_t v3 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/cc/props/widget_state");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100780B94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100780BD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100780C18()
{
}

void sub_100780C28()
{
}

__n128 sub_100780C3C(uint64_t a1)
{
  char v2 = (char *)operator new(0x20uLL);
  *(void *)char v2 = off_101A05560;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100780C90(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A05560;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100780CC8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  xpc_object_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100780D10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100780D50()
{
}

void sub_100780D5C(capabilities::ct ***a1)
{
  uint64_t v1 = a1;
  sub_10077F960(**a1);
  operator delete();
}

void sub_100780DB0()
{
}

uint64_t *sub_100780DDC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 48));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100780E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100781348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100781420(uint64_t a1, void *a2, uint64_t a3, unsigned int a4)
{
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v26 = 0;
  id v6 = a2;
  sub_100058DB0(v25, (char *)[v6 UTF8String]);
  subscriber::makeSimSlotRange();
  int v8 = v22;
  int v7 = v23;
  if (v22 == v23) {
    goto LABEL_31;
  }
  uint64_t v9 = v24;
  while ((v24(*v8) & 1) == 0)
  {
    if (++v8 == v23)
    {
      int v8 = v23;
      break;
    }
  }
  uint64_t v10 = v23;
  if (v8 == v23)
  {
LABEL_31:
    uint64_t IsListedAsEmergency = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v11 = *v8;
      uint64_t v21 = 0;
      long long v19 = 0u;
      long long v20 = 0u;
      *(_OWORD *)long long v17 = 0u;
      *(_OWORD *)std::string __p = 0u;
      long long v16 = 0u;
      memset(&v15, 0, sizeof(v15));
      sub_100147360(a1, v11, a4, 0, (uint64_t)&v15);
      if (CSIPhoneNumber::getTypeOfNumber(&v15) == 2)
      {
        uint64_t IsListedAsEmergency = 1;
      }
      else
      {
        uint64_t IsListedAsEmergency = (sub_10121F67C() || sub_10121F6B4())
                           && CSIPhoneNumber::getTypeOfNumber(&v15) == 3;
        if (((IsListedAsEmergency | a4 ^ 1) & 1) == 0) {
          uint64_t IsListedAsEmergency = CSIPhoneNumber::getIsListedAsEmergency(&v15);
        }
      }
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(v17[0]);
      }
      if (SBYTE7(v16) < 0) {
        operator delete(*(void **)&v15.var2.__r_.var0);
      }
      if (*((char *)&v15.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(v15.var2.__r_.__value_.var0.var1.__data_);
      }
      if (IsListedAsEmergency) {
        break;
      }
      uint64_t v13 = v8 + 1;
      int v8 = v7;
      if (v13 != v7)
      {
        int v8 = v13;
        while ((v9(*v8) & 1) == 0)
        {
          if (++v8 == v7)
          {
            int v8 = v7;
            break;
          }
        }
      }
      if (v8 == v10) {
        goto LABEL_33;
      }
    }
    uint64_t IsListedAsEmergency = 1;
  }
LABEL_33:
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[0]);
  }

  return IsListedAsEmergency;
}

void sub_10078160C(_Unwind_Exception *a1)
{
  if (*(char *)(v2 - 81) < 0) {
    operator delete(*(void **)(v2 - 104));
  }

  _Unwind_Resume(a1);
}

void sub_100781B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }

  _Unwind_Resume(a1);
}

void sub_100781FE0(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100782404(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1007827B8(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100782CD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v24);
  }

  _Unwind_Resume(a1);
}

void sub_10078325C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v5);
  }

  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100783334(uint64_t a1)
{
  return a1;
}

void sub_100783360(uint64_t a1)
{
  operator delete();
}

void *sub_1007833AC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A055E0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100783404(uint64_t a1, void *a2)
{
  *a2 = off_101A055E0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10078344C(uint64_t a1)
{
}

void sub_100783454(id *a1)
{
  operator delete(a1);
}

void sub_100783490(uint64_t a1, uint64_t **a2)
{
  char v4 = objc_opt_new();
  char v5 = &kPhoneServicesActiveKey;
  objc_msgSend(v4, "setIsWifiCallingAvailable:", *((_DWORD *)sub_1003B2574(a2, &kPhoneServicesActiveKey, (uint64_t)&unk_10144E20E, &v5) + 10) != 0);
  char v5 = &kPhoneServicesVoLTECallingAvailableKey;
  objc_msgSend(v4, "setIsVoLTECallingAvailable:", *((_DWORD *)sub_1003B2574(a2, &kPhoneServicesVoLTECallingAvailableKey, (uint64_t)&unk_10144E20E, &v5) + 10) != 0);
  char v5 = &kPhoneServicesCSCallingAvailableKey;
  objc_msgSend(v4, "setIsCSCallingAvailable:", *((_DWORD *)sub_1003B2574(a2, &kPhoneServicesCSCallingAvailableKey, (uint64_t)&unk_10144E20E, &v5) + 10) != 0);
  char v5 = &kIsEmergencyWiFiAllowed;
  objc_msgSend(v4, "setIsEmergencyCallingOnWifiAllowed:", *((_DWORD *)sub_1003B2574(a2, &kIsEmergencyWiFiAllowed, (uint64_t)&unk_10144E20E, &v5) + 10) != 0);
  char v5 = &kIsEmergencyWiFiCallCapable;
  objc_msgSend(v4, "setIsEmergencyCallingOnWifiAvailable:", *((_DWORD *)sub_1003B2574(a2, &kIsEmergencyWiFiCallCapable, (uint64_t)&unk_10144E20E, &v5) + 10) != 0);
  char v5 = &kIsEmergencyWiFiNoLimit;
  objc_msgSend(v4, "setIsCarrierSupportsEmergencyCallOnWifiNoLimit:", *((_DWORD *)sub_1003B2574(a2, &kIsEmergencyWiFiNoLimit, (uint64_t)&unk_10144E20E, &v5) + 10) != 0);
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100783640(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100783650(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A05650)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100783690()
{
  return &off_101A05650;
}

void *sub_10078369C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100783720@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  ProvisioningProfileSupuint16_t port = (capabilities::ct *)capabilities::ct::getProvisioningProfileSupport(a1);
  if (ProvisioningProfileSupport == 1
    || (uint64_t result = capabilities::ct::supportsVoiceCall(ProvisioningProfileSupport), (result & 1) == 0))
  {
    operator new();
  }
  return result;
}

void sub_100783A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100783B80(uint64_t a1)
{
  *(void *)a1 = off_101A05670;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 384);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  char v4 = *(std::__shared_weak_count **)(a1 + 352);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100785298((void *)(a1 + 304));
  if (*(unsigned char *)(a1 + 288)) {
    sub_1000C584C(a1 + 72);
  }
  char v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100783C44(uint64_t a1)
{
  sub_100783B80(a1);

  operator delete();
}

void sub_100783C7C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  char v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100783D7C(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 64) != a2)
  {
    if (*(unsigned char *)(a1 + 64)
      && (capabilities::ct::supportsVoiceCall((capabilities::ct *)a1) & 1) == 0
      && *(void *)(a1 + 376))
    {
      sub_100058DB0(&__p, "/cc/assertions/airplane_mode");
      ctu::rest::AssertionHandle::create();
      if (v6 < 0) {
        operator delete(__p);
      }
      uint64_t v3 = *(std::__shared_weak_count **)(a1 + 384);
      *(_OWORD *)(a1 + 376) = v4;
      if (v3) {
        sub_10004D2C8(v3);
      }
    }
    else
    {
      sub_100783E68(a1);
    }
  }
}

void sub_100783E4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100783E68(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64)
    || (uint64_t v2 = (capabilities::ct *)capabilities::ct::supportsCampOnlyMode((capabilities::ct *)a1),
        (v2 & 1) != 0)
    || (capabilities::ct::supportsCMASCampOnlyMode(v2) & 1) != 0)
  {
    int v3 = *(_DWORD *)(a1 + 68);
    if (v3 == 1) {
      goto LABEL_9;
    }
    if (v3 == 2)
    {
      int v4 = 1;
      goto LABEL_12;
    }
    if (*(unsigned char *)(a1 + 288) && *(unsigned char *)(a1 + 161)) {
LABEL_9:
    }
      int v4 = 2;
    else {
      int v4 = 2 * (*(unsigned char *)(a1 + 296) == 0);
    }
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 68) != 0;
  }
LABEL_12:
  uint64_t v5 = *(int *)(a1 + 336);
  if (v4 == v5) {
    return;
  }
  char v6 = *(NSObject **)(a1 + 40);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v5 > 2) {
      int v8 = "DataPlan IndicatorType Undefined";
    }
    else {
      int v8 = off_101A05B88[v5];
    }
    uint64_t v9 = off_101A05B88[v4];
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Updating indicator from %s to %s", buf, 0x16u);
  }
  uint64_t v10 = (_DWORD *)(a1 + 336);
  if (v4 == 2)
  {
    if (*v10
      || (uint64_t v16 = capabilities::ct::supportsCampOnlyMode((capabilities::ct *)v7), (v16 & 1) == 0)
      && (uint64_t v16 = capabilities::ct::supportsCMASCampOnlyMode((capabilities::ct *)v16), !v16)
      || (capabilities::ct::supportsVoiceCall((capabilities::ct *)v16) & 1) == 0 && *(unsigned char *)(a1 + 64))
    {
      if (*(void *)(a1 + 368))
      {
        uint64_t v11 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Timer already active - skipping", buf, 2u);
        }
      }
      else
      {
        Registry::getTimerService(&v38, *(Registry **)(a1 + 344));
        uint64_t v23 = v38;
        sub_100058DB0(v36, "Signalling Reduction Timer");
        CFTypeRef v24 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v24
          || (v25 = *(void *)(a1 + 360), uint64_t v26 = *(void *)(a1 + 8), (v27 = std::__shared_weak_count::lock(v24)) == 0))
        {
          sub_100088B9C();
        }
        CFTypeRef v28 = v27;
        atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v27);
        *(_OWORD *)std::string __p = *(_OWORD *)v36;
        uint64_t v42 = v37;
        v36[0] = 0;
        v36[1] = 0;
        uint64_t v37 = 0;
        uint64_t v44 = 0;
        CFNumberRef v29 = operator new(0x20uLL);
        void *v29 = off_101A05B18;
        v29[1] = a1;
        v29[2] = v26;
        void v29[3] = v28;
        uint64_t v44 = v29;
        (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, unsigned char *))(*(void *)v23 + 40))(&v40, v23, __p, 2, 60000000 * v25, 0, buf);
        sub_10003B34C(buf);
        if (SHIBYTE(v42) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v30 = v40;
        uint64_t v40 = 0;
        uint64_t v31 = *(void *)(a1 + 368);
        *(void *)(a1 + 368) = v30;
        if (v31)
        {
          (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
          uint64_t v32 = v40;
          uint64_t v40 = 0;
          if (v32) {
            (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
          }
        }
        if (SHIBYTE(v37) < 0) {
          operator delete(v36[0]);
        }
        if (v39) {
          sub_10004D2C8(v39);
        }
        CFTypeRef v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = *(void *)(a1 + 360);
          *(_DWORD *)std::string buf = 134217984;
          *(void *)&uint8_t buf[4] = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Starting delaying signaling reduction timer: %lu minutes", buf, 0xCu);
        }
      }
      goto LABEL_61;
    }
    long long v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Entering signaling reduction immediately", buf, 2u);
    }
    sub_100785038((capabilities::ct *)buf, a1);
    long long v18 = *(_OWORD *)buf;
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    long long v19 = *(std::__shared_weak_count **)(a1 + 384);
    *(_OWORD *)(a1 + 376) = v18;
    if (v19)
    {
      sub_10004D2C8(v19);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
    uint64_t v20 = *(void *)(a1 + 368);
    *(void *)(a1 + 368) = 0;
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
    }
    goto LABEL_31;
  }
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Exiting signaling reduction", buf, 2u);
  }
  uint64_t v13 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 384);
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  if (v14) {
    sub_10004D2C8(v14);
  }
  int v15 = *(_DWORD *)(a1 + 68);
  if (v15 == 2)
  {
    if (!*(unsigned char *)(a1 + 400))
    {
      uint64_t v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Start tracking assertions", buf, 2u);
      }
      *(void *)(a1 + 392) = sub_100784464(*(Registry **)(a1 + 344));
      *(unsigned char *)(a1 + 400) = v22;
    }
    goto LABEL_61;
  }
  if (!v15) {
LABEL_31:
  }
    sub_100784510(a1);
LABEL_61:
  if (*v10 != v4)
  {
    *(_DWORD *)(a1 + 336) = v4;
    uint64_t v35 = *(void *)(a1 + 328);
    if (v35) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v35 + 48))(v35, a1 + 336);
    }
  }
}

void sub_1007843E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(a1);
}

void sub_100784450(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 68) != a2) {
    sub_100783E68(a1);
  }
}

unint64_t sub_100784464(Registry *a1)
{
  uint64_t v5 = 0;
  char v6 = 0;
  Registry::getTimerService((uint64_t *)&v5, a1);
  if (v5)
  {
    uint64_t v1 = (**v5)(v5);
    unint64_t v2 = v1 & 0xFFFFFFFFFFFFFF00;
    uint64_t v3 = v1;
  }
  else
  {
    uint64_t v3 = 0;
    unint64_t v2 = 0;
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  return v2 | v3;
}

void sub_1007844F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100784510(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 400))
  {
    unint64_t v2 = sub_100784464(*(Registry **)(a1 + 344));
    if (v3)
    {
      unint64_t v4 = v2;
      uint64_t v5 = *(void *)(a1 + 392);
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 344));
      BOOL v7 = ServiceMap;
      if (v8 < 0)
      {
        uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v10 = 5381;
        do
        {
          uint64_t v8 = v10;
          unsigned int v11 = *v9++;
          uint64_t v10 = (33 * v10) ^ v11;
        }
        while (v11);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v8;
      uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
      uint64_t v13 = v4 - v5;
      uint64_t v14 = (unsigned __int128)((uint64_t)(v4 - v5) * (__int128)0x431BDE82D7B634DBLL) >> 64;
      if (v12)
      {
        uint64_t v16 = v12[3];
        int v15 = (std::__shared_weak_count *)v12[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v7);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v7);
      int v15 = 0;
      char v17 = 1;
LABEL_11:
      int64_t v18 = (v14 >> 18) + ((unint64_t)v14 >> 63);
      if (v16)
      {
        if (*(unsigned char *)(a1 + 288))
        {
          v57[0] = 0;
          xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v20 = v19;
          if (v19)
          {
            v57[0] = v19;
          }
          else
          {
            xpc_object_t v20 = xpc_null_create();
            v57[0] = v20;
            if (!v20)
            {
              xpc_object_t v23 = xpc_null_create();
              xpc_object_t v20 = 0;
              goto LABEL_25;
            }
          }
          if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v20);
LABEL_26:
            xpc_release(v20);
            memset(buf, 0, sizeof(buf));
            if (!*(unsigned char *)(a1 + 288)) {
              sub_10016C840();
            }
            if (*(char *)(a1 + 191) >= 0) {
              size_t v24 = *(unsigned __int8 *)(a1 + 191);
            }
            else {
              size_t v24 = *(void *)(a1 + 176);
            }
            memset(&__dst, 0, sizeof(__dst));
            p_dst = &__dst;
            sub_1000C140C((uint64_t)&__dst, v24 + 1);
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
            }
            if (v24)
            {
              if (*(char *)(a1 + 191) >= 0) {
                uint64_t v26 = (const void *)(a1 + 168);
              }
              else {
                uint64_t v26 = *(const void **)(a1 + 168);
              }
              memmove(p_dst, v26, v24);
            }
            *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v24) = 47;
            if (!*(unsigned char *)(a1 + 288)) {
              sub_10016C840();
            }
            int v27 = *(char *)(a1 + 215);
            if (v27 >= 0) {
              CFTypeRef v28 = (const std::string::value_type *)(a1 + 192);
            }
            else {
              CFTypeRef v28 = *(const std::string::value_type **)(a1 + 192);
            }
            if (v27 >= 0) {
              std::string::size_type v29 = *(unsigned __int8 *)(a1 + 215);
            }
            else {
              std::string::size_type v29 = *(void *)(a1 + 200);
            }
            uint64_t v30 = std::string::append(&__dst, v28, v29);
            long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
            *(void *)&uint8_t buf[16] = *((void *)&v30->__r_.__value_.__l + 2);
            *(_OWORD *)std::string buf = v31;
            v30->__r_.__value_.__l.__size_ = 0;
            v30->__r_.__value_.__r.__words[2] = 0;
            v30->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            if ((buf[23] & 0x80u) == 0) {
              uint64_t v32 = buf;
            }
            else {
              uint64_t v32 = *(uint8_t **)buf;
            }
            xpc_object_t v55 = xpc_string_create((const char *)v32);
            if (!v55) {
              xpc_object_t v55 = xpc_null_create();
            }
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v57;
            __dst.__r_.__value_.__l.__size_ = (std::string::size_type)"carrierIdentifier";
            sub_100035E70((uint64_t)&__dst, &v55, &object);
            xpc_release(object);
            xpc_object_t object = 0;
            xpc_release(v55);
            xpc_object_t v55 = 0;
            xpc_object_t v53 = xpc_uint64_create(v18);
            if (!v53) {
              xpc_object_t v53 = xpc_null_create();
            }
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v57;
            __dst.__r_.__value_.__l.__size_ = (std::string::size_type)"onlineDuration";
            sub_100035E70((uint64_t)&__dst, &v53, &v54);
            xpc_release(v54);
            xpc_object_t v54 = 0;
            xpc_release(v53);
            xpc_object_t v53 = 0;
            __dst.__r_.__value_.__l.__data_ = (std::string::pointer)v57[0];
            if (v57[0]) {
              xpc_retain(v57[0]);
            }
            else {
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
            }
            (*(void (**)(uint64_t, const char *, std::string *))(*(void *)v16 + 16))(v16, "commCenterBootstrapUsageSummary", &__dst);
            xpc_release(__dst.__r_.__value_.__l.__data_);
            __dst.__r_.__value_.__r.__words[0] = 0;
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            xpc_release(v57[0]);
LABEL_59:
            if ((v17 & 1) == 0) {
              sub_10004D2C8(v15);
            }
            if (60000 * *(void *)(a1 + 360) + 900000 >= v18) {
              goto LABEL_95;
            }
            CFTypeRef v33 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)std::string buf = 134217984;
              *(void *)&uint8_t buf[4] = v13 / 1000000000;
              _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Excess assertion time -- %llu seconds", buf, 0xCu);
            }
            *(_OWORD *)&uint8_t buf[8] = 0u;
            uint64_t v60 = 0x400000000000000;
            long long v59 = 0u;
            *(_OWORD *)&v61[8] = 0u;
            BYTE5(v62[2]) = 0;
            HIWORD(v62[2]) = 5376;
            long long v64 = 0u;
            long long v63 = 0u;
            buf[23] = 8;
            *(void *)std::string buf = 0x72616C756C6C6543;
            LODWORD(v59) = 1296651109;
            v61[23] = 18;
            qmemcpy(v61, "SignalingReduction", 18);
            strcpy((char *)v62, "excessive online tim");
            void v62[3] = (void *)23;
            uint64_t v34 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 344));
            uint64_t v35 = v34;
            if ((v36 & 0x8000000000000000) != 0)
            {
              uint64_t v37 = (unsigned __int8 *)(v36 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v38 = 5381;
              do
              {
                std::string::size_type v36 = v38;
                unsigned int v39 = *v37++;
                uint64_t v38 = (33 * v38) ^ v39;
              }
              while (v39);
            }
            std::mutex::lock(v34);
            __dst.__r_.__value_.__r.__words[0] = v36;
            uint64_t v40 = sub_10004D37C(&v35[1].__m_.__sig, (unint64_t *)&__dst);
            if (v40)
            {
              uint64_t v42 = v40[3];
              uint64_t v41 = (std::__shared_weak_count *)v40[4];
              if (v41)
              {
                atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v35);
                atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v41);
                char v43 = 0;
                if (!v42) {
                  goto LABEL_83;
                }
                goto LABEL_73;
              }
            }
            else
            {
              uint64_t v42 = 0;
            }
            std::mutex::unlock(v35);
            uint64_t v41 = 0;
            char v43 = 1;
            if (!v42)
            {
LABEL_83:
              if ((v43 & 1) == 0) {
                sub_10004D2C8(v41);
              }
              if (SBYTE7(v64) < 0) {
                operator delete((void *)v63);
              }
              if (SHIBYTE(v62[2]) < 0) {
                operator delete(v62[0]);
              }
              if ((v61[23] & 0x80000000) != 0) {
                operator delete(*(void **)v61);
              }
              if (SHIBYTE(v60) < 0) {
                operator delete((void *)v59);
              }
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
LABEL_95:
              if (*(unsigned char *)(a1 + 400)) {
                *(unsigned char *)(a1 + 400) = 0;
              }
              return;
            }
LABEL_73:
            sub_1000DB86C((char *)&__dst, (long long *)buf);
            v57[3] = 0;
            (*(void (**)(uint64_t, std::string *, xpc_object_t *))(*(void *)v42 + 16))(v42, &__dst, v57);
            sub_1000DBADC(v57);
            if (v52 < 0) {
              operator delete(__p);
            }
            if (v50 < 0) {
              operator delete(v49);
            }
            if (v48 < 0) {
              operator delete(v47);
            }
            if (v46 < 0) {
              operator delete(v45);
            }
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            goto LABEL_83;
          }
          xpc_object_t v23 = xpc_null_create();
LABEL_25:
          v57[0] = v23;
          goto LABEL_26;
        }
        uint64_t v21 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          goto LABEL_59;
        }
        *(_WORD *)std::string buf = 0;
        char v22 = "Failed to send bootstrap online time metric : (no profile details)";
      }
      else
      {
        uint64_t v21 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          goto LABEL_59;
        }
        *(_WORD *)std::string buf = 0;
        char v22 = "Failed to send bootstrap online time metric : (no analytics interface)";
      }
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v22, buf, 2u);
      goto LABEL_59;
    }
  }
}

void sub_100784C20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,xpc_object_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100784D10(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 296) != a2) {
    sub_100783E68(a1);
  }
}

void sub_100784D24(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = a1 + 72;
  int v5 = *(unsigned __int8 *)(a1 + 288);
  if (a2[216]) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if ((a2[216] != 0) == (v5 != 0)) {
      return;
    }
    if (!a2[216])
    {
LABEL_13:
      uint64_t v8 = (uint64_t *)(a1 + 360);
      *(void *)(a1 + 360) = 2;
LABEL_14:
      uint64_t v9 = (os_log_t *)(a1 + 40);
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Received bootstrap profile update", (uint8_t *)__p, 2u);
      }
      if (*(unsigned char *)(a1 + 288))
      {
        *(_OWORD *)std::string __p = 0u;
        long long v19 = 0u;
        sub_10098CFF0((uint64_t)__p, (Registry **)(a1 + 344), (os_log_t *)(a1 + 40), v4);
        if (HIDWORD(v19))
        {
          if (HIDWORD(v19) <= 2) {
            uint64_t v11 = 2;
          }
          else {
            uint64_t v11 = HIDWORD(v19);
          }
          *uint64_t v8 = v11;
          uint64_t v12 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 134217984;
            *(void *)((char *)&buf + 4) = v11;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Updated delay time %lu minutes", (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          char v17 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "No signaling reduction delay time settings", (uint8_t *)&buf, 2u);
          }
        }
        if (SBYTE7(v19) < 0) {
          operator delete(__p[0]);
        }
        return;
      }
      uint64_t v13 = *v9;
      if (!os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR)) {
        return;
      }
      LOWORD(__p[0]) = 0;
      uint64_t v14 = "No Bootstrap profile details";
LABEL_28:
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v14, (uint8_t *)__p, 2u);
      return;
    }
  }
  else
  {
    char v7 = VinylProfileDetails::operator==();
    if (v7) {
      return;
    }
    if (!a2[216]) {
      goto LABEL_13;
    }
  }
  if (!*(unsigned char *)(a1 + 288))
  {
    *(void *)(a1 + 360) = 2;
    goto LABEL_24;
  }
  if (a2[89] == *(unsigned __int8 *)(a1 + 161))
  {
    __p[0] = a2 + 96;
    __p[1] = a2 + 120;
    *(void *)&long long v19 = a2 + 144;
    *((void *)&v19 + 1) = a2 + 168;
    xpc_object_t v20 = a2 + 16;
  }
  else
  {
    sub_100783E68(a1);
    int v15 = *(unsigned __int8 *)(a1 + 288);
    __p[0] = a2 + 96;
    __p[1] = a2 + 120;
    *(void *)&long long v19 = a2 + 144;
    *((void *)&v19 + 1) = a2 + 168;
    xpc_object_t v20 = a2 + 16;
    if (!v15) {
      sub_10016C840();
    }
  }
  *(void *)&long long buf = a1 + 168;
  *((void *)&buf + 1) = a1 + 192;
  uint64_t v23 = a1 + 216;
  uint64_t v24 = a1 + 240;
  uint64_t v25 = a1 + 88;
  if ((sub_10078531C((uint64_t)&v21, (uint64_t)__p, (uint64_t)&buf) & 1) == 0)
  {
    int v16 = a2[216];
    uint64_t v8 = (uint64_t *)(a1 + 360);
    *(void *)(a1 + 360) = 2;
    if (!v16 || *(unsigned char *)(a1 + 288)) {
      goto LABEL_14;
    }
LABEL_24:
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(__p[0]) = 0;
    uint64_t v14 = "Bootstrap no longer valid";
    goto LABEL_28;
  }
}

void sub_100785038(capabilities::ct *a1, uint64_t a2)
{
  uint64_t v3 = capabilities::ct::supportsCampOnlyMode(a1);
  if (v3 & 1) != 0 || (uint64_t v3 = capabilities::ct::supportsCMASCampOnlyMode((capabilities::ct *)v3), (v3))
  {
    if (capabilities::ct::supportsVoiceCall((capabilities::ct *)v3))
    {
      sub_100058DB0(__p, "/cc/assertions/baseband_camp_only_assertion");
      ctu::rest::AssertionHandle::create();
    }
    else
    {
      if (*(unsigned char *)(a2 + 64)) {
        sub_100058DB0(__p, "/cc/assertions/airplane_mode");
      }
      else {
        sub_100058DB0(__p, "/cc/assertions/baseband_camp_only_assertion");
      }
      ctu::rest::AssertionHandle::create();
    }
  }
  else
  {
    sub_100058DB0(__p, "/cc/assertions/airplane_mode");
    ctu::rest::AssertionHandle::create();
  }
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10078513C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100785164(uint64_t a1)
{
  unint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 336);
    if (v3 > 2) {
      uint64_t v4 = "DataPlan IndicatorType Undefined";
    }
    else {
      uint64_t v4 = off_101A05B88[v3];
    }
    uint64_t v5 = *(void *)(a1 + 360);
    int v7 = 136315394;
    uint64_t v8 = v4;
    __int16 v9 = 2048;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Indicator: %s - delay time %lu minutes", (uint8_t *)&v7, 0x16u);
    unint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 368)) {
      BOOL v6 = "Yes";
    }
    else {
      BOOL v6 = "No";
    }
    int v7 = 136315138;
    uint64_t v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Timer active: %s", (uint8_t *)&v7, 0xCu);
  }
}

void *sub_100785298(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10078531C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1007853E8((uint64_t)&v20, a2, a3);
  if (result)
  {
    BOOL v6 = *(unsigned __int8 **)(a2 + 32);
    int v7 = *(unsigned __int8 ***)(a3 + 32);
    uint64_t v8 = v6[23];
    if ((v8 & 0x80u) == 0) {
      __int16 v9 = (unsigned __int8 *)v6[23];
    }
    else {
      __int16 v9 = (unsigned __int8 *)*((void *)v6 + 1);
    }
    uint64_t v10 = (unsigned __int8 *)*((unsigned __int8 *)v7 + 23);
    int v11 = (char)v10;
    if ((char)v10 < 0) {
      uint64_t v10 = v7[1];
    }
    if (v9 == v10)
    {
      if (v11 >= 0) {
        uint64_t v12 = *(unsigned __int8 **)(a3 + 32);
      }
      else {
        uint64_t v12 = *v7;
      }
      if ((v8 & 0x80) != 0)
      {
        return memcmp(*(const void **)v6, v12, *((void *)v6 + 1)) == 0;
      }
      else if (v6[23])
      {
        uint64_t v13 = v8 - 1;
        do
        {
          int v15 = *v6++;
          int v14 = v15;
          int v17 = *v12++;
          int v16 = v17;
          BOOL v19 = v13-- != 0;
          uint64_t result = v14 == v16;
        }
        while (v14 == v16 && v19);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1007853E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1007854B4((uint64_t)&v20, a2, a3);
  if (result)
  {
    BOOL v6 = *(unsigned __int8 **)(a2 + 24);
    int v7 = *(unsigned __int8 ***)(a3 + 24);
    uint64_t v8 = v6[23];
    if ((v8 & 0x80u) == 0) {
      __int16 v9 = (unsigned __int8 *)v6[23];
    }
    else {
      __int16 v9 = (unsigned __int8 *)*((void *)v6 + 1);
    }
    uint64_t v10 = (unsigned __int8 *)*((unsigned __int8 *)v7 + 23);
    int v11 = (char)v10;
    if ((char)v10 < 0) {
      uint64_t v10 = v7[1];
    }
    if (v9 == v10)
    {
      if (v11 >= 0) {
        uint64_t v12 = *(unsigned __int8 **)(a3 + 24);
      }
      else {
        uint64_t v12 = *v7;
      }
      if ((v8 & 0x80) != 0)
      {
        return memcmp(*(const void **)v6, v12, *((void *)v6 + 1)) == 0;
      }
      else if (v6[23])
      {
        uint64_t v13 = v8 - 1;
        do
        {
          int v15 = *v6++;
          int v14 = v15;
          int v17 = *v12++;
          int v16 = v17;
          BOOL v19 = v13-- != 0;
          uint64_t result = v14 == v16;
        }
        while (v14 == v16 && v19);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1007854B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_100785580((uint64_t)&v20, a2, a3);
  if (result)
  {
    BOOL v6 = *(unsigned __int8 **)(a2 + 16);
    int v7 = *(unsigned __int8 ***)(a3 + 16);
    uint64_t v8 = v6[23];
    if ((v8 & 0x80u) == 0) {
      __int16 v9 = (unsigned __int8 *)v6[23];
    }
    else {
      __int16 v9 = (unsigned __int8 *)*((void *)v6 + 1);
    }
    uint64_t v10 = (unsigned __int8 *)*((unsigned __int8 *)v7 + 23);
    int v11 = (char)v10;
    if ((char)v10 < 0) {
      uint64_t v10 = v7[1];
    }
    if (v9 == v10)
    {
      if (v11 >= 0) {
        uint64_t v12 = *(unsigned __int8 **)(a3 + 16);
      }
      else {
        uint64_t v12 = *v7;
      }
      if ((v8 & 0x80) != 0)
      {
        return memcmp(*(const void **)v6, v12, *((void *)v6 + 1)) == 0;
      }
      else if (v6[23])
      {
        uint64_t v13 = v8 - 1;
        do
        {
          int v15 = *v6++;
          int v14 = v15;
          int v17 = *v12++;
          int v16 = v17;
          BOOL v19 = v13-- != 0;
          uint64_t result = v14 == v16;
        }
        while (v14 == v16 && v19);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100785580(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_10078564C((uint64_t)&v20, (const void ***)a2, (unsigned __int8 **)a3);
  if (result)
  {
    BOOL v6 = *(unsigned __int8 **)(a2 + 8);
    int v7 = *(unsigned __int8 ***)(a3 + 8);
    uint64_t v8 = v6[23];
    if ((v8 & 0x80u) == 0) {
      __int16 v9 = (unsigned __int8 *)v6[23];
    }
    else {
      __int16 v9 = (unsigned __int8 *)*((void *)v6 + 1);
    }
    uint64_t v10 = (unsigned __int8 *)*((unsigned __int8 *)v7 + 23);
    int v11 = (char)v10;
    if ((char)v10 < 0) {
      uint64_t v10 = v7[1];
    }
    if (v9 == v10)
    {
      if (v11 >= 0) {
        uint64_t v12 = *(unsigned __int8 **)(a3 + 8);
      }
      else {
        uint64_t v12 = *v7;
      }
      if ((v8 & 0x80) != 0)
      {
        return memcmp(*(const void **)v6, v12, *((void *)v6 + 1)) == 0;
      }
      else if (v6[23])
      {
        uint64_t v13 = v8 - 1;
        do
        {
          int v15 = *v6++;
          int v14 = v15;
          int v17 = *v12++;
          int v16 = v17;
          BOOL v19 = v13-- != 0;
          uint64_t result = v14 == v16;
        }
        while (v14 == v16 && v19);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10078564C(uint64_t a1, const void ***a2, unsigned __int8 **a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a3;
  uint64_t v5 = *((unsigned __int8 *)*a2 + 23);
  size_t v6 = (size_t)(*a2)[1];
  if ((v5 & 0x80u) == 0) {
    int v7 = (const void *)*((unsigned __int8 *)*a2 + 23);
  }
  else {
    int v7 = (*a2)[1];
  }
  uint64_t v8 = (const void *)v4[23];
  int v9 = (char)v8;
  if ((char)v8 < 0) {
    uint64_t v8 = (const void *)*((void *)v4 + 1);
  }
  if (v7 != v8) {
    return 0;
  }
  if (v9 >= 0) {
    uint64_t v10 = v4;
  }
  else {
    uint64_t v10 = *(unsigned __int8 **)v4;
  }
  if ((v5 & 0x80) != 0) {
    return memcmp(*v3, v10, v6) == 0;
  }
  if (!v5) {
    return 1;
  }
  uint64_t v11 = v5 - 1;
  do
  {
    int v13 = *(unsigned __int8 *)v3;
    uint64_t v3 = (const void **)((char *)v3 + 1);
    int v12 = v13;
    int v15 = *v10++;
    int v14 = v15;
    BOOL v17 = v11-- != 0;
    uint64_t result = v12 == v14;
  }
  while (v12 == v14 && v17);
  return result;
}

void sub_1007856F8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100785730(uint64_t a1)
{
}

uint64_t sub_10078574C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100785790(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1007857BC(ServiceManager::Service *this)
{
  *(void *)this = off_101A05788;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100785818(ServiceManager::Service *this)
{
  *(void *)this = off_101A05788;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100785888@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SignlingReductionManager");
}

unsigned char *sub_100785898@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *unint64_t v2 = 4;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1007858D8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100783C7C(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100783C7C(v4, 0);
}

uint64_t sub_10078595C()
{
  return 0;
}

uint64_t sub_100785964()
{
  return 1;
}

uint64_t sub_10078596C()
{
  return 0;
}

void sub_10078597C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100785A90(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 48));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100785AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100785AF4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *(void **)v1;
  Registry::createRestModuleOneTimeUseConnection(&v15, *(Registry **)(*(void *)v1 + 344));
  ctu::RestModule::connect();
  if (v16) {
    sub_10004D2C8(v16);
  }
  uint64_t v3 = v2 + 38;
  v17[0] = off_101A05808;
  v17[1] = v2 + 6;
  int64_t v18 = v17;
  if (v17 != v2 + 38)
  {
    uint64_t v4 = (void *)v2[41];
    if (v4 == v3)
    {
      __p[1] = v2 + 6;
      uint64_t v20 = 0;
      int64_t v18 = 0;
      __p[0] = off_101A05808;
      (*(void (**)(void *, void *))(*v3 + 24))(v2 + 38, v17);
      (*(void (**)(void))(*(void *)v2[41] + 32))(v2[41]);
      v2[41] = 0;
      int64_t v18 = v17;
      (*((void (**)(void **, void *))__p[0] + 3))(__p, v2 + 38);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      v2[38] = off_101A05808;
      v2[39] = v2 + 6;
      int64_t v18 = v4;
    }
    v2[41] = v3;
  }
  sub_100785298(v17);
  uint64_t v5 = v2[41];
  if (v5) {
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 48))(v5, v2 + 42);
  }
  sub_100058DB0(__p, "/cc/props/baseband_activated");
  size_t v6 = operator new(0x28uLL);
  void *v6 = off_101A05898;
  v6[1] = v2 + 8;
  _DWORD v6[2] = v2;
  void v6[3] = sub_100783D7C;
  void v6[4] = 0;
  int64_t v18 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(v17);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/vinyl_info");
  int v7 = operator new(0x28uLL);
  void *v7 = off_101A05918;
  v7[1] = v2 + 9;
  uint64_t v7[2] = v2;
  double v7[3] = sub_100784D24;
  void v7[4] = 0;
  int64_t v18 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(v17);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/cellular_plan_bootstrap_status");
  uint64_t v8 = operator new(0x28uLL);
  *uint64_t v8 = off_101A05998;
  v8[1] = (char *)v2 + 68;
  id v8[2] = v2;
  v8[3] = sub_100784450;
  void v8[4] = 0;
  int64_t v18 = v8;
  ctu::RestModule::observeProperty();
  int v9 = (capabilities::ct *)sub_10003F600(v17);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  if ((capabilities::ct::supportsVoiceCall(v9) & 1) == 0)
  {
    sub_100058DB0(__p, "/cc/props/cellular_data_setting");
    uint64_t v10 = operator new(0x28uLL);
    void *v10 = off_101A05A18;
    v10[1] = v2 + 37;
    v10[2] = v2;
    void v10[3] = sub_100784D10;
    void v10[4] = 0;
    int64_t v18 = v10;
    ctu::RestModule::observeProperty();
    sub_10003F600(v17);
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v11 = operator new(0x20uLL);
  void *v11 = off_101A05A98;
  v11[1] = v2;
  v11[2] = sub_100785164;
  id v11[3] = 0;
  int64_t v18 = v11;
  ctu::RestModule::observeEvent();
  sub_10003F600(v17);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  sub_100088C88(&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100785F7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100786008()
{
}

void *sub_10078601C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A05808;
  result[1] = v3;
  return result;
}

uint64_t sub_100786064(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A05808;
  a2[1] = v2;
  return result;
}

void sub_100786090(uint64_t a1, int *a2, const char *a3)
{
  uint64_t v3 = (ctu::rest::detail *)*a2;
  if (v3 > 2) {
    uint64_t v4 = "DataPlan IndicatorType Undefined";
  }
  else {
    uint64_t v4 = off_101A05B88[(void)v3];
  }
  xpc_object_t v8 = 0;
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v3, (uint64_t)v4, a3);
  sub_100058DB0(&__p, "/cc/props/dataplan_suppressing_indicator");
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100786154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100786198(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007861D8()
{
}

void sub_1007861E8()
{
}

__n128 sub_1007861FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A05898;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100786250(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A05898;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100786288(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  size_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    size_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100786324(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100786364()
{
}

void sub_100786374()
{
}

__n128 sub_100786388(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A05918;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007863DC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A05918;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100786414(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  sub_10010C4E0((uint64_t *)&v10, a2);
  long long v14 = 0u;
  memset(v13, 0, sizeof(v13));
  sub_100690AC0(v13, v3);
  long long v8 = v10;
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  long long v10 = 0uLL;
  sub_100786618(v3, (uint64_t *)&v8);
  int v12 = (void **)&v8;
  sub_1000C56F4(&v12);
  int v4 = (BYTE8(v14) != 0) ^ (*(unsigned char *)(v3 + 216) != 0);
  if (BYTE8(v14) && *(unsigned char *)(v3 + 216)) {
    int v4 = VinylProfileDetails::operator!=();
  }
  if (v4)
  {
    int v5 = (void (*)(void *, _OWORD *))a1[3];
    uint64_t v6 = a1[4];
    uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
    if (v6) {
      int v5 = *(void (**)(void *, _OWORD *))(*v7 + v5);
    }
    v5(v7, v13);
  }
  if (BYTE8(v14)) {
    sub_1000C584C((uint64_t)v13);
  }
  *(void *)&v13[0] = &v10;
  sub_1000C56F4((void ***)v13);
}

void sub_100786584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  if (a44) {
    sub_1000C584C((uint64_t)&a17);
  }
  a17 = (void **)&a13;
  sub_1000C56F4(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_1007865CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10078660C()
{
}

uint64_t sub_100786618(uint64_t result, uint64_t *a2)
{
  if (*(unsigned char *)(result + 216))
  {
    __n128 result = sub_1000C584C(result);
    *(unsigned char *)(result + 216) = 0;
  }
  for (uint64_t i = *a2; i != a2[1]; i += 88)
  {
    if (*(unsigned char *)(i + 80))
    {
      for (uint64_t j = *(void *)(i + 64); j != *(void *)(i + 56); j -= 216)
      {
        uint64_t v5 = j - 216;
        if (*(unsigned __int8 *)(j - 128))
        {
          return sub_1007866A0(result, v5);
        }
      }
    }
  }
  return result;
}

uint64_t sub_1007866A0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 216))
  {
    *(_OWORD *)a1 = *(_OWORD *)a2;
    std::string::operator=((std::string *)(a1 + 16), (const std::string *)(a2 + 16));
    std::string::operator=((std::string *)(a1 + 40), (const std::string *)(a2 + 40));
    std::string::operator=((std::string *)(a1 + 64), (const std::string *)(a2 + 64));
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
    std::string::operator=((std::string *)(a1 + 96), (const std::string *)(a2 + 96));
    std::string::operator=((std::string *)(a1 + 120), (const std::string *)(a2 + 120));
    std::string::operator=((std::string *)(a1 + 144), (const std::string *)(a2 + 144));
    std::string::operator=((std::string *)(a1 + 168), (const std::string *)(a2 + 168));
    std::string::operator=((std::string *)(a1 + 192), (const std::string *)(a2 + 192));
  }
  else
  {
    sub_1000C5AB4(a1, a2);
    *(unsigned char *)(a1 + 216) = 1;
  }
  return a1;
}

void sub_10078675C()
{
}

__n128 sub_100786770(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A05998;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007867C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A05998;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007867FC(void *a1, xpc_object_t *a2)
{
  int v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  long long v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    long long v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_1007868F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100786934()
{
}

void sub_100786944()
{
}

__n128 sub_100786958(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A05A18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007869AC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A05A18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007869E4(void *a1, xpc *this, BOOL a3)
{
  int v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100786A80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100786AC0()
{
}

void sub_100786AD0()
{
}

__n128 sub_100786AE4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A05A98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100786B38(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A05A98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100786B70(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100786BB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100786BF8()
{
}

void *sub_100786C04(void *a1)
{
  *a1 = off_101A05B18;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100786C50(void *a1)
{
  *a1 = off_101A05B18;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100786CBC(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A05B18;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100786D20(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A05B18;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100786D60(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100786D70(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100786DB0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        int v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100786EC0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100786F00()
{
}

void sub_100786F0C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Entering signaling reduction now", buf, 2u);
  }
  sub_100785038((capabilities::ct *)buf, v1);
  long long v3 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  int v4 = *(std::__shared_weak_count **)(v1 + 384);
  *(_OWORD *)(v1 + 376) = v3;
  if (v4)
  {
    sub_10004D2C8(v4);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  sub_100784510(v1);
  operator delete();
}

void sub_100786FDC()
{
}

uint64_t sub_100787008()
{
  sub_100058DB0(qword_101B0D708, "sq-device-proxy-stage.apple.com");
  __cxa_atexit((void (*)(void *))&std::string::~string, qword_101B0D708, (void *)&_mh_execute_header);
  sub_100058DB0(&qword_101B0D708[3], "sq-device-proxy.apple.com");

  return __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B0D708[3], (void *)&_mh_execute_header);
}

void sub_10078709C()
{
}

void sub_100787164(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void *sub_100787198(void *a1, uint64_t a2, NSObject **a3)
{
  uint64_t v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v11, kCtLoggingSystemName, "subscr.not");
  void *v6 = 0;
  v6[1] = 0;
  uint64_t v7 = *a3;
  a1[3] = *a3;
  if (v7) {
    dispatch_retain(v7);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v12, &v11);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v12);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v11);
  *a1 = off_101A05BB0;
  long long v8 = *(Registry **)a2;
  a1[6] = *(void *)a2;
  uint64_t v9 = *(void *)(a2 + 8);
  a1[7] = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    long long v8 = (Registry *)a1[6];
  }
  Registry::getNotificationSenderFactory((uint64_t *)&v11, v8);
  (*(void (**)(char *))(*(void *)v11.var0 + 88))(v11.var0);
  if (v11.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v11.var1.fRef);
  }
  return a1;
}

void sub_1007872D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, char a12)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v12 + 7);
  if (v16) {
    sub_10004D2C8(v16);
  }
  ctu::OsLogLogger::~OsLogLogger(v14);
  sub_100087E88(v13);
  SubscriberEventSenderInterface::~SubscriberEventSenderInterface(v12);
  _Unwind_Resume(a1);
}

void sub_100787348(void *a1)
{
  *a1 = off_101A05BB0;
  int v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  long long v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  SubscriberEventSenderInterface::~SubscriberEventSenderInterface((SubscriberEventSenderInterface *)a1);
}

void sub_1007873C8(void *a1)
{
  sub_100787348(a1);

  operator delete();
}

uint64_t sub_100787400(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

void sub_100787424(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = subscriber::toSimStatus();
  xpc_object_t object = 0;
  sub_10078750C(&object, v4);
  sub_100787714(a2, 58, object);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), a2, v4);
  if (subscriber::isSimSettled())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotification(DarwinNotifyCenter, kCTSimStatusChangedNotification, 0, 0, 0);
  }
  xpc_release(object);
}

void sub_1007874F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void sub_10078750C(void *a1, unsigned int a2)
{
  *a1 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    *a1 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    *a1 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  *a1 = v6;
LABEL_9:
  xpc_release(v5);
  sub_100C895B8(a2);
  long long v15 = 0uLL;
  uint64_t v16 = 0;
  ctu::cf::assign();
  *(_OWORD *)OsLogContext v11 = 0uLL;
  uint64_t v12 = 0;
  xpc_object_t object = xpc_string_create((const char *)v11);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  long long v15 = 0uLL;
  uint64_t v16 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v15;
  uint64_t v9 = v16;
  uint64_t v7 = __p;
  if (v16 < 0) {
    uint64_t v7 = (void **)__p[0];
  }
  v10[0] = a1;
  v10[1] = v7;
  sub_100035E70((uint64_t)v10, &object, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
}

void sub_1007876AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (*(char *)(v22 - 33) < 0) {
    operator delete(*(void **)(v22 - 56));
  }
  xpc_release(v21);
  if (a20 < 0) {
    operator delete(a15);
  }
  sub_10017143C(v20);
  _Unwind_Resume(a1);
}

void sub_100787714(int a1, int a2, xpc_object_t object)
{
  if (a1 == 1)
  {
    xpc_object_t v3 = object;
    xpc_object_t v7 = object;
    if (object)
    {
      xpc_retain(object);
    }
    else
    {
      xpc_object_t v3 = xpc_null_create();
      xpc_object_t v7 = v3;
    }
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v6 = v5;
    sub_1000452AC(a2, &v7, &v6);
    xpc_release(v5);
    xpc_release(v3);
  }
}

void sub_1007877A4(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_1007877D0(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  xpc_object_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    xpc_object_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v13);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    long long v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  long long v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (v11) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 16))(v11, a2);
LABEL_11:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1007878E0(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007878FC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7 = subscriber::toSimStatus();
  xpc_object_t v14 = 0;
  sub_10078750C(&v14, v7);
  xpc_object_t v12 = xpc_int64_create(a4);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  long long v15 = 0uLL;
  uint64_t v16 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v15;
  uint64_t v10 = v16;
  unsigned int v8 = __p;
  if (v16 < 0) {
    unsigned int v8 = (void **)__p[0];
  }
  v11[0] = &v14;
  v11[1] = v8;
  sub_100035E70((uint64_t)v11, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v12);
  xpc_object_t v12 = 0;
  sub_100787714(a2, 59, v14);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64), a2, v7);
  xpc_release(v14);
}

void sub_100787A4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t object)
{
  if (*(char *)(v18 - 33) < 0) {
    operator delete(*(void **)(v18 - 56));
  }
  xpc_release(v17);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_100787A90(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  xpc_object_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    xpc_object_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v13);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (v11) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 16))(v11, a2);
LABEL_11:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100787BA0(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100787BBC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7 = subscriber::toSimStatus();
  xpc_object_t v14 = 0;
  sub_10078750C(&v14, v7);
  xpc_object_t v12 = xpc_int64_create(a4);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  long long v15 = 0uLL;
  uint64_t v16 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v15;
  uint64_t v10 = v16;
  unsigned int v8 = __p;
  if (v16 < 0) {
    unsigned int v8 = (void **)__p[0];
  }
  v11[0] = &v14;
  v11[1] = v8;
  sub_100035E70((uint64_t)v11, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v12);
  xpc_object_t v12 = 0;
  sub_100787714(a2, 60, v14);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 40))(*(void *)(a1 + 64), a2, v7);
  xpc_release(v14);
}

void sub_100787D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t object)
{
  if (*(char *)(v18 - 33) < 0) {
    operator delete(*(void **)(v18 - 56));
  }
  xpc_release(v17);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_100787D50(uint64_t a1, BOOL a2)
{
  xpc_object_t v17 = 0;
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v17 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v17 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v17 = v5;
LABEL_9:
  xpc_release(v4);
  long long v18 = 0uLL;
  uint64_t v19 = 0;
  ctu::cf::assign();
  *(_OWORD *)unint64_t v13 = 0uLL;
  uint64_t v14 = 0;
  xpc_object_t v15 = xpc_string_create((const char *)v13);
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  long long v18 = 0uLL;
  uint64_t v19 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v18;
  uint64_t v11 = v19;
  xpc_object_t v6 = (void **)v18;
  if (v19 >= 0) {
    xpc_object_t v6 = __p;
  }
  v12[0] = &v17;
  v12[1] = v6;
  sub_100035E70((uint64_t)v12, &v15, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v15);
  xpc_object_t v15 = 0;
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[0]);
  }
  xpc_object_t v8 = xpc_BOOL_create(a2);
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  long long v18 = 0uLL;
  uint64_t v19 = 0;
  ctu::cf::assign();
  *(_OWORD *)unint64_t v13 = v18;
  uint64_t v14 = v19;
  uint64_t v7 = v13;
  if (v19 < 0) {
    uint64_t v7 = (void **)v13[0];
  }
  __p[0] = &v17;
  __p[1] = v7;
  sub_100035E70((uint64_t)__p, &v8, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[0]);
  }
  xpc_release(v8);
  xpc_object_t v8 = 0;
  sub_100787714(1, 53, v17);
  xpc_release(v17);
}

void sub_100787F98(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 48));
  _Unwind_Resume(a1);
}

void sub_10078804C()
{
  xpc_object_t v0 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v1 = v0;
  if (v0)
  {
    xpc_object_t v11 = v0;
  }
  else
  {
    xpc_object_t v1 = xpc_null_create();
    xpc_object_t v11 = v1;
    if (!v1)
    {
      xpc_object_t v2 = xpc_null_create();
      xpc_object_t v1 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v1);
    goto LABEL_9;
  }
  xpc_object_t v2 = xpc_null_create();
LABEL_8:
  xpc_object_t v11 = v2;
LABEL_9:
  xpc_release(v1);
  long long v12 = 0uLL;
  uint64_t v13 = 0;
  ctu::cf::assign();
  *(_OWORD *)uint64_t v7 = 0uLL;
  uint64_t v8 = 0;
  xpc_object_t v9 = xpc_string_create((const char *)v7);
  if (!v9) {
    xpc_object_t v9 = xpc_null_create();
  }
  long long v12 = 0uLL;
  uint64_t v13 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v12;
  uint64_t v5 = v13;
  xpc_object_t v3 = __p;
  if (v13 < 0) {
    xpc_object_t v3 = (void **)__p[0];
  }
  v6[0] = &v11;
  v6[1] = v3;
  sub_100035E70((uint64_t)v6, &v9, &v10);
  xpc_release(v10);
  xpc_object_t v10 = 0;
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v9);
  xpc_object_t v9 = 0;
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[0]);
  }
  sub_100787714(1, 54, v11);
  xpc_release(v11);
}

void sub_1007881F0(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 48));
  _Unwind_Resume(a1);
}

void sub_100788270(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v15 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v15 = v6;
LABEL_9:
  xpc_release(v5);
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  ctu::cf::assign();
  *(_OWORD *)xpc_object_t v11 = 0uLL;
  uint64_t v12 = 0;
  xpc_object_t object = xpc_string_create((const char *)v11);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v16;
  uint64_t v9 = v17;
  uint64_t v7 = __p;
  if (v17 < 0) {
    uint64_t v7 = (void **)__p[0];
  }
  v10[0] = &v15;
  v10[1] = v7;
  sub_100035E70((uint64_t)v10, &object, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  sub_100787714(a2, 55, v15);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), a2, 1);
  xpc_release(v15);
}

void sub_10078845C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22)
{
  if (*(char *)(v23 - 33) < 0) {
    operator delete(*(void **)(v23 - 56));
  }
  xpc_release(v22);
  if (a20 < 0) {
    operator delete(a15);
  }
  xpc_release(*(xpc_object_t *)(v23 - 64));
  _Unwind_Resume(a1);
}

void sub_1007884D4(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v15 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v15 = v6;
LABEL_9:
  xpc_release(v5);
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  ctu::cf::assign();
  *(_OWORD *)xpc_object_t v11 = 0uLL;
  uint64_t v12 = 0;
  xpc_object_t object = xpc_string_create((const char *)v11);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v16;
  uint64_t v9 = v17;
  uint64_t v7 = __p;
  if (v17 < 0) {
    uint64_t v7 = (void **)__p[0];
  }
  v10[0] = &v15;
  v10[1] = v7;
  sub_100035E70((uint64_t)v10, &object, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  sub_100787714(a2, 56, v15);
  (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), a2, 0);
  xpc_release(v15);
}

void sub_1007886C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22)
{
  if (*(char *)(v23 - 33) < 0) {
    operator delete(*(void **)(v23 - 56));
  }
  xpc_release(v22);
  if (a20 < 0) {
    operator delete(a15);
  }
  xpc_release(*(xpc_object_t *)(v23 - 64));
  _Unwind_Resume(a1);
}

void sub_100788738(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v15 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v15 = v6;
LABEL_9:
  xpc_release(v5);
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  ctu::cf::assign();
  *(_OWORD *)xpc_object_t v11 = 0uLL;
  uint64_t v12 = 0;
  xpc_object_t object = xpc_string_create((const char *)v11);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v16;
  uint64_t v9 = v17;
  uint64_t v7 = __p;
  if (v17 < 0) {
    uint64_t v7 = (void **)__p[0];
  }
  v10[0] = &v15;
  v10[1] = v7;
  sub_100035E70((uint64_t)v10, &object, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  sub_100787714(a2, 55, v15);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 48))(*(void *)(a1 + 64), a2, 1);
  xpc_release(v15);
}

void sub_100788924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22)
{
  if (*(char *)(v23 - 33) < 0) {
    operator delete(*(void **)(v23 - 56));
  }
  xpc_release(v22);
  if (a20 < 0) {
    operator delete(a15);
  }
  xpc_release(*(xpc_object_t *)(v23 - 64));
  _Unwind_Resume(a1);
}

void sub_10078899C(uint64_t a1, uint64_t a2, int a3)
{
  xpc_object_t v26 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    xpc_object_t v26 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v26 = v7;
    if (!v7)
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  xpc_object_t v8 = xpc_null_create();
LABEL_8:
  xpc_object_t v26 = v8;
LABEL_9:
  xpc_release(v7);
  long long v27 = 0uLL;
  uint64_t v28 = 0;
  ctu::cf::assign();
  *(_OWORD *)uint64_t v22 = 0u;
  uint64_t v23 = 0;
  xpc_object_t v24 = xpc_string_create((const char *)v22);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  long long v27 = 0uLL;
  uint64_t v28 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v27;
  uint64_t v19 = v28;
  uint64_t v9 = (void **)v27;
  if (v28 >= 0) {
    uint64_t v9 = __p;
  }
  uint64_t v20 = &v26;
  char v21 = v9;
  sub_100035E70((uint64_t)&v20, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v24);
  xpc_object_t v24 = 0;
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[0]);
  }
  xpc_object_t v16 = xpc_int64_create(a3);
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  long long v27 = 0uLL;
  uint64_t v28 = 0;
  ctu::cf::assign();
  *(_OWORD *)uint64_t v22 = v27;
  uint64_t v23 = v28;
  xpc_object_t v10 = (void **)v27;
  if (v28 >= 0) {
    xpc_object_t v10 = v22;
  }
  __p[0] = &v26;
  __p[1] = v10;
  sub_100035E70((uint64_t)__p, &v16, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[0]);
  }
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_object_t v11 = (char *)CSIErrorString();
  sub_100058DB0(v22, v11);
  if (v23 >= 0) {
    uint64_t v12 = v22;
  }
  else {
    uint64_t v12 = (void **)v22[0];
  }
  xpc_object_t v14 = xpc_string_create((const char *)v12);
  if (!v14) {
    xpc_object_t v14 = xpc_null_create();
  }
  long long v27 = 0uLL;
  uint64_t v28 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v27;
  uint64_t v19 = v28;
  uint64_t v13 = __p;
  if (v28 < 0) {
    uint64_t v13 = (void **)__p[0];
  }
  uint64_t v20 = &v26;
  char v21 = v13;
  sub_100035E70((uint64_t)&v20, &v14, &v15);
  xpc_release(v15);
  xpc_object_t v15 = 0;
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v14);
  xpc_object_t v14 = 0;
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[0]);
  }
  sub_100787714(a2, 56, v26);
  (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 64) + 48))(*(void *)(a1 + 64), a2, 0);
  xpc_release(v26);
}

void sub_100788D00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (*(char *)(v25 - 33) < 0) {
    operator delete(*(void **)(v25 - 56));
  }
  xpc_release(v24);
  if (a24 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v25 - 64));
  _Unwind_Resume(a1);
}

void sub_100788DF0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100788EBC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100788F94);
  __cxa_rethrow();
}

void sub_100788EE4(_Unwind_Exception *a1)
{
}

void sub_100788EFC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100788F34(uint64_t a1)
{
}

uint64_t sub_100788F50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100788F94(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100788FC0(uint64_t a1)
{
  xpc_object_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_100788FF4(uint64_t a1, NSObject **a2, void *a3)
{
  xpc_object_t v6 = *a2;
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  sub_1013BD45C(a1, &object, a3, "cp.rch.fam");
  if (object) {
    dispatch_release(object);
  }
  *(void *)a1 = off_101A05DE8;
  *(void *)(a1 + 8) = &off_101A05F18;
  sub_100058DB0(&__p, "CellularPlanFamilyCommandHandler");
  xpc_object_t v8 = *a2;
  *a2 = 0;
  ctu::RestModule::RestModule();
  if (v8) {
    dispatch_release(v8);
  }
  if (v10 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 368) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  int v12 = 0;
  sub_10078C71C((uint64_t **)(a1 + 72), &v12, &v12);
  return a1;
}

void sub_100789124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  *(void *)(v19 - 40) = v17 + 44;
  sub_1003DACB8((void ***)(v19 - 40));
  char v21 = (std::__shared_weak_count *)v17[43];
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v22 = (std::__shared_weak_count *)v17[41];
  if (v22) {
    sub_10004D2C8(v22);
  }
  sub_1007891CC(v18);
  uint64_t v23 = (std::__shared_weak_count *)v17[32];
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_1013BD63C((uint64_t)v17);
  _Unwind_Resume(a1);
}

void sub_1007891AC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x1007891A4);
}

const char *sub_1007891C0()
{
  return "CellularPlanFamilyCommandHandler";
}

void *sub_1007891CC(uint64_t a1)
{
  xpc_object_t v3 = (void **)(a1 + 32);
  sub_1003DACB8(&v3);
  return sub_10078C480((void *)a1);
}

void sub_10078920C(uint64_t a1)
{
  if (*(void *)(a1 + 320) && *(void *)(a1 + 336)) {
    return;
  }
  sub_10003E168(buf, (void *)(a1 + 16));
  uint64_t v3 = *(void *)buf;
  xpc_object_t v2 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  uint64_t v45 = 512;
  (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v49);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v49);
  xpc_object_t v5 = ServiceMap;
  xpc_object_t v6 = "38CellularPlanIDSServiceManagerInterface";
  xpc_object_t v7 = "38CellularPlanIDSServiceManagerInterface";
  if (((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x8000000000000000) != 0)
  {
    xpc_object_t v8 = (unsigned __int8 *)((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      xpc_object_t v7 = (const char *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  char v46 = v7;
  xpc_object_t v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v46);
  if (!v11)
  {
    uint64_t v13 = 0;
    goto LABEL_12;
  }
  uint64_t v13 = v11[3];
  int v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
LABEL_12:
    std::mutex::unlock(v5);
    int v12 = 0;
    char v14 = 1;
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
LABEL_13:
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v13 + 16))(buf, v13);
  long long v15 = *(_OWORD *)buf;
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  xpc_object_t v16 = *(std::__shared_weak_count **)(a1 + 328);
  *(_OWORD *)(a1 + 320) = v15;
  if (v16)
  {
    sub_10004D2C8(v16);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (v50) {
    sub_10004D2C8(v50);
  }
  uint64_t v17 = *(void *)(a1 + 320);
  v43[0] = _NSConcreteStackBlock;
  v43[1] = 1174405120;
  v43[2] = sub_100789C98;
  v43[3] = &unk_101A05FB8;
  void v43[4] = a1;
  v43[5] = v3;
  uint64_t v44 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  v41[0] = _NSConcreteStackBlock;
  v41[1] = 1174405120;
  dispatch_object_t v41[2] = sub_10078AC30;
  v41[3] = &unk_101A06018;
  v41[4] = a1;
  v41[5] = v3;
  uint64_t v42 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  int v18 = (*(uint64_t (**)(uint64_t, const char *, uint64_t *, Block_layout *, void *, void *))(*(void *)v17 + 24))(v17, "CellularPlanFamilyCommandHandler", &v45, &stru_101A05F68, v43, v41);
  (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v49);
  uint64_t v19 = (std::mutex *)Registry::getServiceMap(v49);
  uint64_t v20 = v19;
  if (((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x8000000000000000) != 0)
  {
    char v21 = (unsigned __int8 *)((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      xpc_object_t v6 = (const char *)v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(v19);
  char v46 = v6;
  xpc_object_t v24 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&v46);
  if (v24)
  {
    uint64_t v26 = v24[3];
    uint64_t v25 = (std::__shared_weak_count *)v24[4];
    if (v25)
    {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v25);
      char v27 = 0;
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v20);
  uint64_t v25 = 0;
  char v27 = 1;
LABEL_32:
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v26 + 32))(buf, v26);
  long long v28 = *(_OWORD *)buf;
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  std::string::size_type v29 = *(std::__shared_weak_count **)(a1 + 344);
  *(_OWORD *)(a1 + 336) = v28;
  if (v29)
  {
    sub_10004D2C8(v29);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  if (v50) {
    sub_10004D2C8(v50);
  }
  uint64_t v30 = *(void *)(a1 + 336);
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 1174405120;
  void v39[2] = sub_10078B0E8;
  v39[3] = &unk_101A060F8;
  v39[4] = a1;
  v39[5] = v3;
  uint64_t v40 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  int v31 = (*(uint64_t (**)(uint64_t, const char *, uint64_t *, Block_layout *, Block_layout *, void *))(*(void *)v30 + 24))(v30, "CellularPlanFamilyCommandHandler", &v45, &stru_101A06068, &stru_101A060A8, v39);
  if ((v18 & v31) == 1)
  {
    uint64_t v32 = (uint8_t *)(a1 + 264);
    *(void *)long long buf = off_101A06188;
    *(void *)&uint8_t buf[8] = a1 + 248;
    char v48 = buf;
    if (buf != (uint8_t *)(a1 + 264))
    {
      CFTypeRef v33 = *(uint8_t **)(a1 + 288);
      if (v33 == v32)
      {
        char v50 = (std::__shared_weak_count *)(a1 + 248);
        uint64_t v51 = 0;
        char v48 = 0;
        long long v49 = (Registry *)off_101A06188;
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v32 + 24))(a1 + 264, buf);
        (*(void (**)(void))(**(void **)(a1 + 288) + 32))(*(void *)(a1 + 288));
        *(void *)(a1 + 288) = 0;
        char v48 = buf;
        (*((void (**)(Registry **, uint64_t))v49 + 3))(&v49, a1 + 264);
        (*((void (**)(Registry **))v49 + 4))(&v49);
      }
      else
      {
        *(void *)(a1 + 264) = off_101A06188;
        *(void *)(a1 + 272) = a1 + 248;
        char v48 = v33;
      }
      *(void *)(a1 + 288) = v32;
    }
    sub_10078C480(buf);
    uint64_t v35 = *(void *)(a1 + 288);
    if (v35) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v35 + 48))(v35, a1 + 296);
    }
    sub_100058DB0(&v49, "/cc/events/new_nanoregistry_device_configured");
    std::string::size_type v36 = (uint8_t *)operator new(0x20uLL);
    *(void *)std::string::size_type v36 = off_101A06218;
    *((void *)v36 + 1) = a1;
    *((void *)v36 + 2) = sub_10078B420;
    *((void *)v36 + 3) = 0;
    char v48 = v36;
    ctu::RestModule::observeEvent();
    sub_10003F600(buf);
    if (SHIBYTE(v51) < 0) {
      operator delete(v49);
    }
    (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
    Registry::createRestModuleOneTimeUseConnection(&v37, *(Registry **)buf);
    ctu::RestModule::connect();
    if (v38) {
      sub_10004D2C8(v38);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else
  {
    uint64_t v34 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v18;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v31;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Failed to register: local [%d]; internet [%d]",
        buf,
        0xEu);
    }
  }
  if (v40) {
    std::__shared_weak_count::__release_weak(v40);
  }
  if (v42) {
    std::__shared_weak_count::__release_weak(v42);
  }
  if (v44) {
    std::__shared_weak_count::__release_weak(v44);
  }
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100789990(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100789AAC(id a1, const void *a2)
{
  return sub_100789AB4((uint64_t)a2);
}

BOOL sub_100789AB4(uint64_t a1)
{
  uint64_t v1 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) < 0x60000u) {
    return 0;
  }
  xpc_object_t v4 = (const char **)qword_101B0D740;
  uint64_t v5 = qword_101B0D748;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(v20, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v20 = *(_OWORD *)a1;
    uint64_t v21 = *(void *)(a1 + 16);
  }
  __int16 v22 = *(_WORD *)(a1 + 24);
  if (*(char *)(a1 + 55) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 32);
    uint64_t v24 = *(void *)(a1 + 48);
  }
  int v25 = *v1;
  char v26 = *((unsigned char *)v1 + 4);
  char v6 = HIBYTE(v24);
  if (v4 != (const char **)v5)
  {
    if (v24 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = (long long *)__p;
    }
    if (v24 >= 0) {
      int64_t v8 = HIBYTE(v24);
    }
    else {
      int64_t v8 = *((void *)&__p + 1);
    }
    uint64_t v9 = (char *)p_p + v8;
    while (1)
    {
      unsigned int v10 = *v4;
      int64_t v11 = strlen(*v4);
      if (!v11) {
        break;
      }
      int64_t v12 = v11;
      if (v8 >= v11)
      {
        int v13 = *v10;
        int64_t v14 = v8;
        long long v15 = p_p;
        do
        {
          int64_t v16 = v14 - v12;
          if (v16 == -1) {
            break;
          }
          uint64_t v17 = (char *)memchr(v15, v13, v16 + 1);
          if (!v17) {
            break;
          }
          int v18 = v17;
          if (!memcmp(v17, v10, v12))
          {
            if (v18 == v9 || v18 - (char *)p_p == -1) {
              break;
            }
            goto LABEL_29;
          }
          long long v15 = (long long *)(v18 + 1);
          int64_t v14 = v9 - (v18 + 1);
        }
        while (v14 >= v12);
      }
      if (++v4 == (const char **)v5)
      {
        xpc_object_t v4 = (const char **)v5;
        break;
      }
    }
  }
LABEL_29:
  BOOL v2 = v4 != (const char **)qword_101B0D748;
  if (v6 < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[0]);
  }
  return v2;
}

void sub_100789C7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100789C98(uint64_t a1, uint64_t *a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 1174405120;
  v5[2] = sub_100789E1C;
  v5[3] = &unk_101A05F88;
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v6 = v4;
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 48);
  xpc_object_t v7 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  memset(v8, 0, sizeof(v8));
  sub_1003C1BB8(v8, *a2, a2[1], (a2[1] - *a2) >> 6);
  int64_t v11 = 0;
  int64_t v12 = 0;
  sub_10003E168(&v11, (void *)(v4 + 16));
  uint64_t v3 = *(NSObject **)(v4 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = (void **)1174405120;
  void block[2] = (void **)sub_10078C7D8;
  block[3] = (void **)&unk_101A06148;
  block[5] = v11;
  unsigned int v10 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = (void **)v5;
  dispatch_async(v3, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  block[0] = (void **)v8;
  sub_1002B2AEC(block);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

void sub_100789E04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100789E1C(void *a1)
{
  void (***v99)(long long *__return_ptr);
  uint64_t *v100;
  long long *v101;
  void *v102;
  std::string *v103;
  std::string *v104;
  uint64_t v105;
  void *v106[2];
  uint64_t v107;
  void *__dst[2];
  uint64_t v109;
  __int16 v110;
  long long __p;
  uint64_t v112;
  int v113;
  char v114;
  uint64_t v115;
  void *v116;
  long long buf;
  long long v118;
  long long v119;
  long long v120;
  long long v121;
  unsigned char v122[128];
  long long v123;
  long long v124;
  char *v125;
  char *v126;
  void *v127;

  BOOL v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!a1[5])
      {
LABEL_205:
        sub_10004D2C8(v5);
        return;
      }
      uint64_t v103 = 0;
      v104 = 0;
      v105 = 0;
      sub_1003C1BB8(&v103, a1[7], a1[8], (uint64_t)(a1[8] - a1[7]) >> 6);
      long long v6 = *(NSObject **)(v3 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = ((char *)v104 - (char *)v103) >> 6;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Number of linked devices: %lu", (uint8_t *)&buf, 0xCu);
      }
      if ((std::string **)(v3 + 96) != &v103) {
        sub_1005E459C(v3 + 96, v103, v104, ((char *)v104 - (char *)v103) >> 6);
      }
      uint64_t v8 = *(void *)(v3 + 296);
      uint64_t v7 = *(void *)(v3 + 304);
      if (v8 != v7)
      {
        while (!*(unsigned char *)v8)
        {
          v8 += 216;
          if (v8 == v7)
          {
            uint64_t v8 = *(void *)(v3 + 304);
            break;
          }
        }
      }
      unsigned int v10 = *(const std::string **)(v3 + 96);
      uint64_t v9 = *(unsigned __int8 **)(v3 + 104);
      if (v10 != (const std::string *)v9)
      {
        while (!v10[1].__r_.__value_.__s.__data_[0] || v10[1].__r_.__value_.__s.__data_[1] == 0)
        {
          unsigned int v10 = (const std::string *)((char *)v10 + 64);
          if (v10 == (const std::string *)v9) {
            goto LABEL_37;
          }
        }
      }
      if (v10 == (const std::string *)v9)
      {
LABEL_37:
        int v18 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I No active devices", (uint8_t *)&buf, 2u);
        }
        goto LABEL_46;
      }
      if (v8 == v7)
      {
        uint64_t v19 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          uint64_t v20 = "#I No previous device in proximity";
LABEL_44:
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&buf, 2u);
        }
LABEL_45:
        sub_1013D1334((void *)v3, v10);
LABEL_46:
        uint64_t v21 = *(std::__shared_weak_count **)(v3 + 152);
        if (v21)
        {
          __int16 v22 = std::__shared_weak_count::lock(v21);
          unsigned int v23 = v22;
          if (v22)
          {
            v99 = *(void (****)(long long *__return_ptr))(v3 + 144);
            if (v99)
            {
              v97 = v22;
              unint64_t v98 = v5;
              uint64_t v24 = (void *)(v3 + 264);
              v115 = 1;
              uint64_t v116 = (void *)(v3 + 264);
              int v25 = *(long long **)(v3 + 96);
              v101 = *(long long **)(v3 + 104);
              uint64_t v100 = (uint64_t *)v3;
              if (v25 != v101)
              {
                char v26 = (uint64_t **)(v3 + 120);
                do
                {
                  uint64_t v27 = v116[4];
                  uint64_t v28 = v116[5];
                  if (*((char *)v25 + 23) < 0)
                  {
                    sub_10004FC84(__dst, *(void **)v25, *((void *)v25 + 1));
                  }
                  else
                  {
                    long long v29 = *v25;
                    uint64_t v109 = *((void *)v25 + 2);
                    *(_OWORD *)std::string __dst = v29;
                  }
                  uint64_t v110 = *((_WORD *)v25 + 12);
                  if (*((char *)v25 + 55) < 0)
                  {
                    sub_10004FC84(&__p, *((void **)v25 + 4), *((void *)v25 + 5));
                  }
                  else
                  {
                    long long v30 = v25[2];
                    v112 = *((void *)v25 + 6);
                    long long __p = v30;
                  }
                  int v31 = *((_DWORD *)v25 + 14);
                  v114 = *((unsigned char *)v25 + 60);
                  uint64_t v113 = v31;
                  if (v27 != v28)
                  {
                    if (v109 >= 0) {
                      uint64_t v32 = (void *)HIBYTE(v109);
                    }
                    else {
                      uint64_t v32 = __dst[1];
                    }
                    if (v109 >= 0) {
                      CFTypeRef v33 = __dst;
                    }
                    else {
                      CFTypeRef v33 = (void **)__dst[0];
                    }
                    do
                    {
                      uint64_t v34 = *(unsigned __int8 *)(v27 + 31);
                      if ((v34 & 0x80u) == 0) {
                        uint64_t v35 = (void *)*(unsigned __int8 *)(v27 + 31);
                      }
                      else {
                        uint64_t v35 = *(void **)(v27 + 16);
                      }
                      if (v35 == v32)
                      {
                        if ((v34 & 0x80) != 0)
                        {
                          if (!memcmp(*(const void **)(v27 + 8), v33, *(void *)(v27 + 16))) {
                            goto LABEL_77;
                          }
                        }
                        else
                        {
                          if (!*(unsigned char *)(v27 + 31)) {
                            goto LABEL_77;
                          }
                          uint64_t v36 = 0;
                          while (*(unsigned __int8 *)(v27 + v36 + 8) == *((unsigned __int8 *)v33 + v36))
                          {
                            if (v34 == ++v36) {
                              goto LABEL_77;
                            }
                          }
                        }
                      }
                      v27 += 216;
                    }
                    while (v27 != v28);
                    uint64_t v27 = v28;
                  }
LABEL_77:
                  if (SHIBYTE(v112) < 0) {
                    operator delete((void *)__p);
                  }
                  if (SHIBYTE(v109) < 0) {
                    operator delete(__dst[0]);
                  }
                  if (v27 == v116[5])
                  {
                    id v123 = 0u;
                    uint64_t v121 = 0u;
                    memset(v122, 0, sizeof(v122));
                    uint64_t v119 = 0u;
                    v120 = 0u;
                    long long buf = 0u;
                    v118 = 0u;
                    if (*((char *)v25 + 23) < 0)
                    {
                      sub_10004FC84(v106, *(void **)v25, *((void *)v25 + 1));
                    }
                    else
                    {
                      long long v37 = *v25;
                      uint64_t v107 = *((void *)v25 + 2);
                      *(_OWORD *)uint64_t v106 = v37;
                    }
                    (**v99)(&buf);
                    if (SHIBYTE(v107) < 0) {
                      operator delete(v106[0]);
                    }
                    int v38 = BYTE8(v121);
                    unsigned int v39 = v100[6];
                    BOOL v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
                    if (v38)
                    {
                      if (v40)
                      {
                        uint64_t v41 = v25;
                        if (*((char *)v25 + 23) < 0) {
                          uint64_t v41 = *(long long **)v25;
                        }
                        LODWORD(v124) = 136315138;
                        *(void *)((char *)&v124 + 4) = v41;
                        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I New device found (%s)", (uint8_t *)&v124, 0xCu);
                      }
                      uint64_t v42 = v116;
                      unint64_t v43 = v116[5];
                      unint64_t v44 = v116[6];
                      if (v43 >= v44)
                      {
                        uint64_t v47 = v116[4];
                        unint64_t v48 = 0x84BDA12F684BDA13 * ((uint64_t)(v43 - v47) >> 3);
                        unint64_t v49 = v48 + 1;
                        if (v48 + 1 > 0x12F684BDA12F684) {
                          sub_10006A748();
                        }
                        unint64_t v50 = 0x84BDA12F684BDA13 * ((uint64_t)(v44 - v47) >> 3);
                        if (2 * v50 > v49) {
                          unint64_t v49 = 2 * v50;
                        }
                        if (v50 >= 0x97B425ED097B42) {
                          unint64_t v51 = 0x12F684BDA12F684;
                        }
                        else {
                          unint64_t v51 = v49;
                        }
                        v127 = v116 + 6;
                        if (v51) {
                          char v52 = (char *)sub_1000C5FD0((uint64_t)(v116 + 6), v51);
                        }
                        else {
                          char v52 = 0;
                        }
                        xpc_object_t v53 = &v52[216 * v48];
                        *(void *)&id v124 = v52;
                        *((void *)&v124 + 1) = v53;
                        v126 = &v52[216 * v51];
                        *(_OWORD *)xpc_object_t v53 = 0u;
                        *((_OWORD *)v53 + 1) = 0u;
                        *((_OWORD *)v53 + 2) = 0u;
                        *((_OWORD *)v53 + 3) = 0u;
                        *((_OWORD *)v53 + 4) = 0u;
                        *((_OWORD *)v53 + 5) = 0u;
                        *((_OWORD *)v53 + 6) = 0u;
                        *((_OWORD *)v53 + 7) = 0u;
                        *((_OWORD *)v53 + 8) = 0u;
                        *((_OWORD *)v53 + 9) = 0u;
                        *((_OWORD *)v53 + 10) = 0u;
                        *((_OWORD *)v53 + 11) = 0u;
                        *((_OWORD *)v53 + 12) = 0u;
                        *((void *)v53 + 26) = 0;
                        uint64_t v125 = v53 + 216;
                        sub_10078C504(v42 + 4, &v124);
                        unint64_t v45 = v42[5];
                        sub_10078C610((uint64_t)&v124);
                      }
                      else
                      {
                        *(void *)(v43 + 208) = 0;
                        *(_OWORD *)(v43 + 176) = 0u;
                        *(_OWORD *)(v43 + 192) = 0u;
                        *(_OWORD *)(v43 + 144) = 0u;
                        *(_OWORD *)(v43 + 160) = 0u;
                        *(_OWORD *)(v43 + 112) = 0u;
                        *(_OWORD *)(v43 + 128) = 0u;
                        *(_OWORD *)(v43 + 80) = 0u;
                        *(_OWORD *)(v43 + 96) = 0u;
                        *(_OWORD *)(v43 + 48) = 0u;
                        *(_OWORD *)(v43 + 64) = 0u;
                        *(_OWORD *)(v43 + 16) = 0u;
                        *(_OWORD *)(v43 + 32) = 0u;
                        *(_OWORD *)unint64_t v43 = 0u;
                        unint64_t v45 = v43 + 216;
                        v42[5] = v43 + 216;
                      }
                      v42[5] = v45;
                      if (BYTE8(v123))
                      {
                        cellplan::RemoteDeviceIdentifiers::operator=();
                      }
                      else
                      {
                        std::string::operator=((std::string *)(v45 - 112), (const std::string *)(v25 + 2));
                        std::string::operator=((std::string *)(v45 - 208), (const std::string *)v25);
                      }
                      uint64_t v55 = *((void *)&v119 + 1);
                      for (uint64_t i = v119; i != v55; i += 88)
                      {
                        *(void *)&id v124 = i + 16;
                        int v56 = (std::string *)sub_1003DE940(v26, i + 16, (uint64_t)&unk_10144E20E, (_OWORD **)&v124);
                        std::string::operator=(v56 + 2, (const std::string *)v25);
                      }
                      std::string::operator=((std::string *)(v45 - 72), (const std::string *)&buf);
                      *(void *)(v45 - 48) = *((void *)&v118 + 1);
                      if ((long long *)(v45 - 72) != &buf) {
                        sub_1003DB294(v45 - 40, v119, *((uint64_t *)&v119 + 1), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)&v119 + 1) - v119) >> 3));
                      }
                      int v57 = v121;
                      *(void *)(v45 - 16) = *((void *)&v120 + 1);
                      *(_DWORD *)(v45 - 8) = v57;
                      *(_DWORD *)(v45 - 16) = 2;
                      *(unsigned char *)(v45 - 216) = *((unsigned char *)v25 + 25);
                      *(unsigned char *)(v45 - 48) = *((unsigned char *)v25 + 24);
                    }
                    else if (v40)
                    {
                      char v46 = v25;
                      if (*((char *)v25 + 23) < 0) {
                        char v46 = *(long long **)v25;
                      }
                      LODWORD(v124) = 136315138;
                      *(void *)((char *)&v124 + 4) = v46;
                      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I No vinyl info yet (%s)", (uint8_t *)&v124, 0xCu);
                    }
                    sub_10037AD1C((uint64_t)v122);
                    sub_10037ACC8((uint64_t)&buf);
                  }
                  else
                  {
                    *(unsigned char *)uint64_t v27 = *((unsigned char *)v25 + 25);
                    *(unsigned char *)(v27 + 168) = *((unsigned char *)v25 + 24);
                  }
                  v25 += 4;
                }
                while (v25 != v101);
                uint64_t v24 = v116;
              }
              long long v59 = (unsigned char *)v24[4];
              char v58 = (unsigned char *)v24[5];
              uint64_t v125 = 0;
              id v124 = 0uLL;
              sub_1003C1BB8(&v124, (uint64_t)v103, (uint64_t)v104, ((char *)v104 - (char *)v103) >> 6);
              uint64_t v102 = v24;
              if (v59 == v58) {
                goto LABEL_190;
              }
              uint64_t v60 = v58;
              while (1)
              {
                uint64_t v62 = *((void *)&v124 + 1);
                uint64_t v61 = v124;
                if ((char)v59[31] < 0)
                {
                  sub_10004FC84(&buf, *((void **)v59 + 1), *((void *)v59 + 2));
                }
                else
                {
                  long long v63 = *(_OWORD *)(v59 + 8);
                  *(void *)&v118 = *((void *)v59 + 3);
                  long long buf = v63;
                }
                char v64 = BYTE7(v118);
                if (v61 != v62)
                {
                  if ((SBYTE7(v118) & 0x80u) == 0) {
                    uint64_t v65 = BYTE7(v118);
                  }
                  else {
                    uint64_t v65 = *((void *)&buf + 1);
                  }
                  if ((SBYTE7(v118) & 0x80u) == 0) {
                    p_long long buf = &buf;
                  }
                  else {
                    p_long long buf = (long long *)buf;
                  }
                  do
                  {
                    uint64_t v67 = *(unsigned __int8 *)(v61 + 23);
                    if ((v67 & 0x80u) == 0) {
                      uint64_t v68 = *(unsigned __int8 *)(v61 + 23);
                    }
                    else {
                      uint64_t v68 = *(void *)(v61 + 8);
                    }
                    if (v68 == v65)
                    {
                      if ((v67 & 0x80) != 0)
                      {
                        if (!memcmp(*(const void **)v61, p_buf, *(void *)(v61 + 8)))
                        {
LABEL_147:
                          char v70 = 0;
                          if (v64 < 0) {
                            goto LABEL_148;
                          }
                          goto LABEL_149;
                        }
                      }
                      else
                      {
                        if (!*(unsigned char *)(v61 + 23)) {
                          goto LABEL_147;
                        }
                        uint64_t v69 = 0;
                        while (*(unsigned __int8 *)(v61 + v69) == *((unsigned __int8 *)p_buf + v69))
                        {
                          if (v67 == ++v69) {
                            goto LABEL_147;
                          }
                        }
                      }
                    }
                    v61 += 64;
                  }
                  while (v61 != v62);
                }
                char v70 = 1;
                if (v64 < 0) {
LABEL_148:
                }
                  operator delete((void *)buf);
LABEL_149:
                if (v70) {
                  break;
                }
                v59 += 216;
                if (v59 == v58) {
                  goto LABEL_191;
                }
              }
              if (v59 == v58) {
                goto LABEL_191;
              }
              char v72 = v59 + 216;
              if (v59 + 216 == v58)
              {
LABEL_190:
                uint64_t v60 = v59;
                goto LABEL_191;
              }
              uint64_t v60 = v59;
LABEL_158:
              uint64_t v73 = v72;
              uint64_t v74 = *((void *)&v124 + 1);
              uint64_t v75 = v124;
              if ((char)v59[247] < 0)
              {
                sub_10004FC84(&buf, *((void **)v59 + 28), *((void *)v59 + 29));
              }
              else
              {
                long long buf = *((_OWORD *)v59 + 14);
                *(void *)&v118 = *((void *)v59 + 30);
              }
              char v76 = BYTE7(v118);
              if (v75 == v74)
              {
LABEL_180:
                char v82 = 1;
                if ((v76 & 0x80) == 0) {
                  goto LABEL_184;
                }
LABEL_181:
                operator delete((void *)buf);
                if ((v82 & 1) == 0) {
                  goto LABEL_185;
                }
                goto LABEL_188;
              }
              if ((SBYTE7(v118) & 0x80u) == 0) {
                uint64_t v77 = BYTE7(v118);
              }
              else {
                uint64_t v77 = *((void *)&buf + 1);
              }
              if ((SBYTE7(v118) & 0x80u) == 0) {
                __int16 v78 = &buf;
              }
              else {
                __int16 v78 = (long long *)buf;
              }
              while (1)
              {
                uint64_t v79 = *(unsigned __int8 *)(v75 + 23);
                if ((v79 & 0x80u) == 0) {
                  uint64_t v80 = *(unsigned __int8 *)(v75 + 23);
                }
                else {
                  uint64_t v80 = *(void *)(v75 + 8);
                }
                if (v80 == v77)
                {
                  if ((v79 & 0x80) != 0)
                  {
                    if (!memcmp(*(const void **)v75, v78, *(void *)(v75 + 8)))
                    {
LABEL_183:
                      char v82 = 0;
                      if (v76 < 0) {
                        goto LABEL_181;
                      }
LABEL_184:
                      if ((v82 & 1) == 0)
                      {
LABEL_185:
                        unsigned char *v60 = *v73;
                        cellplan::RemoteDeviceIdentifiers::operator=();
                        int v83 = (void **)(v60 + 144);
                        if ((char)v60[167] < 0) {
                          operator delete(*v83);
                        }
                        long long v84 = *(_OWORD *)(v59 + 360);
                        *((void *)v60 + 20) = *((void *)v59 + 47);
                        *(_OWORD *)int v83 = v84;
                        v59[383] = 0;
                        v59[360] = 0;
                        *((void *)v60 + 21) = *((void *)v59 + 48);
                        sub_1003DB434((void **)v60 + 22);
                        *((_OWORD *)v60 + 11) = *(_OWORD *)(v59 + 392);
                        *((void *)v60 + 24) = *((void *)v59 + 51);
                        *((void *)v59 + 49) = 0;
                        *((void *)v59 + 50) = 0;
                        *((void *)v59 + 51) = 0;
                        uint64_t v85 = *((void *)v59 + 52);
                        *((_DWORD *)v60 + 52) = *((_DWORD *)v59 + 106);
                        *((void *)v60 + 25) = v85;
                        v60 += 216;
                      }
LABEL_188:
                      char v72 = v73 + 216;
                      long long v59 = v73;
                      if (v73 + 216 == v58)
                      {
LABEL_191:
                        uint64_t v86 = (unsigned char *)v116[5];
                        unsigned int v23 = v97;
                        uint64_t v5 = v98;
                        if (v60 != v86)
                        {
                          uint64_t v87 = v86 - v60;
                          uint64_t v88 = (uint64_t)&v60[v87];
                          uint64_t v89 = (unsigned char *)v102[5];
                          if (&v60[v87] != v89)
                          {
                            uint64_t v90 = 8 * (v87 >> 3);
                            do
                            {
                              unsigned char *v60 = v60[v90];
                              cellplan::RemoteDeviceIdentifiers::operator=();
                              v91 = (void **)(v60 + 144);
                              if ((char)v60[167] < 0) {
                                operator delete(*v91);
                              }
                              uint64_t v92 = &v60[v90];
                              long long v93 = *(_OWORD *)&v60[v90 + 144];
                              uint64_t v94 = *(void *)&v60[v90 + 168];
                              *((void *)v60 + 20) = *(void *)&v60[v90 + 160];
                              *(_OWORD *)v91 = v93;
                              v92[167] = 0;
                              v92[144] = 0;
                              *((void *)v60 + 21) = v94;
                              sub_1003DB434((void **)v60 + 22);
                              *((_OWORD *)v60 + 11) = *(_OWORD *)&v60[v90 + 176];
                              *((void *)v92 + 22) = 0;
                              *((void *)v92 + 23) = 0;
                              int v95 = *(_DWORD *)&v60[v90 + 208];
                              uint64_t v96 = *(void *)&v60[v90 + 200];
                              *((void *)v60 + 24) = *(void *)&v60[v90 + 192];
                              *((void *)v60 + 25) = v96;
                              *((void *)v92 + 24) = 0;
                              *((_DWORD *)v60 + 52) = v95;
                              v60 += 216;
                            }
                            while (&v60[v90] != v89);
                            uint64_t v88 = v102[5];
                          }
                          while ((unsigned char *)v88 != v60)
                            uint64_t v88 = sub_1003DAC14(v88 - 216);
                          v102[5] = v60;
                        }
                        *(void *)&long long buf = &v124;
                        sub_1002B2AEC((void ***)&buf);
                        sub_1013D1C40(v100);
                        sub_10078CC0C((uint64_t)&v115);
                        goto LABEL_202;
                      }
                      goto LABEL_158;
                    }
                  }
                  else
                  {
                    if (!*(unsigned char *)(v75 + 23)) {
                      goto LABEL_183;
                    }
                    uint64_t v81 = 0;
                    while (*(unsigned __int8 *)(v75 + v81) == *((unsigned __int8 *)v78 + v81))
                    {
                      if (v79 == ++v81) {
                        goto LABEL_183;
                      }
                    }
                  }
                }
                v75 += 64;
                if (v75 == v74) {
                  goto LABEL_180;
                }
              }
            }
          }
        }
        else
        {
          unsigned int v23 = 0;
        }
        CFStringRef v71 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "Missing delegate to load from database!", (uint8_t *)&buf, 2u);
        }
LABEL_202:
        if (v23) {
          sub_10004D2C8(v23);
        }
        *(void *)&long long buf = &v103;
        sub_1002B2AEC((void ***)&buf);
        goto LABEL_205;
      }
      uint64_t v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
      if ((v12 & 0x80u) == 0) {
        std::string::size_type size = HIBYTE(v10->__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v10->__r_.__value_.__l.__size_;
      }
      uint64_t v14 = *(unsigned __int8 *)(v8 + 31);
      int v15 = (char)v14;
      if ((v14 & 0x80u) != 0) {
        uint64_t v14 = *(void *)(v8 + 16);
      }
      if (size == v14)
      {
        if (v15 >= 0) {
          int64_t v16 = (unsigned __int8 *)(v8 + 8);
        }
        else {
          int64_t v16 = *(unsigned __int8 **)(v8 + 8);
        }
        if ((v12 & 0x80) != 0)
        {
          if (memcmp(v10->__r_.__value_.__l.__data_, v16, v10->__r_.__value_.__l.__size_)) {
            goto LABEL_42;
          }
        }
        else if (*((unsigned char *)&v10->__r_.__value_.__s + 23))
        {
          uint64_t v17 = v10;
          while (v17->__r_.__value_.__s.__data_[0] == *v16)
          {
            uint64_t v17 = (const std::string *)((char *)v17 + 1);
            ++v16;
            if (!--v12) {
              goto LABEL_207;
            }
          }
          goto LABEL_42;
        }
LABEL_207:
        if (*(unsigned char *)(v8 + 168)) {
          goto LABEL_46;
        }
        uint64_t v19 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          uint64_t v20 = "#I Previous quick switched device is now in proximity";
          goto LABEL_44;
        }
        goto LABEL_45;
      }
LABEL_42:
      uint64_t v19 = *(NSObject **)(v3 + 48);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        uint64_t v20 = "#I Devices in proximity changed";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
  }
}

void sub_10078AA7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char *a40,uint64_t a41,uint64_t a42,char a43)
{
  a40 = &a18;
  sub_1002B2AEC((void ***)&a40);
  sub_10004D2C8(a10);
  _Unwind_Resume(a1);
}

void *sub_10078AB50(void *a1, void *a2)
{
  uint64_t v2 = a2[6];
  a1[5] = a2[5];
  a1[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  return sub_1003C1BB8(a1 + 7, a2[7], a2[8], (uint64_t)(a2[8] - a2[7]) >> 6);
}

void sub_10078ABA8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10078ABC0(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 56);
  sub_1002B2AEC(&v3);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_10078AC04(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10078AC20(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10078AC30(uint64_t a1, long long *a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  void v6[2] = sub_10078AE6C;
  void v6[3] = &unk_101A05FE8;
  long long v5 = *(_OWORD *)(a1 + 32);
  long long v7 = v5;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v8 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v9, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    uint64_t v10 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v12 = *((void *)a2 + 5);
  }
  __int16 v13 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v14, (const void **)a2 + 7);
  sub_100119B5C(&v15, (const void **)a2 + 8);
  v16[0] = *((void *)a2 + 9);
  *(void *)((char *)v16 + 6) = *(void *)((char *)a2 + 78);
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_10003E168(&v19, (void *)(v5 + 16));
  long long v4 = *(NSObject **)(v5 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_10078C7D8;
  block[3] = &unk_101A06148;
  block[5] = v19;
  int v18 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v4, block);
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  sub_1000FE824(&v15);
  sub_100030068(&v14);
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)v9);
  }
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_10078AE38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_10078AE6C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (*(void *)(a1 + 40))
      {
        long long v6 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          long long v7 = (void *)(a1 + 56);
          if (*(char *)(a1 + 79) < 0) {
            long long v7 = (void *)*v7;
          }
          int v8 = 136315138;
          long long v9 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received local IDS Message from [%s]", (uint8_t *)&v8, 0xCu);
        }
        sub_1013CF5F4((uint64_t **)v3, a1 + 56);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10078AF54(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_10078AF68(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  long long v6 = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)long long v6 = v7;
  }
  *(_WORD *)(a1 + 104) = *(_WORD *)(a2 + 104);
  sub_10002FD9C((const void **)(a1 + 112), (const void **)(a2 + 112));
  __n128 result = sub_100119B5C((const void **)(a1 + 120), (const void **)(a2 + 120));
  uint64_t v9 = *(void *)(a2 + 128);
  *(void *)(a1 + 134) = *(void *)(a2 + 134);
  *(void *)(a1 + 128) = v9;
  return result;
}

void sub_10078B038(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 48);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_10078B068(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 120));
  sub_100030068((const void **)(a1 + 112));
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

BOOL sub_10078B0DC(id a1, const void *a2)
{
  return sub_100789AB4((uint64_t)a2);
}

void sub_10078B0E8(uint64_t a1, long long *a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  void v6[2] = sub_10078B324;
  void v6[3] = &unk_101A060C8;
  long long v5 = *(_OWORD *)(a1 + 32);
  long long v7 = v5;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  int v8 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v9, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    uint64_t v10 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v12 = *((void *)a2 + 5);
  }
  __int16 v13 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v14, (const void **)a2 + 7);
  sub_100119B5C(&v15, (const void **)a2 + 8);
  v16[0] = *((void *)a2 + 9);
  *(void *)((char *)v16 + 6) = *(void *)((char *)a2 + 78);
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_10003E168(&v19, (void *)(v5 + 16));
  uint64_t v4 = *(NSObject **)(v5 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_10078C7D8;
  block[3] = &unk_101A06148;
  block[5] = v19;
  int v18 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v4, block);
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  sub_1000FE824(&v15);
  sub_100030068(&v14);
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)v9);
  }
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_10078B2F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_10078B324(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (*(void *)(a1 + 40))
      {
        long long v6 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          long long v7 = (void *)(a1 + 56);
          if (*(char *)(a1 + 79) < 0) {
            long long v7 = (void *)*v7;
          }
          int v8 = 136315138;
          long long v9 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received internet IDS Message from [%s]", (uint8_t *)&v8, 0xCu);
        }
        sub_1013CF5F4((uint64_t **)v3, a1 + 56);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10078B40C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10078B420(void *a1)
{
  uint64_t v1 = (const std::string *)a1[12];
  uint64_t v2 = (const std::string *)a1[13];
  if (v1 != v2)
  {
    while (!v1[1].__r_.__value_.__s.__data_[1])
    {
      uint64_t v1 = (const std::string *)((char *)v1 + 64);
      if (v1 == v2) {
        return;
      }
    }
  }
  if (v1 != v2) {
    sub_1013D1334(a1, v1);
  }
}

uint64_t sub_10078B454(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 248));
}

void sub_10078B45C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  memset(v3, 0, sizeof(v3));
  sub_1000C1BB8(a3, (uint64_t)v3, 17);
  uint64_t v4 = (void **)v3;
  sub_1000C5238(&v4);
}

void sub_10078B4A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_1000C5238(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10078B4C4(void *a1, uint64_t a2)
{
  uint64_t v3 = (void *)a1[16];
  if (!v3) {
    goto LABEL_20;
  }
  uint64_t v4 = a1 + 16;
  do
  {
    uint64_t v5 = 0;
    do
    {
      unsigned int v6 = *((unsigned __int8 *)v3 + v5 + 32);
      unsigned int v7 = *(unsigned __int8 *)(a2 + v5);
    }
    while (v6 == v7 && v5++ != 15);
    long long v9 = v3 + 1;
    if (v6 >= v7)
    {
      long long v9 = v3;
      uint64_t v4 = v3;
    }
    uint64_t v3 = (void *)*v9;
  }
  while (*v9);
  if (v4 == a1 + 16) {
    goto LABEL_20;
  }
  uint64_t v10 = 0;
  do
  {
    unsigned int v11 = *(unsigned __int8 *)(a2 + v10);
    unsigned int v12 = *((unsigned __int8 *)v4 + v10 + 32);
  }
  while (v11 == v12 && v10++ != 15);
  if (v11 >= v12)
  {
    uint64_t v17 = (unsigned __int8 *)a1[12];
    int v18 = (unsigned __int8 *)a1[13];
    if (v17 == v18)
    {
LABEL_46:
      if (v17 != v18)
      {
        if (!v17[25] || !v17[24]) {
          return 1;
        }
        return 2;
      }
    }
    else
    {
      uint64_t v19 = (const void **)(v4 + 6);
      uint64_t v20 = *((unsigned __int8 *)v4 + 71);
      size_t v21 = v4[7];
      if ((v20 & 0x80u) == 0) {
        uint64_t v22 = *((unsigned __int8 *)v4 + 71);
      }
      else {
        uint64_t v22 = v4[7];
      }
      do
      {
        uint64_t v23 = v17[23];
        int v24 = (char)v23;
        if ((v23 & 0x80u) != 0) {
          uint64_t v23 = *((void *)v17 + 1);
        }
        if (v22 == v23)
        {
          if (v24 >= 0) {
            int v25 = v17;
          }
          else {
            int v25 = *(unsigned __int8 **)v17;
          }
          if ((v20 & 0x80) != 0)
          {
            if (!memcmp(*v19, v25, v21)) {
              goto LABEL_46;
            }
          }
          else
          {
            if (!v20) {
              goto LABEL_46;
            }
            char v26 = v19;
            uint64_t v27 = v20;
            while (*(unsigned __int8 *)v26 == *v25)
            {
              char v26 = (const void **)((char *)v26 + 1);
              ++v25;
              if (!--v27) {
                goto LABEL_46;
              }
            }
          }
        }
        v17 += 64;
      }
      while (v17 != v18);
    }
    uint64_t v14 = a1[6];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      sCardSerialNumberAsString();
      if (v31 >= 0) {
        long long v29 = __p;
      }
      else {
        long long v29 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136315138;
      CFTypeRef v33 = v29;
      int64_t v16 = "#E Device not found for %s";
      goto LABEL_25;
    }
  }
  else
  {
LABEL_20:
    uint64_t v14 = a1[6];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      sCardSerialNumberAsString();
      if (v31 >= 0) {
        int v15 = __p;
      }
      else {
        int v15 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136315138;
      CFTypeRef v33 = v15;
      int64_t v16 = "#E %s not found";
LABEL_25:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v16, buf, 0xCu);
      if (v31 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  return 2;
}

void sub_10078B748(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t sub_10078B754()
{
  return 8;
}

void *sub_10078B75C@<X0>(void *result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (a2 == 1)
  {
    uint64_t v4 = result[42];
    uint64_t v3 = result[43];
  }
  else
  {
    uint64_t v4 = result[40];
    uint64_t v3 = result[41];
  }
  *a3 = v4;
  a3[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10078B788(void *a1, unsigned __int8 *a2, unsigned char *a3)
{
  v24[0] = 1;
  v24[1] = a1 + 33;
  uint64_t v6 = a1[37];
  uint64_t v7 = a1[38];
  if (v6 == v7)
  {
LABEL_20:
    if (v6 != v7)
    {
      unsigned __int8 v17 = a3[1] ? *a3 : 0;
      *(_DWORD *)(v6 + 172) = v17;
      int v18 = a1[6];
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = (char)a2[23];
        uint64_t v20 = *(unsigned __int8 **)a2;
        uint64_t v21 = asString();
        if (v19 >= 0) {
          uint64_t v22 = a2;
        }
        else {
          uint64_t v22 = v20;
        }
        *(_DWORD *)long long buf = 136315394;
        char v26 = v22;
        __int16 v27 = 2080;
        uint64_t v28 = v21;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Device (%s), first unlock done: %s", buf, 0x16u);
      }
    }
  }
  else
  {
    uint64_t v8 = a2[23];
    uint64_t v10 = *(const void **)a2;
    size_t v9 = *((void *)a2 + 1);
    if ((v8 & 0x80u) == 0) {
      uint64_t v11 = a2[23];
    }
    else {
      uint64_t v11 = *((void *)a2 + 1);
    }
    do
    {
      uint64_t v12 = *(unsigned __int8 *)(v6 + 31);
      int v13 = (char)v12;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(v6 + 16);
      }
      if (v11 == v12)
      {
        if (v13 >= 0) {
          uint64_t v14 = (unsigned __int8 *)(v6 + 8);
        }
        else {
          uint64_t v14 = *(unsigned __int8 **)(v6 + 8);
        }
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(v10, v14, v9)) {
            goto LABEL_20;
          }
        }
        else
        {
          if (!v8) {
            goto LABEL_20;
          }
          int v15 = a2;
          uint64_t v16 = v8;
          while (*v15 == *v14)
          {
            ++v15;
            ++v14;
            if (!--v16) {
              goto LABEL_20;
            }
          }
        }
      }
      v6 += 216;
    }
    while (v6 != v7);
  }
  return sub_10078CC0C((uint64_t)v24);
}

void sub_10078B944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10078B958(void *a1, std::string *__str, std::string *a3, __int16 a4, uint64_t *a5)
{
  uint64_t v56 = 1;
  int v57 = a1 + 33;
  unint64_t v9 = a1[37];
  unint64_t v10 = a1[38];
  if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__p, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = *__str;
  }
  uint64_t v11 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if (v9 != v10)
  {
    long long v12 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    do
    {
      uint64_t v14 = *(unsigned __int8 *)(v9 + 31);
      int v15 = (char)v14;
      if ((v14 & 0x80u) != 0) {
        uint64_t v14 = *(void *)(v9 + 16);
      }
      if (size == v14)
      {
        if (v15 >= 0) {
          uint64_t v16 = (unsigned __int8 *)(v9 + 8);
        }
        else {
          uint64_t v16 = *(unsigned __int8 **)(v9 + 8);
        }
        if ((v11 & 0x80) != 0)
        {
          if (!memcmp((const void *)v12, v16, *((size_t *)&v12 + 1))) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!v11) {
            goto LABEL_25;
          }
          p_p = &__p;
          uint64_t v18 = v11;
          while (p_p->__r_.__value_.__s.__data_[0] == *v16)
          {
            p_p = (std::string *)((char *)p_p + 1);
            ++v16;
            if (!--v18) {
              goto LABEL_23;
            }
          }
        }
      }
      v9 += 216;
    }
    while (v9 != v10);
    unint64_t v9 = v10;
  }
LABEL_23:
  if ((v11 & 0x80) != 0) {
LABEL_24:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_25:
  uint64_t v54 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  memset(__stra, 0, sizeof(__stra));
  std::string::operator=((std::string *)__stra, __str);
  WORD6(v53) = a4;
  DWORD2(v53) = 1;
  *(_DWORD *)&__stra[28] = 2;
  if (&v52 != (long long *)a5) {
    sub_1003DB294((uint64_t)&v52, *a5, a5[1], 0x2E8BA2E8BA2E8BA3 * ((a5[1] - *a5) >> 3));
  }
  uint64_t v19 = a1[12];
  uint64_t v20 = a1[13];
  if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(__dst, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)&__str->__r_.__value_.__l.__data_;
    int64_t v50 = __str->__r_.__value_.__r.__words[2];
  }
  char v21 = HIBYTE(v50);
  if (v19 != v20)
  {
    if (v50 >= 0) {
      uint64_t v22 = (void *)HIBYTE(v50);
    }
    else {
      uint64_t v22 = __dst[1];
    }
    if (v50 >= 0) {
      uint64_t v23 = __dst;
    }
    else {
      uint64_t v23 = (void **)__dst[0];
    }
    do
    {
      uint64_t v24 = *(unsigned __int8 *)(v19 + 23);
      if ((v24 & 0x80u) == 0) {
        int v25 = (void *)*(unsigned __int8 *)(v19 + 23);
      }
      else {
        int v25 = *(void **)(v19 + 8);
      }
      if (v25 == v22)
      {
        if ((v24 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v19, v23, *(void *)(v19 + 8))) {
            goto LABEL_50;
          }
        }
        else
        {
          if (!*(unsigned char *)(v19 + 23)) {
            goto LABEL_50;
          }
          uint64_t v26 = 0;
          while (*(unsigned __int8 *)(v19 + v26) == *((unsigned __int8 *)v23 + v26))
          {
            if (v24 == ++v26) {
              goto LABEL_50;
            }
          }
        }
      }
      v19 += 64;
    }
    while (v19 != v20);
    uint64_t v19 = v20;
  }
LABEL_50:
  if (v21 < 0) {
    operator delete(__dst[0]);
  }
  if (v19 == a1[13])
  {
    uint64_t v28 = a1[6];
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Cannot find IDS device (potentially missing OS Version & Model Identifier) - continue", (uint8_t *)&buf, 2u);
    }
    char v27 = 0;
  }
  else
  {
    LODWORD(v54) = *(_DWORD *)(v19 + 56);
    if (a3[5].__r_.__value_.__s.__data_[16]) {
      std::string::operator=(a3 + 4, (const std::string *)(v19 + 32));
    }
    char v27 = *(unsigned char *)(v19 + 24);
  }
  __stra[24] = v27;
  long long v29 = v57;
  uint64_t v30 = v57[5];
  char v31 = a1[6];
  BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
  if (v9 == v30)
  {
    if (v32)
    {
      if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v35 = __str;
      }
      else {
        uint64_t v35 = (std::string *)__str->__r_.__value_.__r.__words[0];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v35;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I New family device found: (%s)", (uint8_t *)&buf, 0xCu);
      long long v29 = v57;
      unint64_t v9 = v57[5];
    }
    unint64_t v36 = v29[6];
    if (v9 >= v36)
    {
      uint64_t v38 = v29[4];
      unint64_t v39 = 0x84BDA12F684BDA13 * ((uint64_t)(v9 - v38) >> 3);
      if (v39 + 1 > 0x12F684BDA12F684) {
        sub_10006A748();
      }
      unint64_t v40 = 0x84BDA12F684BDA13 * ((uint64_t)(v36 - v38) >> 3);
      uint64_t v41 = 2 * v40;
      if (2 * v40 <= v39 + 1) {
        uint64_t v41 = v39 + 1;
      }
      if (v40 >= 0x97B425ED097B42) {
        unint64_t v42 = 0x12F684BDA12F684;
      }
      else {
        unint64_t v42 = v41;
      }
      uint64_t v61 = v29 + 6;
      if (v42) {
        unint64_t v43 = (char *)sub_1000C5FD0((uint64_t)(v29 + 6), v42);
      }
      else {
        unint64_t v43 = 0;
      }
      unint64_t v44 = &v43[216 * v39];
      *(void *)&long long buf = v43;
      *((void *)&buf + 1) = v44;
      uint64_t v60 = &v43[216 * v42];
      *(_OWORD *)unint64_t v44 = 0u;
      *((_OWORD *)v44 + 1) = 0u;
      *((_OWORD *)v44 + 2) = 0u;
      *((_OWORD *)v44 + 3) = 0u;
      *((_OWORD *)v44 + 4) = 0u;
      *((_OWORD *)v44 + 5) = 0u;
      *((_OWORD *)v44 + 6) = 0u;
      *((_OWORD *)v44 + 7) = 0u;
      *((_OWORD *)v44 + 8) = 0u;
      *((_OWORD *)v44 + 9) = 0u;
      *((_OWORD *)v44 + 10) = 0u;
      *((_OWORD *)v44 + 11) = 0u;
      *((_OWORD *)v44 + 12) = 0u;
      *((void *)v44 + 26) = 0;
      long long v59 = v44 + 216;
      sub_10078C504(v29 + 4, &buf);
      uint64_t v37 = v29[5];
      sub_10078C610((uint64_t)&buf);
    }
    else
    {
      *(void *)(v9 + 208) = 0;
      *(_OWORD *)(v9 + 176) = 0u;
      *(_OWORD *)(v9 + 192) = 0u;
      *(_OWORD *)(v9 + 144) = 0u;
      *(_OWORD *)(v9 + 160) = 0u;
      *(_OWORD *)(v9 + 112) = 0u;
      *(_OWORD *)(v9 + 128) = 0u;
      *(_OWORD *)(v9 + 80) = 0u;
      *(_OWORD *)(v9 + 96) = 0u;
      *(_OWORD *)(v9 + 48) = 0u;
      *(_OWORD *)(v9 + 64) = 0u;
      *(_OWORD *)(v9 + 16) = 0u;
      *(_OWORD *)(v9 + 32) = 0u;
      *(_OWORD *)unint64_t v9 = 0u;
      uint64_t v37 = v9 + 216;
      void v29[5] = v9 + 216;
    }
    void v29[5] = v37;
    BOOL v45 = v19 != a1[13] && *(unsigned char *)(v19 + 25) != 0;
    *(unsigned char *)(v37 - 216) = v45;
    std::string::operator=((std::string *)(v37 - 72), (const std::string *)__stra);
    *(void *)(v37 - 48) = *(void *)&__stra[24];
    if ((unsigned char *)(v37 - 72) != __stra) {
      sub_1003DB294(v37 - 40, v52, *((uint64_t *)&v52 + 1), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)&v52 + 1) - v52) >> 3));
    }
    uint64_t v46 = *((void *)&v53 + 1);
    *(_DWORD *)(v37 - 8) = v54;
    *(void *)(v37 - 16) = v46;
    if (a3[5].__r_.__value_.__s.__data_[16]) {
      cellplan::RemoteDeviceIdentifiers::operator=();
    }
    else {
      std::string::operator=((std::string *)(v37 - 208), __str);
    }
  }
  else
  {
    if (v32)
    {
      if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFTypeRef v33 = __str;
      }
      else {
        CFTypeRef v33 = (std::string *)__str->__r_.__value_.__r.__words[0];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v33;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I updaing family device: (%s)", (uint8_t *)&buf, 0xCu);
    }
    BOOL v34 = v19 != a1[13] && *(unsigned char *)(v19 + 25) != 0;
    *(unsigned char *)unint64_t v9 = v34;
    std::string::operator=((std::string *)(v9 + 144), (const std::string *)__stra);
    *(void *)(v9 + 168) = *(void *)&__stra[24];
    if ((unsigned char *)(v9 + 144) != __stra) {
      sub_1003DB294(v9 + 176, v52, *((uint64_t *)&v52 + 1), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)&v52 + 1) - v52) >> 3));
    }
    *(void *)(v9 + 200) = *((void *)&v53 + 1);
    *(_DWORD *)(v9 + 208) = v54;
    if (a3[5].__r_.__value_.__s.__data_[16])
    {
      if (a3[5].__r_.__value_.__s.__data_[0]) {
        *(void *)(v9 + 128) = a3[5].__r_.__value_.__l.__data_;
      }
      if (a3[5].__r_.__value_.__s.__data_[8]) {
        *(void *)(v9 + 136) = a3[5].__r_.__value_.__l.__size_;
      }
      if (a3[2].__r_.__value_.__s.__data_[8]) {
        sub_1003DC1E4(v9 + 64, (uint64_t)&a3[2].__r_.__value_.__l.__size_);
      }
      if (a3[1].__r_.__value_.__s.__data_[0]) {
        sub_1003DC1E4(v9 + 32, (uint64_t)&a3[1]);
      }
      if (a3[3].__r_.__value_.__s.__data_[16]) {
        *(unsigned char *)(v9 + 96) = a3[3].__r_.__value_.__s.__data_[16];
      }
    }
  }
  *(void *)&long long buf = &v52;
  sub_1000C56F4((void ***)&buf);
  if ((__stra[23] & 0x80000000) != 0) {
    operator delete(*(void **)__stra);
  }
  return sub_10078CC0C((uint64_t)&v56);
}

void sub_10078BFFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_10078C610(v29 - 144);
  sub_1003CC6D4((uint64_t)&a15);
  sub_10078CC0C((uint64_t)&a29);
  _Unwind_Resume(a1);
}

uint64_t sub_10078C038(uint64_t a1, uint64_t a2, __int16 a3)
{
  v18[0] = 1;
  v18[1] = a1 + 264;
  uint64_t v4 = *(void *)(a1 + 296);
  uint64_t v5 = *(void *)(a1 + 304);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v17 = *(void *)(a2 + 16);
  }
  uint64_t v6 = HIBYTE(v17);
  if (v4 != v5)
  {
    uint64_t v8 = __p[0];
    uint64_t v7 = __p[1];
    if (v17 >= 0) {
      unint64_t v9 = (void *)HIBYTE(v17);
    }
    else {
      unint64_t v9 = __p[1];
    }
    do
    {
      unint64_t v10 = (void *)*(unsigned __int8 *)(v4 + 31);
      int v11 = (char)v10;
      if ((char)v10 < 0) {
        unint64_t v10 = *(void **)(v4 + 16);
      }
      if (v9 == v10)
      {
        if (v11 >= 0) {
          long long v12 = (unsigned __int8 *)(v4 + 8);
        }
        else {
          long long v12 = *(unsigned __int8 **)(v4 + 8);
        }
        if ((v6 & 0x80) != 0)
        {
          if (!memcmp(v8, v12, (size_t)v7)) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!v6) {
            goto LABEL_25;
          }
          int v13 = __p;
          uint64_t v14 = v6;
          while (*(unsigned __int8 *)v13 == *v12)
          {
            int v13 = (void **)((char *)v13 + 1);
            ++v12;
            if (!--v14) {
              goto LABEL_23;
            }
          }
        }
      }
      v4 += 216;
    }
    while (v4 != v5);
    uint64_t v4 = v5;
  }
LABEL_23:
  if ((v6 & 0x80) != 0) {
LABEL_24:
  }
    operator delete(__p[0]);
LABEL_25:
  *(_WORD *)(v4 + 204) = a3;
  return sub_10078CC0C((uint64_t)v18);
}

void sub_10078C168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10078CC0C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10078C17C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = 1;
  uint64_t v28 = a1 + 33;
  uint64_t v6 = a1[37];
  uint64_t v7 = a1[38];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v26 = *(void *)(a2 + 16);
  }
  uint64_t v8 = HIBYTE(v26);
  if (v6 != v7)
  {
    unint64_t v10 = __p[0];
    unint64_t v9 = __p[1];
    if (v26 >= 0) {
      int v11 = (void *)HIBYTE(v26);
    }
    else {
      int v11 = __p[1];
    }
    do
    {
      long long v12 = (void *)*(unsigned __int8 *)(v6 + 31);
      int v13 = (char)v12;
      if ((char)v12 < 0) {
        long long v12 = *(void **)(v6 + 16);
      }
      if (v11 == v12)
      {
        if (v13 >= 0) {
          uint64_t v14 = (unsigned __int8 *)(v6 + 8);
        }
        else {
          uint64_t v14 = *(unsigned __int8 **)(v6 + 8);
        }
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(v10, v14, (size_t)v9)) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!v8) {
            goto LABEL_25;
          }
          int v15 = __p;
          uint64_t v16 = v8;
          while (*(unsigned __int8 *)v15 == *v14)
          {
            int v15 = (void **)((char *)v15 + 1);
            ++v14;
            if (!--v16) {
              goto LABEL_23;
            }
          }
        }
      }
      v6 += 216;
    }
    while (v6 != v7);
    uint64_t v6 = v7;
  }
LABEL_23:
  if ((v8 & 0x80) != 0) {
LABEL_24:
  }
    operator delete(__p[0]);
LABEL_25:
  if (v6 == v28[5])
  {
    uint64_t v22 = a1[6];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v24 = (void *)a2;
      }
      else {
        uint64_t v24 = *(void **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      char v31 = v24;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Cannot find family device (%s) - aborting", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v17 = *(void *)(v6 + 176);
    for (uint64_t i = *(void *)(v6 + 184); v17 != i; v17 += 88)
    {
      sub_1000C5DA8((uint64_t)buf, v17);
      BOOL v20 = v32 != *(void *)(a3 + 16) || v33 != *(void *)(a3 + 24);
      if (v36[24])
      {
        uint64_t v29 = (void **)v36;
        sub_1000C57C8(&v29);
      }
      if (v35 < 0)
      {
        operator delete(v34);
        if (!v20)
        {
LABEL_39:
          long long v21 = *(_OWORD *)(a3 + 16);
          *(_OWORD *)uint64_t v17 = *(_OWORD *)a3;
          *(_OWORD *)(v17 + 16) = v21;
          std::string::operator=((std::string *)(v17 + 32), (const std::string *)(a3 + 32));
          sub_1000C86CC(v17 + 56, a3 + 56);
        }
      }
      else if (!v20)
      {
        goto LABEL_39;
      }
    }
  }
  return sub_10078CC0C((uint64_t)&v27);
}

void sub_10078C3E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10078CC0C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10078C404(uint64_t a1)
{
  sub_10078C660(a1);

  operator delete();
}

uint64_t sub_10078C43C(uint64_t a1)
{
  return sub_10078C660(a1 - 8);
}

void sub_10078C444(uint64_t a1)
{
  sub_10078C660(a1 - 8);

  operator delete();
}

void *sub_10078C480(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10078C504(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10078C57C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10078C57C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0;
  uint64_t v11 = a7 - 216;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 216;
    sub_1003DB738(v12, v10 + a3);
  }
  return a6;
}

uint64_t sub_10078C610(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 216;
    sub_1003DAC14(i - 216);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10078C660(uint64_t a1)
{
  *(void *)a1 = off_101A05DE8;
  *(void *)(a1 + 8) = &off_101A05F18;
  uint64_t v6 = (void **)(a1 + 352);
  sub_1003DACB8(&v6);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 344);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 328);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v6 = (void **)(a1 + 296);
  sub_1003DACB8(&v6);
  sub_10078C480((void *)(a1 + 264));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 256);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return sub_1013BD63C(a1);
}

uint64_t **sub_10078C71C(uint64_t **a1, int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    sub_100046C38(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t sub_10078C7D8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10078C7E8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10078C804(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10078C818()
{
}

void *sub_10078C82C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A06188;
  result[1] = v3;
  return result;
}

uint64_t sub_10078C874(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A06188;
  a2[1] = v2;
  return result;
}

void sub_10078C8A0(uint64_t a1, uint64_t *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  while (v6 != v5)
  {
    cellplan::write_rest_value();
    xpc_array_append_value(v4, value[0]);
    xpc_release(value[0]);
    v6 += 216;
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v7 = v4;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(value, "/cc/props/family_provisioning_device_info");
  xpc_object_t object = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v10 < 0) {
    operator delete(value[0]);
  }
  xpc_release(v7);
}

void sub_10078CA04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_10078CA88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10078CAC8()
{
}

void sub_10078CAD8()
{
}

__n128 sub_10078CAEC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A06218;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10078CB40(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A06218;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10078CB78(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  xpc_object_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10078CBC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10078CC00()
{
}

uint64_t sub_10078CC0C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_10078CC70()
{
  qword_101B0D740 = 0;
  qword_101B0D748 = 0;
  qword_101B0D750 = 0;
  xpc_object_t v0 = operator new(0xB0uLL);
  qword_101B0D750 = (uint64_t)(v0 + 11);
  v0[8] = *(_OWORD *)off_101A05DA8;
  v0[9] = *(_OWORD *)off_101A05DB8;
  v0[10] = *(_OWORD *)off_101A05DC8;
  v0[4] = *(_OWORD *)off_101A05D68;
  v0[5] = *(_OWORD *)off_101A05D78;
  v0[6] = *(_OWORD *)off_101A05D88;
  v0[7] = *(_OWORD *)off_101A05D98;
  *xpc_object_t v0 = *(_OWORD *)off_101A05D28;
  v0[1] = *(_OWORD *)off_101A05D38;
  v0[2] = *(_OWORD *)off_101A05D48;
  v0[3] = *(_OWORD *)off_101A05D58;
  qword_101B0D740 = (uint64_t)v0;
  qword_101B0D748 = (uint64_t)(v0 + 11);

  return __cxa_atexit((void (*)(void *))sub_100788FC0, &qword_101B0D740, (void *)&_mh_execute_header);
}

uint64_t sub_10078CD14(uint64_t a1, uint64_t a2)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, "stw.mode");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, &v6);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  *(void *)a1 = off_101A06298;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = 0;
  *(_WORD *)(a1 + 28) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 57) = 0u;
  xpc_object_t v4 = operator new(0x20uLL);
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = off_1019B3378;
  *((unsigned char *)v4 + 24) = 1;
  *(void *)(a1 + 80) = v4 + 3;
  *(void *)(a1 + 88) = v4;
  return a1;
}

void sub_10078CE00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  *(void *)(v12 + 48) = 0;
  ctu::OsLogLogger::~OsLogLogger(v13);
  _Unwind_Resume(a1);
}

void sub_10078CE38()
{
}

void sub_10078CE9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  sub_10078DCA8((uint64_t)&a10, v10);
  _Unwind_Resume(a1);
}

void sub_10078CED8()
{
}

uint64_t sub_10078CF7C(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 25) != a2)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v5 = (*(uint64_t (**)(void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48));
      if (v5 > 4) {
        OsLogContext v6 = "???";
      }
      else {
        OsLogContext v6 = off_101A06390[v5];
      }
      xpc_object_t v7 = "Exit";
      if (a2) {
        xpc_object_t v7 = "Enter";
      }
      int v8 = 136315394;
      int v9 = v6;
      __int16 v10 = 2080;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s Stewie mode %s requested", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(v3 + 25) = a2;
    return (*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 24))(*(void *)(v3 + 48), 0);
  }
  return result;
}

uint64_t sub_10078D0CC(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 24) != a2)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v5 = (*(uint64_t (**)(void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48));
      if (v5 > 4) {
        OsLogContext v6 = "???";
      }
      else {
        OsLogContext v6 = off_101A06390[v5];
      }
      xpc_object_t v7 = "other";
      if (a2) {
        xpc_object_t v7 = "stewie";
      }
      int v8 = 136315394;
      int v9 = v6;
      __int16 v10 = 2080;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s Radio operating mode changed to: %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(v3 + 24) = a2;
    return (*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 24))(*(void *)(v3 + 48), 0);
  }
  return result;
}

uint64_t sub_10078D21C(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 26) != a2)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v5 = (*(uint64_t (**)(void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48));
      if (v5 > 4) {
        OsLogContext v6 = "???";
      }
      else {
        OsLogContext v6 = off_101A06390[v5];
      }
      xpc_object_t v7 = "no";
      if (a2) {
        xpc_object_t v7 = "yes";
      }
      int v8 = 136315394;
      int v9 = v6;
      __int16 v10 = 2080;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s InEmergency changed to: %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(v3 + 26) = a2;
    return (*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 24))(*(void *)(v3 + 48), 0);
  }
  return result;
}

void sub_10078D36C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 27))
  {
    uint64_t v2 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
      if (v3 > 4) {
        xpc_object_t v4 = "???";
      }
      else {
        xpc_object_t v4 = off_101A06390[v3];
      }
      int v5 = 136315138;
      OsLogContext v6 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s Resetting failures", (uint8_t *)&v5, 0xCu);
    }
    *(unsigned char *)(a1 + 27) = 0;
  }
}

void sub_10078D45C(uint64_t a1)
{
  if (*(void *)(a1 + 56)) {
    return;
  }
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    if (v3 > 4) {
      xpc_object_t v4 = "???";
    }
    else {
      xpc_object_t v4 = off_101A06390[v3];
    }
    LODWORD(v13) = 136315138;
    *(void *)((char *)&v13 + 4) = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s Acquiring stewie mode assertion", (uint8_t *)&v13, 0xCu);
  }
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 16) + 16))(&v13);
  long long v5 = v13;
  long long v13 = 0uLL;
  OsLogContext v6 = *(std::__shared_weak_count **)(a1 + 64);
  *(_OWORD *)(a1 + 56) = v5;
  if (v6)
  {
    sub_10004D2C8(v6);
    if (*((void *)&v13 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
    }
    if (*(void *)(a1 + 56)) {
      goto LABEL_11;
    }
  }
  else if ((void)v5)
  {
LABEL_11:
    uint64_t v8 = *(void *)(a1 + 80);
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
    }
    int v9 = operator new(0x20uLL);
    *int v9 = off_101A06320;
    v9[1] = a1;
    _DWORD v9[2] = v8;
    void v9[3] = v7;
    uint64_t v14 = v9;
    ctu::rest::AssertionHandle::setHandler_impl();
    sub_100060644(&v13);
    return;
  }
  __int16 v10 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    unsigned int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    if (v11 > 4) {
      uint64_t v12 = "???";
    }
    else {
      uint64_t v12 = off_101A06390[v11];
    }
    LODWORD(v13) = 136315138;
    *(void *)((char *)&v13 + 4) = v12;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%s Failed to acquire stewie mode assertion", (uint8_t *)&v13, 0xCu);
  }
}

void sub_10078D6A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10078D6D0(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v2 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
      if (v3 > 4) {
        xpc_object_t v4 = "???";
      }
      else {
        xpc_object_t v4 = off_101A06390[v3];
      }
      int v6 = 136315138;
      uint64_t v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s Releasing stewie mode assertion", (uint8_t *)&v6, 0xCu);
    }
    if (*(unsigned char *)(a1 + 29)) {
      *(unsigned char *)(a1 + 29) = 0;
    }
    long long v5 = *(std::__shared_weak_count **)(a1 + 64);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
}

void sub_10078D7D8(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    uint64_t v2 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
      if (v3 > 4) {
        xpc_object_t v4 = "???";
      }
      else {
        xpc_object_t v4 = off_101A06390[v3];
      }
      int v6 = 136315138;
      uint64_t v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s Releasing GPS disablement assertion", (uint8_t *)&v6, 0xCu);
    }
    long long v5 = *(std::__shared_weak_count **)(a1 + 40);
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_10078D8D4(uint64_t result)
{
  if (!*(unsigned char *)(result + 27))
  {
    uint64_t v1 = result;
    __n128 result = (*(uint64_t (**)(void))(**(void **)(result + 48) + 16))(*(void *)(result + 48));
    int v2 = result == 3;
    if (*(unsigned __int8 *)(v1 + 72) != v2)
    {
      int v3 = result;
      xpc_object_t v4 = *(NSObject **)(v1 + 8);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v5 = (*(uint64_t (**)(void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48));
        if (v5 > 4) {
          int v6 = "???";
        }
        else {
          int v6 = off_101A06390[v5];
        }
        uint64_t v7 = "no";
        if (v3 == 3) {
          uint64_t v7 = "yes";
        }
        int v8 = 136315394;
        int v9 = v6;
        __int16 v10 = 2080;
        unsigned int v11 = v7;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s Notifying delegate about stewie mode [active = %s]", (uint8_t *)&v8, 0x16u);
      }
      *(unsigned char *)(v1 + 72) = v2;
      return (*(uint64_t (**)(void, BOOL))(**(void **)(v1 + 16) + 24))(*(void *)(v1 + 16), v3 == 3);
    }
  }
  return result;
}

uint64_t sub_10078DA60(uint64_t result)
{
  if (!*(unsigned char *)(result + 27))
  {
    uint64_t v1 = result;
    *(unsigned char *)(result + 27) = 1;
    *(unsigned char *)(result + 72) = 0;
    *(unsigned char *)(result + 25) = 0;
    int v2 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48));
      if (v3 > 4) {
        xpc_object_t v4 = "???";
      }
      else {
        xpc_object_t v4 = off_101A06390[v3];
      }
      int v5 = 136315138;
      int v6 = v4;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%s Notifying delegate of failure", (uint8_t *)&v5, 0xCu);
    }
    return (*(uint64_t (**)(void))(**(void **)(v1 + 16) + 32))(*(void *)(v1 + 16));
  }
  return result;
}

void *sub_10078DB88(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unsigned int v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = a1[6];
  a1[6] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  int v5 = (std::__shared_weak_count *)a1[5];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_10078DC08(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unsigned int v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = a1[6];
  a1[6] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  int v5 = (std::__shared_weak_count *)a1[5];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  operator delete();
}

void sub_10078DCA8(uint64_t a1, void *a2)
{
  if (a2)
  {
    unsigned int v3 = (std::__shared_weak_count *)a2[11];
    if (v3) {
      sub_10004D2C8(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)a2[8];
    if (v4) {
      sub_10004D2C8(v4);
    }
    uint64_t v5 = a2[6];
    a2[6] = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    int v6 = (std::__shared_weak_count *)a2[5];
    if (v6) {
      sub_10004D2C8(v6);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a2 + 1));
    operator delete();
  }
}

void *sub_10078DD50(void *a1)
{
  *a1 = off_101A06320;
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10078DD9C(void *a1)
{
  *a1 = off_101A06320;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10078DE08(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A06320;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10078DE6C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A06320;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10078DEAC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10078DEBC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10078DEFC(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        *(_WORD *)(v5 + 28) = v4 | 0x100;
        int v8 = *(NSObject **)(v5 + 8);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v9 = (*(uint64_t (**)(void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48));
          if (v9 > 4) {
            __int16 v10 = "???";
          }
          else {
            __int16 v10 = off_101A06390[v9];
          }
          unsigned int v11 = "";
          if (!v4) {
            unsigned int v11 = "not ";
          }
          int v12 = 136315394;
          long long v13 = v10;
          __int16 v14 = 2080;
          int v15 = v11;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s Stewie mode assertion: %sgranted", (uint8_t *)&v12, 0x16u);
        }
        (*(void (**)(void, void))(**(void **)(v5 + 48) + 24))(*(void *)(v5 + 48), 0);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10078E06C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10078E084(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10078E0C4()
{
}

void *sub_10078E0D0(void *a1, uint64_t *a2, NSObject **a3)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  *a1 = off_101A063C8;
  a1[1] = v5;
  a1[2] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  int v6 = *a3;
  a1[3] = *a3;
  if (v6) {
    dispatch_retain(v6);
  }
  a1[6] = 0;
  a1[5] = 0;
  a1[4] = a1 + 5;
  return a1;
}

void sub_10078E148(void *a1, int a2)
{
  uint64_t v4 = a1 + 5;
  uint64_t v3 = (uint64_t *)a1[5];
  if (v3)
  {
    uint64_t v5 = v4;
    int v6 = v3;
    do
    {
      int v7 = *((_DWORD *)v6 + 8);
      BOOL v8 = v7 < a2;
      if (v7 >= a2) {
        unsigned int v9 = (uint64_t **)v6;
      }
      else {
        unsigned int v9 = (uint64_t **)(v6 + 1);
      }
      if (!v8) {
        uint64_t v5 = v6;
      }
      int v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && *((_DWORD *)v5 + 8) <= a2)
    {
      __int16 v10 = v4;
      unsigned int v11 = v3;
      do
      {
        int v12 = *((_DWORD *)v11 + 8);
        BOOL v13 = v12 < a2;
        if (v12 >= a2) {
          __int16 v14 = (uint64_t **)v11;
        }
        else {
          __int16 v14 = (uint64_t **)(v11 + 1);
        }
        if (!v13) {
          __int16 v10 = v11;
        }
        unsigned int v11 = *v14;
      }
      while (*v14);
      if (v10 != v4 && *((_DWORD *)v10 + 8) <= a2)
      {
        int v15 = (uint64_t *)v10[1];
        if (v15)
        {
          do
          {
            uint64_t v16 = v15;
            int v15 = (uint64_t *)*v15;
          }
          while (v15);
        }
        else
        {
          uint64_t v17 = v10;
          do
          {
            uint64_t v16 = (uint64_t *)v17[2];
            BOOL v18 = *v16 == (void)v17;
            uint64_t v17 = v16;
          }
          while (!v18);
        }
        if ((uint64_t *)a1[4] == v10) {
          a1[4] = v16;
        }
        --a1[6];
        sub_10005EE6C(v3, v10);
        uint64_t v19 = (std::__shared_weak_count *)v10[6];
        if (v19) {
          sub_10004D2C8(v19);
        }
        operator delete(v10);
      }
    }
  }
}

void sub_10078E264(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2) {
    dispatch_retain(v2);
  }
  sub_1007D6704(&v3);
}

void sub_10078E37C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (v18) {
    dispatch_release(v18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_10078E3A8(uint64_t a1)
{
  __n128 result = sub_100256E84((uint64_t **)(*(void *)(a1 + 40) + 32), *(_DWORD *)(a1 + 48), (_DWORD *)(a1 + 48));
  if (result[5])
  {
    long long v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
    return (uint64_t **)v3();
  }
  return result;
}

BOOL sub_10078E428(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = a1 + 40;
  uint64_t v3 = v4;
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = v2;
  do
  {
    int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      BOOL v8 = (uint64_t *)v3;
    }
    else {
      BOOL v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == v2 || *(_DWORD *)(v5 + 32) > a2) {
LABEL_11:
  }
    uint64_t v5 = v2;
  return v5 != v2;
}

uint64_t sub_10078E474(uint64_t a1)
{
  *(void *)a1 = off_101A063C8;
  sub_100119D90(*(void **)(a1 + 40));
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_10078E4D4(uint64_t a1)
{
  *(void *)a1 = off_101A063C8;
  sub_100119D90(*(void **)(a1 + 40));
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void sub_10078E554(uint64_t a1, unsigned char *a2)
{
  if (a2)
  {
    LOBYTE(v4) = *a2;
    if (*a2)
    {
      unsigned int v5 = 1;
      do
      {
        std::string::push_back((std::string *)(a1 + 8), v4);
        int v4 = a2[v5++];
      }
      while (v4);
    }
  }

  std::string::push_back((std::string *)(a1 + 8), 0);
}

void sub_10078E5C4(uint64_t a1, unsigned int a2)
{
  char v3 = 3;
  while (!(a2 >> (8 * v3)))
  {
    if (!--v3)
    {
      int v4 = (std::string *)(a1 + 8);
      int v5 = 1;
      std::string::push_back((std::string *)(a1 + 8), 1);
      goto LABEL_6;
    }
  }
  unsigned __int8 v6 = v3 + 1;
  int v4 = (std::string *)(a1 + 8);
  std::string::push_back((std::string *)(a1 + 8), v3 + 1);
  int v5 = v6;
LABEL_6:
  unsigned int v7 = v5 + 1;
  int v8 = 8 * v5 - 8;
  do
  {
    std::string::push_back(v4, a2 >> v8);
    --v7;
    v8 -= 8;
  }
  while (v7 > 1);
}

void sub_10078E66C(uint64_t a1, unsigned int a2)
{
  if (a2 > 0x7F) {
    sub_10078E5C4(a1, a2);
  }
  else {
    std::string::push_back((std::string *)(a1 + 8), a2 | 0x80);
  }
}

void sub_10078E684(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = (std::string *)(a1 + 8);
  if (a2)
  {
    char v4 = 1;
    for (int i = 28; i != -7; i -= 7)
    {
      int v6 = (a2 >> i) & 0x7F;
      v4 &= v6 == 0;
      if ((v4 & 1) == 0) {
        std::string::push_back(v2, v6 | ((i != 0) << 7));
      }
    }
  }
  else
  {
    unsigned int v7 = (std::string *)(a1 + 8);
    std::string::push_back(v7, 0);
  }
}

void sub_10078E718(uint64_t a1, unsigned int a2)
{
  if (a2 > 0x1E)
  {
    std::string::push_back((std::string *)(a1 + 8), 31);
    sub_10078E684(a1, a2);
  }
  else
  {
    char v4 = (std::string *)(a1 + 8);
    std::string::push_back(v4, a2);
  }
}

void sub_10078E78C(uint64_t a1, unsigned char *a2)
{
  if (a2 && (char)*a2 < 0) {
    std::string::push_back((std::string *)(a1 + 8), 127);
  }

  sub_10078E554(a1, a2);
}

void sub_10078E7E0(uint64_t a1, uint64_t a2, unsigned int a3)
{
  char v3 = (void **)a2;
  char v5 = *(unsigned char *)(a2 + 23);
  if (a3 == 3 || (v5 >= 0 ? (uint64_t v6 = *(unsigned __int8 *)(a2 + 23)) : (uint64_t v6 = *(void *)(a2 + 8)), !v6))
  {
    if (v5 < 0) {
      a2 = *(void *)a2;
    }
    sub_10078E554(a1, (unsigned char *)a2);
  }
  else
  {
    unsigned int v7 = a3;
    v19[0] = 0;
    v19[1] = 0;
    uint64_t v20 = 0;
    unsigned int v8 = *(_DWORD *)(a1 + 32);
    BOOL v9 = v8 == a3 || v8 == 0;
    if (!v9 && sub_100EBEA94(a2, (uint64_t)v19, a3, v8))
    {
      unsigned int v7 = *(_DWORD *)(a1 + 32);
      char v3 = v19;
    }
    if (v7 == 106)
    {
      __int16 v10 = (char *)v3;
      if (*((char *)v3 + 23) < 0) {
        __int16 v10 = (char *)*v3;
      }
      do
      {
        int v11 = *v10++;
        BOOL v12 = v11 == 0;
      }
      while (v11 > 0);
      if (v12) {
        unsigned int v7 = 3;
      }
      else {
        unsigned int v7 = 106;
      }
    }
    *(_OWORD *)std::string __p = 0u;
    long long v17 = 0u;
    LODWORD(__p[0]) = *(_DWORD *)a1;
    uint64_t v18 = 0;
    __p[1] = 0;
    long long v17 = 0uLL;
    LODWORD(v18) = *(_DWORD *)(a1 + 32);
    sub_10078E66C((uint64_t)__p, v7);
    if (*((char *)v3 + 23) < 0) {
      char v3 = (void **)*v3;
    }
    sub_10078E78C((uint64_t)__p, v3);
    if (v17 >= 0) {
      unsigned int v13 = HIBYTE(v17);
    }
    else {
      unsigned int v13 = v17;
    }
    sub_10078E718(a1, v13);
    if (v17 >= 0) {
      __int16 v14 = (const std::string::value_type *)&__p[1];
    }
    else {
      __int16 v14 = (const std::string::value_type *)__p[1];
    }
    if (v17 >= 0) {
      std::string::size_type v15 = HIBYTE(v17);
    }
    else {
      std::string::size_type v15 = v17;
    }
    std::string::append((std::string *)(a1 + 8), v14, v15);
    if (SHIBYTE(v17) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(v19[0]);
    }
  }
}

void sub_10078E97C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10078E9B4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100CCA3B0(a2, "Content-Type");
  uint64_t v5 = sub_100CCA3B0(a2, "X-Mms-Message-Type");
  uint64_t v6 = sub_100CCA3B0(a2, "X-Mms-Transaction-ID");
  uint64_t v7 = sub_100CCA3B0(a2, "X-Mms-MMS-Version");
  if (v5
    && (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 32))(v5, a1)
     || ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 40))(v5, a1) & 1) == 0))
  {
    if (qword_101B14178 != -1) {
      dispatch_once(&qword_101B14178, &stru_101A84F28);
    }
    long long v17 = qword_101B14170;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)std::string __p = 0;
    uint64_t v18 = "unable to encode message type";
LABEL_39:
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v18, __p, 2u);
    return 0;
  }
  if (v6
    && (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v6 + 32))(v6, a1)
     || ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 40))(v6, a1) & 1) == 0))
  {
    if (qword_101B14178 != -1) {
      dispatch_once(&qword_101B14178, &stru_101A84F28);
    }
    long long v17 = qword_101B14170;
    BOOL result = os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)std::string __p = 0;
    uint64_t v18 = "unable to encode transactionId";
    goto LABEL_39;
  }
  if (!v7
    || (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v7 + 32))(v7, a1)
    && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 40))(v7, a1) & 1) != 0)
  {
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v8 = *(void *)(a2 + 16);
    if (v8 == v9) {
      return 1;
    }
    unint64_t v10 = 0;
    unsigned int v11 = 1;
    while (1)
    {
      uint64_t v12 = *(void *)(v9 + 8 * v10);
      if (v12 != v4 && v12 != v5 && v12 != v6 && v12 != v7)
      {
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v12 + 32))(v12, a1)
          || !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v12 + 40))(v12, a1))
        {
          if (qword_101B14178 != -1) {
            dispatch_once(&qword_101B14178, &stru_101A84F28);
          }
          uint64_t v19 = qword_101B14170;
          if (os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_ERROR))
          {
            uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 64))(v12);
            *(_DWORD *)std::string __p = 136315138;
            *(void *)&__p[4] = v21;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "encoding failed for header '%s'", __p, 0xCu);
            if (qword_101B14178 != -1) {
              dispatch_once(&qword_101B14178, &stru_101A84F28);
            }
          }
          uint64_t v20 = qword_101B14170;
          BOOL result = os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_ERROR);
          if (!result) {
            return result;
          }
          (*(void (**)(unsigned char *__return_ptr, uint64_t, void))(*(void *)v12 + 48))(__p, v12, 0);
          if (v24 >= 0) {
            uint64_t v22 = __p;
          }
          else {
            uint64_t v22 = *(unsigned char **)__p;
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v26 = v22;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
          if (v24 < 0) {
            operator delete(*(void **)__p);
          }
          return 0;
        }
        uint64_t v9 = *(void *)(a2 + 8);
        uint64_t v8 = *(void *)(a2 + 16);
      }
      unint64_t v10 = v11++;
      if (v10 >= (v8 - v9) >> 3) {
        return 1;
      }
    }
  }
  if (qword_101B14178 != -1) {
    dispatch_once(&qword_101B14178, &stru_101A84F28);
  }
  long long v17 = qword_101B14170;
  BOOL result = os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)std::string __p = 0;
    uint64_t v18 = "unable to encode MMS version";
    goto LABEL_39;
  }
  return result;
}

uint64_t sub_10078EED0(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  memset(&__dst, 0, sizeof(__dst));
  p_dst = *(std::string **)(a2 + 72);
  std::string::size_type size = *(unsigned int *)(a2 + 96);
  uint64_t v6 = sub_100CCA3B0(a2, "Content-Type");
  if (v6 && (uint64_t v7 = *(void *)(v6 + 24)) != 0)
  {
    uint64_t v8 = (const char *)(*(uint64_t (**)(void))(*(void *)v7 + 16))(*(void *)(v6 + 24));
    if (!strcmp(v8, "text"))
    {
      uint64_t v10 = sub_100CCA3B0(v7 + 8, "charset");
      unsigned int v11 = (unsigned int *)(v10 + 20);
      if (!v10) {
        unsigned int v11 = (unsigned int *)&unk_1015989E4;
      }
      unsigned int v12 = *v11;
      sub_10003ECB8(&__dst, (const std::string::value_type *)p_dst, size);
      unsigned int v13 = a1[8];
      if (v13)
      {
        if (v12 && v12 != v13)
        {
          if (v12 != 3 || v13 != 106) {
            sub_100EBEA94((uint64_t)&__dst, (uint64_t)&__dst, v12, v13);
          }
          operator new();
        }
      }
      uint64_t v15 = sub_100CCA3B0(v7 + 8, "charset");
      uint64_t v16 = (_DWORD *)(v15 + 20);
      if (!v15) {
        uint64_t v16 = &unk_1015989E4;
      }
      if (*v16 == 106)
      {
        if (qword_101B14178 != -1) {
          dispatch_once(&qword_101B14178, &stru_101A84F28);
        }
        long long v17 = qword_101B14170;
        BOOL v18 = os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_ERROR);
        if (v18)
        {
          LOWORD(__p[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "About to encode the body public -> private", (uint8_t *)__p, 2u);
        }
        uint64_t v19 = *a1;
        Registry::get((uint64_t *)&v32, (Registry *)v18);
        *(_OWORD *)std::string __p = v32;
        long long v32 = 0uLL;
        sub_10079694C(v19, (Registry **)__p, &__dst, 0);
        if (__p[1]) {
          sub_10004D2C8((std::__shared_weak_count *)__p[1]);
        }
        if (*((void *)&v32 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::size_type size = __dst.__r_.__value_.__l.__size_;
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        else
        {
          std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          p_dst = &__dst;
        }
      }
      if (a1[8] == 106)
      {
        uint64_t v20 = &__dst;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v20 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        do
        {
          int v22 = v20->__r_.__value_.__s.__data_[0];
          uint64_t v20 = (std::string *)((char *)v20 + 1);
          int v21 = v22;
        }
        while (v22 > 0);
        if (!v21) {
          operator new();
        }
      }
      if (!v2 && v12)
      {
        uint64_t v23 = sub_100CCA330(0, "Content-Disposition");
        if (v23) {
          sub_10095B91C(v23 + 32, v12);
        }
        uint64_t v2 = 0;
      }
    }
    *(_OWORD *)std::string __p = 0u;
    long long v30 = 0u;
    LODWORD(__p[0]) = *a1;
    uint64_t v31 = 0;
    __p[1] = 0;
    long long v30 = 0uLL;
    LODWORD(v31) = a1[8];
    (*(void (**)(uint64_t, void **))(*(void *)v7 + 40))(v7, __p);
    sub_10078E9B4((uint64_t)__p, v2);
    if (v30 >= 0) {
      unsigned int v24 = HIBYTE(v30);
    }
    else {
      unsigned int v24 = v30;
    }
    sub_10078E684((uint64_t)a1, v24);
    sub_10078E684((uint64_t)a1, size);
    int v25 = (std::string *)(a1 + 2);
    if (v30 >= 0) {
      uint64_t v26 = (const std::string::value_type *)&__p[1];
    }
    else {
      uint64_t v26 = (const std::string::value_type *)__p[1];
    }
    if (v30 >= 0) {
      std::string::size_type v27 = HIBYTE(v30);
    }
    else {
      std::string::size_type v27 = v30;
    }
    std::string::append(v25, v26, v27);
    if (size) {
      std::string::append(v25, (const std::string::value_type *)p_dst, size);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(__p[1]);
    }
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v9;
}

void sub_10078F3C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

uint64_t sub_10078F488(uint64_t a1, uint64_t a2)
{
  if (sub_10022E6D4(a2))
  {
    uint64_t v4 = sub_100CCA3B0(a2, "X-Mms-Message-Type");
    if (v4)
    {
      if (*(unsigned __int8 *)(v4 + 17) == 128) {
        sub_100CCA5A0(a2, "*/*");
      }
    }
    return 1;
  }
  uint64_t result = sub_100CCA330(a2, "Content-Type");
  if (result)
  {
    uint64_t v6 = (uint64_t *)result;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 32))(result, a1);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t))(*v6 + 40))(v6, a1);
      if (result)
      {
        BOOL v7 = sub_10035F9FC(v6[3]);
        uint64_t v8 = *(void *)(a2 + 72);
        if (v7)
        {
          unint64_t v9 = *(void *)(a2 + 80) - v8;
          unint64_t v10 = v9 >> 3;
          std::string::push_back((std::string *)(a1 + 8), v9 << 53 >> 56);
          if (v10)
          {
            unsigned int v11 = 0;
            int v12 = 0;
            do
            {
              uint64_t v13 = *(void *)(a2 + 72);
              if (v11 >= ((unint64_t)(*(void *)(a2 + 80) - v13) >> 3)) {
                uint64_t v14 = 0;
              }
              else {
                uint64_t v14 = *(void *)(v13 + 8 * v11);
              }
              uint64_t result = sub_10078EED0((unsigned int *)a1, v14);
              if ((result & 1) == 0) {
                break;
              }
              unsigned int v11 = ++v12;
            }
            while (v10 > v12);
            return result;
          }
        }
        else
        {
          std::string::append((std::string *)(a1 + 8), *(const std::string::value_type **)(*(void *)v8 + 72), *(unsigned int *)(*(void *)v8 + 96));
        }
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_10078F678(uint64_t a1, uint64_t a2)
{
  if (!sub_10022C1E8(a2) || !sub_10078E9B4(a1, a2)) {
    return 0;
  }

  return sub_10078F488(a1, a2);
}

uint64_t sub_10078F6E0(uint64_t a1, unsigned int a2, unsigned char *a3, unsigned char *a4, unsigned char *a5, unsigned char *a6)
{
  if (a4) {
    BOOL v7 = a4;
  }
  else {
    BOOL v7 = &unk_1016345EA;
  }
  if (a3) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = &unk_1016345EA;
  }
  if (a5) {
    unint64_t v9 = a5;
  }
  else {
    unint64_t v9 = &unk_1016345EA;
  }
  if (a6) {
    unint64_t v10 = a6;
  }
  else {
    unint64_t v10 = &unk_1016345EA;
  }
  sub_10078E66C(a1, a2);
  sub_10078E554(a1, v8);
  sub_10078E554(a1, v7);
  sub_10078E554(a1, v9);
  sub_10078E554(a1, v10);
  return 1;
}

void sub_10078F770(uint64_t a1, const char *a2)
{
  if (*(char *)(a1 + 31) < 0)
  {
    char v3 = *(const void **)(a1 + 8);
    size_t v4 = *(void *)(a1 + 16);
  }
  else
  {
    char v3 = (const void *)(a1 + 8);
    size_t v4 = *(unsigned __int8 *)(a1 + 31);
  }
  sub_100058DB0(__p, (char *)&unk_1016345EA);
  sub_100FF02BC(a2, v3, v4, (uint64_t)__p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10078F7EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10078F808@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x28uLL);
  v2[1] = 0;
  _OWORD v2[2] = 0;
  *uint64_t v2 = off_101A06480;
  void v2[4] = 0;
  v2[3] = off_101A55770;
  uint64_t result = ctb::Client::Client((ctb::Client *)(v2 + 4));
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_10078F888(_Unwind_Exception *a1)
{
  BlastDoorClientInterface::~BlastDoorClientInterface(v2);
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_10078F8AC(BlastDoorClientFactoryInterface *a1)
{
  BlastDoorClientFactoryInterface::~BlastDoorClientFactoryInterface(a1);

  operator delete();
}

void sub_10078F8E4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A06480;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10078F904(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A06480;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10078F958(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_10078F980(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  unint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v25 = *a2;
  uint64_t v26 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  int v12 = *(_DWORD *)(*(void *)a3 + 52);
  if (v12 == 2)
  {
    int v21 = "DATA.Connection.iw5???.2";
    if (a6 == 17) {
      int v21 = "DATA.Connection.iw5.2";
    }
    int v22 = "iw5???.2";
    if (a6 == 17) {
      int v22 = "iw5.2";
    }
    if (a6 == 26) {
      uint64_t v19 = "DATA.Connection.iw5t.2";
    }
    else {
      uint64_t v19 = v21;
    }
    if (a6 == 26) {
      uint64_t v20 = "iw5t.2";
    }
    else {
      uint64_t v20 = v22;
    }
  }
  else
  {
    uint64_t v13 = "DATA.Connection.iw5???.?";
    if (a6 == 17) {
      uint64_t v13 = "DATA.Connection.iw5.?";
    }
    uint64_t v14 = "iw5.?";
    if (a6 != 17) {
      uint64_t v14 = "iw5???.?";
    }
    if (a6 == 26) {
      uint64_t v13 = "DATA.Connection.iw5t.?";
    }
    uint64_t v15 = "DATA.Connection.iw5???.1";
    if (a6 == 26) {
      uint64_t v14 = "iw5t.?";
    }
    uint64_t v16 = "DATA.Connection.iw5t.1";
    if (a6 == 17) {
      uint64_t v15 = "DATA.Connection.iw5.1";
    }
    long long v17 = "iw5.1";
    if (a6 != 17) {
      long long v17 = "iw5???.1";
    }
    if (a6 != 26) {
      uint64_t v16 = v15;
    }
    BOOL v18 = "iw5t.1";
    if (a6 != 26) {
      BOOL v18 = v17;
    }
    if (v12 == 1) {
      uint64_t v19 = v16;
    }
    else {
      uint64_t v19 = v13;
    }
    if (v12 == 1) {
      uint64_t v20 = v18;
    }
    else {
      uint64_t v20 = v14;
    }
  }
  sub_10129653C(a1, (uint64_t *)&off_101A06F30, &v25, a3, a4, &object, v19, (uint64_t)v20, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
  *(void *)a1 = off_101A064F8;
  *(void *)(a1 + 64) = off_101A06A48;
  *(void *)(a1 + 72) = off_101A06CD8;
  *(void *)(a1 + 80) = off_101A06EC8;
  *(_WORD *)(a1 + 388) = 0;
  *(unsigned char *)(a1 + 390) = 0;
  *(unsigned char *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  *(unsigned char *)(a1 + 408) = 0;
  return a1;
}

void sub_10078FBCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

const void **sub_10078FBF8(uint64_t a1)
{
  uint64_t result = (const void **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 760))(a1);
  if (result != 17) {
    return result;
  }
  char v3 = *(std::__shared_weak_count **)(a1 + 432);
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = 0;
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v33 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 88));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    BOOL v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  unint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v10)
  {
    uint64_t v12 = 0;
    goto LABEL_11;
  }
  uint64_t v12 = v10[3];
  unsigned int v11 = (std::__shared_weak_count *)v10[4];
  if (!v11)
  {
LABEL_11:
    std::mutex::unlock(v5);
    unsigned int v11 = 0;
    char v13 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
LABEL_12:
  uint64_t v14 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(int **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v12 + 96))(&v33, v12, v14, 1, @"IWLANImsBackoffTimerOnCellularStart", 0, 0);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  uint64_t v15 = v33;
  if (v33) {
    uint64_t v16 = sub_100080934;
  }
  else {
    uint64_t v16 = 0;
  }
  if (v16)
  {
    *(_DWORD *)long long buf = 0;
    if (v33)
    {
      CFTypeID v17 = CFGetTypeID(v33);
      if (v17 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)buf, v15, v18);
      }
      unsigned int v19 = *(_DWORD *)buf;
      if (*(int *)buf >= 1)
      {
        sub_10003E168(buf, (void *)(a1 + 24));
        long long v20 = *(_OWORD *)buf;
        if (*(void *)&buf[8])
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
          sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
        }
        Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 88));
        uint64_t v21 = *(void *)buf;
        sub_100058DB0(__p, "startup back off IWLAN timer");
        int v22 = *(NSObject **)(a1 + 40);
        dispatch_object_t object = v22;
        if (v22) {
          dispatch_retain(v22);
        }
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = 1174405120;
        aBlock[2] = sub_100790098;
        aBlock[3] = &unk_101A06F98;
        void aBlock[4] = a1;
        long long v26 = v20;
        if (*((void *)&v20 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v20 + 1) + 16), 1uLL, memory_order_relaxed);
        }
        std::string::size_type v27 = "startup back off IWLAN timer";
        uint64_t v28 = _Block_copy(aBlock);
        sub_100118A44(v21, (uint64_t)__p, 0, 1000000 * v19, &object, &v28);
        sub_1004DC2E0((void *)(a1 + 424), &v32);
        uint64_t v23 = v32;
        uint64_t v32 = 0;
        if (v23) {
          (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
        }
        if (v28) {
          _Block_release(v28);
        }
        if (object) {
          dispatch_release(object);
        }
        if (v31 < 0) {
          operator delete(__p[0]);
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        unsigned int v24 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "startup back off IWLAN timer";
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s set", buf, 0xCu);
        }
        if (*((void *)&v26 + 1)) {
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v26 + 1));
        }
        if (*((void *)&v20 + 1)) {
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v20 + 1));
        }
      }
    }
  }
  return sub_1000577C4((const void **)&v33);
}

void sub_10078FFB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *aBlock, dispatch_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100790098(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    char v3 = (PersonalitySpecificImpl *)a1[4];
    size_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = (std::__shared_weak_count *)*((void *)v3 + 54);
        *((void *)v3 + 53) = 0;
        *((void *)v3 + 54) = 0;
        if (v6) {
          sub_10004D2C8(v6);
        }
        BOOL v7 = *((void *)v3 + 7);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = a1[7];
          *(_DWORD *)long long buf = 136315138;
          uint64_t v14 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s fired", buf, 0xCu);
        }
        uint64_t v9 = *((void *)v3 + 27);
        uint64_t v10 = PersonalitySpecificImpl::simSlot(v3);
        sub_100058DB0(__p, "activateFailedTrigger");
        (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v9 + 192))(v9, v10, __p, 0);
        if (v12 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1007901DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100790208(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100790224(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

const void **sub_100790234(uint64_t a1)
{
  return sub_10078FBF8(a1 - 64);
}

void sub_10079023C(void *a1)
{
  *a1 = off_101A064F8;
  a1[8] = off_101A06A48;
  a1[9] = off_101A06CD8;
  a1[10] = off_101A06EC8;
  uint64_t v2 = (std::__shared_weak_count *)a1[54];
  if (v2) {
    sub_10004D2C8(v2);
  }

  sub_101296BD8((uint64_t)a1, (uint64_t *)&off_101A06F30);
}

void sub_100790300(void *a1)
{
  sub_10079023C(a1);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100790328(uint64_t a1)
{
  sub_10079023C((void *)(a1 - 64));

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100790354(uint64_t a1)
{
  sub_10079023C((void *)(a1 - 72));

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100790380(uint64_t a1)
{
  sub_10079023C((void *)(a1 - 80));

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1007903AC(void *a1)
{
  sub_10079023C(a1);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_1007903E8(uint64_t a1)
{
}

void sub_1007903F0(uint64_t a1)
{
}

void sub_1007903F8(uint64_t a1)
{
}

uint64_t sub_100790400(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1[11]);
  char v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)__p);
  if (!v8)
  {
    uint64_t v11 = 0x100010101000000;
    std::mutex::unlock(v3);
    goto LABEL_31;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v3);
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
    if (!v10)
    {
      uint64_t v11 = 0x100010101000000;
      sub_10004D2C8(v9);
LABEL_31:
      uint64_t v17 = 0;
      return v17 | v11;
    }
LABEL_10:
    uint64_t v21 = 0;
    int v22 = 0;
    (*((void (**)(void **__return_ptr, Registry **))*a1 + 64))(__p, a1);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v10 + 40))(&v21, v10, __p);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
    if (v21)
    {
      if ((*((unsigned int (**)(Registry **))*a1 + 95))(a1) == 26)
      {
        BOOL v12 = 1;
      }
      else
      {
        __p[0] = 0;
        (*(void (**)(void **__return_ptr))(*(void *)v21 + 40))(__p);
        uint64_t v14 = (BOOL *)__p[0];
        BOOL v12 = 1;
        char v23 = 1;
        if (__p[0])
        {
          CFTypeID v15 = CFGetTypeID(__p[0]);
          if (v15 == CFBooleanGetTypeID())
          {
            ctu::cf::assign((ctu::cf *)&v23, v14, v16);
            BOOL v12 = v23 != 0;
          }
          else
          {
            BOOL v12 = 1;
          }
        }
        sub_1000577C4((const void **)__p);
      }
      int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 360))(v21);
    }
    else
    {
      int v13 = 0;
      BOOL v12 = 1;
    }
    if (v22) {
      sub_10004D2C8(v22);
    }
    if (v9)
    {
      sub_10004D2C8(v9);
      if (v12) {
        goto LABEL_27;
      }
    }
    else if (v12)
    {
LABEL_27:
      uint64_t v11 = 0x100010101000000;
      if ((v13 & 1) == 0) {
        goto LABEL_31;
      }
      goto LABEL_28;
    }
    uint64_t v11 = 0x100000101000000;
    if (!v13) {
      goto LABEL_31;
    }
LABEL_28:
    uint64_t v17 = 256;
    return v17 | v11;
  }
  std::mutex::unlock(v3);
  if (v10) {
    goto LABEL_10;
  }
  uint64_t v17 = 0;
  uint64_t v11 = 0x100010101000000;
  return v17 | v11;
}

void sub_1007906E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100790740(uint64_t a1)
{
  return sub_100790400((Registry **)(a1 - 72));
}

uint64_t sub_100790760(void *a1, int a2)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 1040))(a1);
  if (result)
  {
    if (a2 == 4)
    {
      uint64_t v5 = a1[7];
      BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v6)
      {
        int v7 = 136315394;
        uint64_t v8 = "deactivateWithReasonAllowed";
        __int16 v9 = 2080;
        uint64_t v10 = asString();
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Do not deactivate for %s", (uint8_t *)&v7, 0x16u);
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_100790868(uint64_t a1, int a2)
{
  return sub_100790760((void *)(a1 - 72), a2);
}

void sub_100790870(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = a1[7];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v11 = "pcoTrigger";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: passing to SystemDetermination", buf, 0xCu);
  }
  uint64_t v7 = a1[27];
  (*(void (**)(void **__return_ptr, void *))(*a1 + 512))(__p, a1);
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t))(*(void *)v7 + 240))(v7, __p, a2, a3);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007909A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007909C4()
{
  return 1;
}

uint64_t sub_1007909CC()
{
  return 1;
}

uint64_t sub_1007909D4(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *(unsigned __int8 *)(a1 + 388);
  uint64_t v3 = 2000;
  if (!result) {
    uint64_t v3 = 0;
  }
  *a2 = v3;
  return result;
}

uint64_t sub_1007909EC(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *(unsigned __int8 *)(a1 + 316);
  uint64_t v3 = 2000;
  if (!result) {
    uint64_t v3 = 0;
  }
  *a2 = v3;
  return result;
}

uint64_t sub_100790A04(uint64_t result, char a2)
{
  *(unsigned char *)(result + 388) = a2;
  return result;
}

uint64_t sub_100790A0C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 324) = a2;
  return result;
}

uint64_t sub_100790A14()
{
  return 1;
}

uint64_t sub_100790A1C()
{
  return 1;
}

uint64_t sub_100790A24()
{
  return 1;
}

uint64_t sub_100790A2C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 1056))();
}

uint64_t sub_100790A58(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int *a4, uint64_t a5, uint64_t a6)
{
  if ((validContextType() & 1) == 0)
  {
    CFBooleanRef v16 = *(NSObject **)(a1 + 56);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    int v41 = 136315394;
    unint64_t v42 = "activateFailedTrigger";
    __int16 v43 = 2080;
    unint64_t v44 = (const char *)asString();
    uint64_t v17 = "#E %s: wrong context type: %s";
    CFNumberRef v18 = v16;
    uint32_t v19 = 22;
LABEL_42:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&v41, v19);
    return 0;
  }
  uint64_t v12 = *a3;
  int v13 = (std::__shared_weak_count *)a3[1];
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = sub_100790F4C(a1, a2, v12);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (!v14 || *a4 != 68 && *a4 != 63) {
    return 0;
  }
  if (a5
    && *a3
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)*a3 + 1096))(*a3, a5, a6))
  {
    CFTypeID v15 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = 136315650;
      unint64_t v42 = "activateFailedTrigger";
      __int16 v43 = 2080;
      unint64_t v44 = (const char *)asString();
      __int16 v45 = 2048;
      uint64_t v46 = (const char *)v14;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s: ActivationBlocker: type=%s, imsPref=%llu: flexible blocker settings exist, ignoring hardcoded 'FatalActivationBlocker' logic", (uint8_t *)&v41, 0x20u);
    }
  }
  else
  {
    char v20 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = 136315906;
      unint64_t v42 = "activateFailedTrigger";
      __int16 v43 = 2080;
      unint64_t v44 = (const char *)asString();
      __int16 v45 = 2048;
      uint64_t v46 = (const char *)v14;
      __int16 v47 = 2080;
      uint64_t v48 = asString();
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s: ActivationBlocker: type=%s, imsPref=%llu, cause %s", (uint8_t *)&v41, 0x2Au);
    }
    if (*a3) {
      (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)*a3 + 1160))(*a3, a2, *a4, 1);
    }
  }
  int v21 = *((unsigned __int8 *)a4 + 28);
  int v22 = *(NSObject **)(a1 + 56);
  BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  if (!v21)
  {
    if (!v23) {
      return 0;
    }
    std::string::size_type v27 = *(const char **)(a1 + 136);
    if (*a4) {
      uint64_t v28 = "f";
    }
    else {
      uint64_t v28 = "t";
    }
    if (*a4) {
      uint64_t v29 = (const char *)asString();
    }
    else {
      uint64_t v29 = "OK";
    }
    unint64_t v36 = (unsigned char *)*((void *)a4 + 1);
    if (v36)
    {
      uint64_t v37 = *((void *)a4 + 2);
      if (*v36)
      {
        uint64_t v38 = "}";
        unint64_t v39 = "{";
LABEL_41:
        int v41 = 136317186;
        unint64_t v42 = v27;
        __int16 v43 = 2080;
        unint64_t v44 = "activateFailedTrigger";
        __int16 v45 = 2080;
        uint64_t v46 = "ActivationBlocker: error code";
        __int16 v47 = 2080;
        uint64_t v48 = (uint64_t)v28;
        __int16 v49 = 2080;
        int64_t v50 = v29;
        __int16 v51 = 2080;
        long long v52 = v39;
        __int16 v53 = 2080;
        uint64_t v54 = v36;
        __int16 v55 = 2080;
        uint64_t v56 = v37;
        __int16 v57 = 2080;
        uint64_t v58 = (uint64_t)v38;
        uint64_t v17 = "#I DATA.%s: %s: %s: %s(%s%s%s %s%s)";
        CFNumberRef v18 = v22;
        uint32_t v19 = 92;
        goto LABEL_42;
      }
    }
    else
    {
      uint64_t v37 = *((void *)a4 + 2);
    }
    unint64_t v39 = "";
    uint64_t v38 = "";
    goto LABEL_41;
  }
  if (v23)
  {
    unsigned int v24 = *(const char **)(a1 + 136);
    if (*a4) {
      uint64_t v25 = "f";
    }
    else {
      uint64_t v25 = "t";
    }
    if (*a4) {
      long long v26 = (const char *)asString();
    }
    else {
      long long v26 = "OK";
    }
    char v31 = (const char *)*((void *)a4 + 1);
    long long v30 = (unsigned char *)*((void *)a4 + 2);
    uint64_t v32 = asStringBool(*((unsigned char *)a4 + 24));
    uint64_t v33 = asStringBool(*((unsigned char *)a4 + 25));
    uint64_t v34 = asStringBool(*((unsigned char *)a4 + 26));
    uint64_t v35 = asStringBool(*((unsigned char *)a4 + 27));
    int v41 = 136317698;
    unint64_t v42 = v24;
    __int16 v43 = 2080;
    unint64_t v44 = "activateFailedTrigger";
    __int16 v45 = 2080;
    uint64_t v46 = "ActivationBlocker: error code";
    __int16 v47 = 2080;
    uint64_t v48 = (uint64_t)v25;
    __int16 v49 = 2080;
    int64_t v50 = v26;
    __int16 v51 = 2080;
    long long v52 = v31;
    __int16 v53 = 2080;
    uint64_t v54 = v30;
    __int16 v55 = 2080;
    uint64_t v56 = v32;
    __int16 v57 = 2080;
    uint64_t v58 = v33;
    __int16 v59 = 2080;
    uint64_t v60 = v34;
    __int16 v61 = 2080;
    uint64_t v62 = v35;
    uint64_t v17 = "#I DATA.%s: %s: %s: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})";
    CFNumberRef v18 = v22;
    uint32_t v19 = 112;
    goto LABEL_42;
  }
  return 0;
}

void sub_100790F2C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100790F4C(uint64_t a1, int a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  if ((validContextType() & 1) == 0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315650;
      uint64_t v7 = "getCurrentImsPref for context type unknown";
      __int16 v8 = 2080;
      char v9 = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Data/Source/DataConnectionIMS.cpp";
      __int16 v10 = 1024;
      int v11 = 434;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT validContextType(ct)\n %s\n at %s:%d\n**********", (uint8_t *)&v6, 0x1Cu);
    }
    if ((validContextType() & 1) == 0) {
      __TUAssertTrigger();
    }
  }
  return *(void *)(a1 + 8 * a2 + 392);
}

uint64_t sub_100791058(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (!a2)
  {
    sub_1012A0D1C(a1, a2, 1, buf);
    char v9 = *(std::__shared_weak_count **)(a3 + 8);
    uint64_t v10 = *(void *)buf;
    *(_OWORD *)a3 = *(_OWORD *)buf;
    if (v9)
    {
      sub_10004D2C8(v9);
      if (!a5 || !*(void *)a3) {
        goto LABEL_27;
      }
    }
    else if (!a5 || !v10)
    {
      goto LABEL_27;
    }
    long long v30 = 0;
    uint64_t v31 = 0;
    uint64_t v28 = 0;
    uint64_t v29 = &v30;
    uint64_t v27 = 0;
    uint64_t v11 = *(void *)(a1 + 216);
    uint64_t v12 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v11 + 416))(&v27, v11, v12);
    if (v27)
    {
      (*(void (**)(unsigned char *__return_ptr))(*(void *)v27 + 80))(buf);
      sub_1000346F8((uint64_t)&v29, v30);
      int v13 = *(void **)&buf[8];
      uint64_t v29 = *(void ***)buf;
      long long v30 = *(void **)&buf[8];
      uint64_t v31 = *(void *)&buf[16];
      if (*(void *)&buf[16])
      {
        *(void *)(*(void *)&buf[8] + 16) = &v30;
        *(void *)long long buf = &buf[8];
        *(void *)&uint8_t buf[8] = 0;
        *(void *)&uint8_t buf[16] = 0;
        int v13 = 0;
      }
      else
      {
        uint64_t v29 = &v30;
      }
      sub_1000346F8((uint64_t)buf, v13);
    }
    if (v28) {
      sub_10004D2C8(v28);
    }
    uint64_t v14 = v30;
    if (v30)
    {
      CFTypeID v15 = v30;
      do
      {
        int v16 = *((_DWORD *)v15 + 7);
        if (v16 <= a5)
        {
          if (v16 >= a5)
          {
            uint64_t v17 = *(NSObject **)(a1 + 56);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v19 = asString();
              *(_DWORD *)long long buf = 136315650;
              *(void *)&uint8_t buf[4] = "handoverFailedCallback";
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v19;
              *(_WORD *)&unsigned char buf[22] = 1024;
              int v33 = a5;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: error = %s(%d), set handover blocked flag to true", buf, 0x1Cu);
              uint64_t v14 = v30;
            }
            *(unsigned char *)(a1 + 389) = 1;
            break;
          }
          ++v15;
        }
        CFTypeID v15 = (void *)*v15;
      }
      while (v15);
    }
    sub_1000346F8((uint64_t)&v29, v14);
  }
LABEL_27:
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 216) + 24))(buf);
  uint64_t v20 = *(void *)buf;
  if (*(void *)buf)
  {
    uint64_t v21 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 760))(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v20 + 64))(v20, v21, v22, a2);
  }
  BOOL v23 = *(std::__shared_weak_count **)(a3 + 8);
  long long v26 = v23;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v24 = sub_1012A4C00(a1, a2);
  if (v26) {
    sub_10004D2C8(v26);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  return v24;
}

void sub_1007913A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *a15)
{
}

uint64_t sub_100791400(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  return sub_100791058(a1 - 72, a2, a3, a4, a5);
}

void sub_100791408(void *a1, int a2)
{
  (*(void (**)(void *))(*a1 + 992))(a1);
  uint64_t v4 = a1[7];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "failed";
    if (a2) {
      uint64_t v5 = "succeeded";
    }
    int v6 = 136315394;
    uint64_t v7 = "mOBIKEDoneTrigger";
    __int16 v8 = 2080;
    char v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: MOBIKE handover %s.", (uint8_t *)&v6, 0x16u);
  }
}

void sub_100791500(uint64_t a1, int a2, void *a3)
{
  int v6 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "deactivatedTrigger";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: ", buf, 0xCu);
  }
  *(unsigned char *)(a1 + 389) = 0;
  int v16 = 2;
  uint64_t v14 = 0;
  CFTypeID v15 = 0;
  sub_101299CF0(a1, &v16, &v14);
  if (!validContextType() || v16 == a2 && v14 == *a3)
  {
    uint64_t v7 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = asString();
      uint64_t v9 = asString();
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "deactivatedTrigger";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v8;
      __int16 v18 = 2080;
      uint64_t v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: connection deactivated for %s (current %s)", buf, 0x20u);
    }
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 216) + 24))(buf);
    uint64_t v10 = *(void *)buf;
    if (*(void *)buf)
    {
      uint64_t v11 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 760))(a1);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const char *))(*(void *)v10 + 56))(v10, v11, v12, 2, 2, "");
    }
    v13[0] = 0;
    v13[1] = 0;
    sub_100791794((PersonalitySpecificImpl *)a1, 2, v13);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_100791754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100791794(PersonalitySpecificImpl *a1, uint64_t a2, void *a3)
{
  v32[0] = 0;
  v32[1] = 0;
  uint64_t v33 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 512))(v32);
  int v6 = (void *)HIBYTE(v33);
  if (v33 < 0) {
    int v6 = v32[1];
  }
  if (v6)
  {
    sub_1012A0D1C((uint64_t)a1, 0, 1, buf);
    uint64_t v7 = *(std::__shared_weak_count **)&buf[8];
    v31[0] = *(void *)buf;
    v31[1] = *(void *)&buf[8];
    uint64_t v8 = sub_100791C70((uint64_t)a1, 0, v31);
    if (v7) {
      sub_10004D2C8(v7);
    }
    sub_1012A0D1C((uint64_t)a1, 1, 1, buf);
    uint64_t v9 = *(std::__shared_weak_count **)&buf[8];
    v30[0] = *(void *)buf;
    v30[1] = *(void *)&buf[8];
    uint64_t v10 = sub_100791C70((uint64_t)a1, 1, v30);
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (*a3 && (sub_10129C4EC((uint64_t)a1), validContextType()))
    {
      sub_1012A0D1C((uint64_t)a1, a2, 1, buf);
      uint64_t v11 = *(void *)buf;
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      uint64_t v12 = *((void *)a1 + 7);
      BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
      if (!v11)
      {
        if (v13)
        {
          uint64_t v20 = asString();
          *(_DWORD *)long long buf = 136315906;
          *(void *)&uint8_t buf[4] = "evaluateImsPref";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v20;
          __int16 v35 = 2048;
          uint64_t v36 = v8;
          __int16 v37 = 2048;
          uint64_t v38 = v10;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: from disabled settings (%s), ignoring bb mask %llu and tech mask %llu", buf, 0x2Au);
        }
        goto LABEL_30;
      }
      if (v13)
      {
        uint64_t v14 = asString();
        sub_10129C4EC((uint64_t)a1);
        uint64_t v15 = asString();
        *(_DWORD *)long long buf = 136316162;
        *(void *)&uint8_t buf[4] = "evaluateImsPref";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v14;
        __int16 v35 = 2080;
        uint64_t v36 = v15;
        __int16 v37 = 2048;
        uint64_t v38 = v8;
        __int16 v39 = 2048;
        uint64_t v40 = v10;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: from active settings (%s), firing event ct=%s bb mask %llu and tech mask %llu", buf, 0x34u);
      }
      uint64_t v16 = *((void *)a1 + 27);
      if (SHIBYTE(v33) < 0)
      {
        sub_10004FC84(__p, v32[0], (unint64_t)v32[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)v32;
        uint64_t v29 = v33;
      }
      uint64_t v21 = sub_10129C4EC((uint64_t)a1);
      (*(void (**)(uint64_t, void **, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 232))(v16, __p, v21, v8, v10);
      if ((SHIBYTE(v29) & 0x80000000) == 0)
      {
LABEL_30:
        uint64_t v22 = *((void *)a1 + 27);
        uint64_t v23 = PersonalitySpecificImpl::simSlot(a1);
        sub_100058DB0(v24, "IM IMS preferences changed");
        (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v22 + 192))(v22, v23, v24, 0);
        if (v25 < 0) {
          operator delete(v24[0]);
        }
        goto LABEL_32;
      }
      uint64_t v19 = __p[0];
    }
    else
    {
      uint64_t v17 = *((void *)a1 + 7);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "evaluateImsPref";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v8;
        __int16 v35 = 2048;
        uint64_t v36 = v10;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: firing event with bb mask %llu and tech mask %llu", buf, 0x20u);
      }
      uint64_t v18 = *((void *)a1 + 27);
      if (SHIBYTE(v33) < 0)
      {
        sub_10004FC84(&__dst, v32[0], (unint64_t)v32[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)v32;
        uint64_t v27 = v33;
      }
      (*(void (**)(uint64_t, long long *, uint64_t, uint64_t, uint64_t))(*(void *)v18 + 232))(v18, &__dst, 2, v8, v10);
      if ((SHIBYTE(v27) & 0x80000000) == 0) {
        goto LABEL_30;
      }
      uint64_t v19 = (void *)__dst;
    }
    operator delete(v19);
    goto LABEL_30;
  }
LABEL_32:
  if (SHIBYTE(v33) < 0) {
    operator delete(v32[0]);
  }
}

void sub_100791BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100791C70(uint64_t a1, int a2, uint64_t *a3)
{
  if (!*a3) {
    return 0;
  }
  (*(void (**)(unsigned char *__return_ptr))(*(void *)a1 + 136))(v14);
  uint64_t v6 = *(void *)v14;
  if (*(void *)&v14[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v14[8]);
  }
  if (!v6)
  {
    uint64_t v10 = (std::__shared_weak_count *)a3[1];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
    }
    return 0;
  }
  if (!a2 && *(unsigned char *)(a1 + 387)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 416))
  {
    uint64_t v7 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 408);
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)&void v14[4] = "getCurrentImsPref";
      *(_WORD *)&unsigned char v14[12] = 2048;
      *(void *)&v14[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: in call IMS pref is present(%llu)", v14, 0x16u);
      if (!*(unsigned char *)(a1 + 416)) {
        sub_10016C840();
      }
    }
    return *(void *)(a1 + 408);
  }
  else
  {
    uint64_t v12 = *a3;
    BOOL v13 = (std::__shared_weak_count *)a3[1];
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = sub_100790F4C(a1, a2, v12);
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
  return v9;
}

void sub_100791DF4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100791E14(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[27];
  if (v2)
  {
    (*(void (**)(void **__return_ptr))(*a1 + 512))(__p);
    (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v2 + 248))(v2, __p, a2);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100791EB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100791ED0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (capabilities::ct *)capabilities::ct::supportsSMSIMSStack((capabilities::ct *)a1);
  if (!v6)
  {
    if (capabilities::ct::supportsThumperService(v6)) {
      goto LABEL_9;
    }
LABEL_6:
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 760))(a1) == 26) {
      return;
    }
    goto LABEL_9;
  }
  if (a2 == 1)
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 760))(a1) == 17) {
      return;
    }
    goto LABEL_9;
  }
  if (!a2) {
    goto LABEL_6;
  }
LABEL_9:
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  sub_1012A0D1C(a1, a2, 0, &v22);
  uint64_t v7 = v22;
  if (v22)
  {
    if ((validContextType() & 1) == 0)
    {
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "setImsPref for context type unknown";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Data/Source/DataConnectionIMS.cpp";
        __int16 v25 = 1024;
        LODWORD(v26) = 375;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT validContextType(ct)\n %s\n at %s:%d\n**********", buf, 0x1Cu);
      }
      if ((validContextType() & 1) == 0) {
        __TUAssertTrigger();
      }
    }
    uint64_t v8 = a1 + 8 * (int)a2;
    uint64_t v9 = *(void *)(v8 + 392);
    if (v9 != a3)
    {
      uint64_t v11 = (uint64_t *)(v8 + 392);
      uint64_t v12 = *(NSObject **)(a1 + 56);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = asString();
        uint64_t v14 = *v11;
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = "updateCurrentImsPref";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v13;
        __int16 v25 = 2048;
        uint64_t v26 = v14;
        __int16 v27 = 2048;
        uint64_t v28 = a3;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: IMS pref for %s changes from %llu -> %llu", buf, 0x2Au);
        uint64_t v9 = *v11;
      }
      uint64_t *v11 = a3;
      if ((a3 & 1) != 0 && (v9 & 1) == 0 && sub_10129C4EC(a1) != a2)
      {
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 216) + 24))(buf);
        uint64_t v15 = *(void *)buf;
        if (*(void *)buf)
        {
          uint64_t v16 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
          if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 88))(v15, v16, 1) == a2)
          {
            uint64_t v17 = *(NSObject **)(a1 + 56);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v21 = 0;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I triggeriRatChangeEvent because of IMS PREF", v21, 2u);
            }
            uint64_t v18 = *(void *)buf;
            uint64_t v19 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18 + 112))(v18, v19, 1);
          }
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
    }
  }
  uint64_t v10 = v23;
  v20[0] = v7;
  v20[1] = v23;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100791794((PersonalitySpecificImpl *)a1, a2, v20);
  if (v10)
  {
    sub_10004D2C8(v10);
    sub_10004D2C8(v10);
  }
}

void sub_100792284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007922D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1007922DC(uint64_t a1, int a2, uint64_t *a3)
{
  return sub_100791C70(a1 - 72, a2, a3);
}

uint64_t sub_1007922E4(Registry **a1, uint64_t a2, uint64_t a3)
{
  if ((*((unsigned int (**)(Registry **))*a1 + 65))(a1) == 4)
  {
    uint64_t v6 = a1[7];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v75 = "handoverPossible";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: we are already deactivating, shouldn't do handover as the old connection is already destroyed most probably", buf, 0xCu);
    }
    return a2;
  }
  uint64_t v72 = 0;
  uint64_t v73 = 0;
  (*((void (**)(uint64_t *__return_ptr, Registry **, uint64_t))*a1 + 17))(&v72, a1, a3);
  if (!v72)
  {
    if (a2 != 1
      || (uint64_t v11 = a1[27],
          uint64_t v12 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1),
          ((*(uint64_t (**)(Registry *, uint64_t))(*(void *)v11 + 400))(v11, v12) & 1) != 0))
    {
      a2 = sub_1012A3AAC(a1, a2, a3);
      goto LABEL_62;
    }
    int v41 = a1[7];
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    uint64_t v42 = asString();
    uint64_t v43 = asString();
    *(_DWORD *)long long buf = 136315650;
    uint64_t v75 = "handoverPossible";
    __int16 v76 = 2080;
    uint64_t v77 = v42;
    __int16 v78 = 2080;
    uint64_t v79 = v43;
    unint64_t v44 = "#I %s: No context %s to switch over to, we should deactivate context %s";
    __int16 v45 = v41;
    goto LABEL_55;
  }
  if (*((unsigned char *)a1 + 389))
  {
    uint64_t v7 = a1[7];
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_62;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v75 = "handoverPossible";
    uint64_t v8 = "#I %s: handover is blocked, shouldn't do handover";
    goto LABEL_8;
  }
  uint64_t v13 = a1[27];
  uint64_t v14 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  int v15 = (*(uint64_t (**)(Registry *, uint64_t))(*(void *)v13 + 256))(v13, v14);
  char v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v72 + 1072))(v72, a2, a3);
  uint64_t v17 = a1[27];
  uint64_t v18 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  if (!(*(unsigned int (**)(Registry *, uint64_t))(*(void *)v17 + 400))(v17, v18))
  {
    if (v16)
    {
      uint64_t v30 = v72;
      uint64_t v31 = v73;
      if (v73) {
        atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v32 = sub_100790F4C((uint64_t)a1, a3, v30);
      if (v31) {
        sub_10004D2C8(v31);
      }
      if (v32)
      {
        uint64_t v69 = 0;
        char v70 = 0;
        uint64_t v33 = a1[27];
        uint64_t v34 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint64_t *__return_ptr, Registry *, uint64_t))(*(void *)v33 + 416))(&v69, v33, v34);
        uint64_t v35 = v69;
        if (a3 != 1 || v69 == 0) {
          char v37 = 1;
        }
        else {
          char v37 = v15;
        }
        if ((v37 & 1) == 0)
        {
          if (!(*(unsigned int (**)(void))(*(void *)v69 + 184))())
          {
            uint64_t v58 = a1[7];
            if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_89;
            }
            sub_10129C4EC((uint64_t)a1);
            uint64_t v59 = asString();
            *(_DWORD *)long long buf = 136315394;
            uint64_t v75 = "handoverPossible";
            __int16 v76 = 2080;
            uint64_t v77 = v59;
            uint64_t v60 = "#I %s: WiFi calling is not allowed in roaming, we stay on current context %s";
            __int16 v61 = v58;
            goto LABEL_87;
          }
          uint64_t v35 = v69;
        }
        if (v35 && (((*(unsigned int (**)(uint64_t))(*(void *)v35 + 168))(v35) | v15) & 1) == 0)
        {
          uint64_t v62 = a1[7];
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
          {
            sub_10129C4EC((uint64_t)a1);
            uint64_t v63 = asString();
            *(_DWORD *)long long buf = 136315394;
            uint64_t v75 = "handoverPossible";
            __int16 v76 = 2080;
            uint64_t v77 = v63;
            _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I %s: Handover is not allowed in roaming, we should deactivate current context %s", buf, 0x16u);
          }
          a2 = 2;
          goto LABEL_89;
        }
        uint64_t v38 = a1[7];
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_52;
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v75 = "handoverPossible";
        __int16 v39 = "#I %s: have settings to handover to, good to go (2)";
        uint64_t v40 = v38;
        goto LABEL_51;
      }
      __int16 v49 = a1[7];
      BOOL v50 = os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT);
      if (a3)
      {
        if (v50)
        {
          uint64_t v51 = asString();
          uint64_t v52 = asString();
          *(_DWORD *)long long buf = 136315650;
          uint64_t v75 = "handoverPossible";
          __int16 v76 = 2080;
          uint64_t v77 = v51;
          __int16 v78 = 2080;
          uint64_t v79 = v52;
          uint64_t v8 = "#I %s: No IMS Pref in context %s at all, we should stay in context %s";
          uint64_t v9 = v49;
          uint32_t v10 = 32;
          goto LABEL_9;
        }
        goto LABEL_62;
      }
      if (v50)
      {
        uint64_t v64 = asString();
        uint64_t v65 = asString();
        *(_DWORD *)long long buf = 136315650;
        uint64_t v75 = "handoverPossible";
        __int16 v76 = 2080;
        uint64_t v77 = v64;
        __int16 v78 = 2080;
        uint64_t v79 = v65;
        unint64_t v44 = "#I %s: No IMS Pref in context %s at all, we should deactivate context %s";
        __int16 v45 = v49;
LABEL_55:
        uint32_t v46 = 32;
LABEL_60:
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, v44, buf, v46);
      }
    }
    else
    {
      __int16 v47 = a1[7];
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        uint64_t v75 = "handoverPossible";
        unint64_t v44 = "#I %s: handover is not supported for this data mode, shouldn't do handover, deactivate current context typ"
              "e when not in a call";
        __int16 v45 = v47;
        uint32_t v46 = 12;
        goto LABEL_60;
      }
    }
LABEL_61:
    a2 = 2;
    goto LABEL_62;
  }
  if ((v16 & 1) == 0)
  {
    uint64_t v7 = a1[7];
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_62;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v75 = "handoverPossible";
    uint64_t v8 = "#I %s: handover is not supported for this data mode, shouldn't do handover, stay with the current context type when in a call";
    goto LABEL_8;
  }
  if ((*(unsigned int (**)(Registry *))(*(void *)a1[27] + 408))(a1[27]))
  {
    uint64_t v19 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    if (!sub_100792DE0((uint64_t)a1, v19))
    {
      uint64_t v7 = a1[7];
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_62;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v75 = "handoverPossible";
      uint64_t v8 = "#I %s: handover in emergency mode is not supported, shouldn't do handover";
LABEL_8:
      uint64_t v9 = v7;
      uint32_t v10 = 12;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
      goto LABEL_62;
    }
  }
  uint64_t v20 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  if (!isCallHandoverSupported(a1 + 11, v20))
  {
    uint64_t v7 = a1[7];
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_62;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v75 = "handoverPossible";
    uint64_t v8 = "#I %s: call handover is not supported, shouldn't do handover";
    goto LABEL_8;
  }
  uint64_t v21 = v72;
  uint64_t v22 = v73;
  if (v73) {
    atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v23 = sub_100790F4C((uint64_t)a1, a3, v21);
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (!a3)
  {
    uint64_t v24 = a1[27];
    uint64_t v25 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    if ((*(unsigned int (**)(Registry *, uint64_t))(*(void *)v24 + 448))(v24, v25))
    {
      uint64_t v26 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      if (isCallHandoverWithoutIMSVoiceServiceSupported(a1 + 11, v26))
      {
        __int16 v27 = v73;
        v71[0] = v72;
        v71[1] = (uint64_t)v73;
        if (v73) {
          atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        char v23 = sub_100791C70((uint64_t)a1, 0, v71);
        if (v27) {
          sub_10004D2C8(v27);
        }
      }
    }
  }
  if (v23)
  {
    uint64_t v69 = 0;
    char v70 = 0;
    __int16 v53 = a1[27];
    uint64_t v54 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    (*(void (**)(uint64_t *__return_ptr, Registry *, uint64_t))(*(void *)v53 + 416))(&v69, v53, v54);
    if (!v69)
    {
      CFStringRef v66 = a1[7];
      if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_89;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v75 = "handoverPossible";
      uint64_t v60 = "#I %s: Tech config is not found - handover is not supported";
      __int16 v61 = v66;
      uint32_t v67 = 12;
      goto LABEL_88;
    }
    char v55 = (*(uint64_t (**)(uint64_t))(*(void *)v69 + 168))(v69) | v15;
    uint64_t v56 = a1[7];
    BOOL v57 = os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT);
    if (v55)
    {
      if (!v57) {
        goto LABEL_52;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v75 = "handoverPossible";
      __int16 v39 = "#I %s: have settings to handover to, good to go (1)";
      uint64_t v40 = v56;
LABEL_51:
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, v39, buf, 0xCu);
LABEL_52:
      a2 = a3;
      goto LABEL_89;
    }
    if (!v57)
    {
LABEL_89:
      if (v70) {
        sub_10004D2C8(v70);
      }
      goto LABEL_62;
    }
    sub_10129C4EC((uint64_t)a1);
    uint64_t v68 = asString();
    *(_DWORD *)long long buf = 136315394;
    uint64_t v75 = "handoverPossible";
    __int16 v76 = 2080;
    uint64_t v77 = v68;
    uint64_t v60 = "#I %s: Handover is not allowed in roaming, stay in current context %s as in call";
    __int16 v61 = v56;
LABEL_87:
    uint32_t v67 = 22;
LABEL_88:
    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, v60, buf, v67);
    goto LABEL_89;
  }
  uint64_t v28 = a1[7];
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = asString();
    *(_DWORD *)long long buf = 136315394;
    uint64_t v75 = "handoverPossible";
    __int16 v76 = 2080;
    uint64_t v77 = v29;
    uint64_t v8 = "#I %s: We shouldn't handover if call cannot be maintained in context %s";
    uint64_t v9 = v28;
    uint32_t v10 = 22;
    goto LABEL_9;
  }
LABEL_62:
  if (v73) {
    sub_10004D2C8(v73);
  }
  return a2;
}

void sub_100792D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100792DE0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x10uLL);
  __int16 v27 = v4 + 2;
  uint64_t v28 = v4 + 2;
  void *v4 = @"EmergencyCalling";
  v4[1] = @"WaitForWiFiRegistration";
  uint64_t v25 = 0;
  uint64_t v26 = v4;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 88));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, uint64_t))(*(void *)v13 + 104))(__p, v13, a2, 1, &v26, 0, 1);
  sub_1000057AC(&v25, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v25, v15);
  int v16 = buf[0];
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  uint64_t v24 = *(void *)&buf[16];
  uint64_t v17 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = SHIBYTE(v24);
    uint64_t v19 = (void **)__p[0];
    uint64_t v20 = asStringBool(v16 != 0);
    uint64_t v21 = __p;
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "carrierPrefersToWaitForWiFi";
    if (v18 < 0) {
      uint64_t v21 = v19;
    }
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v21;
    *(_WORD *)&unsigned char buf[22] = 2082;
    uint64_t v30 = v20;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: %{public}s = %{public}s", buf, 0x20u);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  sub_100062778((const void **)&v25);
  if (v26)
  {
    __int16 v27 = v26;
    operator delete(v26);
  }
  return v16 != 0;
}

void sub_100793060(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (v23 < 0) {
    operator delete(v22);
  }
  sub_100062778(&a13);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007930E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1007922E4((Registry **)(a1 - 72), a2, a3);
}

uint64_t sub_1007930F0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "handOverNotPossibleTrigger";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: ", buf, 0xCu);
  }
  *(_OWORD *)long long buf = 0uLL;
  sub_100058DB0(&__p, *(char **)(a1 + 136));
  uint64_t v3 = *(NSObject **)(a1 + 40);
  dispatch_object_t v12 = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  uint64_t v4 = *(NSObject **)(a1 + 48);
  dispatch_object_t object = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v12) {
    dispatch_release(v12);
  }
  if (v14 < 0) {
    operator delete(__p);
  }
  Registry::createRestModuleOneTimeUseConnection(&v9, *(Registry **)(a1 + 88));
  ctu::RestModule::connect();
  char v5 = (capabilities::ct *)v10;
  if (v10) {
    sub_10004D2C8(v10);
  }
  int v6 = capabilities::ct::supports5G(v5);
  v8[0] = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  v8[1] = v6;
  sub_1004C0384((uint64_t)buf, v8);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  return 0;
}

void sub_100793254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v21 = *(std::__shared_weak_count **)(v19 - 40);
  if (v21) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007932C4(uint64_t a1)
{
  return 0;
}

uint64_t sub_1007932E4(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 216);
  uint64_t v5 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v4 + 400))(v4, v5)) {
    return a2 == 1;
  }
  uint64_t v6 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  uint64_t result = isCallHandoverSupported((Registry **)(a1 + 88), v6);
  if (result) {
    return a2 == 1;
  }
  return result;
}

uint64_t sub_100793374(uint64_t a1, int a2)
{
  return sub_1007932E4(a1 - 72, a2);
}

BOOL sub_10079337C(uint64_t a1, int a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 390);
  if (v3 != a2)
  {
    *(unsigned char *)(a1 + 390) = a2;
    uint64_t v4 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "disabled";
      if (a2) {
        uint64_t v5 = "enabled";
      }
      int v7 = 136315394;
      uint64_t v8 = "enableSMSOverIMSOnly";
      __int16 v9 = 2080;
      unsigned int v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: SMS over IMS context is %s", (uint8_t *)&v7, 0x16u);
    }
  }
  return v3 != a2;
}

BOOL sub_100793464(uint64_t a1, int a2)
{
  return sub_10079337C(a1 - 64, a2);
}

uint64_t sub_10079346C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(*(unsigned char *)(a1 + 390));
    int v5 = 136315394;
    uint64_t v6 = "isSMSOverIMSOnly";
    __int16 v7 = 2080;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: fIsSMSOverIMSnoVoLTEEnabled=%s", (uint8_t *)&v5, 0x16u);
  }
  return *(unsigned __int8 *)(a1 + 390);
}

uint64_t sub_100793528(uint64_t a1)
{
  return sub_10079346C(a1 - 72);
}

uint64_t sub_100793530(PersonalitySpecificImpl *a1)
{
  uint64_t v2 = *((void *)a1 + 27);
  uint64_t v3 = PersonalitySpecificImpl::simSlot(a1);
  int v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 400))(v2, v3);
  if (v4)
  {
    int v5 = *((void *)a1 + 7);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315138;
      uint64_t v8 = "shouldActOnTransportTypeChangeTo";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: In a call, don't do anything.", (uint8_t *)&v7, 0xCu);
    }
  }
  return v4 ^ 1u;
}

uint64_t sub_10079361C(uint64_t a1)
{
  return sub_100793530((PersonalitySpecificImpl *)(a1 - 72));
}

void sub_100793624(uint64_t a1, BOOL *a2, BOOL *a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    sub_100793950(&v22, a3);
    int v7 = SHIBYTE(v22.__r_.__value_.__r.__words[2]);
    std::string::size_type v8 = v22.__r_.__value_.__r.__words[0];
    sub_100793950(&__p, a2);
    __int16 v9 = &v22;
    if (v7 < 0) {
      __int16 v9 = (std::string *)v8;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "handleCallStateChange";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v9;
    __int16 v24 = 2080;
    uint64_t v25 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Call State changed from (%s) to (%s)", buf, 0x20u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
  }
  if (a2[1] != a3[1])
  {
    if (a2[1])
    {
      uint64_t v11 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      if (!isCallHandoverWithoutIMSVoiceServiceSupported((Registry **)(a1 + 88), v11)) {
        return;
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 0;
      *(_OWORD *)&v22.__r_.__value_.__l.__data_ = 0uLL;
      sub_101299CF0(a1, &__p, &v22);
      int data = (int)__p.__r_.__value_.__l.__data_;
      std::string::size_type size = (std::__shared_weak_count *)v22.__r_.__value_.__l.__size_;
      uint64_t v13 = v22.__r_.__value_.__r.__words[0];
      if (v22.__r_.__value_.__l.__size_) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v22.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v15 = sub_100790F4C(a1, data, v13);
      if (size) {
        sub_10004D2C8(size);
      }
      if (v15)
      {
        *(void *)(a1 + 408) = v15;
        *(unsigned char *)(a1 + 416) = 1;
        int v16 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = "handleCallStateChange";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v15;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: Saved in call IMS pref value as %llu", buf, 0x16u);
        }
      }
      if (!size) {
        return;
      }
LABEL_31:
      sub_10004D2C8(size);
      return;
    }
    if (*(unsigned char *)(a1 + 416))
    {
      uint64_t v17 = *(NSObject **)(a1 + 56);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)
        || (uint64_t v18 = *(void *)(a1 + 408),
            *(_DWORD *)long long buf = 136315394,
            *(void *)&uint8_t buf[4] = "handleCallStateChange",
            *(_WORD *)&unsigned char buf[12] = 2048,
            *(void *)&buf[14] = v18,
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: Clear in call IMS pref(%llu)", buf, 0x16u), *(unsigned char *)(a1 + 416)))
      {
        *(unsigned char *)(a1 + 416) = 0;
      }
      LODWORD(v22.__r_.__value_.__l.__data_) = 0;
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      sub_101299CF0(a1, &v22, buf);
      uint64_t data_low = LODWORD(v22.__r_.__value_.__l.__data_);
      std::string::size_type size = *(std::__shared_weak_count **)&buf[8];
      v20[0] = *(void *)buf;
      v20[1] = *(void *)&buf[8];
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      sub_100791794((PersonalitySpecificImpl *)a1, data_low, v20);
      if (size)
      {
        sub_10004D2C8(size);
        goto LABEL_31;
      }
    }
  }
}

void sub_10079390C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (v19)
  {
    sub_10004D2C8(v19);
    sub_10004D2C8(v19);
  }
  _Unwind_Resume(exception_object);
}

void sub_100793950(std::string *a1, BOOL *a2)
{
  *((unsigned char *)&v15.__r_.__value_.__s + 23) = 8;
  strcpy((char *)&v15, "Active: ");
  int v4 = (const char *)asStringBool(*a2);
  size_t v5 = strlen(v4);
  uint64_t v6 = std::string::append(&v15, v4, v5);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  char v14 = 8;
  strcpy((char *)__p, ", VoIP: ");
  std::string::size_type v8 = std::string::append(&v16, (const std::string::value_type *)__p, 8uLL);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  unsigned int v10 = (const char *)asStringBool(a2[1]);
  size_t v11 = strlen(v10);
  dispatch_object_t v12 = std::string::append(&v17, v10, v11);
  *a1 = *v12;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
}

void sub_100793A9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100793AF8(uint64_t a1, BOOL *a2, BOOL *a3)
{
}

void sub_100793B00(PersonalitySpecificImpl *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v22 = 0;
  int v23 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 136))(&v22);
  uint64_t v8 = v22;
  if (*(_DWORD *)a2) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v22 == 0;
  }
  if (!v9)
  {
    if (a3 == 1 && *((void *)a1 + 53))
    {
      if ((*(unsigned int (**)(PersonalitySpecificImpl *))(*(void *)a1 + 520))(a1) != 5)
      {
        *(void *)(a4 + 48) = 0;
        *(_OWORD *)(a4 + 16) = 0u;
        *(_OWORD *)(a4 + 32) = 0u;
        *(_OWORD *)a4 = 0u;
        uint64_t v17 = asString();
        *(_DWORD *)a4 = -9;
        uint64_t v18 = "";
        if (v17) {
          uint64_t v18 = (const char *)v17;
        }
        *(void *)(a4 + 8) = "Initial iWLAN is backed off after baseband online";
        *(void *)(a4 + 16) = v18;
        *(_DWORD *)(a4 + 24) = 0;
        *(unsigned char *)(a4 + 28) = 0;
        *(_DWORD *)(a4 + 32) = 2;
        *(void *)(a4 + 44) = 0;
        *(void *)(a4 + 36) = 0;
        *(_DWORD *)(a4 + 52) = 0;
        sub_100793E20(a4);
      }
      uint64_t v8 = v22;
    }
    unsigned int v10 = v23;
    v21[0] = v8;
    v21[1] = (uint64_t)v23;
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = sub_100791C70((uint64_t)a1, a3, v21);
    if (v10) {
      sub_10004D2C8(v10);
    }
    if (!v11)
    {
      *(void *)(a4 + 48) = 0;
      *(_OWORD *)(a4 + 16) = 0u;
      *(_OWORD *)(a4 + 32) = 0u;
      *(_OWORD *)a4 = 0u;
      uint64_t v15 = asString();
      *(_DWORD *)a4 = 83;
      std::string v16 = "";
      if (v15) {
        std::string v16 = (const char *)v15;
      }
      *(void *)(a4 + 8) = "service mask is 0";
      *(void *)(a4 + 16) = v16;
      *(_DWORD *)(a4 + 24) = 0;
      *(unsigned char *)(a4 + 28) = 0;
      *(_DWORD *)(a4 + 32) = a3;
      *(void *)(a4 + 44) = 0;
      *(void *)(a4 + 36) = 0;
      *(_DWORD *)(a4 + 52) = 0;
      sub_100793E20(a4);
    }
    if (a3 == 1 && !(*(unsigned int (**)(PersonalitySpecificImpl *))(*(void *)a1 + 1216))(a1))
    {
      uint64_t v12 = *((void *)a1 + 27);
      uint64_t v13 = PersonalitySpecificImpl::simSlot(a1);
      if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 40))(v12, v13) & 1) == 0)
      {
        *(void *)(a4 + 48) = 0;
        *(_OWORD *)(a4 + 16) = 0u;
        *(_OWORD *)(a4 + 32) = 0u;
        *(_OWORD *)a4 = 0u;
        uint64_t v19 = asString();
        *(_DWORD *)a4 = -1;
        uint64_t v20 = "";
        if (v19) {
          uint64_t v20 = (const char *)v19;
        }
        *(void *)(a4 + 8) = "iWLAN is not the preferred context type and no iWLan over Cellular support";
        *(void *)(a4 + 16) = v20;
        *(_DWORD *)(a4 + 24) = 0;
        *(unsigned char *)(a4 + 28) = 0;
        *(void *)(a4 + 40) = 0;
        *(void *)(a4 + 48) = 0;
        *(void *)(a4 + 32) = 0;
        sub_100793E20(a4);
      }
    }
  }
  long long v14 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a4 = *(_OWORD *)a2;
  *(_OWORD *)(a4 + 16) = v14;
  *(void *)(a4 + 32) = *(void *)(a2 + 32);
  *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  if (v23) {
    sub_10004D2C8(v23);
  }
}

void sub_100793DD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  long long v14 = *(std::__shared_weak_count **)(v12 + 48);
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100793E20(uint64_t a1)
{
  do
    a1 = *(void *)(a1 + 40);
  while (a1);
  operator new();
}

uint64_t sub_100793EA8(PersonalitySpecificImpl *a1, uint64_t a2)
{
  uint64_t v3 = *((void *)a1 + 27);
  uint64_t v4 = PersonalitySpecificImpl::simSlot(a1);
  size_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 352);

  return v5(v3, v4, a2);
}

uint64_t sub_100793F14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 144);
  uint64_t v4 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)(a1 - 72));
  size_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 352);

  return v5(v3, v4, a2);
}

uint64_t sub_100793F88(PersonalitySpecificImpl *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *((void *)a1 + 27);
  uint64_t v6 = PersonalitySpecificImpl::simSlot(a1);
  long long v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v5 + 360);

  return v7(v5, v6, a2, a3);
}

uint64_t sub_100794004(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 144);
  uint64_t v6 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)(a1 - 72));
  long long v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v5 + 360);

  return v7(v5, v6, a2, a3);
}

void sub_100794088(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 392);
    uint64_t v3 = *(void *)(a1 + 400);
    if (*(unsigned char *)(a1 + 416)) {
      uint64_t v5 = *(void *)(a1 + 408);
    }
    else {
      uint64_t v5 = -1;
    }
    uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 387));
    int v7 = 134218754;
    uint64_t v8 = v4;
    __int16 v9 = 2048;
    uint64_t v10 = v3;
    __int16 v11 = 2048;
    uint64_t v12 = v5;
    __int16 v13 = 2080;
    uint64_t v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fImsPrefs[kDataContextBB] = %lu fImsPrefs[kDataContextIWLAN] = %lu fInCallImsPref = %lu fIsSatelliteSystem = %s", (uint8_t *)&v7, 0x2Au);
  }
}

uint64_t sub_100794174()
{
  return 0;
}

uint64_t sub_10079417C()
{
  return 200;
}

uint64_t sub_100794184()
{
  return 0;
}

uint64_t sub_10079418C()
{
  return 0;
}

uint64_t sub_100794194()
{
  return 0;
}

uint64_t sub_10079419C()
{
  return 200;
}

void sub_1007941A4(uint64_t a1, uint64_t a2)
{
  sub_1007941EC(&v2, a2);
}

void sub_1007941EC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10079425C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_100794304((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100794280(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007942B8(uint64_t a1)
{
}

uint64_t sub_1007942C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100794304(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    long long v2 = *(std::__shared_weak_count **)(a2 + 48);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
}

void sub_10079435C(void **a1)
{
  *a1 = off_101A07D68;
  long long v2 = a1 + 1;
  sub_100465E6C(&v2);
  PB::Base::~Base((PB::Base *)a1);
}

void sub_1007943B8(void **a1)
{
  *a1 = off_101A07D68;
  long long v2 = a1 + 1;
  sub_100465E6C(&v2);
  PB::Base::~Base((PB::Base *)a1);
  operator delete();
}

uint64_t sub_100794428(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  char v5 = *(unsigned char *)(a1 + 40);
  if (v5)
  {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 32));
    char v5 = *(unsigned char *)(a1 + 40);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(this, "result", *(unsigned char *)(a1 + 36));
  }
  uint64_t v6 = *(uint64_t **)(a1 + 8);
  int v7 = *(uint64_t **)(a1 + 16);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "slotInfo");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1007944F8(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_26:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 3) {
        sub_100465C64();
      }
      if (v20 == 2)
      {
        *(unsigned char *)(a1 + 40) |= 1u;
        unint64_t v27 = *((void *)this + 1);
        unint64_t v28 = *((void *)this + 2);
        uint64_t v29 = *(void *)this;
        if (v27 > 0xFFFFFFFFFFFFFFF5 || v27 + 10 > v28)
        {
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v32 = 0;
          if (v28 <= v27) {
            unint64_t v28 = *((void *)this + 1);
          }
          while (1)
          {
            if (v28 == v27)
            {
              LODWORD(v32) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_52;
            }
            unint64_t v37 = v27 + 1;
            char v38 = *(unsigned char *)(v29 + v27);
            *((void *)this + 1) = v37;
            v32 |= (unint64_t)(v38 & 0x7F) << v35;
            if ((v38 & 0x80) == 0) {
              break;
            }
            v35 += 7;
            unint64_t v27 = v37;
            BOOL v14 = v36++ > 8;
            if (v14)
            {
LABEL_48:
              LODWORD(v32) = 0;
              goto LABEL_52;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v32) = 0;
          }
        }
        else
        {
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v32 = 0;
          while (1)
          {
            unint64_t v33 = v27 + 1;
            *((void *)this + 1) = v27 + 1;
            char v34 = *(unsigned char *)(v29 + v27);
            v32 |= (unint64_t)(v34 & 0x7F) << v30;
            if ((v34 & 0x80) == 0) {
              break;
            }
            v30 += 7;
            unint64_t v27 = v33;
            BOOL v14 = v31++ > 8;
            if (v14) {
              goto LABEL_48;
            }
          }
        }
LABEL_52:
        *(_DWORD *)(a1 + 32) = v32;
      }
      else if (v20 == 1)
      {
        *(unsigned char *)(a1 + 40) |= 2u;
        unint64_t v23 = *((void *)this + 1);
        if (v23 >= *((void *)this + 2))
        {
          BOOL v26 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v24 = v23 + 1;
          int v25 = *(unsigned __int8 *)(*(void *)this + v23);
          *((void *)this + 1) = v24;
          BOOL v26 = v25 != 0;
        }
        *(unsigned char *)(a1 + 36) = v26;
      }
      else
      {
LABEL_20:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_26;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100794800(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  char v4 = *(unsigned char *)(result + 40);
  if ((v4 & 2) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(result + 36), 1u);
    char v4 = *(unsigned char *)(v3 + 40);
  }
  if (v4) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 32), 2u);
  }
  uint64_t v6 = *(const PB::Base ***)(v3 + 8);
  char v5 = *(const PB::Base ***)(v3 + 16);
  while (v6 != v5)
  {
    int v7 = *v6++;
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 3u);
  }
  return result;
}

void sub_10079487C(uint64_t *a1, uint64_t a2)
{
  int v2 = a2;
  uint64_t v3 = *a1;
  if (v3) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 16))(v3, a2);
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315394;
    uint64_t v5 = CSIEventString();
    __int16 v6 = 1024;
    int v7 = v2;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Sending event %s (%d)", (uint8_t *)&v4, 0x12u);
  }
}

BOOL sub_100794960@<W0>(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  if (a2)
  {
    CFDictionaryRef theDict = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
    uint64_t v5 = ServiceMap;
    if (v6 < 0)
    {
      int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        uint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v6;
    unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
    if (v10)
    {
      uint64_t v12 = v10[3];
      unint64_t v11 = (std::__shared_weak_count *)v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v13 = 0;
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v5);
    unint64_t v11 = 0;
    char v13 = 1;
LABEL_13:
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v12 + 80))(&v22, v12, a2, 1, @"SMSSettings", 0, 0);
    sub_10004EFE4(&theDict, &v22);
    sub_1000577C4(&v22);
    if ((v13 & 1) == 0) {
      sub_10004D2C8(v11);
    }
    if (theDict) {
      unsigned int v16 = sub_100080778;
    }
    else {
      unsigned int v16 = 0;
    }
    if (v16)
    {
      CFNumberRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"SupportsEMS");
      char v18 = Value;
      BOOL v15 = 1;
      buf[0] = 1;
      if (!Value)
      {
LABEL_23:
        sub_100057D78((const void **)&theDict);
        return v15;
      }
      CFTypeID v19 = CFGetTypeID(Value);
      if (v19 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)buf, v18, v20);
        BOOL v15 = buf[0] != 0;
        goto LABEL_23;
      }
    }
    BOOL v15 = 1;
    goto LABEL_23;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "msg.sms");
  BOOL v14 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "supportsEMS called with invalid slot:subscriber::SimSlot::kUnknown", buf, 2u);
  }
  return 0;
}

void sub_100794B88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000577C4(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

CFTypeRef sub_100794BC4(NSObject **a1, Registry **a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v37 = v7;
  unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v37);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v13 + 96))(&cf, v13, a3, 1, @"PhoneNumberRegistrationGatewayAddress", 0, 0);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  CFTypeRef v15 = cf;
  if (cf) {
    unsigned int v16 = sub_100080934;
  }
  else {
    unsigned int v16 = 0;
  }
  if (!v16)
  {
    char v18 = *a1;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      long long v37 = 0uLL;
      uint64_t v38 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = v37;
      uint64_t v33 = v38;
      CFTypeID v19 = __p;
      if (v38 < 0) {
        CFTypeID v19 = (void **)v37;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Carrier bundle does not have %s, returning NULL", buf, 0xCu);
      if (SHIBYTE(v33) < 0) {
        operator delete(__p[0]);
      }
    }
    goto LABEL_49;
  }
  if (cf)
  {
    CFTypeID v17 = CFGetTypeID(cf);
    if (v17 == CFStringGetTypeID()) {
      goto LABEL_38;
    }
    CFTypeRef v34 = cf;
    CFArrayRef theArray = 0;
    if (cf)
    {
      CFRetain(cf);
      __p[0] = (void *)v34;
      CFRetain(v34);
      goto LABEL_26;
    }
  }
  else
  {
    CFTypeRef v34 = 0;
    CFArrayRef theArray = 0;
  }
  __p[0] = 0;
LABEL_26:
  *(void *)long long buf = 0;
  *(void *)&long long v37 = 0;
  sub_100044D6C(&v37, (CFTypeRef *)__p);
  if ((void)v37) {
    CFBooleanRef v20 = sub_100083F10;
  }
  else {
    CFBooleanRef v20 = 0;
  }
  if (v20) {
    sub_100449580((const void **)buf, (const void **)&v37);
  }
  sub_100044D00((const void **)&v37);
  CFArrayRef theArray = *(CFArrayRef *)buf;
  *(void *)long long buf = 0;
  sub_100044D00((const void **)buf);
  sub_1000577C4((const void **)__p);
  sub_1000577C4(&v34);
  if (theArray) {
    uint64_t v21 = sub_100083F10;
  }
  else {
    uint64_t v21 = 0;
  }
  if (!v21)
  {
    uint64_t v29 = *a1;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      long long v37 = 0uLL;
      uint64_t v38 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = v37;
      uint64_t v33 = v38;
      char v30 = __p;
      if (v38 < 0) {
        char v30 = (void **)v37;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle has an unsupported type for value for %s", buf, 0xCu);
      if (SHIBYTE(v33) < 0) {
        operator delete(__p[0]);
      }
    }
    goto LABEL_48;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  unsigned int v23 = time(0);
  srand(v23);
  int v24 = rand();
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v24 % Count);
  CFTypeRef v15 = ValueAtIndex;
  if (!ValueAtIndex || (CFTypeID v26 = CFGetTypeID(ValueAtIndex), v26 != CFStringGetTypeID()))
  {
LABEL_48:
    sub_100044D00((const void **)&theArray);
LABEL_49:
    CFTypeRef v15 = 0;
    goto LABEL_50;
  }
  sub_100044D00((const void **)&theArray);
LABEL_38:
  CFRetain(v15);
  unint64_t v27 = *a1;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    long long v37 = 0uLL;
    uint64_t v38 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v37;
    uint64_t v33 = v38;
    unint64_t v28 = __p;
    if (v38 < 0) {
      unint64_t v28 = (void **)v37;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v28;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle value for recipient address: %s", buf, 0xCu);
    if (SHIBYTE(v33) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_50:
  sub_1000577C4(&cf);
  return v15;
}

void sub_100795048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1007950F0@<W0>(Registry **a1@<X0>, uint64_t a2@<X1>, unsigned __int8 *a3@<X2>, uint64_t *a4@<X8>)
{
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *a1);
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v14 + 96))(&cf, v14, a2, 1, @"PhoneNumberRegistrationGatewayAddress", 0, 0);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  CFTypeRef v16 = cf;
  if (cf) {
    CFTypeID v17 = sub_100080934;
  }
  else {
    CFTypeID v17 = 0;
  }
  if (!v17) {
    goto LABEL_51;
  }
  if (!cf) {
    goto LABEL_48;
  }
  CFTypeID v18 = CFGetTypeID(cf);
  if (v18 == CFStringGetTypeID()) {
    CFTypeRef v19 = v16;
  }
  else {
    CFTypeRef v19 = 0;
  }
  CFTypeRef v20 = cf;
  if (!cf)
  {
    if (!v19) {
      goto LABEL_48;
    }
LABEL_28:
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "msg.sms");
    int v24 = __n;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "PNR value is a string, doing single comparison", buf, 2u);
    }
    *(void *)long long buf = 0;
    size_t __n = 0;
    uint64_t v44 = 0;
    ctu::cf::assign();
    if (v44 >= 0) {
      size_t v25 = HIBYTE(v44);
    }
    else {
      size_t v25 = __n;
    }
    uint64_t v26 = a3[23];
    int v27 = (char)v26;
    if ((v26 & 0x80u) != 0) {
      uint64_t v26 = *((void *)a3 + 1);
    }
    if (v25 == v26)
    {
      if (v27 >= 0) {
        unint64_t v28 = a3;
      }
      else {
        unint64_t v28 = *(unsigned __int8 **)a3;
      }
      if (v44 < 0)
      {
        int v41 = *(void **)buf;
        BOOL v37 = memcmp(*(const void **)buf, v28, __n) == 0;
        goto LABEL_57;
      }
      if (!HIBYTE(v44))
      {
        BOOL v37 = 1;
        goto LABEL_52;
      }
      uint64_t v29 = HIBYTE(v44) - 1;
      char v30 = buf;
      do
      {
        int v32 = *v30++;
        int v31 = v32;
        int v34 = *v28++;
        int v33 = v34;
        BOOL v36 = v29-- != 0;
        BOOL v37 = v31 == v33;
      }
      while (v31 == v33 && v36);
    }
    else
    {
      BOOL v37 = 0;
    }
    if ((v44 & 0x8000000000000000) == 0) {
      goto LABEL_52;
    }
    int v41 = *(void **)buf;
LABEL_57:
    operator delete(v41);
    goto LABEL_52;
  }
  CFTypeID v21 = CFGetTypeID(cf);
  if (v21 != CFArrayGetTypeID()) {
    CFTypeRef v20 = 0;
  }
  if (v19) {
    goto LABEL_28;
  }
  if (v20)
  {
    uint64_t v22 = (const char *)kCtLoggingSystemName;
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "msg.sms");
    unsigned int v23 = __n;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "PNR value is an array, checking within array", buf, 2u);
    }
    ctu::cf::convert_copy();
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v22, "msg.sms");
    uint64_t v38 = __n;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
      goto LABEL_51;
    }
    *(_WORD *)long long buf = 0;
    __int16 v39 = "Unable to convert destination to string";
    goto LABEL_50;
  }
LABEL_48:
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "msg.sms");
  uint64_t v38 = __n;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    __int16 v39 = "PNR value is an unsupported type, ignoring";
LABEL_50:
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_INFO, v39, buf, 2u);
  }
LABEL_51:
  BOOL v37 = 0;
LABEL_52:
  sub_1000577C4(&cf);
  return v37;
}

void sub_10079551C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17)
{
}

void sub_100795560()
{
  if ((v0 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  JUMPOUT(0x100795558);
}

uint64_t sub_100795578(Registry **a1, uint64_t a2)
{
  CFNumberRef number = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t valuePtr = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &valuePtr);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v11 + 96))(&v16, v11, a2, 1, @"SMSSizeInBytesSentAsMMSInstead", 0, 0);
  sub_1000842D0(&number, &v16);
  sub_1000577C4(&v16);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (number) {
    uint64_t v13 = sub_100081E58;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13)
  {
    LODWORD(valuePtr) = 0;
    if (CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr)) {
      uint64_t v14 = valuePtr & ~((int)valuePtr >> 31);
    }
    else {
      uint64_t v14 = 0;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  sub_1000570E8((const void **)&number);
  return v14;
}

void sub_100795704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100795740(uint64_t a1, Registry **a2)
{
  CFTypeID v17 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v18);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v11 + 96))(&v16, v11, a1, 1, @"SMSEncoding", 0, 0);
  sub_1000842D0(&v17, &v16);
  sub_1000577C4(&v16);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  LODWORD(v18) = -1;
  ctu::cf::assign((ctu::cf *)&v18, v17, v13);
  uint64_t v14 = v18;
  sub_1000570E8((const void **)&v17);
  return v14;
}

void sub_10079589C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1007958D8@<X0>(uint64_t a1@<X0>, Registry **a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v18 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a2);
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    unsigned int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v19);
  if (v11)
  {
    uint64_t v13 = v11[3];
    char v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  char v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v13 + 96))(&v18, v13, a1, 1, @"HandleMTSmsAsMMSSenderAddress", 0, 0);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  sub_100058DB0(&v16, "6245");
  ctu::cf::assign();
  *(_OWORD *)a3 = v16;
  a3[2] = v17;
  uint64_t v17 = 0;
  long long v16 = 0uLL;
  return sub_1000577C4(&v18);
}

void sub_100795A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(&a16);
  _Unwind_Resume(a1);
}

time_t sub_100795A94(uint64_t a1)
{
  int8x16_t v1 = (int8x16_t)vrev64q_s32(*(int32x4_t *)a1);
  *(int8x16_t *)&v3.tm_sec = vextq_s8(v1, v1, 0xCuLL);
  *(int32x2_t *)&v3.tm_mon = vadd_s32(*(int32x2_t *)(a1 + 16), (int32x2_t)0xFFFFF894FFFFFFFFLL);
  memset(&v3.tm_wday, 0, 32);
  return timegm(&v3) - 60 * *(int *)(a1 + 24);
}

time_t sub_100795B00(uint64_t a1, Registry **a2, uint64_t a3)
{
  time_t v6 = time(0);
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *a2);
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v23);
  if (v14)
  {
    uint64_t v16 = v14[3];
    char v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  char v15 = 0;
  char v17 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v16 + 96))(&cf, v16, a1, 1, @"SMSUseLocalTZ", kCFBooleanFalse, 0);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  unint64_t v18 = (BOOL *)cf;
  LOBYTE(v23) = 0;
  if (!cf
    || (CFTypeID v19 = CFGetTypeID(cf), v19 != CFBooleanGetTypeID())
    || (ctu::cf::assign((ctu::cf *)&v23, v18, v20), !(_BYTE)v23))
  {
    time_t v6 = sub_100795A94(a3);
  }
  sub_1000577C4(&cf);
  return v6;
}

void sub_100795C98(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100795CC4(uint64_t a1, _DWORD *a2)
{
  CFPropertyListRef v4 = CFPreferencesCopyValue(@"TextToBinarySMS", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  char v17 = v4;
  unint64_t v18 = v4;
  if (v4) {
    CFRetain(v4);
  }
  __p[0] = 0;
  sub_1000057AC(__p, &v17);
  if (__p[0]) {
    unint64_t v5 = sub_100084B4C;
  }
  else {
    unint64_t v5 = 0;
  }
  if (v5)
  {
    BOOL v6 = __p[0] == kCFBooleanTrue;
  }
  else
  {
    CFNumberRef number = 0;
    sub_1000842D0(&number, &v17);
    LODWORD(valuePtr) = 0;
    if (number) {
      unint64_t v7 = sub_100081E58;
    }
    else {
      unint64_t v7 = 0;
    }
    if (v7)
    {
      if (CFNumberGetValue(number, kCFNumberIntType, &valuePtr)) {
        BOOL v8 = valuePtr == 0;
      }
      else {
        BOOL v8 = 1;
      }
      BOOL v6 = !v8;
    }
    else
    {
      BOOL v6 = 0;
    }
    sub_1000570E8((const void **)&number);
  }
  sub_100062778((const void **)__p);
  sub_1000577C4(&v17);
  if (v6)
  {
    CFNumberRef number = (CFNumberRef)&off_101A0BD40;
    CFDictionaryRef valuePtr = 0;
    sub_100058DB0(__p, "/System/Library/Frameworks/CoreTelephony.framework/Support/TextToBinaryMap.plist");
    (*((void (**)(const __CFDictionary **__return_ptr, CFNumberRef *, const CFAllocatorRef, void **))number
     + 20))(&valuePtr, &number, kCFAllocatorDefault, __p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    if (valuePtr) {
      uint64_t v9 = sub_100080778;
    }
    else {
      uint64_t v9 = 0;
    }
    if (v9)
    {
      if (*(char *)(a1 + 23) >= 0) {
        unint64_t v10 = (const char *)a1;
      }
      else {
        unint64_t v10 = *(const char **)a1;
      }
      CFStringRef v15 = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault, v10, 0x8000100u, kCFAllocatorNull);
      __p[0] = 0;
      __p[1] = (void *)v15;
      CFDictionaryApplyFunction(valuePtr, (CFDictionaryApplierFunction)sub_100796030, __p);
      if (__p[0])
      {
        CFTypeRef v13 = __p[0];
        CFNumberRef v14 = 0;
        sub_1000842D0(&v14, &v13);
        if (v14) {
          uint64_t v11 = sub_100081E58;
        }
        else {
          uint64_t v11 = 0;
        }
        if (v11)
        {
          LODWORD(v13) = 0;
          if (CFNumberGetValue(v14, kCFNumberIntType, &v13)) {
            *a2 = v13;
          }
        }
        sub_1000570E8((const void **)&v14);
      }
      sub_1000558F4((const void **)&v15);
    }
    sub_100057D78((const void **)&valuePtr);
    FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&number);
  }
  return sub_1000577C4(&v18);
}

void sub_100795F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, const void *a13, __int16 a14, char a15, char a16, int a17, const void *a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
}

CFStringRef sub_100796030(const __CFString *prefix, uint64_t a2, uint64_t a3)
{
  if (!*(void *)a3)
  {
    prefix = (const __CFString *)CFStringHasPrefix(*(CFStringRef *)(a3 + 8), prefix);
    if (prefix) {
      *(void *)a3 = a2;
    }
  }
  return prefix;
}

void sub_100796070(const char *a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, char **a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  v41[0] = 0;
  v41[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v41);
  size_t v10 = strlen(a1);
  ctu::TextConverter::setSource((ctu::TextConverter *)v41, a1, v10);
  ctu::TextConverter::pushConversion();
  int v11 = 0;
  uint64_t v12 = 0;
  while (1)
  {
    SourceCFIndex Count = ctu::TextConverter::getSourceCount((ctu::TextConverter *)v41);
    unsigned int Code = ctu::TextConverter::nextCode((ctu::TextConverter *)v41);
    if (Code == -1) {
      break;
    }
    if (Code >> 26 == 54) {
      int v15 = 4;
    }
    else {
      int v15 = a4;
    }
    if (v15 + v11 > a2)
    {
      uint64_t v16 = SourceCount - v12;
      unint64_t v18 = (uint64_t *)a5[1];
      unint64_t v17 = (unint64_t)a5[2];
      if ((unint64_t)v18 >= v17)
      {
        CFBooleanRef v20 = (uint64_t *)*a5;
        uint64_t v21 = ((char *)v18 - *a5) >> 3;
        unint64_t v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 61) {
          sub_10006A748();
        }
        uint64_t v23 = v17 - (void)v20;
        if (v23 >> 2 > v22) {
          unint64_t v22 = v23 >> 2;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v24 = v22;
        }
        if (v24)
        {
          size_t v25 = (char *)sub_10004EF74((uint64_t)(a5 + 2), v24);
          CFBooleanRef v20 = (uint64_t *)*a5;
          unint64_t v18 = (uint64_t *)a5[1];
        }
        else
        {
          size_t v25 = 0;
        }
        uint64_t v26 = &v25[8 * v21];
        *(void *)uint64_t v26 = v16;
        CFTypeID v19 = v26 + 8;
        while (v18 != v20)
        {
          uint64_t v27 = *--v18;
          *((void *)v26 - 1) = v27;
          v26 -= 8;
        }
        *a5 = v26;
        a5[1] = v19;
        a5[2] = &v25[8 * v24];
        if (v20) {
          operator delete(v20);
        }
      }
      else
      {
        uint64_t *v18 = v16;
        CFTypeID v19 = (char *)(v18 + 1);
      }
      int v11 = 0;
      a5[1] = v19;
      uint64_t v12 = SourceCount;
      a2 = a3;
    }
    v11 += v15;
  }
  if (ctu::TextConverter::getSourceCount((ctu::TextConverter *)v41))
  {
    uint64_t v28 = ctu::TextConverter::getSourceCount((ctu::TextConverter *)v41) - v12;
    char v30 = (uint64_t *)a5[1];
    unint64_t v29 = (unint64_t)a5[2];
    if ((unint64_t)v30 >= v29)
    {
      int v32 = (uint64_t *)*a5;
      uint64_t v33 = ((char *)v30 - *a5) >> 3;
      unint64_t v34 = v33 + 1;
      if ((unint64_t)(v33 + 1) >> 61) {
        sub_10006A748();
      }
      uint64_t v35 = v29 - (void)v32;
      if (v35 >> 2 > v34) {
        unint64_t v34 = v35 >> 2;
      }
      if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v36 = v34;
      }
      if (v36)
      {
        BOOL v37 = (char *)sub_10004EF74((uint64_t)(a5 + 2), v36);
        int v32 = (uint64_t *)*a5;
        char v30 = (uint64_t *)a5[1];
      }
      else
      {
        BOOL v37 = 0;
      }
      uint64_t v38 = &v37[8 * v33];
      __int16 v39 = &v37[8 * v36];
      *(void *)uint64_t v38 = v28;
      int v31 = v38 + 8;
      while (v30 != v32)
      {
        uint64_t v40 = *--v30;
        *((void *)v38 - 1) = v40;
        v38 -= 8;
      }
      *a5 = v38;
      a5[1] = v31;
      a5[2] = v39;
      if (v32) {
        operator delete(v32);
      }
    }
    else
    {
      *char v30 = v28;
      int v31 = (char *)(v30 + 1);
    }
    a5[1] = v31;
  }
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v41);
}

void sub_1007962E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)&a9);
  int v11 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v11;
    operator delete(v11);
  }
  _Unwind_Resume(a1);
}

void sub_100796324(os_log_t *a1@<X0>, const char *a2@<X1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, int a7@<W6>, char **a8@<X8>)
{
  *a8 = 0;
  a8[1] = 0;
  a8[2] = 0;
  v73[0] = 0;
  v73[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v73);
  CFStringRef v71 = a8;
  size_t v11 = strlen(a2);
  ctu::TextConverter::setSource((ctu::TextConverter *)v73, a2, v11);
  ctu::TextConverter::pushConversion();
  int v12 = 0;
  uint64_t v69 = 0;
  int v13 = 0;
  uint64_t v14 = 0;
  int v15 = a3 - a5;
  uint64_t v64 = (uint64_t)(v71 + 2);
  int v16 = -1;
  uint64_t v17 = -1;
  int v18 = a4;
  while (1)
  {
    SourceCFIndex Count = ctu::TextConverter::getSourceCount((ctu::TextConverter *)v73);
    uint64_t v20 = SourceCount;
    if (v16 == a6) {
      uint64_t v21 = SourceCount;
    }
    else {
      uint64_t v21 = v17;
    }
    if (v16 == a6) {
      int v13 = v12;
    }
    unsigned int Code = ctu::TextConverter::nextCode((ctu::TextConverter *)v73);
    int v16 = Code;
    if (Code == -1) {
      break;
    }
    if (Code >> 26 == 54) {
      int v23 = 4;
    }
    else {
      int v23 = v18;
    }
    if (v23 + v12 <= v15)
    {
      uint64_t v17 = v21;
    }
    else
    {
      uint64_t v68 = v14;
      v14 += v12 / v18;
      unint64_t v24 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134218240;
        uint64_t v75 = v68 + 1;
        __int16 v76 = 2048;
        uint64_t v77 = v14;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Looking for a space to cleanly break at for characters in range [%lu %lu]", buf, 0x16u);
      }
      if (v21 == -1 || v16 == a6 || (v12 -= v13, v15 - v12 < v15 / a7))
      {
        uint64_t v25 = v20 - v69;
        uint64_t v27 = v71[1];
        unint64_t v26 = (unint64_t)v71[2];
        if ((unint64_t)v27 >= v26)
        {
          unint64_t v29 = *v71;
          uint64_t v30 = (v27 - *v71) >> 3;
          unint64_t v31 = v30 + 1;
          if ((unint64_t)(v30 + 1) >> 61) {
            sub_10006A748();
          }
          uint64_t v32 = v26 - (void)v29;
          if (v32 >> 2 > v31) {
            unint64_t v31 = v32 >> 2;
          }
          if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v33 = v31;
          }
          if (v33)
          {
            unint64_t v34 = (char *)sub_10004EF74(v64, v33);
            unint64_t v29 = *v71;
            uint64_t v27 = v71[1];
          }
          else
          {
            unint64_t v34 = 0;
          }
          __int16 v39 = &v34[8 * v30];
          *(void *)__int16 v39 = v25;
          uint64_t v28 = v39 + 8;
          while (v27 != v29)
          {
            uint64_t v40 = *((void *)v27 - 1);
            v27 -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          *CFStringRef v71 = v39;
          v71[1] = v28;
          uint64_t v71[2] = &v34[8 * v33];
          if (v29) {
            operator delete(v29);
          }
        }
        else
        {
          *(void *)uint64_t v27 = v25;
          uint64_t v28 = v27 + 8;
        }
        int v12 = 0;
        v71[1] = v28;
        uint64_t v17 = v21;
        uint64_t v21 = v20;
      }
      else
      {
        uint64_t v35 = v21 - v69;
        BOOL v37 = v71[1];
        unint64_t v36 = (unint64_t)v71[2];
        if ((unint64_t)v37 >= v36)
        {
          int v41 = *v71;
          uint64_t v42 = (v37 - *v71) >> 3;
          unint64_t v43 = v42 + 1;
          if ((unint64_t)(v42 + 1) >> 61) {
            sub_10006A748();
          }
          uint64_t v44 = v36 - (void)v41;
          if (v44 >> 2 > v43) {
            unint64_t v43 = v44 >> 2;
          }
          if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v45 = v43;
          }
          if (v45)
          {
            uint32_t v46 = (char *)sub_10004EF74(v64, v45);
            int v41 = *v71;
            BOOL v37 = v71[1];
          }
          else
          {
            uint32_t v46 = 0;
          }
          __int16 v47 = &v46[8 * v42];
          *(void *)__int16 v47 = v35;
          uint64_t v38 = v47 + 8;
          while (v37 != v41)
          {
            uint64_t v48 = *((void *)v37 - 1);
            v37 -= 8;
            *((void *)v47 - 1) = v48;
            v47 -= 8;
          }
          *CFStringRef v71 = v47;
          v71[1] = v38;
          uint64_t v71[2] = &v46[8 * v45];
          if (v41) {
            operator delete(v41);
          }
        }
        else
        {
          *(void *)BOOL v37 = v35;
          uint64_t v38 = v37 + 8;
        }
        v71[1] = v38;
        v14 -= v12 / a4;
        uint64_t v17 = -1;
      }
      __int16 v49 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134218240;
        uint64_t v75 = v68 + 1;
        __int16 v76 = 2048;
        uint64_t v77 = v14;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I PDU pushed contains character in range [%lu %lu]", buf, 0x16u);
      }
      uint64_t v69 = v21;
      int v15 = a3;
      int v18 = a4;
    }
    v12 += v23;
  }
  if (ctu::TextConverter::getSourceCount((ctu::TextConverter *)v73))
  {
    BOOL v50 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      uint64_t v75 = v14 + 1;
      __int16 v76 = 2048;
      uint64_t v77 = v14 + v12 / a4;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I PDU pushed contains character in range [%lu %lu]", buf, 0x16u);
    }
    uint64_t v51 = ctu::TextConverter::getSourceCount((ctu::TextConverter *)v73) - v69;
    __int16 v53 = v71[1];
    unint64_t v52 = (unint64_t)v71[2];
    if ((unint64_t)v53 >= v52)
    {
      char v55 = *v71;
      uint64_t v56 = (v53 - *v71) >> 3;
      unint64_t v57 = v56 + 1;
      if ((unint64_t)(v56 + 1) >> 61) {
        sub_10006A748();
      }
      uint64_t v58 = v52 - (void)v55;
      if (v58 >> 2 > v57) {
        unint64_t v57 = v58 >> 2;
      }
      if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v59 = v57;
      }
      if (v59)
      {
        uint64_t v60 = (char *)sub_10004EF74(v64, v59);
        char v55 = *v71;
        __int16 v53 = v71[1];
      }
      else
      {
        uint64_t v60 = 0;
      }
      __int16 v61 = &v60[8 * v56];
      uint64_t v62 = &v60[8 * v59];
      *(void *)__int16 v61 = v51;
      uint64_t v54 = v61 + 8;
      while (v53 != v55)
      {
        uint64_t v63 = *((void *)v53 - 1);
        v53 -= 8;
        *((void *)v61 - 1) = v63;
        v61 -= 8;
      }
      *CFStringRef v71 = v61;
      v71[1] = v54;
      uint64_t v71[2] = v62;
      if (v55) {
        operator delete(v55);
      }
    }
    else
    {
      *(void *)__int16 v53 = v51;
      uint64_t v54 = v53 + 8;
    }
    v71[1] = v54;
  }
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v73);
}

void sub_10079686C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)va);
  int v12 = *(void **)a10;
  if (*(void *)a10)
  {
    *(void *)(a10 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007968BC(unsigned int a1)
{
  if ((int)a1 < 1)
  {
    LOBYTE(v1) = 0;
  }
  else if (a1 > 0x2D0)
  {
    if (a1 > 0x5A0)
    {
      if (a1 <= 0xA8C0) {
        LOBYTE(v1) = ((11651 * (unsigned __int16)a1) >> 24) - 90;
      }
      else {
        LOBYTE(v1) = a1 / 0x2760 - 64;
      }
    }
    else
    {
      return ((unsigned __int16)(a1 - 720) / 0x1Eu - 113);
    }
  }
  else
  {
    return ((unsigned __int16)a1 / 5u - 1);
  }
  return v1;
}

const void **sub_10079694C(uint64_t a1, Registry **a2, std::string *a3, int a4)
{
  if (a4) {
    CFStringRef v7 = @"SoftbankSMS-Any";
  }
  else {
    CFStringRef v7 = @"Any-SoftbankSMS";
  }
  CFBooleanRef v37 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    size_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  int v15 = 0;
  char v17 = 1;
LABEL_12:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v16 + 96))(&v36, v16, a1, 1, @"ConvertPublicEmojiCodePointsToPrivate", kCFBooleanFalse, 0);
  sub_1000057AC(&v37, &v36);
  sub_1000577C4(&v36);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (v37) {
    int v18 = sub_100084B4C;
  }
  else {
    int v18 = 0;
  }
  if (!v18 || v37 != kCFBooleanTrue)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "msg.sms");
    uint64_t v25 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      return sub_100062778((const void **)&v37);
    }
    unint64_t v26 = "public";
    if (a4) {
      unint64_t v26 = "private";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v26;
    uint64_t v27 = "Carrier bundle not set up to do code point conversion, keeping the codepoint as %s";
    uint64_t v28 = v25;
    uint32_t v29 = 12;
LABEL_44:
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v27, buf, v29);
    return sub_100062778((const void **)&v37);
  }
  id v19 = objc_alloc((Class)NSMutableString);
  if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v20 = (uint64_t *)a3;
  }
  else {
    uint64_t v20 = (uint64_t *)a3->__r_.__value_.__r.__words[0];
  }
  uint64_t v21 = (__CFString *)[v19 initWithUTF8String:v20];
  unint64_t v22 = (const char *)kCtLoggingSystemName;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "msg.sms");
  int v23 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    unint64_t v31 = "public -> private";
    if (a4) {
      unint64_t v31 = "private -> public";
    }
    if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v32 = a3;
    }
    else {
      uint64_t v32 = (std::string *)a3->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v31;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v32;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Carrier bundle contains \"ConvertPublicEmojiCodePointsToPrivate\"; attempting to perform %s code point conversion on \"%s\"",
      buf,
      0x16u);
    if (v21) {
      goto LABEL_24;
    }
    goto LABEL_41;
  }
  if (!v21)
  {
LABEL_41:
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v22, "msg.sms");
    unint64_t v33 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      return sub_100062778((const void **)&v37);
    }
    *(_WORD *)long long buf = 0;
    uint64_t v27 = "Unable to create mutable conversion string";
    uint64_t v28 = v33;
    uint32_t v29 = 2;
    goto LABEL_44;
  }
LABEL_24:
  if (CFStringTransform(v21, 0, v7, 0))
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v22, "msg.sms");
    unint64_t v24 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      id v35 = [(__CFString *)v21 UTF8String];
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v35;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Properly converted the codepoints to: %s", buf, 0xCu);
    }
    sub_10003ED78(a3, (char *)[(__CFString *)v21 UTF8String]);
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v22, "msg.sms");
    uint64_t v30 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Unable to perform private code point conversion", buf, 2u);
    }
  }

  return sub_100062778((const void **)&v37);
}

void sub_100796DD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100796E38(int a1@<W0>, uint64_t *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v13 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v13);
  if (*((char *)a2 + 23) >= 0) {
    BOOL v6 = a2;
  }
  else {
    BOOL v6 = (uint64_t *)*a2;
  }
  CFStringRef v7 = +[NSString stringWithUTF8String:v6];
  id v8 = objc_alloc((Class)CTPhoneNumber);
  if (a1 == 1) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = 2 * (a1 == 2);
  }
  id v10 = [v8 initWithDigits:v9 digits:v7 countryCode:0];
  size_t v11 = v10;
  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  if (v10)
  {
    id v12 = [v10 encodedString];
    if (v12) {
      sub_10003ED78(a3, (char *)[v12 UTF8String]);
    }
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v13);
}

void sub_100796F00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100796F30(uint64_t a1, uint64_t a2, const __CFString *a3, const void *a4, int a5)
{
  if (!*(void *)a2) {
    return 0;
  }
  std::string __p = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  CFDictionaryRef theDict = 0;
  if (a3)
  {
    *(void *)&long long valuePtr = @"SMSSettings";
    *((void *)&valuePtr + 1) = @"RetryStrategy";
    CFStringRef v43 = a3;
    CFStringRef v44 = @"RP-Error";
    sub_10015C6C8((char *)&__p, (char *)&valuePtr, (uint64_t)&v45, 4uLL);
    (*(void (**)(const void **__return_ptr))(**(void **)a2 + 104))(&v36);
    sub_10004EFE4(&v37, &v36);
    *(void *)&long long valuePtr = theDict;
    CFDictionaryRef v8 = v37;
    CFDictionaryRef v37 = 0;
    CFDictionaryRef theDict = v8;
    sub_100057D78((const void **)&valuePtr);
    sub_100057D78((const void **)&v37);
    sub_1000577C4(&v36);
    CFDictionaryRef v9 = theDict;
  }
  else
  {
    CFDictionaryRef v9 = 0;
  }
  if (v9) {
    size_t v11 = sub_100080778;
  }
  else {
    size_t v11 = 0;
  }
  if (!v11)
  {
    long long valuePtr = *(_OWORD *)off_101A07DB8;
    CFStringRef v43 = @"RP-Error";
    sub_10015C6C8((char *)&__p, (char *)&valuePtr, (uint64_t)&v44, 3uLL);
    (*(void (**)(const void **__return_ptr))(**(void **)a2 + 104))(&v36);
    sub_10004EFE4(&v37, &v36);
    *(void *)&long long valuePtr = theDict;
    CFDictionaryRef v12 = v37;
    CFDictionaryRef v37 = 0;
    CFDictionaryRef theDict = v12;
    sub_100057D78((const void **)&valuePtr);
    sub_100057D78((const void **)&v37);
    sub_1000577C4(&v36);
    CFDictionaryRef v9 = theDict;
  }
  if (v9) {
    uint64_t v13 = sub_100080778;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13
    && (CFArrayRef v14 = (const __CFArray *)CFDictionaryGetValue(v9, a4), (v15 = v14) != 0)
    && (CFTypeID v16 = CFGetTypeID(v14), v16 == CFArrayGetTypeID())
    && (CFIndex v17 = CFArrayGetCount(v15), v17 >= 1))
  {
    CFIndex v18 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, v18);
      CFDictionaryRef v20 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v21 = CFGetTypeID(ValueAtIndex);
        if (v21 == CFDictionaryGetTypeID())
        {
          CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v20, @"CauseCodes");
          CFArrayRef v23 = Value;
          if (Value)
          {
            CFTypeID v24 = CFGetTypeID(Value);
            if (v24 == CFArrayGetTypeID())
            {
              CFIndex Count = CFArrayGetCount(v23);
              if (Count >= 1) {
                break;
              }
            }
          }
        }
      }
LABEL_30:
      if (++v18 == v17) {
        goto LABEL_31;
      }
    }
    CFIndex v26 = 0;
    while (1)
    {
      uint64_t v27 = (int *)CFArrayGetValueAtIndex(v23, v26);
      uint64_t v28 = v27;
      LODWORD(valuePtr) = 0;
      if (v27)
      {
        CFTypeID v29 = CFGetTypeID(v27);
        if (v29 == CFNumberGetTypeID()) {
          ctu::cf::assign((ctu::cf *)&valuePtr, v28, v30);
        }
      }
      if (valuePtr == a5) {
        break;
      }
      if (Count == ++v26) {
        goto LABEL_30;
      }
    }
    CFNumberRef v32 = (const __CFNumber *)CFDictionaryGetValue(v20, @"ServiceStateMask");
    CFNumberRef v33 = v32;
    if (v32)
    {
      CFTypeID v34 = CFGetTypeID(v32);
      if (v34 == CFNumberGetTypeID()) {
        CFNumberRef v35 = v33;
      }
      else {
        CFNumberRef v35 = 0;
      }
    }
    else
    {
      CFNumberRef v35 = 0;
    }
    LODWORD(valuePtr) = 0;
    if (CFNumberGetValue(v35, kCFNumberIntType, &valuePtr)) {
      uint64_t v10 = valuePtr;
    }
    else {
      uint64_t v10 = 0;
    }
  }
  else
  {
LABEL_31:
    uint64_t v10 = 0;
  }
  sub_100057D78((const void **)&theDict);
  if (__p)
  {
    uint64_t v40 = __p;
    operator delete(__p);
  }
  return v10;
}

void sub_1007972F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, void *__p, uint64_t a13)
{
  if (__p)
  {
    a13 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100797358(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  if ((a4 - 38) > 9) {
    uint64_t v8 = 43200;
  }
  else {
    uint64_t v8 = dword_1014F0478[a4 - 38];
  }
  uint64_t v9 = *a2;
  if (!*a2) {
    return v8;
  }
  CFDictionaryRef theDict = 0;
  if (a3)
  {
    uint64_t v10 = operator new(0x20uLL);
    uint64_t v42 = v10 + 4;
    CFStringRef v43 = v10 + 4;
    void *v10 = @"SMSSettings";
    v10[1] = @"RetryStrategy";
    void v10[2] = a3;
    void v10[3] = @"RP-Error";
    std::string __p = v10;
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v9 + 104))(&v44, v9, a1, 2, &__p, 0, 0);
    sub_10004EFE4(&v45, &v44);
    CFDictionaryRef v11 = theDict;
    CFDictionaryRef theDict = v45;
    CFDictionaryRef v47 = v11;
    CFDictionaryRef v45 = 0;
    sub_100057D78((const void **)&v47);
    sub_100057D78((const void **)&v45);
    sub_1000577C4(&v44);
    if (__p)
    {
      uint64_t v42 = __p;
      operator delete(__p);
    }
    CFDictionaryRef v12 = theDict;
    if (theDict) {
      uint64_t v13 = sub_100080778;
    }
    else {
      uint64_t v13 = 0;
    }
    if (v13) {
      goto LABEL_16;
    }
    uint64_t v9 = *a2;
  }
  CFArrayRef v14 = operator new(0x18uLL);
  uint64_t v42 = v14 + 3;
  CFStringRef v43 = v14 + 3;
  *(_OWORD *)CFArrayRef v14 = *(_OWORD *)off_101A07DB8;
  v14[2] = @"RP-Error";
  std::string __p = v14;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v9 + 104))(&v44, v9, a1, 2, &__p, 0, 0);
  sub_10004EFE4(&v45, &v44);
  CFDictionaryRef v15 = theDict;
  CFDictionaryRef theDict = v45;
  CFDictionaryRef v47 = v15;
  CFDictionaryRef v45 = 0;
  sub_100057D78((const void **)&v47);
  sub_100057D78((const void **)&v45);
  sub_1000577C4(&v44);
  if (__p)
  {
    uint64_t v42 = __p;
    operator delete(__p);
  }
  CFDictionaryRef v12 = theDict;
LABEL_16:
  if (v12) {
    CFTypeID v16 = sub_100080778;
  }
  else {
    CFTypeID v16 = 0;
  }
  if (v16)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v12, @"ThrottlingParameters");
    CFArrayRef v18 = Value;
    if (Value)
    {
      CFTypeID v19 = CFGetTypeID(Value);
      if (v19 == CFArrayGetTypeID())
      {
        CFIndex Count = CFArrayGetCount(v18);
        if (Count >= 1)
        {
          CFIndex v40 = Count;
          CFIndex v21 = 0;
          while (1)
          {
            CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v18, v21);
            CFArrayRef v23 = ValueAtIndex;
            if (ValueAtIndex)
            {
              CFTypeID v24 = CFGetTypeID(ValueAtIndex);
              CFDictionaryRef v25 = v24 == CFDictionaryGetTypeID() ? (const __CFDictionary *)v23 : 0;
            }
            else
            {
              CFDictionaryRef v25 = 0;
            }
            CFIndex v26 = CFDictionaryGetValue(v25, @"CauseCodes");
            uint64_t v27 = v26;
            if (v26)
            {
              CFTypeID v28 = CFGetTypeID(v26);
              CFArrayRef v29 = v28 == CFArrayGetTypeID() ? (const __CFArray *)v27 : 0;
            }
            else
            {
              CFArrayRef v29 = 0;
            }
            CFIndex v30 = CFArrayGetCount(v29);
            if (v30 >= 1) {
              break;
            }
LABEL_41:
            if (++v21 == v40) {
              goto LABEL_47;
            }
          }
          CFIndex v31 = 0;
          while (1)
          {
            CFNumberRef v32 = (unsigned int *)CFArrayGetValueAtIndex(v29, v31);
            CFNumberRef v33 = v32;
            LODWORD(__p) = 0;
            if (v32)
            {
              CFTypeID v34 = CFGetTypeID(v32);
              if (v34 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)&__p, v33, v35);
              }
            }
            if (__p == a4) {
              break;
            }
            if (v30 == ++v31) {
              goto LABEL_41;
            }
          }
          unint64_t v36 = CFDictionaryGetValue(v25, @"DelayInSeconds");
          uint64_t v8 = (uint64_t)v36;
          LODWORD(__p) = 0;
          if (v36)
          {
            CFTypeID v37 = CFGetTypeID(v36);
            if (v37 == CFNumberGetTypeID())
            {
              ctu::cf::assign((ctu::cf *)&__p, (unsigned int *)v8, v38);
              uint64_t v8 = __p;
            }
            else
            {
              uint64_t v8 = 0;
            }
          }
        }
      }
    }
  }
LABEL_47:
  sub_100057D78((const void **)&theDict);
  return v8;
}

void sub_100797708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, const void *a15)
{
}

uint64_t sub_10079776C(uint64_t a1, void *a2, const __CFString *a3, int a4)
{
  CFPropertyListRef v4 = (std::__shared_weak_count *)a2[1];
  v7[0] = *a2;
  v7[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = sub_100796F30(a1, (uint64_t)v7, a3, @"FatalCauseCodes", a4);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return v5;
}

void sub_1007977D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007977E8(uint64_t a1, void *a2, const __CFString *a3, int a4)
{
  CFPropertyListRef v4 = (std::__shared_weak_count *)a2[1];
  v7[0] = *a2;
  v7[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = sub_100796F30(a1, (uint64_t)v7, a3, @"NonFatalCauseCodes", a4);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return v5;
}

void sub_10079784C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100797864@<W0>(Registry **a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t *a4@<X8>)
{
  CFDictionaryRef theDict = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *a1);
  CFStringRef v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v8;
  CFDictionaryRef v12 = sub_10004D37C(&v7[1].__m_.__sig, &v26);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v14 + 80))(&v24, v14, a2, 1, @"SMSSettings", 0, 0);
  sub_10004EFE4(&theDict, &v24);
  sub_1000577C4(&v24);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (theDict) {
    CFTypeID v16 = sub_100080778;
  }
  else {
    CFTypeID v16 = 0;
  }
  if (v16)
  {
    CFArrayRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"SupportsEMSOnC2K");
    CFArrayRef v18 = Value;
    int v19 = 1;
    LOBYTE(v26) = 1;
    if (Value)
    {
      CFTypeID v20 = CFGetTypeID(Value);
      if (v20 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v26, v18, v21);
        int v19 = v26;
      }
      else
      {
        int v19 = 1;
      }
    }
    BOOL v22 = 1;
    if (a3 <= 8 && ((1 << a3) & 0x138) != 0) {
      BOOL v22 = v19 != 0;
    }
  }
  else
  {
    BOOL v22 = 1;
  }
  sub_100057D78((const void **)&theDict);
  return v22;
}

void sub_100797A4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100798188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100798274()
{
}

void sub_10079837C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    sub_10004D2C8(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  dispatch_release(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007983C8(uint64_t a1, void *a2, NSObject **a3, int a4, void *a5, const void *a6)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, "vinyl.receipt");
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  CFDictionaryRef v12 = *a3;
  *(void *)(a1 + 56) = *a3;
  if (v12) {
    dispatch_retain(v12);
  }
  *(void *)(a1 + 64) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v18, &v17);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 72), (const ctu::OsLogLogger *)v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)a1 = off_101A07DF0;
  *(void *)(a1 + 80) = *a2;
  uint64_t v13 = a2[1];
  *(void *)(a1 + 88) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 96) = 0uLL;
  *(_OWORD *)(a1 + 112) = 0uLL;
  if (a6) {
    uint64_t v14 = _Block_copy(a6);
  }
  else {
    uint64_t v14 = 0;
  }
  *(void *)(a1 + 128) = v14;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 176) = 0x10000;
  *(_DWORD *)(a1 + 180) = a4;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 208) = *a5;
  uint64_t v15 = a5[1];
  *(void *)(a1 + 216) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 248) = 0;
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  return a1;
}

void sub_10079853C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  sub_100087E88(v2);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100798568(uint64_t a1)
{
  *(void *)a1 = off_101A07DF0;
  int v2 = *(std::__shared_weak_count **)(a1 + 360);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 351) < 0) {
    operator delete(*(void **)(a1 + 328));
  }
  if (*(char *)(a1 + 327) < 0) {
    operator delete(*(void **)(a1 + 304));
  }
  if (*(char *)(a1 + 303) < 0) {
    operator delete(*(void **)(a1 + 280));
  }
  int v3 = *(void **)(a1 + 256);
  if (v3)
  {
    *(void *)(a1 + 264) = v3;
    operator delete(v3);
  }
  unsigned int v11 = (void **)(a1 + 224);
  sub_10079AAD4(&v11);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 216);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  uint64_t v5 = *(const void **)(a1 + 128);
  if (v5) {
    _Block_release(v5);
  }
  uint64_t v6 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  if (v6) {
    sub_1007A8468(a1 + 120, v6);
  }
  uint64_t v7 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = 0;
  if (v7) {
    sub_1007A84C4(v7);
  }
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 104);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 88);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10132A164(a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 72));
  sub_100087E88((void *)(a1 + 40));
  return a1;
}

void sub_1007986A4(uint64_t a1)
{
  sub_100798568(a1);

  operator delete();
}

uint64_t sub_1007986DC(uint64_t result, uint64_t *a2, uint64_t a3)
{
  if (!*(void *)(result + 96))
  {
    uint64_t v3 = result;
    if (!*(unsigned char *)(result + 179))
    {
      uint64_t v6 = *(NSObject **)(result + 72);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        sCardSerialNumberAsString();
        uint64_t v7 = v15 >= 0 ? &__p : (void **)__p;
        *(_DWORD *)long long buf = 136315138;
        OsLogContext v17 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Starting Vinyl receipts procedure for %s", buf, 0xCu);
        if (v15 < 0) {
          operator delete(__p);
        }
      }
      uint64_t v9 = *a2;
      uint64_t v8 = a2[1];
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v10 = *(std::__shared_weak_count **)(v3 + 104);
      *(void *)(v3 + 96) = v9;
      *(void *)(v3 + 104) = v8;
      if (v10) {
        sub_10004D2C8(v10);
      }
      *(_OWORD *)(v3 + 160) = *(_OWORD *)(a3 + 16);
      if (*(unsigned char *)(a3 + 80))
      {
        uint64_t v11 = *(void *)(a3 + 56);
        uint64_t v12 = *(void *)(a3 + 64);
        if (v11 != v12)
        {
          while (!*(unsigned char *)(v11 + 88))
          {
            v11 += 216;
            if (v11 == v12) {
              goto LABEL_20;
            }
          }
        }
        if (v11 != v12) {
          std::string::operator=((std::string *)(v3 + 184), (const std::string *)(v11 + 16));
        }
      }
LABEL_20:
      (*(void (**)(const void **__return_ptr))(**(void **)(v3 + 208) + 40))(&v13);
      sub_10132A314(v3, &v13);
      sub_100044D00(&v13);
      operator new();
    }
  }
  return result;
}

void sub_1007989B8()
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  std::__shared_weak_count::__release_weak(v1);
  uint64_t v3 = *(std::__shared_weak_count **)(v0 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  std::__shared_weak_count::__release_weak(v1);
  operator delete();
}

uint64_t sub_100798A48(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 179);
}

void sub_100798A50()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Pause isnt supported on receipts operations!");
}

void sub_100798A98(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100798AAC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 178);
}

uint64_t sub_100798AB4()
{
  return 0;
}

void sub_100798ABC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 179))
  {
    uint64_t v2 = "done";
  }
  else if (*(unsigned char *)(a1 + 178))
  {
    uint64_t v2 = "paused";
  }
  else
  {
    uint64_t v2 = "running";
  }
  uint64_t v3 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(unsigned __int16 *)(a1 + 176);
    unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 232) - *(void *)(a1 + 224)) >> 4);
    uint64_t v6 = *(void *)(a1 + 264) - *(void *)(a1 + 256);
    int v7 = 136315906;
    uint64_t v8 = v2;
    __int16 v9 = 1024;
    int v10 = v4;
    __int16 v11 = 2048;
    unint64_t v12 = v5;
    __int16 v13 = 2048;
    uint64_t v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I VinylReceiptsOperation: {\n  fRunning = %s (retries used=%d)\n  fReceiptsInfo = %lu receipts\n  fReceiptCFDataRef Data = %lu bytes\n}", (uint8_t *)&v7, 0x26u);
  }
}

const void **sub_100798BD4(uint64_t a1)
{
  if (*(char *)(a1 + 303) < 0)
  {
    **(unsigned char **)(a1 + 280) = 0;
    *(void *)(a1 + 288) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 280) = 0;
    *(unsigned char *)(a1 + 303) = 0;
  }
  *(void *)(a1 + 264) = *(void *)(a1 + 256);
  *(_DWORD *)(a1 + 248) = 0;
  if (*(char *)(a1 + 327) < 0)
  {
    **(unsigned char **)(a1 + 304) = 0;
    *(void *)(a1 + 312) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 304) = 0;
    *(unsigned char *)(a1 + 327) = 0;
  }
  if (*(char *)(a1 + 351) < 0)
  {
    **(unsigned char **)(a1 + 328) = 0;
    *(void *)(a1 + 336) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 328) = 0;
    *(unsigned char *)(a1 + 351) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 224);
  for (uint64_t i = *(void *)(a1 + 232); i != v3; sub_10075516C(i))
    i -= 80;
  *(void *)(a1 + 232) = v3;
  int v4 = *(std::__shared_weak_count **)(a1 + 360);
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 360) = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
  unint64_t v5 = *(const void **)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  int v7 = v5;
  return sub_100044D00(&v7);
}

uint64_t sub_100798CB4(uint64_t result)
{
  if (!*(unsigned char *)(result + 179))
  {
    uint64_t v1 = result;
    uint64_t v2 = *(NSObject **)(result + 72);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Cancelling receipts procedure", buf, 2u);
    }
    uint64_t v3 = *(void *)(v1 + 112);
    if (v3)
    {
      v4[0] = 0;
      int v5 = 0;
      return sub_1007A9B94(v3, (uint64_t)v4, 1);
    }
    else
    {
      uint64_t result = sub_100798D54(v1, 1);
      *(unsigned char *)(v1 + 178) = 0;
    }
  }
  return result;
}

uint64_t sub_100798D54(uint64_t result, int a2)
{
  if (!*(unsigned char *)(result + 179))
  {
    uint64_t v3 = result;
    sub_1004EFE28(*(unsigned int *)(result + 180), a2);
    *(unsigned char *)(v3 + 179) = 1;
    switch(a2)
    {
      case 0:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        int v4 = *(NSObject **)(v3 + 72);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v8 = 0;
          int v5 = "#I [X] Vinyl receipts operation complete: error=failed";
          uint64_t v6 = (uint8_t *)&v8;
          goto LABEL_5;
        }
        break;
      case 1:
        int v4 = *(NSObject **)(v3 + 72);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v9 = 0;
          int v5 = "#I [X] Vinyl receipts operation complete: error=cancelled";
          uint64_t v6 = (uint8_t *)&v9;
          goto LABEL_5;
        }
        break;
      case 2:
        int v4 = *(NSObject **)(v3 + 72);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v10 = 0;
          int v5 = "#I [X] Vinyl receipts operation complete: error=rejected";
          uint64_t v6 = (uint8_t *)&v10;
          goto LABEL_5;
        }
        break;
      case 10:
        int v4 = *(NSObject **)(v3 + 72);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v11 = 0;
          int v5 = "#I [X] Vinyl receipts operation complete: success!";
          uint64_t v6 = (uint8_t *)&v11;
LABEL_5:
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
        }
        break;
      default:
        break;
    }
    (*(void (**)(void))(*(void *)(v3 + 128) + 16))(*(void *)(v3 + 128));
    int v7 = *(const void **)(v3 + 128);
    *(void *)(v3 + 128) = 0;
    if (v7) {
      _Block_release(v7);
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 88))(v3);
  }
  return result;
}

uint64_t sub_100798F14(uint64_t result)
{
  if (!*(unsigned char *)(result + 179))
  {
    uint64_t v1 = result;
    uint64_t v2 = *(NSObject **)(result + 72);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Cancelling receipts procedure with failure", buf, 2u);
    }
    uint64_t v3 = *(void *)(v1 + 112);
    if (v3)
    {
      v4[0] = 0;
      int v5 = 0;
      return sub_1007A9B94(v3, (uint64_t)v4, 1);
    }
    else
    {
      uint64_t result = sub_100798D54(v1, 0);
      *(unsigned char *)(v1 + 178) = 0;
    }
  }
  return result;
}

void sub_100798FB4(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    int v5 = (void *)a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_100799138;
        void v13[3] = &unk_101A07E50;
        void v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        __int16 v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        __int16 v11 = v10;
        unint64_t v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        void block[2] = sub_1007AA9BC;
        block[3] = &unk_101A08220;
        block[5] = v9;
        CFArrayRef v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            CFTypeID v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100799120(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100799138(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 != 2)
  {
    if (v3 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    char v55 = 0;
    uint64_t v56 = 0;
    uint64_t v57 = 0;
    sub_10005C928(&v55, *(const void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
    int v4 = sub_100751D1C((uint64_t *)&v55);
    int v5 = v4;
    if (v4)
    {
      if (v4 != 9)
      {
        uint64_t v6 = *(NSObject **)(v2 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I List notification response failure", (uint8_t *)buf, 2u);
        }
        uint64_t v7 = *(void *)(v2 + 120);
        if (v7) {
          sub_100EE8BC8(v7, "ListNotificationRsp");
        }
        else {
          *(void *)(v2 + 120) = 0;
        }
        uint64_t v19 = *(void *)(v2 + 112);
        LOBYTE(buf[0]) = 0;
        DWORD1(buf[0]) = v5;
        sub_1007A9B94(v19, (uint64_t)buf, 1);
        goto LABEL_80;
      }
LABEL_79:
      sub_1007AA148(*(void *)(v2 + 112), (uint64_t)buf, 1);
LABEL_80:
      if (v55)
      {
        uint64_t v56 = v55;
        operator delete(v55);
      }
      return;
    }
    if (*(void *)(v2 + 232) == *(void *)(v2 + 224)) {
      goto LABEL_79;
    }
    uint64_t v18 = *(void *)(v2 + 120);
    if (v18) {
      sub_100EE8BC8(v18, "ListNotificationRsp");
    }
    else {
      *(void *)(v2 + 120) = 0;
    }
    unint64_t v52 = 0;
    __int16 v53 = 0;
    uint64_t v54 = 0;
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v67 = 0u;
    memset(buf, 0, sizeof(buf));
    (*(void (**)(void, void **))(**(void **)(v2 + 208) + 24))(*(void *)(v2 + 208), &v52);
    if (v52 != v53)
    {
      std::string __p = 0;
      BOOL v50 = 0;
      uint64_t v51 = 0;
      sub_10005C928(&__p, v52, (uint64_t)v53, v53 - (unsigned char *)v52);
      int v20 = sub_10074FA50(&__p, v2 + 328);
      if (__p)
      {
        BOOL v50 = __p;
        operator delete(__p);
      }
      if (v20) {
        std::string::operator=((std::string *)(v2 + 304), (const std::string *)&buf[1]);
      }
    }
    uint64_t v21 = *(void *)(v2 + 224);
    BOOL v22 = *(const void ***)(v2 + 232);
    unint64_t v23 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v22 - v21) >> 4));
    if (v22 == (const void **)v21) {
      uint64_t v24 = 0;
    }
    else {
      uint64_t v24 = v23;
    }
    sub_10079ABAC(v21, v22, v24, 1);
    uint64_t v25 = *(void *)(v2 + 224);
    uint64_t v26 = *(void *)(v2 + 232);
    if (v26 == v25)
    {
LABEL_75:
      if (*((void *)&v78 + 1))
      {
        *(void *)&long long v79 = *((void *)&v78 + 1);
        operator delete(*((void **)&v78 + 1));
      }
      sub_1000C584C((uint64_t)buf);
      if (v52)
      {
        __int16 v53 = v52;
        operator delete(v52);
      }
      goto LABEL_79;
    }
    uint64_t v27 = *(void *)(v2 + 224);
    while (1)
    {
      uint64_t v58 = 0;
      unint64_t v59 = 0;
      uint64_t v60 = 0;
      sub_10005C928(&v58, *(const void **)v27, *(void *)(v27 + 8), *(void *)(v27 + 8) - *(void *)v27);
      if (*(char *)(v27 + 47) < 0)
      {
        sub_10004FC84(&__s1, *(void **)(v27 + 24), *(void *)(v27 + 32));
      }
      else
      {
        long long v28 = *(_OWORD *)(v27 + 24);
        uint64_t v62 = *(void *)(v27 + 40);
        long long __s1 = v28;
      }
      if (*(char *)(v27 + 71) < 0)
      {
        sub_10004FC84(&v63, *(void **)(v27 + 48), *(void *)(v27 + 56));
      }
      else
      {
        long long v29 = *(_OWORD *)(v27 + 48);
        uint64_t v64 = *(void *)(v27 + 64);
        long long v63 = v29;
      }
      __int16 v65 = *(_WORD *)(v27 + 72);
      char v30 = HIBYTE(v62);
      if (v62 >= 0) {
        uint64_t v31 = HIBYTE(v62);
      }
      else {
        uint64_t v31 = *((void *)&__s1 + 1);
      }
      uint64_t v32 = *(unsigned __int8 *)(v25 + 47);
      int v33 = (char)v32;
      if ((v32 & 0x80u) != 0) {
        uint64_t v32 = *(void *)(v25 + 32);
      }
      if (v31 == v32)
      {
        if (v33 >= 0) {
          CFTypeID v34 = (unsigned __int8 *)(v25 + 24);
        }
        else {
          CFTypeID v34 = *(unsigned __int8 **)(v25 + 24);
        }
        if (SHIBYTE(v62) < 0)
        {
          BOOL v43 = memcmp((const void *)__s1, v34, *((size_t *)&__s1 + 1)) == 0;
        }
        else if (HIBYTE(v62))
        {
          uint64_t v35 = HIBYTE(v62) - 1;
          p_s1 = &__s1;
          do
          {
            int v38 = *(unsigned __int8 *)p_s1;
            p_s1 = (long long *)((char *)p_s1 + 1);
            int v37 = v38;
            int v40 = *v34++;
            int v39 = v40;
            BOOL v42 = v35-- != 0;
            BOOL v43 = v37 == v39;
          }
          while (v37 == v39 && v42);
        }
        else
        {
          BOOL v43 = 1;
        }
      }
      else
      {
        BOOL v43 = 0;
      }
      if (SHIBYTE(v64) < 0)
      {
        operator delete((void *)v63);
        if ((v62 & 0x8000000000000000) == 0) {
          goto LABEL_64;
        }
      }
      else if ((v30 & 0x80) == 0)
      {
        goto LABEL_64;
      }
      operator delete((void *)__s1);
LABEL_64:
      if (v58)
      {
        unint64_t v59 = v58;
        operator delete(v58);
      }
      if (!v43) {
        goto LABEL_71;
      }
      v27 += 80;
      if (v27 == v26)
      {
        uint64_t v27 = v26;
LABEL_71:
        unint64_t v44 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((v27 - v25) >> 4));
        if (v27 == v25) {
          uint64_t v45 = 0;
        }
        else {
          uint64_t v45 = v44;
        }
        sub_1007A1244(v25, (void *)v27, v45, 1);
        uint64_t v26 = *(void *)(v2 + 232);
        uint64_t v25 = v27;
        if (v26 == v27) {
          goto LABEL_75;
        }
      }
    }
  }
  if (*(unsigned char *)(a1 + 48) == 3 && (unsigned int v8 = *(unsigned __int16 *)(v2 + 176), v8 <= 2))
  {
    *(_WORD *)(v2 + 176) = v8 + 1;
    uint64_t v9 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = asString();
      int v11 = *(unsigned __int16 *)(v2 + 176);
      LODWORD(buf[0]) = 136315394;
      *(void *)((char *)buf + 4) = v10;
      WORD6(buf[0]) = 1024;
      *(_DWORD *)((char *)buf + 14) = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I List notification failed with temporary error %s; retrying (retry #%d)",
        (uint8_t *)buf,
        0x12u);
    }
    sub_1007AA4F8(*(void *)(v2 + 112), (uint64_t)buf, 1);
  }
  else
  {
    unint64_t v12 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "List notification failed with final error %s; aborting",
        (uint8_t *)buf,
        0xCu);
    }
    uint64_t v13 = *(void *)(v2 + 112);
    LOBYTE(buf[0]) = 0;
    DWORD1(buf[0]) = 0;
    sub_1007A9B94(v13, (uint64_t)buf, 1);
    int v14 = *(unsigned __int8 *)(a1 + 40);
    if (v14 != 2)
    {
      if (v14 == 1)
      {
        uint32_t v46 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v46);
      }
      uint64_t v48 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v48);
    }
    if (*(unsigned char *)(a1 + 48) == 2)
    {
      unsigned int v15 = *(_DWORD *)(v2 + 180);
      unsigned int v16 = *(unsigned __int8 *)(a1 + 49);
      unsigned int v17 = *(unsigned __int8 *)(a1 + 50);
      *(void *)&buf[0] = _NSConcreteStackBlock;
      *((void *)&buf[0] + 1) = 0x40000000;
      *(void *)&buf[1] = sub_1004F09E8;
      *((void *)&buf[1] + 1) = &unk_1019DB198;
      *(void *)&long long v67 = v15 | 0x700000000;
      *((void *)&v67 + 1) = __PAIR64__(v17, v16);
      sub_1004F0808((wis::MetricFactory *)0x800F1);
    }
  }
}

void sub_1007997B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100799860((uint64_t)&a32);
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100799860(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 216);
  if (v2)
  {
    *(void *)(a1 + 224) = v2;
    operator delete(v2);
  }

  return sub_1000C584C(a1);
}

unsigned __int8 *sub_1007998A4(unsigned __int8 *a1)
{
  int v1 = *a1;
  if (v1 != 2)
  {
    if (v1 == 1)
    {
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsNotError::ResultIsNotError(exception);
      int v5 = &ctu::ResultIsNotError::~ResultIsNotError;
    }
    else
    {
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      int v5 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
    }
    __cxa_throw(exception, v4, (void (*)(void *))v5);
  }
  return a1 + 8;
}

void sub_10079992C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100799944(uint64_t a1, uint64_t a2)
{
  return sub_1007A816C(a1 + 40, (unsigned __int8 *)(a2 + 40));
}

void sub_100799950(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40) == 1)
  {
    uint64_t v2 = *(void **)(a1 + 48);
    if (v2)
    {
      *(void *)(a1 + 56) = v2;
      operator delete(v2);
    }
  }
  *(unsigned char *)(a1 + 40) = 0;
}

uint64_t sub_100799990(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007999AC(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1007999BC(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    int v5 = (void *)a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_100799B40;
        void v13[3] = &unk_101A07EB0;
        void v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        unsigned int v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        unint64_t v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        void block[2] = sub_1007AA9BC;
        block[3] = &unk_101A08220;
        block[5] = v9;
        uint64_t v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            unsigned int v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100799B28(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100799B40(uint64_t a1)
{
  int v3 = (unsigned __int8 *)(a1 + 40);
  int v2 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v2 == 2)
  {
    switch(*(unsigned char *)(a1 + 48))
    {
      case 2:
      case 4:
      case 0xB:
        uint64_t v9 = *(NSObject **)(v4 + 72);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E Get notification failed; skipping one",
            buf,
            2u);
        }
        ++*(_DWORD *)(v4 + 248);
        sub_1007AA9F8(*(void *)(v4 + 112), (uint64_t)buf, 1);
        int v10 = *v3;
        if (v10 != 2)
        {
          if (v10 == 1)
          {
            exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
            ctu::ResultIsNotError::ResultIsNotError(exception);
          }
          uint64_t v24 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsEmptyError::ResultIsEmptyError(v24);
        }
        if (*(unsigned char *)(a1 + 48) == 2)
        {
          int v11 = *(_DWORD *)(v4 + 180);
          int v12 = *(unsigned __int8 *)(a1 + 49);
          int v13 = *(unsigned __int8 *)(a1 + 50);
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 0x40000000;
          *(void *)&uint8_t buf[16] = sub_1004F09E8;
          long long v28 = &unk_1019DB198;
          int v29 = v11;
          int v30 = 8;
          int v31 = v12;
          int v32 = v13;
          sub_1004F0808((wis::MetricFactory *)0x800F1);
        }
        break;
      case 3:
        unsigned int v15 = *(unsigned __int16 *)(v4 + 176);
        if (v15 > 2) {
          goto LABEL_25;
        }
        *(_WORD *)(v4 + 176) = v15 + 1;
        unsigned int v16 = *(NSObject **)(v4 + 72);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = asString();
          int v18 = *(unsigned __int16 *)(v4 + 176);
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v17;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v18;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Get notification failed with temporary error %s; retrying (retry #%d)",
            buf,
            0x12u);
        }
        sub_1007AA4F8(*(void *)(v4 + 112), (uint64_t)buf, 1);
        break;
      default:
LABEL_25:
        uint64_t v19 = *(NSObject **)(v4 + 72);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          sub_1007998A4(v3);
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = asString();
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Get notification failed with final error %s; aborting",
            buf,
            0xCu);
        }
        uint64_t v20 = *(void *)(v4 + 112);
        buf[0] = 0;
        *(_DWORD *)&uint8_t buf[4] = 0;
        sub_1007A9B94(v20, (uint64_t)buf, 1);
        break;
    }
  }
  else
  {
    if (v2 != 1)
    {
      BOOL v22 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v22);
    }
    int v5 = *(NSObject **)(v4 + 72);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Got receipt data with %lu bytes", buf, 0xCu);
      int v7 = *(unsigned __int8 *)(a1 + 40);
      if (v7 != 1)
      {
        if (v7 == 2)
        {
          unint64_t v23 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v23);
        }
        uint64_t v25 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v25);
      }
    }
    memset(buf, 0, sizeof(buf));
    sub_10005C928(buf, *(const void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
    uint64_t v8 = *(void *)(v4 + 120);
    if (v8) {
      sub_100EE8BC8(v8, "GetNotificationRsp");
    }
    else {
      *(void *)(v4 + 120) = 0;
    }
    if (sub_100752AF0(buf, (void *)(v4 + 256)))
    {
      int v14 = *(NSObject **)(v4 + 72);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v26 = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Could not decode get notification - skipping one", v26, 2u);
      }
      ++*(_DWORD *)(v4 + 248);
      sub_1007AA9F8(*(void *)(v4 + 112), (uint64_t)v26, 1);
    }
    else
    {
      std::string::operator=((std::string *)(v4 + 280), (const std::string *)(*(void *)(v4 + 224) + 80 * *(unsigned int *)(v4 + 248) + 24));
      sub_1007AAF88(*(void *)(v4 + 112), (uint64_t)v26, 1);
    }
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
  }
}

void sub_10079A00C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  __cxa_free_exception(v12);
  _Unwind_Resume(a1);
}

void sub_10079A080(void *a1, void *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[5])
      {
        uint64_t v26 = 0;
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        int v8 = sub_10132A828(v5, (os_log_t *)(v5 + 72), a2, 204, 2, (uint64_t)&v26);
        if (v8 == 10)
        {
          std::string __p = 0;
          uint64_t v24 = 0;
          uint64_t v25 = 0;
          sub_10005C928(&__p, v26, (uint64_t)v27, v27 - (unsigned char *)v26);
          uint64_t v20 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 134217984;
            int64_t v30 = v24 - (unsigned char *)__p;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Receipt sent, returned %lu bytes", buf, 0xCu);
          }
          uint64_t v21 = *(void *)(v5 + 120);
          if (v21) {
            sub_100EE8BC8(v21, "ReceiptAck");
          }
          else {
            *(void *)(v5 + 120) = 0;
          }
          sub_1007AB334(*(void *)(v5 + 112), (uint64_t)buf, 1);
          if (__p)
          {
            uint64_t v24 = __p;
            operator delete(__p);
          }
        }
        else if (v8 == 2)
        {
          uint64_t v9 = *(void *)(v5 + 224);
          unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(v5 + 232) - v9) >> 4);
          unint64_t v11 = *(unsigned int *)(v5 + 248);
          if (v10 > v11)
          {
            int v12 = *(char *)(v5 + 303);
            if (v12 >= 0) {
              uint64_t v13 = *(unsigned __int8 *)(v5 + 303);
            }
            else {
              uint64_t v13 = *(void *)(v5 + 288);
            }
            do
            {
              uint64_t v14 = v9 + 80 * v11;
              uint64_t v15 = *(unsigned __int8 *)(v14 + 47);
              size_t v16 = *(void *)(v14 + 32);
              uint64_t v17 = (v15 & 0x80u) == 0 ? *(unsigned __int8 *)(v14 + 47) : *(void *)(v14 + 32);
              if (v17 != v13) {
                break;
              }
              int v18 = (const void **)(v14 + 24);
              if (v12 >= 0) {
                uint64_t v19 = (unsigned __int8 *)(v5 + 280);
              }
              else {
                uint64_t v19 = *(unsigned __int8 **)(v5 + 280);
              }
              if ((v15 & 0x80) != 0)
              {
                if (memcmp(*v18, v19, v16)) {
                  break;
                }
              }
              else if (v15)
              {
                while (*(unsigned __int8 *)v18 == *v19)
                {
                  int v18 = (const void **)((char *)v18 + 1);
                  ++v19;
                  if (!--v15) {
                    goto LABEL_23;
                  }
                }
                break;
              }
LABEL_23:
              unint64_t v11 = (v11 + 1);
              *(_DWORD *)(v5 + 248) = v11;
            }
            while (v10 > v11);
          }
          sub_1007AA9F8(*(void *)(v5 + 112), (uint64_t)&__p, 1);
        }
        else
        {
          uint64_t v22 = *(void *)(v5 + 112);
          LOBYTE(__p) = v8;
          HIDWORD(__p) = 0;
          sub_1007A9B94(v22, (uint64_t)&__p, 1);
        }
        if (v26)
        {
          uint64_t v27 = v26;
          operator delete(v26);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10079A2FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  sub_10004D2C8(v13);
  _Unwind_Resume(a1);
}

void sub_10079A348(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_10079A4CC;
        void v13[3] = &unk_101A07F40;
        void v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        int v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        unint64_t v11 = v10;
        int v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        void block[2] = sub_1007AA9BC;
        block[3] = &unk_101A08220;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            size_t v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10079A4B4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10079A4CC(uint64_t a1)
{
  int v3 = (unsigned __int8 *)(a1 + 40);
  int v2 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v2 == 2)
  {
    switch(*(unsigned char *)(a1 + 48))
    {
      case 2:
      case 4:
      case 0xB:
        int v12 = *(NSObject **)(v4 + 72);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v42 = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E Receipt deletion failed skipping this receipt", v42, 2u);
        }
        uint64_t v13 = *(void *)(v4 + 224);
        unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(v4 + 232) - v13) >> 4);
        unint64_t v15 = *(unsigned int *)(v4 + 248);
        if (v14 > v15)
        {
          int v16 = *(char *)(v4 + 303);
          if (v16 >= 0) {
            uint64_t v17 = *(unsigned __int8 *)(v4 + 303);
          }
          else {
            uint64_t v17 = *(void *)(v4 + 288);
          }
          do
          {
            uint64_t v18 = v13 + 80 * v15;
            uint64_t v19 = *(unsigned __int8 *)(v18 + 47);
            size_t v20 = *(void *)(v18 + 32);
            uint64_t v21 = (v19 & 0x80u) == 0 ? *(unsigned __int8 *)(v18 + 47) : *(void *)(v18 + 32);
            if (v21 != v17) {
              break;
            }
            uint64_t v22 = (const void **)(v18 + 24);
            if (v16 >= 0) {
              unint64_t v23 = (unsigned __int8 *)(v4 + 280);
            }
            else {
              unint64_t v23 = *(unsigned __int8 **)(v4 + 280);
            }
            if ((v19 & 0x80) != 0)
            {
              if (memcmp(*v22, v23, v20)) {
                break;
              }
            }
            else if (v19)
            {
              while (*(unsigned __int8 *)v22 == *v23)
              {
                uint64_t v22 = (const void **)((char *)v22 + 1);
                ++v23;
                if (!--v19) {
                  goto LABEL_29;
                }
              }
              break;
            }
LABEL_29:
            unint64_t v15 = (v15 + 1);
            *(_DWORD *)(v4 + 248) = v15;
          }
          while (v14 > v15);
        }
        uint64_t result = sub_1007AA9F8(*(void *)(v4 + 112), (uint64_t)v42, 1);
        int v25 = *v3;
        if (v25 != 2)
        {
          if (v25 == 1)
          {
            exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
            ctu::ResultIsNotError::ResultIsNotError(exception);
          }
          int v40 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsEmptyError::ResultIsEmptyError(v40);
        }
        if (*(unsigned char *)(a1 + 48) == 2)
        {
          int v26 = *(_DWORD *)(v4 + 180);
          int v27 = *(unsigned __int8 *)(a1 + 49);
          int v28 = *(unsigned __int8 *)(a1 + 50);
          *(void *)BOOL v42 = _NSConcreteStackBlock;
          *(void *)&v42[8] = 0x40000000;
          *(void *)&v42[16] = sub_1004F09E8;
          BOOL v43 = &unk_1019DB198;
          int v44 = v26;
          int v45 = 9;
          int v46 = v27;
          int v47 = v28;
          uint64_t result = sub_1004F0808((wis::MetricFactory *)0x800F1);
        }
        break;
      case 3:
        unsigned int v30 = *(unsigned __int16 *)(v4 + 176);
        if (v30 > 2) {
          goto LABEL_42;
        }
        *(_WORD *)(v4 + 176) = v30 + 1;
        int v31 = *(NSObject **)(v4 + 72);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v32 = asString();
          int v33 = *(unsigned __int16 *)(v4 + 176);
          *(_DWORD *)BOOL v42 = 136315394;
          *(void *)&v42[4] = v32;
          *(_WORD *)&v42[12] = 1024;
          *(_DWORD *)&v42[14] = v33;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Receipt deletion failed with temporary error %s; retrying (retry #%d)",
            v42,
            0x12u);
        }
        uint64_t result = sub_1007AA4F8(*(void *)(v4 + 112), (uint64_t)v42, 1);
        break;
      default:
LABEL_42:
        CFTypeID v34 = *(NSObject **)(v4 + 72);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          sub_1007998A4(v3);
          *(_DWORD *)BOOL v42 = 136315138;
          *(void *)&v42[4] = asString();
          _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Receipt deletion failed with final error %s; aborting",
            v42,
            0xCu);
        }
        uint64_t v35 = *(void *)(v4 + 112);
        v42[0] = 0;
        *(_DWORD *)&v42[4] = 0;
        uint64_t result = sub_1007A9B94(v35, (uint64_t)v42, 1);
        break;
    }
  }
  else
  {
    if (v2 != 1)
    {
      int v37 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v37);
    }
    uint64_t v5 = *(NSObject **)(v4 + 72);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(v4 + 248);
      *(_DWORD *)BOOL v42 = 67109120;
      *(_DWORD *)&v42[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Receipt #%d deleted", v42, 8u);
      int v7 = *v3;
      if (v7 != 1)
      {
        if (v7 == 2)
        {
          int v38 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v38);
        }
        uint64_t v41 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v41);
      }
    }
    uint64_t v8 = a1 + 48;
    uint64_t v9 = *(void *)(v4 + 120);
    if (v9)
    {
      sub_100EE8BC8(v9, "DeleteNotificationRsp");
      int v10 = *v3;
      if (v10 != 1)
      {
        if (v10 == 2)
        {
          unint64_t v11 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v11);
        }
        int v39 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v39);
      }
    }
    else
    {
      *(void *)(v4 + 120) = 0;
    }
    if (sub_1007530DC(v8))
    {
      int v29 = *(NSObject **)(v4 + 72);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v42 = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#E Decoding failed - continuing anyways", v42, 2u);
      }
    }
    ++*(_DWORD *)(v4 + 248);
    return sub_1007AB678(*(void *)(v4 + 112), (uint64_t)v42, 1);
  }
  return result;
}

void sub_10079AA74(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_10079AAD4(void ***a1)
{
  int v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        sub_10075516C(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_10079AB58(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  int v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_10079ABAC(uint64_t a1, const void **a2, uint64_t a3, char a4)
{
  p_src = &__src;
  while (2)
  {
    uint64_t v235 = (uint64_t)(a2 - 10);
    uint64_t v231 = (uint64_t)(a2 - 30);
    uint64_t v232 = (uint64_t)(a2 - 20);
    uint64_t v8 = (const void **)a1;
    unint64_t v239 = (unint64_t)a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (char *)a2 - (char *)v8;
        unint64_t v249 = 0xCCCCCCCCCCCCCCCDLL * (((char *)a2 - (char *)v8) >> 4);
        a1 = (uint64_t)v8;
        if (!(!v5 & v4))
        {
          switch(0xCCCCCCCCCCCCCCCDLL * (((char *)a2 - (char *)v8) >> 4))
          {
            case 0uLL:
            case 1uLL:
              return;
            case 2uLL:
              v298 = 0;
              v297 = 0;
              uint64_t v299 = 0;
              uint64_t v73 = (uint64_t)(a2 - 10);
              sub_10005C928(&v297, *(a2 - 10), (uint64_t)*(a2 - 9), (unsigned char *)*(a2 - 9) - (unsigned char *)*(a2 - 10));
              if (*(char *)(v239 - 33) < 0)
              {
                sub_10004FC84(&v300, *(void **)(v239 - 56), *(void *)(v239 - 48));
              }
              else
              {
                long long v74 = *(_OWORD *)(v239 - 56);
                uint64_t v301 = *(void *)(v239 - 40);
                long long v300 = v74;
              }
              if (*(char *)(v239 - 9) < 0)
              {
                sub_10004FC84(&v302, *(void **)(v239 - 32), *(void *)(v239 - 24));
              }
              else
              {
                long long v227 = *(_OWORD *)(v239 - 32);
                uint64_t v303 = *(void *)(v239 - 16);
                long long v302 = v227;
              }
              __int16 v304 = *(_WORD *)(v239 - 8);
              v290 = 0;
              uint64_t v291 = 0;
              v289 = 0;
              sub_10005C928(&v289, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
              if (*(char *)(a1 + 47) < 0)
              {
                sub_10004FC84(&v292, *(void **)(a1 + 24), *(void *)(a1 + 32));
              }
              else
              {
                long long v228 = *(_OWORD *)(a1 + 24);
                uint64_t v293 = *(void *)(a1 + 40);
                long long v292 = v228;
              }
              if (*(char *)(a1 + 71) < 0)
              {
                sub_10004FC84(&v294, *(void **)(a1 + 48), *(void *)(a1 + 56));
              }
              else
              {
                long long v229 = *(_OWORD *)(a1 + 48);
                uint64_t v295 = *(void *)(a1 + 64);
                long long v294 = v229;
              }
              __int16 v296 = *(_WORD *)(a1 + 72);
              char v230 = sub_100046FE8(&v300, (void **)&v292);
              if (SHIBYTE(v295) < 0) {
                operator delete((void *)v294);
              }
              if (SHIBYTE(v293) < 0) {
                operator delete((void *)v292);
              }
              if (v289)
              {
                v290 = v289;
                operator delete(v289);
              }
              if (SHIBYTE(v303) < 0) {
                operator delete((void *)v302);
              }
              if (SHIBYTE(v301) < 0) {
                operator delete((void *)v300);
              }
              if (v297)
              {
                v298 = v297;
                operator delete(v297);
              }
              if (v230 < 0) {
                sub_1007A0A70(a1, v73);
              }
              break;
            case 3uLL:
              sub_10079E970((uint64_t)v8, (uint64_t)(v8 + 10), v235);
              break;
            case 4uLL:
              sub_1007A0C14((uint64_t)v8, (uint64_t)(v8 + 10), (uint64_t)(v8 + 20), v235);
              break;
            case 5uLL:
              sub_10079E114((uint64_t)v8, (uint64_t)(v8 + 10), (uint64_t)(v8 + 20), (uint64_t)(v8 + 30), v235);
              break;
            default:
              JUMPOUT(0);
          }
          return;
        }
        uint64_t v10 = (uint64_t)v8;
        if (v9 <= 1919)
        {
          if (a4)
          {
            if (v8 != a2)
            {
              long long v75 = v8 + 10;
              if (v8 + 10 != (const void **)v239)
              {
                v269 = 0;
                long long v76 = v8;
                do
                {
                  v267 = v75;
                  v368[1] = 0;
                  v368[0] = 0;
                  uint64_t v369 = 0;
                  sub_10005C928(v368, v76[10], (uint64_t)v76[11], (unsigned char *)v76[11] - (unsigned char *)v76[10]);
                  long long v77 = (long long *)(v76 + 13);
                  if (*((char *)v76 + 127) < 0)
                  {
                    sub_10004FC84(&__src, (void *)v76[13], (unint64_t)v76[14]);
                  }
                  else
                  {
                    long long __src = *v77;
                    v371 = v76[15];
                  }
                  long long v78 = (long long *)(v76 + 16);
                  if (*((char *)v76 + 151) < 0)
                  {
                    sub_10004FC84(&v372, (void *)v76[16], (unint64_t)v76[17]);
                  }
                  else
                  {
                    long long v372 = *v78;
                    v373 = v76[18];
                  }
                  LOWORD(v374) = *((_WORD *)v76 + 76);
                  uint64_t v362 = 0;
                  v360 = 0;
                  v361 = 0;
                  sub_10005C928(&v360, *v76, (uint64_t)v76[1], (unsigned char *)v76[1] - (unsigned char *)*v76);
                  if (*((char *)v76 + 47) < 0)
                  {
                    sub_10004FC84(&v363, (void *)v76[3], (unint64_t)v76[4]);
                  }
                  else
                  {
                    long long v79 = *(_OWORD *)(v76 + 3);
                    v364 = v76[5];
                    long long v363 = v79;
                  }
                  if (*((char *)v76 + 71) < 0)
                  {
                    sub_10004FC84(&v365, (void *)v76[6], (unint64_t)v76[7]);
                  }
                  else
                  {
                    long long v80 = *((_OWORD *)v76 + 3);
                    v366 = v76[8];
                    long long v365 = v80;
                  }
                  __int16 v367 = *((_WORD *)v76 + 36);
                  char v81 = sub_100046FE8(&__src, (void **)&v363);
                  if (SHIBYTE(v366) < 0) {
                    operator delete((void *)v365);
                  }
                  if (SHIBYTE(v364) < 0) {
                    operator delete((void *)v363);
                  }
                  if (v360)
                  {
                    v361 = v360;
                    operator delete(v360);
                  }
                  if (SHIBYTE(v373) < 0) {
                    operator delete((void *)v372);
                  }
                  if (SHIBYTE(v371) < 0) {
                    operator delete((void *)__src);
                  }
                  if (v368[0])
                  {
                    v368[1] = v368[0];
                    operator delete(v368[0]);
                  }
                  if (v81 < 0)
                  {
                    uint64_t v359 = 0;
                    *(_OWORD *)v353 = *(_OWORD *)v267;
                    v354 = v76[12];
                    *v267 = 0;
                    v267[1] = 0;
                    v267[2] = 0;
                    long long v355 = *v77;
                    v356 = v76[15];
                    v76[14] = 0;
                    v76[15] = 0;
                    *(void *)long long v77 = 0;
                    long long v357 = *v78;
                    v358 = v76[18];
                    *(void *)long long v78 = 0;
                    v76[17] = 0;
                    v76[18] = 0;
                    char v82 = v269;
                    LOWORD(v359) = *((_WORD *)v76 + 76);
                    while (1)
                    {
                      int v83 = &v82[a1];
                      sub_10005C9A4((uint64_t)&v82[a1 + 80], (__n128 *)&v82[a1]);
                      long long v84 = (void **)&v82[a1 + 104];
                      if (v82[a1 + 127] < 0) {
                        operator delete(*v84);
                      }
                      *(_OWORD *)long long v84 = *(_OWORD *)(v83 + 24);
                      *((void *)v83 + 15) = *((void *)v83 + 5);
                      v83[47] = 0;
                      v83[24] = 0;
                      uint64_t v85 = (void **)(v83 + 128);
                      if (v83[151] < 0) {
                        operator delete(*v85);
                      }
                      uint64_t v86 = &v82[a1];
                      *(_OWORD *)uint64_t v85 = *(_OWORD *)&v82[a1 + 48];
                      *((void *)v83 + 18) = *(void *)&v82[a1 + 64];
                      v86[71] = 0;
                      v86[48] = 0;
                      *((_WORD *)v86 + 76) = *((_WORD *)v86 + 36);
                      if (!v82)
                      {
                        uint64_t v93 = a1;
                        goto LABEL_270;
                      }
                      v346 = 0;
                      v345 = 0;
                      uint64_t v347 = 0;
                      sub_10005C928(&v345, v353[0], (uint64_t)v353[1], (char *)v353[1] - (char *)v353[0]);
                      if (SHIBYTE(v356) < 0)
                      {
                        sub_10004FC84(&v348, (void *)v355, *((unint64_t *)&v355 + 1));
                      }
                      else
                      {
                        long long v348 = v355;
                        v349 = v356;
                      }
                      if (SHIBYTE(v358) < 0)
                      {
                        sub_10004FC84(&v350, (void *)v357, *((unint64_t *)&v357 + 1));
                      }
                      else
                      {
                        long long v350 = v357;
                        v351 = v358;
                      }
                      __int16 v352 = v359;
                      uint64_t v383 = 0;
                      long long v382 = 0uLL;
                      sub_10005C928(&v382, *(const void **)&v82[a1 - 80], *(void *)&v82[a1 - 72], *(void *)&v82[a1 - 72] - *(void *)&v82[a1 - 80]);
                      uint64_t v87 = (void **)&v82[a1 - 56];
                      if (v82[a1 - 33] < 0)
                      {
                        uint64_t v89 = a1;
                        sub_10004FC84(&v384, *v87, *(void *)&v82[a1 - 48]);
                      }
                      else
                      {
                        long long v88 = *(_OWORD *)v87;
                        uint64_t v385 = *(void *)&v82[a1 - 40];
                        long long v384 = v88;
                        uint64_t v89 = a1;
                      }
                      uint64_t v90 = (void **)&v82[v89 - 32];
                      if (v82[v89 - 9] < 0)
                      {
                        sub_10004FC84(&v386, *v90, *(void *)&v82[v89 - 24]);
                      }
                      else
                      {
                        long long v91 = *(_OWORD *)v90;
                        v387 = *(const void **)&v82[v89 - 16];
                        long long v386 = v91;
                      }
                      LOWORD(v388) = *(_WORD *)&v82[a1 - 8];
                      char v92 = sub_100046FE8(&v348, (void **)&v384);
                      if (SHIBYTE(v387) < 0) {
                        operator delete((void *)v386);
                      }
                      if (SHIBYTE(v385) < 0) {
                        operator delete((void *)v384);
                      }
                      if ((void)v382)
                      {
                        *((void *)&v382 + 1) = v382;
                        operator delete((void *)v382);
                      }
                      if (SHIBYTE(v351) < 0) {
                        operator delete((void *)v350);
                      }
                      if (SHIBYTE(v349) < 0) {
                        operator delete((void *)v348);
                      }
                      if (v345)
                      {
                        v346 = v345;
                        operator delete(v345);
                      }
                      if ((v92 & 0x80000000) == 0) {
                        break;
                      }
                      v82 -= 80;
                    }
                    uint64_t v93 = (uint64_t)&v82[a1];
LABEL_270:
                    uint64_t v94 = *(void **)v93;
                    if (*(void *)v93)
                    {
                      *(void *)(v93 + 8) = v94;
                      operator delete(v94);
                      *(void *)uint64_t v93 = 0;
                      *(void *)(v93 + 8) = 0;
                      *(void *)(v93 + 16) = 0;
                    }
                    int v95 = v86 + 24;
                    *(_OWORD *)uint64_t v93 = *(_OWORD *)v353;
                    *(void *)(v93 + 16) = v354;
                    v353[1] = 0;
                    v353[0] = 0;
                    v354 = 0;
                    if (*(char *)(v93 + 47) < 0) {
                      operator delete(*(void **)v95);
                    }
                    uint64_t v96 = v86 + 48;
                    long long v97 = v355;
                    *((void *)v95 + 2) = v356;
                    *(_OWORD *)int v95 = v97;
                    HIBYTE(v356) = 0;
                    LOBYTE(v355) = 0;
                    if (*(char *)(v93 + 71) < 0) {
                      operator delete(*(void **)v96);
                    }
                    long long v98 = v357;
                    *((void *)v96 + 2) = v358;
                    *(_OWORD *)uint64_t v96 = v98;
                    *(_WORD *)(v93 + 72) = v359;
                  }
                  long long v76 = v267;
                  long long v75 = v267 + 10;
                  v269 += 80;
                }
                while (v267 + 10 != (const void **)v239);
              }
            }
          }
          else if (v8 != a2)
          {
            v207 = v8 + 10;
            if (v8 + 10 != (const void **)v239)
            {
              v272 = v8 + 19;
              do
              {
                v268 = v207;
                v368[1] = 0;
                v368[0] = 0;
                uint64_t v369 = 0;
                uint64_t v208 = v10;
                sub_10005C928(v368, *(const void **)(v10 + 80), *(void *)(v10 + 88), *(void *)(v10 + 88) - *(void *)(v10 + 80));
                v209 = (long long *)(v208 + 104);
                if (*(char *)(v208 + 127) < 0)
                {
                  sub_10004FC84(&__src, *(void **)(v208 + 104), *(void *)(v208 + 112));
                }
                else
                {
                  long long __src = *v209;
                  v371 = *(const void **)(v208 + 120);
                }
                v210 = (long long *)(v208 + 128);
                if (*(char *)(v208 + 151) < 0)
                {
                  sub_10004FC84(&v372, *(void **)(v208 + 128), *(void *)(v208 + 136));
                }
                else
                {
                  long long v372 = *v210;
                  v373 = *(const void **)(v208 + 144);
                }
                LOWORD(v374) = *(_WORD *)(v208 + 152);
                uint64_t v362 = 0;
                v360 = 0;
                v361 = 0;
                sub_10005C928(&v360, *(const void **)v208, *(void *)(v208 + 8), *(void *)(v208 + 8) - *(void *)v208);
                if (*(char *)(v208 + 47) < 0)
                {
                  sub_10004FC84(&v363, *(void **)(v208 + 24), *(void *)(v208 + 32));
                }
                else
                {
                  long long v211 = *(_OWORD *)(v208 + 24);
                  v364 = *(const void **)(v208 + 40);
                  long long v363 = v211;
                }
                if (*(char *)(v208 + 71) < 0)
                {
                  sub_10004FC84(&v365, *(void **)(v208 + 48), *(void *)(v208 + 56));
                }
                else
                {
                  long long v212 = *(_OWORD *)(v208 + 48);
                  v366 = *(const void **)(v208 + 64);
                  long long v365 = v212;
                }
                __int16 v367 = *(_WORD *)(v208 + 72);
                char v213 = sub_100046FE8(&__src, (void **)&v363);
                if (SHIBYTE(v366) < 0) {
                  operator delete((void *)v365);
                }
                if (SHIBYTE(v364) < 0) {
                  operator delete((void *)v363);
                }
                if (v360)
                {
                  v361 = v360;
                  operator delete(v360);
                }
                if (SHIBYTE(v373) < 0) {
                  operator delete((void *)v372);
                }
                if (SHIBYTE(v371) < 0) {
                  operator delete((void *)__src);
                }
                if (v368[0])
                {
                  v368[1] = v368[0];
                  operator delete(v368[0]);
                }
                if (v213 < 0)
                {
                  uint64_t v359 = 0;
                  *(_OWORD *)v353 = *(_OWORD *)v268;
                  v354 = *(const void **)(v208 + 96);
                  *v268 = 0;
                  v268[1] = 0;
                  v268[2] = 0;
                  long long v355 = *v209;
                  v356 = *(const void **)(v208 + 120);
                  *(void *)(v208 + 112) = 0;
                  *(void *)(v208 + 120) = 0;
                  *(void *)v209 = 0;
                  long long v357 = *v210;
                  v358 = *(const void **)(v208 + 144);
                  *(void *)v210 = 0;
                  *(void *)(v208 + 136) = 0;
                  *(void *)(v208 + 144) = 0;
                  v214 = v272;
                  LOWORD(v359) = *(_WORD *)(v208 + 152);
                  do
                  {
                    sub_10005C9A4((uint64_t)(v214 - 36), (__n128 *)(v214 - 76));
                    v215 = (void **)(v214 - 24);
                    if (*((char *)v214 - 25) < 0) {
                      operator delete(*v215);
                    }
                    *(_OWORD *)v215 = *((_OWORD *)v214 - 8);
                    *((void *)v214 - 4) = *((void *)v214 - 14);
                    *((unsigned char *)v214 - 105) = 0;
                    *((unsigned char *)v214 - 128) = 0;
                    v216 = (void **)(v214 - 12);
                    if (*((char *)v214 - 1) < 0) {
                      operator delete(*v216);
                    }
                    *(_OWORD *)v216 = *(_OWORD *)(v214 - 52);
                    *((void *)v214 - 1) = *((void *)v214 - 11);
                    *((unsigned char *)v214 - 81) = 0;
                    *((unsigned char *)v214 - 104) = 0;
                    _WORD *v214 = *(v214 - 40);
                    v346 = 0;
                    v345 = 0;
                    uint64_t v347 = 0;
                    v217 = v353[0];
                    v218 = v353[1];
                    sub_10005C928(&v345, v353[0], (uint64_t)v353[1], (char *)v353[1] - (char *)v353[0]);
                    if (SHIBYTE(v356) < 0)
                    {
                      sub_10004FC84(&v348, (void *)v355, *((unint64_t *)&v355 + 1));
                    }
                    else
                    {
                      long long v348 = v355;
                      v349 = v356;
                    }
                    if (SHIBYTE(v358) < 0)
                    {
                      sub_10004FC84(&v350, (void *)v357, *((unint64_t *)&v357 + 1));
                    }
                    else
                    {
                      long long v350 = v357;
                      v351 = v358;
                    }
                    __int16 v352 = v359;
                    uint64_t v383 = 0;
                    long long v382 = 0uLL;
                    sub_10005C928(&v382, *((const void **)v214 - 29), *((void *)v214 - 28), *((void *)v214 - 28) - *((void *)v214 - 29));
                    if (*((char *)v214 - 185) < 0)
                    {
                      sub_10004FC84(&v384, *((void **)v214 - 26), *((void *)v214 - 25));
                    }
                    else
                    {
                      long long v219 = *((_OWORD *)v214 - 13);
                      uint64_t v385 = *((void *)v214 - 24);
                      long long v384 = v219;
                    }
                    if (*((char *)v214 - 161) < 0)
                    {
                      sub_10004FC84(&v386, *((void **)v214 - 23), *((void *)v214 - 22));
                    }
                    else
                    {
                      long long v220 = *(_OWORD *)(v214 - 92);
                      v387 = (const void *)*((void *)v214 - 21);
                      long long v386 = v220;
                    }
                    LOWORD(v388) = *(v214 - 80);
                    char v221 = sub_100046FE8(&v348, (void **)&v384);
                    if (SHIBYTE(v387) < 0) {
                      operator delete((void *)v386);
                    }
                    if (SHIBYTE(v385) < 0) {
                      operator delete((void *)v384);
                    }
                    if ((void)v382)
                    {
                      *((void *)&v382 + 1) = v382;
                      operator delete((void *)v382);
                    }
                    if (SHIBYTE(v351) < 0) {
                      operator delete((void *)v350);
                    }
                    if (SHIBYTE(v349) < 0) {
                      operator delete((void *)v348);
                    }
                    if (v345)
                    {
                      v346 = v345;
                      operator delete(v345);
                    }
                    v214 -= 40;
                  }
                  while (v221 < 0);
                  v222 = (void *)*((void *)v214 - 9);
                  if (v222)
                  {
                    *((void *)v214 - 8) = v222;
                    operator delete(v222);
                    *((void *)v214 - 9) = 0;
                    *((void *)v214 - 8) = 0;
                    *((void *)v214 - 7) = 0;
                    v217 = v353[0];
                    v218 = v353[1];
                  }
                  v223 = v214 - 24;
                  *((void *)v214 - 9) = v217;
                  *((void *)v214 - 8) = v218;
                  *((void *)v214 - 7) = v354;
                  v353[1] = 0;
                  v353[0] = 0;
                  v354 = 0;
                  if (*((char *)v214 - 25) < 0)
                  {
                    operator delete(*(void **)v223);
                    v223 = v214 - 24;
                  }
                  v224 = (void **)(v214 - 12);
                  long long v225 = v355;
                  *((void *)v223 + 2) = v356;
                  *(_OWORD *)v223 = v225;
                  HIBYTE(v356) = 0;
                  LOBYTE(v355) = 0;
                  if (*((char *)v214 - 1) < 0) {
                    operator delete(*v224);
                  }
                  long long v226 = v357;
                  *((void *)v214 - 1) = v358;
                  *(_OWORD *)v224 = v226;
                  HIBYTE(v358) = 0;
                  LOBYTE(v357) = 0;
                  _WORD *v214 = v359;
                }
                uint64_t v10 = (uint64_t)v268;
                v207 = v268 + 10;
                v272 += 40;
              }
              while (v268 + 10 != (const void **)v239);
            }
          }
          return;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            unint64_t v243 = (char *)a2 - (char *)v8;
            v270 = (void *)((v249 - 2) >> 1);
            uint64_t v99 = (uint64_t)v270;
            do
            {
              uint64_t v100 = v99;
              if ((uint64_t)v270 >= v99)
              {
                v256 = (void *)v99;
                uint64_t v101 = (2 * v99) | 1;
                uint64_t v102 = &v8[10 * v101];
                uint64_t v103 = 2 * v99 + 2;
                if (v103 < (uint64_t)v249)
                {
                  v368[1] = 0;
                  v368[0] = 0;
                  uint64_t v369 = 0;
                  sub_10005C928(v368, *v102, (uint64_t)v102[1], (unsigned char *)v102[1] - (unsigned char *)*v102);
                  v104 = (void **)&v8[10 * v101 + 3];
                  if (*((char *)v102 + 47) < 0)
                  {
                    sub_10004FC84(&__src, *v104, (unint64_t)v8[10 * v101 + 4]);
                  }
                  else
                  {
                    long long v105 = *(_OWORD *)v104;
                    v371 = v8[10 * v101 + 5];
                    long long __src = v105;
                  }
                  uint64_t v106 = (void **)&v8[10 * v101 + 6];
                  if (*((char *)v102 + 71) < 0)
                  {
                    sub_10004FC84(&v372, *v106, (unint64_t)v8[10 * v101 + 7]);
                  }
                  else
                  {
                    long long v107 = *(_OWORD *)v106;
                    v373 = v8[10 * v101 + 8];
                    long long v372 = v107;
                  }
                  LOWORD(v374) = v8[10 * v101 + 9];
                  uint64_t v362 = 0;
                  v360 = 0;
                  v361 = 0;
                  sub_10005C928(&v360, v102[10], (uint64_t)v102[11], (unsigned char *)v102[11] - (unsigned char *)v102[10]);
                  if (*((char *)v102 + 127) < 0)
                  {
                    sub_10004FC84(&v363, (void *)v102[13], (unint64_t)v102[14]);
                  }
                  else
                  {
                    long long v108 = *(_OWORD *)(v102 + 13);
                    v364 = v102[15];
                    long long v363 = v108;
                  }
                  if (*((char *)v102 + 151) < 0)
                  {
                    sub_10004FC84(&v365, (void *)v102[16], (unint64_t)v102[17]);
                  }
                  else
                  {
                    long long v109 = *((_OWORD *)v102 + 8);
                    v366 = v102[18];
                    long long v365 = v109;
                  }
                  __int16 v367 = *((_WORD *)v102 + 76);
                  char v110 = sub_100046FE8(&__src, (void **)&v363);
                  if (SHIBYTE(v366) < 0) {
                    operator delete((void *)v365);
                  }
                  if (SHIBYTE(v364) < 0) {
                    operator delete((void *)v363);
                  }
                  if (v360)
                  {
                    v361 = v360;
                    operator delete(v360);
                  }
                  if (SHIBYTE(v373) < 0) {
                    operator delete((void *)v372);
                  }
                  if (SHIBYTE(v371) < 0) {
                    operator delete((void *)__src);
                  }
                  if (v368[0])
                  {
                    v368[1] = v368[0];
                    operator delete(v368[0]);
                  }
                  if (v110 < 0)
                  {
                    v102 += 10;
                    uint64_t v101 = v103;
                  }
                }
                v353[1] = 0;
                v353[0] = 0;
                v354 = 0;
                sub_10005C928(v353, *v102, (uint64_t)v102[1], (unsigned char *)v102[1] - (unsigned char *)*v102);
                if (*((char *)v102 + 47) < 0)
                {
                  sub_10004FC84(&v355, (void *)v102[3], (unint64_t)v102[4]);
                }
                else
                {
                  long long v111 = *(_OWORD *)(v102 + 3);
                  v356 = v102[5];
                  long long v355 = v111;
                }
                v112 = v256;
                if (*((char *)v102 + 71) < 0)
                {
                  sub_10004FC84(&v357, (void *)v102[6], (unint64_t)v102[7]);
                  v112 = v256;
                }
                else
                {
                  long long v113 = *((_OWORD *)v102 + 3);
                  v358 = v102[8];
                  long long v357 = v113;
                }
                uint64_t v114 = (uint64_t)&v8[10 * (void)v112];
                LOWORD(v359) = *((_WORD *)v102 + 36);
                uint64_t v347 = 0;
                v345 = 0;
                v346 = 0;
                v115 = v112;
                sub_10005C928(&v345, *(const void **)v114, *(void *)(v114 + 8), *(void *)(v114 + 8) - *(void *)v114);
                uint64_t v116 = (uint64_t)&v8[10 * (void)v115 + 3];
                uint64_t v117 = v115;
                if (*(char *)(v114 + 47) < 0)
                {
                  sub_10004FC84(&v348, *(void **)v116, (unint64_t)v8[10 * (void)v115 + 4]);
                  uint64_t v117 = v256;
                }
                else
                {
                  long long v118 = *(_OWORD *)v116;
                  v349 = v8[10 * (void)v115 + 5];
                  long long v348 = v118;
                }
                uint64_t v119 = (uint64_t)&v8[10 * (void)v117 + 6];
                if (*(char *)(v114 + 71) < 0)
                {
                  sub_10004FC84(&v350, *(void **)v119, (unint64_t)v8[10 * (void)v117 + 7]);
                  uint64_t v117 = v256;
                }
                else
                {
                  long long v120 = *(_OWORD *)v119;
                  v351 = v8[10 * (void)v117 + 8];
                  long long v350 = v120;
                }
                uint64_t v121 = &v8[10 * (void)v117];
                __int16 v123 = *((_WORD *)v121 + 36);
                v122 = v121 + 9;
                __int16 v352 = v123;
                char v124 = sub_100046FE8(&v355, (void **)&v348);
                if (SHIBYTE(v351) < 0) {
                  operator delete((void *)v350);
                }
                if (SHIBYTE(v349) < 0) {
                  operator delete((void *)v348);
                }
                if (v345)
                {
                  v346 = v345;
                  operator delete(v345);
                }
                if (SHIBYTE(v358) < 0) {
                  operator delete((void *)v357);
                }
                if (SHIBYTE(v356) < 0) {
                  operator delete((void *)v355);
                }
                if (v353[0])
                {
                  v353[1] = v353[0];
                  operator delete(v353[0]);
                }
                uint64_t v100 = (uint64_t)v256;
                if ((v124 & 0x80000000) == 0)
                {
                  uint64_t v388 = 0;
                  long long v382 = *(_OWORD *)v114;
                  uint64_t v383 = *(void *)(v114 + 16);
                  *(void *)uint64_t v114 = 0;
                  *(void *)(v114 + 8) = 0;
                  *(void *)(v114 + 16) = 0;
                  long long v125 = *(_OWORD *)v116;
                  uint64_t v385 = *(void *)(v116 + 16);
                  long long v384 = v125;
                  *(void *)(v116 + 8) = 0;
                  *(void *)(v116 + 16) = 0;
                  *(void *)uint64_t v116 = 0;
                  long long v126 = *(_OWORD *)v119;
                  v387 = *(const void **)(v119 + 16);
                  long long v386 = v126;
                  *(void *)(v119 + 8) = 0;
                  *(void *)(v119 + 16) = 0;
                  *(void *)uint64_t v119 = 0;
                  LOWORD(v388) = *v122;
                  do
                  {
                    uint64_t v127 = (uint64_t)v102;
                    sub_10005C9A4(v114, (__n128 *)v102);
                    v128 = (void **)(v114 + 24);
                    if (*(char *)(v114 + 47) < 0) {
                      operator delete(*v128);
                    }
                    v129 = (void **)(v102 + 3);
                    long long v130 = *(_OWORD *)(v102 + 3);
                    *(void *)(v114 + 40) = v102[5];
                    *(_OWORD *)v128 = v130;
                    *((unsigned char *)v102 + 47) = 0;
                    *((unsigned char *)v102 + 24) = 0;
                    v131 = (void **)(v114 + 48);
                    if (*(char *)(v114 + 71) < 0) {
                      operator delete(*v131);
                    }
                    long long v132 = *((_OWORD *)v102 + 3);
                    *(void *)(v114 + 64) = v102[8];
                    *(_OWORD *)v131 = v132;
                    *((unsigned char *)v102 + 71) = 0;
                    *((unsigned char *)v102 + 48) = 0;
                    *(_WORD *)(v114 + 72) = *((_WORD *)v102 + 36);
                    if ((uint64_t)v270 < v101) {
                      break;
                    }
                    uint64_t v133 = (2 * v101) | 1;
                    uint64_t v102 = &v8[10 * v133];
                    uint64_t v134 = 2 * v101 + 2;
                    if (v134 >= (uint64_t)v249)
                    {
                      uint64_t v101 = (2 * v101) | 1;
                    }
                    else
                    {
                      long long v375 = 0uLL;
                      uint64_t v376 = 0;
                      sub_10005C928(&v375, *v102, (uint64_t)v102[1], (unsigned char *)v102[1] - (unsigned char *)*v102);
                      v135 = (void **)&v8[10 * v133 + 3];
                      if (*((char *)v102 + 47) < 0)
                      {
                        sub_10004FC84(&v377, *v135, (unint64_t)v8[10 * v133 + 4]);
                      }
                      else
                      {
                        long long v136 = *(_OWORD *)v135;
                        v378 = v8[10 * v133 + 5];
                        long long v377 = v136;
                      }
                      v137 = (void **)&v8[10 * v133 + 6];
                      if (*((char *)v102 + 71) < 0)
                      {
                        sub_10004FC84(&v379, *v137, (unint64_t)v8[10 * v133 + 7]);
                      }
                      else
                      {
                        long long v138 = *(_OWORD *)v137;
                        v380 = v8[10 * v133 + 8];
                        long long v379 = v138;
                      }
                      __int16 v381 = (__int16)v8[10 * v133 + 9];
                      uint64_t v339 = 0;
                      v337 = 0;
                      v338 = 0;
                      sub_10005C928(&v337, v102[10], (uint64_t)v102[11], (unsigned char *)v102[11] - (unsigned char *)v102[10]);
                      if (*((char *)v102 + 127) < 0)
                      {
                        sub_10004FC84(&v340, (void *)v102[13], (unint64_t)v102[14]);
                      }
                      else
                      {
                        long long v139 = *(_OWORD *)(v102 + 13);
                        v341 = v102[15];
                        long long v340 = v139;
                      }
                      if (*((char *)v102 + 151) < 0)
                      {
                        sub_10004FC84(&v342, (void *)v102[16], (unint64_t)v102[17]);
                      }
                      else
                      {
                        long long v140 = *((_OWORD *)v102 + 8);
                        v343 = v102[18];
                        long long v342 = v140;
                      }
                      __int16 v344 = *((_WORD *)v102 + 76);
                      char v141 = sub_100046FE8(&v377, (void **)&v340);
                      if (SHIBYTE(v343) < 0) {
                        operator delete((void *)v342);
                      }
                      if (SHIBYTE(v341) < 0) {
                        operator delete((void *)v340);
                      }
                      if (v337)
                      {
                        v338 = v337;
                        operator delete(v337);
                      }
                      if (SHIBYTE(v380) < 0) {
                        operator delete((void *)v379);
                      }
                      if (SHIBYTE(v378) < 0) {
                        operator delete((void *)v377);
                      }
                      if ((void)v375)
                      {
                        *((void *)&v375 + 1) = v375;
                        operator delete((void *)v375);
                      }
                      uint64_t v101 = (2 * v101) | 1;
                      if (v141 < 0)
                      {
                        v102 += 10;
                        uint64_t v101 = v134;
                      }
                    }
                    v330 = 0;
                    v329 = 0;
                    uint64_t v331 = 0;
                    sub_10005C928(&v329, *v102, (uint64_t)v102[1], (unsigned char *)v102[1] - (unsigned char *)*v102);
                    if (*((char *)v102 + 47) < 0)
                    {
                      sub_10004FC84(&v332, (void *)v102[3], (unint64_t)v102[4]);
                    }
                    else
                    {
                      long long v142 = *(_OWORD *)(v102 + 3);
                      v333 = v102[5];
                      long long v332 = v142;
                    }
                    if (*((char *)v102 + 71) < 0)
                    {
                      sub_10004FC84(&v334, (void *)v102[6], (unint64_t)v102[7]);
                    }
                    else
                    {
                      long long v143 = *((_OWORD *)v102 + 3);
                      v335 = v102[8];
                      long long v334 = v143;
                    }
                    __int16 v336 = *((_WORD *)v102 + 36);
                    uint64_t v323 = 0;
                    v321 = 0;
                    v322 = 0;
                    sub_10005C928(&v321, (const void *)v382, *((uint64_t *)&v382 + 1), *((void *)&v382 + 1) - v382);
                    if (SHIBYTE(v385) < 0)
                    {
                      sub_10004FC84(&v324, (void *)v384, *((unint64_t *)&v384 + 1));
                    }
                    else
                    {
                      long long v324 = v384;
                      uint64_t v325 = v385;
                    }
                    if (SHIBYTE(v387) < 0)
                    {
                      sub_10004FC84(&v326, (void *)v386, *((unint64_t *)&v386 + 1));
                    }
                    else
                    {
                      long long v326 = v386;
                      v327 = v387;
                    }
                    __int16 v328 = v388;
                    char v144 = sub_100046FE8(&v332, (void **)&v324);
                    if (SHIBYTE(v327) < 0) {
                      operator delete((void *)v326);
                    }
                    if (SHIBYTE(v325) < 0) {
                      operator delete((void *)v324);
                    }
                    if (v321)
                    {
                      v322 = v321;
                      operator delete(v321);
                    }
                    if (SHIBYTE(v335) < 0) {
                      operator delete((void *)v334);
                    }
                    if (SHIBYTE(v333) < 0) {
                      operator delete((void *)v332);
                    }
                    if (v329)
                    {
                      v330 = v329;
                      operator delete(v329);
                    }
                    int v145 = v144;
                    uint64_t v114 = v127;
                  }
                  while ((v145 & 0x80000000) == 0);
                  v146 = *(void **)v127;
                  if (*(void *)v127)
                  {
                    *(void *)(v127 + 8) = v146;
                    operator delete(v146);
                    *(void *)uint64_t v127 = 0;
                    *(void *)(v127 + 8) = 0;
                    *(void *)(v127 + 16) = 0;
                  }
                  *(_OWORD *)uint64_t v127 = v382;
                  *(void *)(v127 + 16) = v383;
                  if (*(char *)(v127 + 47) < 0) {
                    operator delete(*v129);
                  }
                  v147 = (void **)(v127 + 48);
                  long long v148 = v384;
                  *(void *)(v127 + 40) = v385;
                  *(_OWORD *)v129 = v148;
                  if (*(char *)(v127 + 71) < 0) {
                    operator delete(*v147);
                  }
                  long long v149 = v386;
                  *(void *)(v127 + 64) = v387;
                  *(_OWORD *)v147 = v149;
                  *(_WORD *)(v127 + 72) = v388;
                  uint64_t v100 = (uint64_t)v256;
                }
              }
              uint64_t v99 = v100 - 1;
            }
            while (v100);
            unint64_t v150 = v243 / 0x50;
            v151 = (__n128 *)v239;
            do
            {
              uint64_t v152 = 0;
              v261 = (void *)*v8;
              v247 = (void *)v8[1];
              v252 = v151;
              v245 = (void *)v8[2];
              v257 = (void *)v8[3];
              v8[1] = 0;
              int v8[2] = 0;
              *uint64_t v8 = 0;
              *(void *)&long long v382 = v8[4];
              *(void *)((char *)&v382 + 7) = *(const void **)((char *)v8 + 39);
              unsigned __int8 v263 = *((unsigned char *)v8 + 47);
              void v8[4] = 0;
              void v8[5] = 0;
              void v8[3] = 0;
              v259 = (void *)v8[6];
              *(void *)((char *)&v375 + 7) = *(const void **)((char *)v8 + 63);
              *(void *)&long long v375 = v8[7];
              unsigned __int8 v265 = *((unsigned char *)v8 + 71);
              void v8[6] = 0;
              v8[7] = 0;
              v8[8] = 0;
              uint64_t v271 = v150;
              int64_t v153 = (v150 - 2) >> 1;
              uint64_t v154 = (uint64_t)v8;
              unsigned __int16 v254 = *((_WORD *)v8 + 36);
              do
              {
                uint64_t v155 = v152 + 1;
                uint64_t v156 = v154 + 80 * (v152 + 1);
                uint64_t v157 = 2 * v152;
                uint64_t v152 = (2 * v152) | 1;
                uint64_t v158 = v157 + 2;
                if (v157 + 2 < v271)
                {
                  v368[1] = 0;
                  v368[0] = 0;
                  uint64_t v369 = 0;
                  sub_10005C928(v368, *(const void **)v156, *(void *)(v156 + 8), *(void *)(v156 + 8) - *(void *)v156);
                  v159 = (void **)(v154 + 80 * v155 + 24);
                  if (*(char *)(v156 + 47) < 0)
                  {
                    sub_10004FC84(&__src, *v159, *(void *)(v154 + 80 * v155 + 32));
                  }
                  else
                  {
                    long long v160 = *(_OWORD *)v159;
                    v371 = *(const void **)(v154 + 80 * v155 + 40);
                    long long __src = v160;
                  }
                  v161 = (void **)(v154 + 80 * v155 + 48);
                  if (*(char *)(v156 + 71) < 0)
                  {
                    sub_10004FC84(&v372, *v161, *(void *)(v154 + 80 * v155 + 56));
                  }
                  else
                  {
                    long long v162 = *(_OWORD *)v161;
                    v373 = *(const void **)(v154 + 80 * v155 + 64);
                    long long v372 = v162;
                  }
                  LOWORD(v374) = *(_WORD *)(v154 + 80 * v155 + 72);
                  uint64_t v362 = 0;
                  v360 = 0;
                  v361 = 0;
                  sub_10005C928(&v360, *(const void **)(v156 + 80), *(void *)(v156 + 88), *(void *)(v156 + 88) - *(void *)(v156 + 80));
                  if (*(char *)(v156 + 127) < 0)
                  {
                    sub_10004FC84(&v363, *(void **)(v156 + 104), *(void *)(v156 + 112));
                  }
                  else
                  {
                    long long v163 = *(_OWORD *)(v156 + 104);
                    v364 = *(const void **)(v156 + 120);
                    long long v363 = v163;
                  }
                  if (*(char *)(v156 + 151) < 0)
                  {
                    sub_10004FC84(&v365, *(void **)(v156 + 128), *(void *)(v156 + 136));
                  }
                  else
                  {
                    long long v164 = *(_OWORD *)(v156 + 128);
                    v366 = *(const void **)(v156 + 144);
                    long long v365 = v164;
                  }
                  __int16 v367 = *(_WORD *)(v156 + 152);
                  char v165 = sub_100046FE8(&__src, (void **)&v363);
                  if (SHIBYTE(v366) < 0) {
                    operator delete((void *)v365);
                  }
                  if (SHIBYTE(v364) < 0) {
                    operator delete((void *)v363);
                  }
                  if (v360)
                  {
                    v361 = v360;
                    operator delete(v360);
                  }
                  if (SHIBYTE(v373) < 0) {
                    operator delete((void *)v372);
                  }
                  if (SHIBYTE(v371) < 0) {
                    operator delete((void *)__src);
                  }
                  if (v368[0])
                  {
                    v368[1] = v368[0];
                    operator delete(v368[0]);
                  }
                  if (v165 < 0)
                  {
                    v156 += 80;
                    uint64_t v152 = v158;
                  }
                }
                sub_10005C9A4(v154, (__n128 *)v156);
                v166 = (void **)(v154 + 24);
                if (*(char *)(v154 + 47) < 0) {
                  operator delete(*v166);
                }
                v167 = (void **)(v156 + 24);
                long long v168 = *(_OWORD *)(v156 + 24);
                *(void *)(v154 + 40) = *(void *)(v156 + 40);
                *(_OWORD *)v166 = v168;
                *(unsigned char *)(v156 + 47) = 0;
                *(unsigned char *)(v156 + 24) = 0;
                v169 = (void **)(v154 + 48);
                if (*(char *)(v154 + 71) < 0) {
                  operator delete(*v169);
                }
                long long v170 = *(_OWORD *)(v156 + 48);
                *(void *)(v154 + 64) = *(void *)(v156 + 64);
                *(_OWORD *)v169 = v170;
                *(unsigned char *)(v156 + 71) = 0;
                *(unsigned char *)(v156 + 48) = 0;
                *(_WORD *)(v154 + 72) = *(_WORD *)(v156 + 72);
                uint64_t v154 = v156;
              }
              while (v152 <= v153);
              v171 = (void **)(v156 + 48);
              v151 = v252 - 5;
              if ((__n128 *)v156 == &v252[-5])
              {
                v182 = *(void **)v156;
                if (*(void *)v156)
                {
                  *(void *)(v156 + 8) = v182;
                  operator delete(v182);
                  *(void *)uint64_t v156 = 0;
                  *(void *)(v156 + 8) = 0;
                  *(void *)(v156 + 16) = 0;
                }
                *(void *)uint64_t v156 = v261;
                *(void *)(v156 + 8) = v247;
                *(void *)(v156 + 16) = v245;
                if (*(char *)(v156 + 47) < 0) {
                  operator delete(*v167);
                }
                *(void *)(v156 + 24) = v257;
                uint64_t v183 = v382;
                *(void *)(v156 + 39) = *(void *)((char *)&v382 + 7);
                *(void *)(v156 + 32) = v183;
                *(unsigned char *)(v156 + 47) = v263;
                if (*(char *)(v156 + 71) < 0) {
                  operator delete(*v171);
                }
                *(void *)(v156 + 48) = v259;
                uint64_t v184 = v375;
                *(void *)(v156 + 63) = *(void *)((char *)&v375 + 7);
                *(void *)(v156 + 56) = v184;
                *(unsigned char *)(v156 + 71) = v265;
                *(_WORD *)(v156 + 72) = v254;
              }
              else
              {
                sub_10005C9A4(v156, v252 - 5);
                if (*(char *)(v156 + 47) < 0) {
                  operator delete(*v167);
                }
                long long v172 = *(long long *)((char *)&v252[-4] + 8);
                *(void *)(v156 + 40) = v252[-3].n128_u64[1];
                *(_OWORD *)v167 = v172;
                v252[-3].n128_u8[15] = 0;
                v252[-4].n128_u8[8] = 0;
                if (*(char *)(v156 + 71) < 0) {
                  operator delete(*v171);
                }
                __n128 v173 = v252[-2];
                *(void *)(v156 + 64) = v252[-1].n128_u64[0];
                *(__n128 *)v171 = v173;
                v252[-1].n128_u8[7] = 0;
                v252[-2].n128_u8[0] = 0;
                *(_WORD *)(v156 + 72) = v252[-1].n128_u16[4];
                v174 = (void *)v252[-5].n128_u64[0];
                if (v174)
                {
                  v252[-5].n128_u64[1] = (unint64_t)v174;
                  operator delete(v174);
                  v151->n128_u64[0] = 0;
                  v252[-5].n128_u64[1] = 0;
                  v252[-4].n128_u64[0] = 0;
                }
                v252[-5].n128_u64[0] = (unint64_t)v261;
                v252[-5].n128_u64[1] = (unint64_t)v247;
                v252[-4].n128_u64[0] = (unint64_t)v245;
                if (v252[-3].n128_i8[15] < 0) {
                  operator delete((void *)v252[-4].n128_u64[1]);
                }
                v240 = v252 - 5;
                v252[-4].n128_u64[1] = (unint64_t)v257;
                unint64_t v175 = v382;
                *(unint64_t *)((char *)v252[-3].n128_u64 + 7) = *(void *)((char *)&v382 + 7);
                v252[-3].n128_u64[0] = v175;
                v252[-3].n128_u8[15] = v263;
                if (v252[-1].n128_i8[7] < 0) {
                  operator delete((void *)v252[-2].n128_u64[0]);
                }
                v252[-2].n128_u64[0] = (unint64_t)v259;
                unint64_t v176 = v375;
                *(unint64_t *)((char *)&v252[-2].n128_u64[1] + 7) = *(void *)((char *)&v375 + 7);
                v252[-2].n128_u64[1] = v176;
                v252[-1].n128_u8[7] = v265;
                v252[-1].n128_u16[4] = v254;
                uint64_t v177 = v156 + 80 - (void)v8;
                if (v177 >= 81)
                {
                  unint64_t v178 = (v177 / 0x50uLL - 2) >> 1;
                  v179 = &v8[10 * v178];
                  v368[1] = 0;
                  v368[0] = 0;
                  uint64_t v369 = 0;
                  sub_10005C928(v368, *v179, (uint64_t)v179[1], (unsigned char *)v179[1] - (unsigned char *)*v179);
                  v180 = (void **)(v179 + 3);
                  if (*((char *)v179 + 47) < 0)
                  {
                    sub_10004FC84(&__src, *v180, (unint64_t)v8[10 * v178 + 4]);
                  }
                  else
                  {
                    long long v181 = *(_OWORD *)v180;
                    v371 = v8[10 * v178 + 5];
                    long long __src = v181;
                  }
                  v185 = (void **)&v8[10 * v178 + 6];
                  if (*((char *)v179 + 71) < 0)
                  {
                    sub_10004FC84(&v372, *v185, (unint64_t)v8[10 * v178 + 7]);
                  }
                  else
                  {
                    long long v186 = *(_OWORD *)v185;
                    v373 = v8[10 * v178 + 8];
                    long long v372 = v186;
                  }
                  LOWORD(v374) = v8[10 * v178 + 9];
                  uint64_t v362 = 0;
                  v360 = 0;
                  v361 = 0;
                  sub_10005C928(&v360, *(const void **)v156, *(void *)(v156 + 8), *(void *)(v156 + 8) - *(void *)v156);
                  if (*(char *)(v156 + 47) < 0)
                  {
                    sub_10004FC84(&v363, *(void **)(v156 + 24), *(void *)(v156 + 32));
                  }
                  else
                  {
                    long long v187 = *(_OWORD *)v167;
                    v364 = *(const void **)(v156 + 40);
                    long long v363 = v187;
                  }
                  if (*(char *)(v156 + 71) < 0)
                  {
                    sub_10004FC84(&v365, *(void **)(v156 + 48), *(void *)(v156 + 56));
                  }
                  else
                  {
                    long long v188 = *(_OWORD *)v171;
                    v366 = *(const void **)(v156 + 64);
                    long long v365 = v188;
                  }
                  __int16 v367 = *(_WORD *)(v156 + 72);
                  char v189 = sub_100046FE8(&__src, (void **)&v363);
                  if (SHIBYTE(v366) < 0) {
                    operator delete((void *)v365);
                  }
                  if (SHIBYTE(v364) < 0) {
                    operator delete((void *)v363);
                  }
                  if (v360)
                  {
                    v361 = v360;
                    operator delete(v360);
                  }
                  if (SHIBYTE(v373) < 0) {
                    operator delete((void *)v372);
                  }
                  if (SHIBYTE(v371) < 0) {
                    operator delete((void *)__src);
                  }
                  if (v368[0])
                  {
                    v368[1] = v368[0];
                    operator delete(v368[0]);
                  }
                  if (v189 < 0)
                  {
                    v190 = *(void **)v156;
                    long long v191 = *(_OWORD *)(v156 + 8);
                    *(void *)(v156 + 8) = 0;
                    *(void *)(v156 + 16) = 0;
                    *(void *)uint64_t v156 = 0;
                    v192 = *(void **)(v156 + 24);
                    v258 = *(void **)(v156 + 32);
                    int v193 = *(_DWORD *)(v156 + 43);
                    LODWORD(v337) = *(_DWORD *)(v156 + 40);
                    *(_DWORD *)((char *)&v337 + 3) = v193;
                    int v264 = *(char *)(v156 + 47);
                    *v167 = 0;
                    *(void *)(v156 + 32) = 0;
                    *(void *)(v156 + 40) = 0;
                    v260 = *(void **)(v156 + 48);
                    v262 = v192;
                    v255 = *(void **)(v156 + 56);
                    int v194 = *(_DWORD *)(v156 + 64);
                    *(_DWORD *)((char *)&v329 + 3) = *(_DWORD *)(v156 + 67);
                    LODWORD(v329) = v194;
                    int v195 = *(char *)(v156 + 71);
                    *v171 = 0;
                    *(void *)(v156 + 56) = 0;
                    *(void *)(v156 + 64) = 0;
                    __int16 v253 = *(_WORD *)(v156 + 72);
                    *(_OWORD *)v241 = v191;
                    v266 = v190;
                    v248 = (void *)v191;
                    v246 = (void *)(v191 - (void)v190);
                    do
                    {
                      uint64_t v196 = (uint64_t)v179;
                      sub_10005C9A4(v156, (__n128 *)v179);
                      v197 = (void **)(v156 + 24);
                      if (*(char *)(v156 + 47) < 0) {
                        operator delete(*v197);
                      }
                      long long v198 = *(_OWORD *)(v196 + 24);
                      *(void *)(v156 + 40) = *(void *)(v196 + 40);
                      *(_OWORD *)v197 = v198;
                      *(unsigned char *)(v196 + 47) = 0;
                      *(unsigned char *)(v196 + 24) = 0;
                      v199 = (void **)(v156 + 48);
                      if (*(char *)(v156 + 71) < 0) {
                        operator delete(*v199);
                      }
                      long long v200 = *(_OWORD *)(v196 + 48);
                      *(void *)(v156 + 64) = *(void *)(v196 + 64);
                      *(_OWORD *)v199 = v200;
                      *(unsigned char *)(v196 + 71) = 0;
                      *(unsigned char *)(v196 + 48) = 0;
                      *(_WORD *)(v156 + 72) = *(_WORD *)(v196 + 72);
                      if (!v178) {
                        break;
                      }
                      unint64_t v178 = (v178 - 1) >> 1;
                      v179 = &v8[10 * v178];
                      v353[1] = 0;
                      v353[0] = 0;
                      v354 = 0;
                      sub_10005C928(v353, *v179, (uint64_t)v179[1], (unsigned char *)v179[1] - (unsigned char *)*v179);
                      v201 = (void **)(v179 + 3);
                      if (*((char *)v179 + 47) < 0)
                      {
                        sub_10004FC84(&v355, *v201, (unint64_t)v8[10 * v178 + 4]);
                      }
                      else
                      {
                        long long v202 = *(_OWORD *)v201;
                        v356 = v8[10 * v178 + 5];
                        long long v355 = v202;
                      }
                      v203 = (void **)&v8[10 * v178 + 6];
                      if (*((char *)v179 + 71) < 0)
                      {
                        sub_10004FC84(&v357, *v203, (unint64_t)v8[10 * v178 + 7]);
                      }
                      else
                      {
                        long long v204 = *(_OWORD *)v203;
                        v358 = v8[10 * v178 + 8];
                        long long v357 = v204;
                      }
                      LOWORD(v359) = v8[10 * v178 + 9];
                      uint64_t v347 = 0;
                      v345 = 0;
                      v346 = 0;
                      sub_10005C928(&v345, v266, (uint64_t)v248, (size_t)v246);
                      if (v264 < 0)
                      {
                        sub_10004FC84(&v348, v262, (unint64_t)v258);
                      }
                      else
                      {
                        *(void *)&long long v348 = v262;
                        *((void *)&v348 + 1) = v258;
                        LODWORD(v349) = v337;
                        *(_DWORD *)((char *)&v349 + 3) = *(_DWORD *)((char *)&v337 + 3);
                        HIBYTE(v349) = v264;
                      }
                      if (v195 < 0)
                      {
                        sub_10004FC84(&v350, v260, (unint64_t)v255);
                      }
                      else
                      {
                        *(void *)&long long v350 = v260;
                        *((void *)&v350 + 1) = v255;
                        LODWORD(v351) = v329;
                        *(_DWORD *)((char *)&v351 + 3) = *(_DWORD *)((char *)&v329 + 3);
                        HIBYTE(v351) = v195;
                      }
                      __int16 v352 = v253;
                      char v205 = sub_100046FE8(&v355, (void **)&v348);
                      if (SHIBYTE(v351) < 0) {
                        operator delete((void *)v350);
                      }
                      if (SHIBYTE(v349) < 0) {
                        operator delete((void *)v348);
                      }
                      if (v345)
                      {
                        v346 = v345;
                        operator delete(v345);
                      }
                      if (SHIBYTE(v358) < 0) {
                        operator delete((void *)v357);
                      }
                      if (SHIBYTE(v356) < 0) {
                        operator delete((void *)v355);
                      }
                      if (v353[0])
                      {
                        v353[1] = v353[0];
                        operator delete(v353[0]);
                      }
                      uint64_t v156 = v196;
                    }
                    while (v205 < 0);
                    v206 = *(void **)v196;
                    if (*(void *)v196)
                    {
                      *(void *)(v196 + 8) = v206;
                      operator delete(v206);
                      *(void *)uint64_t v196 = 0;
                      *(void *)(v196 + 8) = 0;
                      *(void *)(v196 + 16) = 0;
                    }
                    *(void *)uint64_t v196 = v266;
                    *(_OWORD *)(v196 + 8) = *(_OWORD *)v241;
                    if (*(char *)(v196 + 47) < 0) {
                      operator delete(*(void **)(v196 + 24));
                    }
                    *(void *)(v196 + 24) = v262;
                    *(void *)(v196 + 32) = v258;
                    *(_DWORD *)(v196 + 40) = v337;
                    *(_DWORD *)(v196 + 43) = *(_DWORD *)((char *)&v337 + 3);
                    *(unsigned char *)(v196 + 47) = v264;
                    if (*(char *)(v196 + 71) < 0) {
                      operator delete(*(void **)(v196 + 48));
                    }
                    *(void *)(v196 + 48) = v260;
                    *(void *)(v196 + 56) = v255;
                    *(_DWORD *)(v196 + 64) = v329;
                    *(_DWORD *)(v196 + 67) = *(_DWORD *)((char *)&v329 + 3);
                    *(unsigned char *)(v196 + 71) = v195;
                    *(_WORD *)(v196 + 72) = v253;
                  }
                }
                v151 = v240;
              }
              unint64_t v150 = v271 - 1;
            }
            while (v271 > 2);
          }
          return;
        }
        unint64_t v11 = v249 >> 1;
        uint64_t v12 = v10 + 80 * (v249 >> 1);
        if ((unint64_t)v9 < 0x2801)
        {
          sub_10079E970(v10 + 80 * (v249 >> 1), v10, v235);
          uint64_t v13 = a1;
        }
        else
        {
          sub_10079E970(v10, v10 + 80 * (v249 >> 1), v235);
          sub_10079E970(a1 + 80, a1 + 80 * v11 - 80, v232);
          sub_10079E970(a1 + 160, a1 + 80 * v11 + 80, v231);
          sub_10079E970(a1 + 80 * v11 - 80, v12, a1 + 80 * v11 + 80);
          uint64_t v13 = a1;
          sub_1007A0A70(a1, v12);
        }
        --a3;
        if (a4) {
          break;
        }
        v281 = 0;
        v282 = 0;
        uint64_t v283 = 0;
        sub_10005C928(&v281, *(const void **)(v13 - 80), *(void *)(v13 - 72), *(void *)(v13 - 72) - *(void *)(v13 - 80));
        uint64_t v13 = a1;
        if (*(char *)(a1 - 33) < 0)
        {
          sub_10004FC84(&v284, *(void **)(a1 - 56), *(void *)(a1 - 48));
        }
        else
        {
          long long v14 = *(_OWORD *)(a1 - 56);
          uint64_t v285 = *(void *)(a1 - 40);
          long long v284 = v14;
        }
        if (*(char *)(a1 - 9) < 0)
        {
          sub_10004FC84(&v286, *(void **)(a1 - 32), *(void *)(a1 - 24));
        }
        else
        {
          long long v15 = *(_OWORD *)(a1 - 32);
          uint64_t v287 = *(void *)(a1 - 16);
          long long v286 = v15;
        }
        __int16 v288 = *(_WORD *)(a1 - 8);
        v274 = 0;
        uint64_t v275 = 0;
        v273 = 0;
        sub_10005C928(&v273, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
        if (*(char *)(a1 + 47) < 0)
        {
          sub_10004FC84(&v276, *(void **)(a1 + 24), *(void *)(a1 + 32));
        }
        else
        {
          long long v16 = *(_OWORD *)(a1 + 24);
          uint64_t v277 = *(void *)(a1 + 40);
          long long v276 = v16;
        }
        if (*(char *)(a1 + 71) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
        }
        else
        {
          long long v17 = *(_OWORD *)(a1 + 48);
          uint64_t v279 = *(void *)(a1 + 64);
          long long __p = v17;
        }
        __int16 v280 = *(_WORD *)(a1 + 72);
        char v18 = sub_100046FE8(&v284, (void **)&v276);
        if (SHIBYTE(v279) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v277) < 0) {
          operator delete((void *)v276);
        }
        if (v273)
        {
          v274 = v273;
          operator delete(v273);
        }
        if (SHIBYTE(v287) < 0) {
          operator delete((void *)v286);
        }
        if (SHIBYTE(v285) < 0) {
          operator delete((void *)v284);
        }
        if (v281)
        {
          v282 = v281;
          operator delete(v281);
        }
        if (v18 < 0) {
          break;
        }
        uint64_t v8 = sub_10079F358(a1, v239);
LABEL_198:
        a4 = 0;
        a2 = (const void **)v239;
      }
      uint64_t v19 = 0;
      uint64_t v374 = 0;
      *(_OWORD *)v368 = *(_OWORD *)v13;
      uint64_t v369 = *(void *)(v13 + 16);
      *(void *)uint64_t v13 = 0;
      *(void *)(v13 + 8) = 0;
      *(void *)(v13 + 16) = 0;
      uint64_t v236 = v13 + 24;
      long long v20 = *(_OWORD *)(v13 + 24);
      *((void *)p_src + 2) = *(void *)(v13 + 40);
      long long *p_src = v20;
      *(void *)(v13 + 32) = 0;
      *(void *)(v13 + 40) = 0;
      *(void *)(v13 + 24) = 0;
      uint64_t v237 = v13 + 48;
      uint64_t v238 = a3;
      long long v21 = *(_OWORD *)(v13 + 48);
      v373 = *(const void **)(v13 + 64);
      long long v372 = v21;
      *(void *)(v13 + 48) = 0;
      *(void *)(v13 + 56) = 0;
      *(void *)(v13 + 64) = 0;
      __int16 v250 = *(_WORD *)(v13 + 72);
      LOWORD(v374) = v250;
      do
      {
        v361 = 0;
        v360 = 0;
        uint64_t v362 = 0;
        sub_10005C928(&v360, *(const void **)(v13 + v19 + 80), *(void *)(v13 + v19 + 88), *(void *)(v13 + v19 + 88) - *(void *)(v13 + v19 + 80));
        uint64_t v22 = (void **)(v13 + v19 + 104);
        if (*(char *)(v13 + v19 + 127) < 0)
        {
          sub_10004FC84(&v363, *v22, *(void *)(v13 + v19 + 112));
        }
        else
        {
          long long v23 = *(_OWORD *)v22;
          v364 = *(const void **)(v13 + v19 + 120);
          long long v363 = v23;
        }
        uint64_t v24 = (void **)(v13 + v19 + 128);
        if (*(char *)(v13 + v19 + 151) < 0)
        {
          sub_10004FC84(&v365, *v24, *(void *)(v13 + v19 + 136));
        }
        else
        {
          long long v25 = *(_OWORD *)v24;
          v366 = *(const void **)(v13 + v19 + 144);
          long long v365 = v25;
        }
        __int16 v367 = *(_WORD *)(v13 + v19 + 152);
        v354 = 0;
        v353[0] = 0;
        v353[1] = 0;
        int v26 = v368[0];
        int v27 = v368[1];
        size_t v28 = (char *)v368[1] - (char *)v368[0];
        sub_10005C928(v353, v368[0], (uint64_t)v368[1], (char *)v368[1] - (char *)v368[0]);
        int v29 = SHIBYTE(v371);
        if (SHIBYTE(v371) < 0)
        {
          sub_10004FC84(&v355, (void *)__src, *((unint64_t *)&__src + 1));
        }
        else
        {
          long long v355 = *p_src;
          v356 = (const void *)*((void *)p_src + 2);
        }
        int v30 = SHIBYTE(v373);
        if (SHIBYTE(v373) < 0)
        {
          sub_10004FC84(&v357, (void *)v372, *((unint64_t *)&v372 + 1));
        }
        else
        {
          long long v357 = v372;
          v358 = v373;
        }
        LOWORD(v359) = v250;
        char v31 = sub_100046FE8(&v363, (void **)&v355);
        if (SHIBYTE(v358) < 0) {
          operator delete((void *)v357);
        }
        if (SHIBYTE(v356) < 0) {
          operator delete((void *)v355);
        }
        if (v353[0])
        {
          v353[1] = v353[0];
          operator delete(v353[0]);
        }
        if (SHIBYTE(v366) < 0) {
          operator delete((void *)v365);
        }
        if (SHIBYTE(v364) < 0) {
          operator delete((void *)v363);
        }
        if (v360)
        {
          v361 = v360;
          operator delete(v360);
        }
        v19 += 80;
      }
      while (v31 < 0);
      unint64_t v242 = v13 + v19;
      unint64_t v32 = v239;
      if (v19 == 80)
      {
        unint64_t i = v239;
        if (v242 < v239)
        {
          for (unint64_t i = v235; ; i -= 80)
          {
            v346 = 0;
            v345 = 0;
            uint64_t v347 = 0;
            sub_10005C928(&v345, *(const void **)i, *(void *)(i + 8), *(void *)(i + 8) - *(void *)i);
            if (*(char *)(i + 47) < 0)
            {
              sub_10004FC84(&v348, *(void **)(i + 24), *(void *)(i + 32));
            }
            else
            {
              long long v38 = *(_OWORD *)(i + 24);
              v349 = *(const void **)(i + 40);
              long long v348 = v38;
            }
            if (*(char *)(i + 71) < 0)
            {
              sub_10004FC84(&v350, *(void **)(i + 48), *(void *)(i + 56));
            }
            else
            {
              long long v39 = *(_OWORD *)(i + 48);
              v351 = *(const void **)(i + 64);
              long long v350 = v39;
            }
            __int16 v352 = *(_WORD *)(i + 72);
            uint64_t v383 = 0;
            long long v382 = 0uLL;
            sub_10005C928(&v382, v26, (uint64_t)v27, v28);
            if (v29 < 0)
            {
              sub_10004FC84(&v384, (void *)__src, *((unint64_t *)&__src + 1));
            }
            else
            {
              long long v384 = *p_src;
              uint64_t v385 = *((void *)p_src + 2);
            }
            if (v30 < 0)
            {
              sub_10004FC84(&v386, (void *)v372, *((unint64_t *)&v372 + 1));
            }
            else
            {
              long long v386 = v372;
              v387 = v373;
            }
            LOWORD(v388) = v250;
            char v40 = sub_100046FE8(&v348, (void **)&v384);
            if (SHIBYTE(v387) < 0) {
              operator delete((void *)v386);
            }
            if (SHIBYTE(v385) < 0) {
              operator delete((void *)v384);
            }
            if ((void)v382)
            {
              *((void *)&v382 + 1) = v382;
              operator delete((void *)v382);
            }
            if (SHIBYTE(v351) < 0) {
              operator delete((void *)v350);
            }
            if (SHIBYTE(v349) < 0) {
              operator delete((void *)v348);
            }
            if (v345)
            {
              v346 = v345;
              operator delete(v345);
            }
            if (v242 >= i || v40 < 0) {
              break;
            }
          }
        }
      }
      else
      {
        do
        {
          long long v375 = 0uLL;
          uint64_t v376 = 0;
          unint64_t i = v32 - 80;
          sub_10005C928(&v375, *(const void **)(v32 - 80), *(void *)(v32 - 72), *(void *)(v32 - 72) - *(void *)(v32 - 80));
          if (*(char *)(v32 - 33) < 0)
          {
            sub_10004FC84(&v377, *(void **)(v32 - 56), *(void *)(v32 - 48));
          }
          else
          {
            long long v34 = *(_OWORD *)(v32 - 56);
            v378 = *(const void **)(v32 - 40);
            long long v377 = v34;
          }
          if (*(char *)(v32 - 9) < 0)
          {
            sub_10004FC84(&v379, *(void **)(v32 - 32), *(void *)(v32 - 24));
          }
          else
          {
            long long v35 = *(_OWORD *)(v32 - 32);
            v380 = *(const void **)(v32 - 16);
            long long v379 = v35;
          }
          __int16 v381 = *(_WORD *)(v32 - 8);
          uint64_t v339 = 0;
          v337 = 0;
          v338 = 0;
          sub_10005C928(&v337, v26, (uint64_t)v27, v28);
          if (v29 < 0)
          {
            sub_10004FC84(&v340, (void *)__src, *((unint64_t *)&__src + 1));
          }
          else
          {
            long long v340 = *p_src;
            v341 = (const void *)*((void *)p_src + 2);
          }
          if (v30 < 0)
          {
            sub_10004FC84(&v342, (void *)v372, *((unint64_t *)&v372 + 1));
          }
          else
          {
            long long v342 = v372;
            v343 = v373;
          }
          __int16 v344 = v250;
          char v36 = sub_100046FE8(&v377, (void **)&v340);
          if (SHIBYTE(v343) < 0) {
            operator delete((void *)v342);
          }
          if (SHIBYTE(v341) < 0) {
            operator delete((void *)v340);
          }
          if (v337)
          {
            v338 = v337;
            operator delete(v337);
          }
          if (SHIBYTE(v380) < 0) {
            operator delete((void *)v379);
          }
          if (SHIBYTE(v378) < 0) {
            operator delete((void *)v377);
          }
          if ((void)v375)
          {
            *((void *)&v375 + 1) = v375;
            operator delete((void *)v375);
          }
          int v37 = v36;
          unint64_t v32 = i;
        }
        while ((v37 & 0x80000000) == 0);
      }
      unint64_t v41 = v242;
      if (v242 >= i)
      {
        uint64_t v43 = v242;
        a3 = v238;
      }
      else
      {
        unint64_t v233 = i;
        unint64_t v42 = i;
        uint64_t v43 = v242;
        do
        {
          int v44 = p_src;
          sub_1007A0A70(v43, v42);
          int v45 = (const void **)(v43 + 152);
          do
          {
            v330 = 0;
            v329 = 0;
            uint64_t v331 = 0;
            sub_10005C928(&v329, *(v45 - 9), (uint64_t)*(v45 - 8), (unsigned char *)*(v45 - 8) - (unsigned char *)*(v45 - 9));
            if (*((char *)v45 - 25) < 0)
            {
              sub_10004FC84(&v332, (void *)*(v45 - 6), (unint64_t)*(v45 - 5));
            }
            else
            {
              long long v46 = *((_OWORD *)v45 - 3);
              v333 = *(v45 - 4);
              long long v332 = v46;
            }
            if (*((char *)v45 - 1) < 0)
            {
              sub_10004FC84(&v334, (void *)*(v45 - 3), (unint64_t)*(v45 - 2));
            }
            else
            {
              long long v47 = *(_OWORD *)(v45 - 3);
              v335 = *(v45 - 1);
              long long v334 = v47;
            }
            __int16 v336 = *(_WORD *)v45;
            uint64_t v323 = 0;
            v321 = 0;
            v322 = 0;
            uint64_t v48 = v368[0];
            __int16 v49 = v368[1];
            size_t v50 = (char *)v368[1] - (char *)v368[0];
            sub_10005C928(&v321, v368[0], (uint64_t)v368[1], (char *)v368[1] - (char *)v368[0]);
            int v51 = SHIBYTE(v371);
            if (SHIBYTE(v371) < 0)
            {
              sub_10004FC84(&v324, (void *)__src, *((unint64_t *)&__src + 1));
            }
            else
            {
              long long v324 = *v44;
              uint64_t v325 = *((void *)v44 + 2);
            }
            int v52 = SHIBYTE(v373);
            if (SHIBYTE(v373) < 0)
            {
              sub_10004FC84(&v326, (void *)v372, *((unint64_t *)&v372 + 1));
            }
            else
            {
              long long v326 = v372;
              v327 = v373;
            }
            __int16 v53 = v374;
            __int16 v328 = v374;
            char v54 = sub_100046FE8(&v332, (void **)&v324);
            if (SHIBYTE(v327) < 0) {
              operator delete((void *)v326);
            }
            if (SHIBYTE(v325) < 0) {
              operator delete((void *)v324);
            }
            if (v321)
            {
              v322 = v321;
              operator delete(v321);
            }
            if (SHIBYTE(v335) < 0) {
              operator delete((void *)v334);
            }
            if (SHIBYTE(v333) < 0) {
              operator delete((void *)v332);
            }
            if (v329)
            {
              v330 = v329;
              operator delete(v329);
            }
            v45 += 10;
          }
          while (v54 < 0);
          v251 = v45 - 19;
          unint64_t v55 = v42;
          p_src = v44;
          do
          {
            v314 = 0;
            v313 = 0;
            uint64_t v315 = 0;
            uint64_t v56 = *(const void **)(v42 - 80);
            uint64_t v57 = *(void *)(v42 - 72);
            v42 -= 80;
            sub_10005C928(&v313, v56, v57, v57 - (void)v56);
            if (*(char *)(v55 - 33) < 0)
            {
              sub_10004FC84(&v316, *(void **)(v55 - 56), *(void *)(v55 - 48));
            }
            else
            {
              long long v58 = *(_OWORD *)(v55 - 56);
              uint64_t v317 = *(void *)(v55 - 40);
              long long v316 = v58;
            }
            if (*(char *)(v55 - 9) < 0)
            {
              sub_10004FC84(&v318, *(void **)(v55 - 32), *(void *)(v55 - 24));
            }
            else
            {
              long long v59 = *(_OWORD *)(v55 - 32);
              uint64_t v319 = *(void *)(v55 - 16);
              long long v318 = v59;
            }
            __int16 v320 = *(_WORD *)(v55 - 8);
            uint64_t v307 = 0;
            v305 = 0;
            v306 = 0;
            sub_10005C928(&v305, v48, (uint64_t)v49, v50);
            if (v51 < 0)
            {
              sub_10004FC84(&v308, (void *)__src, *((unint64_t *)&__src + 1));
            }
            else
            {
              long long v308 = *v44;
              uint64_t v309 = *((void *)v44 + 2);
            }
            if (v52 < 0)
            {
              sub_10004FC84(&v310, (void *)v372, *((unint64_t *)&v372 + 1));
            }
            else
            {
              long long v310 = v372;
              v311 = v373;
            }
            __int16 v312 = v53;
            char v60 = sub_100046FE8(&v316, (void **)&v308);
            if (SHIBYTE(v311) < 0) {
              operator delete((void *)v310);
            }
            if (SHIBYTE(v309) < 0) {
              operator delete((void *)v308);
            }
            if (v305)
            {
              v306 = v305;
              operator delete(v305);
            }
            if (SHIBYTE(v319) < 0) {
              operator delete((void *)v318);
            }
            if (SHIBYTE(v317) < 0) {
              operator delete((void *)v316);
            }
            if (v313)
            {
              v314 = v313;
              operator delete(v313);
            }
            int v61 = v60;
            unint64_t v55 = v42;
          }
          while ((v61 & 0x80000000) == 0);
          uint64_t v43 = (uint64_t)v251;
        }
        while ((unint64_t)v251 < v42);
        uint64_t v13 = a1;
        a3 = v238;
        unint64_t v41 = v242;
        unint64_t i = v233;
      }
      uint64_t v62 = (void **)(v43 - 80);
      if (v43 - 80 != v13)
      {
        sub_10005C9A4(v13, (__n128 *)(v43 - 80));
        if (*(char *)(v13 + 47) < 0) {
          operator delete(*(void **)v236);
        }
        long long v63 = *(_OWORD *)(v43 - 56);
        *(void *)(v236 + 16) = *(void *)(v43 - 40);
        *(_OWORD *)uint64_t v236 = v63;
        *(unsigned char *)(v43 - 33) = 0;
        *(unsigned char *)(v43 - 56) = 0;
        if (*(char *)(v13 + 71) < 0) {
          operator delete(*(void **)v237);
        }
        long long v64 = *(_OWORD *)(v43 - 32);
        *(void *)(v237 + 16) = *(void *)(v43 - 16);
        *(_OWORD *)uint64_t v237 = v64;
        *(unsigned char *)(v43 - 9) = 0;
        *(unsigned char *)(v43 - 32) = 0;
        *(_WORD *)(v13 + 72) = *(_WORD *)(v43 - 8);
      }
      uint64_t v65 = v43;
      unint64_t v66 = i;
      long long v67 = *v62;
      if (*v62)
      {
        *(void *)(v65 - 72) = v67;
        operator delete(v67);
        char *v62 = 0;
        v62[1] = 0;
        v62[2] = 0;
      }
      *(_OWORD *)(v65 - 80) = *(_OWORD *)v368;
      *(void *)(v65 - 64) = v369;
      v368[1] = 0;
      v368[0] = 0;
      uint64_t v369 = 0;
      long long v68 = (void **)(v65 - 56);
      if (*(char *)(v65 - 33) < 0) {
        operator delete(*v68);
      }
      long long v69 = *p_src;
      *(void *)(v65 - 40) = *((void *)p_src + 2);
      *(_OWORD *)long long v68 = v69;
      HIBYTE(v371) = 0;
      LOBYTE(__src) = 0;
      long long v70 = (void **)(v65 - 32);
      if (*(char *)(v65 - 9) < 0) {
        operator delete(*v70);
      }
      long long v71 = v372;
      *(void *)(v65 - 16) = v373;
      *(_OWORD *)long long v70 = v71;
      HIBYTE(v373) = 0;
      LOBYTE(v372) = 0;
      uint64_t v8 = (const void **)v65;
      *(_WORD *)(v65 - 8) = v374;
      if (SHIBYTE(v373) < 0) {
        operator delete((void *)v372);
      }
      if (SHIBYTE(v371) < 0) {
        operator delete((void *)__src);
      }
      if (v368[0]) {
        operator delete(v368[0]);
      }
      if (v41 < v66)
      {
LABEL_196:
        sub_10079ABAC(v13, v62, a3, a4 & 1);
        goto LABEL_198;
      }
      BOOL v72 = sub_1007A0168(v13, (uint64_t)v62);
      if (sub_1007A0168(v65, v239)) {
        break;
      }
      uint64_t v13 = a1;
      a2 = (const void **)v239;
      if (!v72) {
        goto LABEL_196;
      }
    }
    a2 = (const void **)v62;
    if (!v72) {
      continue;
    }
    break;
  }
}

void sub_10079D9EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,void *a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x20F]) < 0) {
    operator delete(__p);
  }
  if (a69) {
    operator delete(a69);
  }
  sub_10079AB58((uint64_t)&STACK[0x230]);
  _Unwind_Resume(a1);
}

void sub_10079E114(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_1007A0C14(a1, a2, a3, a4);
  long long v76 = 0;
  long long v77 = 0;
  uint64_t v78 = 0;
  sub_10005C928(&v76, *(const void **)a5, *(void *)(a5 + 8), *(void *)(a5 + 8) - *(void *)a5);
  if (*(char *)(a5 + 47) < 0)
  {
    sub_10004FC84(&v79, *(void **)(a5 + 24), *(void *)(a5 + 32));
  }
  else
  {
    long long v79 = *(_OWORD *)(a5 + 24);
    uint64_t v80 = *(void *)(a5 + 40);
  }
  if (*(char *)(a5 + 71) < 0)
  {
    sub_10004FC84(&v81, *(void **)(a5 + 48), *(void *)(a5 + 56));
  }
  else
  {
    long long v81 = *(_OWORD *)(a5 + 48);
    uint64_t v82 = *(void *)(a5 + 64);
  }
  __int16 v83 = *(_WORD *)(a5 + 72);
  long long v69 = 0;
  uint64_t v70 = 0;
  long long v68 = 0;
  sub_10005C928(&v68, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
  uint64_t v10 = (long long *)(a4 + 24);
  if (*(char *)(a4 + 47) < 0)
  {
    sub_10004FC84(&v71, *(void **)(a4 + 24), *(void *)(a4 + 32));
  }
  else
  {
    long long v71 = *v10;
    uint64_t v72 = *(void *)(a4 + 40);
  }
  unint64_t v11 = (long long *)(a4 + 48);
  if (*(char *)(a4 + 71) < 0)
  {
    sub_10004FC84(&v73, *(void **)(a4 + 48), *(void *)(a4 + 56));
  }
  else
  {
    long long v73 = *v11;
    uint64_t v74 = *(void *)(a4 + 64);
  }
  __int16 v75 = *(_WORD *)(a4 + 72);
  char v12 = sub_100046FE8(&v79, (void **)&v71);
  if (SHIBYTE(v74) < 0) {
    operator delete((void *)v73);
  }
  if (SHIBYTE(v72) < 0) {
    operator delete((void *)v71);
  }
  if (v68)
  {
    long long v69 = v68;
    operator delete(v68);
  }
  if (SHIBYTE(v82) < 0) {
    operator delete((void *)v81);
  }
  if (SHIBYTE(v80) < 0) {
    operator delete((void *)v79);
  }
  if (v76)
  {
    long long v77 = v76;
    operator delete(v76);
  }
  if (v12 < 0)
  {
    sub_1007A0A70(a4, a5);
    char v60 = 0;
    int v61 = 0;
    uint64_t v62 = 0;
    sub_10005C928(&v60, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
    if (*(char *)(a4 + 47) < 0)
    {
      sub_10004FC84(&v63, *(void **)(a4 + 24), *(void *)(a4 + 32));
    }
    else
    {
      long long v63 = *v10;
      uint64_t v64 = *(void *)(a4 + 40);
    }
    if (*(char *)(a4 + 71) < 0)
    {
      sub_10004FC84(&v65, *(void **)(a4 + 48), *(void *)(a4 + 56));
    }
    else
    {
      long long v65 = *v11;
      uint64_t v66 = *(void *)(a4 + 64);
    }
    __int16 v67 = *(_WORD *)(a4 + 72);
    __int16 v53 = 0;
    uint64_t v54 = 0;
    int v52 = 0;
    sub_10005C928(&v52, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    uint64_t v13 = (long long *)(a3 + 24);
    if (*(char *)(a3 + 47) < 0)
    {
      sub_10004FC84(&v55, *(void **)(a3 + 24), *(void *)(a3 + 32));
    }
    else
    {
      long long v55 = *v13;
      uint64_t v56 = *(void *)(a3 + 40);
    }
    long long v14 = (long long *)(a3 + 48);
    if (*(char *)(a3 + 71) < 0)
    {
      sub_10004FC84(&__p, *(void **)(a3 + 48), *(void *)(a3 + 56));
    }
    else
    {
      long long __p = *v14;
      uint64_t v58 = *(void *)(a3 + 64);
    }
    __int16 v59 = *(_WORD *)(a3 + 72);
    char v15 = sub_100046FE8(&v63, (void **)&v55);
    if (SHIBYTE(v58) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v56) < 0) {
      operator delete((void *)v55);
    }
    if (v52)
    {
      __int16 v53 = v52;
      operator delete(v52);
    }
    if (SHIBYTE(v66) < 0) {
      operator delete((void *)v65);
    }
    if (SHIBYTE(v64) < 0) {
      operator delete((void *)v63);
    }
    if (v60)
    {
      int v61 = v60;
      operator delete(v60);
    }
    if (v15 < 0)
    {
      sub_1007A0A70(a3, a4);
      int v44 = 0;
      int v45 = 0;
      uint64_t v46 = 0;
      sub_10005C928(&v44, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
      if (*(char *)(a3 + 47) < 0)
      {
        sub_10004FC84(&v47, *(void **)(a3 + 24), *(void *)(a3 + 32));
      }
      else
      {
        long long v47 = *v13;
        uint64_t v48 = *(void *)(a3 + 40);
      }
      if (*(char *)(a3 + 71) < 0)
      {
        sub_10004FC84(&v49, *(void **)(a3 + 48), *(void *)(a3 + 56));
      }
      else
      {
        long long v49 = *v14;
        uint64_t v50 = *(void *)(a3 + 64);
      }
      __int16 v51 = *(_WORD *)(a3 + 72);
      int v37 = 0;
      uint64_t v38 = 0;
      char v36 = 0;
      sub_10005C928(&v36, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
      long long v16 = (long long *)(a2 + 24);
      if (*(char *)(a2 + 47) < 0)
      {
        sub_10004FC84(&v39, *(void **)(a2 + 24), *(void *)(a2 + 32));
      }
      else
      {
        long long v39 = *v16;
        uint64_t v40 = *(void *)(a2 + 40);
      }
      long long v17 = (long long *)(a2 + 48);
      if (*(char *)(a2 + 71) < 0)
      {
        sub_10004FC84(&v41, *(void **)(a2 + 48), *(void *)(a2 + 56));
      }
      else
      {
        long long v41 = *v17;
        uint64_t v42 = *(void *)(a2 + 64);
      }
      __int16 v43 = *(_WORD *)(a2 + 72);
      char v18 = sub_100046FE8(&v47, (void **)&v39);
      if (SHIBYTE(v42) < 0) {
        operator delete((void *)v41);
      }
      if (SHIBYTE(v40) < 0) {
        operator delete((void *)v39);
      }
      if (v36)
      {
        int v37 = v36;
        operator delete(v36);
      }
      if (SHIBYTE(v50) < 0) {
        operator delete((void *)v49);
      }
      if (SHIBYTE(v48) < 0) {
        operator delete((void *)v47);
      }
      if (v44)
      {
        int v45 = v44;
        operator delete(v44);
      }
      if (v18 < 0)
      {
        sub_1007A0A70(a2, a3);
        size_t v28 = 0;
        int v29 = 0;
        uint64_t v30 = 0;
        sub_10005C928(&v28, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
        if (*(char *)(a2 + 47) < 0)
        {
          sub_10004FC84(&v31, *(void **)(a2 + 24), *(void *)(a2 + 32));
        }
        else
        {
          long long v31 = *v16;
          uint64_t v32 = *(void *)(a2 + 40);
        }
        if (*(char *)(a2 + 71) < 0)
        {
          sub_10004FC84(&v33, *(void **)(a2 + 48), *(void *)(a2 + 56));
        }
        else
        {
          long long v33 = *v17;
          uint64_t v34 = *(void *)(a2 + 64);
        }
        __int16 v35 = *(_WORD *)(a2 + 72);
        long long v21 = 0;
        uint64_t v22 = 0;
        long long v20 = 0;
        sub_10005C928(&v20, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
        if (*(char *)(a1 + 47) < 0)
        {
          sub_10004FC84(&v23, *(void **)(a1 + 24), *(void *)(a1 + 32));
        }
        else
        {
          long long v23 = *(_OWORD *)(a1 + 24);
          uint64_t v24 = *(void *)(a1 + 40);
        }
        if (*(char *)(a1 + 71) < 0)
        {
          sub_10004FC84(&v25, *(void **)(a1 + 48), *(void *)(a1 + 56));
        }
        else
        {
          long long v25 = *(_OWORD *)(a1 + 48);
          uint64_t v26 = *(void *)(a1 + 64);
        }
        __int16 v27 = *(_WORD *)(a1 + 72);
        char v19 = sub_100046FE8(&v31, (void **)&v23);
        if (SHIBYTE(v26) < 0) {
          operator delete((void *)v25);
        }
        if (SHIBYTE(v24) < 0) {
          operator delete((void *)v23);
        }
        if (v20)
        {
          long long v21 = v20;
          operator delete(v20);
        }
        if (SHIBYTE(v34) < 0) {
          operator delete((void *)v33);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete((void *)v31);
        }
        if (v28)
        {
          int v29 = v28;
          operator delete(v28);
        }
        if (v19 < 0) {
          sub_1007A0A70(a1, a2);
        }
      }
    }
  }
}

void sub_10079E7A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a10) {
    operator delete(a10);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a23)
  {
    void *v37 = a23;
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

void sub_10079E970(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v91 = 0;
  char v92 = 0;
  uint64_t v93 = 0;
  sub_10005C928(&v91, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  int v6 = (long long *)(a2 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(&v94, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v94 = *v6;
    uint64_t v95 = *(void *)(a2 + 40);
  }
  int v7 = (long long *)(a2 + 48);
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84(&v96, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v96 = *v7;
    uint64_t v97 = *(void *)(a2 + 64);
  }
  __int16 v98 = *(_WORD *)(a2 + 72);
  long long v84 = 0;
  uint64_t v85 = 0;
  __int16 v83 = 0;
  sub_10005C928(&v83, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  uint64_t v8 = (long long *)(a1 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    sub_10004FC84(&v86, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    long long v86 = *v8;
    uint64_t v87 = *(void *)(a1 + 40);
  }
  uint64_t v9 = (long long *)(a1 + 48);
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(&v88, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    long long v88 = *v9;
    uint64_t v89 = *(void *)(a1 + 64);
  }
  __int16 v90 = *(_WORD *)(a1 + 72);
  char v10 = sub_100046FE8(&v94, (void **)&v86);
  if (SHIBYTE(v89) < 0) {
    operator delete((void *)v88);
  }
  if (SHIBYTE(v87) < 0) {
    operator delete((void *)v86);
  }
  if (v83)
  {
    long long v84 = v83;
    operator delete(v83);
  }
  if (SHIBYTE(v97) < 0) {
    operator delete((void *)v96);
  }
  if (SHIBYTE(v95) < 0) {
    operator delete((void *)v94);
  }
  if (v91)
  {
    char v92 = v91;
    operator delete(v91);
  }
  unint64_t v11 = (long long *)(a3 + 24);
  if (v10 < 0)
  {
    __int16 v43 = 0;
    int v44 = 0;
    uint64_t v45 = 0;
    sub_10005C928(&v43, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    if (*(char *)(a3 + 47) < 0)
    {
      sub_10004FC84(&v46, *(void **)(a3 + 24), *(void *)(a3 + 32));
    }
    else
    {
      long long v46 = *v11;
      uint64_t v47 = *(void *)(a3 + 40);
    }
    uint64_t v13 = (long long *)(a3 + 48);
    if (*(char *)(a3 + 71) < 0)
    {
      sub_10004FC84(&v48, *(void **)(a3 + 48), *(void *)(a3 + 56));
    }
    else
    {
      long long v48 = *v13;
      uint64_t v49 = *(void *)(a3 + 64);
    }
    __int16 v50 = *(_WORD *)(a3 + 72);
    char v36 = 0;
    uint64_t v37 = 0;
    __int16 v35 = 0;
    sub_10005C928(&v35, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    if (*(char *)(a2 + 47) < 0)
    {
      sub_10004FC84(&v38, *(void **)(a2 + 24), *(void *)(a2 + 32));
    }
    else
    {
      long long v38 = *v6;
      uint64_t v39 = *(void *)(a2 + 40);
    }
    if (*(char *)(a2 + 71) < 0)
    {
      sub_10004FC84(&v40, *(void **)(a2 + 48), *(void *)(a2 + 56));
    }
    else
    {
      long long v40 = *v7;
      uint64_t v41 = *(void *)(a2 + 64);
    }
    __int16 v42 = *(_WORD *)(a2 + 72);
    char v14 = sub_100046FE8(&v46, (void **)&v38);
    if (SHIBYTE(v41) < 0) {
      operator delete((void *)v40);
    }
    if (SHIBYTE(v39) < 0) {
      operator delete((void *)v38);
    }
    if (v35)
    {
      char v36 = v35;
      operator delete(v35);
    }
    if (SHIBYTE(v49) < 0) {
      operator delete((void *)v48);
    }
    if (SHIBYTE(v47) < 0) {
      operator delete((void *)v46);
    }
    if (v43)
    {
      int v44 = v43;
      operator delete(v43);
    }
    uint64_t v15 = a1;
    if ((v14 & 0x80000000) == 0)
    {
      sub_1007A0A70(a1, a2);
      __int16 v27 = 0;
      size_t v28 = 0;
      uint64_t v29 = 0;
      sub_10005C928(&v27, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
      if (*(char *)(a3 + 47) < 0)
      {
        sub_10004FC84(&v30, *(void **)(a3 + 24), *(void *)(a3 + 32));
      }
      else
      {
        long long v30 = *v11;
        uint64_t v31 = *(void *)(a3 + 40);
      }
      if (*(char *)(a3 + 71) < 0)
      {
        sub_10004FC84(&v32, *(void **)(a3 + 48), *(void *)(a3 + 56));
      }
      else
      {
        long long v32 = *v13;
        uint64_t v33 = *(void *)(a3 + 64);
      }
      __int16 v34 = *(_WORD *)(a3 + 72);
      long long v20 = 0;
      uint64_t v21 = 0;
      char v19 = 0;
      sub_10005C928(&v19, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
      if (*(char *)(a2 + 47) < 0)
      {
        sub_10004FC84(&v22, *(void **)(a2 + 24), *(void *)(a2 + 32));
      }
      else
      {
        long long v22 = *v6;
        uint64_t v23 = *(void *)(a2 + 40);
      }
      if (*(char *)(a2 + 71) < 0)
      {
        sub_10004FC84(&v24, *(void **)(a2 + 48), *(void *)(a2 + 56));
      }
      else
      {
        long long v24 = *v7;
        uint64_t v25 = *(void *)(a2 + 64);
      }
      __int16 v26 = *(_WORD *)(a2 + 72);
      char v18 = sub_100046FE8(&v30, (void **)&v22);
      if (SHIBYTE(v25) < 0) {
        operator delete((void *)v24);
      }
      if (SHIBYTE(v23) < 0) {
        operator delete((void *)v22);
      }
      if (v19)
      {
        long long v20 = v19;
        operator delete(v19);
      }
      if (SHIBYTE(v33) < 0) {
        operator delete((void *)v32);
      }
      if (SHIBYTE(v31) < 0) {
        operator delete((void *)v30);
      }
      if (v27)
      {
        size_t v28 = v27;
        operator delete(v27);
      }
      if ((v18 & 0x80000000) == 0) {
        return;
      }
      uint64_t v15 = a2;
    }
    uint64_t v17 = a3;
    goto LABEL_129;
  }
  long long v76 = 0;
  __int16 v75 = 0;
  uint64_t v77 = 0;
  sub_10005C928(&v75, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  if (*(char *)(a3 + 47) < 0)
  {
    sub_10004FC84(&v78, *(void **)(a3 + 24), *(void *)(a3 + 32));
  }
  else
  {
    long long v78 = *v11;
    uint64_t v79 = *(void *)(a3 + 40);
  }
  if (*(char *)(a3 + 71) < 0)
  {
    sub_10004FC84(&v80, *(void **)(a3 + 48), *(void *)(a3 + 56));
  }
  else
  {
    long long v80 = *(_OWORD *)(a3 + 48);
    uint64_t v81 = *(void *)(a3 + 64);
  }
  __int16 v82 = *(_WORD *)(a3 + 72);
  long long v68 = 0;
  uint64_t v69 = 0;
  __int16 v67 = 0;
  sub_10005C928(&v67, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(&v70, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v70 = *v6;
    uint64_t v71 = *(void *)(a2 + 40);
  }
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long __p = *v7;
    uint64_t v73 = *(void *)(a2 + 64);
  }
  __int16 v74 = *(_WORD *)(a2 + 72);
  char v12 = sub_100046FE8(&v78, (void **)&v70);
  if (SHIBYTE(v73) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v71) < 0) {
    operator delete((void *)v70);
  }
  if (v67)
  {
    long long v68 = v67;
    operator delete(v67);
  }
  if (SHIBYTE(v81) < 0) {
    operator delete((void *)v80);
  }
  if (SHIBYTE(v79) < 0) {
    operator delete((void *)v78);
  }
  if (v75)
  {
    long long v76 = v75;
    operator delete(v75);
  }
  if (v12 < 0)
  {
    sub_1007A0A70(a2, a3);
    __int16 v59 = 0;
    char v60 = 0;
    uint64_t v61 = 0;
    sub_10005C928(&v59, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    if (*(char *)(a2 + 47) < 0)
    {
      sub_10004FC84(&v62, *(void **)(a2 + 24), *(void *)(a2 + 32));
    }
    else
    {
      long long v62 = *v6;
      uint64_t v63 = *(void *)(a2 + 40);
    }
    if (*(char *)(a2 + 71) < 0)
    {
      sub_10004FC84(&v64, *(void **)(a2 + 48), *(void *)(a2 + 56));
    }
    else
    {
      long long v64 = *v7;
      uint64_t v65 = *(void *)(a2 + 64);
    }
    __int16 v66 = *(_WORD *)(a2 + 72);
    int v52 = 0;
    uint64_t v53 = 0;
    __int16 v51 = 0;
    sub_10005C928(&v51, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(&v54, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      long long v54 = *v8;
      uint64_t v55 = *(void *)(a1 + 40);
    }
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(&v56, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      long long v56 = *v9;
      uint64_t v57 = *(void *)(a1 + 64);
    }
    __int16 v58 = *(_WORD *)(a1 + 72);
    char v16 = sub_100046FE8(&v62, (void **)&v54);
    if (SHIBYTE(v57) < 0) {
      operator delete((void *)v56);
    }
    if (SHIBYTE(v55) < 0) {
      operator delete((void *)v54);
    }
    if (v51)
    {
      int v52 = v51;
      operator delete(v51);
    }
    if (SHIBYTE(v65) < 0) {
      operator delete((void *)v64);
    }
    if (SHIBYTE(v63) < 0) {
      operator delete((void *)v62);
    }
    if (v59)
    {
      char v60 = v59;
      operator delete(v59);
    }
    if (v16 < 0)
    {
      uint64_t v15 = a1;
      uint64_t v17 = a2;
LABEL_129:
      sub_1007A0A70(v15, v17);
    }
  }
}

void sub_10079F144(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *__p, uint64_t a7, int a8, __int16 a9, char a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  if (a11 < 0) {
    operator delete(__p);
  }
  if (a3) {
    operator delete(a3);
  }
  sub_10079AB58((uint64_t)va);
  _Unwind_Resume(a1);
}

const void **sub_10079F358(uint64_t a1, unint64_t a2)
{
  char v4 = *(const void **)a1;
  *(_OWORD *)&v128[8] = *(_OWORD *)(a1 + 8);
  uint64_t v5 = *(void *)&v128[8];
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  long long v129 = *(_OWORD *)(a1 + 24);
  int v6 = *(const void **)(a1 + 40);
  *(void *)v128 = v4;
  long long v130 = v6;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  long long v131 = *(_OWORD *)(a1 + 48);
  long long v132 = *(const void **)(a1 + 64);
  uint64_t v133 = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  LOWORD(v133) = *(_WORD *)(a1 + 72);
  long long v120 = 0;
  uint64_t v121 = 0;
  uint64_t v122 = 0;
  sub_10005C928(&v120, v4, v5, v5 - (void)v4);
  if (SHIBYTE(v130) < 0)
  {
    sub_10004FC84(&v123, (void *)v129, *((unint64_t *)&v129 + 1));
  }
  else
  {
    long long v123 = v129;
    char v124 = v130;
  }
  if (SHIBYTE(v132) < 0)
  {
    sub_10004FC84(&v125, (void *)v131, *((unint64_t *)&v131 + 1));
  }
  else
  {
    long long v125 = v131;
    long long v126 = v132;
  }
  __int16 v127 = v133;
  uint64_t v114 = 0;
  v112 = 0;
  long long v113 = 0;
  sub_10005C928(&v112, *(const void **)(a2 - 80), *(void *)(a2 - 72), *(void *)(a2 - 72) - *(void *)(a2 - 80));
  if (*(char *)(a2 - 33) < 0)
  {
    sub_10004FC84(&v115, *(void **)(a2 - 56), *(void *)(a2 - 48));
  }
  else
  {
    long long v115 = *(_OWORD *)(a2 - 56);
    uint64_t v116 = *(void *)(a2 - 40);
  }
  if (*(char *)(a2 - 9) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a2 - 32), *(void *)(a2 - 24));
  }
  else
  {
    long long __p = *(_OWORD *)(a2 - 32);
    uint64_t v118 = *(void *)(a2 - 16);
  }
  __int16 v119 = *(_WORD *)(a2 - 8);
  char v7 = sub_100046FE8(&v123, (void **)&v115);
  if (SHIBYTE(v118) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v116) < 0) {
    operator delete((void *)v115);
  }
  if (v112)
  {
    long long v113 = v112;
    operator delete(v112);
  }
  if (SHIBYTE(v126) < 0) {
    operator delete((void *)v125);
  }
  if (SHIBYTE(v124) < 0) {
    operator delete((void *)v123);
  }
  if (v120)
  {
    uint64_t v121 = v120;
    operator delete(v120);
  }
  if (v7 < 0)
  {
    char v10 = (const void **)(a1 + 152);
    do
    {
      long long v105 = 0;
      v104 = 0;
      uint64_t v106 = 0;
      sub_10005C928(&v104, *(const void **)v128, *(uint64_t *)&v128[8], *(void *)&v128[8] - *(void *)v128);
      if (SHIBYTE(v130) < 0)
      {
        sub_10004FC84(&v107, (void *)v129, *((unint64_t *)&v129 + 1));
      }
      else
      {
        long long v107 = v129;
        long long v108 = v130;
      }
      if (SHIBYTE(v132) < 0)
      {
        sub_10004FC84(&v109, (void *)v131, *((unint64_t *)&v131 + 1));
      }
      else
      {
        long long v109 = v131;
        char v110 = v132;
      }
      __int16 v111 = v133;
      uint64_t v98 = 0;
      long long v96 = 0;
      uint64_t v97 = 0;
      sub_10005C928(&v96, *(v10 - 9), (uint64_t)*(v10 - 8), (unsigned char *)*(v10 - 8) - (unsigned char *)*(v10 - 9));
      if (*((char *)v10 - 25) < 0)
      {
        sub_10004FC84(&v99, (void *)*(v10 - 6), (unint64_t)*(v10 - 5));
      }
      else
      {
        long long v99 = *((_OWORD *)v10 - 3);
        uint64_t v100 = (uint64_t)*(v10 - 4);
      }
      if (*((char *)v10 - 1) < 0)
      {
        sub_10004FC84(&v101, (void *)*(v10 - 3), (unint64_t)*(v10 - 2));
      }
      else
      {
        long long v101 = *(_OWORD *)(v10 - 3);
        uint64_t v102 = (uint64_t)*(v10 - 1);
      }
      __int16 v103 = *(_WORD *)v10;
      char v11 = sub_100046FE8(&v107, (void **)&v99);
      if (SHIBYTE(v102) < 0) {
        operator delete((void *)v101);
      }
      if (SHIBYTE(v100) < 0) {
        operator delete((void *)v99);
      }
      if (v96)
      {
        uint64_t v97 = v96;
        operator delete(v96);
      }
      if (SHIBYTE(v110) < 0) {
        operator delete((void *)v109);
      }
      if (SHIBYTE(v108) < 0) {
        operator delete((void *)v107);
      }
      if (v104)
      {
        long long v105 = v104;
        operator delete(v104);
      }
      v10 += 10;
    }
    while ((v11 & 0x80000000) == 0);
    uint64_t v8 = v10 - 19;
  }
  else
  {
    uint64_t v8 = (const void **)(a1 + 80);
    if (a1 + 80 < a2)
    {
      do
      {
        uint64_t v89 = 0;
        long long v88 = 0;
        uint64_t v90 = 0;
        sub_10005C928(&v88, *(const void **)v128, *(uint64_t *)&v128[8], *(void *)&v128[8] - *(void *)v128);
        if (SHIBYTE(v130) < 0)
        {
          sub_10004FC84(&v91, (void *)v129, *((unint64_t *)&v129 + 1));
        }
        else
        {
          long long v91 = v129;
          char v92 = v130;
        }
        if (SHIBYTE(v132) < 0)
        {
          sub_10004FC84(&v93, (void *)v131, *((unint64_t *)&v131 + 1));
        }
        else
        {
          long long v93 = v131;
          long long v94 = v132;
        }
        __int16 v95 = v133;
        uint64_t v82 = 0;
        long long v80 = 0;
        uint64_t v81 = 0;
        sub_10005C928(&v80, *v8, (uint64_t)v8[1], (unsigned char *)v8[1] - (unsigned char *)*v8);
        if (*((char *)v8 + 47) < 0)
        {
          sub_10004FC84(&v83, (void *)v8[3], (unint64_t)v8[4]);
        }
        else
        {
          long long v83 = *(_OWORD *)(v8 + 3);
          long long v84 = v8[5];
        }
        if (*((char *)v8 + 71) < 0)
        {
          sub_10004FC84(&v85, (void *)v8[6], (unint64_t)v8[7]);
        }
        else
        {
          long long v85 = *((_OWORD *)v8 + 3);
          long long v86 = v8[8];
        }
        __int16 v87 = *((_WORD *)v8 + 36);
        char v9 = sub_100046FE8(&v91, (void **)&v83);
        if (SHIBYTE(v86) < 0) {
          operator delete((void *)v85);
        }
        if (SHIBYTE(v84) < 0) {
          operator delete((void *)v83);
        }
        if (v80)
        {
          uint64_t v81 = v80;
          operator delete(v80);
        }
        if (SHIBYTE(v94) < 0) {
          operator delete((void *)v93);
        }
        if (SHIBYTE(v92) < 0) {
          operator delete((void *)v91);
        }
        if (v88)
        {
          uint64_t v89 = v88;
          operator delete(v88);
        }
        if (v9 < 0) {
          break;
        }
        v8 += 10;
      }
      while ((unint64_t)v8 < a2);
    }
  }
  if ((unint64_t)v8 < a2)
  {
    do
    {
      uint64_t v72 = 0;
      uint64_t v73 = 0;
      uint64_t v74 = 0;
      sub_10005C928(&v72, *(const void **)v128, *(uint64_t *)&v128[8], *(void *)&v128[8] - *(void *)v128);
      if (SHIBYTE(v130) < 0)
      {
        sub_10004FC84(&v75, (void *)v129, *((unint64_t *)&v129 + 1));
      }
      else
      {
        long long v75 = v129;
        long long v76 = v130;
      }
      if (SHIBYTE(v132) < 0)
      {
        sub_10004FC84(&v77, (void *)v131, *((unint64_t *)&v131 + 1));
      }
      else
      {
        long long v77 = v131;
        long long v78 = v132;
      }
      __int16 v79 = v133;
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      long long v64 = 0;
      sub_10005C928(&v64, *(const void **)(a2 - 80), *(void *)(a2 - 72), *(void *)(a2 - 72) - *(void *)(a2 - 80));
      if (*(char *)(a2 - 33) < 0)
      {
        sub_10004FC84(&v67, *(void **)(a2 - 56), *(void *)(a2 - 48));
      }
      else
      {
        long long v67 = *(_OWORD *)(a2 - 56);
        uint64_t v68 = *(void *)(a2 - 40);
      }
      if (*(char *)(a2 - 9) < 0)
      {
        sub_10004FC84(&v69, *(void **)(a2 - 32), *(void *)(a2 - 24));
      }
      else
      {
        long long v69 = *(_OWORD *)(a2 - 32);
        uint64_t v70 = *(void *)(a2 - 16);
      }
      __int16 v71 = *(_WORD *)(a2 - 8);
      char v12 = sub_100046FE8(&v75, (void **)&v67);
      if (SHIBYTE(v70) < 0) {
        operator delete((void *)v69);
      }
      if (SHIBYTE(v68) < 0) {
        operator delete((void *)v67);
      }
      if (v64)
      {
        uint64_t v65 = v64;
        operator delete(v64);
      }
      if (SHIBYTE(v78) < 0) {
        operator delete((void *)v77);
      }
      if (SHIBYTE(v76) < 0) {
        operator delete((void *)v75);
      }
      if (v72)
      {
        uint64_t v73 = v72;
        operator delete(v72);
      }
      a2 -= 80;
    }
    while (v12 < 0);
  }
  if ((unint64_t)v8 < a2)
  {
    uint64_t v13 = (uint64_t)v8;
    do
    {
      sub_1007A0A70(v13, a2);
      char v14 = (const void **)(v13 + 152);
      do
      {
        long long v56 = 0;
        uint64_t v57 = 0;
        uint64_t v58 = 0;
        sub_10005C928(&v56, *(const void **)v128, *(uint64_t *)&v128[8], *(void *)&v128[8] - *(void *)v128);
        if (SHIBYTE(v130) < 0)
        {
          sub_10004FC84(&v59, (void *)v129, *((unint64_t *)&v129 + 1));
        }
        else
        {
          long long v59 = v129;
          char v60 = v130;
        }
        if (SHIBYTE(v132) < 0)
        {
          sub_10004FC84(&v61, (void *)v131, *((unint64_t *)&v131 + 1));
        }
        else
        {
          long long v61 = v131;
          long long v62 = v132;
        }
        __int16 v63 = v133;
        uint64_t v49 = 0;
        uint64_t v50 = 0;
        long long v48 = 0;
        sub_10005C928(&v48, *(v14 - 9), (uint64_t)*(v14 - 8), (unsigned char *)*(v14 - 8) - (unsigned char *)*(v14 - 9));
        if (*((char *)v14 - 25) < 0)
        {
          sub_10004FC84(&v51, (void *)*(v14 - 6), (unint64_t)*(v14 - 5));
        }
        else
        {
          long long v15 = *((_OWORD *)v14 - 3);
          uint64_t v52 = (uint64_t)*(v14 - 4);
          long long v51 = v15;
        }
        if (*((char *)v14 - 1) < 0)
        {
          sub_10004FC84(&v53, (void *)*(v14 - 3), (unint64_t)*(v14 - 2));
        }
        else
        {
          long long v16 = *(_OWORD *)(v14 - 3);
          uint64_t v54 = (uint64_t)*(v14 - 1);
          long long v53 = v16;
        }
        __int16 v55 = *(_WORD *)v14;
        char v17 = sub_100046FE8(&v59, (void **)&v51);
        if (SHIBYTE(v54) < 0) {
          operator delete((void *)v53);
        }
        if (SHIBYTE(v52) < 0) {
          operator delete((void *)v51);
        }
        if (v48)
        {
          uint64_t v49 = v48;
          operator delete(v48);
        }
        if (SHIBYTE(v62) < 0) {
          operator delete((void *)v61);
        }
        if (SHIBYTE(v60) < 0) {
          operator delete((void *)v59);
        }
        if (v56)
        {
          uint64_t v57 = v56;
          operator delete(v56);
        }
        v14 += 10;
      }
      while ((v17 & 0x80000000) == 0);
      do
      {
        long long v40 = 0;
        uint64_t v41 = 0;
        uint64_t v42 = 0;
        sub_10005C928(&v40, *(const void **)v128, *(uint64_t *)&v128[8], *(void *)&v128[8] - *(void *)v128);
        if (SHIBYTE(v130) < 0)
        {
          sub_10004FC84(&v43, (void *)v129, *((unint64_t *)&v129 + 1));
        }
        else
        {
          long long v43 = v129;
          int v44 = v130;
        }
        if (SHIBYTE(v132) < 0)
        {
          sub_10004FC84(&v45, (void *)v131, *((unint64_t *)&v131 + 1));
        }
        else
        {
          long long v45 = v131;
          long long v46 = v132;
        }
        __int16 v47 = v133;
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        long long v32 = 0;
        sub_10005C928(&v32, *(const void **)(a2 - 80), *(void *)(a2 - 72), *(void *)(a2 - 72) - *(void *)(a2 - 80));
        if (*(char *)(a2 - 33) < 0)
        {
          sub_10004FC84(&v35, *(void **)(a2 - 56), *(void *)(a2 - 48));
        }
        else
        {
          long long v18 = *(_OWORD *)(a2 - 56);
          uint64_t v36 = *(void *)(a2 - 40);
          long long v35 = v18;
        }
        if (*(char *)(a2 - 9) < 0)
        {
          sub_10004FC84(&v37, *(void **)(a2 - 32), *(void *)(a2 - 24));
        }
        else
        {
          long long v19 = *(_OWORD *)(a2 - 32);
          uint64_t v38 = *(void *)(a2 - 16);
          long long v37 = v19;
        }
        __int16 v39 = *(_WORD *)(a2 - 8);
        char v20 = sub_100046FE8(&v43, (void **)&v35);
        if (SHIBYTE(v38) < 0) {
          operator delete((void *)v37);
        }
        if (SHIBYTE(v36) < 0) {
          operator delete((void *)v35);
        }
        if (v32)
        {
          uint64_t v33 = v32;
          operator delete(v32);
        }
        if (SHIBYTE(v46) < 0) {
          operator delete((void *)v45);
        }
        if (SHIBYTE(v44) < 0) {
          operator delete((void *)v43);
        }
        if (v40)
        {
          uint64_t v41 = v40;
          operator delete(v40);
        }
        a2 -= 80;
      }
      while (v20 < 0);
      uint64_t v13 = (uint64_t)(v14 - 19);
    }
    while ((unint64_t)(v14 - 19) < a2);
    uint64_t v8 = v14 - 19;
  }
  uint64_t v21 = (void **)(v8 - 10);
  if (v8 - 10 != (const void **)a1)
  {
    long long v22 = (void **)(a1 + 24);
    sub_10005C9A4(a1, (__n128 *)v8 - 5);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v22);
    }
    uint64_t v23 = (void **)(a1 + 48);
    long long v24 = *(_OWORD *)(v8 - 7);
    *(void *)(a1 + 40) = *(v8 - 5);
    *(_OWORD *)long long v22 = v24;
    *((unsigned char *)v8 - 33) = 0;
    *((unsigned char *)v8 - 56) = 0;
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*v23);
    }
    long long v25 = *((_OWORD *)v8 - 2);
    *(void *)(a1 + 64) = *(v8 - 2);
    *(_OWORD *)uint64_t v23 = v25;
    *((unsigned char *)v8 - 9) = 0;
    *((unsigned char *)v8 - 32) = 0;
    *(_WORD *)(a1 + 72) = *((_WORD *)v8 - 4);
  }
  __int16 v26 = *v21;
  if (*v21)
  {
    *(v8 - 9) = v26;
    operator delete(v26);
    void *v21 = 0;
    *(v8 - 9) = 0;
    *(v8 - 8) = 0;
  }
  *((_OWORD *)v8 - 5) = *(_OWORD *)v128;
  *(v8 - 8) = *(const void **)&v128[16];
  memset(v128, 0, sizeof(v128));
  __int16 v27 = (void **)(v8 - 7);
  if (*((char *)v8 - 33) < 0) {
    operator delete(*v27);
  }
  long long v28 = v129;
  *(v8 - 5) = v130;
  *(_OWORD *)__int16 v27 = v28;
  HIBYTE(v130) = 0;
  LOBYTE(v129) = 0;
  uint64_t v29 = (void **)(v8 - 4);
  if (*((char *)v8 - 9) < 0) {
    operator delete(*v29);
  }
  long long v30 = v131;
  *(v8 - 2) = v132;
  *(_OWORD *)uint64_t v29 = v30;
  HIBYTE(v132) = 0;
  LOBYTE(v131) = 0;
  *((_WORD *)v8 - 4) = v133;
  if (SHIBYTE(v132) < 0) {
    operator delete((void *)v131);
  }
  if (SHIBYTE(v130) < 0) {
    operator delete((void *)v129);
  }
  if (*(void *)v128)
  {
    *(void *)&v128[8] = *(void *)v128;
    operator delete(*(void **)v128);
  }
  return v8;
}

void sub_10079FEC8(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x37F]) < 0) {
    operator delete((void *)STACK[0x368]);
  }
  int v3 = (void *)STACK[0x350];
  if (STACK[0x350])
  {
    STACK[0x358] = (unint64_t)v3;
    operator delete(v3);
  }
  sub_10079AB58(v1 - 256);
  sub_10079AB58(v1 - 176);
  _Unwind_Resume(a1);
}

BOOL sub_1007A0168(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      int v6 = *(const void **)(a2 - 80);
      uint64_t v7 = *(void *)(a2 - 72);
      long long v78 = 0;
      __int16 v79 = 0;
      uint64_t v80 = 0;
      sub_10005C928(&v78, v6, v7, v7 - (void)v6);
      if (*(char *)(a2 - 33) < 0)
      {
        sub_10004FC84(&v81, *(void **)(a2 - 56), *(void *)(a2 - 48));
      }
      else
      {
        long long v81 = *(_OWORD *)(a2 - 56);
        uint64_t v82 = *(void *)(a2 - 40);
      }
      if (*(char *)(a2 - 9) < 0)
      {
        sub_10004FC84(&v83, *(void **)(a2 - 32), *(void *)(a2 - 24));
      }
      else
      {
        long long v83 = *(_OWORD *)(a2 - 32);
        uint64_t v84 = *(void *)(a2 - 16);
      }
      __int16 v85 = *(_WORD *)(a2 - 8);
      __int16 v71 = 0;
      uint64_t v72 = 0;
      uint64_t v70 = 0;
      sub_10005C928(&v70, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
      if (*(char *)(a1 + 47) < 0)
      {
        sub_10004FC84(&v73, *(void **)(a1 + 24), *(void *)(a1 + 32));
      }
      else
      {
        long long v73 = *(_OWORD *)(a1 + 24);
        uint64_t v74 = *(void *)(a1 + 40);
      }
      if (*(char *)(a1 + 71) < 0)
      {
        sub_10004FC84(&v75, *(void **)(a1 + 48), *(void *)(a1 + 56));
      }
      else
      {
        long long v75 = *(_OWORD *)(a1 + 48);
        uint64_t v76 = *(void *)(a1 + 64);
      }
      __int16 v77 = *(_WORD *)(a1 + 72);
      char v28 = sub_100046FE8(&v81, (void **)&v73);
      if (SHIBYTE(v76) < 0) {
        operator delete((void *)v75);
      }
      if (SHIBYTE(v74) < 0) {
        operator delete((void *)v73);
      }
      if (v70)
      {
        __int16 v71 = v70;
        operator delete(v70);
      }
      if (SHIBYTE(v84) < 0) {
        operator delete((void *)v83);
      }
      if (SHIBYTE(v82) < 0) {
        operator delete((void *)v81);
      }
      if (v78)
      {
        __int16 v79 = v78;
        operator delete(v78);
      }
      if (v28 < 0) {
        sub_1007A0A70(a1, a2 - 80);
      }
      return 1;
    case 3uLL:
      sub_10079E970(a1, a1 + 80, a2 - 80);
      return 1;
    case 4uLL:
      sub_1007A0C14(a1, a1 + 80, a1 + 160, a2 - 80);
      return 1;
    case 5uLL:
      sub_10079E114(a1, a1 + 80, a1 + 160, a1 + 240, a2 - 80);
      return 1;
    default:
      uint64_t v8 = a1 + 160;
      sub_10079E970(a1, a1 + 80, a1 + 160);
      uint64_t v9 = a1 + 240;
      if (a1 + 240 == a2) {
        return 1;
      }
      int v29 = 0;
      uint64_t v30 = 0;
      break;
  }
  while (1)
  {
    long long v62 = 0;
    __int16 v63 = 0;
    uint64_t v64 = 0;
    sub_10005C928(&v62, *(const void **)v9, *(void *)(v9 + 8), *(void *)(v9 + 8) - *(void *)v9);
    char v10 = (long long *)(v9 + 24);
    if (*(char *)(v9 + 47) < 0)
    {
      sub_10004FC84(&v65, *(void **)(v9 + 24), *(void *)(v9 + 32));
    }
    else
    {
      long long v65 = *v10;
      uint64_t v66 = *(void *)(v9 + 40);
    }
    char v11 = (long long *)(v9 + 48);
    if (*(char *)(v9 + 71) < 0)
    {
      sub_10004FC84(&v67, *(void **)(v9 + 48), *(void *)(v9 + 56));
    }
    else
    {
      long long v67 = *v11;
      uint64_t v68 = *(void *)(v9 + 64);
    }
    __int16 v69 = *(_WORD *)(v9 + 72);
    __int16 v55 = 0;
    uint64_t v56 = 0;
    uint64_t v54 = 0;
    sub_10005C928(&v54, *(const void **)v8, *(void *)(v8 + 8), *(void *)(v8 + 8) - *(void *)v8);
    if (*(char *)(v8 + 47) < 0)
    {
      sub_10004FC84(&v57, *(void **)(v8 + 24), *(void *)(v8 + 32));
    }
    else
    {
      long long v12 = *(_OWORD *)(v8 + 24);
      uint64_t v58 = *(void *)(v8 + 40);
      long long v57 = v12;
    }
    if (*(char *)(v8 + 71) < 0)
    {
      sub_10004FC84(&__p, *(void **)(v8 + 48), *(void *)(v8 + 56));
    }
    else
    {
      long long v13 = *(_OWORD *)(v8 + 48);
      uint64_t v60 = *(void *)(v8 + 64);
      long long __p = v13;
    }
    __int16 v61 = *(_WORD *)(v8 + 72);
    char v14 = sub_100046FE8(&v65, (void **)&v57);
    if (SHIBYTE(v60) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v58) < 0) {
      operator delete((void *)v57);
    }
    if (v54)
    {
      __int16 v55 = v54;
      operator delete(v54);
    }
    if (SHIBYTE(v68) < 0) {
      operator delete((void *)v67);
    }
    if (SHIBYTE(v66) < 0) {
      operator delete((void *)v65);
    }
    if (v62)
    {
      __int16 v63 = v62;
      operator delete(v62);
    }
    if (v14 < 0)
    {
      long long v47 = *(_OWORD *)v9;
      uint64_t v15 = *(void *)(v9 + 16);
      uint64_t v53 = 0;
      uint64_t v48 = v15;
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      *(void *)(v9 + 16) = 0;
      long long v49 = *v10;
      uint64_t v50 = *(void *)(v9 + 40);
      *(void *)char v10 = 0;
      *(void *)(v9 + 32) = 0;
      *(void *)(v9 + 40) = 0;
      long long v51 = *v11;
      uint64_t v52 = *(void *)(v9 + 64);
      *(void *)(v9 + 56) = 0;
      *(void *)(v9 + 64) = 0;
      *(void *)char v11 = 0;
      uint64_t v16 = v30;
      LOWORD(v53) = *(_WORD *)(v9 + 72);
      while (1)
      {
        uint64_t v17 = a1 + v16;
        sub_10005C9A4(a1 + v16 + 240, (__n128 *)(a1 + v16 + 160));
        long long v18 = (void **)(a1 + v16 + 264);
        if (*(char *)(a1 + v16 + 287) < 0) {
          operator delete(*v18);
        }
        *(_OWORD *)long long v18 = *(_OWORD *)(v17 + 184);
        *(void *)(v17 + 280) = *(void *)(v17 + 200);
        *(unsigned char *)(v17 + 207) = 0;
        *(unsigned char *)(v17 + 184) = 0;
        uint64_t v19 = v17 + 288;
        if (*(char *)(v17 + 311) < 0) {
          operator delete(*(void **)v19);
        }
        uint64_t v20 = a1 + v16;
        *(_OWORD *)uint64_t v19 = *(_OWORD *)(a1 + v16 + 208);
        *(void *)(v19 + 16) = *(void *)(a1 + v16 + 224);
        *(unsigned char *)(v20 + 231) = 0;
        *(unsigned char *)(v20 + 208) = 0;
        *(_WORD *)(v20 + 312) = *(_WORD *)(a1 + v16 + 232);
        if (v16 == -160)
        {
          uint64_t v24 = a1;
          goto LABEL_65;
        }
        __int16 v39 = 0;
        long long v40 = 0;
        uint64_t v41 = 0;
        sub_10005C928(&v39, (const void *)v47, *((uint64_t *)&v47 + 1), *((void *)&v47 + 1) - v47);
        if (SHIBYTE(v50) < 0)
        {
          sub_10004FC84(&v42, (void *)v49, *((unint64_t *)&v49 + 1));
        }
        else
        {
          long long v42 = v49;
          uint64_t v43 = v50;
        }
        if (SHIBYTE(v52) < 0)
        {
          sub_10004FC84(&v44, (void *)v51, *((unint64_t *)&v51 + 1));
        }
        else
        {
          long long v44 = v51;
          uint64_t v45 = v52;
        }
        __int16 v46 = v53;
        long long v32 = 0;
        uint64_t v33 = 0;
        uint64_t v31 = 0;
        sub_10005C928(&v31, *(const void **)(a1 + v16 + 80), *(void *)(a1 + v16 + 88), *(void *)(a1 + v16 + 88) - *(void *)(a1 + v16 + 80));
        uint64_t v21 = (void **)(a1 + v16 + 104);
        if (*(char *)(a1 + v16 + 127) < 0)
        {
          sub_10004FC84(&v34, *v21, *(void *)(a1 + v16 + 112));
        }
        else
        {
          long long v34 = *(_OWORD *)v21;
          uint64_t v35 = *(void *)(a1 + v16 + 120);
        }
        long long v22 = (void **)(a1 + v16 + 128);
        if (*(char *)(a1 + v16 + 151) < 0)
        {
          sub_10004FC84(&v36, *v22, *(void *)(a1 + v16 + 136));
        }
        else
        {
          long long v36 = *(_OWORD *)v22;
          uint64_t v37 = *(void *)(a1 + v16 + 144);
        }
        __int16 v38 = *(_WORD *)(a1 + v16 + 152);
        char v23 = sub_100046FE8(&v42, (void **)&v34);
        if (SHIBYTE(v37) < 0) {
          operator delete((void *)v36);
        }
        if (SHIBYTE(v35) < 0) {
          operator delete((void *)v34);
        }
        if (v31)
        {
          long long v32 = v31;
          operator delete(v31);
        }
        if (SHIBYTE(v45) < 0) {
          operator delete((void *)v44);
        }
        if (SHIBYTE(v43) < 0) {
          operator delete((void *)v42);
        }
        if (v39)
        {
          long long v40 = v39;
          operator delete(v39);
        }
        if ((v23 & 0x80000000) == 0) {
          break;
        }
        v16 -= 80;
      }
      uint64_t v24 = a1 + v16 + 160;
LABEL_65:
      long long v25 = *(void **)v24;
      if (*(void *)v24)
      {
        *(void *)(v24 + 8) = v25;
        operator delete(v25);
        *(void *)uint64_t v24 = 0;
        *(void *)(v24 + 8) = 0;
        *(void *)(v24 + 16) = 0;
      }
      uint64_t v26 = v20 + 184;
      *(_OWORD *)uint64_t v24 = v47;
      *(void *)(v24 + 16) = v48;
      uint64_t v48 = 0;
      long long v47 = 0uLL;
      if (*(char *)(v24 + 47) < 0) {
        operator delete(*(void **)v26);
      }
      uint64_t v27 = v20 + 208;
      *(void *)(v26 + 16) = v50;
      *(_OWORD *)uint64_t v26 = v49;
      HIBYTE(v50) = 0;
      LOBYTE(v49) = 0;
      if (*(char *)(v24 + 71) < 0) {
        operator delete(*(void **)v27);
      }
      *(_OWORD *)uint64_t v27 = v51;
      *(void *)(v27 + 16) = v52;
      *(_WORD *)(v24 + 72) = v53;
      if (++v29 == 8) {
        return v9 + 80 == a2;
      }
    }
    uint64_t v8 = v9;
    v30 += 80;
    v9 += 80;
    if (v9 == a2) {
      return 1;
    }
  }
}

void sub_1007A0900(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 201) < 0) {
    operator delete(*(void **)(v1 - 224));
  }
  int v3 = *(void **)(v1 - 248);
  if (v3)
  {
    *(void *)(v1 - 240) = v3;
    operator delete(v3);
  }
  sub_10079AB58(v1 - 168);
  _Unwind_Resume(a1);
}

void sub_1007A0A70(uint64_t a1, uint64_t a2)
{
  long long v15 = *(_OWORD *)a1;
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  uint64_t v5 = a1 + 24;
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)long long v18 = *(void *)(a1 + 32);
  *(void *)&v18[7] = *(void *)(a1 + 39);
  char v7 = *(unsigned char *)(a1 + 47);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v8 = a1 + 48;
  *(void *)&v17[7] = *(void *)(a1 + 63);
  uint64_t v16 = *(void *)(a1 + 48);
  *(void *)uint64_t v17 = *(void *)(a1 + 56);
  char v9 = *(unsigned char *)(a1 + 71);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  __int16 v10 = *(_WORD *)(a1 + 72);
  sub_10005C9A4(a1, (__n128 *)a2);
  char v11 = (void **)(a2 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)v5);
  }
  long long v12 = *(_OWORD *)v11;
  *(void *)(v5 + 16) = *(void *)(a2 + 40);
  *(_OWORD *)uint64_t v5 = v12;
  *(unsigned char *)(a2 + 47) = 0;
  *(unsigned char *)(a2 + 24) = 0;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)v8);
  }
  long long v13 = *(_OWORD *)(a2 + 48);
  *(void *)(v8 + 16) = *(void *)(a2 + 64);
  *(_OWORD *)uint64_t v8 = v13;
  *(unsigned char *)(a2 + 71) = 0;
  *(unsigned char *)(a2 + 48) = 0;
  *(_WORD *)(a1 + 72) = *(_WORD *)(a2 + 72);
  char v14 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v14;
    operator delete(v14);
  }
  *(_OWORD *)a2 = v15;
  *(void *)(a2 + 16) = v4;
  if (*(char *)(a2 + 47) < 0) {
    operator delete(*v11);
  }
  *(void *)(a2 + 24) = v6;
  *(void *)(a2 + 32) = *(void *)v18;
  *(void *)(a2 + 39) = *(void *)&v18[7];
  *(unsigned char *)(a2 + 47) = v7;
  if (*(char *)(a2 + 71) < 0) {
    operator delete(*(void **)(a2 + 48));
  }
  *(void *)(a2 + 48) = v16;
  *(void *)(a2 + 56) = *(void *)v17;
  *(void *)(a2 + 63) = *(void *)&v17[7];
  *(unsigned char *)(a2 + 71) = v9;
  *(_WORD *)(a2 + 72) = v10;
}

void sub_1007A0C14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_10079E970(a1, a2, a3);
  __int16 v55 = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  sub_10005C928(&v55, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
  if (*(char *)(a4 + 47) < 0)
  {
    sub_10004FC84(&v58, *(void **)(a4 + 24), *(void *)(a4 + 32));
  }
  else
  {
    long long v58 = *(_OWORD *)(a4 + 24);
    uint64_t v59 = *(void *)(a4 + 40);
  }
  if (*(char *)(a4 + 71) < 0)
  {
    sub_10004FC84(&v60, *(void **)(a4 + 48), *(void *)(a4 + 56));
  }
  else
  {
    long long v60 = *(_OWORD *)(a4 + 48);
    uint64_t v61 = *(void *)(a4 + 64);
  }
  __int16 v62 = *(_WORD *)(a4 + 72);
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  long long v47 = 0;
  sub_10005C928(&v47, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  uint64_t v8 = (long long *)(a3 + 24);
  if (*(char *)(a3 + 47) < 0)
  {
    sub_10004FC84(&v50, *(void **)(a3 + 24), *(void *)(a3 + 32));
  }
  else
  {
    long long v50 = *v8;
    uint64_t v51 = *(void *)(a3 + 40);
  }
  char v9 = (long long *)(a3 + 48);
  if (*(char *)(a3 + 71) < 0)
  {
    sub_10004FC84(&v52, *(void **)(a3 + 48), *(void *)(a3 + 56));
  }
  else
  {
    long long v52 = *v9;
    uint64_t v53 = *(void *)(a3 + 64);
  }
  __int16 v54 = *(_WORD *)(a3 + 72);
  char v10 = sub_100046FE8(&v58, (void **)&v50);
  if (SHIBYTE(v53) < 0) {
    operator delete((void *)v52);
  }
  if (SHIBYTE(v51) < 0) {
    operator delete((void *)v50);
  }
  if (v47)
  {
    uint64_t v48 = v47;
    operator delete(v47);
  }
  if (SHIBYTE(v61) < 0) {
    operator delete((void *)v60);
  }
  if (SHIBYTE(v59) < 0) {
    operator delete((void *)v58);
  }
  if (v55)
  {
    uint64_t v56 = v55;
    operator delete(v55);
  }
  if (v10 < 0)
  {
    sub_1007A0A70(a3, a4);
    __int16 v39 = 0;
    long long v40 = 0;
    uint64_t v41 = 0;
    sub_10005C928(&v39, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    if (*(char *)(a3 + 47) < 0)
    {
      sub_10004FC84(&v42, *(void **)(a3 + 24), *(void *)(a3 + 32));
    }
    else
    {
      long long v42 = *v8;
      uint64_t v43 = *(void *)(a3 + 40);
    }
    if (*(char *)(a3 + 71) < 0)
    {
      sub_10004FC84(&v44, *(void **)(a3 + 48), *(void *)(a3 + 56));
    }
    else
    {
      long long v44 = *v9;
      uint64_t v45 = *(void *)(a3 + 64);
    }
    __int16 v46 = *(_WORD *)(a3 + 72);
    long long v32 = 0;
    uint64_t v33 = 0;
    uint64_t v31 = 0;
    sub_10005C928(&v31, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    char v11 = (long long *)(a2 + 24);
    if (*(char *)(a2 + 47) < 0)
    {
      sub_10004FC84(&v34, *(void **)(a2 + 24), *(void *)(a2 + 32));
    }
    else
    {
      long long v34 = *v11;
      uint64_t v35 = *(void *)(a2 + 40);
    }
    long long v12 = (long long *)(a2 + 48);
    if (*(char *)(a2 + 71) < 0)
    {
      sub_10004FC84(&__p, *(void **)(a2 + 48), *(void *)(a2 + 56));
    }
    else
    {
      long long __p = *v12;
      uint64_t v37 = *(void *)(a2 + 64);
    }
    __int16 v38 = *(_WORD *)(a2 + 72);
    char v13 = sub_100046FE8(&v42, (void **)&v34);
    if (SHIBYTE(v37) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete((void *)v34);
    }
    if (v31)
    {
      long long v32 = v31;
      operator delete(v31);
    }
    if (SHIBYTE(v45) < 0) {
      operator delete((void *)v44);
    }
    if (SHIBYTE(v43) < 0) {
      operator delete((void *)v42);
    }
    if (v39)
    {
      long long v40 = v39;
      operator delete(v39);
    }
    if (v13 < 0)
    {
      sub_1007A0A70(a2, a3);
      char v23 = 0;
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      sub_10005C928(&v23, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
      if (*(char *)(a2 + 47) < 0)
      {
        sub_10004FC84(&v26, *(void **)(a2 + 24), *(void *)(a2 + 32));
      }
      else
      {
        long long v26 = *v11;
        uint64_t v27 = *(void *)(a2 + 40);
      }
      if (*(char *)(a2 + 71) < 0)
      {
        sub_10004FC84(&v28, *(void **)(a2 + 48), *(void *)(a2 + 56));
      }
      else
      {
        long long v28 = *v12;
        uint64_t v29 = *(void *)(a2 + 64);
      }
      __int16 v30 = *(_WORD *)(a2 + 72);
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      long long v15 = 0;
      sub_10005C928(&v15, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
      if (*(char *)(a1 + 47) < 0)
      {
        sub_10004FC84(&v18, *(void **)(a1 + 24), *(void *)(a1 + 32));
      }
      else
      {
        long long v18 = *(_OWORD *)(a1 + 24);
        uint64_t v19 = *(void *)(a1 + 40);
      }
      if (*(char *)(a1 + 71) < 0)
      {
        sub_10004FC84(&v20, *(void **)(a1 + 48), *(void *)(a1 + 56));
      }
      else
      {
        long long v20 = *(_OWORD *)(a1 + 48);
        uint64_t v21 = *(void *)(a1 + 64);
      }
      __int16 v22 = *(_WORD *)(a1 + 72);
      char v14 = sub_100046FE8(&v26, (void **)&v18);
      if (SHIBYTE(v21) < 0) {
        operator delete((void *)v20);
      }
      if (SHIBYTE(v19) < 0) {
        operator delete((void *)v18);
      }
      if (v15)
      {
        uint64_t v16 = v15;
        operator delete(v15);
      }
      if (SHIBYTE(v29) < 0) {
        operator delete((void *)v28);
      }
      if (SHIBYTE(v27) < 0) {
        operator delete((void *)v26);
      }
      if (v23)
      {
        uint64_t v24 = v23;
        operator delete(v23);
      }
      if (v14 < 0) {
        sub_1007A0A70(a1, a2);
      }
    }
  }
}

void sub_1007A1100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a9) {
    operator delete(a9);
  }
  sub_10079AB58((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_1007A1244(uint64_t a1, void *n128_u64, uint64_t a3, char a4)
{
  while (2)
  {
    uint64_t v367 = (uint64_t)(n128_u64 - 10);
    uint64_t v365 = (uint64_t)(n128_u64 - 30);
    uint64_t v366 = (uint64_t)(n128_u64 - 20);
    unint64_t v8 = a1;
    uint64_t v371 = (uint64_t)n128_u64;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t)n128_u64 - v8;
        unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)((uint64_t)n128_u64 - v8) >> 4);
        a1 = v8;
        if (!(!v5 & v4))
        {
          switch(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)((uint64_t)n128_u64 - v8) >> 4))
          {
            case 0uLL:
            case 1uLL:
              return;
            case 2uLL:
              v429 = 0;
              v428 = 0;
              uint64_t v430 = 0;
              sub_10005C928(&v428, (const void *)*(n128_u64 - 10), *(n128_u64 - 9), *(n128_u64 - 9) - *(n128_u64 - 10));
              if (*((char *)n128_u64 - 33) < 0)
              {
                sub_10004FC84(&v431, (void *)*(n128_u64 - 7), *(n128_u64 - 6));
              }
              else
              {
                long long v117 = *(_OWORD *)(n128_u64 - 7);
                uint64_t v432 = *(n128_u64 - 5);
                long long v431 = v117;
              }
              if (*((char *)n128_u64 - 9) < 0)
              {
                sub_10004FC84(&v433, (void *)*(n128_u64 - 4), *(n128_u64 - 3));
              }
              else
              {
                long long v356 = *((_OWORD *)n128_u64 - 2);
                uint64_t v434 = *(n128_u64 - 2);
                long long v433 = v356;
              }
              __int16 v435 = *((_WORD *)n128_u64 - 4);
              v421 = 0;
              uint64_t v422 = 0;
              v420 = 0;
              sub_10005C928(&v420, *(const void **)v8, *(void *)(v8 + 8), *(void *)(v8 + 8) - *(void *)v8);
              if (*(char *)(v8 + 47) < 0)
              {
                sub_10004FC84(&v423, *(void **)(v8 + 24), *(void *)(v8 + 32));
              }
              else
              {
                long long v357 = *(_OWORD *)(v8 + 24);
                uint64_t v424 = *(void *)(v8 + 40);
                long long v423 = v357;
              }
              if (*(char *)(v8 + 71) < 0)
              {
                sub_10004FC84(&v425, *(void **)(v8 + 48), *(void *)(v8 + 56));
              }
              else
              {
                long long v358 = *(_OWORD *)(v8 + 48);
                uint64_t v426 = *(void *)(v8 + 64);
                long long v425 = v358;
              }
              __int16 v427 = *(_WORD *)(v8 + 72);
              uint64_t v359 = (unsigned __int8 *)v428;
              v360 = (unsigned __int8 *)v420;
              if (v421 - (unsigned char *)v420 >= v429 - (unsigned char *)v428) {
                uint64_t v361 = v429 - (unsigned char *)v428;
              }
              else {
                uint64_t v361 = v421 - (unsigned char *)v420;
              }
              if (v361 < 1) {
                goto LABEL_852;
              }
              break;
            case 3uLL:
              sub_1007A5608(v8, v8 + 80, v367);
              return;
            case 4uLL:
              sub_1007A7A90(v8, v8 + 80, v8 + 160, v367);
              return;
            case 5uLL:
              sub_1007A4CB8(v8, v8 + 80, v8 + 160, v8 + 240, v367);
              return;
            default:
              JUMPOUT(0);
          }
          while (1)
          {
            unsigned int v362 = *v359;
            unsigned int v363 = *v360;
            if (v362 != v363) {
              break;
            }
            ++v359;
            ++v360;
            if (!--v361)
            {
LABEL_852:
              BOOL v364 = v429 - (unsigned char *)v428 < v421 - (unsigned char *)v420;
              goto LABEL_854;
            }
          }
          BOOL v364 = v362 < v363;
LABEL_854:
          if (SHIBYTE(v426) < 0) {
            operator delete((void *)v425);
          }
          if (SHIBYTE(v424) < 0) {
            operator delete((void *)v423);
          }
          if (v420)
          {
            v421 = v420;
            operator delete(v420);
          }
          if (SHIBYTE(v434) < 0) {
            operator delete((void *)v433);
          }
          if (SHIBYTE(v432) < 0) {
            operator delete((void *)v431);
          }
          if (v428)
          {
            v429 = v428;
            operator delete(v428);
          }
          if (v364) {
            sub_1007A0A70(v8, (uint64_t)(n128_u64 - 10));
          }
          return;
        }
        char v11 = (void *)v8;
        if (v9 <= 1919)
        {
          if (a4)
          {
            if ((void *)v8 != n128_u64)
            {
              uint64_t v118 = (char *)(v8 + 80);
              if ((void *)(v8 + 80) != n128_u64)
              {
                do
                {
                  v402 = v118;
                  v499[1] = 0;
                  v499[0] = 0;
                  uint64_t v500 = 0;
                  sub_10005C928(v499, *(const void **)(v8 + 80), *(void *)(v8 + 88), *(void *)(v8 + 88) - *(void *)(v8 + 80));
                  __int16 v119 = (long long *)(v8 + 104);
                  if (*(char *)(v8 + 127) < 0)
                  {
                    sub_10004FC84(&__src, *(void **)(v8 + 104), *(void *)(v8 + 112));
                  }
                  else
                  {
                    long long __src = *v119;
                    uint64_t v502 = *(void *)(v8 + 120);
                  }
                  long long v120 = (long long *)(v8 + 128);
                  if (*(char *)(v8 + 151) < 0)
                  {
                    sub_10004FC84(&v503, *(void **)(v8 + 128), *(void *)(v8 + 136));
                  }
                  else
                  {
                    long long v503 = *v120;
                    uint64_t v504 = *(void *)(v8 + 144);
                  }
                  LOWORD(v505) = *(_WORD *)(v8 + 152);
                  uint64_t v493 = 0;
                  v491 = 0;
                  v492 = 0;
                  sub_10005C928(&v491, *(const void **)v8, *(void *)(v8 + 8), *(void *)(v8 + 8) - *(void *)v8);
                  if (*(char *)(v8 + 47) < 0)
                  {
                    sub_10004FC84(&v494, *(void **)(v8 + 24), *(void *)(v8 + 32));
                  }
                  else
                  {
                    long long v121 = *(_OWORD *)(v8 + 24);
                    uint64_t v495 = *(void *)(v8 + 40);
                    long long v494 = v121;
                  }
                  if (*(char *)(v8 + 71) < 0)
                  {
                    sub_10004FC84(&v496, *(void **)(v8 + 48), *(void *)(v8 + 56));
                  }
                  else
                  {
                    long long v122 = *(_OWORD *)(v8 + 48);
                    uint64_t v497 = *(void *)(v8 + 64);
                    long long v496 = v122;
                  }
                  __int16 v498 = *(_WORD *)(v8 + 72);
                  long long v123 = (unsigned __int8 *)v499[0];
                  char v124 = (unsigned __int8 *)v491;
                  int64_t v125 = (char *)v499[1] - (char *)v499[0];
                  int64_t v126 = v492 - (unsigned char *)v491;
                  if (v492 - (unsigned char *)v491 >= (char *)v499[1] - (char *)v499[0]) {
                    int64_t v127 = (char *)v499[1] - (char *)v499[0];
                  }
                  else {
                    int64_t v127 = v492 - (unsigned char *)v491;
                  }
                  if (v127 < 1)
                  {
LABEL_315:
                    if (v125 < v126) {
                      char v130 = -1;
                    }
                    else {
                      char v130 = 1;
                    }
                    if (v125 == v126) {
                      char v131 = 0;
                    }
                    else {
                      char v131 = v130;
                    }
                  }
                  else
                  {
                    while (1)
                    {
                      unsigned int v128 = *v123;
                      unsigned int v129 = *v124;
                      if (v128 != v129) {
                        break;
                      }
                      ++v123;
                      ++v124;
                      if (!--v127) {
                        goto LABEL_315;
                      }
                    }
                    if (v128 < v129) {
                      char v131 = -1;
                    }
                    else {
                      char v131 = 1;
                    }
                  }
                  if (SHIBYTE(v497) < 0) {
                    operator delete((void *)v496);
                  }
                  if (SHIBYTE(v495) < 0) {
                    operator delete((void *)v494);
                  }
                  if (v491)
                  {
                    v492 = v491;
                    operator delete(v491);
                  }
                  if (SHIBYTE(v504) < 0) {
                    operator delete((void *)v503);
                  }
                  if (SHIBYTE(v502) < 0) {
                    operator delete((void *)__src);
                  }
                  if (v499[0])
                  {
                    v499[1] = v499[0];
                    operator delete(v499[0]);
                  }
                  if (v131 < 0)
                  {
                    uint64_t v490 = 0;
                    uint64_t v132 = (uint64_t)v402;
                    *(_OWORD *)v484 = *(_OWORD *)v402;
                    uint64_t v485 = *(void *)(v8 + 96);
                    void *v402 = 0;
                    v402[1] = 0;
                    v402[2] = 0;
                    long long v486 = *v119;
                    uint64_t v487 = *(void *)(v8 + 120);
                    *(void *)(v8 + 112) = 0;
                    *(void *)(v8 + 120) = 0;
                    *(void *)__int16 v119 = 0;
                    long long v488 = *v120;
                    uint64_t v489 = *(void *)(v8 + 144);
                    *(void *)long long v120 = 0;
                    *(void *)(v8 + 136) = 0;
                    *(void *)(v8 + 144) = 0;
                    LOWORD(v490) = *(_WORD *)(v8 + 152);
                    while (1)
                    {
                      unint64_t v133 = v8;
                      sub_10005C9A4(v132, (__n128 *)v8);
                      uint64_t v134 = (void **)(v132 + 24);
                      if (*(char *)(v132 + 47) < 0) {
                        operator delete(*v134);
                      }
                      v135 = (void **)(v8 + 24);
                      *(_OWORD *)uint64_t v134 = *(_OWORD *)(v8 + 24);
                      *(void *)(v132 + 40) = *(void *)(v8 + 40);
                      *(unsigned char *)(v8 + 47) = 0;
                      *(unsigned char *)(v8 + 24) = 0;
                      long long v136 = (void **)(v132 + 48);
                      if (*(char *)(v132 + 71) < 0) {
                        operator delete(*v136);
                      }
                      *(_OWORD *)long long v136 = *(_OWORD *)(v8 + 48);
                      *(void *)(v132 + 64) = *(void *)(v8 + 64);
                      *(unsigned char *)(v8 + 71) = 0;
                      *(unsigned char *)(v8 + 48) = 0;
                      *(_WORD *)(v132 + 72) = *(_WORD *)(v8 + 72);
                      if (v8 == a1) {
                        break;
                      }
                      v477 = 0;
                      v476 = 0;
                      uint64_t v478 = 0;
                      sub_10005C928(&v476, v484[0], (uint64_t)v484[1], (char *)v484[1] - (char *)v484[0]);
                      if (SHIBYTE(v487) < 0)
                      {
                        sub_10004FC84(&v479, (void *)v486, *((unint64_t *)&v486 + 1));
                      }
                      else
                      {
                        long long v479 = v486;
                        uint64_t v480 = v487;
                      }
                      if (SHIBYTE(v489) < 0)
                      {
                        sub_10004FC84(&v481, (void *)v488, *((unint64_t *)&v488 + 1));
                      }
                      else
                      {
                        long long v481 = v488;
                        uint64_t v482 = v489;
                      }
                      __int16 v483 = v490;
                      uint64_t v514 = 0;
                      long long v513 = 0uLL;
                      v137 = *(const void **)(v8 - 80);
                      uint64_t v138 = *(void *)(v8 - 72);
                      v8 -= 80;
                      sub_10005C928(&v513, v137, v138, v138 - (void)v137);
                      if (*(char *)(v133 - 33) < 0)
                      {
                        sub_10004FC84(&v515, *(void **)(v133 - 56), *(void *)(v133 - 48));
                      }
                      else
                      {
                        long long v139 = *(_OWORD *)(v133 - 56);
                        uint64_t v516 = *(void *)(v133 - 40);
                        long long v515 = v139;
                      }
                      if (*(char *)(v133 - 9) < 0)
                      {
                        sub_10004FC84(&v517, *(void **)(v133 - 32), *(void *)(v133 - 24));
                      }
                      else
                      {
                        long long v140 = *(_OWORD *)(v133 - 32);
                        uint64_t v518 = *(void *)(v133 - 16);
                        long long v517 = v140;
                      }
                      LOWORD(v519) = *(_WORD *)(v133 - 8);
                      char v141 = (unsigned __int8 *)v476;
                      long long v142 = (unsigned __int8 *)v513;
                      int64_t v143 = v477 - (unsigned char *)v476;
                      int64_t v144 = *((void *)&v513 + 1) - v513;
                      if (*((void *)&v513 + 1) - (void)v513 >= v477 - (unsigned char *)v476) {
                        uint64_t v145 = v477 - (unsigned char *)v476;
                      }
                      else {
                        uint64_t v145 = *((void *)&v513 + 1) - v513;
                      }
                      if (v145 < 1)
                      {
LABEL_361:
                        if (v143 < v144) {
                          char v148 = -1;
                        }
                        else {
                          char v148 = 1;
                        }
                        if (v143 == v144) {
                          char v149 = 0;
                        }
                        else {
                          char v149 = v148;
                        }
                      }
                      else
                      {
                        while (1)
                        {
                          unsigned int v146 = *v141;
                          unsigned int v147 = *v142;
                          if (v146 != v147) {
                            break;
                          }
                          ++v141;
                          ++v142;
                          if (!--v145) {
                            goto LABEL_361;
                          }
                        }
                        if (v146 < v147) {
                          char v149 = -1;
                        }
                        else {
                          char v149 = 1;
                        }
                      }
                      if (SHIBYTE(v518) < 0) {
                        operator delete((void *)v517);
                      }
                      if (SHIBYTE(v516) < 0) {
                        operator delete((void *)v515);
                      }
                      if ((void)v513)
                      {
                        *((void *)&v513 + 1) = v513;
                        operator delete((void *)v513);
                      }
                      if (SHIBYTE(v482) < 0) {
                        operator delete((void *)v481);
                      }
                      if (SHIBYTE(v480) < 0) {
                        operator delete((void *)v479);
                      }
                      if (v476)
                      {
                        v477 = v476;
                        operator delete(v476);
                      }
                      uint64_t v132 = v133;
                      if ((v149 & 0x80) == 0)
                      {
                        uint64_t v150 = v133;
                        goto LABEL_385;
                      }
                    }
                    uint64_t v150 = a1;
LABEL_385:
                    v151 = *(void **)v150;
                    if (*(void *)v150)
                    {
                      *(void *)(v150 + 8) = v151;
                      operator delete(v151);
                      *(void *)uint64_t v150 = 0;
                      *(void *)(v150 + 8) = 0;
                      *(void *)(v150 + 16) = 0;
                    }
                    *(_OWORD *)uint64_t v150 = *(_OWORD *)v484;
                    *(void *)(v150 + 16) = v485;
                    v484[1] = 0;
                    v484[0] = 0;
                    uint64_t v485 = 0;
                    if (*(char *)(v150 + 47) < 0) {
                      operator delete(*v135);
                    }
                    uint64_t v152 = (void **)(v133 + 48);
                    long long v153 = v486;
                    *(void *)(v133 + 40) = v487;
                    *(_OWORD *)v135 = v153;
                    HIBYTE(v487) = 0;
                    LOBYTE(v486) = 0;
                    if (*(char *)(v150 + 71) < 0) {
                      operator delete(*v152);
                    }
                    long long v154 = v488;
                    *(void *)(v133 + 64) = v489;
                    *(_OWORD *)uint64_t v152 = v154;
                    *(_WORD *)(v150 + 72) = v490;
                  }
                  unint64_t v8 = (unint64_t)v402;
                  uint64_t v118 = (char *)(v402 + 10);
                }
                while (v402 + 10 != (void *)v371);
              }
            }
          }
          else if ((void *)v8 != n128_u64)
          {
            long long v318 = (char *)(v8 + 80);
            if ((void *)(v8 + 80) != n128_u64)
            {
              do
              {
                v401 = v318;
                v499[1] = 0;
                v499[0] = 0;
                uint64_t v500 = 0;
                uint64_t v319 = v11;
                sub_10005C928(v499, (const void *)v11[10], v11[11], v11[11] - v11[10]);
                __int16 v320 = (long long *)(v319 + 13);
                if (*((char *)v319 + 127) < 0)
                {
                  sub_10004FC84(&__src, (void *)v319[13], v319[14]);
                }
                else
                {
                  long long __src = *v320;
                  uint64_t v502 = v319[15];
                }
                v321 = (long long *)(v319 + 16);
                if (*((char *)v319 + 151) < 0)
                {
                  sub_10004FC84(&v503, (void *)v319[16], v319[17]);
                }
                else
                {
                  long long v503 = *v321;
                  uint64_t v504 = v319[18];
                }
                LOWORD(v505) = *((_WORD *)v319 + 76);
                uint64_t v493 = 0;
                v491 = 0;
                v492 = 0;
                sub_10005C928(&v491, (const void *)*v319, v319[1], v319[1] - *v319);
                if (*((char *)v319 + 47) < 0)
                {
                  sub_10004FC84(&v494, (void *)v319[3], v319[4]);
                }
                else
                {
                  long long v322 = *(_OWORD *)(v319 + 3);
                  uint64_t v495 = v319[5];
                  long long v494 = v322;
                }
                if (*((char *)v319 + 71) < 0)
                {
                  sub_10004FC84(&v496, (void *)v319[6], v319[7]);
                }
                else
                {
                  long long v323 = *((_OWORD *)v319 + 3);
                  uint64_t v497 = v319[8];
                  long long v496 = v323;
                }
                __int16 v498 = *((_WORD *)v319 + 36);
                long long v324 = (unsigned __int8 *)v499[0];
                uint64_t v325 = (unsigned __int8 *)v491;
                int64_t v326 = (char *)v499[1] - (char *)v499[0];
                int64_t v327 = v492 - (unsigned char *)v491;
                if (v492 - (unsigned char *)v491 >= (char *)v499[1] - (char *)v499[0]) {
                  int64_t v328 = (char *)v499[1] - (char *)v499[0];
                }
                else {
                  int64_t v328 = v492 - (unsigned char *)v491;
                }
                if (v328 < 1)
                {
LABEL_760:
                  if (v326 < v327) {
                    char v331 = -1;
                  }
                  else {
                    char v331 = 1;
                  }
                  if (v326 == v327) {
                    char v332 = 0;
                  }
                  else {
                    char v332 = v331;
                  }
                }
                else
                {
                  while (1)
                  {
                    unsigned int v329 = *v324;
                    unsigned int v330 = *v325;
                    if (v329 != v330) {
                      break;
                    }
                    ++v324;
                    ++v325;
                    if (!--v328) {
                      goto LABEL_760;
                    }
                  }
                  if (v329 < v330) {
                    char v332 = -1;
                  }
                  else {
                    char v332 = 1;
                  }
                }
                if (SHIBYTE(v497) < 0) {
                  operator delete((void *)v496);
                }
                if (SHIBYTE(v495) < 0) {
                  operator delete((void *)v494);
                }
                if (v491)
                {
                  v492 = v491;
                  operator delete(v491);
                }
                if (SHIBYTE(v504) < 0) {
                  operator delete((void *)v503);
                }
                if (SHIBYTE(v502) < 0) {
                  operator delete((void *)__src);
                }
                if (v499[0])
                {
                  v499[1] = v499[0];
                  operator delete(v499[0]);
                }
                if (v332 < 0)
                {
                  uint64_t v490 = 0;
                  uint64_t v333 = (uint64_t)v401;
                  *(_OWORD *)v484 = *(_OWORD *)v401;
                  uint64_t v485 = v319[12];
                  void *v401 = 0;
                  v401[1] = 0;
                  v401[2] = 0;
                  long long v486 = *v320;
                  uint64_t v487 = v319[15];
                  v319[14] = 0;
                  v319[15] = 0;
                  *(void *)__int16 v320 = 0;
                  long long v488 = *v321;
                  uint64_t v489 = v319[18];
                  *(void *)v321 = 0;
                  v319[17] = 0;
                  v319[18] = 0;
                  LOWORD(v490) = *((_WORD *)v319 + 76);
                  do
                  {
                    uint64_t v334 = (uint64_t)v319;
                    sub_10005C9A4(v333, (__n128 *)v319);
                    v335 = (void **)(v333 + 24);
                    if (*(char *)(v333 + 47) < 0) {
                      operator delete(*v335);
                    }
                    __int16 v336 = (void **)(v319 + 3);
                    *(_OWORD *)v335 = *(_OWORD *)(v319 + 3);
                    *(void *)(v333 + 40) = v319[5];
                    *((unsigned char *)v319 + 47) = 0;
                    *((unsigned char *)v319 + 24) = 0;
                    v337 = (void **)(v333 + 48);
                    if (*(char *)(v333 + 71) < 0) {
                      operator delete(*v337);
                    }
                    *(_OWORD *)v337 = *((_OWORD *)v319 + 3);
                    *(void *)(v333 + 64) = v319[8];
                    *((unsigned char *)v319 + 71) = 0;
                    *((unsigned char *)v319 + 48) = 0;
                    *(_WORD *)(v333 + 72) = *((_WORD *)v319 + 36);
                    uint64_t v478 = 0;
                    v476 = 0;
                    v477 = 0;
                    v338 = v484[0];
                    uint64_t v339 = v484[1];
                    sub_10005C928(&v476, v484[0], (uint64_t)v484[1], (char *)v484[1] - (char *)v484[0]);
                    if (SHIBYTE(v487) < 0)
                    {
                      sub_10004FC84(&v479, (void *)v486, *((unint64_t *)&v486 + 1));
                    }
                    else
                    {
                      long long v479 = v486;
                      uint64_t v480 = v487;
                    }
                    if (SHIBYTE(v489) < 0)
                    {
                      sub_10004FC84(&v481, (void *)v488, *((unint64_t *)&v488 + 1));
                    }
                    else
                    {
                      long long v481 = v488;
                      uint64_t v482 = v489;
                    }
                    __int16 v483 = v490;
                    uint64_t v514 = 0;
                    long long v513 = 0uLL;
                    long long v340 = (const void *)*(v319 - 10);
                    v319 -= 10;
                    sub_10005C928(&v513, v340, *(void *)(v334 - 72), *(void *)(v334 - 72) - (void)v340);
                    if (*(char *)(v334 - 33) < 0)
                    {
                      sub_10004FC84(&v515, *(void **)(v334 - 56), *(void *)(v334 - 48));
                    }
                    else
                    {
                      long long v341 = *(_OWORD *)(v334 - 56);
                      uint64_t v516 = *(void *)(v334 - 40);
                      long long v515 = v341;
                    }
                    if (*(char *)(v334 - 9) < 0)
                    {
                      sub_10004FC84(&v517, *(void **)(v334 - 32), *(void *)(v334 - 24));
                    }
                    else
                    {
                      long long v342 = *(_OWORD *)(v334 - 32);
                      uint64_t v518 = *(void *)(v334 - 16);
                      long long v517 = v342;
                    }
                    LOWORD(v519) = *(_WORD *)(v334 - 8);
                    v343 = (unsigned __int8 *)v476;
                    __int16 v344 = (unsigned __int8 *)v513;
                    int64_t v345 = v477 - (unsigned char *)v476;
                    int64_t v346 = *((void *)&v513 + 1) - v513;
                    if (*((void *)&v513 + 1) - (void)v513 >= v477 - (unsigned char *)v476) {
                      uint64_t v347 = v477 - (unsigned char *)v476;
                    }
                    else {
                      uint64_t v347 = *((void *)&v513 + 1) - v513;
                    }
                    if (v347 < 1)
                    {
LABEL_805:
                      if (v345 < v346) {
                        char v350 = -1;
                      }
                      else {
                        char v350 = 1;
                      }
                      if (v345 == v346) {
                        char v351 = 0;
                      }
                      else {
                        char v351 = v350;
                      }
                    }
                    else
                    {
                      while (1)
                      {
                        unsigned int v348 = *v343;
                        unsigned int v349 = *v344;
                        if (v348 != v349) {
                          break;
                        }
                        ++v343;
                        ++v344;
                        if (!--v347) {
                          goto LABEL_805;
                        }
                      }
                      if (v348 < v349) {
                        char v351 = -1;
                      }
                      else {
                        char v351 = 1;
                      }
                    }
                    if (SHIBYTE(v518) < 0) {
                      operator delete((void *)v517);
                    }
                    if (SHIBYTE(v516) < 0) {
                      operator delete((void *)v515);
                    }
                    if ((void)v513)
                    {
                      *((void *)&v513 + 1) = v513;
                      operator delete((void *)v513);
                    }
                    if (SHIBYTE(v482) < 0) {
                      operator delete((void *)v481);
                    }
                    if (SHIBYTE(v480) < 0) {
                      operator delete((void *)v479);
                    }
                    if (v476)
                    {
                      v477 = v476;
                      operator delete(v476);
                    }
                    uint64_t v333 = v334;
                  }
                  while (v351 < 0);
                  __int16 v352 = *(void **)v334;
                  if (*(void *)v334)
                  {
                    *(void *)(v334 + 8) = v352;
                    operator delete(v352);
                    *(void *)uint64_t v334 = 0;
                    *(void *)(v334 + 8) = 0;
                    *(void *)(v334 + 16) = 0;
                    v338 = v484[0];
                    uint64_t v339 = v484[1];
                  }
                  n128_u64 = (void *)v371;
                  *(void *)uint64_t v334 = v338;
                  *(void *)(v334 + 8) = v339;
                  *(void *)(v334 + 16) = v485;
                  v484[1] = 0;
                  v484[0] = 0;
                  uint64_t v485 = 0;
                  if (*(char *)(v334 + 47) < 0) {
                    operator delete(*v336);
                  }
                  v353 = (void **)(v334 + 48);
                  long long v354 = v486;
                  *(void *)(v334 + 40) = v487;
                  *(_OWORD *)__int16 v336 = v354;
                  HIBYTE(v487) = 0;
                  LOBYTE(v486) = 0;
                  if (*(char *)(v334 + 71) < 0) {
                    operator delete(*v353);
                  }
                  long long v355 = v488;
                  *(void *)(v334 + 64) = v489;
                  *(_OWORD *)v353 = v355;
                  *(_WORD *)(v334 + 72) = v490;
                }
                char v11 = v401;
                long long v318 = (char *)(v401 + 10);
              }
              while (v401 + 10 != n128_u64);
            }
          }
          return;
        }
        if (!a3)
        {
          if ((void *)v8 != n128_u64)
          {
            unint64_t v376 = (unint64_t)n128_u64 - v8;
            v403 = (void *)((v10 - 2) >> 1);
            uint64_t v155 = (uint64_t)v403;
            do
            {
              size_t v156 = v155;
              if ((uint64_t)v403 >= v155)
              {
                uint64_t v157 = (2 * v155) | 1;
                unint64_t v158 = v8 + 80 * v157;
                uint64_t v159 = 2 * v155 + 2;
                size_t v160 = v155;
                if (v159 < (uint64_t)v10)
                {
                  v499[1] = 0;
                  v499[0] = 0;
                  uint64_t v500 = 0;
                  sub_10005C928(v499, *(const void **)v158, *(void *)(v158 + 8), *(void *)(v158 + 8) - *(void *)v158);
                  v161 = (void **)(v8 + 80 * v157 + 24);
                  if (*(char *)(v158 + 47) < 0)
                  {
                    sub_10004FC84(&__src, *v161, *(void *)(v8 + 80 * v157 + 32));
                  }
                  else
                  {
                    long long v162 = *(_OWORD *)v161;
                    uint64_t v502 = *(void *)(v8 + 80 * v157 + 40);
                    long long __src = v162;
                  }
                  long long v163 = (void **)(v8 + 80 * v157 + 48);
                  if (*(char *)(v158 + 71) < 0)
                  {
                    sub_10004FC84(&v503, *v163, *(void *)(v8 + 80 * v157 + 56));
                  }
                  else
                  {
                    long long v164 = *(_OWORD *)v163;
                    uint64_t v504 = *(void *)(v8 + 80 * v157 + 64);
                    long long v503 = v164;
                  }
                  LOWORD(v505) = *(_WORD *)(v8 + 80 * v157 + 72);
                  uint64_t v493 = 0;
                  v491 = 0;
                  v492 = 0;
                  sub_10005C928(&v491, *(const void **)(v158 + 80), *(void *)(v158 + 88), *(void *)(v158 + 88) - *(void *)(v158 + 80));
                  if (*(char *)(v158 + 127) < 0)
                  {
                    sub_10004FC84(&v494, *(void **)(v158 + 104), *(void *)(v158 + 112));
                  }
                  else
                  {
                    long long v165 = *(_OWORD *)(v158 + 104);
                    uint64_t v495 = *(void *)(v158 + 120);
                    long long v494 = v165;
                  }
                  if (*(char *)(v158 + 151) < 0)
                  {
                    sub_10004FC84(&v496, *(void **)(v158 + 128), *(void *)(v158 + 136));
                  }
                  else
                  {
                    long long v166 = *(_OWORD *)(v158 + 128);
                    uint64_t v497 = *(void *)(v158 + 144);
                    long long v496 = v166;
                  }
                  __int16 v498 = *(_WORD *)(v158 + 152);
                  v167 = (unsigned __int8 *)v499[0];
                  long long v168 = (unsigned __int8 *)v491;
                  int64_t v169 = (char *)v499[1] - (char *)v499[0];
                  int64_t v170 = v492 - (unsigned char *)v491;
                  if (v492 - (unsigned char *)v491 >= (char *)v499[1] - (char *)v499[0]) {
                    int64_t v171 = (char *)v499[1] - (char *)v499[0];
                  }
                  else {
                    int64_t v171 = v492 - (unsigned char *)v491;
                  }
                  if (v171 < 1)
                  {
LABEL_416:
                    if (v169 < v170) {
                      char v174 = -1;
                    }
                    else {
                      char v174 = 1;
                    }
                    if (v169 == v170) {
                      char v175 = 0;
                    }
                    else {
                      char v175 = v174;
                    }
                  }
                  else
                  {
                    while (1)
                    {
                      unsigned int v172 = *v167;
                      unsigned int v173 = *v168;
                      if (v172 != v173) {
                        break;
                      }
                      ++v167;
                      ++v168;
                      if (!--v171) {
                        goto LABEL_416;
                      }
                    }
                    if (v172 < v173) {
                      char v175 = -1;
                    }
                    else {
                      char v175 = 1;
                    }
                  }
                  if (SHIBYTE(v497) < 0) {
                    operator delete((void *)v496);
                  }
                  if (SHIBYTE(v495) < 0) {
                    operator delete((void *)v494);
                  }
                  if (v491)
                  {
                    v492 = v491;
                    operator delete(v491);
                  }
                  if (SHIBYTE(v504) < 0) {
                    operator delete((void *)v503);
                  }
                  if (SHIBYTE(v502) < 0) {
                    operator delete((void *)__src);
                  }
                  if (v499[0])
                  {
                    v499[1] = v499[0];
                    operator delete(v499[0]);
                  }
                  if (v175 < 0)
                  {
                    v158 += 80;
                    uint64_t v157 = v159;
                  }
                }
                v484[1] = 0;
                v484[0] = 0;
                uint64_t v485 = 0;
                sub_10005C928(v484, *(const void **)v158, *(void *)(v158 + 8), *(void *)(v158 + 8) - *(void *)v158);
                if (*(char *)(v158 + 47) < 0)
                {
                  sub_10004FC84(&v486, *(void **)(v158 + 24), *(void *)(v158 + 32));
                }
                else
                {
                  long long v176 = *(_OWORD *)(v158 + 24);
                  uint64_t v487 = *(void *)(v158 + 40);
                  long long v486 = v176;
                }
                if (*(char *)(v158 + 71) < 0)
                {
                  sub_10004FC84(&v488, *(void **)(v158 + 48), *(void *)(v158 + 56));
                }
                else
                {
                  long long v177 = *(_OWORD *)(v158 + 48);
                  uint64_t v489 = *(void *)(v158 + 64);
                  long long v488 = v177;
                }
                uint64_t v178 = v8 + 80 * v160;
                LOWORD(v490) = *(_WORD *)(v158 + 72);
                uint64_t v478 = 0;
                v476 = 0;
                v477 = 0;
                sub_10005C928(&v476, *(const void **)v178, *(void *)(v178 + 8), *(void *)(v178 + 8) - *(void *)v178);
                v179 = (void **)(v178 + 24);
                if (*(char *)(v178 + 47) < 0)
                {
                  sub_10004FC84(&v479, *v179, *(void *)(v8 + 80 * v160 + 32));
                }
                else
                {
                  long long v180 = *(_OWORD *)v179;
                  uint64_t v480 = *(void *)(v8 + 80 * v160 + 40);
                  long long v479 = v180;
                }
                uint64_t v181 = v8 + 80 * v160 + 48;
                if (*(char *)(v178 + 71) < 0)
                {
                  sub_10004FC84(&v481, *(void **)v181, *(void *)(v8 + 80 * v160 + 56));
                }
                else
                {
                  long long v182 = *(_OWORD *)v181;
                  uint64_t v482 = *(void *)(v8 + 80 * v160 + 64);
                  long long v481 = v182;
                }
                size_t __sz = v160;
                unint64_t v183 = v8 + 80 * v160;
                __int16 v185 = *(_WORD *)(v183 + 72);
                uint64_t v184 = (_WORD *)(v183 + 72);
                __int16 v483 = v185;
                long long v186 = (unsigned __int8 *)v484[0];
                long long v187 = (unsigned __int8 *)v476;
                int64_t v188 = (char *)v484[1] - (char *)v484[0];
                int64_t v189 = v477 - (unsigned char *)v476;
                if (v477 - (unsigned char *)v476 >= (char *)v484[1] - (char *)v484[0]) {
                  int64_t v190 = (char *)v484[1] - (char *)v484[0];
                }
                else {
                  int64_t v190 = v477 - (unsigned char *)v476;
                }
                if (v190 < 1)
                {
LABEL_457:
                  if (v188 < v189) {
                    char v193 = -1;
                  }
                  else {
                    char v193 = 1;
                  }
                  if (v188 == v189) {
                    char v194 = 0;
                  }
                  else {
                    char v194 = v193;
                  }
                }
                else
                {
                  while (1)
                  {
                    unsigned int v191 = *v186;
                    unsigned int v192 = *v187;
                    if (v191 != v192) {
                      break;
                    }
                    ++v186;
                    ++v187;
                    if (!--v190) {
                      goto LABEL_457;
                    }
                  }
                  if (v191 < v192) {
                    char v194 = -1;
                  }
                  else {
                    char v194 = 1;
                  }
                }
                if (SHIBYTE(v482) < 0) {
                  operator delete((void *)v481);
                }
                if (SHIBYTE(v480) < 0) {
                  operator delete((void *)v479);
                }
                if (v476)
                {
                  v477 = v476;
                  operator delete(v476);
                }
                if (SHIBYTE(v489) < 0) {
                  operator delete((void *)v488);
                }
                if (SHIBYTE(v487) < 0) {
                  operator delete((void *)v486);
                }
                if (v484[0])
                {
                  v484[1] = v484[0];
                  operator delete(v484[0]);
                }
                size_t v156 = __sz;
                if ((v194 & 0x80) == 0)
                {
                  uint64_t v519 = 0;
                  long long v513 = *(_OWORD *)v178;
                  uint64_t v514 = *(void *)(v178 + 16);
                  *(void *)uint64_t v178 = 0;
                  *(void *)(v178 + 8) = 0;
                  *(void *)(v178 + 16) = 0;
                  long long v195 = *(_OWORD *)v179;
                  uint64_t v516 = *(void *)(v178 + 40);
                  long long v515 = v195;
                  *(void *)(v178 + 32) = 0;
                  *(void *)(v178 + 40) = 0;
                  *v179 = 0;
                  long long v196 = *(_OWORD *)v181;
                  uint64_t v518 = *(void *)(v181 + 16);
                  long long v517 = v196;
                  *(void *)(v181 + 8) = 0;
                  *(void *)(v181 + 16) = 0;
                  *(void *)uint64_t v181 = 0;
                  LOWORD(v519) = *v184;
                  unint64_t v197 = v8;
                  do
                  {
                    uint64_t v198 = v158;
                    sub_10005C9A4(v178, (__n128 *)v158);
                    v199 = (void **)(v178 + 24);
                    if (*(char *)(v178 + 47) < 0) {
                      operator delete(*v199);
                    }
                    long long v200 = (void **)(v158 + 24);
                    long long v201 = *(_OWORD *)(v158 + 24);
                    *(void *)(v178 + 40) = *(void *)(v158 + 40);
                    *(_OWORD *)v199 = v201;
                    *(unsigned char *)(v158 + 47) = 0;
                    *(unsigned char *)(v158 + 24) = 0;
                    long long v202 = (void **)(v178 + 48);
                    if (*(char *)(v178 + 71) < 0) {
                      operator delete(*v202);
                    }
                    long long v203 = *(_OWORD *)(v158 + 48);
                    *(void *)(v178 + 64) = *(void *)(v158 + 64);
                    *(_OWORD *)long long v202 = v203;
                    *(unsigned char *)(v158 + 71) = 0;
                    *(unsigned char *)(v158 + 48) = 0;
                    *(_WORD *)(v178 + 72) = *(_WORD *)(v158 + 72);
                    if ((uint64_t)v403 < v157) {
                      break;
                    }
                    uint64_t v204 = (2 * v157) | 1;
                    unint64_t v158 = v197 + 80 * v204;
                    uint64_t v205 = 2 * v157 + 2;
                    if (v205 >= (uint64_t)v10)
                    {
                      uint64_t v157 = (2 * v157) | 1;
                    }
                    else
                    {
                      long long v506 = 0uLL;
                      uint64_t v507 = 0;
                      sub_10005C928(&v506, *(const void **)v158, *(void *)(v158 + 8), *(void *)(v158 + 8) - *(void *)v158);
                      v206 = (void **)(v197 + 80 * v204 + 24);
                      if (*(char *)(v158 + 47) < 0)
                      {
                        sub_10004FC84(&v508, *v206, *(void *)(v197 + 80 * v204 + 32));
                      }
                      else
                      {
                        long long v207 = *(_OWORD *)v206;
                        uint64_t v509 = *(void *)(v197 + 80 * v204 + 40);
                        long long v508 = v207;
                      }
                      uint64_t v208 = (void **)(v197 + 80 * v204 + 48);
                      if (*(char *)(v158 + 71) < 0)
                      {
                        sub_10004FC84(&v510, *v208, *(void *)(v197 + 80 * v204 + 56));
                      }
                      else
                      {
                        long long v209 = *(_OWORD *)v208;
                        uint64_t v511 = *(void *)(v197 + 80 * v204 + 64);
                        long long v510 = v209;
                      }
                      __int16 v512 = *(_WORD *)(v197 + 80 * v204 + 72);
                      uint64_t v470 = 0;
                      v468 = 0;
                      v469 = 0;
                      sub_10005C928(&v468, *(const void **)(v158 + 80), *(void *)(v158 + 88), *(void *)(v158 + 88) - *(void *)(v158 + 80));
                      if (*(char *)(v158 + 127) < 0)
                      {
                        sub_10004FC84(&v471, *(void **)(v158 + 104), *(void *)(v158 + 112));
                      }
                      else
                      {
                        long long v210 = *(_OWORD *)(v158 + 104);
                        uint64_t v472 = *(void *)(v158 + 120);
                        long long v471 = v210;
                      }
                      if (*(char *)(v158 + 151) < 0)
                      {
                        sub_10004FC84(&v473, *(void **)(v158 + 128), *(void *)(v158 + 136));
                      }
                      else
                      {
                        long long v211 = *(_OWORD *)(v158 + 128);
                        uint64_t v474 = *(void *)(v158 + 144);
                        long long v473 = v211;
                      }
                      __int16 v475 = *(_WORD *)(v158 + 152);
                      long long v212 = (unsigned __int8 *)v506;
                      char v213 = (unsigned __int8 *)v468;
                      int64_t v214 = *((void *)&v506 + 1) - v506;
                      int64_t v215 = v469 - (unsigned char *)v468;
                      uint64_t v216 = v469 - (unsigned char *)v468 >= *((void *)&v506 + 1) - (void)v506
                           ? *((void *)&v506 + 1) - v506
                           : v469 - (unsigned char *)v468;
                      if (v216 < 1)
                      {
LABEL_505:
                        char v219 = v214 < v215 ? -1 : 1;
                        char v220 = v214 == v215 ? 0 : v219;
                      }
                      else
                      {
                        while (1)
                        {
                          unsigned int v217 = *v212;
                          unsigned int v218 = *v213;
                          if (v217 != v218) {
                            break;
                          }
                          ++v212;
                          ++v213;
                          if (!--v216) {
                            goto LABEL_505;
                          }
                        }
                        char v220 = v217 < v218 ? -1 : 1;
                      }
                      if (SHIBYTE(v474) < 0) {
                        operator delete((void *)v473);
                      }
                      if (SHIBYTE(v472) < 0) {
                        operator delete((void *)v471);
                      }
                      if (v468)
                      {
                        v469 = v468;
                        operator delete(v468);
                      }
                      if (SHIBYTE(v511) < 0) {
                        operator delete((void *)v510);
                      }
                      if (SHIBYTE(v509) < 0) {
                        operator delete((void *)v508);
                      }
                      if ((void)v506)
                      {
                        *((void *)&v506 + 1) = v506;
                        operator delete((void *)v506);
                      }
                      uint64_t v157 = (2 * v157) | 1;
                      if (v220 < 0)
                      {
                        v158 += 80;
                        uint64_t v157 = v205;
                      }
                    }
                    v461 = 0;
                    v460 = 0;
                    uint64_t v462 = 0;
                    sub_10005C928(&v460, *(const void **)v158, *(void *)(v158 + 8), *(void *)(v158 + 8) - *(void *)v158);
                    unint64_t v197 = v8;
                    if (*(char *)(v158 + 47) < 0)
                    {
                      sub_10004FC84(&v463, *(void **)(v158 + 24), *(void *)(v158 + 32));
                    }
                    else
                    {
                      long long v221 = *(_OWORD *)(v158 + 24);
                      uint64_t v464 = *(void *)(v158 + 40);
                      long long v463 = v221;
                    }
                    if (*(char *)(v158 + 71) < 0)
                    {
                      sub_10004FC84(&v465, *(void **)(v158 + 48), *(void *)(v158 + 56));
                    }
                    else
                    {
                      long long v222 = *(_OWORD *)(v158 + 48);
                      uint64_t v466 = *(void *)(v158 + 64);
                      long long v465 = v222;
                    }
                    __int16 v467 = *(_WORD *)(v158 + 72);
                    uint64_t v454 = 0;
                    v452 = 0;
                    v453 = 0;
                    sub_10005C928(&v452, (const void *)v513, *((uint64_t *)&v513 + 1), *((void *)&v513 + 1) - v513);
                    if (SHIBYTE(v516) < 0)
                    {
                      sub_10004FC84(&v455, (void *)v515, *((unint64_t *)&v515 + 1));
                    }
                    else
                    {
                      long long v455 = v515;
                      uint64_t v456 = v516;
                    }
                    if (SHIBYTE(v518) < 0)
                    {
                      sub_10004FC84(&v457, (void *)v517, *((unint64_t *)&v517 + 1));
                    }
                    else
                    {
                      long long v457 = v517;
                      uint64_t v458 = v518;
                    }
                    __int16 v459 = v519;
                    v223 = (unsigned __int8 *)v460;
                    v224 = (unsigned __int8 *)v452;
                    int64_t v225 = v461 - (unsigned char *)v460;
                    int64_t v226 = v453 - (unsigned char *)v452;
                    uint64_t v227 = v453 - (unsigned char *)v452 >= v461 - (unsigned char *)v460 ? v461 - (unsigned char *)v460 : v453 - (unsigned char *)v452;
                    if (v227 < 1)
                    {
LABEL_546:
                      char v230 = v225 < v226 ? -1 : 1;
                      char v231 = v225 == v226 ? 0 : v230;
                    }
                    else
                    {
                      while (1)
                      {
                        unsigned int v228 = *v223;
                        unsigned int v229 = *v224;
                        if (v228 != v229) {
                          break;
                        }
                        ++v223;
                        ++v224;
                        if (!--v227) {
                          goto LABEL_546;
                        }
                      }
                      char v231 = v228 < v229 ? -1 : 1;
                    }
                    if (SHIBYTE(v458) < 0) {
                      operator delete((void *)v457);
                    }
                    if (SHIBYTE(v456) < 0) {
                      operator delete((void *)v455);
                    }
                    if (v452)
                    {
                      v453 = v452;
                      operator delete(v452);
                    }
                    if (SHIBYTE(v466) < 0) {
                      operator delete((void *)v465);
                    }
                    if (SHIBYTE(v464) < 0) {
                      operator delete((void *)v463);
                    }
                    if (v460)
                    {
                      v461 = v460;
                      operator delete(v460);
                    }
                    uint64_t v178 = v198;
                  }
                  while ((v231 & 0x80) == 0);
                  uint64_t v232 = *(void **)v198;
                  if (*(void *)v198)
                  {
                    *(void *)(v198 + 8) = v232;
                    operator delete(v232);
                    *(void *)uint64_t v198 = 0;
                    *(void *)(v198 + 8) = 0;
                    *(void *)(v198 + 16) = 0;
                  }
                  *(_OWORD *)uint64_t v198 = v513;
                  *(void *)(v198 + 16) = v514;
                  if (*(char *)(v198 + 47) < 0) {
                    operator delete(*v200);
                  }
                  unint64_t v233 = (void **)(v198 + 48);
                  long long v234 = v515;
                  *(void *)(v198 + 40) = v516;
                  *(_OWORD *)long long v200 = v234;
                  if (*(char *)(v198 + 71) < 0) {
                    operator delete(*v233);
                  }
                  long long v235 = v517;
                  *(void *)(v198 + 64) = v518;
                  *(_OWORD *)unint64_t v233 = v235;
                  *(_WORD *)(v198 + 72) = v519;
                  n128_u64 = (void *)v371;
                  size_t v156 = __sz;
                }
              }
              uint64_t v155 = v156 - 1;
            }
            while (v156);
            int64_t v236 = v376 / 0x50;
            v380 = (void *)(v8 + 32);
            __int16 v381 = (void *)(v8 + 24);
            long long v377 = (void *)(v8 + 56);
            v378 = (void *)(v8 + 48);
            do
            {
              uint64_t v237 = 0;
              uint64_t v238 = (__n128 *)n128_u64;
              v395 = *(void **)a1;
              size_t __sza = *(void *)(a1 + 16);
              long long v386 = *(void **)(a1 + 8);
              unint64_t v239 = *(void **)(a1 + 24);
              *(void *)(a1 + 8) = 0;
              *(void *)(a1 + 16) = 0;
              *(void *)a1 = 0;
              *(void *)&long long v513 = *v380;
              *(void *)((char *)&v513 + 7) = *(void *)((char *)v380 + 7);
              unsigned __int8 v397 = *(unsigned char *)(a1 + 47);
              v381[1] = 0;
              v381[2] = 0;
              *__int16 v381 = 0;
              v391 = v239;
              v393 = *(void **)(a1 + 48);
              *(void *)((char *)&v506 + 7) = *(void *)((char *)v377 + 7);
              *(void *)&long long v506 = *v377;
              unsigned __int8 v399 = *(unsigned char *)(a1 + 71);
              void *v378 = 0;
              v378[1] = 0;
              v378[2] = 0;
              uint64_t v240 = a1;
              unsigned __int16 v389 = *(_WORD *)(a1 + 72);
              do
              {
                uint64_t v241 = v237 + 1;
                uint64_t v242 = v240 + 80 * (v237 + 1);
                uint64_t v243 = 2 * v237;
                uint64_t v237 = (2 * v237) | 1;
                uint64_t v244 = v243 + 2;
                if (v243 + 2 < v236)
                {
                  v499[1] = 0;
                  v499[0] = 0;
                  uint64_t v500 = 0;
                  sub_10005C928(v499, *(const void **)v242, *(void *)(v242 + 8), *(void *)(v242 + 8) - *(void *)v242);
                  v245 = (void **)(v240 + 80 * v241 + 24);
                  if (*(char *)(v242 + 47) < 0)
                  {
                    sub_10004FC84(&__src, *v245, *(void *)(v240 + 80 * v241 + 32));
                  }
                  else
                  {
                    long long v246 = *(_OWORD *)v245;
                    uint64_t v502 = *(void *)(v240 + 80 * v241 + 40);
                    long long __src = v246;
                  }
                  v247 = (void **)(v240 + 80 * v241 + 48);
                  if (*(char *)(v242 + 71) < 0)
                  {
                    sub_10004FC84(&v503, *v247, *(void *)(v240 + 80 * v241 + 56));
                  }
                  else
                  {
                    long long v248 = *(_OWORD *)v247;
                    uint64_t v504 = *(void *)(v240 + 80 * v241 + 64);
                    long long v503 = v248;
                  }
                  LOWORD(v505) = *(_WORD *)(v240 + 80 * v241 + 72);
                  uint64_t v493 = 0;
                  v491 = 0;
                  v492 = 0;
                  sub_10005C928(&v491, *(const void **)(v242 + 80), *(void *)(v242 + 88), *(void *)(v242 + 88) - *(void *)(v242 + 80));
                  if (*(char *)(v242 + 127) < 0)
                  {
                    sub_10004FC84(&v494, *(void **)(v242 + 104), *(void *)(v242 + 112));
                  }
                  else
                  {
                    long long v249 = *(_OWORD *)(v242 + 104);
                    uint64_t v495 = *(void *)(v242 + 120);
                    long long v494 = v249;
                  }
                  if (*(char *)(v242 + 151) < 0)
                  {
                    sub_10004FC84(&v496, *(void **)(v242 + 128), *(void *)(v242 + 136));
                  }
                  else
                  {
                    long long v250 = *(_OWORD *)(v242 + 128);
                    uint64_t v497 = *(void *)(v242 + 144);
                    long long v496 = v250;
                  }
                  __int16 v498 = *(_WORD *)(v242 + 152);
                  v251 = (unsigned __int8 *)v499[0];
                  v252 = (unsigned __int8 *)v491;
                  int64_t v253 = (char *)v499[1] - (char *)v499[0];
                  int64_t v254 = v492 - (unsigned char *)v491;
                  if (v492 - (unsigned char *)v491 >= (char *)v499[1] - (char *)v499[0]) {
                    int64_t v255 = (char *)v499[1] - (char *)v499[0];
                  }
                  else {
                    int64_t v255 = v492 - (unsigned char *)v491;
                  }
                  if (v255 < 1)
                  {
LABEL_597:
                    if (v253 < v254) {
                      char v258 = -1;
                    }
                    else {
                      char v258 = 1;
                    }
                    if (v253 == v254) {
                      char v259 = 0;
                    }
                    else {
                      char v259 = v258;
                    }
                  }
                  else
                  {
                    while (1)
                    {
                      unsigned int v256 = *v251;
                      unsigned int v257 = *v252;
                      if (v256 != v257) {
                        break;
                      }
                      ++v251;
                      ++v252;
                      if (!--v255) {
                        goto LABEL_597;
                      }
                    }
                    if (v256 < v257) {
                      char v259 = -1;
                    }
                    else {
                      char v259 = 1;
                    }
                  }
                  if (SHIBYTE(v497) < 0) {
                    operator delete((void *)v496);
                  }
                  if (SHIBYTE(v495) < 0) {
                    operator delete((void *)v494);
                  }
                  if (v491)
                  {
                    v492 = v491;
                    operator delete(v491);
                  }
                  if (SHIBYTE(v504) < 0) {
                    operator delete((void *)v503);
                  }
                  if (SHIBYTE(v502) < 0) {
                    operator delete((void *)__src);
                  }
                  if (v499[0])
                  {
                    v499[1] = v499[0];
                    operator delete(v499[0]);
                  }
                  if (v259 < 0)
                  {
                    v242 += 80;
                    uint64_t v237 = v244;
                  }
                }
                sub_10005C9A4(v240, (__n128 *)v242);
                v260 = (void **)(v240 + 24);
                if (*(char *)(v240 + 47) < 0) {
                  operator delete(*v260);
                }
                v261 = (void **)(v242 + 24);
                long long v262 = *(_OWORD *)(v242 + 24);
                *(void *)(v240 + 40) = *(void *)(v242 + 40);
                *(_OWORD *)v260 = v262;
                *(unsigned char *)(v242 + 47) = 0;
                *(unsigned char *)(v242 + 24) = 0;
                unsigned __int8 v263 = (void **)(v240 + 48);
                if (*(char *)(v240 + 71) < 0) {
                  operator delete(*v263);
                }
                long long v264 = *(_OWORD *)(v242 + 48);
                *(void *)(v240 + 64) = *(void *)(v242 + 64);
                *(_OWORD *)unsigned __int8 v263 = v264;
                *(unsigned char *)(v242 + 71) = 0;
                *(unsigned char *)(v242 + 48) = 0;
                *(_WORD *)(v240 + 72) = *(_WORD *)(v242 + 72);
                uint64_t v240 = v242;
              }
              while (v237 <= (uint64_t)((unint64_t)(v236 - 2) >> 1));
              unsigned __int8 v265 = (void **)(v242 + 48);
              n128_u64 = v238[-5].n128_u64;
              if ((__n128 *)v242 == &v238[-5])
              {
                long long v276 = *(void **)v242;
                if (*(void *)v242)
                {
                  *(void *)(v242 + 8) = v276;
                  operator delete(v276);
                  *(void *)uint64_t v242 = 0;
                  *(void *)(v242 + 8) = 0;
                  *(void *)(v242 + 16) = 0;
                }
                *(void *)uint64_t v242 = v395;
                *(void *)(v242 + 8) = v386;
                *(void *)(v242 + 16) = __sza;
                if (*(char *)(v242 + 47) < 0) {
                  operator delete(*v261);
                }
                *(void *)(v242 + 24) = v391;
                uint64_t v277 = v513;
                *(void *)(v242 + 39) = *(void *)((char *)&v513 + 7);
                *(void *)(v242 + 32) = v277;
                *(unsigned char *)(v242 + 47) = v397;
                if (*(char *)(v242 + 71) < 0) {
                  operator delete(*v265);
                }
                *(void *)(v242 + 48) = v393;
                uint64_t v278 = v506;
                *(void *)(v242 + 63) = *(void *)((char *)&v506 + 7);
                *(void *)(v242 + 56) = v278;
                *(unsigned char *)(v242 + 71) = v399;
                *(_WORD *)(v242 + 72) = v389;
              }
              else
              {
                sub_10005C9A4(v242, v238 - 5);
                if (*(char *)(v242 + 47) < 0) {
                  operator delete(*v261);
                }
                long long v266 = *(long long *)((char *)&v238[-4] + 8);
                *(void *)(v242 + 40) = v238[-3].n128_u64[1];
                *(_OWORD *)v261 = v266;
                v238[-3].n128_u8[15] = 0;
                v238[-4].n128_u8[8] = 0;
                if (*(char *)(v242 + 71) < 0) {
                  operator delete(*v265);
                }
                __n128 v267 = v238[-2];
                *(void *)(v242 + 64) = v238[-1].n128_u64[0];
                *(__n128 *)unsigned __int8 v265 = v267;
                v238[-1].n128_u8[7] = 0;
                v238[-2].n128_u8[0] = 0;
                *(_WORD *)(v242 + 72) = v238[-1].n128_u16[4];
                v268 = (void *)v238[-5].n128_u64[0];
                if (v268)
                {
                  v238[-5].n128_u64[1] = (unint64_t)v268;
                  operator delete(v268);
                  *n128_u64 = 0;
                  v238[-5].n128_u64[1] = 0;
                  v238[-4].n128_u64[0] = 0;
                }
                v238[-5].n128_u64[0] = (unint64_t)v395;
                v238[-5].n128_u64[1] = (unint64_t)v386;
                v238[-4].n128_u64[0] = __sza;
                if (v238[-3].n128_i8[15] < 0) {
                  operator delete((void *)v238[-4].n128_u64[1]);
                }
                v387 = (long long *)(v242 + 48);
                v238[-4].n128_u64[1] = (unint64_t)v391;
                unint64_t v269 = v513;
                *(unint64_t *)((char *)v238[-3].n128_u64 + 7) = *(void *)((char *)&v513 + 7);
                v238[-3].n128_u64[0] = v269;
                v238[-3].n128_u8[15] = v397;
                if (v238[-1].n128_i8[7] < 0) {
                  operator delete((void *)v238[-2].n128_u64[0]);
                }
                v238[-2].n128_u64[0] = (unint64_t)v393;
                unint64_t v270 = v506;
                *(unint64_t *)((char *)&v238[-2].n128_u64[1] + 7) = *(void *)((char *)&v506 + 7);
                v238[-2].n128_u64[1] = v270;
                v238[-1].n128_u8[7] = v399;
                v238[-1].n128_u16[4] = v389;
                uint64_t v271 = v242 + 80 - a1;
                if (v271 >= 81)
                {
                  unint64_t v272 = (v271 / 0x50uLL - 2) >> 1;
                  unint64_t v273 = a1 + 80 * v272;
                  v499[1] = 0;
                  v499[0] = 0;
                  uint64_t v500 = 0;
                  sub_10005C928(v499, *(const void **)v273, *(void *)(v273 + 8), *(void *)(v273 + 8) - *(void *)v273);
                  v274 = (void **)(v273 + 24);
                  if (*(char *)(v273 + 47) < 0)
                  {
                    sub_10004FC84(&__src, *v274, *(void *)(a1 + 80 * v272 + 32));
                  }
                  else
                  {
                    long long v275 = *(_OWORD *)v274;
                    uint64_t v502 = *(void *)(a1 + 80 * v272 + 40);
                    long long __src = v275;
                  }
                  uint64_t v279 = (void **)(a1 + 80 * v272 + 48);
                  if (*(char *)(v273 + 71) < 0)
                  {
                    sub_10004FC84(&v503, *v279, *(void *)(a1 + 80 * v272 + 56));
                  }
                  else
                  {
                    long long v280 = *(_OWORD *)v279;
                    uint64_t v504 = *(void *)(a1 + 80 * v272 + 64);
                    long long v503 = v280;
                  }
                  LOWORD(v505) = *(_WORD *)(a1 + 80 * v272 + 72);
                  uint64_t v493 = 0;
                  v491 = 0;
                  v492 = 0;
                  sub_10005C928(&v491, *(const void **)v242, *(void *)(v242 + 8), *(void *)(v242 + 8) - *(void *)v242);
                  if (*(char *)(v242 + 47) < 0)
                  {
                    sub_10004FC84(&v494, *(void **)(v242 + 24), *(void *)(v242 + 32));
                  }
                  else
                  {
                    long long v281 = *(_OWORD *)v261;
                    uint64_t v495 = *(void *)(v242 + 40);
                    long long v494 = v281;
                  }
                  if (*(char *)(v242 + 71) < 0)
                  {
                    sub_10004FC84(&v496, *(void **)(v242 + 48), *(void *)(v242 + 56));
                  }
                  else
                  {
                    long long v282 = *v387;
                    uint64_t v497 = *(void *)(v242 + 64);
                    long long v496 = v282;
                  }
                  __int16 v498 = *(_WORD *)(v242 + 72);
                  uint64_t v283 = (unsigned __int8 *)v499[0];
                  long long v284 = (unsigned __int8 *)v491;
                  int64_t v285 = (char *)v499[1] - (char *)v499[0];
                  int64_t v286 = v492 - (unsigned char *)v491;
                  if (v492 - (unsigned char *)v491 >= (char *)v499[1] - (char *)v499[0]) {
                    int64_t v287 = (char *)v499[1] - (char *)v499[0];
                  }
                  else {
                    int64_t v287 = v492 - (unsigned char *)v491;
                  }
                  if (v287 < 1)
                  {
LABEL_662:
                    if (v285 < v286) {
                      char v290 = -1;
                    }
                    else {
                      char v290 = 1;
                    }
                    if (v285 == v286) {
                      char v291 = 0;
                    }
                    else {
                      char v291 = v290;
                    }
                  }
                  else
                  {
                    while (1)
                    {
                      unsigned int v288 = *v283;
                      unsigned int v289 = *v284;
                      if (v288 != v289) {
                        break;
                      }
                      ++v283;
                      ++v284;
                      if (!--v287) {
                        goto LABEL_662;
                      }
                    }
                    if (v288 < v289) {
                      char v291 = -1;
                    }
                    else {
                      char v291 = 1;
                    }
                  }
                  if (SHIBYTE(v497) < 0) {
                    operator delete((void *)v496);
                  }
                  if (SHIBYTE(v495) < 0) {
                    operator delete((void *)v494);
                  }
                  if (v491)
                  {
                    v492 = v491;
                    operator delete(v491);
                  }
                  if (SHIBYTE(v504) < 0) {
                    operator delete((void *)v503);
                  }
                  if (SHIBYTE(v502) < 0) {
                    operator delete((void *)__src);
                  }
                  if (v499[0])
                  {
                    v499[1] = v499[0];
                    operator delete(v499[0]);
                  }
                  if (v291 < 0)
                  {
                    long long v372 = v238 - 5;
                    long long v292 = *(void **)v242;
                    long long v293 = *(_OWORD *)(v242 + 8);
                    *(void *)(v242 + 8) = 0;
                    *(void *)(v242 + 16) = 0;
                    *(void *)uint64_t v242 = 0;
                    v396 = *(void **)(v242 + 24);
                    v392 = *(void **)(v242 + 32);
                    int v294 = *(_DWORD *)(v242 + 43);
                    LODWORD(v468) = *(_DWORD *)(v242 + 40);
                    *(_DWORD *)((char *)&v468 + 3) = v294;
                    int v398 = *(char *)(v242 + 47);
                    void *v261 = 0;
                    *(void *)(v242 + 32) = 0;
                    *(void *)(v242 + 40) = 0;
                    v394 = *(void **)(v242 + 48);
                    v390 = *(void **)(v242 + 56);
                    int v295 = *(_DWORD *)(v242 + 64);
                    *(_DWORD *)((char *)&v460 + 3) = *(_DWORD *)(v242 + 67);
                    LODWORD(v460) = v295;
                    int v296 = *(char *)(v242 + 71);
                    *(void *)v387 = 0;
                    *(void *)(v242 + 56) = 0;
                    *(void *)(v242 + 64) = 0;
                    __int16 v388 = *(_WORD *)(v242 + 72);
                    long long v375 = v293;
                    v400 = v292;
                    uint64_t v297 = v293;
                    size_t __szb = v293 - (void)v292;
                    do
                    {
                      uint64_t v298 = v273;
                      sub_10005C9A4(v242, (__n128 *)v273);
                      uint64_t v299 = (void **)(v242 + 24);
                      if (*(char *)(v242 + 47) < 0) {
                        operator delete(*v299);
                      }
                      long long v300 = *(_OWORD *)(v273 + 24);
                      *(void *)(v242 + 40) = *(void *)(v273 + 40);
                      *(_OWORD *)uint64_t v299 = v300;
                      *(unsigned char *)(v273 + 47) = 0;
                      *(unsigned char *)(v273 + 24) = 0;
                      uint64_t v301 = (void **)(v242 + 48);
                      if (*(char *)(v242 + 71) < 0) {
                        operator delete(*v301);
                      }
                      long long v302 = *(_OWORD *)(v273 + 48);
                      *(void *)(v242 + 64) = *(void *)(v273 + 64);
                      *(_OWORD *)uint64_t v301 = v302;
                      *(unsigned char *)(v273 + 71) = 0;
                      *(unsigned char *)(v273 + 48) = 0;
                      *(_WORD *)(v242 + 72) = *(_WORD *)(v273 + 72);
                      if (!v272) {
                        break;
                      }
                      unint64_t v272 = (v272 - 1) >> 1;
                      unint64_t v273 = a1 + 80 * v272;
                      v484[1] = 0;
                      v484[0] = 0;
                      uint64_t v485 = 0;
                      sub_10005C928(v484, *(const void **)v273, *(void *)(v273 + 8), *(void *)(v273 + 8) - *(void *)v273);
                      uint64_t v303 = (void **)(v273 + 24);
                      if (*(char *)(v273 + 47) < 0)
                      {
                        sub_10004FC84(&v486, *v303, *(void *)(a1 + 80 * v272 + 32));
                      }
                      else
                      {
                        long long v304 = *(_OWORD *)v303;
                        uint64_t v487 = *(void *)(a1 + 80 * v272 + 40);
                        long long v486 = v304;
                      }
                      v305 = (void **)(a1 + 80 * v272 + 48);
                      if (*(char *)(v273 + 71) < 0)
                      {
                        sub_10004FC84(&v488, *v305, *(void *)(a1 + 80 * v272 + 56));
                      }
                      else
                      {
                        long long v306 = *(_OWORD *)v305;
                        uint64_t v489 = *(void *)(a1 + 80 * v272 + 64);
                        long long v488 = v306;
                      }
                      LOWORD(v490) = *(_WORD *)(a1 + 80 * v272 + 72);
                      uint64_t v478 = 0;
                      v476 = 0;
                      v477 = 0;
                      sub_10005C928(&v476, v400, v297, __szb);
                      if (v398 < 0)
                      {
                        sub_10004FC84(&v479, v396, (unint64_t)v392);
                      }
                      else
                      {
                        *(void *)&long long v479 = v396;
                        *((void *)&v479 + 1) = v392;
                        LODWORD(v480) = v468;
                        *(_DWORD *)((char *)&v480 + 3) = *(_DWORD *)((char *)&v468 + 3);
                        HIBYTE(v480) = v398;
                      }
                      if (v296 < 0)
                      {
                        sub_10004FC84(&v481, v394, (unint64_t)v390);
                      }
                      else
                      {
                        *(void *)&long long v481 = v394;
                        *((void *)&v481 + 1) = v390;
                        LODWORD(v482) = v460;
                        *(_DWORD *)((char *)&v482 + 3) = *(_DWORD *)((char *)&v460 + 3);
                        HIBYTE(v482) = v296;
                      }
                      __int16 v483 = v388;
                      uint64_t v307 = (unsigned __int8 *)v484[0];
                      long long v308 = (unsigned __int8 *)v476;
                      int64_t v309 = (char *)v484[1] - (char *)v484[0];
                      int64_t v310 = v477 - (unsigned char *)v476;
                      int64_t v311 = v477 - (unsigned char *)v476 >= (char *)v484[1] - (char *)v484[0]
                           ? (char *)v484[1] - (char *)v484[0]
                           : v477 - (unsigned char *)v476;
                      if (v311 < 1)
                      {
LABEL_708:
                        char v314 = v309 < v310 ? -1 : 1;
                        char v315 = v309 == v310 ? 0 : v314;
                      }
                      else
                      {
                        while (1)
                        {
                          unsigned int v312 = *v307;
                          unsigned int v313 = *v308;
                          if (v312 != v313) {
                            break;
                          }
                          ++v307;
                          ++v308;
                          if (!--v311) {
                            goto LABEL_708;
                          }
                        }
                        char v315 = v312 < v313 ? -1 : 1;
                      }
                      if (SHIBYTE(v482) < 0) {
                        operator delete((void *)v481);
                      }
                      if (SHIBYTE(v480) < 0) {
                        operator delete((void *)v479);
                      }
                      if (v476)
                      {
                        v477 = v476;
                        operator delete(v476);
                      }
                      if (SHIBYTE(v489) < 0) {
                        operator delete((void *)v488);
                      }
                      if (SHIBYTE(v487) < 0) {
                        operator delete((void *)v486);
                      }
                      if (v484[0])
                      {
                        v484[1] = v484[0];
                        operator delete(v484[0]);
                      }
                      uint64_t v242 = v298;
                    }
                    while (v315 < 0);
                    long long v316 = *(void **)v298;
                    if (*(void *)v298)
                    {
                      *(void *)(v298 + 8) = v316;
                      operator delete(v316);
                      *(void *)uint64_t v298 = 0;
                      *(void *)(v298 + 8) = 0;
                      *(void *)(v298 + 16) = 0;
                    }
                    *(void *)uint64_t v298 = v400;
                    *(_OWORD *)(v298 + 8) = v375;
                    if (*(char *)(v298 + 47) < 0) {
                      operator delete(*(void **)(v298 + 24));
                    }
                    *(void *)(v298 + 24) = v396;
                    *(void *)(v298 + 32) = v392;
                    *(_DWORD *)(v298 + 40) = v468;
                    *(_DWORD *)(v298 + 43) = *(_DWORD *)((char *)&v468 + 3);
                    *(unsigned char *)(v298 + 47) = v398;
                    if (*(char *)(v298 + 71) < 0) {
                      operator delete(*(void **)(v298 + 48));
                    }
                    *(void *)(v298 + 48) = v394;
                    *(void *)(v298 + 56) = v390;
                    *(_DWORD *)(v298 + 64) = v460;
                    *(_DWORD *)(v298 + 67) = *(_DWORD *)((char *)&v460 + 3);
                    *(unsigned char *)(v298 + 71) = v296;
                    *(_WORD *)(v298 + 72) = v388;
                    n128_u64 = v372->n128_u64;
                  }
                }
              }
            }
            while (v236-- > 2);
          }
          return;
        }
        unint64_t v12 = v10 >> 1;
        uint64_t v13 = v8 + 80 * (v10 >> 1);
        if ((unint64_t)v9 < 0x2801)
        {
          sub_1007A5608(v8 + 80 * (v10 >> 1), v8, v367);
          unint64_t v14 = v8;
        }
        else
        {
          sub_1007A5608(v8, v8 + 80 * (v10 >> 1), v367);
          sub_1007A5608(v8 + 80, v8 + 80 * v12 - 80, v366);
          sub_1007A5608(v8 + 160, v8 + 80 * v12 + 80, v365);
          sub_1007A5608(v8 + 80 * v12 - 80, v13, v8 + 80 * v12 + 80);
          unint64_t v14 = v8;
          sub_1007A0A70(v8, v13);
        }
        --a3;
        if (a4) {
          break;
        }
        v412 = 0;
        v413 = 0;
        uint64_t v414 = 0;
        sub_10005C928(&v412, *(const void **)(v14 - 80), *(void *)(v14 - 72), *(void *)(v14 - 72) - *(void *)(v14 - 80));
        unint64_t v14 = v8;
        if (*(char *)(v8 - 33) < 0)
        {
          sub_10004FC84(&v415, *(void **)(v8 - 56), *(void *)(v8 - 48));
        }
        else
        {
          long long v15 = *(_OWORD *)(v8 - 56);
          uint64_t v416 = *(void *)(v8 - 40);
          long long v415 = v15;
        }
        if (*(char *)(v8 - 9) < 0)
        {
          sub_10004FC84(&v417, *(void **)(v8 - 32), *(void *)(v8 - 24));
        }
        else
        {
          long long v16 = *(_OWORD *)(v8 - 32);
          uint64_t v418 = *(void *)(v8 - 16);
          long long v417 = v16;
        }
        __int16 v419 = *(_WORD *)(v8 - 8);
        v405 = 0;
        uint64_t v406 = 0;
        v404 = 0;
        sub_10005C928(&v404, *(const void **)v8, *(void *)(v8 + 8), *(void *)(v8 + 8) - *(void *)v8);
        if (*(char *)(v8 + 47) < 0)
        {
          sub_10004FC84(&v407, *(void **)(v8 + 24), *(void *)(v8 + 32));
        }
        else
        {
          long long v17 = *(_OWORD *)(v8 + 24);
          uint64_t v408 = *(void *)(v8 + 40);
          long long v407 = v17;
        }
        if (*(char *)(v8 + 71) < 0)
        {
          sub_10004FC84(&__p, *(void **)(v8 + 48), *(void *)(v8 + 56));
        }
        else
        {
          long long v18 = *(_OWORD *)(v8 + 48);
          uint64_t v410 = *(void *)(v8 + 64);
          long long __p = v18;
        }
        __int16 v411 = *(_WORD *)(v8 + 72);
        uint64_t v19 = (unsigned __int8 *)v412;
        long long v20 = (unsigned __int8 *)v404;
        int64_t v21 = v413 - (unsigned char *)v412;
        int64_t v22 = v405 - (unsigned char *)v404;
        uint64_t v23 = v405 - (unsigned char *)v404 >= v413 - (unsigned char *)v412 ? v413 - (unsigned char *)v412 : v405 - (unsigned char *)v404;
        if (v23 < 1)
        {
LABEL_28:
          char v26 = v21 < v22 ? -1 : 1;
          char v27 = v21 == v22 ? 0 : v26;
        }
        else
        {
          while (1)
          {
            unsigned int v24 = *v19;
            unsigned int v25 = *v20;
            if (v24 != v25) {
              break;
            }
            ++v19;
            ++v20;
            if (!--v23) {
              goto LABEL_28;
            }
          }
          char v27 = v24 < v25 ? -1 : 1;
        }
        if (SHIBYTE(v410) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v408) < 0) {
          operator delete((void *)v407);
        }
        if (v404)
        {
          v405 = v404;
          operator delete(v404);
        }
        if (SHIBYTE(v418) < 0) {
          operator delete((void *)v417);
        }
        if (SHIBYTE(v416) < 0) {
          operator delete((void *)v415);
        }
        if (v412)
        {
          v413 = v412;
          operator delete(v412);
        }
        if (v27 < 0) {
          break;
        }
        unint64_t v8 = sub_1007A611C(v8, (unint64_t)n128_u64);
LABEL_285:
        a4 = 0;
      }
      uint64_t v374 = a3;
      uint64_t v505 = 0;
      *(_OWORD *)v499 = *(_OWORD *)v14;
      uint64_t v500 = *(void *)(v14 + 16);
      *(void *)unint64_t v14 = 0;
      *(void *)(v14 + 8) = 0;
      *(void *)(v14 + 16) = 0;
      long long v28 = *(_OWORD *)(v14 + 24);
      uint64_t v502 = *(void *)(v14 + 40);
      long long __src = v28;
      *(void *)(v14 + 32) = 0;
      *(void *)(v14 + 40) = 0;
      *(void *)(v14 + 24) = 0;
      unint64_t v369 = v14 + 24;
      unint64_t v370 = v14 + 48;
      long long v29 = *(_OWORD *)(v14 + 48);
      uint64_t v504 = *(void *)(v14 + 64);
      long long v503 = v29;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(void *)(v14 + 64) = 0;
      __int16 v30 = *(_WORD *)(v14 + 72);
      uint64_t v31 = (void *)v14;
      LOWORD(v505) = v30;
      do
      {
        long long v32 = v31;
        uint64_t v33 = (const void *)v31[10];
        v492 = 0;
        v491 = 0;
        uint64_t v493 = 0;
        uint64_t v385 = v31 + 10;
        sub_10005C928(&v491, v33, v31[11], v31[11] - (void)v33);
        if (*((char *)v32 + 127) < 0)
        {
          sub_10004FC84(&v494, (void *)v32[13], v32[14]);
        }
        else
        {
          long long v494 = *(_OWORD *)(v32 + 13);
          uint64_t v495 = v32[15];
        }
        if (*((char *)v32 + 151) < 0)
        {
          sub_10004FC84(&v496, (void *)v32[16], v32[17]);
        }
        else
        {
          long long v496 = *((_OWORD *)v32 + 8);
          uint64_t v497 = v32[18];
        }
        __int16 v498 = *((_WORD *)v32 + 76);
        uint64_t v485 = 0;
        v484[0] = 0;
        v484[1] = 0;
        long long v34 = v499[0];
        uint64_t v35 = v499[1];
        size_t v36 = (char *)v499[1] - (char *)v499[0];
        sub_10005C928(v484, v499[0], (uint64_t)v499[1], (char *)v499[1] - (char *)v499[0]);
        int v37 = SHIBYTE(v502);
        if (SHIBYTE(v502) < 0)
        {
          sub_10004FC84(&v486, (void *)__src, *((unint64_t *)&__src + 1));
        }
        else
        {
          long long v486 = __src;
          uint64_t v487 = v502;
        }
        int v38 = SHIBYTE(v504);
        if (SHIBYTE(v504) < 0)
        {
          sub_10004FC84(&v488, (void *)v503, *((unint64_t *)&v503 + 1));
        }
        else
        {
          long long v488 = v503;
          uint64_t v489 = v504;
        }
        LOWORD(v490) = v30;
        __int16 v39 = (unsigned __int8 *)v491;
        long long v40 = (unsigned __int8 *)v484[0];
        int64_t v41 = v492 - (unsigned char *)v491;
        int64_t v42 = (char *)v484[1] - (char *)v484[0];
        if ((char *)v484[1] - (char *)v484[0] >= v492 - (unsigned char *)v491) {
          int64_t v43 = v492 - (unsigned char *)v491;
        }
        else {
          int64_t v43 = (char *)v484[1] - (char *)v484[0];
        }
        if (v43 < 1)
        {
LABEL_69:
          if (v41 < v42) {
            char v46 = -1;
          }
          else {
            char v46 = 1;
          }
          if (v41 == v42) {
            char v47 = 0;
          }
          else {
            char v47 = v46;
          }
        }
        else
        {
          while (1)
          {
            unsigned int v44 = *v39;
            unsigned int v45 = *v40;
            if (v44 != v45) {
              break;
            }
            ++v39;
            ++v40;
            if (!--v43) {
              goto LABEL_69;
            }
          }
          if (v44 < v45) {
            char v47 = -1;
          }
          else {
            char v47 = 1;
          }
        }
        if (SHIBYTE(v489) < 0) {
          operator delete((void *)v488);
        }
        if (SHIBYTE(v487) < 0) {
          operator delete((void *)v486);
        }
        if (v484[0])
        {
          v484[1] = v484[0];
          operator delete(v484[0]);
        }
        if (SHIBYTE(v497) < 0) {
          operator delete((void *)v496);
        }
        if (SHIBYTE(v495) < 0) {
          operator delete((void *)v494);
        }
        if (v491)
        {
          v492 = v491;
          operator delete(v491);
        }
        uint64_t v31 = v385;
      }
      while (v47 < 0);
      uint64_t v48 = n128_u64;
      if (v32 == (void *)v14)
      {
        uint64_t v61 = n128_u64;
        if (v385 < n128_u64)
        {
          while (1)
          {
            v477 = 0;
            v476 = 0;
            uint64_t v478 = 0;
            __int16 v62 = n128_u64 - 10;
            sub_10005C928(&v476, (const void *)*(n128_u64 - 10), *(n128_u64 - 9), *(n128_u64 - 9) - *(n128_u64 - 10));
            if (*((char *)n128_u64 - 33) < 0)
            {
              sub_10004FC84(&v479, (void *)*(n128_u64 - 7), *(n128_u64 - 6));
            }
            else
            {
              long long v63 = *(_OWORD *)(n128_u64 - 7);
              uint64_t v480 = *(n128_u64 - 5);
              long long v479 = v63;
            }
            if (*((char *)n128_u64 - 9) < 0)
            {
              sub_10004FC84(&v481, (void *)*(n128_u64 - 4), *(n128_u64 - 3));
            }
            else
            {
              long long v64 = *((_OWORD *)n128_u64 - 2);
              uint64_t v482 = *(n128_u64 - 2);
              long long v481 = v64;
            }
            __int16 v483 = *((_WORD *)n128_u64 - 4);
            uint64_t v514 = 0;
            long long v513 = 0uLL;
            sub_10005C928(&v513, v34, (uint64_t)v35, v36);
            if (v37 < 0)
            {
              sub_10004FC84(&v515, (void *)__src, *((unint64_t *)&__src + 1));
            }
            else
            {
              long long v515 = __src;
              uint64_t v516 = v502;
            }
            if (v38 < 0)
            {
              sub_10004FC84(&v517, (void *)v503, *((unint64_t *)&v503 + 1));
            }
            else
            {
              long long v517 = v503;
              uint64_t v518 = v504;
            }
            LOWORD(v519) = v30;
            long long v65 = (unsigned __int8 *)v476;
            uint64_t v66 = (unsigned __int8 *)v513;
            int64_t v67 = v477 - (unsigned char *)v476;
            int64_t v68 = *((void *)&v513 + 1) - v513;
            uint64_t v69 = *((void *)&v513 + 1) - (void)v513 >= v477 - (unsigned char *)v476
                ? v477 - (unsigned char *)v476
                : *((void *)&v513 + 1) - v513;
            if (v69 < 1)
            {
LABEL_152:
              char v72 = v67 < v68 ? -1 : 1;
              char v73 = v67 == v68 ? 0 : v72;
            }
            else
            {
              while (1)
              {
                unsigned int v70 = *v65;
                unsigned int v71 = *v66;
                if (v70 != v71) {
                  break;
                }
                ++v65;
                ++v66;
                if (!--v69) {
                  goto LABEL_152;
                }
              }
              char v73 = v70 < v71 ? -1 : 1;
            }
            if (SHIBYTE(v518) < 0) {
              operator delete((void *)v517);
            }
            if (SHIBYTE(v516) < 0) {
              operator delete((void *)v515);
            }
            if ((void)v513)
            {
              *((void *)&v513 + 1) = v513;
              operator delete((void *)v513);
            }
            if (SHIBYTE(v482) < 0) {
              operator delete((void *)v481);
            }
            if (SHIBYTE(v480) < 0) {
              operator delete((void *)v479);
            }
            if (v476)
            {
              v477 = v476;
              operator delete(v476);
            }
            if (v385 >= v62) {
              break;
            }
            n128_u64 -= 10;
            uint64_t v61 = v62;
            if (v73 < 0) {
              goto LABEL_177;
            }
          }
          uint64_t v61 = n128_u64 - 10;
        }
      }
      else
      {
        do
        {
          long long v506 = 0uLL;
          uint64_t v507 = 0;
          uint64_t v49 = v48 - 10;
          sub_10005C928(&v506, (const void *)*(v48 - 10), *(v48 - 9), *(v48 - 9) - *(v48 - 10));
          if (*((char *)v48 - 33) < 0)
          {
            sub_10004FC84(&v508, (void *)*(v48 - 7), *(v48 - 6));
          }
          else
          {
            long long v50 = *(_OWORD *)(v48 - 7);
            uint64_t v509 = *(v48 - 5);
            long long v508 = v50;
          }
          if (*((char *)v48 - 9) < 0)
          {
            sub_10004FC84(&v510, (void *)*(v48 - 4), *(v48 - 3));
          }
          else
          {
            long long v51 = *((_OWORD *)v48 - 2);
            uint64_t v511 = *(v48 - 2);
            long long v510 = v51;
          }
          __int16 v512 = *((_WORD *)v48 - 4);
          uint64_t v470 = 0;
          v468 = 0;
          v469 = 0;
          sub_10005C928(&v468, v34, (uint64_t)v35, v36);
          if (v37 < 0)
          {
            sub_10004FC84(&v471, (void *)__src, *((unint64_t *)&__src + 1));
          }
          else
          {
            long long v471 = __src;
            uint64_t v472 = v502;
          }
          if (v38 < 0)
          {
            sub_10004FC84(&v473, (void *)v503, *((unint64_t *)&v503 + 1));
          }
          else
          {
            long long v473 = v503;
            uint64_t v474 = v504;
          }
          __int16 v475 = v30;
          long long v52 = (unsigned __int8 *)v506;
          uint64_t v53 = (unsigned __int8 *)v468;
          int64_t v54 = *((void *)&v506 + 1) - v506;
          int64_t v55 = v469 - (unsigned char *)v468;
          if (v469 - (unsigned char *)v468 >= *((void *)&v506 + 1) - (void)v506) {
            uint64_t v56 = *((void *)&v506 + 1) - v506;
          }
          else {
            uint64_t v56 = v469 - (unsigned char *)v468;
          }
          if (v56 < 1)
          {
LABEL_110:
            if (v54 < v55) {
              char v59 = -1;
            }
            else {
              char v59 = 1;
            }
            if (v54 == v55) {
              char v60 = 0;
            }
            else {
              char v60 = v59;
            }
          }
          else
          {
            while (1)
            {
              unsigned int v57 = *v52;
              unsigned int v58 = *v53;
              if (v57 != v58) {
                break;
              }
              ++v52;
              ++v53;
              if (!--v56) {
                goto LABEL_110;
              }
            }
            if (v57 < v58) {
              char v60 = -1;
            }
            else {
              char v60 = 1;
            }
          }
          if (SHIBYTE(v474) < 0) {
            operator delete((void *)v473);
          }
          if (SHIBYTE(v472) < 0) {
            operator delete((void *)v471);
          }
          if (v468)
          {
            v469 = v468;
            operator delete(v468);
          }
          if (SHIBYTE(v511) < 0) {
            operator delete((void *)v510);
          }
          if (SHIBYTE(v509) < 0) {
            operator delete((void *)v508);
          }
          if ((void)v506)
          {
            *((void *)&v506 + 1) = v506;
            operator delete((void *)v506);
          }
          v48 -= 10;
          uint64_t v61 = v49;
        }
        while ((v60 & 0x80) == 0);
      }
LABEL_177:
      unint64_t v8 = (unint64_t)v385;
      unint64_t v373 = (unint64_t)v61;
      if (v385 < v61)
      {
        unint64_t v74 = (unint64_t)v61;
        do
        {
          sub_1007A0A70(v8, v74);
          unint64_t v75 = v8;
          do
          {
            uint64_t v76 = *(const void **)(v8 + 80);
            uint64_t v77 = *(void *)(v8 + 88);
            v8 += 80;
            v461 = 0;
            v460 = 0;
            uint64_t v462 = 0;
            sub_10005C928(&v460, v76, v77, v77 - (void)v76);
            if (*(char *)(v75 + 127) < 0)
            {
              sub_10004FC84(&v463, *(void **)(v75 + 104), *(void *)(v75 + 112));
            }
            else
            {
              long long v463 = *(_OWORD *)(v75 + 104);
              uint64_t v464 = *(void *)(v75 + 120);
            }
            if (*(char *)(v75 + 151) < 0)
            {
              sub_10004FC84(&v465, *(void **)(v75 + 128), *(void *)(v75 + 136));
            }
            else
            {
              long long v465 = *(_OWORD *)(v75 + 128);
              uint64_t v466 = *(void *)(v75 + 144);
            }
            __int16 v467 = *(_WORD *)(v75 + 152);
            uint64_t v454 = 0;
            v452 = 0;
            v453 = 0;
            long long v78 = v499[0];
            __int16 v79 = v499[1];
            size_t v80 = (char *)v499[1] - (char *)v499[0];
            sub_10005C928(&v452, v499[0], (uint64_t)v499[1], (char *)v499[1] - (char *)v499[0]);
            int v81 = SHIBYTE(v502);
            if (SHIBYTE(v502) < 0)
            {
              sub_10004FC84(&v455, (void *)__src, *((unint64_t *)&__src + 1));
            }
            else
            {
              long long v455 = __src;
              uint64_t v456 = v502;
            }
            int v82 = SHIBYTE(v504);
            if (SHIBYTE(v504) < 0)
            {
              sub_10004FC84(&v457, (void *)v503, *((unint64_t *)&v503 + 1));
            }
            else
            {
              long long v457 = v503;
              uint64_t v458 = v504;
            }
            __int16 v83 = v505;
            __int16 v459 = v505;
            uint64_t v84 = (unsigned __int8 *)v460;
            __int16 v85 = (unsigned __int8 *)v452;
            int64_t v86 = v461 - (unsigned char *)v460;
            int64_t v87 = v453 - (unsigned char *)v452;
            if (v453 - (unsigned char *)v452 >= v461 - (unsigned char *)v460) {
              uint64_t v88 = v461 - (unsigned char *)v460;
            }
            else {
              uint64_t v88 = v453 - (unsigned char *)v452;
            }
            if (v88 < 1)
            {
LABEL_198:
              if (v86 < v87) {
                char v91 = -1;
              }
              else {
                char v91 = 1;
              }
              if (v86 == v87) {
                char v92 = 0;
              }
              else {
                char v92 = v91;
              }
            }
            else
            {
              while (1)
              {
                unsigned int v89 = *v84;
                unsigned int v90 = *v85;
                if (v89 != v90) {
                  break;
                }
                ++v84;
                ++v85;
                if (!--v88) {
                  goto LABEL_198;
                }
              }
              if (v89 < v90) {
                char v92 = -1;
              }
              else {
                char v92 = 1;
              }
            }
            if (SHIBYTE(v458) < 0) {
              operator delete((void *)v457);
            }
            if (SHIBYTE(v456) < 0) {
              operator delete((void *)v455);
            }
            if (v452)
            {
              v453 = v452;
              operator delete(v452);
            }
            if (SHIBYTE(v466) < 0) {
              operator delete((void *)v465);
            }
            if (SHIBYTE(v464) < 0) {
              operator delete((void *)v463);
            }
            if (v460)
            {
              v461 = v460;
              operator delete(v460);
            }
            unint64_t v75 = v8;
          }
          while (v92 < 0);
          unint64_t v93 = v74;
          do
          {
            v445 = 0;
            v444 = 0;
            uint64_t v446 = 0;
            long long v94 = *(const void **)(v74 - 80);
            uint64_t v95 = *(void *)(v74 - 72);
            v74 -= 80;
            sub_10005C928(&v444, v94, v95, v95 - (void)v94);
            if (*(char *)(v93 - 33) < 0)
            {
              sub_10004FC84(&v447, *(void **)(v93 - 56), *(void *)(v93 - 48));
            }
            else
            {
              long long v96 = *(_OWORD *)(v93 - 56);
              uint64_t v448 = *(void *)(v93 - 40);
              long long v447 = v96;
            }
            if (*(char *)(v93 - 9) < 0)
            {
              sub_10004FC84(&v449, *(void **)(v93 - 32), *(void *)(v93 - 24));
            }
            else
            {
              long long v97 = *(_OWORD *)(v93 - 32);
              uint64_t v450 = *(void *)(v93 - 16);
              long long v449 = v97;
            }
            __int16 v451 = *(_WORD *)(v93 - 8);
            uint64_t v438 = 0;
            v436 = 0;
            v437 = 0;
            sub_10005C928(&v436, v78, (uint64_t)v79, v80);
            if (v81 < 0)
            {
              sub_10004FC84(&v439, (void *)__src, *((unint64_t *)&__src + 1));
            }
            else
            {
              long long v439 = __src;
              uint64_t v440 = v502;
            }
            if (v82 < 0)
            {
              sub_10004FC84(&v441, (void *)v503, *((unint64_t *)&v503 + 1));
            }
            else
            {
              long long v441 = v503;
              uint64_t v442 = v504;
            }
            __int16 v443 = v83;
            uint64_t v98 = (unsigned __int8 *)v444;
            long long v99 = (unsigned __int8 *)v436;
            int64_t v100 = v445 - (unsigned char *)v444;
            int64_t v101 = v437 - (unsigned char *)v436;
            if (v437 - (unsigned char *)v436 >= v445 - (unsigned char *)v444) {
              uint64_t v102 = v445 - (unsigned char *)v444;
            }
            else {
              uint64_t v102 = v437 - (unsigned char *)v436;
            }
            if (v102 < 1)
            {
LABEL_239:
              if (v100 < v101) {
                char v105 = -1;
              }
              else {
                char v105 = 1;
              }
              if (v100 == v101) {
                char v106 = 0;
              }
              else {
                char v106 = v105;
              }
            }
            else
            {
              while (1)
              {
                unsigned int v103 = *v98;
                unsigned int v104 = *v99;
                if (v103 != v104) {
                  break;
                }
                ++v98;
                ++v99;
                if (!--v102) {
                  goto LABEL_239;
                }
              }
              if (v103 < v104) {
                char v106 = -1;
              }
              else {
                char v106 = 1;
              }
            }
            if (SHIBYTE(v442) < 0) {
              operator delete((void *)v441);
            }
            if (SHIBYTE(v440) < 0) {
              operator delete((void *)v439);
            }
            if (v436)
            {
              v437 = v436;
              operator delete(v436);
            }
            if (SHIBYTE(v450) < 0) {
              operator delete((void *)v449);
            }
            if (SHIBYTE(v448) < 0) {
              operator delete((void *)v447);
            }
            if (v444)
            {
              v445 = v444;
              operator delete(v444);
            }
            unint64_t v93 = v74;
          }
          while ((v106 & 0x80) == 0);
        }
        while (v8 < v74);
      }
      long long v107 = (void **)(v8 - 80);
      uint64_t v108 = a1;
      n128_u64 = (void *)v371;
      a3 = v374;
      if (v8 - 80 != a1)
      {
        sub_10005C9A4(a1, (__n128 *)(v8 - 80));
        if (*(char *)(a1 + 47) < 0) {
          operator delete(*(void **)v369);
        }
        long long v109 = *(_OWORD *)(v8 - 56);
        *(void *)(v369 + 16) = *(void *)(v8 - 40);
        *(_OWORD *)unint64_t v369 = v109;
        *(unsigned char *)(v8 - 33) = 0;
        *(unsigned char *)(v8 - 56) = 0;
        if (*(char *)(a1 + 71) < 0) {
          operator delete(*(void **)v370);
        }
        long long v110 = *(_OWORD *)(v8 - 32);
        *(void *)(v370 + 16) = *(void *)(v8 - 16);
        *(_OWORD *)unint64_t v370 = v110;
        *(unsigned char *)(v8 - 9) = 0;
        *(unsigned char *)(v8 - 32) = 0;
        *(_WORD *)(a1 + 72) = *(_WORD *)(v8 - 8);
      }
      __int16 v111 = *v107;
      if (*v107)
      {
        *(void *)(v8 - 72) = v111;
        operator delete(v111);
        *long long v107 = 0;
        *(void *)(v8 - 72) = 0;
        *(void *)(v8 - 64) = 0;
      }
      *(_OWORD *)(v8 - 80) = *(_OWORD *)v499;
      *(void *)(v8 - 64) = v500;
      v499[1] = 0;
      v499[0] = 0;
      uint64_t v500 = 0;
      v112 = (void **)(v8 - 56);
      if (*(char *)(v8 - 33) < 0) {
        operator delete(*v112);
      }
      long long v113 = __src;
      *(void *)(v8 - 40) = v502;
      *(_OWORD *)v112 = v113;
      HIBYTE(v502) = 0;
      LOBYTE(__src) = 0;
      uint64_t v114 = (void **)(v8 - 32);
      if (*(char *)(v8 - 9) < 0) {
        operator delete(*v114);
      }
      long long v115 = v503;
      *(void *)(v8 - 16) = v504;
      *(_OWORD *)uint64_t v114 = v115;
      HIBYTE(v504) = 0;
      LOBYTE(v503) = 0;
      *(_WORD *)(v8 - 8) = v505;
      if (SHIBYTE(v504) < 0) {
        operator delete((void *)v503);
      }
      if (SHIBYTE(v502) < 0) {
        operator delete((void *)__src);
      }
      if (v499[0]) {
        operator delete(v499[0]);
      }
      if ((unint64_t)v385 < v373)
      {
LABEL_283:
        sub_1007A1244(v108, v8 - 80, v374, a4 & 1);
        goto LABEL_285;
      }
      BOOL v116 = sub_1007A70E0(a1, v8 - 80);
      if (sub_1007A70E0(v8, v371)) {
        break;
      }
      uint64_t v108 = a1;
      if (!v116) {
        goto LABEL_283;
      }
    }
    n128_u64 = (void *)(v8 - 80);
    if (!v116) {
      continue;
    }
    break;
  }
}

void sub_1007A4590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,void *a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x20F]) < 0) {
    operator delete(__p);
  }
  if (a69) {
    operator delete(a69);
  }
  sub_10079AB58((uint64_t)&STACK[0x230]);
  _Unwind_Resume(a1);
}

void sub_1007A4CB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_1007A7A90(a1, a2, a3, a4);
  char v105 = 0;
  char v106 = 0;
  uint64_t v107 = 0;
  sub_10005C928(&v105, *(const void **)a5, *(void *)(a5 + 8), *(void *)(a5 + 8) - *(void *)a5);
  if (*(char *)(a5 + 47) < 0)
  {
    sub_10004FC84(&v108, *(void **)(a5 + 24), *(void *)(a5 + 32));
  }
  else
  {
    long long v108 = *(_OWORD *)(a5 + 24);
    uint64_t v109 = *(void *)(a5 + 40);
  }
  if (*(char *)(a5 + 71) < 0)
  {
    sub_10004FC84(&v110, *(void **)(a5 + 48), *(void *)(a5 + 56));
  }
  else
  {
    long long v110 = *(_OWORD *)(a5 + 48);
    uint64_t v111 = *(void *)(a5 + 64);
  }
  __int16 v112 = *(_WORD *)(a5 + 72);
  uint64_t v98 = 0;
  uint64_t v99 = 0;
  long long v97 = 0;
  sub_10005C928(&v97, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
  unint64_t v10 = (long long *)(a4 + 24);
  if (*(char *)(a4 + 47) < 0)
  {
    sub_10004FC84(&v100, *(void **)(a4 + 24), *(void *)(a4 + 32));
  }
  else
  {
    long long v100 = *v10;
    uint64_t v101 = *(void *)(a4 + 40);
  }
  char v11 = (long long *)(a4 + 48);
  if (*(char *)(a4 + 71) < 0)
  {
    sub_10004FC84(&v102, *(void **)(a4 + 48), *(void *)(a4 + 56));
  }
  else
  {
    long long v102 = *v11;
    uint64_t v103 = *(void *)(a4 + 64);
  }
  __int16 v104 = *(_WORD *)(a4 + 72);
  unint64_t v12 = v105;
  uint64_t v13 = v97;
  int64_t v14 = v106 - v105;
  int64_t v15 = v98 - v97;
  if (v98 - v97 >= v106 - v105) {
    uint64_t v16 = v106 - v105;
  }
  else {
    uint64_t v16 = v98 - v97;
  }
  if (v16 < 1)
  {
LABEL_19:
    if (v14 < v15) {
      char v19 = -1;
    }
    else {
      char v19 = 1;
    }
    if (v14 == v15) {
      char v20 = 0;
    }
    else {
      char v20 = v19;
    }
  }
  else
  {
    while (1)
    {
      unsigned int v17 = *v12;
      unsigned int v18 = *v13;
      if (v17 != v18) {
        break;
      }
      ++v12;
      ++v13;
      if (!--v16) {
        goto LABEL_19;
      }
    }
    if (v17 < v18) {
      char v20 = -1;
    }
    else {
      char v20 = 1;
    }
  }
  if (SHIBYTE(v103) < 0) {
    operator delete((void *)v102);
  }
  if (SHIBYTE(v101) < 0) {
    operator delete((void *)v100);
  }
  if (v97)
  {
    uint64_t v98 = v97;
    operator delete(v97);
  }
  if (SHIBYTE(v111) < 0) {
    operator delete((void *)v110);
  }
  if (SHIBYTE(v109) < 0) {
    operator delete((void *)v108);
  }
  if (v105)
  {
    char v106 = v105;
    operator delete(v105);
  }
  if (v20 < 0)
  {
    sub_1007A0A70(a4, a5);
    unsigned int v89 = 0;
    unsigned int v90 = 0;
    uint64_t v91 = 0;
    sub_10005C928(&v89, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
    if (*(char *)(a4 + 47) < 0)
    {
      sub_10004FC84(&v92, *(void **)(a4 + 24), *(void *)(a4 + 32));
    }
    else
    {
      long long v92 = *v10;
      uint64_t v93 = *(void *)(a4 + 40);
    }
    if (*(char *)(a4 + 71) < 0)
    {
      sub_10004FC84(&v94, *(void **)(a4 + 48), *(void *)(a4 + 56));
    }
    else
    {
      long long v94 = *v11;
      uint64_t v95 = *(void *)(a4 + 64);
    }
    __int16 v96 = *(_WORD *)(a4 + 72);
    int v82 = 0;
    uint64_t v83 = 0;
    int v81 = 0;
    sub_10005C928(&v81, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    int64_t v21 = (long long *)(a3 + 24);
    if (*(char *)(a3 + 47) < 0)
    {
      sub_10004FC84(&v84, *(void **)(a3 + 24), *(void *)(a3 + 32));
    }
    else
    {
      long long v84 = *v21;
      uint64_t v85 = *(void *)(a3 + 40);
    }
    int64_t v22 = (long long *)(a3 + 48);
    if (*(char *)(a3 + 71) < 0)
    {
      sub_10004FC84(&__p, *(void **)(a3 + 48), *(void *)(a3 + 56));
    }
    else
    {
      long long __p = *v22;
      uint64_t v87 = *(void *)(a3 + 64);
    }
    __int16 v88 = *(_WORD *)(a3 + 72);
    uint64_t v23 = (unsigned __int8 *)v89;
    unsigned int v24 = (unsigned __int8 *)v81;
    int64_t v25 = v90 - (unsigned char *)v89;
    int64_t v26 = v82 - (unsigned char *)v81;
    if (v82 - (unsigned char *)v81 >= v90 - (unsigned char *)v89) {
      uint64_t v27 = v90 - (unsigned char *)v89;
    }
    else {
      uint64_t v27 = v82 - (unsigned char *)v81;
    }
    if (v27 < 1)
    {
LABEL_59:
      if (v25 < v26) {
        char v30 = -1;
      }
      else {
        char v30 = 1;
      }
      if (v25 == v26) {
        char v31 = 0;
      }
      else {
        char v31 = v30;
      }
    }
    else
    {
      while (1)
      {
        unsigned int v28 = *v23;
        unsigned int v29 = *v24;
        if (v28 != v29) {
          break;
        }
        ++v23;
        ++v24;
        if (!--v27) {
          goto LABEL_59;
        }
      }
      if (v28 < v29) {
        char v31 = -1;
      }
      else {
        char v31 = 1;
      }
    }
    if (SHIBYTE(v87) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v85) < 0) {
      operator delete((void *)v84);
    }
    if (v81)
    {
      int v82 = v81;
      operator delete(v81);
    }
    if (SHIBYTE(v95) < 0) {
      operator delete((void *)v94);
    }
    if (SHIBYTE(v93) < 0) {
      operator delete((void *)v92);
    }
    if (v89)
    {
      unsigned int v90 = v89;
      operator delete(v89);
    }
    if (v31 < 0)
    {
      sub_1007A0A70(a3, a4);
      char v73 = 0;
      unint64_t v74 = 0;
      uint64_t v75 = 0;
      sub_10005C928(&v73, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
      if (*(char *)(a3 + 47) < 0)
      {
        sub_10004FC84(&v76, *(void **)(a3 + 24), *(void *)(a3 + 32));
      }
      else
      {
        long long v76 = *v21;
        uint64_t v77 = *(void *)(a3 + 40);
      }
      if (*(char *)(a3 + 71) < 0)
      {
        sub_10004FC84(&v78, *(void **)(a3 + 48), *(void *)(a3 + 56));
      }
      else
      {
        long long v78 = *v22;
        uint64_t v79 = *(void *)(a3 + 64);
      }
      __int16 v80 = *(_WORD *)(a3 + 72);
      uint64_t v66 = 0;
      uint64_t v67 = 0;
      long long v65 = 0;
      sub_10005C928(&v65, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
      long long v32 = (long long *)(a2 + 24);
      if (*(char *)(a2 + 47) < 0)
      {
        sub_10004FC84(&v68, *(void **)(a2 + 24), *(void *)(a2 + 32));
      }
      else
      {
        long long v68 = *v32;
        uint64_t v69 = *(void *)(a2 + 40);
      }
      uint64_t v33 = (long long *)(a2 + 48);
      if (*(char *)(a2 + 71) < 0)
      {
        sub_10004FC84(&v70, *(void **)(a2 + 48), *(void *)(a2 + 56));
      }
      else
      {
        long long v70 = *v33;
        uint64_t v71 = *(void *)(a2 + 64);
      }
      __int16 v72 = *(_WORD *)(a2 + 72);
      long long v34 = (unsigned __int8 *)v73;
      uint64_t v35 = (unsigned __int8 *)v65;
      int64_t v36 = v74 - (unsigned char *)v73;
      int64_t v37 = v66 - (unsigned char *)v65;
      if (v66 - (unsigned char *)v65 >= v74 - (unsigned char *)v73) {
        uint64_t v38 = v74 - (unsigned char *)v73;
      }
      else {
        uint64_t v38 = v66 - (unsigned char *)v65;
      }
      if (v38 < 1)
      {
LABEL_99:
        if (v36 < v37) {
          char v41 = -1;
        }
        else {
          char v41 = 1;
        }
        if (v36 == v37) {
          char v42 = 0;
        }
        else {
          char v42 = v41;
        }
      }
      else
      {
        while (1)
        {
          unsigned int v39 = *v34;
          unsigned int v40 = *v35;
          if (v39 != v40) {
            break;
          }
          ++v34;
          ++v35;
          if (!--v38) {
            goto LABEL_99;
          }
        }
        if (v39 < v40) {
          char v42 = -1;
        }
        else {
          char v42 = 1;
        }
      }
      if (SHIBYTE(v71) < 0) {
        operator delete((void *)v70);
      }
      if (SHIBYTE(v69) < 0) {
        operator delete((void *)v68);
      }
      if (v65)
      {
        uint64_t v66 = v65;
        operator delete(v65);
      }
      if (SHIBYTE(v79) < 0) {
        operator delete((void *)v78);
      }
      if (SHIBYTE(v77) < 0) {
        operator delete((void *)v76);
      }
      if (v73)
      {
        unint64_t v74 = v73;
        operator delete(v73);
      }
      if (v42 < 0)
      {
        sub_1007A0A70(a2, a3);
        unsigned int v57 = 0;
        unsigned int v58 = 0;
        uint64_t v59 = 0;
        sub_10005C928(&v57, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
        if (*(char *)(a2 + 47) < 0)
        {
          sub_10004FC84(&v60, *(void **)(a2 + 24), *(void *)(a2 + 32));
        }
        else
        {
          long long v60 = *v32;
          uint64_t v61 = *(void *)(a2 + 40);
        }
        if (*(char *)(a2 + 71) < 0)
        {
          sub_10004FC84(&v62, *(void **)(a2 + 48), *(void *)(a2 + 56));
        }
        else
        {
          long long v62 = *v33;
          uint64_t v63 = *(void *)(a2 + 64);
        }
        __int16 v64 = *(_WORD *)(a2 + 72);
        long long v50 = 0;
        uint64_t v51 = 0;
        uint64_t v49 = 0;
        sub_10005C928(&v49, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
        if (*(char *)(a1 + 47) < 0)
        {
          sub_10004FC84(&v52, *(void **)(a1 + 24), *(void *)(a1 + 32));
        }
        else
        {
          long long v52 = *(_OWORD *)(a1 + 24);
          uint64_t v53 = *(void *)(a1 + 40);
        }
        if (*(char *)(a1 + 71) < 0)
        {
          sub_10004FC84(&v54, *(void **)(a1 + 48), *(void *)(a1 + 56));
        }
        else
        {
          long long v54 = *(_OWORD *)(a1 + 48);
          uint64_t v55 = *(void *)(a1 + 64);
        }
        __int16 v56 = *(_WORD *)(a1 + 72);
        int64_t v43 = (unsigned __int8 *)v57;
        unsigned int v44 = (unsigned __int8 *)v49;
        if (v50 - (unsigned char *)v49 >= v58 - (unsigned char *)v57) {
          uint64_t v45 = v58 - (unsigned char *)v57;
        }
        else {
          uint64_t v45 = v50 - (unsigned char *)v49;
        }
        if (v45 < 1)
        {
LABEL_139:
          BOOL v48 = v58 - (unsigned char *)v57 < v50 - (unsigned char *)v49;
        }
        else
        {
          while (1)
          {
            unsigned int v46 = *v43;
            unsigned int v47 = *v44;
            if (v46 != v47) {
              break;
            }
            ++v43;
            ++v44;
            if (!--v45) {
              goto LABEL_139;
            }
          }
          BOOL v48 = v46 < v47;
        }
        if (SHIBYTE(v55) < 0) {
          operator delete((void *)v54);
        }
        if (SHIBYTE(v53) < 0) {
          operator delete((void *)v52);
        }
        if (v49)
        {
          long long v50 = v49;
          operator delete(v49);
        }
        if (SHIBYTE(v63) < 0) {
          operator delete((void *)v62);
        }
        if (SHIBYTE(v61) < 0) {
          operator delete((void *)v60);
        }
        if (v57)
        {
          unsigned int v58 = v57;
          operator delete(v57);
        }
        if (v48) {
          sub_1007A0A70(a1, a2);
        }
      }
    }
  }
}

void sub_1007A543C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a9) {
    operator delete(a9);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a22)
  {
    void *v36 = a22;
    operator delete(a22);
  }
  _Unwind_Resume(a1);
}

void sub_1007A5608(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int64_t v125 = 0;
  int64_t v126 = 0;
  uint64_t v127 = 0;
  sub_10005C928(&v125, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  uint64_t v6 = (long long *)(a2 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(&v128, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v128 = *v6;
    uint64_t v129 = *(void *)(a2 + 40);
  }
  char v7 = (long long *)(a2 + 48);
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84(&v130, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v130 = *v7;
    uint64_t v131 = *(void *)(a2 + 64);
  }
  __int16 v132 = *(_WORD *)(a2 + 72);
  uint64_t v118 = 0;
  uint64_t v119 = 0;
  long long v117 = 0;
  sub_10005C928(&v117, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  unint64_t v8 = (long long *)(a1 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    sub_10004FC84(&v120, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    long long v120 = *v8;
    uint64_t v121 = *(void *)(a1 + 40);
  }
  uint64_t v9 = (long long *)(a1 + 48);
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(&v122, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    long long v122 = *v9;
    uint64_t v123 = *(void *)(a1 + 64);
  }
  __int16 v124 = *(_WORD *)(a1 + 72);
  unint64_t v10 = v125;
  char v11 = v117;
  int64_t v12 = v126 - v125;
  int64_t v13 = v118 - v117;
  if (v118 - v117 >= v126 - v125) {
    uint64_t v14 = v126 - v125;
  }
  else {
    uint64_t v14 = v118 - v117;
  }
  if (v14 < 1)
  {
LABEL_19:
    if (v12 < v13) {
      char v17 = -1;
    }
    else {
      char v17 = 1;
    }
    if (v12 == v13) {
      char v18 = 0;
    }
    else {
      char v18 = v17;
    }
  }
  else
  {
    while (1)
    {
      unsigned int v15 = *v10;
      unsigned int v16 = *v11;
      if (v15 != v16) {
        break;
      }
      ++v10;
      ++v11;
      if (!--v14) {
        goto LABEL_19;
      }
    }
    if (v15 < v16) {
      char v18 = -1;
    }
    else {
      char v18 = 1;
    }
  }
  if (SHIBYTE(v123) < 0) {
    operator delete((void *)v122);
  }
  if (SHIBYTE(v121) < 0) {
    operator delete((void *)v120);
  }
  if (v117)
  {
    uint64_t v118 = v117;
    operator delete(v117);
  }
  if (SHIBYTE(v131) < 0) {
    operator delete((void *)v130);
  }
  if (SHIBYTE(v129) < 0) {
    operator delete((void *)v128);
  }
  if (v125)
  {
    int64_t v126 = v125;
    operator delete(v125);
  }
  char v19 = (long long *)(a3 + 24);
  if (v18 < 0)
  {
    uint64_t v77 = 0;
    long long v78 = 0;
    uint64_t v79 = 0;
    sub_10005C928(&v77, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    if (*(char *)(a3 + 47) < 0)
    {
      sub_10004FC84(&v80, *(void **)(a3 + 24), *(void *)(a3 + 32));
    }
    else
    {
      long long v80 = *v19;
      uint64_t v81 = *(void *)(a3 + 40);
    }
    unsigned int v29 = (long long *)(a3 + 48);
    if (*(char *)(a3 + 71) < 0)
    {
      sub_10004FC84(&v82, *(void **)(a3 + 48), *(void *)(a3 + 56));
    }
    else
    {
      long long v82 = *v29;
      uint64_t v83 = *(void *)(a3 + 64);
    }
    __int16 v84 = *(_WORD *)(a3 + 72);
    long long v70 = 0;
    uint64_t v71 = 0;
    uint64_t v69 = 0;
    sub_10005C928(&v69, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    if (*(char *)(a2 + 47) < 0)
    {
      sub_10004FC84(&v72, *(void **)(a2 + 24), *(void *)(a2 + 32));
    }
    else
    {
      long long v72 = *v6;
      uint64_t v73 = *(void *)(a2 + 40);
    }
    if (*(char *)(a2 + 71) < 0)
    {
      sub_10004FC84(&v74, *(void **)(a2 + 48), *(void *)(a2 + 56));
    }
    else
    {
      long long v74 = *v7;
      uint64_t v75 = *(void *)(a2 + 64);
    }
    __int16 v76 = *(_WORD *)(a2 + 72);
    char v30 = (unsigned __int8 *)v77;
    char v31 = (unsigned __int8 *)v69;
    int64_t v32 = v78 - (unsigned char *)v77;
    int64_t v33 = v70 - (unsigned char *)v69;
    if (v70 - (unsigned char *)v69 >= v78 - (unsigned char *)v77) {
      uint64_t v34 = v78 - (unsigned char *)v77;
    }
    else {
      uint64_t v34 = v70 - (unsigned char *)v69;
    }
    if (v34 < 1)
    {
LABEL_101:
      if (v32 < v33) {
        char v37 = -1;
      }
      else {
        char v37 = 1;
      }
      if (v32 == v33) {
        char v38 = 0;
      }
      else {
        char v38 = v37;
      }
    }
    else
    {
      while (1)
      {
        unsigned int v35 = *v30;
        unsigned int v36 = *v31;
        if (v35 != v36) {
          break;
        }
        ++v30;
        ++v31;
        if (!--v34) {
          goto LABEL_101;
        }
      }
      if (v35 < v36) {
        char v38 = -1;
      }
      else {
        char v38 = 1;
      }
    }
    if (SHIBYTE(v75) < 0) {
      operator delete((void *)v74);
    }
    if (SHIBYTE(v73) < 0) {
      operator delete((void *)v72);
    }
    if (v69)
    {
      long long v70 = v69;
      operator delete(v69);
    }
    if (SHIBYTE(v83) < 0) {
      operator delete((void *)v82);
    }
    if (SHIBYTE(v81) < 0) {
      operator delete((void *)v80);
    }
    if (v77)
    {
      long long v78 = v77;
      operator delete(v77);
    }
    uint64_t v39 = a1;
    if ((v38 & 0x80) == 0)
    {
      sub_1007A0A70(a1, a2);
      uint64_t v61 = 0;
      long long v62 = 0;
      uint64_t v63 = 0;
      sub_10005C928(&v61, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
      if (*(char *)(a3 + 47) < 0)
      {
        sub_10004FC84(&v64, *(void **)(a3 + 24), *(void *)(a3 + 32));
      }
      else
      {
        long long v64 = *v19;
        uint64_t v65 = *(void *)(a3 + 40);
      }
      if (*(char *)(a3 + 71) < 0)
      {
        sub_10004FC84(&v66, *(void **)(a3 + 48), *(void *)(a3 + 56));
      }
      else
      {
        long long v66 = *v29;
        uint64_t v67 = *(void *)(a3 + 64);
      }
      __int16 v68 = *(_WORD *)(a3 + 72);
      long long v54 = 0;
      uint64_t v55 = 0;
      uint64_t v53 = 0;
      sub_10005C928(&v53, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
      if (*(char *)(a2 + 47) < 0)
      {
        sub_10004FC84(&v56, *(void **)(a2 + 24), *(void *)(a2 + 32));
      }
      else
      {
        long long v56 = *v6;
        uint64_t v57 = *(void *)(a2 + 40);
      }
      if (*(char *)(a2 + 71) < 0)
      {
        sub_10004FC84(&v58, *(void **)(a2 + 48), *(void *)(a2 + 56));
      }
      else
      {
        long long v58 = *v7;
        uint64_t v59 = *(void *)(a2 + 64);
      }
      __int16 v60 = *(_WORD *)(a2 + 72);
      unsigned int v46 = (unsigned __int8 *)v61;
      unsigned int v47 = (unsigned __int8 *)v53;
      if (v54 - (unsigned char *)v53 >= v62 - (unsigned char *)v61) {
        uint64_t v48 = v62 - (unsigned char *)v61;
      }
      else {
        uint64_t v48 = v54 - (unsigned char *)v53;
      }
      if (v48 < 1)
      {
LABEL_158:
        BOOL v51 = v62 - (unsigned char *)v61 < v54 - (unsigned char *)v53;
      }
      else
      {
        while (1)
        {
          unsigned int v49 = *v46;
          unsigned int v50 = *v47;
          if (v49 != v50) {
            break;
          }
          ++v46;
          ++v47;
          if (!--v48) {
            goto LABEL_158;
          }
        }
        BOOL v51 = v49 < v50;
      }
      if (SHIBYTE(v59) < 0) {
        operator delete((void *)v58);
      }
      if (SHIBYTE(v57) < 0) {
        operator delete((void *)v56);
      }
      if (v53)
      {
        long long v54 = v53;
        operator delete(v53);
      }
      if (SHIBYTE(v67) < 0) {
        operator delete((void *)v66);
      }
      if (SHIBYTE(v65) < 0) {
        operator delete((void *)v64);
      }
      if (v61)
      {
        long long v62 = v61;
        operator delete(v61);
      }
      if (!v51) {
        return;
      }
      uint64_t v39 = a2;
    }
    uint64_t v52 = a3;
    goto LABEL_190;
  }
  long long v110 = 0;
  uint64_t v109 = 0;
  uint64_t v111 = 0;
  sub_10005C928(&v109, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  if (*(char *)(a3 + 47) < 0)
  {
    sub_10004FC84(&v112, *(void **)(a3 + 24), *(void *)(a3 + 32));
  }
  else
  {
    long long v112 = *v19;
    uint64_t v113 = *(void *)(a3 + 40);
  }
  if (*(char *)(a3 + 71) < 0)
  {
    sub_10004FC84(&v114, *(void **)(a3 + 48), *(void *)(a3 + 56));
  }
  else
  {
    long long v114 = *(_OWORD *)(a3 + 48);
    uint64_t v115 = *(void *)(a3 + 64);
  }
  __int16 v116 = *(_WORD *)(a3 + 72);
  long long v102 = 0;
  uint64_t v103 = 0;
  uint64_t v101 = 0;
  sub_10005C928(&v101, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(&v104, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v104 = *v6;
    uint64_t v105 = *(void *)(a2 + 40);
  }
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long __p = *v7;
    uint64_t v107 = *(void *)(a2 + 64);
  }
  __int16 v108 = *(_WORD *)(a2 + 72);
  char v20 = (unsigned __int8 *)v109;
  int64_t v21 = (unsigned __int8 *)v101;
  int64_t v22 = v110 - (unsigned char *)v109;
  int64_t v23 = v102 - (unsigned char *)v101;
  if (v102 - (unsigned char *)v101 >= v110 - (unsigned char *)v109) {
    uint64_t v24 = v110 - (unsigned char *)v109;
  }
  else {
    uint64_t v24 = v102 - (unsigned char *)v101;
  }
  if (v24 < 1)
  {
LABEL_61:
    if (v22 < v23) {
      char v27 = -1;
    }
    else {
      char v27 = 1;
    }
    if (v22 == v23) {
      char v28 = 0;
    }
    else {
      char v28 = v27;
    }
  }
  else
  {
    while (1)
    {
      unsigned int v25 = *v20;
      unsigned int v26 = *v21;
      if (v25 != v26) {
        break;
      }
      ++v20;
      ++v21;
      if (!--v24) {
        goto LABEL_61;
      }
    }
    if (v25 < v26) {
      char v28 = -1;
    }
    else {
      char v28 = 1;
    }
  }
  if (SHIBYTE(v107) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v105) < 0) {
    operator delete((void *)v104);
  }
  if (v101)
  {
    long long v102 = v101;
    operator delete(v101);
  }
  if (SHIBYTE(v115) < 0) {
    operator delete((void *)v114);
  }
  if (SHIBYTE(v113) < 0) {
    operator delete((void *)v112);
  }
  if (v109)
  {
    long long v110 = v109;
    operator delete(v109);
  }
  if (v28 < 0)
  {
    sub_1007A0A70(a2, a3);
    uint64_t v93 = 0;
    long long v94 = 0;
    uint64_t v95 = 0;
    sub_10005C928(&v93, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    if (*(char *)(a2 + 47) < 0)
    {
      sub_10004FC84(&v96, *(void **)(a2 + 24), *(void *)(a2 + 32));
    }
    else
    {
      long long v96 = *v6;
      uint64_t v97 = *(void *)(a2 + 40);
    }
    if (*(char *)(a2 + 71) < 0)
    {
      sub_10004FC84(&v98, *(void **)(a2 + 48), *(void *)(a2 + 56));
    }
    else
    {
      long long v98 = *v7;
      uint64_t v99 = *(void *)(a2 + 64);
    }
    __int16 v100 = *(_WORD *)(a2 + 72);
    int64_t v86 = 0;
    uint64_t v87 = 0;
    uint64_t v85 = 0;
    sub_10005C928(&v85, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(&v88, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      long long v88 = *v8;
      uint64_t v89 = *(void *)(a1 + 40);
    }
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(&v90, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      long long v90 = *v9;
      uint64_t v91 = *(void *)(a1 + 64);
    }
    __int16 v92 = *(_WORD *)(a1 + 72);
    unsigned int v40 = (unsigned __int8 *)v93;
    char v41 = (unsigned __int8 *)v85;
    uint64_t v42 = v86 - (unsigned char *)v85 >= v94 - (unsigned char *)v93 ? v94 - (unsigned char *)v93 : v86 - (unsigned char *)v85;
    if (v42 < 1)
    {
LABEL_150:
      BOOL v45 = v94 - (unsigned char *)v93 < v86 - (unsigned char *)v85;
    }
    else
    {
      while (1)
      {
        unsigned int v43 = *v40;
        unsigned int v44 = *v41;
        if (v43 != v44) {
          break;
        }
        ++v40;
        ++v41;
        if (!--v42) {
          goto LABEL_150;
        }
      }
      BOOL v45 = v43 < v44;
    }
    if (SHIBYTE(v91) < 0) {
      operator delete((void *)v90);
    }
    if (SHIBYTE(v89) < 0) {
      operator delete((void *)v88);
    }
    if (v85)
    {
      int64_t v86 = v85;
      operator delete(v85);
    }
    if (SHIBYTE(v99) < 0) {
      operator delete((void *)v98);
    }
    if (SHIBYTE(v97) < 0) {
      operator delete((void *)v96);
    }
    if (v93)
    {
      long long v94 = v93;
      operator delete(v93);
    }
    if (v45)
    {
      uint64_t v39 = a1;
      uint64_t v52 = a2;
LABEL_190:
      sub_1007A0A70(v39, v52);
    }
  }
}

void sub_1007A5F08(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, void *__p, uint64_t a6, int a7, __int16 a8, char a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  if (a10 < 0) {
    operator delete(__p);
  }
  if (a2) {
    operator delete(a2);
  }
  sub_10079AB58((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t sub_1007A611C(uint64_t a1, unint64_t a2)
{
  char v4 = *(const void **)a1;
  *(_OWORD *)&v173[8] = *(_OWORD *)(a1 + 8);
  uint64_t v5 = *(void *)&v173[8];
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  long long v174 = *(_OWORD *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 40);
  *(void *)unsigned int v173 = v4;
  uint64_t v175 = v6;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  long long v176 = *(_OWORD *)(a1 + 48);
  uint64_t v177 = *(void *)(a1 + 64);
  uint64_t v178 = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  LOWORD(v178) = *(_WORD *)(a1 + 72);
  long long v165 = 0;
  long long v166 = 0;
  uint64_t v167 = 0;
  sub_10005C928(&v165, v4, v5, v5 - (void)v4);
  if (SHIBYTE(v175) < 0)
  {
    sub_10004FC84(&v168, (void *)v174, *((unint64_t *)&v174 + 1));
  }
  else
  {
    long long v168 = v174;
    uint64_t v169 = v175;
  }
  if (SHIBYTE(v177) < 0)
  {
    sub_10004FC84(&v170, (void *)v176, *((unint64_t *)&v176 + 1));
  }
  else
  {
    long long v170 = v176;
    uint64_t v171 = v177;
  }
  __int16 v172 = v178;
  uint64_t v159 = 0;
  uint64_t v157 = 0;
  unint64_t v158 = 0;
  sub_10005C928(&v157, *(const void **)(a2 - 80), *(void *)(a2 - 72), *(void *)(a2 - 72) - *(void *)(a2 - 80));
  if (*(char *)(a2 - 33) < 0)
  {
    sub_10004FC84(&v160, *(void **)(a2 - 56), *(void *)(a2 - 48));
  }
  else
  {
    long long v160 = *(_OWORD *)(a2 - 56);
    uint64_t v161 = *(void *)(a2 - 40);
  }
  if (*(char *)(a2 - 9) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a2 - 32), *(void *)(a2 - 24));
  }
  else
  {
    long long __p = *(_OWORD *)(a2 - 32);
    uint64_t v163 = *(void *)(a2 - 16);
  }
  __int16 v164 = *(_WORD *)(a2 - 8);
  char v7 = v165;
  unint64_t v8 = (unsigned __int8 *)v157;
  int64_t v9 = v166 - v165;
  int64_t v10 = v158 - (unsigned char *)v157;
  if (v158 - (unsigned char *)v157 >= v166 - v165) {
    uint64_t v11 = v166 - v165;
  }
  else {
    uint64_t v11 = v158 - (unsigned char *)v157;
  }
  if (v11 < 1)
  {
LABEL_19:
    if (v9 < v10) {
      char v14 = -1;
    }
    else {
      char v14 = 1;
    }
    if (v9 == v10) {
      char v15 = 0;
    }
    else {
      char v15 = v14;
    }
  }
  else
  {
    while (1)
    {
      unsigned int v12 = *v7;
      unsigned int v13 = *v8;
      if (v12 != v13) {
        break;
      }
      ++v7;
      ++v8;
      if (!--v11) {
        goto LABEL_19;
      }
    }
    if (v12 < v13) {
      char v15 = -1;
    }
    else {
      char v15 = 1;
    }
  }
  if (SHIBYTE(v163) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v161) < 0) {
    operator delete((void *)v160);
  }
  if (v157)
  {
    unint64_t v158 = v157;
    operator delete(v157);
  }
  if (SHIBYTE(v171) < 0) {
    operator delete((void *)v170);
  }
  if (SHIBYTE(v169) < 0) {
    operator delete((void *)v168);
  }
  if (v165)
  {
    long long v166 = v165;
    operator delete(v165);
  }
  if (v15 < 0)
  {
    unint64_t v16 = a1;
    do
    {
      uint64_t v150 = 0;
      char v149 = 0;
      uint64_t v151 = 0;
      sub_10005C928(&v149, *(const void **)v173, *(uint64_t *)&v173[8], *(void *)&v173[8] - *(void *)v173);
      if (SHIBYTE(v175) < 0)
      {
        sub_10004FC84(&v152, (void *)v174, *((unint64_t *)&v174 + 1));
      }
      else
      {
        long long v152 = v174;
        uint64_t v153 = v175;
      }
      if (SHIBYTE(v177) < 0)
      {
        sub_10004FC84(&v154, (void *)v176, *((unint64_t *)&v176 + 1));
      }
      else
      {
        long long v154 = v176;
        uint64_t v155 = v177;
      }
      __int16 v156 = v178;
      uint64_t v143 = 0;
      char v141 = 0;
      long long v142 = 0;
      sub_10005C928(&v141, *(const void **)(v16 + 80), *(void *)(v16 + 88), *(void *)(v16 + 88) - *(void *)(v16 + 80));
      if (*(char *)(v16 + 127) < 0)
      {
        sub_10004FC84(&v144, *(void **)(v16 + 104), *(void *)(v16 + 112));
      }
      else
      {
        long long v144 = *(_OWORD *)(v16 + 104);
        uint64_t v145 = *(void *)(v16 + 120);
      }
      if (*(char *)(v16 + 151) < 0)
      {
        sub_10004FC84(&v146, *(void **)(v16 + 128), *(void *)(v16 + 136));
      }
      else
      {
        long long v146 = *(_OWORD *)(v16 + 128);
        uint64_t v147 = *(void *)(v16 + 144);
      }
      __int16 v148 = *(_WORD *)(v16 + 152);
      char v28 = (unsigned __int8 *)v149;
      unsigned int v29 = (unsigned __int8 *)v141;
      int64_t v30 = v150 - (unsigned char *)v149;
      int64_t v31 = v142 - (unsigned char *)v141;
      if (v142 - (unsigned char *)v141 >= v150 - (unsigned char *)v149) {
        uint64_t v32 = v150 - (unsigned char *)v149;
      }
      else {
        uint64_t v32 = v142 - (unsigned char *)v141;
      }
      if (v32 < 1)
      {
LABEL_104:
        if (v30 < v31) {
          char v35 = -1;
        }
        else {
          char v35 = 1;
        }
        if (v30 == v31) {
          char v36 = 0;
        }
        else {
          char v36 = v35;
        }
      }
      else
      {
        while (1)
        {
          unsigned int v33 = *v28;
          unsigned int v34 = *v29;
          if (v33 != v34) {
            break;
          }
          ++v28;
          ++v29;
          if (!--v32) {
            goto LABEL_104;
          }
        }
        if (v33 < v34) {
          char v36 = -1;
        }
        else {
          char v36 = 1;
        }
      }
      if (SHIBYTE(v147) < 0) {
        operator delete((void *)v146);
      }
      if (SHIBYTE(v145) < 0) {
        operator delete((void *)v144);
      }
      if (v141)
      {
        long long v142 = v141;
        operator delete(v141);
      }
      if (SHIBYTE(v155) < 0) {
        operator delete((void *)v154);
      }
      if (SHIBYTE(v153) < 0) {
        operator delete((void *)v152);
      }
      if (v149)
      {
        uint64_t v150 = v149;
        operator delete(v149);
      }
      v16 += 80;
    }
    while ((v36 & 0x80) == 0);
  }
  else
  {
    unint64_t v16 = a1 + 80;
    if (a1 + 80 < a2)
    {
      uint64_t v17 = a1;
      while (1)
      {
        unint64_t v18 = v16;
        uint64_t v134 = 0;
        unint64_t v133 = 0;
        uint64_t v135 = 0;
        sub_10005C928(&v133, *(const void **)v173, *(uint64_t *)&v173[8], *(void *)&v173[8] - *(void *)v173);
        if (SHIBYTE(v175) < 0)
        {
          sub_10004FC84(&v136, (void *)v174, *((unint64_t *)&v174 + 1));
        }
        else
        {
          long long v136 = v174;
          uint64_t v137 = v175;
        }
        if (SHIBYTE(v177) < 0)
        {
          sub_10004FC84(&v138, (void *)v176, *((unint64_t *)&v176 + 1));
        }
        else
        {
          long long v138 = v176;
          uint64_t v139 = v177;
        }
        __int16 v140 = v178;
        uint64_t v127 = 0;
        int64_t v125 = 0;
        int64_t v126 = 0;
        sub_10005C928(&v125, *(const void **)v16, *(void *)(v17 + 88), *(void *)(v17 + 88) - *(void *)v16);
        if (*(char *)(v17 + 127) < 0)
        {
          sub_10004FC84(&v128, *(void **)(v17 + 104), *(void *)(v17 + 112));
        }
        else
        {
          long long v128 = *(_OWORD *)(v17 + 104);
          uint64_t v129 = *(void *)(v17 + 120);
        }
        if (*(char *)(v17 + 151) < 0)
        {
          sub_10004FC84(&v130, *(void **)(v17 + 128), *(void *)(v17 + 136));
        }
        else
        {
          long long v130 = *(_OWORD *)(v17 + 128);
          uint64_t v131 = *(void *)(v17 + 144);
        }
        __int16 v132 = *(_WORD *)(v17 + 152);
        char v19 = (unsigned __int8 *)v133;
        char v20 = (unsigned __int8 *)v125;
        int64_t v21 = v134 - (unsigned char *)v133;
        int64_t v22 = v126 - (unsigned char *)v125;
        uint64_t v23 = v126 - (unsigned char *)v125 >= v134 - (unsigned char *)v133 ? v134 - (unsigned char *)v133 : v126 - (unsigned char *)v125;
        if (v23 < 1)
        {
LABEL_61:
          char v26 = v21 < v22 ? -1 : 1;
          char v27 = v21 == v22 ? 0 : v26;
        }
        else
        {
          while (1)
          {
            unsigned int v24 = *v19;
            unsigned int v25 = *v20;
            if (v24 != v25) {
              break;
            }
            ++v19;
            ++v20;
            if (!--v23) {
              goto LABEL_61;
            }
          }
          char v27 = v24 < v25 ? -1 : 1;
        }
        if (SHIBYTE(v131) < 0) {
          operator delete((void *)v130);
        }
        if (SHIBYTE(v129) < 0) {
          operator delete((void *)v128);
        }
        if (v125)
        {
          int64_t v126 = v125;
          operator delete(v125);
        }
        if (SHIBYTE(v139) < 0) {
          operator delete((void *)v138);
        }
        if (SHIBYTE(v137) < 0) {
          operator delete((void *)v136);
        }
        if (v133)
        {
          uint64_t v134 = v133;
          operator delete(v133);
        }
        if (v27 < 0) {
          break;
        }
        unint64_t v16 = v18 + 80;
        uint64_t v17 = v18;
        if (v18 + 80 >= a2) {
          goto LABEL_128;
        }
      }
      unint64_t v16 = v18;
    }
  }
LABEL_128:
  if (v16 < a2)
  {
    do
    {
      long long v117 = 0;
      uint64_t v118 = 0;
      uint64_t v119 = 0;
      sub_10005C928(&v117, *(const void **)v173, *(uint64_t *)&v173[8], *(void *)&v173[8] - *(void *)v173);
      if (SHIBYTE(v175) < 0)
      {
        sub_10004FC84(&v120, (void *)v174, *((unint64_t *)&v174 + 1));
      }
      else
      {
        long long v120 = v174;
        uint64_t v121 = v175;
      }
      if (SHIBYTE(v177) < 0)
      {
        sub_10004FC84(&v122, (void *)v176, *((unint64_t *)&v176 + 1));
      }
      else
      {
        long long v122 = v176;
        uint64_t v123 = v177;
      }
      __int16 v124 = v178;
      long long v110 = 0;
      uint64_t v111 = 0;
      uint64_t v109 = 0;
      sub_10005C928(&v109, *(const void **)(a2 - 80), *(void *)(a2 - 72), *(void *)(a2 - 72) - *(void *)(a2 - 80));
      if (*(char *)(a2 - 33) < 0)
      {
        sub_10004FC84(&v112, *(void **)(a2 - 56), *(void *)(a2 - 48));
      }
      else
      {
        long long v112 = *(_OWORD *)(a2 - 56);
        uint64_t v113 = *(void *)(a2 - 40);
      }
      if (*(char *)(a2 - 9) < 0)
      {
        sub_10004FC84(&v114, *(void **)(a2 - 32), *(void *)(a2 - 24));
      }
      else
      {
        long long v114 = *(_OWORD *)(a2 - 32);
        uint64_t v115 = *(void *)(a2 - 16);
      }
      __int16 v116 = *(_WORD *)(a2 - 8);
      char v37 = (unsigned __int8 *)v117;
      char v38 = (unsigned __int8 *)v109;
      int64_t v39 = v118 - (unsigned char *)v117;
      int64_t v40 = v110 - (unsigned char *)v109;
      if (v110 - (unsigned char *)v109 >= v118 - (unsigned char *)v117) {
        uint64_t v41 = v118 - (unsigned char *)v117;
      }
      else {
        uint64_t v41 = v110 - (unsigned char *)v109;
      }
      if (v41 < 1)
      {
LABEL_147:
        if (v39 < v40) {
          char v44 = -1;
        }
        else {
          char v44 = 1;
        }
        if (v39 == v40) {
          char v45 = 0;
        }
        else {
          char v45 = v44;
        }
      }
      else
      {
        while (1)
        {
          unsigned int v42 = *v37;
          unsigned int v43 = *v38;
          if (v42 != v43) {
            break;
          }
          ++v37;
          ++v38;
          if (!--v41) {
            goto LABEL_147;
          }
        }
        if (v42 < v43) {
          char v45 = -1;
        }
        else {
          char v45 = 1;
        }
      }
      if (SHIBYTE(v115) < 0) {
        operator delete((void *)v114);
      }
      if (SHIBYTE(v113) < 0) {
        operator delete((void *)v112);
      }
      if (v109)
      {
        long long v110 = v109;
        operator delete(v109);
      }
      if (SHIBYTE(v123) < 0) {
        operator delete((void *)v122);
      }
      if (SHIBYTE(v121) < 0) {
        operator delete((void *)v120);
      }
      if (v117)
      {
        uint64_t v118 = v117;
        operator delete(v117);
      }
      a2 -= 80;
    }
    while (v45 < 0);
  }
  while (v16 < a2)
  {
    sub_1007A0A70(v16, a2);
    do
    {
      uint64_t v101 = 0;
      long long v102 = 0;
      uint64_t v103 = 0;
      sub_10005C928(&v101, *(const void **)v173, *(uint64_t *)&v173[8], *(void *)&v173[8] - *(void *)v173);
      if (SHIBYTE(v175) < 0)
      {
        sub_10004FC84(&v104, (void *)v174, *((unint64_t *)&v174 + 1));
      }
      else
      {
        long long v104 = v174;
        uint64_t v105 = v175;
      }
      if (SHIBYTE(v177) < 0)
      {
        sub_10004FC84(&v106, (void *)v176, *((unint64_t *)&v176 + 1));
      }
      else
      {
        long long v106 = v176;
        uint64_t v107 = v177;
      }
      __int16 v108 = v178;
      long long v94 = 0;
      uint64_t v95 = 0;
      uint64_t v93 = 0;
      sub_10005C928(&v93, *(const void **)(v16 + 80), *(void *)(v16 + 88), *(void *)(v16 + 88) - *(void *)(v16 + 80));
      if (*(char *)(v16 + 127) < 0)
      {
        sub_10004FC84(&v96, *(void **)(v16 + 104), *(void *)(v16 + 112));
      }
      else
      {
        long long v96 = *(_OWORD *)(v16 + 104);
        uint64_t v97 = *(void *)(v16 + 120);
      }
      if (*(char *)(v16 + 151) < 0)
      {
        sub_10004FC84(&v98, *(void **)(v16 + 128), *(void *)(v16 + 136));
      }
      else
      {
        long long v98 = *(_OWORD *)(v16 + 128);
        uint64_t v99 = *(void *)(v16 + 144);
      }
      __int16 v100 = *(_WORD *)(v16 + 152);
      unsigned int v46 = (unsigned __int8 *)v101;
      unsigned int v47 = (unsigned __int8 *)v93;
      int64_t v48 = v102 - (unsigned char *)v101;
      int64_t v49 = v94 - (unsigned char *)v93;
      if (v94 - (unsigned char *)v93 >= v102 - (unsigned char *)v101) {
        uint64_t v50 = v102 - (unsigned char *)v101;
      }
      else {
        uint64_t v50 = v94 - (unsigned char *)v93;
      }
      if (v50 < 1)
      {
LABEL_189:
        if (v48 < v49) {
          char v53 = -1;
        }
        else {
          char v53 = 1;
        }
        if (v48 == v49) {
          char v54 = 0;
        }
        else {
          char v54 = v53;
        }
      }
      else
      {
        while (1)
        {
          unsigned int v51 = *v46;
          unsigned int v52 = *v47;
          if (v51 != v52) {
            break;
          }
          ++v46;
          ++v47;
          if (!--v50) {
            goto LABEL_189;
          }
        }
        if (v51 < v52) {
          char v54 = -1;
        }
        else {
          char v54 = 1;
        }
      }
      if (SHIBYTE(v99) < 0) {
        operator delete((void *)v98);
      }
      if (SHIBYTE(v97) < 0) {
        operator delete((void *)v96);
      }
      if (v93)
      {
        long long v94 = v93;
        operator delete(v93);
      }
      if (SHIBYTE(v107) < 0) {
        operator delete((void *)v106);
      }
      if (SHIBYTE(v105) < 0) {
        operator delete((void *)v104);
      }
      if (v101)
      {
        long long v102 = v101;
        operator delete(v101);
      }
      v16 += 80;
    }
    while ((v54 & 0x80) == 0);
    do
    {
      uint64_t v85 = 0;
      int64_t v86 = 0;
      uint64_t v87 = 0;
      sub_10005C928(&v85, *(const void **)v173, *(uint64_t *)&v173[8], *(void *)&v173[8] - *(void *)v173);
      if (SHIBYTE(v175) < 0)
      {
        sub_10004FC84(&v88, (void *)v174, *((unint64_t *)&v174 + 1));
      }
      else
      {
        long long v88 = v174;
        uint64_t v89 = v175;
      }
      if (SHIBYTE(v177) < 0)
      {
        sub_10004FC84(&v90, (void *)v176, *((unint64_t *)&v176 + 1));
      }
      else
      {
        long long v90 = v176;
        uint64_t v91 = v177;
      }
      __int16 v92 = v178;
      long long v78 = 0;
      uint64_t v79 = 0;
      uint64_t v77 = 0;
      sub_10005C928(&v77, *(const void **)(a2 - 80), *(void *)(a2 - 72), *(void *)(a2 - 72) - *(void *)(a2 - 80));
      if (*(char *)(a2 - 33) < 0)
      {
        sub_10004FC84(&v80, *(void **)(a2 - 56), *(void *)(a2 - 48));
      }
      else
      {
        long long v55 = *(_OWORD *)(a2 - 56);
        uint64_t v81 = *(void *)(a2 - 40);
        long long v80 = v55;
      }
      if (*(char *)(a2 - 9) < 0)
      {
        sub_10004FC84(&v82, *(void **)(a2 - 32), *(void *)(a2 - 24));
      }
      else
      {
        long long v56 = *(_OWORD *)(a2 - 32);
        uint64_t v83 = *(void *)(a2 - 16);
        long long v82 = v56;
      }
      __int16 v84 = *(_WORD *)(a2 - 8);
      uint64_t v57 = (unsigned __int8 *)v85;
      long long v58 = (unsigned __int8 *)v77;
      int64_t v59 = v86 - (unsigned char *)v85;
      int64_t v60 = v78 - (unsigned char *)v77;
      if (v78 - (unsigned char *)v77 >= v86 - (unsigned char *)v85) {
        uint64_t v61 = v86 - (unsigned char *)v85;
      }
      else {
        uint64_t v61 = v78 - (unsigned char *)v77;
      }
      if (v61 < 1)
      {
LABEL_229:
        if (v59 < v60) {
          char v64 = -1;
        }
        else {
          char v64 = 1;
        }
        if (v59 == v60) {
          char v65 = 0;
        }
        else {
          char v65 = v64;
        }
      }
      else
      {
        while (1)
        {
          unsigned int v62 = *v57;
          unsigned int v63 = *v58;
          if (v62 != v63) {
            break;
          }
          ++v57;
          ++v58;
          if (!--v61) {
            goto LABEL_229;
          }
        }
        if (v62 < v63) {
          char v65 = -1;
        }
        else {
          char v65 = 1;
        }
      }
      if (SHIBYTE(v83) < 0) {
        operator delete((void *)v82);
      }
      if (SHIBYTE(v81) < 0) {
        operator delete((void *)v80);
      }
      if (v77)
      {
        long long v78 = v77;
        operator delete(v77);
      }
      if (SHIBYTE(v91) < 0) {
        operator delete((void *)v90);
      }
      if (SHIBYTE(v89) < 0) {
        operator delete((void *)v88);
      }
      if (v85)
      {
        int64_t v86 = v85;
        operator delete(v85);
      }
      a2 -= 80;
    }
    while (v65 < 0);
  }
  long long v66 = (void **)(v16 - 80);
  if (v16 - 80 != a1)
  {
    uint64_t v67 = (void **)(a1 + 24);
    sub_10005C9A4(a1, (__n128 *)(v16 - 80));
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v67);
    }
    __int16 v68 = (void **)(a1 + 48);
    long long v69 = *(_OWORD *)(v16 - 56);
    *(void *)(a1 + 40) = *(void *)(v16 - 40);
    *(_OWORD *)uint64_t v67 = v69;
    *(unsigned char *)(v16 - 33) = 0;
    *(unsigned char *)(v16 - 56) = 0;
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*v68);
    }
    long long v70 = *(_OWORD *)(v16 - 32);
    *(void *)(a1 + 64) = *(void *)(v16 - 16);
    *(_OWORD *)__int16 v68 = v70;
    *(unsigned char *)(v16 - 9) = 0;
    *(unsigned char *)(v16 - 32) = 0;
    *(_WORD *)(a1 + 72) = *(_WORD *)(v16 - 8);
  }
  uint64_t v71 = *v66;
  if (*v66)
  {
    *(void *)(v16 - 72) = v71;
    operator delete(v71);
    *long long v66 = 0;
    *(void *)(v16 - 72) = 0;
    *(void *)(v16 - 64) = 0;
  }
  *(_OWORD *)(v16 - 80) = *(_OWORD *)v173;
  *(void *)(v16 - 64) = *(void *)&v173[16];
  memset(v173, 0, sizeof(v173));
  long long v72 = (void **)(v16 - 56);
  if (*(char *)(v16 - 33) < 0) {
    operator delete(*v72);
  }
  long long v73 = v174;
  *(void *)(v16 - 40) = v175;
  *(_OWORD *)long long v72 = v73;
  HIBYTE(v175) = 0;
  LOBYTE(v174) = 0;
  long long v74 = (void **)(v16 - 32);
  if (*(char *)(v16 - 9) < 0) {
    operator delete(*v74);
  }
  long long v75 = v176;
  *(void *)(v16 - 16) = v177;
  *(_OWORD *)long long v74 = v75;
  HIBYTE(v177) = 0;
  LOBYTE(v176) = 0;
  *(_WORD *)(v16 - 8) = v178;
  if (SHIBYTE(v177) < 0) {
    operator delete((void *)v176);
  }
  if (SHIBYTE(v175) < 0) {
    operator delete((void *)v174);
  }
  if (*(void *)v173)
  {
    *(void *)&v173[8] = *(void *)v173;
    operator delete(*(void **)v173);
  }
  return v16;
}

void sub_1007A6E40(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x36F]) < 0) {
    operator delete((void *)STACK[0x358]);
  }
  int v3 = (void *)STACK[0x340];
  if (STACK[0x340])
  {
    STACK[0x348] = (unint64_t)v3;
    operator delete(v3);
  }
  sub_10079AB58(v1 - 256);
  sub_10079AB58(v1 - 176);
  _Unwind_Resume(a1);
}

BOOL sub_1007A70E0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v6 = *(const void **)(a2 - 80);
      uint64_t v7 = *(void *)(v2 - 72);
      uint64_t v103 = 0;
      long long v104 = 0;
      uint64_t v105 = 0;
      sub_10005C928(&v103, v6, v7, v7 - (void)v6);
      if (*(char *)(v2 - 33) < 0)
      {
        sub_10004FC84(&v106, *(void **)(v2 - 56), *(void *)(v2 - 48));
      }
      else
      {
        long long v106 = *(_OWORD *)(v2 - 56);
        uint64_t v107 = *(void *)(v2 - 40);
      }
      if (*(char *)(v2 - 9) < 0)
      {
        sub_10004FC84(&v108, *(void **)(v2 - 32), *(void *)(v2 - 24));
      }
      else
      {
        long long v108 = *(_OWORD *)(v2 - 32);
        uint64_t v109 = *(void *)(v2 - 16);
      }
      __int16 v110 = *(_WORD *)(v2 - 8);
      long long v96 = 0;
      uint64_t v97 = 0;
      uint64_t v95 = 0;
      sub_10005C928(&v95, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
      if (*(char *)(a1 + 47) < 0)
      {
        sub_10004FC84(&v98, *(void **)(a1 + 24), *(void *)(a1 + 32));
      }
      else
      {
        long long v98 = *(_OWORD *)(a1 + 24);
        uint64_t v99 = *(void *)(a1 + 40);
      }
      if (*(char *)(a1 + 71) < 0)
      {
        sub_10004FC84(&v100, *(void **)(a1 + 48), *(void *)(a1 + 56));
      }
      else
      {
        long long v100 = *(_OWORD *)(a1 + 48);
        uint64_t v101 = *(void *)(a1 + 64);
      }
      __int16 v102 = *(_WORD *)(a1 + 72);
      unsigned int v47 = v103;
      int64_t v48 = v95;
      if (v96 - v95 >= v104 - v103) {
        uint64_t v49 = v104 - v103;
      }
      else {
        uint64_t v49 = v96 - v95;
      }
      if (v49 < 1) {
        goto LABEL_122;
      }
      while (1)
      {
        unsigned int v50 = *v47;
        unsigned int v51 = *v48;
        if (v50 != v51) {
          break;
        }
        ++v47;
        ++v48;
        if (!--v49)
        {
LABEL_122:
          BOOL v52 = v104 - v103 < v96 - v95;
LABEL_124:
          if (SHIBYTE(v101) < 0) {
            operator delete((void *)v100);
          }
          if (SHIBYTE(v99) < 0) {
            operator delete((void *)v98);
          }
          if (v95)
          {
            long long v96 = v95;
            operator delete(v95);
          }
          if (SHIBYTE(v109) < 0) {
            operator delete((void *)v108);
          }
          if (SHIBYTE(v107) < 0) {
            operator delete((void *)v106);
          }
          if (v103)
          {
            long long v104 = v103;
            operator delete(v103);
          }
          if (v52) {
            sub_1007A0A70(a1, v2 - 80);
          }
          return 1;
        }
      }
      BOOL v52 = v50 < v51;
      goto LABEL_124;
    case 3uLL:
      sub_1007A5608(a1, a1 + 80, a2 - 80);
      return 1;
    case 4uLL:
      sub_1007A7A90(a1, a1 + 80, a1 + 160, a2 - 80);
      return 1;
    case 5uLL:
      sub_1007A4CB8(a1, a1 + 80, a1 + 160, a1 + 240, a2 - 80);
      return 1;
    default:
      uint64_t v8 = a1 + 160;
      sub_1007A5608(a1, a1 + 80, a1 + 160);
      uint64_t v9 = a1 + 240;
      if (a1 + 240 == v2) {
        return 1;
      }
      int v54 = 0;
      uint64_t v55 = a1;
      uint64_t v53 = v2;
      break;
  }
  while (1)
  {
    uint64_t v87 = 0;
    long long v88 = 0;
    uint64_t v89 = 0;
    sub_10005C928(&v87, *(const void **)v9, *(void *)(v9 + 8), *(void *)(v9 + 8) - *(void *)v9);
    int64_t v10 = (long long *)(v9 + 24);
    if (*(char *)(v9 + 47) < 0)
    {
      sub_10004FC84(&v90, *(void **)(v9 + 24), *(void *)(v9 + 32));
    }
    else
    {
      long long v90 = *v10;
      uint64_t v91 = *(void *)(v9 + 40);
    }
    uint64_t v11 = (long long *)(v9 + 48);
    if (*(char *)(v9 + 71) < 0)
    {
      sub_10004FC84(&v92, *(void **)(v9 + 48), *(void *)(v9 + 56));
    }
    else
    {
      long long v92 = *v11;
      uint64_t v93 = *(void *)(v9 + 64);
    }
    __int16 v94 = *(_WORD *)(v9 + 72);
    long long v80 = 0;
    uint64_t v81 = 0;
    uint64_t v79 = 0;
    sub_10005C928(&v79, *(const void **)v8, *(void *)(v8 + 8), *(void *)(v8 + 8) - *(void *)v8);
    if (*(char *)(v8 + 47) < 0)
    {
      sub_10004FC84(&v82, *(void **)(v8 + 24), *(void *)(v8 + 32));
    }
    else
    {
      long long v12 = *(_OWORD *)(v8 + 24);
      uint64_t v83 = *(void *)(v8 + 40);
      long long v82 = v12;
    }
    if (*(char *)(v8 + 71) < 0)
    {
      sub_10004FC84(&__p, *(void **)(v8 + 48), *(void *)(v8 + 56));
    }
    else
    {
      long long v13 = *(_OWORD *)(v8 + 48);
      uint64_t v85 = *(void *)(v8 + 64);
      long long __p = v13;
    }
    __int16 v86 = *(_WORD *)(v8 + 72);
    char v14 = (unsigned __int8 *)v87;
    char v15 = (unsigned __int8 *)v79;
    int64_t v16 = v88 - (unsigned char *)v87;
    int64_t v17 = v80 - (unsigned char *)v79;
    uint64_t v18 = v80 - (unsigned char *)v79 >= v88 - (unsigned char *)v87 ? v88 - (unsigned char *)v87 : v80 - (unsigned char *)v79;
    if (v18 < 1)
    {
LABEL_24:
      char v21 = v16 < v17 ? -1 : 1;
      char v22 = v16 == v17 ? 0 : v21;
    }
    else
    {
      while (1)
      {
        unsigned int v19 = *v14;
        unsigned int v20 = *v15;
        if (v19 != v20) {
          break;
        }
        ++v14;
        ++v15;
        if (!--v18) {
          goto LABEL_24;
        }
      }
      char v22 = v19 < v20 ? -1 : 1;
    }
    if (SHIBYTE(v85) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v83) < 0) {
      operator delete((void *)v82);
    }
    if (v79)
    {
      long long v80 = v79;
      operator delete(v79);
    }
    if (SHIBYTE(v93) < 0) {
      operator delete((void *)v92);
    }
    if (SHIBYTE(v91) < 0) {
      operator delete((void *)v90);
    }
    if (v87)
    {
      long long v88 = v87;
      operator delete(v87);
    }
    if (v22 < 0)
    {
      long long v72 = *(_OWORD *)v9;
      uint64_t v23 = *(void *)(v9 + 16);
      uint64_t v78 = 0;
      uint64_t v73 = v23;
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      *(void *)(v9 + 16) = 0;
      long long v74 = *v10;
      uint64_t v75 = *(void *)(v9 + 40);
      *(void *)int64_t v10 = 0;
      *(void *)(v9 + 32) = 0;
      *(void *)(v9 + 40) = 0;
      long long v76 = *v11;
      uint64_t v77 = *(void *)(v9 + 64);
      *(void *)(v9 + 56) = 0;
      *(void *)(v9 + 64) = 0;
      *(void *)uint64_t v11 = 0;
      uint64_t v24 = v9;
      LOWORD(v78) = *(_WORD *)(v9 + 72);
      while (1)
      {
        uint64_t v25 = v8;
        sub_10005C9A4(v24, (__n128 *)v8);
        char v26 = (void **)(v24 + 24);
        if (*(char *)(v24 + 47) < 0) {
          operator delete(*v26);
        }
        char v27 = (void **)(v8 + 24);
        *(_OWORD *)char v26 = *(_OWORD *)(v8 + 24);
        *(void *)(v24 + 40) = *(void *)(v8 + 40);
        *(unsigned char *)(v8 + 47) = 0;
        *(unsigned char *)(v8 + 24) = 0;
        char v28 = (void **)(v24 + 48);
        if (*(char *)(v24 + 71) < 0) {
          operator delete(*v28);
        }
        *(_OWORD *)char v28 = *(_OWORD *)(v8 + 48);
        *(void *)(v24 + 64) = *(void *)(v8 + 64);
        *(unsigned char *)(v8 + 71) = 0;
        *(unsigned char *)(v8 + 48) = 0;
        *(_WORD *)(v24 + 72) = *(_WORD *)(v8 + 72);
        if (v8 == v55) {
          break;
        }
        char v64 = 0;
        char v65 = 0;
        uint64_t v66 = 0;
        sub_10005C928(&v64, (const void *)v72, *((uint64_t *)&v72 + 1), *((void *)&v72 + 1) - v72);
        if (SHIBYTE(v75) < 0)
        {
          sub_10004FC84(&v67, (void *)v74, *((unint64_t *)&v74 + 1));
        }
        else
        {
          long long v67 = v74;
          uint64_t v68 = v75;
        }
        if (SHIBYTE(v77) < 0)
        {
          sub_10004FC84(&v69, (void *)v76, *((unint64_t *)&v76 + 1));
        }
        else
        {
          long long v69 = v76;
          uint64_t v70 = v77;
        }
        __int16 v71 = v78;
        uint64_t v57 = 0;
        uint64_t v58 = 0;
        long long v56 = 0;
        unsigned int v29 = *(const void **)(v8 - 80);
        uint64_t v30 = *(void *)(v8 - 72);
        v8 -= 80;
        sub_10005C928(&v56, v29, v30, v30 - (void)v29);
        if (*(char *)(v25 - 33) < 0)
        {
          sub_10004FC84(&v59, *(void **)(v25 - 56), *(void *)(v25 - 48));
        }
        else
        {
          long long v31 = *(_OWORD *)(v25 - 56);
          uint64_t v60 = *(void *)(v25 - 40);
          long long v59 = v31;
        }
        if (*(char *)(v25 - 9) < 0)
        {
          sub_10004FC84(&v61, *(void **)(v25 - 32), *(void *)(v25 - 24));
        }
        else
        {
          long long v32 = *(_OWORD *)(v25 - 32);
          uint64_t v62 = *(void *)(v25 - 16);
          long long v61 = v32;
        }
        __int16 v63 = *(_WORD *)(v25 - 8);
        unsigned int v33 = (unsigned __int8 *)v64;
        unsigned int v34 = (unsigned __int8 *)v56;
        int64_t v35 = v65 - (unsigned char *)v64;
        int64_t v36 = v57 - (unsigned char *)v56;
        if (v57 - (unsigned char *)v56 >= v65 - (unsigned char *)v64) {
          uint64_t v37 = v65 - (unsigned char *)v64;
        }
        else {
          uint64_t v37 = v57 - (unsigned char *)v56;
        }
        if (v37 < 1)
        {
LABEL_70:
          if (v35 < v36) {
            char v40 = -1;
          }
          else {
            char v40 = 1;
          }
          if (v35 == v36) {
            char v41 = 0;
          }
          else {
            char v41 = v40;
          }
        }
        else
        {
          while (1)
          {
            unsigned int v38 = *v33;
            unsigned int v39 = *v34;
            if (v38 != v39) {
              break;
            }
            ++v33;
            ++v34;
            if (!--v37) {
              goto LABEL_70;
            }
          }
          if (v38 < v39) {
            char v41 = -1;
          }
          else {
            char v41 = 1;
          }
        }
        if (SHIBYTE(v62) < 0) {
          operator delete((void *)v61);
        }
        if (SHIBYTE(v60) < 0) {
          operator delete((void *)v59);
        }
        if (v56)
        {
          uint64_t v57 = v56;
          operator delete(v56);
        }
        if (SHIBYTE(v70) < 0) {
          operator delete((void *)v69);
        }
        if (SHIBYTE(v68) < 0) {
          operator delete((void *)v67);
        }
        if (v64)
        {
          char v65 = v64;
          operator delete(v64);
        }
        uint64_t v24 = v25;
        if ((v41 & 0x80) == 0)
        {
          uint64_t v42 = v25;
          goto LABEL_94;
        }
      }
      uint64_t v42 = v55;
LABEL_94:
      unsigned int v43 = *(void **)v42;
      if (*(void *)v42)
      {
        *(void *)(v42 + 8) = v43;
        operator delete(v43);
        *(void *)uint64_t v42 = 0;
        *(void *)(v42 + 8) = 0;
        *(void *)(v42 + 16) = 0;
      }
      *(_OWORD *)uint64_t v42 = v72;
      *(void *)(v42 + 16) = v73;
      long long v72 = 0uLL;
      uint64_t v73 = 0;
      if (*(char *)(v42 + 47) < 0) {
        operator delete(*v27);
      }
      char v44 = (void **)(v25 + 48);
      long long v45 = v74;
      *(void *)(v25 + 40) = v75;
      *(_OWORD *)char v27 = v45;
      HIBYTE(v75) = 0;
      LOBYTE(v74) = 0;
      if (*(char *)(v42 + 71) < 0) {
        operator delete(*v44);
      }
      long long v46 = v76;
      *(void *)(v25 + 64) = v77;
      *(_OWORD *)char v44 = v46;
      *(_WORD *)(v42 + 72) = v78;
      ++v54;
      uint64_t v2 = v53;
      if (v54 == 8) {
        return v9 + 80 == v53;
      }
    }
    uint64_t v8 = v9;
    v9 += 80;
    if (v9 == v2) {
      return 1;
    }
  }
}

void sub_1007A7920(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 201) < 0) {
    operator delete(*(void **)(v1 - 224));
  }
  int v3 = *(void **)(v1 - 248);
  if (v3)
  {
    *(void *)(v1 - 240) = v3;
    operator delete(v3);
  }
  sub_10079AB58(v1 - 168);
  _Unwind_Resume(a1);
}

void sub_1007A7A90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1007A5608(a1, a2, a3);
  long long v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  sub_10005C928(&v76, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
  if (*(char *)(a4 + 47) < 0)
  {
    sub_10004FC84(&v79, *(void **)(a4 + 24), *(void *)(a4 + 32));
  }
  else
  {
    long long v79 = *(_OWORD *)(a4 + 24);
    uint64_t v80 = *(void *)(a4 + 40);
  }
  if (*(char *)(a4 + 71) < 0)
  {
    sub_10004FC84(&v81, *(void **)(a4 + 48), *(void *)(a4 + 56));
  }
  else
  {
    long long v81 = *(_OWORD *)(a4 + 48);
    uint64_t v82 = *(void *)(a4 + 64);
  }
  __int16 v83 = *(_WORD *)(a4 + 72);
  long long v69 = 0;
  uint64_t v70 = 0;
  uint64_t v68 = 0;
  sub_10005C928(&v68, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  uint64_t v8 = (long long *)(a3 + 24);
  if (*(char *)(a3 + 47) < 0)
  {
    sub_10004FC84(&v71, *(void **)(a3 + 24), *(void *)(a3 + 32));
  }
  else
  {
    long long v71 = *v8;
    uint64_t v72 = *(void *)(a3 + 40);
  }
  uint64_t v9 = (long long *)(a3 + 48);
  if (*(char *)(a3 + 71) < 0)
  {
    sub_10004FC84(&v73, *(void **)(a3 + 48), *(void *)(a3 + 56));
  }
  else
  {
    long long v73 = *v9;
    uint64_t v74 = *(void *)(a3 + 64);
  }
  __int16 v75 = *(_WORD *)(a3 + 72);
  int64_t v10 = v76;
  uint64_t v11 = v68;
  int64_t v12 = v77 - v76;
  int64_t v13 = v69 - v68;
  if (v69 - v68 >= v77 - v76) {
    uint64_t v14 = v77 - v76;
  }
  else {
    uint64_t v14 = v69 - v68;
  }
  if (v14 < 1)
  {
LABEL_19:
    if (v12 < v13) {
      char v17 = -1;
    }
    else {
      char v17 = 1;
    }
    if (v12 == v13) {
      char v18 = 0;
    }
    else {
      char v18 = v17;
    }
  }
  else
  {
    while (1)
    {
      unsigned int v15 = *v10;
      unsigned int v16 = *v11;
      if (v15 != v16) {
        break;
      }
      ++v10;
      ++v11;
      if (!--v14) {
        goto LABEL_19;
      }
    }
    if (v15 < v16) {
      char v18 = -1;
    }
    else {
      char v18 = 1;
    }
  }
  if (SHIBYTE(v74) < 0) {
    operator delete((void *)v73);
  }
  if (SHIBYTE(v72) < 0) {
    operator delete((void *)v71);
  }
  if (v68)
  {
    long long v69 = v68;
    operator delete(v68);
  }
  if (SHIBYTE(v82) < 0) {
    operator delete((void *)v81);
  }
  if (SHIBYTE(v80) < 0) {
    operator delete((void *)v79);
  }
  if (v76)
  {
    uint64_t v77 = v76;
    operator delete(v76);
  }
  if (v18 < 0)
  {
    sub_1007A0A70(a3, a4);
    uint64_t v60 = 0;
    long long v61 = 0;
    uint64_t v62 = 0;
    sub_10005C928(&v60, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    if (*(char *)(a3 + 47) < 0)
    {
      sub_10004FC84(&v63, *(void **)(a3 + 24), *(void *)(a3 + 32));
    }
    else
    {
      long long v63 = *v8;
      uint64_t v64 = *(void *)(a3 + 40);
    }
    if (*(char *)(a3 + 71) < 0)
    {
      sub_10004FC84(&v65, *(void **)(a3 + 48), *(void *)(a3 + 56));
    }
    else
    {
      long long v65 = *v9;
      uint64_t v66 = *(void *)(a3 + 64);
    }
    __int16 v67 = *(_WORD *)(a3 + 72);
    uint64_t v53 = 0;
    uint64_t v54 = 0;
    BOOL v52 = 0;
    sub_10005C928(&v52, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    unsigned int v19 = (long long *)(a2 + 24);
    if (*(char *)(a2 + 47) < 0)
    {
      sub_10004FC84(&v55, *(void **)(a2 + 24), *(void *)(a2 + 32));
    }
    else
    {
      long long v55 = *v19;
      uint64_t v56 = *(void *)(a2 + 40);
    }
    unsigned int v20 = (long long *)(a2 + 48);
    if (*(char *)(a2 + 71) < 0)
    {
      sub_10004FC84(&__p, *(void **)(a2 + 48), *(void *)(a2 + 56));
    }
    else
    {
      long long __p = *v20;
      uint64_t v58 = *(void *)(a2 + 64);
    }
    __int16 v59 = *(_WORD *)(a2 + 72);
    char v21 = (unsigned __int8 *)v60;
    char v22 = (unsigned __int8 *)v52;
    int64_t v23 = v61 - (unsigned char *)v60;
    int64_t v24 = v53 - (unsigned char *)v52;
    if (v53 - (unsigned char *)v52 >= v61 - (unsigned char *)v60) {
      uint64_t v25 = v61 - (unsigned char *)v60;
    }
    else {
      uint64_t v25 = v53 - (unsigned char *)v52;
    }
    if (v25 < 1)
    {
LABEL_59:
      if (v23 < v24) {
        char v28 = -1;
      }
      else {
        char v28 = 1;
      }
      if (v23 == v24) {
        char v29 = 0;
      }
      else {
        char v29 = v28;
      }
    }
    else
    {
      while (1)
      {
        unsigned int v26 = *v21;
        unsigned int v27 = *v22;
        if (v26 != v27) {
          break;
        }
        ++v21;
        ++v22;
        if (!--v25) {
          goto LABEL_59;
        }
      }
      if (v26 < v27) {
        char v29 = -1;
      }
      else {
        char v29 = 1;
      }
    }
    if (SHIBYTE(v58) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v56) < 0) {
      operator delete((void *)v55);
    }
    if (v52)
    {
      uint64_t v53 = v52;
      operator delete(v52);
    }
    if (SHIBYTE(v66) < 0) {
      operator delete((void *)v65);
    }
    if (SHIBYTE(v64) < 0) {
      operator delete((void *)v63);
    }
    if (v60)
    {
      long long v61 = v60;
      operator delete(v60);
    }
    if (v29 < 0)
    {
      sub_1007A0A70(a2, a3);
      char v44 = 0;
      long long v45 = 0;
      uint64_t v46 = 0;
      sub_10005C928(&v44, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
      if (*(char *)(a2 + 47) < 0)
      {
        sub_10004FC84(&v47, *(void **)(a2 + 24), *(void *)(a2 + 32));
      }
      else
      {
        long long v47 = *v19;
        uint64_t v48 = *(void *)(a2 + 40);
      }
      if (*(char *)(a2 + 71) < 0)
      {
        sub_10004FC84(&v49, *(void **)(a2 + 48), *(void *)(a2 + 56));
      }
      else
      {
        long long v49 = *v20;
        uint64_t v50 = *(void *)(a2 + 64);
      }
      __int16 v51 = *(_WORD *)(a2 + 72);
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      int64_t v36 = 0;
      sub_10005C928(&v36, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
      if (*(char *)(a1 + 47) < 0)
      {
        sub_10004FC84(&v39, *(void **)(a1 + 24), *(void *)(a1 + 32));
      }
      else
      {
        long long v39 = *(_OWORD *)(a1 + 24);
        uint64_t v40 = *(void *)(a1 + 40);
      }
      if (*(char *)(a1 + 71) < 0)
      {
        sub_10004FC84(&v41, *(void **)(a1 + 48), *(void *)(a1 + 56));
      }
      else
      {
        long long v41 = *(_OWORD *)(a1 + 48);
        uint64_t v42 = *(void *)(a1 + 64);
      }
      __int16 v43 = *(_WORD *)(a1 + 72);
      uint64_t v30 = (unsigned __int8 *)v44;
      long long v31 = (unsigned __int8 *)v36;
      if (v37 - (unsigned char *)v36 >= v45 - (unsigned char *)v44) {
        uint64_t v32 = v45 - (unsigned char *)v44;
      }
      else {
        uint64_t v32 = v37 - (unsigned char *)v36;
      }
      if (v32 < 1)
      {
LABEL_99:
        BOOL v35 = v45 - (unsigned char *)v44 < v37 - (unsigned char *)v36;
      }
      else
      {
        while (1)
        {
          unsigned int v33 = *v30;
          unsigned int v34 = *v31;
          if (v33 != v34) {
            break;
          }
          ++v30;
          ++v31;
          if (!--v32) {
            goto LABEL_99;
          }
        }
        BOOL v35 = v33 < v34;
      }
      if (SHIBYTE(v42) < 0) {
        operator delete((void *)v41);
      }
      if (SHIBYTE(v40) < 0) {
        operator delete((void *)v39);
      }
      if (v36)
      {
        uint64_t v37 = v36;
        operator delete(v36);
      }
      if (SHIBYTE(v50) < 0) {
        operator delete((void *)v49);
      }
      if (SHIBYTE(v48) < 0) {
        operator delete((void *)v47);
      }
      if (v44)
      {
        long long v45 = v44;
        operator delete(v44);
      }
      if (v35) {
        sub_1007A0A70(a1, a2);
      }
    }
  }
}

void sub_1007A8028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a9) {
    operator delete(a9);
  }
  sub_10079AB58((uint64_t)&a22);
  _Unwind_Resume(a1);
}

uint64_t sub_1007A816C(uint64_t a1, unsigned __int8 *a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_1007A81C8((unsigned __int8 *)a1, a2);
  return a1;
}

void sub_1007A819C(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)v1 == 1)
  {
    int v3 = *(void **)(v1 + 8);
    if (v3)
    {
      *(void *)(v1 + 16) = v3;
      operator delete(v3);
    }
  }
  *(unsigned char *)uint64_t v1 = 0;
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_1007A81C8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (v3 == 2)
  {
    sub_1007A821C(a1, a2 + 8);
  }
  else if (v3 == 1)
  {
    sub_1000C59A0((uint64_t)a1, (char **)a2 + 1);
  }
  return a1;
}

void sub_1007A821C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v4 = *a1;
  if (v4 == 1)
  {
    uint64_t v5 = (void *)*((void *)a1 + 1);
    if (v5)
    {
      *((void *)a1 + 2) = v5;
      operator delete(v5);
    }
  }
  else if (v4 == 2)
  {
    a1[8] = *a2;
    a1[9] = a2[1];
    a1[10] = a2[2];
    return;
  }
  *a1 = 2;
  __int16 v6 = *(_WORD *)a2;
  a1[10] = a2[2];
  *((_WORD *)a1 + 4) = v6;
}

void sub_1007A8298(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007A8364(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[7], v1, (dispatch_function_t)sub_1007A843C);
  __cxa_rethrow();
}

void sub_1007A838C(_Unwind_Exception *a1)
{
}

void sub_1007A83A4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007A83DC(uint64_t a1)
{
}

uint64_t sub_1007A83F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1007A843C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1007A8468(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(char *)(a2 + 31) < 0) {
      operator delete(*(void **)(a2 + 8));
    }
    operator delete();
  }
}

void sub_1007A84C4(uint64_t a1)
{
  sub_1000B3D68((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void sub_1007A8520(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007A8558(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1007A8588(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_1007A85CC(void *a1)
{
  *a1 = off_101A08130;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1007A8618(void *a1)
{
  *a1 = off_101A08130;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1007A8684(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        __int16 v6 = (os_log_t *)(v5 + 72);
        uint64_t v7 = *(NSObject **)(v5 + 72);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = *(_DWORD *)(v5 + 248);
          unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v5 + 232) - *(void *)(v5 + 224)) >> 4);
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v8;
          LOWORD(v33) = 2048;
          *(void *)((char *)&v33 + 2) = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [3] Send receipt # %d (of %lu) to server", buf, 0x12u);
        }
        char v29 = 0;
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        if (sub_10074B1E8(v5 + 256, (uint64_t)&v29))
        {
          uint64_t v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          sub_10132A1C0(v5, &v26);
          std::operator+<char>();
          uint64_t v24 = 0;
          uint64_t v25 = 0;
          sub_10132A438((Registry **)(v5 + 80), "/gsma/rsp2/es9plus/handleNotification", (uint64_t)buf, (uint64_t)&v29, (void *)(v5 + 56), (uint64_t)&v26, __p, &v24);
          long long v10 = *(_OWORD *)__p;
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v11 = *(std::__shared_weak_count **)(v5 + 360);
          *(_OWORD *)(v5 + 352) = v10;
          if (v11)
          {
            sub_10004D2C8(v11);
            if (__p[1]) {
              sub_10004D2C8((std::__shared_weak_count *)__p[1]);
            }
          }
          if (v25) {
            sub_10004D2C8(v25);
          }
          if (SHIBYTE(v33) < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v12 = *(void *)(v5 + 352);
          sub_100062740((const void **)buf, (const void **)(v5 + 32));
          (*(void (**)(uint64_t, void))(*(void *)v12 + 72))(v12, *(void *)buf);
          sub_100044D00((const void **)buf);
          (*(void (**)(void, Block_layout *))(**(void **)(v5 + 352) + 240))(*(void *)(v5 + 352), &stru_101AB2198);
          uint64_t v13 = *(void *)(v5 + 120);
          if (v13) {
            sub_100EE8BC8(v13, "SendNotificationReq");
          }
          else {
            *(void *)(v5 + 120) = 0;
          }
          unsigned int v15 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v15 || (v16 = *(void *)(v5 + 40), (char v17 = std::__shared_weak_count::lock(v15)) == 0)) {
            sub_100088B9C();
          }
          char v18 = v17;
          p_shared_weak_owners = &v17->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          uint64_t v20 = *(void *)(v5 + 352);
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&long long v33 = 1174405120;
          *((void *)&v33 + 1) = sub_10079A080;
          unsigned int v34 = &unk_101A07F10;
          uint64_t v35 = v5;
          uint64_t v36 = v16;
          uint64_t v37 = v18;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v20 + 16))(v20, buf);
          uint64_t v21 = *(void *)(v5 + 352);
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, void **))(*(void *)v21 + 40))(v21, __p);
          if (v23 < 0) {
            operator delete(__p[0]);
          }
          if (v37) {
            std::__shared_weak_count::__release_weak(v37);
          }
          std::__shared_weak_count::__release_weak(v18);
          sub_10010C0E0((uint64_t)&v26, v27);
        }
        else
        {
          uint64_t v14 = *v6;
          if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E Cannot encode receipt data! Skipping and removing notification", buf, 2u);
          }
          sub_1007AB334(*(void *)(v5 + 112), (uint64_t)buf, 1);
        }
        if (v29)
        {
          uint64_t v30 = v29;
          operator delete(v29);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1007A8A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,void *a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,std::__shared_weak_count *a35)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a35) {
    std::__shared_weak_count::__release_weak(a35);
  }
  std::__shared_weak_count::__release_weak(v36);
  sub_10010C0E0((uint64_t)&a20, a21);
  if (a23)
  {
    a24 = (uint64_t)a23;
    operator delete(a23);
  }
  sub_10004D2C8(v35);
  _Unwind_Resume(a1);
}

void sub_1007A8B4C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void **)(a1 + 8);
      if (v5)
      {
        __int16 v6 = v5[9];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v12[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [1] Retrieving receipt list from baseband", (uint8_t *)v12, 2u);
        }
        uint64_t v7 = (std::__shared_weak_count *)v5[6];
        if (!v7 || (uint64_t v8 = v5[5], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        long long v10 = v9;
        p_shared_weak_owners = &v9->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 1174405120;
        void v12[2] = sub_100798FB4;
        void v12[3] = &unk_101A07E80;
        void v12[4] = v5;
        void v12[5] = v8;
        uint64_t v13 = v10;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        VinylCommandDriver::tapeListNotifications();
        if (v13) {
          std::__shared_weak_count::__release_weak(v13);
        }
        std::__shared_weak_count::__release_weak(v10);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1007A8CAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v16);
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_1007A8CDC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        __int16 v6 = *(NSObject **)(v5 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v7 = *(_DWORD *)(v5 + 248);
          unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v5 + 232) - *(void *)(v5 + 224)) >> 4);
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v7;
          LOWORD(v22) = 2048;
          *(void *)((char *)&v22 + 2) = v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [2] Retrieving data for receipt #%d (of %lu) from baseband", buf, 0x12u);
        }
        unint64_t v9 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v9 || (v10 = *(void *)(v5 + 40), (uint64_t v11 = std::__shared_weak_count::lock(v9)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v12 = v11;
        atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        if (sub_1007529C0((char **)(*(void *)(v5 + 224) + 80 * *(unsigned int *)(v5 + 248)), (uint64_t)&v18))
        {
          uint64_t v13 = *(void *)(v5 + 120);
          if (v13) {
            sub_100EE8BC8(v13, "GetNotificationReq");
          }
          else {
            *(void *)(v5 + 120) = 0;
          }
          uint64_t v16 = 0;
          uint64_t v17 = 0;
          long long __p = 0;
          sub_10005C928(&__p, v18, (uint64_t)v19, v19 - (unsigned char *)v18);
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&long long v22 = 1174405120;
          *((void *)&v22 + 1) = sub_1007999BC;
          char v23 = &unk_101A07EE0;
          uint64_t v24 = v5;
          uint64_t v25 = v10;
          uint64_t v26 = v12;
          atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          VinylCommandDriver::tapeGetNotification();
          if (__p)
          {
            uint64_t v16 = __p;
            operator delete(__p);
          }
          if (v26) {
            std::__shared_weak_count::__release_weak(v26);
          }
        }
        else
        {
          uint64_t v14 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Could not encode notification request - skipping", buf, 2u);
          }
          ++*(_DWORD *)(v5 + 248);
          sub_1007AA9F8(*(void *)(v5 + 112), (uint64_t)buf, 1);
        }
        if (v18)
        {
          unsigned int v19 = v18;
          operator delete(v18);
        }
        std::__shared_weak_count::__release_weak(v12);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1007A8FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_weak(a21);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  std::__shared_weak_count::__release_weak(v22);
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

void sub_1007A8FFC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        __int16 v6 = *(NSObject **)(v5 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v7 = *(_DWORD *)(v5 + 248);
          unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v5 + 232) - *(void *)(v5 + 224)) >> 4);
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v7;
          LOWORD(v22) = 2048;
          *(void *)((char *)&v22 + 2) = v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [4] Deleting receipt #%d (of %lu) from baseband", buf, 0x12u);
        }
        unint64_t v9 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v9 || (v10 = *(void *)(v5 + 40), (uint64_t v11 = std::__shared_weak_count::lock(v9)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v12 = v11;
        atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        if (!sub_100752FBC((char **)(*(void *)(v5 + 224) + 80 * *(unsigned int *)(v5 + 248)), (uint64_t)&v18))
        {
          uint64_t v13 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E Could not encode - continuing anyways", buf, 2u);
          }
          ++*(_DWORD *)(v5 + 248);
          sub_1007AB678(*(void *)(v5 + 112), (uint64_t)buf, 1);
        }
        uint64_t v14 = *(void *)(v5 + 120);
        if (v14) {
          sub_100EE8BC8(v14, "DeleteNotificationReq");
        }
        else {
          *(void *)(v5 + 120) = 0;
        }
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        long long __p = 0;
        sub_10005C928(&__p, v18, (uint64_t)v19, v19 - (unsigned char *)v18);
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&long long v22 = 1174405120;
        *((void *)&v22 + 1) = sub_10079A348;
        char v23 = &unk_101A07F70;
        uint64_t v24 = v5;
        uint64_t v25 = v10;
        uint64_t v26 = v12;
        atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        VinylCommandDriver::tapeDeleteNotification();
        if (__p)
        {
          uint64_t v16 = __p;
          operator delete(__p);
        }
        if (v26) {
          std::__shared_weak_count::__release_weak(v26);
        }
        if (v18)
        {
          unsigned int v19 = v18;
          operator delete(v18);
        }
        std::__shared_weak_count::__release_weak(v12);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1007A92BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v22);
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

void sub_1007A9318(uint64_t a1, int a2)
{
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      __int16 v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7) {
        sub_100798D54(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1007A9394(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1007A93A8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        __int16 v6 = *(NSObject **)(v5 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [-] Receipts operation has been paused due to baseband error; will resume on trigger",
            v7,
            2u);
        }
        *(unsigned char *)(v5 + 178) = 1;
      }
      sub_10004D2C8(v4);
    }
  }
}

BOOL sub_1007A9460(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  int v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    BOOL v5 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v4 + 232) - *(void *)(v4 + 224)) >> 4) > *(unsigned int *)(v4 + 248);
  }
  else {
    BOOL v5 = 0;
  }
  sub_10004D2C8(v3);
  return v5;
}

uint64_t sub_1007A94D4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  int v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    long long __p = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v5 = *(void *)(v5 + 256) != *(void *)(v5 + 264)
      && *(unsigned char *)(*(void *)(v5 + 224) + 80 * *(unsigned int *)(v5 + 248) + 72)
      && (sub_1007493A8((uint64_t *)(v5 + 256)) & 1) != 0
      && (*(char *)(v5 + 207) < 0 ? (uint64_t v6 = *(void *)(v5 + 192)) : (uint64_t v6 = *(unsigned __int8 *)(v5 + 207)), v6)
      && sub_10001D294((unsigned __int8 *)(v5 + 184), (unsigned __int8 *)(*(void *)(v5 + 224) + 80 * *(unsigned int *)(v5 + 248) + 48));
    if (SHIBYTE(v10) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v13) < 0) {
      operator delete(v11);
    }
  }
  sub_10004D2C8(v4);
  return v5;
}

void sub_1007A974C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

uint64_t sub_1007A9780(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D758[8 * *(_DWORD *)(a1 + 24) + 72])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1007A9A38((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1007A98F8(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKN"
                                        "S8_5StartEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5StartEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1007A9A04(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t *sub_1007A9A38(uint64_t *result)
{
  if (result[9])
  {
    uint64_t v1 = result;
    uint64_t v2 = (int64x2_t *)(result + 4);
    do
    {
      memset(v6, 0, sizeof(v6));
      uint64_t v3 = *(void *)(v1[5] + (((unint64_t)v1[8] >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v1[8] & 0x7F);
      uint64_t v4 = *(void *)v3;
      if (*(void *)v3)
      {
        *(void *)&v6[0] = *(void *)v3;
        if (v4)
        {
          long long v5 = *(_OWORD *)(v3 + 8);
          *((void *)&v6[1] + 1) = *(void *)(v3 + 24);
          *(_OWORD *)((char *)v6 + 8) = v5;
        }
        else
        {
          (*(void (**)(uint64_t, char *, void))(v4 & 0xFFFFFFFFFFFFFFFELL))(v3 + 8, (char *)v6 + 8, 0);
        }
      }
      sub_1000983B4(v2);
      sub_100098420(v6);
      uint64_t result = sub_100098288((uint64_t *)v6);
    }
    while (v1[9]);
  }
  return result;
}

void sub_1007A9AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1007A9B10()
{
  return 0;
}

uint64_t sub_1007A9B18(uint64_t a1, int a2, int a3)
{
  if (a3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 0;
  (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 1;
  return 1;
}

uint64_t sub_1007A9B94(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D758[8 * *(_DWORD *)(a1 + 24) + 128])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1007A9A38((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1007A9D10(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKN"
                                        "S8_5AbortEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5AbortEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1007A9E24(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[32];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1007A9E58(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 800, "state == (current_state)");
  }
  return 1;
}

uint64_t sub_1007A9E94(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 4;
  (*(void (**)(void, void, void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1));
  *(_DWORD *)(v4 + 24) = 5;
  return 1;
}

uint64_t sub_1007A9F20(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 3;
  (*(void (**)(void, void, void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1));
  *(_DWORD *)(v4 + 24) = 5;
  return 1;
}

uint64_t sub_1007A9FAC(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 2;
  (*(void (**)(void, void, void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1));
  *(_DWORD *)(v4 + 24) = 5;
  return 1;
}

uint64_t sub_1007AA038(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 1;
  (*(void (**)(void, void, void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1));
  *(_DWORD *)(v4 + 24) = 5;
  return 1;
}

uint64_t sub_1007AA0C4(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 0;
  (*(void (**)(void, void, void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1));
  *(_DWORD *)(v4 + 24) = 5;
  return 1;
}

uint64_t sub_1007AA148(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D758[8 * *(_DWORD *)(a1 + 24) + 184])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1007A9A38((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1007AA2C0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKN"
                                        "S8_21bbListReceiptsSuccessEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_21bbListReceiptsSuccessEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1007AA3CC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1007AA400()
{
  return 0;
}

uint64_t sub_1007AA408(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 1;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 32))();
    int v9 = 2;
  }
  else
  {
    (*(void (**)(void))(v8 + 48))();
    int v9 = 5;
  }
  int *v7 = v9;
  return 1;
}

uint64_t sub_1007AA4F8(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D758[8 * *(_DWORD *)(a1 + 24) + 240])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1007A9A38((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1007AA670(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKN"
                                        "S8_5RetryEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5RetryEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1007AA77C(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1007AA7B0()
{
  return 0;
}

uint64_t sub_1007AA7B8(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 4;
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 4;
  return 1;
}

uint64_t sub_1007AA838(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 3;
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), 1);
  *(_DWORD *)(v3 + 24) = 3;
  return 1;
}

uint64_t sub_1007AA8BC(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 2;
  (*(void (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 2;
  return 1;
}

uint64_t sub_1007AA93C(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 1;
  (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 1;
  return 1;
}

uint64_t sub_1007AA9BC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1007AA9CC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007AA9E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_1007AA9F8(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D758[8 * *(_DWORD *)(a1 + 24) + 296])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1007A9A38((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1007AAB70(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKN"
                                        "S8_4SkipEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_4SkipEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1007AAC7C(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1007AACB0()
{
  return 0;
}

uint64_t sub_1007AACB8(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 4;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 32))();
    int v9 = 2;
  }
  else
  {
    (*(void (**)(void))(v8 + 48))();
    int v9 = 5;
  }
  int *v7 = v9;
  return 1;
}

uint64_t sub_1007AADA8(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 3;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 32))();
    int v9 = 2;
  }
  else
  {
    (*(void (**)(void))(v8 + 48))();
    int v9 = 5;
  }
  int *v7 = v9;
  return 1;
}

uint64_t sub_1007AAE98(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 2;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 32))();
    int v9 = 2;
  }
  else
  {
    (*(void (**)(void))(v8 + 48))();
    int v9 = 5;
  }
  int *v7 = v9;
  return 1;
}

uint64_t sub_1007AAF88(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D758[8 * *(_DWORD *)(a1 + 24) + 352])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1007A9A38((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1007AB100(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKN"
                                        "S8_12bbGotReceiptEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_12bbGotReceiptEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1007AB20C(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1007AB240()
{
  return 0;
}

uint64_t sub_1007AB248(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 2;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 40))();
    int v9 = 4;
  }
  else
  {
    (*(void (**)(void))(v8 + 16))();
    int v9 = 3;
  }
  int *v7 = v9;
  return 1;
}

uint64_t sub_1007AB334(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D758[8 * *(_DWORD *)(a1 + 24) + 408])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1007A9A38((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1007AB4AC(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKN"
                                        "S8_13vsReceiptSentEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_13vsReceiptSentEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1007AB5B8(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1007AB5EC()
{
  return 0;
}

uint64_t sub_1007AB5F4(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 3;
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 4;
  return 1;
}

uint64_t sub_1007AB678(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D758[8 * *(_DWORD *)(a1 + 24) + 464])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1007A9A38((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1007AB7F0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKN"
                                        "S8_16bbReceiptDeletedEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN18vinyl_receipts_fsm21VinylReceiptsFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_16bbReceiptDeletedEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1007AB8FC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1007AB930()
{
  return 0;
}

uint64_t sub_1007AB938(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 4;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 32))();
    int v9 = 2;
  }
  else
  {
    (*(void (**)(void))(v8 + 48))();
    int v9 = 5;
  }
  int *v7 = v9;
  return 1;
}

void sub_1007ABA28()
{
  if ((byte_101B0D758[0] & 1) == 0)
  {
    byte_101B0D758[0] = 1;
    qword_101B0D7C0 = (uint64_t)sub_1007A9B10;
    unk_101B0D7C8 = sub_1007A9B10;
    qword_101B0D7B0 = (uint64_t)sub_1007A9B10;
    unk_101B0D7B8 = sub_1007A9B10;
    qword_101B0D7A8 = (uint64_t)sub_1007A9B10;
    qword_101B0D7A0 = (uint64_t)sub_1007A9B18;
  }
}

void sub_1007ABA70()
{
  if ((byte_101B0D760 & 1) == 0)
  {
    byte_101B0D760 = 1;
    qword_101B0D800 = (uint64_t)sub_1007A9E58;
    qword_101B0D7F8 = (uint64_t)sub_1007A9E94;
    qword_101B0D7F0 = (uint64_t)sub_1007A9F20;
    qword_101B0D7E8 = (uint64_t)sub_1007A9FAC;
    qword_101B0D7E0 = (uint64_t)sub_1007AA038;
    qword_101B0D7D8 = (uint64_t)sub_1007AA0C4;
  }
}

void sub_1007ABAF0()
{
  if ((byte_101B0D768 & 1) == 0)
  {
    byte_101B0D768 = 1;
    qword_101B0D830 = (uint64_t)sub_1007AA400;
    unk_101B0D838 = sub_1007AA400;
    qword_101B0D820 = (uint64_t)sub_1007AA400;
    unk_101B0D828 = sub_1007AA400;
    qword_101B0D810 = (uint64_t)sub_1007AA400;
    qword_101B0D818 = (uint64_t)sub_1007AA408;
  }
}

void sub_1007ABB38()
{
  if ((byte_101B0D770 & 1) == 0)
  {
    byte_101B0D770 = 1;
    qword_101B0D870 = (uint64_t)sub_1007AA7B0;
    qword_101B0D848 = (uint64_t)sub_1007AA7B0;
    qword_101B0D868 = (uint64_t)sub_1007AA7B8;
    qword_101B0D860 = (uint64_t)sub_1007AA838;
    qword_101B0D858 = (uint64_t)sub_1007AA8BC;
    qword_101B0D850 = (uint64_t)sub_1007AA93C;
  }
}

void sub_1007ABBAC()
{
  if ((byte_101B0D778 & 1) == 0)
  {
    byte_101B0D778 = 1;
    qword_101B0D8A8 = (uint64_t)sub_1007AACB0;
    qword_101B0D880 = (uint64_t)sub_1007AACB0;
    unk_101B0D888 = sub_1007AACB0;
    qword_101B0D8A0 = (uint64_t)sub_1007AACB8;
    qword_101B0D898 = (uint64_t)sub_1007AADA8;
    qword_101B0D890 = (uint64_t)sub_1007AAE98;
  }
}

void sub_1007ABC10()
{
  if ((byte_101B0D780 & 1) == 0)
  {
    byte_101B0D780 = 1;
    qword_101B0D8D8 = (uint64_t)sub_1007AB240;
    unk_101B0D8E0 = sub_1007AB240;
    qword_101B0D8D0 = (uint64_t)sub_1007AB240;
    qword_101B0D8B8 = (uint64_t)sub_1007AB240;
    unk_101B0D8C0 = sub_1007AB240;
    qword_101B0D8C8 = (uint64_t)sub_1007AB248;
  }
}

void sub_1007ABC58()
{
  if ((byte_101B0D788 & 1) == 0)
  {
    byte_101B0D788 = 1;
    qword_101B0D910 = (uint64_t)sub_1007AB5EC;
    unk_101B0D918 = sub_1007AB5EC;
    qword_101B0D8F8 = (uint64_t)sub_1007AB5EC;
    unk_101B0D900 = sub_1007AB5EC;
    qword_101B0D8F0 = (uint64_t)sub_1007AB5EC;
    qword_101B0D908 = (uint64_t)sub_1007AB5F4;
  }
}

void sub_1007ABCA0()
{
  if ((byte_101B0D790 & 1) == 0)
  {
    byte_101B0D790 = 1;
    qword_101B0D950 = (uint64_t)sub_1007AB930;
    qword_101B0D938 = (uint64_t)sub_1007AB930;
    unk_101B0D940 = sub_1007AB930;
    qword_101B0D928 = (uint64_t)sub_1007AB930;
    unk_101B0D930 = sub_1007AB930;
    qword_101B0D948 = (uint64_t)sub_1007AB938;
  }
}

BOOL sub_1007ABCE8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  uint64_t v6 = a2;
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a1, a2, *((void *)a1 + 1))) {
      return 0;
    }
  }
  else if (a1[23])
  {
    uint64_t v8 = a1;
    while (*v8 == *a2)
    {
      ++v8;
      ++a2;
      if (!--v2) {
        goto LABEL_16;
      }
    }
    return 0;
  }
LABEL_16:
  uint64_t v9 = a1[47];
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = a1[47];
  }
  else {
    uint64_t v10 = *((void *)a1 + 4);
  }
  uint64_t v11 = v6[47];
  int v12 = (char)v11;
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *((void *)v6 + 4);
  }
  if (v10 != v11) {
    return 0;
  }
  uint64_t v13 = (const void **)(a1 + 24);
  if (v12 >= 0) {
    uint64_t v14 = v6 + 24;
  }
  else {
    uint64_t v14 = (unsigned __int8 *)*((void *)v6 + 3);
  }
  if ((v9 & 0x80) != 0)
  {
    if (memcmp(*v13, v14, *((void *)a1 + 4))) {
      return 0;
    }
  }
  else if (a1[47])
  {
    while (*(unsigned __int8 *)v13 == *v14)
    {
      uint64_t v13 = (const void **)((char *)v13 + 1);
      ++v14;
      if (!--v9) {
        goto LABEL_31;
      }
    }
    return 0;
  }
LABEL_31:
  uint64_t v15 = a1[71];
  if ((v15 & 0x80u) == 0) {
    uint64_t v16 = a1[71];
  }
  else {
    uint64_t v16 = *((void *)a1 + 7);
  }
  uint64_t v17 = v6[71];
  int v18 = (char)v17;
  if ((v17 & 0x80u) != 0) {
    uint64_t v17 = *((void *)v6 + 7);
  }
  if (v16 != v17) {
    return 0;
  }
  unsigned int v19 = (const void **)(a1 + 48);
  if (v18 >= 0) {
    uint64_t v20 = v6 + 48;
  }
  else {
    uint64_t v20 = (unsigned __int8 *)*((void *)v6 + 6);
  }
  if ((v15 & 0x80) != 0)
  {
    if (memcmp(*v19, v20, *((void *)a1 + 7))) {
      return 0;
    }
  }
  else if (a1[71])
  {
    while (*(unsigned __int8 *)v19 == *v20)
    {
      unsigned int v19 = (const void **)((char *)v19 + 1);
      ++v20;
      if (!--v15) {
        goto LABEL_46;
      }
    }
    return 0;
  }
LABEL_46:
  int v21 = v6[169];
  if (a1[169]) {
    BOOL v22 = v21 == 0;
  }
  else {
    BOOL v22 = 1;
  }
  if (v22)
  {
    if ((a1[169] != 0) == (v21 != 0)) {
      goto LABEL_54;
    }
    return 0;
  }
  if (a1[168] != v6[168]) {
    return 0;
  }
LABEL_54:
  if (a1[170] != v6[170] || a1[171] != v6[171] || a1[172] != v6[172] || a1[173] != v6[173]) {
    return 0;
  }
  BOOL result = sub_10001D294(a1 + 72, v6 + 72);
  if (!result) {
    return result;
  }
  if (*((_DWORD *)a1 + 44) != *((_DWORD *)v6 + 44) || *((_DWORD *)a1 + 45) != *((_DWORD *)v6 + 45)) {
    return 0;
  }
  BOOL result = sub_10001D294(a1 + 120, v6 + 120);
  if (result)
  {
    BOOL result = sub_10001D294(a1 + 144, v6 + 144);
    if (result)
    {
      if (a1[184] == v6[184] && a1[185] == v6[185]) {
        return a1[186] == v6[186];
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_1007ABF84@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 *a2@<X1>, void *a3@<X8>)
{
  uint64_t v132 = 0;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  long long v122 = 0u;
  long long v123 = 0u;
  *(_OWORD *)long long v120 = 0u;
  long long v121 = 0u;
  memset(v119, 0, sizeof(v119));
  long long v118 = 0u;
  sub_10004BD84((uint64_t)&v118);
  int v5 = sub_10004B96C(v119, (uint64_t)"Cached-imsi: ", 13);
  if ((char)a1[23] < 0)
  {
    sub_10004FC84(__dst, *(void **)a1, *((void *)a1 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a1;
    uint64_t v114 = *((void *)a1 + 2);
  }
  uint64_t v6 = (void *)HIBYTE(v114);
  if (v114 < 0) {
    uint64_t v6 = __dst[1];
  }
  if (v6) {
    std::exception v7 = "OK";
  }
  else {
    std::exception v7 = "(empty)";
  }
  sub_100058DB0(&__p, v7);
  if ((v117 & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v117 & 0x80u) == 0) {
    uint64_t v9 = v117;
  }
  else {
    uint64_t v9 = v116;
  }
  sub_10004B96C(v5, (uint64_t)p_p, v9);
  if ((char)v117 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v114) < 0) {
    operator delete(__dst[0]);
  }
  uint64_t v10 = sub_10004B96C(v119, (uint64_t)", Imei: ", 8);
  uint64_t v11 = a1 + 24;
  if ((char)a1[47] < 0)
  {
    sub_10004FC84(v111, *((void **)a1 + 3), *((void *)a1 + 4));
  }
  else
  {
    *(_OWORD *)uint64_t v111 = *v11;
    uint64_t v112 = *((void *)a1 + 5);
  }
  int v12 = (void *)HIBYTE(v112);
  if (v112 < 0) {
    int v12 = v111[1];
  }
  if (v12) {
    uint64_t v13 = "OK";
  }
  else {
    uint64_t v13 = "(empty)";
  }
  sub_100058DB0(&__p, v13);
  if ((v117 & 0x80u) == 0) {
    uint64_t v14 = &__p;
  }
  else {
    uint64_t v14 = __p;
  }
  if ((v117 & 0x80u) == 0) {
    uint64_t v15 = v117;
  }
  else {
    uint64_t v15 = v116;
  }
  sub_10004B96C(v10, (uint64_t)v14, v15);
  if ((char)v117 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v112) < 0) {
    operator delete(v111[0]);
  }
  uint64_t v16 = sub_10004B96C(v119, (uint64_t)", url: ", 7);
  uint64_t v17 = a1 + 48;
  if ((char)a1[71] < 0)
  {
    sub_10004FC84(v109, *((void **)a1 + 6), *((void *)a1 + 7));
  }
  else
  {
    *(_OWORD *)uint64_t v109 = *v17;
    uint64_t v110 = *((void *)a1 + 8);
  }
  int v18 = (void *)HIBYTE(v110);
  if (v110 < 0) {
    int v18 = v109[1];
  }
  if (v18) {
    unsigned int v19 = "OK";
  }
  else {
    unsigned int v19 = "(empty)";
  }
  sub_100058DB0(&__p, v19);
  if ((v117 & 0x80u) == 0) {
    uint64_t v20 = &__p;
  }
  else {
    uint64_t v20 = __p;
  }
  if ((v117 & 0x80u) == 0) {
    uint64_t v21 = v117;
  }
  else {
    uint64_t v21 = v116;
  }
  sub_10004B96C(v16, (uint64_t)v20, v21);
  if ((char)v117 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v110) < 0) {
    operator delete(v109[0]);
  }
  BOOL v22 = sub_10004B96C(v119, (uint64_t)", Ph#: ", 7);
  char v23 = a1 + 72;
  if ((char)a1[95] < 0)
  {
    sub_10004FC84(v107, *((void **)a1 + 9), *((void *)a1 + 10));
  }
  else
  {
    *(_OWORD *)uint64_t v107 = *v23;
    uint64_t v108 = *((void *)a1 + 11);
  }
  uint64_t v24 = (void *)HIBYTE(v108);
  if (v108 < 0) {
    uint64_t v24 = v107[1];
  }
  if (v24) {
    uint64_t v25 = "OK";
  }
  else {
    uint64_t v25 = "(empty)";
  }
  sub_100058DB0(&__p, v25);
  if ((v117 & 0x80u) == 0) {
    uint64_t v26 = &__p;
  }
  else {
    uint64_t v26 = __p;
  }
  if ((v117 & 0x80u) == 0) {
    uint64_t v27 = v117;
  }
  else {
    uint64_t v27 = v116;
  }
  sub_10004B96C(v22, (uint64_t)v26, v27);
  if ((char)v117 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v108) < 0) {
    operator delete(v107[0]);
  }
  uint64_t v28 = sub_10004B96C(v119, (uint64_t)", Switch: [ enabled:", 20);
  char v29 = (const char *)printers::asString();
  size_t v30 = strlen(v29);
  uint64_t v31 = sub_10004B96C(v28, (uint64_t)v29, v30);
  uint64_t v32 = sub_10004B96C(v31, (uint64_t)", default: ", 11);
  if (a1[173]) {
    long long v33 = "true";
  }
  else {
    long long v33 = "false";
  }
  if (a1[173]) {
    uint64_t v34 = 4;
  }
  else {
    uint64_t v34 = 5;
  }
  uint64_t v35 = sub_10004B96C(v32, (uint64_t)v33, v34);
  sub_10004B96C(v35, (uint64_t)"]", 1);
  uint64_t v36 = sub_10004B96C(v119, (uint64_t)", SMS Online: ", 14);
  if (a1[170]) {
    uint64_t v37 = "true";
  }
  else {
    uint64_t v37 = "false";
  }
  if (a1[170]) {
    uint64_t v38 = 4;
  }
  else {
    uint64_t v38 = 5;
  }
  sub_10004B96C(v36, (uint64_t)v37, v38);
  long long v39 = sub_10004B96C(v119, (uint64_t)", Bundle: ", 10);
  if (a1[171]) {
    uint64_t v40 = "true";
  }
  else {
    uint64_t v40 = "false";
  }
  if (a1[171]) {
    uint64_t v41 = 4;
  }
  else {
    uint64_t v41 = 5;
  }
  sub_10004B96C(v39, (uint64_t)v40, v41);
  uint64_t v42 = sub_10004B96C(v119, (uint64_t)", Carrier: ", 11);
  if (a1[172]) {
    __int16 v43 = "true";
  }
  else {
    __int16 v43 = "false";
  }
  if (a1[172]) {
    uint64_t v44 = 4;
  }
  else {
    uint64_t v44 = 5;
  }
  sub_10004B96C(v42, (uint64_t)v43, v44);
  long long v45 = sub_10004B96C(v119, (uint64_t)", Interfaces: [", 15);
  uint64_t v46 = *((int *)a1 + 44);
  if (v46 > 4) {
    long long v47 = "kCellular";
  }
  else {
    long long v47 = off_101A082D0[v46];
  }
  size_t v48 = strlen(v47);
  long long v49 = sub_10004B96C(v45, (uint64_t)v47, v48);
  uint64_t v50 = sub_10004B96C(v49, (uint64_t)", ", 2);
  uint64_t v51 = *((int *)a1 + 45);
  if (v51 > 4) {
    BOOL v52 = "kCellular";
  }
  else {
    BOOL v52 = off_101A082D0[v51];
  }
  size_t v53 = strlen(v52);
  uint64_t v54 = sub_10004B96C(v50, (uint64_t)v52, v53);
  sub_10004B96C(v54, (uint64_t)"]", 1);
  long long v55 = sub_10004B96C(v119, (uint64_t)", Gid: [", 8);
  int v56 = (char)a1[143];
  if (v56 >= 0) {
    uint64_t v57 = (uint64_t)(a1 + 120);
  }
  else {
    uint64_t v57 = *((void *)a1 + 15);
  }
  if (v56 >= 0) {
    uint64_t v58 = a1[143];
  }
  else {
    uint64_t v58 = *((void *)a1 + 16);
  }
  __int16 v59 = sub_10004B96C(v55, v57, v58);
  uint64_t v60 = sub_10004B96C(v59, (uint64_t)", ", 2);
  int v61 = (char)a1[167];
  if (v61 >= 0) {
    uint64_t v62 = (uint64_t)(a1 + 144);
  }
  else {
    uint64_t v62 = *((void *)a1 + 18);
  }
  if (v61 >= 0) {
    uint64_t v63 = a1[167];
  }
  else {
    uint64_t v63 = *((void *)a1 + 19);
  }
  uint64_t v64 = sub_10004B96C(v60, v62, v63);
  sub_10004B96C(v64, (uint64_t)"]", 1);
  long long v65 = sub_10004B96C(v119, (uint64_t)", Did First Unlock: ", 20);
  if (a1[184]) {
    uint64_t v66 = "true";
  }
  else {
    uint64_t v66 = "false";
  }
  if (a1[184]) {
    uint64_t v67 = 4;
  }
  else {
    uint64_t v67 = 5;
  }
  sub_10004B96C(v65, (uint64_t)v66, v67);
  uint64_t v68 = sub_10004B96C(v119, (uint64_t)", Feature Disabled By profile: ", 31);
  if (a1[185]) {
    long long v69 = "true";
  }
  else {
    long long v69 = "false";
  }
  if (a1[185]) {
    uint64_t v70 = 4;
  }
  else {
    uint64_t v70 = 5;
  }
  sub_10004B96C(v68, (uint64_t)v69, v70);
  long long v71 = sub_10004B96C(v119, (uint64_t)", Feature Disabled Store Demo: ", 31);
  if (a1[186]) {
    uint64_t v72 = "true";
  }
  else {
    uint64_t v72 = "false";
  }
  if (a1[186]) {
    uint64_t v73 = 4;
  }
  else {
    uint64_t v73 = 5;
  }
  sub_10004B96C(v71, (uint64_t)v72, v73);
  if (a2[192])
  {
    sub_10004B96C(v119, (uint64_t)" Changed: ", 10);
    uint64_t v74 = a2[23];
    if ((v74 & 0x80u) == 0) {
      uint64_t v75 = a2[23];
    }
    else {
      uint64_t v75 = *((void *)a2 + 1);
    }
    uint64_t v76 = a1[23];
    int v77 = (char)v76;
    if ((v76 & 0x80u) != 0) {
      uint64_t v76 = *((void *)a1 + 1);
    }
    if (v75 == v76)
    {
      if (v77 >= 0) {
        uint64_t v78 = a1;
      }
      else {
        uint64_t v78 = *(unsigned __int8 **)a1;
      }
      if ((v74 & 0x80) == 0)
      {
        if (a2[23])
        {
          long long v79 = "Cached-IMSI";
          uint64_t v80 = 11;
          long long v81 = a2;
          while (*v81 == *v78)
          {
            ++v81;
            ++v78;
            if (!--v74) {
              goto LABEL_151;
            }
          }
          goto LABEL_204;
        }
LABEL_151:
        uint64_t v82 = a2[47];
        if ((v82 & 0x80u) == 0) {
          uint64_t v83 = a2[47];
        }
        else {
          uint64_t v83 = *((void *)a2 + 4);
        }
        uint64_t v84 = a1[47];
        int v85 = (char)v84;
        if ((v84 & 0x80u) != 0) {
          uint64_t v84 = *((void *)a1 + 4);
        }
        if (v83 == v84)
        {
          __int16 v86 = (const void **)(a2 + 24);
          if (v85 >= 0) {
            uint64_t v87 = a1 + 24;
          }
          else {
            uint64_t v87 = *(unsigned __int8 **)v11;
          }
          if ((v82 & 0x80) == 0)
          {
            if (a2[47])
            {
              long long v79 = "IMEI";
              uint64_t v80 = 4;
              while (*(unsigned __int8 *)v86 == *v87)
              {
                __int16 v86 = (const void **)((char *)v86 + 1);
                ++v87;
                if (!--v82) {
                  goto LABEL_169;
                }
              }
              goto LABEL_204;
            }
LABEL_169:
            uint64_t v88 = a2[71];
            if ((v88 & 0x80u) == 0) {
              uint64_t v89 = a2[71];
            }
            else {
              uint64_t v89 = *((void *)a2 + 7);
            }
            uint64_t v90 = a1[71];
            int v91 = (char)v90;
            if ((v90 & 0x80u) != 0) {
              uint64_t v90 = *((void *)a1 + 7);
            }
            if (v89 == v90)
            {
              long long v92 = (const void **)(a2 + 48);
              if (v91 >= 0) {
                uint64_t v93 = a1 + 48;
              }
              else {
                uint64_t v93 = *(unsigned __int8 **)v17;
              }
              if ((v88 & 0x80) == 0)
              {
                if (a2[71])
                {
                  long long v79 = "URL";
                  uint64_t v80 = 3;
                  while (*(unsigned __int8 *)v92 == *v93)
                  {
                    long long v92 = (const void **)((char *)v92 + 1);
                    ++v93;
                    if (!--v88) {
                      goto LABEL_186;
                    }
                  }
                  goto LABEL_204;
                }
LABEL_186:
                uint64_t v94 = a2[95];
                if ((v94 & 0x80u) == 0) {
                  uint64_t v95 = a2[95];
                }
                else {
                  uint64_t v95 = *((void *)a2 + 10);
                }
                uint64_t v96 = a1[95];
                int v97 = (char)v96;
                if ((v96 & 0x80u) != 0) {
                  uint64_t v96 = *((void *)a1 + 10);
                }
                if (v95 == v96)
                {
                  long long v98 = (const void **)(a2 + 72);
                  if (v97 >= 0) {
                    uint64_t v99 = a1 + 72;
                  }
                  else {
                    uint64_t v99 = *(unsigned __int8 **)v23;
                  }
                  if ((v94 & 0x80) == 0)
                  {
                    if (a2[95])
                    {
                      long long v79 = "MSISDN";
                      uint64_t v80 = 6;
                      while (*(unsigned __int8 *)v98 == *v99)
                      {
                        long long v98 = (const void **)((char *)v98 + 1);
                        ++v99;
                        if (!--v94) {
                          goto LABEL_208;
                        }
                      }
                      goto LABEL_204;
                    }
LABEL_208:
                    int v102 = a1[169];
                    if (a2[169]) {
                      BOOL v103 = v102 == 0;
                    }
                    else {
                      BOOL v103 = 1;
                    }
                    if (v103)
                    {
                      if ((a2[169] != 0) != (v102 != 0))
                      {
LABEL_231:
                        long long v79 = "Switch";
                        goto LABEL_203;
                      }
                    }
                    else if (a2[168] != a1[168])
                    {
                      goto LABEL_231;
                    }
                    if (a2[173] != a1[173])
                    {
                      long long v79 = "Switch(default)";
                      uint64_t v80 = 15;
                      goto LABEL_204;
                    }
                    if (a2[171] == a1[171])
                    {
                      if (a2[172] != a1[172])
                      {
                        long long v79 = "Carrier based support";
                        uint64_t v80 = 21;
                        goto LABEL_204;
                      }
                      if (*((_DWORD *)a2 + 44) == *((_DWORD *)a1 + 44))
                      {
                        if (*((_DWORD *)a2 + 45) != *((_DWORD *)a1 + 45))
                        {
                          long long v79 = "Ims interface";
                          uint64_t v80 = 13;
                          goto LABEL_204;
                        }
                        if (sub_10001D294(a2 + 120, a1 + 120))
                        {
                          if (sub_10001D294(a2 + 144, a1 + 144))
                          {
                            if (a2[184] == a1[184])
                            {
                              if (a2[185] == a1[185])
                              {
                                if (a2[186] == a1[186])
                                {
                                  int v104 = a2[170];
                                  int v105 = a1[170];
                                  if (v104 == v105) {
                                    long long v79 = "(nothing)";
                                  }
                                  else {
                                    long long v79 = "SMS online";
                                  }
                                  if (v104 == v105) {
                                    uint64_t v80 = 9;
                                  }
                                  else {
                                    uint64_t v80 = 10;
                                  }
                                  goto LABEL_204;
                                }
                                long long v79 = "Feature disabled store demo";
                              }
                              else
                              {
                                long long v79 = "Feature disabled by profile";
                              }
                              uint64_t v80 = 27;
                            }
                            else
                            {
                              long long v79 = "First unlock state";
                              uint64_t v80 = 18;
                            }
LABEL_204:
                            sub_10004B96C(v119, (uint64_t)v79, v80);
                            goto LABEL_205;
                          }
                          long long v79 = "GID2";
                        }
                        else
                        {
                          long long v79 = "GID1";
                        }
LABEL_168:
                        uint64_t v80 = 4;
                        goto LABEL_204;
                      }
                      long long v79 = "Prov interface";
                    }
                    else
                    {
                      long long v79 = "Bundle support";
                    }
                    uint64_t v80 = 14;
                    goto LABEL_204;
                  }
                  if (!memcmp(*v98, v99, *((void *)a2 + 10))) {
                    goto LABEL_208;
                  }
                }
                long long v79 = "MSISDN";
LABEL_203:
                uint64_t v80 = 6;
                goto LABEL_204;
              }
              if (!memcmp(*v92, v93, *((void *)a2 + 7))) {
                goto LABEL_186;
              }
            }
            long long v79 = "URL";
            uint64_t v80 = 3;
            goto LABEL_204;
          }
          if (!memcmp(*v86, v87, *((void *)a2 + 4))) {
            goto LABEL_169;
          }
        }
        long long v79 = "IMEI";
        goto LABEL_168;
      }
      if (!memcmp(*(const void **)a2, v78, *((void *)a2 + 1))) {
        goto LABEL_151;
      }
    }
    long long v79 = "Cached-IMSI";
    uint64_t v80 = 11;
    goto LABEL_204;
  }
LABEL_205:
  sub_10004BC98((uint64_t)v119 + 8, a3);
  *(void *)((char *)&v119[-1]
  *(void *)&v119[0] = v100;
  if (SHIBYTE(v121) < 0) {
    operator delete(v120[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1007ACAD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44)
{
}

uint64_t sub_1007ACBA8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  uint64_t v6 = a2;
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a1, a2, *((void *)a1 + 1))) {
      return 0;
    }
  }
  else if (a1[23])
  {
    uint64_t v8 = a1;
    while (*v8 == *a2)
    {
      ++v8;
      ++a2;
      if (!--v2) {
        goto LABEL_16;
      }
    }
    return 0;
  }
LABEL_16:
  uint64_t v9 = a1[47];
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = a1[47];
  }
  else {
    uint64_t v10 = *((void *)a1 + 4);
  }
  uint64_t v11 = v6[47];
  int v12 = (char)v11;
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *((void *)v6 + 4);
  }
  if (v10 != v11) {
    return 0;
  }
  uint64_t v13 = (const void **)(a1 + 24);
  if (v12 >= 0) {
    uint64_t v14 = v6 + 24;
  }
  else {
    uint64_t v14 = (unsigned __int8 *)*((void *)v6 + 3);
  }
  if ((v9 & 0x80) != 0)
  {
    if (memcmp(*v13, v14, *((void *)a1 + 4))) {
      return 0;
    }
  }
  else if (a1[47])
  {
    while (*(unsigned __int8 *)v13 == *v14)
    {
      uint64_t v13 = (const void **)((char *)v13 + 1);
      ++v14;
      if (!--v9) {
        goto LABEL_31;
      }
    }
    return 0;
  }
LABEL_31:
  uint64_t v15 = (unsigned __int8 *)*((void *)a1 + 15);
  uint64_t v16 = (unsigned __int8 *)*((void *)a1 + 16);
  uint64_t v17 = (unsigned __int8 *)*((void *)v6 + 15);
  if (v16 - v15 != *((void *)v6 + 16) - (void)v17) {
    return 0;
  }
  while (v15 != v16)
  {
    uint64_t result = sub_1000609C0((uint64_t)&v48, v15, v17);
    if (!result) {
      return result;
    }
    v15 += 24;
    v17 += 24;
  }
  unsigned int v19 = (unsigned __int8 *)*((void *)a1 + 18);
  uint64_t v20 = (unsigned __int8 *)*((void *)a1 + 19);
  uint64_t v21 = (unsigned __int8 *)*((void *)v6 + 18);
  if (v20 - v19 != *((void *)v6 + 19) - (void)v21) {
    return 0;
  }
  while (v19 != v20)
  {
    uint64_t result = sub_1000609C0((uint64_t)&v49, v19, v21);
    if (!result) {
      return result;
    }
    v19 += 24;
    v21 += 24;
  }
  uint64_t v22 = a1[95];
  if ((v22 & 0x80u) == 0) {
    uint64_t v23 = a1[95];
  }
  else {
    uint64_t v23 = *((void *)a1 + 10);
  }
  uint64_t v24 = v6[95];
  int v25 = (char)v24;
  if ((v24 & 0x80u) != 0) {
    uint64_t v24 = *((void *)v6 + 10);
  }
  if (v23 != v24) {
    return 0;
  }
  uint64_t v26 = (const void **)(a1 + 72);
  if (v25 >= 0) {
    uint64_t v27 = v6 + 72;
  }
  else {
    uint64_t v27 = (unsigned __int8 *)*((void *)v6 + 9);
  }
  if ((v22 & 0x80) != 0)
  {
    if (memcmp(*v26, v27, *((void *)a1 + 10))) {
      return 0;
    }
  }
  else if (a1[95])
  {
    while (*(unsigned __int8 *)v26 == *v27)
    {
      uint64_t v26 = (const void **)((char *)v26 + 1);
      ++v27;
      if (!--v22) {
        goto LABEL_54;
      }
    }
    return 0;
  }
LABEL_54:
  uint64_t v28 = a1[119];
  if ((v28 & 0x80u) == 0) {
    uint64_t v29 = a1[119];
  }
  else {
    uint64_t v29 = *((void *)a1 + 13);
  }
  uint64_t v30 = v6[119];
  int v31 = (char)v30;
  if ((v30 & 0x80u) != 0) {
    uint64_t v30 = *((void *)v6 + 13);
  }
  if (v29 != v30) {
    return 0;
  }
  uint64_t v32 = (const void **)(a1 + 96);
  if (v31 >= 0) {
    long long v33 = v6 + 96;
  }
  else {
    long long v33 = (unsigned __int8 *)*((void *)v6 + 12);
  }
  if ((v28 & 0x80) != 0)
  {
    if (memcmp(*v32, v33, *((void *)a1 + 13))) {
      return 0;
    }
  }
  else if (a1[119])
  {
    while (*(unsigned __int8 *)v32 == *v33)
    {
      uint64_t v32 = (const void **)((char *)v32 + 1);
      ++v33;
      if (!--v28) {
        goto LABEL_69;
      }
    }
    return 0;
  }
LABEL_69:
  uint64_t result = sub_10001D294(a1 + 48, v6 + 48);
  if (!result) {
    return result;
  }
  if (a1[249] != v6[249] || *((_DWORD *)a1 + 63) != *((_DWORD *)v6 + 63)) {
    return 0;
  }
  uint64_t result = sub_10001D294(a1 + 256, v6 + 256);
  if (!result) {
    return result;
  }
  if (a1[246] != v6[246] || a1[247] != v6[247] || a1[248] != v6[248]) {
    return 0;
  }
  if (a1[176])
  {
    uint64_t result = 0;
    if (!v6[176] || *((void *)a1 + 21) != *((void *)v6 + 21)) {
      return result;
    }
  }
  else if (v6[176])
  {
    return 0;
  }
  if (a1[192])
  {
    uint64_t result = 0;
    if (!v6[192] || *((void *)a1 + 23) != *((void *)v6 + 23)) {
      return result;
    }
  }
  else if (v6[192])
  {
    return 0;
  }
  if (a1[208])
  {
    uint64_t result = 0;
    if (!v6[208] || *((void *)a1 + 25) != *((void *)v6 + 25)) {
      return result;
    }
  }
  else if (v6[208])
  {
    return 0;
  }
  unsigned int v34 = *((unsigned __int16 *)v6 + 116);
  unsigned int v35 = v34 >> 8;
  if (*((unsigned __int16 *)a1 + 116) > 0xFFu)
  {
    uint64_t result = 0;
    if (!v35 || *((_WORD *)a1 + 116) != v34) {
      return result;
    }
  }
  else if (v35)
  {
    return 0;
  }
  unsigned int v36 = *((unsigned __int16 *)v6 + 117);
  unsigned int v37 = v36 >> 8;
  if (*((unsigned __int16 *)a1 + 117) > 0xFFu)
  {
    uint64_t result = 0;
    if (!v37 || *((_WORD *)a1 + 117) != v36) {
      return result;
    }
  }
  else if (v37)
  {
    return 0;
  }
  unsigned int v38 = *((unsigned __int16 *)v6 + 118);
  unsigned int v39 = v38 >> 8;
  if (*((unsigned __int16 *)a1 + 118) > 0xFFu)
  {
    uint64_t result = 0;
    if (!v39 || *((_WORD *)a1 + 118) != v38) {
      return result;
    }
  }
  else if (v39)
  {
    return 0;
  }
  unsigned int v40 = *((unsigned __int16 *)v6 + 119);
  unsigned int v41 = v40 >> 8;
  if (*((unsigned __int16 *)a1 + 119) > 0xFFu)
  {
    uint64_t result = 0;
    if (!v41 || *((_WORD *)a1 + 119) != v40) {
      return result;
    }
  }
  else if (v41)
  {
    return 0;
  }
  unsigned int v42 = *((unsigned __int16 *)v6 + 121);
  unsigned int v43 = v42 >> 8;
  if (*((unsigned __int16 *)a1 + 121) <= 0xFFu)
  {
    if (!v43) {
      goto LABEL_116;
    }
    return 0;
  }
  uint64_t result = 0;
  if (!v43 || *((_WORD *)a1 + 121) != v42) {
    return result;
  }
LABEL_116:
  unsigned int v44 = *((unsigned __int16 *)v6 + 120);
  unsigned int v45 = v44 >> 8;
  if (*((unsigned __int16 *)a1 + 120) > 0xFFu)
  {
    uint64_t result = 0;
    if (!v45 || *((_WORD *)a1 + 120) != v44) {
      return result;
    }
  }
  else if (v45)
  {
    return 0;
  }
  int v46 = HIBYTE(*((unsigned __int16 *)v6 + 122));
  if (*((unsigned __int16 *)a1 + 122) >= 0x100u) {
    return v46 && *((_WORD *)a1 + 122) == *((_WORD *)v6 + 122);
  }
  else {
    return v46 == 0;
  }
}

BOOL sub_1007AD098(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  uint64_t v6 = a2;
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a1, a2, *((void *)a1 + 1))) {
      return 0;
    }
  }
  else if (a1[23])
  {
    uint64_t v8 = a1;
    while (*v8 == *a2)
    {
      ++v8;
      ++a2;
      if (!--v2) {
        goto LABEL_16;
      }
    }
    return 0;
  }
LABEL_16:
  uint64_t v9 = a1[47];
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = a1[47];
  }
  else {
    uint64_t v10 = *((void *)a1 + 4);
  }
  uint64_t v11 = v6[47];
  int v12 = (char)v11;
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *((void *)v6 + 4);
  }
  if (v10 != v11) {
    return 0;
  }
  uint64_t v13 = (const void **)(a1 + 24);
  if (v12 >= 0) {
    uint64_t v14 = v6 + 24;
  }
  else {
    uint64_t v14 = (unsigned __int8 *)*((void *)v6 + 3);
  }
  if ((v9 & 0x80) != 0)
  {
    if (memcmp(*v13, v14, *((void *)a1 + 4))) {
      return 0;
    }
  }
  else if (a1[47])
  {
    while (*(unsigned __int8 *)v13 == *v14)
    {
      uint64_t v13 = (const void **)((char *)v13 + 1);
      ++v14;
      if (!--v9) {
        goto LABEL_31;
      }
    }
    return 0;
  }
LABEL_31:
  uint64_t v15 = a1[71];
  if ((v15 & 0x80u) == 0) {
    uint64_t v16 = a1[71];
  }
  else {
    uint64_t v16 = *((void *)a1 + 7);
  }
  uint64_t v17 = v6[71];
  int v18 = (char)v17;
  if ((v17 & 0x80u) != 0) {
    uint64_t v17 = *((void *)v6 + 7);
  }
  if (v16 != v17) {
    return 0;
  }
  unsigned int v19 = (const void **)(a1 + 48);
  if (v18 >= 0) {
    uint64_t v20 = v6 + 48;
  }
  else {
    uint64_t v20 = (unsigned __int8 *)*((void *)v6 + 6);
  }
  if ((v15 & 0x80) != 0)
  {
    if (memcmp(*v19, v20, *((void *)a1 + 7))) {
      return 0;
    }
  }
  else if (a1[71])
  {
    while (*(unsigned __int8 *)v19 == *v20)
    {
      unsigned int v19 = (const void **)((char *)v19 + 1);
      ++v20;
      if (!--v15) {
        goto LABEL_46;
      }
    }
    return 0;
  }
LABEL_46:
  if (*((void *)a1 + 9) == *((void *)v6 + 9) && a1[80] == v6[80]) {
    return a1[81] == v6[81];
  }
  return 0;
}

BOOL sub_1007AD264(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a2 + 8);
  if (*(unsigned char *)(a1 + 8)) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if ((*(unsigned char *)(a1 + 8) != 0) != (v2 != 0)) {
      return 0;
    }
  }
  else if (*(void *)a1 != *(void *)a2)
  {
    return 0;
  }
  int v4 = *(unsigned __int8 *)(a2 + 24);
  if (*(unsigned char *)(a1 + 24)) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
      return 0;
    }
    return *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32);
  }
  if ((*(unsigned char *)(a1 + 24) != 0) == (v4 != 0)) {
    return *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32);
  }
  return 0;
}

void *sub_1007AD2FC(void *a1)
{
  *a1 = off_101A08308;
  int v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1007AD348(void *a1)
{
  *a1 = off_101A08308;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1007AD3B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    std::exception v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 144))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1007AD450(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void CSIRadioModulePrivate::CSIRadioModulePrivate(uint64_t a1, uint64_t *a2)
{
  *(void *)a1 = off_101A2DBE0;
  *(void *)(a1 + 8) = off_1019E6A48;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = off_101A56230;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v10, kCtLoggingSystemName, LogGroupName);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v10);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
  *(void *)a1 = off_101A08338;
  *(void *)(a1 + 8) = off_101A08590;
  *(void *)(a1 + 16) = off_101A085B8;
  *(void *)(a1 + 48) = dispatch_queue_create("CSIRadioModulePrivate", 0);
  ATCSMutex::ATCSMutex((ATCSMutex *)(a1 + 56), "radio module lock");
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  ATCSDPCQueue::ATCSDPCQueue((ATCSDPCQueue *)(a1 + 80));
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  sub_100058DB0(&__p, "RadioModule");
  BOOL v5 = *(NSObject **)(a1 + 48);
  std::exception v7 = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  ctu::RestModule::RestModule();
  if (v7) {
    dispatch_release(v7);
  }
  if (v9 < 0) {
    operator delete(__p);
  }
  *(_DWORD *)(a1 + 212) = 0;
  uint64_t v6 = *a2;
  *a2 = 0;
  *(void *)(a1 + 216) = v6;
  *(void *)(a1 + 248) = 0;
  *(unsigned char *)(a1 + 256) = 0;
  *(void *)(a1 + 288) = 0;
  *(unsigned char *)(a1 + 296) = 0;
  *(void *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_WORD *)(a1 + 340) = 1;
  *(void *)(a1 + 344) = 0x200000000;
  *(_WORD *)(a1 + 352) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  ATCSCondition::ATCSCondition((ATCSCondition *)(a1 + 392), "state change wait");
  sub_100BAC8C8(a1 + 400);
  *(void *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 432) = 0;
  sub_100360720((void *)(a1 + 440));
}

void sub_1007AD74C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v24 = v20;
  ATCSTimer::~ATCSTimer(v24);
  uint64_t v26 = *(std::__shared_weak_count **)(v16 + 576);
  if (v26) {
    sub_10004D2C8(v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v16 + 560);
  if (v27) {
    sub_10004D2C8(v27);
  }
  uint64_t v28 = *(NSObject **)(v16 + 544);
  if (v28)
  {
    dispatch_group_leave(v28);
    uint64_t v29 = *(NSObject **)(v16 + 544);
    if (v29) {
      dispatch_release(v29);
    }
  }
  uint64_t v30 = *(NSObject **)(v16 + 536);
  if (v30)
  {
    dispatch_group_leave(v30);
    int v31 = *(NSObject **)(v16 + 536);
    if (v31) {
      dispatch_release(v31);
    }
  }
  if (*(char *)(v16 + 503) < 0) {
    operator delete(*(void **)(v16 + 480));
  }
  sub_1007AD924(v23);
  if (*(char *)(v16 + 423) < 0) {
    operator delete(*v22);
  }
  ATCSCondition::~ATCSCondition(v21);
  uint64_t v32 = *(std::__shared_weak_count **)(v16 + 368);
  if (v32) {
    sub_10004D2C8(v32);
  }
  sub_1007B0C90((void *)(v16 + 304));
  sub_10030AB98((void *)(v16 + 264));
  sub_100060644((void *)(v16 + 224));
  uint64_t v33 = *(void *)(v16 + 216);
  *(void *)(v16 + 216) = 0;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
  }
  unsigned int v34 = *(std::__shared_weak_count **)(v16 + 200);
  if (v34) {
    sub_10004D2C8(v34);
  }
  unsigned int v35 = *(std::__shared_weak_count **)(v16 + 184);
  if (v35) {
    sub_10004D2C8(v35);
  }
  ATCSDPCQueue::~ATCSDPCQueue(v19);
  unsigned int v36 = *(std::__shared_weak_count **)(v16 + 72);
  if (v36) {
    sub_10004D2C8(v36);
  }
  ATCSMutex::~ATCSMutex(v18);
  unsigned int v37 = *(NSObject **)(v16 + 48);
  if (v37) {
    dispatch_release(v37);
  }
  ctu::OsLogLogger::~OsLogLogger(v17);
  unsigned int v38 = *(std::__shared_weak_count **)(v16 + 32);
  if (v38) {
    std::__shared_weak_count::__release_weak(v38);
  }
  _Unwind_Resume(a1);
}

void sub_1007AD8EC()
{
}

void sub_1007AD8F4()
{
}

void sub_1007AD8FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  JUMPOUT(0x1007AD8D8);
}

void sub_1007AD91C()
{
}

uint64_t sub_1007AD924(uint64_t a1)
{
  *(void *)a1 = off_1019AC298;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void CSIRadioModulePrivate::~CSIRadioModulePrivate(CSIRadioModulePrivate *this)
{
  *(void *)this = off_101A08338;
  *((void *)this + 1) = off_101A08590;
  *((void *)this + 2) = off_101A085B8;
  uint64_t v2 = *((void *)this + 63);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  BOOL v3 = (std::__shared_weak_count *)*((void *)this + 96);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 94);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10011A838((uint64_t *)this + 90);
  sub_10066AA88((uint64_t *)this + 87);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 86);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 84);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 82);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (*((char *)this + 639) < 0) {
    operator delete(*((void **)this + 77));
  }
  ATCSTimer::~ATCSTimer((CSIRadioModulePrivate *)((char *)this + 584));
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 72);
  if (v8) {
    sub_10004D2C8(v8);
  }
  char v9 = (std::__shared_weak_count *)*((void *)this + 70);
  if (v9) {
    sub_10004D2C8(v9);
  }
  OsLogContext v10 = *((void *)this + 68);
  if (v10)
  {
    dispatch_group_leave(v10);
    uint64_t v11 = *((void *)this + 68);
    if (v11) {
      dispatch_release(v11);
    }
  }
  int v12 = *((void *)this + 67);
  if (v12)
  {
    dispatch_group_leave(v12);
    uint64_t v13 = *((void *)this + 67);
    if (v13) {
      dispatch_release(v13);
    }
  }
  if (*((char *)this + 503) < 0) {
    operator delete(*((void **)this + 60));
  }
  sub_100160AF8((atomic_uint **)this + 59);
  *((void *)this + 55) = off_1019AC298;
  sub_10000A740((atomic_uint **)this + 57);
  if (*((char *)this + 423) < 0) {
    operator delete(*((void **)this + 50));
  }
  ATCSCondition::~ATCSCondition((CSIRadioModulePrivate *)((char *)this + 392));
  uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 46);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_1007B0C90((void *)this + 38);
  sub_10030AB98((void *)this + 33);
  sub_100060644((void *)this + 28);
  uint64_t v15 = *((void *)this + 27);
  *((void *)this + 27) = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 25);
  if (v16) {
    sub_10004D2C8(v16);
  }
  uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v17) {
    sub_10004D2C8(v17);
  }
  ATCSDPCQueue::~ATCSDPCQueue((CSIRadioModulePrivate *)((char *)this + 80));
  int v18 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v18) {
    sub_10004D2C8(v18);
  }
  ATCSMutex::~ATCSMutex((CSIRadioModulePrivate *)((char *)this + 56));
  unsigned int v19 = *((void *)this + 6);
  if (v19) {
    dispatch_release(v19);
  }
  ctu::OsLogLogger::~OsLogLogger((CSIRadioModulePrivate *)((char *)this + 40));
  uint64_t v20 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
}

void CSIRadioModulePrivate::init(CSIRadioModulePrivate *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (!v2 || (v3 = *((void *)this + 3), (int v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  uint64_t v6 = operator new(0x30uLL);
  v6[1] = 0;
  _OWORD v6[2] = 0;
  void *v6 = off_101A086A0;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  void v6[3] = off_101A08308;
  void v6[4] = v3;
  v6[5] = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  std::__shared_weak_count::__release_weak(v5);
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 23);
  *((void *)this + 22) = v6 + 3;
  *((void *)this + 23) = v6;
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_10004D2C8(v5);
  Registry::get((uint64_t *)buf, v8);
  char v9 = (Registry **)((char *)this + 744);
  long long v10 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 94);
  *(_OWORD *)((char *)this + 744) = v10;
  if (v11)
  {
    sub_10004D2C8(v11);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    int v12 = *v9;
    if (*v9)
    {
LABEL_9:
      ServiceMap = (std::mutex *)Registry::getServiceMap(v12);
      uint64_t v14 = ServiceMap;
      uint64_t v15 = "19RadioStateAggregate";
      if (((unint64_t)"19RadioStateAggregate" & 0x8000000000000000) != 0)
      {
        uint64_t v16 = (unsigned __int8 *)((unint64_t)"19RadioStateAggregate" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v17 = 5381;
        do
        {
          uint64_t v15 = (const char *)v17;
          unsigned int v18 = *v16++;
          uint64_t v17 = (33 * v17) ^ v18;
        }
        while (v18);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v15;
      unsigned int v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
      if (v19)
      {
        uint64_t v21 = v19[3];
        uint64_t v20 = (std::__shared_weak_count *)v19[4];
        if (v20)
        {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v14);
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v20);
          goto LABEL_20;
        }
      }
      else
      {
        uint64_t v21 = 0;
      }
      std::mutex::unlock(v14);
      uint64_t v20 = 0;
LABEL_20:
      uint64_t v23 = (std::__shared_weak_count *)*((void *)this + 46);
      *((void *)this + 45) = v21;
      *((void *)this + 46) = v20;
      if (v23) {
        sub_10004D2C8(v23);
      }
      uint64_t v24 = *((void *)this + 94);
      if (v24) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
      }
      int v25 = (std::__shared_weak_count *)*((void *)this + 4);
      if (v25)
      {
        if (std::__shared_weak_count::lock(v25)) {
          sub_1008EB424();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    int v12 = (Registry *)v10;
    if ((void)v10) {
      goto LABEL_9;
    }
  }
  uint64_t v22 = *((void *)this + 5);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to get Registry!!!!!", buf, 2u);
  }
}

void sub_1007ADF80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CSIRadioModulePrivate::changeState(uint64_t a1, unsigned int a2)
{
  CSIGetTime();
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(int *)(a1 + 380);
    if (v5 > 8) {
      uint64_t v6 = "???";
    }
    else {
      uint64_t v6 = off_101A08C78[v5];
    }
    if (a2 > 8) {
      uint64_t v7 = "???";
    }
    else {
      uint64_t v7 = off_101A08C78[a2];
    }
    *(_DWORD *)long long buf = 136317442;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v11 = 2080;
    int v12 = v7;
    __int16 v13 = 1024;
    int v14 = 0;
    __int16 v15 = 1024;
    int v16 = 0;
    __int16 v17 = 1024;
    int v18 = 0;
    __int16 v19 = 1024;
    int v20 = 0;
    __int16 v21 = 1024;
    int v22 = 0;
    __int16 v23 = 1024;
    int v24 = 0;
    __int16 v25 = 1024;
    int v26 = 0;
    __int16 v27 = 2080;
    uint64_t v28 = "ST";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Changing state from %s to %s at %d:%02d:%02d (%+d) %02d/%02d/%4d %s", buf, 0x4Au);
  }
  uint64_t v8 = a1 + 304;
  *(void *)long long buf = *(void *)(a1 + 336);
  if (a2 - 7 < 2)
  {
    *(_DWORD *)long long buf = 0;
    uint8_t buf[4] = 1;
  }
  else
  {
    if (a2 == 5)
    {
      uint8_t buf[4] = 1;
      *(_DWORD *)long long buf = 0;
      uint64_t result = sub_100655E2C(v8, (int *)buf);
      *(_DWORD *)(a1 + 380) = 5;
      goto LABEL_23;
    }
    if (a2 == 1)
    {
      uint8_t buf[4] = 0;
      uint64_t result = sub_100655E2C(v8, (int *)buf);
      *(_DWORD *)(a1 + 380) = 1;
LABEL_16:
      if (!*(unsigned char *)(a1 + 296)) {
        goto LABEL_23;
      }
      *(unsigned char *)(a1 + 296) = 0;
      goto LABEL_21;
    }
  }
  uint64_t result = sub_100655E2C(v8, (int *)buf);
  *(_DWORD *)(a1 + 380) = a2;
  if (a2 != 8)
  {
    if (a2 != 1) {
      goto LABEL_23;
    }
    goto LABEL_16;
  }
  if (*(unsigned char *)(a1 + 296)) {
    goto LABEL_23;
  }
  *(unsigned char *)(a1 + 296) = 1;
LABEL_21:
  uint64_t result = *(void *)(a1 + 288);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, a1 + 296);
  }
LABEL_23:
  if (*(_DWORD *)(a1 + 384)) {
    return ATCSCondition::signal((ATCSCondition *)(a1 + 392));
  }
  return result;
}

uint64_t CSIRadioModulePrivate::getOsVersion@<X0>(CSIRadioModulePrivate *this@<X0>, uint64_t a2@<X8>)
{
  int v4 = (CSIRadioModulePrivate *)((char *)this + 56);
  ATCSMutex::lock((CSIRadioModulePrivate *)((char *)this + 56));
  if (*((char *)this + 423) < 0)
  {
    sub_10004FC84((unsigned char *)a2, *((void **)this + 50), *((void *)this + 51));
  }
  else
  {
    *(_OWORD *)a2 = *((_OWORD *)this + 25);
    *(void *)(a2 + 16) = *((void *)this + 52);
  }
  return ATCSMutex::unlock(v4);
}

void sub_1007AE298(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CSIRadioModulePrivate::startTracing_nl(uint64_t this)
{
  if (*(void *)(this + 504)) {
    operator new();
  }
  return this;
}

void sub_1007AE384()
{
}

uint64_t sub_1007AE3A8(uint64_t a1, int a2)
{
  int v4 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 560);
  *(_OWORD *)(a1 + 552) = 0u;
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (a2)
  {
    uint64_t v6 = *(int *)(a1 + 380);
    if ((v6 - 1) >= 3)
    {
      char v9 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        return ATCSMutex::unlock(v4);
      }
      if (v6 > 8) {
        long long v10 = "???";
      }
      else {
        long long v10 = off_101A08BA0[v6];
      }
      int v14 = 136315138;
      __int16 v15 = v10;
      int v12 = "#I State is %s, skipping start";
      goto LABEL_20;
    }
    (*(void (**)(void))(**(void **)(a1 + 64) + 48))(*(void *)(a1 + 64));
    if (*(void *)(a1 + 248))
    {
      uint64_t v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Failed to enter low power before, trying again", (uint8_t *)&v14, 2u);
      }
      uint64_t v8 = *(int *)(a1 + 380);
      if (v8 == 1)
      {
        CSIRadioModulePrivate::enterLowPowerInternal((CSIRadioModulePrivate *)a1);
        return ATCSMutex::unlock(v4);
      }
      char v9 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        return ATCSMutex::unlock(v4);
      }
      if (v8 > 8) {
        __int16 v11 = "???";
      }
      else {
        __int16 v11 = off_101A08BE8[v8];
      }
      int v14 = 136315138;
      __int16 v15 = v11;
      int v12 = "#I State is %s, trying again later";
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v14, 0xCu);
    }
  }
  return ATCSMutex::unlock(v4);
}

void sub_1007AE58C(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

BOOL CSIRadioModulePrivate::enterLowPowerInternal(CSIRadioModulePrivate *this)
{
  uint64_t v2 = (CSIRadioModulePrivate *)((char *)this + 56);
  if ((ATCSMutex::isLocked((CSIRadioModulePrivate *)((char *)this + 56)) & 1) == 0) {
    __TUAssertTrigger();
  }
  CSIRadioModulePrivate::changeState((uint64_t)this, 2u);
  ATCSMutex::unlock(v2);
  sub_100360A94((uint64_t *)this + 55, 3u, 0, 0, 0);
  (*(void (**)(CSIRadioModulePrivate *))(*(void *)this + 536))(this);
  (*(void (**)(CSIRadioModulePrivate *))(*(void *)this + 544))(this);
  ATCSMutex::lock(v2);
  uint64_t v3 = *((int *)this + 95);
  if (v3 == 2)
  {
    CSIRadioModulePrivate::changeState((uint64_t)this, 3u);
    sub_1007AE7BC(this, 1);
    int v4 = *((void *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Completed entering low power", (uint8_t *)&v8, 2u);
    }
  }
  else
  {
    uint64_t v5 = *((void *)this + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (v3 > 8) {
        uint64_t v6 = "???";
      }
      else {
        uint64_t v6 = off_101A08C30[v3];
      }
      int v8 = 136315138;
      char v9 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Failed entering low power due to state change to %s", (uint8_t *)&v8, 0xCu);
    }
    sub_1007AE7BC(this, 0);
  }
  return v3 == 2;
}

void *sub_1007AE7BC(void *result, char a2)
{
  if (result[31])
  {
    uint64_t v2 = result + 28;
    sub_1000607A8((uint64_t)(result + 28), a2);
    return sub_100555F38(v2);
  }
  return result;
}

void CSIRadioModulePrivate::resetCleanup_nl(void *a1, char *a2, int a3, uint64_t a4, uint64_t **a5)
{
  char v9 = a1[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a5 + 23) < 0) {
      a5 = (uint64_t **)*a5;
    }
    uint64_t v10 = *((int *)a1 + 95);
    if (v10 > 8) {
      __int16 v11 = "???";
    }
    else {
      __int16 v11 = off_101A08C78[v10];
    }
    *(_DWORD *)long long buf = 136446978;
    *(void *)&uint8_t buf[4] = a5;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a2;
    *(_WORD *)&unsigned char buf[22] = 1024;
    *(_DWORD *)&uint8_t buf[24] = a3;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Reset requested at %{public}s: %s, with logs = %d, rm state: %s", buf, 0x26u);
  }
  unsigned int v12 = *((_DWORD *)a1 + 95);
  BOOL v13 = v12 >= 7;
  unsigned int v14 = v12 - 7;
  if (!v13)
  {
LABEL_9:
    memset(buf, 0, sizeof(buf));
    __int16 v15 = a1[5];
    os_signpost_id_t v16 = os_signpost_id_generate(v15);
    if (v16 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      __int16 v17 = a1[5];
      if (os_signpost_enabled(v17))
      {
        *(_WORD *)unsigned int v35 = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v17, OS_SIGNPOST_INTERVAL_BEGIN, v16, "BasebandReset", (const char *)&unk_1017DEDA7, v35, 2u);
      }
    }
    *(void *)unsigned int v35 = off_101A08AE8;
    unsigned int v36 = v35;
    *(void *)long long buf = v16;
    *(void *)&uint8_t buf[8] = os_retain(v15);
    sub_1000336E8((uint64_t)&buf[16], (uint64_t)v35);
    sub_100033A10(v35);
    sub_100058DB0(&__p, "BasebandReset");
    v32[0] = *(void *)buf;
    v32[1] = *(void *)&buf[8];
    sub_1000336E8((uint64_t)&v33, (uint64_t)&buf[16]);
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_100033AF4(&buf[16]);
    Registry::createXpcJetsamAssertion();
    long long v18 = *(_OWORD *)v35;
    *(void *)unsigned int v35 = 0;
    *(void *)&v35[8] = 0;
    __int16 v19 = (std::__shared_weak_count *)a1[70];
    *(_OWORD *)(a1 + 69) = v18;
    if (v19)
    {
      sub_10004D2C8(v19);
      if (*(void *)&v35[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v35[8]);
      }
    }
    sub_1000339DC(v32);
    if (v30 < 0) {
      operator delete(__p);
    }
    (*(void (**)(void *, void *))(*a1 + 568))(a1, a1 + 77);
    int v20 = (std::string *)sub_100058DB0(v35, a2);
    __int16 v21 = std::string::insert(v20, 0, "modem reset: ", 0xDuLL);
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[0];
    v31[0] = v21->__r_.__value_.__l.__size_;
    *(void *)((char *)v31 + 7) = *(std::string::size_type *)((char *)&v21->__r_.__value_.__r.__words[1] + 7);
    char v23 = HIBYTE(v21->__r_.__value_.__r.__words[2]);
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    int v24 = (void **)(a1 + 60);
    if (*((char *)a1 + 503) < 0) {
      operator delete(*v24);
    }
    uint64_t v25 = v31[0];
    a1[60] = v22;
    a1[61] = v25;
    *(void *)((char *)a1 + 495) = *(void *)((char *)v31 + 7);
    *((unsigned char *)a1 + 503) = v23;
    if ((char)v35[23] < 0)
    {
      operator delete(*(void **)v35);
      if ((*((unsigned char *)a1 + 503) & 0x80) == 0) {
        goto LABEL_21;
      }
    }
    else if ((v23 & 0x80) == 0)
    {
LABEL_21:
      (*(void (**)(void *, void **))(*a1 + 512))(a1, v24);
      ATCSMutex::unlock((ATCSMutex *)(a1 + 7));
      if (a3) {
        sub_1007AED70((uint64_t)a1);
      }
      int v26 = a1[5];
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unsigned int v35 = 136315138;
        *(void *)&v35[4] = a2;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Silent Reset Requested: %s", v35, 0xCu);
      }
      if (a1[63]) {
        operator new();
      }
      ATCSMutex::lock((ATCSMutex *)(a1 + 7));
      sub_1000339DC((uint64_t *)buf);
      return;
    }
    int v24 = (void **)*v24;
    goto LABEL_21;
  }
  if (v14 > 1)
  {
    __TUAssertTrigger();
    goto LABEL_9;
  }
  __int16 v27 = a1[5];
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Ignoring reset request", buf, 2u);
  }
  uint64_t v28 = a1[67];
  a1[67] = 0;
  if (v28)
  {
    dispatch_group_leave(v28);
    dispatch_release(v28);
  }
}

void sub_1007AECE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
}

void sub_1007AED70(uint64_t a1)
{
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  (*(void (**)(uint64_t))(*(void *)a1 + 576))(a1);
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 380);
    if (v3 > 8) {
      int v4 = "???";
    }
    else {
      int v4 = off_101A08C78[v3];
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Reset in progress. Current state is '%s'", (uint8_t *)&v5, 0xCu);
  }
  if ((*(_DWORD *)(a1 + 380) | 2) != 7) {
    __TUAssertTrigger();
  }
  operator new();
}

void sub_1007AEEFC(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void CSIRadioModulePrivate::resetInternal(CSIRadioModulePrivate *this, const char *a2)
{
  if ((ATCSMutex::isLocked((CSIRadioModulePrivate *)((char *)this + 56)) & 1) == 0) {
    __TUAssertTrigger();
  }
  CSIRadioModulePrivate::changeState((uint64_t)this, 5u);
  ++*((_DWORD *)this + 108);
  (*(void (**)(void, void))(**((void **)this + 8) + 32))(*((void *)this + 8), 0);
  uint64_t v3 = *((void *)this + 5);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    LOWORD(v5) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband is reset, turning off Packet Interfaces", (uint8_t *)&v5, 2u);
  }
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  sub_1003BEF68((Registry *)v4, &v5);
  if (v5) {
    (*(void (**)(uint64_t, void, void))(*(void *)v5 + 456))(v5, 0, 0);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_1007AF05C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007AF074(uint64_t a1)
{
  uint64_t v2 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  if (*(_DWORD *)(a1 + 380) == 5)
  {
    if (!*(unsigned char *)(a1 + 256))
    {
      *(_DWORD *)(a1 + 424) = CSISystemElapsedTimeSecs();
      if (*(_DWORD *)(a1 + 428))
      {
        uint64_t v3 = (uint64_t **)sub_100365D74();
        sub_100058DB0(&__p, *(char **)(a1 + 640));
        int v8 = 0;
        sub_10044B194(v3, &__p, &v8);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        *(_DWORD *)(a1 + 428) = 0;
      }
      CSIRadioModulePrivate::changeState(a1, 6u);
      LODWORD(v4) = 1;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Back to back reset, ignoring reset", (uint8_t *)&__p, 2u);
    }
  }
  BOOL v4 = *(NSObject **)(a1 + 536);
  *(void *)(a1 + 536) = 0;
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
    LODWORD(v4) = 0;
  }
LABEL_12:
  ATCSMutex::unlock(v2);
  if (v4)
  {
    (*(void (**)(void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64));
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Reset complete", (uint8_t *)&__p, 2u);
    }
    uint64_t v7 = *(NSObject **)(a1 + 536);
    *(void *)(a1 + 536) = 0;
    if (v7)
    {
      dispatch_group_leave(v7);
      dispatch_release(v7);
    }
  }
}

void sub_1007AF20C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  ATCSMutex::unlock(v16);
  _Unwind_Resume(a1);
}

void CSIRadioModulePrivate::completeDumpState(uint64_t a1, std::string *a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 472))(a1);
  memset(&v38, 0, sizeof(v38));
  std::string::basic_string(&v38, a2, 0, 0xFFuLL, (std::allocator<char> *)&buf);
  BOOL v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I --------------  STATE DUMP --------------------", (uint8_t *)&buf, 2u);
    BOOL v4 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = &v38;
    if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v5 = (std::string *)v38.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Reason: %s", (uint8_t *)&buf, 0xCu);
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)a1 + 480))(a1, a2);
  sub_1007AF924();
  sub_100477910(&event::dumpState[3]);
  uint64_t v6 = (uint64_t *)sub_100161CDC(&event::dumpState[1]);
  sub_10035414C(v6);
  (*(void (**)(void))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64));
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = asStringBool(*(unsigned char *)(a1 + 296));
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I fBasebandFirmwareDead=%s", (uint8_t *)&buf, 0xCu);
    uint64_t v7 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 560))(a1);
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I DormancyMask=%x", (uint8_t *)&buf, 8u);
    uint64_t v7 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 648)) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I fAirplaneModeAssertionForBrickMode=%s", (uint8_t *)&buf, 0xCu);
    uint64_t v7 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 664)) {
      __int16 v11 = "true";
    }
    else {
      __int16 v11 = "false";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I fAirplaneModeAssertionForBreadMode=%s", (uint8_t *)&buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  BOOL v13 = ServiceMap;
  if (v14 < 0)
  {
    __int16 v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v14;
  long long v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&buf);
  if (v18)
  {
    uint64_t v20 = v18[3];
    __int16 v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v21 = 0;
      if (!v20) {
        goto LABEL_32;
      }
      goto LABEL_30;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v13);
  __int16 v19 = 0;
  char v21 = 1;
  if (!v20) {
    goto LABEL_32;
  }
LABEL_30:
  std::string::size_type v22 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 64))(v20);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I CommCenter starts since boot=%zu", (uint8_t *)&buf, 0xCu);
  }
LABEL_32:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  int v24 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    Registry::getXpcJetsamAssertionManager((uint64_t *)&v36, *(Registry **)(a1 + 744));
    ctu::XpcJetsamAssertion::dumpState((uint64_t *)&buf, v36);
    if (v40 >= 0) {
      p_long long buf = &buf;
    }
    else {
      p_long long buf = (long long *)buf;
    }
    *(_DWORD *)unsigned int v41 = 136446210;
    unsigned int v42 = p_buf;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %{public}s", v41, 0xCu);
    if (SHIBYTE(v40) < 0) {
      operator delete((void *)buf);
    }
    if (v37) {
      sub_10004D2C8(v37);
    }
    int v24 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I **************************", (uint8_t *)&buf, 2u);
  }
  long long buf = 0uLL;
  uint64_t v40 = 0;
  (*(void (**)(uint64_t, std::string *, long long *))(*(void *)a1 + 488))(a1, a2, &buf);
  if (qword_101B13C98 != -1) {
    dispatch_once(&qword_101B13C98, &stru_1019BBCD0);
  }
  int v26 = (unsigned char *)qword_101B13C90;
  int v27 = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
  std::string::size_type v28 = a2->__r_.__value_.__r.__words[0];
  CSIRadioModulePrivate::getUptime((CSIRadioModulePrivate *)a1);
  if (v27 >= 0) {
    char v34 = (char)a2;
  }
  else {
    char v34 = v28;
  }
  sub_100356D8C(v26, 0, "reset: reason=%s;uptime=%d;count=%d;%s", v29, v30, v31, v32, v33, v34);
  unsigned int v35 = *(std::__shared_weak_count **)(a1 + 752);
  unsigned int v36 = *(ctu::XpcJetsamAssertion **)(a1 + 744);
  unsigned int v37 = v35;
  if (v35) {
    atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100BCA380((Registry **)&v36);
  if (v37) {
    sub_10004D2C8(v37);
  }
  sleep(1u);
  if (SHIBYTE(v40) < 0) {
    operator delete((void *)buf);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
}

void sub_1007AF890(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007AF924()
{
  sub_100058DB0(&__p, "/cc/events/dump_state");
  xpc_object_t object = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
}

void sub_1007AF994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t CSIRadioModulePrivate::getUptime(CSIRadioModulePrivate *this)
{
  uint64_t v1 = this;
  char v2 = (CSIRadioModulePrivate *)((char *)this + 56);
  ATCSMutex::lock((CSIRadioModulePrivate *)((char *)this + 56));
  int v3 = CSISystemElapsedTimeSecs();
  int v4 = *((_DWORD *)v1 + 106);
  LODWORD(v1) = *((_DWORD *)v1 + 107);
  ATCSMutex::unlock(v2);
  return (v3 - v4 + v1);
}

void sub_1007AFA1C(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void CSIRadioModulePrivate::requestDumpMemory(CSIRadioModulePrivate *this, const char *a2)
{
  char v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315138;
    int v4 = "CommCenterMemory";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I memory to be dumped into %s", (uint8_t *)&v3, 0xCu);
  }
}

uint64_t CSIRadioModulePrivate::inResetState(CSIRadioModulePrivate *this)
{
  unsigned int v1 = *((_DWORD *)this + 95);
  if (v1 >= 9) {
    __assert_rtn("inResetState", "CSIRadioModulePrivate.cpp", 556, "false");
  }
  return (0x1E1u >> v1) & 1;
}

BOOL CSIRadioModulePrivate::isDead(CSIRadioModulePrivate *this)
{
  return *((_DWORD *)this + 95) == 8;
}

uint64_t CSIRadioModulePrivate::exitLowPower(CSIRadioModulePrivate *this)
{
  char v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Request to exit low power", (uint8_t *)&v20, 2u);
  }
  int v3 = (CSIRadioModulePrivate *)((char *)this + 56);
  ATCSMutex::lock((CSIRadioModulePrivate *)((char *)this + 56));
  unsigned int v4 = *((_DWORD *)this + 95);
  if (v4 == 2)
  {
    int v9 = *((void *)this + 5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Currently entering low power, waiting for state change", (uint8_t *)&v20, 2u);
    }
    int v10 = *((_DWORD *)this + 96) + 1;
    do
    {
      *((_DWORD *)this + 96) = v10;
      ATCSCondition::wait((CSIRadioModulePrivate *)((char *)this + 392), (CSIRadioModulePrivate *)((char *)this + 56), -1);
      int v10 = *((_DWORD *)this + 96);
      *((_DWORD *)this + 96) = v10 - 1;
      unsigned int v11 = *((_DWORD *)this + 95);
    }
    while (v11 == 2);
    if (v11 != 3)
    {
      uint64_t v16 = *((void *)this + 5);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        if (v11 > 8) {
          unsigned int v17 = "???";
        }
        else {
          unsigned int v17 = off_101A08CC0[v11];
        }
        int v20 = 136315138;
        char v21 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I State is %s, skipping exiting low power", (uint8_t *)&v20, 0xCu);
      }
      char v7 = 1;
      goto LABEL_30;
    }
  }
  else if (v4 != 3)
  {
    uint64_t v5 = *((void *)this + 5);
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    char v7 = 0;
    if (v6)
    {
      if (v4 > 8) {
        uint64_t v8 = "???";
      }
      else {
        uint64_t v8 = off_101A08CC0[v4];
      }
      int v20 = 136315138;
      char v21 = v8;
      long long v18 = "#I State is %s, skipping exiting low power";
LABEL_26:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v20, 0xCu);
      char v7 = 0;
      goto LABEL_30;
    }
    goto LABEL_30;
  }
  CSIRadioModulePrivate::changeState((uint64_t)this, 4u);
  ATCSMutex::unlock((CSIRadioModulePrivate *)((char *)this + 56));
  sub_100360A94((uint64_t *)this + 55, 4u, 0, 0, 0);
  (*(void (**)(CSIRadioModulePrivate *))(*(void *)this + 552))(this);
  ATCSMutex::lock((CSIRadioModulePrivate *)((char *)this + 56));
  uint64_t v12 = *((int *)this + 95);
  if (v12 != 4)
  {
    uint64_t v5 = *((void *)this + 5);
    BOOL v14 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    char v7 = 0;
    if (v14)
    {
      if (v12 > 8) {
        __int16 v15 = "???";
      }
      else {
        __int16 v15 = off_101A08D08[v12];
      }
      int v20 = 136315138;
      char v21 = v15;
      long long v18 = "#I Failed exiting low power due to state change to %s";
      goto LABEL_26;
    }
LABEL_30:
    sub_1007AE7BC(this, v7);
    return ATCSMutex::unlock(v3);
  }
  CSIRadioModulePrivate::changeState((uint64_t)this, 1u);
  sub_1007AE7BC(this, 1);
  BOOL v13 = *((void *)this + 5);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Completed exiting low power", (uint8_t *)&v20, 2u);
  }
  return ATCSMutex::unlock(v3);
}

void sub_1007AFE84(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1007AFEBC(uint64_t a1)
{
  sub_10015FF40();
  char v2 = *(std::__shared_weak_count **)(a1 + 768);
  *(_OWORD *)(a1 + 760) = v3;
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_1007AFF1C(uint64_t a1)
{
  unsigned int v1 = (_OWORD *)(a1 + 760);
  char v2 = *(std::__shared_weak_count **)(a1 + 768);
  *unsigned int v1 = 0u;
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void CSIRadioModulePrivate::addReasonToLastDump(CSIRadioModulePrivate *this, const char *a2)
{
}

void sub_1007AFFF8()
{
}

void sub_1007B0038(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 504))
  {
    sub_100058DB0(&v8, "CSILog");
    sub_100058DB0(&v7, "comment");
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a2;
      uint64_t v6 = *(void *)(a2 + 16);
    }
    sub_10040B070();
  }
  long long v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Warning: Failed to add reason as TraceModule has not been setup yet.", v4, 2u);
  }
  if (a2)
  {
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    operator delete();
  }
}

void sub_1007B0164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v23 - 17) < 0) {
    operator delete(*(void **)(v23 - 40));
  }
  _Unwind_Resume(exception_object);
}

uint64_t CSIRadioModulePrivate::enableTrace(uint64_t a1, uint64_t a2, int a3)
{
  v10[0] = 0;
  v10[1] = 0;
  uint64_t v11 = 0;
  if (a3) {
    uint64_t v5 = "true";
  }
  else {
    uint64_t v5 = "false";
  }
  sub_100058DB0(v10, v5);
  sub_100058DB0(__p, "enabled");
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, void **, void **))(*(void *)a1 + 224))(a1, a2, __p, v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[0]);
  }
  return v6;
}

void sub_1007B0274(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007B02AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a1 + 504))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)a2;
      uint64_t v12 = *(void *)(a2 + 16);
    }
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v9, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)char v9 = *(_OWORD *)a3;
      uint64_t v10 = *(void *)(a3 + 16);
    }
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      uint64_t v8 = *(void *)(a4 + 16);
    }
    sub_10040B070();
  }
  return 0;
}

void sub_1007B03B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007B0400(uint64_t a1, const void **a2, unsigned __int8 *a3, void *a4)
{
  *(void *)string = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v5 = *(void *)(a1 + 504);
  if (v5)
  {
    uint64_t v6 = sub_10040A374(v5, a2, a3, (uint64_t)string);
    if (v14 >= 0) {
      char v7 = string;
    }
    else {
      char v7 = *(char **)string;
    }
  }
  else
  {
    uint64_t v6 = 0;
    char v7 = string;
  }
  xpc_object_t v10 = xpc_string_create(v7);
  if (!v10) {
    xpc_object_t v10 = xpc_null_create();
  }
  v9[0] = *a4;
  v9[1] = "kRadioTracePropertyValue";
  sub_100035E70((uint64_t)v9, &v10, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v10);
  xpc_object_t v10 = 0;
  if (SHIBYTE(v14) < 0) {
    operator delete(*(void **)string);
  }
  return v6;
}

void sub_1007B04D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CSIRadioModulePrivate::queryTraceFullStatus(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v3 = *(void *)(a1 + 504);
  if (v3)
  {
    sub_100058DB0(__p, "status");
    sub_10040A374(v3, a2, (unsigned __int8 *)__p, (uint64_t)a3);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1007B0570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CSIRadioModulePrivate::suspendFastDormancy(CSIRadioModulePrivate *this, char a2)
{
  *((unsigned char *)this + 521) = a2;
  return ATCSMutex::unlock((CSIRadioModulePrivate *)((char *)this + 56));
}

uint64_t CSIRadioModulePrivate::isFastDormancySupportEnabled(CSIRadioModulePrivate *this)
{
  return *((unsigned __int8 *)this + 520);
}

uint64_t CSIRadioModulePrivate::enableFastDormancySupport(CSIRadioModulePrivate *this, int a2, int a3)
{
  uint64_t v6 = (CSIRadioModulePrivate *)((char *)this + 56);
  ATCSMutex::lock((CSIRadioModulePrivate *)((char *)this + 56));
  *((unsigned char *)this + 520) = a2;
  if (a3)
  {
    char v7 = (uint64_t **)sub_100365D74();
    sub_100058DB0(&__p, "GsmRadioModule::kFastFastDormancySupportOn");
    unsigned __int8 v12 = *((unsigned char *)this + 520);
    sub_100571BC4(v7, &__p, &v12);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v8 = (*(uint64_t (**)(CSIRadioModulePrivate *))(*(void *)this + 560))(this);
  if (!a2 || (uint64_t v9 = *((unsigned int *)this + 129), !v9) || (v10 = v8, !v8))
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 27) + 64))(*((void *)this + 27), v9, v10);
  return ATCSMutex::unlock(v6);
}

void sub_1007B0728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  ATCSMutex::unlock(v15);
  _Unwind_Resume(a1);
}

uint64_t CSIRadioModulePrivate::restartFastDormancyTimer(CSIRadioModulePrivate *this)
{
  char v2 = (CSIRadioModulePrivate *)((char *)this + 56);
  ATCSMutex::lock((CSIRadioModulePrivate *)((char *)this + 56));
  (*(void (**)(void))(**((void **)this + 27) + 80))(*((void *)this + 27));
  return ATCSMutex::unlock(v2);
}

void sub_1007B07C0(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CSIRadioModulePrivate::getModelMask(CSIRadioModulePrivate *this)
{
  return *((void *)this + 66);
}

void *CSIRadioModulePrivate::getLastTraceFileNamePrefix@<X0>(void *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = this[63];
  if (!v2) {
    return sub_100058DB0(a2, "");
  }
  if (*(char *)(v2 + 263) < 0) {
    return sub_10004FC84(a2, *(void **)(v2 + 240), *(void *)(v2 + 248));
  }
  long long v3 = *(_OWORD *)(v2 + 240);
  a2[2] = *(void *)(v2 + 256);
  *(_OWORD *)a2 = v3;
  return this;
}

uint64_t CSIRadioModulePrivate::setRadioLinkQualityMetric(void *a1, uint64_t a2)
{
  unsigned int v4 = (ATCSMutex *)(a1 + 7);
  ATCSMutex::lock((ATCSMutex *)(a1 + 7));
  uint64_t v5 = a1[27];
  if (!v5) {
    return ATCSMutex::unlock(v4);
  }
  uint64_t v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = a2;
    LOWORD(v17[0]) = 2080;
    *(std::__shared_weak_count **)((char *)v17 + 2) = (std::__shared_weak_count *)asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setting link quality to: %d (%s)", buf, 0x12u);
    uint64_t v5 = a1[27];
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 72))(v5, a2);
  WISPostSimpleMetricWithInteger();
  xpc_object_t v15 = 0;
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v15 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t v15 = v8;
    if (!v8)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_11;
    }
  }
  if (xpc_get_type(v8) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v9 = xpc_null_create();
LABEL_11:
    xpc_object_t v15 = v9;
    goto LABEL_12;
  }
  xpc_retain(v8);
LABEL_12:
  xpc_release(v8);
  xpc_object_t v13 = xpc_string_create(abm::kSetLinkQualityMetricCommand);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  *(void *)long long buf = &v15;
  v17[0] = (std::__shared_weak_count *)abm::kCTTxPowerCommandString;
  sub_100035E70((uint64_t)buf, &v13, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_object_t v11 = xpc_int64_create((int)a2);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  *(void *)long long buf = &v15;
  v17[0] = (std::__shared_weak_count *)abm::kCTTxPowerCommandData;
  sub_100035E70((uint64_t)buf, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  sub_100068A94(buf);
  (*(void (**)(void, xpc_object_t *))(**(void **)buf + 408))(*(void *)buf, &v15);
  if (v17[0]) {
    sub_10004D2C8(v17[0]);
  }
  xpc_release(v15);
  return ATCSMutex::unlock(v4);
}

void sub_1007B0AB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, uint64_t a15, uint64_t a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t CSIRadioModulePrivate::resetStoredLogs(CSIRadioModulePrivate *this)
{
  uint64_t v2 = (CSIRadioModulePrivate *)((char *)this + 56);
  ATCSMutex::lock((CSIRadioModulePrivate *)((char *)this + 56));
  if (*((void *)this + 63)) {
    ctu::concurrency::Monitor::notifyOnCompletion();
  }
  return ATCSMutex::unlock(v2);
}

void sub_1007B0BDC(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007B0BF8(uint64_t a1, int a2)
{
  unsigned int v4 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  unsigned int v5 = *(_DWORD *)(a1 + 344);
  if (v5 != a2 && v5 <= 1)
  {
    uint64_t v8 = *(void *)(a1 + 336);
    BYTE5(v8) = v5 == 1;
    sub_100655E2C(a1 + 304, (int *)&v8);
  }
  return ATCSMutex::unlock(v4);
}

void sub_1007B0C70(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void *sub_1007B0C90(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1007B0D14(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A086A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007B0D34(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A086A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007B0D88(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1007B0DB0(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 32);
  sub_10041BCB4(v1 + 212);
  xpc_object_t v9 = off_101A08710;
  uint64_t v10 = v1 + 192;
  xpc_object_t v12 = &v9;
  sub_100318874(&v9, (void *)(v1 + 264));
  sub_10030AB98(&v9);
  uint64_t v2 = *(void *)(v1 + 288);
  if (v2) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 48))(v2, v1 + 296);
  }
  long long v3 = (uint64_t (***)())(v1 + 304);
  xpc_object_t v9 = off_101A08790;
  uint64_t v10 = v1 + 192;
  xpc_object_t v12 = &v9;
  if (&v9 != (uint64_t (***)())(v1 + 304))
  {
    unsigned int v4 = *(uint64_t (****)())(v1 + 328);
    if (v4 == v3)
    {
      __p[1] = (void *)(v1 + 192);
      uint64_t v14 = 0;
      xpc_object_t v12 = 0;
      __p[0] = off_101A08790;
      ((void (*)(uint64_t, uint64_t (***)()))(*v3)[3])(v1 + 304, &v9);
      (*(void (**)(void))(**(void **)(v1 + 328) + 32))(*(void *)(v1 + 328));
      *(void *)(v1 + 328) = 0;
      xpc_object_t v12 = &v9;
      (*((void (**)(void **, uint64_t))__p[0] + 3))(__p, v1 + 304);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      *(void *)(v1 + 304) = off_101A08790;
      *(void *)(v1 + 312) = v1 + 192;
      xpc_object_t v12 = v4;
    }
    *(void *)(v1 + 328) = v3;
  }
  sub_1007B0C90(&v9);
  unsigned int v5 = *(capabilities::ct **)(v1 + 328);
  if (v5) {
    unsigned int v5 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, uint64_t))(*(void *)v5 + 48))(v5, v1 + 336);
  }
  if (capabilities::ct::supportsCMASCampOnlyMode(v5))
  {
    sub_100058DB0(__p, "/cc/props/cmas_camp_only_mode");
    uint64_t v6 = (uint64_t (***)())operator new(0x28uLL);
    NSObject *v6 = off_101A08820;
    v6[1] = (uint64_t (**)())(v1 + 344);
    _OWORD v6[2] = (uint64_t (**)())v1;
    void v6[3] = (uint64_t (**)())sub_1007B0BF8;
    void v6[4] = 0;
    xpc_object_t v12 = v6;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v9);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "/cc/props/operating_mode_request");
  xpc_object_t v9 = off_101A088A0;
  uint64_t v10 = v1 + 348;
  uint64_t v11 = v1;
  xpc_object_t v12 = &v9;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v9);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(v1 + 744));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100058DB0(__p, "/cc/events/request_dump_state");
  xpc_object_t v9 = off_101A08920;
  uint64_t v10 = v1;
  xpc_object_t v12 = &v9;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v9);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/is_postponement_ticket_available");
  xpc_object_t v9 = off_101A089A0;
  uint64_t v10 = v1 + 353;
  uint64_t v11 = v1;
  xpc_object_t v12 = &v9;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v9);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/cellular_data_setting");
  xpc_object_t v9 = off_101A08A20;
  uint64_t v10 = v1 + 352;
  uint64_t v11 = v1;
  xpc_object_t v12 = &v9;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v9);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007B1228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007B1294()
{
}

void *sub_1007B12A8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A08710;
  result[1] = v3;
  return result;
}

uint64_t sub_1007B12F0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A08710;
  a2[1] = v2;
  return result;
}

void sub_1007B131C(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/baseband_firmware_dead");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_1007B13CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1007B1414(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007B1454()
{
}

void sub_1007B1464()
{
}

void *sub_1007B1478(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A08790;
  result[1] = v3;
  return result;
}

uint64_t sub_1007B14C0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A08790;
  a2[1] = v2;
  return result;
}

void sub_1007B14EC()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/props/radio_mode");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_1007B1590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1007B15D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007B1614()
{
}

void sub_1007B1624()
{
}

__n128 sub_1007B1638(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_101A08820;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007B168C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A08820;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007B16C4(void *a1, xpc_object_t *a2)
{
  unsigned int v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  xpc_object_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_1007B17BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007B17FC()
{
}

void sub_1007B180C()
{
}

__n128 sub_1007B1820(uint64_t a1)
{
  char v2 = (char *)operator new(0x18uLL);
  *(void *)char v2 = off_101A088A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007B186C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A088A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007B189C(uint64_t a1, xpc_object_t *a2)
{
  unsigned int v4 = *(int **)(a1 + 8);
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v11 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v11, (int *)a2, v6);
    int *v4 = v11;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = *(void *)(a1 + 16);
  ATCSMutex::lock((ATCSMutex *)(v9 + 56));
  (*(void (**)(void, void))(**(void **)(v9 + 64) + 112))(*(void *)(v9 + 64), *(unsigned int *)(v9 + 348));
  return ATCSMutex::unlock((ATCSMutex *)(v9 + 56));
}

void sub_1007B198C(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007B19A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007B19E4()
{
}

void sub_1007B19F4()
{
}

void *sub_1007B1A08(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A08920;
  result[1] = v3;
  return result;
}

uint64_t sub_1007B1A50(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A08920;
  a2[1] = v2;
  return result;
}

void sub_1007B1A7C(uint64_t a1)
{
  long long v3 = 0u;
  long long v4 = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  RequestDumpStatePayload::RequestDumpStatePayload();
  read_rest_value();
  (*(void (**)(void, void **))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), v2);
  if (SBYTE7(v3) < 0) {
    operator delete(v2[0]);
  }
}

void sub_1007B1B34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007B1B68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007B1BA8()
{
}

void sub_1007B1BB8()
{
}

__n128 sub_1007B1BCC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A089A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007B1C18(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A089A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007B1C48(uint64_t a1, xpc *this, BOOL a3)
{
  long long v4 = *(unsigned char **)(a1 + 8);
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v5 = *(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 16) + 64) + 40);

  return v5();
}

uint64_t sub_1007B1CB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007B1CF8()
{
}

void sub_1007B1D08()
{
}

__n128 sub_1007B1D1C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A08A20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007B1D68(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A08A20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007B1D98(uint64_t a1, xpc *this, BOOL a3)
{
  long long v4 = *(unsigned char **)(a1 + 8);
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v5 = *(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 16) + 64) + 120);

  return v5();
}

uint64_t sub_1007B1E08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007B1E48()
{
}

void sub_1007B1E58(ATCSDPCQueue::Callback *a1)
{
  ATCSDPCQueue::Callback::~Callback(a1);

  operator delete();
}

uint64_t sub_1007B1E90(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(void *, void))(result + 24);
    uint64_t v3 = *(void *)(result + 32);
    long long v4 = (void *)(v1 + (v3 >> 1));
    if (v3) {
      uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
    }
    return v2(v4, *(unsigned __int8 *)(result + 8));
  }
  return result;
}

uint64_t sub_1007B1EE8()
{
  return 0;
}

void sub_1007B1EF4()
{
}

void *sub_1007B1F08()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A08AE8;
  return result;
}

void sub_1007B1F40(uint64_t a1, void *a2)
{
  *a2 = off_101A08AE8;
}

void sub_1007B1F68(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    long long v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "BasebandReset", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_1007B1FE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007B2020()
{
}

void sub_1007B2030(ATCSDPCQueue::Callback *a1)
{
  ATCSDPCQueue::Callback::~Callback(a1);

  operator delete();
}

uint64_t sub_1007B2068(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v2 = a1[3];
  os_signpost_id_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    uint64_t v1 = *(uint64_t (**)(void *, void))(*v3 + v1);
  }
  return v1(v3, a1[4]);
}

uint64_t sub_1007B20B8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_1007B20C0()
{
  if ((byte_101B09D70 & 1) == 0)
  {
    byte_101B09D70 = 1;
    return __cxa_atexit((void (*)(void *))sub_100160564, &stru_101B09D20, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_1007B20FC(uint64_t a1)
{
  *(void *)a1 = off_101A08D60;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v2 = (void *)(a1 + 16);
  uint64_t v3 = v4;
  *uint64_t v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  sub_100110A40((void ***)(a1 + 8), 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_1007B216C(uint64_t a1)
{
  sub_1007B20FC(a1);

  operator delete();
}

void *sub_1007B21A4(void *result, uint64_t a2)
{
  *uint64_t result = off_101A08D60;
  result[1] = 0;
  result[2] = 0;
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  return result;
}

uint64_t sub_1007B22C0(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  if (*(void *)(a1 + 16)) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1007B2334(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      if ((v10 >> 3) == 2) {
        operator new();
      }
      if (v19 == 1) {
        operator new();
      }
LABEL_24:
      uint64_t result = PB::Reader::skip(this, v19, v18, 0);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_20;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_24;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_1007B253C(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  if (*(void *)(v3 + 16))
  {
    return PB::Writer::write();
  }
  return result;
}

void sub_1007B28A8(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1007B2BAC(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1007B2E5C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1007B3148(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1007B31B8(uint64_t a1)
{
  return a1;
}

void sub_1007B31E4(uint64_t a1)
{
  operator delete();
}

void *sub_1007B3230(uint64_t a1)
{
  unint64_t v2 = operator new(0x10uLL);
  *unint64_t v2 = off_101A08DB0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1007B3288(uint64_t a1, void *a2)
{
  *a2 = off_101A08DB0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1007B32D0(uint64_t a1)
{
}

void sub_1007B32D8(id *a1)
{
  operator delete(a1);
}

void sub_1007B3314(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int16 *a4)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *a3;
  uint64_t v7 = *a4;
  id v11 = (id)objc_opt_new();
  char v8 = +[NSNumber numberWithUnsignedInteger:v5];
  [v11 setMajorVersion:v8];

  unsigned int v9 = +[NSNumber numberWithUnsignedInteger:v6];
  [v11 setMinorVersion:v9];

  unint64_t v10 = +[NSNumber numberWithUnsignedInteger:v7];
  [v11 setReleaseVersion:v10];

  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_1007B3404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007B343C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A08E20)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007B347C()
{
  return &off_101A08E20;
}

void *sub_1007B3488(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1007B350C(uint64_t a1)
{
  return a1;
}

void sub_1007B3538(uint64_t a1)
{
  operator delete();
}

void *sub_1007B3584(uint64_t a1)
{
  unint64_t v2 = operator new(0x10uLL);
  *unint64_t v2 = off_101A08E40;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1007B35DC(uint64_t a1, void *a2)
{
  *a2 = off_101A08E40;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1007B3624(uint64_t a1)
{
}

void sub_1007B362C(id *a1)
{
  operator delete(a1);
}

void sub_1007B3668(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  id v3 = +[NSNumber numberWithBool:*a2];
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_1007B36D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007B36E8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A08EA0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007B3728()
{
  return &off_101A08EA0;
}

void sub_1007B38F8()
{
}

void sub_1007B3970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  unint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)CTWifiLocationManager;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1007B3A7C(os_log_t *a1)
{
  unsigned int v2 = sub_1007B3D44();
  unint64_t v3 = sub_1007B4C8C();
  if (HIDWORD(v3))
  {
    unsigned int v9 = v3;
    unint64_t v10 = *a1;
    BOOL v11 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
    if (v2 == v9)
    {
      if (!v11) {
        return;
      }
      if (v2 > 4) {
        char v12 = "???";
      }
      else {
        char v12 = off_101A08FE8[v2];
      }
      *(_DWORD *)std::string __str = 136315138;
      *(void *)&__str[4] = v12;
      unsigned int v15 = "#I Same location status had already been saved previously: %s";
      unint64_t v16 = v10;
      goto LABEL_27;
    }
    if (v11)
    {
      if (v9 > 4) {
        char v14 = "???";
      }
      else {
        char v14 = off_101A08FE8[v9];
      }
      if (v2 > 4) {
        char v17 = "???";
      }
      else {
        char v17 = off_101A08FE8[v2];
      }
      *(_DWORD *)std::string __str = 136315394;
      *(void *)&__str[4] = v14;
      *(_WORD *)&__str[12] = 2080;
      *(void *)&__str[14] = v17;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Saved location status changed from %s -> %s", (uint8_t *)__str, 0x16u);
    }
  }
  char v4 = (uint64_t **)sub_100365D74();
  sub_100058DB0(&v18, "WifiCallingLocationAuthorizationStatus");
  memset(__str, 0, 32);
  snprintf(__str, 0x20uLL, "0x%x", v2);
  sub_100058DB0(&__p, __str);
  int v5 = sub_10036627C(v4, &v18, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  uint64_t v6 = *a1;
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v7) {
      return;
    }
    if (v2 > 4) {
      char v8 = "???";
    }
    else {
      char v8 = off_101A08FE8[v2];
    }
    *(_DWORD *)std::string __str = 136315138;
    *(void *)&__str[4] = v8;
    unsigned int v15 = "#I Successfully save current location status %s";
  }
  else
  {
    if (!v7) {
      return;
    }
    if (v2 > 4) {
      BOOL v13 = "???";
    }
    else {
      BOOL v13 = off_101A08FE8[v2];
    }
    *(_DWORD *)std::string __str = 136315138;
    *(void *)&__str[4] = v13;
    unsigned int v15 = "#I Failed to save current location status %s";
  }
  unint64_t v16 = v6;
LABEL_27:
  _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)__str, 0xCu);
}

void sub_1007B3D08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

id sub_1007B3D44()
{
  uint64_t v0 = +[NSBundle bundleWithPath:@"/System/Library/LocationBundles/WifiCalling.bundle"];
  id v1 = +[CLLocationManager authorizationStatusForBundle:v0];

  return v1;
}

void sub_1007B3D9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B3E2C(NSObject *a1, int a2)
{
  if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
  {
    char v4 = "false";
    if (a2) {
      char v4 = "true";
    }
    int v7 = 136315138;
    char v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_DEFAULT, "#I Set location status authorized: %s", (uint8_t *)&v7, 0xCu);
  }
  if (a2) {
    uint64_t v5 = 3;
  }
  else {
    uint64_t v5 = 2;
  }
  uint64_t v6 = +[NSBundle bundleWithPath:@"/System/Library/LocationBundles/WifiCalling.bundle"];
  +[CLLocationManager setAuthorizationStatusByType:v5 forBundle:v6];
}

void sub_1007B3F28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B3F40()
{
  uint64_t v0 = (uint64_t **)sub_100365D74();
  sub_100058DB0(__p, "WifiCallingLocationAuthorizationStatus");
  sub_1003660FC(v0, __p);
  if (v2 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007B3F98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007B408C(NSObject **a1)
{
  unint64_t v2 = sub_1007B4C8C();
  if (HIDWORD(v2))
  {
    unsigned int v6 = v2;
    sub_1007B3E2C(*a1, (v2 - 3) < 0xFFFFFFFE);
    sub_1007B3F40();
    unint64_t v3 = *a1;
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    if (v6 > 4) {
      int v7 = "???";
    }
    else {
      int v7 = off_101A08FE8[v6];
    }
    int v9 = 136315138;
    unint64_t v10 = v7;
    char v8 = "#I Successfully restored location status %s";
  }
  else
  {
    unint64_t v3 = *a1;
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    unsigned int v4 = sub_1007B3D44();
    if (v4 > 4) {
      uint64_t v5 = "???";
    }
    else {
      uint64_t v5 = off_101A08FE8[v4];
    }
    int v9 = 136315138;
    unint64_t v10 = v5;
    char v8 = "#I No saved location status to restore. Current: %s";
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v9, 0xCu);
}

void sub_1007B4788(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B496C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t sub_1007B4C8C()
{
  unsigned int v5 = 0;
  uint64_t v0 = sub_100365D74();
  sub_100058DB0(__p, "WifiCallingLocationAuthorizationStatus");
  BOOL v1 = sub_1004421D8(v0, __p, &v5);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (v1) {
    return v5 | (unint64_t)&_mh_execute_header;
  }
  else {
    return 0;
  }
}

void sub_1007B4D00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007B4F9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1007B50E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B51C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CTWifiLocationManager **sub_1007B52C0(CTWifiLocationManager **a1)
{
  *a1 = 0;
  unint64_t v2 = objc_alloc_init(CTWifiLocationManager);
  unint64_t v3 = *a1;
  *a1 = v2;

  return a1;
}

void sub_1007B5300(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B5314()
{
}

void sub_1007B536C()
{
}

void sub_1007B5390(void *a1)
{
  unint64_t v2 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "wifi-loc");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  *a1 = off_101A08EC0;
  operator new();
}

void sub_1007B5468()
{
}

void sub_1007B54D0(void *a1)
{
  *a1 = off_101A08EC0;
  unint64_t v2 = (id *)a1[2];
  a1[2] = 0;
  if (v2)
  {

    operator delete();
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  CTWifiLocationInterface::~CTWifiLocationInterface((CTWifiLocationInterface *)a1);
}

void sub_1007B5558(void *a1)
{
  sub_1007B54D0(a1);

  operator delete();
}

void sub_1007B5590(uint64_t a1)
{
  BOOL v1 = **(void ***)(a1 + 16);
  if (v1)
  {
    [v1 initialize];
  }
  else
  {
    unint64_t v2 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)OsLogContext v3 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "CTWifiLocation failed to initialize. WifiLocationManager is invalid", v3, 2u);
    }
  }
}

void sub_1007B5614(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B5624(uint64_t a1)
{
  BOOL v1 = **(void ***)(a1 + 16);
  if (v1)
  {
    id v2 = v1;
    [v1 disableVoWiFiLocationStatusOnFirstLaunch];
    BOOL v1 = v2;
  }
}

void sub_1007B5678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B5688(uint64_t a1)
{
  BOOL v1 = **(void ***)(a1 + 16);
  if (v1)
  {
    [v1 handleDataMigration];
  }
  else
  {
    id v2 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)OsLogContext v3 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "CTWifiLocation failed to handle data migration. WifiLocationManager is invalid", v3, 2u);
    }
  }
}

void sub_1007B570C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B571C(uint64_t a1)
{
  BOOL v1 = **(void ***)(a1 + 16);
  if (v1)
  {
    [v1 registerWifiCallingEntity];
  }
  else
  {
    id v2 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)OsLogContext v3 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "registerWifiCallingEntity: Error - No CTWifiLocationManager !!!", v3, 2u);
    }
  }
}

void sub_1007B57A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B57B0(uint64_t a1, uint64_t a2)
{
  id v2 = **(void ***)(a1 + 16);
  if (v2)
  {
    id v3 = v2;
    [v2 enableVoWiFiLocationStatus:a2];
    id v2 = v3;
  }
}

void sub_1007B580C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B581C(uint64_t a1, uint64_t a2)
{
  id v3 = **(void ***)(a1 + 16);
  id v5 = v3;
  if (v3)
  {
    id v4 = v3;
    id v3 = v5;
  }
  [v3 startLocationUpdateWithForceLocationLookup:a2];
}

void sub_1007B587C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1007B5890(uint64_t a1)
{
  BOOL v1 = **(void ***)(a1 + 16);
  id v3 = v1;
  if (v1)
  {
    id v2 = v1;
    BOOL v1 = v3;
  }
  [v1 stopLocationUpdates];
}

void sub_1007B58E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id sub_1007B58FC(uint64_t a1)
{
  BOOL v1 = **(void ***)(a1 + 16);
  if (v1) {
    id v2 = [v1 isLocationServiceAuthorized];
  }
  else {
    id v2 = 0;
  }

  return v2;
}

void sub_1007B594C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1007B595C(uint64_t a1)
{
  BOOL v1 = **(void ***)(a1 + 16);
  if (v1) {
    id v2 = [v1 isLocationServiceEnabled];
  }
  else {
    id v2 = 0;
  }

  return v2;
}

void sub_1007B59AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1007B59BC(uint64_t a1)
{
  BOOL v1 = **(void ***)(a1 + 16);
  if (v1) {
    id v2 = [v1 isLocationServiceAuthorized];
  }
  else {
    id v2 = 0;
  }

  return v2;
}

void sub_1007B5A0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B5A1C(uint64_t a1)
{
  BOOL v1 = **(void ***)(a1 + 16);
  if (v1)
  {
    id v2 = v1;
    [v1 handleDumpState];
    BOOL v1 = v2;
  }
}

void sub_1007B5A70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1007B5A80(uint64_t a1)
{
  BOOL v1 = *(void **)(a1 + 32);
  id v2 = objc_alloc((Class)CLLocationManager);
  id v3 = +[NSBundle bundleWithPath:@"/System/Library/LocationBundles/WifiCalling.bundle"];
  id v4 = [v2 initWithEffectiveBundle:v3 delegate:*v1 onQueue:*(void *)(*v1 + 32)];
  id v5 = *(void **)(*v1 + 8);
  *(void *)(*v1 + 8) = v4;

  [*(id *)(*v1 + 8) setDistanceFilter:-1.0];
  [*(id *)(*v1 + 8) setDesiredAccuracy:kCLLocationAccuracyHundredMeters];
  unsigned int v6 = *(void **)(*v1 + 8);

  return [v6 setDynamicAccuracyReductionEnabled:1];
}

void sub_1007B5B40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

atomic_uint **sub_1007B5B50(uint64_t *a1, double a2, double a3)
{
  double v25 = a3;
  double v26 = a2;
  long long v24 = 0uLL;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(&v29, v4);
  uint64_t v5 = a1[1];
  if (v5)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) == 1) {
      sub_100351B34(a1, &v29, 0, 1);
    }
    uint64_t v6 = *a1;
    uint64_t v7 = a1[1];
    if (v7) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = *a1;
  }
  long long v8 = v24;
  *(void *)&long long v24 = v6;
  *((void *)&v24 + 1) = v7;
  v28[0] = v8;
  sub_10000A740((atomic_uint **)v28 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v40 + 1));
  sub_10000A5F8(&v29);
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  uint64_t v44 = 0;
  uint64_t v45 = 10;
  int v46 = (char *)&v29 + 8;
  uint64_t v47 = 0;
  char v48 = &v26;
  char v49 = &v25;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  int v9 = (uint64_t *)sub_100351790((uint64_t *)&v24);
  v23[0] = &v29;
  v23[1] = a1;
  v23[2] = sub_100352AF4(v9);
  uint64_t v10 = sub_100351790((uint64_t *)&v24);
  uint64_t v11 = sub_100060EA8((uint64_t *)(v10 + 16));
  char v12 = (uint64_t *)sub_100351790((uint64_t *)&v24);
  uint64_t v13 = *(void *)(sub_100352AF4(v12) + 8);
  char v14 = (uint64_t *)sub_100351790((uint64_t *)&v24);
  *(void *)&long long v21 = v13;
  *((void *)&v21 + 1) = sub_100352AF4(v14);
  *(void *)&long long v22 = &v29;
  *((void *)&v22 + 1) = *((void *)&v21 + 1);
  sub_1007B5F5C((uint64_t *)&v21);
  unsigned int v15 = (uint64_t *)sub_100351790((uint64_t *)&v24);
  uint64_t v16 = sub_100352AF4(v15);
  char v17 = (uint64_t *)sub_100351790((uint64_t *)&v24);
  *(void *)&long long v19 = v16;
  *((void *)&v19 + 1) = sub_100352AF4(v17);
  *(void *)&long long v20 = &v29;
  *((void *)&v20 + 1) = *((void *)&v19 + 1);
  sub_1007B5F5C((uint64_t *)&v19);
  v28[0] = v21;
  v28[1] = v22;
  v27[0] = v19;
  v27[1] = v20;
  sub_1007B5DD0(v11, (uint64_t *)v28, v27);
  sub_1007B63E4((uint64_t)v23);
  sub_1007B65C8((uint64_t)&v29);
  return sub_10000A740((atomic_uint **)&v24 + 1);
}

void sub_1007B5D7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,atomic_uint *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_1007B5DD0(uint64_t a1, uint64_t *a2, void *a3)
{
  while (*a2 != *a3)
  {
    sub_1007B5E50(a2);
    *a2 = *(void *)(*a2 + 8);
    sub_1007B5F5C(a2);
    uint64_t v5 = (unsigned char *)a2[2];
    if (*v5) {
      unsigned char *v5 = 0;
    }
  }
}

unsigned char *sub_1007B5E50(void *a1)
{
  id v2 = (unsigned char *)a1[2];
  if (!*v2)
  {
    sub_1007B5F0C((uint64_t)(v2 + 272), (uint64_t *)(*a1 + 16));
    if (!*v2) {
      *id v2 = 1;
    }
  }
  id v3 = (unsigned char *)a1[2];
  if (!*v3) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  return v3 + 1;
}

uint64_t sub_1007B5F0C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = sub_1003517D4(a2);
  id v3 = (void *)(sub_100352284((uint64_t *)(v2 + 32)) + 24);

  return sub_100353260(v3);
}

void sub_1007B5F5C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_15;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      id v3 = (uint64_t *)(*a1 + 16);
      long long v15 = 0u;
      long long v16 = 0u;
      uint64_t v4 = sub_1007B61B8(v3);
      sub_10000A4EC(&v15, v4);
      uint64_t v5 = (atomic_uint **)sub_1003517D4((uint64_t *)(*a1 + 16));
      sub_1007B61FC(v5, &v15, (void *)(a1[2] + 8));
      uint64_t v6 = sub_1003517D4((uint64_t *)(*a1 + 16));
      uint64_t v7 = a1[2];
      if (*(unsigned char *)(v6 + 24)) {
        ++*(_DWORD *)(v7 + 288);
      }
      else {
        ++*(_DWORD *)(v7 + 292);
      }
      uint64_t v8 = sub_1003517D4((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v8 + 24)
        || (uint64_t v9 = *(void *)(v8 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v9 + 8), memory_order_acquire))
      {
        int v10 = 1;
      }
      else
      {
        sub_1007B631C(a1, &v15, *a1);
        int v10 = 0;
      }
      (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
      sub_10000A5F8(&v15);
      uint64_t v1 = *a1;
      uint64_t v11 = a1[1];
      if (!v10) {
        break;
      }
      uint64_t v12 = *(void *)(v1 + 8);
      *a1 = v12;
      if (v12 == v11)
      {
        uint64_t v1 = v11;
        goto LABEL_15;
      }
    }
    if (v1 == v11)
    {
LABEL_15:
      uint64_t v13 = a1[3];
      if (v13 != v1)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        uint64_t v14 = sub_1007B61B8((uint64_t *)(v13 + 16));
        sub_10000A4EC(&v15, v14);
        sub_1007B631C(a1, &v15, a1[1]);
        (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
        sub_10000A5F8(&v15);
      }
    }
  }
}

void sub_1007B617C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007B61B8(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_1007B61FC(atomic_uint **result, void *a2, void *a3)
{
  id v3 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v6 = result;
    for (unint64_t i = *(atomic_uint **)sub_100352284((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_100352284(v3);
      if (i == result[1]) {
        break;
      }
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v6 + 24))
        {
          *((unsigned char *)v6 + 24) = 0;
          sub_100060D70(v6, a2);
        }
        return sub_1000624B4((uint64_t)v8);
      }
      sub_100062188(a3, (uint64_t)v8);
      sub_1000624B4((uint64_t)v8);
    }
  }
  return result;
}

void sub_1007B62F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1007B631C(void *a1, void *a2, uint64_t a3)
{
  a1[3] = a3;
  uint64_t v3 = a1[2];
  if (a1[1] == a3)
  {
    uint64_t result = *(atomic_uint ***)(v3 + 296);
    if (result) {
      uint64_t result = sub_100060D70(result, a2);
    }
    *(void *)(v3 + 296) = 0;
  }
  else
  {
    uint64_t v4 = *(void *)(a3 + 16);
    uint64_t v5 = a1[2];
    return sub_1007B637C(v5, a2, v4);
  }
  return result;
}

atomic_uint **sub_1007B637C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result = *(atomic_uint ***)(a1 + 296);
  if (result) {
    uint64_t result = sub_100060D70(result, a2);
  }
  *(void *)(a1 + 296) = a3;
  if (a3)
  {
    int v6 = *(_DWORD *)(a3 + 28);
    if (!v6) {
      __assert_rtn("inc_slot_refcount", "connection.hpp", 114, "m_slot_refcount != 0");
    }
    *(_DWORD *)(a3 + 28) = v6 + 1;
  }
  return result;
}

uint64_t sub_1007B63E4(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)a1 + 292) > *(_DWORD *)(*(void *)a1 + 288)) {
    sub_1007B6428(*(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
  }
  return a1;
}

void sub_1007B6428(uint64_t *a1, uint64_t a2)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v9, v4);
  uint64_t v5 = (uint64_t *)sub_100351790(a1);
  if (sub_100352AF4(v5) == a2)
  {
    uint64_t v6 = a1[1];
    if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
      operator new();
    }
    uint64_t v7 = (uint64_t *)sub_100351790(a1);
    uint64_t v8 = *(uint64_t **)(sub_100352AF4(v7) + 8);
    sub_1003519F8(a1, v9, 0, &v8, 0);
  }
  sub_10000A6C8(*((pthread_mutex_t **)&v10 + 1));
  sub_10000A5F8(v9);
}

void sub_1007B6574()
{
}

uint64_t sub_1007B65C8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_1007B669C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1007B66BC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007B6724(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007B6760(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007B6798(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1007B67C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1007B680C()
{
}

void *sub_1007B6834@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x30uLL);
  uint64_t result = sub_1007B68A8(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1007B6894(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1007B68A8(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A09020;
  a1[3] = off_101A090A8;
  sub_1007B8304(a2, a3, a4, a1 + 4);
  return a1;
}

void sub_1007B6920(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1007B6934(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A09020;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007B6954(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A09020;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007B69A8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1007B6B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

id sub_1007B6BE4(uint64_t a1)
{
  return [*(id *)(a1 + 32) configure];
}

void sub_1007B6C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NetworkMonitorWrapper;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1007B6D64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B6EE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B6F18(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    [WeakRetained submitUsageMetricWithTransport:*(unsigned __int8 *)(a1 + 48)];
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1007B6F80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1007B77D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, std::__shared_weak_count *a11, int a12, char a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, xpc_object_t object, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if ((a13 & 1) == 0) {
    sub_10004D2C8(a11);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007B7C24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *sub_1007B7DC8(void *a1)
{
  *a1 = off_101A090A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1007B7E14(void *a1)
{
  *a1 = off_101A090A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1007B7E80(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  sub_1000F0058((uint64_t)v6, a3);
  uint64_t v7 = v4;
  char v8 = a2;
  sub_1000F0058((uint64_t)&v9, (uint64_t)v6);
  long long v5 = *(std::__shared_weak_count **)(v4 + 8);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1007B7FE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void *sub_1007B8014(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v21, kCtLoggingSystemName, "cp.pur.usage");
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  uint64_t v9 = dispatch_queue_create_with_target_V2("CellularPlanPurchaseFlowDataUsageCollector", initially_inactive, 0);
  dispatch_set_qos_class_floor(v9, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v9);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = v9;
  if (v9)
  {
    dispatch_retain(v9);
    a1[3] = 0;
    dispatch_release(v9);
  }
  else
  {
    a1[3] = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v22, &v21);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v22);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v22);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  long long v10 = [NetworkMonitorWrapper alloc];
  uint64_t v11 = a1[2];
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  uint64_t v18 = *a2;
  long long v19 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a3;
    uint64_t v17 = *(void *)(a3 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    uint64_t v15 = *(void *)(a4 + 16);
  }
  a1[5] = [(NetworkMonitorWrapper *)v10 initWithQueue:&object registry:&v18 carrier:__dst domain:__p];
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(__dst[0]);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (object) {
    dispatch_release(object);
  }
  return a1;
}

void sub_1007B81DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,dispatch_object_t object)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a24) {
    sub_10004D2C8(a24);
  }
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::~OsLogLogger(v26);
  sub_100087E88(v25);
  _Unwind_Resume(a1);
}

_OWORD *sub_1007B8270(uint64_t **a1, void **a2, _OWORD **a3)
{
  uint64_t v11 = 0;
  long long v5 = (void **)sub_100046ED4((uint64_t)a1, &v11, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    uint64_t v6 = operator new(0x40uLL);
    char v8 = *a3;
    uint64_t v9 = *((void *)*a3 + 2);
    _OWORD v6[2] = **a3;
    *((void *)v6 + 6) = v9;
    v8[1] = 0;
    int v8[2] = 0;
    *char v8 = 0;
    *((void *)v6 + 7) = 0;
    sub_100046C38(a1, v11, v7, (uint64_t *)v6);
  }
  return v6;
}

void sub_1007B8304(uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  char v8 = operator new(0x48uLL);
  sub_1007B8390(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;

  sub_1000B3BC8((uint64_t)a4, v8 + 3, (uint64_t)(v8 + 3));
}

void sub_1007B837C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1007B8390(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A090E8;
  sub_1007B8014(a1 + 3, a2, a3, a4);
  return a1;
}

void sub_1007B83D8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1007B83EC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A090E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007B840C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A090E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_1007B8460(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 24);

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 56));

  return sub_100087E88(v2);
}

uint64_t *sub_1007B84AC(unsigned __int8 **a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void **)(*(void *)v1 + 40);
  uint64_t v3 = v1[8];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3321888768;
  void v7[2] = sub_1007B8610;
  double v7[3] = &unk_101A09128;
  sub_1000F0058((uint64_t)v8, (uint64_t)(v1 + 16));
  [v2 syncAndSubmitUsageMetricWithTransport:v3 completion:v7];
  sub_10003B34C(v8);
  sub_1007B85C0((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1007B8594(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  sub_10003B34C(v2);
  sub_1007B85C0((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1007B85C0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10003B34C((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_1007B8610(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if (!v1) {
    sub_10007B600();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

uint64_t sub_1007B8660(uint64_t a1, uint64_t a2)
{
  return sub_1000F0058(a1 + 32, a2 + 32);
}

void *sub_1007B866C(uint64_t a1)
{
  return sub_10003B34C((void *)(a1 + 32));
}

void sub_1007B8674()
{
}

void sub_1007B869C(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86A4(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86AC(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86B4(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86BC(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86C8(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86D4(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86DC(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86E4(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86EC(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86F4(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B86FC(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B8704(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B870C(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B8714(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B871C(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B8724(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1007B872C(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1007B8734()
{
  return 0;
}

void sub_1007B8744(CarrierSettingsInterface *a1)
{
  CarrierSettingsInterface::~CarrierSettingsInterface(a1);

  operator delete();
}

uint64_t sub_1007B877C(uint64_t a1, char *__str)
{
  *(_DWORD *)(a1 + 20) = strtoul(__str, 0, 0);
  return 1;
}

uint64_t sub_1007B87B4(uint64_t a1, uint64_t a2)
{
  return sub_100FECBAC(a2, (int *)(a1 + 20));
}

uint64_t sub_1007B87C4(uint64_t a1, uint64_t a2)
{
  return 1;
}

void sub_1007B87EC()
{
}

void sub_1007B884C()
{
}

const char *sub_1007B88B0()
{
  return "integer";
}

uint64_t sub_1007B88BC(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v10 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)std::string __p = 0u;
  memset(v6, 0, sizeof(v6));
  sub_10004DE24((uint64_t)v6);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v6 + 8, &v4);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v4;
  *(void *)(a2 + 16) = v5;
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return 1;
}

void sub_1007B8A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1007B8A60(uint64_t a1, char *__s1)
{
  if (!strcmp(__s1, "MMS 1.0"))
  {
    int v4 = 16;
  }
  else if (!strcmp(__s1, "MMS 1.1"))
  {
    int v4 = 17;
  }
  else if (!strcmp(__s1, "MMS 1.2"))
  {
    int v4 = 18;
  }
  else
  {
    int v4 = 19;
  }
  *(_DWORD *)(a1 + 20) = v4;
  return 1;
}

uint64_t sub_1007B8AE4(uint64_t a1, uint64_t *a2)
{
  switch(*(_DWORD *)(a1 + 20))
  {
    case 0x10:
      if (*((char *)a2 + 23) < 0)
      {
        a2[1] = 7;
        a2 = (uint64_t *)*a2;
      }
      else
      {
        *((unsigned char *)a2 + 23) = 7;
      }
      uint64_t v2 = "MMS 1.0";
      goto LABEL_22;
    case 0x11:
      if (*((char *)a2 + 23) < 0)
      {
        a2[1] = 7;
        a2 = (uint64_t *)*a2;
      }
      else
      {
        *((unsigned char *)a2 + 23) = 7;
      }
      uint64_t v2 = "MMS 1.1";
      goto LABEL_22;
    case 0x12:
      if (*((char *)a2 + 23) < 0)
      {
        a2[1] = 7;
        a2 = (uint64_t *)*a2;
      }
      else
      {
        *((unsigned char *)a2 + 23) = 7;
      }
      uint64_t v2 = "MMS 1.2";
      goto LABEL_22;
    case 0x13:
      if (*((char *)a2 + 23) < 0)
      {
        a2[1] = 7;
        a2 = (uint64_t *)*a2;
      }
      else
      {
        *((unsigned char *)a2 + 23) = 7;
      }
      uint64_t v2 = "MMS 1.3";
LABEL_22:
      *(_DWORD *)a2 = *(_DWORD *)v2;
      *(_DWORD *)((char *)a2 + 3) = *(_DWORD *)(v2 + 3);
      break;
    default:
      if (*((char *)a2 + 23) < 0)
      {
        a2[1] = 7;
        a2 = (uint64_t *)*a2;
      }
      else
      {
        *((unsigned char *)a2 + 23) = 7;
      }
      *(_DWORD *)((char *)a2 + 3) = 1853321070;
      *(_DWORD *)a2 = 1852534357;
      break;
  }
  *((unsigned char *)a2 + 7) = 0;
  return 1;
}

void sub_1007B8C28()
{
}

void sub_1007B8C88()
{
}

uint64_t sub_1007B8CEC(uint64_t a1, char *a2)
{
  memset(&v5, 0, sizeof(v5));
  uint64_t result = (uint64_t)strptime(a2, "%a %b %d %T %Y\n", &v5);
  if (result)
  {
    time_t v4 = timegm(&v5);
    if (v4 == -1)
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(a1 + 20) = v4;
      return 1;
    }
  }
  return result;
}

BOOL sub_1007B8D60(uint64_t a1, std::string *a2)
{
  time_t v6 = *(unsigned int *)(a1 + 20);
  *(void *)__s = 0;
  uint64_t v8 = 0;
  __int16 v10 = 0;
  uint64_t v9 = 0;
  memset(&v5, 0, sizeof(v5));
  gmtime_r(&v6, &v5);
  strftime(__s, 0x1AuLL, "%a %b %d %T %Y\n", &v5);
  int v3 = __s[0];
  if (__s[0]) {
    sub_10003ED78(a2, __s);
  }
  return v3 != 0;
}

void sub_1007B8E1C()
{
}

void sub_1007B8E7C()
{
}

const char *sub_1007B8EE0()
{
  return "date";
}

void sub_1007B8EF0()
{
}

void sub_1007B8F08()
{
}

void sub_1007B8F20()
{
}

void stewie::Targets::create()
{
}

void sub_1007B8F9C()
{
}

void *stewie::Targets::Targets(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  sub_1007B918C(a1 + 2, a2);
  return a1;
}

void sub_1007B8FEC(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t stewie::Targets::getById@<X0>(stewie::Targets *this@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = *((void *)this + 3);
  uint64_t result = (uint64_t)this + 24;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = result;
  do
  {
    unsigned int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 >= a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v4;
    }
    else {
      uint64_t v9 = (uint64_t *)(v4 + 8);
    }
    if (v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != result && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v11 = *(void *)(v6 + 40);
    uint64_t v10 = *(void *)(v6 + 48);
    *a3 = v11;
    a3[1] = v10;
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_12:
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

void sub_1007B9064(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007B90E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_10036DC3C((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007B9108(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007B9140(uint64_t a1)
{
}

uint64_t sub_1007B9148(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_1007B918C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1007B91E4(a1, *(unsigned int **)a2, (unsigned int *)(a2 + 8));
  return a1;
}

void sub_1007B91CC(_Unwind_Exception *a1)
{
  sub_10005D0E4(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1007B91E4(uint64_t *result, unsigned int *a2, unsigned int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t)(result + 1);
    do
    {
      uint64_t result = sub_1007B9270(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      unsigned int v7 = (unsigned int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          unsigned int v7 = *(unsigned int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          BOOL v8 = (unsigned int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1007B9270(uint64_t **a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v5 = (uint64_t *)a2;
  unsigned int v7 = *a3;
  BOOL v8 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2 || (unsigned int v9 = *(_DWORD *)(a2 + 32), v9 > v7))
  {
    uint64_t v10 = *(void *)a2;
    if (*a1 == (uint64_t *)a2)
    {
      uint64_t v12 = a2;
      goto LABEL_16;
    }
    if (v10)
    {
      uint64_t v11 = *(void *)a2;
      do
      {
        uint64_t v12 = v11;
        uint64_t v11 = *(void *)(v11 + 8);
      }
      while (v11);
    }
    else
    {
      uint64_t v17 = a2;
      do
      {
        uint64_t v12 = *(void *)(v17 + 16);
        BOOL v18 = *(void *)v12 == v17;
        uint64_t v17 = v12;
      }
      while (v18);
    }
    if (*(_DWORD *)(v12 + 32) < v7)
    {
LABEL_16:
      if (v10) {
        long long v15 = (uint64_t **)v12;
      }
      else {
        long long v15 = (uint64_t **)a2;
      }
      if (v10) {
        long long v14 = (uint64_t **)(v12 + 8);
      }
      else {
        long long v14 = (uint64_t **)a2;
      }
      uint64_t v5 = *v14;
      if (*v14) {
        return v5;
      }
      goto LABEL_43;
    }
    uint64_t v19 = *v8;
    long long v14 = a1 + 1;
    long long v15 = a1 + 1;
    if (*v8)
    {
      while (1)
      {
        while (1)
        {
          long long v15 = (uint64_t **)v19;
          unsigned int v20 = *((_DWORD *)v19 + 8);
          if (v20 <= v7) {
            break;
          }
          uint64_t v19 = (uint64_t *)*v19;
          long long v14 = v15;
          if (!*v15) {
            goto LABEL_43;
          }
        }
        if (v20 >= v7) {
          return (uint64_t *)v15;
        }
        uint64_t v19 = (uint64_t *)v19[1];
        if (!v19) {
          goto LABEL_30;
        }
      }
    }
  }
  else
  {
    if (v9 >= v7) {
      return v5;
    }
    long long v14 = (uint64_t **)(a2 + 8);
    long long v13 = *(uint64_t **)(a2 + 8);
    if (v13)
    {
      do
      {
        long long v14 = (uint64_t **)v13;
        long long v13 = (uint64_t *)*v13;
        long long v15 = v14;
        long long v16 = v14;
      }
      while (v13);
    }
    else
    {
      long long v16 = (uint64_t **)a2;
      do
      {
        OsLogContext v21 = (uint64_t *)v16;
        long long v16 = (uint64_t **)v16[2];
      }
      while (*v16 != v21);
      long long v15 = (uint64_t **)a2;
    }
    if (v16 != v8 && *((_DWORD *)v16 + 8) <= v7)
    {
      long long v22 = *v8;
      long long v14 = a1 + 1;
      long long v15 = a1 + 1;
      if (*v8)
      {
        while (1)
        {
          while (1)
          {
            long long v15 = (uint64_t **)v22;
            unsigned int v23 = *((_DWORD *)v22 + 8);
            if (v23 <= v7) {
              break;
            }
            long long v22 = (uint64_t *)*v22;
            long long v14 = v15;
            if (!*v15) {
              goto LABEL_43;
            }
          }
          if (v23 >= v7) {
            return (uint64_t *)v15;
          }
          long long v22 = (uint64_t *)v22[1];
          if (!v22)
          {
LABEL_30:
            long long v14 = v15 + 1;
            break;
          }
        }
      }
    }
  }
LABEL_43:
  uint64_t v5 = (uint64_t *)operator new(0x38uLL);
  *((_DWORD *)v5 + 8) = *(_DWORD *)a4;
  uint64_t v24 = *(void *)(a4 + 16);
  void v5[5] = *(void *)(a4 + 8);
  v5[6] = v24;
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100046C38(a1, (uint64_t)v15, v14, v5);
  return v5;
}

const void **sub_1007B946C@<X0>(os_log_t *a1@<X0>, Registry **a2@<X1>, const UInt8 *a3@<X2>, const void **a4@<X8>)
{
  *a4 = 0;
  int v8 = *((char *)a3 + 23);
  if (v8 >= 0) {
    unsigned int v9 = a3;
  }
  else {
    unsigned int v9 = *(const UInt8 **)a3;
  }
  if (v8 >= 0) {
    CFIndex v10 = a3[23];
  }
  else {
    CFIndex v10 = *((void *)a3 + 1);
  }
  CFURLRef v11 = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, v9, v10, 0);
  CFURLRef v23 = v11;
  if (v11) {
    uint64_t v12 = sub_1000FCC20;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v12)
  {
    memset(v29, 0, sizeof(v29));
    uint64_t v30 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0u;
    uint64_t v26 = 0;
    long long v13 = *a2;
    memset(v29, 0, sizeof(v29));
    Registry::getFileSystemInterface((uint64_t *)v29, v13);
    if (*(void *)v29)
    {
      CFTypeRef cf = 0;
      (*(void (**)(CFTypeRef *__return_ptr))(**(void **)v29 + 152))(&cf);
      CFTypeRef v14 = cf;
      if (cf) {
        long long v15 = sub_100080778;
      }
      else {
        long long v15 = 0;
      }
      if (!v15)
      {
        long long v16 = *a1;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          CFURLRef v28 = v11;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Failed to load the file: %@", buf, 0xCu);
          CFTypeRef v14 = cf;
        }
      }
      OsLogContext v21 = v14;
      if (v14) {
        CFRetain(v14);
      }
      sub_100057D78(&cf);
      if (*(void *)&v29[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v29[8]);
      }
    }
    else
    {
      if (*(void *)&v29[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v29[8]);
      }
      uint64_t v19 = *a1;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v29 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not get FileSystemInterface", v29, 2u);
      }
      OsLogContext v21 = 0;
    }
    if (SHIBYTE(v26) < 0) {
      operator delete(__p[0]);
    }
    sub_10004EFE4(&v22, &v21);
    if (&v22 != a4)
    {
      *(void *)long long v29 = *a4;
      *a4 = v22;
      long long v22 = 0;
      sub_100057D78((const void **)v29);
    }
    sub_100057D78(&v22);
    sub_1000577C4(&v21);
  }
  else
  {
    uint64_t v17 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) >= 0) {
        BOOL v18 = a3;
      }
      else {
        BOOL v18 = *(const UInt8 **)a3;
      }
      *(_DWORD *)long long v29 = 136315138;
      *(void *)&v29[4] = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N Failed to get the URL for the file %s", v29, 0xCu);
    }
  }
  return sub_1000FE824((const void **)&v23);
}

void sub_1007B973C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007B983C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007B98C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1007B996C(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  *a1 = off_101A09478;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  uint64_t v6 = a3[1];
  a1[4] = *a3;
  a1[5] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  id v7 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:10];
  int v8 = (void *)a1[2];
  a1[2] = v7;

  unsigned int v9 = (void *)a1[1];
  a1[1] = v5;
  id v10 = v5;

  CFURLRef v11 = (void *)a1[3];
  a1[3] = 0;

  return a1;
}

void sub_1007B9A20(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 40);
  if (v4) {
    sub_10004D2C8(v4);
  }

  DataUsageCacheManagerInterface::~DataUsageCacheManagerInterface((DataUsageCacheManagerInterface *)v1);
  _Unwind_Resume(a1);
}

void sub_1007B9A5C(uint64_t a1)
{
  uint64_t v19 = [*(id *)(a1 + 8) mainObjectContext];
  if (v19)
  {
    long long v16 = +[NSEntityDescription entityForName:inManagedObjectContext:](NSEntityDescription, "entityForName:inManagedObjectContext:", @"Process");
    id v17 = objc_alloc_init((Class)NSFetchRequest);
    [v17 setEntity:v16];
    [v17 setResultType:2];
    [v17 setFetchLimit:10];
    id v2 = objc_alloc_init((Class)NSExpressionDescription);
    [v2 setName:@"objectID"];
    int v3 = +[NSExpression expressionForEvaluatedObject];
    [v2 setExpression:v3];

    [v2 setExpressionResultType:2000];
    uint64_t v4 = +[NSArray arrayWithObjects:@"procName", v2, 0];
    [v17 setPropertiesToFetch:v4];

    id v24 = 0;
    id v5 = [v19 executeFetchRequest:v17 error:&v24];
    id v15 = v24;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v6 = v5;
    id v7 = [v6 countByEnumeratingWithState:&v20 objects:v26 count:16];
    if (v7)
    {
      uint64_t v8 = *(void *)v21;
      do
      {
        for (unint64_t i = 0; i != v7; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v21 != v8) {
            objc_enumerationMutation(v6);
          }
          id v10 = *(void **)(*((void *)&v20 + 1) + 8 * i);
          CFURLRef v11 = [v10 objectForKeyedSubscript:@"procName"];
          uint64_t v12 = [v10 objectForKeyedSubscript:@"objectID"];
          sub_1007B9DD4(a1, v11, v12);
        }
        id v7 = [v6 countByEnumeratingWithState:&v20 objects:v26 count:16];
      }
      while (v7);
    }

    long long v13 = v19;
  }
  else
  {
    CFTypeRef v14 = *(NSObject **)getDataUsageLog();
    long long v13 = 0;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Managed object context is nil", buf, 2u);
    }
  }
}

void sub_1007B9D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1007B9DD4(uint64_t a1, void *a2, void *a3)
{
  id v11 = a2;
  id v5 = a3;
  if (v11 && v5)
  {
    id v6 = [*(id *)(a1 + 16) objectForKey:v11];

    if (!v6)
    {
      while ((unint64_t)[*(id *)(a1 + 16) count] >= 0xA)
      {
        unsigned int v9 = [*(id *)(a1 + 16) keysSortedByValueUsingSelector:"compare:"];
        id v10 = [v9 firstObject];

        if (v10) {
          [*(id *)(a1 + 16) removeObjectForKey:v10];
        }
      }
    }
    id v7 = *(void **)(a1 + 16);
    id v8 = [[CacheEntry alloc] init:v5];
    [v7 setObject:v8 forKey:v11];
  }
}

void sub_1007B9EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1007B9F24(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v6 = v3;
  if (v3)
  {
    uint64_t v4 = [v3 objectID];
    id v5 = *(void **)(a1 + 24);
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    id v5 = *(void **)(a1 + 24);
    *(void *)(a1 + 24) = 0;
  }
}

void sub_1007B9F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id sub_1007B9FA0(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    id v2 = [*(id *)(a1 + 8) mainObjectContext];
    id v3 = v2;
    if (v2)
    {
      uint64_t v4 = [v2 objectWithID:*(void *)(a1 + 24)];
    }
    else
    {
      id v5 = *(NSObject **)getDataUsageLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v7 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Managed object context is nil", v7, 2u);
      }
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

void sub_1007BA064(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007BA078(uint64_t a1, void *a2)
{
  id v5 = a2;
  id v3 = [v5 procName];
  uint64_t v4 = [v5 objectID];
  sub_1007B9DD4(a1, v3, v4);
}

void sub_1007BA0F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id sub_1007BA124(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = [*(id *)(a1 + 16) objectForKey:v3];
    if (v4)
    {
      [v4 setLastAccess:CFAbsoluteTimeGetCurrent()];
      id v5 = [v4 nsManagedObjectId];
      if (v5)
      {
        id v6 = [*(id *)(a1 + 8) mainObjectContext];
        id v7 = v6;
        if (v6)
        {
          id v8 = [v6 objectWithID:v5];
        }
        else
        {
          unsigned int v9 = *(NSObject **)getDataUsageLog();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)id v11 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Managed object context is nil", v11, 2u);
          }
          id v8 = 0;
        }
      }
      else
      {
        id v8 = 0;
      }
    }
    else
    {
      id v8 = 0;
    }
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void sub_1007BA250(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007BA28C(uint64_t a1)
{
  *(void *)a1 = off_101A09478;
  id v2 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = 0;

  id v3 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;

  uint64_t v4 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;

  id v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5) {
    sub_10004D2C8(v5);
  }

  DataUsageCacheManagerInterface::~DataUsageCacheManagerInterface((DataUsageCacheManagerInterface *)a1);
}

void sub_1007BA328(uint64_t a1)
{
  sub_1007BA28C(a1);

  operator delete();
}

uint64_t sub_1007BA360(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)a1 = off_101AB2248;
  id v5 = (void *)(a1 + 8);
  id v6 = (std::__shared_weak_count *)a2[1];
  v10[0] = *a2;
  v10[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10132B1BC(v5, v10);
  if (v6) {
    sub_10004D2C8(v6);
  }
  *(void *)a1 = off_101A094E0;
  *(void *)(a1 + 32) = *(void *)a3;
  id v7 = (unsigned char *)(a1 + 40);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(v7, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v8 = *(_OWORD *)(a3 + 8);
    *(void *)(a1 + 56) = *(void *)(a3 + 24);
    *(_OWORD *)id v7 = v8;
  }
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a3 + 32);
  return a1;
}

void sub_1007BA438(_Unwind_Exception *exception_object)
{
  if (*(void *)(v1 + 16)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007BA460(uint64_t a1, os_log_t *a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v7 = 0;
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2 <= 0)
  {
    uint64_t v4 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      unsigned int v9 = "Config_refresh.xml";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Invalid validity of %s xml", buf, 0xCu);
    }
    return 1;
  }
  else
  {
    BOOL v3 = sub_10132B248(a1 + 8, v2, (uint64_t)__p);
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[0]);
    }
  }
  return v3;
}

void sub_1007BA544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007BA560(uint64_t a1)
{
  *(void *)a1 = off_101A094E0;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1007BA5BC(uint64_t a1)
{
  *(void *)a1 = off_101A094E0;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

uint64_t sub_1007BA638(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v3 = a1 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)v3, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(v3 + 16) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v3 = v4;
  }
  *(unsigned char *)(a1 + 32) = 1;
  return a1;
}

void sub_1007BA698(uint64_t a1)
{
  *(void *)a1 = off_101A09540;
  uint64_t v2 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v4) {
    sub_100206334(a1 + 96, v4);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v5) {
    sub_100206334(a1 + 88, v5);
  }
  sub_100110A40((void ***)(a1 + 80), 0);
  uint64_t v6 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v6) {
    sub_100206334(a1 + 72, v6);
  }
  uint64_t v7 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v7) {
    sub_100206334(a1 + 64, v7);
  }
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v8) {
    sub_100206334(a1 + 56, v8);
  }
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v9) {
    sub_100206334(a1 + 48, v9);
  }
  uint64_t v10 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v10) {
    sub_100206334(a1 + 40, v10);
  }
  uint64_t v11 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v11) {
    sub_100206334(a1 + 32, v11);
  }
  uint64_t v12 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v12) {
    sub_100206334(a1 + 24, v12);
  }
  uint64_t v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v13) {
    sub_100206334(a1 + 16, v13);
  }
  uint64_t v14 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v14) {
    sub_100206334(a1 + 8, v14);
  }

  PB::Base::~Base((PB::Base *)a1);
}

void sub_1007BA834(uint64_t a1)
{
  sub_1007BA698(a1);

  operator delete();
}

uint64_t sub_1007BA86C(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = off_101A09540;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  *(_DWORD *)(result + 128) = 0;
  *(_OWORD *)(result + 104) = 0u;
  if (*(void *)(a2 + 80)) {
    operator new();
  }
  if (*(void *)(a2 + 32)) {
    operator new();
  }
  char v2 = *(unsigned char *)(a2 + 128);
  if ((v2 & 0x10) != 0)
  {
    char v3 = *(unsigned char *)(a2 + 124);
    *(unsigned char *)(result + 128) |= 0x10u;
    *(unsigned char *)(result + 124) = v3;
    char v2 = *(unsigned char *)(a2 + 128);
  }
  if ((v2 & 8) != 0)
  {
    char v4 = *(unsigned char *)(a2 + 123);
    *(unsigned char *)(result + 128) |= 8u;
    *(unsigned char *)(result + 123) = v4;
  }
  if (*(void *)(a2 + 56)) {
    operator new();
  }
  if (*(void *)(a2 + 64)) {
    operator new();
  }
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 24)) {
    operator new();
  }
  char v5 = *(unsigned char *)(a2 + 128);
  if ((v5 & 4) != 0)
  {
    char v7 = *(unsigned char *)(a2 + 122);
    *(unsigned char *)(result + 128) |= 4u;
    *(unsigned char *)(result + 122) = v7;
    char v5 = *(unsigned char *)(a2 + 128);
    if ((v5 & 2) == 0)
    {
LABEL_19:
      if ((v5 & 1) == 0) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
  }
  else if ((*(unsigned char *)(a2 + 128) & 2) == 0)
  {
    goto LABEL_19;
  }
  char v8 = *(unsigned char *)(a2 + 121);
  *(unsigned char *)(result + 128) |= 2u;
  *(unsigned char *)(result + 121) = v8;
  if (*(unsigned char *)(a2 + 128))
  {
LABEL_20:
    char v6 = *(unsigned char *)(a2 + 120);
    *(unsigned char *)(result + 128) |= 1u;
    *(unsigned char *)(result + 120) = v6;
  }
LABEL_21:
  if (*(void *)(a2 + 104)) {
    operator new();
  }
  if (*(void *)(a2 + 72)) {
    operator new();
  }
  if (*(void *)(a2 + 48)) {
    operator new();
  }
  if (*(void *)(a2 + 40)) {
    operator new();
  }
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(void *)(a2 + 112)) {
    operator new();
  }
  if (*(void *)(a2 + 88)) {
    operator new();
  }
  if (*(void *)(a2 + 96)) {
    operator new();
  }
  return result;
}

uint64_t sub_1007BAFA4(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  char v5 = *(unsigned char *)(a1 + 128);
  if (v5)
  {
    PB::TextFormatter::format(this, "ccRequired", *(unsigned char *)(a1 + 120));
    char v5 = *(unsigned char *)(a1 + 128);
    if ((v5 & 2) == 0)
    {
LABEL_5:
      if ((v5 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  else if ((*(unsigned char *)(a1 + 128) & 2) == 0)
  {
    goto LABEL_5;
  }
  PB::TextFormatter::format(this, "deleteNotAllowed", *(unsigned char *)(a1 + 121));
  if ((*(unsigned char *)(a1 + 128) & 4) != 0) {
LABEL_6:
  }
    PB::TextFormatter::format(this, "disableNotAllowed", *(unsigned char *)(a1 + 122));
LABEL_7:
  if (*(void *)(a1 + 16)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 24)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 32)) {
    PB::TextFormatter::format();
  }
  char v6 = *(unsigned char *)(a1 + 128);
  if ((v6 & 8) != 0)
  {
    PB::TextFormatter::format(this, "isActive", *(unsigned char *)(a1 + 123));
    char v6 = *(unsigned char *)(a1 + 128);
  }
  if ((v6 & 0x10) != 0) {
    PB::TextFormatter::format(this, "isBootstrap", *(unsigned char *)(a1 + 124));
  }
  if (*(void *)(a1 + 40)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 48)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 56)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 64)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 72)) {
    PB::TextFormatter::format();
  }
  char v7 = *(const PB::Data **)(a1 + 80);
  if (v7) {
    PB::TextFormatter::format(this, "profileId", v7);
  }
  if (*(void *)(a1 + 88)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 96)) {
    PB::TextFormatter::format();
  }
  uint64_t v8 = *(void *)(a1 + 104);
  if (v8) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "subscriptionDetails");
  }
  uint64_t v9 = *(void *)(a1 + 112);
  if (v9) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, this, "transferDetails");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1007BB210(unsigned char *a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
        break;
      }
      char v15 = 0;
      unsigned int v16 = 0;
      unint64_t v11 = 0;
      if (v2 > v3) {
        unint64_t v3 = v2;
      }
      do
      {
        if (v3 == v2)
        {
          int v4 = 1;
          *((unsigned char *)this + 24) = 1;
          return v4 == 0;
        }
        unint64_t v17 = v2 + 1;
        char v18 = *(unsigned char *)(v8 + v2);
        *((void *)this + 1) = v17;
        v11 |= (unint64_t)(v18 & 0x7F) << v15;
        if ((v18 & 0x80) == 0) {
          goto LABEL_22;
        }
        v15 += 7;
        unint64_t v2 = v17;
        BOOL v14 = v16++ > 8;
      }
      while (!v14);
LABEL_19:
      unsigned __int8 v19 = 0;
      LODWORD(v20) = 0;
LABEL_20:
      uint64_t result = PB::Reader::skip(this, v20, v19, 0);
      if (!result) {
        return result;
      }
LABEL_48:
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v9 = 0;
    unsigned int v10 = 0;
    unint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = v2 + 1;
      *((void *)this + 1) = v2 + 1;
      char v13 = *(unsigned char *)(v8 + v2);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0) {
        break;
      }
      v9 += 7;
      unint64_t v2 = v12;
      BOOL v14 = v10++ > 8;
      if (v14) {
        goto LABEL_19;
      }
    }
LABEL_22:
    unsigned __int8 v19 = v11 & 7;
    if ((v11 & 7) != 4)
    {
      unint64_t v20 = v11 >> 3;
      switch((v11 >> 3))
      {
        case 1u:
          operator new();
        case 2u:
          operator new();
        case 3u:
          a1[128] |= 0x10u;
          unint64_t v22 = *((void *)this + 1);
          if (v22 >= *((void *)this + 2))
          {
            BOOL v25 = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v23 = v22 + 1;
            int v24 = *(unsigned __int8 *)(*(void *)this + v22);
            *((void *)this + 1) = v23;
            BOOL v25 = v24 != 0;
          }
          a1[124] = v25;
          goto LABEL_48;
        case 4u:
          a1[128] |= 8u;
          unint64_t v26 = *((void *)this + 1);
          if (v26 >= *((void *)this + 2))
          {
            BOOL v29 = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v27 = v26 + 1;
            int v28 = *(unsigned __int8 *)(*(void *)this + v26);
            *((void *)this + 1) = v27;
            BOOL v29 = v28 != 0;
          }
          a1[123] = v29;
          goto LABEL_48;
        case 5u:
          operator new();
        case 6u:
          operator new();
        case 7u:
          operator new();
        case 8u:
          operator new();
        case 9u:
          a1[128] |= 4u;
          unint64_t v30 = *((void *)this + 1);
          if (v30 >= *((void *)this + 2))
          {
            BOOL v33 = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v31 = v30 + 1;
            int v32 = *(unsigned __int8 *)(*(void *)this + v30);
            *((void *)this + 1) = v31;
            BOOL v33 = v32 != 0;
          }
          a1[122] = v33;
          goto LABEL_48;
        case 0xAu:
          a1[128] |= 2u;
          unint64_t v34 = *((void *)this + 1);
          if (v34 >= *((void *)this + 2))
          {
            BOOL v37 = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v35 = v34 + 1;
            int v36 = *(unsigned __int8 *)(*(void *)this + v34);
            *((void *)this + 1) = v35;
            BOOL v37 = v36 != 0;
          }
          a1[121] = v37;
          goto LABEL_48;
        case 0xBu:
          a1[128] |= 1u;
          unint64_t v38 = *((void *)this + 1);
          if (v38 >= *((void *)this + 2))
          {
            BOOL v41 = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v39 = v38 + 1;
            int v40 = *(unsigned __int8 *)(*(void *)this + v38);
            *((void *)this + 1) = v39;
            BOOL v41 = v40 != 0;
          }
          a1[120] = v41;
          goto LABEL_48;
        case 0xCu:
          operator new();
        case 0xDu:
          operator new();
        case 0xEu:
          operator new();
        case 0xFu:
          operator new();
        case 0x10u:
          operator new();
        case 0x11u:
          operator new();
        case 0x12u:
          operator new();
        case 0x13u:
          operator new();
        default:
          goto LABEL_20;
      }
    }
    int v4 = 0;
  }
  return v4 == 0;
}

uint64_t sub_1007BBB10(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 80);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  if (*(void *)(v3 + 32)) {
    uint64_t result = PB::Writer::write();
  }
  char v5 = *(unsigned char *)(v3 + 128);
  if ((v5 & 0x10) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 124), 3u);
    char v5 = *(unsigned char *)(v3 + 128);
  }
  if ((v5 & 8) != 0) {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 123), 4u);
  }
  if (*(void *)(v3 + 56)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 64)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 16)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 24)) {
    uint64_t result = PB::Writer::write();
  }
  char v6 = *(unsigned char *)(v3 + 128);
  if ((v6 & 4) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 122), 9u);
    char v6 = *(unsigned char *)(v3 + 128);
    if ((v6 & 2) == 0)
    {
LABEL_19:
      if ((v6 & 1) == 0) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
  }
  else if ((*(unsigned char *)(v3 + 128) & 2) == 0)
  {
    goto LABEL_19;
  }
  uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 121), 0xAu);
  if (*(unsigned char *)(v3 + 128)) {
LABEL_20:
  }
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 120), 0xBu);
LABEL_21:
  char v7 = *(const PB::Base **)(v3 + 104);
  if (v7) {
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 0xCu);
  }
  if (*(void *)(v3 + 72)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 48)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 40)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 8)) {
    uint64_t result = PB::Writer::write();
  }
  uint64_t v8 = *(const PB::Base **)(v3 + 112);
  if (v8) {
    uint64_t result = PB::Writer::writeSubmessage(this, v8, 0x11u);
  }
  if (*(void *)(v3 + 88)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 96))
  {
    return PB::Writer::write();
  }
  return result;
}

uint64_t sub_1007BBCE8(uint64_t result)
{
  if (!*(void *)(result + 104)) {
    operator new();
  }
  return result;
}

uint64_t sub_1007BBD98(uint64_t result)
{
  if (!*(void *)(result + 112)) {
    operator new();
  }
  return result;
}

void sub_1007BBE54()
{
}

void sub_1007BBEC4()
{
}

uint64_t sub_1007BBEE8(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2 > 3) {
    char v6 = "DATA.iRatClient.1";
  }
  else {
    char v6 = off_101A09880[a2];
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v10, kCtLoggingSystemName, v6);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v10);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 72), (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
  sub_100058DB0(&__p, "com.apple.irat.client");
  ctu::XpcClient::XpcClient();
  if (v9 < 0) {
    operator delete(__p);
  }
  *(void *)a1 = off_101A09590;
  *(void *)(a1 + 80) = a3;
  *(_DWORD *)(a1 + 88) = a2;
  return a1;
}

void sub_1007BBFD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, char a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  ctu::OsLogLogger::~OsLogLogger(v17);
  _Unwind_Resume(a1);
}

void sub_1007BC020(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_1007BC12C;
  void v3[3] = &unk_101A095B0;
  void v3[4] = a1;
  uint64_t v6 = 0;
  char v7 = 0;
  sub_10003E168(&v6, (void *)(a1 + 8));
  unint64_t v2 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1007BF350;
  block[3] = &unk_101A09740;
  block[5] = v6;
  char v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1007BC12C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unint64_t v2 = *(NSObject **)(v1 + 72);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting iRat Client", buf, 2u);
  }
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.WirelessCoexManager", *(dispatch_queue_t *)(v1 + 24), 0);
  if (mach_service)
  {
    xpc_object_t v4 = mach_service;
    xpc_object_t object = mach_service;
LABEL_6:
    xpc_retain(v4);
    goto LABEL_7;
  }
  xpc_object_t v4 = xpc_null_create();
  xpc_object_t object = v4;
  if (v4) {
    goto LABEL_6;
  }
  xpc_object_t v4 = 0;
  xpc_object_t object = xpc_null_create();
LABEL_7:
  v5.var0.fObuint64_t j = (dispatch_object_s *)&object;
  ctu::XpcClient::setServer_sync((ctu::XpcClient *)v1, v5);
  xpc_release(object);
  xpc_object_t object = 0;
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_connection) {
    sub_1007BD32C(v1);
  }
  xpc_release(v4);
}

void sub_1007BC22C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_1007BC25C(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_1007BC320;
  void v3[3] = &unk_101A095D0;
  void v3[4] = a1;
  xpc_object_t v4 = v3;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_1007BF38C;
  block[3] = &unk_101A09770;
  block[4] = a1 + 8;
  block[5] = &v4;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8)) {
    dispatch_async_and_wait(v1, block);
  }
  else {
    dispatch_sync(v1, block);
  }
}

void sub_1007BC320(uint64_t a1)
{
  uint64_t v1 = *(ctu::XpcClient **)(a1 + 32);
  uint64_t v2 = *((void *)v1 + 9);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Shutting down iRat Client", buf, 2u);
  }
  xpc_object_t object = xpc_null_create();
  v3.var0.fObuint64_t j = (dispatch_object_s *)&object;
  ctu::XpcClient::setServer_sync(v1, v3);
  xpc_release(object);
}

void sub_1007BC3A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void sub_1007BC3C0(uint64_t a1, uint64_t *a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  _OWORD v6[2] = sub_1007BC4F4;
  void v6[3] = &unk_101A095F0;
  uint64_t v4 = *a2;
  connection v3 = (std::__shared_weak_count *)a2[1];
  _OWORD v6[4] = a1;
  v6[5] = v4;
  char v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  connection v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1007BF350;
  block[3] = &unk_101A09740;
  block[5] = v10;
  char v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1007BC4F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 48);
  v4[0] = *(int ****)(a1 + 40);
  v4[1] = (int ***)v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1007BC584(v2, 0x190uLL, v4);
  if (v3)
  {
    sub_10004D2C8((std::__shared_weak_count *)v3);
  }
}

void sub_1007BC56C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007BC584(uint64_t a1, uint64_t a2, int ****a3)
{
  if (xpc_get_type(*(xpc_object_t *)(a1 + 40)) != (xpc_type_t)&_xpc_type_connection)
  {
    uint64_t v6 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Invalid XPC connection. Failed to send msg %llu to server", (uint8_t *)&buf, 0xCu);
    }
    return;
  }
  xpc_object_t v7 = xpc_array_create(0, 0);
  if (v7 || (xpc_object_t v7 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t v7 = 0;
  }
  uint64_t v35 = a2;
  xpc_object_t xarray = v8;
  xpc_release(v7);
  char v9 = **a3;
  uint64_t v10 = (*a3)[1];
  while (v9 != v10)
  {
    unint64_t v11 = *v9;
    unint64_t v12 = (std::__shared_weak_count *)v9[1];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*v11 < 0) {
      goto LABEL_74;
    }
    *(void *)uint64_t v60 = 0;
    xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v14 = v13;
    if (v13)
    {
      *(void *)uint64_t v60 = v13;
    }
    else
    {
      xpc_object_t v14 = xpc_null_create();
      *(void *)uint64_t v60 = v14;
      if (!v14)
      {
        xpc_object_t v15 = xpc_null_create();
        xpc_object_t v14 = 0;
        goto LABEL_21;
      }
    }
    if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v14);
      goto LABEL_22;
    }
    xpc_object_t v15 = xpc_null_create();
LABEL_21:
    *(void *)uint64_t v60 = v15;
LABEL_22:
    xpc_release(v14);
    xpc_object_t object = xpc_uint64_create(*v11);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    *(void *)&long long buf = v60;
    *((void *)&buf + 1) = "kWRMApplicationType";
    sub_100035E70((uint64_t)&buf, &object, &v57);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    xpc_release(object);
    xpc_object_t object = 0;
    sub_10134D304((uint64_t)v60);
    uint64_t v16 = v11[1];
    if ((v16 & 0x80000000) == 0)
    {
      xpc_object_t v54 = xpc_uint64_create(v16);
      if (!v54) {
        xpc_object_t v54 = xpc_null_create();
      }
      *(void *)&long long buf = v60;
      *((void *)&buf + 1) = "kWRMLinkType";
      sub_100035E70((uint64_t)&buf, &v54, &v55);
      xpc_release(v55);
      xpc_object_t v55 = 0;
      xpc_release(v54);
      xpc_object_t v54 = 0;
    }
    unint64_t v17 = (const char *)(v11 + 2);
    if (*((char *)v11 + 31) < 0)
    {
      if (!*((void *)v11 + 2)) {
        goto LABEL_36;
      }
      unint64_t v17 = *(const char **)v17;
    }
    else if (!*((unsigned char *)v11 + 31))
    {
      goto LABEL_36;
    }
    xpc_object_t v52 = xpc_string_create(v17);
    if (!v52) {
      xpc_object_t v52 = xpc_null_create();
    }
    *(void *)&long long buf = v60;
    *((void *)&buf + 1) = "kWRMConnIdentifier";
    sub_100035E70((uint64_t)&buf, &v52, &v53);
    xpc_release(v53);
    xpc_object_t v53 = 0;
    xpc_release(v52);
    xpc_object_t v52 = 0;
LABEL_36:
    uint64_t v18 = v11[8];
    if ((v18 & 0x80000000) == 0)
    {
      xpc_object_t v50 = xpc_uint64_create(v18);
      if (!v50) {
        xpc_object_t v50 = xpc_null_create();
      }
      *(void *)&long long buf = v60;
      *((void *)&buf + 1) = "kWRMDesiredLinkQoS";
      sub_100035E70((uint64_t)&buf, &v50, &v51);
      xpc_release(v51);
      xpc_object_t v51 = 0;
      xpc_release(v50);
      xpc_object_t v50 = 0;
    }
    uint64_t v19 = v11[9];
    if ((v19 & 0x80000000) == 0)
    {
      xpc_object_t v48 = xpc_uint64_create(v19);
      if (!v48) {
        xpc_object_t v48 = xpc_null_create();
      }
      *(void *)&long long buf = v60;
      *((void *)&buf + 1) = "kWRMDesiredBandwidth";
      sub_100035E70((uint64_t)&buf, &v48, &v49);
      xpc_release(v49);
      xpc_object_t v49 = 0;
      xpc_release(v48);
      xpc_object_t v48 = 0;
    }
    uint64_t v20 = v11[10];
    if ((v20 & 0x80000000) == 0)
    {
      xpc_object_t v46 = xpc_uint64_create(v20);
      if (!v46) {
        xpc_object_t v46 = xpc_null_create();
      }
      *(void *)&long long buf = v60;
      *((void *)&buf + 1) = "kWRMServiceStatus";
      sub_100035E70((uint64_t)&buf, &v46, &v47);
      xpc_release(v47);
      xpc_object_t v47 = 0;
      xpc_release(v46);
      xpc_object_t v46 = 0;
    }
    if (v11[11] < 0 && v11[12] < 0) {
      goto LABEL_73;
    }
    xpc_object_t v45 = 0;
    xpc_object_t v21 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v22 = v21;
    if (v21)
    {
      xpc_object_t v45 = v21;
    }
    else
    {
      xpc_object_t v22 = xpc_null_create();
      xpc_object_t v45 = v22;
      if (!v22)
      {
        xpc_object_t v23 = xpc_null_create();
        xpc_object_t v22 = 0;
        goto LABEL_57;
      }
    }
    if (xpc_get_type(v22) != (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t v23 = xpc_null_create();
LABEL_57:
      xpc_object_t v45 = v23;
      goto LABEL_58;
    }
    xpc_retain(v22);
LABEL_58:
    xpc_release(v22);
    xpc_object_t v43 = v45;
    if (v45) {
      xpc_retain(v45);
    }
    else {
      xpc_object_t v43 = xpc_null_create();
    }
    *(void *)&long long buf = v60;
    *((void *)&buf + 1) = "kWRMPolicyInfo";
    sub_10014E03C((uint64_t)&buf, &v43, &v44);
    xpc_release(v44);
    xpc_object_t v44 = 0;
    xpc_release(v43);
    xpc_object_t v43 = 0;
    unsigned int v24 = v11[11];
    if ((v24 & 0x80000000) == 0)
    {
      if (v24 <= 2) {
        int64_t v25 = v24;
      }
      else {
        int64_t v25 = 0;
      }
      xpc_object_t v41 = xpc_int64_create(v25);
      if (!v41) {
        xpc_object_t v41 = xpc_null_create();
      }
      *(void *)&long long buf = &v45;
      *((void *)&buf + 1) = "kWRMPolicyInfoHoAlgorithmType";
      sub_100035E70((uint64_t)&buf, &v41, &v42);
      xpc_release(v42);
      xpc_object_t v42 = 0;
      xpc_release(v41);
      xpc_object_t v41 = 0;
    }
    uint64_t v26 = v11[12];
    if ((v26 & 0x80000000) == 0)
    {
      xpc_object_t v39 = xpc_uint64_create(v26);
      if (!v39) {
        xpc_object_t v39 = xpc_null_create();
      }
      *(void *)&long long buf = &v45;
      *((void *)&buf + 1) = "kWRMPolicyInfoServiceType";
      sub_100035E70((uint64_t)&buf, &v39, &v40);
      xpc_release(v40);
      xpc_object_t v40 = 0;
      xpc_release(v39);
      xpc_object_t v39 = 0;
    }
    xpc_release(v45);
LABEL_73:
    xpc_array_append_value(xarray, *(xpc_object_t *)v60);
    xpc_release(*(xpc_object_t *)v60);
LABEL_74:
    if (v12)
    {
      sub_10004D2C8(v12);
      sub_10004D2C8(v12);
    }
    v9 += 2;
  }
  if (xarray)
  {
    xpc_retain(xarray);
    sub_1006941A8(&object);
    xpc_object_t v27 = xarray;
LABEL_80:
    xpc_retain(v27);
    uint64_t v28 = v35;
    xpc_object_t v29 = v27;
LABEL_81:
    xpc_retain(v29);
    xpc_object_t v57 = v29;
    xpc_object_t v30 = v29;
    goto LABEL_82;
  }
  xpc_object_t v27 = xpc_null_create();
  sub_1006941A8(&object);
  if (v27) {
    goto LABEL_80;
  }
  uint64_t v28 = v35;
  xpc_object_t v29 = xpc_null_create();
  if (v29)
  {
    xpc_object_t v27 = 0;
    goto LABEL_81;
  }
  xpc_object_t v30 = xpc_null_create();
  xpc_object_t v57 = v30;
  if (!v30)
  {
    xpc_object_t v27 = 0;
    xpc_object_t v29 = 0;
    xpc_object_t v30 = 0;
    xpc_object_t v57 = xpc_null_create();
    goto LABEL_83;
  }
  xpc_object_t v27 = 0;
  xpc_object_t v29 = 0;
LABEL_82:
  xpc_retain(v30);
LABEL_83:
  *(void *)&long long buf = &object;
  *((void *)&buf + 1) = "kWRMApplicationTypeList";
  sub_100035E70((uint64_t)&buf, &v57, (xpc_object_t *)v60);
  xpc_release(*(xpc_object_t *)v60);
  *(void *)uint64_t v60 = 0;
  xpc_release(v57);
  xpc_object_t v57 = 0;
  xpc_object_t v31 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v31 = xpc_null_create();
  }
  xpc_release(v30);
  xpc_release(v29);
  xpc_release(object);
  xpc_object_t v32 = xpc_null_create();
  xpc_release(v32);
  xpc_release(v27);
  xpc_object_t v57 = 0;
  sub_1006941A8(&buf);
  sub_1007BF3A0((void **)v60, (void **)&buf, (uint64_t)"kMessageId", v28);
  xpc_release((xpc_object_t)buf);
  xpc_object_t v57 = *(xpc_object_t *)v60;
  *(void *)uint64_t v60 = xpc_null_create();
  xpc_release(*(xpc_object_t *)v60);
  xpc_object_t v37 = v31;
  if (v31) {
    xpc_retain(v31);
  }
  else {
    xpc_object_t v37 = xpc_null_create();
  }
  *(void *)&long long buf = &v57;
  *((void *)&buf + 1) = "kMessageArgs";
  sub_10014E03C((uint64_t)&buf, &v37, &v38);
  xpc_release(v38);
  xpc_object_t v38 = 0;
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), v57);
  BOOL v33 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)&buf, (xpc::object *)&v57);
    if (v59 >= 0) {
      p_long long buf = &buf;
    }
    else {
      p_long long buf = (long long *)buf;
    }
    *(_DWORD *)uint64_t v60 = 134218242;
    *(void *)&void v60[4] = v28;
    __int16 v61 = 2080;
    uint64_t v62 = p_buf;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Send msg %llu to server: %s", v60, 0x16u);
    if (v59 < 0) {
      operator delete((void *)buf);
    }
  }
  xpc_release(v57);
  xpc_release(v31);
  xpc_release(xarray);
}

void sub_1007BCD9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1007BCF24(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007BCF40(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1007BCF50(uint64_t a1, uint64_t *a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  _OWORD v6[2] = sub_1007BD084;
  void v6[3] = &unk_101A09620;
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  _OWORD v6[4] = a1;
  v6[5] = v4;
  xpc_object_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  connection v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1007BF350;
  block[3] = &unk_101A09740;
  block[5] = v10;
  char v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1007BD084(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 48);
  v4[0] = *(int ****)(a1 + 40);
  v4[1] = (int ***)v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1007BC584(v2, 0x191uLL, v4);
  if (v3)
  {
    sub_10004D2C8((std::__shared_weak_count *)v3);
  }
}

void sub_1007BD0FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007BD114(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_1007BD1F8(uint64_t a1, xpc::object *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)__p, a2);
    connection v5 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136315138;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received error from server: %s", buf, 0xCu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
  if (*(_UNKNOWN **)a2 == &_xpc_error_connection_interrupted)
  {
    uint64_t v6 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Connection interrupted", (uint8_t *)__p, 2u);
    }
    sub_1007BD32C(a1);
  }
}

void sub_1007BD32C(uint64_t a1)
{
  if (xpc_get_type(*(xpc_object_t *)(a1 + 40)) == (xpc_type_t)&_xpc_type_connection)
  {
    xpc_object_t message = 0;
    sub_1006941A8(object);
    sub_1007BF3A0((void **)buf, object, (uint64_t)"kMessageId", 1uLL);
    xpc_release(object[0]);
    xpc_object_t message = *(xpc_object_t *)buf;
    *(void *)long long buf = xpc_null_create();
    xpc_release(*(xpc_object_t *)buf);
    if (*(_DWORD *)(a1 + 88) == 2) {
      uint64_t v3 = 21;
    }
    else {
      uint64_t v3 = 7;
    }
    sub_1006941A8(object);
    sub_1007BF3A0((void **)buf, object, (uint64_t)"kWCMRegisterProcess_ProcessId", v3);
    xpc_release(object[0]);
    uint64_t v4 = *(void **)buf;
    *(void *)long long buf = xpc_null_create();
    xpc_release(*(xpc_object_t *)buf);
    xpc_object_t v9 = v4;
    if (v4) {
      xpc_retain(v4);
    }
    else {
      xpc_object_t v9 = xpc_null_create();
    }
    object[0] = &message;
    object[1] = "kMessageArgs";
    sub_10014E03C((uint64_t)object, &v9, &v10);
    xpc_release(v10);
    xpc_object_t v10 = 0;
    xpc_release(v9);
    xpc_object_t v9 = 0;
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), message);
    connection v5 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)object, (xpc::object *)&message);
      if (v8 >= 0) {
        uint64_t v6 = object;
      }
      else {
        uint64_t v6 = (xpc_object_t *)object[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I register with server: %s", buf, 0xCu);
      if (v8 < 0) {
        operator delete(object[0]);
      }
    }
    (*(void (**)(void, void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), *(unsigned int *)(a1 + 88));
    xpc_release(v4);
    xpc_release(message);
  }
  else
  {
    uint64_t v2 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(object[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Invalid XPC connection. Failed to register with server", (uint8_t *)object, 2u);
    }
  }
}

void sub_1007BD580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  xpc_release(v14);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_1007BD5E4(uint64_t a1, xpc::object *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)&__p, a2);
    connection v5 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
       ? &__p
       : (std::string *)__p.__r_.__value_.__r.__words[0];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received msg from server: %s", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kMessageId";
  sub_100048BAC((uint64_t)&__p, &buf);
  uint64_t v7 = xpc::dyn_cast_or_default((xpc *)&buf, 0, v6);
  xpc_release(buf.__r_.__value_.__l.__data_);
  if (v7 <= 1349)
  {
    if (v7 == 1300)
    {
      unint64_t v34 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Received new Link Preference Notification", (uint8_t *)&__p, 2u);
      }
      xpc_object_t v82 = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kMessageArgs";
      sub_10000CB28((uint64_t)&__p, &v82);
      xpc_object_t xarray = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v82;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMApplicationTypeList";
      sub_10005107C((uint64_t)&__p, &xarray);
      uint64_t v35 = (std::__shared_weak_count *)operator new(0x30uLL);
      v35->__shared_owners_ = 0;
      p_shared_owners = &v35->__shared_owners_;
      v35->__shared_weak_owners_ = 0;
      v35->__vftable = (std::__shared_weak_count_vtbl *)off_101A097A0;
      v35[1].__vftable = 0;
      xpc_object_t v37 = (uint64_t *)&v35[1];
      v35[1].__shared_owners_ = 0;
      v35[1].__shared_weak_owners_ = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)xarray;
      if (xarray) {
        xpc_retain(xarray);
      }
      else {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
      }
      sub_100048BF4(&v83, (void **)&__p.__r_.__value_.__l.__data_, 0);
      xpc_release(__p.__r_.__value_.__l.__data_);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)xarray;
      if (xarray) {
        xpc_retain(xarray);
      }
      else {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
      }
      uint64_t v73 = v35;
      if (xpc_get_type(xarray) == (xpc_type_t)&_xpc_type_array) {
        count = (void *)xpc_array_get_count(xarray);
      }
      else {
        count = 0;
      }
      sub_100048BF4(object, (void **)&__p.__r_.__value_.__l.__data_, count);
      xpc_release(__p.__r_.__value_.__l.__data_);
      for (unint64_t i = v84; i != object[1] || v83 != object[0]; unint64_t i = ++v84)
      {
        v79[0] = &v83;
        v79[1] = (xpc_object_t)i;
        sub_10003FBDC((uint64_t)v79, &v78);
        atomic_fetch_add_explicit(p_shared_owners, 1uLL, memory_order_relaxed);
        xpc_object_t v53 = operator new(0x50uLL);
        v53[1] = 0;
        v53[2] = 0;
        *xpc_object_t v53 = off_101A09840;
        v53[3] = -1;
        v53[4] = 0;
        v53[5] = 0;
        v53[6] = 0;
        v53[7] = -1;
        v53[8] = -1;
        v53[9] = -1;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)(v53 + 3);
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v53;
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v78;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMApplicationType";
        sub_100048BAC((uint64_t)&buf, &v86);
        *((_DWORD *)v53 + 6) = xpc::dyn_cast_or_default((xpc *)&v86, 0, v54);
        xpc_release(v86);
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v78;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMLinkType";
        uint64_t v35 = v73;
        sub_100048BAC((uint64_t)&buf, &v86);
        *((_DWORD *)v53 + 7) = xpc::dyn_cast_or_default((xpc *)&v86, 0, v55);
        xpc_release(v86);
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v78;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMLinkTypeChangeReasonCode";
        sub_100048BAC((uint64_t)&buf, &v86);
        *((_DWORD *)v53 + 19) = xpc::dyn_cast_or_default((xpc *)&v86, 0, v56);
        xpc_release(v86);
        sub_1007BEEA4(v37, (long long *)&__p);
        if (__p.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
        }
        sub_10004D2C8(v73);
        xpc_release(v78);
      }
      xpc_release(v83);
      xpc_release(v83);
      uint64_t v57 = *(void *)(a1 + 80);
      uint64_t v58 = *(unsigned int *)(a1 + 88);
      uint64_t v76 = v37;
      int v77 = v35;
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      (*(void (**)(uint64_t, uint64_t, uint64_t **))(*(void *)v57 + 24))(v57, v58, &v76);
      if (v77) {
        sub_10004D2C8(v77);
      }
      sub_10004D2C8(v35);
      xpc_release(xarray);
      xpc_release(v82);
    }
    else if (v7 == 1304)
    {
      char v8 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Received new Operating Mode Notification", (uint8_t *)&__p, 2u);
      }
      xpc_object_t v83 = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kMessageArgs";
      sub_10000CB28((uint64_t)&__p, &v83);
      xpc_object_t v9 = (char *)operator new(0x58uLL);
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = 0;
      *(void *)xpc_object_t v9 = off_101A097F0;
      *((void *)v9 + 3) = -1;
      *((void *)v9 + 10) = 0xFFFFFFFFLL;
      *((_OWORD *)v9 + 2) = 0u;
      xpc_object_t v10 = (void **)(v9 + 32);
      *((_OWORD *)v9 + 3) = 0u;
      *((_OWORD *)v9 + 4) = 0u;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"WRMCommCenterOperatingModeNotifcation_EnableTelephony";
      sub_100048BAC((uint64_t)&__p, &buf);
      *((_DWORD *)v9 + 6) = xpc::dyn_cast_or_default((xpc *)&buf, (const object *)0xFFFFFFFFLL, v11);
      xpc_release(buf.__r_.__value_.__l.__data_);
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
      buf.__r_.__value_.__l.__size_ = (std::string::size_type)"WRMCommCenterOperatingModeNotifcation_EnableTelephony_Reason";
      sub_100048BAC((uint64_t)&buf, object);
      xpc::dyn_cast_or_default((uint64_t *)&__p, (xpc *)object, (const object *)"unknown", v12);
      if (v9[55] < 0) {
        operator delete(*v10);
      }
      *(_OWORD *)xpc_object_t v10 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((void *)v9 + 6) = *((void *)&__p.__r_.__value_.__l + 2);
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      __p.__r_.__value_.__s.__data_[0] = 0;
      xpc_release(object[0]);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"WRMCommCenterOperatingModeNotifcation_SetBBState";
      sub_100048BAC((uint64_t)&__p, &buf);
      *((_DWORD *)v9 + 7) = xpc::dyn_cast_or_default((xpc *)&buf, (const object *)0xFFFFFFFFFFFFFFFFLL, v13);
      xpc_release(buf.__r_.__value_.__l.__data_);
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
      buf.__r_.__value_.__l.__size_ = (std::string::size_type)"WRMCommCenterOperatingModeNotifcation_SetBBState_Reason";
      sub_100048BAC((uint64_t)&buf, object);
      xpc::dyn_cast_or_default((uint64_t *)&__p, (xpc *)object, (const object *)"unknown", v14);
      xpc_object_t v15 = (void **)(v9 + 56);
      if (v9[79] < 0) {
        operator delete(*v15);
      }
      *(_OWORD *)xpc_object_t v15 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((void *)v9 + 9) = *((void *)&__p.__r_.__value_.__l + 2);
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      __p.__r_.__value_.__s.__data_[0] = 0;
      xpc_release(object[0]);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"WRMCommCenterOperatingModeNotifcation_WiFiCallAllowed";
      sub_100048BAC((uint64_t)&__p, &buf);
      *((_DWORD *)v9 + 20) = xpc::dyn_cast_or_default((xpc *)&buf, (const object *)0xFFFFFFFFLL, v16);
      xpc_release(buf.__r_.__value_.__l.__data_);
      uint64_t v17 = *(void *)(a1 + 80);
      uint64_t v18 = *(unsigned int *)(a1 + 88);
      uint64_t v74 = v9 + 24;
      uint64_t v75 = (std::__shared_weak_count *)v9;
      atomic_fetch_add_explicit((atomic_ullong *volatile)v9 + 1, 1uLL, memory_order_relaxed);
      (*(void (**)(uint64_t, uint64_t, char **))(*(void *)v17 + 40))(v17, v18, &v74);
      if (v75) {
        sub_10004D2C8(v75);
      }
      sub_10004D2C8((std::__shared_weak_count *)v9);
      xpc_release(v83);
    }
    return;
  }
  if (v7 != 1350)
  {
    if (v7 != 2500) {
      return;
    }
    memset(&buf, 0, sizeof(buf));
    object[0] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kMessageArgs";
    sub_10000CB28((uint64_t)&__p, object);
    xpc_object_t v83 = object;
    uint64_t v84 = "kWRMVoIPBundleId";
    sub_100048BAC((uint64_t)&v83, v79);
    xpc::dyn_cast_or_default((uint64_t *)&__p, (xpc *)v79, (const object *)"", v19);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    std::string buf = __p;
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    xpc_release(v79[0]);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)object;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMVoIPCallActiveFlag";
    sub_100048BAC((uint64_t)&__p, &v83);
    uint64_t v21 = xpc::dyn_cast_or_default((xpc *)&v83, 0, v20);
    xpc_release(v83);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)object;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMVoIPCallStartingFlag";
    sub_100048BAC((uint64_t)&__p, &v83);
    uint64_t v23 = xpc::dyn_cast_or_default((xpc *)&v83, 0, v22);
    xpc_release(v83);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)object;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMVoIPCallEndedFlag";
    sub_100048BAC((uint64_t)&__p, &v83);
    uint64_t v25 = xpc::dyn_cast_or_default((xpc *)&v83, 0, v24);
    xpc_release(v83);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)object;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMVoIPCallVideoFlag";
    sub_100048BAC((uint64_t)&__p, &v83);
    uint64_t v27 = xpc::dyn_cast_or_default((xpc *)&v83, 0, v26);
    xpc_release(v83);
    xpc_release(object[0]);
    uint64_t v28 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      std::string::size_type v30 = asStringBool(v23);
      uint64_t v31 = asStringBool(v21);
      uint64_t v32 = asStringBool(v25);
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v30;
      HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
      uint64_t v88 = v31;
      __int16 v89 = 2080;
      uint64_t v90 = v32;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Received new WCMVoIPCallInfo Notification: %s[starting=%s active=%s ended=%s]", (uint8_t *)&__p, 0x2Au);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::size_type size = buf.__r_.__value_.__l.__size_;
      if (!buf.__r_.__value_.__l.__size_) {
        goto LABEL_93;
      }
    }
    else
    {
      std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
        return;
      }
    }
    if (size < 0xB) {
      goto LABEL_92;
    }
    memset(&__p, 0, sizeof(__p));
    std::string::basic_string(&__p, &buf, 0, 0xAuLL, (std::allocator<char> *)&v83);
    xpc_object_t v83 = 0;
    uint64_t v84 = 0;
    uint64_t v85 = 0;
    sub_100058DB0(&v83, "com.apple.");
    char v59 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v60 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v60 = __p.__r_.__value_.__l.__size_;
    }
    __int16 v61 = (const char *)HIBYTE(v85);
    int v62 = SHIBYTE(v85);
    if (v85 < 0) {
      __int16 v61 = v84;
    }
    if ((const char *)v60 == v61)
    {
      if (v85 >= 0) {
        uint64_t v63 = (unsigned __int8 *)&v83;
      }
      else {
        uint64_t v63 = (unsigned __int8 *)v83;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        BOOL v72 = memcmp(__p.__r_.__value_.__l.__data_, v63, __p.__r_.__value_.__l.__size_) == 0;
      }
      else if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
      {
        uint64_t v64 = HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1;
        p_p = &__p;
        do
        {
          int v67 = p_p->__r_.__value_.__s.__data_[0];
          p_p = (std::string *)((char *)p_p + 1);
          int v66 = v67;
          int v69 = *v63++;
          int v68 = v69;
          BOOL v71 = v64-- != 0;
          BOOL v72 = v66 == v68;
        }
        while (v66 == v68 && v71);
      }
      else
      {
        BOOL v72 = 1;
      }
    }
    else
    {
      BOOL v72 = 0;
    }
    if (v62 < 0)
    {
      operator delete(v83);
      if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
      {
LABEL_88:
        if (v72)
        {
LABEL_93:
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          return;
        }
LABEL_92:
        (*(void (**)(void, std::string *, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 32))(*(void *)(a1 + 80), &buf, v23, v21, v25, v27);
        goto LABEL_93;
      }
    }
    else if ((v59 & 0x80) == 0)
    {
      goto LABEL_88;
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v72) {
      goto LABEL_93;
    }
    goto LABEL_92;
  }
  buf.__r_.__value_.__r.__words[0] = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kMessageArgs";
  sub_10000CB28((uint64_t)&__p, &buf);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMiWLANMetricsReport_SlotId";
  sub_100048BAC((uint64_t)&__p, &v83);
  int v39 = xpc::dyn_cast_or_default((xpc *)&v83, 0, v38);
  xpc_release(v83);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMCbrsCurrentDataSlotQuality";
  sub_100048BAC((uint64_t)&__p, &v83);
  uint64_t v41 = xpc::dyn_cast_or_default((xpc *)&v83, 0, v40);
  xpc_release(v83);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)"kWRMAnyCallState";
  sub_100048BAC((uint64_t)&__p, &v83);
  uint64_t v43 = xpc::dyn_cast_or_default((xpc *)&v83, 0, v42);
  xpc_release(v83);
  if (v39 == 1) {
    uint64_t v44 = 1;
  }
  else {
    uint64_t v44 = 2 * (v39 == 2);
  }
  if (v41) {
    uint64_t v45 = 2 * (v41 == 1);
  }
  else {
    uint64_t v45 = 1;
  }
  if (v43 == 1) {
    uint64_t v46 = 1;
  }
  else {
    uint64_t v46 = 2 * (v43 == 2);
  }
  xpc_object_t v47 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v48 = subscriber::asString();
    uint64_t v49 = rest::asString();
    uint64_t v50 = rest::asString();
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v48;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v49;
    HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
    uint64_t v88 = v50;
    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Received new Sub Preference Notification subId: %s, currentDataSlotQuality: %s, anyCallState: %s", (uint8_t *)&__p, 0x20u);
  }
  (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 48))(*(void *)(a1 + 80), v44, v45, v46);
  xpc_release(buf.__r_.__value_.__l.__data_);
}

void sub_1007BE1C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16, xpc_object_t a17, uint64_t a18, xpc_object_t a19, uint64_t a20,xpc_object_t object,xpc_object_t a22,xpc_object_t a23,uint64_t a24,uint64_t a25,xpc_object_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v32 - 105) < 0) {
    operator delete(*(void **)(v32 - 128));
  }
  _Unwind_Resume(exception_object);
}

void sub_1007BE534(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_1007BE648;
  uint64_t v4[3] = &unk_101A09650;
  unsigned char v4[4] = a1;
  char v5 = a2;
  uint64_t v8 = 0;
  xpc_object_t v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1007BF350;
  block[3] = &unk_101A09740;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_1007BE648(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int64_t v2 = *(unsigned __int8 *)(a1 + 40);
  if (xpc_get_type(*(xpc_object_t *)(v1 + 40)) != (xpc_type_t)&_xpc_type_connection)
  {
    uint64_t v3 = *(NSObject **)(v1 + 72);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Invalid XPC connection. Failed to send NWD notification", buf, 2u);
    }
    return;
  }
  xpc_object_t v19 = 0;
  sub_1006941A8(buf);
  sub_1007BF3A0((void **)&object.__r_.__value_.__l.__data_, (void **)buf, (uint64_t)"kMessageId", 0x1A0uLL);
  xpc_release(*(xpc_object_t *)buf);
  xpc_object_t v19 = (xpc_object_t)object.__r_.__value_.__r.__words[0];
  object.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
  xpc_release(object.__r_.__value_.__l.__data_);
  xpc_object_t v18 = 0;
  sub_1006941A8(&v20);
  xpc_object_t v4 = xpc_int64_create(v2);
  xpc_object_t v5 = v4;
  if (v4)
  {
    *(void *)uint64_t v21 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    *(void *)uint64_t v21 = v5;
    if (!v5)
    {
      xpc_object_t v5 = 0;
      *(void *)uint64_t v21 = xpc_null_create();
      goto LABEL_8;
    }
  }
  xpc_retain(v5);
LABEL_8:
  *(void *)std::string buf = &v20;
  uint64_t v13 = "kTunnelDisconnected";
  sub_100035E70((uint64_t)buf, (xpc_object_t *)v21, (xpc_object_t *)&object.__r_.__value_.__l.__data_);
  xpc_release(object.__r_.__value_.__l.__data_);
  object.__r_.__value_.__r.__words[0] = 0;
  xpc_release(*(xpc_object_t *)v21);
  *(void *)uint64_t v21 = 0;
  xpc_object_t v6 = v20;
  if (v20) {
    xpc_retain(v20);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  xpc_release(v5);
  xpc_release(v20);
  xpc_object_t v18 = v6;
  xpc_object_t v7 = xpc_null_create();
  xpc_release(v7);
  unsigned int v8 = subscriber::simSlotAsInstance();
  xpc_object_t v17 = xpc_uint64_create(v8);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  *(void *)std::string buf = &v18;
  uint64_t v13 = "kSlotID";
  sub_100035E70((uint64_t)buf, &v17, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_object_t v15 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v15 = xpc_null_create();
  }
  *(void *)std::string buf = &v19;
  uint64_t v13 = "kMessageArgs";
  sub_10014E03C((uint64_t)buf, &v15, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_connection_send_message(*(xpc_connection_t *)(v1 + 40), v19);
  xpc_object_t v9 = *(NSObject **)(v1 + 72);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    sub_100120074(&v19, &object);
    sub_1007BEDD0((uint64_t)buf, &object);
    if (v14 >= 0) {
      xpc_object_t v10 = buf;
    }
    else {
      xpc_object_t v10 = *(uint8_t **)buf;
    }
    *(_DWORD *)uint64_t v21 = 136315138;
    *(void *)&void v21[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I send NWD notification to iRat: <%s>", v21, 0xCu);
    if (v14 < 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(object.__r_.__value_.__l.__data_);
    }
  }
  xpc_release(v18);
  xpc_release(v19);
}

void sub_1007BE958(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1007BEA00(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_1007BEB0C;
  void v3[3] = &unk_101A09670;
  void v3[4] = a1;
  uint64_t v6 = 0;
  xpc_object_t v7 = 0;
  sub_10003E168(&v6, (void *)(a1 + 8));
  int64_t v2 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1007BF350;
  block[3] = &unk_101A09740;
  block[5] = v6;
  xpc_object_t v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1007BEB0C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (xpc_get_type(*(xpc_object_t *)(v1 + 40)) == (xpc_type_t)&_xpc_type_connection)
  {
    xpc_object_t message = 0;
    sub_1006941A8(buf);
    sub_1007BF3A0((void **)&__p.__r_.__value_.__l.__data_, (void **)buf, (uint64_t)"kMessageId", 0x1A4uLL);
    xpc_release(*(xpc_object_t *)buf);
    xpc_object_t message = (xpc_object_t)__p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
    xpc_release(__p.__r_.__value_.__l.__data_);
    uint64_t v3 = subscriber::simSlotAsInstance();
    sub_1006941A8(buf);
    sub_1007BF3A0((void **)&__p.__r_.__value_.__l.__data_, (void **)buf, (uint64_t)"kSlotID", v3);
    xpc_release(*(xpc_object_t *)buf);
    xpc_object_t v4 = (void *)__p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
    xpc_release(__p.__r_.__value_.__l.__data_);
    xpc_object_t v11 = v4;
    if (v4) {
      xpc_retain(v4);
    }
    else {
      xpc_object_t v11 = xpc_null_create();
    }
    *(void *)std::string buf = &message;
    xpc_object_t v9 = "kMessageArgs";
    sub_10014E03C((uint64_t)buf, &v11, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v11);
    xpc_object_t v11 = 0;
    xpc_connection_send_message(*(xpc_connection_t *)(v1 + 40), message);
    xpc_object_t v5 = *(NSObject **)(v1 + 72);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      sub_100120074(&message, &__p);
      sub_1007BEDD0((uint64_t)buf, &__p);
      if (v10 >= 0) {
        uint64_t v6 = buf;
      }
      else {
        uint64_t v6 = *(uint8_t **)buf;
      }
      *(_DWORD *)char v14 = 136315138;
      xpc_object_t v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I send TUNSTL notification to iRat: <%s>", v14, 0xCu);
      if (v10 < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    xpc_release(v4);
    xpc_release(message);
  }
  else
  {
    int64_t v2 = *(NSObject **)(v1 + 72);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Invalid XPC connection. Failed to send TUNSTL notification", buf, 2u);
    }
  }
}

void sub_1007BED48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,xpc_object_t object)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
  xpc_release(object);
  _Unwind_Resume(a1);
}

__n128 sub_1007BEDD0(uint64_t a1, std::string *this)
{
  char v4 = 0;
  uint64_t v5 = 0;
  __int16 v11 = 2573;
  do
  {
    char v6 = v4;
    std::string::value_type v7 = *((unsigned char *)&v11 + v5);
    std::string::size_type v8 = std::string::find(this, v7, 0);
    if (v8 != -1)
    {
      for (std::string::size_type i = v8; i != -1; std::string::size_type i = std::string::find(this, v7, 0))
        std::string::replace(this, i, 1uLL, " ", 1uLL);
    }
    char v4 = 1;
    uint64_t v5 = 1;
  }
  while ((v6 & 1) == 0);
  __n128 result = *(__n128 *)&this->__r_.__value_.__l.__data_;
  *(_OWORD *)a1 = *(_OWORD *)&this->__r_.__value_.__l.__data_;
  *(void *)(a1 + 16) = *((void *)&this->__r_.__value_.__l + 2);
  this->__r_.__value_.__l.__size_ = 0;
  this->__r_.__value_.__r.__words[2] = 0;
  this->__r_.__value_.__r.__words[0] = 0;
  return result;
}

void **sub_1007BEEA4(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  __n128 result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  std::string::value_type v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    void v18[4] = result;
    char v14 = (char *)sub_10006A794((uint64_t)result, v13);
    xpc_object_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    void v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)xpc_object_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    void v18[2] = v15 + 16;
    sub_1007BF040(a1, v18);
    xpc_object_t v9 = (void *)a1[1];
    __n128 result = sub_1006C59A4(v18);
  }
  else
  {
    void *v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    xpc_object_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1007BEFAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006C59A4((void **)va);
  _Unwind_Resume(a1);
}

ctu::XpcClient *sub_1007BEFC0(ctu::XpcClient *a1)
{
  ctu::XpcClient::~XpcClient(a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v2 + 72));
  return a1;
}

void sub_1007BEFF0(ctu::XpcClient *a1)
{
  ctu::XpcClient::~XpcClient(a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 72));

  operator delete();
}

uint64_t sub_1007BF040(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1007BF0B8((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1007BF0B8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v12[0] = a1;
  v12[1] = &v13;
  void v12[2] = &v14;
  void v12[3] = 1;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v14 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v14;
  }
  sub_1007BF148((uint64_t)v12);
  return v10;
}

uint64_t sub_1007BF148(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1006C5960(a1);
  }
  return a1;
}

void sub_1007BF180(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007BF24C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1007BF324);
  __cxa_rethrow();
}

void sub_1007BF274(_Unwind_Exception *a1)
{
}

void sub_1007BF28C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007BF2C4(uint64_t a1)
{
}

uint64_t sub_1007BF2E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1007BF324(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_1007BF350(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1007BF360(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007BF37C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void *sub_1007BF38C(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void sub_1007BF3A0(void **a1, void **a2, uint64_t a3, uint64_t value)
{
  xpc_object_t v7 = xpc_uint64_create(value);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v11 = v7;
LABEL_4:
    xpc_retain(v8);
    goto LABEL_5;
  }
  xpc_object_t v8 = xpc_null_create();
  xpc_object_t v11 = v8;
  if (v8) {
    goto LABEL_4;
  }
  xpc_object_t v8 = 0;
  xpc_object_t v11 = xpc_null_create();
LABEL_5:
  v10[0] = a2;
  v10[1] = a3;
  sub_100035E70((uint64_t)v10, &v11, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  long long v9 = *a2;
  *a1 = *a2;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    *a1 = xpc_null_create();
  }
  xpc_release(v8);
}

void sub_1007BF484(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(_xpc_connection_s **)(v2 + 40);
  if (v3) {
    xpc_retain(*(xpc_object_t *)(v2 + 40));
  }
  else {
    uint64_t v3 = (_xpc_connection_s *)xpc_null_create();
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_connection)
  {
    xpc_object_t v12 = 0;
    uint64_t v6 = subscriber::simSlotAsInstance();
    sub_1006941A8(&buf);
    sub_1007BF3A0(&object, (void **)&buf, (uint64_t)"kPlanSlotID", v6);
    xpc_release((xpc_object_t)buf);
    xpc_object_t v12 = object;
    xpc_object_t object = xpc_null_create();
    xpc_release(object);
    xpc_object_t v10 = xpc_uint64_create(*((unsigned __int8 *)v1 + 8));
    if (!v10) {
      xpc_object_t v10 = xpc_null_create();
    }
    *(void *)&long long buf = &v12;
    *((void *)&buf + 1) = "kisExpensive";
    sub_100035E70((uint64_t)&buf, &v10, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v10);
    xpc_object_t message = 0;
    xpc_object_t v10 = 0;
    sub_1006941A8(&buf);
    sub_1007BF3A0(&v8, (void **)&buf, (uint64_t)"kMessageId", 0x1A3uLL);
    xpc_release((xpc_object_t)buf);
    xpc_object_t message = v8;
    xpc_object_t v8 = xpc_null_create();
    xpc_release(v8);
    xpc_object_t v7 = v12;
    if (v12) {
      xpc_retain(v12);
    }
    else {
      xpc_object_t v7 = xpc_null_create();
    }
    *(void *)&long long buf = &message;
    *((void *)&buf + 1) = "kMessageArgs";
    sub_10014E03C((uint64_t)&buf, &v7, &v8);
    xpc_release(v8);
    xpc_object_t v8 = 0;
    xpc_release(v7);
    xpc_object_t v7 = 0;
    xpc_connection_send_message(v3, message);
    xpc_release(message);
    xpc_release(v12);
  }
  else
  {
    char v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      if (*((unsigned char *)v1 + 8)) {
        uint64_t v5 = "true";
      }
      else {
        uint64_t v5 = "false";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Invalid XPC connection. Failed to send interface expensive=%s to server", (uint8_t *)&buf, 0xCu);
    }
  }
  xpc_release(v3);
  operator delete();
}

void sub_1007BF6F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, xpc_object_t a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1007BF7A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A097A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007BF7C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A097A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007BF818(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  sub_10005CBF0(&v1);
}

void sub_1007BF848(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A097F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007BF868(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A097F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007BF8BC(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    operator delete(v2);
  }
}

void sub_1007BF918(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A09840;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007BF938(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A09840;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007BF98C(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void sub_1007BFB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(a1);
}

void sub_1007C0264(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007C02FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NetworkReachability;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1007C03D4(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v3 = [WeakRetained[24] path];
    unsigned int v4 = [v3 usesInterfaceType:1];

    uint64_t v5 = [v2[24] path];
    unsigned int v6 = [v5 usesInterfaceType:2];

    xpc_object_t v7 = [v2[24] path];
    unsigned int v8 = [v7 usesInterfaceType:3];

    long long v9 = (char *)(v2 + 5);
    if (v4)
    {
      int v10 = 1;
      *((unsigned char *)v2 + 40) = 1;
      xpc_object_t v11 = (capabilities::ct *)v2[4];
      if (v11) {
        xpc_object_t v11 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, char *))(*(void *)v11 + 48))(v11, v9);
      }
    }
    else if (v6)
    {
      *((unsigned char *)v2 + 40) = 2;
      xpc_object_t v11 = (capabilities::ct *)v2[4];
      if (v11) {
        xpc_object_t v11 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, char *))(*(void *)v11 + 48))(v11, v9);
      }
      int v10 = 1;
    }
    else
    {
      *((unsigned char *)v2 + 40) = 0;
      xpc_object_t v11 = (capabilities::ct *)v2[4];
      if (v11) {
        xpc_object_t v11 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, char *))(*(void *)v11 + 48))(v11, v9);
      }
      int v10 = 2;
    }
    if (capabilities::ct::getBasebandBootStrategy(v11) == 2)
    {
      xpc_object_t v12 = [v2[24] path];
      unsigned int v13 = [v12 usesInterfaceType:0];

      if (v13)
      {
        long long v14 = [v2[24] path];
        xpc_object_t v15 = [v14 interface];
        id v16 = [v15 subtype];

        if (v16 == (id)5001)
        {
          long long v17 = *(NSObject **)v2[27];
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            int v25 = 136315138;
            BOOL v26 = "true";
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I On Companion: %s", (uint8_t *)&v25, 0xCu);
          }
          int v10 = 1;
        }
      }
    }
    if (*((unsigned __int8 *)v2 + 80) != v10)
    {
      *((unsigned char *)v2 + 80) = v10;
      id v18 = v2[9];
      if (v18) {
        (*(void (**)(id, id *))(*(void *)v18 + 48))(v18, v2 + 10);
      }
    }
    if (*((unsigned __int8 *)v2 + 120) != v4)
    {
      *((unsigned char *)v2 + 120) = v4;
      id v19 = v2[14];
      if (v19) {
        (*(void (**)(id, id *))(*(void *)v19 + 48))(v19, v2 + 15);
      }
    }
    if (*((unsigned __int8 *)v2 + 160) != v8)
    {
      *((unsigned char *)v2 + 160) = v8;
      id v20 = v2[19];
      if (v20) {
        (*(void (**)(id, id *))(*(void *)v20 + 48))(v20, v2 + 20);
      }
    }
    uint64_t v21 = *(NSObject **)v2[27];
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v22 = "false";
      if (v4) {
        uint64_t v23 = "true";
      }
      else {
        uint64_t v23 = "false";
      }
      if (v6) {
        BOOL v24 = "true";
      }
      else {
        BOOL v24 = "false";
      }
      int v25 = 136315650;
      BOOL v26 = v23;
      __int16 v27 = 2080;
      uint64_t v28 = v24;
      if (v8) {
        BOOL v22 = "true";
      }
      __int16 v29 = 2080;
      std::string::size_type v30 = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I On WiFi: %s On Cellular: %s On Ethernet: %s", (uint8_t *)&v25, 0x20u);
    }
  }
}

void sub_1007C076C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1007C08B0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1007C0934(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1007C09B8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1007C0A3C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1007C0AC4()
{
}

void *sub_1007C0AD8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A098D8;
  result[1] = v3;
  return result;
}

uint64_t sub_1007C0B20(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A098D8;
  a2[1] = v2;
  return result;
}

void sub_1007C0B4C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = (ctu::rest::detail *)*a2;
  xpc_object_t v8 = 0;
  unint64_t v3 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/props/internet_reachability_interface");
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_1007C0C00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1007C0C44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007C0C84()
{
}

void sub_1007C0C94()
{
}

void *sub_1007C0CA8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A09968;
  result[1] = v3;
  return result;
}

uint64_t sub_1007C0CF0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A09968;
  a2[1] = v2;
  return result;
}

void sub_1007C0D1C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = (ctu::rest::detail *)*a2;
  xpc_object_t v8 = 0;
  unint64_t v3 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/props/internet_status");
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_1007C0DD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1007C0E14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007C0E54()
{
}

void sub_1007C0E64()
{
}

void *sub_1007C0E78(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A099F8;
  result[1] = v3;
  return result;
}

uint64_t sub_1007C0EC0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A099F8;
  a2[1] = v2;
  return result;
}

void sub_1007C0EEC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = (ctu::rest::detail *)*a2;
  xpc_object_t v8 = 0;
  unint64_t v3 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/props/wifi_status");
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_1007C0FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1007C0FE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007C1024()
{
}

void sub_1007C1034()
{
}

void *sub_1007C1048(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A09A88;
  result[1] = v3;
  return result;
}

uint64_t sub_1007C1090(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A09A88;
  a2[1] = v2;
  return result;
}

void sub_1007C10BC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = (ctu::rest::detail *)*a2;
  xpc_object_t v8 = 0;
  unint64_t v3 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/props/ethernet_status");
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_1007C1170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1007C11B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007C11F4()
{
}

uint64_t sub_1007C1200(uint64_t a1, void *a2, unsigned int a3, NSObject **a4, uint64_t a5)
{
  *(void *)a1 = off_101AA4E10;
  if (a3 > 9) {
    int v10 = "DATA.Collocation:N:";
  }
  else {
    int v10 = off_101A09E10[a3];
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v14, kCtLoggingSystemName, v10);
  sub_1007C134C((void *)(a1 + 8), a4, &v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v14);
  *(void *)a1 = off_101A09B18;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 72) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 80) = a3;
  *(void *)(a1 + 88) = a5;
  if (a3 > 9) {
    xpc_object_t v12 = "DATA.Collocation:N:";
  }
  else {
    xpc_object_t v12 = off_101A09E10[a3];
  }
  *(void *)(a1 + 96) = v12;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 130) = 0u;
  return a1;
}

void sub_1007C1338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1007C134C(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_1007C13B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1007C13D8(uint64_t a1)
{
  *(void *)a1 = off_101A09B18;
  uint64_t v2 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unsigned int v6 = (void **)(a1 + 152);
  sub_100047F64(&v6);
  uint64_t v3 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_1007C14B8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    unsigned int v6 = "init";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: init", (uint8_t *)&v5, 0xCu);
  }
  uint64_t result = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  uint64_t v4 = 120000;
  if (!*(_DWORD *)(a1 + 80)) {
    uint64_t v4 = 300000;
  }
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = v4;
  return result;
}

void sub_1007C15B0(uint64_t a1, char a2)
{
  uint64_t v6 = 0;
  char v7 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 88) + 112))(&v6);
  if (v6)
  {
    if (a2)
    {
      (*(void (**)(void))(**(void **)(a1 + 88) + 160))(*(void *)(a1 + 88));
      uint64_t v4 = isNetworkServicePrimaryRankDefault();
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 136))(v6, v4);
    }
    else
    {
      (*(void (**)(void))(*(void *)v6 + 136))();
    }
  }
  else
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      long long v9 = "checkRank";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: PDPManager is not initialized. Can not proceed with interface ranking", buf, 0xCu);
    }
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1007C1728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007C1750()
{
}

void sub_1007C1EBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,char a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (v38)
  {
    sub_10004D2C8(v38);
    sub_10004D2C8(v38);
  }
  *(void *)(v39 - 176) = &a24;
  sub_10005CBF0((void ***)(v39 - 176));
  if (a23) {
    sub_10004D2C8(a23);
  }
  _Unwind_Resume(a1);
}

void sub_1007C1FA8()
{
}

void sub_1007C202C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007C2044()
{
}

void sub_1007C20CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5)
{
  uint64_t v5 = a4;
  uint64_t v6 = a5;
  if (a5) {
    atomic_fetch_add_explicit(&a5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 24))(a2, a3, &v5);
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_1007C2148(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007C2160(uint64_t a1, const char *a2, uint64_t a3, const char *a4, uint64_t a5, int a6, int a7, const char *a8, int64_t value, int64_t a10, unsigned int a11, BOOL a12, int64_t a13, uint64_t a14, uint64_t a15)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  BOOL v22 = ServiceMap;
  if (v23 < 0)
  {
    BOOL v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v25 = 5381;
    do
    {
      uint64_t v23 = v25;
      unsigned int v26 = *v24++;
      uint64_t v25 = (33 * v25) ^ v26;
    }
    while (v26);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long string = v23;
  __int16 v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)&string);
  if (!v27)
  {
    uint64_t v31 = 0;
    goto LABEL_10;
  }
  uint64_t v29 = v27[3];
  uint64_t v28 = (std::__shared_weak_count *)v27[4];
  if (!v28)
  {
    uint64_t v31 = v27[3];
LABEL_10:
    std::mutex::unlock(v22);
    xpc_object_t v78 = 0;
    char v30 = 1;
    if (!v31) {
      goto LABEL_181;
    }
LABEL_11:
    char v77 = v30;
    xpc_object_t v146 = 0;
    xpc_object_t v32 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v33 = v32;
    if (v32)
    {
      xpc_object_t v146 = v32;
    }
    else
    {
      xpc_object_t v33 = xpc_null_create();
      xpc_object_t v146 = v33;
      if (!v33)
      {
        xpc_object_t v34 = xpc_null_create();
        xpc_object_t v33 = 0;
        goto LABEL_18;
      }
    }
    if (xpc_get_type(v33) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v33);
      goto LABEL_19;
    }
    xpc_object_t v34 = xpc_null_create();
LABEL_18:
    xpc_object_t v146 = v34;
LABEL_19:
    xpc_release(v33);
    if (a2[23] < 0) {
      a2 = *(const char **)a2;
    }
    xpc_object_t v144 = xpc_string_create(a2);
    if (!v144) {
      xpc_object_t v144 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "activateReason";
    sub_100035E70((uint64_t)&string, &v144, &v145);
    xpc_release(v145);
    xpc_object_t v145 = 0;
    xpc_release(v144);
    xpc_object_t v144 = 0;
    xpc_object_t object = xpc_uint64_create(a3);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "activatingTime";
    sub_100035E70((uint64_t)&string, &object, &v143);
    xpc_release(v143);
    xpc_object_t v143 = 0;
    xpc_release(object);
    xpc_object_t object = 0;
    uint64_t v35 = a4;
    if (a4[23] < 0) {
      uint64_t v35 = *(const char **)a4;
    }
    xpc_object_t v140 = xpc_string_create(v35);
    if (!v140) {
      xpc_object_t v140 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "apn";
    sub_100035E70((uint64_t)&string, &v140, &v141);
    xpc_release(v141);
    xpc_object_t v141 = 0;
    xpc_release(v140);
    xpc_object_t v140 = 0;
    xpc_object_t v138 = xpc_uint64_create(a5);
    if (!v138) {
      xpc_object_t v138 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "connectionMasks";
    sub_100035E70((uint64_t)&string, &v138, &v139);
    xpc_release(v139);
    xpc_object_t v139 = 0;
    xpc_release(v138);
    xpc_object_t v138 = 0;
    xpc_object_t v136 = xpc_int64_create(a6);
    if (!v136) {
      xpc_object_t v136 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "contextId";
    sub_100035E70((uint64_t)&string, &v136, &v137);
    xpc_release(v137);
    xpc_object_t v137 = 0;
    xpc_release(v136);
    xpc_object_t v136 = 0;
    xpc_object_t v134 = xpc_int64_create(a7);
    if (!v134) {
      xpc_object_t v134 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "contextType";
    sub_100035E70((uint64_t)&string, &v134, &v135);
    xpc_release(v135);
    xpc_object_t v135 = 0;
    xpc_release(v134);
    xpc_object_t v134 = 0;
    if (a8[23] < 0) {
      a8 = *(const char **)a8;
    }
    xpc_object_t v132 = xpc_string_create(a8);
    if (!v132) {
      xpc_object_t v132 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "csiError";
    sub_100035E70((uint64_t)&string, &v132, &v133);
    xpc_release(v133);
    xpc_object_t v133 = 0;
    xpc_release(v132);
    xpc_object_t v132 = 0;
    xpc_object_t v130 = xpc_int64_create(value);
    if (!v130) {
      xpc_object_t v130 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "ipFamily";
    sub_100035E70((uint64_t)&string, &v130, &v131);
    xpc_release(v131);
    xpc_object_t v131 = 0;
    xpc_release(v130);
    xpc_object_t v130 = 0;
    xpc_object_t v128 = xpc_int64_create(HIDWORD(value));
    if (!v128) {
      xpc_object_t v128 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "rat";
    sub_100035E70((uint64_t)&string, &v128, &v129);
    xpc_release(v129);
    xpc_object_t v129 = 0;
    xpc_release(v128);
    xpc_object_t v128 = 0;
    xpc_object_t v126 = xpc_int64_create(a10);
    if (!v126) {
      xpc_object_t v126 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "requestedIpFamily";
    sub_100035E70((uint64_t)&string, &v126, &v127);
    xpc_release(v127);
    xpc_object_t v127 = 0;
    xpc_release(v126);
    xpc_object_t v126 = 0;
    xpc_object_t v124 = xpc_int64_create(SHIDWORD(a10));
    if (!v124) {
      xpc_object_t v124 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "result";
    sub_100035E70((uint64_t)&string, &v124, &v125);
    xpc_release(v125);
    xpc_object_t v125 = 0;
    xpc_release(v124);
    xpc_object_t v124 = 0;
    unsigned int v36 = subscriber::simSlotAsInstance();
    xpc_object_t v122 = xpc_int64_create(v36);
    if (!v122) {
      xpc_object_t v122 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "subs_id";
    sub_100035E70((uint64_t)&string, &v122, &v123);
    xpc_release(v123);
    xpc_object_t v123 = 0;
    xpc_release(v122);
    xpc_object_t v122 = 0;
    xpc_object_t v120 = xpc_BOOL_create(a12);
    if (!v120) {
      xpc_object_t v120 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "success";
    sub_100035E70((uint64_t)&string, &v120, &v121);
    xpc_release(v121);
    xpc_object_t v121 = 0;
    xpc_release(v120);
    xpc_object_t v120 = 0;
    xpc_object_t v118 = xpc_int64_create(a13);
    if (!v118) {
      xpc_object_t v118 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "transportType";
    sub_100035E70((uint64_t)&string, &v118, &v119);
    xpc_release(v119);
    xpc_object_t v119 = 0;
    xpc_release(v118);
    xpc_object_t v37 = (const char *)a14;
    xpc_object_t v118 = 0;
    if (*(char *)(a14 + 23) < 0) {
      xpc_object_t v37 = *(const char **)a14;
    }
    xpc_object_t v116 = xpc_string_create(v37);
    if (!v116) {
      xpc_object_t v116 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "wdsReason";
    sub_100035E70((uint64_t)&string, &v116, &v117);
    xpc_release(v117);
    xpc_object_t v117 = 0;
    xpc_release(v116);
    int v38 = (const char *)a15;
    xpc_object_t v116 = 0;
    if (*(char *)(a15 + 23) < 0) {
      int v38 = *(const char **)a15;
    }
    xpc_object_t v114 = xpc_string_create(v38);
    if (!v114) {
      xpc_object_t v114 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "wdsReasonType";
    sub_100035E70((uint64_t)&string, &v114, &v115);
    xpc_release(v115);
    xpc_object_t v115 = 0;
    xpc_release(v114);
    xpc_object_t v114 = 0;
    int v39 = isSliceMask(a5);
    xpc_object_t v112 = xpc_BOOL_create(v39);
    if (!v112) {
      xpc_object_t v112 = xpc_null_create();
    }
    *(void *)&long long string = &v146;
    *((void *)&string + 1) = "nwslice";
    sub_100035E70((uint64_t)&string, &v112, &v113);
    xpc_release(v113);
    xpc_object_t v113 = 0;
    xpc_release(v112);
    xpc_object_t v112 = 0;
    if (!v39) {
      goto LABEL_176;
    }
    uint64_t v76 = v31;
    int v40 = a7;
    long long v110 = 0u;
    long long v111 = 0u;
    long long v108 = 0u;
    long long v109 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    long long string = 0u;
    long long v103 = 0u;
    uint64_t v41 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    unint64_t v42 = v41;
    if (v43 < 0)
    {
      uint64_t v44 = (unsigned __int8 *)(v43 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v45 = 5381;
      do
      {
        uint64_t v43 = v45;
        unsigned int v46 = *v44++;
        uint64_t v45 = (33 * v45) ^ v46;
      }
      while (v46);
    }
    std::mutex::lock(v41);
    *(void *)long long buf = v43;
    xpc_object_t v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)buf);
    int v48 = v40;
    if (v47)
    {
      uint64_t v49 = v47[3];
      uint64_t v50 = (std::__shared_weak_count *)v47[4];
      if (v50)
      {
        atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v42);
        atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
        int v48 = v40;
        sub_10004D2C8(v50);
        char v51 = 0;
        if (!v49) {
          goto LABEL_78;
        }
        goto LABEL_73;
      }
    }
    else
    {
      uint64_t v49 = 0;
    }
    std::mutex::unlock(v42);
    uint64_t v50 = 0;
    char v51 = 1;
    if (!v49) {
      goto LABEL_78;
    }
LABEL_73:
    uint64_t v52 = (*(uint64_t (**)(uint64_t))(*(void *)v49 + 872))(v49);
    if (v52)
    {
      uint64_t v53 = 28;
      do
      {
        if ((ConnectionTypeToMask() & a5) != 0)
        {
          uint64_t v54 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v52 + 80))(v52, a11, v53);
          (*(void (**)(uint64_t, void, uint64_t, long long *))(*(void *)v52 + 136))(v52, a11, v54, &string);
        }
        uint64_t v53 = (v53 + 1);
      }
      while (v53 != 36);
    }
LABEL_78:
    if (SBYTE7(v103) < 0)
    {
      if (*((void *)&string + 1))
      {
        int v55 = (const char *)string;
LABEL_83:
        xpc_object_t v100 = xpc_string_create(v55);
        if (!v100) {
          xpc_object_t v100 = xpc_null_create();
        }
        *(void *)long long buf = &v146;
        *(void *)&uint8_t buf[8] = "bundleid";
        sub_100035E70((uint64_t)buf, &v100, &v101);
        xpc_release(v101);
        xpc_object_t v101 = 0;
        xpc_release(v100);
        xpc_object_t v100 = 0;
        if (DWORD2(v103))
        {
          xpc_object_t v98 = xpc_int64_create(DWORD2(v103));
          if (!v98) {
            xpc_object_t v98 = xpc_null_create();
          }
          *(void *)long long buf = &v146;
          *(void *)&uint8_t buf[8] = "trafficClass";
          sub_100035E70((uint64_t)buf, &v98, &v99);
          xpc_release(v99);
          xpc_object_t v99 = 0;
          xpc_release(v98);
          xpc_object_t v98 = 0;
        }
        if (SBYTE7(v105) < 0)
        {
          if (!*((void *)&v104 + 1)) {
            goto LABEL_100;
          }
          int v56 = (const char *)v104;
        }
        else
        {
          int v56 = (const char *)&v104;
          if (!BYTE7(v105)) {
            goto LABEL_100;
          }
        }
        xpc_object_t v96 = xpc_string_create(v56);
        if (!v96) {
          xpc_object_t v96 = xpc_null_create();
        }
        *(void *)long long buf = &v146;
        *(void *)&uint8_t buf[8] = "dnn";
        sub_100035E70((uint64_t)buf, &v96, &v97);
        xpc_release(v97);
        xpc_object_t v97 = 0;
        xpc_release(v96);
        xpc_object_t v96 = 0;
LABEL_100:
        if (SHIBYTE(v106) < 0)
        {
          if (!(void)v106) {
            goto LABEL_108;
          }
          char v59 = (const char *)*((void *)&v105 + 1);
        }
        else
        {
          char v59 = (char *)&v105 + 8;
          if (!HIBYTE(v106)) {
            goto LABEL_108;
          }
        }
        xpc_object_t v94 = xpc_string_create(v59);
        if (!v94) {
          xpc_object_t v94 = xpc_null_create();
        }
        *(void *)long long buf = &v146;
        *(void *)&uint8_t buf[8] = "genres";
        sub_100035E70((uint64_t)buf, &v94, &v95);
        xpc_release(v95);
        xpc_object_t v95 = 0;
        xpc_release(v94);
        xpc_object_t v94 = 0;
LABEL_108:
        if (SBYTE7(v108) < 0)
        {
          if (!*((void *)&v107 + 1)) {
            goto LABEL_116;
          }
          std::string::size_type v60 = (const char *)v107;
        }
        else
        {
          std::string::size_type v60 = (const char *)&v107;
          if (!BYTE7(v108)) {
            goto LABEL_116;
          }
        }
        xpc_object_t v92 = xpc_string_create(v60);
        if (!v92) {
          xpc_object_t v92 = xpc_null_create();
        }
        *(void *)long long buf = &v146;
        *(void *)&uint8_t buf[8] = "sliceTrafficInfo";
        sub_100035E70((uint64_t)buf, &v92, &v93);
        xpc_release(v93);
        xpc_object_t v93 = 0;
        xpc_release(v92);
        xpc_object_t v92 = 0;
LABEL_116:
        xpc_object_t v90 = xpc_BOOL_create(SBYTE8(v108));
        if (!v90) {
          xpc_object_t v90 = xpc_null_create();
        }
        *(void *)long long buf = &v146;
        *(void *)&uint8_t buf[8] = "is_vpn_active";
        sub_100035E70((uint64_t)buf, &v90, &v91);
        xpc_release(v91);
        xpc_object_t v91 = 0;
        xpc_release(v90);
        xpc_object_t v90 = 0;
        xpc_object_t v88 = xpc_BOOL_create(SBYTE9(v108));
        if (!v88) {
          xpc_object_t v88 = xpc_null_create();
        }
        *(void *)long long buf = &v146;
        *(void *)&uint8_t buf[8] = "is_app_using_ids";
        sub_100035E70((uint64_t)buf, &v88, &v89);
        xpc_release(v89);
        xpc_object_t v89 = 0;
        xpc_release(v88);
        xpc_object_t v88 = 0;
        if (SBYTE7(v110) < 0)
        {
          if (!*((void *)&v109 + 1)) {
            goto LABEL_128;
          }
          __int16 v61 = (const char *)v109;
        }
        else
        {
          __int16 v61 = (const char *)&v109;
          if (!BYTE7(v110)) {
            goto LABEL_128;
          }
        }
        xpc_object_t v86 = xpc_string_create(v61);
        if (!v86) {
          xpc_object_t v86 = xpc_null_create();
        }
        *(void *)long long buf = &v146;
        *(void *)&uint8_t buf[8] = "slicing_type";
        sub_100035E70((uint64_t)buf, &v86, &v87);
        xpc_release(v87);
        xpc_object_t v87 = 0;
        xpc_release(v86);
        xpc_object_t v86 = 0;
LABEL_128:
        if (SHIBYTE(v111) < 0)
        {
          if (!(void)v111)
          {
LABEL_136:
            if (!v48)
            {
              v83[11] = 0;
              v83[12] = 0;
              sub_1007C1FA8();
            }
            uint64_t v63 = (uint64_t *)a4;
            uint64_t v64 = *(NSObject **)(a1 + 40);
            BOOL v65 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
            char v58 = 0;
            if (v65)
            {
              char v80 = v51;
              xpc_object_t v82 = v50;
              uint64_t v75 = asStringBool(1);
              if ((SBYTE7(v103) & 0x80u) == 0) {
                p_long long string = &string;
              }
              else {
                p_long long string = (long long *)string;
              }
              if ((SBYTE7(v105) & 0x80u) == 0) {
                int v67 = &v104;
              }
              else {
                int v67 = (long long *)v104;
              }
              if (*((char *)v63 + 23) < 0) {
                uint64_t v63 = (uint64_t *)*v63;
              }
              int v68 = DWORD2(v103);
              if (v106 >= 0) {
                int v69 = (char *)&v105 + 8;
              }
              else {
                int v69 = (char *)*((void *)&v105 + 1);
              }
              if ((SBYTE7(v108) & 0x80u) == 0) {
                uint64_t v70 = &v107;
              }
              else {
                uint64_t v70 = (long long *)v107;
              }
              uint64_t v71 = asStringBool(SBYTE8(v108));
              uint64_t v72 = asStringBool(SBYTE9(v108));
              if ((SBYTE7(v110) & 0x80u) == 0) {
                uint64_t v73 = &v109;
              }
              else {
                uint64_t v73 = (long long *)v109;
              }
              uint64_t v74 = (char *)&v110 + 8;
              if (v111 < 0) {
                uint64_t v74 = (char *)*((void *)&v110 + 1);
              }
              *(_DWORD *)long long buf = 136318210;
              *(void *)&uint8_t buf[4] = v75;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = p_string;
              __int16 v148 = 1024;
              int v149 = v68;
              __int16 v150 = 2080;
              uint64_t v151 = v67;
              __int16 v152 = 2080;
              uint64_t v153 = v63;
              __int16 v154 = 2080;
              uint64_t v155 = v69;
              __int16 v156 = 2080;
              uint64_t v157 = v70;
              __int16 v158 = 2080;
              uint64_t v159 = v71;
              __int16 v160 = 2080;
              uint64_t v161 = v72;
              __int16 v162 = 2080;
              uint64_t v163 = v73;
              __int16 v164 = 2080;
              long long v165 = v74;
              __int16 v166 = 1024;
              int v167 = 255;
              __int16 v168 = 1024;
              int v169 = 0xFFFFFF;
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I submitCoreAnalyticsCCPDPContextActEndMetric for 5G Slice: nwslice=%s bundleid=%s tc=%u dnn=%s apn=%s genres=%s sliceTrafficInfo=%s isVpnActive=%s isAppUsingIds=%s slicingType=%s managedSliceType=%s snssai_sst=%u snssai_sd=%u", buf, 0x78u);
              char v58 = 0;
              uint64_t v50 = v82;
              char v51 = v80;
            }
            goto LABEL_160;
          }
          int v62 = (const char *)*((void *)&v110 + 1);
        }
        else
        {
          int v62 = (char *)&v110 + 8;
          if (!HIBYTE(v111)) {
            goto LABEL_136;
          }
        }
        xpc_object_t v84 = xpc_string_create(v62);
        if (!v84) {
          xpc_object_t v84 = xpc_null_create();
        }
        *(void *)long long buf = &v146;
        *(void *)&uint8_t buf[8] = "managed_slice_type";
        sub_100035E70((uint64_t)buf, &v84, &v85);
        xpc_release(v85);
        xpc_object_t v85 = 0;
        xpc_release(v84);
        xpc_object_t v84 = 0;
        goto LABEL_136;
      }
    }
    else if (BYTE7(v103))
    {
      int v55 = (const char *)&string;
      goto LABEL_83;
    }
    uint64_t v57 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I submitCoreAnalyticsCCPDPContextActEndMetric for 5G Slice: cancel metrics for pending slice activation", buf, 2u);
    }
    char v58 = 1;
LABEL_160:
    if ((v51 & 1) == 0) {
      sub_10004D2C8(v50);
    }
    if (SHIBYTE(v111) < 0) {
      operator delete(*((void **)&v110 + 1));
    }
    uint64_t v31 = v76;
    if (SBYTE7(v110) < 0) {
      operator delete((void *)v109);
    }
    if (SBYTE7(v108) < 0) {
      operator delete((void *)v107);
    }
    if (SHIBYTE(v106) < 0) {
      operator delete(*((void **)&v105 + 1));
    }
    if (SBYTE7(v105) < 0) {
      operator delete((void *)v104);
    }
    if (SBYTE7(v103) < 0)
    {
      operator delete((void *)string);
      if (v58) {
        goto LABEL_174;
      }
    }
    else if (v58)
    {
LABEL_174:
      xpc_release(v146);
LABEL_180:
      char v30 = v77;
      goto LABEL_181;
    }
LABEL_176:
    v83[0] = v146;
    if (v146) {
      xpc_retain(v146);
    }
    else {
      v83[0] = xpc_null_create();
    }
    (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v31 + 16))(v31, "metricCCPDPContextActEnd", v83);
    xpc_release(v83[0]);
    v83[0] = 0;
    xpc_release(v146);
    goto LABEL_180;
  }
  atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v22);
  atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  xpc_object_t v78 = v28;
  sub_10004D2C8(v28);
  char v30 = 0;
  uint64_t v31 = v29;
  if (v29) {
    goto LABEL_11;
  }
LABEL_181:
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v78);
  }
}

void sub_1007C334C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, int a17, uint64_t a18, int a19, uint64_t a20,xpc_object_t object,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1007C3614(uint64_t a1)
{
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1007C3698()
{
}

void sub_1007C588C(_Unwind_Exception *a1)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 - 216);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

void sub_1007C5DC0(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 145);
  if (v2 != a2)
  {
    BOOL v3 = a2;
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315650;
      char v7 = "setAssertionGone";
      __int16 v8 = 2080;
      uint64_t v9 = asStringBool(v2 != 0);
      __int16 v10 = 2080;
      uint64_t v11 = asStringBool(v3);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: from %s to %s", (uint8_t *)&v6, 0x20u);
    }
    *(unsigned char *)(a1 + 145) = v3;
  }
}

uint64_t sub_1007C5EAC(uint64_t a1, int a2)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 88) + 168))(&v7);
  uint64_t v4 = v7;
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (!v4) {
    return 0;
  }
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 88) + 168))(&v7);
  int v5 = *(_DWORD *)(v7 + 52);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v5 == a2) {
    return (*(uint64_t (**)(void, uint64_t, void, void))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88), 2, 0, 0);
  }
  else {
    return 0;
  }
}

uint64_t *sub_1007C5F9C(NSObject *a1, int a2, int a3, __darwin_time_t a4, int a5, int a6, int a7, int a8, char a9, std::string *__str, std::string *a11, int a12, int a13, uint64_t a14, int a15)
{
  if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a4 + 23) >= 0) {
      __darwin_time_t v17 = a4;
    }
    else {
      __darwin_time_t v17 = *(void *)a4;
    }
    LODWORD(v19.tv_sec) = 136315138;
    *(__darwin_time_t *)((char *)&v19.tv_sec + 4) = v17;
    _os_log_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_DEFAULT, "#I Reason: %s", (uint8_t *)&v19, 0xCu);
  }
  v19.tv_sec = 0;
  *(void *)&v19.tv_usec = 0;
  gettimeofday(&v19, 0);
  v19.tv_sec = 0;
  *(void *)&v19.tv_usec = 524441;
  if (sub_10017B48C()) {
    operator new();
  }
  return sub_1007CC180(&v19.tv_sec);
}

void sub_1007C6274()
{
}

uint64_t sub_1007C62E0(uint64_t a1, char a2, int a3)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 88) + 48))(*(void *)(a1 + 88)))
  {
    sub_1007C5DC0(a1, 0);
    sub_1007C8624(a1, 1);
    uint64_t v5 = *(void *)(a1 + 104);
    if (v5)
    {
      int v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "assertionUpdate";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: removing inactivity timeout due to assertion", buf, 0xCu);
        uint64_t v5 = *(void *)(a1 + 104);
        *(void *)(a1 + 104) = 0;
        if (!v5) {
          return 0;
        }
      }
      else
      {
        *(void *)(a1 + 104) = 0;
      }
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    return 0;
  }
  int v7 = *(unsigned __int8 *)(a1 + 144);
  sub_1007C8624(a1, 0);
  uint64_t v8 = *(void *)(a1 + 88);
  if (!v8) {
    return 0;
  }
  memset(buf, 0, sizeof(buf));
  (*(void (**)(uint8_t *__return_ptr))(*(void *)v8 + 16))(buf);
  __int16 v10 = *(uint64_t **)buf;
  uint64_t v9 = *(uint64_t **)&buf[8];
  if (*(void *)buf == *(void *)&buf[8])
  {
    xpc_object_t v47 = buf;
    sub_10005CBF0((void ***)&v47);
    return 0;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  do
  {
    uint64_t v14 = *v10;
    unsigned int v13 = (std::__shared_weak_count *)v10[1];
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v14 + 136))(v14, 3))
    {
      if (v7) {
        sub_1007C5DC0(a1, 1);
      }
      uint64_t v11 = (v11 + 1);
      if ((a2 & 1) != 0
        || *(unsigned char *)(a1 + 145) && a3 && (*(unsigned int (**)(uint64_t))(*(void *)v14 + 160))(v14))
      {
        (*(void (**)(uint8_t **__return_ptr))(**(void **)(a1 + 88) + 168))(&v47);
        if (v47)
        {
          uint64_t v15 = *(void *)(a1 + 88);
          uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 56))(v14);
          (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 88) + 168))(&v45);
          int v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t, const char *))(*(void *)v15 + 88))(v15, v16, &v45, 22, "CommCenter");
          if (v46) {
            sub_10004D2C8(v46);
          }
        }
        else
        {
          int v17 = 0;
        }
        if (v48) {
          sub_10004D2C8(v48);
        }
        uint64_t v12 = (v12 + v17);
      }
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
    v10 += 2;
  }
  while (v10 != v9);
  xpc_object_t v47 = buf;
  sub_10005CBF0((void ***)&v47);
  if (v11)
  {
    uint64_t v18 = *(void *)(a1 + 104);
    if (v12 == v11)
    {
      *(void *)(a1 + 104) = 0;
      if (v18) {
        (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
      }
      return v11;
    }
    else if (!v18)
    {
      LODWORD(v45) = 0;
      int v49 = 0;
      uint64_t v44 = 0;
      (*(void (**)(uint64_t, uint64_t *, int *, char *, uint64_t *))(*(void *)a1 + 248))(a1, &v45, &v49, (char *)&v44 + 4, &v44);
      uint64_t v20 = sub_1007CB550(a1, *(void *)(a1 + 120), 0);
      uint64_t v21 = sub_1007CB550(a1, *(void *)(a1 + 112), 1u);
      uint64_t v22 = v21;
      if (v21) {
        uint64_t v23 = v21;
      }
      else {
        uint64_t v23 = v20;
      }
      if (v23) {
        uint64_t v24 = v23;
      }
      else {
        uint64_t v24 = 30000;
      }
      uint64_t v25 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136316418;
        *(void *)&uint8_t buf[4] = "assertionUpdate";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v20;
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v51 = v22;
        __int16 v52 = 2048;
        uint64_t v53 = v24;
        __int16 v54 = 1024;
        int v55 = v45;
        __int16 v56 = 1024;
        int v57 = v49;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s: no assertions, scheduling inactivity timeout %llu msecs, checkpoint %llu, interval %llu. Packets: out=%u, in=%u", buf, 0x36u);
      }
      unsigned int v26 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v26 || (v27 = *(void *)(a1 + 8), (uint64_t v28 = std::__shared_weak_count::lock(v26)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v29 = v28;
      atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v28);
      Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 64));
      uint64_t v30 = *(void *)buf;
      sub_100058DB0(__p, "inactivity timeout");
      uint64_t v31 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v31;
      if (v31) {
        dispatch_retain(v31);
      }
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 1174405120;
      aBlock[2] = sub_1007C8710;
      aBlock[3] = &unk_101A09CB0;
      void aBlock[4] = a1;
      void aBlock[5] = v27;
      int v38 = v29;
      atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v39 = v24;
      int v40 = _Block_copy(aBlock);
      sub_10038ECF0(v30, (uint64_t)__p, 0, 1000 * v24, &object, &v40);
      xpc_object_t v32 = v47;
      xpc_object_t v47 = 0;
      uint64_t v33 = *(void *)(a1 + 104);
      *(void *)(a1 + 104) = v32;
      if (v33)
      {
        (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
        xpc_object_t v34 = v47;
        xpc_object_t v47 = 0;
        if (v34) {
          (*(void (**)(uint8_t *))(*(void *)v34 + 8))(v34);
        }
      }
      if (v40) {
        _Block_release(v40);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v43 < 0) {
        operator delete(__p[0]);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      int v35 = v45;
      *(_DWORD *)(a1 + 128) = v49;
      *(_DWORD *)(a1 + 132) = v35;
      if (v38) {
        std::__shared_weak_count::__release_weak(v38);
      }
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  return v12;
}

void sub_1007C696C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *aBlock, dispatch_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007C6A3C(uint64_t a1, char a2)
{
  BOOL v3 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2 & 1) == 0) {
      goto LABEL_3;
    }
LABEL_7:
    sub_1007C6B54();
  }
  int v4 = 136315394;
  uint64_t v5 = "handleDataContextIPOffline";
  __int16 v6 = 2080;
  uint64_t v7 = asString();
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: %s", (uint8_t *)&v4, 0x16u);
  if (a2) {
    goto LABEL_7;
  }
LABEL_3:
  if ((a2 & 2) != 0) {
    sub_1007C6B54();
  }
}

void sub_1007C6B54()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_1007C1FA8();
}

void sub_1007C7328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,char a47)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  *(void *)(v47 - 144) = &a47;
  sub_10005CBF0((void ***)(v47 - 144));
  int v49 = *(std::__shared_weak_count **)(v47 - 152);
  if (v49) {
    sub_10004D2C8(v49);
  }
  _Unwind_Resume(a1);
}

void sub_1007C7454(uint64_t a1, double a2, double a3)
{
  if (a2 == 1.79769313e308)
  {
    uint64_t v3 = 0;
    *(void *)(a1 + 120) = 86400000;
    unint64_t v4 = 86400000;
LABEL_17:
    *(void *)(a1 + 112) = v3;
    unint64_t v6 = v3;
    goto LABEL_18;
  }
  if (a2 <= 0.0)
  {
    if (*(_DWORD *)(a1 + 80)) {
      unint64_t v4 = 120000;
    }
    else {
      unint64_t v4 = 300000;
    }
  }
  else
  {
    unint64_t v4 = (unint64_t)a2;
  }
  if ((double)v4 <= a3 || a3 <= 0.0) {
    unint64_t v6 = 0;
  }
  else {
    unint64_t v6 = (unint64_t)a3;
  }
  *(void *)(a1 + 112) = v6;
  *(void *)(a1 + 120) = v4;
  if (v4 > 0x5265C00)
  {
    *(void *)(a1 + 120) = 86400000;
    unint64_t v4 = 86400000;
  }
  uint64_t v3 = 86400000;
  if (v6 > 0x5265C00) {
    goto LABEL_17;
  }
LABEL_18:
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315650;
    uint64_t v9 = "updateTimeoutMsec";
    __int16 v10 = 2048;
    unint64_t v11 = v4;
    __int16 v12 = 2048;
    unint64_t v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: Inactivity timeout is set to %llu msec with checkpoint %llu msec", (uint8_t *)&v8, 0x20u);
  }
}

uint64_t sub_1007C75AC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (!v1) {
    return 0;
  }
  uint64_t v9 = 0;
  __int16 v10 = 0;
  uint64_t v11 = 0;
  (*(void (**)(uint64_t **__return_ptr))(*(void *)v1 + 16))(&v9);
  int v2 = v9;
  uint64_t v3 = v10;
  if (v9 == v10)
  {
    uint64_t v4 = 0;
  }
  else
  {
    LODWORD(v4) = 0;
    do
    {
      uint64_t v5 = *v2;
      unint64_t v6 = (std::__shared_weak_count *)v2[1];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 72))(v5);
      if (v6) {
        sub_10004D2C8(v6);
      }
      uint64_t v4 = v7 | v4;
      v2 += 2;
    }
    while (v2 != v3);
  }
  __int16 v12 = (void **)&v9;
  sub_10005CBF0(&v12);
  return v4;
}

void sub_1007C76AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  a12 = (void **)&a9;
  sub_10005CBF0(&a12);
  _Unwind_Resume(a1);
}

BOOL sub_1007C76D4(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 3) == 6;
}

CFDictionaryRef sub_1007C7718(uint64_t a1)
{
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x4002000000;
  uint64_t v27 = sub_1007C7A3C;
  uint64_t v28 = sub_1007C7A58;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v16 = 0;
  int v17 = &v16;
  uint64_t v18 = 0x4002000000;
  timeval v19 = sub_1007C7A3C;
  uint64_t v20 = sub_1007C7A58;
  std::string __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_1007C7A6C;
  void v15[3] = &unk_101A09C50;
  v15[5] = &v16;
  v15[6] = a1;
  void v15[4] = &v24;
  values[0] = v15;
  *(void *)&long long block = _NSConcreteStackBlock;
  *((void *)&block + 1) = 0x40000000;
  xpc_object_t v34 = sub_1007CC16C;
  int v35 = &unk_101A09DF0;
  uint64_t v36 = a1 + 8;
  xpc_object_t v37 = values;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8)) {
    dispatch_async_and_wait(v1, &block);
  }
  else {
    dispatch_sync(v1, &block);
  }
  CFStringRef v13 = 0;
  CFStringRef v14 = 0;
  uint64_t v3 = (const char *)(v25 + 5);
  if (*((char *)v25 + 63) < 0) {
    uint64_t v3 = *(const char **)v3;
  }
  CFStringRef v4 = CFStringCreateWithCString(kCFAllocatorDefault, v3, 0x8000100u);
  CFStringRef v5 = v14;
  CFStringRef v14 = v4;
  *(void *)&long long block = v5;
  sub_1000558F4((const void **)&block);
  unint64_t v6 = (const char *)(v17 + 5);
  if (*((char *)v17 + 63) < 0) {
    unint64_t v6 = *(const char **)v6;
  }
  CFStringRef v7 = CFStringCreateWithCString(kCFAllocatorDefault, v6, 0x8000100u);
  CFStringRef v8 = v13;
  CFStringRef v13 = v7;
  *(void *)&long long block = v8;
  sub_1000558F4((const void **)&block);
  if (v14) {
    uint64_t v9 = sub_1000810B8;
  }
  else {
    uint64_t v9 = 0;
  }
  if (v9 && (v13 ? (__int16 v10 = sub_1000810B8) : (__int16 v10 = 0), v10))
  {
    long long block = *(_OWORD *)off_101A09C70;
    values[0] = (void *)v14;
    values[1] = (void *)v13;
    CFDictionaryRef v11 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&block, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  else
  {
    CFDictionaryRef v11 = 0;
  }
  sub_1000558F4((const void **)&v13);
  sub_1000558F4((const void **)&v14);
  _Block_object_dispose(&v16, 8);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&v24, 8);
  if (SHIBYTE(v31) < 0) {
    operator delete(v29);
  }
  return v11;
}

void sub_1007C79E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a30, 8);
  if (a40 < 0) {
    operator delete(a35);
  }
  _Unwind_Resume(a1);
}

__n128 sub_1007C7A3C(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1007C7A58(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void sub_1007C7A6C(void *a1)
{
  uint64_t v1 = a1[6];
  uint64_t v2 = *(void *)(a1[4] + 8);
  uint64_t v3 = *(void *)(a1[5] + 8);
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 0;
  (*(void (**)(uint64_t **__return_ptr))(**(void **)(v1 + 88) + 16))(&v16);
  CFStringRef v4 = v16;
  CFStringRef v5 = v17;
  if (v17 == v16) {
    goto LABEL_27;
  }
  uint64_t v7 = *v16;
  unint64_t v6 = (std::__shared_weak_count *)v16[1];
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    CFStringRef v5 = v17;
  }
  if (v4 != v5)
  {
    while (1)
    {
      uint64_t v9 = *v4;
      CFStringRef v8 = (std::__shared_weak_count *)v4[1];
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v9 + 136))(v9, 1)) {
        break;
      }
      if (v8) {
        sub_10004D2C8(v8);
      }
      v4 += 2;
      if (v4 == v5) {
        goto LABEL_11;
      }
    }
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    if (v8) {
      sub_10004D2C8(v8);
    }
    goto LABEL_19;
  }
LABEL_11:
  if (v7)
  {
    uint64_t v9 = v7;
    CFStringRef v8 = v6;
LABEL_19:
    uint64_t v10 = *(void *)(v1 + 88);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 56))(v9);
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v10 + 40))(&v14, v10, v11);
    __int16 v12 = (void **)(v2 + 40);
    if (*(char *)(v2 + 63) < 0) {
      operator delete(*v12);
    }
    *(_OWORD *)__int16 v12 = v14;
    *(void *)(v2 + 56) = v15;
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 96))(v9, 1);
    CSIPacketAddress::operator std::string();
    CFStringRef v13 = (void **)(v3 + 40);
    if (*(char *)(v3 + 63) < 0) {
      operator delete(*v13);
    }
    *(_OWORD *)CFStringRef v13 = v14;
    *(void *)(v3 + 56) = v15;
    goto LABEL_25;
  }
  CFStringRef v8 = v6;
LABEL_25:
  if (v8) {
    sub_10004D2C8(v8);
  }
LABEL_27:
  *(void *)&long long v14 = &v16;
  sub_10005CBF0((void ***)&v14);
}

void sub_1007C7CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  a9 = (void **)&a12;
  sub_10005CBF0(&a9);
  _Unwind_Resume(a1);
}

void sub_1007C7CF8(uint64_t a1, unint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  CFStringRef v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  if (!v12)
  {
    xpc_object_t v37 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "inactivityCallBack";
    int v38 = "#I %s: no data service, skip InactivityTimer";
    goto LABEL_43;
  }
  LODWORD(v55) = 0;
  uint64_t v57 = 0;
  unsigned int v56 = 0;
  (*(void (**)(uint64_t, uint64_t *, char *, uint64_t *, unsigned int *))(*(void *)a1 + 248))(a1, &v55, (char *)&v57 + 4, &v57, &v56);
  int v14 = v55;
  if (__PAIR64__(v55, HIDWORD(v57)) == *(void *)(a1 + 128))
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    BOOL v17 = 0;
  }
  else
  {
    char v18 = v13;
    timeval v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = "inactivityCallBack";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = a2 / 0x3E8;
      *(_WORD *)&unsigned char buf[22] = 1024;
      int v59 = v14;
      __int16 v60 = 1024;
      int v61 = HIDWORD(v57);
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: Checkpoint: %llu sec, Packets: out=%d, in=%d (still active)", buf, 0x22u);
    }
    unsigned int v20 = v56;
    int v21 = v57;
    unsigned int v22 = *(_DWORD *)(a1 + 140);
    uint64_t v16 = v57 - v22;
    if (v57 >= v22 && (v23 = *(_DWORD *)(a1 + 136), uint64_t v15 = v56 - v23, v56 >= v23))
    {
      uint64_t v47 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "inactivityCallBack";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v15;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s: uplink bytes: %u, downlink bytes %u", buf, 0x18u);
        unsigned int v20 = v56;
        int v21 = v57;
      }
    }
    else
    {
      uint64_t v15 = 0;
      uint64_t v16 = 0;
    }
    int v24 = v55;
    *(_DWORD *)(a1 + 128) = HIDWORD(v57);
    *(_DWORD *)(a1 + 132) = v24;
    *(_DWORD *)(a1 + 136) = v20;
    *(_DWORD *)(a1 + 140) = v21;
    BOOL v17 = 1;
    char v13 = v18;
  }
  unint64_t v25 = sub_1007CB550(a1, *(void *)(a1 + 120), 0);
  if (v25 <= a2)
  {
    uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 872))(v12);
    uint64_t v40 = v39;
    if (v39
      && (*(unsigned int (**)(uint64_t))(*(void *)v39 + 40))(v39)
      && (v41 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v40 + 56))(v40, *(unsigned int *)(a1 + 80), v16, v15), v42 = v41, v41 >= 0x100u)&& (BOOL v17 = v41 != 0, v43 = *(NSObject **)(a1 + 40), os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "inactivityCallBack";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v42;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I %s: slice connection retention: %{BOOL}d", buf, 0x12u);
      if (v42) {
        goto LABEL_61;
      }
    }
    else if (v17)
    {
      goto LABEL_61;
    }
    uint64_t v44 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      int v45 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "inactivityCallBack";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v45;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I %s: Deactivating context %d, because it has gone idle", buf, 0x12u);
    }
    uint64_t v46 = *(void *)(a1 + 104);
    *(void *)(a1 + 104) = 0;
    if (v46) {
      (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
    }
    if (((*(uint64_t (**)(uint64_t))(*(void *)v12 + 856))(v12) & 1) == 0)
    {
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 80))(*(void *)(a1 + 88), 20);
      goto LABEL_61;
    }
    xpc_object_t v37 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "inactivityCallBack";
    int v38 = "#I %s: In LoopBack Mode, skip InactivityTimer";
LABEL_43:
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v38, buf, 0xCu);
    goto LABEL_61;
  }
  uint64_t v26 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "inactivityCallBack";
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v25;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s: skip the first (\"dirty\") interval and set the next at %lu msec ahead", buf, 0x16u);
  }
  uint64_t v27 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v28 || (v29 = *(void *)(a1 + 8), (uint64_t v30 = std::__shared_weak_count::lock(v28)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v31 = v30;
  atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v30);
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 64));
  uint64_t v32 = *(void *)buf;
  sub_100058DB0(__p, "inactivity timeout");
  uint64_t v33 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v33;
  if (v33) {
    dispatch_retain(v33);
  }
  v48[0] = _NSConcreteStackBlock;
  v48[1] = 1174405120;
  v48[2] = sub_1007C856C;
  v48[3] = &unk_101A09C80;
  v48[4] = a1;
  v48[5] = v29;
  int v49 = v31;
  atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  unint64_t v50 = v25;
  long long aBlock = _Block_copy(v48);
  sub_10038ECF0(v32, (uint64_t)__p, 0, 1000 * v25, &object, &aBlock);
  uint64_t v34 = v55;
  uint64_t v55 = 0;
  uint64_t v35 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = v34;
  if (v35)
  {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
    uint64_t v36 = v55;
    uint64_t v55 = 0;
    if (v36) {
      (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
    }
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v54 < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v49) {
    std::__shared_weak_count::__release_weak(v49);
  }
  std::__shared_weak_count::__release_weak(v31);
LABEL_61:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1007C84C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007C856C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    CFStringRef v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFStringRef v5 = v4;
      if (a1[5]) {
        sub_1007C7CF8(v3, a1[7]);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1007C85E4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007C85F8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007C8614(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1007C8624(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 144);
  if (v2 != a2)
  {
    BOOL v3 = a2;
    CFStringRef v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315650;
      uint64_t v7 = "setAsserted";
      __int16 v8 = 2080;
      uint64_t v9 = asStringBool(v2 != 0);
      __int16 v10 = 2080;
      uint64_t v11 = asStringBool(v3);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: from %s to %s", (uint8_t *)&v6, 0x20u);
    }
    *(unsigned char *)(a1 + 144) = v3;
  }
}

void sub_1007C8710(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    CFStringRef v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFStringRef v5 = v4;
      if (a1[5]) {
        sub_1007C7CF8(v3, a1[7]);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1007C8788(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1007C879C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    CFStringRef v5 = "handleDataContextIPRetry";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: handleDataContextIPRetry", buf, 0xCu);
  }
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_1007C2044();
}

void sub_1007C8A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007C8AD8(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315138;
    uint64_t v3 = "handleDataContextIPResume";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: handleDataContextIPResume", (uint8_t *)&v2, 0xCu);
  }
  sub_1007C3698();
}

void sub_1007C8BC8(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315138;
    uint64_t v3 = "handleDataContextIPOnline";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: handleDataContextIPOnline", (uint8_t *)&v2, 0xCu);
  }
  sub_1007C3698();
}

uint64_t sub_1007C8CB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = 136315394;
    uint64_t v19 = asString();
    __int16 v20 = 1024;
    int v21 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I handleDataContextDidGetMTU[%s]: mtu=%u", (uint8_t *)&v18, 0x12u);
  }
  if (a2)
  {
    *(_DWORD *)(a1 + 56) = a3;
    uint64_t v7 = *(unsigned int *)(a1 + 60);
    if (v7)
    {
      if (v7 >= a3)
      {
        if (v7 > a3)
        {
          __int16 v10 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v11 = asString();
            int v18 = 136315394;
            uint64_t v19 = v11;
            __int16 v20 = 1024;
            int v21 = a3;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I handleDataContextDidGetMTU[%s]: retro-adjusted mtu=%u", (uint8_t *)&v18, 0x12u);
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 296))(a1, 2, a3);
        }
      }
      else
      {
        __int16 v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = asString();
          int v18 = 136315394;
          uint64_t v19 = v9;
          __int16 v20 = 1024;
          int v21 = v7;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I handleDataContextDidGetMTU[%s]: adjusted mtu=%u", (uint8_t *)&v18, 0x12u);
        }
        a3 = v7;
      }
    }
  }
  if ((a2 & 2) != 0)
  {
    *(_DWORD *)(a1 + 60) = a3;
    uint64_t v12 = *(unsigned int *)(a1 + 56);
    if (v12)
    {
      if (v12 >= a3)
      {
        if (v12 > a3)
        {
          uint64_t v15 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v16 = asString();
            int v18 = 136315394;
            uint64_t v19 = v16;
            __int16 v20 = 1024;
            int v21 = a3;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I handleDataContextDidGetMTU[%s]: retro-adjusted mtu=%u", (uint8_t *)&v18, 0x12u);
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 296))(a1, 1, a3);
        }
      }
      else
      {
        char v13 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = asString();
          int v18 = 136315394;
          uint64_t v19 = v14;
          __int16 v20 = 1024;
          int v21 = v12;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I handleDataContextDidGetMTU[%s]: adjusted mtu=%u", (uint8_t *)&v18, 0x12u);
        }
        a3 = v12;
      }
    }
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 296))(a1, a2, a3);
}